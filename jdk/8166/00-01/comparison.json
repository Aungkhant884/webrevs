{"files":[{"patch":"@@ -37,1 +37,1 @@\n-inline void FreezeBase::patch_chunk_pd(intptr_t* frame_sp, intptr_t* heap_sp) {\n+inline void FreezeBase::patch_stack_pd(intptr_t* frame_sp, intptr_t* heap_sp) {\n@@ -193,0 +193,1 @@\n+  \/\/ The values in the returned frame object will be written into the callee's stack in patch.\n@@ -203,0 +204,1 @@\n+      log_develop_trace(continuations)(\"Adding internal interpreted frame alignment\");\n","filename":"src\/hotspot\/cpu\/aarch64\/continuation_aarch64.inline.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-inline void FreezeBase::patch_chunk_pd(intptr_t* frame_sp, intptr_t* heap_sp) {\n+inline void FreezeBase::patch_stack_pd(intptr_t* frame_sp, intptr_t* heap_sp) {\n","filename":"src\/hotspot\/cpu\/arm\/continuation_arm.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-inline void FreezeBase::patch_chunk_pd(intptr_t* frame_sp, intptr_t* heap_sp) {\n+inline void FreezeBase::patch_stack_pd(intptr_t* frame_sp, intptr_t* heap_sp) {\n","filename":"src\/hotspot\/cpu\/ppc\/continuation_ppc.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-inline void FreezeBase::patch_chunk_pd(intptr_t* frame_sp, intptr_t* heap_sp) {\n+inline void FreezeBase::patch_stack_pd(intptr_t* frame_sp, intptr_t* heap_sp) {\n","filename":"src\/hotspot\/cpu\/s390\/continuation_s390.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -342,1 +342,0 @@\n-  \/\/ signature.append(T_INT);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-inline void FreezeBase::patch_chunk_pd(intptr_t* frame_sp, intptr_t* heap_sp) {\n+inline void FreezeBase::patch_stack_pd(intptr_t* frame_sp, intptr_t* heap_sp) {\n@@ -208,0 +208,1 @@\n+  \/\/ The values in the returned frame object will be written into the callee's stack in patch.\n","filename":"src\/hotspot\/cpu\/x86\/continuation_x86.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-inline void FreezeBase::patch_chunk_pd(intptr_t* frame_sp, intptr_t* heap_sp) {\n+inline void FreezeBase::patch_stack_pd(intptr_t* frame_sp, intptr_t* heap_sp) {\n","filename":"src\/hotspot\/cpu\/zero\/continuation_zero.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1317,11 +1317,0 @@\n-\/\/ Example: Thread.currentCarrierThread()\n-void LIRGenerator::do_currentCarrierThread(Intrinsic* x) {\n-  assert(x->number_of_arguments() == 0, \"wrong type\");\n-  LIR_Opr temp = new_register(T_ADDRESS);\n-  LIR_Opr reg = rlock_result(x);\n-  __ move(new LIR_Address(getThreadPointer(), in_bytes(JavaThread::threadObj_offset()), T_ADDRESS), temp);\n-  \/\/ threadObj = ((OopHandle)_threadObj)->resolve();\n-  access_load(IN_NATIVE, T_OBJECT,\n-              LIR_OprFact::address(new LIR_Address(temp, T_OBJECT)), reg);\n-}\n-\n@@ -1432,6 +1421,6 @@\n-  assert(x->number_of_arguments() == 0, \"wrong type\");\n-  LIR_Opr temp = new_register(T_ADDRESS);\n-  LIR_Opr reg = rlock_result(x);\n-  __ move(new LIR_Address(getThreadPointer(), in_bytes(JavaThread::scopeLocalCache_offset()), T_ADDRESS), temp);\n-  access_load(IN_NATIVE, T_OBJECT,\n-              LIR_OprFact::address(new LIR_Address(temp, T_OBJECT)), reg);\n+  do_JavaThreadField(x, JavaThread::scopeLocalCache_offset());\n+}\n+\n+\/\/ Example: Thread.currentCarrierThread()\n+void LIRGenerator::do_currentCarrierThread(Intrinsic* x) {\n+  do_JavaThreadField(x, JavaThread::threadObj_offset());\n@@ -1441,0 +1430,4 @@\n+  do_JavaThreadField(x, JavaThread::vthread_offset());\n+}\n+\n+void LIRGenerator::do_JavaThreadField(Intrinsic* x, ByteSize offset) {\n@@ -1444,1 +1437,1 @@\n-  __ move(new LIR_Address(getThreadPointer(), in_bytes(JavaThread::vthread_offset()), T_ADDRESS), temp);\n+  __ move(new LIR_Address(getThreadPointer(), in_bytes(offset), T_ADDRESS), temp);\n@@ -2908,1 +2901,0 @@\n-  LabelObj* L_NULL = new LabelObj();\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":11,"deletions":19,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -262,0 +262,1 @@\n+  void do_JavaThreadField(Intrinsic* x, ByteSize offset);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1114,11 +1114,11 @@\n-  static inline oop scope(oop ref);\n-  static inline oop target(oop ref);\n-  static inline oop parent(oop ref);\n-  static inline oop yieldInfo(oop ref);\n-  static inline void set_yieldInfo(oop ref, oop value);\n-  static inline stackChunkOop tail(oop ref);\n-  static inline void set_tail(oop ref, stackChunkOop value);\n-  static inline bool on_local_stack(oop ref, address adr);\n-  static inline bool done(oop ref);\n-  static inline bool is_preempted(oop ref);\n-  static inline void set_preempted(oop ref, bool value);\n+  static inline oop scope(oop continuation);\n+  static inline oop target(oop continuation);\n+  static inline oop parent(oop continuation);\n+  static inline oop yieldInfo(oop continuation);\n+  static inline void set_yieldInfo(oop continuation, oop value);\n+  static inline stackChunkOop tail(oop continuation);\n+  static inline void set_tail(oop continuation, stackChunkOop value);\n+  static inline bool on_local_stack(oop continuation, address adr);\n+  static inline bool done(oop continuation);\n+  static inline bool is_preempted(oop continuation);\n+  static inline void set_preempted(oop continuation, bool value);\n@@ -1155,2 +1155,2 @@\n-  static inline oop parent(oop ref);\n-  static inline void set_parent(oop ref, oop value);\n+  static inline oop parent(oop chunk);\n+  static inline void set_parent(oop chunk, oop value);\n@@ -1158,1 +1158,1 @@\n-  static inline bool is_parent_null(oop ref); \/\/ bypasses barriers for a faster test\n+  static inline bool is_parent_null(oop chunk); \/\/ bypasses barriers for a faster test\n@@ -1160,1 +1160,1 @@\n-  static inline void set_parent_raw(oop ref, oop value);\n+  static inline void set_parent_raw(oop chunk, oop value);\n@@ -1162,2 +1162,2 @@\n-  static inline int size(oop ref);\n-  static inline void set_size(HeapWord* ref, int value);\n+  static inline int size(oop chunk);\n+  static inline void set_size(HeapWord* chunk, int value);\n@@ -1165,9 +1165,9 @@\n-  static inline int sp(oop ref);\n-  static inline void set_sp(oop ref, int value);\n-  static inline void set_sp(HeapWord* ref, int value); \/\/ used while allocating\n-  static inline intptr_t pc(oop ref);\n-  static inline void set_pc(oop ref, intptr_t value);\n-  static inline int argsize(oop ref);\n-  static inline void set_argsize(oop ref, int value);\n-  static inline uint8_t flags(oop ref);\n-  static inline void set_flags(oop ref, uint8_t value);\n+  static inline int sp(oop chunk);\n+  static inline void set_sp(oop chunk, int value);\n+  static inline void set_sp(HeapWord* chunk, int value); \/\/ used while allocating\n+  static inline intptr_t pc(oop chunk);\n+  static inline void set_pc(oop chunk, intptr_t value);\n+  static inline int argsize(oop chunk);\n+  static inline void set_argsize(oop chunk, int value);\n+  static inline uint8_t flags(oop chunk);\n+  static inline void set_flags(oop chunk, uint8_t value);\n@@ -1175,2 +1175,2 @@\n-  static inline int maxSize(oop ref);\n-  static inline void set_maxSize(oop ref, int value);\n+  static inline int maxSize(oop chunk);\n+  static inline void set_maxSize(oop chunk, int value);\n@@ -1179,2 +1179,2 @@\n-  static inline oop cont(oop ref);\n-  static inline void set_cont(oop ref, oop value);\n+  static inline oop cont(oop chunk);\n+  static inline void set_cont(oop chunk, oop value);\n@@ -1182,1 +1182,1 @@\n-  static inline oop cont_raw(oop ref);\n+  static inline oop cont_raw(oop chunk);\n@@ -1184,1 +1184,1 @@\n-  static inline void set_cont_raw(oop ref, oop value);\n+  static inline void set_cont_raw(oop chunk, oop value);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -227,2 +227,2 @@\n-inline oop jdk_internal_vm_Continuation::scope(oop ref) {\n-  return ref->obj_field(_scope_offset);\n+inline oop jdk_internal_vm_Continuation::scope(oop continuation) {\n+  return continuation->obj_field(_scope_offset);\n@@ -231,2 +231,2 @@\n-inline oop jdk_internal_vm_Continuation::target(oop ref) {\n-  return ref->obj_field(_target_offset);\n+inline oop jdk_internal_vm_Continuation::target(oop continuation) {\n+  return continuation->obj_field(_target_offset);\n@@ -235,2 +235,2 @@\n-inline oop jdk_internal_vm_Continuation::parent(oop ref) {\n-  return ref->obj_field(_parent_offset);\n+inline oop jdk_internal_vm_Continuation::parent(oop continuation) {\n+  return continuation->obj_field(_parent_offset);\n@@ -239,2 +239,2 @@\n-inline oop jdk_internal_vm_Continuation::yieldInfo(oop ref) {\n-  return ref->obj_field(_yieldInfo_offset);\n+inline oop jdk_internal_vm_Continuation::yieldInfo(oop continuation) {\n+  return continuation->obj_field(_yieldInfo_offset);\n@@ -243,2 +243,2 @@\n-inline void jdk_internal_vm_Continuation::set_yieldInfo(oop ref, oop value) {\n-  ref->obj_field_put(_yieldInfo_offset, value);\n+inline void jdk_internal_vm_Continuation::set_yieldInfo(oop continuation, oop value) {\n+  continuation->obj_field_put(_yieldInfo_offset, value);\n@@ -247,2 +247,2 @@\n-inline stackChunkOop jdk_internal_vm_Continuation::tail(oop ref) {\n-  return stackChunkOopDesc::cast(ref->obj_field(_tail_offset));\n+inline stackChunkOop jdk_internal_vm_Continuation::tail(oop continuation) {\n+  return stackChunkOopDesc::cast(continuation->obj_field(_tail_offset));\n@@ -251,2 +251,2 @@\n-inline void jdk_internal_vm_Continuation::set_tail(oop ref, stackChunkOop value) {\n-  ref->obj_field_put(_tail_offset, value);\n+inline void jdk_internal_vm_Continuation::set_tail(oop continuation, stackChunkOop value) {\n+  continuation->obj_field_put(_tail_offset, value);\n@@ -255,2 +255,2 @@\n-inline bool jdk_internal_vm_Continuation::done(oop ref) {\n-  return ref->bool_field(_done_offset);\n+inline bool jdk_internal_vm_Continuation::done(oop continuation) {\n+  return continuation->bool_field(_done_offset);\n@@ -259,2 +259,2 @@\n-inline bool jdk_internal_vm_Continuation::is_preempted(oop ref) {\n-  return ref->bool_field(_preempted_offset);\n+inline bool jdk_internal_vm_Continuation::is_preempted(oop continuation) {\n+  return continuation->bool_field(_preempted_offset);\n@@ -263,2 +263,2 @@\n-inline void jdk_internal_vm_Continuation::set_preempted(oop ref, bool value) {\n-  ref->bool_field_put(_preempted_offset, (jboolean)value);\n+inline void jdk_internal_vm_Continuation::set_preempted(oop continuation, bool value) {\n+  continuation->bool_field_put(_preempted_offset, (jboolean)value);\n@@ -267,2 +267,2 @@\n-inline oop jdk_internal_vm_StackChunk::parent(oop ref) {\n-  return ref->obj_field(_parent_offset);\n+inline oop jdk_internal_vm_StackChunk::parent(oop chunk) {\n+  return chunk->obj_field(_parent_offset);\n@@ -271,2 +271,2 @@\n-inline void jdk_internal_vm_StackChunk::set_parent(oop ref, oop value) {\n-  ref->obj_field_put(_parent_offset, value);\n+inline void jdk_internal_vm_StackChunk::set_parent(oop chunk, oop value) {\n+  chunk->obj_field_put(_parent_offset, value);\n@@ -276,2 +276,2 @@\n-inline bool jdk_internal_vm_StackChunk::is_parent_null(oop ref) {\n-  return (oop)RawAccess<>::oop_load(ref->field_addr<P>(_parent_offset)) == NULL;\n+inline bool jdk_internal_vm_StackChunk::is_parent_null(oop chunk) {\n+  return (oop)RawAccess<>::oop_load(chunk->field_addr<P>(_parent_offset)) == NULL;\n@@ -281,2 +281,2 @@\n-inline void jdk_internal_vm_StackChunk::set_parent_raw(oop ref, oop value) {\n-  RawAccess<>::oop_store(ref->field_addr<P>(_parent_offset), value);\n+inline void jdk_internal_vm_StackChunk::set_parent_raw(oop chunk, oop value) {\n+  RawAccess<>::oop_store(chunk->field_addr<P>(_parent_offset), value);\n@@ -285,2 +285,2 @@\n-inline oop jdk_internal_vm_StackChunk::cont(oop ref) {\n-  return ref->obj_field(_cont_offset);\n+inline oop jdk_internal_vm_StackChunk::cont(oop chunk) {\n+  return chunk->obj_field(_cont_offset);\n@@ -289,2 +289,2 @@\n-inline void jdk_internal_vm_StackChunk::set_cont(oop ref, oop value) {\n-  ref->obj_field_put(_cont_offset, value);\n+inline void jdk_internal_vm_StackChunk::set_cont(oop chunk, oop value) {\n+  chunk->obj_field_put(_cont_offset, value);\n@@ -294,2 +294,2 @@\n-inline oop jdk_internal_vm_StackChunk::cont_raw(oop ref) {\n-  return (oop)RawAccess<>::oop_load(ref->field_addr<P>(_cont_offset));\n+inline oop jdk_internal_vm_StackChunk::cont_raw(oop chunk) {\n+  return (oop)RawAccess<>::oop_load(chunk->field_addr<P>(_cont_offset));\n@@ -299,2 +299,2 @@\n-inline void jdk_internal_vm_StackChunk::set_cont_raw(oop ref, oop value) {\n-  RawAccess<>::oop_store(ref->field_addr<P>(_cont_offset), value);\n+inline void jdk_internal_vm_StackChunk::set_cont_raw(oop chunk, oop value) {\n+  RawAccess<>::oop_store(chunk->field_addr<P>(_cont_offset), value);\n@@ -303,2 +303,2 @@\n-inline int jdk_internal_vm_StackChunk::size(oop ref) {\n-  return ref->int_field(_size_offset);\n+inline int jdk_internal_vm_StackChunk::size(oop chunk) {\n+  return chunk->int_field(_size_offset);\n@@ -307,2 +307,5 @@\n-inline void jdk_internal_vm_StackChunk::set_size(HeapWord* ref, int value) {\n-  *(cast_to_oop(ref))->field_addr<jint>(_size_offset) = value;\n+inline void jdk_internal_vm_StackChunk::set_size(HeapWord* chunk, int value) {\n+  \/\/ Used by StackChunkAllocator before the Object has been finished,\n+  \/\/ so don't cast too oop and use int_field_put in this function.\n+  assert(_size_offset != 0, \"must be set\");\n+  *(int*)(((char*)chunk) + _size_offset) = (int)value;\n@@ -311,2 +314,2 @@\n-inline int jdk_internal_vm_StackChunk::sp(oop ref) {\n-  return ref->int_field(_sp_offset);\n+inline int jdk_internal_vm_StackChunk::sp(oop chunk) {\n+  return chunk->int_field(_sp_offset);\n@@ -315,2 +318,2 @@\n-inline void jdk_internal_vm_StackChunk::set_sp(oop ref, int value) {\n-  ref->int_field_put(_sp_offset, value);\n+inline void jdk_internal_vm_StackChunk::set_sp(oop chunk, int value) {\n+  chunk->int_field_put(_sp_offset, value);\n@@ -319,2 +322,5 @@\n-inline void jdk_internal_vm_StackChunk::set_sp(HeapWord* ref, int value) {\n-  *(cast_to_oop(ref))->field_addr<jint>(_sp_offset) = value;\n+inline void jdk_internal_vm_StackChunk::set_sp(HeapWord* chunk, int value) {\n+  \/\/ Used by StackChunkAllocator before the Object has been finished,\n+  \/\/ so don't cast too oop and use int_field_put in this function.\n+  assert(_sp_offset != 0, \"must be set\");\n+  *(int*)(((char*)chunk) + _sp_offset) = (int)value;\n@@ -323,2 +329,2 @@\n-inline intptr_t jdk_internal_vm_StackChunk::pc(oop ref) {\n-  return ref->long_field(_pc_offset);\n+inline intptr_t jdk_internal_vm_StackChunk::pc(oop chunk) {\n+  return chunk->long_field(_pc_offset);\n@@ -327,2 +333,2 @@\n-inline void jdk_internal_vm_StackChunk::set_pc(oop ref, intptr_t value) {\n-  ref->long_field_put(_pc_offset, value);\n+inline void jdk_internal_vm_StackChunk::set_pc(oop chunk, intptr_t value) {\n+  chunk->long_field_put(_pc_offset, value);\n@@ -331,2 +337,2 @@\n-inline int jdk_internal_vm_StackChunk::argsize(oop ref) {\n-  return ref->int_field(_argsize_offset);\n+inline int jdk_internal_vm_StackChunk::argsize(oop chunk) {\n+  return chunk->int_field(_argsize_offset);\n@@ -335,2 +341,2 @@\n-inline void jdk_internal_vm_StackChunk::set_argsize(oop ref, int value) {\n-  ref->int_field_put(_argsize_offset, value);\n+inline void jdk_internal_vm_StackChunk::set_argsize(oop chunk, int value) {\n+  chunk->int_field_put(_argsize_offset, value);\n@@ -339,2 +345,2 @@\n-inline uint8_t jdk_internal_vm_StackChunk::flags(oop ref) {\n-  return Atomic::load(ref->field_addr<uint8_t>(_flags_offset));\n+inline uint8_t jdk_internal_vm_StackChunk::flags(oop chunk) {\n+  return Atomic::load(chunk->field_addr<uint8_t>(_flags_offset));\n@@ -343,2 +349,2 @@\n-inline void jdk_internal_vm_StackChunk::set_flags(oop ref, uint8_t value) {\n-  Atomic::store(ref->field_addr<uint8_t>(_flags_offset), value);\n+inline void jdk_internal_vm_StackChunk::set_flags(oop chunk, uint8_t value) {\n+  Atomic::store(chunk->field_addr<uint8_t>(_flags_offset), value);\n@@ -347,2 +353,2 @@\n-inline int jdk_internal_vm_StackChunk::maxSize(oop ref) {\n-  return ref->int_field(_maxSize_offset);\n+inline int jdk_internal_vm_StackChunk::maxSize(oop chunk) {\n+  return chunk->int_field(_maxSize_offset);\n@@ -351,1 +357,1 @@\n-inline void jdk_internal_vm_StackChunk::set_maxSize(oop ref, int value) {\n+inline void jdk_internal_vm_StackChunk::set_maxSize(oop chunk, int value) {\n@@ -353,1 +359,1 @@\n-  jint old = maxSize(ref);\n+  jint old = maxSize(chunk);\n@@ -356,1 +362,1 @@\n-  ref->int_field_put(_maxSize_offset, value);\n+  chunk->int_field_put(_maxSize_offset, value);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":69,"deletions":63,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -1998,0 +1998,1 @@\n+  \/\/ Process oops in the nmethod\n@@ -1999,0 +2000,2 @@\n+\n+  \/\/ CodeCache sweeper support\n@@ -2000,0 +2003,1 @@\n+\n@@ -2002,0 +2006,3 @@\n+\n+  \/\/ There's an assumption made that this function is not used by GCs that\n+  \/\/ relocate objects, and therefore we don't call fix_oop_relocations.\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -79,0 +79,4 @@\n+\n+  \/\/ Evacuate objects pointed to by the nmethod\n+  nm->oops_do(&_oc);\n+\n@@ -80,0 +84,1 @@\n+    \/\/ CodeCache sweeper support\n@@ -81,0 +86,1 @@\n+\n@@ -86,1 +92,1 @@\n-  nm->oops_do(&_oc);\n+\n@@ -91,0 +97,1 @@\n+  \/\/ Mark through oops in the nmethod\n@@ -92,0 +99,2 @@\n+\n+  \/\/ CodeCache sweeper support\n@@ -93,0 +102,1 @@\n+\n@@ -97,0 +107,2 @@\n+\n+  \/\/ The oops were only marked, no need to update oop relocations.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeBlobClosure.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -69,1 +69,3 @@\n-  nm->mark_as_maybe_on_continuation();\n+  \/\/ If the nmethod is the only thing pointing to the oops, and we are using a\n+  \/\/ SATB GC, then it is important that this code marks them live. This is done\n+  \/\/ by the phantom load.\n@@ -72,0 +74,4 @@\n+\n+  \/\/ CodeCache sweeper support\n+  nm->mark_as_maybe_on_continuation();\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  \/\/ Class redefinition support\n+  \/\/ CodeCache sweeper support\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetNMethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -703,0 +703,2 @@\n+\n+      \/\/ CodeCache sweeper support\n@@ -704,0 +706,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+    \/\/ Process the oops in the nmethod\n@@ -62,3 +63,1 @@\n-    if (_fix_relocations) {\n-      nm->fix_oop_relocations();\n-    }\n+\n@@ -66,0 +65,1 @@\n+      \/\/ CodeCache sweeper support\n@@ -67,0 +67,1 @@\n+\n@@ -72,0 +73,4 @@\n+\n+    if (_fix_relocations) {\n+      nm->fix_oop_relocations();\n+    }\n","filename":"src\/hotspot\/share\/memory\/iterator.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -102,0 +102,2 @@\n+  \/\/\n+  \/\/ Used to determine metadata liveness for class unloading GCs.\n@@ -106,0 +108,2 @@\n+\n+  \/\/ Class redefinition needs to get notified about methods from stackChunkOops\n@@ -107,0 +111,1 @@\n+  \/\/ The code cache sweeper needs to get notified about methods from stackChunkOops\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  \/\/ Mark interpreted frames for marking_cycle\n+  \/\/ Mark interpreted frames for class redefinition\n","filename":"src\/hotspot\/share\/memory\/iterator.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -209,0 +209,3 @@\n+  #ifdef ASSERT\n+    f.print_value_on(_st, nullptr);\n+  #else\n@@ -210,0 +213,1 @@\n+  #endif\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -113,0 +113,5 @@\n+\/\/ The high-order bit tagging has only been verified to work on these platforms.\n+#if (defined(X86) && defined(_LP64)) || defined(AARCH64)\n+#define HIGH_ORDER_BIT_TAGGING_SUPPORTED\n+#endif\n+\n@@ -120,1 +125,1 @@\n-#if defined(X86) || defined(AARCH64)\n+#ifdef HIGH_ORDER_BIT_TAGGING_SUPPORTED\n@@ -126,1 +131,1 @@\n-#if defined(X86) || defined(AARCH64)\n+#ifdef HIGH_ORDER_BIT_TAGGING_SUPPORTED\n@@ -138,1 +143,1 @@\n-#if defined(X86) || defined(AARCH64)\n+#ifdef HIGH_ORDER_BIT_TAGGING_SUPPORTED\n@@ -266,0 +271,18 @@\n+#ifdef ASSERT\n+template <ChunkFrames frame_kind, typename RegisterMapT>\n+static void assert_relativized_derived_oops_in_frame(const StackChunkFrameStream<frame_kind>& f,\n+                                                     const RegisterMapT* map) {\n+  class AssertRelativeDerivedOopClosure : public DerivedOopClosure {\n+  public:\n+    virtual void do_derived_oop(oop* base_loc, derived_pointer* derived_loc) override {\n+      assert(*base_loc == nullptr || is_derived_oop_offset(*(intptr_t*)derived_loc), \"\");\n+    }\n+  };\n+  assert(!f.is_compiled() || f.oopmap()->has_derived_oops() == f.oopmap()->has_any(OopMapValue::derived_oop_value), \"\");\n+  if (f.is_compiled() && f.oopmap()->has_derived_oops()) {\n+    AssertRelativeDerivedOopClosure derived_closure;\n+    f.iterate_derived_pointers(&derived_closure, map);\n+  }\n+}\n+#endif\n+\n@@ -372,0 +395,1 @@\n+    \/\/ Class redefinition support\n@@ -382,1 +406,5 @@\n-  relativize_derived_oops_in_frame(f, map);\n+  if (UseZGC) {\n+    relativize_derived_oops_in_frame(f, map);\n+  } else {\n+    DEBUG_ONLY(assert_relativized_derived_oops_in_frame(f, map));\n+  }\n@@ -539,0 +567,9 @@\n+    } else {\n+      if (is_derived_oop_offset(value)) {\n+        intptr_t offset = untag_derived_oop_offset(value); \/\/ for assertions\n+      } else {\n+        \/\/ The offset was a non-offset derived pointer that\n+        \/\/ had not been converted to an offset yet.\n+        intptr_t offset = value - cast_from_oop<intptr_t>(base);\n+        tag_derived_oop_offset(offset); \/\/ for assertions\n+      }\n@@ -584,1 +621,1 @@\n-      f.print_on(&ls);\n+      f.print_value_on(&ls);\n@@ -684,1 +721,3 @@\n-    int calculated_max_size = closure._size + closure._num_i2c * frame::align_wiggle;\n+    int calculated_max_size = closure._size\n+                              + closure._num_i2c * frame::align_wiggle\n+                              + closure._num_interpreted_frames * frame::align_wiggle;\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.cpp","additions":45,"deletions":6,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -70,1 +70,4 @@\n-inline void stackChunkOopDesc::set_max_size(int value)  { jdk_internal_vm_StackChunk::set_maxSize(this, (jint)value); }\n+inline void stackChunkOopDesc::set_max_size(int value)  {\n+  assert(value >= 0, \"size must be >= 0\");\n+  jdk_internal_vm_StackChunk::set_maxSize(this, (jint)value);\n+}\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2956,0 +2956,36 @@\n+\/*\n+ * The intrinsic is a model of this pseudo-code:\n+ *\n+ * JfrThreadLocal* const tl = Thread::jfr_thread_local()\n+ * jobject h_event_writer = tl->java_event_writer();\n+ * if (h_event_writer == NULL) {\n+ *   return NULL;\n+ * }\n+ * oop threadObj = Thread::threadObj();\n+ * oop vthread = java_lang_Thread::vthread(threadObj);\n+ * traceid tid;\n+ * bool excluded;\n+ * if (vthread != threadObj) {  \/\/ i.e. current thread is virtual\n+ *   tid = java_lang_Thread::tid(vthread);\n+ *   u2 vthread_epoch_raw = java_lang_Thread::jfr_epoch(vthread);\n+ *   excluded = vthread_epoch_raw & excluded_mask;\n+ *   if (!excluded) {\n+ *     traceid current_epoch = JfrTraceIdEpoch::current_generation();\n+ *     u2 vthread_epoch = vthread_epoch_raw & epoch_mask;\n+ *     if (vthread_epoch != current_epoch) {\n+ *       write_checkpoint();\n+ *     }\n+ *   }\n+ * } else {\n+ *   tid = java_lang_Thread::tid(threadObj);\n+ *   u2 thread_epoch_raw = java_lang_Thread::jfr_epoch(threadObj);\n+ *   excluded = thread_epoch_raw & excluded_mask;\n+ * }\n+ * oop event_writer = JNIHandles::resolve_non_null(h_event_writer);\n+ * traceid tid_in_event_writer = getField(event_writer, \"threadID\");\n+ * if (tid_in_event_writer != tid) {\n+ *   setField(event_writer, \"threadID\", tid);\n+ *   setField(event_writer, \"excluded\", excluded);\n+ * }\n+ * return event_writer\n+ *\/\n@@ -3211,0 +3247,18 @@\n+\/*\n+ * The intrinsic is a model of this pseudo-code:\n+ *\n+ * JfrThreadLocal* const tl = thread->jfr_thread_local();\n+ * if (carrierThread != thread) { \/\/ is virtual thread\n+ *   const u2 vthread_epoch_raw = java_lang_Thread::jfr_epoch(thread);\n+ *   bool excluded = vthread_epoch_raw & excluded_mask;\n+ *   Atomic::store(&tl->_contextual_tid, java_lang_Thread::tid(thread));\n+ *   Atomic::store(&tl->_contextual_thread_excluded, is_excluded);\n+ *   if (!excluded) {\n+ *     const u2 vthread_epoch = vthread_epoch_raw & epoch_mask;\n+ *     Atomic::store(&tl->_vthread_epoch, vthread_epoch);\n+ *   }\n+ *   Atomic::release_store(&tl->_vthread, true);\n+ *   return;\n+ * }\n+ * Atomic::release_store(&tl->_vthread, false);\n+ *\/\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -603,4 +603,4 @@\n-    objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));\n-    objArrayHandle frames_array_h(THREAD, fa);\n-    Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));\n-    Handle cont_h(THREAD, JNIHandles::resolve_non_null(cont));\n+  objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));\n+  objArrayHandle frames_array_h(THREAD, fa);\n+  Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));\n+  Handle cont_h(THREAD, JNIHandles::resolve_non_null(cont));\n@@ -608,1 +608,1 @@\n-    StackWalk::setContinuation(stackStream_h, anchor, frames_array_h, cont_h, THREAD);\n+  StackWalk::setContinuation(stackStream_h, anchor, frames_array_h, cont_h, THREAD);\n@@ -3113,1 +3113,1 @@\n-  assert(jthread != NULL, \"no current thread!\");\n+  assert(jthread != NULL, \"no current carrier thread!\");\n@@ -3192,1 +3192,1 @@\n-                                   jobject theCache))\n+                                       jobject theCache))\n@@ -3944,1 +3944,1 @@\n-  JvmtiVTMTDisabler::start_VTMT(vthread, true);\n+  JvmtiVTMTDisabler::start_VTMT(vthread, \/* is_mount *\/ true);\n@@ -3968,1 +3968,1 @@\n-  JvmtiVTMTDisabler::finish_VTMT(vthread, true);\n+  JvmtiVTMTDisabler::finish_VTMT(vthread, \/* is_mount *\/ true);\n@@ -4018,1 +4018,1 @@\n-  JvmtiVTMTDisabler::start_VTMT(vthread, false);\n+  JvmtiVTMTDisabler::start_VTMT(vthread, \/* is_mount *\/ false);\n@@ -4039,1 +4039,1 @@\n-  JvmtiVTMTDisabler::finish_VTMT(vthread, false);\n+  JvmtiVTMTDisabler::finish_VTMT(vthread, \/* is_mount *\/ false);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1736,0 +1736,1 @@\n+        Virtual threads that are currently suspended do not change state.\n@@ -1740,1 +1741,0 @@\n-        Virtual threads that are currently suspended do not change state.\n@@ -1864,0 +1864,1 @@\n+        Virtual threads that are currently resumed do not change state.\n@@ -1868,1 +1869,0 @@\n-        Virtual threads that are currently resumed do not change state.\n@@ -5825,1 +5825,1 @@\n-      The <code>GetLocalXXX<\/code> functions may be to used retrieve the value of\n+      The <code>GetLocalXXX<\/code> functions may be used to retrieve the value of\n@@ -12978,1 +12978,1 @@\n-      Virtual thread start events are generated before its initial method executes.\n+      A virtual thread start event is generated before its initial method executes.\n@@ -13011,1 +13011,1 @@\n-      Virtual thread end events are generated after its initial method has finished execution.\n+      A virtual thread end event is generated after its initial method has finished execution.\n@@ -13041,1 +13041,1 @@\n-      Virtual thread mount events are generated before its method continue to execute on the mounted thread.\n+      A virtual thread mount event is generated before its method continue to execute on the mounted thread.\n@@ -13072,1 +13072,1 @@\n-      Virtual thread unmount events are generated when the virtual thread is about to be unmounted from the carrier thread.\n+      A virtual thread unmount event is generated when the virtual thread is about to be unmounted from the carrier thread.\n","filename":"src\/hotspot\/share\/prims\/jvmti.xml","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -150,2 +150,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -155,1 +153,0 @@\n-  oop thread_obj = NULL;\n@@ -157,0 +154,2 @@\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n@@ -161,1 +160,1 @@\n-    err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+    jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n@@ -185,0 +184,1 @@\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -204,2 +204,0 @@\n-    JavaThread* java_thread = NULL;\n-    oop thread_obj = NULL;\n@@ -209,0 +207,2 @@\n+    JavaThread* java_thread = NULL;\n+    oop thread_obj = NULL;\n@@ -588,2 +588,0 @@\n-    JavaThread* java_thread = NULL;\n-    oop thread_obj = NULL;\n@@ -592,0 +590,2 @@\n+    JavaThread* java_thread = NULL;\n+    oop thread_obj = NULL;\n@@ -855,0 +855,1 @@\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -859,2 +860,0 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_oop = NULL;\n@@ -864,0 +863,2 @@\n+  JavaThread* java_thread = NULL;\n+  oop thread_oop = NULL;\n@@ -866,0 +867,3 @@\n+    \/\/ We got an error code so we don't have a JavaThread*, but only\n+    \/\/ return an error from here if the error is not because the thread\n+    \/\/ is a virtual thread.\n@@ -869,1 +873,0 @@\n-  \/\/ Support for virtual thread\n@@ -925,0 +928,1 @@\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -929,0 +933,2 @@\n+\n+  jvmtiError err;\n@@ -931,2 +937,0 @@\n-  jvmtiError err;\n-\n@@ -943,1 +947,1 @@\n-      err = suspend_thread(thread_oop, java_thread, true, NULL); \/\/ single suspend\n+      err = suspend_thread(thread_oop, java_thread, \/* single_suspend *\/ true, NULL);\n@@ -948,1 +952,1 @@\n-  err = suspend_thread(thread_oop, current, true, NULL); \/\/ single suspend\n+  err = suspend_thread(thread_oop, current, \/* single_suspend *\/ true, NULL);\n@@ -983,1 +987,1 @@\n-      results[i] = suspend_thread(thread_oop, java_thread, true, NULL); \/\/ single suspend\n+      results[i] = suspend_thread(thread_oop, java_thread, \/* single_suspend *\/ true, NULL);\n@@ -990,1 +994,1 @@\n-    results[self_idx] = suspend_thread(self_tobj(), current, true, NULL); \/\/ single suspend\n+    results[self_idx] = suspend_thread(self_tobj(), current, \/* single_suspend *\/ true, NULL);\n@@ -1016,1 +1020,1 @@\n-    \/\/ Collect threads from except_list which resumed status must be restored.\n+    \/\/ Collect threads from except_list for which resumed status must be restored.\n@@ -1021,1 +1025,1 @@\n-          \/\/ is resumed, so its resumed status must be restored\n+          \/\/ is not suspended, so its resumed status must be restored\n@@ -1036,1 +1040,1 @@\n-      ) {\n+         ) {\n@@ -1041,1 +1045,1 @@\n-        suspend_thread(vt_oop, java_thread, false, NULL); \/\/ suspend all mode\n+        suspend_thread(vt_oop, java_thread, \/* single_suspend *\/ false, NULL);\n@@ -1046,1 +1050,1 @@\n-    \/\/ Restore resumed state for threads from except list that were resumed before.\n+    \/\/ Restore resumed state for threads from except list that were not suspended before.\n@@ -1058,1 +1062,1 @@\n-    suspend_thread(self_tobj(), current, false, NULL); \/\/ suspend all\n+    suspend_thread(self_tobj(), current, \/* single_suspend *\/ false, NULL);\n@@ -1064,0 +1068,1 @@\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1066,2 +1071,0 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_oop = NULL;\n@@ -1071,0 +1074,2 @@\n+  JavaThread* java_thread = NULL;\n+  oop thread_oop = NULL;\n@@ -1075,1 +1080,1 @@\n-  err = resume_thread(thread_oop, java_thread, true); \/\/ single suspend\n+  err = resume_thread(thread_oop, java_thread, \/* single_resume *\/ true);\n@@ -1099,1 +1104,1 @@\n-    results[i] = resume_thread(thread_oop, java_thread, true); \/\/ single suspend\n+    results[i] = resume_thread(thread_oop, java_thread, \/* single_resume *\/ true);\n@@ -1119,1 +1124,1 @@\n-  \/\/ Collect threads from except_list which suspended status must be restored.\n+  \/\/ Collect threads from except_list for which suspended status must be restored.\n@@ -1140,1 +1145,1 @@\n-      resume_thread(vt_oop, java_thread, false); \/\/ suspend all\n+      resume_thread(vt_oop, java_thread, \/* single_resume *\/ false);\n@@ -1170,0 +1175,1 @@\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1173,2 +1179,0 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_obj = NULL;\n@@ -1180,0 +1184,2 @@\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n@@ -1185,1 +1191,0 @@\n-  \/\/ Support for virtual threads\n@@ -1187,0 +1192,1 @@\n+    \/\/ For virtual threads we have to call into Java to interrupt:\n@@ -1210,0 +1216,1 @@\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1253,1 +1260,0 @@\n-  \/\/ Support for virtual threads\n@@ -1308,1 +1314,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1313,1 +1319,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n@@ -1315,1 +1320,0 @@\n-  JavaThread* java_thread = NULL;\n@@ -1317,1 +1321,0 @@\n-  oop thread_oop = NULL;\n@@ -1323,1 +1326,0 @@\n-\n@@ -1327,1 +1329,3 @@\n-  err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_oop);\n+  JavaThread* java_thread = NULL;\n+  oop thread_oop = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_oop);\n@@ -1333,1 +1337,0 @@\n-  \/\/ Support for virtual threads\n@@ -1335,1 +1338,1 @@\n-    \/\/ there is no monitor info to collect if target virtual thread is unmounted\n+    \/\/ There is no monitor info to collect if target virtual thread is unmounted.\n@@ -1384,1 +1387,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1389,1 +1392,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n@@ -1391,1 +1393,0 @@\n-  JavaThread* java_thread = NULL;\n@@ -1393,1 +1394,0 @@\n-  oop thread_oop = NULL;\n@@ -1402,1 +1402,3 @@\n-  err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_oop);\n+  JavaThread* java_thread = NULL;\n+  oop thread_oop = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_oop);\n@@ -1408,1 +1410,0 @@\n-  \/\/ Support for virtual threads\n@@ -1410,1 +1411,1 @@\n-    \/\/ there is no monitor info to collect if target virtual thread is unmounted\n+    \/\/ There is no monitor info to collect if target virtual thread is unmounted.\n@@ -1461,1 +1462,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1465,1 +1466,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n@@ -1467,1 +1467,0 @@\n-  JavaThread* java_thread = NULL;\n@@ -1469,1 +1468,0 @@\n-  oop thread_oop = NULL;\n@@ -1474,1 +1472,3 @@\n-  err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_oop);\n+  JavaThread* java_thread = NULL;\n+  oop thread_oop = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_oop);\n@@ -1479,1 +1479,0 @@\n-  \/\/ Support for virtual threads\n@@ -1481,1 +1480,1 @@\n-    \/\/ there is no monitor info to collect if target virtual thread is unmounted\n+    \/\/ There is no monitor info to collect if target virtual thread is unmounted.\n@@ -1483,1 +1482,1 @@\n-      GetCurrentContendedMonitorClosure op(calling_thread, this, monitor_ptr, true); \/\/ is_virtual\n+      GetCurrentContendedMonitorClosure op(calling_thread, this, monitor_ptr, \/* is_virtual *\/ true);\n@@ -1497,1 +1496,1 @@\n-    err = get_current_contended_monitor(calling_thread, java_thread, monitor_ptr, false);\n+    err = get_current_contended_monitor(calling_thread, java_thread, monitor_ptr, \/* is_virtual *\/ false);\n@@ -1500,1 +1499,1 @@\n-    GetCurrentContendedMonitorClosure op(calling_thread, this, monitor_ptr, false); \/\/ !is_virtual\n+    GetCurrentContendedMonitorClosure op(calling_thread, this, monitor_ptr, \/* is_virtual *\/ false);\n@@ -1508,0 +1507,1 @@\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1533,0 +1533,1 @@\n+    \/\/ No support for virtual threads.\n@@ -1600,1 +1601,0 @@\n-  ThreadPriority max_priority;\n@@ -1602,0 +1602,1 @@\n+  ThreadPriority max_priority;\n@@ -1605,1 +1606,0 @@\n-  max_priority = java_lang_ThreadGroup::maxPriority(group_obj());\n@@ -1607,0 +1607,5 @@\n+  max_priority = java_lang_ThreadGroup::maxPriority(group_obj());\n+\n+  info_ptr->is_daemon    = is_daemon;\n+  info_ptr->max_priority = max_priority;\n+  info_ptr->parent       = jni_reference(parent_group);\n@@ -1616,4 +1621,0 @@\n-  info_ptr->parent       = jni_reference(parent_group);\n-  info_ptr->max_priority = max_priority;\n-  info_ptr->is_daemon    = is_daemon;\n-\n@@ -1673,1 +1674,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1679,2 +1680,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -1683,1 +1682,0 @@\n-  oop thread_obj = NULL;\n@@ -1688,1 +1686,3 @@\n-  err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n@@ -1693,1 +1693,0 @@\n-  \/\/ Support for virtual threads\n@@ -1695,1 +1694,1 @@\n-    if (java_thread == NULL) { \/\/ target virtual thread is unmounted\n+    if (java_thread == NULL) {  \/\/ Target virtual thread is unmounted.\n@@ -1757,0 +1756,1 @@\n+\n@@ -1765,10 +1765,8 @@\n-    \/\/ Support for virtual threads\n-    if (java_lang_VirtualThread::is_instance(thread_obj)) {\n-      if (java_thread == NULL) { \/\/ target virtual thread is unmounted\n-        ResourceMark rm(current_thread);\n-        MultipleStackTracesCollector collector(this, max_frame_count);\n-        collector.fill_frames(thread, java_thread, thread_obj);\n-        collector.allocate_and_fill_stacks(1);\n-        *stack_info_ptr = collector.stack_info();\n-        return collector.result();\n-      }\n+    if (java_lang_VirtualThread::is_instance(thread_obj) && java_thread == NULL) {\n+      \/\/ Target virtual thread is unmounted.\n+      ResourceMark rm(current_thread);\n+      MultipleStackTracesCollector collector(this, max_frame_count);\n+      collector.fill_frames(thread, java_thread, thread_obj);\n+      collector.allocate_and_fill_stacks(\/* thread_count *\/ 1);\n+      *stack_info_ptr = collector.stack_info();\n+      return collector.result();\n@@ -1796,1 +1794,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1800,2 +1798,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -1804,1 +1800,0 @@\n-  oop thread_obj = NULL;\n@@ -1809,1 +1804,3 @@\n-  err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n@@ -1814,1 +1811,0 @@\n-  \/\/ Support for virtual threads\n@@ -1816,1 +1812,1 @@\n-    if (java_thread == NULL) { \/\/ target virtual thread is unmounted\n+    if (java_thread == NULL) {  \/\/ Target virtual thread is unmounted.\n@@ -1840,1 +1836,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1843,2 +1839,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -1847,1 +1841,0 @@\n-  oop thread_obj = NULL;\n@@ -1855,1 +1848,3 @@\n-  err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n@@ -1860,1 +1855,0 @@\n-  \/\/ Support for virtual threads\n@@ -1862,0 +1856,1 @@\n+    \/\/ No support for virtual threads (yet).\n@@ -1888,1 +1883,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1894,2 +1889,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -1898,1 +1891,0 @@\n-  oop thread_obj = NULL;\n@@ -1903,1 +1895,3 @@\n-  err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n@@ -1908,1 +1902,0 @@\n-  \/\/ Support for virtual threads\n@@ -1910,1 +1903,1 @@\n-    if (java_thread == NULL) { \/\/ target virtual thread is unmounted\n+    if (java_thread == NULL) {  \/\/ Target virtual thread is unmounted.\n@@ -1938,1 +1931,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n@@ -1940,2 +1932,0 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_obj = NULL;\n@@ -1945,1 +1935,3 @@\n-  err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n@@ -1953,16 +1945,0 @@\n-\n-  \/\/ Support for virtual threads\n-  if (java_lang_VirtualThread::is_instance(thread_obj)) {\n-    if (java_thread == NULL) {\n-      \/\/ java_thread is NULL if virtual thread is unmounted\n-      JvmtiThreadState *state = JvmtiThreadState::state_for(java_thread, thread_handle);\n-      if (state == NULL) {\n-        return JVMTI_ERROR_THREAD_NOT_ALIVE;\n-      }\n-      MutexLocker mu(JvmtiThreadState_lock);\n-      int frame_number = state->count_frames() - depth;\n-      state->env_thread_state(this)->set_frame_pop(frame_number);\n-      return JVMTI_ERROR_NONE;\n-    }\n-  }\n-\n@@ -1974,0 +1950,12 @@\n+  if (java_lang_VirtualThread::is_instance(thread_handle())) {\n+    VirtualThreadSetFramePopClosure op(this, thread_handle, state, depth);\n+    MutexLocker mu(current, JvmtiThreadState_lock);\n+    if (java_thread == NULL || java_thread == current) {\n+      \/\/ Target virtual thread is unmounted or current.\n+      op.doit(java_thread, true \/* self *\/);\n+    } else {\n+      Handshake::execute(&op, java_thread);\n+    }\n+    return op.result();\n+  }\n+\n@@ -1989,1 +1977,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1998,1 +1986,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2007,1 +1995,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2016,1 +2004,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2025,1 +2013,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2034,1 +2022,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2212,1 +2200,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2217,2 +2205,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -2225,1 +2211,0 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2227,0 +2212,2 @@\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2228,1 +2215,0 @@\n-    \/\/ Support for virtual threads\n@@ -2239,0 +2225,1 @@\n+    JavaThread* java_thread = NULL;\n@@ -2253,1 +2240,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2258,2 +2245,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -2266,1 +2251,0 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2268,0 +2252,2 @@\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2269,1 +2255,0 @@\n-    \/\/ Support for virtual threads\n@@ -2280,0 +2265,1 @@\n+    JavaThread* java_thread = NULL;\n@@ -2295,1 +2281,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2300,2 +2286,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -2308,1 +2292,0 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2310,0 +2293,2 @@\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2311,1 +2296,0 @@\n-    \/\/ Support for virtual threads\n@@ -2322,0 +2306,1 @@\n+    JavaThread* java_thread = NULL;\n@@ -2337,1 +2322,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2342,2 +2327,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -2350,1 +2333,0 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2352,0 +2334,2 @@\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2353,1 +2337,0 @@\n-    \/\/ Support for virtual threads\n@@ -2364,0 +2347,1 @@\n+    JavaThread* java_thread = NULL;\n@@ -2379,1 +2363,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2384,2 +2368,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -2392,1 +2374,0 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2394,0 +2375,2 @@\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2395,1 +2378,0 @@\n-    \/\/ Support for virtual threads\n@@ -2406,0 +2388,1 @@\n+    JavaThread* java_thread = NULL;\n@@ -2421,1 +2404,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2426,2 +2409,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -2434,1 +2415,0 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2436,0 +2416,2 @@\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2437,1 +2419,0 @@\n-    \/\/ Support for virtual threads\n@@ -2448,0 +2429,1 @@\n+    JavaThread* java_thread = NULL;\n@@ -2463,1 +2445,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2467,2 +2449,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -2475,1 +2455,0 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2479,0 +2458,2 @@\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2480,1 +2461,0 @@\n-    \/\/ Support for virtual threads\n@@ -2488,0 +2468,1 @@\n+    JavaThread* java_thread = NULL;\n@@ -2500,1 +2481,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2504,2 +2485,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -2512,1 +2491,0 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2516,0 +2494,2 @@\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2517,1 +2497,0 @@\n-    \/\/ Support for virtual threads\n@@ -2525,0 +2504,1 @@\n+    JavaThread* java_thread = NULL;\n@@ -2537,1 +2517,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2541,2 +2521,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -2549,1 +2527,0 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2553,0 +2530,2 @@\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2554,1 +2533,0 @@\n-    \/\/ Support for virtual threads\n@@ -2562,0 +2540,1 @@\n+    JavaThread* java_thread = NULL;\n@@ -2574,1 +2553,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2578,2 +2557,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -2586,1 +2563,0 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2590,0 +2566,2 @@\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2591,1 +2569,0 @@\n-    \/\/ Support for virtual threads\n@@ -2599,0 +2576,1 @@\n+    JavaThread* java_thread = NULL;\n@@ -2611,1 +2589,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2615,2 +2593,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -2623,1 +2599,0 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2627,0 +2602,2 @@\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2628,1 +2605,0 @@\n-    \/\/ Support for virtual threads\n@@ -2636,0 +2612,1 @@\n+    JavaThread* java_thread = NULL;\n@@ -3872,1 +3849,1 @@\n-  \/\/ Surprizingly the GetCurrentThreadCpuTime is used by non-JavaThread's.\n+  \/\/ Surprisingly the GetCurrentThreadCpuTime is used by non-JavaThread's.\n@@ -3875,0 +3852,1 @@\n+      \/\/ No support for virtual threads (yet).\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":162,"deletions":184,"binary":false,"changes":346,"status":"modified"},{"patch":"@@ -618,1 +618,1 @@\n-\/\/ return JavaThread if virtual thread is mounted, NULL otherwise\n+\/\/ Return JavaThread if virtual thread is mounted, NULL otherwise.\n@@ -622,1 +622,0 @@\n-    \/\/ can be NULL\n@@ -628,1 +627,1 @@\n-  assert(cont != NULL, \"virtual thread continuation must not be NULL\");\n+  assert(cont != NULL, \"must be\");\n@@ -637,1 +636,1 @@\n-    return jvf; \/\/ no frames to skip\n+    return jvf;  \/\/ No frames to skip.\n@@ -639,1 +638,1 @@\n-  \/\/ find jvf with a method annotated with @JvmtiMountTransition\n+  \/\/ Find jvf with a method annotated with @JvmtiMountTransition.\n@@ -641,2 +640,2 @@\n-    if (jvf->method()->jvmti_mount_transition()) { \/\/ cannot actually appear in an unmounted continuation; they're never frozen.\n-      jvf = jvf->java_sender(); \/\/ skip annotated method\n+    if (jvf->method()->jvmti_mount_transition()) {  \/\/ Cannot actually appear in an unmounted continuation; they're never frozen.\n+      jvf = jvf->java_sender();  \/\/ Skip annotated method.\n@@ -648,1 +647,1 @@\n-    \/\/ skip frame above annotated method\n+    \/\/ Skip frame above annotated method.\n@@ -715,1 +714,1 @@\n-    \/\/ get most state bits\n+    \/\/ Get most state bits.\n@@ -744,1 +743,1 @@\n-    \/\/ If virtual thread is blocked on a monitor eneter the BLOCKED_ON_MONITOR_ENTER bit\n+    \/\/ If virtual thread is blocked on a monitor enter the BLOCKED_ON_MONITOR_ENTER bit\n@@ -750,1 +749,1 @@\n-    \/\/ this call can trigger a safepoint, so thread_oop must not be used after it\n+    \/\/ This call can trigger a safepoint, so thread_oop must not be used after it.\n@@ -770,1 +769,1 @@\n-  ThreadsListEnumerator tle(current_thread, true);\n+  ThreadsListEnumerator tle(current_thread, \/* include_jvmti_agent_threads *\/ true);\n@@ -791,2 +790,2 @@\n-  int ngroups  = java_lang_ThreadGroup::ngroups(group_hdl());\n-  int nweaks  = java_lang_ThreadGroup::nweaks(group_hdl());\n+  int ngroups = java_lang_ThreadGroup::ngroups(group_hdl());\n+  int nweaks = java_lang_ThreadGroup::nweaks(group_hdl());\n@@ -800,1 +799,0 @@\n-    \/\/ strongly reachable subgroups\n@@ -802,0 +800,1 @@\n+      \/\/ Strongly reachable subgroups:\n@@ -810,1 +809,0 @@\n-    \/\/ weakly reachable subgroups\n@@ -812,0 +810,1 @@\n+      \/\/ Weakly reachable subgroups:\n@@ -848,1 +847,1 @@\n-  RegisterMap  reg_map(java_thread, true, true);\n+  RegisterMap  reg_map(java_thread, \/* update_map *\/ true, \/* process_frames *\/ true);\n@@ -850,2 +849,1 @@\n-  for (javaVFrame *jvf = java_thread->last_java_vframe(&reg_map);\n-       jvf != NULL;\n+  for (javaVFrame *jvf = java_thread->last_java_vframe(&reg_map); jvf != NULL;\n@@ -936,2 +934,1 @@\n-         jvf != NULL;\n-         jvf = jvf->java_sender()) {\n+         jvf != NULL; jvf = jvf->java_sender()) {\n@@ -967,2 +964,2 @@\n-      \/\/ add locked objects for this frame into list\n-      err = get_locked_objects_in_frame(calling_thread, java_thread, jvf, owned_monitors_list, depth-1);\n+      \/\/ Add locked objects for this frame into list.\n+      err = get_locked_objects_in_frame(calling_thread, java_thread, jvf, owned_monitors_list, depth - 1);\n@@ -1090,1 +1087,1 @@\n-        \/\/ start_depth is deeper than the stack depth\n+        \/\/ start_depth is deeper than the stack depth.\n@@ -1094,1 +1091,1 @@\n-      \/\/ we are referencing the starting depth based on the oldest\n+      \/\/ We are referencing the starting depth based on the oldest\n@@ -1096,1 +1093,1 @@\n-      \/\/ optimize to limit the number of times that java_sender() is called\n+      \/\/ Optimize to limit the number of times that java_sender() is called.\n@@ -1109,1 +1106,1 @@\n-        \/\/ previous pointer is exactly where we want to start\n+        \/\/ Previous pointer is exactly where we want to start.\n@@ -1112,1 +1109,1 @@\n-        \/\/ we need to back up further to get to the right place\n+        \/\/ We need to back up further to get to the right place.\n@@ -1114,1 +1111,1 @@\n-          \/\/ the -start_depth is greater than the stack depth\n+          \/\/ The -start_depth is greater than the stack depth.\n@@ -1117,1 +1114,1 @@\n-        \/\/ j now is the number of frames on the stack starting with\n+        \/\/ j is now the number of frames on the stack starting with\n@@ -1119,1 +1116,1 @@\n-        \/\/ the stack that many, the result is -start_depth frames\n+        \/\/ the stack that many, and the result is -start_depth frames\n@@ -1141,3 +1138,0 @@\n-#ifdef ASSERT\n-  uint32_t debug_bits = 0;\n-#endif\n@@ -1152,1 +1146,1 @@\n-    RegisterMap reg_map(java_thread, true, false); \/\/ don't process frames\n+    RegisterMap reg_map(java_thread, \/* update_map *\/ true, \/* process_frames *\/ false);\n@@ -1281,0 +1275,19 @@\n+jvmtiError\n+JvmtiEnvBase::set_frame_pop(JvmtiThreadState* state, javaVFrame* jvf, jint depth) {\n+  vframe* vf = jvf;\n+  for (int d = 0; vf != NULL && d < depth; d++) {\n+    vf = vf->java_sender();\n+  }\n+  if (vf == NULL) {\n+    return JVMTI_ERROR_NO_MORE_FRAMES;\n+  }\n+  if (!vf->is_java_frame() || ((javaVFrame*)vf)->method()->is_native()) {\n+    return JVMTI_ERROR_OPAQUE_FRAME;\n+  }\n+  assert(vf->frame_pointer() != NULL, \"frame pointer mustn't be NULL\");\n+\n+  int frame_number = (int)get_frame_count(jvf) - depth;\n+  state->env_thread_state((JvmtiEnvBase*)this)->set_frame_pop(frame_number);\n+  return JVMTI_ERROR_NONE;\n+}\n+\n@@ -1390,1 +1403,1 @@\n-      Handle     th(current_thread, get_vthread_or_thread_oop(owning_thread));\n+      Handle th(current_thread, get_vthread_or_thread_oop(owning_thread));\n@@ -1522,0 +1535,1 @@\n+\/\/ java_thread - protected by ThreadsListHandle\n@@ -1590,0 +1604,1 @@\n+\/\/ java_thread - protected by ThreadsListHandle\n@@ -1591,1 +1606,1 @@\n-JvmtiEnvBase::resume_thread(oop thread_oop, JavaThread* java_thread, bool single_suspend) {\n+JvmtiEnvBase::resume_thread(oop thread_oop, JavaThread* java_thread, bool single_resume) {\n@@ -1598,1 +1613,1 @@\n-    if (single_suspend) {\n+    if (single_resume) {\n@@ -1604,1 +1619,1 @@\n-      \/\/ A non-NULL java_thread is always passed in the !single_suspend case.\n+      \/\/ A non-NULL java_thread is always passed in the !single_resume case.\n@@ -1635,1 +1650,1 @@\n-    assert(single_suspend || is_virtual, \"ResumeAllVirtualThreads should never resume non-virtual threads\");\n+    assert(single_resume || is_virtual, \"ResumeAllVirtualThreads should never resume non-virtual threads\");\n@@ -1691,1 +1706,0 @@\n-\n@@ -1717,1 +1731,0 @@\n-  \/\/ Support for virtual threads\n@@ -1900,0 +1913,2 @@\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n+\n@@ -1902,2 +1917,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -1906,1 +1919,0 @@\n-  oop thread_obj = NULL;\n@@ -1911,1 +1923,3 @@\n-  err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n@@ -1916,1 +1930,0 @@\n-  \/\/ Support for virtual threads\n@@ -1918,0 +1931,1 @@\n+    \/\/ No support for virtual threads (yet).\n@@ -2133,1 +2147,1 @@\n-    if(JvmtiEnvBase::vframe_for_no_process(java_thread, 1) == NULL) {\n+    if (JvmtiEnvBase::vframe_for_no_process(java_thread, 1) == NULL) {\n@@ -2178,2 +2192,0 @@\n-\n-  \/\/ TBD: This might need to be corrected for detached carrier and virtual threads.\n@@ -2186,1 +2198,0 @@\n-\n@@ -2261,4 +2272,4 @@\n-  tty->print_cr(\"%s(%s) exiting: %d is_susp: %d is_thread_susp: %d is_vthread_susp: %d is_VTMT_disabler: %d, is_in_VTMT = %d\",\n-                tname, java_thread->name(), java_thread->is_exiting(),\n-                java_thread->is_suspended(), java_thread->is_carrier_thread_suspended(), is_vt_suspended,\n-                java_thread->is_VTMT_disabler(), java_thread->is_in_VTMT());\n+  log_error(jvmti)(\"%s(%s) exiting: %d is_susp: %d is_thread_susp: %d is_vthread_susp: %d is_VTMT_disabler: %d, is_in_VTMT = %d\\n\",\n+                   tname, java_thread->name(), java_thread->is_exiting(),\n+                   java_thread->is_suspended(), java_thread->is_carrier_thread_suspended(), is_vt_suspended,\n+                   java_thread->is_VTMT_disabler(), java_thread->is_in_VTMT());\n@@ -2267,1 +2278,1 @@\n-    RegisterMap reg_map(java_thread, true, true);\n+    RegisterMap reg_map(java_thread, \/* update_map *\/ true, \/* process_frames *\/ true);\n@@ -2272,3 +2283,3 @@\n-      tty->print_cr(\"  %s:%d\",\n-                    jvf->method()->external_name(),\n-                    jvf->method()->line_number_from_bci(jvf->bci()));\n+      log_error(jvmti)(\"  %s:%d\",\n+                       jvf->method()->external_name(),\n+                       jvf->method()->line_number_from_bci(jvf->bci()));\n@@ -2278,1 +2289,1 @@\n-  tty->print_cr(\"\");\n+  log_error(jvmti)(\"\\n\");\n@@ -2287,1 +2298,1 @@\n-      java_thread->is_handshake_safe_for(current_thread),\n+         java_thread->is_handshake_safe_for(current_thread),\n@@ -2398,0 +2409,15 @@\n+\n+void\n+VirtualThreadSetFramePopClosure::doit(Thread *target, bool self) {\n+  if (!JvmtiEnvBase::is_vthread_alive(_vthread_h())) {\n+    _result = JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    return;\n+  }\n+  if (!self && !JvmtiVTSuspender::is_vthread_suspended(_vthread_h())) {\n+    _result = JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+    return;\n+  }\n+  ResourceMark rm;\n+  javaVFrame *jvf = JvmtiEnvBase::get_vthread_jvf(_vthread_h());\n+  _result = ((JvmtiEnvBase*)_env)->set_frame_pop(_state, jvf, _depth);\n+}\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":87,"deletions":61,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-  static jvmtiError resume_thread(oop thread_oop, JavaThread* java_thread, bool single_suspend);\n+  static jvmtiError resume_thread(oop thread_oop, JavaThread* java_thread, bool single_resume);\n@@ -179,1 +179,1 @@\n-  \/\/ If there is a virtual thread mounted to the JavaThread* then\n+  \/\/ If there is a virtual thread mounted on the JavaThread* then\n@@ -372,0 +372,1 @@\n+  jvmtiError set_frame_pop(JvmtiThreadState* state, javaVFrame* jvf, jint depth);\n@@ -385,1 +386,1 @@\n-                          GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list);\n+                                GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list);\n@@ -467,1 +468,1 @@\n-    : JvmtiHandshakeClosure(\"SetFramePop\"),\n+    : JvmtiHandshakeClosure(\"SetFramePopClosure\"),\n@@ -875,0 +876,23 @@\n+\/\/ HandshakeClosure to set frame pop for a virtual thread..\n+class VirtualThreadSetFramePopClosure : public JvmtiHandshakeClosure {\n+private:\n+  JvmtiEnv *_env;\n+  Handle _vthread_h;\n+  JvmtiThreadState* _state;\n+  jint _depth;\n+\n+public:\n+  VirtualThreadSetFramePopClosure(JvmtiEnv *env, Handle vthread_h, JvmtiThreadState* state, jint depth)\n+    : JvmtiHandshakeClosure(\"VirtualThreadSetFramePopClosure\"),\n+      _env(env),\n+      _vthread_h(vthread_h),\n+      _state(state),\n+      _depth(depth) {}\n+\n+  void do_thread(Thread *target) {\n+    doit(target, false \/* self *\/);\n+  }\n+  void doit(Thread *target, bool self);\n+};\n+\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":28,"deletions":4,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -285,1 +285,1 @@\n-      return; \/\/ _completed remains false\n+      return; \/\/ _completed remains false.\n@@ -291,1 +291,1 @@\n-      \/\/ jvf can be NULL, when the native enterSpecial frame is on the top\n+      \/\/ jvf can be NULL, when the native enterSpecial frame is on the top.\n@@ -378,1 +378,0 @@\n-    \/\/ Check for an unmounted virual thread case.\n@@ -380,0 +379,1 @@\n+      \/\/ Handle the unmounted virtual thread case.\n@@ -386,1 +386,0 @@\n-      \/\/ do nothing if virtual thread has been already terminated\n@@ -388,0 +387,1 @@\n+        \/\/ Do nothing if virtual thread has been already terminated.\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvThreadState.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvThreadState.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-      return; \/\/ the pending flag has been already cleared, so bail out\n+      return;  \/\/ The pending flag has been already cleared, so bail out.\n@@ -219,1 +219,1 @@\n-    state->set_pending_interp_only_mode(false); \/\/ clear the pending flag\n+    state->set_pending_interp_only_mode(false);  \/\/ Clear the pending flag.\n@@ -362,1 +362,1 @@\n-    return; \/\/ an EnterInterpOnlyModeClosure handshake is already pending for execution\n+    return;  \/\/ An EnterInterpOnlyModeClosure handshake is already pending for execution.\n@@ -364,1 +364,1 @@\n-  \/\/ this flag will be cleared in EnterInterpOnlyModeClosure handshake\n+  \/\/ This flag will be cleared in EnterInterpOnlyModeClosure handshake.\n@@ -367,1 +367,1 @@\n-    return; \/\/ EnterInterpOnlyModeClosure will be executed right after mount\n+    return;  \/\/ EnterInterpOnlyModeClosure will be executed right after mount.\n@@ -385,1 +385,1 @@\n-    state->set_pending_interp_only_mode(false); \/\/ just clear the pending flag\n+    state->set_pending_interp_only_mode(false);  \/\/ Just clear the pending flag.\n@@ -583,1 +583,0 @@\n-    \/\/ pointer to JavaThread can be NULL for unmouted virtual thread\n@@ -585,1 +584,2 @@\n-      \/\/ update the JavaThread cached value for thread-specific should_post_on_exceptions value\n+      \/\/ The JavaThread for carrier or mounted virtual thread case.\n+      \/\/ Update the cached value for thread-specific should_post_on_exceptions value.\n@@ -774,1 +774,1 @@\n-  \/\/ mask to clear normal event bits\n+  \/\/ Mask to clear normal event bits.\n@@ -776,1 +776,1 @@\n-  \/\/ avoid cleaning extension event bits\n+  \/\/ Avoid cleaning extension event bits.\n@@ -898,1 +898,4 @@\n-  if (thread == NULL && thread_oop_h() == NULL) { \/\/ thread can be NULL for unmounted virtual trheads\n+  if (thread == NULL && thread_oop_h() == NULL) {\n+    \/\/ NULL thread and NULL thread_oop now indicate setting globally instead\n+    \/\/ of setting thread specific since NULL thread by itself means an\n+    \/\/ unmounted virtual thread.\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -891,0 +891,1 @@\n+    assert(!_thread->is_in_VTMT(), \"CFLH events are not allowed in VTMT\");\n@@ -1337,3 +1338,2 @@\n-  if (thread->is_in_VTMT()) {\n-    return; \/\/ no events should be posted if thread is in a VTMT transition\n-  }\n+  assert(!thread->is_in_VTMT(), \"class load events are not allowed in VTMT\");\n+\n@@ -1373,3 +1373,2 @@\n-  if (thread->is_in_VTMT()) {\n-    return; \/\/ no events should be posted if thread is in a VTMT transition\n-  }\n+  assert(!thread->is_in_VTMT(), \"class prepare events are not allowed in VTMT\");\n+\n@@ -1690,0 +1689,5 @@\n+  Thread *thread = Thread::current();\n+\n+  if (thread->is_Java_thread() && JavaThread::cast(thread)->is_in_VTMT()) {\n+    return; \/\/ no events should be posted if thread is in a VTMT transition\n+  }\n@@ -1705,0 +1709,4 @@\n+  if (thread->is_in_VTMT()) {\n+    return; \/\/ no events should be posted if thread is in a VTMT transition\n+  }\n+\n@@ -1785,3 +1793,0 @@\n-  if (mh->jvmti_mount_transition() || thread->is_in_VTMT()) {\n-    return; \/\/ no events should be posted if thread is in a VTMT transition\n-  }\n@@ -1831,0 +1836,4 @@\n+  if (mh->jvmti_mount_transition() || thread->is_in_VTMT()) {\n+    return; \/\/ no events should be posted if thread is in a VTMT transition\n+  }\n+\n@@ -1891,1 +1900,0 @@\n-\n@@ -2063,0 +2071,3 @@\n+      if (mh->jvmti_mount_transition() || thread->is_in_VTMT()) {\n+        return; \/\/ no events should be posted if thread is in a VTMT transition\n+      }\n@@ -2411,0 +2422,2 @@\n+  assert(!thread->is_in_VTMT(), \"compiled method load events are not allowed in VTMT\");\n+\n@@ -2432,0 +2445,2 @@\n+  assert(!thread->is_in_VTMT(), \"compiled method load events are not allowed in VTMT\");\n+\n@@ -2455,0 +2470,3 @@\n+\n+  assert(!thread->is_in_VTMT(), \"dynamic code generated events are not allowed in VTMT\");\n+\n@@ -2500,0 +2518,3 @@\n+\n+  assert(!thread->is_in_VTMT(), \"dynamic code generated events are not allowed in VTMT\");\n+\n@@ -2521,0 +2542,3 @@\n+  JavaThread* thread = JavaThread::current();\n+  assert(!thread->is_in_VTMT(), \"dynamic code generated events are not allowed in VTMT\");\n+\n@@ -2526,1 +2550,1 @@\n-  JvmtiThreadState* state = JavaThread::current()->jvmti_thread_state();\n+  JvmtiThreadState* state = thread->jvmti_thread_state();\n@@ -2946,0 +2970,5 @@\n+\n+        \/\/ Agent_OnAttach may have used JNI\n+        if (THREAD->is_pending_jni_exception_check()) {\n+          THREAD->clear_pending_jni_exception_check();\n+        }\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":40,"deletions":11,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,3 +41,3 @@\n-\/*\n- * Extension Functions\n- *\/\n+\/\/\n+\/\/ Extension Functions\n+\/\/\n@@ -172,1 +172,1 @@\n-  \/\/ register our extension functions\n+  \/\/ Register our extension functions.\n","filename":"src\/hotspot\/share\/prims\/jvmtiExtensions.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -493,1 +493,1 @@\n-    \/\/ Just to check index boundaries\n+    \/\/ Just to check index boundaries.\n@@ -651,1 +651,1 @@\n-      \/\/ continuation can't be unmounted at this point (it was checked\/reported in get_java_vframe)\n+      \/\/ Continuation can't be unmounted at this point (it was checked\/reported in get_java_vframe).\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -386,1 +386,1 @@\n-\/\/ VM operation to get or set virtual thread local\n+\/\/ VM operation to get or set virtual thread local.\n@@ -395,1 +395,1 @@\n-  \/\/ Constructor for non-object getter\n+  \/\/ Constructor for non-object getter.\n@@ -398,1 +398,1 @@\n-  \/\/ Constructor for object or non-object setter\n+  \/\/ Constructor for object or non-object setter.\n@@ -402,1 +402,1 @@\n-  \/\/ Constructor for object getter\n+  \/\/ Constructor for object getter.\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -274,1 +274,1 @@\n-  \/\/ special case for virtual thread events\n+  \/\/ Special case for virtual thread events.\n","filename":"src\/hotspot\/share\/prims\/jvmtiManageCapabilities.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/prims\/jvmtiRawMonitor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -120,1 +120,0 @@\n-  \/\/ thread can be NULL if virtual thread is unmounted\n@@ -122,1 +121,0 @@\n-    \/\/ set this as the state for the thread only if thread_oop is current thread->jvmti_vthread()\n@@ -124,0 +122,2 @@\n+      \/\/ The JavaThread for carrier or mounted virtual thread case.\n+      \/\/ Set this only if thread_oop is current thread->jvmti_vthread().\n@@ -213,1 +213,3 @@\n-\/* Virtual Threads Mount Transition (VTMT) mechanism *\/\n+\/\/\n+\/\/ Virtual Threads Mount Transition (VTMT) mechanism\n+\/\/\n@@ -215,1 +217,1 @@\n-\/\/ VTMT can not be disabled while this counter is positive\n+\/\/ VTMT cannot be disabled while this counter is positive.\n@@ -221,1 +223,1 @@\n-\/\/ there is an active suspender or resumer\n+\/\/ There is an active suspender or resumer.\n@@ -228,2 +230,3 @@\n-  tty->print_cr(\"_VTMT_disable_count: %d _VTMT_count: %d\\n\",\n-                _VTMT_disable_count, _VTMT_count);\n+  log_error(jvmti)(\"_VTMT_disable_count: %d _VTMT_count: %d\\n\\n\",\n+                   _VTMT_disable_count, _VTMT_count);\n+  int attempts = 10000;\n@@ -232,1 +235,1 @@\n-    \/\/ Handshake with target\n+    \/\/ Handshake with target.\n@@ -240,0 +243,3 @@\n+  if (!Continuations::enabled()) {\n+    return; \/\/ JvmtiVTMTDisabler is no-op without virtual threads\n+  }\n@@ -241,1 +247,1 @@\n-    return; \/\/ detached thread, can be a call from Agent_OnLoad\n+    return;  \/\/ Detached thread, can be a call from Agent_OnLoad.\n@@ -248,0 +254,3 @@\n+  if (!Continuations::enabled()) {\n+    return; \/\/ JvmtiVTMTDisabler is a no-op without virtual threads\n+  }\n@@ -249,1 +258,1 @@\n-    return; \/\/ detached thread, can be a call from Agent_OnLoad\n+    return;  \/\/ Detached thread, can be a call from Agent_OnLoad.\n@@ -263,2 +272,2 @@\n-    while (_SR_mode) { \/\/ suspender or resumer is a JvmtiVTMTDisabler monopolist\n-      ml.wait(10); \/\/ wait while there is an active suspender or resumer\n+    while (_SR_mode) {  \/\/ suspender or resumer is a JvmtiVTMTDisabler monopolist\n+      ml.wait(10);  \/\/ Wait while there is an active suspender or resumer.\n@@ -269,1 +278,1 @@\n-        ml.wait(10); \/\/ wait while there is any active jvmtiVTMTDisabler\n+        ml.wait(10);  \/\/ Wait while there is any active jvmtiVTMTDisabler.\n@@ -275,1 +284,1 @@\n-    \/\/ Debug version fails and print diagnostic information\n+    \/\/ Debug version fails and prints diagnostic information.\n@@ -283,1 +292,0 @@\n-    if (attempts != 0) {\n@@ -285,2 +293,3 @@\n-      thread->set_is_VTMT_disabler(true);\n-#endif\n+    if (attempts == 0) {\n+      print_info();\n+      fatal(\"stuck in JvmtiVTMTDisabler::disable_VTMT\");\n@@ -288,6 +297,1 @@\n-  }\n-#ifdef ASSERT\n-  if (attempts == 0) {\n-    print_info();\n-    assert(false, \"stuck in JvmtiVTMTDisabler::disable_VTMT\");\n-  }\n+    thread->set_is_VTMT_disabler(true);\n@@ -295,0 +299,1 @@\n+  }\n@@ -304,1 +309,1 @@\n-    if (_is_SR) { \/\/ disabler is suspender or resumer\n+    if (_is_SR) {  \/\/ Disabler is suspender or resumer.\n@@ -330,1 +335,1 @@\n-  int64_t thread_id = java_lang_Thread::thread_id(vth()); \/\/ cannot use oops while blocked\n+  int64_t thread_id = java_lang_Thread::thread_id(vth());  \/\/ Cannot use oops while blocked.\n@@ -349,1 +354,1 @@\n-        \/\/ block while transitions are disabled or there are suspend requests\n+        \/\/ Block while transitions are disabled or there are suspend requests.\n@@ -354,1 +359,1 @@\n-        continue; \/\/ ~ThreadBlockInVM has handshake-based suspend point\n+        continue;  \/\/ ~ThreadBlockInVM has handshake-based suspend point.\n@@ -360,1 +365,9 @@\n-  \/\/ enter VTMT section\n+#ifdef ASSERT\n+  if (attempts == 0) {\n+    log_error(jvmti)(\"start_VTMT: thread->is_suspended: %d is_vthread_suspended: %d\\n\\n\",\n+                     thread->is_suspended(), JvmtiVTSuspender::is_vthread_suspended(thread_id));\n+    print_info();\n+    fatal(\"stuck in JvmtiVTMTDisabler::start_VTMT\");\n+  }\n+#endif\n+  \/\/ Enter VTMT section.\n@@ -367,8 +380,0 @@\n-#ifdef ASSERT\n-  if (attempts == 0) {\n-    tty->print_cr(\"start_VTMT: thread->is_suspended: %d is_vthread_suspended: %d\\n\",\n-                  thread->is_suspended(), JvmtiVTSuspender::is_vthread_suspended(vth()));\n-    print_info();\n-    assert(false, \"stuck in JvmtiVTMTDisabler::start_VTMT\");\n-  }\n-#endif\n@@ -392,1 +397,1 @@\n-  \/\/ unblock waiting VTMT disablers\n+  \/\/ Unblock waiting VTMT disablers.\n@@ -399,0 +404,1 @@\n+  int attempts = 10000;\n@@ -404,1 +410,1 @@\n-      \/\/ block while there are suspend requests\n+      \/\/ Block while there are suspend requests.\n@@ -408,2 +414,5 @@\n-        \/\/ block while there are suspend requests\n-        ml.wait(10);\n+        \/\/ Block while there are suspend requests.\n+        if (ml.wait(10)) {\n+          attempts--;\n+        }\n+        DEBUG_ONLY(if (attempts == 0) break;)\n@@ -415,0 +424,8 @@\n+#ifdef ASSERT\n+  if (attempts == 0) {\n+    log_error(jvmti)(\"finish_VTMT: thread->is_suspended: %d is_vthread_suspended: %d\\n\\n\",\n+                     thread->is_suspended(), JvmtiVTSuspender::is_vthread_suspended(thread_id));\n+    print_info();\n+    fatal(\"stuck in JvmtiVTMTDisabler::finish_VTMT\");\n+  }\n+#endif\n@@ -417,1 +434,3 @@\n-\/* Virtual Threads Suspend\/Resume management *\/\n+\/\/\n+\/\/ Virtual Threads Suspend\/Resume management\n+\/\/\n@@ -527,1 +546,1 @@\n-  assert(is_interp_only_mode(), \"leaving interp only when mode not one\");\n+  assert(is_interp_only_mode(), \"leaving interp only when not in interp only mode\");\n@@ -529,0 +548,1 @@\n+    \/\/ Unmounted virtual thread updates the saved value.\n@@ -549,1 +569,1 @@\n-        thread->is_handshake_safe_for(current_thread),\n+           thread->is_handshake_safe_for(current_thread),\n@@ -551,1 +571,1 @@\n-    if (!thread->has_last_Java_frame()) return 0;  \/\/ no Java frames\n+    if (!thread->has_last_Java_frame()) return 0;  \/\/ No Java frames.\n@@ -553,1 +573,1 @@\n-    RegisterMap reg_map(thread, false, false, true);\n+    RegisterMap reg_map(thread, \/* update_map *\/ false, \/* process_frames *\/ false, \/* walk_cont *\/ true);\n@@ -768,1 +788,1 @@\n-  _thread_saved = NULL; \/\/ common case;\n+  _thread_saved = NULL;  \/\/ Common case.\n@@ -783,1 +803,0 @@\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":66,"deletions":47,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,1 @@\n-  if (thread_oop == NULL) { \/\/ then thread should not be NULL (see assert above)\n+  if (thread_oop == NULL) {  \/\/ Then thread should not be NULL (see assert above).\n@@ -87,1 +87,1 @@\n-  \/\/ in a case of unmounted virtual thread the thread can be NULL\n+  \/\/ In a case of unmounted virtual thread the thread can be NULL.\n@@ -91,1 +91,1 @@\n-    \/\/ don't add a JvmtiThreadState to a thread that is exiting\n+    \/\/ Don't add a JvmtiThreadState to a thread that is exiting.\n@@ -95,2 +95,2 @@\n-    \/\/ check if java_lang_Thread already has a link to the JvmtiThreadState\n-    if (thread_oop != NULL) { \/\/ thread_oop can be NULL at early VMStart\n+    \/\/ Check if java_lang_Thread already has a link to the JvmtiThreadState.\n+    if (thread_oop != NULL) {  \/\/ thread_oop can be NULL during early VMStart.\n@@ -99,1 +99,1 @@\n-    if (state == NULL) { \/\/ need to create state\n+    if (state == NULL) {  \/\/ Need to create state.\n@@ -108,1 +108,1 @@\n-  \/\/ in a case of unmounted virtual thread the thread can be NULL\n+  \/\/ In a case of unmounted virtual thread the thread can be NULL.\n@@ -136,1 +136,1 @@\n-  \/\/ save interp_only_mode\n+  \/\/ Save thread's interp_only_mode.\n@@ -138,1 +138,1 @@\n-  state->set_thread(NULL); \/\/ it is to make sure stale _thread value is never used\n+  state->set_thread(NULL);  \/\/ Make sure stale _thread value is never used.\n@@ -142,1 +142,1 @@\n-  \/\/ restore thread interp_only_mode\n+  \/\/ Restore thread's interp_only_mode.\n@@ -145,1 +145,1 @@\n-  \/\/ make continuation to notice the interp_only_mode change\n+  \/\/ Make continuation notice the interp_only_mode change.\n@@ -148,1 +148,1 @@\n-  \/\/ bind JavaThread to JvmtiThreadState\n+  \/\/ Bind JavaThread to JvmtiThreadState.\n@@ -152,1 +152,1 @@\n-    \/\/ bind to JavaThread\n+    \/\/ Bind to JavaThread.\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.inline.hpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/prims\/jvmtiTrace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/prims\/jvmtiUtil.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -174,0 +174,2 @@\n+static void print_frame_layout(const frame& f, bool callee_complete, outputStream* st = tty);\n+\n@@ -179,1 +181,0 @@\n-static void print_frame_layout(const frame& f, outputStream* st = tty);\n@@ -650,1 +651,1 @@\n-  return f.is_heap_frame() || is_sp_in_continuation(entry, f.unextended_sp());\n+  return is_sp_in_continuation(entry, f.unextended_sp());\n@@ -663,1 +664,1 @@\n-  return get_continuation_entry_for_sp(thread, f.unextended_sp()) != nullptr;\n+  return f.is_heap_frame() || (get_continuation_entry_for_sp(thread, f.unextended_sp()) != nullptr);\n@@ -690,1 +691,1 @@\n-  assert (ce != nullptr, \"\");\n+  assert(ce != nullptr, \"\");\n@@ -955,1 +956,1 @@\n-  inline void patch_chunk_pd(intptr_t* frame_sp, intptr_t* heap_sp);\n+  inline void patch_stack_pd(intptr_t* frame_sp, intptr_t* heap_sp);\n@@ -1166,2 +1167,3 @@\n-      \/\/ We copy the fp from the chunk back to the stack because it contains some caller data\n-      patch_chunk_pd(bottom_sp, chunk->sp_address());\n+      \/\/ We copy the fp from the chunk back to the stack because it contains some caller data,\n+      \/\/ including, possibly, an oop that might have gone stale since we thawed.\n+      patch_stack_pd(bottom_sp, chunk->sp_address());\n@@ -1401,1 +1403,1 @@\n-    DEBUG_ONLY(print_frame_layout(hf, &ls);)\n+    DEBUG_ONLY(print_frame_layout(hf, false, &ls);)\n@@ -1610,0 +1612,1 @@\n+  _align_size += frame::align_wiggle; \/\/ add alignment room for internal interpreted frame alignment om AArch64\n@@ -1628,1 +1631,1 @@\n-  \/\/ Mark frame_method's marking cycle for GC and redefinition on_stack calculation.\n+  \/\/ Mark frame_method's GC epoch for class redefinition on_stack calculation.\n@@ -1743,0 +1746,4 @@\n+  if (lt.develop_is_enabled()) {\n+    LogStream ls(lt);\n+    chunk->print_on(true, &ls);\n+  }\n@@ -1801,0 +1808,1 @@\n+  \/\/ assert that chunk is properly initialized\n@@ -1803,0 +1811,1 @@\n+  assert(chunk->sp() == chunk->stack_size(), \"\");\n@@ -1804,1 +1813,3 @@\n-\n+  assert(chunk->max_size() == 0, \"\");\n+  assert(chunk->pc() == nullptr, \"\");\n+  assert(chunk->argsize() == 0, \"\");\n@@ -1807,2 +1818,2 @@\n-  assert(chunk->max_size() == 0, \"\");\n-  assert(chunk->sp() == chunk->stack_size(), \"\");\n+\n+  chunk->set_mark(chunk->mark().set_age(15)); \/\/ Promote young chunks quickly\n@@ -2060,0 +2071,7 @@\n+static int thaw_size(stackChunkOop chunk) {\n+  int size = chunk->max_size();\n+  size += frame::metadata_words; \/\/ For the top pc+fp in push_return_frame or top = stack_sp - frame::metadata_words in thaw_fast\n+  size += 2*frame::align_wiggle; \/\/ in case of alignments at the top and bottom\n+  return size + 200;\n+}\n+\n@@ -2068,1 +2086,1 @@\n-  assert (ce != nullptr, \"\");\n+  assert(ce != nullptr, \"\");\n@@ -2076,1 +2094,2 @@\n-  \/\/ Comment needed: Why would the tail chunk be empty? Why do you get the parent?\n+  \/\/ The tail can be empty because it might still be available for another freeze.\n+  \/\/ However, here we want to thaw, so we get rid of it (it will be GCed).\n@@ -2086,0 +2105,1 @@\n+  assert(chunk->max_size() > 0, \"chunk invariant violated; expected to not be empty\");\n@@ -2087,8 +2107,2 @@\n-  \/\/ Only make space for the topmost chunk.\n-  int size = chunk->max_size();\n-  guarantee (size > 0, \"\");\n-\n-  \/\/ For the top pc+fp in push_return_frame or top = stack_sp - frame::metadata_words in thaw_fast\n-  size += frame::metadata_words;\n-  size += frame::align_wiggle; \/\/ just in case we have an interpreted entry after which we need to align\n-  size <<= LogBytesPerWord;\n+  \/\/ Only make space for the last chunk because we only thaw from the last chunk\n+  int size = thaw_size(chunk) << LogBytesPerWord;\n@@ -2117,0 +2131,1 @@\n+  DEBUG_ONLY(intptr_t* _top_stack_address);\n@@ -2133,0 +2148,2 @@\n+    assert (cont.tail() != nullptr, \"no last chunk\");\n+    DEBUG_ONLY(_top_stack_address = _cont.entrySP() - thaw_size(cont.tail());)\n@@ -2139,2 +2156,2 @@\n-  void patch_chunk(intptr_t* sp, bool is_last);\n-  void patch_chunk_pd(intptr_t* sp);\n+  void patch_return(intptr_t* sp, bool is_last);\n+  void patch_chunk_pd(intptr_t* sp); \/\/ TODO remove\n@@ -2190,3 +2207,0 @@\n-  \/\/ Comment in assert needed: is entryPC in the heap? or enterSpecial stub frame?\n-  assert(!Interpreter::contains(_cont.entryPC()), \"\");\n-\n@@ -2201,1 +2215,0 @@\n-  \/\/ I have no idea what config does in this function.\n@@ -2215,2 +2228,0 @@\n-  \/\/ TODO: explain why we're not setting the tail\n-\n@@ -2257,1 +2268,1 @@\n-    f.next(SmallRegisterMap::instance);\n+    f.next(SmallRegisterMap::instance, true \/* stop *\/);\n@@ -2268,2 +2279,3 @@\n-      address top_pc = *(address*)(chunk_sp + frame_size - frame::sender_sp_ret_address_offset());\n-      chunk->set_pc(top_pc);\n+      \/\/ We set chunk->pc to the return pc into the next frame\n+      chunk->set_pc(f.pc());\n+      assert(f.pc() == *(address*)(chunk_sp + frame_size - frame::sender_sp_ret_address_offset()), \"unexpected pc\");\n@@ -2275,0 +2287,1 @@\n+  \/\/ Are we thawing the last frame(s) in the continuation\n@@ -2284,0 +2297,3 @@\n+  \/\/ possibly adds a one-word padding between entrySP and the bottom-most frame's stack args\n+  \/\/ The only possible source of misalignment is stack-passed arguments because all compiled\n+  \/\/ frames are 16-byte aligned.\n@@ -2287,0 +2303,1 @@\n+  \/\/ also copy metadata words\n@@ -2290,3 +2307,5 @@\n-  assert(_cont.entrySP() - 1 <= to + thaw_size + frame::metadata_words, \"\");\n-  assert(to + thaw_size + frame::metadata_words <= _cont.entrySP(), \"\");\n-  assert(argsize != 0 || to + thaw_size + frame::metadata_words == _cont.entrySP(), \"\");\n+  \/\/ We assert we have not overwritten the entry frame, but that we're at most\n+  \/\/ one alignment word away from it.\n+  assert(to + thaw_size + frame::metadata_words <= _cont.entrySP(), \"overwritten entry frame\");\n+  assert(_cont.entrySP() - 1 <= to + thaw_size + frame::metadata_words, \"missed entry frame\");\n+  assert(argsize != 0 || to + thaw_size + frame::metadata_words == _cont.entrySP(), \"missed entry frame\");\n@@ -2295,1 +2314,1 @@\n-  _cont.set_argsize(argsize);\n+  _cont.set_argsize(argsize); \/\/ sets argsize in ContinuationEntry\n@@ -2297,1 +2316,1 @@\n-  patch_chunk(bottom_sp, is_last);\n+  assert(bottom_sp == _cont.entry()->bottom_sender_sp(), \"\");\n@@ -2299,0 +2318,2 @@\n+  \/\/ install the return barrier if not last frame, or the entry's pc if last\n+  patch_return(bottom_sp, is_last);\n@@ -2331,0 +2352,2 @@\n+  assert(to >= _top_stack_address, \"overwrote past thawing space\"\n+    \" to: \" INTPTR_FORMAT \" top_address: \" INTPTR_FORMAT, p2i(to), p2i(_top_stack_address));\n@@ -2333,1 +2356,1 @@\n-void ThawBase::patch_chunk(intptr_t* sp, bool is_last) {\n+void ThawBase::patch_return(intptr_t* sp, bool is_last) {\n@@ -2338,1 +2361,0 @@\n-\n@@ -2343,1 +2365,0 @@\n-\n@@ -2371,1 +2392,1 @@\n-    heap_frame.print_on(&ls);\n+    heap_frame.print_value_on(&ls, nullptr);\n@@ -2386,13 +2407,0 @@\n-\n-#ifdef ASSERT\n-  {\n-    frame f(sp);\n-    if (lt.develop_is_enabled()) {\n-      LogStream ls(lt);\n-      ls.print_cr(\"Jumping to frame (thaw): [\" JLONG_FORMAT \"]\", java_tid(_thread));\n-      f.print_on(&ls);\n-    }\n-    assert(f.is_interpreted_frame() || f.is_compiled_frame() || f.is_safepoint_blob_frame(), \"\");\n-  }\n-#endif\n-\n@@ -2476,1 +2484,1 @@\n-    hf.print_on(&ls);\n+    hf.print_value_on(&ls, nullptr);\n@@ -2482,0 +2490,1 @@\n+#ifdef ASSERT\n@@ -2486,1 +2495,1 @@\n-    f.print_on(&ls);\n+    print_frame_layout(f, false, &ls); \/\/ f.print_on(&ls);\n@@ -2488,0 +2497,1 @@\n+#endif\n@@ -2526,0 +2536,2 @@\n+  _align_size += frame::align_wiggle; \/\/ remove the added alignment room for internal interpreted frame alignment om AArch64\n+\n@@ -2553,8 +2565,0 @@\n-#ifdef ASSERT\n-  LogTarget(Trace, continuations) lt;\n-  if (lt.develop_is_enabled()) {\n-    LogStream ls(lt);\n-    print_frame_layout(f, &ls);\n-  }\n-#endif\n-\n@@ -2697,0 +2701,1 @@\n+    \/\/ Only remove chunk from list if it can't be reused for another freeze\n@@ -2724,1 +2729,1 @@\n-    _cont.last_frame().print_on(&ls);\n+    _cont.last_frame().print_value_on(&ls, nullptr);\n@@ -2736,1 +2741,1 @@\n-    f.print_on(&ls);\n+    f.print_value_on(&ls, nullptr);\n@@ -2739,4 +2744,3 @@\n-  intptr_t* sp = f.sp();\n-  address pc = f.raw_pc();\n-  *(address*)(sp - frame::sender_sp_ret_address_offset()) = pc;\n-  ContinuationHelper::Frame::patch_pc(f, pc); \/\/ in case we want to deopt the frame in a full transition, this is checked.\n+  assert(f.sp() - frame::metadata_words >= _top_stack_address, \"overwrote past thawing space\"\n+    \" to: \" INTPTR_FORMAT \" top_address: \" INTPTR_FORMAT, p2i(f.sp() - frame::metadata_words), p2i(_top_stack_address));\n+  ContinuationHelper::Frame::patch_pc(f, f.raw_pc()); \/\/ in case we want to deopt the frame in a full transition, this is checked.\n@@ -2759,1 +2763,1 @@\n-  assert (entry != nullptr, \"\");\n+  assert(entry != nullptr, \"\");\n@@ -2800,1 +2804,1 @@\n-    frame(sp).print_on(&ls);\n+    frame(sp).print_value_on(&ls, nullptr);\n@@ -2900,0 +2904,1 @@\n+  const static int show_entry_callers = 3;\n@@ -2926,0 +2931,1 @@\n+    int post_entry = -1;\n@@ -2928,0 +2934,4 @@\n+      if (post_entry >= 0 || Continuation::is_continuation_enterSpecial(f))\n+        post_entry++;\n+      if (post_entry >= show_entry_callers)\n+        break;\n@@ -2998,6 +3008,0 @@\n-#endif\n-\n-#ifndef PRODUCT\n-static jlong java_tid(JavaThread* thread) {\n-  return java_lang_Thread::thread_id(thread->threadObj());\n-}\n@@ -3005,1 +3009,1 @@\n-static void print_frame_layout(const frame& f, outputStream* st) {\n+static void print_frame_layout(const frame& f, bool callee_complete, outputStream* st) {\n@@ -3014,1 +3018,3 @@\n-  frame::update_map_with_saved_link(&map, ContinuationHelper::Frame::callee_link_address(f));\n+  if (callee_complete) {\n+    frame::update_map_with_saved_link(&map, ContinuationHelper::Frame::callee_link_address(f));\n+  }\n@@ -3020,0 +3026,6 @@\n+#ifndef PRODUCT\n+static jlong java_tid(JavaThread* thread) {\n+  return java_lang_Thread::thread_id(thread->threadObj());\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":93,"deletions":81,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-  void assert_absolute() const { assert(_frame_index == -1, \"Using absolute addresses with a chunk frame i: %d h: %d\", _frame_index, _on_heap); }\n+  void assert_absolute() const { assert(_frame_index == -1, \"Using absolute addresses with a chunk frame\"); }\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-  template <typename RegisterMapT> inline void next(RegisterMapT* map);\n+  template <typename RegisterMapT> inline void next(RegisterMapT* map, bool stop = false);\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-inline void StackChunkFrameStream<frame_kind>::next(RegisterMapT* map) {\n+inline void StackChunkFrameStream<frame_kind>::next(RegisterMapT* map, bool stop) {\n@@ -175,0 +175,5 @@\n+  DEBUG_ONLY(_index++;)\n+  if (stop) {\n+    return;\n+  }\n+\n@@ -177,2 +182,1 @@\n-  if (safepoint && cb() != nullptr) {\n-    \/\/ there's no post-call nop and no fast oopmap lookup\n+  if (safepoint && cb() != nullptr) { \/\/ there's no post-call nop and no fast oopmap lookup\n@@ -181,1 +185,0 @@\n-  DEBUG_ONLY(_index++;)\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.inline.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -154,1 +154,2 @@\n-      assert(oopDesc::is_oop_or_null(val), \"bad oop found at \" INTPTR_FORMAT, p2i(value_addr));\n+      assert(oopDesc::is_oop_or_null(val), \"bad oop found at \" INTPTR_FORMAT \" in_cont: %d compressed: %d\",\n+        p2i(value_addr), reg_map->in_cont(), reg_map->in_cont() && reg_map->stack_chunk()->has_bitmap() && UseCompressedOops);\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/DefaultPollerProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/ch\/DefaultPollerProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-        Objects.requireNonNull(in);\n+        super(in);\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-        Objects.requireNonNull(out);\n+        super(out);\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/java\/io\/FilterInputStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-import java.util.Objects;\n+import jdk.internal.misc.InternalLock;\n@@ -66,0 +66,14 @@\n+    \/**\n+     * Return the lock object for the given reader's stream decoder.\n+     * If the reader type is trusted then an internal lock can be used. If the\n+     * reader type is not trusted then the reader object is the lock.\n+     *\/\n+    private static Object lockFor(InputStreamReader reader) {\n+        Class<?> clazz = reader.getClass();\n+        if (clazz == InputStreamReader.class || clazz == FileReader.class) {\n+            return InternalLock.newLockOr(reader);\n+        } else {\n+            return reader;\n+        }\n+    }\n+\n@@ -75,2 +89,3 @@\n-        Objects.requireNonNull(in);\n-        sd = StreamDecoder.forInputStreamReader(in, lock, Charset.defaultCharset());\n+        super(in);\n+        Charset cs = Charset.defaultCharset();\n+        sd = StreamDecoder.forInputStreamReader(in, lockFor(this), cs);\n@@ -94,3 +109,4 @@\n-        Objects.requireNonNull(in);\n-        Objects.requireNonNull(charsetName, \"charsetName\");\n-        sd = StreamDecoder.forInputStreamReader(in, lock, charsetName);\n+        super(in);\n+        if (charsetName == null)\n+            throw new NullPointerException(\"charsetName\");\n+        sd = StreamDecoder.forInputStreamReader(in, lockFor(this), charsetName);\n@@ -108,3 +124,4 @@\n-        Objects.requireNonNull(in);\n-        Objects.requireNonNull(cs, \"charset\");\n-        sd = StreamDecoder.forInputStreamReader(in, lock, cs);\n+        super(in);\n+        if (cs == null)\n+            throw new NullPointerException(\"charset\");\n+        sd = StreamDecoder.forInputStreamReader(in, lockFor(this), cs);\n@@ -122,2 +139,4 @@\n-        Objects.requireNonNull(dec, \"charset decoder\");\n-        sd = StreamDecoder.forInputStreamReader(in, lock, dec);\n+        super(in);\n+        if (dec == null)\n+            throw new NullPointerException(\"charset decoder\");\n+        sd = StreamDecoder.forInputStreamReader(in, lockFor(this), dec);\n","filename":"src\/java.base\/share\/classes\/java\/io\/InputStreamReader.java","additions":31,"deletions":12,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-import java.util.Objects;\n+import jdk.internal.misc.InternalLock;\n@@ -79,0 +79,14 @@\n+    \/**\n+     * Return the lock object for the given writer's stream encoder.\n+     * If the writer type is trusted then an internal lock can be used. If the\n+     * writer type is not trusted then the writer object is the lock.\n+     *\/\n+    private static Object lockFor(OutputStreamWriter writer) {\n+        Class<?> clazz = writer.getClass();\n+        if (clazz == OutputStreamWriter.class || clazz == FileWriter.class) {\n+            return InternalLock.newLockOr(writer);\n+        } else {\n+            return writer;\n+        }\n+    }\n+\n@@ -94,3 +108,4 @@\n-        Objects.requireNonNull(out);\n-        Objects.requireNonNull(charsetName, \"charsetName\");\n-        se = StreamEncoder.forOutputStreamWriter(out, lock, charsetName);\n+        super(out);\n+        if (charsetName == null)\n+            throw new NullPointerException(\"charsetName\");\n+        se = StreamEncoder.forOutputStreamWriter(out, lockFor(this), charsetName);\n@@ -108,2 +123,2 @@\n-        Objects.requireNonNull(out);\n-        se = StreamEncoder.forOutputStreamWriter(out, lock,\n+        super(out);\n+        se = StreamEncoder.forOutputStreamWriter(out, lockFor(this),\n@@ -125,3 +140,4 @@\n-        Objects.requireNonNull(out);\n-        Objects.requireNonNull(cs, \"charset\");\n-        se = StreamEncoder.forOutputStreamWriter(out, lock, cs);\n+        super(out);\n+        if (cs == null)\n+            throw new NullPointerException(\"charset\");\n+        se = StreamEncoder.forOutputStreamWriter(out, lockFor(this), cs);\n@@ -142,3 +158,4 @@\n-        Objects.requireNonNull(out);\n-        Objects.requireNonNull(enc, \"charset encoder\");\n-        se = StreamEncoder.forOutputStreamWriter(out, lock, enc);\n+        super(out);\n+        if (enc == null)\n+            throw new NullPointerException(\"charset encoder\");\n+        se = StreamEncoder.forOutputStreamWriter(out, lockFor(this), enc);\n","filename":"src\/java.base\/share\/classes\/java\/io\/OutputStreamWriter.java","additions":30,"deletions":13,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -114,1 +114,2 @@\n-        this.out = Objects.requireNonNull(out);\n+        super(out);\n+        this.out = out;\n","filename":"src\/java.base\/share\/classes\/java\/io\/PrintWriter.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -157,10 +157,1 @@\n-        \/\/ use InternalLock for trusted classes\n-        Class<?> clazz = getClass();\n-        if (clazz == InputStreamReader.class\n-            || clazz == BufferedReader.class\n-            || clazz == FileReader.class\n-            || clazz == sun.nio.cs.StreamDecoder.class) {\n-            this.lock = InternalLock.newLockOr(this);\n-        } else {\n-            this.lock = this;\n-        }\n+        this.lock = this;\n@@ -176,1 +167,19 @@\n-        this.lock = Objects.requireNonNull(lock);\n+        if (lock == null) {\n+            throw new NullPointerException();\n+        }\n+        this.lock = lock;\n+    }\n+\n+    \/**\n+     * For use by BufferedReader to create a character-stream reader that uses an\n+     * internal lock when BufferedReader is not extended and the given reader is\n+     * trusted, otherwise critical sections will synchronize on the given reader.\n+     *\/\n+    Reader(Reader in) {\n+        Class<?> clazz = in.getClass();\n+        if (getClass() == BufferedReader.class &&\n+                (clazz == InputStreamReader.class || clazz == FileReader.class)) {\n+            this.lock = InternalLock.newLockOr(in);\n+        } else {\n+            this.lock = in;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/Reader.java","additions":20,"deletions":11,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-\n-import jdk.internal.misc.InternalLock;\n-\n@@ -32,0 +29,1 @@\n+import jdk.internal.misc.InternalLock;\n@@ -154,11 +152,1 @@\n-        \/\/ use InternalLock for trusted classes\n-        Class<?> clazz = getClass();\n-        if (clazz == OutputStreamWriter.class\n-                || clazz == BufferedWriter.class\n-                || clazz == FileWriter.class\n-                || clazz == PrintWriter.class\n-                || clazz == sun.nio.cs.StreamEncoder.class) {\n-            this.lock = InternalLock.newLockOr(this);\n-        } else {\n-            this.lock = this;\n-        }\n+        this.lock = this;\n@@ -175,1 +163,19 @@\n-        this.lock = Objects.requireNonNull(lock);\n+        if (lock == null) {\n+            throw new NullPointerException();\n+        }\n+        this.lock = lock;\n+    }\n+\n+    \/**\n+     * For use by BufferedWriter to create a character-stream writer that uses an\n+     * internal lock when BufferedWriter is not extended and the given writer is\n+     * trusted, otherwise critical sections will synchronize on the given writer.\n+     *\/\n+    Writer(Writer writer) {\n+        Class<?> clazz = writer.getClass();\n+        if (getClass() == BufferedWriter.class &&\n+                (clazz == OutputStreamWriter.class || clazz == FileWriter.class)) {\n+            this.lock = InternalLock.newLockOr(writer);\n+        } else {\n+            this.lock = writer;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/Writer.java","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * <p> This is a <a href=\"package-summary.html\">functional interface<\/a>\n+ * <p> This is a {@linkplain java.util.function functional interface}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Runnable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2169,6 +2169,1 @@\n-        \/\/ Subsystems that are invoked during initialization can invoke\n-        \/\/ VM.isBooted() in order to avoid doing things that should\n-        \/\/ wait until the VM is fully initialized. The initialization level\n-        \/\/ is incremented from 0 to 1 here to indicate the first phase of\n-        \/\/ initialization has completed.\n-        \/\/ IMPORTANT: Ensure that this remains the last initialization action!\n+        \/\/ system properties, java.lang and other core classes are now initialized\n@@ -2186,1 +2181,0 @@\n-     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.util.concurrent.RejectedExecutionException;\n@@ -39,1 +38,0 @@\n-\n@@ -57,1 +55,0 @@\n-\n@@ -92,0 +89,2 @@\n+ * <p> Platform threads get an automatically generated thread name by default.\n+ *\n@@ -96,3 +95,3 @@\n- * terminated. Unstarted daemon threads do not prevent the Java virtual machine from\n- * terminating. The Java virtual machine can also be terminated by invoking the\n- * {@linkplain Runtime#exit(int)} method, in which case it will terminate even\n+ * terminated. Unstarted non-daemon threads do not prevent the Java virtual machine\n+ * from terminating. The Java virtual machine can also be terminated by invoking\n+ * the {@linkplain Runtime#exit(int)} method, in which case it will terminate even\n@@ -105,2 +104,0 @@\n- * <p> Platform threads get an automatically generated thread name by default.\n- *\n@@ -110,4 +107,4 @@\n- * virtual machine rather than the operating system. Virtual threads will typically\n- * require few resources and a single Java virtual machine may support millions of\n- * virtual threads. Virtual threads are suitable for executing tasks that spend most\n- * of the time blocked, often waiting for I\/O operations to complete. Virtual threads\n+ * runtime rather than the operating system. Virtual threads will typically require\n+ * few resources and a single Java virtual machine may support millions of virtual\n+ * threads. Virtual threads are suitable for executing tasks that spend most of\n+ * the time blocked, often waiting for I\/O operations to complete. Virtual threads\n@@ -116,7 +113,4 @@\n- * <p> Virtual threads typically employ a small set of platform threads used\n- * as <em>carrier threads<\/em>. Locking and I\/O operations are the <i>scheduling\n- * points<\/i> where a carrier thread is re-scheduled from one virtual thread to\n- * another. Code executing in a virtual thread will usually not be aware of the\n- * underlying carrier thread, and in particular, the {@linkplain Thread#currentThread()}\n- * method, to obtain a reference to the <i>current thread<\/i>, will return the {@code\n- * Thread} object for the virtual thread, not the underlying carrier thread.\n+ * <p> Virtual threads typically employ a small set of platform threads used as\n+ * <em>carrier threads<\/em>. Locking and I\/O operations are examples of operations\n+ * where a carrier thread may be re-scheduled from one virtual thread to another.\n+ * Code executing in a virtual thread is not aware of underlying carrier thread.\n@@ -124,1 +118,12 @@\n- * <p> Virtual threads get an empty thread name by default.\n+ *\n+ * The {@linkplain Thread#currentThread()} method, used to obtain a reference\n+ * to the <i>current thread<\/i>, will always return the {@code Thread} object\n+ * for the virtual thread.\n+ *\n+ * <p> Virtual threads do not have a thread name by default. The {@link #getName()\n+ * getName} method returns the empty string if a thread name is not set.\n+ *\n+ * <p> Virtual threads are daemon threads and so do not prevent the Java virtual\n+ * machine from terminating. They have a fixed priority (see {@link #getPriority()\n+ * getPriority}). Virtual threads are not members of a thread group (see\n+ * {@link #getThreadGroup() getThreadGroup}).\n@@ -155,7 +160,20 @@\n- * <h2><a id=\"inheritance\">Inheritance<\/a><\/h2>\n- * Creating a {@code Thread} will inherit, by default, the initial values of\n- * {@linkplain InheritableThreadLocal inheritable-thread-local} variables\n- * (including the context class loader) from the parent thread. Platform threads\n- * inherit the daemon status and thread priority. Platform threads also inherit\n- * the thread group when a thread group is not provided (or not selected by a\n- * security manager).\n+ * <h2><a id=\"inheritance\">Inheritance when creating threads<\/a><\/h2>\n+ * A {@code Thread} inherits its initial values of {@linkplain InheritableThreadLocal\n+ * inheritable-thread-local} variables (including the context class loader) from\n+ * the parent thread values at the time that the child {@code Thread} is created.\n+ * The 5-param {@linkplain Thread#Thread(ThreadGroup, Runnable, String, long, boolean)\n+ * constructor} can be used to create a thread that does not inherit its initial\n+ * values from the constructing thread. When using a {@code Thread.Builder}, the\n+ * {@link Builder#inheritInheritableThreadLocals(boolean) inheritInheritableThreadLocals}\n+ * method can be used to select if the initial values are inherited.\n+ *\n+ * <p> Platform threads inherit the daemon status, thread priority, and when not\n+ * provided (or not selected by a security manager), the thread group.\n+ *\n+ * <p> Inherited Access Control Context:\n+ * Creating a platform thread {@linkplain AccessController#getContext() captures} the\n+ * {@linkplain AccessControlContext caller context} to limit the {@linkplain Permission\n+ * permissions} of {@linkplain AccessController#doPrivileged(PrivilegedAction) privileged\n+ * actions} performed by code in the thread. Creating a virtual thread does not capture\n+ * the caller context; virtual threads have no permissions when executing code that\n+ * performs privileged actions.\n@@ -852,1 +870,1 @@\n-         * {@link ThreadLocal#set(Object) set} method throws {@code\n+         * {@link ThreadLocal#set(Object)} method throws {@code\n@@ -855,1 +873,1 @@\n-         * setContextClassLoader} also throws. The {@link ThreadLocal#get() get} method\n+         * setContextClassLoader} also throws. The {@link ThreadLocal#get()} method\n@@ -897,1 +915,1 @@\n-         * @see <a href=\"Thread.html#inheritance\">Inheritance<\/a>\n+         * @see <a href=\"Thread.html#inheritance\">Inheritance when creating threads<\/a>\n@@ -904,0 +922,1 @@\n+         *\n@@ -906,1 +925,1 @@\n-         * @see <a href=\"Thread.html#inheritance\">Inheritance<\/a>\n+         * @see <a href=\"Thread.html#inheritance\">Inheritance when creating threads<\/a>\n@@ -923,0 +942,3 @@\n+         * <p> Unless otherwise specified, passing a null argument to a method in\n+         * this interface causes a {@code NullPointerException} to be thrown.\n+         *\n@@ -1008,2 +1030,2 @@\n-         * <p> Virtual threads created with a builder, or with a {@code ThreadFactory}\n-         * created from a builder, have no {@link Permission permissions}.\n+         * <p> Unless otherwise specified, passing a null argument to a method in\n+         * this interface causes a {@code NullPointerException} to be thrown.\n@@ -1028,5 +1050,0 @@\n-\n-            \/**\n-             * @throws RejectedExecutionException if the scheduler cannot accept a task\n-             *\/\n-            @Override Thread start(Runnable task);\n@@ -1092,1 +1109,1 @@\n-     * @see <a href=\"#inheritance\">Inheritance<\/a>\n+     * @see <a href=\"#inheritance\">Inheritance when creating threads<\/a>\n@@ -1113,1 +1130,1 @@\n-     * @see <a href=\"#inheritance\">Inheritance<\/a>\n+     * @see <a href=\"#inheritance\">Inheritance when creating threads<\/a>\n@@ -1155,1 +1172,1 @@\n-     * @see <a href=\"#inheritance\">Inheritance<\/a>\n+     * @see <a href=\"#inheritance\">Inheritance when creating threads<\/a>\n@@ -1172,1 +1189,1 @@\n-     * @see <a href=\"#inheritance\">Inheritance<\/a>\n+     * @see <a href=\"#inheritance\">Inheritance when creating threads<\/a>\n@@ -1201,1 +1218,1 @@\n-     * @see <a href=\"#inheritance\">Inheritance<\/a>\n+     * @see <a href=\"#inheritance\">Inheritance when creating threads<\/a>\n@@ -1223,1 +1240,1 @@\n-     * @see <a href=\"#inheritance\">Inheritance<\/a>\n+     * @see <a href=\"#inheritance\">Inheritance when creating threads<\/a>\n@@ -1277,1 +1294,1 @@\n-     * @see <a href=\"#inheritance\">Inheritance<\/a>\n+     * @see <a href=\"#inheritance\">Inheritance when creating threads<\/a>\n@@ -1359,1 +1376,1 @@\n-     * @see <a href=\"#inheritance\">Inheritance<\/a>\n+     * @see <a href=\"#inheritance\">Inheritance when creating threads<\/a>\n@@ -1424,1 +1441,1 @@\n-     * @see <a href=\"#inheritance\">Inheritance<\/a>\n+     * @see <a href=\"#inheritance\">Inheritance when creating threads<\/a>\n@@ -1436,2 +1453,0 @@\n-     * <p> The thread has no {@link Permission permissions}.\n-     *\n@@ -1444,1 +1459,1 @@\n-     * @see <a href=\"#inheritance\">Inheritance<\/a>\n+     * @see <a href=\"#inheritance\">Inheritance when creating threads<\/a>\n@@ -1471,4 +1486,3 @@\n-     * <p>\n-     * It is never legal to start a thread more than once.\n-     * In particular, a thread may not be restarted once it has completed\n-     * execution.\n+     *\n+     * <p> A thread can be started at most once. In particular, a thread can not\n+     * be restarted after it has terminated.\n@@ -1477,2 +1491,0 @@\n-     * @throws RejectedExecutionException if the thread is virtual and the\n-     *         scheduler cannot accept a task\n@@ -1522,5 +1534,2 @@\n-     * Run by the thread when it executes. Subclasses of {@code Thread} may override\n-     * this method. When not overridden, and this thread was created with a {@link\n-     * Runnable} task, then it invokes the task's {@link Runnable#run() run} method.\n-     * When not overridden and this thread was created without a {@code Runnable}\n-     * task then this method does nothing.\n+     * This method is run by the thread when it executes. Subclasses of {@code\n+     * Thread} may override this method.\n@@ -1529,1 +1538,1 @@\n-     * platform thread created with a {@code Runnable} task then invoking this method\n+     * platform thread created with a {@link Runnable} task then invoking this method\n@@ -1532,0 +1541,4 @@\n+     *\n+     * @implSpec The default implementation executes the {@link Runnable} task that\n+     * the {@code Thread} was created with. If the thread was created without a task\n+     * then this method does nothing.\n@@ -1555,1 +1568,1 @@\n-     * This method is called by the system to give a Thread\n+     * This method is called by the VM to give a Thread\n@@ -1928,5 +1941,7 @@\n-     * @implNote\n-     * If this thread is the current thread, and is a platform thread that isn't\n-     * mapped to a native thread attached to the VM with the Java Native Interface\n-     * {@code AttachCurrentThread} function, then a best effort attempt is made to\n-     * change the operating system thread name too.\n+     * @implNote In the JDK Reference Implementation, if this thread is the\n+     * current thread, and it's a platform thread that was not attached to the\n+     * VM with the Java Native Interface\n+     * <a href=\"{@docRoot}\/..\/specs\/jni\/invocation.html#attachcurrentthread\">\n+     * AttachCurrentThread<\/a> function, then this method will set the operating\n+     * system thread name. This may be useful for debugging and troubleshooting\n+     * purposes.\n@@ -1962,2 +1977,2 @@\n-     * Returns the thread group to which this thread belongs.\n-     * This method returns null if the thread has terminated.\n+     * Returns the thread's thread group or {@code null} if the thread has\n+     * terminated.\n@@ -1965,1 +1980,20 @@\n-     * @return  this thread's thread group.\n+     * <p> Virtual threads are not members of a thread group. If invoked on a\n+     * virtual thread that has not terminated, this method returns a special\n+     * thread group that behaves as follows:\n+     * <ul>\n+     *  <li> There are no {@linkplain ThreadGroup#activeCount() active} virtual\n+     *       threads in the thread group. The {@link ThreadGroup#enumerate(Thread[])\n+     *       enumerate} method does not enumerate virtual threads.\n+     *  <li> There may be active platform threads in the thread group. The thread\n+     *       group may be provided when creating a platform thread, the thread group\n+     *       may be <a href=\"Thread.html#inheritance\">inherited<\/a> when a\n+     *       virtual thread creates a platform thread, or the thread group may\n+     *       be inherited when a platform thread in the thread group creates\n+     *       another platform thread.\n+     *  <li> The {@linkplain ThreadGroup#getMaxPriority() maximum priority} of\n+     *       the thread group is {@link Thread#NORM_PRIORITY} when initially\n+     *       created. Changing the maximum priority of the thread group has no\n+     *       impact on the priority of virtual threads.\n+     * <\/ul>\n+     *\n+     * @return  this thread's thread group or {@code null}\n@@ -2643,10 +2677,0 @@\n-     * @since 19\n-     *\/\n-    public final long threadId() {\n-        return tid;\n-    }\n-\n-    \/**\n-     * Returns the identifier of this Thread obtained by invoking {@link #threadId()}.\n-     *\n-     * @return this thread's ID\n@@ -2664,0 +2688,12 @@\n+    \/**\n+     * Returns the identifier of this Thread.  The thread ID is a positive\n+     * {@code long} number generated when this thread was created.\n+     * The thread ID is unique and remains unchanged during its lifetime.\n+     *\n+     * @return this thread's ID\n+     * @since 19\n+     *\/\n+    public final long threadId() {\n+        return tid;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":117,"deletions":81,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -68,1 +68,2 @@\n-     * @see <a href=\"..\/..\/lang\/Thread.html#inheritance\">Inheritance<\/a>\n+     * @see <a href=\"..\/..\/lang\/Thread.html#inheritance\">Inheritance when\n+     * creating threads<\/a>\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadFactory.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-                VirtualThreads.unpark(thread); \/\/ can throw RejectedExecutionException\n+                VirtualThreads.unpark(thread);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/LockSupport.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,2 +33,4 @@\n- * java.util.concurrent.locks.ReentrantLock} so that it can be used for\n- * special handling in the {@link java.io} classes.\n+ * java.util.concurrent.locks.ReentrantLock} so that it can be distinguished\n+ * from lock objects accessible to subclasses of {@link java.io.Reader} and\n+ * {@link java.io.Writer} (it is possible to create a Reader that uses a\n+ * lock object of type ReentrantLock for example).\n@@ -36,1 +38,0 @@\n-\n@@ -38,1 +39,9 @@\n-    private final ReentrantLock lock = new ReentrantLock();\n+    private static final boolean CAN_USE_INTERNAL_LOCK;\n+    static {\n+        String s = System.getProperty(\"jdk.io.useMonitors\");\n+        if (s != null && (s.isEmpty() || s.equals(\"true\"))) {\n+            CAN_USE_INTERNAL_LOCK = false;\n+        } else {\n+            CAN_USE_INTERNAL_LOCK = true;\n+        }\n+    }\n@@ -40,2 +49,1 @@\n-    \/\/ may have this configurable via system property\n-    private static final boolean CAN_USE_INTERNAL_LOCK = true;\n+    private final ReentrantLock lock;\n@@ -43,1 +51,3 @@\n-    private InternalLock() { }\n+    private InternalLock() {\n+        this.lock = new ReentrantLock();\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/InternalLock.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * Defines static methods to allow code in java.base to cretae or throw\n+ * Defines static methods to allow code in java.base to create or throw\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/StructureViolationExceptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.io.ByteArrayOutputStream;\n@@ -50,0 +51,3 @@\n+    \/\/ the maximum byte array to return when generating the thread dump to a byte array\n+    private static final int MAX_BYTE_ARRAY_SIZE = 16_000;\n+\n@@ -51,1 +55,1 @@\n-     * Generate a thread dump in plain text format to the given file, UTF-8 encoded.\n+     * Generate a thread dump in plain text format to a byte array or file, UTF-8 encoded.\n@@ -54,0 +58,4 @@\n+     *\n+     * @param file the file path to the file, null or \"-\" to return a byte array\n+     * @param okayToOverwrite true to overwrite an existing file\n+     * @return the UTF-8 encoded thread dump or message to return to the user\n@@ -56,1 +64,5 @@\n-        return dumpThreads(file, okayToOverwrite, false);\n+        if (file == null || file.equals(\"-\")) {\n+            return dumpThreadsToByteArray(false, MAX_BYTE_ARRAY_SIZE);\n+        } else {\n+            return dumpThreadsToFile(file, okayToOverwrite, false);\n+        }\n@@ -60,1 +72,1 @@\n-     * Generate a thread dump in JSON format to the given file, UTF-8 encoded.\n+     * Generate a thread dump in JSON format to a byte array or file, UTF-8 encoded.\n@@ -63,0 +75,4 @@\n+     *\n+     * @param file the file path to the file, null or \"-\" to return a byte array\n+     * @param okayToOverwrite true to overwrite an existing file\n+     * @return the UTF-8 encoded thread dump or message to return to the user\n@@ -65,1 +81,20 @@\n-        return dumpThreads(file, okayToOverwrite, true);\n+        if (file == null || file.equals(\"-\")) {\n+            return dumpThreadsToByteArray(true, MAX_BYTE_ARRAY_SIZE);\n+        } else {\n+            return dumpThreadsToFile(file, okayToOverwrite, true);\n+        }\n+    }\n+\n+    \/**\n+     * Generate a thread dump in plain text or JSON format to a byte array, UTF-8 encoded.\n+     *\/\n+    private static byte[] dumpThreadsToByteArray(boolean json, int maxSize) {\n+        try (var out = new BoundedByteArrayOutputStream(maxSize);\n+             PrintStream ps = new PrintStream(out, true, StandardCharsets.UTF_8)) {\n+            if (json) {\n+                dumpThreadsToJson(ps);\n+            } else {\n+                dumpThreads(ps);\n+            }\n+            return out.toByteArray();\n+        }\n@@ -71,1 +106,1 @@\n-    private static byte[] dumpThreads(String file, boolean okayToOverwrite, boolean json) {\n+    private static byte[] dumpThreadsToFile(String file, boolean okayToOverwrite, boolean json) {\n@@ -288,0 +323,27 @@\n+    \/**\n+     * A ByteArrayOutputStream of bounded size. Once the maximum number of bytes is\n+     * written the subsequent bytes are discarded.\n+     *\/\n+    private static class BoundedByteArrayOutputStream extends ByteArrayOutputStream {\n+        final int max;\n+        BoundedByteArrayOutputStream(int max) {\n+            this.max = max;\n+        }\n+        @Override\n+        public void write(int b) {\n+            if (max < count) {\n+                super.write(b);\n+            }\n+        }\n+        @Override\n+        public void write(byte[] b, int off, int len) {\n+            int remaining = max - count;\n+            if (remaining > 0) {\n+                super.write(b, off, Integer.min(len, remaining));\n+            }\n+        }\n+        @Override\n+        public void close() {\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadDumper.java","additions":67,"deletions":5,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/ChangesCurrentThread.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/JvmtiMountTransition.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-            if (nanos == 0) {\n+            if (nanos <= 0) {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SelChImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,0 +127,1 @@\n+        Object lock = this.lock;\n@@ -168,0 +169,1 @@\n+        Object lock = this.lock;\n@@ -220,0 +222,1 @@\n+        Object lock = this.lock;\n@@ -240,0 +243,1 @@\n+        Object lock = this.lock;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/StreamDecoder.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,0 +110,1 @@\n+        Object lock = this.lock;\n@@ -118,1 +119,1 @@\n-            synchronized (super.lock) {\n+            synchronized (lock) {\n@@ -138,0 +139,1 @@\n+        Object lock = this.lock;\n@@ -146,1 +148,1 @@\n-            synchronized (super.lock) {\n+            synchronized (lock) {\n@@ -175,0 +177,1 @@\n+            Object lock = this.lock;\n@@ -183,1 +186,1 @@\n-                synchronized (super.lock) {\n+                synchronized (lock) {\n@@ -198,0 +201,1 @@\n+        Object lock = this.lock;\n@@ -218,0 +222,1 @@\n+        Object lock = this.lock;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/StreamEncoder.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLLogger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/native\/libjava\/RandomAccessFile.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/native\/libjava\/StackTraceElement.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/native\/libjava\/VirtualThread.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/DefaultPollerProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1591,20 +1591,20 @@\n-      \/*\n-       * If the node is in neither list, the debugger never suspended\n-       * this thread, so the suspend count is 0, unless it is a vthread.\n-       *\/\n-      if (isVThread(thread)) {\n-          jint vthread_state = 0;\n-          jvmtiError error = threadState(thread, &vthread_state);\n-          if (error != JVMTI_ERROR_NONE) {\n-              EXIT_ERROR(error, \"getting thread state\");\n-          }\n-          if (vthread_state == 0) {\n-              \/\/ If state == 0, then this is a new vthread that has not been started yet.\n-              *count = 0;\n-          } else {\n-              \/\/ This is a started vthread that we are not tracking. Use suspendAllCount.\n-              *count = suspendAllCount;\n-          }\n-      } else {\n-        *count = 0;\n-      }\n+        \/*\n+         * If the node is in neither list, the debugger never suspended\n+         * this thread, so the suspend count is 0, unless it is a vthread.\n+         *\/\n+        if (isVThread(thread)) {\n+            jint vthread_state = 0;\n+            jvmtiError error = threadState(thread, &vthread_state);\n+            if (error != JVMTI_ERROR_NONE) {\n+                EXIT_ERROR(error, \"getting thread state\");\n+            }\n+            if (vthread_state == 0) {\n+                \/\/ If state == 0, then this is a new vthread that has not been started yet.\n+                *count = 0;\n+            } else {\n+                \/\/ This is a started vthread that we are not tracking. Use suspendAllCount.\n+                *count = suspendAllCount;\n+            }\n+        } else {\n+            *count = 0;\n+        }\n@@ -1804,1 +1804,1 @@\n-             * vthreads with a suspendCount > 0. Therefor we don't want\n+             * vthreads with a suspendCount > 0. Therefore we don't want\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,34 +42,0 @@\n-    private Path genThreadDumpPath(String suffix) throws IOException {\n-        Path dir = Path.of(\".\").toAbsolutePath();\n-        Path file = Files.createTempFile(dir, \"threads-\", suffix);\n-        Files.delete(file);\n-        return file;\n-    }\n-\n-    private OutputAnalyzer threadDump(Path file, String... options) {\n-        String cmd = \"Thread.dump_to_file\";\n-        for (String option : options) {\n-            cmd += \" \" + option;\n-        }\n-        return new PidJcmdExecutor().execute(cmd + \" \" + file);\n-    }\n-\n-    private boolean find(Path file, String text) throws IOException {\n-        try (Stream<String> stream = Files.lines(file)) {\n-            return  stream.anyMatch(line -> line.indexOf(text) >= 0);\n-        }\n-    }\n-\n-    \/**\n-     * Test thread dump in plain text format.\n-     *\/\n-    private void testPlainThreadDump(Path file, String... options) throws IOException {\n-        threadDump(file, options).shouldMatch(\"Created\");\n-\n-        \/\/ test that thread dump contains the name and id of the current thread\n-        String name = Thread.currentThread().getName();\n-        long tid = Thread.currentThread().getId();\n-        String expected = \"#\" + tid + \" \\\"\" + name + \"\\\"\";\n-        assertTrue(find(file, expected), expected + \" not found in \" + file);\n-    }\n-\n@@ -134,0 +100,34 @@\n+\n+    \/**\n+     * Test thread dump in plain text format.\n+     *\/\n+    private void testPlainThreadDump(Path file, String... options) throws IOException {\n+        threadDump(file, options).shouldMatch(\"Created\");\n+\n+        \/\/ test that thread dump contains the name and id of the current thread\n+        String name = Thread.currentThread().getName();\n+        long tid = Thread.currentThread().getId();\n+        String expected = \"#\" + tid + \" \\\"\" + name + \"\\\"\";\n+        assertTrue(find(file, expected), expected + \" not found in \" + file);\n+    }\n+\n+    private Path genThreadDumpPath(String suffix) throws IOException {\n+        Path dir = Path.of(\".\").toAbsolutePath();\n+        Path file = Files.createTempFile(dir, \"threads-\", suffix);\n+        Files.delete(file);\n+        return file;\n+    }\n+\n+    private OutputAnalyzer threadDump(Path file, String... options) {\n+        String cmd = \"Thread.dump_to_file\";\n+        for (String option : options) {\n+            cmd += \" \" + option;\n+        }\n+        return new PidJcmdExecutor().execute(cmd + \" \" + file);\n+    }\n+\n+    private boolean find(Path file, String text) throws IOException {\n+        try (Stream<String> stream = Files.lines(file)) {\n+            return  stream.anyMatch(line -> line.indexOf(text) >= 0);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/thread\/ThreadDumpToFileTest.java","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n- * @build jdk.test.lib.helpers.ClassFileInstaller jdk.test.lib.compiler.InMemoryJavaCompiler\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/ClassVersionAfterRedefine.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n- * @build jdk.test.lib.helpers.ClassFileInstaller jdk.test.lib.compiler.InMemoryJavaCompiler\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineAddLambdaExpression.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n- * @build jdk.test.lib.helpers.ClassFileInstaller jdk.test.lib.compiler.InMemoryJavaCompiler\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineDoubleDelete.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n- * @build jdk.test.lib.helpers.ClassFileInstaller jdk.test.lib.compiler.InMemoryJavaCompiler\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineFinalizer.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n- * @build jdk.test.lib.helpers.ClassFileInstaller jdk.test.lib.compiler.InMemoryJavaCompiler\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineInterfaceCall.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n- * @build jdk.test.lib.helpers.ClassFileInstaller jdk.test.lib.compiler.InMemoryJavaCompiler\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineInterfaceMethods.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n- * @compile --enable-preview -source ${jdk.version} RedefineRunningMethods.java\n@@ -36,0 +35,1 @@\n+ * @compile --enable-preview -source ${jdk.version} RedefineRunningMethods.java\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineRunningMethods.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n- * @compile --enable-preview -source ${jdk.version} RedefineRunningMethodsWithBacktrace.java\n- * @build jdk.test.lib.helpers.ClassFileInstaller jdk.test.lib.compiler.InMemoryJavaCompiler\n@@ -37,0 +35,1 @@\n+ * @compile --enable-preview -source ${jdk.version} RedefineRunningMethodsWithBacktrace.java\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineRunningMethodsWithBacktrace.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n- * @build jdk.test.lib.helpers.ClassFileInstaller jdk.test.lib.compiler.InMemoryJavaCompiler\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineRunningMethodsWithResolutionErrors.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n- * @build jdk.test.lib.helpers.ClassFileInstaller jdk.test.lib.compiler.InMemoryJavaCompiler\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineSubtractLambdaExpression.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n- * @build jdk.test.lib.helpers.ClassFileInstaller jdk.test.lib.compiler.InMemoryJavaCompiler\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/TestAddDeleteMethods.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n- * @build jdk.test.lib.helpers.ClassFileInstaller jdk.test.lib.compiler.InMemoryJavaCompiler\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/TestMultipleClasses.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n- * @build jdk.test.lib.helpers.ClassFileInstaller jdk.test.lib.compiler.InMemoryJavaCompiler\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/TestRedefineCondy.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-        if (result !=0 ) {\n+        if (result != 0 ) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/Breakpoint\/breakpoint01\/breakpoint01.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -187,19 +187,0 @@\n-\/*\n-void JNICALL\n-MethodEntry(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread, jmethodID method) {\n-\n-  int p = ((long) method \/ 128 % 100);\n-  if (p < 1) {\n-    RawMonitorLocker rml(jvmti, jni, monitor);\n-    if (is_vm_running) {\n-      jvmtiThreadInfo thread_info;\n-      check_jvmti_status(jni, jvmti->GetThreadInfo(thread, &thread_info), \"Error in GetThreadInfo11\");\n-      if (strcmp(\"main\", thread_info.name) == 0) {\n-        \/\/ Skip main() method entries\n-        return;\n-      }\n-      check_reset_tls(jvmti, jni, thread, \"MethodEntry\");\n-    }\n-  }\n-}\n-*\/\n@@ -267,1 +248,0 @@\n-  \/\/ callbacks.MethodEntry = &MethodEntry;\n@@ -282,2 +262,0 @@\n-  \/\/jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_ENTRY, NULL);\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/stress\/ThreadLocalStorage\/SetGetThreadLocalStorageStressTest\/libSetGetThreadLocalStorageStress.cpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -132,3 +132,0 @@\n-      \/\/== name &&\n-        \/\/  (idx == POINT_AGENT_THREAD || strlen(name) ==\n-          \/\/    strlen(expected_thread_info[idx].thr_names[i]));\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetAllThreads\/allthr01\/liballthr01.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-        Thread.sleep(100); \/\/ 10 is not enough as it intermittently fails with smaller frames count\n+        Thread.sleep(100);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetFrameCount\/framecnt01\/framecnt01.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,2 +63,0 @@\n-\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetFrameLocation\/frameloc02\/frameloc02.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -220,2 +220,0 @@\n-\n-  \/\/ TODO set somehow configure\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/SuspendThreadList\/suspendthrdlst01\/libsuspendthrdlst01.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,2 +68,0 @@\n-            \/\/ System.out.println(\"======>>>>>\\n\" + jstackOutput + \"\\n<<<<<========\");\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbInspect.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-static jboolean printdump = JNI_TRUE;\n+static jboolean printdump = JNI_FALSE;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClassPrepare\/classprep001\/classprep001.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -116,9 +116,0 @@\n-#if 0\n-    \/\/ Check removed: the concept of daemon thread group no longer exists.\n-    if (daemon != inf.is_daemon) {\n-        printf(\"(%d) unexpected is_daemon: %s,\", stage,\n-            (inf.is_daemon == JNI_TRUE) ? \"true\" : \"false\");\n-        printf(\" expected: %s\\n\", (daemon == JNI_TRUE) ? \"true\" : \"false\");\n-        result = STATUS_FAILED;\n-    }\n-#endif\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadGroupInfo\/thrgrpinfo001\/thrgrpinfo001.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+            \"java.lang.Thread.clearReferences\",\n@@ -78,0 +79,2 @@\n+            \"java.lang.Thread.threadContainer\",\n+            \"jdk.internal.misc.Blocker.end\",\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace001.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -85,0 +85,2 @@\n+            \"java.lang.Thread.threadContainer\",\n+            \"jdk.internal.misc.Blocker.end\",\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace002.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -128,0 +128,1 @@\n+            \"jdk.internal.misc.Blocker.end\",\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace003.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -121,0 +121,1 @@\n+            \"jdk.internal.misc.Blocker.end\",\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace004.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-com\/sun\/crypto\/provider\/Cipher\/AEAD\/GCMBufferTest.java 8283022 generic-all\n-\n@@ -38,1 +36,1 @@\n-java\/lang\/ref\/ReferenceEnqueue.java                    8284236 generic-all\n\\ No newline at end of file\n+java\/lang\/ref\/ReferenceEnqueue.java                    8284236 generic-all\n","filename":"test\/jdk\/ProblemList-Xcomp.txt","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\n+##########\n+## Tests failing when main() is executed in additional vthread or in vthread instead of thread\n+#\n+\n+com\/sun\/jdi\/DeferredStepTest.java\n+com\/sun\/jdi\/EarlyReturnTest.java\n+com\/sun\/jdi\/ExceptionEvents.java\n+com\/sun\/jdi\/FetchLocals.java\n+com\/sun\/jdi\/Frames2Test.java\n+com\/sun\/jdi\/GetSetLocalTest.java\n+com\/sun\/jdi\/JdbMethodExitTest.java\n+com\/sun\/jdi\/JdbStepTest.java\n+com\/sun\/jdi\/JdbStopThreadTest.java\n+com\/sun\/jdi\/JdbStopThreadidTest.java\n+com\/sun\/jdi\/LaunchCommandLine.java\n+com\/sun\/jdi\/MethodEntryExitEvents.java\n+com\/sun\/jdi\/MultiBreakpointsTest.java\n+com\/sun\/jdi\/NativeInstanceFilter.java\n+com\/sun\/jdi\/PopAndStepTest.java\n+com\/sun\/jdi\/PopAsynchronousTest.java\n+com\/sun\/jdi\/PopSynchronousTest.java\n+com\/sun\/jdi\/RedefineCrossStart.java\n+com\/sun\/jdi\/RedefineG.java\n+com\/sun\/jdi\/RedefineNestmateAttr\/TestNestmateAttr.java\n+com\/sun\/jdi\/RedefineTTYLineNumber.java\n+com\/sun\/jdi\/ReferrersTest.java\n+com\/sun\/jdi\/ResumeAfterThreadResumeCallTest.java\n+com\/sun\/jdi\/SetLocalWhileThreadInNative.java\n+com\/sun\/jdi\/StepTest.java\n+com\/sun\/jdi\/redefine\/RedefineTest.java\n+com\/sun\/jdi\/redefineMethod\/RedefineTest.java\n+\n+####\n+# JDI SDE Tests\n+# Use custom classpath\n+\n+com\/sun\/jdi\/sde\/FilterMangleTest.java\n+com\/sun\/jdi\/sde\/MangleTest.java\n+com\/sun\/jdi\/sde\/MangleStepTest.java\n+com\/sun\/jdi\/sde\/TemperatureTableTest.java\n+com\/sun\/jdi\/sde\/SourceDebugExtensionTest.java\n","filename":"test\/jdk\/ProblemList-svc-vthread.txt","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -460,2 +460,4 @@\n-        if (System.getProperty(\"main.wrapper\") != null) {\n-            argInfo.targetAppCommandLine  = TestScaffold.class.getName() + \" \" + System.getProperty(\"main.wrapper\") + \" \";\n+        String mainWrapper = System.getProperty(\"main.wrapper\");\n+        if (\"Virtual\".equals(mainWrapper)) {\n+            argInfo.targetAppCommandLine = TestScaffold.class.getName() + \" \" + mainWrapper + \" \";\n+            argInfo.targetVMArgs += \"--enable-preview \";\n","filename":"test\/jdk\/com\/sun\/jdi\/TestScaffold.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+ * @run main\/othervm\/timeout=300 --enable-preview -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. -XX:+PreserveFramePointer Fuzz\n@@ -41,2 +42,0 @@\n-\/\/ * @run main\/othervm\/timeout=300 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. Fuzz\n-\n@@ -439,0 +438,4 @@\n+        \/\/ if (VERBOSE) {\n+        \/\/     System.out.println(\">>>> RESULT\");\n+        \/\/     f0.verbose = true;\n+        \/\/ }\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Fuzz.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -14,1 +14,5 @@\n-# CALL_C_DBL, CALL_C_INT, CALL_C_MANY, YIELD, CALL_C_MANY, CALL_C_MANY, CALL_C_CTCH, CALL_C_INT, YIELD, CALL_C_MANY, YIELD, CALL_C_DBL, YIELD, CALL_C_INT, CALL_C_MANY, CALL_C_INT, YIELD, YIELD, CALL_C_CTCH, CALL_C_INT, CALL_C_DBL, CALL_C_MANY, CALL_C_CTCH, CALL_C_CTCH, YIELD, CALL_C_INT, CALL_C_CTCH, YIELD, LOOP, CALL_C_INT, CALL_C_CTCH, CALL_C_DBL, CALL_C_CTCH, CALL_C_INT, CALL_C_DBL, LOOP, CALL_C_MANY, CALL_C_INT, LOOP, LOOP, CALL_C_DBL, LOOP, CALL_C_INT, CALL_C_MANY, CALL_C_DBL, CALL_C_INT, CALL_C_MANY, CALL_C_CTCH, CALL_C_MANY, YIELD, LOOP, YIELD\n\\ No newline at end of file\n+CALL_C_DBL, CALL_C_MANY, CALL_C_INT, CALL_C_DBL, YIELD, CALL_C_INT, CALL_C_MANY, CALL_C_MANY, CALL_C_DBL, CALL_C_MANY, CALL_C_CTCH, CALL_C_DBL, LOOP, CALL_C_CTCH, LOOP, CALL_C_INT, CALL_C_INT, CALL_C_MANY, YIELD, CALL_C_MANY, CALL_C_CTCH, LOOP, CALL_C_INT, CALL_C_INT, LOOP, YIELD, CALL_C_CTCH, YIELD, CALL_C_INT, CALL_C_MANY, YIELD, CALL_C_CTCH, CALL_C_CTCH, LOOP, CALL_C_CTCH, CALL_C_MANY, CALL_C_INT, CALL_C_MANY, LOOP, YIELD, LOOP, CALL_C_MANY, CALL_C_INT, CALL_C_INT, YIELD, CALL_C_DBL, CALL_C_MANY\n+# CALL_C_DBL, CALL_C_INT, CALL_C_MANY, YIELD, CALL_C_MANY, CALL_C_MANY, CALL_C_CTCH, CALL_C_INT, YIELD, CALL_C_MANY, YIELD, CALL_C_DBL, YIELD, CALL_C_INT, CALL_C_MANY, CALL_C_INT, YIELD, YIELD, CALL_C_CTCH, CALL_C_INT, CALL_C_DBL, CALL_C_MANY, CALL_C_CTCH, CALL_C_CTCH, YIELD, CALL_C_INT, CALL_C_CTCH, YIELD, LOOP, CALL_C_INT, CALL_C_CTCH, CALL_C_DBL, CALL_C_CTCH, CALL_C_INT, CALL_C_DBL, LOOP, CALL_C_MANY, CALL_C_INT, LOOP, LOOP, CALL_C_DBL, LOOP, CALL_C_INT, CALL_C_MANY, CALL_C_DBL, CALL_C_INT, CALL_C_MANY, CALL_C_CTCH, CALL_C_MANY, YIELD, LOOP, YIELD\n+\n+MH_I_MANY, YIELD, CALL_I_INT, YIELD\n+CALL_I_MANY, CALL_C_CTCH, LOOP, LOOP, CALL_I_DBL, CALL_I_INT, CALL_C_DBL, CALL_C_INT, CALL_I_CTCH, LOOP, CALL_I_INT, CALL_C_CTCH, YIELD, CALL_C_INT, CALL_C_MANY, CALL_C_MANY, CALL_I_MANY, MH_I_MANY, CALL_I_INT, CALL_C_MANY, CALL_C_CTCH, CALL_C_MANY, CALL_I_MANY, MH_I_MANY, YIELD, CALL_I_CTCH, CALL_I_CTCH, CALL_C_DBL, CALL_C_MANY, CALL_I_CTCH, YIELD, CALL_I_CTCH, CALL_C_DBL, CALL_C_INT, CALL_I_DBL, CALL_C_MANY, LOOP, CALL_C_DBL, MH_C_MANY, CALL_I_INT, CALL_I_INT, CALL_C_DBL, LOOP, CALL_C_MANY, CALL_C_CTCH, CALL_I_MANY, CALL_I_CTCH, CALL_I_CTCH\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/fuzz.dat","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,148 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang;\n-\n-import jdk.internal.vm.Continuation;\n-import jdk.internal.vm.ContinuationScope;\n-\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.Arrays;\n-import java.util.Objects;\n-\n-public class PreemptLiveFrames {\n-    public static void main(String[] args) {\n-        try {\n-            PreemptLiveFrames obj = new PreemptLiveFrames();\n-            obj.test1();\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    static final ContinuationScope FOO = new ContinuationScope() {};\n-    CountDownLatch startLatch = new CountDownLatch(1);\n-    volatile boolean run;\n-    volatile int x;\n-\n-    public void test1() throws Exception {\n-        System.out.println(\"test1\");\n-\n-        final AtomicInteger result = new AtomicInteger(0);\n-        final Continuation cont = new Continuation(FOO, ()-> {\n-                double r = 0;\n-                int k = 1;\n-                int x = 3;\n-                String s = \"abc\";\n-                r += foo(k);\n-                result.set((int)r);\n-            });\n-\n-        final Thread t0 = Thread.currentThread();\n-        Thread t = new Thread(() -> {\n-            try {\n-                startLatch.await();\n-\n-                Continuation.PreemptStatus res;\n-                int i = 0;\n-                do {\n-                    res = cont.tryPreempt(t0);\n-                    i++;\n-                } while (i < 100 && res == Continuation.PreemptStatus.TRANSIENT_FAIL_PINNED_NATIVE);\n-                assertEquals(res, Continuation.PreemptStatus.SUCCESS);\n-                \/\/ assertEquals(res, Continuation.PreemptStatus.SUCCESS);\n-            } catch (InterruptedException e) {\n-                throw new RuntimeException(e);\n-            }\n-        });\n-        t.start();\n-\n-        run = true;\n-\n-        cont.run();\n-        assertEquals(cont.isDone(), false);\n-        assertEquals(cont.isPreempted(), true);\n-\n-        testStackWalk(LiveStackFrame.getStackWalker(cont));\n-\n-        t.join();\n-    }\n-\n-    double foo(int a) {\n-        long x = 8;\n-        String s = \"yyy\";\n-        String r = bar(a + 1);\n-        return Integer.parseInt(r)+1;\n-    }\n-\n-    String bar(long b) {\n-        double x = 9.99;\n-        String s = \"zzz\";\n-        String r = baz(b + 1);\n-        return \"\" + r;\n-    }\n-\n-    String baz(long b) {\n-        double x = 9.99;\n-        String s = \"zzz\";\n-\n-        loop();\n-\n-        long r = b+1;\n-        return \"\" + r;\n-    }\n-\n-    void loop() {\n-        while (run) {\n-            x++;\n-            if (startLatch.getCount() > 0) {\n-                startLatch.countDown();\n-            }\n-        }\n-    }\n-\n-    static void testStackWalk(StackWalker walker) {\n-        \/\/ StackWalker walker = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n-        System.out.println(\"^&^ start\");\n-        walker.forEach(f -> {\n-            try {\n-                System.out.println(\"^&^ --==--\");\n-                \/\/ System.out.println(\"^&^ \" + f);\n-                LiveStackFrame lf = (LiveStackFrame)f;\n-                System.out.println(\"^&^ locals: \" + Arrays.toString(lf.getLocals()));\n-                System.out.println(\"^&^ stack: \" + Arrays.toString(lf.getStack()));\n-            } catch (Throwable t) {\n-                t.printStackTrace();\n-                throw t;\n-            }\n-        });\n-        System.out.println(\"^&^ end\");\n-    }\n-\n-    static void assertEquals(Object actual, Object expected) {\n-        if (!Objects.equals(actual, expected)) {\n-            throw new AssertionError(\"Expected: \" + expected + \", actual: \" + actual);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/java.base\/java\/lang\/PreemptLiveFrames.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"deleted"},{"patch":"@@ -246,4 +246,0 @@\n-        if (vmCompMode().equals(\"Xint\")) {\n-            return \"false\";\n-        }\n-\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -317,0 +317,2 @@\n+        \/\/ When test is executed with process wrapper the line is changed to\n+        \/\/ java <jvm-args> jdk.test.lib.process.ProcessTools <test-class>\n@@ -367,2 +369,0 @@\n-                \/\/ Should be main\n-                \/\/ System.out.println(\"Wrapped TOFIND: \" + cmd);\n@@ -767,0 +767,1 @@\n+    \/\/ It executes method main in a separate virtual or platform thread\n@@ -777,0 +778,2 @@\n+            \/\/ MainThreadGroup used just as a container for exceptions\n+            \/\/ when main is executed in virtual thread\n@@ -778,1 +781,0 @@\n-            \/\/ TODO fix to set virtual scheduler group when become available\n@@ -788,0 +790,3 @@\n+            if (tg.uncaughtThrowable != null) {\n+                throw new RuntimeException(tg.uncaughtThrowable);\n+            }\n","filename":"test\/lib\/jdk\/test\/lib\/process\/ProcessTools.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"}]}