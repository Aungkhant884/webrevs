{"files":[{"patch":"@@ -35,1 +35,3 @@\n-  static CodeBlob* cb = CodeCache::find_blob(entry_pc());\n+  static CodeBlob* cb = CodeCache::find_blob_fast(entry_pc());\n+  assert(cb != nullptr, \"\");\n+  assert(cb->as_compiled_method()->method()->is_continuation_enter_intrinsic(), \"\");\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationEntry_aarch64.inline.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,0 +88,2 @@\n+    \/\/ If the caller.is_empty(), i.e. we're freezing into an empty chunk, then we set\n+    \/\/ the chunk's argsize in finalize_freeze and make room for it above the unextended_sp\n@@ -108,0 +110,2 @@\n+      \/\/ If the caller is interpreted, our stackargs are not supposed to overlap with it\n+      \/\/ so we make more room by moving sp down by argsize\n@@ -177,0 +181,3 @@\n+    \/\/ If we're the bottom-most frame frozen in this freeze, the caller might have stayed frozen in the chunk,\n+    \/\/ and its oop-containing fp fixed. We've now just overwritten it, so we must patch it back to its value\n+    \/\/ as read from the chunk.\n@@ -213,0 +220,1 @@\n+    int padding = 0;\n@@ -216,0 +224,1 @@\n+      padding++;\n@@ -222,1 +231,2 @@\n-    \/\/ it's set again later in derelativize_interpreted_frame_metadata, but we need to set the locals now so that we'll have the frame's bottom\n+    \/\/ it's set again later in set_interpreter_frame_bottom, but we need to set the locals now so that\n+    \/\/ we could call ContinuationHelper::InterpretedFrame::frame_bottom\n@@ -224,2 +234,3 @@\n-    assert((int)offset == locals + frame::sender_sp_offset - 1, \"\");\n-    *(intptr_t**)f.addr_at(frame::interpreter_frame_locals_offset) = fp + offset;\n+    assert((int)offset == frame::sender_sp_offset + locals - 1, \"\");\n+    \/\/ derelativize locals\n+    *(intptr_t**)f.addr_at(frame::interpreter_frame_locals_offset) = fp + padding + offset;\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -162,0 +162,6 @@\n+    if (Continuation::is_return_barrier_entry(sender_pc)) {\n+      \/\/ If our sender_pc is the return barrier, then our \"real\" sender is the continuation entry\n+      frame s = Continuation::continuation_bottom_sender(thread, *this, sender_sp);\n+      sender_sp = s.sp();\n+      sender_pc = s.pc();\n+    }\n@@ -450,1 +456,1 @@\n-      Continuation::fix_continuation_bottom_sender(map->thread(), *this, &sender_pc, &unextended_sp);\n+      return Continuation::continuation_bottom_sender(map->thread(), *this, sender_sp);\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -457,1 +457,1 @@\n-      Continuation::fix_continuation_bottom_sender(map->thread(), *this, &sender_pc, &l_sender_sp);\n+      return Continuation::continuation_bottom_sender(map->thread(), *this, l_sender_sp);\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6532,0 +6532,1 @@\n+    \/\/ We've succeeded, set sp to the ContinuationEntry\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,1 +35,3 @@\n-  static CodeBlob* cb = CodeCache::find_blob(entry_pc());\n+  static CodeBlob* cb = CodeCache::find_blob_fast(entry_pc());\n+  assert(cb != nullptr, \"\");\n+  assert(cb->as_compiled_method()->method()->is_continuation_enter_intrinsic(), \"\");\n","filename":"src\/hotspot\/cpu\/x86\/continuationEntry_x86.inline.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,0 +85,2 @@\n+    \/\/ If the caller.is_empty(), i.e. we're freezing into an empty chunk, then we set\n+    \/\/ the chunk's argsize in finalize_freeze and make room for it above the unextended_sp\n@@ -86,1 +88,1 @@\n-    fp = caller.unextended_sp() - (locals + frame::sender_sp_offset) + (overlap_caller ?  ContinuationHelper::InterpretedFrame::stack_argsize(f) : 0);\n+    fp = caller.unextended_sp() - (locals + frame::sender_sp_offset) + (overlap_caller ? ContinuationHelper::InterpretedFrame::stack_argsize(f) : 0);\n@@ -105,0 +107,2 @@\n+      \/\/ If the caller is interpreted, our stackargs are not supposed to overlap with it\n+      \/\/ so we make more room by moving sp down by argsize\n@@ -175,0 +179,3 @@\n+    \/\/ If we're the bottom-most frame frozen in this freeze, the caller might have stayed frozen in the chunk,\n+    \/\/ and its oop-containing fp fixed. We've now just overwritten it, so we must patch it back to its value\n+    \/\/ as read from the chunk.\n@@ -215,1 +222,2 @@\n-    \/\/ it's set again later in derelativize_interpreted_frame_metadata, but we need to set the locals now so that we'll have the frame's bottom\n+    \/\/ it's set again later in set_interpreter_frame_bottom, but we need to set the locals now so that\n+    \/\/ we could call ContinuationHelper::InterpretedFrame::frame_bottom\n@@ -217,1 +225,2 @@\n-    assert((int)offset == locals + frame::sender_sp_offset - 1, \"\");\n+    assert((int)offset == frame::sender_sp_offset + locals - 1, \"\");\n+    \/\/ derelativize locals\n","filename":"src\/hotspot\/cpu\/x86\/continuationFreezeThaw_x86.inline.hpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -154,1 +154,4 @@\n-      Continuation::fix_continuation_bottom_sender(thread, *this, &sender_pc, &sender_sp);\n+      \/\/ If our sender_pc is the return barrier, then our \"real\" sender is the continuation entry\n+      frame s = Continuation::continuation_bottom_sender(thread, *this, sender_sp);\n+      sender_sp = s.sp();\n+      sender_pc = s.pc();\n@@ -470,1 +473,1 @@\n-      Continuation::fix_continuation_bottom_sender(map->thread(), *this, &sender_pc, &unextended_sp);\n+      return Continuation::continuation_bottom_sender(map->thread(), *this, sender_sp);\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -442,1 +442,1 @@\n-      Continuation::fix_continuation_bottom_sender(map->thread(), *this, &sender_pc, &sender_sp);\n+      return Continuation::continuation_bottom_sender(map->thread(), *this, sender_sp);\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1458,4 +1458,1 @@\n-  __ push(rbp);\n-  if (PreserveFramePointer) {\n-    __ mov(rbp, rsp);\n-  }\n+  __ enter();\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -5065,1 +5065,1 @@\n-int jdk_internal_vm_StackChunk::_maxSize_offset;\n+int jdk_internal_vm_StackChunk::_maxThawingSize_offset;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1129,4 +1129,4 @@\n-  macro(jdk_internal_vm_StackChunk, cont,    continuation_signature, false)  \\\n-  macro(jdk_internal_vm_StackChunk, flags,   byte_signature, false)          \\\n-  macro(jdk_internal_vm_StackChunk, pc,      intptr_signature, false)        \\\n-  macro(jdk_internal_vm_StackChunk, maxSize, int_signature, false)           \\\n+  macro(jdk_internal_vm_StackChunk, cont,           continuation_signature, false)  \\\n+  macro(jdk_internal_vm_StackChunk, flags,          byte_signature, false)          \\\n+  macro(jdk_internal_vm_StackChunk, pc,             intptr_signature, false)        \\\n+  macro(jdk_internal_vm_StackChunk, maxThawingSize, int_signature, false)           \\\n@@ -1143,1 +1143,1 @@\n-  static int _maxSize_offset;\n+  static int _maxThawingSize_offset;\n@@ -1178,2 +1178,2 @@\n-  static inline int maxSize(oop chunk);\n-  static inline void set_maxSize(oop chunk, int value);\n+  static inline int maxThawingSize(oop chunk);\n+  static inline void set_maxThawingSize(oop chunk, int value);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -365,2 +365,2 @@\n-inline int jdk_internal_vm_StackChunk::maxSize(oop chunk) {\n-  return chunk->int_field(_maxSize_offset);\n+inline int jdk_internal_vm_StackChunk::maxThawingSize(oop chunk) {\n+  return chunk->int_field(_maxThawingSize_offset);\n@@ -369,1 +369,1 @@\n-inline void jdk_internal_vm_StackChunk::set_maxSize(oop chunk, int value) {\n+inline void jdk_internal_vm_StackChunk::set_maxThawingSize(oop chunk, int value) {\n@@ -371,1 +371,1 @@\n-  jint old = maxSize(chunk);\n+  jint old = maxThawingSize(chunk);\n@@ -374,1 +374,1 @@\n-  chunk->int_field_put(_maxSize_offset, value);\n+  chunk->int_field_put(_maxThawingSize_offset, value);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -528,0 +528,1 @@\n+  template(maxThawingSize_name,                       \"maxThawingSize\")                           \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-               c->stack_size(), c->argsize(), c->max_size(), c->sp(), p2i(c->pc()));\n+               c->stack_size(), c->argsize(), c->max_thawing_size(), c->sp(), p2i(c->pc()));\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -361,3 +361,0 @@\n-  if (f.is_done()) {\n-    return;\n-  }\n@@ -573,1 +570,1 @@\n-    assert(max_size() == 0, \"\");\n+    assert(max_thawing_size() == 0, \"\");\n@@ -615,1 +612,1 @@\n-    assert(max_size() == calculated_max_size,\n+    assert(max_thawing_size() == calculated_max_size,\n@@ -617,1 +614,1 @@\n-           max_size(), calculated_max_size, closure._argsize, closure._num_i2c);\n+           max_thawing_size(), calculated_max_size, closure._argsize, closure._num_i2c);\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+  \/\/ FLAG_HAS_INTERPRETED_FRAMES actually means \"thaw slow because of some content-based chunk condition\"\n+  \/\/ It is set whenever we freeze slow, but generally signifies there might be interpreted\/deoptimized\/stub frames\n@@ -89,2 +91,2 @@\n-  inline int max_size() const;\n-  inline void set_max_size(int value);\n+  inline int max_thawing_size() const;\n+  inline void set_max_thawing_size(int value);\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -79,2 +79,2 @@\n-inline int stackChunkOopDesc::max_size() const          { return jdk_internal_vm_StackChunk::maxSize(as_oop()); }\n-inline void stackChunkOopDesc::set_max_size(int value)  {\n+inline int stackChunkOopDesc::max_thawing_size() const          { return jdk_internal_vm_StackChunk::maxThawingSize(as_oop()); }\n+inline void stackChunkOopDesc::set_max_thawing_size(int value)  {\n@@ -82,1 +82,1 @@\n-  jdk_internal_vm_StackChunk::set_maxSize(this, (jint)value);\n+  jdk_internal_vm_StackChunk::set_maxThawingSize(this, (jint)value);\n@@ -120,1 +120,4 @@\n-  return sp() >= stack_size() - argsize();\n+  assert(sp() <= stack_size(), \"\");\n+  assert((sp() == stack_size()) == (sp() >= stack_size() - argsize()),\n+    \"sp: %d size: %d argsize: %d\", sp(), stack_size(), argsize());\n+  return sp() == stack_size();\n@@ -154,2 +157,5 @@\n-inline bool stackChunkOopDesc::has_mixed_frames() const            { return is_flag(FLAG_HAS_INTERPRETED_FRAMES); }\n-inline void stackChunkOopDesc::set_has_mixed_frames(bool value)    { set_flag(FLAG_HAS_INTERPRETED_FRAMES, value); }\n+inline bool stackChunkOopDesc::has_mixed_frames() const { return is_flag(FLAG_HAS_INTERPRETED_FRAMES); }\n+inline void stackChunkOopDesc::set_has_mixed_frames(bool value) {\n+  assert((flags() & ~FLAG_HAS_INTERPRETED_FRAMES) == 0, \"other flags should not be set\");\n+  set_flag(FLAG_HAS_INTERPRETED_FRAMES, value);\n+}\n@@ -310,2 +316,2 @@\n-  assert(to >= start_address(), \"\");\n-  assert(to + size <= end_address(), \"\");\n+  assert(to >= start_address(), \"Chunk underflow\");\n+  assert(to + size <= end_address(), \"Chunk overflow\");\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -284,17 +284,13 @@\n-bool Continuation::fix_continuation_bottom_sender(JavaThread* thread, const frame& callee,\n-                                                  address* sender_pc, intptr_t** sender_sp) {\n-  if (thread != nullptr && is_return_barrier_entry(*sender_pc)) {\n-    ContinuationEntry* ce = get_continuation_entry_for_sp(thread,\n-          callee.is_interpreted_frame() ? callee.interpreter_frame_last_sp() : callee.unextended_sp());\n-    assert(ce != nullptr, \"callee.unextended_sp(): \" INTPTR_FORMAT, p2i(callee.unextended_sp()));\n-\n-    log_develop_debug(continuations)(\"fix_continuation_bottom_sender: \"\n-                                  \"[\" JLONG_FORMAT \"] [%d]\", java_tid(thread), thread->osthread()->thread_id());\n-    log_develop_trace(continuations)(\"sender_pc: \" INTPTR_FORMAT \" -> \" INTPTR_FORMAT, p2i(*sender_pc), p2i(ce->entry_pc()));\n-    log_develop_trace(continuations)(\"sender_sp: \" INTPTR_FORMAT \" -> \" INTPTR_FORMAT, p2i(*sender_sp), p2i(ce->entry_sp()));\n-\n-    *sender_pc = ce->entry_pc();\n-    *sender_sp = ce->entry_sp();\n-    \/\/ We DO NOT fix FP. It could contain an oop that has changed on the stack, and its location should be OK anyway\n-\n-    return true;\n+frame Continuation::continuation_bottom_sender(JavaThread* thread, const frame& callee, intptr_t* sender_sp) {\n+  assert (thread != nullptr, \"\");\n+  ContinuationEntry* ce = get_continuation_entry_for_sp(thread,\n+        callee.is_interpreted_frame() ? callee.interpreter_frame_last_sp() : callee.unextended_sp());\n+  assert(ce != nullptr, \"callee.unextended_sp(): \" INTPTR_FORMAT, p2i(callee.unextended_sp()));\n+\n+  log_develop_debug(continuations)(\"continuation_bottom_sender: [\" JLONG_FORMAT \"] [%d] callee: \" INTPTR_FORMAT\n+    \" sender_sp: \" INTPTR_FORMAT,\n+    java_tid(thread), thread->osthread()->thread_id(), p2i(callee.sp()), p2i(sender_sp));\n+\n+  frame entry = ce->to_frame();\n+  if (callee.is_interpreted_frame()) {\n+    entry.set_sp(sender_sp); \/\/ sp != unextended_sp\n@@ -302,1 +298,1 @@\n-  return false;\n+  return entry;\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-  static bool fix_continuation_bottom_sender(JavaThread* thread, const frame& callee, address* sender_pc, intptr_t** sender_sp);\n+  static frame continuation_bottom_sender(JavaThread* thread, const frame& callee, intptr_t* sender_sp);\n","filename":"src\/hotspot\/share\/runtime\/continuation.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+    assert(cb != nullptr, \"sp: \" INTPTR_FORMAT \" pc: \" INTPTR_FORMAT, p2i(sp), p2i(pc));\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -175,0 +175,12 @@\n+#define assert_pfl(p, ...) \\\n+do {                                           \\\n+  if (!(p)) {                                  \\\n+    JavaThread* t = JavaThread::active();      \\\n+    if (t->has_last_Java_frame()) {            \\\n+      tty->print_cr(\"assert(\" #p \") failed:\"); \\\n+      t->print_frame_layout();                 \\\n+    }                                          \\\n+  }                                            \\\n+  vmassert(p, __VA_ARGS__);                    \\\n+} while(0)\n+\n@@ -177,0 +189,1 @@\n+#define assert_pfl(p, ...)\n@@ -337,1 +350,1 @@\n-  bool _barriers;\n+  bool _barriers; \/\/ only set when we allocate a chunk\n@@ -419,0 +432,8 @@\n+\n+#ifdef ASSERT\n+  bool is_empty(stackChunkOop chunk) {\n+    \/\/ during freeze, the chunk is in an intermediate state (after setting the chunk's argsize but before setting its\n+    \/\/ ultimate sp) so we use this instead of stackChunkOopDesc::is_empty\n+    return chunk->sp() >= chunk->stack_size() - chunk->argsize();\n+  }\n+#endif\n@@ -443,1 +464,0 @@\n-  _bottom_address = _cont.entrySP() - _cont.argsize();\n@@ -448,0 +468,1 @@\n+  _bottom_address = _cont.entrySP() - _cont.argsize();\n@@ -463,1 +484,2 @@\n-  assert(StubRoutines::cont_doYield_stub()->frame_size() == frame::metadata_words, \"\");\n+  static const int doYield_stub_frame_size = frame::metadata_words;\n+  assert(StubRoutines::cont_doYield_stub()->frame_size() == doYield_stub_frame_size, \"\");\n@@ -466,1 +488,1 @@\n-  _cont_stack_top    = frame_sp + frame::metadata_words; \/\/ we add metadata_words to skip the doYield stub frame\n+  _cont_stack_top    = frame_sp + doYield_stub_frame_size; \/\/ we don't freeze the doYield stub frame\n@@ -540,0 +562,1 @@\n+\n@@ -541,0 +564,5 @@\n+\n+  \/\/ argsize can be nonzero if we have a caller, but the caller could be in a non-empty parent chunk,\n+  \/\/ so we subtract it only if we overlap with the caller, i.e. the current chunk isn't empty.\n+  \/\/ Consider leaving the chunk's argsize set when emptying it and removing the following branch,\n+  \/\/ although that would require changing stackChunkOopDesc::is_empty\n@@ -545,1 +573,2 @@\n-  bool available = chunk_sp - frame::metadata_words >= total_size_needed;\n+  int chunk_free_room = chunk_sp - frame::metadata_words;\n+  bool available = chunk_free_room >= total_size_needed;\n@@ -568,1 +597,1 @@\n-    chunk->set_max_size(chunk->max_size() + cont_size() - _cont.argsize());\n+    chunk->set_max_thawing_size(chunk->max_thawing_size() + cont_size() - _cont.argsize());\n@@ -588,1 +617,1 @@\n-    chunk->set_max_size(cont_size());\n+    chunk->set_max_thawing_size(cont_size());\n@@ -606,1 +635,1 @@\n-  chunk->set_max_size(cont_size());\n+  chunk->set_max_thawing_size(cont_size());\n@@ -707,1 +736,1 @@\n-  frame caller;\n+  frame caller; \/\/ the frozen caller in the chunk\n@@ -789,1 +818,5 @@\n-  if (FKind::frame_bottom(f) >= _bottom_address - 1) { \/\/ sometimes there's space after enterSpecial\n+  assert(FKind::frame_bottom(f) <= _bottom_address, \"\");\n+\n+  \/\/ We don't use FKind::frame_bottom(f) == _bottom_address because on x64 there's sometimes an extra word between\n+  \/\/ enterSpecial and an interpreted frame\n+  if (FKind::frame_bottom(f) >= _bottom_address - 1) {\n@@ -805,1 +838,1 @@\n-    f.print_on(&ls);\n+    f.print_value_on(&ls, nullptr);\n@@ -840,1 +873,1 @@\n-  assert(chunk == nullptr || (chunk->max_size() == 0) == chunk->is_empty(), \"\");\n+  assert(chunk == nullptr || (chunk->max_thawing_size() == 0) == chunk->is_empty(), \"\");\n@@ -849,0 +882,2 @@\n+      StackChunkFrameStream<ChunkFrames::Mixed> last(chunk);\n+      unextended_sp = chunk->to_offset(StackChunkFrameStream<ChunkFrames::Mixed>(chunk).unextended_sp());\n@@ -850,5 +885,0 @@\n-      unextended_sp = chunk->sp();\n-      if (top_interpreted) {\n-        StackChunkFrameStream<ChunkFrames::Mixed> last(chunk);\n-        unextended_sp += last.unextended_sp() - last.sp(); \/\/ can be negative (-1), often with lambda forms\n-      }\n@@ -870,2 +900,4 @@\n-    \/\/ _barriers can be set to true by an allocation in freeze_fast, in which case the chunk is available\n-  assert(!_barriers || (unextended_sp >= _freeze_size && chunk->is_empty()),\n+  \/\/ _barriers can be set to true by an allocation in freeze_fast, in which case the chunk is available\n+  bool allocated_old_in_freeze_fast = _barriers;\n+  assert(!allocated_old_in_freeze_fast || (unextended_sp >= _freeze_size && chunk->is_empty()),\n+    \"Chunk allocated in freeze_fast is of insufficient size \"\n@@ -873,0 +905,1 @@\n+  assert(!allocated_old_in_freeze_fast || (!UseZGC && !UseG1GC), \"Unexpected allocation\");\n@@ -875,2 +908,2 @@\n-  if (unextended_sp < _freeze_size || chunk->is_gc_mode() || (!_barriers && chunk->requires_barriers())) {\n-    \/\/ ALLOCATION\n+  if (unextended_sp < _freeze_size || chunk->is_gc_mode() || (!allocated_old_in_freeze_fast && chunk->requires_barriers())) {\n+    \/\/ ALLOCATE NEW CHUNK\n@@ -903,1 +936,1 @@\n-    assert(chunk->is_empty(), \"\");\n+    assert(is_empty(chunk), \"\");\n@@ -905,0 +938,1 @@\n+    \/\/ REUSE EXISTING CHUNK\n@@ -911,1 +945,1 @@\n-      assert(chunk->max_size() == 0, \"\");\n+      assert(chunk->max_thawing_size() == 0, \"\");\n@@ -914,0 +948,2 @@\n+  assert(!chunk->is_gc_mode(), \"\");\n+  assert(!chunk->has_bitmap(), \"\");\n@@ -917,1 +953,1 @@\n-  assert(!_barriers || chunk->is_empty(), \"\");\n+  assert(!_barriers || is_empty(chunk), \"\");\n@@ -919,3 +955,2 @@\n-  assert(!chunk->has_bitmap(), \"\");\n-  assert(!chunk->is_empty() || StackChunkFrameStream<ChunkFrames::Mixed>(chunk).is_done(), \"\");\n-  assert(!chunk->is_empty() || StackChunkFrameStream<ChunkFrames::Mixed>(chunk).to_frame().is_empty(), \"\");\n+  assert(!is_empty(chunk) || StackChunkFrameStream<ChunkFrames::Mixed>(chunk).is_done(), \"\");\n+  assert(!is_empty(chunk) || StackChunkFrameStream<ChunkFrames::Mixed>(chunk).to_frame().is_empty(), \"\");\n@@ -928,1 +963,1 @@\n-  chunk->set_max_size(chunk->max_size() + _freeze_size - frame::metadata_words);\n+  chunk->set_max_thawing_size(chunk->max_thawing_size() + _freeze_size - frame::metadata_words);\n@@ -936,0 +971,1 @@\n+  \/\/ The topmost existing frame in the chunk; or an empty frame if the chunk is empty\n@@ -962,0 +998,2 @@\n+    \/\/ If we're the bottom frame, we need to replace the return barrier with the real\n+    \/\/ caller's pc.\n@@ -963,1 +1001,1 @@\n-    assert((last_pc == nullptr) == _cont.tail()->is_empty(), \"\");\n+    assert((last_pc == nullptr) == is_empty(_cont.tail()), \"\");\n@@ -1003,1 +1041,2 @@\n-  intptr_t* const frame_sp = ContinuationHelper::InterpretedFrame::frame_top(f, callee_argsize, callee_interpreted);\n+  \/\/ The frame's top never includes the stack arguments to the callee\n+  intptr_t* const frame_top = ContinuationHelper::InterpretedFrame::frame_top(f, callee_argsize, callee_interpreted);\n@@ -1007,1 +1046,1 @@\n-  const int fsize = f.fp() + frame::metadata_words + locals - frame_sp;\n+  const int fsize = f.fp() + frame::metadata_words + locals - frame_top;\n@@ -1009,1 +1048,1 @@\n-  DEBUG_ONLY(verify_frame_top(f, frame_sp));\n+  DEBUG_ONLY(verify_frame_top(f, frame_top));\n@@ -1024,0 +1063,1 @@\n+  assert(!caller.is_empty() || bottom, \"\");\n@@ -1030,2 +1070,2 @@\n-  intptr_t* heap_sp = ContinuationHelper::InterpretedFrame::frame_top(hf, callee_argsize, callee_interpreted);\n-  assert(ContinuationHelper::InterpretedFrame::frame_bottom(hf) == heap_sp + fsize, \"\");\n+  intptr_t* heap_top = ContinuationHelper::InterpretedFrame::frame_top(hf, callee_argsize, callee_interpreted);\n+  assert(ContinuationHelper::InterpretedFrame::frame_bottom(hf) == heap_top + fsize, \"\");\n@@ -1036,2 +1076,2 @@\n-  copy_to_chunk(frame_sp, heap_sp, fsize - locals); \/\/ copy rest\n-  assert(!bottom || !caller.is_interpreted_frame() || (heap_sp + fsize) == (caller.unextended_sp() + argsize), \"\");\n+  copy_to_chunk(frame_top, heap_top, fsize - locals); \/\/ copy rest\n+  assert(!bottom || !caller.is_interpreted_frame() || (heap_top + fsize) == (caller.unextended_sp() + argsize), \"\");\n@@ -1054,1 +1094,2 @@\n-  intptr_t* const frame_sp = ContinuationHelper::CompiledFrame::frame_top(f, callee_argsize, callee_interpreted);\n+  \/\/ The frame's top never includes the stack arguments to the callee\n+  intptr_t* const frame_top = ContinuationHelper::CompiledFrame::frame_top(f, callee_argsize, callee_interpreted);\n@@ -1056,1 +1097,1 @@\n-  const int fsize = ContinuationHelper::CompiledFrame::frame_bottom(f) + argsize - frame_sp;\n+  const int fsize = ContinuationHelper::CompiledFrame::frame_bottom(f) + argsize - frame_top;\n@@ -1071,0 +1112,1 @@\n+  assert(!caller.is_empty() || bottom, \"\");\n@@ -1076,1 +1118,1 @@\n-  intptr_t* heap_sp = ContinuationHelper::CompiledFrame::frame_top(hf, callee_argsize, callee_interpreted);\n+  intptr_t* heap_top = ContinuationHelper::CompiledFrame::frame_top(hf, callee_argsize, callee_interpreted);\n@@ -1078,2 +1120,2 @@\n-  copy_to_chunk(frame_sp, heap_sp, fsize);\n-  assert(!bottom || !caller.is_compiled_frame() || (heap_sp + fsize) == (caller.unextended_sp() + argsize), \"\");\n+  copy_to_chunk(frame_top, heap_top, fsize);\n+  assert(!bottom || !caller.is_compiled_frame() || (heap_top + fsize) == (caller.unextended_sp() + argsize), \"\");\n@@ -1095,1 +1137,1 @@\n-  intptr_t* const frame_sp = ContinuationHelper::StubFrame::frame_top(f, 0, 0);\n+  intptr_t* const frame_top = ContinuationHelper::StubFrame::frame_top(f, 0, 0);\n@@ -1099,1 +1141,1 @@\n-    f.cb()->name(), _freeze_size, fsize, p2i(frame_sp), p2i(frame_sp+fsize));\n+    f.cb()->name(), _freeze_size, fsize, p2i(frame_top), p2i(frame_top+fsize));\n@@ -1127,2 +1169,2 @@\n-  intptr_t* heap_sp = ContinuationHelper::StubFrame::frame_top(hf, 0, 0);\n-  copy_to_chunk(frame_sp, heap_sp, fsize);\n+  intptr_t* heap_top = ContinuationHelper::StubFrame::frame_top(hf, 0, 0);\n+  copy_to_chunk(frame_top, heap_top, fsize);\n@@ -1151,1 +1193,3 @@\n-  chunk->set_max_size(chunk->max_size() + _total_align_size);\n+  chunk->set_max_thawing_size(chunk->max_thawing_size() + _total_align_size);\n+\n+  \/\/ At this point the chunk is consistent\n@@ -1155,1 +1199,1 @@\n-    \/\/ ParallelGC can allocate objects directly into the old generation.\n+    \/\/ Serial and Parallel GC can allocate objects directly into the old generation.\n@@ -1162,0 +1206,1 @@\n+    \/\/ For objects in the old generation we must maintain the remembered set\n@@ -1184,1 +1229,1 @@\n-  if ((address)&t < t->stack_overflow_state()->stack_overflow_limit()) {\n+  if (os::current_stack_pointer() < t->stack_overflow_state()->stack_overflow_limit()) {\n@@ -1230,1 +1275,1 @@\n-  assert(chunk->max_size() == 0, \"\");\n+  assert(chunk->max_thawing_size() == 0, \"\");\n@@ -1319,0 +1364,2 @@\n+  \/\/ This is done for the sake of the enterSpecial frame\n+  StackWatermarkSet::after_unwind(thread);\n@@ -1381,1 +1428,0 @@\n-    StackWatermarkSet::after_unwind(current);\n@@ -1397,1 +1443,0 @@\n-    StackWatermarkSet::after_unwind(current);\n@@ -1461,1 +1506,1 @@\n-  int size = chunk->max_size();\n+  int size = chunk->max_thawing_size();\n@@ -1464,1 +1509,1 @@\n-  return size + 200;\n+  return size;\n@@ -1494,1 +1539,1 @@\n-  assert(chunk->max_size() > 0, \"chunk invariant violated; expected to not be empty\");\n+  assert(chunk->max_thawing_size() > 0, \"chunk invariant violated; expected to not be empty\");\n@@ -1519,1 +1564,1 @@\n-  intptr_t* _top_unextended_sp;\n+  intptr_t* _top_unextended_sp_before_thaw;\n@@ -1531,1 +1576,1 @@\n-    DEBUG_ONLY(_top_unextended_sp = nullptr;)\n+    DEBUG_ONLY(_top_unextended_sp_before_thaw = nullptr;)\n@@ -1536,0 +1581,2 @@\n+  void clear_chunk(stackChunkOop chunk);\n+  int remove_top_compiled_frame_from_chunk(stackChunkOop chunk, int &argsize);\n@@ -1609,0 +1656,76 @@\n+class ReconstructedStack : public StackObj {\n+  intptr_t* _base;  \/\/ _cont.entrySP(); \/\/ top of the entry frame\n+  int _thaw_size;\n+  int _argsize;\n+public:\n+  ReconstructedStack(intptr_t* base, int thaw_size, int argsize) : _base(base), _thaw_size(thaw_size), _argsize(argsize) {\n+    \/\/ The only possible source of misalignment is stack-passed arguments b\/c compiled frames are 16-byte aligned.\n+    assert(argsize != 0 || (_base - _thaw_size) == ContinuationHelper::frame_align_pointer(_base - _thaw_size), \"\");\n+    \/\/ We're at most one alignment word away from entrySP\n+    assert(_base - 1 <= top() + total_size() + frame::metadata_words, \"missed entry frame\");\n+  }\n+\n+  int thaw_size() const { return _thaw_size; }\n+  int argsize() const { return _argsize; }\n+\n+  \/\/ top and bottom stack pointers\n+  intptr_t* sp() const { return ContinuationHelper::frame_align_pointer(_base - _thaw_size); }\n+  intptr_t* bottom_sp() const { return ContinuationHelper::frame_align_pointer(_base - _argsize); }\n+\n+  \/\/ several operations operate on the totality of the stack being reconstructed,\n+  \/\/ including the metadata words\n+  intptr_t* top() const { return sp() - frame::metadata_words;  }\n+  int total_size() const { return _thaw_size + frame::metadata_words; }\n+};\n+\n+inline void ThawBase::clear_chunk(stackChunkOop chunk) {\n+  chunk->set_sp(chunk->stack_size());\n+  chunk->set_argsize(0);\n+  chunk->set_max_thawing_size(0);\n+}\n+\n+ int ThawBase::remove_top_compiled_frame_from_chunk(stackChunkOop chunk, int &argsize) {\n+  bool empty = false;\n+  StackChunkFrameStream<ChunkFrames::CompiledOnly> f(chunk);\n+  DEBUG_ONLY(intptr_t* const chunk_sp = chunk->start_address() + chunk->sp();)\n+  assert(chunk_sp == f.sp(), \"\");\n+  assert(chunk_sp == f.unextended_sp(), \"\");\n+\n+  const int frame_size = f.cb()->frame_size();\n+  argsize = f.stack_argsize();\n+\n+  f.next(SmallRegisterMap::instance, true \/* stop *\/);\n+  empty = f.is_done();\n+  assert(!empty || argsize == chunk->argsize(), \"\");\n+\n+  if (empty) {\n+    clear_chunk(chunk);\n+  } else {\n+    chunk->set_sp(chunk->sp() + frame_size);\n+    chunk->set_max_thawing_size(chunk->max_thawing_size() - frame_size);\n+    \/\/ We set chunk->pc to the return pc into the next frame\n+    chunk->set_pc(f.pc());\n+    assert(f.pc() == *(address*)(chunk_sp + frame_size - frame::sender_sp_ret_address_offset()), \"unexpected pc\");\n+  }\n+  assert(empty == chunk->is_empty(), \"\");\n+  \/\/ returns the size required to store the frame on stack, and because it is a\n+  \/\/ compiled frame, it must include a copy of the arguments passed by the caller\n+  return frame_size + argsize;\n+}\n+\n+void ThawBase::copy_from_chunk(intptr_t* from, intptr_t* to, int size) {\n+  assert(to >= _top_stack_address, \"overwrote past thawing space\"\n+    \" to: \" INTPTR_FORMAT \" top_address: \" INTPTR_FORMAT, p2i(to), p2i(_top_stack_address));\n+  assert(to + size <= _cont.entrySP(), \"overwrote past thawing space\");\n+  _cont.tail()->copy_from_chunk_to_stack(from, to, size);\n+  CONT_JFR_ONLY(_jfr_info.record_size_copied(size);)\n+}\n+\n+void ThawBase::patch_return(intptr_t* sp, bool is_last) {\n+  log_develop_trace(continuations)(\"thaw_fast patching -- sp: \" INTPTR_FORMAT, p2i(sp));\n+\n+  address pc = !is_last ? StubRoutines::cont_returnBarrier() : _cont.entryPC();\n+  *(address*)(sp - frame::sender_sp_ret_address_offset()) = pc;\n+  \/\/ patch_chunk_pd(sp); -- TODO: If not needed - remove method; it's not used elsewhere\n+}\n+\n@@ -1627,2 +1750,1 @@\n-  int chunk_start_sp = chunk->sp();\n-  const int full_chunk_size = chunk->stack_size() - chunk_start_sp; \/\/ this initial size could be reduced if it's a partial thaw\n+  const int full_chunk_size = chunk->stack_size() - chunk->sp(); \/\/ this initial size could be reduced if it's a partial thaw\n@@ -1631,1 +1753,1 @@\n-  intptr_t* const chunk_sp = chunk->start_address() + chunk_start_sp;\n+  intptr_t* const chunk_sp = chunk->start_address() + chunk->sp();\n@@ -1638,8 +1760,2 @@\n-\n-    argsize = chunk->argsize();\n-    empty = true;\n-\n-    chunk->set_sp(chunk->stack_size());\n-    chunk->set_argsize(0);\n-    chunk->set_max_size(0);\n-\n+    argsize = chunk->argsize(); \/\/ must be called *before* clearing the chunk\n+    clear_chunk(chunk);\n@@ -1647,0 +1763,1 @@\n+    empty = true;\n@@ -1649,25 +1766,2 @@\n-\n-    StackChunkFrameStream<ChunkFrames::CompiledOnly> f(chunk);\n-    assert(chunk_sp == f.sp(), \"\");\n-    assert(chunk_sp == f.unextended_sp(), \"\");\n-\n-    const int frame_size = f.cb()->frame_size();\n-    argsize = f.stack_argsize();\n-\n-    f.next(SmallRegisterMap::instance, true \/* stop *\/);\n-    empty = f.is_done();\n-    assert(!empty || argsize == chunk->argsize(), \"\");\n-\n-    if (empty) {\n-      chunk->set_sp(chunk->stack_size());\n-      chunk->set_argsize(0);\n-      chunk->set_max_size(0);\n-    } else {\n-      chunk->set_sp(chunk->sp() + frame_size);\n-      chunk->set_max_size(chunk->max_size() - frame_size);\n-      \/\/ We set chunk->pc to the return pc into the next frame\n-      chunk->set_pc(f.pc());\n-      assert(f.pc() == *(address*)(chunk_sp + frame_size - frame::sender_sp_ret_address_offset()), \"unexpected pc\");\n-    }\n-    assert(empty == chunk->is_empty(), \"\");\n-    thaw_size = frame_size + argsize;\n+    thaw_size = remove_top_compiled_frame_from_chunk(chunk, argsize);\n+    empty = chunk->is_empty();\n@@ -1678,0 +1772,1 @@\n+  assert(!is_last || argsize == 0, \"\");\n@@ -1682,9 +1777,1 @@\n-  intptr_t* stack_sp = _cont.entrySP();\n-  intptr_t* bottom_sp = ContinuationHelper::frame_align_pointer(stack_sp - argsize);\n-\n-  stack_sp -= thaw_size;\n-  \/\/ possibly adds a one-word padding between entrySP and the bottom-most frame's stack args\n-  \/\/ The only possible source of misalignment is stack-passed arguments because all compiled\n-  \/\/ frames are 16-byte aligned.\n-  assert(argsize != 0 || stack_sp == ContinuationHelper::frame_align_pointer(stack_sp), \"\");\n-  stack_sp = ContinuationHelper::frame_align_pointer(stack_sp);\n+  ReconstructedStack rs(_cont.entrySP(), thaw_size, argsize);\n@@ -1693,8 +1780,1 @@\n-  intptr_t* from = chunk_sp - frame::metadata_words;\n-  intptr_t* to   = stack_sp - frame::metadata_words;\n-  copy_from_chunk(from, to, thaw_size + frame::metadata_words);\n-  \/\/ We assert we have not overwritten the entry frame, but that we're at most\n-  \/\/ one alignment word away from it.\n-  assert(to + thaw_size + frame::metadata_words <= _cont.entrySP(), \"overwritten entry frame\");\n-  assert(_cont.entrySP() - 1 <= to + thaw_size + frame::metadata_words, \"missed entry frame\");\n-  assert(argsize != 0 || to + thaw_size + frame::metadata_words == _cont.entrySP(), \"missed entry frame\");\n+  copy_from_chunk(chunk_sp - frame::metadata_words, rs.top(), rs.total_size());\n@@ -1702,2 +1782,2 @@\n-  assert(!is_last || argsize == 0, \"\");\n-  _cont.set_argsize(argsize); \/\/ sets argsize in ContinuationEntry\n+  \/\/ update the ContinuationEntry\n+  _cont.set_argsize(argsize);\n@@ -1705,1 +1785,1 @@\n-  assert(bottom_sp == _cont.entry()->bottom_sender_sp(), \"\");\n+  assert(rs.bottom_sp() == _cont.entry()->bottom_sender_sp(), \"\");\n@@ -1708,4 +1788,2 @@\n-  patch_return(bottom_sp, is_last);\n-  DEBUG_ONLY(address pc = *(address*)(bottom_sp - frame::sender_sp_ret_address_offset());)\n-  assert(is_last ? CodeCache::find_blob(pc)->as_compiled_method()->method()->is_continuation_enter_intrinsic()\n-                  : pc == StubRoutines::cont_returnBarrier(), \"is_last: %d\", is_last);\n+  patch_return(rs.bottom_sp(), is_last);\n+\n@@ -1726,1 +1804,1 @@\n-  set_anchor(_thread, stack_sp);\n+  set_anchor(_thread, rs.sp());\n@@ -1734,17 +1812,1 @@\n-  return stack_sp;\n-}\n-\n-void ThawBase::copy_from_chunk(intptr_t* from, intptr_t* to, int size) {\n-  assert(to + size <= _cont.entrySP(), \"\");\n-  _cont.tail()->copy_from_chunk_to_stack(from, to, size);\n-  CONT_JFR_ONLY(_jfr_info.record_size_copied(size);)\n-  assert(to >= _top_stack_address, \"overwrote past thawing space\"\n-    \" to: \" INTPTR_FORMAT \" top_address: \" INTPTR_FORMAT, p2i(to), p2i(_top_stack_address));\n-}\n-\n-void ThawBase::patch_return(intptr_t* sp, bool is_last) {\n-  log_develop_trace(continuations)(\"thaw_fast patching -- sp: \" INTPTR_FORMAT, p2i(sp));\n-\n-  address pc = !is_last ? StubRoutines::cont_returnBarrier() : _cont.entryPC();\n-  *(address*)(sp - frame::sender_sp_ret_address_offset()) = pc;\n-  \/\/ patch_chunk_pd(sp); -- TODO: If not needed - remove method; it's not used elsewhere\n+  return rs.sp();\n@@ -1754,1 +1816,1 @@\n-  return _barriers | _cont.tail()->is_gc_mode();\n+  return _barriers || _cont.tail()->is_gc_mode();\n@@ -1775,1 +1837,0 @@\n-  bool last_interpreted = chunk->has_mixed_frames() && Interpreter::contains(chunk->pc());\n@@ -1778,1 +1839,1 @@\n-  _top_unextended_sp = _stream.unextended_sp();\n+  _top_unextended_sp_before_thaw = _stream.unextended_sp();\n@@ -1790,0 +1851,1 @@\n+    \/\/ TODO ZGC: this is where we'd want to restore color to the oops\n@@ -1794,1 +1856,1 @@\n-  frame caller;\n+  frame caller; \/\/ the thawed caller on the stack\n@@ -1866,2 +1928,2 @@\n-  int delta = _stream.unextended_sp() - _top_unextended_sp;\n-  chunk->set_max_size(chunk->max_size() - delta);\n+  int total_thawed = _stream.unextended_sp() - _top_unextended_sp_before_thaw;\n+  chunk->set_max_thawing_size(chunk->max_thawing_size() - total_thawed);\n@@ -1902,1 +1964,1 @@\n-    ContinuationHelper::Frame::patch_pc(caller, _cont.is_empty() ? caller.raw_pc()\n+    ContinuationHelper::Frame::patch_pc(caller, _cont.is_empty() ? caller.pc()\n@@ -1918,0 +1980,1 @@\n+  \/\/ or they will keep objects that are otherwise unreachable alive\n@@ -1935,1 +1998,1 @@\n-  _align_size += frame::align_wiggle; \/\/ remove the added alignment room for internal interpreted frame alignment om AArch64\n+  _align_size += frame::align_wiggle; \/\/ possible added alignment for internal interpreted frame alignment om AArch64\n@@ -1946,4 +2009,2 @@\n-  assert(!bottom || frame_sp + fsize >= _cont.entrySP() - 2, \"\");\n-  assert(!bottom || frame_sp + fsize <= _cont.entrySP(), \"\");\n-\n-  assert(ContinuationHelper::InterpretedFrame::frame_bottom(f) == frame_sp + fsize, \"\");\n+  assert(ContinuationHelper::InterpretedFrame::frame_bottom(f) >= frame_sp + fsize\n+    && ContinuationHelper::InterpretedFrame::frame_bottom(f) <= frame_sp + fsize + 1, \"\"); \/\/ internal alignment on aarch64\n@@ -2013,0 +2074,2 @@\n+  \/\/ If we're the bottom-most thawed frame, we're writing to within one word from entrySP\n+  \/\/ (we might have one padding word for alignment)\n@@ -2020,4 +2083,0 @@\n-  if (f.cb()->is_nmethod()) {\n-    f.cb()->as_nmethod()->run_nmethod_entry_barrier();\n-  }\n-\n@@ -2035,1 +2094,1 @@\n-    f.deoptimize(nullptr); \/\/ we're assuming there are no monitors; this doesn't revoke biased locks\n+    f.deoptimize(nullptr); \/\/ the null thread simply avoids the assertion in deoptimize which we're not set up for\n@@ -2105,1 +2164,1 @@\n-    chunk->set_max_size(0);\n+    chunk->set_max_thawing_size(0);\n@@ -2108,1 +2167,1 @@\n-    chunk->set_max_size(chunk->max_size() - _align_size);\n+    chunk->set_max_thawing_size(chunk->max_thawing_size() - _align_size);\n@@ -2110,1 +2169,1 @@\n-  assert(chunk->is_empty() == (chunk->max_size() == 0), \"\");\n+  assert(chunk->is_empty() == (chunk->max_thawing_size() == 0), \"\");\n@@ -2183,0 +2242,1 @@\n+  \/\/ All the frames have been thawed so we know they don't hold any monitors\n@@ -2185,2 +2245,0 @@\n-  verify_continuation(cont.continuation());\n-\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":214,"deletions":156,"binary":false,"changes":370,"status":"modified"},{"patch":"@@ -2016,1 +2016,1 @@\n-  product(intx, ExtentLocalCacheSize, 16,                                    \\\n+  product(intx, ExtentLocalCacheSize, 16,                                   \\\n@@ -2019,1 +2019,1 @@\n-           constraint(ExtentLocalCacheSizeConstraintFunc, AtParse)           \\\n+           constraint(ExtentLocalCacheSizeConstraintFunc, AtParse)          \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -115,0 +115,1 @@\n+  DEBUG_ONLY(intptr_t* sp_before = thread->last_Java_sp();)\n@@ -143,0 +144,1 @@\n+  assert(sp_before == thread->last_Java_sp(), \"Anchor has changed\");\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -181,0 +181,29 @@\n+ * @implNote\n+ * In the JDK Reference Implementation, the virtual thread scheduler may be configured\n+ * with the following system properties:\n+ * <table class=\"striped\">\n+ * <caption style=\"display:none:\">System properties<\/caption>\n+ *   <thead>\n+ *   <tr>\n+ *     <th scope=\"col\">System property<\/th>\n+ *     <th scope=\"col\">Description<\/th>\n+ *   <\/tr>\n+ *   <\/thead>\n+ *   <tbody>\n+ *   <tr>\n+ *     <th scope=\"row\">\n+ *       {@systemProperty jdk.virtualThreadScheduler.parallelism}\n+ *     <\/th>\n+ *     <td> The number of platform threads available for scheduling virtual\n+ *       threads. It defaults to the number of available processors. <\/td>\n+ *   <\/tr>\n+ *   <tr>\n+ *     <th scope=\"row\">\n+ *       {@systemProperty jdk.virtualThreadScheduler.maxPoolSize}\n+ *     <\/th>\n+ *     <td> The maximum number of platform threads available to the scheduler.\n+ *       It defaults to 256. <\/td>\n+ *   <\/tr>\n+ *   <\/tbody>\n+ * <\/table>\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -42,2 +42,0 @@\n-runtime\/cds\/appcds\/TestParallelGCWithCDS.java                           8284319 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,2 +114,0 @@\n-runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java#id0 8272791 generic-all\n-\n@@ -188,4 +186,1 @@\n-# timeout when testing with virtual threads\n-serviceability\/jvmti\/events\/FramePop\/framepop02\/framepop02.java#id1          8283818 generic-all\n-\n-# stratum mismatch\n+# stratum mismatch, test running with the wrong class path\n@@ -199,1 +194,0 @@\n-gc\/metaspace\/TestPerfCountersAndMemoryPools.java                             8278109 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -Xlog:class+load,class+unload=debug -XX:-UseCompressedOops -XX:-UseCompressedClassPointers -XX:+UseSerialGC -XX:+UsePerfData -Xint gc.metaspace.TestPerfCountersAndMemoryPools\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -Xlog:class+load,class+unload=debug -XX:+UseCompressedOops -XX:+UseCompressedClassPointers -XX:+UseSerialGC -XX:+UsePerfData -Xint gc.metaspace.TestPerfCountersAndMemoryPools\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -Xlog:class+load,class+unload=trace -XX:-UseCompressedOops -XX:-UseCompressedClassPointers -XX:+UseSerialGC -XX:+UsePerfData -Xint gc.metaspace.TestPerfCountersAndMemoryPools\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -Xlog:class+load,class+unload=trace -XX:+UseCompressedOops -XX:+UseCompressedClassPointers -XX:+UseSerialGC -XX:+UsePerfData -Xint gc.metaspace.TestPerfCountersAndMemoryPools\n@@ -83,4 +83,13 @@\n-        \/\/ Adding a second GC due to metadata allocations caused by getting the\n-        \/\/ initial size from the pool. This is needed when running with -Xcomp.\n-        System.gc();\n-        assertEQ(getUsed(perfNS), pool.getUsage().getUsed(), \"Used out of sync\");\n+        long usedPerfCounters;\n+        long usedMXBean;\n+\n+        \/\/ the pool.getUsage().getUsed() might load additional classes intermittently\n+        \/\/ so first verify that perfCounters are not changed, call System.gc() to reset them\n+        do {\n+            System.gc();\n+            usedPerfCounters = getUsed(perfNS);\n+            usedMXBean = pool.getUsage().getUsed();\n+            System.gc();\n+        } while (usedPerfCounters != getUsed(perfNS));\n+        assertEQ(usedPerfCounters, usedMXBean, \"Used out of sync\");\n+\n","filename":"test\/hotspot\/jtreg\/gc\/metaspace\/TestPerfCountersAndMemoryPools.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -148,2 +148,0 @@\n-\/*\n-        TODO uncomment, should be join added to orginal test?\n@@ -155,1 +153,1 @@\n- *\/\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineRunningMethods.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-    final AtomicBoolean isJNITestingCompleted = new AtomicBoolean(false);\n@@ -40,0 +39,1 @@\n+    volatile private boolean target_is_ready = false;\n@@ -44,8 +44,7 @@\n-            do {\n-                try {\n-                    lock.wait(1);\n-                } catch (InterruptedException ie) {\n-                    System.err.println(\"Virtual thread was interrupted as expected\");\n-                    iterrupted = true;\n-                }\n-            } while (!isJNITestingCompleted.get());\n+            try {\n+                target_is_ready = true;\n+                lock.wait();\n+            } catch (InterruptedException ie) {\n+                 System.err.println(\"Virtual thread was interrupted as expected\");\n+                 iterrupted = true;\n+            }\n@@ -57,0 +56,7 @@\n+\n+        \/\/ wait for target virtual thread to reach the expected waiting state\n+        while (!target_is_ready) {\n+           synchronized (lock) {\n+              lock.wait(1);\n+            }\n+        }\n@@ -58,1 +64,0 @@\n-        isJNITestingCompleted.set(true);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/InterruptThreadTest\/InterruptThreadTest.java","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -326,3 +326,3 @@\n-    \/\/ @Test\n-    public void testPinnedNative() {\n-        \/\/ pinning due to native method\n+    @Test\n+    public void testPinnedCriticalSection() {\n+        \/\/ pinning due to critical section\n@@ -332,1 +332,1 @@\n-            nativeFoo(1);\n+            csFoo(1);\n@@ -341,1 +341,1 @@\n-        assertEquals(res.get(), Continuation.Pinned.NATIVE);\n+        assertEquals(res.get(), Continuation.Pinned.CRITICAL_SECTION);\n@@ -344,1 +344,5 @@\n-    static double nativeFoo(int a) {\n+    static double csFoo(int a) {\n+        long x = 8;\n+        String s = \"yyy\";\n+        String r;\n+        Continuation.pin();\n@@ -346,17 +350,0 @@\n-            long x = 8;\n-            String s = \"yyy\";\n-            return Bar.x; \/\/ load the class\n-        } catch (Exception e) {\n-            throw new AssertionError(e);\n-        }\n-    }\n-\n-    \/\/ use a class initializer to have a native method on the stack\n-    class Bar {\n-        static {\n-            nativeBar(5);\n-        }\n-\n-        static String nativeBar(long b) {\n-            double x = 9.99;\n-            String s = \"zzz\";\n@@ -364,5 +351,3 @@\n-            boolean res = Continuation.yield(FOO);\n-            assert res == false;\n-\n-            long r = b+1;\n-            return \"\" + r;\n+            r = bar2(a + 1);\n+        } finally {\n+            Continuation.unpin();\n@@ -370,2 +355,1 @@\n-\n-        static int x = 5;\n+        return Integer.parseInt(r)+1;\n@@ -375,2 +359,2 @@\n-    public void testPinnedCriticalSection() {\n-        \/\/ pinning due to critical section\n+    public void testPinnedNative() {\n+        \/\/ pinning due to native method\n@@ -380,1 +364,1 @@\n-            csFoo(1);\n+            nativeFoo(1);\n@@ -389,1 +373,1 @@\n-        assertEquals(res.get(), Continuation.Pinned.CRITICAL_SECTION);\n+        assertEquals(res.get(), Continuation.Pinned.NATIVE);\n@@ -392,5 +376,1 @@\n-    static double csFoo(int a) {\n-        long x = 8;\n-        String s = \"yyy\";\n-        String r;\n-        Continuation.pin();\n+    static double nativeFoo(int a) {\n@@ -398,4 +378,5 @@\n-            assert Continuation.isPinned(FOO);\n-            r = bar2(a + 1);\n-        } finally {\n-            Continuation.unpin();\n+            int x = 8;\n+            String s = \"yyy\";\n+            return nativeBar(x);\n+        } catch (Exception e) {\n+            throw new AssertionError(e);\n@@ -403,1 +384,16 @@\n-        return Integer.parseInt(r)+1;\n+    }\n+\n+    static int nativeBaz(int b) {\n+        double x = 9.99;\n+        String s = \"zzz\";\n+        assert Continuation.isPinned(FOO);\n+        boolean res = Continuation.yield(FOO);\n+        assert res == false;\n+\n+        return b+1;\n+    }\n+\n+    private static native int nativeBar(int x);\n+\n+    static {\n+        System.loadLibrary(\"BasicJNI\");\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Basic.java","additions":40,"deletions":44,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -68,1 +69,1 @@\n-    static final boolean RANDOM  = false;\n+    static final boolean RANDOM  = true;\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Fuzz.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -19,0 +19,2 @@\n+YIELD, CALL_C_MANY, LOOP, YIELD, CALL_C_PIN, LOOP, CALL_C_INT, YIELD, CALL_C_PIN, LOOP, CALL_C_MANY, LOOP, YIELD, YIELD, CALL_C_DBL, LOOP, CALL_C_MANY, CALL_C_INT, CALL_C_MANY, LOOP, YIELD, CALL_C_CTCH, CALL_C_MANY, CALL_C_INT, CALL_C_CTCH, CALL_C_CTCH, CALL_C_INT, CALL_C_DBL, LOOP, CALL_C_CTCH, CALL_C_INT, CALL_C_MANY, CALL_C_MANY, YIELD, YIELD, CALL_C_MANY, CALL_C_CTCH, CALL_C_CTCH, CALL_C_DBL, CALL_C_CTCH, YIELD, CALL_C_CTCH, YIELD, CALL_C_INT, YIELD, YIELD, CALL_C_CTCH\n+CALL_I_DBL, CALL_I_CTCH, CALL_I_CTCH, CALL_I_DBL, CALL_I_INT, CALL_I_DBL, CALL_I_DBL, CALL_I_DBL, CALL_I_DBL, LOOP, CALL_I_CTCH, CALL_I_MANY, CALL_C_DBL, CALL_I_DBL, YIELD, CALL_C_DBL, CALL_C_CTCH, CALL_I_INT, CALL_I_MANY, CALL_I_INT, CALL_C_DBL, CALL_I_DBL, CALL_C_INT, CALL_C_MANY, CALL_I_MANY, CALL_C_INT, LOOP, LOOP, CALL_C_DBL, LOOP, LOOP, CALL_I_CTCH, LOOP, CALL_I_CTCH, CALL_I_CTCH, YIELD, LOOP, CALL_I_INT, CALL_I_INT, YIELD, CALL_I_CTCH, CALL_C_CTCH, CALL_I_MANY, CALL_I_CTCH, CALL_I_CTCH\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/fuzz.dat","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+\n+JNIEXPORT jint JNICALL\n+Java_Basic_nativeBar(JNIEnv* env, jclass klass, jint x) {\n+    jmethodID nativeBaz = (*env)->GetStaticMethodID(env, klass, \"nativeBaz\", \"(I)I\");\n+    jint r = (*env)->CallStaticIntMethod(env, klass, nativeBaz, x+1);\n+    return r + 1;\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/libBasicJNI.c","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"}]}