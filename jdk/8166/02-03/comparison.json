{"files":[{"patch":"@@ -304,0 +304,4 @@\n+void LIRGenerator::do_continuation_doYield(Intrinsic* x) {\n+  fatal(\"Continuation.doYield intrinsic is not implemented on this platform\");\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRGenerator_riscv.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_RISCV_CONTINUATIONENTRY_RISCV_INLINE_HPP\n+#define CPU_RISCV_CONTINUATIONENTRY_RISCV_INLINE_HPP\n+\n+#include \"runtime\/continuationEntry.hpp\"\n+\n+\/\/ TODO: Implement\n+\n+inline frame ContinuationEntry::to_frame() const {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+inline intptr_t* ContinuationEntry::entry_fp() const {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n+inline void ContinuationEntry::update_register_map(RegisterMap* map) const {\n+  Unimplemented();\n+}\n+\n+#endif \/\/ CPU_RISCV_CONTINUATIONENTRY_RISCV_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/riscv\/continuationEntry_riscv.inline.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_RISCV_CONTINUATIONFREEZETHAW_RISCV_INLINE_HPP\n+#define CPU_RISCV_CONTINUATIONFREEZETHAW_RISCV_INLINE_HPP\n+\n+#include \"oops\/stackChunkOop.inline.hpp\"\n+#include \"runtime\/frame.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+\n+\n+inline void FreezeBase::set_top_frame_metadata_pd(const frame& hf) {\n+  Unimplemented();\n+}\n+\n+template<typename FKind>\n+inline frame FreezeBase::sender(const frame& f) {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template<typename FKind> frame FreezeBase::new_heap_frame(frame& f, frame& caller) {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+void FreezeBase::adjust_interpreted_frame_unextended_sp(frame& f) {\n+  Unimplemented();\n+}\n+\n+inline void FreezeBase::relativize_interpreted_frame_metadata(const frame& f, const frame& hf) {\n+  Unimplemented();\n+}\n+\n+inline void FreezeBase::patch_pd(frame& hf, const frame& caller) {\n+  Unimplemented();\n+}\n+\n+inline void FreezeBase::patch_stack_pd(intptr_t* frame_sp, intptr_t* heap_sp) {\n+  Unimplemented();\n+}\n+\n+inline frame ThawBase::new_entry_frame() {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template<typename FKind> frame ThawBase::new_stack_frame(const frame& hf, frame& caller, bool bottom) {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+inline void ThawBase::set_interpreter_frame_bottom(const frame& f, intptr_t* bottom) {\n+  Unimplemented();\n+}\n+\n+inline void ThawBase::derelativize_interpreted_frame_metadata(const frame& hf, const frame& f) {\n+  Unimplemented();\n+}\n+\n+inline intptr_t* ThawBase::align(const frame& hf, intptr_t* frame_sp, frame& caller, bool bottom) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline void ThawBase::patch_pd(frame& f, const frame& caller) {\n+  Unimplemented();\n+}\n+\n+void ThawBase::patch_chunk_pd(intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n+inline void ThawBase::prefetch_chunk_pd(void* start, int size) {\n+  Unimplemented();\n+}\n+\n+#endif \/\/ CPU_RISCV_CONTINUATIONFREEZETHAW_RISCV_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/riscv\/continuationFreezeThaw_riscv.inline.hpp","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_RISCV_CONTINUATIONHELPER_RISCV_INLINE_HPP\n+#define CPU_RISCV_CONTINUATIONHELPER_RISCV_INLINE_HPP\n+\n+#include \"runtime\/continuationHelper.hpp\"\n+\n+template<typename FKind>\n+static inline intptr_t** link_address(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline int ContinuationHelper::frame_align_words(int size) {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+inline intptr_t* ContinuationHelper::frame_align_pointer(intptr_t* sp) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template<typename FKind>\n+inline void ContinuationHelper::update_register_map(const frame& f, RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+inline void ContinuationHelper::update_register_map_with_callee(const frame& f, RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+inline void ContinuationHelper::push_pd(const frame& f) {\n+  Unimplemented();\n+}\n+\n+\n+inline void ContinuationHelper::set_anchor_to_entry_pd(JavaFrameAnchor* anchor, ContinuationEntry* cont) {\n+  Unimplemented();\n+}\n+\n+#ifdef ASSERT\n+inline void ContinuationHelper::set_anchor_pd(JavaFrameAnchor* anchor, intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n+inline bool ContinuationHelper::Frame::assert_frame_laid_out(frame f) {\n+  Unimplemented();\n+  return false;\n+}\n+#endif\n+\n+inline intptr_t** ContinuationHelper::Frame::callee_link_address(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template<typename FKind>\n+static inline intptr_t* real_fp(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline address* ContinuationHelper::InterpretedFrame::return_pc_address(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n+inline address* ContinuationHelper::Frame::return_pc_address(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline address ContinuationHelper::Frame::real_pc(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline void ContinuationHelper::Frame::patch_pc(const frame& f, address pc) {\n+  Unimplemented();\n+}\n+\n+inline intptr_t* ContinuationHelper::InterpretedFrame::frame_top(const frame& f, InterpreterOopMap* mask) { \/\/ inclusive; this will be copied with the frame\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline intptr_t* ContinuationHelper::InterpretedFrame::frame_bottom(const frame& f) { \/\/ exclusive; this will not be copied with the frame\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline intptr_t* ContinuationHelper::InterpretedFrame::frame_top(const frame& f, int callee_argsize, bool callee_interpreted) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+#endif \/\/ CPU_RISCV_CONTINUATIONFRAMEHELPERS_RISCV_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/riscv\/continuationHelper_riscv.inline.hpp","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -285,5 +285,0 @@\n-int frame::frame_size(RegisterMap* map) const {\n-  frame sender = this->sender(map);\n-  return sender.sp() - sp();\n-}\n-\n@@ -401,1 +396,1 @@\n-        DEBUG_ONLY(verify_deopt_original_pc(sender_cm, _unextended_sp));\n+        verify_deopt_original_pc(sender_cm, _unextended_sp);\n@@ -407,20 +402,0 @@\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::update_map_with_saved_link\n-void frame::update_map_with_saved_link(RegisterMap* map, intptr_t** link_addr) {\n-  \/\/ The interpreter and compiler(s) always save fp in a known\n-  \/\/ location on entry. We must record where that location is\n-  \/\/ so that if fp was live on callout from c2 we can find\n-  \/\/ the saved copy no matter what it called.\n-\n-  \/\/ Since the interpreter always saves fp if we record where it is then\n-  \/\/ we don't have to always save fp on entry and exit to c2 compiled\n-  \/\/ code, on entry will be enough.\n-  assert(map != NULL, \"map must be set\");\n-  map->set_location(::fp->as_VMReg(), (address) link_addr);\n-  \/\/ this is weird \"H\" ought to be at a higher address however the\n-  \/\/ oopMaps seems to have the \"H\" regs at the same address and the\n-  \/\/ vanilla register.\n-  map->set_location(::fp->as_VMReg()->next(), (address) link_addr);\n-}\n-\n-\n@@ -447,74 +422,0 @@\n-\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::sender_for_compiled_frame\n-frame frame::sender_for_compiled_frame(RegisterMap* map) const {\n-  \/\/ we cannot rely upon the last fp having been saved to the thread\n-  \/\/ in C2 code but it will have been pushed onto the stack. so we\n-  \/\/ have to find it relative to the unextended sp\n-\n-  assert(_cb->frame_size() >= 0, \"must have non-zero frame size\");\n-  intptr_t* l_sender_sp = unextended_sp() + _cb->frame_size();\n-  intptr_t* unextended_sp = l_sender_sp;\n-\n-  \/\/ the return_address is always the word on the stack\n-  address sender_pc = (address) *(l_sender_sp + frame::return_addr_offset);\n-\n-  intptr_t** saved_fp_addr = (intptr_t**) (l_sender_sp + frame::link_offset);\n-\n-  assert(map != NULL, \"map must be set\");\n-  if (map->update_map()) {\n-    \/\/ Tell GC to use argument oopmaps for some runtime stubs that need it.\n-    \/\/ For C1, the runtime stub might not have oop maps, so set this flag\n-    \/\/ outside of update_register_map.\n-    map->set_include_argument_oops(_cb->caller_must_gc_arguments(map->thread()));\n-    if (_cb->oop_maps() != NULL) {\n-      OopMapSet::update_register_map(this, map);\n-    }\n-\n-    \/\/ Since the prolog does the save and restore of FP there is no\n-    \/\/ oopmap for it so we must fill in its location as if there was\n-    \/\/ an oopmap entry since if our caller was compiled code there\n-    \/\/ could be live jvm state in it.\n-    update_map_with_saved_link(map, saved_fp_addr);\n-  }\n-\n-  return frame(l_sender_sp, unextended_sp, *saved_fp_addr, sender_pc);\n-}\n-\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::sender_raw\n-frame frame::sender_raw(RegisterMap* map) const {\n-  \/\/ Default is we done have to follow them. The sender_for_xxx will\n-  \/\/ update it accordingly\n-  assert(map != NULL, \"map must be set\");\n-  map->set_include_argument_oops(false);\n-\n-  if (is_entry_frame()) {\n-    return sender_for_entry_frame(map);\n-  }\n-  if (is_interpreted_frame()) {\n-    return sender_for_interpreter_frame(map);\n-  }\n-  assert(_cb == CodeCache::find_blob(pc()),\"Must be the same\");\n-\n-  \/\/ This test looks odd: why is it not is_compiled_frame() ?  That's\n-  \/\/ because stubs also have OOP maps.\n-  if (_cb != NULL) {\n-    return sender_for_compiled_frame(map);\n-  }\n-\n-  \/\/ Must be native-compiled frame, i.e. the marshaling code for native\n-  \/\/ methods that exists in the core system.\n-  return frame(sender_sp(), link(), sender_pc());\n-}\n-\n-frame frame::sender(RegisterMap* map) const {\n-  frame result = sender_raw(map);\n-\n-  if (map->process_frames()) {\n-    StackWatermarkSet::on_iteration(map->thread(), result);\n-  }\n-\n-  return result;\n-}\n-\n@@ -658,13 +559,0 @@\n-intptr_t* frame::real_fp() const {\n-  if (_cb != NULL) {\n-    \/\/ use the frame size if valid\n-    int size = _cb->frame_size();\n-    if (size > 0) {\n-      return unextended_sp() + size;\n-    }\n-  }\n-  \/\/ else rely on fp()\n-  assert(!is_compiled_frame(), \"unknown compiled frame size\");\n-  return fp();\n-}\n-\n@@ -675,1 +563,1 @@\n-frame::frame(void* ptr_sp, void* ptr_fp, void* pc) {\n+frame::frame(void* ptr_sp, void* ptr_fp, void* pc) : _on_heap(false) {\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.cpp","additions":2,"deletions":114,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -138,1 +138,8 @@\n-    arg_reg_save_area_bytes                          =  0\n+    arg_reg_save_area_bytes                          =  0,\n+\n+    \/\/ size, in words, of frame metadata (e.g. pc and link)\n+    metadata_words                                   = sender_sp_offset,\n+    \/\/ in bytes\n+    frame_alignment                                  = 16,\n+    \/\/ size, in words, of maximum shift in frame position due to alignment\n+    align_wiggle                                     =  1\n@@ -171,0 +178,2 @@\n+  const ImmutableOopMap* get_oop_map() const;\n+\n@@ -184,1 +193,1 @@\n-  intptr_t*   fp() const { return _fp; }\n+  intptr_t* fp() const { return _fp; }\n@@ -191,2 +200,2 @@\n-  \/\/ helper to update a map with callee-saved RBP\n-  static void update_map_with_saved_link(RegisterMap* map, intptr_t** link_addr);\n+  template <typename RegisterMapT>\n+  static void update_map_with_saved_link(RegisterMapT* map, intptr_t** link_addr);\n@@ -200,1 +209,1 @@\n-  frame sender_raw(RegisterMap* map) const;\n+  inline frame sender_raw(RegisterMap* map) const;\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.hpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+  _on_heap = false;\n+  DEBUG_ONLY(_frame_index = -1;)\n@@ -66,0 +68,3 @@\n+\n+  _on_heap = false;\n+  DEBUG_ONLY(_frame_index = -1;)\n@@ -92,0 +97,7 @@\n+\n+  _on_heap = false;\n+  DEBUG_ONLY(_frame_index = -1;)\n+}\n+\n+inline frame::frame(intptr_t* ptr_sp) {\n+  Unimplemented();\n@@ -122,0 +134,3 @@\n+\n+  _on_heap = false;\n+  DEBUG_ONLY(_frame_index = -1;)\n@@ -153,0 +168,32 @@\n+inline void frame::set_unextended_sp(intptr_t* value) {\n+  Unimplemented();\n+}\n+\n+inline int frame::offset_unextended_sp() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+inline void frame::set_offset_unextended_sp(int value) {\n+  Unimplemented();\n+}\n+\n+inline intptr_t* frame::real_fp() const {\n+  if (_cb != NULL) {\n+    \/\/ use the frame size if valid\n+    int size = _cb->frame_size();\n+    if (size > 0) {\n+      return unextended_sp() + size;\n+    }\n+  }\n+  \/\/ else rely on fp()\n+  assert(!is_compiled_frame(), \"unknown compiled frame size\");\n+  return fp();\n+}\n+\n+inline int frame::frame_size() const {\n+  return is_interpreted_frame()\n+    ? sender_sp() - sp()\n+    : cb()->frame_size();\n+}\n+\n@@ -163,1 +210,1 @@\n-  return *(intptr_t**)addr_at(interpreter_frame_last_sp_offset);\n+  return (intptr_t*)at(interpreter_frame_last_sp_offset);\n@@ -236,1 +283,1 @@\n-  oop* result_adr = (oop *)map->location(x10->as_VMReg());\n+  oop* result_adr = (oop *)map->location(x10->as_VMReg(), nullptr);\n@@ -242,1 +289,1 @@\n-  oop* result_adr = (oop *)map->location(x10->as_VMReg());\n+  oop* result_adr = (oop *)map->location(x10->as_VMReg(), nullptr);\n@@ -248,0 +295,114 @@\n+inline const ImmutableOopMap* frame::get_oop_map() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline int frame::compiled_frame_stack_argsize() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+inline void frame::interpreted_frame_oop_map(InterpreterOopMap* mask) const {\n+  Unimplemented();\n+}\n+\n+inline int frame::sender_sp_ret_address_offset() {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+\/\/------------------------------------------------------------------------------\n+\/\/ frame::sender\n+frame frame::sender(RegisterMap* map) const {\n+  frame result = sender_raw(map);\n+\n+  if (map->process_frames()) {\n+    StackWatermarkSet::on_iteration(map->thread(), result);\n+  }\n+\n+  return result;\n+}\n+\n+\/\/------------------------------------------------------------------------------\n+\/\/ frame::sender_raw\n+frame frame::sender_raw(RegisterMap* map) const {\n+  \/\/ Default is we done have to follow them. The sender_for_xxx will\n+  \/\/ update it accordingly\n+  assert(map != NULL, \"map must be set\");\n+  map->set_include_argument_oops(false);\n+\n+  if (is_entry_frame()) {\n+    return sender_for_entry_frame(map);\n+  }\n+  if (is_interpreted_frame()) {\n+    return sender_for_interpreter_frame(map);\n+  }\n+  assert(_cb == CodeCache::find_blob(pc()),\"Must be the same\");\n+\n+  \/\/ This test looks odd: why is it not is_compiled_frame() ?  That's\n+  \/\/ because stubs also have OOP maps.\n+  if (_cb != NULL) {\n+    return sender_for_compiled_frame(map);\n+  }\n+\n+  \/\/ Must be native-compiled frame, i.e. the marshaling code for native\n+  \/\/ methods that exists in the core system.\n+  return frame(sender_sp(), link(), sender_pc());\n+}\n+\n+\/\/------------------------------------------------------------------------------\n+\/\/ frame::sender_for_compiled_frame\n+frame frame::sender_for_compiled_frame(RegisterMap* map) const {\n+  \/\/ we cannot rely upon the last fp having been saved to the thread\n+  \/\/ in C2 code but it will have been pushed onto the stack. so we\n+  \/\/ have to find it relative to the unextended sp\n+\n+  assert(_cb->frame_size() >= 0, \"must have non-zero frame size\");\n+  intptr_t* l_sender_sp = unextended_sp() + _cb->frame_size();\n+  intptr_t* unextended_sp = l_sender_sp;\n+\n+  \/\/ the return_address is always the word on the stack\n+  address sender_pc = (address) *(l_sender_sp + frame::return_addr_offset);\n+\n+  intptr_t** saved_fp_addr = (intptr_t**) (l_sender_sp + frame::link_offset);\n+\n+  assert(map != NULL, \"map must be set\");\n+  if (map->update_map()) {\n+    \/\/ Tell GC to use argument oopmaps for some runtime stubs that need it.\n+    \/\/ For C1, the runtime stub might not have oop maps, so set this flag\n+    \/\/ outside of update_register_map.\n+    map->set_include_argument_oops(_cb->caller_must_gc_arguments(map->thread()));\n+    if (_cb->oop_maps() != NULL) {\n+      OopMapSet::update_register_map(this, map);\n+    }\n+\n+    \/\/ Since the prolog does the save and restore of FP there is no\n+    \/\/ oopmap for it so we must fill in its location as if there was\n+    \/\/ an oopmap entry since if our caller was compiled code there\n+    \/\/ could be live jvm state in it.\n+    update_map_with_saved_link(map, saved_fp_addr);\n+  }\n+\n+  return frame(l_sender_sp, unextended_sp, *saved_fp_addr, sender_pc);\n+}\n+\n+\/\/------------------------------------------------------------------------------\n+\/\/ frame::update_map_with_saved_link\n+template <typename RegisterMapT>\n+void frame::update_map_with_saved_link(RegisterMapT* map, intptr_t** link_addr) {\n+  \/\/ The interpreter and compiler(s) always save fp in a known\n+  \/\/ location on entry. We must record where that location is\n+  \/\/ so that if fp was live on callout from c2 we can find\n+  \/\/ the saved copy no matter what it called.\n+\n+  \/\/ Since the interpreter always saves fp if we record where it is then\n+  \/\/ we don't have to always save fp on entry and exit to c2 compiled\n+  \/\/ code, on entry will be enough.\n+  assert(map != NULL, \"map must be set\");\n+  map->set_location(::fp->as_VMReg(), (address) link_addr);\n+  \/\/ this is weird \"H\" ought to be at a higher address however the\n+  \/\/ oopMaps seems to have the \"H\" regs at the same address and the\n+  \/\/ vanilla register.\n+  map->set_location(::fp->as_VMReg()->next(), (address) link_addr);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.inline.hpp","additions":164,"deletions":3,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"runtime\/frame.inline.hpp\"\n@@ -164,0 +165,4 @@\n+void BarrierSetNMethod::arm(nmethod* nm, int arm_value) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetNMethod_riscv.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -572,0 +572,31 @@\n+class NativePostCallNop: public NativeInstruction {\n+public:\n+  bool check() const { Unimplemented(); return false; }\n+  int displacement() const { Unimplemented(); return 0; }\n+  void patch(jint diff) { Unimplemented(); }\n+  void make_deopt() { Unimplemented(); }\n+};\n+\n+inline NativePostCallNop* nativePostCallNop_at(address address) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+class NativeDeoptInstruction: public NativeInstruction {\n+public:\n+  address instruction_address() const       { Unimplemented(); return NULL; }\n+  address next_instruction_address() const  { Unimplemented(); return NULL; }\n+\n+  void  verify() { Unimplemented(); }\n+\n+  static bool is_deopt_at(address instr) {\n+    Unimplemented();\n+    return false;\n+  }\n+\n+  \/\/ MT-safe patching\n+  static void insert(address code_pos) {\n+    Unimplemented();\n+  }\n+};\n+\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2021, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -36,1 +36,1 @@\n-    address base_location = location(base_reg);\n+    address base_location = location(base_reg, nullptr);\n@@ -43,1 +43,1 @@\n-    return location(base_reg->next(slot_idx));\n+    return location(base_reg->next(slot_idx), nullptr);\n","filename":"src\/hotspot\/cpu\/riscv\/registerMap_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_RISCV_SMALLREGISTERMAP_RISCV_INLINE_HPP\n+#define CPU_RISCV_SMALLREGISTERMAP_RISCV_INLINE_HPP\n+\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+\n+\/\/ Java frames don't have callee saved registers (except for rfp), so we can use a smaller RegisterMap\n+class SmallRegisterMap {\n+public:\n+  static constexpr SmallRegisterMap* instance = nullptr;\n+private:\n+  static void assert_is_rfp(VMReg r) PRODUCT_RETURN\n+                                     DEBUG_ONLY({ Unimplemented(); })\n+public:\n+  \/\/ as_RegisterMap is used when we didn't want to templatize and abstract over RegisterMap type to support SmallRegisterMap\n+  \/\/ Consider enhancing SmallRegisterMap to support those cases\n+  const RegisterMap* as_RegisterMap() const { return nullptr; }\n+  RegisterMap* as_RegisterMap() { return nullptr; }\n+\n+  RegisterMap* copy_to_RegisterMap(RegisterMap* map, intptr_t* sp) const {\n+    Unimplemented();\n+    return map;\n+  }\n+\n+  SmallRegisterMap() {}\n+\n+  SmallRegisterMap(const RegisterMap* map) {\n+    Unimplemented();\n+  }\n+\n+  inline address location(VMReg reg, intptr_t* sp) const {\n+    Unimplemented();\n+    return NULL;\n+  }\n+\n+  inline void set_location(VMReg reg, address loc) { assert_is_rfp(reg); }\n+\n+  JavaThread* thread() const {\n+  #ifndef ASSERT\n+    guarantee (false, \"\");\n+  #endif\n+    return nullptr;\n+  }\n+\n+  bool update_map()    const { return false; }\n+  bool walk_cont()     const { return false; }\n+  bool include_argument_oops() const { return false; }\n+  void set_include_argument_oops(bool f)  {}\n+  bool in_cont()       const { return false; }\n+  stackChunkHandle stack_chunk() const { return stackChunkHandle(); }\n+\n+#ifdef ASSERT\n+  bool should_skip_missing() const  { return false; }\n+  VMReg find_register_spilled_here(void* p, intptr_t* sp) {\n+    Unimplemented();\n+    return NULL;\n+  }\n+  void print() const { print_on(tty); }\n+  void print_on(outputStream* st) const { st->print_cr(\"Small register map\"); }\n+#endif\n+};\n+\n+#endif \/\/ CPU_RISCV_SMALLREGISTERMAP_RISCV_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/riscv\/smallRegisterMap_riscv.inline.hpp","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_RISCV_STACKCHUNKFRAMESTREAM_RISCV_INLINE_HPP\n+#define CPU_RISCV_STACKCHUNKFRAMESTREAM_RISCV_INLINE_HPP\n+\n+#include \"interpreter\/oopMapCache.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+\n+#ifdef ASSERT\n+template <ChunkFrames frame_kind>\n+inline bool StackChunkFrameStream<frame_kind>::is_in_frame(void* p0) const {\n+  Unimplemented();\n+  return true;\n+}\n+#endif\n+\n+template <ChunkFrames frame_kind>\n+inline frame StackChunkFrameStream<frame_kind>::to_frame() const {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <ChunkFrames frame_kind>\n+inline address StackChunkFrameStream<frame_kind>::get_pc() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <ChunkFrames frame_kind>\n+inline intptr_t* StackChunkFrameStream<frame_kind>::fp() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <ChunkFrames frame_kind>\n+inline intptr_t* StackChunkFrameStream<frame_kind>::derelativize(int offset) const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <ChunkFrames frame_kind>\n+inline intptr_t* StackChunkFrameStream<frame_kind>::unextended_sp_for_interpreter_frame() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <ChunkFrames frame_kind>\n+intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <ChunkFrames frame_kind>\n+inline void StackChunkFrameStream<frame_kind>::next_for_interpreter_frame() {\n+  Unimplemented();\n+}\n+\n+template <ChunkFrames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_size() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <ChunkFrames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_stack_argsize() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <ChunkFrames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<ChunkFrames::Mixed>::update_reg_map_pd(RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<ChunkFrames::CompiledOnly>::update_reg_map_pd(RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+template <ChunkFrames frame_kind>\n+template <typename RegisterMapT>\n+inline void StackChunkFrameStream<frame_kind>::update_reg_map_pd(RegisterMapT* map) {}\n+\n+#endif \/\/ CPU_RISCV_STACKCHUNKFRAMESTREAM_RISCV_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/riscv\/stackChunkFrameStream_riscv.inline.hpp","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_RISCV_STACKCHUNKOOP_RISCV_INLINE_HPP\n+#define CPU_RISCV_STACKCHUNKOOP_RISCV_INLINE_HPP\n+\n+inline void stackChunkOopDesc::relativize_frame_pd(frame& fr) const {\n+  Unimplemented();\n+}\n+\n+inline void stackChunkOopDesc::derelativize_frame_pd(frame& fr) const {\n+  Unimplemented();\n+}\n+\n+#endif \/\/ CPU_RISCV_STACKCHUNKOOP_RISCV_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/riscv\/stackChunkOop_riscv.inline.hpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -3858,1 +3858,1 @@\n-void StubGenerator_generate(CodeBuffer* code, bool all) {\n+void StubGenerator_generate(CodeBuffer* code, int phase) {\n@@ -3863,1 +3863,1 @@\n-  StubGenerator g(code, all);\n+  StubGenerator g(code, phase);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -800,0 +800,5 @@\n+address TemplateInterpreterGenerator::generate_Continuation_doYield_entry(void) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -272,1 +272,1 @@\n-  HeapWord* mem = _thread->tlab().allocate(_word_size);\n+  HeapWord* mem = allocate_inside_tlab_fast();\n@@ -281,0 +281,4 @@\n+HeapWord* MemAllocator::allocate_inside_tlab_fast() const {\n+  return _thread->tlab().allocate(_word_size);\n+}\n+\n@@ -375,0 +379,15 @@\n+oop MemAllocator::try_allocate_in_existing_tlab() {\n+  oop obj = NULL;\n+  {\n+    HeapWord* mem = allocate_inside_tlab_fast();\n+    if (mem != NULL) {\n+      obj = initialize(mem);\n+    } else {\n+      \/\/ The unhandled oop detector will poison local variable obj,\n+      \/\/ so reset it to NULL if mem is NULL.\n+      obj = NULL;\n+    }\n+  }\n+  return obj;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+  HeapWord* allocate_inside_tlab_fast() const;\n@@ -75,0 +76,1 @@\n+  oop try_allocate_in_existing_tlab();\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -394,0 +394,1 @@\n+  assert (!f.is_done(), \"\");\n@@ -479,1 +480,2 @@\n-  if (f.is_compiled_frame() && f.oop_map()->has_derived_oops()) {\n+  if ((is_gc_mode() || UseZGC) && f.is_compiled_frame() && f.oop_map()->has_derived_oops()) {\n+    OrderAccess::loadload();\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1003,0 +1003,6 @@\n+  if (!JvmtiExport::can_support_virtual_threads()) {\n+    return JVMTI_ERROR_MUST_POSSESS_CAPABILITY;\n+  }\n+  if (!Continuations::enabled()) {\n+    return JVMTI_ERROR_NONE; \/\/ Nothing to do when there are no virtual threads;\n+  }\n@@ -1009,3 +1015,0 @@\n-  if (!JvmtiExport::can_support_virtual_threads()) {\n-    return JVMTI_ERROR_MUST_POSSESS_CAPABILITY;\n-  }\n@@ -1113,0 +1116,6 @@\n+  if (!JvmtiExport::can_support_virtual_threads()) {\n+    return JVMTI_ERROR_MUST_POSSESS_CAPABILITY;\n+  }\n+  if (!Continuations::enabled()) {\n+    return JVMTI_ERROR_NONE; \/\/ Nothing to do when there are no virtual threads;\n+  }\n@@ -1117,3 +1126,0 @@\n-  if (!JvmtiExport::can_support_virtual_threads()) {\n-    return JVMTI_ERROR_MUST_POSSESS_CAPABILITY;\n-  }\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -571,0 +571,3 @@\n+  if (!for_cont) {\n+    vf = JvmtiEnvBase::check_and_skip_hidden_frames(java_thread, (javaVFrame*)vf);\n+  }\n@@ -1167,1 +1170,0 @@\n-    Method* method = jvf->method();\n@@ -1278,3 +1280,2 @@\n-  vframe* vf = jvf;\n-  for (int d = 0; vf != NULL && d < depth; d++) {\n-    vf = vf->java_sender();\n+  for (int d = 0; jvf != NULL && d < depth; d++) {\n+    jvf = jvf->java_sender();\n@@ -1282,1 +1283,1 @@\n-  if (vf == NULL) {\n+  if (jvf == NULL) {\n@@ -1285,1 +1286,1 @@\n-  if (!vf->is_java_frame() || ((javaVFrame*)vf)->method()->is_native()) {\n+  if (jvf->method()->is_native()) {\n@@ -1288,3 +1289,2 @@\n-  assert(vf->frame_pointer() != NULL, \"frame pointer mustn't be NULL\");\n-\n-  int frame_number = (int)get_frame_count(jvf) - depth;\n+  assert(jvf->frame_pointer() != NULL, \"frame pointer mustn't be NULL\");\n+  int frame_number = (int)get_frame_count(jvf);\n@@ -2199,2 +2199,1 @@\n-  vframe *vf = JvmtiEnvBase::vframe_for_no_process(java_thread, _depth);\n-  if (vf == NULL) {\n+  if (!java_thread->has_last_Java_frame()) {\n@@ -2204,10 +2203,3 @@\n-  vf = JvmtiEnvBase::check_and_skip_hidden_frames(java_thread, (javaVFrame*)vf);\n-  if (!vf->is_java_frame() || ((javaVFrame*) vf)->method()->is_native()) {\n-    _result = JVMTI_ERROR_OPAQUE_FRAME;\n-    return;\n-  }\n-\n-  assert(vf->frame_pointer() != NULL, \"frame pointer mustn't be NULL\");\n-  int frame_number = _state->count_frames() - _depth;\n-  _state->env_thread_state((JvmtiEnvBase*)_env)->set_frame_pop(frame_number);\n-  _result = JVMTI_ERROR_NONE;\n+  RegisterMap reg_map(java_thread, true \/* update_map *\/, false \/* process_frames *\/, true \/* walk_cont *\/);\n+  javaVFrame* jvf = JvmtiEnvBase::get_cthread_last_java_vframe(java_thread, &reg_map);\n+  _result = ((JvmtiEnvBase*)_env)->set_frame_pop(_state, jvf, _depth);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":13,"deletions":21,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -876,1 +876,1 @@\n-\/\/ HandshakeClosure to set frame pop for a virtual thread..\n+\/\/ HandshakeClosure to set frame pop for a virtual thread.\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -383,1 +383,1 @@\n-    \/\/ Virtual threads support. There is a performance impact of VTMT transitions enabled.\n+    \/\/ Virtual threads support. There is a performance impact when VTMT transitions are enabled.\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -133,3 +133,1 @@\n-  if (java_lang_VirtualThread::notify_jvmti_events()) {\n-    jc.can_support_virtual_threads = 1;\n-  }\n+  jc.can_support_virtual_threads = 1;\n","filename":"src\/hotspot\/share\/prims\/jvmtiManageCapabilities.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -292,0 +292,6 @@\n+#ifdef ASSERT\n+    if (attempts > 0) {\n+      thread->set_is_VTMT_disabler(true);\n+    }\n+#endif\n+  }\n@@ -297,1 +303,0 @@\n-    thread->set_is_VTMT_disabler(true);\n@@ -299,1 +304,0 @@\n-  }\n@@ -327,1 +331,1 @@\n-  int attempts = 10000;\n+  int attempts = 50000;\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -370,1 +370,1 @@\n-  assert(cont.chunk_invariant(tty), \"\");\n+  assert(cont.chunk_invariant(), \"\");\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,33 +65,0 @@\n-#define CONT_JFR false \/\/ emit low-level JFR events that count slow\/fast path for continuation peformance debugging only\n-#if CONT_JFR\n-  #define CONT_JFR_ONLY(code) code\n-#else\n-  #define CONT_JFR_ONLY(code)\n-#endif\n-\n-#if CONT_JFR\n-class FreezeThawJfrInfo : public StackObj {\n-  short _e_size;\n-  short _e_num_interpreted_frames;\n- public:\n-\n-  FreezeThawJfrInfo() : _e_size(0), _e_num_interpreted_frames(0) {}\n-  inline void record_interpreted_frame() { _e_num_interpreted_frames++; }\n-  inline void record_size_copied(int size) { _e_size += size << LogBytesPerWord; }\n-  template<typename Event> void post_jfr_event(Event *e, oop continuation, JavaThread* jt);\n-};\n-\n-template<typename Event> void FreezeThawJfrInfo::post_jfr_event(Event* e, oop continuation, JavaThread* jt) {\n-  if (e->should_commit()) {\n-    log_develop_trace(continuations)(\"JFR event: iframes: %d size: %d\", _e_num_interpreted_frames, _e_size);\n-    e->set_carrierThread(JFR_JVM_THREAD_ID(jt));\n-    e->set_contClass(continuation->klass());\n-    e->set_numIFrames(_e_num_interpreted_frames);\n-    e->set_size(_e_size);\n-    e->commit();\n-  }\n-}\n-#endif \/\/ CONT_JFR\n-\n-static const bool TEST_THAW_ONE_CHUNK_FRAME = false; \/\/ force thawing frames one-at-a-time for testing\n-\n@@ -177,0 +144,9 @@\n+static const bool TEST_THAW_ONE_CHUNK_FRAME = false; \/\/ force thawing frames one-at-a-time for testing\n+\n+#define CONT_JFR false \/\/ emit low-level JFR events that count slow\/fast path for continuation peformance debugging only\n+#if CONT_JFR\n+  #define CONT_JFR_ONLY(code) code\n+#else\n+  #define CONT_JFR_ONLY(code)\n+#endif\n+\n@@ -194,1 +170,1 @@\n-static bool do_verify_after_thaw(JavaThread* thread, bool barriers, stackChunkOop chunk, outputStream* st);\n+static bool do_verify_after_thaw(JavaThread* thread, stackChunkOop chunk, outputStream* st);\n@@ -330,0 +306,24 @@\n+#if CONT_JFR\n+class FreezeThawJfrInfo : public StackObj {\n+  short _e_size;\n+  short _e_num_interpreted_frames;\n+ public:\n+\n+  FreezeThawJfrInfo() : _e_size(0), _e_num_interpreted_frames(0) {}\n+  inline void record_interpreted_frame() { _e_num_interpreted_frames++; }\n+  inline void record_size_copied(int size) { _e_size += size << LogBytesPerWord; }\n+  template<typename Event> void post_jfr_event(Event *e, oop continuation, JavaThread* jt);\n+};\n+\n+template<typename Event> void FreezeThawJfrInfo::post_jfr_event(Event* e, oop continuation, JavaThread* jt) {\n+  if (e->should_commit()) {\n+    log_develop_trace(continuations)(\"JFR event: iframes: %d size: %d\", _e_num_interpreted_frames, _e_size);\n+    e->set_carrierThread(JFR_JVM_THREAD_ID(jt));\n+    e->set_contClass(continuation->klass());\n+    e->set_numIFrames(_e_num_interpreted_frames);\n+    e->set_size(_e_size);\n+    e->commit();\n+  }\n+}\n+#endif \/\/ CONT_JFR\n+\n@@ -365,1 +365,0 @@\n-\n@@ -368,0 +367,3 @@\n+  \/\/ slow path\n+  virtual stackChunkOop allocate_chunk_slow(size_t stack_size) = 0;\n+\n@@ -395,3 +397,0 @@\n-\n-protected:\n-  virtual stackChunkOop allocate_chunk_slow(size_t stack_size) = 0;\n@@ -409,1 +408,1 @@\n-  inline bool is_chunk_available(intptr_t* frame_sp\n+  inline bool is_chunk_available_for_fast_freeze(intptr_t* frame_sp\n@@ -498,1 +497,1 @@\n-bool Freeze<ConfigT>::is_chunk_available(intptr_t* frame_sp\n+bool Freeze<ConfigT>::is_chunk_available_for_fast_freeze(intptr_t* frame_sp\n@@ -505,1 +504,1 @@\n-    log_develop_trace(continuations)(\"is_chunk_available %s\", chunk == nullptr ? \"no chunk\" : \"chunk requires barriers\");\n+    log_develop_trace(continuations)(\"chunk available %s\", chunk == nullptr ? \"no chunk\" : \"chunk requires barriers\");\n@@ -523,1 +522,1 @@\n-  log_develop_trace(continuations)(\"is_chunk_available: %d size: %d argsize: %d top: \" INTPTR_FORMAT \" bottom: \" INTPTR_FORMAT,\n+  log_develop_trace(continuations)(\"chunk available: %d size: %d argsize: %d top: \" INTPTR_FORMAT \" bottom: \" INTPTR_FORMAT,\n@@ -532,1 +531,1 @@\n-  assert(_cont.chunk_invariant(tty), \"\");\n+  assert(_cont.chunk_invariant(), \"\");\n@@ -549,1 +548,1 @@\n-  bool is_chunk_available0 = is_chunk_available(frame_sp, &is_chunk_available_size);\n+  bool is_chunk_available0 = is_chunk_available_for_fast_freeze(frame_sp, &is_chunk_available_size);\n@@ -592,1 +591,1 @@\n-    assert(!is_chunk_available(frame_sp), \"\");\n+    assert(!is_chunk_available_for_fast_freeze(frame_sp), \"\");\n@@ -663,1 +662,1 @@\n-  assert(_cont.chunk_invariant(tty), \"\");\n+  assert(_cont.chunk_invariant(), \"\");\n@@ -1170,1 +1169,1 @@\n-  assert(_cont.chunk_invariant(tty), \"\");\n+  assert(_cont.chunk_invariant(), \"\");\n@@ -1203,1 +1202,0 @@\n-  stackChunkOop chunk;\n@@ -1205,4 +1203,3 @@\n-  HeapWord* start = current->tlab().allocate(size_in_words);\n-  if (start != nullptr) {\n-    chunk = stackChunkOopDesc::cast(allocator.StackChunkAllocator::initialize(start));\n-  } else {\n+  oop fast_oop = allocator.try_allocate_in_existing_tlab();\n+  oop chunk_oop = fast_oop;\n+  if (chunk_oop == nullptr) {\n@@ -1211,6 +1208,4 @@\n-    _jvmti_event_collector->start(); \/\/ can safepoint\n-\n-    chunk = stackChunkOopDesc::cast(allocator.allocate()); \/\/ can safepoint\n-\n-    if (chunk == nullptr) { \/\/ OOME\n-      return nullptr;\n+    _jvmti_event_collector->start();  \/\/ can safepoint\n+    chunk_oop = allocator.allocate(); \/\/ can safepoint\n+    if (chunk_oop == nullptr) {\n+      return nullptr; \/\/ OOME\n@@ -1220,0 +1215,1 @@\n+  stackChunkOop chunk = stackChunkOopDesc::cast(chunk_oop);\n@@ -1231,7 +1227,0 @@\n-  chunk->set_mark(chunk->mark().set_age(15)); \/\/ Promote young chunks quickly\n-\n-  stackChunkOop chunk0 = _cont.tail();\n-  if (chunk0 != nullptr && chunk0->is_empty()) {\n-    chunk0 = chunk0->parent();\n-    assert(chunk0 == nullptr || !chunk0->is_empty(), \"\");\n-  }\n@@ -1239,1 +1228,1 @@\n-  chunk->set_parent_raw<typename ConfigT::OopT>(chunk0);\n+  chunk->set_parent_raw<typename ConfigT::OopT>(_cont.last_nonempty_chunk());\n@@ -1244,1 +1233,1 @@\n-  if (start != nullptr) {\n+  if (fast_oop != nullptr) {\n@@ -1403,1 +1392,1 @@\n-  if (fast && fr.is_chunk_available(sp)) {\n+  if (fast && fr.is_chunk_available_for_fast_freeze(sp)) {\n@@ -1550,6 +1539,0 @@\n-#ifdef ASSERT\n-  public:\n-    bool barriers() { return _barriers; }\n-  protected:\n-#endif\n-\n@@ -1580,0 +1563,2 @@\n+  inline bool seen_by_gc();\n+\n@@ -1740,1 +1725,1 @@\n-  assert(_cont.chunk_invariant(tty), \"\");\n+  assert(_cont.chunk_invariant(), \"\");\n@@ -1780,0 +1765,4 @@\n+inline bool ThawBase::seen_by_gc() {\n+  return _barriers | _cont.tail()->is_gc_mode();\n+}\n+\n@@ -1816,1 +1805,1 @@\n-  assert(_cont.chunk_invariant(tty), \"\");\n+  assert(_cont.chunk_invariant(), \"\");\n@@ -1944,1 +1933,1 @@\n-  if (UNLIKELY(_barriers)) {\n+  if (UNLIKELY(seen_by_gc())) {\n@@ -2004,1 +1993,1 @@\n-  if (!stub_caller && UNLIKELY(_barriers)) { \/\/ recurse_thaw_stub_frame already invoked our barriers with a full regmap\n+  if (!stub_caller && UNLIKELY(seen_by_gc())) { \/\/ recurse_thaw_stub_frame already invoked our barriers with a full regmap\n@@ -2059,2 +2048,1 @@\n-    \/\/ can only fix caller once this frame is thawed (due to callee saved regs)\n-    \/\/ This happens on the stack\n+    \/\/ can only fix caller once this frame is thawed (due to callee saved regs); this happens on the stack\n@@ -2078,1 +2066,1 @@\n-    if (UNLIKELY(_barriers)) { \/\/ we're now doing this on the stub's caller\n+    if (UNLIKELY(seen_by_gc())) { \/\/ we're now doing this on the stub's caller\n@@ -2118,1 +2106,1 @@\n-    if (_barriers) {\n+    if (seen_by_gc()) {\n@@ -2211,1 +2199,1 @@\n-    assert(do_verify_after_thaw(thread, thw.barriers(), cont.tail(), tty), \"\");\n+    assert(do_verify_after_thaw(thread, cont.tail(), tty), \"\");\n@@ -2277,1 +2265,1 @@\n-static bool do_verify_after_thaw(JavaThread* thread, bool barriers, stackChunkOop chunk, outputStream* st) {\n+static bool do_verify_after_thaw(JavaThread* thread, stackChunkOop chunk, outputStream* st) {\n@@ -2297,1 +2285,1 @@\n-      st->print_cr(\"Failed for frame barriers: %d %d\", barriers, chunk->requires_barriers());\n+      st->print_cr(\"Failed for frame barriers: %d\",chunk->requires_barriers());\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":73,"deletions":85,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-bool ContinuationWrapper::chunk_invariant(outputStream* st) {\n+bool ContinuationWrapper::chunk_invariant() const {\n@@ -92,2 +92,0 @@\n-      st->print_cr(\"i: %d\", i);\n-      chunk->print_on(true, st);\n","filename":"src\/hotspot\/share\/runtime\/continuationWrapper.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -132,2 +132,1 @@\n-  stackChunkOop last_nonempty_chunk() const { return nonempty_chunk(_tail); }\n-  inline stackChunkOop nonempty_chunk(stackChunkOop chunk) const;\n+  inline stackChunkOop last_nonempty_chunk() const;\n@@ -138,1 +137,1 @@\n-  bool chunk_invariant(outputStream* st);\n+  bool chunk_invariant() const;\n@@ -184,2 +183,4 @@\n-inline stackChunkOop ContinuationWrapper::nonempty_chunk(stackChunkOop chunk) const {\n-  while (chunk != nullptr && chunk->is_empty()) {\n+inline stackChunkOop ContinuationWrapper::last_nonempty_chunk() const {\n+  assert(chunk_invariant(), \"\");\n+  stackChunkOop chunk = _tail;\n+  if (chunk != nullptr && chunk->is_empty()) {\n@@ -188,0 +189,1 @@\n+  assert(chunk == nullptr || !chunk->is_empty(), \"\");\n","filename":"src\/hotspot\/share\/runtime\/continuationWrapper.inline.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-     * Max size of the internal buffer or -1 if internal buffer cannot be resized.\n+     * Max size of the internal buffer.\n@@ -67,1 +67,1 @@\n-     * Returns the buffer size to use when no output buffer size specified\n+     * Returns the buffer size to use when no output buffer size specified.\n@@ -91,1 +91,0 @@\n-            this.maxBufSize = maxSize;\n@@ -96,1 +95,0 @@\n-            this.maxBufSize = -1;\n@@ -98,0 +96,1 @@\n+        this.maxBufSize = maxSize;\n@@ -135,0 +134,2 @@\n+     *\n+     * This method should only be called while holding the lock.\n@@ -137,7 +138,7 @@\n-        if (maxBufSize > 0) {\n-            int neededSize = count + len + 1;\n-            int bufSize = buf.length;\n-            if (neededSize > bufSize && bufSize < maxBufSize) {\n-                int newSize = Math.min(neededSize, maxBufSize);\n-                buf = Arrays.copyOf(buf, newSize);\n-            }\n+        int neededSize = count + len + 1;\n+        if (neededSize < 0)\n+            neededSize = Integer.MAX_VALUE;\n+        int bufSize = buf.length;\n+        if (neededSize > bufSize && bufSize < maxBufSize) {\n+            int newSize = Math.min(neededSize, maxBufSize);\n+            buf = Arrays.copyOf(buf, newSize);\n@@ -210,2 +211,1 @@\n-        int max = (maxBufSize > 0) ? maxBufSize : buf.length;\n-        if (len >= max) {\n+        if (len >= maxBufSize) {\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedOutputStream.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -139,0 +139,2 @@\n+     *\n+     * This method should only be called while holding the lock.\n@@ -142,0 +144,2 @@\n+        if (neededSize < 0)\n+            neededSize = Integer.MAX_VALUE;\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedWriter.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -207,1 +207,1 @@\n-    public void mark(int readlimit) {\n+    public synchronized void mark(int readlimit) {\n@@ -233,1 +233,1 @@\n-    public void reset() throws IOException {\n+    public synchronized void reset() throws IOException {\n","filename":"src\/java.base\/share\/classes\/java\/io\/FilterInputStream.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1420,1 +1420,1 @@\n-                    implFormat(format, args);\n+                    implFormat(l, format, args);\n","filename":"src\/java.base\/share\/classes\/java\/io\/PrintStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,0 +53,10 @@\n+    \/**\n+     * Temporary buffer used to hold writes of strings and single characters\n+     *\/\n+    private char[] writeBuffer;\n+\n+    \/**\n+     * Size of writeBuffer, must be >= 1\n+     *\/\n+    private static final int WRITE_BUFFER_SIZE = 1024;\n+\n@@ -155,14 +165,0 @@\n-    \/**\n-     * Creates a new character-stream writer whose critical sections will\n-     * synchronize on the given object.\n-     *\n-     * @param  lock\n-     *         Object to synchronize on\n-     *\/\n-    protected Writer(Object lock) {\n-        if (lock == null) {\n-            throw new NullPointerException();\n-        }\n-        this.lock = lock;\n-    }\n-\n@@ -184,0 +180,14 @@\n+    \/**\n+     * Creates a new character-stream writer whose critical sections will\n+     * synchronize on the given object.\n+     *\n+     * @param  lock\n+     *         Object to synchronize on\n+     *\/\n+    protected Writer(Object lock) {\n+        if (lock == null) {\n+            throw new NullPointerException();\n+        }\n+        this.lock = lock;\n+    }\n+\n@@ -199,1 +209,19 @@\n-        var writeBuffer = new char[1];\n+        Object lock = this.lock;\n+        if (lock instanceof InternalLock locker) {\n+            locker.lock();\n+            try {\n+                implWrite(c);\n+            } finally {\n+                locker.unlock();\n+            }\n+        } else {\n+            synchronized (lock) {\n+                implWrite(c);\n+            }\n+        }\n+    }\n+\n+    private void implWrite(int c) throws IOException {\n+        if (writeBuffer == null){\n+            writeBuffer = new char[WRITE_BUFFER_SIZE];\n+        }\n@@ -280,2 +308,25 @@\n-        Objects.checkFromIndexSize(off, len, str.length());\n-        char cbuf[] = new char[len];\n+        Object lock = this.lock;\n+        if (lock instanceof InternalLock locker) {\n+            locker.lock();\n+            try {\n+                implWrite(str, off, len);\n+            } finally {\n+                locker.unlock();\n+            }\n+        } else {\n+            synchronized (lock) {\n+                implWrite(str, off, len);\n+            }\n+        }\n+    }\n+\n+    private void implWrite(String str, int off, int len) throws IOException {\n+        char cbuf[];\n+        if (len <= WRITE_BUFFER_SIZE) {\n+            if (writeBuffer == null) {\n+                writeBuffer = new char[WRITE_BUFFER_SIZE];\n+            }\n+            cbuf = writeBuffer;\n+        } else {    \/\/ Don't permanently allocate very large buffers.\n+            cbuf = new char[len];\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/Writer.java","additions":68,"deletions":17,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -209,1 +209,2 @@\n-    \/\/ Additional fields for platform threads\n+    \/\/ Additional fields for platform threads.\n+    \/\/ All fields, except task, are accessed directly by the VM.\n@@ -601,1 +602,1 @@\n-            \/\/ getContextClassLoader not trusted\n+            \/\/ skip call to getContextClassLoader\n@@ -748,0 +749,12 @@\n+     * <p> <a id=\"ofplatform-security\"><b>Interaction with security manager when\n+     * creating platform threads<\/b><\/a>\n+     * <p> Creating a platform thread when there is a security manager set will\n+     * invoke the security manager's {@link SecurityManager#checkAccess(ThreadGroup)\n+     * checkAccess(ThreadGroup)} method with the thread's thread group.\n+     * If the thread group has not been set with the {@link\n+     * Builder.OfPlatform#group(ThreadGroup) OfPlatform.group} method then the\n+     * security manager's {@link SecurityManager#getThreadGroup() getThreadGroup}\n+     * method will be invoked first to select the thread group. If the security\n+     * manager {@code getThreadGroup} method returns {@code null} then the thread\n+     * group of the constructing thread is used.\n+     *\n@@ -762,1 +775,0 @@\n-     * @throws UnsupportedOperationException if preview features are not enabled\n@@ -767,1 +779,0 @@\n-        PreviewFeatures.ensureEnabled();\n@@ -910,0 +921,1 @@\n+         *\n@@ -912,0 +924,4 @@\n+         * @throws SecurityException if denied by the security manager\n+         *         (See <a href=\"Thread.html#ofplatform-security\">Interaction with\n+         *         security manager when creating platform threads<\/a>)\n+         *\n@@ -922,0 +938,4 @@\n+         * @throws SecurityException if denied by the security manager\n+         *         (See <a href=\"Thread.html#ofplatform-security\">Interaction with\n+         *         security manager when creating platform threads<\/a>)\n+         *\n@@ -960,12 +980,0 @@\n-            \/**\n-             * @throws SecurityException if a thread group has been set and the current\n-             *         thread cannot create a thread in that thread group\n-             *\/\n-            @Override Thread unstarted(Runnable task);\n-\n-            \/**\n-             * @throws SecurityException if a thread group has been set and the current\n-             *         thread cannot create a thread in that thread group\n-             *\/\n-            @Override Thread start(Runnable task);\n-\n@@ -1552,1 +1560,1 @@\n-     * Null out reference after Thread termination (JDK-4006245)\n+     * Null out reference after Thread termination.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -57,7 +57,9 @@\n- * <h2><a id=\"virtualthreadgroup\">The ThreadGroup for virtual threads<\/a><\/h2>\n- * <a href=\"Thread.html#virtual-threads\">Virtual threads<\/a> are considered members\n- * of a special thread group that is created by the Java runtime. The thread group\n- * differs to other thread groups in that its maximum priority is fixed and cannot\n- * be changed with the {@link #setMaxPriority(int) setMaxPriority} method.\n- * Virtual threads are not included in the estimated thread count returned by\n- * the {@link #activeCount() activeCount} method, are not enumerated by the {@link\n+ * <h2><a id=\"virtualthreadgroup\">Thread groups and virtual threads<\/a><\/h2>\n+ * The Java runtime creates a special thread group for\n+ * <a href=\"Thread.html#virtual-threads\">virtual threads<\/a>. This group is\n+ * returned by the {@link Thread#getThreadGroup() Thread.getThreadGroup} method\n+ * when invoked on a virtual thread. The thread group differs to other thread\n+ * groups in that its maximum priority is fixed and cannot be changed with the\n+ * {@link #setMaxPriority(int) setMaxPriority} method.\n+ * Virtual threads are not included in the estimated thread count returned by the\n+ * {@link #activeCount() activeCount} method, are not enumerated by the {@link\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ThreadGroup.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+import jdk.internal.access.JavaUtilConcurrentFJPAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -3666,7 +3668,3 @@\n-     * Invoked reflectively by jdk.internal.misc.Blocker to mark the beginning\n-     * of a possibly blocking operation on a virtual thread that pins the\n-     * underlying carrier thread in this pool.\n-     *\n-     * This method works like managedBlock and invokes tryCompensate to create\n-     * or re-activate a spare thread to compensate for the blocked thread. When\n-     * the blocking operation is done then endCompensatedBlock must be invoked\n+     * Invokes tryCompensate to create or re-activate a spare thread to\n+     * compensate for a thread that performs a blocking operation. When the\n+     * blocking operation is done then endCompensatedBlock must be invoked\n@@ -3687,3 +3685,1 @@\n-     * Invoked reflectively by jdk.internal.misc.Blocker to mark the end of\n-     * a blocking operation on a virtual thread that pinned the underlying\n-     * carrier thread in this pool.\n+     * Re-adjusts parallelism after a blocking operation completes.\n@@ -3739,0 +3735,11 @@\n+        \/\/ allow access to non-public methods\n+        SharedSecrets.setJavaUtilConcurrentFJPAccess(\n+            new JavaUtilConcurrentFJPAccess() {\n+                @Override\n+                public long beginCompensatedBlock(ForkJoinPool pool) {\n+                    return pool.beginCompensatedBlock();\n+                }\n+                public void endCompensatedBlock(ForkJoinPool pool, long post) {\n+                    pool.endCompensatedBlock(post);\n+                }\n+            });\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.access;\n+\n+import java.util.concurrent.ForkJoinPool;\n+\n+public interface JavaUtilConcurrentFJPAccess {\n+    long beginCompensatedBlock(ForkJoinPool pool);\n+    void endCompensatedBlock(ForkJoinPool pool, long post);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaUtilConcurrentFJPAccess.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.concurrent.ForkJoinPool;\n@@ -80,0 +81,1 @@\n+    private static JavaUtilConcurrentFJPAccess javaUtilConcurrentFJPAccess;\n@@ -117,0 +119,11 @@\n+    public static void setJavaUtilConcurrentFJPAccess(JavaUtilConcurrentFJPAccess access) {\n+        javaUtilConcurrentFJPAccess = access;\n+    }\n+\n+    public static JavaUtilConcurrentFJPAccess getJavaUtilConcurrentFJPAccess() {\n+        if (javaUtilConcurrentFJPAccess == null) {\n+            ensureClassInitialized(ForkJoinPool.class);\n+        }\n+        return javaUtilConcurrentFJPAccess;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,5 +28,0 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.security.AccessController;\n-import java.security.PrivilegedExceptionAction;\n@@ -35,0 +30,1 @@\n+import jdk.internal.access.JavaUtilConcurrentFJPAccess;\n@@ -69,1 +65,1 @@\n-     * Marks the beginning of possibly blocking operation.\n+     * Marks the beginning of a possibly blocking operation.\n@@ -76,3 +72,11 @@\n-            long comp = ForkJoinPools.beginCompensatedBlock(ct.getPool());\n-            assert currentCarrierThread() == ct;\n-            return comp;\n+            boolean completed = false;\n+            try {\n+                long comp = ForkJoinPools.beginCompensatedBlock(ct.getPool());\n+                assert currentCarrierThread() == ct;\n+                completed = true;\n+                return comp;\n+            } finally {\n+                if (!completed) {\n+                    ct.endBlocking();\n+                }\n+            }\n@@ -84,1 +88,1 @@\n-     * Marks the beginning of possibly blocking operation.\n+     * Marks the beginning of a possibly blocking operation.\n@@ -94,1 +98,1 @@\n-     * Marks the end an operation that may have blocked.\n+     * Marks the end of an operation that may have blocked.\n@@ -107,1 +111,2 @@\n-     * Defines static methods to invoke non-public ForkJoinPool methods.\n+     * Defines static methods to invoke non-public ForkJoinPool methods via the\n+     * shared secret support.\n@@ -110,17 +115,2 @@\n-        private static final Unsafe U = Unsafe.getUnsafe();\n-        private static final MethodHandle beginCompensatedBlock, endCompensatedBlock;\n-        static {\n-            try {\n-                PrivilegedExceptionAction<MethodHandles.Lookup> pa = () ->\n-                    MethodHandles.privateLookupIn(ForkJoinPool.class, MethodHandles.lookup());\n-                @SuppressWarnings(\"removal\")\n-                MethodHandles.Lookup l = AccessController.doPrivileged(pa);\n-                MethodType methodType = MethodType.methodType(long.class);\n-                beginCompensatedBlock = l.findVirtual(ForkJoinPool.class, \"beginCompensatedBlock\", methodType);\n-                methodType = MethodType.methodType(void.class, long.class);\n-                endCompensatedBlock = l.findVirtual(ForkJoinPool.class, \"endCompensatedBlock\", methodType);\n-\n-            } catch (Exception e) {\n-                throw new InternalError(e);\n-            }\n-        }\n+        private static final JavaUtilConcurrentFJPAccess FJP_ACCESS =\n+                SharedSecrets.getJavaUtilConcurrentFJPAccess();\n@@ -128,6 +118,1 @@\n-            try {\n-                return (long) beginCompensatedBlock.invoke(pool);\n-            } catch (Throwable e) {\n-                U.throwException(e);\n-            }\n-            return 0;\n+            return FJP_ACCESS.beginCompensatedBlock(pool);\n@@ -136,5 +121,1 @@\n-            try {\n-                endCompensatedBlock.invoke(pool, post);\n-            } catch (Throwable e) {\n-                U.throwException(e);\n-            }\n+            FJP_ACCESS.endCompensatedBlock(pool, post);\n@@ -143,0 +124,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Blocker.java","additions":22,"deletions":40,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -262,0 +262,3 @@\n+     * @throws IllegalThreadStateException if the given thread was already started\n+     * @throws WrongThreadException if the current thread is not the owner or a thread\n+     * contained in the flock\n@@ -263,3 +266,1 @@\n-     * cope-local bindings are not the same as when the flock was created\n-     * @throws IllegalThreadStateException if the thread has already started,\n-     * or the current thread is not the owner or a thread contained in the flock\n+      * scope-local bindings are not the same as when the flock was created\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/ThreadFlock.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -42,8 +42,1 @@\n-    private static class ThreadRef {\n-        private final Thread thread;\n-        ThreadRef(Thread thread) {\n-            this.thread = thread;\n-        }\n-        Thread thread() {\n-            return thread;\n-        }\n+    private record ThreadRef(Thread thread) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/ThreadTracker.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -88,7 +88,6 @@\n-        switch (reason) {\n-            case 2: return Pinned.CRITICAL_SECTION;\n-            case 3: return Pinned.NATIVE;\n-            case 4: return Pinned.MONITOR;\n-            default:\n-                throw new AssertionError(\"Unknown pinned reason: \" + reason);\n-        }\n+        return switch (reason) {\n+            case 2 -> Pinned.CRITICAL_SECTION;\n+            case 3 -> Pinned.NATIVE;\n+            case 4 -> Pinned.MONITOR;\n+            default -> throw new AssertionError(\"Unknown pinned reason: \" + reason);\n+        };\n@@ -310,1 +309,1 @@\n-    private static int doYield() { throw new Error(\"Intrinsic not installed\"); };\n+    private static int doYield() { throw new Error(\"Intrinsic not installed\"); }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/Continuation.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * method being unlined into is also annotated ChangesCurrentThread.\n+ * method being inlined into is also annotated ChangesCurrentThread.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/ChangesCurrentThread.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2024,4 +2024,4 @@\n-            (Error INVALID_THREAD \"The thread is null, not a valid thread, the thread \"\n-                                  \"is not alive, or the thread is a virtual thread \"\n-                                  \"and the target VM does not support stopping it \"\n-                                  \"with an asynchronous exception at this time.\")\n+            (Error INVALID_THREAD \"The thread is null, not a valid thread, or the thread \"\n+                                  \"is not alive.\")\n+            (Error NOT_IMPLEMENTED \"The thread is a virtual thread and the target \"\n+                                  \"VM does not support the command on virtual threads.\")\n@@ -2150,8 +2150,6 @@\n-            (Error OPAQUE_FRAME      \"Attempted to return early from \"\n-                                     \"a frame corresponding to a native \"\n-                                     \"method. \"\n-                                     \"The thread is a virtual thread and the target \"\n-                                     \"VM is unable force its current frame to return. \"\n-                                     \"Or the implementation is \"\n-                                     \"unable to provide this functionality \"\n-                                     \"on this frame.\")\n+            (Error OPAQUE_FRAME      \"Attempted to return early from a frame \"\n+                                     \"corresponding to a native method, \"\n+                                     \"the thread is a virtual thread and the target \"\n+                                     \"VM is unable to force its current frame to return, \"\n+                                     \"or the implementation is unable to provide this \"\n+                                     \"functionality on this frame.\")\n","filename":"src\/java.se\/share\/data\/jdwp\/jdwp.spec","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-     * @param message the detail messag, can be {@code null}\n+     * @param message the detail message, can be {@code null}\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/OpaqueFrameException.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/ThreadGroupReference.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -128,3 +128,4 @@\n-     * @throws IllegalThreadStateException if the thread has terminated,\n-     * or the thread is a virtual thread that cannot be stopped with an\n-     * asynchronous exception at this time\n+     * @throws IllegalThreadStateException if the thread has terminated\n+     * @throws UnsupportedOperationException if the thread is a virtual\n+     * thread and the target VM does not support this operation on\n+     * virtual threads\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/ThreadReference.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-import com.sun.jdi.request.ThreadStartRequest;\n@@ -48,0 +47,1 @@\n+import com.sun.jdi.request.ThreadStartRequest;\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/VirtualMachine.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,2 +56,0 @@\n-     * The behavior of this method is unspecified when the event is restricted\n-     * to only platform threads.\n@@ -68,2 +66,0 @@\n-     * The behavior of this method is unspecified when the event is restricted\n-     * to a specific thread.\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/request\/ThreadDeathRequest.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,2 +56,0 @@\n-     * The behavior of this method is unspecified when the event is restricted\n-     * to only platform threads.\n@@ -68,2 +66,0 @@\n-     * The behavior of this method is unspecified when the event is restricted\n-     * to a specific thread.\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/request\/ThreadStartRequest.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -723,0 +723,2 @@\n+            } catch (UnsupportedOperationException uoe) {\n+                MessageOutput.println(\"Operation is not supported on the target VM\");\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/Commands.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    boolean trackVthreads;\n+    private final boolean trackVthreads;\n@@ -122,2 +122,2 @@\n-            \/\/ then the ThreadDeathReqest was setup to filter out vthreads. So we'll need\n-            \/\/ to create a special ThreadDeathReqest just to detect when this vthread dies.\n+            \/\/ then the ThreadDeathRequest was setup to filter out vthreads. So we'll need\n+            \/\/ to create a special ThreadDeathRequest just to detect when this vthread dies.\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/EventHandler.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    private boolean trackVthreads;\n+    private final boolean trackVthreads;\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/VMConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/StackFrameImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/EventRequestImpl.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -565,3 +565,0 @@\n-\n-            jvmtiDeallocate(theThreads);\n-            jvmtiDeallocate(theVThreads);\n@@ -570,0 +567,3 @@\n+        jvmtiDeallocate(theThreads);\n+        jvmtiDeallocate(theVThreads);\n+\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/VirtualMachineImpl.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -178,0 +178,2 @@\n+        CASE_RETURN_TEXT(JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED)\n+        CASE_RETURN_TEXT(JVMTI_ERROR_UNSUPPORTED_OPERATION)\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/error_messages.c","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventFilter.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventFilter.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -907,1 +907,0 @@\n-    \/*tty_message(\"cbVThreadStart: vthread=%p\", vthread);*\/\n@@ -929,1 +928,0 @@\n-    \/*tty_message(\"cbVThreadEnd: vthread=%p\", vthread);*\/\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.c","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-            \/* This NULL will trigger a AGENT_ERROR_INVALID_EVENT_TYPE *\/\n+            \/* This NULL will trigger an AGENT_ERROR_INVALID_EVENT_TYPE *\/\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/standardHandlers.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -413,1 +413,1 @@\n-                EXIT_ERROR(error, \"getting thread state\");\n+                EXIT_ERROR(error, \"getting vthread state\");\n@@ -1599,1 +1599,1 @@\n-                EXIT_ERROR(error, \"getting thread state\");\n+                EXIT_ERROR(error, \"getting vthread state\");\n@@ -1696,1 +1696,1 @@\n-             * compliment to this that happens during the resumeAll() is handled by\n+             * complement to this that happens during the resumeAll() is handled by\n@@ -2533,5 +2533,0 @@\n-#if 0\n-    tty_message(\"status %s: node(%p) suspendCount(%d) %d %d %s\",\n-                isVThread(thread) ? \"vthread\" : \"thread\",\n-                node, node->suspendCount, *pstatus, *statusFlags, node->name);\n-#endif\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2279,0 +2279,2 @@\n+        case JVMTI_ERROR_UNSUPPORTED_OPERATION:\n+            return JDWP_ERROR(NOT_IMPLEMENTED);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.c","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,2 +87,2 @@\n-    jboolean vthreadsSupported; \/* If true, debugging support for vthreads is enabled.*\/\n-    jboolean enumerateVThreads; \/* If true, JDWP APIs returns vthreads in thread lists. *\/\n+    jboolean vthreadsSupported; \/* If true, debugging support for vthreads is enabled. *\/\n+    jboolean enumerateVThreads; \/* If true, JDWP APIs return vthreads in thread lists. *\/\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-vmTestbase\/nsk\/jdb\/kill\/kill001\/kill001.java                00000000 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList-svc-vthread.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-            String msg = (vthreadMode ? \"Illegal thread state\" : \"killed\");\n+            String msg = (vthreadMode ? \"Operation is not supported\" : \"killed\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/kill\/kill001\/kill001.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-        \/\/ check 'threads', searching for java.lang.Thread main or old-m-a-i-n\n+        \/\/ check 'threads', searching for \"java.lang.Thread\" followed by the main thread name.\n@@ -156,1 +156,1 @@\n-            v.add(\"old-m-a-i-n\");\n+            v.add(nsk.share.MainWrapper.OLD_MAIN_THREAD_NAME);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/monitor\/monitor001\/monitor001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -187,1 +187,1 @@\n-        \/\/ check 'threads', searching for java.lang.Thread main or old-m-a-i-n\n+        \/\/ check 'threads', searching for \"java.lang.Thread\" followed by the main thread name.\n@@ -190,1 +190,1 @@\n-            v.add(\"old-m-a-i-n\");\n+            v.add(nsk.share.MainWrapper.OLD_MAIN_THREAD_NAME);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/unmonitor\/unmonitor001\/unmonitor001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -250,4 +250,4 @@\n-                 * With the added wrapper support, it will also contain \"old-m-a-i-n\". However,\n-                 * when run with vthread wrapper, it will only have \"Thread2\" since \"main\" and\n-                 * \"old-m-a-i-n\" will be vthreads, which are always considered to be in the\n-                 * \"VirtualThreads\" ThreadGroup, and threfore do not show up in group1.\n+                 * With the added wrapper support, it will also contain the original main thread.\n+                 * However, when run with vthread wrapper, it will only have \"Thread2\" since \"main\"\n+                 * and original main thread will be vthreads, which are always considered to be in\n+                 * the \"VirtualThreads\" ThreadGroup, and threfore do not show up in group1.\n@@ -275,1 +275,1 @@\n-                    if (s1.equals(\"old-m-a-i-n\"))\n+                    if (s1.equals(nsk.share.MainWrapper.OLD_MAIN_THREAD_NAME))\n@@ -286,1 +286,2 @@\n-                        log3(\"ERROR: # of 'old-m-a-i-n' threads != 1  : \" + nOldMain);\n+                        log3(\"ERROR: # of '\" + nsk.share.MainWrapper.OLD_MAIN_THREAD_NAME +\n+                             \"' threads != 1  : \" + nOldMain);\n@@ -291,1 +292,2 @@\n-                        log3(\"ERROR: # of 'old-m-a-i-n' threads != 0  : \" + nOldMain);\n+                        log3(\"ERROR: # of '\" + nsk.share.MainWrapper.OLD_MAIN_THREAD_NAME +\n+                             \"n' threads != 0  : \" + nOldMain);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadGroupReference\/threads\/threads001.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -249,3 +249,3 @@\n-                                      \/\/ When using the jtreg wrapper, the main thread is renamed to old-m-a-i-n,\n-                                      \/\/ and a new \"main\" vthread is created. However, the rename happens after\n-                                      \/\/ the debug agent has already generated the THREAD_START event for the\n+                                      \/\/ When using the jtreg wrapper, the main thread is renamed, and a new\n+                                      \/\/ \"main\" vthread is created. However, the rename happens after the\n+                                      \/\/ debug agent has already generated the THREAD_START event for the\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadStartEvent\/thread\/thread001.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+    public static final String OLD_MAIN_THREAD_NAME = \"old-m-a-i-n\";\n@@ -71,1 +72,1 @@\n-        Thread.currentThread().setName(\"old-m-a-i-n\");\n+        Thread.currentThread().setName(OLD_MAIN_THREAD_NAME);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/MainWrapper.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,7 +39,3 @@\n-    @Test\n-    public void testOfPlatform() throws Exception {\n-        Method ofPlatform = Thread.class.getDeclaredMethod(\"ofPlatform\");\n-        var exc = expectThrows(InvocationTargetException.class, () -> ofPlatform.invoke(null));\n-        assertTrue(exc.getCause() instanceof UnsupportedOperationException);\n-    }\n-\n+    \/**\n+     * Thread.ofVirtual should fail with UOE.\n+     *\/\n@@ -53,0 +49,3 @@\n+    \/**\n+     * Thread.startVirtualThread should fail with UOE.\n+     *\/\n@@ -62,0 +61,3 @@\n+    \/**\n+     * Executors.newVirtualThreadPerTaskExecutor should fail with UOE.\n+     *\/\n@@ -70,0 +72,3 @@\n+    \/**\n+     * Directly accessing internal Continuation class should fail with UOE.\n+     *\/\n@@ -77,0 +82,30 @@\n+    \/**\n+     * Thread.isVirtual should not fail.\n+     *\/\n+    @Test\n+    public void testIsVirtual() throws Exception {\n+        boolean isVirtual = isVirtual(Thread.currentThread());\n+        assertFalse(isVirtual);\n+    }\n+\n+    \/**\n+     * Thread.ofPlatform should not fail.\n+     *\/\n+    @Test\n+    public void testOfPlatform() throws Exception {\n+        Method ofPlatform = Thread.class.getDeclaredMethod(\"ofPlatform\");\n+        Object builder = ofPlatform.invoke(null);\n+        Method startMethod = Class.forName(\"java.lang.Thread$Builder\")\n+                .getMethod(\"start\", Runnable.class);\n+        Runnable task = () -> { };\n+        Thread thread = (Thread) startMethod.invoke(builder, task);\n+    }\n+\n+    \/**\n+     * Invokes Thread::isVirtual reflectively to test if the given thread is a\n+     * virtual thread.\n+     *\/\n+    private static boolean isVirtual(Thread thread) throws Exception {\n+        Method isVirtualMethod = Thread.class.getDeclaredMethod(\"isVirtual\");\n+        return (boolean) isVirtualMethod.invoke(thread);\n+    }\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/PreviewFeaturesNotEnabled.java","additions":42,"deletions":7,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2047,1 +2047,0 @@\n-\n@@ -2128,1 +2127,0 @@\n-\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadAPI.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -311,0 +311,1 @@\n+                break;\n@@ -341,1 +342,1 @@\n-                        continue;\n+                        break;\n@@ -347,15 +348,0 @@\n-                if (cmd.startsWith(\"-cp\")) {\n-                    skipNext = true;\n-                    args.add(cmd);\n-                    continue;\n-                }\n-                if (cmd.startsWith(\"--add-exports\")) {\n-                    skipNext = true;\n-                    args.add(cmd);\n-                    continue;\n-                }\n-                if (cmd.startsWith(\"--patch-module\")) {\n-                    skipNext = true;\n-                    args.add(cmd);\n-                    continue;\n-                }\n","filename":"test\/lib\/jdk\/test\/lib\/process\/ProcessTools.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"}]}