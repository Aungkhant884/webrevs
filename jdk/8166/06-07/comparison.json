{"files":[{"patch":"@@ -340,0 +340,2 @@\n+    ContinuationGCSupport::transform_stack_chunk(obj);\n+\n@@ -346,2 +348,0 @@\n-\n-    ContinuationGCSupport::transform_stack_chunk(obj);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"utilities\/vmError.hpp\"\n@@ -210,0 +211,4 @@\n+    if (VMError::is_error_reported()) {\n+      return;\n+    }\n+\n","filename":"src\/hotspot\/share\/oops\/accessBackend.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -405,1 +405,1 @@\n-  NOINLINE freeze_result freeze(frame& f, frame& caller, int callee_argsize, bool callee_interpreted, bool top);\n+  NOINLINE freeze_result recurse_freeze(frame& f, frame& caller, int callee_argsize, bool callee_interpreted, bool top);\n@@ -409,2 +409,2 @@\n-  inline void before_freeze_java_frame(const frame& f, const frame& caller, int fsize, int argsize, bool bottom);\n-  inline void after_freeze_java_frame(const frame& hf, bool bottom);\n+  inline void before_freeze_java_frame(const frame& f, const frame& caller, int fsize, int argsize, bool is_bottom_frame);\n+  inline void after_freeze_java_frame(const frame& hf, bool is_bottom_frame);\n@@ -412,1 +412,1 @@\n-  void patch(const frame& f, frame& hf, const frame& caller, bool bottom);\n+  void patch(const frame& f, frame& hf, const frame& caller, bool is_bottom_frame);\n@@ -737,1 +737,1 @@\n-  freeze_result res = freeze(f, caller, 0, false, true);\n+  freeze_result res = recurse_freeze(f, caller, 0, false, true);\n@@ -780,1 +780,1 @@\n-NOINLINE freeze_result FreezeBase::freeze(frame& f, frame& caller, int callee_argsize, bool callee_interpreted, bool top) {\n+NOINLINE freeze_result FreezeBase::recurse_freeze(frame& f, frame& caller, int callee_argsize, bool callee_interpreted, bool top) {\n@@ -827,1 +827,1 @@\n-    freeze_result result = freeze(senderf, caller, argsize, FKind::interpreted, false); \/\/ recursive call\n+    freeze_result result = recurse_freeze(senderf, caller, argsize, FKind::interpreted, false); \/\/ recursive call\n@@ -832,1 +832,1 @@\n-inline void FreezeBase::before_freeze_java_frame(const frame& f, const frame& caller, int fsize, int argsize, bool bottom) {\n+inline void FreezeBase::before_freeze_java_frame(const frame& f, const frame& caller, int fsize, int argsize, bool is_bottom_frame) {\n@@ -836,1 +836,1 @@\n-    ls.print_cr(\"======== FREEZING FRAME interpreted: %d bottom: %d\", f.is_interpreted_frame(), bottom);\n+    ls.print_cr(\"======== FREEZING FRAME interpreted: %d bottom: %d\", f.is_interpreted_frame(), is_bottom_frame);\n@@ -843,1 +843,1 @@\n-inline void FreezeBase::after_freeze_java_frame(const frame& hf, bool bottom) {\n+inline void FreezeBase::after_freeze_java_frame(const frame& hf, bool is_bottom_frame) {\n@@ -850,1 +850,1 @@\n-    if (bottom) {\n+    if (is_bottom_frame) {\n@@ -996,2 +996,2 @@\n-void FreezeBase::patch(const frame& f, frame& hf, const frame& caller, bool bottom) {\n-  if (bottom) {\n+void FreezeBase::patch(const frame& f, frame& hf, const frame& caller, bool is_bottom_frame) {\n+  if (is_bottom_frame) {\n@@ -1031,1 +1031,1 @@\n-         \"frame_sp: \" INTPTR_FORMAT \" Interpreted::frame_top: \" INTPTR_FORMAT,\n+         \"frame_top: \" INTPTR_FORMAT \" Interpreted::frame_top: \" INTPTR_FORMAT,\n@@ -1042,2 +1042,1 @@\n-  intptr_t* const frame_top = ContinuationHelper::InterpretedFrame::frame_top(f, callee_argsize, callee_interpreted);\n-  const int argsize = ContinuationHelper::InterpretedFrame::stack_argsize(f);\n+  intptr_t* const stack_frame_top = ContinuationHelper::InterpretedFrame::frame_top(f, callee_argsize, callee_interpreted);\n@@ -1045,2 +1044,1 @@\n-  assert(ContinuationHelper::InterpretedFrame::frame_bottom(f) >= f.fp() + frame::metadata_words + locals, \"\");\/\/ = on x86\n-  const int fsize = f.fp() + frame::metadata_words + locals - frame_top;\n+  const int fsize = f.fp() + frame::metadata_words + locals - stack_frame_top;\n@@ -1048,1 +1046,4 @@\n-  DEBUG_ONLY(verify_frame_top(f, frame_top));\n+  intptr_t* const stack_frame_bottom = ContinuationHelper::InterpretedFrame::frame_bottom(f);\n+  assert(stack_frame_bottom - stack_frame_top >= fsize, \"\"); \/\/ == on x86\n+\n+  DEBUG_ONLY(verify_frame_top(f, stack_frame_top));\n@@ -1051,0 +1052,1 @@\n+  const int argsize = ContinuationHelper::InterpretedFrame::stack_argsize(f);\n@@ -1062,2 +1064,2 @@\n-  bool bottom = result == freeze_ok_bottom;\n-  assert(!caller.is_empty() || bottom, \"\");\n+  bool is_bottom_frame = result == freeze_ok_bottom;\n+  assert(!caller.is_empty() || is_bottom_frame, \"\");\n@@ -1065,1 +1067,1 @@\n-  DEBUG_ONLY(before_freeze_java_frame(f, caller, fsize, 0, bottom);)\n+  DEBUG_ONLY(before_freeze_java_frame(f, caller, fsize, 0, is_bottom_frame);)\n@@ -1070,2 +1072,3 @@\n-  intptr_t* heap_top = ContinuationHelper::InterpretedFrame::frame_top(hf, callee_argsize, callee_interpreted);\n-  assert(ContinuationHelper::InterpretedFrame::frame_bottom(hf) == heap_top + fsize, \"\");\n+  intptr_t* heap_frame_top = ContinuationHelper::InterpretedFrame::frame_top(hf, callee_argsize, callee_interpreted);\n+  intptr_t* heap_frame_bottom = ContinuationHelper::InterpretedFrame::frame_bottom(hf);\n+  assert(heap_frame_bottom == heap_frame_top + fsize, \"\");\n@@ -1074,4 +1077,3 @@\n-  copy_to_chunk(ContinuationHelper::InterpretedFrame::frame_bottom(f) - locals,\n-                ContinuationHelper::InterpretedFrame::frame_bottom(hf) - locals, locals); \/\/ copy locals\n-  copy_to_chunk(frame_top, heap_top, fsize - locals); \/\/ copy rest\n-  assert(!bottom || !caller.is_interpreted_frame() || (heap_top + fsize) == (caller.unextended_sp() + argsize), \"\");\n+  copy_to_chunk(stack_frame_bottom - locals, heap_frame_bottom - locals, locals); \/\/ copy locals\n+  copy_to_chunk(stack_frame_top, heap_frame_top, fsize - locals);                 \/\/ copy rest\n+  assert(!is_bottom_frame || !caller.is_interpreted_frame() || (heap_frame_top + fsize) == (caller.unextended_sp() + argsize), \"\");\n@@ -1081,1 +1083,1 @@\n-  patch(f, hf, caller, bottom);\n+  patch(f, hf, caller, is_bottom_frame);\n@@ -1084,1 +1086,1 @@\n-  DEBUG_ONLY(after_freeze_java_frame(hf, bottom);)\n+  DEBUG_ONLY(after_freeze_java_frame(hf, is_bottom_frame);)\n@@ -1095,1 +1097,2 @@\n-  intptr_t* const frame_top = ContinuationHelper::CompiledFrame::frame_top(f, callee_argsize, callee_interpreted);\n+  intptr_t* const stack_frame_top = ContinuationHelper::CompiledFrame::frame_top(f, callee_argsize, callee_interpreted);\n+  intptr_t* const stack_frame_bottom = ContinuationHelper::CompiledFrame::frame_bottom(f);\n@@ -1097,1 +1100,1 @@\n-  const int fsize = ContinuationHelper::CompiledFrame::frame_bottom(f) + argsize - frame_top;\n+  const int fsize = stack_frame_bottom + argsize - stack_frame_top;\n@@ -1111,2 +1114,2 @@\n-  bool bottom = result == freeze_ok_bottom;\n-  assert(!caller.is_empty() || bottom, \"\");\n+  bool is_bottom_frame = result == freeze_ok_bottom;\n+  assert(!caller.is_empty() || is_bottom_frame, \"\");\n@@ -1114,1 +1117,1 @@\n-  DEBUG_ONLY(before_freeze_java_frame(f, caller, fsize, argsize, bottom);)\n+  DEBUG_ONLY(before_freeze_java_frame(f, caller, fsize, argsize, is_bottom_frame);)\n@@ -1118,1 +1121,1 @@\n-  intptr_t* heap_top = ContinuationHelper::CompiledFrame::frame_top(hf, callee_argsize, callee_interpreted);\n+  intptr_t* heap_frame_top = ContinuationHelper::CompiledFrame::frame_top(hf, callee_argsize, callee_interpreted);\n@@ -1120,2 +1123,2 @@\n-  copy_to_chunk(frame_top, heap_top, fsize);\n-  assert(!bottom || !caller.is_compiled_frame() || (heap_top + fsize) == (caller.unextended_sp() + argsize), \"\");\n+  copy_to_chunk(stack_frame_top, heap_frame_top, fsize);\n+  assert(!is_bottom_frame || !caller.is_compiled_frame() || (heap_frame_top + fsize) == (caller.unextended_sp() + argsize), \"\");\n@@ -1127,1 +1130,1 @@\n-  patch(f, hf, caller, bottom);\n+  patch(f, hf, caller, is_bottom_frame);\n@@ -1129,1 +1132,1 @@\n-  assert(bottom || Interpreter::contains(ContinuationHelper::CompiledFrame::real_pc(caller)) == caller.is_interpreted_frame(), \"\");\n+  assert(is_bottom_frame || Interpreter::contains(ContinuationHelper::CompiledFrame::real_pc(caller)) == caller.is_interpreted_frame(), \"\");\n@@ -1131,1 +1134,1 @@\n-  DEBUG_ONLY(after_freeze_java_frame(hf, bottom);)\n+  DEBUG_ONLY(after_freeze_java_frame(hf, is_bottom_frame);)\n@@ -1137,1 +1140,1 @@\n-  intptr_t* const frame_top = ContinuationHelper::StubFrame::frame_top(f, 0, 0);\n+  intptr_t* const stack_frame_top = ContinuationHelper::StubFrame::frame_top(f, 0, 0);\n@@ -1141,1 +1144,1 @@\n-    f.cb()->name(), _freeze_size, fsize, p2i(frame_top), p2i(frame_top+fsize));\n+    f.cb()->name(), _freeze_size, fsize, p2i(stack_frame_top), p2i(stack_frame_top+fsize));\n@@ -1169,2 +1172,2 @@\n-  intptr_t* heap_top = ContinuationHelper::StubFrame::frame_top(hf, 0, 0);\n-  copy_to_chunk(frame_top, heap_top, fsize);\n+  intptr_t* heap_frame_top = ContinuationHelper::StubFrame::frame_top(hf, 0, 0);\n+  copy_to_chunk(stack_frame_top, heap_frame_top, fsize);\n@@ -1594,1 +1597,1 @@\n-  void thaw_one_frame(const frame& heap_frame, frame& caller, int num_frames, bool top);\n+  void recurse_thaw(const frame& heap_frame, frame& caller, int num_frames, bool top);\n@@ -1857,1 +1860,1 @@\n-  thaw_one_frame(heap_frame, caller, num_frames, true);\n+  recurse_thaw(heap_frame, caller, num_frames, true);\n@@ -1871,1 +1874,1 @@\n-void ThawBase::thaw_one_frame(const frame& heap_frame, frame& caller, int num_frames, bool top) {\n+void ThawBase::recurse_thaw(const frame& heap_frame, frame& caller, int num_frames, bool top) {\n@@ -1909,1 +1912,1 @@\n-    thaw_one_frame(_stream.to_frame(), caller, num_frames - 1, false);\n+    recurse_thaw(_stream.to_frame(), caller, num_frames - 1, false);\n@@ -1994,1 +1997,1 @@\n-  const bool bottom = recurse_thaw_java_frame<ContinuationHelper::InterpretedFrame>(caller, num_frames);\n+  const bool is_bottom_frame = recurse_thaw_java_frame<ContinuationHelper::InterpretedFrame>(caller, num_frames);\n@@ -1996,1 +1999,1 @@\n-  DEBUG_ONLY(before_thaw_java_frame(hf, caller, bottom, num_frames);)\n+  DEBUG_ONLY(before_thaw_java_frame(hf, caller, is_bottom_frame, num_frames);)\n@@ -2000,1 +2003,1 @@\n-  frame f = new_stack_frame<ContinuationHelper::InterpretedFrame>(hf, caller, bottom);\n+  frame f = new_stack_frame<ContinuationHelper::InterpretedFrame>(hf, caller, is_bottom_frame);\n@@ -2002,3 +2005,4 @@\n-  intptr_t* const frame_sp = f.sp();\n-  intptr_t* const heap_sp = hf.unextended_sp();\n-  intptr_t* const frame_bottom = ContinuationHelper::InterpretedFrame::frame_bottom(f);\n+  intptr_t* const stack_frame_top = f.sp();\n+  intptr_t* const stack_frame_bottom = ContinuationHelper::InterpretedFrame::frame_bottom(f);\n+  intptr_t* const heap_frame_top = hf.unextended_sp();\n+  intptr_t* const heap_frame_bottom = ContinuationHelper::InterpretedFrame::frame_bottom(hf);\n@@ -2007,1 +2011,1 @@\n-  const int fsize = ContinuationHelper::InterpretedFrame::frame_bottom(hf) - heap_sp;\n+  const int fsize = heap_frame_bottom - heap_frame_top;\n@@ -2009,2 +2013,2 @@\n-  assert(ContinuationHelper::InterpretedFrame::frame_bottom(f) >= frame_sp + fsize\n-    && ContinuationHelper::InterpretedFrame::frame_bottom(f) <= frame_sp + fsize + 1, \"\"); \/\/ internal alignment on aarch64\n+  assert((stack_frame_bottom >= stack_frame_top + fsize) &&\n+         (stack_frame_bottom <= stack_frame_top + fsize + 1), \"\"); \/\/ internal alignment on aarch64\n@@ -2017,3 +2021,2 @@\n-  copy_from_chunk(ContinuationHelper::InterpretedFrame::frame_bottom(hf) - locals,\n-                  ContinuationHelper::InterpretedFrame::frame_bottom(f) - locals, locals); \/\/ copy locals\n-  copy_from_chunk(heap_sp, frame_sp, fsize - locals); \/\/ copy rest\n+  copy_from_chunk(heap_frame_bottom - locals, stack_frame_bottom - locals, locals); \/\/ copy locals\n+  copy_from_chunk(heap_frame_top, stack_frame_top, fsize - locals);                 \/\/ copy rest\n@@ -2021,1 +2024,1 @@\n-  set_interpreter_frame_bottom(f, frame_bottom); \/\/ the copy overwrites the metadata\n+  set_interpreter_frame_bottom(f, stack_frame_bottom); \/\/ the copy overwrites the metadata\n@@ -2023,1 +2026,1 @@\n-  patch(f, caller, bottom);\n+  patch(f, caller, is_bottom_frame);\n@@ -2026,1 +2029,1 @@\n-  assert(ContinuationHelper::InterpretedFrame::frame_bottom(f) <= ContinuationHelper::Frame::frame_top(caller), \"\");\n+  assert(stack_frame_bottom <= ContinuationHelper::Frame::frame_top(caller), \"\");\n@@ -2032,1 +2035,1 @@\n-  if (!bottom) {\n+  if (!is_bottom_frame) {\n@@ -2037,1 +2040,1 @@\n-    clear_bitmap_bits(ContinuationHelper::InterpretedFrame::frame_bottom(hf) - locals, locals);\n+    clear_bitmap_bits(heap_frame_bottom - locals, locals);\n@@ -2040,1 +2043,1 @@\n-  DEBUG_ONLY(after_thaw_java_frame(f, bottom);)\n+  DEBUG_ONLY(after_thaw_java_frame(f, is_bottom_frame);)\n@@ -2052,1 +2055,1 @@\n-  const bool bottom = recurse_thaw_java_frame<ContinuationHelper::CompiledFrame>(caller, num_frames);\n+  const bool is_bottom_frame = recurse_thaw_java_frame<ContinuationHelper::CompiledFrame>(caller, num_frames);\n@@ -2054,1 +2057,1 @@\n-  DEBUG_ONLY(before_thaw_java_frame(hf, caller, bottom, num_frames);)\n+  DEBUG_ONLY(before_thaw_java_frame(hf, caller, is_bottom_frame, num_frames);)\n@@ -2058,1 +2061,1 @@\n-  if ((!bottom && caller.is_interpreted_frame()) || (bottom && Interpreter::contains(_cont.tail()->pc()))) {\n+  if ((!is_bottom_frame && caller.is_interpreted_frame()) || (is_bottom_frame && Interpreter::contains(_cont.tail()->pc()))) {\n@@ -2062,3 +2065,3 @@\n-  frame f = new_stack_frame<ContinuationHelper::CompiledFrame>(hf, caller, bottom);\n-  intptr_t* const frame_sp = f.sp();\n-  intptr_t* const heap_sp = hf.unextended_sp();\n+  frame f = new_stack_frame<ContinuationHelper::CompiledFrame>(hf, caller, is_bottom_frame);\n+  intptr_t* const stack_frame_top = f.sp();\n+  intptr_t* const heap_frame_top = hf.unextended_sp();\n@@ -2066,1 +2069,1 @@\n-  const int added_argsize = (bottom || caller.is_interpreted_frame()) ? hf.compiled_frame_stack_argsize() : 0;\n+  const int added_argsize = (is_bottom_frame || caller.is_interpreted_frame()) ? hf.compiled_frame_stack_argsize() : 0;\n@@ -2070,2 +2073,2 @@\n-  intptr_t* from = heap_sp - frame::metadata_words;\n-  intptr_t* to   = frame_sp - frame::metadata_words;\n+  intptr_t* from = heap_frame_top - frame::metadata_words;\n+  intptr_t* to   = stack_frame_top - frame::metadata_words;\n@@ -2076,2 +2079,2 @@\n-  assert(!bottom || (_cont.entrySP() - 1 <= to + sz && to + sz <= _cont.entrySP()), \"\");\n-  assert(!bottom || hf.compiled_frame_stack_argsize() != 0 || (to + sz && to + sz == _cont.entrySP()), \"\");\n+  assert(!is_bottom_frame || (_cont.entrySP() - 1 <= to + sz && to + sz <= _cont.entrySP()), \"\");\n+  assert(!is_bottom_frame || hf.compiled_frame_stack_argsize() != 0 || (to + sz && to + sz == _cont.entrySP()), \"\");\n@@ -2081,1 +2084,1 @@\n-  patch(f, caller, bottom);\n+  patch(f, caller, is_bottom_frame);\n@@ -2100,1 +2103,1 @@\n-  if (!bottom) {\n+  if (!is_bottom_frame) {\n@@ -2104,1 +2107,1 @@\n-    clear_bitmap_bits(heap_sp + ContinuationHelper::CompiledFrame::size(hf), added_argsize);\n+    clear_bitmap_bits(heap_frame_top + ContinuationHelper::CompiledFrame::size(hf), added_argsize);\n@@ -2107,1 +2110,1 @@\n-  DEBUG_ONLY(after_thaw_java_frame(f, bottom);)\n+  DEBUG_ONLY(after_thaw_java_frame(f, is_bottom_frame);)\n@@ -2136,2 +2139,2 @@\n-  intptr_t* frame_sp = f.sp();\n-  intptr_t* heap_sp = hf.sp();\n+  intptr_t* stack_frame_top = f.sp();\n+  intptr_t* heap_frame_top = hf.sp();\n@@ -2139,1 +2142,1 @@\n-  copy_from_chunk(heap_sp - frame::metadata_words, frame_sp - frame::metadata_words,\n+  copy_from_chunk(heap_frame_top - frame::metadata_words, stack_frame_top - frame::metadata_words,\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":88,"deletions":85,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -3066,1 +3066,1 @@\n-    @Stable private volatile ThreadContainer container;\n+    @Stable private ThreadContainer container;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.net.DatagramPacket;\n@@ -642,2 +641,7 @@\n-     * Attempts to receive a datagram into the given byte array.\n-     * @param connected true if the channel is connected\n+     * Receives a datagram into the given buffer.\n+     *\n+     * @apiNote This method is for use by the socket adaptor. The buffer is\n+     * assumed to be trusted, meaning it is not accessible to user code.\n+     *\n+     * @throws IllegalBlockingModeException if the channel is non-blocking\n+     * @throws SocketTimeoutException if the timeout elapses\n@@ -645,6 +649,2 @@\n-    private int tryReceive(byte[] b, int off, int len, boolean connected)\n-        throws IOException\n-    {\n-        \/\/ ensure direct buffer is at least size 1\n-        ByteBuffer dst = Util.getTemporaryDirectBuffer(Math.max(len, 1));\n-        assert dst.position() == 0;\n+    SocketAddress blockingReceive(ByteBuffer dst, long nanos) throws IOException {\n+        readLock.lock();\n@@ -652,18 +652,12 @@\n-\n-            int n = receive(dst, connected);\n-            if (n >= 0) {\n-                \/\/ check security manager when not connected\n-                if (!connected) {\n-                    @SuppressWarnings(\"removal\")\n-                    SecurityManager sm = System.getSecurityManager();\n-                    if (sm != null) {\n-                        \/\/ invoke decode directly to avoid touch cache\n-                        InetSocketAddress sender = sourceSockAddr.decode();\n-                        try {\n-                            sm.checkAccept(sender.getAddress().getHostAddress(),\n-                                           sender.getPort());\n-                        } catch (SecurityException e) {\n-                            \/\/ ignore datagram\n-                            n = IOStatus.UNAVAILABLE;\n-                        }\n-                    }\n+            ensureOpen();\n+            if (!isBlocking())\n+                throw new IllegalBlockingModeException();\n+            @SuppressWarnings(\"removal\")\n+            SecurityManager sm = System.getSecurityManager();\n+            boolean connected = isConnected();\n+            SocketAddress sender;\n+            do {\n+                if (nanos > 0) {\n+                    sender = trustedBlockingReceive(dst, nanos);\n+                } else {\n+                    sender = trustedBlockingReceive(dst);\n@@ -671,8 +665,7 @@\n-\n-                \/\/ copy datagram into byte array\n-                if (n > 0) {\n-                    if (len > 0) {\n-                        dst.flip();\n-                        dst.get(b, off, n);\n-                    } else {\n-                        n = 0;\n+                \/\/ check sender when security manager set and not connected\n+                if (sm != null && !connected) {\n+                    InetSocketAddress isa = (InetSocketAddress) sender;\n+                    try {\n+                        sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());\n+                    } catch (SecurityException e) {\n+                        sender = null;\n@@ -681,4 +674,4 @@\n-            }\n-            return n;\n-        } finally{\n-            Util.offerFirstTemporaryDirectBuffer(dst);\n+            } while (sender == null);\n+            return sender;\n+        } finally {\n+            readLock.unlock();\n@@ -689,3 +682,3 @@\n-     * Receive a datagram into the given byte array with a timeout.\n-     * @param connected true if the channel is connected\n-     * @throws SocketTimeoutException if the receive timeout elapses\n+     * Receives a datagram into given buffer. This method is used to support\n+     * the socket adaptor. The buffer is assumed to be trusted.\n+     * @throws SocketTimeoutException if the timeout elapses\n@@ -693,1 +686,1 @@\n-    private int timedReceive(byte[] b, int off, int len, long nanos, boolean connected)\n+    private SocketAddress trustedBlockingReceive(ByteBuffer dst)\n@@ -696,6 +689,10 @@\n-        long startNanos = System.nanoTime();\n-        int n = tryReceive(b, off, len, connected);\n-        while (n == IOStatus.UNAVAILABLE && isOpen()) {\n-            long remainingNanos = nanos - (System.nanoTime() - startNanos);\n-            if (remainingNanos <= 0) {\n-                throw new SocketTimeoutException(\"Read timed out\");\n+        assert readLock.isHeldByCurrentThread() && isBlocking();\n+        SocketAddress sender = null;\n+        try {\n+            SocketAddress remote = beginRead(true, false);\n+            configureSocketNonBlockingIfVirtualThread();\n+            boolean connected = (remote != null);\n+            int n = receive(dst, connected);\n+            while (IOStatus.okayToRetry(n) && isOpen()) {\n+                park(Net.POLLIN);\n+                n = receive(dst, connected);\n@@ -703,2 +700,7 @@\n-            park(Net.POLLIN, remainingNanos);\n-            n = tryReceive(b, off, len, connected);\n+            if (n >= 0) {\n+                \/\/ sender address is in socket address buffer\n+                sender = sourceSocketAddress();\n+            }\n+            return sender;\n+        } finally {\n+            endRead(true, (sender != null));\n@@ -706,1 +708,0 @@\n-        return n;\n@@ -710,5 +711,2 @@\n-     * Receives a datagram into the byte array of the given DatagramPacket.\n-     *\n-     * @apiNote This method is for use by the socket adaptor.\n-     *\n-     * @throws IllegalBlockingModeException if the channel is non-blocking\n+     * Receives a datagram into given buffer with a timeout. This method is\n+     * used to support the socket adaptor. The buffer is assumed to be trusted.\n@@ -717,12 +715,5 @@\n-    void blockingReceive(DatagramPacket p, long nanos) throws IOException {\n-        byte[] ba; int off, len;\n-        synchronized (p) {\n-            ba = p.getData();\n-            off = p.getOffset();\n-            len = DatagramPackets.getBufLength(p);\n-        }\n-\n-        int n = -1;\n-        InetSocketAddress sender = null;\n-\n-        readLock.lock();\n+    private SocketAddress trustedBlockingReceive(ByteBuffer dst, long nanos)\n+        throws IOException\n+    {\n+        assert readLock.isHeldByCurrentThread() && isBlocking();\n+        SocketAddress sender = null;\n@@ -730,3 +721,2 @@\n-            ensureOpen();\n-            if (!isBlocking())\n-                throw new IllegalBlockingModeException();\n+            SocketAddress remote = beginRead(true, false);\n+            boolean connected = (remote != null);\n@@ -734,0 +724,2 @@\n+            \/\/ change socket to non-blocking\n+            lockedConfigureBlocking(false);\n@@ -735,18 +727,6 @@\n-                SocketAddress remote = beginRead(true, false);\n-                configureSocketNonBlockingIfVirtualThread();\n-                boolean connected = (remote != null);\n-                if (nanos > 0) {\n-                    \/\/ timed receive, change socket to non-blocking\n-                    lockedConfigureBlocking(false);\n-                    try {\n-                        n = timedReceive(ba, off, len, nanos, connected);\n-                    } finally {\n-                        \/\/ restore socket to blocking mode\n-                        tryLockedConfigureBlocking(true);\n-                    }\n-                } else {\n-                    \/\/ untimed receive\n-                    n = tryReceive(ba, off, len, connected);\n-                    while (IOStatus.okayToRetry(n) && isOpen()) {\n-                        park(Net.POLLIN);\n-                        n = tryReceive(ba, off, len, connected);\n+                long startNanos = System.nanoTime();\n+                int n = receive(dst, connected);\n+                while (n == IOStatus.UNAVAILABLE && isOpen()) {\n+                    long remainingNanos = nanos - (System.nanoTime() - startNanos);\n+                    if (remainingNanos <= 0) {\n+                        throw new SocketTimeoutException(\"Receive timed out\");\n@@ -754,0 +734,2 @@\n+                    park(Net.POLLIN, remainingNanos);\n+                    n = receive(dst, connected);\n@@ -759,0 +741,1 @@\n+                return sender;\n@@ -760,1 +743,2 @@\n-                endRead(true, n >= 0);\n+                \/\/ restore socket to blocking mode (if channel is open)\n+                tryLockedConfigureBlocking(true);\n@@ -763,8 +747,1 @@\n-            readLock.unlock();\n-        }\n-\n-        \/\/ set datagram length and sender address\n-        assert n >= 0 && sender != null;\n-        synchronized (p) {\n-            DatagramPackets.setLength(p, n);\n-            p.setSocketAddress(sender);\n+            endRead(true, (sender != null));\n@@ -898,33 +875,1 @@\n-     * Attempts to write a datagram.\n-     *\/\n-    private int tryWrite(byte[] b, int off, int len) throws IOException {\n-        ByteBuffer src = Util.getTemporaryDirectBuffer(len);\n-        assert src.position() == 0;\n-        try {\n-            src.put(b, off, len);\n-            src.flip();\n-            return IOUtil.write(fd, src, -1, nd);\n-        } finally {\n-            Util.offerFirstTemporaryDirectBuffer(src);\n-        }\n-    }\n-\n-    \/**\n-     * Attempts to send a datagram to the given target address.\n-     *\/\n-    private int trySend(byte[] b, int off, int len, InetSocketAddress target)\n-        throws IOException\n-    {\n-        ByteBuffer src = Util.getTemporaryDirectBuffer(len);\n-        assert src.position() == 0;\n-        try {\n-            src.put(b, off, len);\n-            src.flip();\n-            return send(fd, src, target);\n-        } finally {\n-            Util.offerFirstTemporaryDirectBuffer(src);\n-        }\n-    }\n-\n-    \/**\n-     * Sends a datagram from the bytes in given byte array.\n+     * Sends a datagram from the bytes in given buffer.\n@@ -936,5 +881,1 @@\n-    void blockingSend(byte[] b, int off, int len, SocketAddress target)\n-        throws IOException\n-    {\n-        Objects.checkFromIndexSize(off, len, b.length);\n-        InetSocketAddress isa = Net.checkAddress(target, family);\n+    void blockingSend(ByteBuffer src, SocketAddress target) throws IOException {\n@@ -946,42 +887,1 @@\n-\n-            boolean completed = false;\n-            try {\n-                SocketAddress remote = beginWrite(true, false);\n-                configureSocketNonBlockingIfVirtualThread();\n-                if (remote != null) {\n-                    \/\/ connected\n-                    if (!target.equals(remote)) {\n-                        throw new AlreadyConnectedException();\n-                    }\n-                    int n = tryWrite(b, off, len);\n-                    while (IOStatus.okayToRetry(n) && isOpen()) {\n-                        park(Net.POLLOUT);\n-                        n = tryWrite(b, off, len);\n-                    }\n-                    completed = (n > 0);\n-                } else {\n-                    \/\/ not connected\n-                    @SuppressWarnings(\"removal\")\n-                    SecurityManager sm = System.getSecurityManager();\n-                    InetAddress ia = isa.getAddress();\n-                    if (sm != null) {\n-                        if (ia.isMulticastAddress()) {\n-                            sm.checkMulticast(ia);\n-                        } else {\n-                            sm.checkConnect(ia.getHostAddress(), isa.getPort());\n-                        }\n-                    }\n-                    if (ia.isLinkLocalAddress())\n-                        isa = IPAddressUtil.toScopedAddress(isa);\n-                    if (isa.getPort() == 0)\n-                        throw new SocketException(\"Can't send to port 0\");\n-                    int n = trySend(b, off, len, isa);\n-                    while (IOStatus.okayToRetry(n) && isOpen()) {\n-                        park(Net.POLLOUT);\n-                        n = trySend(b, off, len, isa);\n-                    }\n-                    completed = (n >= 0);\n-                }\n-            } finally {\n-                endWrite(true, completed);\n-            }\n+            send(src, target);\n@@ -2035,38 +1935,0 @@\n-    \/**\n-     * Defines static methods to get\/set DatagramPacket fields and workaround\n-     * DatagramPacket deficiencies.\n-     *\/\n-    private static class DatagramPackets {\n-        private static final VarHandle LENGTH;\n-        private static final VarHandle BUF_LENGTH;\n-        static {\n-            try {\n-                PrivilegedExceptionAction<MethodHandles.Lookup> pa = () ->\n-                    MethodHandles.privateLookupIn(DatagramPacket.class, MethodHandles.lookup());\n-                @SuppressWarnings(\"removal\")\n-                MethodHandles.Lookup l = AccessController.doPrivileged(pa);\n-                LENGTH = l.findVarHandle(DatagramPacket.class, \"length\", int.class);\n-                BUF_LENGTH = l.findVarHandle(DatagramPacket.class, \"bufLength\", int.class);\n-            } catch (Exception e) {\n-                throw new ExceptionInInitializerError(e);\n-            }\n-        }\n-\n-        \/**\n-         * Sets the DatagramPacket.length field. DatagramPacket.setLength cannot be\n-         * used at this time because it sets both the length and bufLength fields.\n-         *\/\n-        static void setLength(DatagramPacket p, int value) {\n-            assert Thread.holdsLock(p);\n-            LENGTH.set(p, value);\n-        }\n-\n-        \/**\n-         * Returns the value of the DatagramPacket.bufLength field.\n-         *\/\n-        static int getBufLength(DatagramPacket p) {\n-            assert Thread.holdsLock(p);\n-            return (int) BUF_LENGTH.get(p);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":79,"deletions":217,"binary":false,"changes":296,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.invoke.VarHandle;\n@@ -46,0 +47,1 @@\n+import java.nio.ByteBuffer;\n@@ -57,0 +59,1 @@\n+import jdk.internal.misc.Blocker;\n@@ -192,3 +195,0 @@\n-        byte[] ba; int off, len;\n-        InetSocketAddress target;\n-\n@@ -196,9 +196,21 @@\n-            ba = p.getData();\n-            off = p.getOffset();\n-            len = p.getLength();\n-\n-            \/\/ target address\n-            if (p.getAddress() == null) {\n-                InetSocketAddress remote = dc.remoteAddress();\n-                if (remote == null) {\n-                    throw new IllegalArgumentException(\"Address not set\");\n+            int len = p.getLength();\n+            ByteBuffer bb = Util.getTemporaryDirectBuffer(len);\n+            try {\n+                \/\/ copy bytes to temporary direct buffer\n+                bb.put(p.getData(), p.getOffset(), len);\n+                bb.flip();\n+\n+                \/\/ target address\n+                InetSocketAddress target;\n+                if (p.getAddress() == null) {\n+                    InetSocketAddress remote = dc.remoteAddress();\n+                    if (remote == null) {\n+                        \/\/ not specified by DatagramSocket\n+                        throw new IllegalArgumentException(\"Address not set\");\n+                    }\n+                    \/\/ set address\/port to maintain compatibility with DatagramSocket\n+                    p.setAddress(remote.getAddress());\n+                    p.setPort(remote.getPort());\n+                    target = remote;\n+                } else {\n+                    target = (InetSocketAddress) p.getSocketAddress();\n@@ -206,8 +218,0 @@\n-                \/\/ set address\/port to maintain legacy compatibility\n-                p.setAddress(remote.getAddress());\n-                p.setPort(remote.getPort());\n-                target = remote;\n-            } else {\n-                target = (InetSocketAddress) p.getSocketAddress();\n-            }\n-        }\n@@ -215,9 +219,9 @@\n-        \/\/ send datagram\n-        try {\n-            dc.blockingSend(ba, off, len, target);\n-        } catch (AlreadyConnectedException e) {\n-            throw new IllegalArgumentException(\"Connected and packet address differ\");\n-        } catch (ClosedChannelException e) {\n-            var exc = new SocketException(\"Socket closed\");\n-            exc.initCause(e);\n-            throw exc;\n+                \/\/ send datagram\n+                dc.blockingSend(bb, target);\n+            } catch (AlreadyConnectedException e) {\n+                throw new IllegalArgumentException(\"Connected and packet address differ\");\n+            } catch (ClosedChannelException e) {\n+                throw new SocketException(\"Socket closed\", e);\n+            } finally {\n+                Util.offerFirstTemporaryDirectBuffer(bb);\n+            }\n@@ -229,10 +233,34 @@\n-        long nanos = MILLISECONDS.toNanos(timeout);\n-        try {\n-            dc.blockingReceive(p, nanos);\n-        } catch (SocketTimeoutException e) {\n-            throw e;\n-        } catch (InterruptedIOException e) {\n-            Thread thread = Thread.currentThread();\n-            if (thread.isVirtual() && thread.isInterrupted()) {\n-                close();\n-                throw new SocketException(\"Closed by interrupt\");\n+        synchronized (p) {\n+            \/\/ get temporary direct buffer with a capacity of p.bufLength\n+            int bufLength = DatagramPackets.getBufLength(p);\n+            ByteBuffer bb = Util.getTemporaryDirectBuffer(bufLength);\n+            try {\n+                SocketAddress sender;\n+                long comp = Blocker.begin();\n+                try {\n+                    sender = dc.blockingReceive(bb, MILLISECONDS.toNanos(timeout));\n+                } finally {\n+                    Blocker.end(comp);\n+                }\n+                bb.flip();\n+\n+                \/\/ copy bytes to the DatagramPacket and set length\n+                int len = Math.min(bb.limit(), DatagramPackets.getBufLength(p));\n+                bb.get(p.getData(), p.getOffset(), len);\n+                DatagramPackets.setLength(p, len);\n+\n+                \/\/ sender address\n+                p.setSocketAddress(sender);\n+            } catch (SocketTimeoutException | ClosedByInterruptException e) {\n+                throw e;\n+            } catch (InterruptedIOException e) {\n+                Thread thread = Thread.currentThread();\n+                if (thread.isVirtual() && thread.isInterrupted()) {\n+                    close();\n+                    throw new SocketException(\"Closed by interrupt\");\n+                }\n+                throw e;\n+            } catch (ClosedChannelException e) {\n+                throw new SocketException(\"Socket closed\", e);\n+            } finally {\n+                Util.offerFirstTemporaryDirectBuffer(bb);\n@@ -240,5 +268,0 @@\n-            throw e;\n-        } catch (ClosedByInterruptException e) {\n-            throw e;\n-        } catch (ClosedChannelException e) {\n-            throw new SocketException(\"Socket closed\", e);\n@@ -684,0 +707,38 @@\n+    \/**\n+     * Defines static methods to get\/set DatagramPacket fields and workaround\n+     * DatagramPacket deficiencies.\n+     *\/\n+    private static class DatagramPackets {\n+        private static final VarHandle LENGTH;\n+        private static final VarHandle BUF_LENGTH;\n+        static {\n+            try {\n+                PrivilegedExceptionAction<MethodHandles.Lookup> pa = () ->\n+                    MethodHandles.privateLookupIn(DatagramPacket.class, MethodHandles.lookup());\n+                @SuppressWarnings(\"removal\")\n+                MethodHandles.Lookup l = AccessController.doPrivileged(pa);\n+                LENGTH = l.findVarHandle(DatagramPacket.class, \"length\", int.class);\n+                BUF_LENGTH = l.findVarHandle(DatagramPacket.class, \"bufLength\", int.class);\n+            } catch (Exception e) {\n+                throw new ExceptionInInitializerError(e);\n+            }\n+        }\n+\n+        \/**\n+         * Sets the DatagramPacket.length field. DatagramPacket.setLength cannot be\n+         * used at this time because it sets both the length and bufLength fields.\n+         *\/\n+        static void setLength(DatagramPacket p, int value) {\n+            assert Thread.holdsLock(p);\n+            LENGTH.set(p, value);\n+        }\n+\n+        \/**\n+         * Returns the value of the DatagramPacket.bufLength field.\n+         *\/\n+        static int getBufLength(DatagramPacket p) {\n+            assert Thread.holdsLock(p);\n+            return (int) BUF_LENGTH.get(p);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramSocketAdaptor.java","additions":105,"deletions":44,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+     * @throws UnsupportedOperationException if this operation is not supported\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/HotSpotDiagnosticMXBean.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -30,0 +31,2 @@\n+import jdk.test.lib.Asserts;\n+\n@@ -59,4 +62,1 @@\n-        if (isVirtual != expected) {\n-            throw new RuntimeException(\"JNI IsVirtualThread returned \" + isVirtual\n-                    + \", expected \" + expected);\n-        }\n+        Asserts.assertEQ(expected, isVirtual, \"JNI IsVirtualThread() not equals to Thread.isVirtual()\");\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/IsVirtualThread\/IsVirtualThread.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+            \"jdk.internal.misc.Blocker.currentCarrierThread\",\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace001.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+            \"jdk.internal.misc.Blocker.currentCarrierThread\",\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace002.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -128,0 +128,1 @@\n+            \"jdk.internal.misc.Blocker.currentCarrierThread\",\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace003.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -121,0 +121,1 @@\n+            \"jdk.internal.misc.Blocker.currentCarrierThread\",\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace004.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @modules jdk.httpserver\n+ * @library \/test\/lib\n@@ -47,0 +49,1 @@\n+import jdk.test.lib.net.URIBuilder;\n@@ -74,2 +77,6 @@\n-        var address = server.getAddress();\n-        URL url = new URL(\"http:\/\/\" + address.getHostName() + \":\" + address.getPort() + \"\/hello\");\n+        URL url = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .loopback()\n+                .port(server.getAddress().getPort())\n+                .path(\"\/hello\")\n+                .toURL();\n","filename":"test\/jdk\/java\/net\/vthread\/HttpALot.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @library \/test\/lib\n@@ -42,0 +43,1 @@\n+import jdk.test.lib.net.URIBuilder;\n@@ -46,1 +48,1 @@\n-        try (Server server = new Server()) {\n+        try (Server server = new Server().start()) {\n@@ -49,0 +51,8 @@\n+            \/\/ http:\/\/host:port\/hello\n+            URL url = URIBuilder.newBuilder()\n+                    .scheme(\"http\")\n+                    .loopback()\n+                    .port(server.port())\n+                    .path(\"\/hello\")\n+                    .toURL();\n+\n@@ -52,1 +62,0 @@\n-                    URL url = new URL(server.address() + \"\/hello\");\n@@ -83,1 +92,0 @@\n-        private final String address;\n@@ -88,1 +96,3 @@\n-            address = \"http:\/\/\" + lb.getHostAddress() + \":\" + listener.getLocalPort();\n+        }\n+\n+        Server start() {\n@@ -90,0 +100,1 @@\n+            return this;\n@@ -109,2 +120,2 @@\n-        String address() {\n-            return address;\n+        int port() {\n+            return listener.getLocalPort();\n","filename":"test\/jdk\/java\/net\/vthread\/InterruptHttp.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -74,2 +74,0 @@\n-            \/\/ && Objects.equals(a.getByteCodeIndex(), b.getByteCodeIndex()) \/\/ TODO !!!!\n-            \/\/ && Objects.equals(a.getContinuationScopeName(), b.getContinuationScopeName())\n@@ -79,2 +77,0 @@\n-            \/\/ System.out.println(\"XXXX\\ta: \" + a + \" a.scope: \" + a.getContinuationScopeName() + \" a.bci: \" + a.getByteCodeIndex() + \" a.toSTE: \" + a.toStackTraceElement()\n-            \/\/                    + \"\\n\\tb: \" + b + \" b.scope: \" + b.getContinuationScopeName() + \" b.bci: \" + b.getByteCodeIndex() + \" b.toSTE: \" + b.toStackTraceElement());\n@@ -91,1 +87,1 @@\n-        \/\/ assert Objects.equals(a.toStackTraceElement(), b.toStackTraceElement()) : \"a\" + a.toStackTraceElement() + \" b: \" + b.toStackTraceElement();\n+\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/java.base\/java\/lang\/StackWalkerHelper.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"}]}