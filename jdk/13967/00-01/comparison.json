{"files":[{"patch":"@@ -91,1 +91,1 @@\n-    static final String DEBUGGEE_RESULT = DEBUGGEE_CLASS + \".notKilled\";\n+    static final String DEBUGGEE_RESULT = DEBUGGEE_CLASS + \".killed\";\n@@ -98,4 +98,0 @@\n-        Paragrep grep;\n-        int count;\n-        Vector v;\n-        String found;\n@@ -150,5 +146,5 @@\n-        grep = new Paragrep(reply);\n-        found = grep.findFirst(DEBUGGEE_RESULT + \" =\" );\n-        if (found.length() > 0) {\n-            if (found.indexOf(DEBUGGEE_RESULT + \" = 0\") < 0) {\n-                log.complain(\"Not all \" + MYTHREAD + \"s were killed. \" + found + \" remaining\");\n+        Paragrep grep = new Paragrep(reply);\n+        String killed = grep.findFirst(DEBUGGEE_RESULT + \" =\" );\n+        if (killed.length() > 0) {\n+            if (killed.indexOf(DEBUGGEE_RESULT + \" = \" + numThreads) < 0) {\n+                log.complain(\"Only \" + killed + \"out of \" + numThreads + MYTHREAD + \"s were killed.\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/kill\/kill001\/kill001.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    public static volatile int notKilled = 0;\n+    public static volatile int killed    = 0;\n@@ -89,0 +89,1 @@\n+\n@@ -113,1 +114,1 @@\n-        log.display(\"notKilled == \" + notKilled);\n+        log.display(\"killed == \" + killed);\n@@ -136,0 +137,1 @@\n+    public boolean exceptionThrown = true;\n@@ -143,2 +145,0 @@\n-        boolean killed = false;\n-\n@@ -148,1 +148,1 @@\n-        String CaughtExpected =\"Thread \" + this.name + \" caught expected async exception: \" + expectedException;\n+        String CaughtExpected = \"Thread \" + this.name + \" caught expected async exception: \" + expectedException;\n@@ -156,4 +156,1 @@\n-        \/\/ prevent thread from early finish\n-        synchronized (kill001a.lock) {}\n-\n-        \/\/ Sleep during waitTime to give debugger a chance to kill debugee's thread.\n+            \n@@ -161,4 +158,4 @@\n-            Thread.currentThread().sleep(kill001a.waitTime);\n-        } catch (InterruptedException e) {\n-            kill001a.log.display(ThreadInterrupted);\n-            e.printStackTrace(kill001a.log.getOutStream());\n+            synchronized (kill001a.lock) { }\n+            \/\/ We need some code that does an invoke here to make sure the async exception\n+            \/\/ gets thrown before we leave the try block. Printing a log message works well.\n+            kill001a.log.display(\"exited synchronized\");\n@@ -168,1 +165,5 @@\n-                killed = true;\n+                \/\/ Need to make sure the increment is atomic\n+                synchronized (kill001a.lock) {\n+                    kill001a.killed++;\n+                }\n+                kill001a.log.complain(\"No exception for \" + this.name);\n@@ -175,7 +176,0 @@\n-\n-        if (!killed) {\n-            \/\/ Need to make sure the increment is atomic\n-            synchronized (kill001a.lock) {\n-                kill001a.notKilled++;\n-            }\n-        }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/kill\/kill001\/kill001a.java","additions":15,"deletions":21,"binary":false,"changes":36,"status":"modified"}]}