{"files":[{"patch":"@@ -82,1 +82,0 @@\n-vmTestbase\/nsk\/jdb\/kill\/kill001\/kill001.java        8306467 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Virtual.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-    static final String DEBUGGEE_RESULT = DEBUGGEE_CLASS + \".notKilled\";\n+    static final String DEBUGGEE_RESULT = DEBUGGEE_CLASS + \".killed\";\n@@ -98,4 +98,0 @@\n-        Paragrep grep;\n-        int count;\n-        Vector v;\n-        String found;\n@@ -103,1 +99,0 @@\n-        boolean vthreadMode = \"Virtual\".equals(System.getProperty(\"main.wrapper\"));\n@@ -108,0 +103,7 @@\n+        \/\/ Issue a jdb \"catch all\" command for each exception type that will be thrown.\n+        \/\/ This will force jdb to stop when the exception is thrown.\n+        for (int i = 0; i < kill001a.exceptions.length; i++) {\n+            String className = kill001a.exceptions[i].getClass().getName();\n+            reply = jdb.receiveReplyFor(JdbCommand._catch + \"all \" + className);\n+        }\n+\n@@ -121,2 +123,0 @@\n-            \/\/ kill (ThreadReference.stop) is not supproted for vthreads, so we expect an error.\n-            String msg = (vthreadMode ? \"Operation is not supported\" : \"killed\");\n@@ -125,1 +125,1 @@\n-                                                       msg);\n+                                                       \"killed\");\n@@ -132,6 +132,3 @@\n-        \/\/ Continue each of the threads that received the \"kill\" exception. Not needed\n-        \/\/ for the vthread case since they are not actually killed.\n-        if (!vthreadMode) {\n-            for (int i = 0; i < numThreads; i++) {\n-                reply = jdb.receiveReplyFor(JdbCommand.cont);\n-            }\n+        \/\/ Continue each of the threads that received the \"kill\" exception.\n+        for (int i = 0; i < numThreads; i++) {\n+            reply = jdb.receiveReplyFor(JdbCommand.cont);\n@@ -149,10 +146,5 @@\n-        grep = new Paragrep(reply);\n-        found = grep.findFirst(DEBUGGEE_RESULT + \" =\" );\n-        if (found.length() > 0) {\n-            if (vthreadMode) {\n-                if (found.indexOf(DEBUGGEE_RESULT + \" = \" + numThreads) < 0) {\n-                    log.complain(\"Some \" + MYTHREAD + \"s were killed. \" + found + \" remaining\");\n-                    success = false;\n-                }\n-            } else if (found.indexOf(DEBUGGEE_RESULT + \" = 0\") < 0) {\n-                log.complain(\"Not all \" + MYTHREAD + \"s were killed. \" + found + \" remaining\");\n+        Paragrep grep = new Paragrep(reply);\n+        String killed = grep.findFirst(DEBUGGEE_RESULT + \" =\" );\n+        if (killed.length() > 0) {\n+            if (killed.indexOf(DEBUGGEE_RESULT + \" = \" + numThreads) < 0) {\n+                log.complain(\"Only \" + killed + \"out of \" + numThreads + MYTHREAD + \"s were killed.\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/kill\/kill001\/kill001.java","additions":18,"deletions":26,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    public static volatile int notKilled = 0;\n+    public static volatile int killed    = 0;\n@@ -50,1 +50,0 @@\n-    static boolean vthreadMode           = \"Virtual\".equals(System.getProperty(\"main.wrapper\"));\n@@ -61,1 +60,1 @@\n-                                          };\n+    };\n@@ -65,1 +64,0 @@\n-\n@@ -75,1 +73,1 @@\n-            holder[i] = JDIThreadFactory.newThread(new MyThread(name), name);\n+            holder[i] = JDIThreadFactory.newThread(new MyThread(name, exceptions[i]), name);\n@@ -91,0 +89,1 @@\n+\n@@ -99,7 +98,1 @@\n-                if (vthreadMode) {\n-                    \/\/ vthreads will exit on their own without being killed, so just wait for them to exit.\n-                    try {\n-                        holder[i].join();\n-                    } catch (InterruptedException e) {\n-                    }\n-                } else if (holder[i].isAlive()) {\n+                if (holder[i].isAlive()) {\n@@ -112,1 +105,1 @@\n-                        log.display(\"Main thread was interrupted while waiting for killing of \" + MYTHREAD + \"-\" + i);\n+                        log.complain(\"Main thread was interrupted while waiting for killing of \" + MYTHREAD + \"-\" + i);\n@@ -116,1 +109,1 @@\n-            if (!waited || vthreadMode) {\n+            if (!waited) {\n@@ -121,1 +114,1 @@\n-        log.display(\"notKilled == \" + notKilled);\n+        log.display(\"killed == \" + killed);\n@@ -125,1 +118,1 @@\n-                log.display(\"Debuggee FAILED - thread \" + i + \" is alive\");\n+                log.complain(\"Debuggee FAILED - thread \" + i + \" is alive\");\n@@ -133,0 +126,1 @@\n+}\n@@ -134,4 +128,3 @@\n-    static class MyException extends Exception {\n-        MyException (String message) {\n-            super(message);\n-        }\n+class MyException extends Exception {\n+    MyException (String message) {\n+        super(message);\n@@ -141,1 +134,0 @@\n-\n@@ -144,0 +136,2 @@\n+    Throwable expectedException;\n+    public boolean exceptionThrown = true;\n@@ -145,1 +139,1 @@\n-    public MyThread (String n) {\n+    public MyThread(String n, Throwable e) {\n@@ -147,0 +141,1 @@\n+        expectedException = e;\n@@ -151,1 +146,1 @@\n-        String ThreadFinished = \"WARNING: Thread finished: \" + this.name;\n+        String ThreadFinished = \"Thread finished: \" + this.name;\n@@ -153,0 +148,3 @@\n+        String CaughtExpected = \"Thread \" + this.name + \" caught expected async exception: \" + expectedException;\n+        String CaughtUnexpected = \"WARNING: Thread \" + this.name + \" caught unexpected exception:\";\n+\n@@ -158,6 +156,1 @@\n-        \/\/ prevent thread from early finish\n-        synchronized (kill001a.lock) {}\n-\n-        \/\/ Sleep during waitTime to give debugger a chance to kill debugee's thread.\n-        \/\/ Note vthreads need a short sleep because they will never receive the kill,\n-        \/\/ and therefore sleep the full time, resulting in a test timeout if too long.\n+            \n@@ -165,9 +158,17 @@\n-            Thread.currentThread().sleep(kill001a.vthreadMode ? 10000 : kill001a.waitTime);\n-        } catch (InterruptedException e) {\n-            kill001a.log.display(ThreadInterrupted);\n-            e.printStackTrace(kill001a.log.getOutStream());\n-        }\n-\n-        \/\/ Need to make sure the increment is atomic\n-        synchronized (kill001a.lock) {\n-            kill001a.notKilled++;\n+            synchronized (kill001a.lock) { }\n+            \/\/ We need some code that does an invoke here to make sure the async exception\n+            \/\/ gets thrown before we leave the try block. Printing a log message works well.\n+            kill001a.log.display(\"exited synchronized\");\n+        } catch (Throwable t) {\n+            if (t == expectedException) {\n+                kill001a.log.display(CaughtExpected);\n+                \/\/ Need to make sure the increment is atomic\n+                synchronized (kill001a.lock) {\n+                    kill001a.killed++;\n+                }\n+                kill001a.log.complain(\"No exception for \" + this.name);\n+            } else {\n+                kill001a.log.display(CaughtUnexpected);\n+                kill001a.log.display(t);\n+                t.printStackTrace(kill001a.log.getOutStream());\n+            }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/kill\/kill001\/kill001a.java","additions":40,"deletions":39,"binary":false,"changes":79,"status":"modified"}]}