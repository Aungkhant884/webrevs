{"files":[{"patch":"@@ -8889,0 +8889,11 @@\n+instruct castLL(iRegL dst)\n+%{\n+  match(Set dst (CastLL dst));\n+\n+  size(0);\n+  format %{ \"# castLL of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -5302,0 +5302,8 @@\n+instruct castLL( iRegL dst ) %{\n+  match(Set dst (CastLL dst));\n+  format %{ \"! castLL of $dst\" %}\n+  ins_encode( \/*empty encoding*\/ );\n+  ins_cost(0);\n+  ins_pipe(empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -10387,0 +10387,8 @@\n+instruct castLL(iRegLdst dst) %{\n+  match(Set dst (CastLL dst));\n+  format %{ \" -- \\t\/\/ castLL of $dst\" %}\n+  size(0);\n+  ins_encode( \/*empty*\/ );\n+  ins_pipe(pipe_class_default);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -5382,0 +5382,7 @@\n+instruct castLL(iRegL dst) %{\n+  match(Set dst (CastLL dst));\n+  size(0);\n+  format %{ \"# castLL of $dst\" %}\n+  ins_encode(\/*empty*\/);\n+  ins_pipe(pipe_class_dummy);\n+%}\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -7179,0 +7179,8 @@\n+instruct castLL( eRegL dst ) %{\n+  match(Set dst (CastLL dst));\n+  format %{ \"#castLL of $dst\" %}\n+  ins_encode( \/*empty encoding*\/ );\n+  ins_cost(0);\n+  ins_pipe( empty );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7473,0 +7473,11 @@\n+instruct castLL(rRegL dst)\n+%{\n+  match(Set dst (CastLL dst));\n+\n+  size(0);\n+  format %{ \"# castLL of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -340,0 +340,2 @@\n+  do_intrinsic(_Preconditions_checkLongIndex, jdk_internal_util_Preconditions, checkIndex_name, Preconditions_checkLongIndex_signature, F_S)   \\\n+   do_signature(Preconditions_checkLongIndex_signature,          \"(JJLjava\/util\/function\/BiFunction;)J\")                \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -652,0 +652,1 @@\n+  case vmIntrinsics::_Preconditions_checkLongIndex:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -99,0 +99,5 @@\n+  case Op_CastLL: {\n+    Node* cast = new CastLLNode(n, t, carry_dependency);\n+    cast->set_req(0, c);\n+    return cast;\n+  }\n@@ -111,0 +116,14 @@\n+Node* ConstraintCastNode::make(Node* c, Node *n, const Type *t, BasicType bt) {\n+  switch(bt) {\n+  case T_INT: {\n+    return make_cast(Op_CastII, c, n, t, false);\n+  }\n+  case T_LONG: {\n+    return make_cast(Op_CastLL, c, n, t, false);\n+  }\n+  default:\n+    fatal(\"Bad basic type %s\", type2name(bt));\n+  }\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+  static Node* make(Node* c, Node *n, const Type *t, BasicType bt);\n@@ -95,0 +96,10 @@\n+class CastLLNode: public ConstraintCastNode {\n+public:\n+  CastLLNode(Node* n, const Type* t, bool carry_dependency = false)\n+          : ConstraintCastNode(n, t, carry_dependency){\n+    init_class_id(Class_CastLL);\n+  }\n+  virtual int Opcode() const;\n+  virtual uint ideal_reg() const { return Op_RegL; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1973,1 +1973,1 @@\n-      assert(phi_type->isa_int() || phi_type->isa_ptr(), \"bad phi type\");\n+      assert(phi_type->isa_int() || phi_type->isa_ptr() || phi_type->isa_long(), \"bad phi type\");\n@@ -1979,0 +1979,2 @@\n+      } else if (phi_type->isa_long()) {\n+        cast = ConstraintCastNode::make_cast(Op_CastLL, r, uin, phi_type, true);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+macro(CastLL)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -106,0 +106,7 @@\n+  Node* integercon(jlong con, BasicType bt)   const {\n+    if (bt == T_INT) {\n+      return intcon(checked_cast<jint>(con));\n+    }\n+    assert(bt == T_LONG, \"basic type not an int or long\");\n+    return longcon(con);\n+  }\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -486,1 +486,2 @@\n-  case vmIntrinsics::_Preconditions_checkIndex: return inline_preconditions_checkIndex();\n+  case vmIntrinsics::_Preconditions_checkIndex: return inline_preconditions_checkIndex(T_INT);\n+  case vmIntrinsics::_Preconditions_checkLongIndex: return inline_preconditions_checkIndex(T_LONG);\n@@ -1004,1 +1005,1 @@\n-bool LibraryCallKit::inline_preconditions_checkIndex() {\n+bool LibraryCallKit::inline_preconditions_checkIndex(BasicType bt) {\n@@ -1006,1 +1007,1 @@\n-  Node* length = argument(1);\n+  Node* length = bt == T_INT ? argument(1) : argument(2);\n@@ -1011,1 +1012,2 @@\n-  Node* len_pos_cmp = _gvn.transform(new CmpINode(length, intcon(0)));\n+  \/\/ check that length is positive\n+  Node* len_pos_cmp = _gvn.transform(CmpNode::make(length, integercon(0, bt), bt));\n@@ -1020,0 +1022,7 @@\n+  \/\/ length is now known postive, add a cast node to make this explicit\n+  jlong upper_bound = _gvn.type(length)->is_integer(bt)->hi_as_long();\n+  Node* casted_length = ConstraintCastNode::make(control(), length, TypeInteger::make(0, upper_bound, Type::WidenMax, bt), bt);\n+  casted_length = _gvn.transform(casted_length);\n+  replace_in_map(length, casted_length);\n+  length = casted_length;\n+\n@@ -1024,1 +1033,2 @@\n-  Node* rc_cmp = _gvn.transform(new CmpUNode(index, length));\n+  \/\/ Use an unsigned comparison for the range check itself\n+  Node* rc_cmp = _gvn.transform(CmpNode::make(index, length, bt, true));\n@@ -1044,2 +1054,2 @@\n-  Node* result = new CastIINode(index, TypeInt::make(0, _gvn.type(length)->is_int()->_hi, Type::WidenMax));\n-  result->set_req(0, control());\n+  \/\/ index is now known to be >= 0 and < length, cast it\n+  Node* result = ConstraintCastNode::make(control(), index, TypeInteger::make(0, upper_bound, Type::WidenMax, bt), bt);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-  bool inline_preconditions_checkIndex();\n+  bool inline_preconditions_checkIndex(BasicType bt);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+class CastLLNode;\n@@ -674,0 +675,1 @@\n+        DEFINE_CLASS_ID(CastLL, ConstraintCast, 2)\n@@ -822,0 +824,1 @@\n+  DEFINE_CLASS_QUERY(CastLL)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -277,0 +277,1 @@\n+  ConNode* integercon(jlong l, BasicType bt);\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -566,0 +566,1 @@\n+\n@@ -568,0 +569,18 @@\n+CmpNode *CmpNode::make(Node *in1, Node *in2, BasicType bt, bool unsigned_comp) {\n+  switch (bt) {\n+    case T_INT:\n+      if (unsigned_comp) {\n+        return new CmpUNode(in1, in2);\n+      }\n+      return new CmpINode(in1, in2);\n+    case T_LONG:\n+      if (unsigned_comp) {\n+        return new CmpULNode(in1, in2);\n+      }\n+      return new CmpLNode(in1, in2);\n+    default:\n+      fatal(\"Not implemented for %s\", type2name(bt));\n+  }\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -143,0 +143,2 @@\n+  static CmpNode *make(Node *in1, Node *in2, BasicType bt, bool unsigned_comp = false);\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1348,0 +1348,8 @@\n+const TypeInteger* TypeInteger::make(jlong lo, jlong hi, int w, BasicType bt) {\n+  if (bt == T_INT) {\n+    return TypeInt::make(checked_cast<jint>(lo), checked_cast<jint>(hi), w);\n+  }\n+  assert(bt == T_LONG, \"basic type not an int or long\");\n+  return TypeLong::make(lo, hi, w);\n+}\n+\n@@ -1373,1 +1381,1 @@\n-TypeInt::TypeInt( jint lo, jint hi, int w ) : Type(Int), _lo(lo), _hi(hi), _widen(w) {\n+TypeInt::TypeInt( jint lo, jint hi, int w ) : TypeInteger(Int), _lo(lo), _hi(hi), _widen(w) {\n@@ -1633,1 +1641,1 @@\n-TypeLong::TypeLong( jlong lo, jlong hi, int w ) : Type(Long), _lo(lo), _hi(hi), _widen(w) {\n+TypeLong::TypeLong(jlong lo, jlong hi, int w) : TypeInteger(Long), _lo(lo), _hi(hi), _widen(w) {\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -48,2 +48,3 @@\n-class   TypeInt;\n-class   TypeLong;\n+class   TypeInteger;\n+class     TypeInt;\n+class     TypeLong;\n@@ -286,0 +287,3 @@\n+  const TypeInteger* isa_integer() const;\n+  const TypeInteger* is_integer(BasicType bt) const;\n+  const TypeInteger* isa_integer(BasicType bt) const;\n@@ -528,0 +532,14 @@\n+class TypeInteger : public Type {\n+protected:\n+  TypeInteger(TYPES t) : Type(t) {}\n+\n+public:\n+  virtual jlong hi_as_long() const = 0;\n+  virtual jlong lo_as_long() const = 0;\n+  jlong get_con_as_long(BasicType bt) const;\n+\n+  static const TypeInteger* make(jlong lo, jlong hi, int w, BasicType bt);\n+};\n+\n+\n+\n@@ -531,1 +549,1 @@\n-class TypeInt : public Type {\n+class TypeInt : public TypeInteger {\n@@ -560,0 +578,4 @@\n+\n+  virtual jlong hi_as_long() const { return _hi; }\n+  virtual jlong lo_as_long() const { return _lo; }\n+\n@@ -594,1 +616,1 @@\n-class TypeLong : public Type {\n+class TypeLong : public TypeInteger {\n@@ -623,0 +645,2 @@\n+  virtual jlong hi_as_long() const { return _hi; }\n+  virtual jlong lo_as_long() const { return _lo; }\n@@ -1578,0 +1602,9 @@\n+inline const TypeInteger *Type::is_integer(BasicType bt) const {\n+  assert((bt == T_INT && _base == Int) || (bt == T_LONG && _base == Long), \"Not an Int\");\n+  return (TypeInteger*)this;\n+}\n+\n+inline const TypeInteger *Type::isa_integer(BasicType bt) const {\n+  return (((bt == T_INT && _base == Int) || (bt == T_LONG && _base == Long)) ? (TypeInteger*)this : NULL);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":37,"deletions":4,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,0 +71,14 @@\n+\n+    \/**\n+     * Constructs a new {@code IndexOutOfBoundsException} class with an\n+     * argument indicating the illegal index.\n+     *\n+     * <p>The index is included in this exception's detail message.  The\n+     * exact presentation format of the detail message is unspecified.\n+     *\n+     * @param index the illegal index.\n+     * @since 16\n+     *\/\n+    public IndexOutOfBoundsException(long index) {\n+        super(\"Index out of range: \" + index);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/IndexOutOfBoundsException.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2149,1 +2149,1 @@\n-    static final BiFunction<String, List<Integer>, ArrayIndexOutOfBoundsException>\n+    static final BiFunction<String, List<Number>, ArrayIndexOutOfBoundsException>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -414,0 +414,75 @@\n+    \/**\n+     * Checks if the {@code index} is within the bounds of the range from\n+     * {@code 0} (inclusive) to {@code length} (exclusive).\n+     *\n+     * <p>The {@code index} is defined to be out of bounds if any of the\n+     * following inequalities is true:\n+     * <ul>\n+     *  <li>{@code index < 0}<\/li>\n+     *  <li>{@code index >= length}<\/li>\n+     *  <li>{@code length < 0}, which is implied from the former inequalities<\/li>\n+     * <\/ul>\n+     *\n+     * @param index the index\n+     * @param length the upper-bound (exclusive) of the range\n+     * @return {@code index} if it is within bounds of the range\n+     * @throws IndexOutOfBoundsException if the {@code index} is out of bounds\n+     * @since 16\n+     *\/\n+    @ForceInline\n+    public static\n+    long checkIndex(long index, long length) {\n+        return Preconditions.checkIndex(index, length, null);\n+    }\n+\n+    \/**\n+     * Checks if the sub-range from {@code fromIndex} (inclusive) to\n+     * {@code toIndex} (exclusive) is within the bounds of range from {@code 0}\n+     * (inclusive) to {@code length} (exclusive).\n+     *\n+     * <p>The sub-range is defined to be out of bounds if any of the following\n+     * inequalities is true:\n+     * <ul>\n+     *  <li>{@code fromIndex < 0}<\/li>\n+     *  <li>{@code fromIndex > toIndex}<\/li>\n+     *  <li>{@code toIndex > length}<\/li>\n+     *  <li>{@code length < 0}, which is implied from the former inequalities<\/li>\n+     * <\/ul>\n+     *\n+     * @param fromIndex the lower-bound (inclusive) of the sub-range\n+     * @param toIndex the upper-bound (exclusive) of the sub-range\n+     * @param length the upper-bound (exclusive) the range\n+     * @return {@code fromIndex} if the sub-range within bounds of the range\n+     * @throws IndexOutOfBoundsException if the sub-range is out of bounds\n+     * @since 16\n+     *\/\n+    public static\n+    long checkFromToIndex(long fromIndex, long toIndex, long length) {\n+        return Preconditions.checkFromToIndex(fromIndex, toIndex, length, null);\n+    }\n+\n+    \/**\n+     * Checks if the sub-range from {@code fromIndex} (inclusive) to\n+     * {@code fromIndex + size} (exclusive) is within the bounds of range from\n+     * {@code 0} (inclusive) to {@code length} (exclusive).\n+     *\n+     * <p>The sub-range is defined to be out of bounds if any of the following\n+     * inequalities is true:\n+     * <ul>\n+     *  <li>{@code fromIndex < 0}<\/li>\n+     *  <li>{@code size < 0}<\/li>\n+     *  <li>{@code fromIndex + size > length}, taking into account integer overflow<\/li>\n+     *  <li>{@code length < 0}, which is implied from the former inequalities<\/li>\n+     * <\/ul>\n+     *\n+     * @param fromIndex the lower-bound (inclusive) of the sub-interval\n+     * @param size the size of the sub-range\n+     * @param length the upper-bound (exclusive) of the range\n+     * @return {@code fromIndex} if the sub-range within bounds of the range\n+     * @throws IndexOutOfBoundsException if the sub-range is out of bounds\n+     * @since 16\n+     *\/\n+    public static\n+    long checkFromIndexSize(long fromIndex, long size, long length) {\n+        return Preconditions.checkFromIndexSize(fromIndex, size, length, null);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/Objects.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-            BiFunction<String, List<Integer>, ? extends RuntimeException> oobef,\n+            BiFunction<String, List<Number>, ? extends RuntimeException> oobef,\n@@ -59,2 +59,2 @@\n-            Integer... args) {\n-        List<Integer> largs = List.of(args);\n+            Number... args) {\n+        List<Number> largs = List.of(args);\n@@ -68,1 +68,1 @@\n-            BiFunction<String, List<Integer>, ? extends RuntimeException> oobe,\n+            BiFunction<String, List<Number>, ? extends RuntimeException> oobe,\n@@ -74,1 +74,1 @@\n-            BiFunction<String, List<Integer>, ? extends RuntimeException> oobe,\n+            BiFunction<String, List<Number>, ? extends RuntimeException> oobe,\n@@ -80,1 +80,1 @@\n-            BiFunction<String, List<Integer>, ? extends RuntimeException> oobe,\n+            BiFunction<String, List<Number>, ? extends RuntimeException> oobe,\n@@ -85,0 +85,18 @@\n+    private static RuntimeException outOfBoundsCheckIndex(\n+            BiFunction<String, List<Number>, ? extends RuntimeException> oobe,\n+            long index, long length) {\n+        return outOfBounds(oobe, \"checkIndex\", index, length);\n+    }\n+\n+    private static RuntimeException outOfBoundsCheckFromToIndex(\n+            BiFunction<String, List<Number>, ? extends RuntimeException> oobe,\n+            long fromIndex, long toIndex, long length) {\n+        return outOfBounds(oobe, \"checkFromToIndex\", fromIndex, toIndex, length);\n+    }\n+\n+    private static RuntimeException outOfBoundsCheckFromIndexSize(\n+            BiFunction<String, List<Number>, ? extends RuntimeException> oobe,\n+            long fromIndex, long size, long length) {\n+        return outOfBounds(oobe, \"checkFromIndexSize\", fromIndex, size, length);\n+    }\n+\n@@ -93,2 +111,2 @@\n-     * <em>check kind<\/em>; and a {@code List<Integer>} containing the\n-     * out-of-bound integer values that failed the check.  The list of\n+     * <em>check kind<\/em>; and a {@code List<Number>} containing the\n+     * out-of-bound integral values that failed the check.  The list of\n@@ -105,1 +123,1 @@\n-     * out-of-bound integer values correspond to method argument values, in\n+     * out-of-bound integral values correspond to method argument values, in\n@@ -126,1 +144,1 @@\n-     * BiFunction<String, List<Integer>, ArrayIndexOutOfBoundsException> AIOOBEF =\n+     * BiFunction<String, List<Number>, ArrayIndexOutOfBoundsException> AIOOBEF =\n@@ -153,1 +171,1 @@\n-    BiFunction<String, List<Integer>, X> outOfBoundsExceptionFormatter(Function<String, X> f) {\n+    BiFunction<String, List<Number>, X> outOfBoundsExceptionFormatter(Function<String, X> f) {\n@@ -156,1 +174,1 @@\n-        return new BiFunction<String, List<Integer>, X>() {\n+        return new BiFunction<String, List<Number>, X>() {\n@@ -158,1 +176,1 @@\n-            public X apply(String checkKind, List<Integer> args) {\n+            public X apply(String checkKind, List<Number> args) {\n@@ -164,1 +182,1 @@\n-    private static String outOfBoundsMessage(String checkKind, List<Integer> args) {\n+    private static String outOfBoundsMessage(String checkKind, List<? extends Number> args) {\n@@ -216,1 +234,1 @@\n-     * and an unmodifiable list integers whose values are, in order, the\n+     * and an unmodifiable list of integers whose values are, in order, the\n@@ -246,1 +264,1 @@\n-                   BiFunction<String, List<Integer>, X> oobef) {\n+                   BiFunction<String, List<Number>, X> oobef) {\n@@ -269,1 +287,1 @@\n-     * and an unmodifiable list integers whose values are, in order, the\n+     * and an unmodifiable list of integers whose values are, in order, the\n@@ -293,1 +311,1 @@\n-                         BiFunction<String, List<Integer>, X> oobef) {\n+                         BiFunction<String, List<Number>, X> oobef) {\n@@ -316,1 +334,1 @@\n-     * and an unmodifiable list integers whose values are, in order, the\n+     * and an unmodifiable list of integers whose values are, in order, the\n@@ -341,1 +359,147 @@\n-                           BiFunction<String, List<Integer>, X> oobef) {\n+                           BiFunction<String, List<Number>, X> oobef) {\n+        if ((length | fromIndex | size) < 0 || size > length - fromIndex)\n+            throw outOfBoundsCheckFromIndexSize(oobef, fromIndex, size, length);\n+        return fromIndex;\n+    }\n+\n+    \/**\n+     * Checks if the {@code index} is within the bounds of the range from\n+     * {@code 0} (inclusive) to {@code length} (exclusive).\n+     *\n+     * <p>The {@code index} is defined to be out of bounds if any of the\n+     * following inequalities is true:\n+     * <ul>\n+     *  <li>{@code index < 0}<\/li>\n+     *  <li>{@code index >= length}<\/li>\n+     *  <li>{@code length < 0}, which is implied from the former inequalities<\/li>\n+     * <\/ul>\n+     *\n+     * <p>If the {@code index} is out of bounds, then a runtime exception is\n+     * thrown that is the result of applying the following arguments to the\n+     * exception formatter: the name of this method, {@code checkIndex};\n+     * and an unmodifiable list of longs whose values are, in order, the\n+     * out-of-bounds arguments {@code index} and {@code length}.\n+     *\n+     * @param <X> the type of runtime exception to throw if the arguments are\n+     *        out of bounds\n+     * @param index the index\n+     * @param length the upper-bound (exclusive) of the range\n+     * @param oobef the exception formatter that when applied with this\n+     *        method name and out-of-bounds arguments returns a runtime\n+     *        exception.  If {@code null} or returns {@code null} then, it is as\n+     *        if an exception formatter produced from an invocation of\n+     *        {@code outOfBoundsExceptionFormatter(IndexOutOfBounds::new)} is used\n+     *        instead (though it may be more efficient).\n+     *        Exceptions thrown by the formatter are relayed to the caller.\n+     * @return {@code index} if it is within bounds of the range\n+     * @throws X if the {@code index} is out of bounds and the exception\n+     *         formatter is non-{@code null}\n+     * @throws IndexOutOfBoundsException if the {@code index} is out of bounds\n+     *         and the exception formatter is {@code null}\n+     * @since 16\n+     *\n+     * @implNote\n+     * This method is made intrinsic in optimizing compilers to guide them to\n+     * perform unsigned comparisons of the index and length when it is known the\n+     * length is a non-negative value (such as that of an array length or from\n+     * the upper bound of a loop)\n+     *\/\n+    @IntrinsicCandidate\n+    public static <X extends RuntimeException>\n+    long checkIndex(long index, long length,\n+                    BiFunction<String, List<Number>, X> oobef) {\n+        if (index < 0 || index >= length)\n+            throw outOfBoundsCheckIndex(oobef, index, length);\n+        return index;\n+    }\n+\n+    \/**\n+     * Checks if the sub-range from {@code fromIndex} (inclusive) to\n+     * {@code toIndex} (exclusive) is within the bounds of range from {@code 0}\n+     * (inclusive) to {@code length} (exclusive).\n+     *\n+     * <p>The sub-range is defined to be out of bounds if any of the following\n+     * inequalities is true:\n+     * <ul>\n+     *  <li>{@code fromIndex < 0}<\/li>\n+     *  <li>{@code fromIndex > toIndex}<\/li>\n+     *  <li>{@code toIndex > length}<\/li>\n+     *  <li>{@code length < 0}, which is implied from the former inequalities<\/li>\n+     * <\/ul>\n+     *\n+     * <p>If the sub-range is out of bounds, then a runtime exception is\n+     * thrown that is the result of applying the following arguments to the\n+     * exception formatter: the name of this method, {@code checkFromToIndex};\n+     * and an unmodifiable list of longs whose values are, in order, the\n+     * out-of-bounds arguments {@code fromIndex}, {@code toIndex}, and {@code length}.\n+     *\n+     * @param <X> the type of runtime exception to throw if the arguments are\n+     *        out of bounds\n+     * @param fromIndex the lower-bound (inclusive) of the sub-range\n+     * @param toIndex the upper-bound (exclusive) of the sub-range\n+     * @param length the upper-bound (exclusive) the range\n+     * @param oobef the exception formatter that when applied with this\n+     *        method name and out-of-bounds arguments returns a runtime\n+     *        exception.  If {@code null} or returns {@code null} then, it is as\n+     *        if an exception formatter produced from an invocation of\n+     *        {@code outOfBoundsExceptionFormatter(IndexOutOfBounds::new)} is used\n+     *        instead (though it may be more efficient).\n+     *        Exceptions thrown by the formatter are relayed to the caller.\n+     * @return {@code fromIndex} if the sub-range within bounds of the range\n+     * @throws X if the sub-range is out of bounds and the exception factory\n+     *         function is non-{@code null}\n+     * @throws IndexOutOfBoundsException if the sub-range is out of bounds and\n+     *         the exception factory function is {@code null}\n+     * @since 16\n+     *\/\n+    public static <X extends RuntimeException>\n+    long checkFromToIndex(long fromIndex, long toIndex, long length,\n+                          BiFunction<String, List<Number>, X> oobef) {\n+        if (fromIndex < 0 || fromIndex > toIndex || toIndex > length)\n+            throw outOfBoundsCheckFromToIndex(oobef, fromIndex, toIndex, length);\n+        return fromIndex;\n+    }\n+\n+    \/**\n+     * Checks if the sub-range from {@code fromIndex} (inclusive) to\n+     * {@code fromIndex + size} (exclusive) is within the bounds of range from\n+     * {@code 0} (inclusive) to {@code length} (exclusive).\n+     *\n+     * <p>The sub-range is defined to be out of bounds if any of the following\n+     * inequalities is true:\n+     * <ul>\n+     *  <li>{@code fromIndex < 0}<\/li>\n+     *  <li>{@code size < 0}<\/li>\n+     *  <li>{@code fromIndex + size > length}, taking into account integer overflow<\/li>\n+     *  <li>{@code length < 0}, which is implied from the former inequalities<\/li>\n+     * <\/ul>\n+     *\n+     * <p>If the sub-range is out of bounds, then a runtime exception is\n+     * thrown that is the result of applying the following arguments to the\n+     * exception formatter: the name of this method, {@code checkFromIndexSize};\n+     * and an unmodifiable list of longs whose values are, in order, the\n+     * out-of-bounds arguments {@code fromIndex}, {@code size}, and\n+     * {@code length}.\n+     *\n+     * @param <X> the type of runtime exception to throw if the arguments are\n+     *        out of bounds\n+     * @param fromIndex the lower-bound (inclusive) of the sub-interval\n+     * @param size the size of the sub-range\n+     * @param length the upper-bound (exclusive) of the range\n+     * @param oobef the exception formatter that when applied with this\n+     *        method name and out-of-bounds arguments returns a runtime\n+     *        exception.  If {@code null} or returns {@code null} then, it is as\n+     *        if an exception formatter produced from an invocation of\n+     *        {@code outOfBoundsExceptionFormatter(IndexOutOfBounds::new)} is used\n+     *        instead (though it may be more efficient).\n+     *        Exceptions thrown by the formatter are relayed to the caller.\n+     * @return {@code fromIndex} if the sub-range within bounds of the range\n+     * @throws X if the sub-range is out of bounds and the exception factory\n+     *         function is non-{@code null}\n+     * @throws IndexOutOfBoundsException if the sub-range is out of bounds and\n+     *         the exception factory function is {@code null}\n+     * @since 16\n+     *\/\n+    public static <X extends RuntimeException>\n+    long checkFromIndexSize(long fromIndex, long size, long length,\n+                            BiFunction<String, List<Number>, X> oobef) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/Preconditions.java","additions":184,"deletions":20,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-    private static final BiFunction<String, List<Integer>,\n+    private static final BiFunction<String, List<Number>,\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/ArrayUtil.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -439,0 +439,1 @@\n+                            \"jdk\/internal\/util\/Preconditions.checkIndex(JJLjava\/util\/function\/BiFunction;)J\",\n","filename":"src\/jdk.internal.vm.compiler\/share\/classes\/org.graalvm.compiler.hotspot.test\/src\/org\/graalvm\/compiler\/hotspot\/test\/CheckGraalIntrinsics.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8255150\n+ * @summary Add utility methods to check long indexes and ranges\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @library \/test\/lib \/\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm -ea -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-BackgroundCompilation TestCheckIndex\n+ *\n+ *\/\n+\n+import java.util.Objects;\n+import sun.hotspot.WhiteBox;\n+import java.lang.reflect.Method;\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+\n+public class TestCheckIndex {\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) throws NoSuchMethodException {\n+        Objects.checkIndex(0, 10); \/\/ Load class\n+        Method m1 = TestCheckIndex.class.getDeclaredMethod(\"test1\", int.class, int.class);\n+        Method m2 = TestCheckIndex.class.getDeclaredMethod(\"test2\", long.class, long.class);\n+        Method m3 = TestCheckIndex.class.getDeclaredMethod(\"test3\", int.class, int.class);\n+        Method m4 = TestCheckIndex.class.getDeclaredMethod(\"test4\", long.class, long.class);\n+        assert m1 != null && m2 != null && m3 != null && m4 != null;\n+        WHITE_BOX.enqueueMethodForCompilation(m1, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+        if (!WHITE_BOX.isMethodCompiled(m1)) {\n+            throw new RuntimeException(\"should be compiled\");\n+        }\n+        WHITE_BOX.enqueueMethodForCompilation(m2, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+        if (!WHITE_BOX.isMethodCompiled(m2)) {\n+            throw new RuntimeException(\"should be compiled\");\n+        }\n+        WHITE_BOX.enqueueMethodForCompilation(m3, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+        if (!WHITE_BOX.isMethodCompiled(m3)) {\n+            throw new RuntimeException(\"should be compiled\");\n+        }\n+        WHITE_BOX.enqueueMethodForCompilation(m4, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+        if (!WHITE_BOX.isMethodCompiled(m4)) {\n+            throw new RuntimeException(\"should be compiled\");\n+        }\n+\n+        if (test1(0, 10) != 0) {\n+            throw new RuntimeException(\"incorrect result\");\n+        }\n+        if (!WHITE_BOX.isMethodCompiled(m1)) {\n+            throw new RuntimeException(\"should still be compiled\");\n+        }\n+        if (test2(0, 10) != 0) {\n+            throw new RuntimeException(\"incorrect result\");\n+        }\n+        if (!WHITE_BOX.isMethodCompiled(m2)) {\n+            throw new RuntimeException(\"should still be compiled\");\n+        }\n+\n+        try {\n+            test1(0, -10);\n+            throw new RuntimeException(\"exception not thrown\");\n+        } catch (IndexOutOfBoundsException ioobe) {\n+        }\n+        if (WHITE_BOX.isMethodCompiled(m1)) {\n+            throw new RuntimeException(\"should have deoptimized\");\n+        }\n+        try {\n+            test2(0, -10);\n+            throw new RuntimeException(\"exception not thrown\");\n+        } catch (IndexOutOfBoundsException ioobe) {\n+        }\n+        if (WHITE_BOX.isMethodCompiled(m2)) {\n+            throw new RuntimeException(\"should have deoptimized\");\n+        }\n+\n+        try {\n+            test3(42, 10);\n+            throw new RuntimeException(\"exception not thrown\");\n+        } catch (IndexOutOfBoundsException ioobe) {\n+        }\n+        if (WHITE_BOX.isMethodCompiled(m3)) {\n+            throw new RuntimeException(\"should have deoptimized\");\n+        }\n+        try {\n+            test4(42, 10);\n+            throw new RuntimeException(\"exception not thrown\");\n+        } catch (IndexOutOfBoundsException ioobe) {\n+        }\n+        if (WHITE_BOX.isMethodCompiled(m4)) {\n+            throw new RuntimeException(\"should have deoptimized\");\n+        }\n+    }\n+\n+    static int test1(int index, int length) {\n+        return Objects.checkIndex(index, length);\n+    }\n+\n+    static long test2(long index, long length) {\n+        return Objects.checkIndex(index, length);\n+    }\n+\n+    static int test3(int index, int length) {\n+        return Objects.checkIndex(index, length);\n+    }\n+\n+    static long test4(long index, long length) {\n+        return Objects.checkIndex(index, length);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestCheckIndex.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @summary Objects.checkIndex\/jdk.internal.util.Preconditions.checkIndex tests\n+ * @summary Objects.checkIndex\/jdk.internal.util.Preconditions.checkIndex tests for int values\n@@ -53,1 +53,1 @@\n-    static BiFunction<String, List<Integer>, AssertingOutOfBoundsException> assertingOutOfBounds(\n+    static BiFunction<String, List<Number>, AssertingOutOfBoundsException> assertingOutOfBounds(\n@@ -67,1 +67,1 @@\n-    static BiFunction<String, List<Integer>, AssertingOutOfBoundsException> assertingOutOfBoundsReturnNull(\n+    static BiFunction<String, List<Number>, AssertingOutOfBoundsException> assertingOutOfBoundsReturnNull(\n@@ -89,5 +89,1 @@\n-        return l.toArray(new Object[0][0]);\n-    }\n-\n-    interface X {\n-        int apply(int a, int b, int c);\n+        return l.toArray(Object[][]::new);\n@@ -155,1 +151,1 @@\n-        return l.toArray(new Object[0][0]);\n+        return l.toArray(Object[][]::new);\n@@ -224,1 +220,1 @@\n-        return l.toArray(new Object[0][0]);\n+        return l.toArray(Object[][]::new);\n@@ -272,1 +268,1 @@\n-        BiFunction<String, List<Integer>, IndexOutOfBoundsException> f =\n+        BiFunction<String, List<Number>, IndexOutOfBoundsException> f =\n","filename":"test\/jdk\/java\/util\/Objects\/CheckIndex.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,287 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Objects.checkIndex\/jdk.internal.util.Preconditions.checkIndex tests for long values\n+ * @run testng CheckLongIndex\n+ * @modules java.base\/jdk.internal.util\n+ *\/\n+\n+import jdk.internal.util.Preconditions;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.LongSupplier;\n+\n+import static org.testng.Assert.*;\n+\n+public class CheckLongIndex {\n+\n+    static class AssertingOutOfBoundsException extends RuntimeException {\n+        public AssertingOutOfBoundsException(String message) {\n+            super(message);\n+        }\n+    }\n+\n+    static BiFunction<String, List<Number>, AssertingOutOfBoundsException> assertingOutOfBounds(\n+            String message, String expCheckKind, Long... expArgs) {\n+        return (checkKind, args) -> {\n+            assertEquals(checkKind, expCheckKind);\n+            assertEquals(args, List.of(expArgs));\n+            try {\n+                args.clear();\n+                fail(\"Out of bounds List<Long> argument should be unmodifiable\");\n+            } catch (Exception e)  {\n+            }\n+            return new AssertingOutOfBoundsException(message);\n+        };\n+    }\n+\n+    static BiFunction<String, List<Number>, AssertingOutOfBoundsException> assertingOutOfBoundsReturnNull(\n+            String expCheckKind, Long... expArgs) {\n+        return (checkKind, args) -> {\n+            assertEquals(checkKind, expCheckKind);\n+            assertEquals(args, List.of(expArgs));\n+            return null;\n+        };\n+    }\n+\n+    static final long[] VALUES = {0, 1, Long.MAX_VALUE - 1, Long.MAX_VALUE, -1, Long.MIN_VALUE + 1, Long.MIN_VALUE};\n+\n+    @DataProvider\n+    static Object[][] checkIndexProvider() {\n+        List<Object[]> l = new ArrayList<>();\n+        for (long index : VALUES) {\n+            for (long length : VALUES) {\n+                boolean withinBounds = index >= 0 &&\n+                                       length >= 0 &&\n+                                       index < length;\n+                l.add(new Object[]{index, length, withinBounds});\n+            }\n+        }\n+        return l.toArray(Object[][]::new);\n+    }\n+\n+    @Test(dataProvider = \"checkIndexProvider\")\n+    public void testCheckIndex(long index, long length, boolean withinBounds) {\n+        String expectedMessage = withinBounds\n+                                 ? null\n+                                 : Preconditions.outOfBoundsExceptionFormatter(IndexOutOfBoundsException::new).\n+                apply(\"checkIndex\", List.of(index, length)).getMessage();\n+\n+        BiConsumer<Class<? extends RuntimeException>, LongSupplier> checker = (ec, s) -> {\n+            try {\n+                long rIndex = s.getAsLong();\n+                if (!withinBounds)\n+                    fail(String.format(\n+                            \"Index %d is out of bounds of [0, %d), but was reported to be within bounds\", index, length));\n+                assertEquals(rIndex, index);\n+            }\n+            catch (RuntimeException e) {\n+                assertTrue(ec.isInstance(e));\n+                if (withinBounds)\n+                    fail(String.format(\n+                            \"Index %d is within bounds of [0, %d), but was reported to be out of bounds\", index, length));\n+                else\n+                    assertEquals(e.getMessage(), expectedMessage);\n+            }\n+        };\n+\n+        checker.accept(AssertingOutOfBoundsException.class,\n+                     () -> Preconditions.checkIndex(index, length,\n+                                                    assertingOutOfBounds(expectedMessage, \"checkIndex\", index, length)));\n+        checker.accept(IndexOutOfBoundsException.class,\n+                     () -> Preconditions.checkIndex(index, length,\n+                                                    assertingOutOfBoundsReturnNull(\"checkIndex\", index, length)));\n+        checker.accept(IndexOutOfBoundsException.class,\n+                     () -> Preconditions.checkIndex(index, length, null));\n+        checker.accept(IndexOutOfBoundsException.class,\n+                     () -> Objects.checkIndex(index, length));\n+        checker.accept(ArrayIndexOutOfBoundsException.class,\n+                     () -> Preconditions.checkIndex(index, length,\n+                                                    Preconditions.outOfBoundsExceptionFormatter(ArrayIndexOutOfBoundsException::new)));\n+        checker.accept(StringIndexOutOfBoundsException.class,\n+                     () -> Preconditions.checkIndex(index, length,\n+                                                    Preconditions.outOfBoundsExceptionFormatter(StringIndexOutOfBoundsException::new)));\n+    }\n+\n+\n+    @DataProvider\n+    static Object[][] checkFromToIndexProvider() {\n+        List<Object[]> l = new ArrayList<>();\n+        for (long fromIndex : VALUES) {\n+            for (long toIndex : VALUES) {\n+                for (long length : VALUES) {\n+                    boolean withinBounds = fromIndex >= 0 &&\n+                                           toIndex >= 0 &&\n+                                           length >= 0 &&\n+                                           fromIndex <= toIndex &&\n+                                           toIndex <= length;\n+                    l.add(new Object[]{fromIndex, toIndex, length, withinBounds});\n+                }\n+            }\n+        }\n+        return l.toArray(Object[][]::new);\n+    }\n+\n+    @Test(dataProvider = \"checkFromToIndexProvider\")\n+    public void testCheckFromToIndex(long fromIndex, long toIndex, long length, boolean withinBounds) {\n+        String expectedMessage = withinBounds\n+                                 ? null\n+                                 : Preconditions.outOfBoundsExceptionFormatter(IndexOutOfBoundsException::new).\n+                apply(\"checkFromToIndex\", List.of(fromIndex, toIndex, length)).getMessage();\n+\n+        BiConsumer<Class<? extends RuntimeException>, LongSupplier> check = (ec, s) -> {\n+            try {\n+                long rIndex = s.getAsLong();\n+                if (!withinBounds)\n+                    fail(String.format(\n+                            \"Range [%d, %d) is out of bounds of [0, %d), but was reported to be withing bounds\", fromIndex, toIndex, length));\n+                assertEquals(rIndex, fromIndex);\n+            }\n+            catch (RuntimeException e) {\n+                assertTrue(ec.isInstance(e));\n+                if (withinBounds)\n+                    fail(String.format(\n+                            \"Range [%d, %d) is within bounds of [0, %d), but was reported to be out of bounds\", fromIndex, toIndex, length));\n+                else\n+                    assertEquals(e.getMessage(), expectedMessage);\n+            }\n+        };\n+\n+        check.accept(AssertingOutOfBoundsException.class,\n+                     () -> Preconditions.checkFromToIndex(fromIndex, toIndex, length,\n+                                                          assertingOutOfBounds(expectedMessage, \"checkFromToIndex\", fromIndex, toIndex, length)));\n+        check.accept(IndexOutOfBoundsException.class,\n+                     () -> Preconditions.checkFromToIndex(fromIndex, toIndex, length,\n+                                                          assertingOutOfBoundsReturnNull(\"checkFromToIndex\", fromIndex, toIndex, length)));\n+        check.accept(IndexOutOfBoundsException.class,\n+                     () -> Preconditions.checkFromToIndex(fromIndex, toIndex, length, null));\n+        check.accept(IndexOutOfBoundsException.class,\n+                     () -> Objects.checkFromToIndex(fromIndex, toIndex, length));\n+        check.accept(ArrayIndexOutOfBoundsException.class,\n+                     () -> Preconditions.checkFromToIndex(fromIndex, toIndex, length,\n+                                                          Preconditions.outOfBoundsExceptionFormatter(ArrayIndexOutOfBoundsException::new)));\n+        check.accept(StringIndexOutOfBoundsException.class,\n+                     () -> Preconditions.checkFromToIndex(fromIndex, toIndex, length,\n+                                                          Preconditions.outOfBoundsExceptionFormatter(StringIndexOutOfBoundsException::new)));\n+    }\n+\n+\n+    @DataProvider\n+    static Object[][] checkFromIndexSizeProvider() {\n+        List<Object[]> l = new ArrayList<>();\n+        for (long fromIndex : VALUES) {\n+            for (long size : VALUES) {\n+                for (long length : VALUES) {\n+                    long toIndex = fromIndex + size;\n+\n+                    boolean withinBounds = fromIndex >= 0L &&\n+                                           size >= 0L &&\n+                                           length >= 0L &&\n+                                           fromIndex <= toIndex && \/\/ overflow\n+                                           toIndex <= length;\n+                    l.add(new Object[]{fromIndex, size, length, withinBounds});\n+                }\n+            }\n+        }\n+        return l.toArray(Object[][]::new);\n+    }\n+\n+    @Test(dataProvider = \"checkFromIndexSizeProvider\")\n+    public void testCheckFromIndexSize(long fromIndex, long size, long length, boolean withinBounds) {\n+        String expectedMessage = withinBounds\n+                                 ? null\n+                                 : Preconditions.outOfBoundsExceptionFormatter(IndexOutOfBoundsException::new).\n+                apply(\"checkFromIndexSize\", List.of(fromIndex, size, length)).getMessage();\n+\n+        BiConsumer<Class<? extends RuntimeException>, LongSupplier> check = (ec, s) -> {\n+            try {\n+                long rIndex = s.getAsLong();\n+                if (!withinBounds)\n+                    fail(String.format(\n+                            \"Range [%d, %d + %d) is out of bounds of [0, %d), but was reported to be withing bounds\", fromIndex, fromIndex, size, length));\n+                assertEquals(rIndex, fromIndex);\n+            }\n+            catch (RuntimeException e) {\n+                assertTrue(ec.isInstance(e));\n+                if (withinBounds)\n+                    fail(String.format(\n+                            \"Range [%d, %d + %d) is within bounds of [0, %d), but was reported to be out of bounds\", fromIndex, fromIndex, size, length));\n+                else\n+                    assertEquals(e.getMessage(), expectedMessage);\n+            }\n+        };\n+\n+        check.accept(AssertingOutOfBoundsException.class,\n+                     () -> Preconditions.checkFromIndexSize(fromIndex, size, length,\n+                                                            assertingOutOfBounds(expectedMessage, \"checkFromIndexSize\", fromIndex, size, length)));\n+        check.accept(IndexOutOfBoundsException.class,\n+                     () -> Preconditions.checkFromIndexSize(fromIndex, size, length,\n+                                                            assertingOutOfBoundsReturnNull(\"checkFromIndexSize\", fromIndex, size, length)));\n+        check.accept(IndexOutOfBoundsException.class,\n+                     () -> Preconditions.checkFromIndexSize(fromIndex, size, length, null));\n+        check.accept(IndexOutOfBoundsException.class,\n+                     () -> Objects.checkFromIndexSize(fromIndex, size, length));\n+        check.accept(ArrayIndexOutOfBoundsException.class,\n+                     () -> Preconditions.checkFromIndexSize(fromIndex, size, length,\n+                                                            Preconditions.outOfBoundsExceptionFormatter(ArrayIndexOutOfBoundsException::new)));\n+        check.accept(StringIndexOutOfBoundsException.class,\n+                     () -> Preconditions.checkFromIndexSize(fromIndex, size, length,\n+                                                            Preconditions.outOfBoundsExceptionFormatter(StringIndexOutOfBoundsException::new)));\n+    }\n+\n+    @Test\n+    public void uniqueMessagesForCheckKinds() {\n+        BiFunction<String, List<Number>, IndexOutOfBoundsException> f =\n+                Preconditions.outOfBoundsExceptionFormatter(IndexOutOfBoundsException::new);\n+\n+        List<String> messages = new ArrayList<>();\n+        \/\/ Exact arguments\n+        messages.add(f.apply(\"checkIndex\", List.of(-1L, 0L)).getMessage());\n+        messages.add(f.apply(\"checkFromToIndex\", List.of(-1L, 0L, 0L)).getMessage());\n+        messages.add(f.apply(\"checkFromIndexSize\", List.of(-1L, 0L, 0L)).getMessage());\n+        \/\/ Unknown check kind\n+        messages.add(f.apply(\"checkUnknown\", List.of(-1L, 0L, 0L)).getMessage());\n+        \/\/ Known check kind with more arguments\n+        messages.add(f.apply(\"checkIndex\", List.of(-1L, 0L, 0L)).getMessage());\n+        messages.add(f.apply(\"checkFromToIndex\", List.of(-1L, 0L, 0L, 0L)).getMessage());\n+        messages.add(f.apply(\"checkFromIndexSize\", List.of(-1L, 0L, 0L, 0L)).getMessage());\n+        \/\/ Known check kind with fewer arguments\n+        messages.add(f.apply(\"checkIndex\", List.of(-1L)).getMessage());\n+        messages.add(f.apply(\"checkFromToIndex\", List.of(-1L, 0L)).getMessage());\n+        messages.add(f.apply(\"checkFromIndexSize\", List.of(-1L, 0L)).getMessage());\n+        \/\/ Null arguments\n+        messages.add(f.apply(null, null).getMessage());\n+        messages.add(f.apply(\"checkNullArguments\", null).getMessage());\n+        messages.add(f.apply(null, List.of(-1L)).getMessage());\n+\n+        assertEquals(messages.size(), messages.stream().distinct().count());\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Objects\/CheckLongIndex.java","additions":287,"deletions":0,"binary":false,"changes":287,"status":"added"}]}