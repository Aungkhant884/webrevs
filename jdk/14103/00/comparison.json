{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,0 +101,1 @@\n+    private long lastFlush;\n@@ -257,1 +258,1 @@\n-                    if (CheckpointType.FLUSH.is(parseCheckpointType())) {\n+                    if ((parseFlushCheckpoint())) {\n@@ -272,2 +273,2 @@\n-    private byte parseCheckpointType() throws IOException {\n-        input.readLong(); \/\/ timestamp\n+    private boolean parseFlushCheckpoint() throws IOException {\n+        long timestamp = input.readLong();\n@@ -276,1 +277,5 @@\n-        return input.readByte();\n+        if (CheckpointType.FLUSH.is(input.readByte())) {\n+            lastFlush = timeConverter.convertTimestamp(timestamp);\n+            return true;\n+        }\n+        return false;\n@@ -485,0 +490,4 @@\n+    public long getLastFlush() {\n+        return lastFlush;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ChunkParser.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,3 +169,1 @@\n-                    long endNanos = currentParser.getStartNanos() + currentParser.getChunkDuration();\n-                    \/\/ same conversion as in RecordingInfo\n-                    if (endNanos > filterEnd) {\n+                    if (currentParser.getLastFlush() > filterEnd) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}