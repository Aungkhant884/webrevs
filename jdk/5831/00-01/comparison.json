{"files":[{"patch":"@@ -47,0 +47,5 @@\n+    \/**\n+     * Max sum of iov_len fields over all iovec structures that writev supports\n+     *\/\n+    static final int IOV_MAX_LEN_SUM = Integer.MAX_VALUE;\n+\n@@ -176,2 +181,2 @@\n-            int i = offset;\n-            while (i < count && iov_len < IOV_MAX) {\n+            int iovLenSum = 0;\n+            for (int i = offset; i < count && iov_len < IOV_MAX; i++) {\n@@ -191,0 +196,6 @@\n+                    if (iovLenSum <= IOV_MAX_LEN_SUM - rem) {\n+                        iovLenSum += rem;\n+                    } else {\n+                        rem = IOV_MAX_LEN_SUM - iovLenSum;\n+                        iovLenSum = IOV_MAX_LEN_SUM;\n+                    }\n@@ -200,1 +211,3 @@\n-                        shadow.put(buf);\n+                        int shadowPos = shadow.position();\n+                        shadow.put(shadowPos, buf, pos, rem);\n+                        shadow.position(shadowPos + rem);\n@@ -211,0 +224,3 @@\n+\n+                    if (iovLenSum == IOV_MAX_LEN_SUM)\n+                        break;\n@@ -212,1 +228,0 @@\n-                i++;\n@@ -221,1 +236,1 @@\n-            for (int j=0; j<iov_len; j++) {\n+            for (int j = 0; j < iov_len; j++) {\n@@ -245,1 +260,1 @@\n-                for (int j=0; j<iov_len; j++) {\n+                for (int j = 0; j < iov_len; j++) {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOUtil.java","additions":21,"deletions":6,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include <limits.h>\n@@ -138,40 +137,1 @@\n-    ssize_t result = writev(fd, iov, len);\n-#ifdef MACOSX\n-    if (result < 0 && errno == EINVAL) {\n-        \/\/\n-        \/\/ Calculate sum of iov_len values\n-        \/\/\n-        size_t total_len = 0;\n-        for (int i = 0; i < len; i++)\n-            total_len += iov[i].iov_len;\n-\n-        \/\/\n-        \/\/ [EINVAL] The sum of the iov_len values in the iov array\n-        \/\/          overflows a 32-bit integer.\n-        \/\/\n-        size_t overflow = total_len - INT_MAX;\n-        if (overflow > 0) {\n-            do {\n-                int index = len - 1;\n-                if (iov[index].iov_len <= overflow) {\n-                    \/\/\n-                    \/\/ Clear size of and remove the last iovec element\n-                    \/\/\n-                    overflow -= iov[index].iov_len;\n-                    iov[index].iov_len = 0;\n-                    len--;\n-                } else {\n-                    \/\/\n-                    \/\/ Adjust the last iovec element\n-                    \/\/\n-                    iov[index].iov_len -= overflow;\n-                    overflow = 0; \/\/ loop will exit\n-                }\n-            } while (overflow > 0);\n-\n-            \/\/ Retry the gathering write\n-            result = writev(fd, iov, len);\n-        }\n-    }\n-#endif\n-    return convertLongReturnVal(env, result, JNI_FALSE);\n+    return convertLongReturnVal(env, writev(fd, iov, len), JNI_FALSE);\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileDispatcherImpl.c","additions":1,"deletions":41,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -28,1 +28,4 @@\n- * @run main\/othervm -Xmx8G LargeGatheringWrite\n+ * @library ..\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @run main\/othervm -Xmx4G LargeGatheringWrite\n@@ -39,0 +42,2 @@\n+import jdk.test.lib.RandomFactory;\n+\n@@ -46,1 +51,1 @@\n-    private static final Random RND = new Random(System.nanoTime());\n+    private static final Random RND = RandomFactory.getRandom();\n@@ -96,1 +101,1 @@\n-                    buf.clear();\n+                    buf.rewind();\n@@ -106,1 +111,1 @@\n-                    dst.clear();\n+                    dst.rewind();\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/LargeGatheringWrite.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"}]}