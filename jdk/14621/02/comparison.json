{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+include Utils.gmk\n@@ -42,1 +43,1 @@\n-ALL_MODULES := $(call FindAllModules)\n+ALL_MODULES := $(call FindAllModules) $(EXTRA_MODULES)\n@@ -57,1 +58,4 @@\n-JMODS := $(wildcard $(IMAGES_OUTPUTDIR)\/jmods\/*.jmod)\n+JMODS_DIRS := $(EXTRA_JMODS_DIR) $(IMAGES_OUTPUTDIR)\/jmods\n+\n+JDK_JMODS := $(foreach m, $(JDK_MODULES), $(firstword $(wildcard $(addsuffix \/$m.jmod, $(JMODS_DIRS)))))\n+JRE_JMODS := $(foreach m, $(JRE_MODULES), $(firstword $(wildcard $(addsuffix \/$m.jmod, $(JMODS_DIRS)))))\n@@ -74,1 +78,1 @@\n-    --module-path $(IMAGES_OUTPUTDIR)\/jmods \\\n+    --module-path $(call PathList, $(JMODS_DIRS)) \\\n@@ -90,0 +94,3 @@\n+JDK_IMAGE_SUPPORT_DIR := $(SUPPORT_OUTPUTDIR)\/images\/jdk\n+JRE_IMAGE_SUPPORT_DIR := $(SUPPORT_OUTPUTDIR)\/images\/jre\n+\n@@ -92,2 +99,2 @@\n-    DEPS := $(JMODS) $(BASE_RELEASE_FILE) \\\n-        $(call DependOnVariable, JDK_MODULES_LIST), \\\n+    DEPS := $(JDK_JMODS) $(BASE_RELEASE_FILE) \\\n+        $(call DependOnVariable, JDK_MODULES_LIST, $(JDK_IMAGE_SUPPORT_DIR)\/_jlink_jdk.vardeps), \\\n@@ -95,1 +102,1 @@\n-    SUPPORT_DIR := $(SUPPORT_OUTPUTDIR)\/images\/jdk, \\\n+    SUPPORT_DIR := $(JDK_IMAGE_SUPPORT_DIR), \\\n@@ -106,2 +113,2 @@\n-    DEPS := $(JMODS) $(BASE_RELEASE_FILE) \\\n-        $(call DependOnVariable, JDK_MODULES_LIST), \\\n+    DEPS := $(JRE_JMODS) $(BASE_RELEASE_FILE) \\\n+        $(call DependOnVariable, JRE_MODULES_LIST, $(JRE_IMAGE_SUPPORT_DIR)\/_jlink_jre.vardeps), \\\n@@ -109,1 +116,1 @@\n-    SUPPORT_DIR := $(SUPPORT_OUTPUTDIR)\/images\/jre, \\\n+    SUPPORT_DIR := $(JRE_IMAGE_SUPPORT_DIR), \\\n@@ -145,1 +152,1 @@\n-      SUPPORT_DIR := $$(SUPPORT_OUTPUTDIR)\/images\/jdk, \\\n+      SUPPORT_DIR := $$(JDK_IMAGE_SUPPORT_DIR), \\\n@@ -158,1 +165,1 @@\n-      SUPPORT_DIR := $$(SUPPORT_OUTPUTDIR)\/images\/jre, \\\n+      SUPPORT_DIR := $$(JRE_IMAGE_SUPPORT_DIR), \\\n","filename":"make\/Images.gmk","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -974,1 +974,2 @@\n-    java.base-jmod: jrtfs-jar $(filter-out java.base-jmod, $(JMOD_TARGETS))\n+    java.base-jmod: jrtfs-jar $(filter-out java.base-jmod \\\n+        $(addsuffix -jmod, $(call FindAllUpgradeableModules)), $(JMOD_TARGETS))\n","filename":"make\/Main.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-    constexpr int raw_encoding() const { return this - first(); }\n+    constexpr int raw_encoding() const { return checked_cast<int>(this - first()); }\n@@ -178,1 +178,1 @@\n-    constexpr int raw_encoding() const { return this - first(); }\n+    constexpr int raw_encoding() const { return checked_cast<int>(this - first()); }\n@@ -311,1 +311,1 @@\n-    int raw_encoding() const  { return this - first(); }\n+    int raw_encoding() const  { return checked_cast<int>(this - first()); }\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-    constexpr int raw_encoding() const { return this - first(); }\n+    constexpr int raw_encoding() const { return checked_cast<int>(this - first()); }\n@@ -190,1 +190,1 @@\n-    constexpr int raw_encoding() const { return this - first(); }\n+    constexpr int raw_encoding() const { return checked_cast<int>(this - first()); }\n@@ -300,1 +300,1 @@\n-    constexpr int raw_encoding() const { return this - first(); }\n+    constexpr int raw_encoding() const { return checked_cast<int>(this - first()); }\n","filename":"src\/hotspot\/cpu\/riscv\/register_riscv.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1925,1 +1925,1 @@\n-  emit_int8((int8_t)0xF2);\n+  emit_int8((uint8_t)0xF2);\n@@ -2525,1 +2525,1 @@\n-  emit_data(disp, rspec, call32_operand);\n+  emit_data(checked_cast<int32_t>(disp), rspec, call32_operand);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-      _disp (disp + (index.constant_or_zero() * scale_size(scale))),\n+      _disp (disp + checked_cast<int>(index.constant_or_zero() * scale_size(scale))),\n@@ -279,1 +279,1 @@\n-    a._disp += disp.constant_or_zero() * scale_size(scale);\n+    a._disp += checked_cast<int>(disp.constant_or_zero() * scale_size(scale));\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2024,4 +2024,4 @@\n-  emit_int8((int8_t)0x0f);\n-  emit_int8((int8_t)0x1f);\n-  emit_int8((int8_t)0x84);\n-  emit_int8((int8_t)0x00);\n+  emit_int8((uint8_t)0x0f);\n+  emit_int8((uint8_t)0x1f);\n+  emit_int8((uint8_t)0x84);\n+  emit_int8((uint8_t)0x00);\n@@ -2036,5 +2036,5 @@\n-    emit_int8((int8_t)0x26); \/\/ es:\n-    emit_int8((int8_t)0x2e); \/\/ cs:\n-    emit_int8((int8_t)0x64); \/\/ fs:\n-    emit_int8((int8_t)0x65); \/\/ gs:\n-    emit_int8((int8_t)0x90);\n+    emit_int8((uint8_t)0x26); \/\/ es:\n+    emit_int8((uint8_t)0x2e); \/\/ cs:\n+    emit_int8((uint8_t)0x64); \/\/ fs:\n+    emit_int8((uint8_t)0x65); \/\/ gs:\n+    emit_int8((uint8_t)0x90);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-      int imm8 = target - (address) &disp[1];\n+      int imm8 = checked_cast<int>(target - (address) &disp[1]);\n@@ -123,1 +123,1 @@\n-      *disp = imm8;\n+      *disp = (char)imm8;\n@@ -126,1 +126,1 @@\n-      int imm32 = target - (address) &disp[1];\n+      int imm32 = checked_cast<int>(target - (address) &disp[1]);\n@@ -752,1 +752,1 @@\n-    if (src.is_constant()) addptr(dst, src.as_constant());\n+    if (src.is_constant()) addptr(dst, checked_cast<int>(src.as_constant()));\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-    constexpr int   raw_encoding() const { return this - first(); }\n+    constexpr int   raw_encoding() const { return checked_cast<int>(this - first()); }\n@@ -142,1 +142,1 @@\n-    int   raw_encoding() const { return this - first(); }\n+    int   raw_encoding() const { return checked_cast<int>(this - first()); }\n@@ -205,1 +205,1 @@\n-    constexpr int raw_encoding() const { return this - first(); }\n+    constexpr int raw_encoding() const { return checked_cast<int>(this - first()); }\n@@ -316,1 +316,1 @@\n-    int   raw_encoding() const { return this - first(); }\n+    int   raw_encoding() const { return checked_cast<int>(this - first()); }\n","filename":"src\/hotspot\/cpu\/x86\/register_x86.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3140,2 +3140,2 @@\n-intx VM_Version::L1_line_size() {\n-  intx result = 0;\n+uint VM_Version::L1_line_size() {\n+  uint result = 0;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -636,1 +636,1 @@\n-  static intx L1_line_size();\n+  static uint L1_line_size();\n@@ -638,1 +638,1 @@\n-  static intx prefetch_data_size()  {\n+  static uint prefetch_data_size()  {\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-  int pad = -(intptr_t)end & (required_align-1);\n+  int pad = checked_cast<int>(-(intptr_t)end & (required_align-1));\n","filename":"src\/hotspot\/share\/asm\/assembler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -255,1 +255,1 @@\n-      _assm->register_skipped(_assm->pc() - _start);\n+      _assm->register_skipped(checked_cast<int>(_assm->pc() - _start));\n","filename":"src\/hotspot\/share\/asm\/assembler.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-VMReg VMRegImpl::stack0 = (VMReg)VMRegImpl::stack_0()->value();\n+VMReg VMRegImpl::stack0 = (VMReg)(intptr_t)VMRegImpl::stack_0()->value();\n@@ -45,1 +45,1 @@\n-    assert(VMRegImpl::regName[value()], \"VMRegImpl::regName[\" INTPTR_FORMAT \"] returns nullptr\", value());\n+    assert(VMRegImpl::regName[value()], \"VMRegImpl::regName[%d] returns nullptr\", value());\n","filename":"src\/hotspot\/share\/code\/vmreg.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-  intptr_t value() const { return this - first(); }\n+  int value() const { return checked_cast<int>(this - first()); }\n@@ -146,1 +146,1 @@\n-  uintptr_t reg2stack() const {\n+  int reg2stack() const {\n@@ -148,1 +148,1 @@\n-    return this - stack_0();\n+    return checked_cast<int>(this - stack_0());\n","filename":"src\/hotspot\/share\/code\/vmreg.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-        tty->print_cr(\"[%c][%d] -> reg (\" INTPTR_FORMAT \")\", omv.type() == OopMapValue::narrowoop_value ? 'n' : 'o', i, omv.reg()->value());\n+        tty->print_cr(\"[%c][%d] -> reg (%d)\", omv.type() == OopMapValue::narrowoop_value ? 'n' : 'o', i, omv.reg()->value());\n@@ -286,1 +286,1 @@\n-        tty->print_cr(\"[%c][%d] -> stack (\"  INTPTR_FORMAT \")\", omv.type() == OopMapValue::narrowoop_value ? 'n' : 'o', i, omv.reg()->reg2stack() * VMRegImpl::stack_slot_size);\n+        tty->print_cr(\"[%c][%d] -> stack (%d)\", omv.type() == OopMapValue::narrowoop_value ? 'n' : 'o', i, omv.reg()->reg2stack() * VMRegImpl::stack_slot_size);\n@@ -290,1 +290,1 @@\n-        tty->print_cr(\"[d][%d] -> reg (\" INTPTR_FORMAT \") stack (\" INTPTR_FORMAT \")\", i, omv.content_reg()->value(), omv.reg()->reg2stack() * VMRegImpl::stack_slot_size);\n+        tty->print_cr(\"[d][%d] -> reg (%d) stack (%d)\", i, omv.content_reg()->value(), omv.reg()->reg2stack() * VMRegImpl::stack_slot_size);\n@@ -292,1 +292,1 @@\n-        tty->print_cr(\"[d][%d] -> stack (\" INTPTR_FORMAT \") reg (\" INTPTR_FORMAT \")\", i, omv.content_reg()->reg2stack() * VMRegImpl::stack_slot_size, omv.reg()->value());\n+        tty->print_cr(\"[d][%d] -> stack (%d) reg (%d)\", i, omv.content_reg()->reg2stack() * VMRegImpl::stack_slot_size, omv.reg()->value());\n","filename":"src\/hotspot\/share\/compiler\/oopMap.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,3 +57,3 @@\n-  short _value;\n-  int value() const                                 { return _value; }\n-  void set_value(int value)                         { _value = value; }\n+  unsigned short _value;\n+  unsigned short value() const                      { return _value; }\n+  void set_value(unsigned short value)              { _value = value; }\n@@ -91,2 +91,2 @@\n-    void set_reg_type(VMReg p, oop_types t) {\n-    set_value((p->value() << register_shift) | t);\n+  void set_reg_type(VMReg p, oop_types t) {\n+    set_value(checked_cast<unsigned short>((p->value() << register_shift) | t));\n@@ -106,1 +106,1 @@\n-    _content_reg = r->value();\n+    _content_reg = checked_cast<short>(r->value());\n@@ -114,1 +114,1 @@\n-      stream->write_int(content_reg()->value());\n+      stream->write_int(checked_cast<int>(content_reg()->value()));\n@@ -119,1 +119,1 @@\n-    set_value(stream->read_int());\n+    set_value(checked_cast<unsigned short>(stream->read_int()));\n@@ -131,1 +131,1 @@\n-  VMReg reg() const { return VMRegImpl::as_VMReg(mask_bits(value(), register_mask_in_place) >> register_shift); }\n+  VMReg reg() const { return VMRegImpl::as_VMReg(checked_cast<int>(mask_bits(value(), register_mask_in_place) >> register_shift)); }\n","filename":"src\/hotspot\/share\/compiler\/oopMap.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-        tty->print_cr(\"missing saved register: reg: \" INTPTR_FORMAT \" %s loc: %p\", reg->value(), reg->name(), loc);\n+        tty->print_cr(\"missing saved register: reg: %d %s loc: %p\", reg->value(), reg->name(), loc);\n","filename":"src\/hotspot\/share\/compiler\/oopMap.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -483,1 +483,1 @@\n-      set_bci_displacement(row, mdp - dp());\n+      set_bci_displacement(row, checked_cast<int>(mdp - dp()));\n@@ -990,1 +990,1 @@\n-  int tag = DataLayout::no_tag;\n+  u1 tag = DataLayout::no_tag;\n@@ -1101,1 +1101,1 @@\n-    data_layout->initialize(tag, stream->bci(), cell_count);\n+    data_layout->initialize(tag, checked_cast<u2>(stream->bci()), cell_count);\n@@ -1313,2 +1313,2 @@\n-  _invoke_mask = right_n_bits(CompilerConfig::scaled_freq_log(Tier0InvokeNotifyFreqLog, scale)) << InvocationCounter::count_shift;\n-  _backedge_mask = right_n_bits(CompilerConfig::scaled_freq_log(Tier0BackedgeNotifyFreqLog, scale)) << InvocationCounter::count_shift;\n+  _invoke_mask = (int)right_n_bits(CompilerConfig::scaled_freq_log(Tier0InvokeNotifyFreqLog, scale)) << InvocationCounter::count_shift;\n+  _backedge_mask = (int)right_n_bits(CompilerConfig::scaled_freq_log(Tier0BackedgeNotifyFreqLog, scale)) << InvocationCounter::count_shift;\n@@ -1482,1 +1482,1 @@\n-    temp.initialize(tag, bci, 0);\n+    temp.initialize(tag, checked_cast<u2>(bci), 0);\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-  enum {\n+  enum : u1 {\n@@ -207,1 +207,1 @@\n-    _header._struct._flags |= (0x1 << flag_number);\n+    _header._struct._flags |= (u1)(0x1 << flag_number);\n@@ -236,1 +236,1 @@\n-  static u8 flag_mask_to_header_mask(uint byte_constant) {\n+  static u8 flag_mask_to_header_mask(u1 byte_constant) {\n@@ -347,1 +347,1 @@\n-  void set_flag_at(int flag_number) {\n+  void set_flag_at(u1 flag_number) {\n@@ -350,1 +350,1 @@\n-  bool flag_at(int flag_number) const {\n+  bool flag_at(u1 flag_number) const {\n@@ -358,1 +358,1 @@\n-  static int flag_number_to_constant(int flag_number) {\n+  static u1 flag_number_to_constant(u1 flag_number) {\n@@ -490,1 +490,1 @@\n-  enum {\n+  enum : u1 {\n@@ -528,1 +528,1 @@\n-  static int null_seen_byte_constant() {\n+  static u1 null_seen_byte_constant() {\n@@ -1129,1 +1129,1 @@\n-    return TypeProfileWidth;\n+    return (uint) TypeProfileWidth;\n@@ -1433,1 +1433,1 @@\n-    return BciProfileWidth;\n+    return (uint) BciProfileWidth;\n@@ -2013,1 +2013,1 @@\n-        _trap_hist._array[reason] = cnt1;\n+        _trap_hist._array[reason] = (u1)cnt1;\n@@ -2265,1 +2265,1 @@\n-  void set_num_loops(int n)                   { _num_loops = n;     }\n+  void set_num_loops(short n)                 { _num_loops = n;     }\n@@ -2267,1 +2267,1 @@\n-  void set_num_blocks(int n)                  { _num_blocks = n;    }\n+  void set_num_blocks(short n)                { _num_blocks = n;    }\n@@ -2329,1 +2329,1 @@\n-    return dp - ((address)_data);\n+    return (int)(dp - ((address)_data));\n@@ -2369,1 +2369,1 @@\n-  int extra_data_size() const          { return (address)extra_data_limit() - (address)extra_data_base(); }\n+  int extra_data_size() const          { return (int)((address)extra_data_limit() - (address)extra_data_base()); }\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1015,1 +1015,1 @@\n-      assert(loc != nullptr, \"missing register map entry reg: \" INTPTR_FORMAT \" %s loc: \" INTPTR_FORMAT, reg->value(), reg->name(), p2i(loc));\n+      assert(loc != nullptr, \"missing register map entry reg: %d %s loc: \" INTPTR_FORMAT, reg->value(), reg->name(), p2i(loc));\n@@ -1444,1 +1444,1 @@\n-          assert(((int)fst->reg2stack()) >= 0, \"reg2stack: \" INTPTR_FORMAT, fst->reg2stack());\n+          assert(((int)fst->reg2stack()) >= 0, \"reg2stack: %d\", fst->reg2stack());\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -517,1 +517,1 @@\n-    return a->location - b->location;\n+    return checked_cast<int>(a->location - b->location);\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1113,1 +1113,1 @@\n-  product(intx, TypeProfileArgsLimit,     2,                                \\\n+  product(int, TypeProfileArgsLimit,     2,                                 \\\n@@ -1117,1 +1117,1 @@\n-  product(intx, TypeProfileParmsLimit,    2,                                \\\n+  product(int, TypeProfileParmsLimit,    2,                                 \\\n@@ -1380,1 +1380,1 @@\n-  product(intx, SpecTrapLimitExtraEntries,  3, EXPERIMENTAL,                \\\n+  product(int, SpecTrapLimitExtraEntries,  3, EXPERIMENTAL,                 \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1998,1 +1998,1 @@\n-    assert(a->value() == b->value(), \"register allocation mismatch: a=\" INTX_FORMAT \", b=\" INTX_FORMAT, a->value(), b->value());\n+    assert(a->value() == b->value(), \"register allocation mismatch: a= %d, b= %d\", a->value(), b->value());\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -520,1 +520,1 @@\n-T2 checked_cast(T1 thing) {\n+constexpr T2 checked_cast(T1 thing) {\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -366,1 +366,3 @@\n-            JNU_CHECK_EXCEPTION(env);\n+            if ((*env)->ExceptionCheck(env)) {\n+                goto errOut;\n+            }\n@@ -508,1 +510,3 @@\n-            JNU_CHECK_EXCEPTION(env);\n+            if ((*env)->ExceptionCheck(env)) {\n+                goto errOut;\n+            }\n","filename":"src\/java.base\/macosx\/native\/libosxsecurity\/KeystoreImpl.m","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -72,0 +72,2 @@\n+ *\n+ * @since 19\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,0 +121,2 @@\n+ *\n+ * @since 19\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -150,0 +150,2 @@\n+ *\n+ * @since 19\n@@ -151,0 +153,1 @@\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -153,0 +156,1 @@\n+import jdk.internal.javac.PreviewFeature;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -628,4 +628,7 @@\n-     * Wait for all threads in this task scope to finish or the task scope to shut down.\n-     * This method waits until all threads started in this task scope finish execution,\n-     * the {@link #shutdown() shutdown} method is invoked to shut down the task scope,\n-     * or the current thread is {@linkplain Thread#interrupt() interrupted}.\n+     * Wait for all subtasks started in this task scope to finish or the task scope to\n+     * shut down.\n+     *\n+     * <p> This method waits for all subtasks by waiting for all threads {@linkplain\n+     * #fork(Callable) started} in this task scope to finish execution. It stops waiting\n+     * when all threads finish, the task scope is {@linkplain #shutdown() shut down}, or\n+     * the current thread is {@linkplain Thread#interrupt() interrupted}.\n@@ -655,5 +658,8 @@\n-     * Wait for all threads in this task scope to finish or the task scope to shut down,\n-     * up to the given deadline. This method waits until all threads started in the task\n-     * scope finish execution, the {@link #shutdown() shutdown} method is invoked to\n-     * shut down the task scope, the current thread is {@linkplain Thread#interrupt()\n-     * interrupted}, or the deadline is reached.\n+     * Wait for all subtasks started in this task scope to finish or the task scope to\n+     * shut down, up to the given deadline.\n+     *\n+     * <p> This method waits for all subtasks by waiting for all threads {@linkplain\n+     * #fork(Callable) started} in this task scope to finish execution. It stops waiting\n+     * when all threads finish, the task scope is {@linkplain #shutdown() shut down}, the\n+     * deadline is reached, or the current thread is {@linkplain Thread#interrupt()\n+     * interrupted}.\n@@ -953,1 +959,1 @@\n-            return Objects.toIdentityString(this ) + stateAsString;\n+            return Objects.toIdentityString(this) + stateAsString;\n@@ -960,1 +966,1 @@\n-     * invokes the {@linkplain #shutdown() shutdown} method to interrupt unfinished threads\n+     * {@linkplain #shutdown() shuts down} the task scope to interrupt unfinished threads\n@@ -968,0 +974,4 @@\n+     * @apiNote This class implements a policy to shut down the task scope when a subtask\n+     * completes successfully. There shouldn't be any need to directly shut down the task\n+     * scope with the {@link #shutdown() shutdown} method.\n+     *\n@@ -1020,2 +1030,0 @@\n-            super.handleComplete(subtask);\n-\n@@ -1041,2 +1049,12 @@\n-         * {@inheritDoc}\n-         * @return this task scope\n+         * Wait for a subtask started in this task scope to complete {@linkplain\n+         * Subtask.State#SUCCESS successfully} or all subtasks to complete.\n+         *\n+         * <p> This method waits for all subtasks by waiting for all threads {@linkplain\n+         * #fork(Callable) started} in this task scope to finish execution. It stops waiting\n+         * when all threads finish, a subtask completes successfully, or the current\n+         * thread is {@linkplain Thread#interrupt() interrupted}. It also stops waiting\n+         * if the {@link #shutdown() shutdown} method is invoked directly to shut down\n+         * this task scope.\n+         *\n+         * <p> This method may only be invoked by the task scope owner.\n+         *\n@@ -1053,2 +1071,13 @@\n-         * {@inheritDoc}\n-         * @return this task scope\n+         * Wait for a subtask started in this task scope to complete {@linkplain\n+         * Subtask.State#SUCCESS successfully} or all subtasks to complete, up to the\n+         * given deadline.\n+         *\n+         * <p> This method waits for all subtasks by waiting for all threads {@linkplain\n+         * #fork(Callable) started} in this task scope to finish execution. It stops waiting\n+         * when all threads finish, a subtask completes successfully, the deadline is\n+         * reached, or the current thread is {@linkplain Thread#interrupt() interrupted}.\n+         * It also stops waiting if the {@link #shutdown() shutdown} method is invoked\n+         * directly to shut down this task scope.\n+         *\n+         * <p> This method may only be invoked by the task scope owner.\n+         *\n@@ -1076,2 +1105,2 @@\n-         * @throws IllegalStateException if the handleComplete method was not invoked with\n-         * a completed subtask, or the task scope owner did not join after forking\n+         * @throws IllegalStateException if no subtasks completed or the task scope owner\n+         * did not join after forking\n@@ -1098,2 +1127,2 @@\n-         * @throws IllegalStateException if the handleComplete method was not invoked with\n-         * a completed subtask, or the task scope owner did not join after forking\n+         * @throws IllegalStateException if no subtasks completed or the task scope owner\n+         * did not join after forking\n@@ -1128,2 +1157,2 @@\n-     * {@linkplain Subtask.State#FAILED fail}. Once captured, it invokes the {@linkplain\n-     * #shutdown() shutdown} method to interrupt unfinished threads and wakeup the task\n+     * {@linkplain Subtask.State#FAILED fail}. Once captured, it {@linkplain #shutdown()\n+     * shuts down} the task scope to interrupt unfinished threads and wakeup the task\n@@ -1137,0 +1166,4 @@\n+     * @apiNote This class implements a policy to shut down the task scope when a subtask\n+     * fails. There shouldn't be any need to directly shut down the task scope with the\n+     * {@link #shutdown() shutdown} method.\n+     *\n@@ -1184,1 +1217,0 @@\n-            super.handleComplete(subtask);\n@@ -1193,2 +1225,11 @@\n-         * {@inheritDoc}\n-         * @return this task scope\n+         * Wait for all subtasks started in this task scope to complete or for a subtask\n+         * to {@linkplain Subtask.State#FAILED fail}.\n+         *\n+         * <p> This method waits for all subtasks by waiting for all threads {@linkplain\n+         * #fork(Callable) started} in this task scope to finish execution. It stops waiting\n+         * when all threads finish, a subtask fails, or the current thread is {@linkplain\n+         * Thread#interrupt() interrupted}. It also stops waiting if the {@link #shutdown()\n+         * shutdown} method is invoked directly to shut down this task scope.\n+         *\n+         * <p> This method may only be invoked by the task scope owner.\n+         *\n@@ -1205,2 +1246,12 @@\n-         * {@inheritDoc}\n-         * @return this task scope\n+         * Wait for all subtasks started in this task scope to complete or for a subtask\n+         * to {@linkplain Subtask.State#FAILED fail}, up to the given deadline.\n+         *\n+         * <p> This method waits for all subtasks by waiting for all threads {@linkplain\n+         * #fork(Callable) started} in this task scope to finish execution. It stops waiting\n+         * when all threads finish, a subtask fails, the deadline is reached, or the current\n+         * thread is {@linkplain Thread#interrupt() interrupted}. It also stops waiting\n+         * if the {@link #shutdown() shutdown} method is invoked directly to shut down\n+         * this task scope.\n+         *\n+         * <p> This method may only be invoked by the task scope owner.\n+         *\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScope.java","additions":79,"deletions":28,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+ *\n+ * @since 1.5\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/Main.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+ *\n+ * @since 1.5\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/package-info.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+    stackMapData               = type.getAddressField(\"_stackmap_data\");\n@@ -111,0 +112,1 @@\n+  private static AddressField stackMapData; \/\/ Raw stackmap data for the method (#entries + entries)\n@@ -139,0 +141,9 @@\n+  public boolean hasStackMapTable() {\n+    return stackMapData.getValue(getAddress()) != null;\n+  }\n+\n+  public U1Array getStackMapData() {\n+    Address addr = stackMapData.getValue(getAddress());\n+    return VMObjectFactory.newObject(U1Array.class, addr);\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ConstMethod.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import sun.jvm.hotspot.utilities.U1Array;\n@@ -121,0 +122,6 @@\n+  public boolean      hasStackMapTable()              {\n+    return getConstMethod().hasStackMapTable();\n+  }\n+  public U1Array      getStackMapData()               {\n+    return getConstMethod().getStackMapData();\n+  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Method.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+    protected short  _stackMapTableIndex;\n@@ -171,0 +172,5 @@\n+        Short stackMapTableIndex = utf8ToIndex.get(\"StackMapTable\");\n+        _stackMapTableIndex = (stackMapTableIndex != null) ?\n+                              stackMapTableIndex.shortValue() : 0;\n+        if (DEBUG) debugMessage(\"StackMapTable index = \" + _stackMapTableIndex);\n+\n@@ -518,0 +524,21 @@\n+            boolean hasStackMapTable = m.hasStackMapTable();\n+            U1Array stackMapData = null;\n+            int stackMapAttrLen = 0;\n+\n+            if (hasStackMapTable) {\n+                if (DEBUG) debugMessage(\"\\tmethod has stack map table\");\n+                stackMapData = m.getStackMapData();\n+                if (DEBUG) debugMessage(\"\\t\\tstack map table length = \" + stackMapData.length());\n+\n+                stackMapAttrLen = stackMapData.length();\n+\n+                codeSize += 2 \/* stack map table attr index *\/ +\n+                            4 \/* stack map table attr length *\/ +\n+                            stackMapAttrLen;\n+\n+                if (DEBUG) debugMessage(\"\\t\\tstack map table attr size = \" +\n+                                        stackMapAttrLen);\n+\n+                codeAttrCount++;\n+            }\n+\n@@ -604,0 +631,11 @@\n+            \/\/ write StackMapTable, if available\n+            if (hasStackMapTable) {\n+                writeIndex(_stackMapTableIndex);\n+                dos.writeInt(stackMapAttrLen);\n+                \/\/ We write bytes directly as stackMapData is\n+                \/\/ raw data (#entries + entries)\n+                for (int i = 0; i < stackMapData.length(); i++) {\n+                    dos.writeByte(stackMapData.at(i));\n+                }\n+            }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/jcore\/ClassWriter.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+ *\n+ * @since 9\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/doclet\/StandardDoclet.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -421,1 +421,1 @@\n-                className = decodeDescriptors(className, arraySize > 0 ? Long.toString(arraySize) : \"\").getFirst();\n+                className = ValueFormatter.decodeDescriptors(className, arraySize > 0 ? Long.toString(arraySize) : \"\").getFirst();\n@@ -466,1 +466,1 @@\n-        for (String qualifiedName : decodeDescriptors(parameter, \"\")) {\n+        for (String qualifiedName : ValueFormatter.decodeDescriptors(parameter, \"\")) {\n@@ -487,1 +487,1 @@\n-            className = decodeDescriptors(className, \"\").getFirst();\n+            className = ValueFormatter.decodeDescriptors(className, \"\").getFirst();\n@@ -492,49 +492,0 @@\n-    List<String> decodeDescriptors(String descriptor, String arraySize) {\n-        List<String> descriptors = new ArrayList<>();\n-        for (int index = 0; index < descriptor.length(); index++) {\n-            String arrayBrackets = \"\";\n-            while (descriptor.charAt(index) == '[') {\n-                arrayBrackets = arrayBrackets +  \"[\" + arraySize + \"]\" ;\n-                arraySize = \"\";\n-                index++;\n-            }\n-            char c = descriptor.charAt(index);\n-            String type;\n-            switch (c) {\n-            case 'L':\n-                int endIndex = descriptor.indexOf(';', index);\n-                type = descriptor.substring(index + 1, endIndex);\n-                index = endIndex;\n-                break;\n-            case 'I':\n-                type = \"int\";\n-                break;\n-            case 'J':\n-                type = \"long\";\n-                break;\n-            case 'Z':\n-                type = \"boolean\";\n-                break;\n-            case 'D':\n-                type = \"double\";\n-                break;\n-            case 'F':\n-                type = \"float\";\n-                break;\n-            case 'S':\n-                type = \"short\";\n-                break;\n-            case 'C':\n-                type = \"char\";\n-                break;\n-            case 'B':\n-                type = \"byte\";\n-                break;\n-            default:\n-                type = \"<unknown-descriptor-type>\";\n-            }\n-            descriptors.add(type + arrayBrackets);\n-        }\n-        return descriptors;\n-    }\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/PrettyWriter.java","additions":3,"deletions":52,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-    private static List<String> decodeDescriptors(String descriptor, String arraySize) {\n+    public static List<String> decodeDescriptors(String descriptor, String arraySize) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/ValueFormatter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -738,2 +738,2 @@\n-       <setting name=\"enabled\">false<\/setting>\n-       <setting name=\"stackTrace\">true<\/setting>\n+      <setting name=\"enabled\">false<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n@@ -748,2 +748,2 @@\n-       <setting name=\"enabled\">false<\/setting>\n-       <setting name=\"stackTrace\">true<\/setting>\n+      <setting name=\"enabled\">false<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n@@ -753,2 +753,2 @@\n-       <setting name=\"enabled\">false<\/setting>\n-       <setting name=\"stackTrace\">true<\/setting>\n+      <setting name=\"enabled\">false<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n@@ -763,2 +763,2 @@\n-       <setting name=\"enabled\">false<\/setting>\n-       <setting name=\"stackTrace\">true<\/setting>\n+      <setting name=\"enabled\">false<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n@@ -768,2 +768,2 @@\n-       <setting name=\"enabled\">false<\/setting>\n-       <setting name=\"stackTrace\">true<\/setting>\n+      <setting name=\"enabled\">false<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n@@ -921,2 +921,0 @@\n-\n-\n@@ -932,1 +930,1 @@\n-     <selection name=\"gc\" default=\"normal\" label=\"Garbage Collector\">\n+      <selection name=\"gc\" default=\"normal\" label=\"Garbage Collector\">\n@@ -977,1 +975,1 @@\n-\t <not>\n+        <not>\n@@ -1125,1 +1123,0 @@\n-\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -738,2 +738,2 @@\n-       <setting name=\"enabled\">false<\/setting>\n-       <setting name=\"stackTrace\">true<\/setting>\n+      <setting name=\"enabled\">false<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n@@ -748,2 +748,2 @@\n-       <setting name=\"enabled\">false<\/setting>\n-       <setting name=\"stackTrace\">true<\/setting>\n+      <setting name=\"enabled\">false<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n@@ -753,2 +753,2 @@\n-       <setting name=\"enabled\">false<\/setting>\n-       <setting name=\"stackTrace\">true<\/setting>\n+      <setting name=\"enabled\">false<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n@@ -763,2 +763,2 @@\n-       <setting name=\"enabled\">false<\/setting>\n-       <setting name=\"stackTrace\">true<\/setting>\n+      <setting name=\"enabled\">false<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n@@ -768,2 +768,2 @@\n-       <setting name=\"enabled\">false<\/setting>\n-       <setting name=\"stackTrace\">true<\/setting>\n+      <setting name=\"enabled\">false<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n@@ -930,1 +930,1 @@\n-        <selection name=\"gc\" default=\"detailed\" label=\"Garbage Collector\">\n+      <selection name=\"gc\" default=\"detailed\" label=\"Garbage Collector\">\n@@ -948,1 +948,1 @@\n-       <or>\n+        <or>\n@@ -952,1 +952,1 @@\n-       <\/or>\n+        <\/or>\n@@ -970,1 +970,1 @@\n-\t    <option label=\"High\" name=\"high\">1000\/s<\/option>\n+        <option label=\"High\" name=\"high\">1000\/s<\/option>\n@@ -1123,1 +1123,0 @@\n-\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -59,4 +59,0 @@\n-####\n-## assert in src\/hotspot\/share\/oops\/instanceStackChunkKlass.cpp:1042\n-vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage006\/TestDescription.java 8300709 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList-Virtual.txt","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,0 +78,2 @@\n+            \/\/ Let javap print additional info, e.g., StackMapTable\n+            launcher.addToolArg(\"-verbose\");\n@@ -89,0 +91,4 @@\n+            \/\/ StackMapTable might not be generated for a class\n+            \/\/ containing only methods with sequential control flows.\n+            \/\/ But the class used here (LingeredApp) is not such a case.\n+            out.shouldContain(\"StackMapTable:\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbDumpclass.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+java\/lang\/ScopedValue\/StressStackOverflow.java#default 8309646 linux-all\n+\n","filename":"test\/jdk\/ProblemList-Virtual.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary Test standard charset name constants.\n+ * @summary Test standard charset name constants and class qualities.\n@@ -29,1 +29,1 @@\n- * @run main Standard\n+ * @run junit Standard\n@@ -34,2 +34,2 @@\n-import java.io.*;\n-import java.nio.charset.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n@@ -37,2 +37,10 @@\n-import java.util.HashSet;\n-import java.util.Set;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -42,4 +50,5 @@\n-    private final static String standardCharsets[] = {\n-        \"US-ASCII\", \"ISO-8859-1\", \"UTF-8\",\n-        \"UTF-16BE\", \"UTF-16LE\", \"UTF-16\",\n-        \"UTF-32BE\", \"UTF-32LE\", \"UTF-32\",\n+    \/\/ These are the charsets StandardCharsets.java is expected to contain.\n+    private final static String[] expectedCharsets = {\n+            \"US-ASCII\", \"ISO-8859-1\", \"UTF-8\",\n+            \"UTF-16BE\", \"UTF-16LE\", \"UTF-16\",\n+            \"UTF-32BE\", \"UTF-32LE\", \"UTF-32\"\n@@ -48,10 +57,10 @@\n-    public static void realMain(String[] args) {\n-        check(StandardCharsets.US_ASCII instanceof Charset);\n-        check(StandardCharsets.ISO_8859_1 instanceof Charset);\n-        check(StandardCharsets.UTF_8 instanceof Charset);\n-        check(StandardCharsets.UTF_16BE instanceof Charset);\n-        check(StandardCharsets.UTF_16LE instanceof Charset);\n-        check(StandardCharsets.UTF_16 instanceof Charset);\n-        check(StandardCharsets.UTF_32BE instanceof Charset);\n-        check(StandardCharsets.UTF_32LE instanceof Charset);\n-        check(StandardCharsets.UTF_32 instanceof Charset);\n+    \/**\n+     * Validates that the Charset constants from the data provider\n+     * are of type Charset.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"charsetProvider\")\n+    public void typeTest(Charset charset) {\n+        \/\/ Doubly checked, as it is validated when passed as a param\n+        assertTrue(charset instanceof Charset);\n+    }\n@@ -59,9 +68,9 @@\n-        check(\"US-ASCII\".equals(StandardCharsets.US_ASCII.name()));\n-        check(\"ISO-8859-1\".equals(StandardCharsets.ISO_8859_1.name()));\n-        check(\"UTF-8\".equals(StandardCharsets.UTF_8.name()));\n-        check(\"UTF-16BE\".equals(StandardCharsets.UTF_16BE.name()));\n-        check(\"UTF-16LE\".equals(StandardCharsets.UTF_16LE.name()));\n-        check(\"UTF-16\".equals(StandardCharsets.UTF_16.name()));\n-        check(\"UTF-32BE\".equals(StandardCharsets.UTF_32BE.name()));\n-        check(\"UTF-32LE\".equals(StandardCharsets.UTF_32LE.name()));\n-        check(\"UTF-32\".equals(StandardCharsets.UTF_32.name()));\n+    \/**\n+     * Validates that calling .name() on a Charset constant is equal\n+     * to the matching String value from the data provider.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"charsetProvider\")\n+    public void nameMethodTest(Charset charset, String charString) {\n+        assertEquals(charset.name(), charString);\n+    }\n@@ -69,9 +78,9 @@\n-        check(Charset.forName(\"US-ASCII\") == StandardCharsets.US_ASCII);\n-        check(Charset.forName(\"ISO-8859-1\") == StandardCharsets.ISO_8859_1);\n-        check(Charset.forName(\"UTF-8\") == StandardCharsets.UTF_8);\n-        check(Charset.forName(\"UTF-16BE\") == StandardCharsets.UTF_16BE);\n-        check(Charset.forName(\"UTF-16LE\") == StandardCharsets.UTF_16LE);\n-        check(Charset.forName(\"UTF-16\") == StandardCharsets.UTF_16);\n-        check(Charset.forName(\"UTF-32BE\") == StandardCharsets.UTF_32BE);\n-        check(Charset.forName(\"UTF-32LE\") == StandardCharsets.UTF_32LE);\n-        check(Charset.forName(\"UTF-32\") == StandardCharsets.UTF_32);\n+    \/**\n+     * Validates that calling Charset.forName() on a String is equal\n+     * to the matching Charset constant from the data provider.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"charsetProvider\")\n+    public void forNameMethodTest(Charset charset, String charString) {\n+        assertEquals(Charset.forName(charString), charset);\n+    }\n@@ -79,2 +88,17 @@\n-        Set<String> charsets = new HashSet<>();\n-        Field standardCharsetFields[] = StandardCharsets.class.getFields();\n+    \/**\n+     * Validates the qualities of a StandardCharsets field are as expected:\n+     * The field is final, static, public, and one can access\n+     * the underlying value of the field.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"charsetFields\")\n+    public void charsetModifiersTest(Field charsetField) throws IllegalAccessException {\n+        \/\/ Check modifiers\n+        assertEquals(StandardCharsets.class, charsetField.getDeclaringClass());\n+        assertTrue(Modifier.isFinal(charsetField.getModifiers()));\n+        assertTrue(Modifier.isStatic(charsetField.getModifiers()));\n+        assertTrue(Modifier.isPublic(charsetField.getModifiers()));\n+        \/\/ Check that the value can be accessed, and it is a Charset\n+        Object valueOfField = charsetField.get(null);\n+        assertTrue(valueOfField instanceof Charset);\n+    }\n@@ -82,6 +106,10 @@\n-        for(Field charsetField : standardCharsetFields) {\n-            check(StandardCharsets.class == charsetField.getDeclaringClass());\n-            check(Modifier.isFinal(charsetField.getModifiers()));\n-            check(Modifier.isStatic(charsetField.getModifiers()));\n-            check(Modifier.isPublic(charsetField.getModifiers()));\n-            Object value;\n+    \/**\n+     * Validates that the Charsets contained in StandardCharsets are equal\n+     * to the expected Charsets list defined in the test. This test should fail if\n+     * either the actual or expected (standard) Charsets are modified, and\n+     * the others are not.\n+     *\/\n+    @Test\n+    public void correctCharsetsTest() {\n+        \/\/ Grab the value from each Standard Charset field\n+        List<String> actualCharsets = Arrays.stream(StandardCharsets.class.getFields()).map(field -> {\n@@ -89,4 +117,3 @@\n-                value = charsetField.get(null);\n-            } catch(IllegalAccessException failure) {\n-                unexpected(failure);\n-                continue;\n+                return ((Charset) field.get(null)).name();\n+            } catch (IllegalAccessException e) {\n+                throw new RuntimeException(\"Can not test correctCharsetsTest() due to %s\", e);\n@@ -94,7 +121,2 @@\n-            check(value instanceof Charset);\n-            charsets.add(((Charset)value).name());\n-        }\n-\n-        check(charsets.containsAll(Arrays.asList(standardCharsets)));\n-        charsets.removeAll(Arrays.asList(standardCharsets));\n-        check(charsets.isEmpty());\n+        }).toList();\n+        assertEquals(actualCharsets, Arrays.asList(expectedCharsets));\n@@ -103,16 +125,16 @@\n-    \/\/--------------------- Infrastructure ---------------------------\n-    static volatile int passed = 0, failed = 0;\n-    static void pass() { passed++; }\n-    static void fail() { failed++; Thread.dumpStack(); }\n-    static void fail(String msg) { System.out.println(msg); fail(); }\n-    static void unexpected(Throwable t) { failed++; t.printStackTrace(); }\n-    static void check(boolean cond) { if (cond) pass(); else fail(); }\n-    static void equal(Object x, Object y) {\n-        if (x == null ? y == null : x.equals(y)) pass();\n-        else {System.out.println(x + \" not equal to \" + y); fail();}}\n-    static void equal2(Object x, Object y) {equal(x, y); equal(y, x);}\n-    public static void main(String[] args) throws Throwable {\n-        try { realMain(args); } catch (Throwable t) { unexpected(t); }\n-\n-        System.out.printf(\"%nPassed = %d, failed = %d%n%n\", passed, failed);\n-        if (failed > 0) throw new Exception(\"Some tests failed\");\n+    \/**\n+     * Provides the constant Charset and associated String value of\n+     * the standard charsets.\n+     *\/\n+    private static Stream<Arguments> charsetProvider() {\n+        return Stream.of(\n+                Arguments.of(StandardCharsets.US_ASCII, \"US-ASCII\"),\n+                Arguments.of(StandardCharsets.ISO_8859_1, \"ISO-8859-1\"),\n+                Arguments.of(StandardCharsets.UTF_8, \"UTF-8\"),\n+                Arguments.of(StandardCharsets.UTF_16BE, \"UTF-16BE\"),\n+                Arguments.of(StandardCharsets.UTF_16LE, \"UTF-16LE\"),\n+                Arguments.of(StandardCharsets.UTF_16, \"UTF-16\"),\n+                Arguments.of(StandardCharsets.UTF_32BE, \"UTF-32BE\"),\n+                Arguments.of(StandardCharsets.UTF_32LE, \"UTF-32LE\"),\n+                Arguments.of(StandardCharsets.UTF_32, \"UTF-32\")\n+        );\n@@ -120,14 +142,0 @@\n-    static byte[] serializedForm(Object obj) {\n-        try {\n-            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-            new ObjectOutputStream(baos).writeObject(obj);\n-            return baos.toByteArray();\n-        } catch (IOException e) { throw new Error(e); }}\n-    static Object readObject(byte[] bytes)\n-        throws IOException, ClassNotFoundException {\n-        InputStream is = new ByteArrayInputStream(bytes);\n-        return new ObjectInputStream(is).readObject();}\n-    @SuppressWarnings(\"unchecked\")\n-    static <T> T serialClone(T obj) {\n-        try { return (T) readObject(serializedForm(obj)); }\n-        catch (Exception e) { throw new Error(e); }}\n@@ -135,0 +143,3 @@\n+    private static Stream<Field> charsetFields() {\n+        return Arrays.stream(StandardCharsets.class.getFields());\n+    }\n","filename":"test\/jdk\/java\/nio\/charset\/StandardCharsets\/Standard.java","additions":98,"deletions":87,"binary":false,"changes":185,"status":"modified"}]}