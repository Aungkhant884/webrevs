{"files":[{"patch":"@@ -1708,1 +1708,1 @@\n-  Node *min_opaq = new OpaqueZeroTripGuardNode(C, limit);\n+  Node *min_opaq = new OpaqueZeroTripGuardNode(C, limit, b_test);\n@@ -1997,1 +1997,1 @@\n-  Node *zer_opaq = new OpaqueZeroTripGuardNode(C, incr);\n+  Node *zer_opaq = new OpaqueZeroTripGuardNode(C, incr, main_end->test_trip());\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1686,0 +1686,7 @@\n+    if (use->Opcode() == Op_OpaqueZeroTripGuard) {\n+      assert(use->outcnt() <= 1, \"OpaqueZeroTripGuard can't be shared\");\n+      if (use->outcnt() == 1) {\n+        Node* cmp = use->unique_out();\n+        _worklist.push(cmp);\n+      }\n+    }\n@@ -1904,0 +1911,1 @@\n+  push_opaque_zero_trip_guard(worklist, use);\n@@ -2024,0 +2032,6 @@\n+void PhaseCCP::push_opaque_zero_trip_guard(Unique_Node_List& worklist, const Node* use) const {\n+  if (use->Opcode() == Op_OpaqueZeroTripGuard) {\n+    push_if_not_bottom_type(worklist, use->unique_out());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -599,0 +599,1 @@\n+  void push_opaque_zero_trip_guard(Unique_Node_List& worklist, const Node* use) const;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"opto\/opaquenode.hpp\"\n@@ -664,0 +665,41 @@\n+const Type* CmpINode::Value(PhaseGVN* phase) const {\n+  Node* in1 = in(1);\n+  Node* in2 = in(2);\n+  \/\/ If this test is the zero trip guard for a main or post loop, check whether, with the opaque node removed, the test\n+  \/\/ would constant fold so the loop is never entered. If so return the type of the test without the opaque node removed:\n+  \/\/ make the loop unreachable.\n+  \/\/ The reason for this is that the iv phi captures the bounds of the loop and if the loop becomes unreachable, it can\n+  \/\/ become top. In that case, the loop must be removed.\n+  \/\/ This is safe because:\n+  \/\/ - as optimizations proceed, the range of iterations executed by the main loop narrows. If no iterations remain, then\n+  \/\/ we're done with optimizations for that loop.\n+  \/\/ - the post loop is initially not reachable but as long as there's a main loop, the zero trip guard for the post\n+  \/\/ loop takes a phi that merges the pre and main loop's iv and can't constant fold the zero trip guard. Once, the main\n+  \/\/ loop is removed, there's no need to preserve the zero trip guard for the post loop anymore.\n+  if (in1 != NULL && in2 != NULL) {\n+    uint input = 0;\n+    Node* cmp = NULL;\n+    BoolTest::mask test;\n+    if (in1->Opcode() == Op_OpaqueZeroTripGuard && phase->type(in1) != Type::TOP) {\n+      cmp = new CmpINode(in1->in(1), in2);\n+      test = ((OpaqueZeroTripGuardNode*)in1)->_loop_entered_mask;\n+    }\n+    if (in2->Opcode() == Op_OpaqueZeroTripGuard && phase->type(in2) != Type::TOP) {\n+      assert(cmp == NULL, \"A cmp with 2 OpaqueZeroTripGuard inputs\");\n+      cmp = new CmpINode(in1, in2->in(1));\n+      test = ((OpaqueZeroTripGuardNode*)in2)->_loop_entered_mask;\n+    }\n+    if (cmp != NULL) {\n+      const Type* cmp_t = cmp->Value(phase);\n+      const Type* t = BoolTest(test).cc2logical(cmp_t);\n+      cmp->destruct(phase);\n+      if (t == TypeInt::ZERO) {\n+        return cmp_t;\n+      }\n+    }\n+  }\n+\n+  return SubNode::Value(phase);\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -662,2 +662,0 @@\n-javax\/swing\/text\/DefaultCaret\/HidingSelection\/HidingSelectionTest.java 8194048 windows-all\n-javax\/swing\/text\/DefaultCaret\/HidingSelection\/MultiSelectionTest.java 8213562 linux-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -129,0 +129,1 @@\n+    jdk\/internal\/util \\\n","filename":"test\/jdk\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}