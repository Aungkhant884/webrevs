{"files":[{"patch":"@@ -3590,4 +3590,0 @@\n-  \/\/ Minimum size must be empty loop\n-  if (_body.size() > EMPTY_LOOP_SIZE) {\n-    return false;\n-  }\n@@ -3597,0 +3593,3 @@\n+  if (!empty_loop_candidate(phase)) {\n+    return false;\n+  }\n@@ -3598,2 +3597,5 @@\n-  if (!cl->is_valid_counted_loop(T_INT)) {\n-    return false;   \/\/ Malformed loop\n+#ifdef ASSERT\n+  \/\/ Call collect_loop_core_nodes to exercise the assert that checks that it finds the right number of nodes\n+  if (empty_loop_with_extra_nodes_candidate(phase)) {\n+    Unique_Node_List wq;\n+    collect_loop_core_nodes(phase, wq);\n@@ -3601,2 +3603,8 @@\n-  if (!phase->is_member(this, phase->get_ctrl(cl->loopexit()->in(CountedLoopEndNode::TestValue)))) {\n-    return false;   \/\/ Infinite loop\n+#endif\n+  \/\/ Minimum size must be empty loop\n+  if (_body.size() > EMPTY_LOOP_SIZE) {\n+    \/\/ This loop has more nodes than an empty loop but, maybe they are only kept alive by the outer strip mined loop's\n+    \/\/ safepoint. If they go away once the safepoint is removed, that loop is empty.\n+    if (!empty_loop_with_data_nodes(phase)) {\n+      return false;\n+    }\n@@ -3700,0 +3708,131 @@\n+bool IdealLoopTree::empty_loop_candidate(PhaseIdealLoop* phase) const {\n+  CountedLoopNode *cl = _head->as_CountedLoop();\n+  if (!cl->is_valid_counted_loop(T_INT)) {\n+    return false;   \/\/ Malformed loop\n+  }\n+  if (!phase->is_member(this, phase->get_ctrl(cl->loopexit()->in(CountedLoopEndNode::TestValue)))) {\n+    return false;   \/\/ Infinite loop\n+  }\n+  return true;\n+}\n+\n+bool IdealLoopTree::empty_loop_with_data_nodes(PhaseIdealLoop* phase) const {\n+  CountedLoopNode* cl = _head->as_CountedLoop();\n+  if (!cl->is_strip_mined() || !empty_loop_with_extra_nodes_candidate(phase)) {\n+    return false;\n+  }\n+  Unique_Node_List empty_loop_nodes;\n+  Unique_Node_List wq;\n+\n+  \/\/ Start from all data nodes in the loop body that are not one of the EMPTY_LOOP_SIZE nodes expected in an empty body\n+  enqueue_data_nodes(phase, empty_loop_nodes, wq);\n+  \/\/ and now follow uses\n+  for (uint i = 0; i < wq.size(); ++i) {\n+    Node* n = wq.at(i);\n+    for (DUIterator_Fast jmax, j = n->fast_outs(jmax); j < jmax; j++) {\n+      Node* u = n->fast_out(j);\n+      if (u->Opcode() == Op_SafePoint) {\n+        \/\/ found a safepoint. Maybe this loop's safepoint or another loop safepoint.\n+        if (!process_safepoint(phase, empty_loop_nodes, wq, u)) {\n+          return false;\n+        }\n+      } else {\n+        const Type* u_t = phase->_igvn.type(u);\n+        if (u_t == Type::CONTROL || u_t == Type::MEMORY || u_t == Type::ABIO) {\n+          \/\/ found a side effect\n+          return false;\n+        }\n+        wq.push(u);\n+      }\n+    }\n+  }\n+  \/\/ Nodes (ignoring the EMPTY_LOOP_SIZE nodes of the \"core\" of the loop) are kept alive by otherwise empty loops'\n+  \/\/ safepoints: kill them.\n+  for (uint i = 0; i < wq.size(); ++i) {\n+    Node* n = wq.at(i);\n+    phase->_igvn.replace_node(n, phase->C->top());\n+  }\n+\n+#ifdef ASSERT\n+  for (uint i = 0; i < _body.size(); ++i) {\n+    Node* n = _body.at(i);\n+    assert(wq.member(n) || empty_loop_nodes.member(n), \"missed a node in the body?\");\n+  }\n+#endif\n+\n+  return true;\n+}\n+\n+bool IdealLoopTree::process_safepoint(PhaseIdealLoop* phase, Unique_Node_List& empty_loop_nodes, Unique_Node_List& wq,\n+                                      Node* sfpt) const {\n+  CountedLoopNode* cl = _head->as_CountedLoop();\n+  if (cl->outer_safepoint() == sfpt) {\n+    \/\/ the current loop's safepoint\n+    return true;\n+  }\n+\n+  \/\/ Some other loop's safepoint. Maybe that loop is empty too.\n+  IdealLoopTree* sfpt_loop = phase->get_loop(sfpt);\n+  if (!sfpt_loop->_head->is_OuterStripMinedLoop()) {\n+    return false;\n+  }\n+  IdealLoopTree* sfpt_inner_loop = sfpt_loop->_child;\n+  CountedLoopNode* sfpt_cl = sfpt_inner_loop->_head->as_CountedLoop();\n+  assert(sfpt_cl->is_strip_mined(), \"inconsistent\");\n+\n+  if (empty_loop_nodes.member(sfpt_cl)) {\n+    \/\/ already taken care of\n+    return true;\n+  }\n+\n+  if (!sfpt_inner_loop->empty_loop_candidate(phase) || !sfpt_inner_loop->empty_loop_with_extra_nodes_candidate(phase)) {\n+    return false;\n+  }\n+\n+  \/\/ Enqueue the nodes of that loop for processing too\n+  sfpt_inner_loop->enqueue_data_nodes(phase, empty_loop_nodes, wq);\n+  return true;\n+}\n+\n+bool IdealLoopTree::empty_loop_with_extra_nodes_candidate(PhaseIdealLoop* phase) const {\n+  CountedLoopNode *cl = _head->as_CountedLoop();\n+  \/\/ No other control flow node in the loop body\n+  if (cl->loopexit()->in(0) != cl) {\n+    return false;\n+  }\n+\n+  if (phase->is_member(this, phase->get_ctrl(cl->limit()))) {\n+    return false;\n+  }\n+  return true;\n+}\n+\n+void IdealLoopTree::enqueue_data_nodes(PhaseIdealLoop* phase, Unique_Node_List& empty_loop_nodes,\n+                                       Unique_Node_List& wq) const {\n+  collect_loop_core_nodes(phase, empty_loop_nodes);\n+  for (uint i = 0; i < _body.size(); ++i) {\n+    Node* n = _body.at(i);\n+    if (!empty_loop_nodes.member(n)) {\n+      wq.push(n);\n+    }\n+  }\n+}\n+\n+\/\/ This collects the node that would be left if this body was empty\n+void IdealLoopTree::collect_loop_core_nodes(PhaseIdealLoop* phase, Unique_Node_List& wq) const {\n+  uint before = wq.size();\n+  wq.push(_head->in(LoopNode::LoopBackControl));\n+  for (uint i = 0; i < wq.size(); ++i) {\n+    Node* n = wq.at(i);\n+    for (uint j = 0; j < n->req(); ++j) {\n+      Node* in = n->in(j);\n+      if (in != NULL) {\n+        if (phase->get_loop(phase->ctrl_or_self(in)) == this) {\n+          wq.push(in);\n+        }\n+      }\n+    }\n+  }\n+  assert(wq.size() - before == EMPTY_LOOP_SIZE, \"expect the EMPTY_LOOP_SIZE nodes of this body if empty\");\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":147,"deletions":8,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -1251,0 +1251,5 @@\n+  \/\/ Allow Bool -> Cmp idealisation in late inlining intrinsics that return a bool\n+  if (n->is_Cmp()) {\n+    add_users_to_worklist(n);\n+  }\n+\n@@ -1787,0 +1792,1 @@\n+  DEBUG_ONLY(Unique_Node_List worklist_verify;)\n@@ -1795,0 +1801,1 @@\n+    DEBUG_ONLY(worklist_verify.push(n);)\n@@ -1808,0 +1815,1 @@\n+  DEBUG_ONLY(verify_analyze(worklist_verify);)\n@@ -1810,0 +1818,45 @@\n+#ifdef ASSERT\n+\/\/ For every node n on verify list, check if type(n) == n->Value()\n+\/\/ We have a list of exceptions, see comments in code.\n+void PhaseCCP::verify_analyze(Unique_Node_List& worklist_verify) {\n+  bool failure = false;\n+  while (worklist_verify.size()) {\n+    Node* n = worklist_verify.pop();\n+    const Type* told = type(n);\n+    const Type* tnew = n->Value(this);\n+    if (told != tnew) {\n+      \/\/ Check special cases that are ok\n+      if (told->isa_integer(tnew->basic_type()) != nullptr) { \/\/ both either int or long\n+        const TypeInteger* t0 = told->is_integer(tnew->basic_type());\n+        const TypeInteger* t1 = tnew->is_integer(tnew->basic_type());\n+        if (t0->lo_as_long() == t1->lo_as_long() &&\n+            t0->hi_as_long() == t1->hi_as_long()) {\n+          continue; \/\/ ignore integer widen\n+        }\n+      }\n+      if (n->is_Load()) {\n+        \/\/ MemNode::can_see_stored_value looks up through many memory nodes,\n+        \/\/ which means we would need to notify modifications from far up in\n+        \/\/ the inputs all the way down to the LoadNode. We don't do that.\n+        continue;\n+      }\n+      tty->cr();\n+      tty->print_cr(\"Missed optimization (PhaseCCP):\");\n+      n->dump_bfs(1, 0, \"\");\n+      tty->print_cr(\"Current type:\");\n+      told->dump_on(tty);\n+      tty->cr();\n+      tty->print_cr(\"Optimized type:\");\n+      tnew->dump_on(tty);\n+      tty->cr();\n+      failure = true;\n+    }\n+  }\n+  \/\/ If we get this assert, check why the reported nodes were not processed again in CCP.\n+  \/\/ We should either make sure that these nodes are properly added back to the CCP worklist\n+  \/\/ in PhaseCCP::push_child_nodes_to_worklist() to update their type or add an exception\n+  \/\/ in the verification code above if that is not possible for some reason (like Load nodes).\n+  assert(!failure, \"Missed optimization opportunity in PhaseCCP\");\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -607,0 +607,4 @@\n+#ifdef ASSERT\n+  \/\/ For every node n on verify list, check if type(n) == n->Value()\n+  void verify_analyze(Unique_Node_List& worklist_verify);\n+#endif\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1472,1 +1472,4 @@\n-  if( cop == Op_FastLock || cop == Op_FastUnlock || cmp->is_SubTypeCheck()) return NULL;\n+  if( cop == Op_FastLock || cop == Op_FastUnlock ||\n+      cmp->is_SubTypeCheck() || cop == Op_VectorTest ) {\n+    return NULL;\n+  }\n@@ -1504,0 +1507,15 @@\n+  \/\/ Change \"bool eq\/ne (cmp (cmove (bool tst (cmp2)) 1 0) 0)\" into \"bool tst\/~tst (cmp2)\"\n+  if (cop == Op_CmpI &&\n+      (_test._test == BoolTest::eq || _test._test == BoolTest::ne) &&\n+      cmp1_op == Op_CMoveI && cmp2->find_int_con(1) == 0) {\n+    \/\/ 0 should be on the true branch\n+    if (cmp1->in(CMoveNode::Condition)->is_Bool() &&\n+        cmp1->in(CMoveNode::IfTrue)->find_int_con(1) == 0 &&\n+        cmp1->in(CMoveNode::IfFalse)->find_int_con(0) != 0) {\n+      BoolNode* target = cmp1->in(CMoveNode::Condition)->as_Bool();\n+      return new BoolNode(target->in(1),\n+                          (_test._test == BoolTest::eq) ? target->_test._test :\n+                                                          target->_test.negate());\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -421,1 +421,0 @@\n-java\/awt\/Choice\/ChoicePopupLocation\/ChoicePopupLocation.java 8202931 macosx-all,linux-all\n@@ -430,1 +429,0 @@\n-java\/awt\/Toolkit\/DesktopProperties\/rfe4758438.java 8193547 linux-all\n@@ -591,1 +589,6 @@\n-javax\/net\/ssl\/DTLS\/CipherSuite.java                             8202059 macosx-x64\n+javax\/net\/ssl\/SSLEngine\/TestAllSuites.java                      8298874 generic-all\n+javax\/net\/ssl\/SSLEngine\/IllegalRecordVersion.java               8298873 generic-all\n+javax\/net\/ssl\/SSLEngine\/EngineCloseOnAlert.java                 8298868 generic-all\n+javax\/net\/ssl\/SSLEngine\/ConnectionTest.java                     8298869 generic-all\n+javax\/net\/ssl\/SSLEngine\/CheckStatus.java                        8298872 generic-all\n+javax\/net\/ssl\/SSLEngine\/Basics.java                             8298867 generic-all\n@@ -612,1 +615,0 @@\n-sun\/security\/provider\/PolicyParser\/ExtDirsChange.java           8039280 generic-all\n@@ -671,1 +673,1 @@\n-java\/awt\/Mouse\/EnterExitEvents\/DragWindowTest.java 8297296 macosx-all\n+java\/awt\/Mouse\/EnterExitEvents\/DragWindowTest.java 8298823 macosx-all\n","filename":"test\/jdk\/ProblemList.txt","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -627,3 +627,0 @@\n-    sun\/security\/provider\/PolicyParser\/ExtDirs.java \\\n-    sun\/security\/provider\/PolicyParser\/ExtDirsChange.java \\\n-    sun\/security\/provider\/PolicyParser\/ExtDirsDefaultPolicy.java \\\n","filename":"test\/jdk\/TEST.groups","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}