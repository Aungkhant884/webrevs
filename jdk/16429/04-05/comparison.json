{"files":[{"patch":"@@ -83,22 +83,0 @@\n-  \/\/ Visit all non-cast uses of the node, bypassing ConstraintCasts.\n-  \/\/ Pattern: this (-> ConstraintCast)* -> non_cast\n-  \/\/ In other words: find all non_cast nodes such that\n-  \/\/ non_cast->uncast() == this.\n-  template <typename Callback>\n-  static void visit_uncasted_uses(const Node* n, Callback callback) {\n-    ResourceMark rm;\n-    Unique_Node_List internals;\n-    internals.push((Node*)n); \/\/ start traversal\n-    for (uint j = 0; j < internals.size(); ++j) {\n-      Node* internal = internals.at(j); \/\/ for every internal\n-      for (DUIterator_Fast kmax, k = internal->fast_outs(kmax); k < kmax; k++) {\n-        Node* internal_use = internal->fast_out(k);\n-        if (internal_use->is_ConstraintCast()) {\n-          internals.push(internal_use); \/\/ traverse this cast also\n-        } else {\n-          callback(internal_use);\n-        }\n-      }\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -172,0 +172,1 @@\n+class Unique_Node_List;\n@@ -1131,0 +1132,15 @@\n+  \/\/ Visit all non-cast uses of the node and apply callback, bypassing nodes\n+  \/\/ according to bypass. Note: definition appears after complete type\n+  \/\/ definition of Unique_Node_List\n+  template <typename Callback, typename Bypass>\n+  void visit_uses(Callback callback, Bypass bypass);\n+\n+  \/\/ Visit all non-cast uses of the node, bypassing ConstraintCasts.\n+  \/\/ Pattern: this (-> ConstraintCast)* -> non_cast\n+  \/\/ In other words: find all non_cast nodes such that\n+  \/\/ non_cast->uncast() == this.\n+  template <typename Callback>\n+  void visit_uncasted_uses(Callback callback) {\n+     visit_uses(callback, [](Node* n){ return n->is_ConstraintCast(); });\n+  }\n+\n@@ -1715,0 +1731,19 @@\n+\/\/ Definition must appear after complete type definition of Unique_Node_List\n+template <typename Callback, typename Bypass>\n+void Node::visit_uses(Callback callback, Bypass bypass) {\n+  ResourceMark rm;\n+  Unique_Node_List internals;\n+  internals.push(this); \/\/ start traversal\n+  for (uint j = 0; j < internals.size(); ++j) {\n+    Node* internal = internals.at(j); \/\/ for every internal\n+    for (DUIterator_Fast kmax, k = internal->fast_outs(kmax); k < kmax; k++) {\n+      Node* internal_use = internal->fast_out(k);\n+      if (bypass(internal_use)) {\n+        internals.push(internal_use); \/\/ traverse this also\n+      } else {\n+        callback(internal_use);\n+      }\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1608,1 +1608,1 @@\n-      ConstraintCastNode::visit_uncasted_uses(use, push_the_uses_to_worklist);\n+      use->visit_uncasted_uses(push_the_uses_to_worklist);\n@@ -1878,1 +1878,1 @@\n-void PhaseCCP::push_more_uses(Unique_Node_List& worklist, Node* parent, const Node* use) const {\n+void PhaseCCP::push_more_uses(Unique_Node_List& worklist, Node* parent, Node* use) const {\n@@ -1977,2 +1977,2 @@\n-\/\/ Pattern: parent -> LShift (use) -> ConstraintCast* -> ConvI2L -> ConstraintCast* -> And\n-void PhaseCCP::push_and(Unique_Node_List& worklist, const Node* parent, const Node* use) const {\n+\/\/ Pattern: parent -> LShift (use) -> (ConstraintCast | ConvI2L)* -> ConstraintCast* -> And\n+void PhaseCCP::push_and(Unique_Node_List& worklist, const Node* parent, Node* use) const {\n@@ -1988,9 +1988,2 @@\n-    auto push_and_uses_to_worklist_skip_conv = [&](Node* n){\n-      uint opc = n->Opcode();\n-      if (opc == Op_ConvI2L) {\n-        \/\/ Step over a single ConvI2L in search for And. Inverse of the logic\n-        \/\/ in MulNode::AndIL_shift_and_mask_is_always_zero.\n-        ConstraintCastNode::visit_uncasted_uses(n, push_and_uses_to_worklist);\n-      } else {\n-        push_and_uses_to_worklist(n);\n-      }\n+    auto bypass = [](Node* n) {\n+      return n->is_ConstraintCast() || n->Opcode() == Op_ConvI2L;\n@@ -1998,1 +1991,1 @@\n-    ConstraintCastNode::visit_uncasted_uses(use, push_and_uses_to_worklist_skip_conv);\n+    use->visit_uses(push_and_uses_to_worklist, bypass);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":7,"deletions":14,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -618,1 +618,1 @@\n-  void push_more_uses(Unique_Node_List& worklist, Node* parent, const Node* use) const;\n+  void push_more_uses(Unique_Node_List& worklist, Node* parent, Node* use) const;\n@@ -625,1 +625,1 @@\n-  void push_and(Unique_Node_List& worklist, const Node* parent, const Node* use) const;\n+  void push_and(Unique_Node_List& worklist, const Node* parent, Node* use) const;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,3 +40,1 @@\n- * @run main\/othervm -XX:CompileCommand=compileonly,compiler.ccp.TestShiftConvertAndNotification::test\n- *                   -Xcomp\n- *                   compiler.ccp.TestShiftConvertAndNotification\n+ * @run main\/othervm compiler.ccp.TestShiftConvertAndNotification\n","filename":"test\/hotspot\/jtreg\/compiler\/ccp\/TestShiftConvertAndNotification.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}