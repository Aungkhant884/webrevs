{"files":[{"patch":"@@ -1496,0 +1496,31 @@\n+void C2_MacroAssembler::load_vector(XMMRegister dst, Address src, int vlen_in_bytes) {\n+  switch (vlen_in_bytes) {\n+  case 4:  movdl(dst, src);   break;\n+  case 8:  movq(dst, src);    break;\n+  case 16: movdqu(dst, src);  break;\n+  case 32: vmovdqu(dst, src); break;\n+  case 64: evmovdqul(dst, src, Assembler::AVX_512bit); break;\n+  default: ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::load_vector(XMMRegister dst, AddressLiteral src, int vlen_in_bytes, Register rscratch) {\n+  if (reachable(src)) {\n+    load_vector(dst, as_Address(src), vlen_in_bytes);\n+  } else {\n+    lea(rscratch, src);\n+    load_vector(dst, Address(rscratch, 0), vlen_in_bytes);\n+  }\n+}\n+\n+void C2_MacroAssembler::store_vector(Address dst, XMMRegister src, int vlen_in_bytes) {\n+  switch (vlen_in_bytes) {\n+  case 4:  movdl(dst, src);   break;\n+  case 8:  movq(dst, src);    break;\n+  case 16: movdqu(dst, src);  break;\n+  case 32: vmovdqu(dst, src); break;\n+  case 64: evmovdqul(dst, src, Assembler::AVX_512bit); break;\n+  default: ShouldNotReachHere();\n+  }\n+}\n+\n@@ -3996,0 +4027,81 @@\n+\/*\n+ * Convert long vectors to floating-point vectors on non-AVX512dq\n+ * The fast path downcasts the vector to an int vector to perform the\n+ * cast; the slow path, where some elements can't be cast losslessly to\n+ * int, tries to convert elements one by one.\n+ *\/\n+void C2_MacroAssembler::vector_castL2FD(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                        Register tmp, KRegister ktmp, BasicType bt, int vlen, int vec_enc) {\n+  Label slow_path;\n+  Label slow_path_loop;\n+  Label done;\n+  assert((ktmp == knoreg) != (vlen == 8), \"\");\n+  assert(bt == T_FLOAT || bt == T_DOUBLE, \"\");\n+\n+  if (vec_enc == AVX_128bit) {\n+    vpshufd(xtmp1, src, 0x08, vec_enc);\n+  } else if (UseAVX > 2) {\n+    evpmovqd(xtmp1, src, VM_Version::supports_avx512vl() ? vec_enc : AVX_512bit);\n+  } else {\n+    vpshufd(xtmp1, src, 0x08, vec_enc);\n+    vpermq(xtmp1, xtmp1, 0x08, vec_enc);\n+  }\n+\n+  vpmovsxdq(xtmp2, xtmp1, vec_enc);\n+  if (vec_enc == AVX_512bit) {\n+    evpcmp(T_LONG, ktmp, k0, src, xtmp2, Assembler::eq, vec_enc);\n+    kmov(tmp, ktmp);\n+  } else {\n+    vpcmpeqq(xtmp2, src, xtmp2, vec_enc);\n+    vmovmskpd(tmp, xtmp2, vec_enc);\n+  }\n+  if (vlen == 1) {\n+    testl(tmp, 1);\n+    jccb(Assembler::zero, slow_path);\n+  } else {\n+    cmp32(tmp, (1 << vlen) - 1);\n+    jccb(Assembler::notEqual, slow_path);\n+  }\n+\n+  \/\/ fast path\n+  if (bt == T_FLOAT) {\n+    vcvtdq2ps(dst, xtmp1, vec_enc == AVX_512bit ? AVX_256bit : AVX_128bit);\n+  } else {\n+    vcvtdq2pd(dst, xtmp1, vec_enc);\n+  }\n+  jmp(done);\n+\n+  bind(slow_path);\n+  subptr(rsp, vlen * (type2aelembytes(T_LONG) + type2aelembytes(bt)));\n+  store_vector(Address(rsp, 0), src, vlen * type2aelembytes(T_LONG));\n+  movl(tmp, vlen);\n+\n+  Address src_ele(rsp, tmp, Address::times_8, -type2aelembytes(T_LONG));\n+  Address dst_ele(rsp, tmp, bt == T_FLOAT ? Address::times_4 : Address::times_8, vlen * type2aelembytes(T_LONG) - type2aelembytes(bt));\n+  bind(slow_path_loop);\n+#ifdef _LP64\n+  if (bt == T_FLOAT) {\n+    cvtsi2ssq(xtmp1, src_ele);\n+    movflt(dst_ele, xtmp1);\n+  } else {\n+    cvtsi2sdq(xtmp1, src_ele);\n+    movdbl(dst_ele, xtmp1);\n+  }\n+#else \/\/ _LP64\n+  if (bt == T_FLOAT) {\n+    fild_d(src_ele);\n+    fstp_s(dst_ele);\n+  } else {\n+    fild_d(src_ele);\n+    fstp_d(dst_ele);\n+  }\n+#endif \/\/ _LP64\n+  decl(tmp);\n+  jccb(Assembler::notZero, slow_path_loop);\n+\n+  load_vector(dst, Address(rsp, vlen * type2aelembytes(T_LONG)), vlen * type2aelembytes(bt));\n+  addptr(rsp, vlen * (type2aelembytes(T_LONG) + type2aelembytes(bt)));\n+\n+  bind(done);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":112,"deletions":0,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -147,0 +147,3 @@\n+  void load_vector(XMMRegister dst, Address src, int vlen_in_bytes);\n+  void load_vector(XMMRegister dst, AddressLiteral src, int vlen_in_bytes, Register rscratch = rscratch1);\n+  void store_vector(Address dst, XMMRegister src, int vlen_in_bytes);\n@@ -297,0 +300,3 @@\n+  void vector_castL2FD(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                       Register tmp, KRegister ktmp, BasicType bt, int vlen, int vec_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1786,14 +1786,0 @@\n-    case Op_VectorCastB2X:\n-    case Op_VectorCastS2X:\n-    case Op_VectorCastI2X:\n-      if (bt != T_DOUBLE && size_in_bits == 256 && UseAVX < 2) {\n-        return false;\n-      }\n-      break;\n-    case Op_VectorCastL2X:\n-      if (is_integral_type(bt) && size_in_bits == 256 && UseAVX < 2) {\n-        return false;\n-      } else if (!is_integral_type(bt) && !VM_Version::supports_avx512dq()) {\n-        return false;\n-      }\n-      break;\n@@ -3822,8 +3808,1 @@\n-    switch (Matcher::vector_length_in_bytes(this)) {\n-      case  4: __ movdl    ($dst$$XMMRegister, $mem$$Address); break;\n-      case  8: __ movq     ($dst$$XMMRegister, $mem$$Address); break;\n-      case 16: __ movdqu   ($dst$$XMMRegister, $mem$$Address); break;\n-      case 32: __ vmovdqu  ($dst$$XMMRegister, $mem$$Address); break;\n-      case 64: __ evmovdqul($dst$$XMMRegister, $mem$$Address, Assembler::AVX_512bit); break;\n-      default: ShouldNotReachHere();\n-    }\n+    __ load_vector($dst$$XMMRegister, $mem$$Address, Matcher::vector_length_in_bytes(this));\n@@ -3840,8 +3819,1 @@\n-    switch (Matcher::vector_length_in_bytes(this, $src)) {\n-      case  4: __ movdl    ($mem$$Address, $src$$XMMRegister); break;\n-      case  8: __ movq     ($mem$$Address, $src$$XMMRegister); break;\n-      case 16: __ movdqu   ($mem$$Address, $src$$XMMRegister); break;\n-      case 32: __ vmovdqu  ($mem$$Address, $src$$XMMRegister); break;\n-      case 64: __ evmovdqul($mem$$Address, $src$$XMMRegister, Assembler::AVX_512bit); break;\n-      default: ShouldNotReachHere();\n-    }\n+    __ store_vector($mem$$Address, $src$$XMMRegister, Matcher::vector_length_in_bytes(this, $src));\n@@ -6907,0 +6879,3 @@\n+  predicate(UseAVX > 1 ||\n+            Matcher::vector_element_basic_type(n) != T_FLOAT ||\n+            Matcher::vector_length_in_bytes(n) < 32);\n@@ -6975,2 +6950,5 @@\n-  predicate((UseAVX > 2 && VM_Version::supports_avx512vlbw()) ||\n-            (Matcher::vector_length_in_bytes(n) >= Matcher::vector_length_in_bytes(n->in(1)))); \/\/ dst >= src\n+  predicate((Matcher::vector_element_basic_type(n) == T_BYTE && UseAVX > 2 && VM_Version::supports_avx512vlbw()) ||\n+            (Matcher::vector_element_basic_type(n) == T_FLOAT && (UseAVX > 1 || Matcher::vector_length_in_bytes(n) < 32)) ||\n+            Matcher::vector_element_basic_type(n) == T_INT ||\n+            Matcher::vector_element_basic_type(n) == T_LONG ||\n+            Matcher::vector_element_basic_type(n) == T_DOUBLE);\n@@ -6985,3 +6963,0 @@\n-        if (!VM_Version::supports_avx512vl()) {\n-          vlen_enc = Assembler::AVX_512bit;\n-        }\n@@ -7013,0 +6988,32 @@\n+instruct vcastBStoF_avx1(vec dst, vec src, vec xtmp) %{\n+  predicate(UseAVX == 1 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT &&\n+            Matcher::vector_length_in_bytes(n) == 32);\n+  match(Set dst (VectorCastB2X src));\n+  match(Set dst (VectorCastS2X src));\n+  format %{ \"vector_cast_bs2x $dst,$src\\t! using $xtmp as TEMP\" %}\n+  effect(TEMP dst, TEMP xtmp);\n+  ins_encode %{\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this, $src);\n+    switch (elem_bt) {\n+      case T_BYTE:\n+        __ pmovsxbd($dst$$XMMRegister, $src$$XMMRegister);\n+        __ pshufd($xtmp$$XMMRegister, $src$$XMMRegister, 0x01);\n+        __ pmovsxbd($xtmp$$XMMRegister, $xtmp$$XMMRegister);\n+        __ vinsertf128_high($dst$$XMMRegister, $xtmp$$XMMRegister);\n+        __ vcvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister, Assembler::AVX_256bit);\n+        break;\n+      case T_SHORT:\n+        __ pmovsxwd($dst$$XMMRegister, $src$$XMMRegister);\n+        __ pshufd($xtmp$$XMMRegister, $src$$XMMRegister, 0x0E);\n+        __ pmovsxwd($xtmp$$XMMRegister, $xtmp$$XMMRegister);\n+        __ vinsertf128_high($dst$$XMMRegister, $xtmp$$XMMRegister);\n+        __ vcvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister, Assembler::AVX_256bit);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -7138,0 +7145,34 @@\n+instruct vcastLtoFD_avx(vec dst, vec src, vec xtmp1, vec xtmp2, rRegI tmp, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx512dq() &&\n+            is_floating_point_type(Matcher::vector_element_basic_type(n)) &&\n+            Matcher::vector_length_in_bytes(n->in(1)) <= 32);\n+  match(Set dst (VectorCastL2X src));\n+  effect(TEMP xtmp1, TEMP xtmp2, TEMP tmp, KILL cr);\n+  format %{ \"vector_cast_l2x  $dst,$src\\t! using $xtmp1, $xtmp2 and $tmp as TEMP\" %}\n+  ins_encode %{\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    int vlen = Matcher::vector_length(this);\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    __ vector_castL2FD($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister,\n+                       $tmp$$Register, knoreg, to_elem_bt, vlen, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcastLtoFD_evex(vec dst, vec src, vec xtmp1, vec xtmp2, rRegI tmp, kReg ktmp, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx512dq() &&\n+            is_floating_point_type(Matcher::vector_element_basic_type(n)) &&\n+            Matcher::vector_length_in_bytes(n->in(1)) == 64);\n+  match(Set dst (VectorCastL2X src));\n+  effect(TEMP xtmp1, TEMP xtmp2, TEMP tmp, TEMP ktmp, KILL cr);\n+  format %{ \"vector_cast_l2x  $dst,$src\\t! using $xtmp1, $xtmp2, $tmp and $ktmp as TEMP\" %}\n+  ins_encode %{\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    int vlen = Matcher::vector_length(this);\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    __ vector_castL2FD($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister,\n+                       $tmp$$Register, $ktmp$$KRegister, to_elem_bt, vlen, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -7139,4 +7180,3 @@\n-  predicate(UseAVX > 2 ||\n-            (Matcher::vector_element_basic_type(n) == T_INT ||\n-             Matcher::vector_element_basic_type(n) == T_FLOAT ||\n-             Matcher::vector_element_basic_type(n) == T_DOUBLE));\n+  predicate((is_subword_type(Matcher::vector_element_basic_type(n)) && UseAVX > 2) ||\n+            Matcher::vector_element_basic_type(n) == T_INT ||\n+            (is_floating_point_type(Matcher::vector_element_basic_type(n)) && VM_Version::supports_avx512dq()));\n@@ -7184,1 +7224,0 @@\n-        assert(UseAVX > 2 && VM_Version::supports_avx512dq(), \"required\");\n@@ -7188,1 +7227,0 @@\n-        assert(UseAVX > 2 && VM_Version::supports_avx512dq(), \"required\");\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":79,"deletions":41,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+            makePair(BSPEC64, FSPEC256),\n@@ -49,0 +50,1 @@\n+            makePair(SSPEC128, FSPEC256),\n@@ -61,0 +63,2 @@\n+            makePair(LSPEC128, FSPEC64),\n+            makePair(LSPEC128, DSPEC128),\n@@ -73,1 +77,0 @@\n-            makePair(BSPEC64, FSPEC256),\n@@ -77,1 +80,0 @@\n-            makePair(SSPEC128, FSPEC256),\n@@ -85,0 +87,2 @@\n+            makePair(LSPEC256, FSPEC128),\n+            makePair(LSPEC256, DSPEC256),\n@@ -105,0 +109,2 @@\n+            makePair(LSPEC512, FSPEC256),\n+            makePair(LSPEC512, DSPEC512),\n@@ -116,3 +122,0 @@\n-            makePair(LSPEC128, DSPEC128),\n-            makePair(LSPEC256, DSPEC256),\n-            makePair(LSPEC512, DSPEC512),\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/utils\/TestCastMethods.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,7 @@\n-                    case \"long\"   -> UnsafeUtils.putLong(input, ibase, i, random.nextLong());\n+                    case \"long\"   -> {\n+                        if (normalArray) {\n+                            UnsafeUtils.putLong(input, ibase, i, random.nextInt());\n+                        } else {\n+                            UnsafeUtils.putLong(input, ibase, i, random.nextLong());\n+                        }\n+                    }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/utils\/VectorReshapeHelper.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"}]}