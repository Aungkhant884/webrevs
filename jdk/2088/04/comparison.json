{"files":[{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/gcTrace.hpp\"\n@@ -100,0 +101,1 @@\n+    GCLockerTracer::start_gc_locker(_jni_lock_count);\n@@ -110,0 +112,1 @@\n+    GCLockerTracer::inc_stall_count();\n@@ -155,0 +158,1 @@\n+    GCLockerTracer::report_gc_locker();\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -210,0 +210,15 @@\n+class GCLockerTracer : public AllStatic {\n+#if INCLUDE_JFR\n+private:\n+  static Ticks _needs_gc_start_timestamp;\n+  static volatile jint _jni_lock_count;\n+  static volatile jint _stall_count;\n+#endif\n+\n+  static bool is_started() NOT_JFR_RETURN_(false);\n+\n+public:\n+  static void start_gc_locker(jint jni_lock_count) NOT_JFR_RETURN();\n+  static void inc_stall_count() NOT_JFR_RETURN();\n+  static void report_gc_locker() NOT_JFR_RETURN();\n+};\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTrace.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -347,0 +347,45 @@\n+\n+#if INCLUDE_JFR\n+Ticks GCLockerTracer::_needs_gc_start_timestamp;\n+volatile jint GCLockerTracer::_jni_lock_count = 0;\n+volatile jint GCLockerTracer::_stall_count = 0;\n+\n+bool GCLockerTracer::is_started() {\n+  return _needs_gc_start_timestamp != Ticks();\n+}\n+\n+void GCLockerTracer::start_gc_locker(const jint jni_lock_count) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"sanity\");\n+  assert(!is_started(), \"sanity\");\n+  assert(_jni_lock_count == 0, \"sanity\");\n+  assert(_stall_count == 0, \"sanity\");\n+  if (EventGCLocker::is_enabled()) {\n+    _needs_gc_start_timestamp.stamp();\n+    _jni_lock_count = jni_lock_count;\n+  }\n+}\n+\n+void GCLockerTracer::inc_stall_count() {\n+  if (is_started()) {\n+    _stall_count++;\n+  }\n+}\n+\n+void GCLockerTracer::report_gc_locker() {\n+  if (is_started()) {\n+    EventGCLocker event(UNTIMED);\n+    if (event.should_commit()) {\n+      event.set_starttime(_needs_gc_start_timestamp);\n+      event.set_lockCount(_jni_lock_count);\n+      event.set_stallCount(_stall_count);\n+      event.commit();\n+    }\n+    \/\/ reset\n+    _needs_gc_start_timestamp = Ticks();\n+    _jni_lock_count = 0;\n+    _stall_count = 0;\n+\n+    assert(!is_started(), \"sanity\");\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTraceSend.cpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -1093,0 +1093,5 @@\n+  <Event name=\"GCLocker\" category=\"Java Virtual Machine, GC, Detailed\" description=\"GC Locker Information\" label=\"GC Locker\" startTime=\"true\" thread=\"true\" stackTrace=\"true\">\n+    <Field type=\"uint\" name=\"lockCount\" label=\"Lock Count\" description=\"the number of java threads in a critical section when the GC locker is started\" \/>\n+    <Field type=\"uint\" name=\"stallCount\" label=\"Stall Count\" description=\"the number of java threads stalled by the GC locker\" \/>\n+  <\/Event>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"gc\/shared\/gcLocker.inline.hpp\"\n@@ -2321,0 +2322,8 @@\n+WB_ENTRY(void, WB_LockCritical(JNIEnv* env, jobject wb))\n+  GCLocker::lock_critical(thread);\n+WB_END\n+\n+WB_ENTRY(void, WB_UnlockCritical(JNIEnv* env, jobject wb))\n+  GCLocker::unlock_critical(thread);\n+WB_END\n+\n@@ -2584,0 +2593,3 @@\n+\n+  {CC\"lockCritical\",    CC\"()V\",                      (void*)&WB_LockCritical},\n+  {CC\"unlockCritical\",  CC\"()V\",                      (void*)&WB_UnlockCritical},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -786,0 +786,5 @@\n+    <event name=\"jdk.GCLocker\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"threshold\">1 s<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+    <\/event>\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -786,0 +786,5 @@\n+    <event name=\"jdk.GCLocker\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"threshold\">100 ms<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+    <\/event>\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation. Alibaba designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\/\n+\n+\/**\n+ * @test TestGCLockerEvent\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xmx32m -Xms32m -Xmn12m -XX:+UseG1GC jdk.jfr.event.gc.detailed.TestGCLockerEvent\n+ *\/\n+\n+package jdk.jfr.event.gc.detailed;\n+\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+import sun.hotspot.WhiteBox;\n+\n+public class TestGCLockerEvent {\n+\n+    private static final String EVENT_NAME = EventNames.GCLocker;\n+\n+    private static final int CRITICAL_THREAD_COUNT = 4;\n+\n+    private static final CountDownLatch LOCK_COUNT_SIGNAL = new CountDownLatch(CRITICAL_THREAD_COUNT);\n+\n+    private static final CountDownLatch UNLOCK_SIGNAL = new CountDownLatch(1);\n+\n+    private static final CountDownLatch UNLOCK_COUNT_SIGNAL = new CountDownLatch(CRITICAL_THREAD_COUNT);\n+\n+    private static final String CRITICAL_THREAD_NAME_PREFIX = \"Critical Thread \";\n+\n+    private static final int STALL_THREAD_COUNT = 8;\n+\n+    private static final CountDownLatch STALL_COUNT_SIGNAL = new CountDownLatch(STALL_THREAD_COUNT);\n+\n+    private static final int LOOP = 32;\n+\n+    private static final int M = 1024 * 1024;\n+\n+    public static void main(String[] args) throws Exception {\n+        var recording = new Recording();\n+        recording.enable(EVENT_NAME);\n+        recording.start();\n+\n+        startCriticalThreads();\n+        LOCK_COUNT_SIGNAL.await();\n+        startStallThreads();\n+        STALL_COUNT_SIGNAL.await();\n+\n+        \/\/ Wait threads to be stalled\n+        Thread.sleep(1500);\n+\n+        UNLOCK_SIGNAL.countDown();\n+        UNLOCK_COUNT_SIGNAL.await();\n+        recording.stop();\n+\n+        \/\/ Verify recording\n+        var all = Events.fromRecording(recording);\n+        Events.hasEvents(all);\n+        var event = all.get(0);\n+\n+        assertTrue(Events.isEventType(event, EVENT_NAME));\n+        Events.assertField(event, \"lockCount\").equal(CRITICAL_THREAD_COUNT);\n+        Events.assertField(event, \"stallCount\").atLeast(STALL_THREAD_COUNT);\n+        assertTrue(event.getThread().getJavaName().startsWith(CRITICAL_THREAD_NAME_PREFIX));\n+\n+        recording.close();\n+    }\n+\n+    private static void startCriticalThreads() {\n+        for (var i = 0; i < CRITICAL_THREAD_COUNT; i++) {\n+            new Thread(() -> {\n+                try {\n+                    WhiteBox.getWhiteBox().lockCritical();\n+                    LOCK_COUNT_SIGNAL.countDown();\n+\n+                    UNLOCK_SIGNAL.await();\n+                    WhiteBox.getWhiteBox().unlockCritical();\n+                    UNLOCK_COUNT_SIGNAL.countDown();\n+                } catch (InterruptedException ex) {\n+                }\n+            }, CRITICAL_THREAD_NAME_PREFIX + i).start();\n+        }\n+    }\n+\n+    private static void startStallThreads() {\n+        var ts = new Thread[STALL_THREAD_COUNT];\n+        for (var i = 0; i < STALL_THREAD_COUNT; i++) {\n+            ts[i] = new Thread(() -> {\n+                STALL_COUNT_SIGNAL.countDown();\n+                for (int j = 0; j < LOOP; j++) {\n+                    byte[] bytes = new byte[M];\n+                }\n+            });\n+        }\n+        for (Thread t : ts) {\n+            t.start();\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/detailed\/TestGCLockerEvent.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -152,0 +152,1 @@\n+    public final static String GCLocker = PREFIX + \"GCLocker\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -646,0 +646,4 @@\n+\n+  public native void lockCritical();\n+\n+  public native void unlockCritical();\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}