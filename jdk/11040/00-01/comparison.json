{"files":[{"patch":"@@ -231,1 +231,1 @@\n-        NativeCallStack ncs(NULL, 0); \/\/ empty stack\n+        NativeCallStack ncs;\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-                    NativeCallStack(0) : NativeCallStack())\n+                    NativeCallStack(0) : FAKE_CALLSTACK)\n@@ -40,1 +40,1 @@\n-                    NativeCallStack(1) : NativeCallStack())\n+                    NativeCallStack(1) : FAKE_CALLSTACK)\n","filename":"src\/hotspot\/share\/services\/memTracker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -629,1 +629,1 @@\n-      NativeCallStack ncs(NULL, 0); \/\/ empty stack\n+      NativeCallStack ncs; \/\/ empty stack\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-const NativeCallStack NativeCallStack::_empty_stack (NULL, 0);\n+const NativeCallStack NativeCallStack::_empty_stack; \/\/ Uses default ctor\n@@ -80,0 +80,1 @@\n+  DEBUG_ONLY(assert_not_fake();)\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+\n@@ -62,7 +63,15 @@\n-  \/\/ JDK-8296437:\n-  \/\/ Default ctor is left intentionally empty to not initialize its stack.\n-  \/\/ This constructor is hot, since it gets used as part of CALLER_PC or CURRENT_PC\n-  \/\/ when NMT is off. Leaving this ctor empty will cause the compiler to optimize\n-  \/\/ it away. That the object remains uninitialized is fine, since it won't be used\n-  \/\/ anyway.\n-  NativeCallStack() {\n+  enum class FakeMarker { its_fake };\n+#ifdef ASSERT\n+  static constexpr uintptr_t _fake_address =\n+             (LP64_ONLY(0x4E4D54535441434BULL) \/\/ \"NMTSTACK\"\n+               NOT_LP64(0x4E4D5453));          \/\/ \"NMTS\"\n+  inline void assert_not_fake() const {\n+    assert(_stack[0] != (address)_fake_address, \"Must not be a fake stack\");\n+  }\n+#endif\n+\n+  \/\/ This \"fake\" constructor is only used in the CALLER_PC and CURRENT_PC macros\n+  \/\/ when NMT is off or in summary mode. In these cases, it does not need a\n+  \/\/ callstack, and we can leave the constructed object uninitialized. That will\n+  \/\/ cause the constructor call to be optimized away (see JDK-8296437).\n+  explicit NativeCallStack(FakeMarker dummy) {\n@@ -71,3 +80,1 @@\n-      \/\/ we zap the object with a pattern in debug builds only\n-      _stack[i] = (address)(LP64_ONLY(0x4E4D54535441434B) \/\/ \"NMTSTACK\"\n-                            NOT_LP64(0x4E4D5453));        \/\/ \"NMTS\"\n+      _stack[i] = (address)_fake_address;\n@@ -78,0 +85,6 @@\n+  \/\/ Default ctor creates an empty stack.\n+  \/\/ (it may make sense to remove this altogether but its used in a few places).\n+  NativeCallStack() {\n+    memset(_stack, 0, sizeof(_stack));\n+  }\n+\n@@ -85,0 +98,1 @@\n+    DEBUG_ONLY(assert_not_fake();)\n@@ -106,0 +120,1 @@\n+    DEBUG_ONLY(assert_not_fake();)\n@@ -117,0 +132,2 @@\n+#define FAKE_CALLSTACK NativeCallStack(NativeCallStack::FakeMarker::its_fake)\n+\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.hpp","additions":27,"deletions":10,"binary":false,"changes":37,"status":"modified"}]}