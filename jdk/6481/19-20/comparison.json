{"files":[{"patch":"@@ -871,1 +871,1 @@\n-                setDate(e);\n+                setZipEntryTime(e);\n@@ -876,1 +876,1 @@\n-                setDate(e);\n+                setZipEntryTime(e);\n@@ -976,1 +976,1 @@\n-                    setDate(e2, e.getTime());\n+                    setZipEntryTime(e2, e.getTime());\n@@ -1042,1 +1042,1 @@\n-        setDate(e);\n+        setZipEntryTime(e);\n@@ -1064,1 +1064,1 @@\n-                setDate(e, lastModified.toMillis());\n+                setZipEntryTime(e, lastModified.toMillis());\n@@ -1066,1 +1066,1 @@\n-                setDate(e);\n+                setZipEntryTime(e);\n@@ -1092,1 +1092,1 @@\n-        setDate(e);\n+        setZipEntryTime(e);\n@@ -1213,1 +1213,1 @@\n-        setDate(e, file.lastModified());\n+        setZipEntryTime(e, file.lastModified());\n@@ -2328,2 +2328,2 @@\n-    private void setDate(ZipEntry e) {\n-        setDate(e, System.currentTimeMillis());\n+    private void setZipEntryTime(ZipEntry e) {\n+        setZipEntryTime(e, System.currentTimeMillis());\n@@ -2334,1 +2334,1 @@\n-    private void setDate(ZipEntry e, long origTime) {\n+    private void setZipEntryTime(ZipEntry e, long origTime) {\n@@ -2336,1 +2336,1 @@\n-          e.setTimeLocal(date);\n+            e.setTimeLocal(date);\n@@ -2338,1 +2338,1 @@\n-          e.setTime(origTime);\n+            e.setTime(origTime);\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 4225317 6969651 8277422 8276766\n+ * @bug 4225317 6969651 8277422\n@@ -33,1 +33,0 @@\n-import java.nio.file.Files;\n@@ -35,1 +34,0 @@\n-import java.util.Arrays;\n@@ -40,6 +38,0 @@\n-import java.time.LocalDateTime;\n-import java.time.ZonedDateTime;\n-import java.time.ZoneId;\n-import java.time.ZoneOffset;\n-import java.time.format.DateTimeFormatter;\n-import java.util.concurrent.TimeUnit;\n@@ -97,2 +89,0 @@\n-        File jarFileSourceDate1 = new File(\"JarEntryTimeSourceDate1.jar\");\n-        File jarFileSourceDate2 = new File(\"JarEntryTimeSourceDate2.jar\");\n@@ -184,99 +174,0 @@\n-        \/\/ Test --date source date\n-        String[] sourceDates = {\"1980-01-01T00:00:02+00:00\",\n-                                \"1986-06-24T01:02:03+00:00\",\n-                                \"2022-03-15T00:00:00+00:00\",\n-                                \"2022-03-15T00:00:00+06:00\",\n-                                \"2021-12-25T09:30:00-08:00[America\/Los_Angeles]\",\n-                                \"2021-12-31T23:59:59Z\",\n-                                \"2024-06-08T14:24Z\",\n-                                \"2026-09-24T16:26-05:00\",\n-                                \"2038-11-26T06:06:06+00:00\",\n-                                \"2098-02-18T00:00:00-08:00\",\n-                                \"2099-12-31T23:59:59+00:00\"};\n-        for (String sourceDate : sourceDates) {\n-            jarFileSourceDate1.delete();\n-            createOuterInnerDirs(dirOuter, dirInner);\n-            check(JAR_TOOL.run(System.out, System.err,\n-                           \"--create\",\n-                           \"--file\", jarFileSourceDate1.getName(),\n-                           \"--date\", sourceDate,\n-                           dirOuter.getName()) == 0);\n-            check(jarFileSourceDate1.exists());\n-\n-            \/\/ Extract jarFileSourceDate1 and check last modified values\n-            extractJar(jarFileSourceDate1, false);\n-            check(dirOuter.exists());\n-            check(dirInner.exists());\n-            check(fileInner.exists());\n-            LocalDateTime expectedLdt = ZonedDateTime.parse(sourceDate,\n-                                             DateTimeFormatter.ISO_DATE_TIME)\n-                                             .withZoneSameInstant(ZoneOffset.UTC).toLocalDateTime();\n-            System.out.format(\"Checking jar entries local date time for --date %s, is %s%n\",\n-                              sourceDate, expectedLdt);\n-            long sourceDateEpochMillis = TimeUnit.MILLISECONDS.convert(\n-                expectedLdt.toEpochSecond(ZoneId.systemDefault().getRules().getOffset(expectedLdt)),\n-                TimeUnit.SECONDS);\n-            checkFileTime(dirOuter.lastModified(), sourceDateEpochMillis);\n-            checkFileTime(dirInner.lastModified(), sourceDateEpochMillis);\n-            checkFileTime(fileInner.lastModified(), sourceDateEpochMillis);\n-\n-            check(cleanup(dirInner));\n-            check(cleanup(dirOuter));\n-        }\n-\n-        \/\/ Test jars are reproducible across timezones\n-        TimeZone tz0    = TimeZone.getDefault();\n-        TimeZone tzAsia = TimeZone.getTimeZone(\"Asia\/Shanghai\");\n-        TimeZone tzLA   = TimeZone.getTimeZone(\"America\/Los_Angeles\");\n-        for (String sourceDate : sourceDates) {\n-            jarFileSourceDate1.delete();\n-            jarFileSourceDate2.delete();\n-            createOuterInnerDirs(dirOuter, dirInner);\n-            TimeZone.setDefault(tzAsia);\n-            check(JAR_TOOL.run(System.out, System.err,\n-                           \"--create\",\n-                           \"--file\", jarFileSourceDate1.getName(),\n-                           \"--date\", sourceDate,\n-                           dirOuter.getName()) == 0);\n-            check(jarFileSourceDate1.exists());\n-\n-            try {\n-                \/\/ Sleep 5 seconds to ensure jar timestamps might be different if they could be\n-                Thread.sleep(5000);\n-            } catch(InterruptedException ex) {}\n-\n-            TimeZone.setDefault(tzLA);\n-            check(JAR_TOOL.run(System.out, System.err,\n-                           \"--create\",\n-                           \"--file\", jarFileSourceDate2.getName(),\n-                           \"--date\", sourceDate,\n-                           dirOuter.getName()) == 0);\n-            check(jarFileSourceDate2.exists());\n-\n-            \/\/ Check jar are identical\n-            checkSameContent(jarFileSourceDate1, jarFileSourceDate2);\n-\n-            check(cleanup(dirInner));\n-            check(cleanup(dirOuter));\n-        }\n-        TimeZone.setDefault(tz0);\n-\n-        \/\/ Negative Tests --date out of range or wrong format source date\n-        String[] badSourceDates = {\"1976-06-24T01:02:03+00:00\",\n-                                   \"1980-01-01T00:00:01+00:00\",\n-                                   \"2100-01-01T00:00:00+00:00\",\n-                                   \"2138-02-18T00:00:00-11:00\",\n-                                   \"2006-04-06T12:38:00\",\n-                                   \"2012-08-24T16\"};\n-        for (String sourceDate : badSourceDates) {\n-            createOuterInnerDirs(dirOuter, dirInner);\n-            check(JAR_TOOL.run(System.out, System.err,\n-                           \"--create\",\n-                           \"--file\", jarFileSourceDate1.getName(),\n-                           \"--date\", sourceDate,\n-                           dirOuter.getName()) != 0);\n-\n-            check(cleanup(dirInner));\n-            check(cleanup(dirOuter));\n-        }\n-\n@@ -284,2 +175,0 @@\n-        check(jarFileSourceDate1.delete());\n-        check(jarFileSourceDate2.delete());\n@@ -289,27 +178,0 @@\n-    static void createOuterInnerDirs(File dirOuter, File dirInner) throws Throwable {\n-        \/* Create a directory structure\n-         * outer\/\n-         *     inner\/\n-         *         foo.txt\n-         * Set the lastModified dates so that outer is created now, inner\n-         * yesterday, and foo.txt created \"earlier\".\n-         *\/\n-        check(dirOuter.mkdir());\n-        check(dirInner.mkdir());\n-        File fileInner = new File(dirInner, \"foo.txt\");\n-        try (PrintWriter pw = new PrintWriter(fileInner)) {\n-            pw.println(\"hello, world\");\n-        }\n-\n-        \/\/ Get the \"now\" from the \"last-modified-time\" of the last file we\n-        \/\/ just created, instead of the \"System.currentTimeMillis()\", to\n-        \/\/ workaround the possible \"time difference\" due to nfs.\n-        final long now = fileInner.lastModified();\n-        final long earlier = now - (60L * 60L * 6L * 1000L);\n-        final long yesterday = now - (60L * 60L * 24L * 1000L);\n-\n-        check(dirOuter.setLastModified(now));\n-        check(dirInner.setLastModified(yesterday));\n-        check(fileInner.setLastModified(earlier));\n-    }\n-\n@@ -343,9 +205,0 @@\n-    static void checkSameContent(File f1, File f2) throws Throwable {\n-        byte[] ba1 = Files.readAllBytes(f1.toPath());\n-        byte[] ba2 = Files.readAllBytes(f2.toPath());\n-        if (!Arrays.equals(ba1, ba2)) {\n-            System.out.format(\"jar content differs: %s != %s%n\", f1, f2);\n-            fail();\n-        }\n-    }\n-\n","filename":"test\/jdk\/tools\/jar\/JarEntryTime.java","additions":1,"deletions":148,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -0,0 +1,296 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8276766\n+ * @summary Test jar --date source date of entries and that jars are\n+ *          reproducible\n+ * @modules jdk.jartool\n+ * @run testng ReproducibleJar\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Arrays;\n+import java.time.ZoneId;\n+import java.util.Date;\n+import java.util.TimeZone;\n+import java.util.spi.ToolProvider;\n+import java.time.LocalDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.time.Instant;\n+import java.util.concurrent.TimeUnit;\n+\n+public class ReproducibleJar {\n+    private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\")\n+        .orElseThrow(() ->\n+            new RuntimeException(\"jar tool not found\")\n+        );\n+\n+    \/\/ ZipEntry's mod date has 2 seconds precision: give extra time to\n+    \/\/ allow for e.g. rounding\/truncation and networked\/samba drives.\n+    private static final long PRECISION = 10000L;\n+\n+    private static final TimeZone TZ = TimeZone.getDefault();\n+    private static final boolean DST = TZ.inDaylightTime(new Date());\n+    private static final String unix2038RolloverTime = \"2038-01-19T03:14:07Z\";\n+    private static final Instant unix2038Rollover = Instant.parse(unix2038RolloverTime);\n+    private static final File dirOuter = new File(\"outer\");\n+    private static final File dirInner = new File(dirOuter, \"inner\");\n+    private static final File fileInner = new File(dirInner, \"foo.txt\");\n+    private static final File jarFileSourceDate1 = new File(\"JarEntryTimeSourceDate1.jar\");\n+    private static final File jarFileSourceDate2 = new File(\"JarEntryTimeSourceDate2.jar\");\n+\n+    private static final String[] sourceDates =\n+                               {\"1980-01-01T00:00:02+00:00\",\n+                                \"1986-06-24T01:02:03+00:00\",\n+                                \"2022-03-15T00:00:00+00:00\",\n+                                \"2022-03-15T00:00:00+06:00\",\n+                                \"2021-12-25T09:30:00-08:00[America\/Los_Angeles]\",\n+                                \"2021-12-31T23:59:59Z\",\n+                                \"2024-06-08T14:24Z\",\n+                                \"2026-09-24T16:26-05:00\",\n+                                \"2038-11-26T06:06:06+00:00\",\n+                                \"2098-02-18T00:00:00-08:00\",\n+                                \"2099-12-31T23:59:59+00:00\"};\n+\n+    private static final String[] badSourceDates =\n+                                {\"1976-06-24T01:02:03+00:00\",\n+                                 \"1980-01-01T00:00:01+00:00\",\n+                                 \"2100-01-01T00:00:00+00:00\",\n+                                 \"2138-02-18T00:00:00-11:00\",\n+                                 \"2006-04-06T12:38:00\",\n+                                 \"2012-08-24T16\"};\n+\n+    @BeforeMethod\n+    public void runBefore() throws Throwable {\n+        cleanup(dirInner);\n+        cleanup(dirOuter);\n+        jarFileSourceDate1.delete();\n+        jarFileSourceDate2.delete();\n+        TimeZone.setDefault(TZ);\n+    }\n+\n+    @AfterMethod\n+    public void runAfter() throws Throwable {\n+        cleanup(dirInner);\n+        cleanup(dirOuter);\n+        jarFileSourceDate1.delete();\n+        jarFileSourceDate2.delete();\n+        TimeZone.setDefault(TZ);\n+    }\n+\n+    @Test\n+    public void testSourceDate() throws Throwable {\n+        if (isInTransition()) return;\n+\n+        \/\/ Test --date source date\n+        for (String sourceDate : sourceDates) {\n+            createOuterInnerDirs(dirOuter, dirInner);\n+            Assert.assertEquals(JAR_TOOL.run(System.out, System.err,\n+                           \"--create\",\n+                           \"--file\", jarFileSourceDate1.getName(),\n+                           \"--date\", sourceDate,\n+                           dirOuter.getName()), 0);\n+            Assert.assertTrue(jarFileSourceDate1.exists());\n+\n+            \/\/ Extract jarFileSourceDate1 and check last modified values\n+            extractJar(jarFileSourceDate1);\n+            Assert.assertTrue(dirOuter.exists());\n+            Assert.assertTrue(dirInner.exists());\n+            Assert.assertTrue(fileInner.exists());\n+            LocalDateTime expectedLdt = ZonedDateTime.parse(sourceDate,\n+                                             DateTimeFormatter.ISO_DATE_TIME)\n+                                             .withZoneSameInstant(ZoneOffset.UTC).toLocalDateTime();\n+            System.out.format(\"Checking jar entries local date time for --date %s, is %s%n\",\n+                              sourceDate, expectedLdt);\n+            long sourceDateEpochMillis = TimeUnit.MILLISECONDS.convert(\n+                expectedLdt.toEpochSecond(ZoneId.systemDefault().getRules().getOffset(expectedLdt)),\n+                TimeUnit.SECONDS);\n+            checkFileTime(dirOuter.lastModified(), sourceDateEpochMillis);\n+            checkFileTime(dirInner.lastModified(), sourceDateEpochMillis);\n+            checkFileTime(fileInner.lastModified(), sourceDateEpochMillis);\n+\n+            cleanup(dirInner);\n+            cleanup(dirOuter);\n+            jarFileSourceDate1.delete();\n+        }\n+    }\n+\n+    @Test\n+    public void testInvalidSourceDate() throws Throwable {\n+        \/\/ Negative Tests --date out of range or wrong format source date\n+        createOuterInnerDirs(dirOuter, dirInner);\n+        for (String sourceDate : badSourceDates) {\n+            Assert.assertNotEquals(JAR_TOOL.run(System.out, System.err,\n+                           \"--create\",\n+                           \"--file\", jarFileSourceDate1.getName(),\n+                           \"--date\", sourceDate,\n+                           dirOuter.getName()), 0);\n+        }\n+    }\n+\n+    @Test\n+    public void testJarsReproducible() throws Throwable {\n+        \/\/ Test jars are reproducible across timezones\n+        TimeZone tzAsia = TimeZone.getTimeZone(\"Asia\/Shanghai\");\n+        TimeZone tzLA   = TimeZone.getTimeZone(\"America\/Los_Angeles\");\n+        for (String sourceDate : sourceDates) {\n+            createOuterInnerDirs(dirOuter, dirInner);\n+            TimeZone.setDefault(tzAsia);\n+            Assert.assertEquals(JAR_TOOL.run(System.out, System.err,\n+                           \"--create\",\n+                           \"--file\", jarFileSourceDate1.getName(),\n+                           \"--date\", sourceDate,\n+                           dirOuter.getName()), 0);\n+            Assert.assertTrue(jarFileSourceDate1.exists());\n+\n+            try {\n+                \/\/ Sleep 5 seconds to ensure jar timestamps might be different if they could be\n+                Thread.sleep(5000);\n+            } catch(InterruptedException ex) {}\n+\n+            TimeZone.setDefault(tzLA);\n+            Assert.assertEquals(JAR_TOOL.run(System.out, System.err,\n+                           \"--create\",\n+                           \"--file\", jarFileSourceDate2.getName(),\n+                           \"--date\", sourceDate,\n+                           dirOuter.getName()), 0);\n+            Assert.assertTrue(jarFileSourceDate2.exists());\n+\n+            \/\/ Check jars are identical\n+            checkSameContent(jarFileSourceDate1, jarFileSourceDate2);\n+\n+            cleanup(dirInner);\n+            cleanup(dirOuter);\n+            jarFileSourceDate1.delete();\n+            jarFileSourceDate2.delete();\n+        }\n+    }\n+\n+    static void createOuterInnerDirs(File dirOuter, File dirInner) throws Throwable {\n+        \/* Create a directory structure\n+         * outer\/\n+         *     inner\/\n+         *         foo.txt\n+         *\/\n+        Assert.assertTrue(dirOuter.mkdir());\n+        Assert.assertTrue(dirInner.mkdir());\n+        try (PrintWriter pw = new PrintWriter(fileInner)) {\n+            pw.println(\"hello, world\");\n+        }\n+\n+        Assert.assertTrue(dirOuter.exists());\n+        Assert.assertTrue(dirInner.exists());\n+        Assert.assertTrue(fileInner.exists());\n+    }\n+\n+    static void checkFileTime(long now, long original) throws Throwable {\n+        if (isTimeSettingChanged()) {\n+            return;\n+        }\n+\n+        if (Math.abs(now - original) > PRECISION) {\n+            \/\/ If original time is after UNIX 2038 32bit rollover\n+            \/\/ and the now time is exactly the rollover time, then assume\n+            \/\/ running on a file system that only supports to 2038 (e.g.XFS) and pass test\n+            if (FileTime.fromMillis(original).toInstant().isAfter(unix2038Rollover) &&\n+                FileTime.fromMillis(now).toInstant().equals(unix2038Rollover)) {\n+                System.out.println(\"Checking file time after Unix 2038 rollover,\" +\n+                                   \" and extracted file time is \" + unix2038RolloverTime + \", \" +\n+                                   \" Assuming restricted file system, pass file time check.\");\n+            } else {\n+                throw new AssertionError(\"checkFileTime failed,\" +\n+                                         \" extracted to \" +  FileTime.fromMillis(now) +\n+                                         \", expected to be close to \" + FileTime.fromMillis(original));\n+            }\n+        }\n+    }\n+\n+    static void checkSameContent(File f1, File f2) throws Throwable {\n+        byte[] ba1 = Files.readAllBytes(f1.toPath());\n+        byte[] ba2 = Files.readAllBytes(f2.toPath());\n+        if (!Arrays.equals(ba1, ba2)) {\n+            throw new AssertionError(\"jar content differs:\" + f1 + \" != \" + f2);\n+        }\n+    }\n+\n+    private static boolean isTimeSettingChanged() {\n+        TimeZone currentTZ = TimeZone.getDefault();\n+        boolean currentDST = currentTZ.inDaylightTime(new Date());\n+        if (!currentTZ.equals(TZ) || currentDST != DST) {\n+            System.out.println(\"Timezone or DST has changed during ReproducibleJar testcase execution. Test skipped\");\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    private static boolean isInTransition() {\n+        boolean inTransition = false;\n+\n+        var date = new Date();\n+        var defZone = ZoneId.systemDefault();\n+        if (defZone.getRules().getTransition(\n+                date.toInstant().atZone(defZone).toLocalDateTime()) != null) {\n+            System.out.println(\"ReproducibleJar testcase being run during Zone offset transition.  Test skipped.\");\n+            inTransition = true;\n+        }\n+\n+        return inTransition;\n+    }\n+\n+    static boolean cleanup(File dir) throws Throwable {\n+        boolean rc = true;\n+        File[] x = dir.listFiles();\n+        if (x != null) {\n+            for (int i = 0; i < x.length; i++) {\n+                rc &= x[i].delete();\n+            }\n+        }\n+        return rc & dir.delete();\n+    }\n+\n+    static void extractJar(File jarFile) throws Throwable {\n+        String javahome = System.getProperty(\"java.home\");\n+        String jarcmd = javahome + File.separator + \"bin\" + File.separator + \"jar\";\n+        String[] args;\n+        args = new String[] {\n+                jarcmd,\n+                \"xf\",\n+                jarFile.getName() };\n+        Process p = Runtime.getRuntime().exec(args);\n+        Assert.assertTrue(p != null && (p.waitFor() == 0));\n+    }\n+}\n","filename":"test\/jdk\/tools\/jar\/ReproducibleJar.java","additions":296,"deletions":0,"binary":false,"changes":296,"status":"added"}]}