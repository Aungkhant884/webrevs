{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -251,0 +251,43 @@\n+    \/**\n+     * Sets the last modification time of the entry in zoned date-time.\n+     *\n+     * <p> If the entry is output to a ZIP file or ZIP file formatted\n+     * output stream the last modification time set by this method will\n+     * be stored into the {@code date and time fields} of the zip file\n+     * entry and encoded in standard {@code MS-DOS date and time format}.\n+     * If the date-time set is out of the range of the standard {@code\n+     * MS-DOS date and time format}, the time will also be stored into\n+     * zip file entry's extended timestamp fields in {@code optional\n+     * extra data} in UTC time converted from the input zoned time.\n+     *\n+     * <p> {@code ZonedDateTime} uses a precision of nanoseconds, whereas\n+     * this class uses a precision of milliseconds. The conversion will\n+     * truncate any excess precision information as though the amount in\n+     * nanoseconds was subject to integer division by one million.\n+     *\n+     * @param  time\n+     *         The last modification time of the entry in zoned date-time\n+     *\n+     * @since 18\n+     *\/\n+    public void setTimeZoned(ZonedDateTime time) {\n+        int year = time.getYear() - 1980;\n+        if (year < 0) {\n+            this.xdostime = DOSTIME_BEFORE_1980;\n+        } else {\n+            this.xdostime = ((year << 25 |\n+                time.getMonthValue() << 21 |\n+                time.getDayOfMonth() << 16 |\n+                time.getHour() << 11 |\n+                time.getMinute() << 5 |\n+                time.getSecond() >> 1) & 0xffffffffL)\n+                + ((long)(((time.getSecond() & 0x1) * 1000) +\n+                      time.getNano() \/ 1000_000) << 32);\n+        }\n+        if (xdostime != DOSTIME_BEFORE_1980 && year <= 0x7f) {\n+            this.mtime = null;\n+        } else {\n+            this.mtime = FileTime.from(time.toInstant());\n+        }\n+    }\n+\n@@ -282,0 +325,34 @@\n+    \/**\n+     * Returns the last modification time of the entry in a zoned date-time.\n+     *\n+     * <p> If the entry is read from a ZIP file or ZIP file formatted\n+     * input stream, this is the last modification time from the zip\n+     * file entry's {@code optional extra data} if the extended timestamp\n+     * fields are present. Otherwise, the last modification time is read\n+     * from entry's standard MS-DOS formatted {@code date and time fields}.\n+     *\n+     * <p> The specified time-zone is used to convert the UTC time to a\n+     * zoned date-time.\n+     *\n+     * @param  zoneId\n+     *         The time-zone used to convert the UTC time to\n+     *         zoned date-time\n+     *\n+     * @return The last modification time of the entry in zoned date-time\n+     *\n+     * @since 18\n+     *\/\n+    public ZonedDateTime getTimeZoned(ZoneId zoneId) {\n+        if (mtime != null) {\n+            return ZonedDateTime.ofInstant(mtime.toInstant(), zoneId);\n+        }\n+        int ms = (int)(xdostime >> 32);\n+        return ZonedDateTime.of((int)(((xdostime >> 25) & 0x7f) + 1980),\n+                             (int)((xdostime >> 21) & 0x0f),\n+                             (int)((xdostime >> 16) & 0x1f),\n+                             (int)((xdostime >> 11) & 0x1f),\n+                             (int)((xdostime >> 5) & 0x3f),\n+                             (int)((xdostime << 1) & 0x3e) + ms \/ 1000,\n+                             (ms % 1000) * 1000_000,\n+                             zoneId);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipEntry.java","additions":78,"deletions":1,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -37,0 +37,3 @@\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n@@ -191,0 +194,12 @@\n+            new Option(true, OptionType.CREATE_UPDATE_INDEX, \"--date\") {\n+                void process(Main jartool, String opt, String arg) throws BadArgs {\n+                    try {\n+                        jartool.date = ZonedDateTime.parse(arg, DateTimeFormatter.ISO_DATE_TIME);\n+                        if (jartool.date.toEpochSecond() < 0) {\n+                            throw new BadArgs(\"error.date.before.epoch\", arg);\n+                        }\n+                    } catch (DateTimeParseException x) {\n+                        throw new BadArgs(\"error.date.notvalid\", arg);\n+                    }\n+                }\n+            },\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/GNUStyleOptions.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -70,0 +70,3 @@\n+import java.time.LocalDateTime;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n@@ -176,0 +179,3 @@\n+    \/* Date option for entry timestamps *\/\n+    ZonedDateTime date;\n+\n@@ -861,1 +867,1 @@\n-                e.setTime(System.currentTimeMillis());\n+                setDate(e);\n@@ -866,1 +872,1 @@\n-                e.setTime(System.currentTimeMillis());\n+                setDate(e);\n@@ -966,1 +972,1 @@\n-                    e2.setTime(e.getTime());\n+                    setDate(e2, e.getTime());\n@@ -1032,1 +1038,1 @@\n-        e.setTime(System.currentTimeMillis());\n+        setDate(e);\n@@ -1051,1 +1057,1 @@\n-            e.setTime(System.currentTimeMillis());\n+            setDate(e);\n@@ -1076,1 +1082,1 @@\n-        e.setTime(System.currentTimeMillis());\n+        setDate(e);\n@@ -1197,1 +1203,1 @@\n-        e.setTime(file.lastModified());\n+        setDate(e, file.lastModified());\n@@ -2276,0 +2282,14 @@\n+    \/\/ Set the ZipEntry dostime using date if specified otherwise the current time\n+    private void setDate(ZipEntry e) {\n+        setDate(e, System.currentTimeMillis());\n+    }\n+\n+    \/\/ Set the ZipEntry dostime using the date if specified\n+    \/\/ otherwise the original time\n+    private void setDate(ZipEntry e, long origTime) {\n+        if (date != null) {\n+          e.setTimeZoned(date);\n+        } else {\n+          e.setTime(origTime);\n+        }\n+    }\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,4 @@\n+error.date.notvalid=\\\n+        date {0} is not a valid ISO 8601 date and time\n+error.date.before.epoch=\\\n+        date {0} is before Epoch 1970-01-01T00:00:00\n@@ -293,0 +297,3 @@\n+main.help.opt.create.update.index.date=\\\n+\\      --date=TIMESTAMP       The timestamp in ISO 8601 format to use\\n\\\n+\\                             for entry timestamps\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar.properties","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,3 @@\n+import java.time.LocalDateTime;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n@@ -57,1 +60,1 @@\n-    static JmodOutputStream newOutputStream(Path file) throws IOException {\n+    static JmodOutputStream newOutputStream(Path file, ZonedDateTime date) throws IOException {\n@@ -60,1 +63,1 @@\n-        return new JmodOutputStream(bos);\n+        return new JmodOutputStream(bos, date);\n@@ -64,1 +67,2 @@\n-    private JmodOutputStream(OutputStream out) {\n+    private final ZonedDateTime   date;\n+    private JmodOutputStream(OutputStream out, ZonedDateTime date) {\n@@ -66,0 +70,1 @@\n+        this.date = date;\n@@ -107,1 +112,5 @@\n-        e2.setTime(e1.getTime());\n+        if (date != null) {\n+            e2.setTimeZoned(date);\n+        } else {\n+            e2.setTime(e1.getTime());\n+        }\n@@ -127,1 +136,5 @@\n-        return new ZipEntry(name);\n+        ZipEntry zipEntry = new ZipEntry(name);\n+        if (date != null) {\n+            zipEntry.setTimeZoned(date);\n+        }\n+        return zipEntry;\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jmod\/JmodOutputStream.java","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -65,0 +65,5 @@\n+import java.time.LocalDateTime;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n@@ -163,0 +168,1 @@\n+        ZonedDateTime date;\n@@ -430,1 +436,1 @@\n-            try (JmodOutputStream jos = JmodOutputStream.newOutputStream(tempTarget)) {\n+            try (JmodOutputStream jos = JmodOutputStream.newOutputStream(tempTarget, options.date)) {\n@@ -987,1 +993,5 @@\n-                            ze.setTime(System.currentTimeMillis());\n+                            if (options.date != null) {\n+                                ze.setTimeZoned(options.date);\n+                            } else {\n+                                ze.setTime(System.currentTimeMillis());\n+                            }\n@@ -1015,1 +1025,1 @@\n-                 JmodOutputStream jos = JmodOutputStream.newOutputStream(tempTarget))\n+                 JmodOutputStream jos = JmodOutputStream.newOutputStream(tempTarget, options.date))\n@@ -1150,0 +1160,19 @@\n+    static class DateConverter implements ValueConverter<ZonedDateTime> {\n+        @Override\n+        public ZonedDateTime convert(String value) {\n+            try {\n+                ZonedDateTime date = ZonedDateTime.parse(value, DateTimeFormatter.ISO_DATE_TIME);\n+                if (date.toEpochSecond() < 0) {\n+                    throw new CommandException(\"err.date.before.epoch\", value);\n+                }\n+                return date;\n+            } catch (DateTimeParseException x) {\n+                throw new CommandException(\"err.invalid.date\", value, x.getMessage());\n+            }\n+        }\n+\n+        @Override public Class<ZonedDateTime> valueType() { return ZonedDateTime.class; }\n+\n+        @Override public String valuePattern() { return \"date\"; }\n+    }\n+\n@@ -1385,0 +1414,5 @@\n+        OptionSpec<ZonedDateTime> date\n+                = parser.accepts(\"date\", getMessage(\"main.opt.date\"))\n+                        .withRequiredArg()\n+                        .withValuesConvertedBy(new DateConverter());\n+\n@@ -1428,0 +1462,2 @@\n+            if (opts.has(date))\n+                options.date = opts.valueOf(date);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jmod\/JmodTask.java","additions":39,"deletions":3,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,0 +77,1 @@\n+main.opt.date=Date and time to timestamp entries with specified in ISO 8601 format \n@@ -109,0 +110,2 @@\n+err.invalid.date=--date {0} is not a valid ISO 8601 date and time: {1} \n+err.date.before.epoch=--date {0} is before Epoch 1970-01-01T00:00:00\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jmod\/resources\/jmod.properties","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8276766\n+ * @summary Test timestamp via ZipEntry.get\/setTimeZoned()\n+ *\/\n+\n+import java.io.*;\n+import java.nio.file.*;\n+import java.time.*;\n+import java.util.*;\n+import java.util.zip.*;\n+\n+public class TestZonedTime {\n+    private static TimeZone tz0 = TimeZone.getDefault();\n+\n+    public static void main(String[] args) throws Throwable{\n+        try {\n+            ZonedDateTime zdt = ZonedDateTime.now();\n+\n+            test(zdt);    \/\/ now\n+            test(zdt.withYear(1968));\n+            test(zdt.withYear(1970));\n+            test(zdt.withYear(1982));\n+            test(zdt.withYear(2037));\n+            test(zdt.withYear(2100));\n+            test(zdt.withYear(2106));\n+\n+            TimeZone tz = TimeZone.getTimeZone(\"Asia\/Shanghai\");\n+            \/\/ dos time does not support < 1980, have to use\n+            \/\/ utc in mtime.\n+            testWithTZ(tz, zdt.withYear(1982));\n+            testWithTZ(tz, zdt.withYear(2037));\n+            testWithTZ(tz, zdt.withYear(2100));\n+            testWithTZ(tz, zdt.withYear(2106));\n+\n+            test(ZonedDateTime.of(2200, 04, 26, 2, 31, 52, 973, ZoneId.of(\"-05:00\")));\n+        } finally {\n+            TimeZone.setDefault(tz0);\n+        }\n+    }\n+\n+    static byte[] getBytes(ZonedDateTime mtime) throws Throwable {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ZipOutputStream zos = new ZipOutputStream(baos);\n+        ZipEntry ze = new ZipEntry(\"TestZonedTime.java\");\n+        ze.setTimeZoned(mtime);\n+        check(ze, mtime);\n+        zos.putNextEntry(ze);\n+        zos.write(new byte[] { 1, 2, 3, 4});\n+        zos.close();\n+        return baos.toByteArray();\n+    }\n+\n+    static void testWithTZ(TimeZone tz, ZonedDateTime zdt) throws Throwable {\n+       TimeZone.setDefault(tz);\n+       byte[] zbytes = getBytes(zdt);\n+       TimeZone.setDefault(tz0);\n+       test(zbytes, zdt);\n+    }\n+\n+    static void test(ZonedDateTime zdt) throws Throwable {\n+        test(getBytes(zdt), zdt);\n+    }\n+\n+    static void test(byte[] zbytes, ZonedDateTime expected) throws Throwable {\n+        System.out.printf(\"--------------------%nTesting: [%s]%n\", expected);\n+        \/\/ ZipInputStream\n+        ZipInputStream zis = new ZipInputStream(new ByteArrayInputStream(zbytes));\n+        ZipEntry ze = zis.getNextEntry();\n+        zis.close();\n+        check(ze, expected);\n+\n+        \/\/ ZipFile\n+        Path zpath = Paths.get(System.getProperty(\"test.dir\", \".\"),\n+                               \"TestZonedTime.zip\");\n+        try {\n+            Files.copy(new ByteArrayInputStream(zbytes), zpath);\n+            ZipFile zf = new ZipFile(zpath.toFile());\n+            ze = zf.getEntry(\"TestZonedTime.java\");\n+            check(ze, expected);\n+            zf.close();\n+        } finally {\n+            Files.deleteIfExists(zpath);\n+        }\n+    }\n+\n+    static void check(ZipEntry ze, ZonedDateTime expected) {\n+        long timeSeconds = ze.getTimeZoned(expected.getZone()).toEpochSecond();\n+        if ( timeSeconds >> 1\n+            != expected.toEpochSecond() >> 1) {\n+            throw new RuntimeException(\"Timestamp: storing mtime failed!\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/TestZonedTime.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4225317 6969651\n+ * @bug 4225317 6969651 8276766\n@@ -37,0 +37,2 @@\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n@@ -88,0 +90,2 @@\n+        File jarFileSourceDate = new File(\"JarEntryTimeSourceDate.jar\");\n+        File jarFileSourceDateBefore1980 = new File(\"JarEntryTimeSourceDateBefore1980.jar\");\n@@ -126,0 +130,19 @@\n+        \/\/ Make a jar file from that directory structure with\n+        \/\/ --date set to 15\/03\/2022\n+        String sourceDate = \"2022-03-15T00:00:00+00:00\";\n+        check(JAR_TOOL.run(System.out, System.err,\n+                           \"--create\",\n+                           \"--file\", jarFileSourceDate.getName(),\n+                           \"--date\", sourceDate,\n+                           dirOuter.getName()) == 0);\n+        check(jarFileSourceDate.exists());\n+\n+        \/\/ Use a date before dostime 1980\/1\/1 in non-UTC zone\n+        String sourceDateBefore1980 = \"1976-03-15T01:02:03+02:00\";\n+        check(JAR_TOOL.run(System.out, System.err,\n+                           \"--create\",\n+                           \"--file\", jarFileSourceDateBefore1980.getName(),\n+                           \"--date\", sourceDateBefore1980,\n+                           dirOuter.getName()) == 0);\n+        check(jarFileSourceDateBefore1980.exists());\n+\n@@ -165,0 +188,28 @@\n+        \/\/ Extract jarFileSourceDate and check last modified values\n+        extractJar(jarFileSourceDate, false);\n+        check(dirOuter.exists());\n+        check(dirInner.exists());\n+        check(fileInner.exists());\n+        long sourceDateEpochMillis = ZonedDateTime.parse(sourceDate,\n+                               DateTimeFormatter.ISO_DATE_TIME).toEpochSecond() * 1000;\n+        checkFileTime(dirOuter.lastModified(), sourceDateEpochMillis);\n+        checkFileTime(dirInner.lastModified(), sourceDateEpochMillis);\n+        checkFileTime(fileInner.lastModified(), sourceDateEpochMillis);\n+\n+        check(cleanup(dirInner));\n+        check(cleanup(dirOuter));\n+\n+        \/\/ Extract jarFileSourceDateBefore1980 and check last modified values\n+        extractJar(jarFileSourceDateBefore1980, false);\n+        check(dirOuter.exists());\n+        check(dirInner.exists());\n+        check(fileInner.exists());\n+        long sourceDateBefore1980Millis = ZonedDateTime.parse(sourceDateBefore1980,\n+                               DateTimeFormatter.ISO_DATE_TIME).toEpochSecond() * 1000;\n+        checkFileTime(dirOuter.lastModified(), sourceDateBefore1980Millis);\n+        checkFileTime(dirInner.lastModified(), sourceDateBefore1980Millis);\n+        checkFileTime(fileInner.lastModified(), sourceDateBefore1980Millis);\n+\n+        check(cleanup(dirInner));\n+        check(cleanup(dirOuter));\n+\n@@ -166,0 +217,2 @@\n+        check(jarFileSourceDate.delete());\n+        check(jarFileSourceDateBefore1980.delete());\n","filename":"test\/jdk\/tools\/jar\/JarEntryTime.java","additions":55,"deletions":2,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8142968 8166568 8166286 8170618 8168149 8240910 8276764\n+ * @bug 8142968 8166568 8166286 8170618 8168149 8240910 8276764 8276766\n@@ -186,0 +186,2 @@\n+        Path jmod = MODS_DIR.resolve(\"foo.jmod\");\n+        FileUtils.deleteFileIfExistsWithRetry(jmod);\n@@ -188,1 +190,1 @@\n-             MODS_DIR.resolve(\"foo.jmod\").toString())\n+             jmod.toString())\n@@ -192,1 +194,1 @@\n-             MODS_DIR.resolve(\"foo.jmod\").toString())\n+             jmod.toString())\n@@ -214,0 +216,71 @@\n+    @Test\n+    public void testSourceDateReproducible() throws IOException {\n+        String cp = EXPLODED_DIR.resolve(\"foo\").resolve(\"classes\").toString();\n+        Path jmod1 = MODS_DIR.resolve(\"foo1.jmod\");\n+        Path jmod2 = MODS_DIR.resolve(\"foo2.jmod\");\n+        Path jmod3 = MODS_DIR.resolve(\"foo3.jmod\");\n+        Path jmod4 = MODS_DIR.resolve(\"foo4.jmod\");\n+        FileUtils.deleteFileIfExistsWithRetry(jmod1);\n+        FileUtils.deleteFileIfExistsWithRetry(jmod2);\n+        FileUtils.deleteFileIfExistsWithRetry(jmod3);\n+        FileUtils.deleteFileIfExistsWithRetry(jmod4);\n+\n+        \/\/ Use source date of 15\/03\/2022\n+        String sourceDate = \"2022-03-15T00:00:00+00:00\";\n+\n+        jmod(\"create\",\n+             \"--class-path\", cp,\n+             \"--date\", sourceDate,\n+             jmod1.toString())\n+            .assertSuccess();\n+\n+        try {\n+            \/\/ Sleep 5 seconds to ensure zip timestamps might be different if they could be\n+            Thread.sleep(5000);\n+        } catch(InterruptedException ex) {}\n+\n+        jmod(\"create\",\n+             \"--class-path\", cp,\n+             \"--date\", sourceDate,\n+             jmod2.toString())\n+            .assertSuccess();\n+\n+        \/\/ Compare file byte content to see if they are identical\n+        assertSameContent(jmod1, jmod2);\n+\n+        \/\/ Use a date before epoch and assert failure error\n+        sourceDate = \"1936-03-15T00:00:00+00:00\";\n+\n+        jmod(\"create\",\n+             \"--class-path\", cp,\n+             \"--date\", sourceDate,\n+             jmod3.toString())\n+            .assertFailure()\n+            .resultChecker(r -> {\n+                assertContains(r.output, \"is before Epoch 1970-01-01T00:00:00\");\n+            });\n+\n+        \/\/ Use a date before zip minimum dostime 1980-1-1\n+        sourceDate = \"1976-03-15T01:02:03+02:00\";\n+\n+        jmod(\"create\",\n+             \"--class-path\", cp,\n+             \"--date\", sourceDate,\n+             jmod3.toString())\n+            .assertSuccess();\n+\n+        try {\n+            \/\/ Sleep 5 seconds to ensure zip timestamps might be different if they could be\n+            Thread.sleep(5000);\n+        } catch(InterruptedException ex) {}\n+\n+        jmod(\"create\",\n+             \"--class-path\", cp,\n+             \"--date\", sourceDate,\n+             jmod4.toString())\n+            .assertSuccess();\n+\n+        \/\/ Compare file byte content to see if they are identical\n+        assertSameContent(jmod3, jmod4);\n+    }\n+\n","filename":"test\/jdk\/tools\/jmod\/JmodTest.java","additions":76,"deletions":3,"binary":false,"changes":79,"status":"modified"}]}