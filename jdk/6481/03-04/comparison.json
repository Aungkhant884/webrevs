{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -251,0 +251,43 @@\n+    \/**\n+     * Sets the last modification time of the entry in zoned date-time.\n+     *\n+     * <p> If the entry is output to a ZIP file or ZIP file formatted\n+     * output stream the last modification time set by this method will\n+     * be stored into the {@code date and time fields} of the zip file\n+     * entry and encoded in standard {@code MS-DOS date and time format}.\n+     * If the date-time set is out of the range of the standard {@code\n+     * MS-DOS date and time format}, the time will also be stored into\n+     * zip file entry's extended timestamp fields in {@code optional\n+     * extra data} in UTC time converted from the input zoned time.\n+     *\n+     * <p> {@code ZonedDateTime} uses a precision of nanoseconds, whereas\n+     * this class uses a precision of milliseconds. The conversion will\n+     * truncate any excess precision information as though the amount in\n+     * nanoseconds was subject to integer division by one million.\n+     *\n+     * @param  time\n+     *         The last modification time of the entry in zoned date-time\n+     *\n+     * @since 18 \n+     *\/\n+    public void setTimeZoned(ZonedDateTime time) {\n+        int year = time.getYear() - 1980;\n+        if (year < 0) {\n+            this.xdostime = DOSTIME_BEFORE_1980;\n+        } else {\n+            this.xdostime = ((year << 25 |\n+                time.getMonthValue() << 21 |\n+                time.getDayOfMonth() << 16 |\n+                time.getHour() << 11 |\n+                time.getMinute() << 5 |\n+                time.getSecond() >> 1) & 0xffffffffL)\n+                + ((long)(((time.getSecond() & 0x1) * 1000) +\n+                      time.getNano() \/ 1000_000) << 32);\n+        }\n+        if (xdostime != DOSTIME_BEFORE_1980 && year <= 0x7f) {\n+            this.mtime = null;\n+        } else {\n+            this.mtime = FileTime.from(time.toInstant());\n+        }\n+    }\n+\n@@ -282,0 +325,34 @@\n+    \/**\n+     * Returns the last modification time of the entry in a zoned date-time.\n+     *\n+     * <p> If the entry is read from a ZIP file or ZIP file formatted\n+     * input stream, this is the last modification time from the zip\n+     * file entry's {@code optional extra data} if the extended timestamp\n+     * fields are present. Otherwise, the last modification time is read\n+     * from entry's standard MS-DOS formatted {@code date and time fields}.\n+     *\n+     * <p> The specified time-zone is used to convert the UTC time to a\n+     * zoned date-time.\n+     *\n+     * @param  zoneId \n+     *         The time-zone used to convert the UTC time to\n+     *         zoned date-time \n+     *\n+     * @return The last modification time of the entry in zoned date-time\n+     *\n+     * @since 18 \n+     *\/\n+    public ZonedDateTime getTimeZoned(ZoneId zoneId) {\n+        if (mtime != null) {\n+            return ZonedDateTime.ofInstant(mtime.toInstant(), zoneId);\n+        }\n+        int ms = (int)(xdostime >> 32);\n+        return ZonedDateTime.of((int)(((xdostime >> 25) & 0x7f) + 1980),\n+                             (int)((xdostime >> 21) & 0x0f),\n+                             (int)((xdostime >> 16) & 0x1f),\n+                             (int)((xdostime >> 11) & 0x1f),\n+                             (int)((xdostime >> 5) & 0x3f),\n+                             (int)((xdostime << 1) & 0x3e) + ms \/ 1000,\n+                             (ms % 1000) * 1000_000,\n+                             zoneId);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipEntry.java","additions":78,"deletions":1,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -37,0 +37,3 @@\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n@@ -191,1 +194,1 @@\n-            new Option(true, OptionType.CREATE_UPDATE_INDEX, \"--source-date\") {\n+            new Option(true, OptionType.CREATE_UPDATE_INDEX, \"--date\") {\n@@ -194,3 +197,6 @@\n-                        jartool.sourceDate = Long.parseLong(arg);\n-                    } catch (NumberFormatException x) {\n-                        throw new BadArgs(\"error.source.date.notnumber\", arg);\n+                        jartool.date = ZonedDateTime.parse(arg, DateTimeFormatter.ISO_DATE_TIME);\n+                        if (jartool.date.toEpochSecond() < 0) {\n+                            throw new BadArgs(\"error.date.before.epoch\", arg);\n+                        }\n+                    } catch (DateTimeParseException x) {\n+                        throw new BadArgs(\"error.date.notvalid\", arg);\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/GNUStyleOptions.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+import java.time.ZonedDateTime;\n@@ -178,2 +179,2 @@\n-    \/* Source date option for entry timestamps *\/\n-    long sourceDate = -1;\n+    \/* Date option for entry timestamps *\/\n+    ZonedDateTime date;\n@@ -866,1 +867,1 @@\n-                setSourceDate(e);\n+                setDate(e);\n@@ -871,1 +872,1 @@\n-                setSourceDate(e);\n+                setDate(e);\n@@ -971,1 +972,1 @@\n-                    setSourceDate(e2, e.getTime());\n+                    setDate(e2, e.getTime());\n@@ -1037,1 +1038,1 @@\n-        setSourceDate(e);\n+        setDate(e);\n@@ -1056,1 +1057,1 @@\n-            setSourceDate(e);\n+            setDate(e);\n@@ -1081,1 +1082,1 @@\n-        setSourceDate(e);\n+        setDate(e);\n@@ -1202,1 +1203,1 @@\n-        setSourceDate(e, file.lastModified());\n+        setDate(e, file.lastModified());\n@@ -2281,3 +2282,3 @@\n-    \/\/ Set the ZipEntry dostime using sourceDate if specified otherwise the current time\n-    private void setSourceDate(ZipEntry e) {\n-        setSourceDate(e, System.currentTimeMillis());\n+    \/\/ Set the ZipEntry dostime using date if specified otherwise the current time\n+    private void setDate(ZipEntry e) {\n+        setDate(e, System.currentTimeMillis());\n@@ -2286,1 +2287,1 @@\n-    \/\/ Set the ZipEntry dostime using the sourceDate if specified\n+    \/\/ Set the ZipEntry dostime using the date if specified\n@@ -2288,3 +2289,3 @@\n-    private void setSourceDate(ZipEntry e, long origTime) {\n-        if (sourceDate != -1) {\n-          e.setTimeLocal(LocalDateTime.ofEpochSecond(sourceDate, 0, ZoneOffset.UTC));\n+    private void setDate(ZipEntry e, long origTime) {\n+        if (date != null) {\n+          e.setTimeZoned(date);\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -85,2 +85,4 @@\n-error.source.date.notnumber=\\\n-        source date {0} is not a valid long integer\n+error.date.notvalid=\\\n+        date {0} is not a valid ISO 8601 date and time\n+error.date.before.epoch=\\\n+        date {0} is before Epoch 1970-01-01T00:00:00\n@@ -295,2 +297,2 @@\n-main.help.opt.create.update.index.source-date=\\\n-\\      --source-date=TIMESTAMP    The epoch timestamp in seconds to use\\n\\\n+main.help.opt.create.update.index.date=\\\n+\\      --date=TIMESTAMP       The timestamp in ISO 8601 format to use\\n\\\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar.properties","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-.\\\" Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+.\\\" Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -214,6 +214,0 @@\n-.TP\n-.B \\f[CB]\\-\\-source\\-date=\\f[R]\\f[I]TIMESTAMP\\f[R]\n-The timestamp in seconds since the epoch to use for all created\n-or updated jar entries.\n-.RS\n-.RE\n","filename":"src\/jdk.jartool\/share\/man\/jar.1","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.time.ZonedDateTime;\n@@ -59,1 +60,1 @@\n-    static JmodOutputStream newOutputStream(Path file, long sourceDate) throws IOException {\n+    static JmodOutputStream newOutputStream(Path file, ZonedDateTime date) throws IOException {\n@@ -62,1 +63,1 @@\n-        return new JmodOutputStream(bos, sourceDate);\n+        return new JmodOutputStream(bos, date);\n@@ -66,2 +67,2 @@\n-    private final long            sourceDate;\n-    private JmodOutputStream(OutputStream out, long sourceDate) {\n+    private final ZonedDateTime   date;\n+    private JmodOutputStream(OutputStream out, ZonedDateTime date) {\n@@ -69,1 +70,1 @@\n-        this.sourceDate = sourceDate;\n+        this.date = date;\n@@ -111,2 +112,2 @@\n-        if (sourceDate != -1) {\n-            e2.setTimeLocal(LocalDateTime.ofEpochSecond(sourceDate, 0, ZoneOffset.UTC));\n+        if (date != null) {\n+            e2.setTimeZoned(date);\n@@ -136,2 +137,2 @@\n-        if (sourceDate != -1) {\n-            zipEntry.setTimeLocal(LocalDateTime.ofEpochSecond(sourceDate, 0, ZoneOffset.UTC));\n+        if (date != null) {\n+            zipEntry.setTimeZoned(date);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jmod\/JmodOutputStream.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -67,0 +67,3 @@\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n@@ -165,1 +168,1 @@\n-        long sourceDate;\n+        ZonedDateTime date;\n@@ -433,1 +436,1 @@\n-            try (JmodOutputStream jos = JmodOutputStream.newOutputStream(tempTarget, options.sourceDate)) {\n+            try (JmodOutputStream jos = JmodOutputStream.newOutputStream(tempTarget, options.date)) {\n@@ -990,2 +993,2 @@\n-                            if (options.sourceDate != -1) {\n-                                ze.setTimeLocal(LocalDateTime.ofEpochSecond(options.sourceDate, 0, ZoneOffset.UTC));\n+                            if (options.date != null) {\n+                                ze.setTimeZoned(options.date);\n@@ -1022,1 +1025,1 @@\n-                 JmodOutputStream jos = JmodOutputStream.newOutputStream(tempTarget, options.sourceDate))\n+                 JmodOutputStream jos = JmodOutputStream.newOutputStream(tempTarget, options.date))\n@@ -1157,1 +1160,1 @@\n-    static class SourceDateConverter implements ValueConverter<Long> {\n+    static class DateConverter implements ValueConverter<ZonedDateTime> {\n@@ -1159,1 +1162,1 @@\n-        public Long convert(String value) {\n+        public ZonedDateTime convert(String value) {\n@@ -1161,3 +1164,7 @@\n-                return Long.valueOf(value);\n-            } catch (NumberFormatException x) {\n-                throw new CommandException(\"err.invalid.source.date\", x.getMessage());\n+                ZonedDateTime date = ZonedDateTime.parse(value, DateTimeFormatter.ISO_DATE_TIME);\n+                if (date.toEpochSecond() < 0) {\n+                    throw new CommandException(\"err.date.before.epoch\", value);\n+                }\n+                return date;\n+            } catch (DateTimeParseException x) {\n+                throw new CommandException(\"err.invalid.date\", value, x.getMessage());\n@@ -1167,1 +1174,1 @@\n-        @Override public Class<Long> valueType() { return Long.class; }\n+        @Override public Class<ZonedDateTime> valueType() { return ZonedDateTime.class; }\n@@ -1169,1 +1176,1 @@\n-        @Override public String valuePattern() { return \"source-date\"; }\n+        @Override public String valuePattern() { return \"date\"; }\n@@ -1407,2 +1414,2 @@\n-        OptionSpec<Long> sourceDate\n-                = parser.accepts(\"source-date\", getMessage(\"main.opt.source-date\"))\n+        OptionSpec<ZonedDateTime> date\n+                = parser.accepts(\"date\", getMessage(\"main.opt.date\"))\n@@ -1410,1 +1417,1 @@\n-                        .withValuesConvertedBy(new SourceDateConverter());\n+                        .withValuesConvertedBy(new DateConverter());\n@@ -1455,4 +1462,2 @@\n-            if (opts.has(sourceDate))\n-                options.sourceDate = opts.valueOf(sourceDate).longValue();\n-            else\n-                options.sourceDate = -1;\n+            if (opts.has(date))\n+                options.date = opts.valueOf(date);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jmod\/JmodTask.java","additions":24,"deletions":19,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-main.opt.source-date=Epoch source date to timestamp entries with in seconds\n+main.opt.date=Date and time to timestamp entries with specified in ISO 8601 format \n@@ -110,1 +110,2 @@\n-err.invalid.source.date=--source-date {0} is not a long integer\n+err.invalid.date=--date {0} is not a valid ISO 8601 date and time: {1} \n+err.date.before.epoch=--date {0} is before Epoch 1970-01-01T00:00:00\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jmod\/resources\/jmod.properties","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-.\\\" Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+.\\\" Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -217,6 +217,0 @@\n-.B \\f[CB]\\-\\-source\\-date=\\f[R]\\f[I]TIMESTAMP\\f[R]\n-The timestamp in seconds since the epoch to use for all created\n-or updated jmod entries.\n-.RS\n-.RE\n-.TP\n","filename":"src\/jdk.jlink\/share\/man\/jmod.1","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8276766\n+ * @summary Test timestamp via ZipEntry.get\/setTimeZoned()\n+ *\/\n+\n+import java.io.*;\n+import java.nio.file.*;\n+import java.time.*;\n+import java.util.*;\n+import java.util.zip.*;\n+\n+public class TestZonedTime {\n+    private static TimeZone tz0 = TimeZone.getDefault();\n+\n+    public static void main(String[] args) throws Throwable{\n+        try {\n+            ZonedDateTime zdt = ZonedDateTime.now();\n+\n+            test(zdt);    \/\/ now\n+            test(zdt.withYear(1968));\n+            test(zdt.withYear(1970));\n+            test(zdt.withYear(1982));\n+            test(zdt.withYear(2037));\n+            test(zdt.withYear(2100));\n+            test(zdt.withYear(2106));\n+\n+            TimeZone tz = TimeZone.getTimeZone(\"Asia\/Shanghai\");\n+            \/\/ dos time does not support < 1980, have to use\n+            \/\/ utc in mtime.\n+            testWithTZ(tz, zdt.withYear(1982));\n+            testWithTZ(tz, zdt.withYear(2037));\n+            testWithTZ(tz, zdt.withYear(2100));\n+            testWithTZ(tz, zdt.withYear(2106));\n+\n+            test(ZonedDateTime.of(2200, 04, 26, 2, 31, 52, 973, ZoneId.of(\"-05:00\")));\n+        } finally {\n+            TimeZone.setDefault(tz0);\n+        }\n+    }\n+\n+    static byte[] getBytes(ZonedDateTime mtime) throws Throwable {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ZipOutputStream zos = new ZipOutputStream(baos);\n+        ZipEntry ze = new ZipEntry(\"TestZonedTime.java\");\n+        ze.setTimeZoned(mtime);\n+        check(ze, mtime);\n+        zos.putNextEntry(ze);\n+        zos.write(new byte[] { 1, 2, 3, 4});\n+        zos.close();\n+        return baos.toByteArray();\n+    }\n+\n+    static void testWithTZ(TimeZone tz, ZonedDateTime zdt) throws Throwable {\n+       TimeZone.setDefault(tz);\n+       byte[] zbytes = getBytes(zdt);\n+       TimeZone.setDefault(tz0);\n+       test(zbytes, zdt);\n+    }\n+\n+    static void test(ZonedDateTime zdt) throws Throwable {\n+        test(getBytes(zdt), zdt);\n+    }\n+\n+    static void test(byte[] zbytes, ZonedDateTime expected) throws Throwable {\n+        System.out.printf(\"--------------------%nTesting: [%s]%n\", expected);\n+        \/\/ ZipInputStream\n+        ZipInputStream zis = new ZipInputStream(new ByteArrayInputStream(zbytes));\n+        ZipEntry ze = zis.getNextEntry();\n+        zis.close();\n+        check(ze, expected);\n+\n+        \/\/ ZipFile\n+        Path zpath = Paths.get(System.getProperty(\"test.dir\", \".\"),\n+                               \"TestZonedTime.zip\");\n+        try {\n+            Files.copy(new ByteArrayInputStream(zbytes), zpath);\n+            ZipFile zf = new ZipFile(zpath.toFile());\n+            ze = zf.getEntry(\"TestZonedTime.java\");\n+            check(ze, expected);\n+            zf.close();\n+        } finally {\n+            Files.deleteIfExists(zpath);\n+        }\n+    }\n+\n+    static void check(ZipEntry ze, ZonedDateTime expected) {\n+        long timeSeconds = ze.getTimeZoned(expected.getZone()).toEpochSecond();\n+        if ( timeSeconds >> 1\n+            != expected.toEpochSecond() >> 1) {\n+            throw new RuntimeException(\"Timestamp: storing mtime failed!\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/TestZonedTime.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -37,0 +37,2 @@\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n@@ -89,0 +91,1 @@\n+        File jarFileSourceDateBefore1980 = new File(\"JarEntryTimeSourceDateBefore1980.jar\");\n@@ -128,2 +131,2 @@\n-        \/\/ --source-date set to epoch seconds 1647302400 (15\/03\/2022)\n-        long sourceDate = 1647302400L;\n+        \/\/ --date set to 15\/03\/2022\n+        String sourceDate = \"2022-03-15T00:00:00+00:00\";\n@@ -133,1 +136,1 @@\n-                           \"--source-date\", String.valueOf(sourceDate),\n+                           \"--date\", sourceDate,\n@@ -137,0 +140,9 @@\n+        \/\/ Use a date before dostime 1980\/1\/1 in non-UTC zone\n+        String sourceDateBefore1980 = \"1976-03-15T01:02:03+02:00\";\n+        check(JAR_TOOL.run(System.out, System.err,\n+                           \"--create\",\n+                           \"--file\", jarFileSourceDateBefore1980.getName(),\n+                           \"--date\", sourceDateBefore1980,\n+                           dirOuter.getName()) == 0);\n+        check(jarFileSourceDateBefore1980.exists());\n+\n@@ -181,3 +193,19 @@\n-        checkFileTime(dirOuter.lastModified(), sourceDate * 1000);\n-        checkFileTime(dirInner.lastModified(), sourceDate * 1000);\n-        checkFileTime(fileInner.lastModified(), sourceDate * 1000);\n+        long sourceDateEpochMillis = ZonedDateTime.parse(sourceDate,\n+                               DateTimeFormatter.ISO_DATE_TIME).toEpochSecond() * 1000;\n+        checkFileTime(dirOuter.lastModified(), sourceDateEpochMillis);\n+        checkFileTime(dirInner.lastModified(), sourceDateEpochMillis);\n+        checkFileTime(fileInner.lastModified(), sourceDateEpochMillis);\n+\n+        check(cleanup(dirInner));\n+        check(cleanup(dirOuter));\n+\n+        \/\/ Extract jarFileSourceDateBefore1980 and check last modified values\n+        extractJar(jarFileSourceDateBefore1980, false);\n+        check(dirOuter.exists());\n+        check(dirInner.exists());\n+        check(fileInner.exists());\n+        long sourceDateBefore1980Millis = ZonedDateTime.parse(sourceDateBefore1980,\n+                               DateTimeFormatter.ISO_DATE_TIME).toEpochSecond() * 1000;\n+        checkFileTime(dirOuter.lastModified(), sourceDateBefore1980Millis);\n+        checkFileTime(dirInner.lastModified(), sourceDateBefore1980Millis);\n+        checkFileTime(fileInner.lastModified(), sourceDateBefore1980Millis);\n@@ -190,0 +218,1 @@\n+        check(jarFileSourceDateBefore1980.delete());\n","filename":"test\/jdk\/tools\/jar\/JarEntryTime.java","additions":35,"deletions":6,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -221,0 +221,2 @@\n+        Path jmod3 = MODS_DIR.resolve(\"foo3.jmod\");\n+        Path jmod4 = MODS_DIR.resolve(\"foo4.jmod\");\n@@ -223,0 +225,2 @@\n+        FileUtils.deleteFileIfExistsWithRetry(jmod3);\n+        FileUtils.deleteFileIfExistsWithRetry(jmod4);\n@@ -224,2 +228,2 @@\n-        \/\/ Use source date of epoch seconds 15\/03\/2022\n-        long sourceDate = 1647302400L;\n+        \/\/ Use source date of 15\/03\/2022\n+        String sourceDate = \"2022-03-15T00:00:00+00:00\";\n@@ -229,1 +233,1 @@\n-             \"--source-date\", String.valueOf(sourceDate),\n+             \"--date\", sourceDate,\n@@ -240,1 +244,1 @@\n-             \"--source-date\", String.valueOf(sourceDate),\n+             \"--date\", sourceDate,\n@@ -246,0 +250,35 @@\n+\n+        \/\/ Use a date before epoch and assert failure error\n+        sourceDate = \"1936-03-15T00:00:00+00:00\";\n+\n+        jmod(\"create\",\n+             \"--class-path\", cp,\n+             \"--date\", sourceDate,\n+             jmod3.toString())\n+            .assertFailure()\n+            .resultChecker(r -> {\n+                assertContains(r.output, \"is before Epoch 1970-01-01T00:00:00\");\n+            });\n+\n+        \/\/ Use a date before zip minimum dostime 1980-1-1 \n+        sourceDate = \"1976-03-15T01:02:03+02:00\";\n+\n+        jmod(\"create\",\n+             \"--class-path\", cp,\n+             \"--date\", sourceDate,\n+             jmod3.toString())\n+            .assertSuccess();\n+\n+        try {\n+            \/\/ Sleep 5 seconds to ensure zip timestamps might be different if they could be\n+            Thread.sleep(5000);\n+        } catch(InterruptedException ex) {}\n+\n+        jmod(\"create\",\n+             \"--class-path\", cp,\n+             \"--date\", sourceDate,\n+             jmod4.toString())\n+            .assertSuccess();\n+\n+        \/\/ Compare file byte content to see if they are identical\n+        assertSameContent(jmod3, jmod4);\n","filename":"test\/jdk\/tools\/jmod\/JmodTest.java","additions":43,"deletions":4,"binary":false,"changes":47,"status":"modified"}]}