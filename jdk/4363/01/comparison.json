{"files":[{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -476,0 +477,8 @@\n+\n+const HeapWord* ThreadLocalAllocBuffer::start_relaxed() const {\n+  return Atomic::load(&_start);\n+}\n+\n+const HeapWord* ThreadLocalAllocBuffer::top_relaxed() const {\n+  return Atomic::load(&_top);\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/threadLocalAllocBuffer.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -132,0 +132,4 @@\n+  \/\/ For external inspection.\n+  const HeapWord* start_relaxed() const;\n+  const HeapWord* top_relaxed() const;\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/threadLocalAllocBuffer.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,8 @@\n-    size_t used_bytes = tlab().used_bytes();\n+    \/\/ These reads are unsynchronized and unordered with the thread updating its tlab pointers.\n+    \/\/ Use only if top > start && used_bytes <= max_tlab_size_bytes.\n+    const HeapWord* const top = tlab().top_relaxed();\n+    const HeapWord* const start = tlab().start_relaxed();\n+    if (top <= start) {\n+      return allocated_bytes;\n+    }\n+    const size_t used_bytes = pointer_delta(top, start, 1);\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}