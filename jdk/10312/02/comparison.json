{"files":[{"patch":"@@ -125,1 +125,1 @@\n-    : _klass(klass), _cld(cld) {}\n+    : _next(NULL), _klass(klass), _cld(cld) {}\n@@ -140,1 +140,1 @@\n-  const ClassLoaderData* _cld;\n+  const ClassLoaderData* _cld; \/\/ May be NULL if loader never loaded anything\n@@ -157,2 +157,4 @@\n-  void print_with_childs(outputStream* st, BranchTracker& branchtracker,\n-      bool print_classes, bool verbose) const {\n+  \/\/ Returns Klass of loader; NULL for bootstrap loader\n+  const Klass* loader_klass() const {\n+    return (_loader_oop != NULL) ? _loader_oop->klass() : NULL;\n+  }\n@@ -160,1 +162,5 @@\n-    ResourceMark rm;\n+  \/\/ Returns ResourceArea-allocated class name of loader class; \"\" if there is no klass (bootstrap loader)\n+  const char* loader_class_name() const {\n+    const Klass* klass = loader_klass();\n+    return klass != NULL ? klass->external_name() : \"\";\n+  }\n@@ -162,4 +168,15 @@\n-    if (_cld == NULL) {\n-      \/\/ Not sure how this could happen: we added a preliminary node for a parent but then never encountered\n-      \/\/ its CLD?\n-      return;\n+  \/\/ Returns oop of loader name; NULL for bootstrap; NULL if no name was set\n+  oop loader_name_oop() const {\n+    return (_loader_oop != NULL) ? java_lang_ClassLoader::name(_loader_oop) : NULL;\n+  }\n+\n+  \/\/ Returns ResourceArea-allocated name of loader, \"\" if none is set\n+  const char* loader_name() const {\n+    oop name_oop = loader_name_oop();\n+    return name_oop != NULL ? java_lang_String::as_utf8_string(name_oop) : \"\";\n+  }\n+\n+  bool is_bootstrap() const {\n+    if (_loader_oop == NULL) {\n+      assert(_cld != NULL && _cld->is_boot_class_loader_data(), \"bootstrap loader must have CLD\");\n+      return true;\n@@ -167,0 +184,9 @@\n+    return false;\n+  }\n+\n+  void print_with_child_nodes(outputStream* st, BranchTracker& branchtracker,\n+      bool print_classes, bool verbose) const {\n+\n+    assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n+\n+    ResourceMark rm;\n@@ -169,2 +195,3 @@\n-    const Klass* const loader_klass = _cld->class_loader_klass();\n-    const Symbol* const loader_name = _cld->name();\n+    const Klass* const the_loader_klass = loader_klass();\n+    const char* const the_loader_class_name = loader_class_name();\n+    const char* const the_loader_name = loader_name();\n@@ -176,1 +203,1 @@\n-    if (_cld->is_the_null_class_loader_data()) {\n+    if (is_bootstrap()) {\n@@ -179,3 +206,2 @@\n-      assert(!_cld->has_class_mirror_holder(), \"_cld must be the primary cld\");\n-      if (loader_name != NULL) {\n-        st->print(\" \\\"%s\\\",\", loader_name->as_C_string());\n+      if (the_loader_name[0] != '\\0') {\n+        st->print(\" \\\"%s\\\",\", the_loader_name);\n@@ -183,1 +209,1 @@\n-      st->print(\" %s\", loader_klass != NULL ? loader_klass->external_name() : \"??\");\n+      st->print(\" %s\", the_loader_class_name);\n@@ -213,1 +239,1 @@\n-        st->print_cr(\"%*s \" PTR_FORMAT, indentation, \"Loader Klass:\", p2i(loader_klass));\n+        st->print_cr(\"%*s \" PTR_FORMAT, indentation, \"Loader Klass:\", p2i(the_loader_klass));\n@@ -222,0 +248,1 @@\n+          assert(_cld != NULL, \"we have classes, we should have a CLD\");\n@@ -246,0 +273,1 @@\n+          assert(_cld != NULL, \"we have classes, we should have a CLD\");\n@@ -279,1 +307,1 @@\n-      c->print_with_childs(st, branchtracker, print_classes, verbose);\n+      c->print_with_child_nodes(st, branchtracker, print_classes, verbose);\n@@ -288,1 +316,1 @@\n-  bool can_fold_into(LoaderTreeNode* target_node) const {\n+  bool can_fold_into(const LoaderTreeNode* target_node) const {\n@@ -290,2 +318,13 @@\n-    return _cld->class_loader_klass() == target_node->_cld->class_loader_klass() &&\n-           _cld->name() == target_node->_cld->name();\n+\n+    \/\/ Must have the same non-null klass\n+    const Klass* k = loader_klass();\n+    if (k == NULL || k != target_node->loader_klass()) {\n+      return false;\n+    }\n+\n+    \/\/ Must have the same loader name, or none\n+    if (::strcmp(loader_name(), target_node->loader_name()) != 0) {\n+      return false;\n+    }\n+\n+    return true;\n@@ -303,0 +342,1 @@\n+    assert(_cld == NULL, \"there should be only one primary CLD per loader\");\n@@ -337,8 +377,0 @@\n-  const ClassLoaderData* cld() const {\n-    return _cld;\n-  }\n-\n-  const oop loader_oop() const {\n-    return _loader_oop;\n-  }\n-\n@@ -367,0 +399,1 @@\n+    ResourceMark rm;\n@@ -392,1 +425,1 @@\n-  void print_with_childs(outputStream* st, bool print_classes, bool print_add_info) const {\n+  void print_with_child_nodes(outputStream* st, bool print_classes, bool print_add_info) const {\n@@ -394,1 +427,1 @@\n-    print_with_childs(st, bwt, print_classes, print_add_info);\n+    print_with_child_nodes(st, bwt, print_classes, print_add_info);\n@@ -469,1 +502,1 @@\n-    _root->print_with_childs(st, _print_classes, _verbose);\n+    _root->print_with_child_nodes(st, _print_classes, _verbose);\n@@ -486,1 +519,0 @@\n-      assert(info->cld() == NULL, \"there should be only one primary CLD per loader\");\n","filename":"src\/hotspot\/share\/classfile\/classLoaderHierarchyDCmd.cpp","additions":65,"deletions":33,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -51,0 +51,13 @@\n+    class EmptyDelegatingLoader extends ClassLoader {\n+        EmptyDelegatingLoader(String name, ClassLoader parent) {\n+            super(name, parent);\n+        }\n+    }\n+\n+    static void loadTestClassInLoaderAndCheck(String classname, ClassLoader loader) throws ClassNotFoundException {\n+        Class<?> c = Class.forName(classname, true, loader);\n+        if (c.getClassLoader() != loader) {\n+            Assert.fail(classname + \" defined by wrong classloader: \" + c.getClassLoader());\n+        }\n+    }\n+\n@@ -63,0 +76,1 @@\n+        \/\/ A) one unnamed, two named loaders\n@@ -64,5 +78,0 @@\n-        Class<?> c1 = Class.forName(\"TestClass2\", true, unnamed_cl);\n-        if (c1.getClassLoader() != unnamed_cl) {\n-            Assert.fail(\"TestClass defined by wrong classloader: \" + c1.getClassLoader());\n-        }\n-\n@@ -70,5 +79,0 @@\n-        Class<?> c2 = Class.forName(\"TestClass2\", true, named_cl);\n-        if (c2.getClassLoader() != named_cl) {\n-            Assert.fail(\"TestClass defined by wrong classloader: \" + c2.getClassLoader());\n-        }\n-\n@@ -76,4 +80,35 @@\n-        Class<?> c3 = Class.forName(\"TestClass2\", true, named_child_cl);\n-        if (c3.getClassLoader() != named_child_cl) {\n-            Assert.fail(\"TestClass defined by wrong classloader: \" + c3.getClassLoader());\n-        }\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", unnamed_cl);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_cl);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_cl);\n+\n+        \/\/ B) A named CL with empty loaders as parents (JDK-8293156)\n+        EmptyDelegatingLoader emptyLoader1 = new EmptyDelegatingLoader(\"EmptyLoader1\", null);\n+        EmptyDelegatingLoader emptyLoader2 = new EmptyDelegatingLoader(\"EmptyLoader2\", emptyLoader1);\n+        ClassLoader named_child_2_cl = new TestClassLoader(\"Child2\", emptyLoader2);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_2_cl);\n+\n+        \/\/ C) Test output for several class loaders, same class, same name, empty parents,\n+        \/\/    and all these should be folded by default.\n+        EmptyDelegatingLoader emptyLoader3 = new EmptyDelegatingLoader(\"EmptyLoader3\", null);\n+        EmptyDelegatingLoader emptyLoader4 = new EmptyDelegatingLoader(\"EmptyLoader4\", emptyLoader3);\n+        ClassLoader named_child_3_cl = new TestClassLoader(\"ChildX\", emptyLoader4); \/\/ Same names\n+        ClassLoader named_child_4_cl = new TestClassLoader(\"ChildX\", emptyLoader4);\n+        ClassLoader named_child_5_cl = new TestClassLoader(\"ChildX\", emptyLoader4);\n+        ClassLoader named_child_6_cl = new TestClassLoader(\"ChildX\", emptyLoader4);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_3_cl);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_4_cl);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_5_cl);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_6_cl);\n+\n+        \/\/ D) Test output for several *unnamed* class loaders, same class, same parents,\n+        \/\/    and all these should be folded by default too.\n+        EmptyDelegatingLoader emptyLoader5 = new EmptyDelegatingLoader(null, null);\n+        EmptyDelegatingLoader emptyLoader6 = new EmptyDelegatingLoader(null, emptyLoader5);\n+        ClassLoader named_child_7_cl = new TestClassLoader(null, emptyLoader6); \/\/ Same names\n+        ClassLoader named_child_8_cl = new TestClassLoader(null, emptyLoader6);\n+        ClassLoader named_child_9_cl = new TestClassLoader(null, emptyLoader6);\n+        ClassLoader named_child_10_cl = new TestClassLoader(null, emptyLoader6);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_7_cl);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_8_cl);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_9_cl);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_10_cl);\n@@ -83,4 +118,19 @@\n-        output.shouldContain(\"<bootstrap>\");\n-        output.shouldMatch(\".*TestClassLoader\");\n-        output.shouldMatch(\"Kevin.*TestClassLoader\");\n-        output.shouldMatch(\"Bill.*TestClassLoader\");\n+        \/\/ (A)\n+        output.shouldContain(\"+-- <bootstrap>\");\n+        output.shouldContain(\"      +-- \\\"platform\\\", jdk.internal.loader.ClassLoaders$PlatformClassLoader\");\n+        output.shouldContain(\"      |     +-- \\\"app\\\", jdk.internal.loader.ClassLoaders$AppClassLoader\");\n+        output.shouldContain(\"      +-- \\\"Kevin\\\", ClassLoaderHierarchyTest$TestClassLoader\");\n+        output.shouldContain(\"      +-- ClassLoaderHierarchyTest$TestClassLoader\");\n+        output.shouldContain(\"      |     +-- \\\"Bill\\\", ClassLoaderHierarchyTest$TestClassLoader\");\n+        \/\/ (B)\n+        output.shouldContain(\"      +-- \\\"EmptyLoader1\\\", ClassLoaderHierarchyTest$EmptyDelegatingLoader\");\n+        output.shouldContain(\"      |     +-- \\\"EmptyLoader2\\\", ClassLoaderHierarchyTest$EmptyDelegatingLoader\");\n+        output.shouldContain(\"      |           +-- \\\"Child2\\\", ClassLoaderHierarchyTest$TestClassLoader\");\n+        \/\/ (C)\n+        output.shouldContain(\"      +-- \\\"EmptyLoader3\\\", ClassLoaderHierarchyTest$EmptyDelegatingLoader\");\n+        output.shouldContain(\"      |     +-- \\\"EmptyLoader4\\\", ClassLoaderHierarchyTest$EmptyDelegatingLoader\");\n+        output.shouldContain(\"      |           +-- \\\"ChildX\\\", ClassLoaderHierarchyTest$TestClassLoader (+ 3 more)\");\n+        \/\/ (D)\n+        output.shouldContain(\"      +-- ClassLoaderHierarchyTest$EmptyDelegatingLoader\");\n+        output.shouldContain(\"            +-- ClassLoaderHierarchyTest$EmptyDelegatingLoader\");\n+        output.shouldContain(\"                  +-- ClassLoaderHierarchyTest$TestClassLoader (+ 3 more)\");\n@@ -92,3 +142,2 @@\n-        output.shouldMatch(\".*TestClassLoader\");\n-        output.shouldMatch(\"Kevin.*TestClassLoader\");\n-        output.shouldMatch(\"Bill.*TestClassLoader\");\n+        output.shouldContain(\"java.lang.Enum\");\n+        output.shouldContain(\"java.lang.NullPointerException\");\n@@ -96,0 +145,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/ClassLoaderHierarchyTest.java","additions":71,"deletions":21,"binary":false,"changes":92,"status":"modified"}]}