{"files":[{"patch":"@@ -44,1 +44,0 @@\n-#include \"metaprogramming\/enableIf.hpp\"\n@@ -65,0 +64,1 @@\n+#include \"utilities\/parseMemorySize.hpp\"\n@@ -748,109 +748,0 @@\n-template <typename T, ENABLE_IF(std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 4)> \/\/ signed 32-bit\n-static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n-  \/\/ Don't use strtol -- on 64-bit builds, \"long\" could be either 32- or 64-bits\n-  \/\/ so the range tests could be tautological and might cause compiler warnings.\n-  STATIC_ASSERT(sizeof(long long) >= 8); \/\/ C++ specification\n-  errno = 0; \/\/ errno is thread safe\n-  long long v = strtoll(s, endptr, base);\n-  if (errno != 0 || v < min_jint || v > max_jint) {\n-    return false;\n-  }\n-  *result = static_cast<T>(v);\n-  return true;\n-}\n-\n-template <typename T, ENABLE_IF(!std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 4)> \/\/ unsigned 32-bit\n-static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n-  if (s[0] == '-') {\n-    return false;\n-  }\n-  \/\/ Don't use strtoul -- same reason as above.\n-  STATIC_ASSERT(sizeof(unsigned long long) >= 8); \/\/ C++ specification\n-  errno = 0; \/\/ errno is thread safe\n-  unsigned long long v = strtoull(s, endptr, base);\n-  if (errno != 0 || v > max_juint) {\n-    return false;\n-  }\n-  *result = static_cast<T>(v);\n-  return true;\n-}\n-\n-template <typename T, ENABLE_IF(std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 8)> \/\/ signed 64-bit\n-static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n-  errno = 0; \/\/ errno is thread safe\n-  *result = strtoll(s, endptr, base);\n-  return errno == 0;\n-}\n-\n-template <typename T, ENABLE_IF(!std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 8)> \/\/ unsigned 64-bit\n-static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n-  if (s[0] == '-') {\n-    return false;\n-  }\n-  errno = 0; \/\/ errno is thread safe\n-  *result = strtoull(s, endptr, base);\n-  return errno == 0;\n-}\n-\n-template<typename T>\n-static bool multiply_by_1k(T& n) {\n-  if (n >= std::numeric_limits<T>::min() \/ 1024 &&\n-      n <= std::numeric_limits<T>::max() \/ 1024) {\n-    n *= 1024;\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}\n-\n-\/\/ All of the integral types that can be used for command line options:\n-\/\/   int, uint, intx, uintx, uint64_t, size_t\n-\/\/\n-\/\/ In all supported platforms, these types can be mapped to only 4 native types:\n-\/\/    {signed, unsigned} x {32-bit, 64-bit}\n-\/\/\n-\/\/ We use SFINAE to pick the correct parse_integer_impl() function\n-template<typename T>\n-static bool parse_integer(const char *s, T* result) {\n-  if (!isdigit(s[0]) && s[0] != '-') {\n-    \/\/ strtoll\/strtoull may allow leading spaces. Forbid it.\n-    return false;\n-  }\n-\n-  T n = 0;\n-  bool is_hex = (s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) ||\n-                (s[0] == '-' && s[1] == '0' && (s[2] == 'x' || s[3] == 'X'));\n-  char* remainder;\n-\n-  if (!parse_integer_impl(s, &remainder, (is_hex ? 16 : 10), &n)) {\n-    return false;\n-  }\n-\n-  \/\/ Fail if no number was read at all or if the remainder contains more than a single non-digit character.\n-  if (remainder == s || strlen(remainder) > 1) {\n-    return false;\n-  }\n-\n-  switch (*remainder) {\n-    case 'T': case 't':\n-      if (!multiply_by_1k(n)) return false;\n-      \/\/ fall-through\n-    case 'G': case 'g':\n-      if (!multiply_by_1k(n)) return false;\n-      \/\/ fall-through\n-    case 'M': case 'm':\n-      if (!multiply_by_1k(n)) return false;\n-      \/\/ fall-through\n-    case 'K': case 'k':\n-      if (!multiply_by_1k(n)) return false;\n-      break;\n-    case '\\0':\n-      break;\n-    default:\n-      return false;\n-  }\n-\n-  *result = n;\n-  return true;\n-}\n-\n@@ -858,1 +749,1 @@\n-  return parse_integer(s, result);\n+  return parse_argument_memory_size(s, result);\n@@ -920,1 +811,1 @@\n-    if (parse_integer(value, &v)) {\n+    if (parse_argument_memory_size(value, &v)) {\n@@ -925,1 +816,1 @@\n-    if (parse_integer(value, &v)) {\n+    if (parse_argument_memory_size(value, &v)) {\n@@ -930,1 +821,1 @@\n-    if (parse_integer(value, &v)) {\n+    if (parse_argument_memory_size(value, &v)) {\n@@ -935,1 +826,1 @@\n-    if (parse_integer(value, &v)) {\n+    if (parse_argument_memory_size(value, &v)) {\n@@ -940,1 +831,1 @@\n-    if (parse_integer(value, &v)) {\n+    if (parse_argument_memory_size(value, &v)) {\n@@ -945,1 +836,1 @@\n-    if (parse_integer(value, &v)) {\n+    if (parse_argument_memory_size(value, &v)) {\n@@ -2120,1 +2011,1 @@\n-  if (!parse_integer(value, &n)) {\n+  if (!parse_argument_memory_size(value, &n)) {\n@@ -2179,1 +2070,1 @@\n-  if (!parse_integer(s, long_arg)) return arg_unreadable;\n+  if (!parse_argument_memory_size(s, long_arg)) return arg_unreadable;\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":10,"deletions":119,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+#define INT32_FORMAT_X           \"0x%\"        PRIx32\n@@ -116,0 +117,1 @@\n+#define UINT32_FORMAT_X          \"0x%\"        PRIx32\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_PARSE_INTEGER_HPP\n+#define SHARE_UTILITIES_PARSE_INTEGER_HPP\n+\n+#include \"metaprogramming\/enableIf.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+#include <errno.h>\n+#include <limits>\n+#include <stdlib.h>\n+\n+template <typename T, ENABLE_IF(std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 4)> \/\/ signed 32-bit\n+inline bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n+  \/\/ Don't use strtol -- on 64-bit builds, \"long\" could be either 32- or 64-bits\n+  \/\/ so the range tests could be tautological and might cause compiler warnings.\n+  STATIC_ASSERT(sizeof(long long) >= 8); \/\/ C++ specification\n+  errno = 0; \/\/ errno is thread safe\n+  long long v = strtoll(s, endptr, base);\n+  if (errno != 0 || v < min_jint || v > max_jint) {\n+    return false;\n+  }\n+  *result = static_cast<T>(v);\n+  return true;\n+}\n+\n+template <typename T, ENABLE_IF(!std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 4)> \/\/ unsigned 32-bit\n+inline bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n+  if (s[0] == '-') {\n+    return false;\n+  }\n+  \/\/ Don't use strtoul -- same reason as above.\n+  STATIC_ASSERT(sizeof(unsigned long long) >= 8); \/\/ C++ specification\n+  errno = 0; \/\/ errno is thread safe\n+  unsigned long long v = strtoull(s, endptr, base);\n+  if (errno != 0 || v > max_juint) {\n+    return false;\n+  }\n+  *result = static_cast<T>(v);\n+  return true;\n+}\n+\n+template <typename T, ENABLE_IF(std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 8)> \/\/ signed 64-bit\n+inline bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n+  errno = 0; \/\/ errno is thread safe\n+  *result = strtoll(s, endptr, base);\n+  return errno == 0;\n+}\n+\n+template <typename T, ENABLE_IF(!std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 8)> \/\/ unsigned 64-bit\n+inline bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n+  if (s[0] == '-') {\n+    return false;\n+  }\n+  errno = 0; \/\/ errno is thread safe\n+  *result = strtoull(s, endptr, base);\n+  return errno == 0;\n+}\n+\n+template <typename T>\n+inline bool parse_integer(const char *s, char **endptr, int base, T* result) {\n+  bool rc = parse_integer_impl(s, endptr, base, result);\n+  \/\/ We fail also if we have not parsed anything\n+  rc = rc && (*endptr > s);\n+  return rc;\n+}\n+\n+#endif \/\/ SHARE_UTILITIES_PARSE_INTEGER_HPP\n","filename":"src\/hotspot\/share\/utilities\/parseInteger.hpp","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_PARSE_MEMORY_SIZE_HPP\n+#define SHARE_UTILITIES_PARSE_MEMORY_SIZE_HPP\n+\n+#include \"metaprogramming\/enableIf.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/parseInteger.hpp\"\n+\n+#include <errno.h>\n+#include <limits>\n+#include <stdlib.h>\n+\n+\/\/ *************************************************************************\n+\/\/ ** Attention compatibility!                                            **\n+\/\/ ** These functions are used to parse JVM arguments (-XX). Be careful   **\n+\/\/ ** with behavioral changes here.                                       **\n+\/\/ *************************************************************************\n+\n+\/\/ Helper for parse_memory_size\n+template<typename T>\n+inline bool multiply_by_1k(T& n) {\n+  if (n >= std::numeric_limits<T>::min() \/ 1024 &&\n+      n <= std::numeric_limits<T>::max() \/ 1024) {\n+    n *= 1024;\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+\/\/ All of the integral types that can be used for command line options:\n+\/\/   int, uint, intx, uintx, uint64_t, size_t\n+\/\/\n+\/\/ In all supported platforms, these types can be mapped to only 4 native types:\n+\/\/    {signed, unsigned} x {32-bit, 64-bit}\n+\/\/\n+\/\/ We use SFINAE to pick the correct parse_integer_impl() function\n+\/\/\n+\/\/ This function will parse until it encounters unparseable parts, then\n+\/\/ stop. If it read no valid memory size, it will fail.\n+\/\/\n+\/\/ Example: \"1024M:oom\" will yield true, result=1G, endptr pointing to \":oom\"\n+\n+template<typename T>\n+static bool parse_memory_size(const char *s, char **endptr, T* result) {\n+\n+  if (!isdigit(s[0]) && s[0] != '-') {\n+    \/\/ strtoll\/strtoull may allow leading spaces. Forbid it.\n+    return false;\n+  }\n+\n+  T n = 0;\n+  bool is_hex = (s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) ||\n+                (s[0] == '-' && s[1] == '0' && (s[2] == 'x' || s[3] == 'X'));\n+  char* remainder;\n+\n+  if (!parse_integer(s, &remainder, (is_hex ? 16 : 10), &n)) {\n+    return false;\n+  }\n+\n+  switch (*remainder) {\n+    case 'T': case 't':\n+      if (!multiply_by_1k(n)) return false;\n+      \/\/ fall-through\n+    case 'G': case 'g':\n+      if (!multiply_by_1k(n)) return false;\n+      \/\/ fall-through\n+    case 'M': case 'm':\n+      if (!multiply_by_1k(n)) return false;\n+      \/\/ fall-through\n+    case 'K': case 'k':\n+      if (!multiply_by_1k(n)) return false;\n+      remainder ++; \/\/ shave off parsed unit char\n+      break;\n+    default:\n+      \/\/ nothing. Return remainder unparsed.\n+      break;\n+  };\n+\n+  *result = n;\n+  *endptr = remainder;\n+  return true;\n+}\n+\n+\/\/ Used for parsing JVM argument sizes (see argument.cpp)\n+\/\/ In contrast to parse_memory_size(s, endptr, result), this variant requires the full\n+\/\/ string to match. No remainder are allowed here.\n+\/\/ Example: \"100m\" - okay, \"100m:oom\" -> not okay\n+template<typename T>\n+static bool parse_argument_memory_size(const char *s, T* result) {\n+  char* remainder;\n+  bool rc = parse_memory_size(s, &remainder, result);\n+  rc = rc && (*remainder == '\\0');\n+  return rc;\n+}\n+\n+#endif \/\/ SHARE_UTILITIES_PARSE_MEMORY_SIZE_HPP\n","filename":"src\/hotspot\/share\/utilities\/parseMemorySize.hpp","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -59,0 +59,2 @@\n+#define LOG_HERE(s, ...) { printf(s, __VA_ARGS__); printf(\"\\n\"); fflush(stdout); }\n+\n","filename":"test\/hotspot\/gtest\/testutils.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -243,0 +243,1 @@\n+  check_format(INT32_FORMAT_X,         0x123,             \"0x123\");\n@@ -247,0 +248,1 @@\n+  check_format(UINT32_FORMAT_X,        0x123u,            \"0x123\");\n","filename":"test\/hotspot\/gtest\/utilities\/test_globalDefinitions.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jvm_io.h\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/parseMemorySize.hpp\"\n+#include \"testutils.hpp\"\n+#include \"unittest.hpp\"\n+\n+template <typename T> const char* type_name();\n+template <> const char* type_name<uint64_t>() { return \"uint64_t\"; }\n+template <> const char* type_name<uint32_t>() { return \"uint32_t\"; }\n+template <> const char* type_name<int64_t>()  { return \"int64_t\"; }\n+template <> const char* type_name<int32_t>()  { return \"int32_t\"; }\n+\n+\/\/#define LOG(s, ...) LOG_HERE(s, __VA_ARGS__)\n+#define LOG(s, ...)\n+\n+template <typename T>\n+static void do_test_valid(T expected_value, const char* pattern) {\n+  LOG(\"%s: \\\"%s\\\", expect: \" UINT64_FORMAT \"(\" UINT64_FORMAT_X \")\", type_name<T>(), pattern,\n+      (uint64_t)expected_value, (uint64_t)expected_value);\n+  T value = 17;\n+  char* end = nullptr;\n+\n+  stringStream ss;\n+  ss.print_raw(pattern);\n+\n+  bool rc = parse_memory_size(ss.base(), &end, &value);\n+  ASSERT_TRUE(rc);\n+  ASSERT_EQ(value, expected_value);\n+\n+  rc = parse_argument_memory_size(ss.base(), &value);\n+  ASSERT_TRUE(rc);\n+  ASSERT_EQ(value, expected_value);\n+\n+  \/\/ Now test with a trailing pattern.\n+  \/\/ parse_memory_size() should return remainder pointer,\n+  \/\/ parse_argument_memory_size() should flatly refuse to parse this.\n+  ss.print(\":-)\");\n+  rc = parse_memory_size(ss.base(), &end, &value);\n+  ASSERT_TRUE(rc);\n+  ASSERT_EQ(value, expected_value);\n+  ASSERT_EQ(end, ss.base() + strlen(pattern));\n+  ASSERT_EQ(strcmp(end, \":-)\"), 0);\n+\n+  rc = parse_argument_memory_size(ss.base(), &value);\n+  ASSERT_FALSE(rc);\n+}\n+\n+template <typename T>\n+static void test_valid(T value, bool hex, T scale, const char* unit) {\n+  if ((std::numeric_limits<T>::max() \/ scale) >= value) {\n+    T expected_result = value * scale;\n+    stringStream ss;\n+    if (hex) {\n+      ss.print(UINT64_FORMAT_X \"%s\", (uint64_t)value, unit);  \/\/ e.g. \"0xFFFF\"\n+    } else {\n+      ss.print(UINT64_FORMAT \"%s\", (uint64_t)value, unit);    \/\/ e.g. \"65535\"\n+    }\n+    do_test_valid((T)expected_result, ss.base());\n+  }\n+}\n+\n+template <typename T>\n+static void test_valid_all_units(T value, bool hex) {\n+  test_valid(value, hex, (T)1, \"\");\n+  test_valid(value, hex, (T)K, \"k\");\n+  test_valid(value, hex, (T)K, \"K\");\n+  test_valid(value, hex, (T)M, \"m\");\n+  test_valid(value, hex, (T)M, \"M\");\n+  test_valid(value, hex, (T)G, \"g\");\n+  test_valid(value, hex, (T)G, \"G\");\n+  if (sizeof(T) > 4) {\n+    test_valid(value, hex, (T)((uint64_t)G * 1024), \"t\");\n+    test_valid(value, hex, (T)((uint64_t)G * 1024), \"T\");\n+  }\n+}\n+\n+template <typename T>\n+static void test_valid_all_power_of_twos() {\n+  for (int hex = 0; hex < 3; hex ++) {\n+    for (T i = 1; i != 0; i <<= 2) {\n+      test_valid_all_units(i - 1, hex == 1);\n+      test_valid_all_units(i, hex == 1);\n+      test_valid_all_units(i + 1, hex == 1);\n+    }\n+  }\n+}\n+\n+TEST(ParseMemorySize, positives) {\n+  test_valid_all_power_of_twos<uint64_t>();\n+  test_valid_all_power_of_twos<uint32_t>();\n+  test_valid_all_power_of_twos<int64_t>();\n+  test_valid_all_power_of_twos<int32_t>();\n+}\n+\n+\/\/ Test invalids.\n+\/\/ Note that parse_argument_memory_size is more restrictive than parse_memory_size, because\n+\/\/ the latter accepts trailing content.\n+\n+static void do_test_invalid_both(const char* pattern) {\n+  uint64_t value = 4711;\n+  char* end = nullptr;\n+\n+  LOG(\"%s\\n\", pattern);\n+\n+  bool rc = parse_memory_size(pattern, &end, &value);\n+  EXPECT_FALSE(rc);\n+  rc = parse_argument_memory_size(pattern, &value);\n+  EXPECT_FALSE(rc);\n+}\n+\n+static void do_test_invalid_for_parse_arguments(const char* pattern) {\n+  uint64_t value = 4711;\n+  char* end = nullptr;\n+\n+  LOG(\"%s\\n\", pattern);\n+\n+  bool rc = parse_memory_size(pattern, &end, &value);\n+  ASSERT_TRUE(rc);\n+  rc = parse_argument_memory_size(pattern, &value);\n+  ASSERT_FALSE(rc);\n+}\n+\n+TEST(ParseMemorySize, negatives_both) {\n+  do_test_invalid_both(\"\");\n+  do_test_invalid_both(\"abc\");\n+\n+  do_test_invalid_for_parse_arguments(\"100 M\"); \/\/ parse_memory_size would see \"100\", parse_argument_memory_size would reject it\n+  do_test_invalid_for_parse_arguments(\"100X\");  \/\/ parse_memory_size would see \"100\", parse_argument_memory_size would reject it\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_parse_memory_size.cpp","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"}]}