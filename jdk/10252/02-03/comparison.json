{"files":[{"patch":"@@ -64,1 +64,1 @@\n-#include \"utilities\/parseMemorySize.hpp\"\n+#include \"utilities\/parseInteger.hpp\"\n@@ -749,1 +749,1 @@\n-  return parse_argument_memory_size(s, result);\n+  return parse_integer(s, result);\n@@ -811,1 +811,1 @@\n-    if (parse_argument_memory_size(value, &v)) {\n+    if (parse_integer(value, &v)) {\n@@ -816,1 +816,1 @@\n-    if (parse_argument_memory_size(value, &v)) {\n+    if (parse_integer(value, &v)) {\n@@ -821,1 +821,1 @@\n-    if (parse_argument_memory_size(value, &v)) {\n+    if (parse_integer(value, &v)) {\n@@ -826,1 +826,1 @@\n-    if (parse_argument_memory_size(value, &v)) {\n+    if (parse_integer(value, &v)) {\n@@ -831,1 +831,1 @@\n-    if (parse_argument_memory_size(value, &v)) {\n+    if (parse_integer(value, &v)) {\n@@ -836,1 +836,1 @@\n-    if (parse_argument_memory_size(value, &v)) {\n+    if (parse_integer(value, &v)) {\n@@ -2011,1 +2011,1 @@\n-  if (!parse_argument_memory_size(value, &n)) {\n+  if (!parse_integer(value, &n)) {\n@@ -2070,1 +2070,1 @@\n-  if (!parse_argument_memory_size(s, long_arg)) return arg_unreadable;\n+  if (!parse_integer(s, long_arg)) return arg_unreadable;\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -38,0 +38,7 @@\n+\/\/ *************************************************************************\n+\/\/ ** Attention compatibility!                                            **\n+\/\/ ** These functions are used to parse JVM arguments (-XX). Be careful   **\n+\/\/ ** with behavioral changes here.                                       **\n+\/\/ *************************************************************************\n+\n+\n@@ -85,5 +92,78 @@\n-template <typename T>\n-inline bool parse_integer(const char *s, char **endptr, int base, T* result) {\n-  bool rc = parse_integer_impl(s, endptr, base, result);\n-  \/\/ We fail also if we have not parsed anything\n-  rc = rc && (*endptr > s);\n+\n+\/\/ Helper for parse_memory_size\n+template<typename T>\n+inline bool multiply_by_1k(T& n) {\n+  if (n >= std::numeric_limits<T>::min() \/ 1024 &&\n+      n <= std::numeric_limits<T>::max() \/ 1024) {\n+    n *= 1024;\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+\/\/ Parses a memory size in the form \"<number>[<unit>]\" with valid units being\n+\/\/ \"k\", \"K\", \"m\", \"M\", \"g\", \"G\", \"t\", \"T\". Unit omitted means bytes. If unit is given,\n+\/\/ no space is allowed between number and unit. Number can be in either decimal form\n+\/\/ or in hexadecimal form, the latter must start with \"0x\".\n+\/\/\n+\/\/ Valid template arguments for T are signed\/unsigned 32\/64-bit values.\n+\/\/\n+\/\/ This function will parse until it encounters unparseable parts, then\n+\/\/ stop. If it read no valid memory size, it will fail.\n+\/\/\n+\/\/ Example: \"1024M:oom\" will yield true, result=1G, endptr pointing to \":oom\"\n+\n+template<typename T>\n+static bool parse_integer(const char *s, char **endptr, T* result) {\n+\n+  if (!isdigit(s[0]) && s[0] != '-') {\n+    \/\/ strtoll\/strtoull may allow leading spaces. Forbid it.\n+    return false;\n+  }\n+\n+  T n = 0;\n+  bool is_hex = (s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) ||\n+                (s[0] == '-' && s[1] == '0' && (s[2] == 'x' || s[3] == 'X'));\n+  char* remainder;\n+\n+  if (!parse_integer_impl<T>(s, &remainder, (is_hex ? 16 : 10), &n)) {\n+    return false;\n+  }\n+  \/\/ Nothing parsed? That is an error too.\n+  if (remainder == s) {\n+    return false;\n+  }\n+\n+  switch (*remainder) {\n+    case 'T': case 't':\n+      if (!multiply_by_1k(n)) return false;\n+      \/\/ fall-through\n+    case 'G': case 'g':\n+      if (!multiply_by_1k(n)) return false;\n+      \/\/ fall-through\n+    case 'M': case 'm':\n+      if (!multiply_by_1k(n)) return false;\n+      \/\/ fall-through\n+    case 'K': case 'k':\n+      if (!multiply_by_1k(n)) return false;\n+      remainder ++; \/\/ shave off parsed unit char\n+      break;\n+    default:\n+      \/\/ nothing. Return remainder unparsed.\n+      break;\n+  };\n+\n+  *result = n;\n+  *endptr = remainder;\n+  return true;\n+}\n+\n+\/\/ Same as parse_integer(const char *s, char **endptr, T* result), but does not allow unrecognizable\n+\/\/ characters. No remainder are allowed here.\n+\/\/ Example: \"100m\" - okay, \"100m:oom\" -> not okay\n+template<typename T>\n+static bool parse_integer(const char *s, T* result) {\n+  char* remainder;\n+  bool rc = parse_integer(s, &remainder, result);\n+  rc = rc && (*remainder == '\\0');\n","filename":"src\/hotspot\/share\/utilities\/parseInteger.hpp","additions":85,"deletions":5,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2022 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_UTILITIES_PARSE_MEMORY_SIZE_HPP\n-#define SHARE_UTILITIES_PARSE_MEMORY_SIZE_HPP\n-\n-#include \"metaprogramming\/enableIf.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/parseInteger.hpp\"\n-\n-#include <errno.h>\n-#include <limits>\n-#include <stdlib.h>\n-\n-\/\/ *************************************************************************\n-\/\/ ** Attention compatibility!                                            **\n-\/\/ ** These functions are used to parse JVM arguments (-XX). Be careful   **\n-\/\/ ** with behavioral changes here.                                       **\n-\/\/ *************************************************************************\n-\n-\/\/ Helper for parse_memory_size\n-template<typename T>\n-inline bool multiply_by_1k(T& n) {\n-  if (n >= std::numeric_limits<T>::min() \/ 1024 &&\n-      n <= std::numeric_limits<T>::max() \/ 1024) {\n-    n *= 1024;\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}\n-\n-\/\/ All of the integral types that can be used for command line options:\n-\/\/   int, uint, intx, uintx, uint64_t, size_t\n-\/\/\n-\/\/ In all supported platforms, these types can be mapped to only 4 native types:\n-\/\/    {signed, unsigned} x {32-bit, 64-bit}\n-\/\/\n-\/\/ We use SFINAE to pick the correct parse_integer_impl() function\n-\/\/\n-\/\/ This function will parse until it encounters unparseable parts, then\n-\/\/ stop. If it read no valid memory size, it will fail.\n-\/\/\n-\/\/ Example: \"1024M:oom\" will yield true, result=1G, endptr pointing to \":oom\"\n-\n-template<typename T>\n-static bool parse_memory_size(const char *s, char **endptr, T* result) {\n-\n-  if (!isdigit(s[0]) && s[0] != '-') {\n-    \/\/ strtoll\/strtoull may allow leading spaces. Forbid it.\n-    return false;\n-  }\n-\n-  T n = 0;\n-  bool is_hex = (s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) ||\n-                (s[0] == '-' && s[1] == '0' && (s[2] == 'x' || s[3] == 'X'));\n-  char* remainder;\n-\n-  if (!parse_integer(s, &remainder, (is_hex ? 16 : 10), &n)) {\n-    return false;\n-  }\n-\n-  switch (*remainder) {\n-    case 'T': case 't':\n-      if (!multiply_by_1k(n)) return false;\n-      \/\/ fall-through\n-    case 'G': case 'g':\n-      if (!multiply_by_1k(n)) return false;\n-      \/\/ fall-through\n-    case 'M': case 'm':\n-      if (!multiply_by_1k(n)) return false;\n-      \/\/ fall-through\n-    case 'K': case 'k':\n-      if (!multiply_by_1k(n)) return false;\n-      remainder ++; \/\/ shave off parsed unit char\n-      break;\n-    default:\n-      \/\/ nothing. Return remainder unparsed.\n-      break;\n-  };\n-\n-  *result = n;\n-  *endptr = remainder;\n-  return true;\n-}\n-\n-\/\/ Used for parsing JVM argument sizes (see argument.cpp)\n-\/\/ In contrast to parse_memory_size(s, endptr, result), this variant requires the full\n-\/\/ string to match. No remainder are allowed here.\n-\/\/ Example: \"100m\" - okay, \"100m:oom\" -> not okay\n-template<typename T>\n-static bool parse_argument_memory_size(const char *s, T* result) {\n-  char* remainder;\n-  bool rc = parse_memory_size(s, &remainder, result);\n-  rc = rc && (*remainder == '\\0');\n-  return rc;\n-}\n-\n-#endif \/\/ SHARE_UTILITIES_PARSE_MEMORY_SIZE_HPP\n","filename":"src\/hotspot\/share\/utilities\/parseMemorySize.hpp","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"utilities\/parseMemorySize.hpp\"\n+#include \"utilities\/parseInteger.hpp\"\n@@ -53,1 +53,1 @@\n-  bool rc = parse_memory_size(ss.base(), &end, &value);\n+  bool rc = parse_integer(ss.base(), &end, &value);\n@@ -57,1 +57,1 @@\n-  rc = parse_argument_memory_size(ss.base(), &value);\n+  rc = parse_integer(ss.base(), &value);\n@@ -65,1 +65,1 @@\n-  rc = parse_memory_size(ss.base(), &end, &value);\n+  rc = parse_integer(ss.base(), &end, &value);\n@@ -71,1 +71,1 @@\n-  rc = parse_argument_memory_size(ss.base(), &value);\n+  rc = parse_integer(ss.base(), &value);\n@@ -132,1 +132,1 @@\n-  bool rc = parse_memory_size(pattern, &end, &value);\n+  bool rc = parse_integer(pattern, &end, &value);\n@@ -134,1 +134,1 @@\n-  rc = parse_argument_memory_size(pattern, &value);\n+  rc = parse_integer(pattern, &value);\n@@ -144,1 +144,3 @@\n-  bool rc = parse_memory_size(pattern, &end, &value);\n+  \/\/ The first overload parses until unrecognized chars are encountered, then\n+  \/\/ returns pointer to string remainder.\n+  bool rc = parse_integer(pattern, &end, &value);\n@@ -146,1 +148,2 @@\n-  rc = parse_argument_memory_size(pattern, &value);\n+  \/\/ The second overload parses everything; unrecognized chars will make it fail.\n+  rc = parse_integer(pattern, &value);\n","filename":"test\/hotspot\/gtest\/utilities\/test_parse_memory_size.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"}]}