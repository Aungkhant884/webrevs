{"files":[{"patch":"@@ -223,1 +223,1 @@\n-    \/** Are total patterns in instanceof allowed\n+    \/** Are unconditional patterns in instanceof allowed\n@@ -1695,1 +1695,1 @@\n-            boolean hasTotalPattern = false;      \/\/ Is there a total pattern?\n+            boolean hasUnconditionalPattern = false; \/\/ Is there a unconditional pattern?\n@@ -1711,1 +1711,1 @@\n-                boolean wasTotalPattern = hasTotalPattern;\n+                boolean wasUnconditionalPattern = hasUnconditionalPattern;\n@@ -1719,1 +1719,1 @@\n-                            } else if (wasTotalPattern) {\n+                            } else if (wasUnconditionalPattern) {\n@@ -1772,2 +1772,2 @@\n-                        } else if (hasTotalPattern) {\n-                            log.error(pat.pos(), Errors.TotalPatternAndDefault);\n+                        } else if (hasUnconditionalPattern) {\n+                            log.error(pat.pos(), Errors.UnconditionalPatternAndDefault);\n@@ -1798,8 +1798,9 @@\n-                        boolean unconditional = TreeInfo.unrefinedCaseLabel(pat);\n-                        boolean isTotal = unconditional &&\n-                                          !patternType.isErroneous() &&\n-                                          types.isSubtype(types.boxedTypeOrType(types.erasure(seltype)),\n-                                                          patternType);\n-                        if (isTotal) {\n-                            if (hasTotalPattern) {\n-                                log.error(pat.pos(), Errors.DuplicateTotalPattern);\n+                        boolean unguarded = TreeInfo.unguardedCaseLabel(pat);\n+                        boolean unconditional =\n+                                unguarded &&\n+                                !patternType.isErroneous() &&\n+                                types.isSubtype(types.boxedTypeOrType(types.erasure(seltype)),\n+                                                patternType);\n+                        if (unconditional) {\n+                            if (hasUnconditionalPattern) {\n+                                log.error(pat.pos(), Errors.DuplicateUnconditionalPattern);\n@@ -1807,1 +1808,1 @@\n-                                log.error(pat.pos(), Errors.TotalPatternAndDefault);\n+                                log.error(pat.pos(), Errors.UnconditionalPatternAndDefault);\n@@ -1809,1 +1810,1 @@\n-                            hasTotalPattern = true;\n+                            hasUnconditionalPattern = true;\n@@ -1815,1 +1816,1 @@\n-                            if (unconditional) {\n+                            if (unguarded) {\n@@ -1842,2 +1843,2 @@\n-                ((JCSwitch) switchTree).hasTotalPattern =\n-                        hasDefault || hasTotalPattern || lastPatternErroneous;\n+                ((JCSwitch) switchTree).hasUnconditionalPattern =\n+                        hasDefault || hasUnconditionalPattern || lastPatternErroneous;\n@@ -1846,2 +1847,2 @@\n-                ((JCSwitchExpression) switchTree).hasTotalPattern =\n-                        hasDefault || hasTotalPattern || lastPatternErroneous;\n+                ((JCSwitchExpression) switchTree).hasUnconditionalPattern =\n+                        hasDefault || hasUnconditionalPattern || lastPatternErroneous;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":22,"deletions":21,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -674,1 +674,1 @@\n-                    if (TreeInfo.unrefinedCaseLabel(pat)) {\n+                    if (TreeInfo.unguardedCaseLabel(pat)) {\n@@ -691,1 +691,1 @@\n-            tree.isExhaustive = tree.hasTotalPattern ||\n+            tree.isExhaustive = tree.hasUnconditionalPattern ||\n@@ -699,1 +699,1 @@\n-            if (!tree.hasTotalPattern) {\n+            if (!tree.hasUnconditionalPattern) {\n@@ -717,1 +717,1 @@\n-                    if (TreeInfo.unrefinedCaseLabel(pat)) {\n+                    if (TreeInfo.unguardedCaseLabel(pat)) {\n@@ -732,1 +732,1 @@\n-            tree.isExhaustive = tree.hasTotalPattern ||\n+            tree.isExhaustive = tree.hasUnconditionalPattern ||\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -259,1 +259,2 @@\n-        handleSwitch(tree, tree.selector, tree.cases, tree.hasTotalPattern, tree.patternSwitch);\n+        handleSwitch(tree, tree.selector, tree.cases,\n+                     tree.hasUnconditionalPattern, tree.patternSwitch);\n@@ -264,1 +265,2 @@\n-        handleSwitch(tree, tree.selector, tree.cases, tree.hasTotalPattern, tree.patternSwitch);\n+        handleSwitch(tree, tree.selector, tree.cases,\n+                     tree.hasUnconditionalPattern, tree.patternSwitch);\n@@ -270,1 +272,1 @@\n-                              boolean hasTotalPattern,\n+                              boolean hasUnconditionalPattern,\n@@ -429,1 +431,1 @@\n-                    } else if (hasTotalPattern && !hasDefault &&\n+                    } else if (hasUnconditionalPattern && !hasDefault &&\n@@ -431,2 +433,3 @@\n-                        \/\/If the switch has total pattern, the last case will contain it.\n-                        \/\/Convert the total pattern to default:\n+                        \/\/If the switch has unconditional pattern,\n+                        \/\/the last case will contain it.\n+                        \/\/Convert the unconditional pattern to default:\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -509,2 +509,2 @@\n-compiler.err.duplicate.total.pattern=\\\n-    duplicate total pattern\n+compiler.err.duplicate.unconditional.pattern=\\\n+    duplicate unconditional pattern\n@@ -512,2 +512,2 @@\n-compiler.err.total.pattern.and.default=\\\n-    switch has both a total pattern and a default label\n+compiler.err.unconditional.pattern.and.default=\\\n+    switch has both an unconditional pattern and a default label\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1286,1 +1286,1 @@\n-        public boolean hasTotalPattern;\n+        public boolean hasUnconditionalPattern;\n@@ -1374,1 +1374,1 @@\n-        public boolean hasTotalPattern;\n+        public boolean hasUnconditionalPattern;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1334,1 +1334,1 @@\n-    public static boolean unrefinedCaseLabel(JCCaseLabel cse) {\n+    public static boolean unguardedCaseLabel(JCCaseLabel cse) {\n@@ -1339,3 +1339,2 @@\n-        if (guard != null && guard.type.hasTag(BOOLEAN)) {\n-            var constValue = guard.type.constValue();\n-            return constValue != null && ((int) constValue) == 1;\n+        if (guard == null) {\n+            return true;\n@@ -1343,1 +1342,4 @@\n-        return true;\n+        var constValue = guard.type.constValue();\n+        return constValue != null &&\n+               guard.type.hasTag(BOOLEAN) &&\n+               ((int) constValue) == 1;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.duplicate.total.pattern\n-\/\/ key: compiler.misc.feature.pattern.switch\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n-\n-class DuplicateTotalPattern {\n-    private void doSwitch(Object o) {\n-        switch (o) {\n-            case Object obj: break;\n-            case Object obj: break;\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/DuplicateTotalPattern.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.duplicate.unconditional.pattern\n+\/\/ key: compiler.misc.feature.pattern.switch\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class DuplicateUnconditionalPattern {\n+    private void doSwitch(Object o) {\n+        switch (o) {\n+            case Object obj: break;\n+            case Object obj: break;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/DuplicateUnconditionalPattern.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.total.pattern.and.default\n-\/\/ key: compiler.misc.feature.pattern.switch\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n-\n-class TotalPatternAndDefault {\n-    private void doSwitch(Object o) {\n-        switch (o) {\n-            case Object obj: break;\n-            default: break;\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/TotalPatternAndDefault.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.unconditional.pattern.and.default\n+\/\/ key: compiler.misc.feature.pattern.switch\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class UnconditionalPatternAndDefault {\n+    private void doSwitch(Object o) {\n+        switch (o) {\n+            case Object obj: break;\n+            default: break;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnconditionalPatternAndDefault.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -870,0 +870,47 @@\n+    @Test\n+    public void testNonPrimitiveBooleanGuard(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface A {}\n+                   final class B1 implements A {}\n+                   final class B2 implements A {}\n+\n+                   void test(A arg, Boolean g) {\n+                       int i = switch (arg) {\n+                           case B1 b1 when g -> 1;\n+                           case B2 b2 -> 2;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:8:17: compiler.err.not.exhaustive\",\n+               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+               \"- compiler.note.preview.recompile\",\n+               \"1 error\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface A {}\n+                   final class B1 implements A {}\n+                   final class B2 implements A {}\n+\n+                   void test(A arg) {\n+                       int i = switch (arg) {\n+                           case B1 b1 when undefined() -> 1;\n+                           case B2 b2 -> 2;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:9:29: compiler.err.cant.resolve.location.args: kindname.method, undefined, , , (compiler.misc.location: kindname.class, test.Test, null)\",\n+               \"Test.java:8:17: compiler.err.not.exhaustive\",\n+               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+               \"- compiler.note.preview.recompile\",\n+               \"2 errors\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-SwitchErrors.java:36:13: compiler.err.total.pattern.and.default\n+SwitchErrors.java:36:13: compiler.err.unconditional.pattern.and.default\n@@ -10,3 +10,3 @@\n-SwitchErrors.java:42:24: compiler.err.total.pattern.and.default\n-SwitchErrors.java:48:18: compiler.err.total.pattern.and.default\n-SwitchErrors.java:54:18: compiler.err.duplicate.total.pattern\n+SwitchErrors.java:42:24: compiler.err.unconditional.pattern.and.default\n+SwitchErrors.java:48:18: compiler.err.unconditional.pattern.and.default\n+SwitchErrors.java:54:18: compiler.err.duplicate.unconditional.pattern\n@@ -36,1 +36,1 @@\n-SwitchErrors.java:218:29: compiler.err.total.pattern.and.default\n+SwitchErrors.java:218:29: compiler.err.unconditional.pattern.and.default\n@@ -41,1 +41,1 @@\n-SwitchErrors.java:244:18: compiler.err.duplicate.total.pattern\n+SwitchErrors.java:244:18: compiler.err.duplicate.unconditional.pattern\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.out","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}