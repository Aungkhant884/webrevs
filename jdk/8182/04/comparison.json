{"files":[{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * Thrown to indicate an unexpected failure in pattern matching.\n+ *\n+ * {@code MatchException} may be thrown when an exhaustive pattern matching language construct\n+ * (such as a switch expression) encounters a value that does not match any of the provided\n+ * patterns at runtime. This can currently arise for separate compilation anomalies,\n+ * where a sealed interface has a different set of permitted subtypes at runtime than\n+ * it had at compilation time, an enum has a different set of constants at runtime than\n+ * it had at compilation time, or the type hierarchy has changed in incompatible ways between\n+ * compile time and run time.\n+ *\n+ * @jls 14.11.3 Execution of a switch Statement\n+ * @jls 14.30.2 Pattern Matching\n+ * @jls 15.28.2 Run-Time Evaluation of switch Expressions\n+ *\n+ * @since   19\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING)\n+public class MatchException extends RuntimeException {\n+    @java.io.Serial\n+    private static final long serialVersionUID = 0L;\n+\n+    \/**\n+     * Constructs an {@code MatchException} with no detail message.\n+     *\/\n+    public MatchException() {\n+        super();\n+    }\n+\n+    \/**\n+     * Constructs an {@code MatchException} with the specified\n+     * detail message.\n+     *\n+     * @param  message the detail message (which is saved for later retrieval\n+     *         by the {@link #getMessage()} method).\n+     *\/\n+    public MatchException(String message) {\n+        super(message);\n+    }\n+\n+    \/**\n+     * Constructs an {@code MatchException} with the specified cause.\n+     *\n+     * @param  cause the cause (which is saved for later retrieval by the\n+     *         {@link #getCause()} method). (A {@code null} value is\n+     *         permitted, and indicates that the cause is nonexistent or\n+     *         unknown.)\n+     *\/\n+    public MatchException(Throwable cause) {\n+        super(cause);\n+    }\n+\n+    \/**\n+     * Constructs an {@code MatchException} with the specified detail message and\n+     * cause.\n+     *\n+     * @param  message the detail message (which is saved for later retrieval\n+     *         by the {@link #getMessage()} method).\n+     * @param  cause the cause (which is saved for later retrieval by the\n+     *         {@link #getCause()} method). (A {@code null} value is\n+     *         permitted, and indicates that the cause is nonexistent or\n+     *         unknown.)\n+     *\/\n+    public MatchException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/MatchException.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.source.tree;\n-\n-import jdk.internal.javac.PreviewFeature;\n-\n-\/**\n- * A guard pattern tree.\n- *\n- * @since 17\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n-public interface GuardedPatternTree extends PatternTree {\n-\n-    \/**\n-     * The guarded pattern expression.\n-     * @return the guarded pattern\n-     *\/\n-    public PatternTree getPattern();\n-\n-    \/**\n-     * The guard expression.\n-     * @return the guard expression\n-     *\/\n-    public ExpressionTree getExpression();\n-\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/GuardedPatternTree.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -34,1 +36,12 @@\n-public interface PatternTree extends Tree, CaseLabelTree {}\n+public interface PatternTree extends Tree, CaseLabelTree {\n+\n+    \/**\n+     * The guard for the case.\n+     *\n+     * @return the guard\n+     * @since 19\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    ExpressionTree getGuard();\n+\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/PatternTree.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -231,8 +231,0 @@\n-        \/**\n-         * Used for instances of {@link GuardedPatternTree}.\n-         *\n-         * @since 17\n-         *\/\n-        @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n-        GUARDED_PATTERN(GuardedPatternTree.class),\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -305,10 +305,0 @@\n-    \/**\n-     * Visits a {@code GuardPatternTree} node.\n-     * @param node the node being visited\n-     * @param p a parameter value\n-     * @return a result value\n-     * @since 17\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n-    R visitGuardedPattern(GuardedPatternTree node, P p);\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -706,16 +706,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @implSpec This implementation calls {@code defaultAction}.\n-     *\n-     * @param node {@inheritDoc}\n-     * @param p {@inheritDoc}\n-     * @return  the result of {@code defaultAction}\n-     * @since 17\n-     *\/\n-    @Override\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n-    public R visitGuardedPattern(GuardedPatternTree node, P p) {\n-        return defaultAction(node, p);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -774,1 +774,3 @@\n-        return scan(node.getVariable(), p);\n+        R r = scan(node.getVariable(), p);\n+        r = scanAndReduce(node.getGuard(), p, r);\n+        return r;\n@@ -836,16 +838,0 @@\n-        return scan(node.getPattern(), p);\n-    }\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @implSpec This implementation scans the children in left to right order.\n-     *\n-     * @param node  {@inheritDoc}\n-     * @param p  {@inheritDoc}\n-     * @return the result of scanning\n-     * @since 17\n-     *\/\n-    @Override\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n-    public R visitGuardedPattern(GuardedPatternTree node, P p) {\n@@ -853,1 +839,2 @@\n-        return scanAndReduce(node.getExpression(), p, r);\n+        r = scanAndReduce(node.getGuard(), p, r);\n+        return r;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":6,"deletions":19,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -190,0 +190,1 @@\n+            case UNCONDITIONAL_PATTERN_IN_INSTANCEOF -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -242,0 +242,1 @@\n+        UNCONDITIONAL_PATTERN_IN_INSTANCEOF(JDK19, Fragments.FeatureUnconditionalPatternsInInstanceof, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -192,0 +192,1 @@\n+    public final Type matchExceptionType;\n@@ -556,0 +557,1 @@\n+        matchExceptionType = enterClass(\"java.lang.MatchException\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -177,0 +177,2 @@\n+        allowUnconditionalPatternsInstance = (preview.isEnabled() || !preview.isPreview(Feature.UNCONDITIONAL_PATTERN_IN_INSTANCEOF)) &&\n+                                     Feature.UNCONDITIONAL_PATTERN_IN_INSTANCEOF.allowedInSource(source);\n@@ -221,0 +223,4 @@\n+    \/** Are total patterns in instanceof allowed\n+     *\/\n+    private final boolean allowUnconditionalPatternsInstance;\n+\n@@ -1773,1 +1779,1 @@\n-                        var primary = TreeInfo.primaryPatternType((JCPattern) pat);\n+                        var primary = TreeInfo.primaryPatternType(pat);\n@@ -1780,1 +1786,13 @@\n-                        boolean isTotal = primary.unconditional() &&\n+                        JCExpression guard = ((JCPattern) pat).guard;\n+                        if (guard != null) {\n+                            MatchBindings afterPattern = matchBindings;\n+                            Env<AttrContext> bodyEnv = bindingEnv(env, matchBindings.bindingsWhenTrue);\n+                            try {\n+                                attribExpr(guard, bodyEnv, syms.booleanType);\n+                            } finally {\n+                                bodyEnv.info.scope.leave();\n+                            }\n+                            matchBindings = matchBindingsComputer.caseGuard(c, afterPattern, matchBindings);\n+                        }\n+                        boolean unconditional = TreeInfo.unrefinedCaseLabel(pat);\n+                        boolean isTotal = unconditional &&\n@@ -1794,1 +1812,1 @@\n-                            if (primary.unconditional()) {\n+                            if (unconditional) {\n@@ -1801,0 +1819,1 @@\n+\n@@ -4093,1 +4112,5 @@\n-                log.error(tree.pos(), Errors.InstanceofPatternNoSubtype(exprtype, clazztype));\n+                if (!allowUnconditionalPatternsInstance) {\n+                    log.error(tree.pos(), Errors.InstanceofPatternNoSubtype(exprtype, clazztype));\n+                } else if (preview.isPreview(Feature.UNCONDITIONAL_PATTERN_IN_INSTANCEOF)) {\n+                    preview.warnPreview(tree.pattern.pos(), Feature.UNCONDITIONAL_PATTERN_IN_INSTANCEOF);\n+                }\n@@ -4161,14 +4184,0 @@\n-    @Override\n-    public void visitGuardPattern(JCGuardPattern tree) {\n-        attribExpr(tree.patt, env);\n-        MatchBindings afterPattern = matchBindings;\n-        Env<AttrContext> bodyEnv = bindingEnv(env, matchBindings.bindingsWhenTrue);\n-        try {\n-            attribExpr(tree.expr, bodyEnv, syms.booleanType);\n-        } finally {\n-            bodyEnv.info.scope.leave();\n-        }\n-        result = tree.type = tree.patt.type;\n-        matchBindings = matchBindingsComputer.guardedPattern(tree, afterPattern, matchBindings);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":27,"deletions":18,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -674,1 +674,3 @@\n-                    handleConstantCaseLabel(constants, pat);\n+                    if (TreeInfo.unrefinedCaseLabel(pat)) {\n+                        handleConstantCaseLabel(constants, pat);\n+                    }\n@@ -715,1 +717,3 @@\n-                    handleConstantCaseLabel(constants, pat);\n+                    if (TreeInfo.unrefinedCaseLabel(pat)) {\n+                        handleConstantCaseLabel(constants, pat);\n+                    }\n@@ -745,1 +749,1 @@\n-                    PatternPrimaryType patternType = TreeInfo.primaryPatternType((JCPattern) pat);\n+                    PatternPrimaryType patternType = TreeInfo.primaryPatternType(pat);\n@@ -747,3 +751,1 @@\n-                    if (patternType.unconditional()) {\n-                        constants.add(patternType.type().tsym);\n-                    }\n+                    constants.add(patternType.type().tsym);\n@@ -2017,0 +2019,8 @@\n+        void scanPattern(JCTree tree) {\n+            scan(tree);\n+            if (inits.isReset()) {\n+                inits.assign(initsWhenTrue);\n+                uninits.assign(uninitsWhenTrue);\n+            }\n+        }\n+\n@@ -2457,5 +2467,1 @@\n-                    scan(pat);\n-                    if (inits.isReset()) {\n-                        inits.assign(initsWhenTrue);\n-                        uninits.assign(uninitsWhenTrue);\n-                    }\n+                    scanPattern(pat);\n@@ -2850,1 +2856,1 @@\n-            super.visitBindingPattern(tree);\n+            scan(tree.var);\n@@ -2852,0 +2858,1 @@\n+            scan(tree.guard);\n@@ -2943,1 +2950,1 @@\n-                    case GUARDPATTERN:\n+                    case BINDINGPATTERN, PARENTHESIZEDPATTERN:\n@@ -2967,1 +2974,1 @@\n-                        case GUARDPATTERN:\n+                        case CASE:\n@@ -2978,1 +2985,1 @@\n-                case GUARDPATTERN -> Fragments.Guard;\n+                case BINDINGPATTERN, PARENTHESIZEDPATTERN -> Fragments.Guard;\n@@ -3018,2 +3025,14 @@\n-        public void visitGuardPattern(JCGuardPattern tree) {\n-            scan(tree.patt);\n+        public void visitBindingPattern(JCBindingPattern tree) {\n+            scan(tree.var);\n+            JCTree prevTree = currentTree;\n+            try {\n+                currentTree = tree;\n+                scan(tree.guard);\n+            } finally {\n+                currentTree = prevTree;\n+            }\n+        }\n+\n+        @Override\n+        public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n+            scan(tree.pattern);\n@@ -3023,1 +3042,1 @@\n-                scan(tree.expr);\n+                scan(tree.guard);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":38,"deletions":19,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3618,1 +3618,3 @@\n-        List<JCCase> cases = tree.patternSwitch ? addDefaultIfNeeded(tree.cases) : tree.cases;\n+        boolean matchException = tree.patternSwitch && !tree.wasEnumSelector;\n+        List<JCCase> cases = tree.patternSwitch ? addDefaultIfNeeded(matchException, tree.cases)\n+                                                : tree.cases;\n@@ -3624,1 +3626,2 @@\n-        List<JCCase> cases = addDefaultIfNeeded(tree.cases);\n+        boolean matchException = tree.patternSwitch && !tree.wasEnumSelector;\n+        List<JCCase> cases = addDefaultIfNeeded(matchException, tree.cases);\n@@ -3628,1 +3631,1 @@\n-    private List<JCCase> addDefaultIfNeeded(List<JCCase> cases) {\n+    private List<JCCase> addDefaultIfNeeded(boolean matchException, List<JCCase> cases) {\n@@ -3630,1 +3633,3 @@\n-            JCThrow thr = make.Throw(makeNewClass(syms.incompatibleClassChangeErrorType,\n+            Type exception = matchException ? syms.matchExceptionType\n+                                            : syms.incompatibleClassChangeErrorType;\n+            JCThrow thr = make.Throw(makeNewClass(exception,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-import com.sun.tools.javac.tree.JCTree.JCGuardPattern;\n+import com.sun.tools.javac.tree.JCTree.JCCase;\n@@ -115,1 +115,1 @@\n-    public MatchBindings guardedPattern(JCGuardPattern tree, MatchBindings patternBindings, MatchBindings guardBindings) {\n+    public MatchBindings caseGuard(JCCase tree, MatchBindings patternBindings, MatchBindings guardBindings) {\n@@ -145,1 +145,1 @@\n-            case PARENTHESIZEDPATTERN: case GUARDPATTERN:\n+            case PARENTHESIZEDPATTERN:\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MatchBindingsComputer.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,0 @@\n-import com.sun.tools.javac.tree.JCTree.JCGuardPattern;\n@@ -258,7 +257,0 @@\n-    @Override\n-    public void visitGuardPattern(JCGuardPattern tree) {\n-        JCExpression pattern = (JCExpression) this.<JCTree>translate(tree.patt);\n-        JCExpression guard = translate(tree.expr);\n-        result = makeBinary(Tag.AND, pattern, guard);\n-    }\n-\n@@ -343,6 +335,0 @@\n-            if (hasTotalPattern && !hasNullCase) {\n-                if (cases.stream().flatMap(c -> c.labels.stream()).noneMatch(l -> l.hasTag(Tag.DEFAULTCASELABEL))) {\n-                    lastCase.labels = lastCase.labels.prepend(makeLit(syms.botType, null));\n-                    hasNullCase = true;\n-                }\n-            }\n@@ -418,0 +404,3 @@\n+                        if (((JCPattern) p).guard != null) {\n+                            test = makeBinary(Tag.AND, test, translate(((JCPattern) p).guard));\n+                        }\n@@ -469,0 +458,1 @@\n+                ((JCSwitch) tree).wasEnumSelector = enumSelector;\n@@ -474,0 +464,1 @@\n+                ((JCSwitchExpression) tree).wasEnumSelector = enumSelector;\n@@ -489,1 +480,1 @@\n-    private Type principalType(JCPattern p) {\n+    private Type principalType(JCTree p) {\n@@ -495,1 +486,1 @@\n-            Type principalType = principalType((JCPattern) l);\n+            Type principalType = principalType(l);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":8,"deletions":17,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -568,0 +568,1 @@\n+        tree.guard = translate(tree.guard, syms.booleanType);\n@@ -585,7 +586,1 @@\n-        result = tree;\n-    }\n-\n-    @Override\n-    public void visitGuardPattern(JCGuardPattern tree) {\n-        tree.patt = translate(tree.patt, null);\n-        tree.expr = translate(tree.expr, syms.booleanType);\n+        tree.guard = translate(tree.guard, syms.booleanType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -766,1 +766,1 @@\n-    public JCPattern parsePattern(int pos, JCModifiers mods, JCExpression parsedType, boolean inInstanceOf) {\n+    public JCPattern parsePattern(int pos, JCModifiers mods, JCExpression parsedType) {\n@@ -771,1 +771,1 @@\n-            JCPattern p = parsePattern(token.pos, null, null, false);\n+            JCPattern p = parsePattern(token.pos, null, null);\n@@ -780,6 +780,0 @@\n-        if (!inInstanceOf && token.kind == AMPAMP) {\n-            checkSourceLevel(Feature.PATTERN_SWITCH);\n-            nextToken();\n-            JCExpression guard = term(EXPR | NOLAMBDA);\n-            pattern = F.at(pos).GuardPattern(pattern, guard);\n-        }\n@@ -970,1 +964,1 @@\n-                    pattern = parsePattern(token.pos, null, null, true);\n+                    pattern = parsePattern(token.pos, null, null);\n@@ -978,1 +972,1 @@\n-                        pattern = parsePattern(patternPos, mods, type, true);\n+                        pattern = parsePattern(patternPos, mods, type);\n@@ -3079,1 +3073,6 @@\n-                return parsePattern(patternPos, mods, null, false);\n+                JCPattern p = parsePattern(patternPos, mods, null);\n+                if (token.kind == IDENTIFIER && token.name() == names.when) {\n+                    nextToken();\n+                    p.guard = term(EXPR | NOLAMBDA);\n+                }\n+                return p;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3085,0 +3085,3 @@\n+compiler.misc.feature.unconditional.patterns.in.instanceof=\\\n+    unconditional patterns in instanceof\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -244,1 +244,0 @@\n-        GUARDPATTERN,\n@@ -1290,0 +1289,1 @@\n+        public boolean wasEnumSelector;\n@@ -1377,0 +1377,1 @@\n+        public boolean wasEnumSelector;\n@@ -2246,0 +2247,5 @@\n+        public JCExpression guard;\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public JCExpression getGuard() { return guard; }\n+\n@@ -2365,42 +2371,0 @@\n-    public static class JCGuardPattern extends JCPattern\n-            implements GuardedPatternTree {\n-        public JCPattern patt;\n-        public JCExpression expr;\n-\n-        public JCGuardPattern(JCPattern patt, JCExpression expr) {\n-            this.patt = patt;\n-            this.expr = expr;\n-        }\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public PatternTree getPattern() {\n-            return patt;\n-        }\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public ExpressionTree getExpression() {\n-            return expr;\n-        }\n-\n-        @Override\n-        public void accept(Visitor v) {\n-            v.visitGuardPattern(this);\n-        }\n-\n-        @DefinedBy(Api.COMPILER_TREE)\n-        public Kind getKind() {\n-            return Kind.GUARDED_PATTERN;\n-        }\n-\n-        @Override\n-        @DefinedBy(Api.COMPILER_TREE)\n-        public <R, D> R accept(TreeVisitor<R, D> v, D d) {\n-            return v.visitGuardedPattern(this, d);\n-        }\n-\n-        @Override\n-        public Tag getTag() {\n-            return Tag.GUARDPATTERN;\n-        }\n-    }\n-\n@@ -3449,1 +3413,0 @@\n-        public void visitGuardPattern(JCGuardPattern that) { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":8,"deletions":45,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -911,0 +911,4 @@\n+            if (patt.guard != null) {\n+                print(\" when \");\n+                printExpr(patt.guard);\n+            }\n@@ -922,11 +926,4 @@\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-    }\n-\n-    @Override\n-    public void visitGuardPattern(JCGuardPattern patt) {\n-        try {\n-            printExpr(patt.patt);\n-            print(\" && \");\n-            printExpr(patt.expr);\n+            if (patt.guard != null) {\n+                print(\" when \");\n+                printExpr(patt.guard);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -497,9 +497,4 @@\n-        return M.at(t.pos).BindingPattern(var);\n-    }\n-\n-    @DefinedBy(Api.COMPILER_TREE)\n-    public JCTree visitGuardedPattern(GuardedPatternTree node, P p) {\n-        JCGuardPattern t = (JCGuardPattern) node;\n-        JCPattern patt = copy(t.patt, p);\n-        JCExpression expr = copy(t.expr, p);\n-        return M.at(t.pos).GuardPattern(patt, expr);\n+        JCExpression guard = copy(t.guard, p);\n+        JCPattern pat = M.at(t.pos).BindingPattern(var);\n+        pat.guard = guard;\n+        return pat;\n@@ -512,1 +507,4 @@\n-        return M.at(t.pos).ParenthesizedPattern(pattern);\n+        JCExpression guard = copy(t.guard, p);\n+        JCPattern pat = M.at(t.pos).ParenthesizedPattern(pattern);\n+        pat.guard = guard;\n+        return pat;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -545,4 +545,0 @@\n-            case GUARDPATTERN: {\n-                JCGuardPattern node = (JCGuardPattern) tree;\n-                return getStartPos(node.patt);\n-            }\n@@ -647,4 +643,0 @@\n-            case GUARDPATTERN: {\n-                JCGuardPattern node = (JCGuardPattern) tree;\n-                return getEndPos(node.expr, endPosTable);\n-            }\n@@ -1355,1 +1347,1 @@\n-    public static PatternPrimaryType primaryPatternType(JCPattern pat) {\n+    public static PatternPrimaryType primaryPatternType(JCTree pat) {\n@@ -1357,14 +1349,1 @@\n-            case BINDINGPATTERN -> new PatternPrimaryType(((JCBindingPattern) pat).type, true);\n-            case GUARDPATTERN -> {\n-                JCGuardPattern guarded = (JCGuardPattern) pat;\n-                PatternPrimaryType nested = primaryPatternType(guarded.patt);\n-                boolean unconditional = nested.unconditional();\n-                if (guarded.expr.type.hasTag(BOOLEAN) && unconditional) {\n-                    unconditional = false;\n-                    var constValue = guarded.expr.type.constValue();\n-                    if (constValue != null && ((int) constValue) == 1) {\n-                        unconditional = true;\n-                    }\n-                }\n-                yield new PatternPrimaryType(nested.type(), unconditional);\n-            }\n+            case BINDINGPATTERN -> new PatternPrimaryType(pat.type);\n@@ -1376,1 +1355,1 @@\n-    public static JCBindingPattern primaryPatternTree(JCPattern pat) {\n+    public static JCBindingPattern primaryPatternTree(JCTree pat) {\n@@ -1379,1 +1358,0 @@\n-            case GUARDPATTERN -> primaryPatternTree(((JCGuardPattern) pat).patt);\n@@ -1385,1 +1363,1 @@\n-    public record PatternPrimaryType(Type type, boolean unconditional) {}\n+    public record PatternPrimaryType(Type type) {}\n@@ -1393,0 +1371,12 @@\n+\n+    public static boolean unrefinedCaseLabel(JCCaseLabel cse) {\n+        if (!cse.isPattern()) {\n+            return true;\n+        }\n+        JCExpression guard = ((JCPattern) cse).guard;\n+        if (guard != null && guard.type.hasTag(BOOLEAN)) {\n+            var constValue = guard.type.constValue();\n+            return constValue != null && ((int) constValue) == 1;\n+        }\n+        return true;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":17,"deletions":27,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 20222, Oracle and\/or its affiliates. All rights reserved.\n@@ -503,6 +503,0 @@\n-    public JCGuardPattern GuardPattern(JCPattern guardedPattern, JCExpression expr) {\n-        JCGuardPattern tree = new JCGuardPattern(guardedPattern, expr);\n-        tree.pos = pos;\n-        return tree;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -308,0 +308,1 @@\n+        scan(tree.guard);\n@@ -315,8 +316,3 @@\n-    public void visitParenthesizedPattern(JCParenthesizedPattern that) {\n-        scan(that.pattern);\n-    }\n-\n-    @Override\n-    public void visitGuardPattern(JCGuardPattern that) {\n-        scan(that.patt);\n-        scan(that.expr);\n+    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n+        scan(tree.pattern);\n+        scan(tree.guard);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -363,0 +363,1 @@\n+        tree.guard = translate(tree.guard);\n@@ -374,7 +375,1 @@\n-        result = tree;\n-    }\n-\n-    @Override\n-    public void visitGuardPattern(JCGuardPattern tree) {\n-        tree.patt = translate(tree.patt);\n-        tree.expr = translate(tree.expr);\n+        tree.guard = translate(tree.guard);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,1 @@\n+    public final Name when;\n@@ -251,0 +252,1 @@\n+        when = fromString(\"when\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-                                 case String s && s.isEmpty() ->           \/\/ 4\n+                                 case String s when s.isEmpty() ->         \/\/ 4\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/LineNumberTable\/RuleSwitchBreaks.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-            case String s && s.length() == i++: break;\n+            case String s when s.length() == i++: break;\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantRefNonEffectivelyFinalVar.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.misc.feature.total.patterns.in.instanceof\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:-options,preview\n+\n+import java.util.*;\n+\n+class FeatureReifiableTypesInstanceof {\n+    String s;\n+    boolean b = (s instanceof String str);\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FeatureTotalPatternsInInstanceof.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n-            long patternCases = Arrays.stream(caseLabels).filter(l -> l == CaseLabel.TYPE_PATTERN || l == CaseLabel.GUARDED_PATTERN || l == CaseLabel.PARENTHESIZED_PATTERN).count();\n+            long patternCases = Arrays.stream(caseLabels).filter(l -> l == CaseLabel.TYPE_PATTERN || l == CaseLabel.PARENTHESIZED_PATTERN).count();\n@@ -129,1 +129,1 @@\n-                        case GUARDED_PATTERN, PARENTHESIZED_PATTERN, TYPE_PATTERN: seenPattern = true; break;\n+                        case PARENTHESIZED_PATTERN, TYPE_PATTERN: seenPattern = true; break;\n@@ -143,1 +143,0 @@\n-        GUARDED_PATTERN(\"Integer i && i > 0\"),\n","filename":"test\/langtools\/tools\/javac\/patterns\/CaseStructureTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-        test.disambiguationTest(\"String s && s.isEmpty()\",\n+        test.disambiguationTest(\"String s when s.isEmpty()\",\n","filename":"test\/langtools\/tools\/javac\/patterns\/DisambiguatePatterns.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-            case String s && s.isEmpty(): return 1;\n+            case String s when s.isEmpty(): return 1;\n@@ -50,2 +50,2 @@\n-            case CharSequence cs && true: return 0;\n-            case String s && s.isEmpty(): return 1;\n+            case CharSequence cs when true: return 0;\n+            case String s when s.isEmpty(): return 1;\n@@ -58,1 +58,1 @@\n-            case CharSequence cs && cs.length() == 0: return 0;\n+            case CharSequence cs when cs.length() == 0: return 0;\n@@ -73,1 +73,1 @@\n-            case (String s && s.isEmpty()): return 1;\n+            case String s when s.isEmpty(): return 1;\n@@ -80,1 +80,1 @@\n-            case (String s && !s.isEmpty()): return 1;\n+            case String s when !s.isEmpty(): return 1;\n@@ -94,1 +94,1 @@\n-            case (Integer j && j == 0): return 1;\n+            case Integer j when j == 0: return 1;\n@@ -101,1 +101,1 @@\n-            case (Integer j && j == 1): return 1;\n+            case Integer j when j == 1: return 1;\n@@ -123,1 +123,1 @@\n-            case (E d && d == E.A): return 1;\n+            case E d when d == E.A: return 1;\n@@ -134,1 +134,1 @@\n-            case (E d && d == E.B): return 1;\n+            case E d when d == E.B: return 1;\n","filename":"test\/langtools\/tools\/javac\/patterns\/Domination.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,2 @@\n+        doRunExhaustive(this::expressionEnumExhaustive);\n+        doRunExhaustive(this::statementEnumExhaustive);\n@@ -52,0 +54,9 @@\n+    void doRunExhaustive(Function<EnumTypeChangesEnum, String> c) throws Exception {\n+        try {\n+            c.apply(EnumTypeChangesEnum.valueOf(\"C\"));\n+            throw new AssertionError();\n+        } catch (IncompatibleClassChangeError e) {\n+            \/\/expected\n+        }\n+    }\n+\n@@ -56,1 +67,1 @@\n-            case EnumTypeChangesEnum e1 && false -> throw new AssertionError();\n+            case EnumTypeChangesEnum e1 when false -> throw new AssertionError();\n@@ -65,1 +76,1 @@\n-            case EnumTypeChangesEnum e1 && false -> throw new AssertionError();\n+            case EnumTypeChangesEnum e1 when false -> throw new AssertionError();\n@@ -70,0 +81,17 @@\n+    String statementEnumExhaustive(EnumTypeChangesEnum e) {\n+        switch (e) {\n+            case A -> { return \"A\"; }\n+            case B -> { return \"B\"; }\n+            case EnumTypeChangesEnum x when e == EnumTypeChangesEnum.A -> throw new AssertionError();\n+        }\n+        return \"\";\n+    }\n+\n+    String expressionEnumExhaustive(EnumTypeChangesEnum e) {\n+        return switch (e) {\n+            case A -> \"A\";\n+            case B -> \"B\";\n+            case EnumTypeChangesEnum x when e == EnumTypeChangesEnum.A -> throw new AssertionError();\n+        };\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/EnumTypeChanges.java","additions":31,"deletions":3,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -210,1 +210,1 @@\n-                           case A a && a.toString().isEmpty() -> 0;\n+                           case A a when a.toString().isEmpty() -> 0;\n@@ -244,1 +244,1 @@\n-                           case A a && !(!(TEST)) -> 0;\n+                           case A a when !(!(TEST)) -> 0;\n@@ -273,1 +273,1 @@\n-                           case A a && false -> 0;\n+                           case A a when false -> 0;\n@@ -534,1 +534,1 @@\n-                           case C c && b -> 0;\n+                           case C c when b -> 0;\n@@ -574,1 +574,1 @@\n-                           case D d && b -> 0;\n+                           case D d when b -> 0;\n@@ -623,1 +623,1 @@\n-                           case C c && b -> 0;\n+                           case C c when b -> 0;\n@@ -671,1 +671,1 @@\n-                           case D d && b -> 0;\n+                           case D d when b -> 0;\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,1 @@\n+        testGuardNPE();\n@@ -69,2 +70,2 @@\n-            case Integer i && i == 0: return \"zero\";\n-            case Integer i && i == 1: return \"one\";\n+            case Integer i when i == 0: return \"zero\";\n+            case Integer i when i == 1: return \"one\";\n@@ -78,2 +79,2 @@\n-            case Integer i && i == 0 -> \"zero\";\n-            case Integer i && i == 1 -> { yield \"one\"; }\n+            case Integer i when i == 0 -> \"zero\";\n+            case Integer i when i == 1 -> { yield \"one\"; }\n@@ -88,2 +89,2 @@\n-            case Integer i && i == 0 -> (x = \"zero\") != null;\n-            case Integer i && i == 1 -> { x = \"one\"; yield true; }\n+            case Integer i when i == 0 -> (x = \"zero\") != null;\n+            case Integer i when i == 1 -> { x = \"one\"; yield true; }\n@@ -102,2 +103,2 @@\n-            case Integer i && i == 0 && i < 1 && o2 instanceof String s: o = s + String.valueOf(i); return \"true\";\n-            case Integer i && i == 0 || i > 1: o = String.valueOf(i); return \"second\";\n+            case Integer i when i == 0 && i < 1 && o2 instanceof String s: o = s + String.valueOf(i); return \"true\";\n+            case Integer i when i == 0 || i > 1: o = String.valueOf(i); return \"second\";\n@@ -111,2 +112,2 @@\n-            case Integer i && i == 0 && i < 1 && o2 instanceof String s: o = s + String.valueOf(i); yield \"true\";\n-            case Integer i && i == 0 || i > 1: o = String.valueOf(i); yield \"second\";\n+            case Integer i when i == 0 && i < 1 && o2 instanceof String s: o = s + String.valueOf(i); yield \"true\";\n+            case Integer i when i == 0 || i > 1: o = String.valueOf(i); yield \"second\";\n@@ -119,1 +120,1 @@\n-        if (o != null && o instanceof (Integer i && i == 0 && i < 1) && (o = i) != null && o2 instanceof String s) {\n+        if (o != null && o instanceof Integer i && i == 0 && i < 1 && (o = i) != null && o2 instanceof String s) {\n@@ -121,1 +122,1 @@\n-        } else if (o != null && o instanceof (Integer i && i == 0 || i > 1) && (o = i) != null) {\n+        } else if (o != null && o instanceof Integer i && (i == 0 || i > 1) && (o = i) != null) {\n@@ -130,2 +131,2 @@\n-            case (Integer i) && i == 0: o = String.valueOf(i); return \"true\";\n-            case ((Integer i) && i == 2): o = String.valueOf(i); return \"second\";\n+            case (Integer i) when i == 0: o = String.valueOf(i); return \"true\";\n+            case (Integer i) when i == 2: o = String.valueOf(i); return \"second\";\n@@ -138,2 +139,2 @@\n-            case (Integer i) && i == 0: o = String.valueOf(i); yield \"true\";\n-            case ((Integer i) && i == 2): o = String.valueOf(i); yield \"second\";\n+            case (Integer i) when i == 0: o = String.valueOf(i); yield \"true\";\n+            case (Integer i) when i == 2: o = String.valueOf(i); yield \"second\";\n@@ -145,1 +146,1 @@\n-        if (o != null && o instanceof ((Integer i) && i == 0)) {\n+        if (o != null && o instanceof (Integer i) && i == 0) {\n@@ -147,1 +148,1 @@\n-        } else if (o != null && o instanceof (((Integer i) && i == 2)) && (o = i) != null) {\n+        } else if (o != null && o instanceof (Integer i) && i == 2 && (o = i) != null) {\n@@ -155,1 +156,1 @@\n-        if (o instanceof (CharSequence cs && cs instanceof String s)) {\n+        if (o instanceof CharSequence cs && cs instanceof String s) {\n@@ -161,0 +162,20 @@\n+    void testGuardNPE() {\n+        assertEquals(\"empty\", guardNPE(\"\"));\n+        assertEquals(\"A\", guardNPE(\"A\"));\n+        assertEquals(\"other\", guardNPE(1));\n+        try {\n+            guardNPE(null);\n+            throw new AssertionError(\"Expected exception missing.\");\n+        } catch (NullPointerException ex) {\n+            \/\/expected\n+        }\n+    }\n+\n+    String guardNPE(Object o) {\n+        return switch (o) {\n+            case null, String s when s.isEmpty() -> \"empty\";\n+            case String s -> s;\n+            case Object x -> \"other\";\n+        };\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Guards.java","additions":41,"deletions":20,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+\/\/TODO: tests and error recovery for misplaced guards\n+\n@@ -35,1 +37,1 @@\n-            case Integer i && i == check -> System.err.println(); \/\/error: check is not effectivelly final\n+            case Integer i when i == check -> System.err.println(); \/\/error: check is not effectivelly final\n","filename":"test\/langtools\/tools\/javac\/patterns\/GuardsErrors.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-GuardsErrors.java:35:36: compiler.err.cant.ref.non.effectively.final.var: check, (compiler.misc.guard)\n+GuardsErrors.java:37:38: compiler.err.cant.ref.non.effectively.final.var: check, (compiler.misc.guard)\n","filename":"test\/langtools\/tools\/javac\/patterns\/GuardsErrors.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,2 @@\n+InstanceofTotalPattern.java:18:37: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.pattern.matching.instanceof), 15, 16\n+1 error\n","filename":"test\/langtools\/tools\/javac\/patterns\/InstanceofTotalPattern-15.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+InstanceofTotalPattern.java:18:19: compiler.err.instanceof.pattern.no.subtype: java.lang.String, java.lang.String\n+InstanceofTotalPattern.java:22:17: compiler.err.instanceof.pattern.no.subtype: java.lang.String, java.lang.String\n+2 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/InstanceofTotalPattern-16.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+InstanceofTotalPattern.java:18:30: compiler.warn.preview.feature.use.plural: (compiler.misc.feature.total.patterns.in.instanceof)\n+InstanceofTotalPattern.java:22:28: compiler.warn.preview.feature.use.plural: (compiler.misc.feature.total.patterns.in.instanceof)\n+2 warnings\n","filename":"test\/langtools\/tools\/javac\/patterns\/InstanceofTotalPattern-preview.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary Verify behavior of total patterns in instanceof\n+ * @compile\/fail\/ref=InstanceofTotalPattern-15.out -source 15 -Xlint:-options -XDrawDiagnostics InstanceofTotalPattern.java\n+ * @compile\/fail\/ref=InstanceofTotalPattern-16.out -source 16 -Xlint:-options -XDrawDiagnostics InstanceofTotalPattern.java\n+ * @compile\/ref=InstanceofTotalPattern-preview.out --enable-preview -source ${jdk.version} -Xlint:-options,preview -XDrawDiagnostics InstanceofTotalPattern.java\n+ * @run main\/othervm --enable-preview InstanceofTotalPattern\n+ *\/\n+\n+public class InstanceofTotalPattern {\n+\n+    public static void main(String[] args) {\n+        new InstanceofTotalPattern().totalTest();\n+    }\n+\n+    void totalTest() {\n+        String str = \"\";\n+        if (!(str instanceof String s1)) {\n+            throw new AssertionError();\n+        }\n+        str = null;\n+        if (str instanceof String s2) {\n+            throw new AssertionError();\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/InstanceofTotalPattern.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-                        if (o instanceof (CharSequence cs && cs instanceof String s)) {\n+                        if (o instanceof CharSequence cs && cs instanceof String s) {\n","filename":"test\/langtools\/tools\/javac\/patterns\/NestedPatternVariablesBytecode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,6 +48,12 @@\n-        assertEquals(0, matchingSwitch9(\"\"));\n-        assertEquals(1, matchingSwitch9(null));\n-        assertEquals(1, matchingSwitch9(0.0));\n-        assertEquals(0, matchingSwitch10(\"\"));\n-        assertEquals(1, matchingSwitch10(null));\n-        assertEquals(1, matchingSwitch10(0.0));\n+        assertEquals(0, matchingSwitch9a(\"\"));\n+        assertEquals(1, matchingSwitch9a(null));\n+        assertEquals(1, matchingSwitch9a(0.0));\n+        assertEquals(0, matchingSwitch10a(\"\"));\n+        assertEquals(1, matchingSwitch10a(null));\n+        assertEquals(1, matchingSwitch10a(0.0));\n+        assertEquals(0, matchingSwitch9b(\"\"));\n+        assertEquals(2, matchingSwitch9b(null));\n+        assertEquals(1, matchingSwitch9b(0.0));\n+        assertEquals(0, matchingSwitch10b(\"\"));\n+        assertEquals(2, matchingSwitch10b(null));\n+        assertEquals(1, matchingSwitch10b(0.0));\n@@ -129,1 +135,1 @@\n-    private int matchingSwitch9(Object obj) {\n+    private int matchingSwitch9a(Object obj) {\n@@ -132,1 +138,1 @@\n-            case Object o: yield 1;\n+            case null, Object o: yield 1;\n@@ -136,1 +142,1 @@\n-    private int matchingSwitch10(Object obj) {\n+    private int matchingSwitch10a(Object obj) {\n@@ -139,1 +145,23 @@\n-            case Object o: return 1;\n+            case null, Object o: return 1;\n+        }\n+    }\n+\n+    private int matchingSwitch9b(Object obj) {\n+        try {\n+            return switch (obj) {\n+                case String s: yield 0;\n+                case Object o: yield 1;\n+            };\n+        } catch (NullPointerException ex) {\n+            return 2;\n+        }\n+    }\n+\n+    private int matchingSwitch10b(Object obj) {\n+        try {\n+            switch (obj) {\n+                case String s: return 0;\n+                case Object o: return 1;\n+            }\n+        } catch (NullPointerException ex) {\n+            return 2;\n","filename":"test\/langtools\/tools\/javac\/patterns\/NullSwitch.java","additions":38,"deletions":10,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-            case (String s && s.isEmpty()) -> System.err.println(\"OK: \" + s);\n+            case (String s) when s.isEmpty() -> System.err.println(\"OK: \" + s);\n@@ -43,1 +43,1 @@\n-            case (String s && s.isEmpty()) -> \"OK: \" + s;\n+            case (String s) when s.isEmpty() -> \"OK: \" + s;\n@@ -46,1 +46,1 @@\n-        if (o instanceof (String s && s.isEmpty())) {\n+        if (o instanceof (String s) && s.isEmpty()) {\n@@ -49,1 +49,1 @@\n-        boolean b1 = o instanceof (String s && s.isEmpty());\n+        boolean b1 = o instanceof (String s) && s.isEmpty();\n","filename":"test\/langtools\/tools\/javac\/patterns\/Parenthesized.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -21,1 +21,1 @@\n-            case (RawTypeBindingWarning w && false) -> {}\n+            case RawTypeBindingWarning w when false -> {}\n","filename":"test\/langtools\/tools\/javac\/patterns\/RawTypeBindingWarning.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-RawTypeBindingWarning.java:21:19: compiler.warn.raw.class.use: RawTypeBindingWarning, RawTypeBindingWarning<T>\n+RawTypeBindingWarning.java:21:18: compiler.warn.raw.class.use: RawTypeBindingWarning, RawTypeBindingWarning<T>\n@@ -7,1 +7,1 @@\n-4 warnings\n+4 warnings\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/RawTypeBindingWarning.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,5 +42,5 @@\n-        doRun(this::expressionIntf, this::validateIncompatibleClassChangeError);\n-        doRun(this::statementIntf, this::validateIncompatibleClassChangeError);\n-        doRun(this::expressionCls, this::validateIncompatibleClassChangeError);\n-        doRun(this::statementCls, this::validateIncompatibleClassChangeError);\n-        doRun(this::statementFallThrough, this::validateIncompatibleClassChangeError);\n+        doRun(this::expressionIntf, this::validateMatchException);\n+        doRun(this::statementIntf, this::validateMatchException);\n+        doRun(this::expressionCls, this::validateMatchException);\n+        doRun(this::statementCls, this::validateMatchException);\n+        doRun(this::statementFallThrough, this::validateMatchException);\n@@ -63,2 +63,2 @@\n-    void validateIncompatibleClassChangeError(Throwable t) {\n-        if (!(t instanceof IncompatibleClassChangeError)) {\n+    void validateMatchException(Throwable t) {\n+        if (!(t instanceof MatchException)) {\n","filename":"test\/langtools\/tools\/javac\/patterns\/SealedTypeChanges.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,23 @@\n+\/*\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n@@ -7,1 +30,0 @@\n-import java.util.List;\n@@ -26,1 +48,1 @@\n-            case String s && s.equalsIgnoreCase(\"test\") -> s.length();\n+            case String s when s.equalsIgnoreCase(\"test\") -> s.length();\n","filename":"test\/langtools\/tools\/javac\/patterns\/SimpleAndGuardPattern.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-            case String s && s.isEmpty() || o2 instanceof Number n: return n;\n+            case String s when s.isEmpty() || o2 instanceof Number n: return n;\n@@ -184,1 +184,1 @@\n-            case String s && s.isEmpty() || o2 instanceof Number n -> n;\n+            case String s when s.isEmpty() || o2 instanceof Number n -> n;\n@@ -191,1 +191,1 @@\n-            case 1, Integer o && o != null:\n+            case 1, Integer o when o != null:\n@@ -200,1 +200,1 @@\n-            case Integer o && o != null, 1:\n+            case Integer o when o != null, 1:\n@@ -209,1 +209,1 @@\n-            case null, Integer o && o != null:\n+            case null, Integer o when o != null:\n@@ -225,1 +225,1 @@\n-            case 1, Integer o && o != null, default:\n+            case 1, Integer o when o != null, default:\n@@ -232,1 +232,1 @@\n-            case Integer o && o != null, 1, default:\n+            case Integer o when o != null, 1, default:\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-SwitchErrors.java:178:76: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n-SwitchErrors.java:184:71: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n+SwitchErrors.java:178:78: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n+SwitchErrors.java:184:73: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n@@ -35,2 +35,1 @@\n-SwitchErrors.java:200:42: compiler.err.pattern.dominated\n-SwitchErrors.java:209:24: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:200:44: compiler.err.pattern.dominated\n@@ -39,3 +38,3 @@\n-SwitchErrors.java:225:45: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:232:42: compiler.err.pattern.dominated\n-SwitchErrors.java:232:45: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:225:47: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:232:44: compiler.err.pattern.dominated\n+SwitchErrors.java:232:47: compiler.err.flows.through.from.pattern\n@@ -57,1 +56,1 @@\n-54 errors\n+53 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.out","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-        assertEquals(2, switchOverNull1());\n+        npeTest(x -> switchOverNull1());\n@@ -272,1 +272,1 @@\n-            case E x && \"A\".equals(x.name()): return \"broken\";\n+            case E x when \"A\".equals(x.name()): return \"broken\";\n@@ -282,1 +282,1 @@\n-            case E x && \"A\".equals(x.name()) -> \"broken\";\n+            case E x when \"A\".equals(x.name()) -> \"broken\";\n@@ -291,1 +291,1 @@\n-            case E x && \"C\".equals(x.name()): return \"C\";\n+            case E x when \"C\".equals(x.name()): return \"C\";\n@@ -300,1 +300,1 @@\n-            case E x && \"C\".equals(x.name()) -> \"C\";\n+            case E x when \"C\".equals(x.name()) -> \"C\";\n@@ -309,1 +309,1 @@\n-            case Object x && \"C\".equals(x.toString()): return \"C\";\n+            case Object x when \"C\".equals(x.toString()): return \"C\";\n@@ -318,1 +318,1 @@\n-            case Object x && \"C\".equals(x.toString()) -> \"C\";\n+            case Object x when \"C\".equals(x.toString()) -> \"C\";\n@@ -327,1 +327,1 @@\n-            case Runnable x && \"C\".equals(x.toString()): return \"C\";\n+            case Runnable x when \"C\".equals(x.toString()): return \"C\";\n@@ -336,1 +336,1 @@\n-            case Runnable x && \"C\".equals(x.toString()) -> \"C\";\n+            case Runnable x when \"C\".equals(x.toString()) -> \"C\";\n@@ -345,1 +345,1 @@\n-            case String x && \"C\".equals(x): return \"C\";\n+            case String x when \"C\".equals(x): return \"C\";\n@@ -354,1 +354,1 @@\n-            case String x && \"C\".equals(x) -> \"C\";\n+            case String x when \"C\".equals(x) -> \"C\";\n@@ -363,1 +363,1 @@\n-            case Integer x && x.equals(2): return \"C\";\n+            case Integer x when x.equals(2): return \"C\";\n@@ -372,1 +372,1 @@\n-            case Integer x && x.equals(2) -> \"C\";\n+            case Integer x when x.equals(2) -> \"C\";\n@@ -381,1 +381,1 @@\n-            case Integer o && o != null:\n+            case Integer o when o != null:\n@@ -392,1 +392,1 @@\n-            case Integer o && o != null:\n+            case Integer o when o != null:\n@@ -406,1 +406,1 @@\n-            case Integer o && o != null:\n+            case Integer o when o != null:\n@@ -417,1 +417,1 @@\n-            case Integer o && o != null:\n+            case Integer o when o != null:\n@@ -442,2 +442,11 @@\n-        switch (o) {\n-            case Object obj:; \/\/no break intentionally - should not fall through to any possible default\n+        try {\n+            switch (o) {\n+                case Object obj:; \/\/no break intentionally - should not fall through to any possible default\n+            }\n+            if (o == null) {\n+                throw new AssertionError();\n+            }\n+        } catch (NullPointerException ex) {\n+            if (o != null) {\n+                throw new AssertionError();\n+            }\n@@ -600,1 +609,1 @@\n-            case Integer j && j == 1 -> 6 + j;\n+            case Integer j when j == 1 -> 6 + j;\n","filename":"test\/langtools\/tools\/javac\/patterns\/Switches.java","additions":30,"deletions":21,"binary":false,"changes":51,"status":"modified"}]}