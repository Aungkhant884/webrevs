{"files":[{"patch":"@@ -35,0 +35,1 @@\n+\n@@ -62,1 +63,1 @@\n-        if (p != NULL && p == _root) {\n+        if (p != NULL && p == cgroup_path) {\n@@ -75,0 +76,13 @@\n+        } else {\n+          \/\/ Find the longest common prefix as namespaces are hierarchical.\n+          \/\/ If there are no matches between the root and the cgroup path,\n+          \/\/ the controller's mount point will be used, which is a reasonable\n+          \/\/ fallback.\n+          stringStream ss;\n+          ss.print_raw(_mount_point);\n+          const char* root_p = _root;\n+          const char* cgroup_p = cgroup_path;\n+          int last_slash = find_last_slash_pos(root_p, cgroup_p);\n+          assert(last_slash >= 0, \"not an absolute path?\");\n+          ss.print_raw(_root, last_slash);\n+          _path = os::strdup(ss.base());\n@@ -81,0 +95,15 @@\n+\/\/ Return last index of '\/' in s1 and s2 up to which point paths\n+\/\/ are the same in s1 and s2. -1 otherwise. For example\n+\/\/ returns 4 for s1 = \"\/cat\/dog\" and s2 = \"\/cat\/cow\".\n+int CgroupV1Controller::find_last_slash_pos(const char* s1, const char* s2) {\n+  int last_matching_slash_pos = -1;\n+  for (int i = 0; *s1 == *s2 && *s1 != 0; i++) {\n+    if (*s1 == '\/') {\n+      last_matching_slash_pos = i;\n+    }\n+    s1++; s2++;\n+  }\n+  return last_matching_slash_pos;\n+}\n+\n+\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -52,0 +52,2 @@\n+  private:\n+    int find_last_slash_pos(const char* s1, const char* s2);\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,1 +115,7 @@\n-            CgroupV1Subsystem subsystem = CgroupV1Subsystem.getInstance(infos);\n+            CgroupV1Subsystem subsystem = null;\n+            try {\n+                subsystem = CgroupV1Subsystem.getInstance(infos);\n+            } catch (NullPointerException e) {\n+                Logger logger = System.getLogger(\"jdk.internal.platform\");\n+                logger.log(Level.DEBUG, \"Creating cgroupv1 instance threw NPE. Metrics disabled.\");\n+            }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemFactory.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -83,8 +83,14 @@\n-                    CgroupV1MemorySubSystemController controller = new CgroupV1MemorySubSystemController(info.getMountRoot(), info.getMountPoint());\n-                    controller.setPath(info.getCgroupPath());\n-                    boolean isHierarchial = getHierarchical(controller);\n-                    controller.setHierarchical(isHierarchial);\n-                    boolean isSwapEnabled = getSwapEnabled(controller);\n-                    controller.setSwapEnabled(isSwapEnabled);\n-                    subsystem.setMemorySubSystem(controller);\n-                    anyActiveControllers = true;\n+                    try {\n+                        CgroupV1MemorySubSystemController controller = new CgroupV1MemorySubSystemController(info.getMountRoot(), info.getMountPoint());\n+                        controller.setPath(info.getCgroupPath());\n+                        boolean isHierarchial = getHierarchical(controller);\n+                        controller.setHierarchical(isHierarchial);\n+                        boolean isSwapEnabled = getSwapEnabled(controller);\n+                        controller.setSwapEnabled(isSwapEnabled);\n+                        subsystem.setMemorySubSystem(controller);\n+                        anyActiveControllers = true;\n+                    } catch (NullPointerException npe) {\n+                        \/\/ disable the memory controller, as hierarchical or\n+                        \/\/ swap enabled look-up threw NPE when trying to find interface\n+                        \/\/ files\n+                    }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1Subsystem.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -65,0 +65,16 @@\n+                    } else {\n+                        StringBuilder pathBuilder = new StringBuilder();\n+                        pathBuilder.append(mountPoint);\n+                        \/\/ Find the longest commonly shared path\n+                        String[] rTokens = root.split(\"\/\");\n+                        String[] cTokens = cgroupPath.split(\"\/\");\n+                        for (int i = 0; rTokens[i].equals(cTokens[i]); i++) {\n+                            \/\/ \"\/foo\".split() ==> [ \"\", \"foo\" ]. Therefore, skip empty\n+                            \/\/ tokens\n+                            if (rTokens[i].isEmpty() && cTokens[i].isEmpty()) {\n+                                continue;\n+                            }\n+                            pathBuilder.append(\"\/\");\n+                            pathBuilder.append(rTokens[i]);\n+                        }\n+                        path = pathBuilder.toString();\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1SubsystemController.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#ifdef LINUX\n+\n+#include \"cgroupV1Subsystem_linux.hpp\"\n+#include \"unittest.hpp\"\n+\n+typedef struct {\n+  const char* mount_path;\n+  const char* root_path;\n+  const char* cgroup_path;\n+  const char* expected_path;\n+} TestCase;\n+\n+TEST(os_linux_cgroup, set_cgroup1_subsystem_path) {\n+  TestCase host = {\n+    \"\/sys\/fs\/cgroup\/memory\",                                             \/\/ mount_path\n+    \"\/\",                                                                 \/\/ root_path\n+    \"\/user.slice\/user-1000.slice\/user@1000.service\",                     \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/memory\/user.slice\/user-1000.slice\/user@1000.service\" \/\/ expected_path\n+  };\n+  TestCase container_engine = {\n+    \"\/sys\/fs\/cgroup\/mem\",                            \/\/ mount_path\n+    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ root_path\n+    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/mem\"                             \/\/ expected_path\n+  };\n+  TestCase prefix_matched_cg = {\n+    \"\/sys\/fs\/cgroup\/memory\",                           \/\/ mount_path\n+    \"\/user.slice\/user-1000.slice\/session-50.scope\",    \/\/ root_path\n+    \"\/user.slice\/user-1000.slice\/session-3.scope\",     \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/memory\/user.slice\/user-1000.slice\" \/\/ expected_path\n+  };\n+  TestCase substring_match = {\n+    \"\/sys\/fs\/cgroup\/memory\",                           \/\/ mount_path\n+    \"\/user.slice\/user-1000.slice\",                     \/\/ root_path\n+    \"\/user.slice\/user-1000.slice\/user@1001.service\",   \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/memory\/user@1001.service\"          \/\/ expected_path\n+  };\n+  TestCase root_only_match = {\n+    \"\/sys\/fs\/cgroup\/m\",                           \/\/ mount_path\n+    \"\/machine.slice\/user-2002.slice\",             \/\/ root_path\n+    \"\/user.sl\/user-3000.slice\/user@3001.service\", \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/m\"                            \/\/ expected_path\n+  };\n+  int length = 5;\n+  TestCase* testCases[] = { &host,\n+                            &container_engine,\n+                            &prefix_matched_cg,\n+                            &substring_match,\n+                            &root_only_match };\n+  for (int i = 0; i < length; i++) {\n+    CgroupV1Controller* ctrl = new CgroupV1Controller( (char*)testCases[i]->root_path,\n+                                                       (char*)testCases[i]->mount_path);\n+    ctrl->set_subsystem_path((char*)testCases[i]->cgroup_path);\n+    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n+  }\n+}\n+\n+#endif\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux_cgroups.cpp","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import org.junit.Test;\n+\n+import jdk.internal.platform.cgroupv1.CgroupV1SubsystemController;\n+\n+\/*\n+ * @test\n+ * @key cgroups\n+ * @requires os.family == \"linux\"\n+ * @modules java.base\/jdk.internal.platform.cgroupv1\n+ * @library \/test\/lib\n+ * @run junit\/othervm CgroupV1SubsystemControllerTest\n+ *\/\n+public class CgroupV1SubsystemControllerTest {\n+\n+    @Test\n+    public void testCgPathEqualsRoot() {\n+        String root = \"\/\";\n+        String mountPoint = \"\/somemount\";\n+        CgroupV1SubsystemController ctrl = new CgroupV1SubsystemController(root, mountPoint);\n+        ctrl.setPath(\"\/\");\n+        assertEquals(mountPoint, ctrl.path());\n+    }\n+\n+    @Test\n+    public void testCgPathNonEmptyRoot() {\n+        String root = \"\/\";\n+        String mountPoint = \"\/sys\/fs\/cgroup\/memory\";\n+        CgroupV1SubsystemController ctrl = new CgroupV1SubsystemController(root, mountPoint);\n+        String cgroupPath = \"\/subpath\";\n+        ctrl.setPath(cgroupPath);\n+        String expectedPath = mountPoint + cgroupPath;\n+        assertEquals(expectedPath, ctrl.path());\n+    }\n+\n+    @Test\n+    public void testCgPathSubstring() {\n+        String root = \"\/foo\/bar\/baz\";\n+        String mountPoint = \"\/sys\/fs\/cgroup\/memory\";\n+        CgroupV1SubsystemController ctrl = new CgroupV1SubsystemController(root, mountPoint);\n+        String cgroupPath = \"\/foo\/bar\/baz\/some\";\n+        ctrl.setPath(cgroupPath);\n+        String expectedPath = mountPoint + \"\/some\";\n+        assertEquals(expectedPath, ctrl.path());\n+    }\n+\n+    @Test\n+    public void testCgPathParentMatch() {\n+        String root = \"\/user.slice\/user-1000.slice\/session-50.scope\";\n+        String mountPoint = \"\/sys\/fs\/cgroup\/memory\";\n+        CgroupV1SubsystemController ctrl = new CgroupV1SubsystemController(root, mountPoint);\n+        String cgroupPath = \"\/user.slice\/user-1000.slice\/session-3.scope\";\n+        ctrl.setPath(cgroupPath);\n+        String expectedPath = mountPoint + \"\/user.slice\/user-1000.slice\";\n+        assertEquals(expectedPath, ctrl.path());\n+    }\n+\n+    @Test\n+    public void testCgPathFallbackToMountPoint() {\n+        String root = \"\/user.slice\/user-1000.slice\/session-50.scope\";\n+        String mountPoint = \"\/sys\/fs\/cgroup\/memory\";\n+        CgroupV1SubsystemController ctrl = new CgroupV1SubsystemController(root, mountPoint);\n+        String cgroupPath = \"\/machine.slice\/machine-1032.slice\/session-3.scope\";\n+        ctrl.setPath(cgroupPath);\n+        String expectedPath = mountPoint;\n+        assertEquals(expectedPath, ctrl.path());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/CgroupV1SubsystemControllerTest.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Red Hat Inc.\n+ * Copyright (c) 2020, 2022, Red Hat, Inc.\n@@ -46,0 +46,1 @@\n+import jdk.internal.platform.cgroupv1.CgroupV1SubsystemController;\n@@ -75,0 +76,1 @@\n+    private Path cgroupv1MntInfoPrefix;\n@@ -77,0 +79,1 @@\n+    private Path cgroupv1SelfPrefix;\n@@ -169,0 +172,1 @@\n+    private String mntInfoPrefix = \"941 931 0:36 \/user.slice\/user-1000.slice\/session-50.scope \/sys\/fs\/cgroup\/memory ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,seclabel,memory\\n\";\n@@ -220,0 +224,1 @@\n+    private  String cgroupv1SelfPrefixContent = \"9:memory:\/user.slice\/user-1000.slice\/session-3.scope\\n\";\n@@ -260,0 +265,3 @@\n+            cgroupv1MntInfoPrefix = Paths.get(existingDirectory.toString(), \"mountinfo-prefix\");\n+            Files.writeString(cgroupv1MntInfoPrefix, mntInfoPrefix);\n+\n@@ -266,0 +274,3 @@\n+            cgroupv1SelfPrefix = Paths.get(existingDirectory.toString(), \"self_prefix_cgv1\");\n+            Files.writeString(cgroupv1SelfPrefix, cgroupv1SelfPrefixContent);\n+\n@@ -396,0 +407,21 @@\n+    @Test\n+    public void testMountPrefixCgroupsV1() throws IOException {\n+        String cgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String mountInfo = cgroupv1MntInfoPrefix.toString();\n+        String selfCgroup = cgroupv1SelfPrefix.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+\n+        assertTrue(\"Expected non-empty cgroup result\", result.isPresent());\n+        CgroupTypeResult res = result.get();\n+        CgroupInfo memoryInfo = res.getInfos().get(\"memory\");\n+        assertEquals(memoryInfo.getCgroupPath(), \"\/user.slice\/user-1000.slice\/session-3.scope\");\n+        String expectedMountPoint = \"\/sys\/fs\/cgroup\/memory\";\n+        assertEquals(expectedMountPoint, memoryInfo.getMountPoint());\n+        CgroupV1SubsystemController cgroupv1MemoryController = new CgroupV1SubsystemController(memoryInfo.getMountRoot(), memoryInfo.getMountPoint());\n+        cgroupv1MemoryController.setPath(memoryInfo.getCgroupPath());\n+        String actualPath = cgroupv1MemoryController.path();\n+        assertNotNull(\"Controller path should not have been null\", actualPath);\n+        String expectedPath = expectedMountPoint + \"\/user.slice\/user-1000.slice\";\n+        assertEquals(\"Should have found the longest common path\", expectedPath, actualPath);\n+    }\n+\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestCgroupSubsystemFactory.java","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"}]}