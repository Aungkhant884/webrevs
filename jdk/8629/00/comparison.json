{"files":[{"patch":"@@ -62,1 +62,1 @@\n-        if (p != NULL && p == _root) {\n+        if (p != NULL && p == cgroup_path) {\n@@ -75,0 +75,39 @@\n+        } else {\n+          \/\/ Find the longest common substring as namespaces are hierarchical.\n+          \/\/ If there are no matches between the root and the cgroup path,\n+          \/\/ the controller's mount point will be used, which is a reasonable\n+          \/\/ fallback.\n+          int buflen;\n+          strncpy(buf, _mount_point, MAXPATHLEN);\n+          buf[MAXPATHLEN-1] = '\\0';\n+          buflen = strlen(buf);\n+          if ((buflen + strlen(cgroup_path)) > (MAXPATHLEN-1)) {\n+              return;\n+          }\n+          char tmp_root_buf[MAXPATHLEN+1];\n+          char tmp_cgroup_buf[MAXPATHLEN+1];\n+          strcpy(tmp_root_buf, _root);\n+          strcpy(tmp_cgroup_buf, cgroup_path);\n+          char* tmp_root = &tmp_root_buf[0];\n+          char* tmp_cgroup = &tmp_cgroup_buf[0];\n+          char* root_save = NULL;\n+          char* cgroup_save = NULL;\n+          char* root_token = NULL;\n+          char* cg_token = NULL;\n+          char* buf_ptr = buf + buflen;\n+          while ((root_token = strtok_r(tmp_root, \"\/\", &root_save)) != NULL &&\n+                 (cg_token = strtok_r(tmp_cgroup, \"\/\", &cgroup_save)) != NULL) {\n+            if (root_token == NULL || cg_token == NULL) {\n+              break;\n+            }\n+            if (strcmp(root_token, cg_token) == 0) {\n+              strncpy(buf_ptr, \"\/\", 2);\n+              buf_ptr++;\n+              strcpy(buf_ptr, root_token);\n+              buf_ptr = buf_ptr + strlen(root_token);\n+            }\n+            tmp_root = NULL;\n+            tmp_cgroup = NULL;\n+          }\n+          buf[MAXPATHLEN-1] = '\\0';\n+          _path = os::strdup(buf);\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -115,1 +115,7 @@\n-            CgroupV1Subsystem subsystem = CgroupV1Subsystem.getInstance(infos);\n+            CgroupV1Subsystem subsystem = null;\n+            try {\n+                subsystem = CgroupV1Subsystem.getInstance(infos);\n+            } catch (NullPointerException e) {\n+                Logger logger = System.getLogger(\"jdk.internal.platform\");\n+                logger.log(Level.DEBUG, \"Creating cgroupv1 instance threw NPE. Metrics disabled.\");\n+            }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemFactory.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -83,8 +83,14 @@\n-                    CgroupV1MemorySubSystemController controller = new CgroupV1MemorySubSystemController(info.getMountRoot(), info.getMountPoint());\n-                    controller.setPath(info.getCgroupPath());\n-                    boolean isHierarchial = getHierarchical(controller);\n-                    controller.setHierarchical(isHierarchial);\n-                    boolean isSwapEnabled = getSwapEnabled(controller);\n-                    controller.setSwapEnabled(isSwapEnabled);\n-                    subsystem.setMemorySubSystem(controller);\n-                    anyActiveControllers = true;\n+                    try {\n+                        CgroupV1MemorySubSystemController controller = new CgroupV1MemorySubSystemController(info.getMountRoot(), info.getMountPoint());\n+                        controller.setPath(info.getCgroupPath());\n+                        boolean isHierarchial = getHierarchical(controller);\n+                        controller.setHierarchical(isHierarchial);\n+                        boolean isSwapEnabled = getSwapEnabled(controller);\n+                        controller.setSwapEnabled(isSwapEnabled);\n+                        subsystem.setMemorySubSystem(controller);\n+                        anyActiveControllers = true;\n+                    } catch (NullPointerException npe) {\n+                        \/\/ disable the memory controller, as hierarchical or\n+                        \/\/ swap enabled look-up threw NPE when trying to find interface\n+                        \/\/ files\n+                    }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1Subsystem.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -65,0 +65,16 @@\n+                    } else {\n+                        StringBuilder pathBuilder = new StringBuilder();\n+                        pathBuilder.append(mountPoint);\n+                        \/\/ Find the longest commonly shared path\n+                        String[] rTokens = root.split(\"\/\");\n+                        String[] cTokens = cgroupPath.split(\"\/\");\n+                        for (int i = 0; rTokens[i].equals(cTokens[i]); i++) {\n+                            \/\/ \"\/foo\".split() ==> [ \"\", \"foo\" ]. Therefore, skip empty\n+                            \/\/ tokens\n+                            if (rTokens[i].isEmpty() && cTokens[i].isEmpty()) {\n+                                continue;\n+                            }\n+                            pathBuilder.append(\"\/\");\n+                            pathBuilder.append(rTokens[i]);\n+                        }\n+                        path = pathBuilder.toString();\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1SubsystemController.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#ifdef LINUX\n+\n+#include \"cgroupV1Subsystem_linux.hpp\"\n+#include \"unittest.hpp\"\n+\n+TEST(os_linux_cgroup, set_cgroup1_subsystem_path) {\n+  int length = 5;\n+  const char* mount_paths[] =     { \"\/sys\/fs\/cgroup\/memory\",\n+                                    \"\/sys\/fs\/cgroup\/memory\", \/* non-matched cg path  *\/\n+                                    \"\/sys\/fs\/cgroup\/mem\",    \/* root matched cg path *\/\n+                                    \"\/sys\/fs\/cgroup\/memory\", \/* substring match      *\/\n+                                    \"\/sys\/fs\/cgroup\/m\"       \/* non-matched cg path  *\/\n+                                  };\n+  const char* root_paths[] =      { \"\/\",\n+                                    \"\/user.slice\/user-1000.slice\/session-50.scope\",  \/* non-matched cg path  *\/\n+                                    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/* root matched cg path *\/\n+                                    \"\/user.slice\/user-1000.slice\",                   \/* substring match *\/\n+                                    \"\/machine.slice\/user-2002.slice\"                 \/* root match only *\/\n+                                  };\n+  const char* cgroup_paths[] =    { \"\/user.slice\/user-1000.slice\/user@1000.service\",\n+                                    \"\/user.slice\/user-1000.slice\/session-3.scope\",   \/* non-matched cg path  *\/\n+                                    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/* root matched cg path *\/\n+                                    \"\/user.slice\/user-1000.slice\/user@1001.service\", \/* substring match *\/\n+                                    \"\/user.sl\/user-3000.slice\/user@3001.service\"     \/* root match only *\/\n+                                  };\n+  const char* expected_cg_paths[] { \"\/sys\/fs\/cgroup\/memory\/user.slice\/user-1000.slice\/user@1000.service\",\n+                                    \"\/sys\/fs\/cgroup\/memory\/user.slice\/user-1000.slice\", \/* closest substring match *\/\n+                                    \"\/sys\/fs\/cgroup\/mem\",                               \/* root matched cg path    *\/\n+                                    \"\/sys\/fs\/cgroup\/memory\/user@1001.service\",          \/* substring match *\/\n+                                    \"\/sys\/fs\/cgroup\/m\"                                  \/* root match only *\/\n+                                  };\n+\n+  for (int i = 0; i < length; i++) {\n+    CgroupV1Controller* ctrl = new CgroupV1Controller((char*)root_paths[i], (char*)mount_paths[i]);\n+    ctrl->set_subsystem_path((char*)cgroup_paths[i]);\n+    ASSERT_STREQ(expected_cg_paths[i], ctrl->subsystem_path());\n+  }\n+}\n+\n+#endif\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux_cgroups.cpp","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import org.junit.Test;\n+\n+import jdk.internal.platform.cgroupv1.CgroupV1SubsystemController;\n+\n+\/*\n+ * @test\n+ * @key cgroups\n+ * @requires os.family == \"linux\"\n+ * @modules java.base\/jdk.internal.platform.cgroupv1\n+ * @library \/test\/lib\n+ * @run junit\/othervm CgroupV1SubsystemControllerTest\n+ *\/\n+public class CgroupV1SubsystemControllerTest {\n+\n+    @Test\n+    public void testCgPathEqualsRoot() {\n+        String root = \"\/\";\n+        String mountPoint = \"\/somemount\";\n+        CgroupV1SubsystemController ctrl = new CgroupV1SubsystemController(root, mountPoint);\n+        ctrl.setPath(\"\/\");\n+        assertEquals(mountPoint, ctrl.path());\n+    }\n+\n+    @Test\n+    public void testCgPathNonEmptyRoot() {\n+        String root = \"\/\";\n+        String mountPoint = \"\/sys\/fs\/cgroup\/memory\";\n+        CgroupV1SubsystemController ctrl = new CgroupV1SubsystemController(root, mountPoint);\n+        String cgroupPath = \"\/subpath\";\n+        ctrl.setPath(cgroupPath);\n+        String expectedPath = mountPoint + cgroupPath;\n+        assertEquals(expectedPath, ctrl.path());\n+    }\n+\n+    @Test\n+    public void testCgPathSubstring() {\n+        String root = \"\/foo\/bar\/baz\";\n+        String mountPoint = \"\/sys\/fs\/cgroup\/memory\";\n+        CgroupV1SubsystemController ctrl = new CgroupV1SubsystemController(root, mountPoint);\n+        String cgroupPath = \"\/foo\/bar\/baz\/some\";\n+        ctrl.setPath(cgroupPath);\n+        String expectedPath = mountPoint + \"\/some\";\n+        assertEquals(expectedPath, ctrl.path());\n+    }\n+\n+    @Test\n+    public void testCgPathParentMatch() {\n+        String root = \"\/user.slice\/user-1000.slice\/session-50.scope\";\n+        String mountPoint = \"\/sys\/fs\/cgroup\/memory\";\n+        CgroupV1SubsystemController ctrl = new CgroupV1SubsystemController(root, mountPoint);\n+        String cgroupPath = \"\/user.slice\/user-1000.slice\/session-3.scope\";\n+        ctrl.setPath(cgroupPath);\n+        String expectedPath = mountPoint + \"\/user.slice\/user-1000.slice\";\n+        assertEquals(expectedPath, ctrl.path());\n+    }\n+\n+    @Test\n+    public void testCgPathFallbackToMountPoint() {\n+        String root = \"\/user.slice\/user-1000.slice\/session-50.scope\";\n+        String mountPoint = \"\/sys\/fs\/cgroup\/memory\";\n+        CgroupV1SubsystemController ctrl = new CgroupV1SubsystemController(root, mountPoint);\n+        String cgroupPath = \"\/machine.slice\/machine-1032.slice\/session-3.scope\";\n+        ctrl.setPath(cgroupPath);\n+        String expectedPath = mountPoint;\n+        assertEquals(expectedPath, ctrl.path());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/CgroupV1SubsystemControllerTest.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Red Hat Inc.\n+ * Copyright (c) 2020, 2022, Red Hat, Inc.\n@@ -46,0 +46,1 @@\n+import jdk.internal.platform.cgroupv1.CgroupV1SubsystemController;\n@@ -75,0 +76,1 @@\n+    private Path cgroupv1MntInfoPrefix;\n@@ -77,0 +79,1 @@\n+    private Path cgroupv1SelfPrefix;\n@@ -169,0 +172,1 @@\n+    private String mntInfoPrefix = \"941 931 0:36 \/user.slice\/user-1000.slice\/session-50.scope \/sys\/fs\/cgroup\/memory ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,seclabel,memory\\n\";\n@@ -220,0 +224,1 @@\n+    private  String cgroupv1SelfPrefixContent = \"9:memory:\/user.slice\/user-1000.slice\/session-3.scope\\n\";\n@@ -260,0 +265,3 @@\n+            cgroupv1MntInfoPrefix = Paths.get(existingDirectory.toString(), \"mountinfo-prefix\");\n+            Files.writeString(cgroupv1MntInfoPrefix, mntInfoPrefix);\n+\n@@ -266,0 +274,3 @@\n+            cgroupv1SelfPrefix = Paths.get(existingDirectory.toString(), \"self_prefix_cgv1\");\n+            Files.writeString(cgroupv1SelfPrefix, cgroupv1SelfPrefixContent);\n+\n@@ -396,0 +407,21 @@\n+    @Test\n+    public void testMountPrefixCgroupsV1() throws IOException {\n+        String cgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String mountInfo = cgroupv1MntInfoPrefix.toString();\n+        String selfCgroup = cgroupv1SelfPrefix.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+\n+        assertTrue(\"Expected non-empty cgroup result\", result.isPresent());\n+        CgroupTypeResult res = result.get();\n+        CgroupInfo memoryInfo = res.getInfos().get(\"memory\");\n+        assertEquals(memoryInfo.getCgroupPath(), \"\/user.slice\/user-1000.slice\/session-3.scope\");\n+        String expectedMountPoint = \"\/sys\/fs\/cgroup\/memory\";\n+        assertEquals(expectedMountPoint, memoryInfo.getMountPoint());\n+        CgroupV1SubsystemController cgroupv1MemoryController = new CgroupV1SubsystemController(memoryInfo.getMountRoot(), memoryInfo.getMountPoint());\n+        cgroupv1MemoryController.setPath(memoryInfo.getCgroupPath());\n+        String actualPath = cgroupv1MemoryController.path();\n+        assertNotNull(\"Controller path should not have been null\", actualPath);\n+        String expectedPath = expectedMountPoint + \"\/user.slice\/user-1000.slice\";\n+        assertEquals(\"Should have found the longest common path\", expectedPath, actualPath);\n+    }\n+\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestCgroupSubsystemFactory.java","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"}]}