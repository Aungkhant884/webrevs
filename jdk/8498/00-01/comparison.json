{"files":[{"patch":"@@ -6180,0 +6180,2 @@\n+#endif \/\/ _LP64\n+\n@@ -6181,0 +6183,1 @@\n+\n@@ -6191,10 +6194,0 @@\n-instruct compressBitsL_reg(rRegL dst, rRegL src, rRegL mask) %{\n-  predicate(n->bottom_type()->isa_long());\n-  match(Set dst (CompressBits src mask));\n-  format %{ \"pextq  $dst, $src, $mask\\t! parallel bit extract\" %}\n-  ins_encode %{\n-    __ pextq($dst$$Register, $src$$Register, $mask$$Register);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n@@ -6211,10 +6204,0 @@\n-instruct expandBitsL_reg(rRegL dst, rRegL src, rRegL mask) %{\n-  predicate(n->bottom_type()->isa_long());\n-  match(Set dst (ExpandBits src mask));\n-  format %{ \"pdepq  $dst, $src, $mask\\t! parallel bit deposit\" %}\n-  ins_encode %{\n-    __ pdepq($dst$$Register, $src$$Register, $mask$$Register);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n@@ -6231,10 +6214,0 @@\n-instruct compressBitsL_mem(rRegL dst, rRegL src, memory mask) %{\n-  predicate(n->bottom_type()->isa_long());\n-  match(Set dst (CompressBits src (LoadL mask)));\n-  format %{ \"pextq  $dst, $src, $mask\\t! parallel bit extract\" %}\n-  ins_encode %{\n-    __ pextq($dst$$Register, $src$$Register, $mask$$Address);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n@@ -6251,10 +6224,0 @@\n-instruct expandBitsL_mem(rRegL dst, rRegL src, memory mask) %{\n-  predicate(n->bottom_type()->isa_long());\n-  match(Set dst (ExpandBits src (LoadL mask)));\n-  format %{ \"pdepq  $dst, $src, $mask\\t! parallel bit deposit\" %}\n-  ins_encode %{\n-    __ pdepq($dst$$Register, $src$$Register, $mask$$Address);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-#endif \/\/ _LP64\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":3,"deletions":40,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -216,0 +216,1 @@\n+reg_class ebpd_reg( EBP,EDI );\n@@ -3895,0 +3896,7 @@\n+operand eBDPRegL( eRegL reg ) %{\n+  constraint(ALLOC_IN_RC(ebpd_reg));\n+  match(reg);\n+\n+  format %{ \"EBP:EDI\" %}\n+  interface(REG_INTER);\n+%}\n@@ -11468,0 +11476,89 @@\n+\/\/----------------------------- CompressBits\/ExpandBits ------------------------\n+\n+instruct compressBitsL_reg(eADXRegL dst, eBCXRegL src, eBDPRegL mask, eSIRegI rtmp, regF xtmp) %{\n+  predicate(n->bottom_type()->isa_long());\n+  match(Set dst (CompressBits src mask));\n+  effect(TEMP rtmp, TEMP xtmp);\n+  format %{ \"compress_bits32 $dst, $src, $mask\\t! using $rtmp and $xtmp as TEMP\" %}\n+  ins_encode %{\n+    Label exit, partail_result;\n+    \/\/ Parallely extract both upper and lower 32 bits of source into destination register pair.\n+    \/\/ Merge the results of upper and lower destination registers such that upper destination\n+    \/\/ results are contiguously laid out after the lower destination result.\n+    __ pextl($dst$$Register, $src$$Register, $mask$$Register);\n+    __ pextl(HIGH_FROM_LOW($dst$$Register), HIGH_FROM_LOW($src$$Register), HIGH_FROM_LOW($mask$$Register));\n+    __ popcntl($rtmp$$Register, $mask$$Register);\n+    \/\/ Skip merging if bit count of lower mask register is equal to 32 (register size).\n+    __ cmpl($rtmp$$Register, 32);\n+    __ jccb(Assembler::equal, exit);\n+    \/\/ Due to constraint on number of GPRs on 32 bit target, using XMM registers as potential spill slots.\n+    __ movdl($xtmp$$XMMRegister, $rtmp$$Register);\n+    \/\/ Shift left the contents of upper destination register by true bit count of lower mask register\n+    \/\/ and merge with lower destination register.\n+    __ shlxl($rtmp$$Register, HIGH_FROM_LOW($dst$$Register), $rtmp$$Register);\n+    __ orl($dst$$Register, $rtmp$$Register);\n+    __ movdl($rtmp$$Register, $xtmp$$XMMRegister);\n+    \/\/ Zero out upper destination register if true bit count of lower 32 bit mask is zero\n+    \/\/ since contents of upper destination have already been copied to lower destination\n+    \/\/ register.\n+    __ cmpl($rtmp$$Register, 0);\n+    __ jccb(Assembler::greater, partail_result);\n+    __ movl(HIGH_FROM_LOW($dst$$Register), 0);\n+    __ jmp(exit);\n+    __ bind(partail_result);\n+    \/\/ Perform right shift over upper destination register to move out bits already copied\n+    \/\/ to lower destination register.\n+    __ subl($rtmp$$Register, 32);\n+    __ negl($rtmp$$Register);\n+    __ shrxl(HIGH_FROM_LOW($dst$$Register), HIGH_FROM_LOW($dst$$Register), $rtmp$$Register);\n+    __ bind(exit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct expandBitsL_reg(eADXRegL dst, eBCXRegL src, eBDPRegL mask, eSIRegI rtmp, regF xtmp) %{\n+  predicate(n->bottom_type()->isa_long());\n+  match(Set dst (ExpandBits src mask));\n+  effect(TEMP rtmp, TEMP xtmp);\n+  format %{ \"expand_bits32 $dst, $src, $mask\\t! using $rtmp and $xtmp as TEMP\" %}\n+  ins_encode %{\n+    \/\/ Extraction operation sequentially reads the bits from source register starting from LSB\n+    \/\/ and lays them out into destination register at bit locations corresponding to true bits\n+    \/\/ in mask register. Thus number of source bits read are equal to combined true bit count\n+    \/\/ of mask register pair.\n+    Label exit, mask_clipping;\n+    __ pdepl($dst$$Register, $src$$Register, $mask$$Register);\n+    __ pdepl(HIGH_FROM_LOW($dst$$Register), HIGH_FROM_LOW($src$$Register), HIGH_FROM_LOW($mask$$Register));\n+    __ popcntl($rtmp$$Register, $mask$$Register);\n+    \/\/ If true bit count of lower mask register is 32 then none of bit of lower source register\n+    \/\/ will feed to upper destination register.\n+    __ cmpl($rtmp$$Register, 32);\n+    __ jccb(Assembler::equal, exit);\n+    \/\/ Due to constraint on number of GPRs on 32 bit target, using XMM registers as potential spill slots.\n+    __ movdl($xtmp$$XMMRegister, $rtmp$$Register);\n+    \/\/ Shift right the contents of lower source register to remove already consumed bits.\n+    __ shrxl($rtmp$$Register, $src$$Register, $rtmp$$Register);\n+    \/\/ Extract the bits from lower source register starting from LSB under the influence\n+    \/\/ of upper mask register.\n+    __ pdepl(HIGH_FROM_LOW($dst$$Register), $rtmp$$Register, HIGH_FROM_LOW($mask$$Register));\n+    __ movdl($rtmp$$Register, $xtmp$$XMMRegister);\n+    __ subl($rtmp$$Register, 32);\n+    __ negl($rtmp$$Register);\n+    __ movdl($xtmp$$XMMRegister, $mask$$Register);\n+    __ movl($mask$$Register, HIGH_FROM_LOW($mask$$Register));\n+    \/\/ Clear the set bits in upper mask register which have been used to extract the contents\n+    \/\/ from lower source register.\n+    __ bind(mask_clipping);\n+    __ blsrl($mask$$Register, $mask$$Register);\n+    __ decrementl($rtmp$$Register, 1);\n+    __ jccb(Assembler::greater, mask_clipping);\n+    \/\/ Starting from LSB extract the bits from upper source register under the influence of\n+    \/\/ remaining set bits in upper mask register.\n+    __ pdepl($rtmp$$Register, HIGH_FROM_LOW($src$$Register), $mask$$Register);\n+    \/\/ Merge the partial results extracted from lower and upper source register bits.\n+    __ orl(HIGH_FROM_LOW($dst$$Register), $rtmp$$Register);\n+    __ movdl($mask$$Register, $xtmp$$XMMRegister);\n+    __ bind(exit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":97,"deletions":0,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -9399,0 +9399,42 @@\n+\/\/----------------------------- CompressBits\/ExpandBits ------------------------\n+\n+instruct compressBitsL_reg(rRegL dst, rRegL src, rRegL mask) %{\n+  predicate(n->bottom_type()->isa_long());\n+  match(Set dst (CompressBits src mask));\n+  format %{ \"pextq  $dst, $src, $mask\\t! parallel bit extract\" %}\n+  ins_encode %{\n+    __ pextq($dst$$Register, $src$$Register, $mask$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct expandBitsL_reg(rRegL dst, rRegL src, rRegL mask) %{\n+  predicate(n->bottom_type()->isa_long());\n+  match(Set dst (ExpandBits src mask));\n+  format %{ \"pdepq  $dst, $src, $mask\\t! parallel bit deposit\" %}\n+  ins_encode %{\n+    __ pdepq($dst$$Register, $src$$Register, $mask$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct compressBitsL_mem(rRegL dst, rRegL src, memory mask) %{\n+  predicate(n->bottom_type()->isa_long());\n+  match(Set dst (CompressBits src (LoadL mask)));\n+  format %{ \"pextq  $dst, $src, $mask\\t! parallel bit extract\" %}\n+  ins_encode %{\n+    __ pextq($dst$$Register, $src$$Register, $mask$$Address);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct expandBitsL_mem(rRegL dst, rRegL src, memory mask) %{\n+  predicate(n->bottom_type()->isa_long());\n+  match(Set dst (ExpandBits src (LoadL mask)));\n+  format %{ \"pdepq  $dst, $src, $mask\\t! parallel bit deposit\" %}\n+  ins_encode %{\n+    __ pdepq($dst$$Register, $src$$Register, $mask$$Address);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -160,2 +160,2 @@\n-  BasicType bt = n->bottom_type()->array_element_basic_type();\n-  \/\/ compress(x, 0) == 0\n+  BasicType bt = n->bottom_type()->basic_type();\n+  \/\/ compress(x, 0) == 0, expand(x, 0) == 0\n@@ -163,1 +163,1 @@\n-  \/\/ compress(x, -1) == x\n+  \/\/ compress(x, -1) == x, expand(x, -1) == x\n@@ -166,0 +166,4 @@\n+  \/\/ expand(-1, x) == x\n+  if(n->Opcode() == Op_ExpandBits &&\n+     phase->type(n->in(1))->higher_equal(TypeInteger::minus_1(bt))) return n->in(2);\n+  return n;\n@@ -172,1 +176,0 @@\n-\n@@ -216,0 +219,60 @@\n+\n+const Type* CompressBitsNode::Value(PhaseGVN* phase) const {\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  BasicType bt = bottom_type()->basic_type();\n+  const TypeInteger* t1i = t1->is_integer(bt);\n+  const TypeInteger* t2i = t2->is_integer(bt);\n+  int w = bt == T_INT ? 32 : 64;\n+\n+  if (t1i->is_con() && t2i->is_con()) {\n+     jlong res = 0;\n+     jlong src = t1i->get_con_as_long(bt);\n+     jlong mask = t2i->get_con_as_long(bt);\n+     src = w == 32 ? src & 0xFFFFFFFFL : src;\n+     mask = w == 32 ? mask & 0xFFFFFFFFL : mask;\n+     for (int i = 0, j = 0; i < w; i++) {\n+       if(mask & 0x1) {\n+         res |= (src & 0x1) << j++;\n+       }\n+       src >>= 1;\n+       mask >>= 1;\n+     }\n+     return TypeInteger::make(res, res, w, bt);\n+  }\n+  return bottom_type();\n+}\n+\n+const Type* ExpandBitsNode::Value(PhaseGVN* phase) const {\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  BasicType bt = bottom_type()->basic_type();\n+  const TypeInteger* t1i = t1->is_integer(bt);\n+  const TypeInteger* t2i = t2->is_integer(bt);\n+  int w = bt == T_INT ? 32 : 64;\n+\n+  if (t1i->is_con() && t2i->is_con()) {\n+     jlong res = 0;\n+     jlong src = t1i->get_con_as_long(bt);\n+     jlong mask = t2i->get_con_as_long(bt);\n+     src = w == 32 ? src & 0xFFFFFFFFL : src;\n+     mask = w == 32 ? mask & 0xFFFFFFFFL : mask;\n+     for (int i = 0; i < w; i++) {\n+       if(mask & 0x1) {\n+         res |= (src & 0x1) << i;\n+         src >>= 1;\n+       }\n+       mask >>= 1;\n+     }\n+     return TypeInteger::make(res, res, w, bt);\n+  }\n+  return bottom_type();\n+}\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.cpp","additions":67,"deletions":4,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -275,0 +275,1 @@\n+  virtual const Type* Value(PhaseGVN* phase) const;\n@@ -286,0 +287,1 @@\n+  virtual const Type* Value(PhaseGVN* phase) const;\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n- * @requires os.simpleArch == \"x64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestBitShuffleOpers.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -774,0 +774,2 @@\n+# java\n+java\/lang\/CompressExpandSanityTest.java\n@@ -775,0 +777,1 @@\n+############################################################################\n","filename":"test\/jdk\/ProblemList.txt","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @ignore\n","filename":"test\/jdk\/java\/lang\/CompressExpandSanityTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @run testng\/othervm -XX:DisableIntrinsic=_expand_i,_expand_l,_compress_i,_compress_l CompressExpandTest\n","filename":"test\/jdk\/java\/lang\/CompressExpandTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}