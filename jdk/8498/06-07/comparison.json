{"files":[{"patch":"@@ -31,0 +31,3 @@\n+#include \"utilities\/population_count.hpp\"\n+#include \"utilities\/count_leading_zeros.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -220,0 +223,59 @@\n+static const Type* bitshuffle_value(const TypeInteger* src_type, const TypeInteger* mask_type, int opc, BasicType bt) {\n+\n+  jlong hi = bt == T_INT ? max_jint : max_jlong;\n+  jlong lo = bt == T_INT ? min_jint : min_jlong;\n+\n+  if(mask_type->is_con() && mask_type->get_con_as_long(bt) != -1L) {\n+    jlong maskcon = mask_type->get_con_as_long(bt);\n+    int bitcount = population_count(static_cast<julong>(bt == T_INT ? maskcon & 0xFFFFFFFFL : maskcon));\n+    if (opc == Op_CompressBits) {\n+      \/\/ Bit compression selects the source bits corresponding to true mask bits\n+      \/\/ and lays them out contiguously at desitination bit poistions starting from\n+      \/\/ LSB, remaining higher order bits are set to zero.\n+      \/\/ Thus, it will always generates a +ve value i.e. sign bit set to 0 if\n+      \/\/ any bit of constant mask value is zero.\n+      lo = 0L;\n+      hi = (1L << bitcount) - 1;\n+    } else {\n+      assert(opc == Op_ExpandBits, \"\");\n+      \/\/ Expansion sequentially reads source bits starting from LSB\n+      \/\/ and places them over destination at bit positions corresponding\n+      \/\/ set mask bit. Thus bit expansion for non-negative mask value\n+      \/\/ will always generate a +ve value.\n+      hi = maskcon >= 0L ? maskcon : maskcon ^ lo;\n+      lo = maskcon >= 0L ? 0L : lo;\n+    }\n+  }\n+\n+  if (!mask_type->is_con()) {\n+    int mask_max_bw;\n+    int max_bw = bt == T_INT ? 32 : 64;\n+    \/\/ Case 1) Mask value range includes -1.\n+    if ((mask_type->lo_as_long() < 0L && mask_type->hi_as_long() >= -1L)) {\n+      mask_max_bw = max_bw;\n+    \/\/ Case 2) Mask value range is less than -1.\n+    } else if (mask_type->hi_as_long() < -1L) {\n+      mask_max_bw = max_bw - 1;\n+    } else {\n+    \/\/ Case 3) Mask value range only includes +ve values.\n+      assert(mask_type->lo_as_long() >= 0, \"\");\n+      mask_max_bw = max_bw - count_leading_zeros(mask_type->hi_as_long());\n+    }\n+    if ( opc == Op_CompressBits) {\n+      lo = mask_max_bw == max_bw ? lo : 0L;\n+      \/\/ Compress operation is inherently an unsigned operation and\n+      \/\/ result value range is primarily dependent on true count\n+      \/\/ of participating mask value.\n+      hi = mask_max_bw < max_bw ? (1L << mask_max_bw) - 1 : src_type->hi_as_long();\n+    } else {\n+      assert(opc == Op_ExpandBits, \"\");\n+      jlong max_mask = mask_type->hi_as_long();\n+      lo = mask_type->lo_as_long() >= 0L ? 0L : lo;\n+      hi = mask_type->lo_as_long() >= 0L ? max_mask : hi;\n+    }\n+  }\n+\n+  return bt == T_INT ? static_cast<const Type*>(TypeInt::make(lo, hi, Type::WidenMax)) :\n+                       static_cast<const Type*>(TypeLong::make(lo, hi, Type::WidenMax));\n+}\n+\n@@ -228,2 +290,2 @@\n-  const TypeInteger* t1i = t1->is_integer(bt);\n-  const TypeInteger* t2i = t2->is_integer(bt);\n+  const TypeInteger* src_type = t1->is_integer(bt);\n+  const TypeInteger* mask_type = t2->is_integer(bt);\n@@ -232,13 +294,14 @@\n-  if (t1i->is_con() && t2i->is_con()) {\n-     jlong res = 0;\n-     jlong src = t1i->get_con_as_long(bt);\n-     jlong mask = t2i->get_con_as_long(bt);\n-     for (int i = 0, j = 0; i < w; i++) {\n-       if(mask & 0x1) {\n-         res |= (src & 0x1) << j++;\n-       }\n-       src >>= 1;\n-       mask >>= 1;\n-     }\n-     return bt == T_INT ? static_cast<const Type*>(TypeInt::make(res)) :\n-                          static_cast<const Type*>(TypeLong::make(res));\n+  \/\/ Constant fold if both src and mask are constants.\n+  if (src_type->is_con() && mask_type->is_con()) {\n+    jlong res = 0;\n+    jlong src = src_type->get_con_as_long(bt);\n+    jlong mask = mask_type->get_con_as_long(bt);\n+    for (int i = 0, j = 0; i < w; i++) {\n+      if(mask & 0x1) {\n+        res |= (src & 0x1) << j++;\n+      }\n+      src >>= 1;\n+      mask >>= 1;\n+    }\n+    return bt == T_INT ? static_cast<const Type*>(TypeInt::make(res)) :\n+                         static_cast<const Type*>(TypeLong::make(res));\n@@ -246,1 +309,2 @@\n-  return bottom_type();\n+\n+  return bitshuffle_value(src_type, mask_type, Op_CompressBits, bt);\n@@ -257,2 +321,2 @@\n-  const TypeInteger* t1i = t1->is_integer(bt);\n-  const TypeInteger* t2i = t2->is_integer(bt);\n+  const TypeInteger* src_type = t1->is_integer(bt);\n+  const TypeInteger* mask_type = t2->is_integer(bt);\n@@ -261,1 +325,2 @@\n-  if (t1i->is_con() && t2i->is_con()) {\n+  \/\/ Constant fold if both src and mask are constants.\n+  if (src_type->is_con() && mask_type->is_con()) {\n@@ -263,2 +328,2 @@\n-     jlong src = t1i->get_con_as_long(bt);\n-     jlong mask = t2i->get_con_as_long(bt);\n+     jlong src = src_type->get_con_as_long(bt);\n+     jlong mask = mask_type->get_con_as_long(bt);\n@@ -275,1 +340,2 @@\n-  return bottom_type();\n+\n+  return bitshuffle_value(src_type, mask_type, Op_ExpandBits, bt);\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.cpp","additions":88,"deletions":22,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        for (int i = 0; i < 10000; i++) {\n+        for (int i = 0; i < 5000; i++) {\n@@ -79,1 +79,1 @@\n-        for (int i = 0; i < 10000; i++) {\n+        for (int i = 0; i < 5000; i++) {\n@@ -94,1 +94,1 @@\n-        for (int i = 0; i < 10000; i++) {\n+        for (int i = 0; i < 5000; i++) {\n@@ -109,1 +109,1 @@\n-        for (int i = 0; i < 10000; i++) {\n+        for (int i = 0; i < 5000; i++) {\n@@ -124,1 +124,1 @@\n-        for (int i = 0; i < 10000; i++) {\n+        for (int i = 0; i < 5000; i++) {\n@@ -139,1 +139,1 @@\n-        for (int i = 0; i < 10000; i++) {\n+        for (int i = 0; i < 5000; i++) {\n@@ -154,1 +154,1 @@\n-        for (int i = 0; i < 10000; i++) {\n+        for (int i = 0; i < 5000; i++) {\n@@ -169,1 +169,1 @@\n-        for (int i = 0; i < 10000; i++) {\n+        for (int i = 0; i < 5000; i++) {\n@@ -184,1 +184,1 @@\n-        for (int i = 0; i < 10000; i++) {\n+        for (int i = 0; i < 5000; i++) {\n@@ -199,1 +199,1 @@\n-        for (int i = 0; i < 10000; i++) {\n+        for (int i = 0; i < 5000; i++) {\n@@ -214,1 +214,1 @@\n-        for (int i = 0; i < 10000; i++) {\n+        for (int i = 0; i < 5000; i++) {\n@@ -229,1 +229,1 @@\n-        for (int i = 0; i < 10000; i++) {\n+        for (int i = 0; i < 5000; i++) {\n@@ -246,1 +246,1 @@\n-        for (int i = 0; i < 10000; i++) {\n+        for (int i = 0; i < 5000; i++) {\n@@ -262,1 +262,1 @@\n-        for (int i = 0; i < 10000; i++) {\n+        for (int i = 0; i < 5000; i++) {\n@@ -278,1 +278,1 @@\n-        for (int i = 0; i < 10000; i++) {\n+        for (int i = 0; i < 5000; i++) {\n@@ -294,1 +294,1 @@\n-        for (int i = 0; i < 10000; i++) {\n+        for (int i = 0; i < 5000; i++) {\n@@ -304,1 +304,1 @@\n-        for (int i = 0; i < 10000; i++) {\n+        for (int i = 0; i < 5000; i++) {\n@@ -310,0 +310,22 @@\n+           resI = Integer.expand(ai[i&(SIZE-1)], -1);\n+           verifyExpandInt(resI, ai[i&(SIZE-1)], -1);\n+           resI = Integer.expand(ai[i&(SIZE-1)], -2);\n+           verifyExpandInt(resI, ai[i&(SIZE-1)], -2);\n+           resI = Integer.expand(ai[i&(SIZE-1)],  5);\n+           verifyExpandInt(resI, ai[i&(SIZE-1)],  5);\n+           resI = Integer.compress(ai[i&(SIZE-1)], -1);\n+           verifyCompressInt(resI, ai[i&(SIZE-1)], -1);\n+           resI = Integer.compress(ai[i&(SIZE-1)], -2);\n+           verifyCompressInt(resI, ai[i&(SIZE-1)], -2);\n+           resI = Integer.compress(ai[i&(SIZE-1)],  5);\n+           verifyCompressInt(resI, ai[i&(SIZE-1)],  5);\n+\n+           resI = Integer.expand(ai[i&(SIZE-1)], bi[i&(SIZE-1)] & ~(0x10000000));\n+           verifyExpandInt(resI, ai[i&(SIZE-1)], bi[i&(SIZE-1)] & ~(0x10000000));\n+           resI = Integer.expand(ai[i&(SIZE-1)], bi[i&(SIZE-1)] | (0x10000000));\n+           verifyExpandInt(resI, ai[i&(SIZE-1)], bi[i&(SIZE-1)] | (0x10000000));\n+           resI = Integer.compress(ai[i&(SIZE-1)], bi[i&(SIZE-1)] & ~(0x10000000));\n+           verifyCompressInt(resI, ai[i&(SIZE-1)], bi[i&(SIZE-1)] & ~(0x10000000));\n+           resI = Integer.compress(ai[i&(SIZE-1)], bi[i&(SIZE-1)] | (0x10000000));\n+           verifyCompressInt(resI, ai[i&(SIZE-1)], bi[i&(SIZE-1)] | (0x10000000));\n+\n@@ -324,0 +346,22 @@\n+\n+           resL = Long.expand(al[i&(SIZE-1)], -1);\n+           verifyExpandLong(resL, al[i&(SIZE-1)], -1);\n+           resL = Long.expand(al[i&(SIZE-1)], -2);\n+           verifyExpandLong(resL, al[i&(SIZE-1)], -2);\n+           resL = Long.expand(al[i&(SIZE-1)],  5);\n+           verifyExpandLong(resL, al[i&(SIZE-1)],  5);\n+           resL = Long.compress(al[i&(SIZE-1)], -1);\n+           verifyCompressLong(resL, al[i&(SIZE-1)], -1);\n+           resL = Long.compress(al[i&(SIZE-1)], -2);\n+           verifyCompressLong(resL, al[i&(SIZE-1)], -2);\n+           resL = Long.compress(al[i&(SIZE-1)],  5);\n+           verifyCompressLong(resL, al[i&(SIZE-1)],  5);\n+\n+           resL = Long.expand(al[i&(SIZE-1)], bl[i&(SIZE-1)] & ~(0x10000000));\n+           verifyExpandLong(resL, al[i&(SIZE-1)], bl[i&(SIZE-1)] & ~(0x10000000));\n+           resL = Long.expand(al[i&(SIZE-1)], bl[i&(SIZE-1)] | (0x10000000));\n+           verifyExpandLong(resL, al[i&(SIZE-1)], bl[i&(SIZE-1)] | (0x10000000));\n+           resL = Long.compress(al[i&(SIZE-1)], bl[i&(SIZE-1)] & ~(0x10000000));\n+           verifyCompressLong(resL, al[i&(SIZE-1)], bl[i&(SIZE-1)] & ~(0x10000000));\n+           resL = Long.compress(al[i&(SIZE-1)], bl[i&(SIZE-1)] | (0x10000000));\n+           verifyCompressLong(resL, al[i&(SIZE-1)], bl[i&(SIZE-1)] | (0x10000000));\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestBitShuffleOpers.java","additions":61,"deletions":17,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+\/\/ Disabled by default\n+\/\/ @test\n@@ -25,5 +27,4 @@\n- * \/\/@test\n- * \/\/@summary Test compress expand as if the test methods are the implementation methods\n- * \/\/@key randomness\n- * \/\/@run testng\/othervm -XX:+UnlockDiagnosticVMOptions -XX:DisableIntrinsic=_expand_i,_expand_l,_compress_i,_compress_l CompressExpandSanityTest\n- * \/\/@run testng CompressExpandSanityTest\n+ * @summary Test compress expand as if the test methods are the implementation methods\n+ * @key randomness\n+ * @run testng\/othervm -XX:+UnlockDiagnosticVMOptions -XX:DisableIntrinsic=_expand_i,_expand_l,_compress_i,_compress_l CompressExpandSanityTest\n+ * @run testng CompressExpandSanityTest\n","filename":"test\/jdk\/java\/lang\/CompressExpandSanityTest.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"}]}