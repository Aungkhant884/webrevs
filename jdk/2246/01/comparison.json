{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -50,1 +51,1 @@\n-    verify_klass(_masm, klass_reg, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_Class),\n+    verify_klass(_masm, klass_reg, VM_CLASS_ID(java_lang_Class),\n@@ -67,1 +68,1 @@\n-                                 Register obj, SystemDictionary::WKID klass_id,\n+                                 Register obj, VMClassID klass_id,\n@@ -69,2 +70,2 @@\n-  InstanceKlass** klass_addr = SystemDictionary::well_known_klass_addr(klass_id);\n-  Klass* klass = SystemDictionary::well_known_klass(klass_id);\n+  InstanceKlass** klass_addr = vmClasses::klass_addr_at(klass_id);\n+  Klass* klass = vmClasses::klass_at(klass_id);\n@@ -292,1 +293,1 @@\n-      verify_klass(_masm, member_reg, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_invoke_MemberName),\n+      verify_klass(_masm, member_reg, VM_CLASS_ID(java_lang_invoke_MemberName),\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-                           Register obj, SystemDictionary::WKID klass_id,\n+                           Register obj, VMClassID klass_id,\n@@ -43,1 +43,1 @@\n-    verify_klass(_masm, mh_reg, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_invoke_MethodHandle),\n+    verify_klass(_masm, mh_reg, VM_CLASS_ID(java_lang_invoke_MethodHandle),\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -56,1 +57,1 @@\n-    verify_klass(_masm, klass_reg, temp1, temp2, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_Class),\n+    verify_klass(_masm, klass_reg, temp1, temp2, VM_CLASS_ID(java_lang_Class),\n@@ -74,1 +75,1 @@\n-                                 Register obj, Register temp1, Register temp2, SystemDictionary::WKID klass_id,\n+                                 Register obj, Register temp1, Register temp2, VMClassID klass_id,\n@@ -76,2 +77,2 @@\n-  InstanceKlass** klass_addr = SystemDictionary::well_known_klass_addr(klass_id);\n-  Klass* klass = SystemDictionary::well_known_klass(klass_id);\n+  InstanceKlass** klass_addr = vmClasses::klass_addr_at(klass_id);\n+  Klass* klass = vmClasses::klass_at(klass_id);\n@@ -308,1 +309,1 @@\n-      verify_klass(_masm, member_reg, temp2, temp3, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_invoke_MemberName),\n+      verify_klass(_masm, member_reg, temp2, temp3, VM_CLASS_ID(java_lang_invoke_MemberName),\n","filename":"src\/hotspot\/cpu\/arm\/methodHandles_arm.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-                           Register obj, Register temp1, Register temp2, SystemDictionary::WKID klass_id,\n+                           Register obj, Register temp1, Register temp2, VMClassID klass_id,\n","filename":"src\/hotspot\/cpu\/arm\/methodHandles_arm.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -59,1 +60,1 @@\n-    verify_klass(_masm, klass_reg, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_Class),\n+    verify_klass(_masm, klass_reg, VM_CLASS_ID(java_lang_Class),\n@@ -77,1 +78,1 @@\n-                                 Register obj_reg, SystemDictionary::WKID klass_id,\n+                                 Register obj_reg, VMClassID klass_id,\n@@ -80,2 +81,2 @@\n-  InstanceKlass** klass_addr = SystemDictionary::well_known_klass_addr(klass_id);\n-  Klass* klass = SystemDictionary::well_known_klass(klass_id);\n+  InstanceKlass** klass_addr = VMClassses::klass_addr_at(klass_id);\n+  Klass* klass = VMClassses::klass_at(klass_id);\n@@ -328,1 +329,1 @@\n-      verify_klass(_masm, member_reg, SystemDictionary::WK_KLASS_ENUM_NAME(MemberName_klass),\n+      verify_klass(_masm, member_reg, VM_CLASS_ID(MemberName_klass),\n","filename":"src\/hotspot\/cpu\/ppc\/methodHandles_ppc.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-                           Register obj_reg, SystemDictionary::WKID klass_id,\n+                           Register obj_reg, VMClassID klass_id,\n@@ -45,1 +45,1 @@\n-    verify_klass(_masm, mh_reg, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_invoke_MethodHandle),\n+    verify_klass(_masm, mh_reg, VM_CLASS_ID(java_lang_invoke_MethodHandle),\n","filename":"src\/hotspot\/cpu\/ppc\/methodHandles_ppc.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -59,1 +60,1 @@\n-    verify_klass(_masm, klass_reg, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_Class),\n+    verify_klass(_masm, klass_reg, VM_CLASS_ID(java_lang_Class),\n@@ -78,1 +79,1 @@\n-                                 Register obj_reg, SystemDictionary::WKID klass_id,\n+                                 Register obj_reg, VMClassID klass_id,\n@@ -82,2 +83,2 @@\n-  InstanceKlass** klass_addr = SystemDictionary::well_known_klass_addr(klass_id);\n-  Klass* klass = SystemDictionary::well_known_klass(klass_id);\n+  InstanceKlass** klass_addr = VMClassses::klass_addr_at(klass_id);\n+  Klass* klass = VMClassses::klass_at(klass_id);\n@@ -390,1 +391,1 @@\n-                 SystemDictionary::WK_KLASS_ENUM_NAME(MemberName_klass),\n+                 VM_CLASS_ID(MemberName_klass),\n","filename":"src\/hotspot\/cpu\/s390\/methodHandles_s390.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-                           Register obj_reg, SystemDictionary::WKID klass_id,\n+                           Register obj_reg, VMClassID klass_id,\n@@ -45,1 +45,1 @@\n-    verify_klass(_masm, mh_reg, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_invoke_MethodHandle),\n+    verify_klass(_masm, mh_reg, VM_CLASS_ID(java_lang_invoke_MethodHandle),\n","filename":"src\/hotspot\/cpu\/s390\/methodHandles_s390.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -57,1 +58,1 @@\n-    verify_klass(_masm, klass_reg, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_Class),\n+    verify_klass(_masm, klass_reg, VM_CLASS_ID(java_lang_Class),\n@@ -74,1 +75,1 @@\n-                                 Register obj, SystemDictionary::WKID klass_id,\n+                                 Register obj, VMClassID klass_id,\n@@ -76,2 +77,2 @@\n-  InstanceKlass** klass_addr = SystemDictionary::well_known_klass_addr(klass_id);\n-  Klass* klass = SystemDictionary::well_known_klass(klass_id);\n+  InstanceKlass** klass_addr = vmClasses::klass_addr_at(klass_id);\n+  Klass* klass = vmClasses::klass_at(klass_id);\n@@ -348,1 +349,1 @@\n-      verify_klass(_masm, member_reg, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_invoke_MemberName),\n+      verify_klass(_masm, member_reg, VM_CLASS_ID(java_lang_invoke_MemberName),\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-                           Register obj, SystemDictionary::WKID klass_id,\n+                           Register obj, VMClassID klass_id,\n@@ -42,1 +42,1 @@\n-    verify_klass(_masm, mh_reg, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_invoke_MethodHandle),\n+    verify_klass(_masm, mh_reg, VM_CLASS_ID(MethodHandle_klass),\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,3 +88,3 @@\n-#define WK_KLASS_DEFN(name, ignore_s) ciInstanceKlass* ciEnv::_##name = NULL;\n-WK_KLASSES_DO(WK_KLASS_DEFN)\n-#undef WK_KLASS_DEFN\n+#define VM_CLASS_DEFN(name, ignore_s) ciInstanceKlass* ciEnv::_##name = NULL;\n+VM_CLASSES_DO(VM_CLASS_DEFN)\n+#undef VM_CLASS_DEFN\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClassMacros.hpp\"\n@@ -87,3 +87,3 @@\n-#define WK_KLASS_DECL(name, ignore_s) static ciInstanceKlass* _##name;\n-  WK_KLASSES_DO(WK_KLASS_DECL)\n-#undef WK_KLASS_DECL\n+#define VM_CLASS_DECL(name, ignore_s) static ciInstanceKlass* _##name;\n+  VM_CLASSES_DO(VM_CLASS_DECL)\n+#undef VM_CLASS_DECL\n@@ -386,1 +386,1 @@\n-#define WK_KLASS_FUNC(name, ignore_s) \\\n+#define VM_CLASS_FUNC(name, ignore_s) \\\n@@ -390,2 +390,2 @@\n-  WK_KLASSES_DO(WK_KLASS_FUNC)\n-#undef WK_KLASS_FUNC\n+  VM_CLASSES_DO(VM_CLASS_FUNC)\n+#undef VM_CLASS_FUNC\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"classfile\/systemDictionary.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,1 +155,1 @@\n-#define WK_KLASS_DEFN(name, ignore_s)                              \\\n+#define VM_CLASS_DEFN(name, ignore_s)                              \\\n@@ -159,2 +159,2 @@\n-  WK_KLASSES_DO(WK_KLASS_DEFN)\n-#undef WK_KLASS_DEFN\n+  VM_CLASSES_DO(VM_CLASS_DEFN)\n+#undef VM_CLASS_DEFN\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -91,1 +92,1 @@\n-  { SystemDictionary::WK_KLASS_ENUM_NAME(klass), VM_SYMBOL_ENUM_NAME(name##_name), VM_SYMBOL_ENUM_NAME(signature), may_be_java },\n+  { VM_CLASS_ID(klass), VM_SYMBOL_ENUM_NAME(name##_name), VM_SYMBOL_ENUM_NAME(signature), may_be_java },\n@@ -1313,1 +1314,1 @@\n-  \/\/ see more details in SystemDictionary::resolve_well_known_classes().\n+  \/\/ see more details in vmClasses::resolve_all().\n@@ -4919,1 +4920,1 @@\n-  \/\/ java_lang_ref_Reference) earlier inside SystemDictionary::resolve_well_known_classes()\n+  \/\/ java_lang_ref_Reference) earlier inside vmClasses::resolve_all()\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -1720,1 +1721,1 @@\n-  const SystemDictionary::WKID klass_id;\n+  const VMClassID klass_id;\n@@ -1726,1 +1727,1 @@\n-  Klass* klass() const    { return SystemDictionary::well_known_klass(klass_id); }\n+  Klass* klass() const      { return vmClasses::klass_at(klass_id); }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -60,1 +61,0 @@\n-#include \"oops\/instanceRefKlass.hpp\"\n@@ -97,5 +97,0 @@\n-InstanceKlass*      SystemDictionary::_well_known_klasses[SystemDictionary::WKID_LIMIT]\n-                                                          =  { NULL \/*, NULL...*\/ };\n-\n-InstanceKlass*      SystemDictionary::_box_klasses[T_VOID+1]      =  { NULL \/*, NULL...*\/ };\n-\n@@ -1421,30 +1416,0 @@\n-void SystemDictionary::quick_resolve(InstanceKlass* klass, ClassLoaderData* loader_data, Handle domain, TRAPS) {\n-  assert(!Universe::is_fully_initialized(), \"We can make short cuts only during VM initialization\");\n-  assert(klass->is_shared(), \"Must be shared class\");\n-  if (klass->class_loader_data() != NULL) {\n-    return;\n-  }\n-\n-  \/\/ add super and interfaces first\n-  Klass* super = klass->super();\n-  if (super != NULL && super->class_loader_data() == NULL) {\n-    assert(super->is_instance_klass(), \"Super should be instance klass\");\n-    quick_resolve(InstanceKlass::cast(super), loader_data, domain, CHECK);\n-  }\n-\n-  Array<InstanceKlass*>* ifs = klass->local_interfaces();\n-  for (int i = 0; i < ifs->length(); i++) {\n-    InstanceKlass* ik = ifs->at(i);\n-    if (ik->class_loader_data()  == NULL) {\n-      quick_resolve(ik, loader_data, domain, CHECK);\n-    }\n-  }\n-\n-  klass->restore_unshareable_info(loader_data, domain, NULL, THREAD);\n-  load_shared_class_misc(klass, loader_data, CHECK);\n-  Dictionary* dictionary = loader_data->dictionary();\n-  unsigned int hash = dictionary->compute_hash(klass->name());\n-  dictionary->add_klass(hash, klass->name(), klass);\n-  add_to_hierarchy(klass);\n-  assert(klass->is_loaded(), \"Must be in at least loaded state\");\n-}\n@@ -1860,7 +1825,0 @@\n-\/\/ CDS: scan and relocate all classes referenced by _well_known_klasses[].\n-void SystemDictionary::well_known_klasses_do(MetaspaceClosure* it) {\n-  for (int id = FIRST_WKID; id < WKID_LIMIT; id++) {\n-    it->push(well_known_klass_addr((WKID)id));\n-  }\n-}\n-\n@@ -1887,1 +1845,1 @@\n-  resolve_well_known_classes(CHECK);\n+  vmClasses::resolve_all(CHECK);\n@@ -1894,178 +1852,0 @@\n-\/\/ Compact table of directions on the initialization of klasses:\n-\/\/ TODO: we should change the base type of vmSymbolID from int to short. Then we can declare this\n-\/\/ array as vmSymbolID wk_init_info[] anf avoid all the type casts.\n-static const short wk_init_info[] = {\n-  #define WK_KLASS_INIT_INFO(name, symbol) \\\n-    ((short)VM_SYMBOL_ENUM_NAME(symbol)),\n-\n-  WK_KLASSES_DO(WK_KLASS_INIT_INFO)\n-  #undef WK_KLASS_INIT_INFO\n-  0\n-};\n-\n-#ifdef ASSERT\n-bool SystemDictionary::is_well_known_klass(Symbol* class_name) {\n-  int sid;\n-  for (int i = 0; (sid = wk_init_info[i]) != 0; i++) {\n-    Symbol* symbol = vmSymbols::symbol_at(vmSymbols::as_SID(sid));\n-    if (class_name == symbol) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-bool SystemDictionary::is_well_known_klass(Klass* k) {\n-  return is_well_known_klass(k->name());\n-}\n-#endif\n-\n-bool SystemDictionary::resolve_wk_klass(WKID id, TRAPS) {\n-  assert(id >= (int)FIRST_WKID && id < (int)WKID_LIMIT, \"oob\");\n-  int sid = wk_init_info[id - FIRST_WKID];\n-  Symbol* symbol = vmSymbols::symbol_at(vmSymbols::as_SID(sid));\n-  InstanceKlass** klassp = &_well_known_klasses[id];\n-\n-#if INCLUDE_CDS\n-  if (UseSharedSpaces && !JvmtiExport::should_post_class_prepare()) {\n-    InstanceKlass* k = *klassp;\n-    assert(k->is_shared_boot_class(), \"must be\");\n-\n-    ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();\n-    quick_resolve(k, loader_data, Handle(), CHECK_false);\n-    return true;\n-  }\n-#endif \/\/ INCLUDE_CDS\n-\n-  if (!is_wk_klass_loaded(*klassp)) {\n-    Klass* k = resolve_or_fail(symbol, true, CHECK_false);\n-    (*klassp) = InstanceKlass::cast(k);\n-  }\n-  return ((*klassp) != NULL);\n-}\n-\n-void SystemDictionary::resolve_wk_klasses_until(WKID limit_id, WKID &start_id, TRAPS) {\n-  assert((int)start_id <= (int)limit_id, \"IDs are out of order!\");\n-  for (int id = (int)start_id; id < (int)limit_id; id++) {\n-    assert(id >= (int)FIRST_WKID && id < (int)WKID_LIMIT, \"oob\");\n-    resolve_wk_klass((WKID)id, CHECK);\n-  }\n-\n-  \/\/ move the starting value forward to the limit:\n-  start_id = limit_id;\n-}\n-\n-void SystemDictionary::resolve_well_known_classes(TRAPS) {\n-  assert(!Object_klass_loaded(), \"well-known classes should only be initialized once\");\n-\n-  \/\/ Create the ModuleEntry for java.base.  This call needs to be done here,\n-  \/\/ after vmSymbols::initialize() is called but before any classes are pre-loaded.\n-  ClassLoader::classLoader_init2(CHECK);\n-\n-  \/\/ Preload commonly used klasses\n-  WKID scan = FIRST_WKID;\n-  \/\/ first do Object, then String, Class\n-#if INCLUDE_CDS\n-  if (UseSharedSpaces) {\n-    resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Object_klass), scan, CHECK);\n-\n-    \/\/ It's unsafe to access the archived heap regions before they\n-    \/\/ are fixed up, so we must do the fixup as early as possible\n-    \/\/ before the archived java objects are accessed by functions\n-    \/\/ such as java_lang_Class::restore_archived_mirror and\n-    \/\/ ConstantPool::restore_unshareable_info (restores the archived\n-    \/\/ resolved_references array object).\n-    \/\/\n-    \/\/ HeapShared::fixup_mapped_heap_regions() fills the empty\n-    \/\/ spaces in the archived heap regions and may use\n-    \/\/ SystemDictionary::Object_klass(), so we can do this only after\n-    \/\/ Object_klass is resolved. See the above resolve_wk_klasses_through()\n-    \/\/ call. No mirror objects are accessed\/restored in the above call.\n-    \/\/ Mirrors are restored after java.lang.Class is loaded.\n-    HeapShared::fixup_mapped_heap_regions();\n-\n-    \/\/ Initialize the constant pool for the Object_class\n-    assert(Object_klass()->is_shared(), \"must be\");\n-    Object_klass()->constants()->restore_unshareable_info(CHECK);\n-    resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);\n-  } else\n-#endif\n-  {\n-    resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);\n-  }\n-\n-  assert(WK_KLASS(Object_klass) != NULL, \"well-known classes should now be initialized\");\n-\n-  java_lang_Object::register_natives(CHECK);\n-\n-  \/\/ Calculate offsets for String and Class classes since they are loaded and\n-  \/\/ can be used after this point.\n-  java_lang_String::compute_offsets();\n-  java_lang_Class::compute_offsets();\n-\n-  \/\/ Fixup mirrors for classes loaded before java.lang.Class.\n-  Universe::initialize_basic_type_mirrors(CHECK);\n-  Universe::fixup_mirrors(CHECK);\n-\n-  \/\/ do a bunch more:\n-  resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Reference_klass), scan, CHECK);\n-\n-  \/\/ The offsets for jlr.Reference must be computed before\n-  \/\/ InstanceRefKlass::update_nonstatic_oop_maps is called. That function uses\n-  \/\/ the offsets to remove the referent and discovered fields from the oop maps,\n-  \/\/ as they are treated in a special way by the GC. Removing these oops from the\n-  \/\/ oop maps must be done before the usual subclasses of jlr.Reference are loaded.\n-  java_lang_ref_Reference::compute_offsets();\n-\n-  \/\/ Preload ref klasses and set reference types\n-  WK_KLASS(Reference_klass)->set_reference_type(REF_OTHER);\n-  InstanceRefKlass::update_nonstatic_oop_maps(WK_KLASS(Reference_klass));\n-\n-  resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(PhantomReference_klass), scan, CHECK);\n-  WK_KLASS(SoftReference_klass)->set_reference_type(REF_SOFT);\n-  WK_KLASS(WeakReference_klass)->set_reference_type(REF_WEAK);\n-  WK_KLASS(FinalReference_klass)->set_reference_type(REF_FINAL);\n-  WK_KLASS(PhantomReference_klass)->set_reference_type(REF_PHANTOM);\n-\n-  \/\/ JSR 292 classes\n-  WKID jsr292_group_start = WK_KLASS_ENUM_NAME(MethodHandle_klass);\n-  WKID jsr292_group_end   = WK_KLASS_ENUM_NAME(VolatileCallSite_klass);\n-  resolve_wk_klasses_until(jsr292_group_start, scan, CHECK);\n-  resolve_wk_klasses_through(jsr292_group_end, scan, CHECK);\n-  WKID last = WKID_LIMIT;\n-  resolve_wk_klasses_until(last, scan, CHECK);\n-\n-  _box_klasses[T_BOOLEAN] = WK_KLASS(Boolean_klass);\n-  _box_klasses[T_CHAR]    = WK_KLASS(Character_klass);\n-  _box_klasses[T_FLOAT]   = WK_KLASS(Float_klass);\n-  _box_klasses[T_DOUBLE]  = WK_KLASS(Double_klass);\n-  _box_klasses[T_BYTE]    = WK_KLASS(Byte_klass);\n-  _box_klasses[T_SHORT]   = WK_KLASS(Short_klass);\n-  _box_klasses[T_INT]     = WK_KLASS(Integer_klass);\n-  _box_klasses[T_LONG]    = WK_KLASS(Long_klass);\n-  \/\/_box_klasses[T_OBJECT]  = WK_KLASS(object_klass);\n-  \/\/_box_klasses[T_ARRAY]   = WK_KLASS(object_klass);\n-\n-#ifdef ASSERT\n-  if (UseSharedSpaces) {\n-    JVMTI_ONLY(assert(JvmtiExport::is_early_phase(),\n-                      \"All well known classes must be resolved in JVMTI early phase\"));\n-    for (int i = FIRST_WKID; i < last; i++) {\n-      InstanceKlass* k = _well_known_klasses[i];\n-      assert(k->is_shared(), \"must not be replaced by JVMTI class file load hook\");\n-    }\n-  }\n-#endif\n-}\n-\n-\/\/ Tells if a given klass is a box (wrapper class, such as java.lang.Integer).\n-\/\/ If so, returns the basic type it holds.  If not, returns T_OBJECT.\n-BasicType SystemDictionary::box_klass_type(Klass* k) {\n-  assert(k != NULL, \"\");\n-  for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n-    if (_box_klasses[i] == k)\n-      return (BasicType)i;\n-  }\n-  return T_OBJECT;\n-}\n-\n@@ -2819,4 +2599,0 @@\n-bool SystemDictionary::is_wk_klass_loaded(InstanceKlass* klass) {\n-  return !(klass == NULL || !klass->is_loaded());\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":2,"deletions":226,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -89,151 +90,4 @@\n-#define WK_KLASS_ENUM_NAME(kname)    kname##_knum\n-\n-\/\/ Certain classes, such as java.lang.Object and java.lang.String,\n-\/\/ are \"well-known\", in the sense that no class loader is allowed\n-\/\/ to provide a different definition.\n-\/\/\n-\/\/ Each well-known class has a short klass name (like object_klass),\n-\/\/ and a vmSymbol name (like java_lang_Object).\n-\/\/\n-\/\/ The order of these definitions is significant: the classes are\n-\/\/ resolved during early VM start-up by resolve_well_known_classes\n-\/\/ in this order. Changing the order may require careful restructuring\n-\/\/ of the VM start-up sequence.\n-\/\/\n-#define WK_KLASSES_DO(do_klass)                                                                                 \\\n-  \/* well-known classes *\/                                                                                      \\\n-  do_klass(Object_klass,                                java_lang_Object                                      ) \\\n-  do_klass(String_klass,                                java_lang_String                                      ) \\\n-  do_klass(Class_klass,                                 java_lang_Class                                       ) \\\n-  do_klass(Cloneable_klass,                             java_lang_Cloneable                                   ) \\\n-  do_klass(ClassLoader_klass,                           java_lang_ClassLoader                                 ) \\\n-  do_klass(Serializable_klass,                          java_io_Serializable                                  ) \\\n-  do_klass(System_klass,                                java_lang_System                                      ) \\\n-  do_klass(Throwable_klass,                             java_lang_Throwable                                   ) \\\n-  do_klass(Error_klass,                                 java_lang_Error                                       ) \\\n-  do_klass(ThreadDeath_klass,                           java_lang_ThreadDeath                                 ) \\\n-  do_klass(Exception_klass,                             java_lang_Exception                                   ) \\\n-  do_klass(RuntimeException_klass,                      java_lang_RuntimeException                            ) \\\n-  do_klass(SecurityManager_klass,                       java_lang_SecurityManager                             ) \\\n-  do_klass(ProtectionDomain_klass,                      java_security_ProtectionDomain                        ) \\\n-  do_klass(AccessControlContext_klass,                  java_security_AccessControlContext                    ) \\\n-  do_klass(AccessController_klass,                      java_security_AccessController                        ) \\\n-  do_klass(SecureClassLoader_klass,                     java_security_SecureClassLoader                       ) \\\n-  do_klass(ClassNotFoundException_klass,                java_lang_ClassNotFoundException                      ) \\\n-  do_klass(Record_klass,                                java_lang_Record                                      ) \\\n-  do_klass(NoClassDefFoundError_klass,                  java_lang_NoClassDefFoundError                        ) \\\n-  do_klass(LinkageError_klass,                          java_lang_LinkageError                                ) \\\n-  do_klass(ClassCastException_klass,                    java_lang_ClassCastException                          ) \\\n-  do_klass(ArrayStoreException_klass,                   java_lang_ArrayStoreException                         ) \\\n-  do_klass(VirtualMachineError_klass,                   java_lang_VirtualMachineError                         ) \\\n-  do_klass(InternalError_klass,                         java_lang_InternalError                               ) \\\n-  do_klass(OutOfMemoryError_klass,                      java_lang_OutOfMemoryError                            ) \\\n-  do_klass(StackOverflowError_klass,                    java_lang_StackOverflowError                          ) \\\n-  do_klass(IllegalMonitorStateException_klass,          java_lang_IllegalMonitorStateException                ) \\\n-  do_klass(Reference_klass,                             java_lang_ref_Reference                               ) \\\n-                                                                                                                \\\n-  \/* ref klasses and set reference types *\/                                                                     \\\n-  do_klass(SoftReference_klass,                         java_lang_ref_SoftReference                           ) \\\n-  do_klass(WeakReference_klass,                         java_lang_ref_WeakReference                           ) \\\n-  do_klass(FinalReference_klass,                        java_lang_ref_FinalReference                          ) \\\n-  do_klass(PhantomReference_klass,                      java_lang_ref_PhantomReference                        ) \\\n-  do_klass(Finalizer_klass,                             java_lang_ref_Finalizer                               ) \\\n-                                                                                                                \\\n-  do_klass(Thread_klass,                                java_lang_Thread                                      ) \\\n-  do_klass(ThreadGroup_klass,                           java_lang_ThreadGroup                                 ) \\\n-  do_klass(Properties_klass,                            java_util_Properties                                  ) \\\n-  do_klass(Module_klass,                                java_lang_Module                                      ) \\\n-  do_klass(reflect_AccessibleObject_klass,              java_lang_reflect_AccessibleObject                    ) \\\n-  do_klass(reflect_Field_klass,                         java_lang_reflect_Field                               ) \\\n-  do_klass(reflect_Parameter_klass,                     java_lang_reflect_Parameter                           ) \\\n-  do_klass(reflect_Method_klass,                        java_lang_reflect_Method                              ) \\\n-  do_klass(reflect_Constructor_klass,                   java_lang_reflect_Constructor                         ) \\\n-                                                                                                                \\\n-  \/* NOTE: needed too early in bootstrapping process to have checks based on JDK version *\/                     \\\n-  \/* It's okay if this turns out to be NULL in non-1.4 JDKs. *\/                                                 \\\n-  do_klass(reflect_MagicAccessorImpl_klass,             reflect_MagicAccessorImpl                             ) \\\n-  do_klass(reflect_MethodAccessorImpl_klass,            reflect_MethodAccessorImpl                            ) \\\n-  do_klass(reflect_ConstructorAccessorImpl_klass,       reflect_ConstructorAccessorImpl                       ) \\\n-  do_klass(reflect_DelegatingClassLoader_klass,         reflect_DelegatingClassLoader                         ) \\\n-  do_klass(reflect_ConstantPool_klass,                  reflect_ConstantPool                                  ) \\\n-  do_klass(reflect_UnsafeStaticFieldAccessorImpl_klass, reflect_UnsafeStaticFieldAccessorImpl                 ) \\\n-  do_klass(reflect_CallerSensitive_klass,               reflect_CallerSensitive                               ) \\\n-  do_klass(reflect_NativeConstructorAccessorImpl_klass, reflect_NativeConstructorAccessorImpl                 ) \\\n-                                                                                                                \\\n-  \/* support for dynamic typing; it's OK if these are NULL in earlier JDKs *\/                                   \\\n-  do_klass(DirectMethodHandle_klass,                    java_lang_invoke_DirectMethodHandle                   ) \\\n-  do_klass(MethodHandle_klass,                          java_lang_invoke_MethodHandle                         ) \\\n-  do_klass(VarHandle_klass,                             java_lang_invoke_VarHandle                            ) \\\n-  do_klass(MemberName_klass,                            java_lang_invoke_MemberName                           ) \\\n-  do_klass(ResolvedMethodName_klass,                    java_lang_invoke_ResolvedMethodName                   ) \\\n-  do_klass(MethodHandleNatives_klass,                   java_lang_invoke_MethodHandleNatives                  ) \\\n-  do_klass(LambdaForm_klass,                            java_lang_invoke_LambdaForm                           ) \\\n-  do_klass(MethodType_klass,                            java_lang_invoke_MethodType                           ) \\\n-  do_klass(BootstrapMethodError_klass,                  java_lang_BootstrapMethodError                        ) \\\n-  do_klass(CallSite_klass,                              java_lang_invoke_CallSite                             ) \\\n-  do_klass(NativeEntryPoint_klass,                      jdk_internal_invoke_NativeEntryPoint                  ) \\\n-  do_klass(Context_klass,                               java_lang_invoke_MethodHandleNatives_CallSiteContext  ) \\\n-  do_klass(ConstantCallSite_klass,                      java_lang_invoke_ConstantCallSite                     ) \\\n-  do_klass(MutableCallSite_klass,                       java_lang_invoke_MutableCallSite                      ) \\\n-  do_klass(VolatileCallSite_klass,                      java_lang_invoke_VolatileCallSite                     ) \\\n-  \/* Note: MethodHandle must be first, and VolatileCallSite last in group *\/                                    \\\n-                                                                                                                \\\n-  do_klass(AssertionStatusDirectives_klass,             java_lang_AssertionStatusDirectives                   ) \\\n-  do_klass(StringBuffer_klass,                          java_lang_StringBuffer                                ) \\\n-  do_klass(StringBuilder_klass,                         java_lang_StringBuilder                               ) \\\n-  do_klass(UnsafeConstants_klass,                       jdk_internal_misc_UnsafeConstants                     ) \\\n-  do_klass(internal_Unsafe_klass,                       jdk_internal_misc_Unsafe                              ) \\\n-  do_klass(module_Modules_klass,                        jdk_internal_module_Modules                           ) \\\n-                                                                                                                \\\n-  \/* support for CDS *\/                                                                                         \\\n-  do_klass(ByteArrayInputStream_klass,                  java_io_ByteArrayInputStream                          ) \\\n-  do_klass(URL_klass,                                   java_net_URL                                          ) \\\n-  do_klass(Jar_Manifest_klass,                          java_util_jar_Manifest                                ) \\\n-  do_klass(jdk_internal_loader_BuiltinClassLoader_klass,jdk_internal_loader_BuiltinClassLoader                ) \\\n-  do_klass(jdk_internal_loader_ClassLoaders_klass,      jdk_internal_loader_ClassLoaders                      ) \\\n-  do_klass(jdk_internal_loader_ClassLoaders_AppClassLoader_klass,      jdk_internal_loader_ClassLoaders_AppClassLoader) \\\n-  do_klass(jdk_internal_loader_ClassLoaders_PlatformClassLoader_klass, jdk_internal_loader_ClassLoaders_PlatformClassLoader) \\\n-  do_klass(CodeSource_klass,                            java_security_CodeSource                              ) \\\n-  do_klass(ConcurrentHashMap_klass,                     java_util_concurrent_ConcurrentHashMap                ) \\\n-  do_klass(ArrayList_klass,                             java_util_ArrayList                                   ) \\\n-                                                                                                                \\\n-  do_klass(StackTraceElement_klass,                     java_lang_StackTraceElement                           ) \\\n-                                                                                                                \\\n-  \/* It's okay if this turns out to be NULL in non-1.4 JDKs. *\/                                                 \\\n-  do_klass(nio_Buffer_klass,                            java_nio_Buffer                                       ) \\\n-                                                                                                                \\\n-  \/* Stack Walking *\/                                                                                           \\\n-  do_klass(StackWalker_klass,                           java_lang_StackWalker                                 ) \\\n-  do_klass(AbstractStackWalker_klass,                   java_lang_StackStreamFactory_AbstractStackWalker      ) \\\n-  do_klass(StackFrameInfo_klass,                        java_lang_StackFrameInfo                              ) \\\n-  do_klass(LiveStackFrameInfo_klass,                    java_lang_LiveStackFrameInfo                          ) \\\n-                                                                                                                \\\n-  \/* support for stack dump lock analysis *\/                                                                    \\\n-  do_klass(java_util_concurrent_locks_AbstractOwnableSynchronizer_klass, java_util_concurrent_locks_AbstractOwnableSynchronizer) \\\n-                                                                                                                \\\n-  \/* boxing klasses *\/                                                                                          \\\n-  do_klass(Boolean_klass,                               java_lang_Boolean                                     ) \\\n-  do_klass(Character_klass,                             java_lang_Character                                   ) \\\n-  do_klass(Float_klass,                                 java_lang_Float                                       ) \\\n-  do_klass(Double_klass,                                java_lang_Double                                      ) \\\n-  do_klass(Byte_klass,                                  java_lang_Byte                                        ) \\\n-  do_klass(Short_klass,                                 java_lang_Short                                       ) \\\n-  do_klass(Integer_klass,                               java_lang_Integer                                     ) \\\n-  do_klass(Long_klass,                                  java_lang_Long                                        ) \\\n-                                                                                                                \\\n-  \/* force inline of iterators *\/                                                                               \\\n-  do_klass(Iterator_klass,                              java_util_Iterator                                    ) \\\n-                                                                                                                \\\n-  \/* support for records *\/                                                                                     \\\n-  do_klass(RecordComponent_klass,                       java_lang_reflect_RecordComponent                     ) \\\n-                                                                                                                \\\n-  \/* support for vectors*\/                                                                                      \\\n-  do_klass(vector_VectorSupport_klass,                  jdk_internal_vm_vector_VectorSupport                  ) \\\n-  do_klass(vector_VectorPayload_klass,                  jdk_internal_vm_vector_VectorPayload                  ) \\\n-  do_klass(vector_Vector_klass,                         jdk_internal_vm_vector_Vector                         ) \\\n-  do_klass(vector_VectorMask_klass,                     jdk_internal_vm_vector_VectorMask                     ) \\\n-  do_klass(vector_VectorShuffle_klass,                  jdk_internal_vm_vector_VectorShuffle                  ) \\\n-                                                                                                                \\\n-  \/*end*\/\n-\n-class SystemDictionary : AllStatic {\n+\/\/ TMP: subclass from vmClasses so that we can still access the VM classes like\n+\/\/ SystemDictionary::Object_klass(). This will be fixed when we replace all SystemDictionary::*_klass()\n+\/\/ calls with vmClasses::*_klass().\n+class SystemDictionary : public vmClasses {\n@@ -241,0 +95,1 @@\n+  friend class vmClasses;\n@@ -244,11 +99,0 @@\n-  enum WKID {\n-    NO_WKID = 0,\n-\n-    #define WK_KLASS_ENUM(name, symbol) WK_KLASS_ENUM_NAME(name), WK_KLASS_ENUM_NAME(symbol) = WK_KLASS_ENUM_NAME(name),\n-    WK_KLASSES_DO(WK_KLASS_ENUM)\n-    #undef WK_KLASS_ENUM\n-\n-    WKID_LIMIT,\n-\n-    FIRST_WKID = NO_WKID + 1\n-  };\n@@ -368,48 +212,0 @@\n-  \/\/ Checked fast access to the well-known classes -- so that you don't try to use them\n-  \/\/ before they are resolved.\n-  static InstanceKlass* check_klass(InstanceKlass* k) {\n-    assert(k != NULL, \"klass not loaded\");\n-    return k;\n-  }\n-\n-  static bool resolve_wk_klass(WKID id, TRAPS);\n-  static void resolve_wk_klasses_until(WKID limit_id, WKID &start_id, TRAPS);\n-  static void resolve_wk_klasses_through(WKID end_id, WKID &start_id, TRAPS) {\n-    int limit = (int)end_id + 1;\n-    resolve_wk_klasses_until((WKID) limit, start_id, THREAD);\n-  }\n-public:\n-  #define WK_KLASS(name) _well_known_klasses[SystemDictionary::WK_KLASS_ENUM_NAME(name)]\n-\n-  #define WK_KLASS_DECLARE(name, symbol) \\\n-    static InstanceKlass* name() { return check_klass(_well_known_klasses[WK_KLASS_ENUM_NAME(name)]); } \\\n-    static InstanceKlass** name##_addr() {                                                              \\\n-      return &_well_known_klasses[SystemDictionary::WK_KLASS_ENUM_NAME(name)];                          \\\n-    }                                                                                                   \\\n-    static bool name##_is_loaded() {                                                                    \\\n-      return is_wk_klass_loaded(WK_KLASS(name));                                                        \\\n-    }\n-  WK_KLASSES_DO(WK_KLASS_DECLARE);\n-  #undef WK_KLASS_DECLARE\n-\n-  static InstanceKlass* well_known_klass(WKID id) {\n-    assert(id >= (int)FIRST_WKID && id < (int)WKID_LIMIT, \"oob\");\n-    return _well_known_klasses[id];\n-  }\n-\n-  static InstanceKlass** well_known_klass_addr(WKID id) {\n-    assert(id >= (int)FIRST_WKID && id < (int)WKID_LIMIT, \"oob\");\n-    return &_well_known_klasses[id];\n-  }\n-  static void well_known_klasses_do(MetaspaceClosure* it);\n-\n-  static InstanceKlass* box_klass(BasicType t) {\n-    assert((uint)t < T_VOID+1, \"range check\");\n-    return check_klass(_box_klasses[t]);\n-  }\n-  static BasicType box_klass_type(Klass* k);  \/\/ inverse of box_klass\n-#ifdef ASSERT\n-  static bool is_well_known_klass(Klass* k);\n-  static bool is_well_known_klass(Symbol* class_name);\n-#endif\n-\n@@ -420,1 +216,0 @@\n-  static bool is_wk_klass_loaded(InstanceKlass* klass);\n@@ -423,6 +218,0 @@\n-  static bool Object_klass_loaded()         { return is_wk_klass_loaded(WK_KLASS(Object_klass));             }\n-  static bool Class_klass_loaded()          { return is_wk_klass_loaded(WK_KLASS(Class_klass));              }\n-  static bool Cloneable_klass_loaded()      { return is_wk_klass_loaded(WK_KLASS(Cloneable_klass));          }\n-  static bool Parameter_klass_loaded()      { return is_wk_klass_loaded(WK_KLASS(reflect_Parameter_klass));  }\n-  static bool ClassLoader_klass_loaded()    { return is_wk_klass_loaded(WK_KLASS(ClassLoader_klass));        }\n-\n@@ -641,5 +430,0 @@\n-  \/\/ Resolve well-known classes so they can be used like SystemDictionary::String_klass()\n-  static void resolve_well_known_classes(TRAPS);\n-  \/\/ quick resolve using CDS for well-known classes only.\n-  static void quick_resolve(InstanceKlass* klass, ClassLoaderData* loader_data, Handle domain, TRAPS) NOT_CDS_RETURN;\n-\n@@ -653,5 +437,0 @@\n-  static InstanceKlass* _well_known_klasses[];\n-\n-  \/\/ table of box klasses (int_klass, etc.)\n-  static InstanceKlass* _box_klasses[T_VOID+1];\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":6,"deletions":227,"binary":false,"changes":233,"status":"modified"},{"patch":"@@ -2181,3 +2181,3 @@\n-void SystemDictionaryShared::serialize_well_known_klasses(SerializeClosure* soc) {\n-  for (int i = FIRST_WKID; i < WKID_LIMIT; i++) {\n-    soc->do_ptr((void**)&_well_known_klasses[i]);\n+void SystemDictionaryShared::serialize_vm_classes(SerializeClosure* soc) {\n+  for (auto id : EnumRange<VMClassID>{}) {\n+    soc->do_ptr((void**)klass_addr_at(id));\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -319,1 +319,1 @@\n-  static void serialize_well_known_klasses(class SerializeClosure* soc);\n+  static void serialize_vm_classes(class SerializeClosure* soc);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CLASSFILE_VMCLASSID_HPP\n+#define SHARE_CLASSFILE_VMCLASSID_HPP\n+\n+#include \"classfile\/vmClassMacros.hpp\"\n+#include \"utilities\/enumIterator.hpp\"\n+\n+enum class VMClassID : int {\n+  #define DECLARE_VM_CLASS(name, symbol) _VM_CLASS_ENUM(name), _VM_CLASS_ENUM(symbol) = _VM_CLASS_ENUM(name),\n+  VM_CLASSES_DO(DECLARE_VM_CLASS)\n+  #undef DECLARE_VM_CLASS\n+\n+  LIMIT,             \/\/ exclusive upper limit\n+  FIRST = 0,         \/\/ inclusive upper limit\n+  LAST = LIMIT - 1   \/\/ inclusive upper limit\n+};\n+\n+ENUMERATOR_RANGE(VMClassID, VMClassID::FIRST, VMClassID::LAST) \/\/ (inclusive start, inclusive end)\n+\n+#endif \/\/ SHARE_CLASSFILE_VMCLASSID_HPP\n","filename":"src\/hotspot\/share\/classfile\/vmClassID.hpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CLASSFILE_VMCLASSMACROS_HPP\n+#define SHARE_CLASSFILE_VMCLASSMACROS_HPP\n+\n+\/\/ _VM_CLASS_ENUM - internal: should be used only by VMClass*.{hpp,cpp}\n+#define _VM_CLASS_ENUM(kname)    kname##_knum\n+\n+#define VM_CLASS_ID(kname)      VMClassID::_VM_CLASS_ENUM(kname)\n+\n+\/\/ VM_CLASSES_DO iterates the classes that are directly referenced\n+\/\/ by the VM, suhch as java.lang.Object and java.lang.String. These\n+\/\/ classes are resolved at VM bootstrap, before any Java code is executed,\n+\/\/ so no class loader is able to provide a different definition.\n+\/\/\n+\/\/ Each VM class has a short klass name (like Object_klass),\n+\/\/ and a vmSymbol name (like java_lang_Object). Both of these can\n+\/\/ be used to find the VMClassID for this class. The following two\n+\/\/ macros will evaluate to the same value:\n+\/\/\n+\/\/    VM_CLASS_ID(Object_klass)\n+\/\/    VM_CLASS_ID(java_lang_Object)\n+\/\/\n+\/\/ The order of these definitions is significant: the classes are\n+\/\/ resolved by vmClasses::resolve_all() in this order. Changing the\n+\/\/ order may require careful restructuring of the VM start-up sequence.\n+\/\/\n+#define VM_CLASSES_DO(do_klass)                                                                                 \\\n+  \/* well-known classes *\/                                                                                      \\\n+  do_klass(Object_klass,                                java_lang_Object                                      ) \\\n+  do_klass(String_klass,                                java_lang_String                                      ) \\\n+  do_klass(Class_klass,                                 java_lang_Class                                       ) \\\n+  do_klass(Cloneable_klass,                             java_lang_Cloneable                                   ) \\\n+  do_klass(ClassLoader_klass,                           java_lang_ClassLoader                                 ) \\\n+  do_klass(Serializable_klass,                          java_io_Serializable                                  ) \\\n+  do_klass(System_klass,                                java_lang_System                                      ) \\\n+  do_klass(Throwable_klass,                             java_lang_Throwable                                   ) \\\n+  do_klass(Error_klass,                                 java_lang_Error                                       ) \\\n+  do_klass(ThreadDeath_klass,                           java_lang_ThreadDeath                                 ) \\\n+  do_klass(Exception_klass,                             java_lang_Exception                                   ) \\\n+  do_klass(RuntimeException_klass,                      java_lang_RuntimeException                            ) \\\n+  do_klass(SecurityManager_klass,                       java_lang_SecurityManager                             ) \\\n+  do_klass(ProtectionDomain_klass,                      java_security_ProtectionDomain                        ) \\\n+  do_klass(AccessControlContext_klass,                  java_security_AccessControlContext                    ) \\\n+  do_klass(AccessController_klass,                      java_security_AccessController                        ) \\\n+  do_klass(SecureClassLoader_klass,                     java_security_SecureClassLoader                       ) \\\n+  do_klass(ClassNotFoundException_klass,                java_lang_ClassNotFoundException                      ) \\\n+  do_klass(Record_klass,                                java_lang_Record                                      ) \\\n+  do_klass(NoClassDefFoundError_klass,                  java_lang_NoClassDefFoundError                        ) \\\n+  do_klass(LinkageError_klass,                          java_lang_LinkageError                                ) \\\n+  do_klass(ClassCastException_klass,                    java_lang_ClassCastException                          ) \\\n+  do_klass(ArrayStoreException_klass,                   java_lang_ArrayStoreException                         ) \\\n+  do_klass(VirtualMachineError_klass,                   java_lang_VirtualMachineError                         ) \\\n+  do_klass(InternalError_klass,                         java_lang_InternalError                               ) \\\n+  do_klass(OutOfMemoryError_klass,                      java_lang_OutOfMemoryError                            ) \\\n+  do_klass(StackOverflowError_klass,                    java_lang_StackOverflowError                          ) \\\n+  do_klass(IllegalMonitorStateException_klass,          java_lang_IllegalMonitorStateException                ) \\\n+  do_klass(Reference_klass,                             java_lang_ref_Reference                               ) \\\n+                                                                                                                \\\n+  \/* ref klasses and set reference types *\/                                                                     \\\n+  do_klass(SoftReference_klass,                         java_lang_ref_SoftReference                           ) \\\n+  do_klass(WeakReference_klass,                         java_lang_ref_WeakReference                           ) \\\n+  do_klass(FinalReference_klass,                        java_lang_ref_FinalReference                          ) \\\n+  do_klass(PhantomReference_klass,                      java_lang_ref_PhantomReference                        ) \\\n+  do_klass(Finalizer_klass,                             java_lang_ref_Finalizer                               ) \\\n+                                                                                                                \\\n+  do_klass(Thread_klass,                                java_lang_Thread                                      ) \\\n+  do_klass(ThreadGroup_klass,                           java_lang_ThreadGroup                                 ) \\\n+  do_klass(Properties_klass,                            java_util_Properties                                  ) \\\n+  do_klass(Module_klass,                                java_lang_Module                                      ) \\\n+  do_klass(reflect_AccessibleObject_klass,              java_lang_reflect_AccessibleObject                    ) \\\n+  do_klass(reflect_Field_klass,                         java_lang_reflect_Field                               ) \\\n+  do_klass(reflect_Parameter_klass,                     java_lang_reflect_Parameter                           ) \\\n+  do_klass(reflect_Method_klass,                        java_lang_reflect_Method                              ) \\\n+  do_klass(reflect_Constructor_klass,                   java_lang_reflect_Constructor                         ) \\\n+                                                                                                                \\\n+  \/* NOTE: needed too early in bootstrapping process to have checks based on JDK version *\/                     \\\n+  \/* It's okay if this turns out to be NULL in non-1.4 JDKs. *\/                                                 \\\n+  do_klass(reflect_MagicAccessorImpl_klass,             reflect_MagicAccessorImpl                             ) \\\n+  do_klass(reflect_MethodAccessorImpl_klass,            reflect_MethodAccessorImpl                            ) \\\n+  do_klass(reflect_ConstructorAccessorImpl_klass,       reflect_ConstructorAccessorImpl                       ) \\\n+  do_klass(reflect_DelegatingClassLoader_klass,         reflect_DelegatingClassLoader                         ) \\\n+  do_klass(reflect_ConstantPool_klass,                  reflect_ConstantPool                                  ) \\\n+  do_klass(reflect_UnsafeStaticFieldAccessorImpl_klass, reflect_UnsafeStaticFieldAccessorImpl                 ) \\\n+  do_klass(reflect_CallerSensitive_klass,               reflect_CallerSensitive                               ) \\\n+  do_klass(reflect_NativeConstructorAccessorImpl_klass, reflect_NativeConstructorAccessorImpl                 ) \\\n+                                                                                                                \\\n+  \/* support for dynamic typing; it's OK if these are NULL in earlier JDKs *\/                                   \\\n+  do_klass(DirectMethodHandle_klass,                    java_lang_invoke_DirectMethodHandle                   ) \\\n+  do_klass(MethodHandle_klass,                          java_lang_invoke_MethodHandle                         ) \\\n+  do_klass(VarHandle_klass,                             java_lang_invoke_VarHandle                            ) \\\n+  do_klass(MemberName_klass,                            java_lang_invoke_MemberName                           ) \\\n+  do_klass(ResolvedMethodName_klass,                    java_lang_invoke_ResolvedMethodName                   ) \\\n+  do_klass(MethodHandleNatives_klass,                   java_lang_invoke_MethodHandleNatives                  ) \\\n+  do_klass(LambdaForm_klass,                            java_lang_invoke_LambdaForm                           ) \\\n+  do_klass(MethodType_klass,                            java_lang_invoke_MethodType                           ) \\\n+  do_klass(BootstrapMethodError_klass,                  java_lang_BootstrapMethodError                        ) \\\n+  do_klass(CallSite_klass,                              java_lang_invoke_CallSite                             ) \\\n+  do_klass(NativeEntryPoint_klass,                      jdk_internal_invoke_NativeEntryPoint                  ) \\\n+  do_klass(Context_klass,                               java_lang_invoke_MethodHandleNatives_CallSiteContext  ) \\\n+  do_klass(ConstantCallSite_klass,                      java_lang_invoke_ConstantCallSite                     ) \\\n+  do_klass(MutableCallSite_klass,                       java_lang_invoke_MutableCallSite                      ) \\\n+  do_klass(VolatileCallSite_klass,                      java_lang_invoke_VolatileCallSite                     ) \\\n+  \/* Note: MethodHandle must be first, and VolatileCallSite last in group *\/                                    \\\n+                                                                                                                \\\n+  do_klass(AssertionStatusDirectives_klass,             java_lang_AssertionStatusDirectives                   ) \\\n+  do_klass(StringBuffer_klass,                          java_lang_StringBuffer                                ) \\\n+  do_klass(StringBuilder_klass,                         java_lang_StringBuilder                               ) \\\n+  do_klass(UnsafeConstants_klass,                       jdk_internal_misc_UnsafeConstants                     ) \\\n+  do_klass(internal_Unsafe_klass,                       jdk_internal_misc_Unsafe                              ) \\\n+  do_klass(module_Modules_klass,                        jdk_internal_module_Modules                           ) \\\n+                                                                                                                \\\n+  \/* support for CDS *\/                                                                                         \\\n+  do_klass(ByteArrayInputStream_klass,                  java_io_ByteArrayInputStream                          ) \\\n+  do_klass(URL_klass,                                   java_net_URL                                          ) \\\n+  do_klass(Jar_Manifest_klass,                          java_util_jar_Manifest                                ) \\\n+  do_klass(jdk_internal_loader_BuiltinClassLoader_klass,jdk_internal_loader_BuiltinClassLoader                ) \\\n+  do_klass(jdk_internal_loader_ClassLoaders_klass,      jdk_internal_loader_ClassLoaders                      ) \\\n+  do_klass(jdk_internal_loader_ClassLoaders_AppClassLoader_klass,      jdk_internal_loader_ClassLoaders_AppClassLoader) \\\n+  do_klass(jdk_internal_loader_ClassLoaders_PlatformClassLoader_klass, jdk_internal_loader_ClassLoaders_PlatformClassLoader) \\\n+  do_klass(CodeSource_klass,                            java_security_CodeSource                              ) \\\n+  do_klass(ConcurrentHashMap_klass,                     java_util_concurrent_ConcurrentHashMap                ) \\\n+  do_klass(ArrayList_klass,                             java_util_ArrayList                                   ) \\\n+                                                                                                                \\\n+  do_klass(StackTraceElement_klass,                     java_lang_StackTraceElement                           ) \\\n+                                                                                                                \\\n+  \/* It's okay if this turns out to be NULL in non-1.4 JDKs. *\/                                                 \\\n+  do_klass(nio_Buffer_klass,                            java_nio_Buffer                                       ) \\\n+                                                                                                                \\\n+  \/* Stack Walking *\/                                                                                           \\\n+  do_klass(StackWalker_klass,                           java_lang_StackWalker                                 ) \\\n+  do_klass(AbstractStackWalker_klass,                   java_lang_StackStreamFactory_AbstractStackWalker      ) \\\n+  do_klass(StackFrameInfo_klass,                        java_lang_StackFrameInfo                              ) \\\n+  do_klass(LiveStackFrameInfo_klass,                    java_lang_LiveStackFrameInfo                          ) \\\n+                                                                                                                \\\n+  \/* support for stack dump lock analysis *\/                                                                    \\\n+  do_klass(java_util_concurrent_locks_AbstractOwnableSynchronizer_klass, java_util_concurrent_locks_AbstractOwnableSynchronizer) \\\n+                                                                                                                \\\n+  \/* boxing klasses *\/                                                                                          \\\n+  do_klass(Boolean_klass,                               java_lang_Boolean                                     ) \\\n+  do_klass(Character_klass,                             java_lang_Character                                   ) \\\n+  do_klass(Float_klass,                                 java_lang_Float                                       ) \\\n+  do_klass(Double_klass,                                java_lang_Double                                      ) \\\n+  do_klass(Byte_klass,                                  java_lang_Byte                                        ) \\\n+  do_klass(Short_klass,                                 java_lang_Short                                       ) \\\n+  do_klass(Integer_klass,                               java_lang_Integer                                     ) \\\n+  do_klass(Long_klass,                                  java_lang_Long                                        ) \\\n+                                                                                                                \\\n+  \/* force inline of iterators *\/                                                                               \\\n+  do_klass(Iterator_klass,                              java_util_Iterator                                    ) \\\n+                                                                                                                \\\n+  \/* support for records *\/                                                                                     \\\n+  do_klass(RecordComponent_klass,                       java_lang_reflect_RecordComponent                     ) \\\n+                                                                                                                \\\n+  \/* support for vectors*\/                                                                                      \\\n+  do_klass(vector_VectorSupport_klass,                  jdk_internal_vm_vector_VectorSupport                  ) \\\n+  do_klass(vector_VectorPayload_klass,                  jdk_internal_vm_vector_VectorPayload                  ) \\\n+  do_klass(vector_Vector_klass,                         jdk_internal_vm_vector_Vector                         ) \\\n+  do_klass(vector_VectorMask_klass,                     jdk_internal_vm_vector_VectorMask                     ) \\\n+  do_klass(vector_VectorShuffle_klass,                  jdk_internal_vm_vector_VectorShuffle                  ) \\\n+                                                                                                                \\\n+  \/*end*\/\n+\n+#endif \/\/ SHARE_CLASSFILE_VMCLASSMACROS_HPP\n+\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -0,0 +1,261 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n+#include \"classfile\/classLoaderData.hpp\"\n+#include \"classfile\/dictionary.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"memory\/heapShared.hpp\"\n+#include \"memory\/metaspaceClosure.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/instanceRefKlass.hpp\"\n+#include \"prims\/jvmtiExport.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+InstanceKlass* vmClasses::_klasses[static_cast<int>(VMClassID::LIMIT)]\n+                                                 =  { NULL \/*, NULL...*\/ };\n+InstanceKlass* vmClasses::_box_klasses[T_VOID+1] =  { NULL \/*, NULL...*\/ };\n+\n+\n+\/\/ CDS: scan and relocate all classes referenced by _klasses[].\n+void vmClasses::metaspace_pointers_do(MetaspaceClosure* it) {\n+  for (auto id : EnumRange<VMClassID>{}) {\n+    it->push(klass_addr_at(id));\n+  }\n+}\n+\n+bool vmClasses::is_loaded(InstanceKlass* klass) {\n+  return klass != NULL && klass->is_loaded();\n+}\n+\n+\/\/ Compact table of the vmSymbolIDs of all the VM classes (stored as short to save space)\n+static const short vm_class_name_ids[] = {\n+  #define VM_CLASS_NAME(name, symbol) ((short)VM_SYMBOL_ENUM_NAME(symbol)),\n+  VM_CLASSES_DO(VM_CLASS_NAME)\n+  #undef VM_CLASS_NAME\n+  0\n+};\n+\n+\n+#ifdef ASSERT\n+bool vmClasses::contain(Symbol* class_name) {\n+  int sid;\n+  for (int i = 0; (sid = vm_class_name_ids[i]) != 0; i++) {\n+    Symbol* symbol = vmSymbols::symbol_at(vmSymbols::as_SID(sid));\n+    if (class_name == symbol) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool vmClasses::contain(Klass* k) {\n+  return contain(k->name());\n+}\n+#endif\n+\n+bool vmClasses::resolve(VMClassID id, TRAPS) {\n+  InstanceKlass** klassp = &_klasses[as_int(id)];\n+\n+#if INCLUDE_CDS\n+  if (UseSharedSpaces && !JvmtiExport::should_post_class_prepare()) {\n+    InstanceKlass* k = *klassp;\n+    assert(k->is_shared_boot_class(), \"must be\");\n+\n+    ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();\n+    resolve_shared_class(k, loader_data, Handle(), CHECK_false);\n+    return true;\n+  }\n+#endif \/\/ INCLUDE_CDS\n+\n+  if (!is_loaded(*klassp)) {\n+    int sid = vm_class_name_ids[as_int(id)];\n+    Symbol* symbol = vmSymbols::symbol_at(vmSymbols::as_SID(sid));\n+    Klass* k = SystemDictionary::resolve_or_fail(symbol, true, CHECK_false);\n+    (*klassp) = InstanceKlass::cast(k);\n+  }\n+  return ((*klassp) != NULL);\n+}\n+\n+void vmClasses::resolve_until(VMClassID limit_id, VMClassID &start_id, TRAPS) {\n+  assert((int)start_id <= (int)limit_id, \"IDs are out of order!\");\n+  for (auto id : EnumRange<VMClassID>{start_id, limit_id}) { \/\/ (inclusive start, exclusive end)\n+    resolve(id, CHECK);\n+  }\n+\n+  \/\/ move the starting value forward to the limit:\n+  start_id = limit_id;\n+}\n+\n+void vmClasses::resolve_all(TRAPS) {\n+  assert(!Object_klass_loaded(), \"well-known classes should only be initialized once\");\n+\n+  \/\/ Create the ModuleEntry for java.base.  This call needs to be done here,\n+  \/\/ after vmSymbols::initialize() is called but before any classes are pre-loaded.\n+  ClassLoader::classLoader_init2(CHECK);\n+\n+  \/\/ Preload commonly used klasses\n+  VMClassID scan = VMClassID::FIRST;\n+  \/\/ first do Object, then String, Class\n+#if INCLUDE_CDS\n+  if (UseSharedSpaces) {\n+    resolve_through(VM_CLASS_ID(Object_klass), scan, CHECK);\n+\n+    \/\/ It's unsafe to access the archived heap regions before they\n+    \/\/ are fixed up, so we must do the fixup as early as possible\n+    \/\/ before the archived java objects are accessed by functions\n+    \/\/ such as java_lang_Class::restore_archived_mirror and\n+    \/\/ ConstantPool::restore_unshareable_info (restores the archived\n+    \/\/ resolved_references array object).\n+    \/\/\n+    \/\/ HeapShared::fixup_mapped_heap_regions() fills the empty\n+    \/\/ spaces in the archived heap regions and may use\n+    \/\/ SystemDictionary::Object_klass(), so we can do this only after\n+    \/\/ Object_klass is resolved. See the above resolve_through()\n+    \/\/ call. No mirror objects are accessed\/restored in the above call.\n+    \/\/ Mirrors are restored after java.lang.Class is loaded.\n+    HeapShared::fixup_mapped_heap_regions();\n+\n+    \/\/ Initialize the constant pool for the Object_class\n+    assert(Object_klass()->is_shared(), \"must be\");\n+    Object_klass()->constants()->restore_unshareable_info(CHECK);\n+    resolve_through(VM_CLASS_ID(Class_klass), scan, CHECK);\n+  } else\n+#endif\n+  {\n+    resolve_through(VM_CLASS_ID(Class_klass), scan, CHECK);\n+  }\n+\n+  assert(vmClasses::Object_klass() != NULL, \"well-known classes should now be initialized\");\n+\n+  java_lang_Object::register_natives(CHECK);\n+\n+  \/\/ Calculate offsets for String and Class classes since they are loaded and\n+  \/\/ can be used after this point.\n+  java_lang_String::compute_offsets();\n+  java_lang_Class::compute_offsets();\n+\n+  \/\/ Fixup mirrors for classes loaded before java.lang.Class.\n+  Universe::initialize_basic_type_mirrors(CHECK);\n+  Universe::fixup_mirrors(CHECK);\n+\n+  \/\/ do a bunch more:\n+  resolve_through(VM_CLASS_ID(Reference_klass), scan, CHECK);\n+\n+  \/\/ The offsets for jlr.Reference must be computed before\n+  \/\/ InstanceRefKlass::update_nonstatic_oop_maps is called. That function uses\n+  \/\/ the offsets to remove the referent and discovered fields from the oop maps,\n+  \/\/ as they are treated in a special way by the GC. Removing these oops from the\n+  \/\/ oop maps must be done before the usual subclasses of jlr.Reference are loaded.\n+  java_lang_ref_Reference::compute_offsets();\n+\n+  \/\/ Preload ref klasses and set reference types\n+  vmClasses::Reference_klass()->set_reference_type(REF_OTHER);\n+  InstanceRefKlass::update_nonstatic_oop_maps(vmClasses::Reference_klass());\n+\n+  resolve_through(VM_CLASS_ID(PhantomReference_klass), scan, CHECK);\n+  vmClasses::SoftReference_klass()->set_reference_type(REF_SOFT);\n+  vmClasses::WeakReference_klass()->set_reference_type(REF_WEAK);\n+  vmClasses::FinalReference_klass()->set_reference_type(REF_FINAL);\n+  vmClasses::PhantomReference_klass()->set_reference_type(REF_PHANTOM);\n+\n+  \/\/ JSR 292 classes\n+  VMClassID jsr292_group_start = VM_CLASS_ID(MethodHandle_klass);\n+  VMClassID jsr292_group_end   = VM_CLASS_ID(VolatileCallSite_klass);\n+  resolve_until(jsr292_group_start, scan, CHECK);\n+  resolve_through(jsr292_group_end, scan, CHECK);\n+  resolve_until(VMClassID::LIMIT, scan, CHECK);\n+\n+  _box_klasses[T_BOOLEAN] = vmClasses::Boolean_klass();\n+  _box_klasses[T_CHAR]    = vmClasses::Character_klass();\n+  _box_klasses[T_FLOAT]   = vmClasses::Float_klass();\n+  _box_klasses[T_DOUBLE]  = vmClasses::Double_klass();\n+  _box_klasses[T_BYTE]    = vmClasses::Byte_klass();\n+  _box_klasses[T_SHORT]   = vmClasses::Short_klass();\n+  _box_klasses[T_INT]     = vmClasses::Integer_klass();\n+  _box_klasses[T_LONG]    = vmClasses::Long_klass();\n+  \/\/_box_klasses[T_OBJECT]  = vmClasses::object_klass();\n+  \/\/_box_klasses[T_ARRAY]   = vmClasses::object_klass();\n+\n+#ifdef ASSERT\n+  if (UseSharedSpaces) {\n+    JVMTI_ONLY(assert(JvmtiExport::is_early_phase(),\n+                      \"All well known classes must be resolved in JVMTI early phase\"));\n+    for (auto id : EnumRange<VMClassID>{}) {\n+      InstanceKlass* k = _klasses[as_int(id)];\n+      assert(k->is_shared(), \"must not be replaced by JVMTI class file load hook\");\n+    }\n+  }\n+#endif\n+}\n+\n+#if INCLUDE_CDS\n+\n+void vmClasses::resolve_shared_class(InstanceKlass* klass, ClassLoaderData* loader_data, Handle domain, TRAPS) {\n+  assert(!Universe::is_fully_initialized(), \"We can make short cuts only during VM initialization\");\n+  assert(klass->is_shared(), \"Must be shared class\");\n+  if (klass->class_loader_data() != NULL) {\n+    return;\n+  }\n+\n+  \/\/ add super and interfaces first\n+  Klass* super = klass->super();\n+  if (super != NULL && super->class_loader_data() == NULL) {\n+    assert(super->is_instance_klass(), \"Super should be instance klass\");\n+    resolve_shared_class(InstanceKlass::cast(super), loader_data, domain, CHECK);\n+  }\n+\n+  Array<InstanceKlass*>* ifs = klass->local_interfaces();\n+  for (int i = 0; i < ifs->length(); i++) {\n+    InstanceKlass* ik = ifs->at(i);\n+    if (ik->class_loader_data()  == NULL) {\n+      resolve_shared_class(ik, loader_data, domain, CHECK);\n+    }\n+  }\n+\n+  klass->restore_unshareable_info(loader_data, domain, NULL, THREAD);\n+  SystemDictionary::load_shared_class_misc(klass, loader_data, CHECK);\n+  Dictionary* dictionary = loader_data->dictionary();\n+  unsigned int hash = dictionary->compute_hash(klass->name());\n+  dictionary->add_klass(hash, klass->name(), klass);\n+  SystemDictionary::add_to_hierarchy(klass);\n+  assert(klass->is_loaded(), \"Must be in at least loaded state\");\n+}\n+\n+#endif \/\/ INCLUDE_CDS\n+\n+\/\/ Tells if a given klass is a box (wrapper class, such as java.lang.Integer).\n+\/\/ If so, returns the basic type it holds.  If not, returns T_OBJECT.\n+BasicType vmClasses::box_klass_type(Klass* k) {\n+  assert(k != NULL, \"\");\n+  for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n+    if (_box_klasses[i] == k)\n+      return (BasicType)i;\n+  }\n+  return T_OBJECT;\n+}\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.cpp","additions":261,"deletions":0,"binary":false,"changes":261,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CLASSFILE_VMCLASSES_HPP\n+#define SHARE_CLASSFILE_VMCLASSES_HPP\n+\n+#include \"classfile\/vmClassID.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"runtime\/handles.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+\n+class ClassLoaderData;\n+class InstanceKlass;\n+class MetaspaceClosure;\n+\n+class vmClasses : AllStatic {\n+  friend class VMStructs;\n+\n+  static VMClassID check_id(VMClassID id) {\n+    assert((int)id >= (int)VMClassID::FIRST && (int)id < (int)VMClassID::LIMIT, \"oob\");\n+    return id;\n+  }\n+\n+  static int as_int(VMClassID id) {\n+    return static_cast<int>(check_id(id));\n+  }\n+\n+  static VMClassID as_id(int i) {\n+    VMClassID id = static_cast<VMClassID>(i);\n+    return check_id(id);\n+  }\n+\n+  static InstanceKlass* check_klass(InstanceKlass* k) {\n+    assert(k != NULL, \"klass not loaded\");\n+    return k;\n+  }\n+\n+  static bool is_loaded(InstanceKlass* klass);\n+  static bool resolve(VMClassID id, TRAPS);\n+  static void resolve_until(VMClassID limit_id, VMClassID &start_id, TRAPS);\n+  static void resolve_through(VMClassID last_id, VMClassID &start_id, TRAPS) {\n+    int limit = as_int(last_id) + 1;\n+    resolve_until(as_id(limit), start_id, THREAD);\n+  }\n+\n+  static void resolve_shared_class(InstanceKlass* klass, ClassLoaderData* loader_data, Handle domain, TRAPS) NOT_CDS_RETURN;\n+\n+#ifdef ASSERT\n+  static bool contain(Klass* k);\n+  static bool contain(Symbol* class_name);\n+#endif\n+\n+  static InstanceKlass* _klasses[];\n+\n+  \/\/ table of box klasses (int_klass, etc.)\n+  static InstanceKlass* _box_klasses[];\n+\n+  \/\/ VM_CLASS_AT should be used by vmClasses.cpp and vmStructs.cpp only.\n+  #define VM_CLASS_AT(name) _klasses[static_cast<int>(VM_CLASS_ID(name))]\n+\n+public:\n+  #define _VM_CLASS_DECLARE(name, symbol) \\\n+    static InstanceKlass* name()         { return check_klass(VM_CLASS_AT(name)); }      \\\n+    static InstanceKlass** name##_addr() { return &VM_CLASS_AT(name); }                  \\\n+    static bool name##_is_loaded()       { return is_loaded(VM_CLASS_AT(name)); }\n+  VM_CLASSES_DO(_VM_CLASS_DECLARE);\n+  #undef _VM_CLASS_DECLARE\n+\n+  static InstanceKlass* klass_at(VMClassID id) {\n+    return _klasses[as_int(id)];\n+  }\n+\n+  static InstanceKlass** klass_addr_at(VMClassID id) {\n+    return &_klasses[as_int(id)];\n+  }\n+\n+  static void metaspace_pointers_do(MetaspaceClosure* it);\n+  static void resolve_all(TRAPS);\n+\n+  static BasicType box_klass_type(Klass* k);  \/\/ inverse of box_klass\n+\n+  static InstanceKlass* box_klass(BasicType t) {\n+    assert((uint)t < T_VOID+1, \"range check\");\n+    return check_klass(_box_klasses[t]);\n+  }\n+\n+  static bool Object_klass_loaded()         { return is_loaded(VM_CLASS_AT(Object_klass));             }\n+  static bool Class_klass_loaded()          { return is_loaded(VM_CLASS_AT(Class_klass));              }\n+  static bool Cloneable_klass_loaded()      { return is_loaded(VM_CLASS_AT(Cloneable_klass));          }\n+  static bool Parameter_klass_loaded()      { return is_loaded(VM_CLASS_AT(reflect_Parameter_klass));  }\n+  static bool ClassLoader_klass_loaded()    { return is_loaded(VM_CLASS_AT(ClassLoader_klass));        }\n+};\n+\n+#endif \/\/ SHARE_CLASSFILE_VMCLASSES_HPP\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.hpp","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -583,1 +584,1 @@\n-\/\/ We must relocate the System::_well_known_klasses only after we have copied the\n+\/\/ We must relocate vmClasses::_klasses[] only after we have copied the\n@@ -586,2 +587,2 @@\n-void ArchiveBuilder::relocate_well_known_klasses() {\n-  log_info(cds)(\"Relocating SystemDictionary::_well_known_klasses[] ... \");\n+void ArchiveBuilder::relocate_vm_classes() {\n+  log_info(cds)(\"Relocating vmClasses::_klasses[] ... \");\n@@ -590,1 +591,1 @@\n-  SystemDictionary::well_known_klasses_do(&doit);\n+  vmClasses::metaspace_pointers_do(&doit);\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -248,1 +248,1 @@\n-  void relocate_well_known_klasses();\n+  void relocate_vm_classes();\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -2038,2 +2039,2 @@\n-\/\/ This internally allocates objects using SystemDictionary::Object_klass(), so it\n-\/\/ must be called after the well-known classes are resolved.\n+\/\/ This internally allocates objects using vmClasses::Object_klass(), so it\n+\/\/ must be called after the Object_klass is loaded\n@@ -2041,0 +2042,1 @@\n+  assert(vmClasses::Object_klass_loaded(), \"must be\");\n@@ -2152,1 +2154,1 @@\n-    \/\/ CDS assumes that no classes resolved in SystemDictionary::resolve_well_known_classes\n+    \/\/ CDS assumes that no classes resolved in vmClasses::resolve_all()\n","filename":"src\/hotspot\/share\/memory\/filemap.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -503,1 +504,1 @@\n-  SystemDictionaryShared::serialize_well_known_klasses(soc);\n+  SystemDictionaryShared::serialize_vm_classes(soc);\n@@ -783,1 +784,1 @@\n-  builder.relocate_well_known_klasses();\n+  builder.relocate_vm_classes();\n@@ -851,1 +852,1 @@\n-  \/\/ (such as SystemDictionary::_well_known_klasses) that may cause these VM operations\n+  \/\/ (such as vmClasses::_klasses) that may cause these VM operations\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,0 +86,1 @@\n+  friend class vmClasses;\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"classfile\/systemDictionary.hpp\"\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -483,2 +484,1 @@\n-  Klass* mh_klass = SystemDictionary::well_known_klass(\n-                              SystemDictionary::WK_KLASS_ENUM_NAME(MethodHandle_klass) );\n+  Klass* mh_klass = vmClasses::klass_at(VM_CLASS_ID(MethodHandle_klass));\n@@ -490,2 +490,1 @@\n-  Klass* vh_klass = SystemDictionary::well_known_klass(\n-                              SystemDictionary::WK_KLASS_ENUM_NAME(VarHandle_klass) );\n+  Klass* vh_klass = vmClasses::klass_at(VM_CLASS_ID(VarHandle_klass));\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -462,8 +463,8 @@\n-     static_field(SystemDictionary,            WK_KLASS(Object_klass),                        InstanceKlass*)                        \\\n-     static_field(SystemDictionary,            WK_KLASS(String_klass),                        InstanceKlass*)                        \\\n-     static_field(SystemDictionary,            WK_KLASS(Class_klass),                         InstanceKlass*)                        \\\n-     static_field(SystemDictionary,            WK_KLASS(ClassLoader_klass),                   InstanceKlass*)                        \\\n-     static_field(SystemDictionary,            WK_KLASS(System_klass),                        InstanceKlass*)                        \\\n-     static_field(SystemDictionary,            WK_KLASS(Thread_klass),                        InstanceKlass*)                        \\\n-     static_field(SystemDictionary,            WK_KLASS(ThreadGroup_klass),                   InstanceKlass*)                        \\\n-     static_field(SystemDictionary,            WK_KLASS(MethodHandle_klass),                  InstanceKlass*)                        \\\n+     static_field(vmClasses,                   VM_CLASS_AT(Object_klass),                        InstanceKlass*)                     \\\n+     static_field(vmClasses,                   VM_CLASS_AT(String_klass),                        InstanceKlass*)                     \\\n+     static_field(vmClasses,                   VM_CLASS_AT(Class_klass),                         InstanceKlass*)                     \\\n+     static_field(vmClasses,                   VM_CLASS_AT(ClassLoader_klass),                   InstanceKlass*)                     \\\n+     static_field(vmClasses,                   VM_CLASS_AT(System_klass),                        InstanceKlass*)                     \\\n+     static_field(vmClasses,                   VM_CLASS_AT(Thread_klass),                        InstanceKlass*)                     \\\n+     static_field(vmClasses,                   VM_CLASS_AT(ThreadGroup_klass),                   InstanceKlass*)                     \\\n+     static_field(vmClasses,                   VM_CLASS_AT(MethodHandle_klass),                  InstanceKlass*)                     \\\n@@ -1328,0 +1329,1 @@\n+  declare_toplevel_type(vmClasses)                                        \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+enum class VMClassID : int;\n","filename":"src\/hotspot\/share\/utilities\/vmEnums.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-    Type type = db.lookupType(\"SystemDictionary\");\n+    Type type = db.lookupType(\"vmClasses\");\n@@ -57,7 +57,8 @@\n-    objectKlassField = type.getAddressField(WK_KLASS(\"Object_klass\"));\n-    classLoaderKlassField = type.getAddressField(WK_KLASS(\"ClassLoader_klass\"));\n-    stringKlassField = type.getAddressField(WK_KLASS(\"String_klass\"));\n-    systemKlassField = type.getAddressField(WK_KLASS(\"System_klass\"));\n-    threadKlassField = type.getAddressField(WK_KLASS(\"Thread_klass\"));\n-    threadGroupKlassField = type.getAddressField(WK_KLASS(\"ThreadGroup_klass\"));\n-    methodHandleKlassField = type.getAddressField(WK_KLASS(\"MethodHandle_klass\"));\n+    \/\/ Note, vmStructs contains a field with the name \"_klasses[static_cast<int>(VMClassID::Object_klass_knum)]\"\n+    objectKlassField = type.getAddressField(VM_CLASS_AT(\"Object_klass\"));\n+    classLoaderKlassField = type.getAddressField(VM_CLASS_AT(\"ClassLoader_klass\"));\n+    stringKlassField = type.getAddressField(VM_CLASS_AT(\"String_klass\"));\n+    systemKlassField = type.getAddressField(VM_CLASS_AT(\"System_klass\"));\n+    threadKlassField = type.getAddressField(VM_CLASS_AT(\"Thread_klass\"));\n+    threadGroupKlassField = type.getAddressField(VM_CLASS_AT(\"ThreadGroup_klass\"));\n+    methodHandleKlassField = type.getAddressField(VM_CLASS_AT(\"MethodHandle_klass\"));\n@@ -66,4 +67,4 @@\n-  \/\/ This WK functions must follow the definitions in systemDictionary.hpp:\n-  private static String WK_KLASS(String name) {\n-      \/\/#define WK_KLASS(name) _well_known_klasses[SystemDictionary::WK_KLASS_ENUM_NAME(name)]\n-      return (\"_well_known_klasses[SystemDictionary::\"+WK_KLASS_ENUM_NAME(name)+\"]\");\n+  \/\/ The following 3 methods must match the corresponding macros in vmClassMacros.hpp and vmClasses.hpp.\n+  private static String _VM_CLASS_ENUM(String kname) {\n+    \/\/ #define _VM_CLASS_ENUM(kname)    kname##_knum\n+    return (kname+\"_knum\");\n@@ -71,3 +72,9 @@\n-  private static String WK_KLASS_ENUM_NAME(String kname) {\n-      \/\/#define WK_KLASS_ENUM_NAME(kname)    kname##_knum\n-      return (kname+\"_knum\");\n+\n+  private static String VM_CLASS_ID(String kname) {\n+    \/\/ #define VM_CLASS_ID(kname)      VMClassID::_VM_CLASS_ENUM(kname)\n+    return \"VMClassID::\" + _VM_CLASS_ENUM(kname);\n+  }\n+\n+  private static String VM_CLASS_AT(String name) {\n+    \/\/ #define VM_CLASS_AT(name) _klasses[static_cast<int>(VM_CLASS_ID(name))]\n+    return \"_klasses[static_cast<int>(\" + VM_CLASS_ID(name) + \")]\";\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/memory\/SystemDictionary.java","additions":23,"deletions":16,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,0 @@\n-            expStrMap.put(\"printstatics SystemDictionary\", List.of(\n-                    \"Static fields of SystemDictionary\",\n-                    \"SystemDictionary::Class_klass_knum\",\n-                    \"SystemDictionary::ClassLoader_klass_knum\",\n-                    \"SystemDictionary::Object_klass_knum\"));\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbPrintStatics.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"}]}