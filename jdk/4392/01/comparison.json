{"files":[{"patch":"@@ -606,9 +606,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -785,18 +777,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -638,9 +638,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -817,18 +809,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -702,9 +702,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -881,18 +873,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -589,10 +589,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -769,18 +760,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":2,"deletions":28,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -576,9 +576,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -755,18 +747,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -574,9 +574,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -753,18 +745,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -578,9 +578,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -757,18 +749,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -586,9 +586,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -765,18 +757,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -572,9 +572,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -751,18 +743,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -571,9 +571,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -750,18 +742,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -578,9 +578,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -757,18 +749,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -586,9 +586,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -765,18 +757,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -602,9 +602,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -781,18 +773,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -574,9 +574,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -753,18 +745,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -571,9 +571,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -750,18 +742,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -582,9 +582,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -761,18 +753,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -588,0 +588,1 @@\n+            System.out.println(dsp);\n@@ -590,9 +591,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -605,0 +598,1 @@\n+            System.out.println(dsp);\n@@ -769,18 +763,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":4,"deletions":27,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -606,9 +606,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -785,18 +777,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -578,9 +578,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -757,18 +749,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -576,9 +576,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -766,18 +758,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -568,9 +568,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -747,18 +739,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -572,9 +572,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -751,18 +743,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -580,9 +580,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -759,18 +751,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -566,9 +566,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -745,18 +737,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -566,9 +566,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -745,18 +737,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -590,9 +590,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -769,18 +761,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -606,9 +606,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -785,18 +777,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -638,9 +638,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -817,18 +809,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -582,9 +582,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -761,18 +753,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -576,9 +576,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -755,18 +747,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -849,9 +849,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte$bits$Vector.Byte$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short$bits$Vector.Short$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int$bits$Vector.Int$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long$bits$Vector.Long$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float$bits$Vector.Float$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double$bits$Vector.Double$bits$Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -1043,18 +1035,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte$bits$Vector.Byte$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short$bits$Vector.Short$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int$bits$Vector.Int$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long$bits$Vector.Long$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float$bits$Vector.Float$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double$bits$Vector.Double$bits$Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -254,0 +254,22 @@\n+    static void assertArraysEquals(int[] r, int[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], a[i+offs]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i+offs], \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], a[i+offs]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i+offs], \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorTest.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -40,0 +40,5 @@\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -5415,1 +5420,1 @@\n-    static void maskFirstTrueByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastByte128VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -5417,7 +5422,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastByte128VectorTestsShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastByte128VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastByte128VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5425,1 +5461,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5427,2 +5464,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte128VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte128VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte128VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte128VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5432,0 +5509,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":89,"deletions":11,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -40,0 +40,5 @@\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -5415,1 +5420,1 @@\n-    static void maskFirstTrueByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastByte256VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -5417,7 +5422,16 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastByte256VectorTestsShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5425,1 +5439,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5427,2 +5442,20 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte256VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte256VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5432,0 +5465,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":45,"deletions":11,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -40,0 +40,5 @@\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -5415,1 +5420,1 @@\n-    static void maskFirstTrueByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastByte512VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -5417,7 +5422,5 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5425,1 +5428,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5427,2 +5431,9 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte512VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5432,0 +5443,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":23,"deletions":11,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -40,0 +40,5 @@\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -5415,1 +5420,1 @@\n-    static void maskFirstTrueByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastByte64VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -5417,7 +5422,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastByte64VectorTestsShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastByte64VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastByte64VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5425,1 +5461,24 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastByte64VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastByte64VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n@@ -5427,2 +5486,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte64VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte64VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte64VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte64VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5431,0 +5530,23 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte64VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte64VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":133,"deletions":11,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -40,0 +40,5 @@\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -5419,3 +5424,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n@@ -5423,13 +5425,0 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n@@ -40,0 +43,2 @@\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -4966,1 +4971,1 @@\n-    static void maskFirstTrueDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastDouble128VectorTestsIntTest(IntFunction<boolean[]> fa) {\n@@ -4968,7 +4973,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble128VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble128VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble128VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -4976,1 +5012,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -4978,2 +5015,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble128VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble128VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble128VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble128VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -4983,0 +5060,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":89,"deletions":11,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n@@ -40,0 +43,2 @@\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -4966,1 +4971,1 @@\n-    static void maskFirstTrueDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastDouble256VectorTestsShortTest(IntFunction<boolean[]> fa) {\n@@ -4968,7 +4973,16 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble256VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -4976,1 +4990,35 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble256VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble256VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble256VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n@@ -4978,2 +5026,20 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble256VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble256VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -4982,0 +5048,34 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble256VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble256VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble256VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":111,"deletions":11,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n@@ -40,0 +43,2 @@\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -4966,1 +4971,1 @@\n-    static void maskFirstTrueDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastDouble512VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -4968,7 +4973,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble512VectorTestsShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble512VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble512VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -4976,1 +5012,24 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble512VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble512VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n@@ -4978,2 +5037,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble512VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble512VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble512VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble512VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -4982,0 +5081,23 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble512VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble512VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":133,"deletions":11,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n@@ -40,0 +43,2 @@\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -4966,1 +4971,1 @@\n-    static void maskFirstTrueDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastDouble64VectorTestsLongTest(IntFunction<boolean[]> fa) {\n@@ -4968,7 +4973,16 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble64VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -4976,1 +4990,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -4978,2 +4993,20 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble64VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble64VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -4983,0 +5016,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":45,"deletions":11,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n@@ -40,0 +43,2 @@\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -4970,3 +4975,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n@@ -4974,13 +4976,0 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.vector.ByteVector;\n@@ -40,0 +41,4 @@\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -4944,1 +4949,1 @@\n-    static void maskFirstTrueFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastFloat128VectorTestsShortTest(IntFunction<boolean[]> fa) {\n@@ -4946,7 +4951,16 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat128VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -4954,1 +4968,35 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat128VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat128VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat128VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n@@ -4956,2 +5004,20 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat128VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat128VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -4960,0 +5026,34 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat128VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat128VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat128VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":111,"deletions":11,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.vector.ByteVector;\n@@ -40,0 +41,4 @@\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -4944,1 +4949,1 @@\n-    static void maskFirstTrueFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastFloat256VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -4946,7 +4951,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat256VectorTestsShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat256VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat256VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -4954,1 +4990,24 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat256VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat256VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n@@ -4956,2 +5015,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat256VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat256VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat256VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat256VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -4960,0 +5059,23 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat256VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat256VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":133,"deletions":11,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.vector.ByteVector;\n@@ -40,0 +41,4 @@\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -4944,1 +4949,1 @@\n-    static void maskFirstTrueFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastFloat512VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -4946,7 +4951,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat512VectorTestsShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat512VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat512VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -4954,1 +4990,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -4956,2 +4993,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat512VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat512VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat512VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat512VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -4961,0 +5038,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":89,"deletions":11,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.vector.ByteVector;\n@@ -40,0 +41,4 @@\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -4944,1 +4949,1 @@\n-    static void maskFirstTrueFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastFloat64VectorTestsIntTest(IntFunction<boolean[]> fa) {\n@@ -4946,7 +4951,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat64VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat64VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat64VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -4954,1 +4990,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -4956,2 +4993,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat64VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat64VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat64VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat64VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -4961,0 +5038,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":89,"deletions":11,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.vector.ByteVector;\n@@ -40,0 +41,4 @@\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -4948,3 +4953,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n@@ -4952,13 +4954,0 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n@@ -40,0 +42,3 @@\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -5369,1 +5374,1 @@\n-    static void maskFirstTrueInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastInt128VectorTestsShortTest(IntFunction<boolean[]> fa) {\n@@ -5371,7 +5376,16 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt128VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5379,1 +5393,35 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt128VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt128VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt128VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n@@ -5381,2 +5429,20 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt128VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt128VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5385,0 +5451,34 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt128VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt128VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt128VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":111,"deletions":11,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n@@ -40,0 +42,3 @@\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -5369,1 +5374,1 @@\n-    static void maskFirstTrueInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastInt256VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -5371,7 +5376,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt256VectorTestsShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt256VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt256VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5379,1 +5415,24 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt256VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt256VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n@@ -5381,2 +5440,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt256VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt256VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt256VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt256VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5385,0 +5484,23 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt256VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt256VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":133,"deletions":11,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n@@ -40,0 +42,3 @@\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -5369,1 +5374,1 @@\n-    static void maskFirstTrueInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastInt512VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -5371,7 +5376,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt512VectorTestsShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt512VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt512VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5379,1 +5415,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5381,2 +5418,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt512VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt512VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt512VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt512VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5386,0 +5463,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":89,"deletions":11,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n@@ -40,0 +42,3 @@\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -5369,1 +5374,1 @@\n-    static void maskFirstTrueInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastInt64VectorTestsIntTest(IntFunction<boolean[]> fa) {\n@@ -5371,7 +5376,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt64VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt64VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt64VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5379,1 +5415,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5381,2 +5418,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt64VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt64VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt64VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt64VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5386,0 +5463,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":89,"deletions":11,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n@@ -40,0 +42,3 @@\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -5373,3 +5378,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n@@ -5377,13 +5379,0 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -39,0 +39,5 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n@@ -5253,1 +5258,1 @@\n-    static void maskFirstTrueLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastLong128VectorTestsIntTest(IntFunction<boolean[]> fa) {\n@@ -5255,7 +5260,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong128VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong128VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong128VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5263,1 +5299,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5265,2 +5302,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong128VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong128VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong128VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong128VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5270,0 +5347,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":89,"deletions":11,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -39,0 +39,5 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n@@ -5253,1 +5258,1 @@\n-    static void maskFirstTrueLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastLong256VectorTestsShortTest(IntFunction<boolean[]> fa) {\n@@ -5255,7 +5260,16 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong256VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5263,1 +5277,35 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong256VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong256VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong256VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n@@ -5265,2 +5313,20 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong256VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong256VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5269,0 +5335,34 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong256VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong256VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong256VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":111,"deletions":11,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -39,0 +39,5 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n@@ -5253,1 +5258,1 @@\n-    static void maskFirstTrueLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastLong512VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -5255,7 +5260,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong512VectorTestsShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong512VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong512VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5263,1 +5299,24 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong512VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong512VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n@@ -5265,2 +5324,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong512VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong512VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong512VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong512VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5269,0 +5368,23 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong512VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong512VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":133,"deletions":11,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -39,0 +39,5 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n@@ -5253,1 +5258,1 @@\n-    static void maskFirstTrueLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastLong64VectorTestsLongTest(IntFunction<boolean[]> fa) {\n@@ -5255,7 +5260,16 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong64VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5263,1 +5277,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5265,2 +5280,20 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong64VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong64VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5270,0 +5303,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":45,"deletions":11,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -39,0 +39,5 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n@@ -5257,3 +5262,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n@@ -5261,13 +5263,0 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -39,0 +39,4 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n@@ -40,0 +44,1 @@\n+import jdk.incubator.vector.LongVector;\n@@ -5394,1 +5399,1 @@\n-    static void maskFirstTrueShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastShort128VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -5396,7 +5401,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort128VectorTestsShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort128VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort128VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5404,1 +5440,24 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort128VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort128VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n@@ -5406,2 +5465,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort128VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort128VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort128VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort128VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5410,0 +5509,23 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort128VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort128VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":133,"deletions":11,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -39,0 +39,4 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n@@ -40,0 +44,1 @@\n+import jdk.incubator.vector.LongVector;\n@@ -5394,1 +5399,1 @@\n-    static void maskFirstTrueShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastShort256VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -5396,7 +5401,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort256VectorTestsShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort256VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort256VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5404,1 +5440,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5406,2 +5443,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort256VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort256VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort256VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort256VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5411,0 +5488,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":89,"deletions":11,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -39,0 +39,4 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n@@ -40,0 +44,1 @@\n+import jdk.incubator.vector.LongVector;\n@@ -5394,1 +5399,1 @@\n-    static void maskFirstTrueShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastShort512VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -5396,7 +5401,16 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort512VectorTestsShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5404,1 +5418,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5406,2 +5421,20 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort512VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort512VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5411,0 +5444,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":45,"deletions":11,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -39,0 +39,4 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n@@ -40,0 +44,1 @@\n+import jdk.incubator.vector.LongVector;\n@@ -5394,1 +5399,1 @@\n-    static void maskFirstTrueShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastShort64VectorTestsShortTest(IntFunction<boolean[]> fa) {\n@@ -5396,7 +5401,16 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort64VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5404,1 +5418,35 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort64VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort64VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort64VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n@@ -5406,2 +5454,20 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort64VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort64VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5410,0 +5476,34 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort64VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort64VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort64VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":111,"deletions":11,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -39,0 +39,4 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n@@ -40,0 +44,1 @@\n+import jdk.incubator.vector.LongVector;\n@@ -5398,3 +5403,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n@@ -5402,13 +5404,0 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+      sizeInBytes=1\n@@ -95,0 +96,1 @@\n+      sizeInBytes=2\n@@ -99,0 +101,1 @@\n+      sizeInBytes=4\n@@ -107,0 +110,1 @@\n+      sizeInBytes=8\n@@ -114,0 +118,1 @@\n+      sizeInBytes=4\n@@ -123,0 +128,1 @@\n+      sizeInBytes=8\n@@ -156,0 +162,1 @@\n+    numLanes=$((bits \/ (sizeInBytes * 8)))\n@@ -164,0 +171,39 @@\n+    bytecastbits=\"\"\n+    toBits=$(( numLanes * 8 ))\n+    castargs=\"\"\n+    if [[ $toBits -ge 64 ]] && [[ $toBits -le 512 ]] ; then\n+       castargs=\"$castargs -KvalidByteCast\"\n+       bytecastbits=$(( numLanes * 8 ))\n+    fi\n+    shortcastbits=\"\"\n+    toBits=$(( numLanes * 16 ))\n+    if [[ $toBits -ge 64 ]] && [[ $toBits -le 512 ]] ; then\n+       castargs=\"$castargs -KvalidShortCast\"\n+       shortcastbits=$(( numLanes * 16 ))\n+    fi\n+    intcastbits=\"\"\n+    toBits=$(( numLanes * 32 ))\n+    if [[ $toBits -ge 64 ]] && [[ $toBits -le 512 ]] ; then\n+       castargs=\"$castargs -KvalidIntegerCast\"\n+       intcastbits=$(( numLanes * 32 ))\n+    fi\n+    longcastbits=\"\"\n+    toBits=$(( numLanes * 64 ))\n+    if [[ $toBits -ge 64 ]] && [[ $toBits -le 512 ]] ; then\n+       castargs=\"$castargs -KvalidLongCast\"\n+       longcastbits=$(( numLanes * 64 ))\n+    fi\n+    floatcastbits=\"\"\n+    toBits=$(( numLanes * 32 ))\n+    if [[ $toBits -ge 64 ]] && [[ $toBits -le 512 ]] ; then\n+       castargs=\"$castargs -KvalidFloatCast\"\n+       floatcastbits=$(( numLanes * 32 ))\n+    fi\n+    doublecastbits=\"\"\n+    toBits=$(( numLanes * 64 ))\n+    if [[ $toBits -ge 64 ]] && [[ $toBits -le 512 ]] ; then\n+       castargs=\"$castargs -KvalidDoubleCast\"\n+       doublecastbits=$(( numLanes * 64 ))\n+    fi\n+    bitargs=\"$bitargs $castargs -Dbytecastbits=$bytecastbits -Dshortcastbits=$shortcastbits -Dintcastbits=$intcastbits -Dfloatcastbits=$floatcastbits -Ddoublecastbits=$doublecastbits -Dlongcastbits=$longcastbits\"\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-tests.sh","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -447,0 +447,2 @@\n+#if[!MaxBit]\n+#if[validByteCast]\n@@ -448,1 +450,1 @@\n-    static void maskFirstTrue$vectorteststype$SmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCast$vectorteststype$ByteTest(IntFunction<boolean[]> fa) {\n@@ -450,7 +452,18 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_$bytecastbits$);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+#end[validByteCast]\n+#if[validShortCast]\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCast$vectorteststype$ShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_$shortcastbits$);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -458,1 +471,55 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n+#end[validShortCast]\n+#if[validIntegerCast]\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCast$vectorteststype$IntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_$intcastbits$);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+#end[validIntegerCast]\n+#if[validLongCast]\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCast$vectorteststype$LongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_$longcastbits$);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+#end[validLongCast]\n+#if[validFloatCast]\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCast$vectorteststype$FloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_$floatcastbits$);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+#end[validFloatCast]\n+#if[validDoubleCast]\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCast$vectorteststype$DoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_$doublecastbits$);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+#end[validDoubleCast]\n@@ -460,2 +527,23 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+#if[validByteCast]\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCast$vectorteststype$ByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_$bytecastbits$);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+#end[validByteCast]\n+#if[validShortCast]\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCast$vectorteststype$ShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_$shortcastbits$);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -464,0 +552,55 @@\n+#end[validShortCast]\n+#if[validIntegerCast]\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCast$vectorteststype$IntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_$intcastbits$);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+#end[validIntegerCast]\n+#if[validLongCast]\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCast$vectorteststype$LongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_$longcastbits$);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+#end[validLongCast]\n+#if[validFloatCast]\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCast$vectorteststype$FloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_$floatcastbits$);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+#end[validFloatCast]\n+#if[validDoubleCast]\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCast$vectorteststype$DoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_$doublecastbits$);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+#end[validDoubleCast]\n+#end[!MaxBit]\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Miscellaneous.template","additions":154,"deletions":11,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-#if[Byte]\n@@ -41,2 +40,0 @@\n-#end[Byte]\n-#if[Float]\n@@ -44,2 +41,0 @@\n-#end[Float]\n-#if[Int]\n@@ -47,2 +42,0 @@\n-#end[Int]\n-#if[Double]\n@@ -50,2 +43,0 @@\n-#end[Double]\n-#if[Short]\n@@ -53,2 +44,0 @@\n-#end[Short]\n-#if[Long]\n@@ -56,1 +45,0 @@\n-#end[Long]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"}]}