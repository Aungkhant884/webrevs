{"files":[{"patch":"@@ -612,9 +612,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -791,18 +783,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -644,9 +644,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -823,18 +815,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -708,9 +708,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -887,18 +879,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -595,10 +595,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -775,18 +766,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":2,"deletions":28,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -582,9 +582,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -761,18 +753,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -580,9 +580,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -759,18 +751,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -584,9 +584,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -763,18 +755,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -592,9 +592,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -771,18 +763,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -578,9 +578,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -757,18 +749,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -577,9 +577,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -756,18 +748,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -584,9 +584,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -763,18 +755,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -592,9 +592,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -771,18 +763,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -608,9 +608,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -787,18 +779,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -580,9 +580,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -759,18 +751,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -577,9 +577,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -756,18 +748,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -588,9 +588,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -767,18 +759,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -594,0 +594,1 @@\n+            System.out.println(dsp);\n@@ -596,9 +597,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -611,0 +604,1 @@\n+            System.out.println(dsp);\n@@ -775,18 +769,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":4,"deletions":27,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -612,9 +612,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -791,18 +783,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -584,9 +584,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -763,18 +755,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -582,9 +582,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -772,18 +764,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -574,9 +574,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -753,18 +745,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -578,9 +578,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -757,18 +749,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -586,9 +586,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -765,18 +757,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -572,9 +572,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -751,18 +743,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -572,9 +572,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -751,18 +743,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -596,9 +596,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -775,18 +767,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -612,9 +612,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -791,18 +783,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -644,9 +644,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -823,18 +815,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -588,9 +588,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -767,18 +759,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -582,9 +582,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -761,18 +753,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -855,9 +855,1 @@\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte$bits$Vector.Byte$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short$bits$Vector.Short$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int$bits$Vector.Int$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long$bits$Vector.Long$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float$bits$Vector.Float$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double$bits$Vector.Double$bits$Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -1049,18 +1041,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte$bits$Vector.Byte$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short$bits$Vector.Short$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int$bits$Vector.Int$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long$bits$Vector.Long$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float$bits$Vector.Float$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double$bits$Vector.Double$bits$Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -254,0 +254,22 @@\n+    static void assertArraysEquals(int[] r, int[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], a[i+offs]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i+offs], \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], a[i+offs]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i+offs], \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorTest.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -40,0 +40,5 @@\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -5182,1 +5187,1 @@\n-    static void maskFirstTrueByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastByte128VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -5184,7 +5189,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastByte128VectorTestsShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastByte128VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastByte128VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5192,1 +5228,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5194,2 +5231,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte128VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte128VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte128VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte128VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5199,0 +5276,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":89,"deletions":11,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -40,0 +40,5 @@\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -5182,1 +5187,1 @@\n-    static void maskFirstTrueByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastByte256VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -5184,7 +5189,16 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastByte256VectorTestsShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5192,1 +5206,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5194,2 +5209,20 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte256VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte256VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5199,0 +5232,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":45,"deletions":11,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -40,0 +40,5 @@\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -5182,1 +5187,1 @@\n-    static void maskFirstTrueByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastByte512VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -5184,7 +5189,5 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5192,1 +5195,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5194,2 +5198,9 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte512VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5199,0 +5210,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":23,"deletions":11,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -40,0 +40,5 @@\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -5182,1 +5187,1 @@\n-    static void maskFirstTrueByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastByte64VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -5184,7 +5189,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastByte64VectorTestsShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastByte64VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastByte64VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5192,1 +5228,24 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastByte64VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastByte64VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n@@ -5194,2 +5253,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte64VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte64VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte64VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte64VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5198,0 +5297,23 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte64VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastByte64VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":133,"deletions":11,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -40,0 +40,5 @@\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -5186,3 +5191,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n@@ -5190,13 +5192,0 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n@@ -40,0 +43,2 @@\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -4928,1 +4933,1 @@\n-    static void maskFirstTrueDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastDouble128VectorTestsIntTest(IntFunction<boolean[]> fa) {\n@@ -4930,7 +4935,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble128VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble128VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble128VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -4938,1 +4974,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -4940,2 +4977,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble128VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble128VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble128VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble128VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -4945,0 +5022,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":89,"deletions":11,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n@@ -40,0 +43,2 @@\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -4928,1 +4933,1 @@\n-    static void maskFirstTrueDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastDouble256VectorTestsShortTest(IntFunction<boolean[]> fa) {\n@@ -4930,7 +4935,16 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble256VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -4938,1 +4952,35 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble256VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble256VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble256VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n@@ -4940,2 +4988,20 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble256VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble256VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -4944,0 +5010,34 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble256VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble256VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble256VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":111,"deletions":11,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n@@ -40,0 +43,2 @@\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -4928,1 +4933,1 @@\n-    static void maskFirstTrueDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastDouble512VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -4930,7 +4935,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble512VectorTestsShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble512VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble512VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -4938,1 +4974,24 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble512VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble512VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n@@ -4940,2 +4999,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble512VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble512VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble512VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble512VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -4944,0 +5043,23 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble512VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble512VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":133,"deletions":11,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n@@ -40,0 +43,2 @@\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -4928,1 +4933,1 @@\n-    static void maskFirstTrueDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastDouble64VectorTestsLongTest(IntFunction<boolean[]> fa) {\n@@ -4930,7 +4935,16 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastDouble64VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -4938,1 +4952,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -4940,2 +4955,20 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble64VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastDouble64VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -4945,0 +4978,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":45,"deletions":11,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n@@ -40,0 +43,2 @@\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -4932,3 +4937,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n@@ -4936,13 +4938,0 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.vector.ByteVector;\n@@ -40,0 +41,4 @@\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -4906,1 +4911,1 @@\n-    static void maskFirstTrueFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastFloat128VectorTestsShortTest(IntFunction<boolean[]> fa) {\n@@ -4908,7 +4913,16 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat128VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -4916,1 +4930,35 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat128VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat128VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat128VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n@@ -4918,2 +4966,20 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat128VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat128VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -4922,0 +4988,34 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat128VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat128VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat128VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":111,"deletions":11,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.vector.ByteVector;\n@@ -40,0 +41,4 @@\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -4906,1 +4911,1 @@\n-    static void maskFirstTrueFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastFloat256VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -4908,7 +4913,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat256VectorTestsShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat256VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat256VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -4916,1 +4952,24 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat256VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat256VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n@@ -4918,2 +4977,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat256VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat256VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat256VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat256VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -4922,0 +5021,23 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat256VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat256VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":133,"deletions":11,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.vector.ByteVector;\n@@ -40,0 +41,4 @@\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -4906,1 +4911,1 @@\n-    static void maskFirstTrueFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastFloat512VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -4908,7 +4913,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat512VectorTestsShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat512VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat512VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -4916,1 +4952,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -4918,2 +4955,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat512VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat512VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat512VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat512VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -4923,0 +5000,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":89,"deletions":11,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.vector.ByteVector;\n@@ -40,0 +41,4 @@\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -4906,1 +4911,1 @@\n-    static void maskFirstTrueFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastFloat64VectorTestsIntTest(IntFunction<boolean[]> fa) {\n@@ -4908,7 +4913,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat64VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat64VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastFloat64VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -4916,1 +4952,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -4918,2 +4955,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat64VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat64VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat64VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastFloat64VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -4923,0 +5000,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":89,"deletions":11,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.vector.ByteVector;\n@@ -40,0 +41,4 @@\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -4910,3 +4915,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n@@ -4914,13 +4916,0 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n@@ -40,0 +42,3 @@\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -5137,1 +5142,1 @@\n-    static void maskFirstTrueInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastInt128VectorTestsShortTest(IntFunction<boolean[]> fa) {\n@@ -5139,7 +5144,16 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt128VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5147,1 +5161,35 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt128VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt128VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt128VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n@@ -5149,2 +5197,20 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt128VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt128VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5153,0 +5219,34 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt128VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt128VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt128VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":111,"deletions":11,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n@@ -40,0 +42,3 @@\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -5137,1 +5142,1 @@\n-    static void maskFirstTrueInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastInt256VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -5139,7 +5144,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt256VectorTestsShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt256VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt256VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5147,1 +5183,24 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt256VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt256VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n@@ -5149,2 +5208,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt256VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt256VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt256VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt256VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5153,0 +5252,23 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt256VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt256VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":133,"deletions":11,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n@@ -40,0 +42,3 @@\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -5137,1 +5142,1 @@\n-    static void maskFirstTrueInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastInt512VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -5139,7 +5144,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt512VectorTestsShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt512VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt512VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5147,1 +5183,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5149,2 +5186,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt512VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt512VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt512VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt512VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5154,0 +5231,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":89,"deletions":11,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n@@ -40,0 +42,3 @@\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -5137,1 +5142,1 @@\n-    static void maskFirstTrueInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastInt64VectorTestsIntTest(IntFunction<boolean[]> fa) {\n@@ -5139,7 +5144,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt64VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt64VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastInt64VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5147,1 +5183,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5149,2 +5186,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt64VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt64VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt64VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastInt64VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5154,0 +5231,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":89,"deletions":11,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n@@ -40,0 +42,3 @@\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -5141,3 +5146,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n@@ -5145,13 +5147,0 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -39,0 +39,5 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n@@ -5020,1 +5025,1 @@\n-    static void maskFirstTrueLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastLong128VectorTestsIntTest(IntFunction<boolean[]> fa) {\n@@ -5022,7 +5027,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong128VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong128VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong128VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5030,1 +5066,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5032,2 +5069,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong128VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong128VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong128VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong128VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5037,0 +5114,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":89,"deletions":11,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -39,0 +39,5 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n@@ -5020,1 +5025,1 @@\n-    static void maskFirstTrueLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastLong256VectorTestsShortTest(IntFunction<boolean[]> fa) {\n@@ -5022,7 +5027,16 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong256VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5030,1 +5044,35 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong256VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong256VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong256VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n@@ -5032,2 +5080,20 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong256VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong256VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5036,0 +5102,34 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong256VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong256VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong256VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":111,"deletions":11,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -39,0 +39,5 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n@@ -5020,1 +5025,1 @@\n-    static void maskFirstTrueLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastLong512VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -5022,7 +5027,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong512VectorTestsShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong512VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong512VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5030,1 +5066,24 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong512VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong512VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n@@ -5032,2 +5091,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong512VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong512VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong512VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong512VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5036,0 +5135,23 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong512VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong512VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":133,"deletions":11,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -39,0 +39,5 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n@@ -5020,1 +5025,1 @@\n-    static void maskFirstTrueLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastLong64VectorTestsLongTest(IntFunction<boolean[]> fa) {\n@@ -5022,7 +5027,16 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastLong64VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5030,1 +5044,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5032,2 +5047,20 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong64VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastLong64VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5037,0 +5070,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":45,"deletions":11,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -39,0 +39,5 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n@@ -5024,3 +5029,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n@@ -5028,13 +5030,0 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -39,0 +39,4 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n@@ -40,0 +44,1 @@\n+import jdk.incubator.vector.LongVector;\n@@ -5161,1 +5166,1 @@\n-    static void maskFirstTrueShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastShort128VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -5163,7 +5168,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort128VectorTestsShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort128VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort128VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5171,1 +5207,24 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort128VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort128VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n@@ -5173,2 +5232,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort128VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort128VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort128VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort128VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5177,0 +5276,23 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort128VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort128VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":133,"deletions":11,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -39,0 +39,4 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n@@ -40,0 +44,1 @@\n+import jdk.incubator.vector.LongVector;\n@@ -5161,1 +5166,1 @@\n-    static void maskFirstTrueShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastShort256VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -5163,7 +5168,38 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort256VectorTestsShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort256VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort256VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5171,1 +5207,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5173,2 +5210,42 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort256VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort256VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort256VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort256VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5178,0 +5255,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":89,"deletions":11,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -39,0 +39,4 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n@@ -40,0 +44,1 @@\n+import jdk.incubator.vector.LongVector;\n@@ -5161,1 +5166,1 @@\n-    static void maskFirstTrueShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastShort512VectorTestsByteTest(IntFunction<boolean[]> fa) {\n@@ -5163,7 +5168,16 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort512VectorTestsShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5171,1 +5185,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5173,2 +5188,20 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort512VectorTestsByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort512VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_512);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5178,0 +5211,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":45,"deletions":11,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -39,0 +39,4 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n@@ -40,0 +44,1 @@\n+import jdk.incubator.vector.LongVector;\n@@ -5161,1 +5166,1 @@\n-    static void maskFirstTrueShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCastShort64VectorTestsShortTest(IntFunction<boolean[]> fa) {\n@@ -5163,7 +5168,16 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort64VectorTestsIntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -5171,1 +5185,35 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort64VectorTestsLongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort64VectorTestsFloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCastShort64VectorTestsDoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n@@ -5173,2 +5221,20 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort64VectorTestsShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_64);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort64VectorTestsIntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -5177,0 +5243,34 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort64VectorTestsLongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort64VectorTestsFloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_128);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCastShort64VectorTestsDoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_256);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":111,"deletions":11,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -39,0 +39,4 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n@@ -40,0 +44,1 @@\n+import jdk.incubator.vector.LongVector;\n@@ -5165,3 +5170,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n@@ -5169,13 +5171,0 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+      sizeInBytes=1\n@@ -95,0 +96,1 @@\n+      sizeInBytes=2\n@@ -99,0 +101,1 @@\n+      sizeInBytes=4\n@@ -107,0 +110,1 @@\n+      sizeInBytes=8\n@@ -114,0 +118,1 @@\n+      sizeInBytes=4\n@@ -123,0 +128,1 @@\n+      sizeInBytes=8\n@@ -156,0 +162,1 @@\n+    numLanes=$((bits \/ (sizeInBytes * 8)))\n@@ -161,0 +168,39 @@\n+    bytecastbits=\"\"\n+    toBits=$(( numLanes * 8 ))\n+    castargs=\"\"\n+    if [[ $toBits -ge 64 ]] && [[ $toBits -le 512 ]] ; then\n+       castargs=\"$castargs -KvalidByteCast\"\n+       bytecastbits=$(( numLanes * 8 ))\n+    fi\n+    shortcastbits=\"\"\n+    toBits=$(( numLanes * 16 ))\n+    if [[ $toBits -ge 64 ]] && [[ $toBits -le 512 ]] ; then\n+       castargs=\"$castargs -KvalidShortCast\"\n+       shortcastbits=$(( numLanes * 16 ))\n+    fi\n+    intcastbits=\"\"\n+    toBits=$(( numLanes * 32 ))\n+    if [[ $toBits -ge 64 ]] && [[ $toBits -le 512 ]] ; then\n+       castargs=\"$castargs -KvalidIntegerCast\"\n+       intcastbits=$(( numLanes * 32 ))\n+    fi\n+    longcastbits=\"\"\n+    toBits=$(( numLanes * 64 ))\n+    if [[ $toBits -ge 64 ]] && [[ $toBits -le 512 ]] ; then\n+       castargs=\"$castargs -KvalidLongCast\"\n+       longcastbits=$(( numLanes * 64 ))\n+    fi\n+    floatcastbits=\"\"\n+    toBits=$(( numLanes * 32 ))\n+    if [[ $toBits -ge 64 ]] && [[ $toBits -le 512 ]] ; then\n+       castargs=\"$castargs -KvalidFloatCast\"\n+       floatcastbits=$(( numLanes * 32 ))\n+    fi\n+    doublecastbits=\"\"\n+    toBits=$(( numLanes * 64 ))\n+    if [[ $toBits -ge 64 ]] && [[ $toBits -le 512 ]] ; then\n+       castargs=\"$castargs -KvalidDoubleCast\"\n+       doublecastbits=$(( numLanes * 64 ))\n+    fi\n+    bitargs=\"$bitargs $castargs -Dbytecastbits=$bytecastbits -Dshortcastbits=$shortcastbits -Dintcastbits=$intcastbits -Dfloatcastbits=$floatcastbits -Ddoublecastbits=$doublecastbits -Dlongcastbits=$longcastbits\"\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-tests.sh","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -447,0 +447,2 @@\n+#if[!MaxBit]\n+#if[validByteCast]\n@@ -448,1 +450,1 @@\n-    static void maskFirstTrue$vectorteststype$SmokeTest(IntFunction<boolean[]> fa) {\n+    static void maskCast$vectorteststype$ByteTest(IntFunction<boolean[]> fa) {\n@@ -450,7 +452,18 @@\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ByteVector.SPECIES_$bytecastbits$);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+#end[validByteCast]\n+#if[validShortCast]\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCast$vectorteststype$ShortTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(ShortVector.SPECIES_$shortcastbits$);\n+                assertArraysEquals(res.toArray(), a, i);\n@@ -458,1 +471,55 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n+#end[validShortCast]\n+#if[validIntegerCast]\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCast$vectorteststype$IntTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(IntVector.SPECIES_$intcastbits$);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+#end[validIntegerCast]\n+#if[validLongCast]\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCast$vectorteststype$LongTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(LongVector.SPECIES_$longcastbits$);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+#end[validLongCast]\n+#if[validFloatCast]\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCast$vectorteststype$FloatTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(FloatVector.SPECIES_$floatcastbits$);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+#end[validFloatCast]\n+#if[validDoubleCast]\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCast$vectorteststype$DoubleTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                var res = vmask.cast(DoubleVector.SPECIES_$doublecastbits$);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+#end[validDoubleCast]\n@@ -460,2 +527,23 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+#if[validByteCast]\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCast$vectorteststype$ByteTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ByteVector.SPECIES_$bytecastbits$);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+#end[validByteCast]\n+#if[validShortCast]\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCast$vectorteststype$ShortTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(ShortVector.SPECIES_$shortcastbits$);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n@@ -464,0 +552,55 @@\n+#end[validShortCast]\n+#if[validIntegerCast]\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCast$vectorteststype$IntTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(IntVector.SPECIES_$intcastbits$);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+#end[validIntegerCast]\n+#if[validLongCast]\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCast$vectorteststype$LongTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(LongVector.SPECIES_$longcastbits$);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+#end[validLongCast]\n+#if[validFloatCast]\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCast$vectorteststype$FloatTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(FloatVector.SPECIES_$floatcastbits$);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+#end[validFloatCast]\n+#if[validDoubleCast]\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleCast$vectorteststype$DoubleTest(BiFunction<Integer,Integer,int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                var res = vshuffle.cast(DoubleVector.SPECIES_$doublecastbits$);\n+                assertArraysEquals(res.toArray(), a, i);\n+            }\n+        }\n+    }\n+#end[validDoubleCast]\n+#end[!MaxBit]\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Miscellaneous.template","additions":154,"deletions":11,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-#if[Byte]\n@@ -41,2 +40,0 @@\n-#end[Byte]\n-#if[Float]\n@@ -44,2 +41,0 @@\n-#end[Float]\n-#if[Int]\n@@ -47,2 +42,0 @@\n-#end[Int]\n-#if[Double]\n@@ -50,2 +43,0 @@\n-#end[Double]\n-#if[Short]\n@@ -53,2 +44,0 @@\n-#end[Short]\n-#if[Long]\n@@ -56,1 +45,0 @@\n-#end[Long]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"}]}