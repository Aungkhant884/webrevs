{"files":[{"patch":"@@ -5461,14 +5461,0 @@\n-    BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n-\n-    if (bs_asm->nmethod_patching_type() == NMethodPatchingType::conc_instruction_and_data_patch) {\n-      BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n-      \/\/ We can get here despite the nmethod being good, if we have not\n-      \/\/ yet applied our cross modification fence (or data fence).\n-      Address thread_epoch_addr(rthread, in_bytes(bs_nm->thread_disarmed_guard_value_offset()) + 4);\n-      __ lea(rscratch2, ExternalAddress(bs_asm->patching_epoch_addr()));\n-      __ ldrw(rscratch2, rscratch2);\n-      __ strw(rscratch2, thread_epoch_addr);\n-      __ isb();\n-      __ membar(__ LoadLoad);\n-    }\n-\n@@ -5491,0 +5477,17 @@\n+    BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n+\n+    \/\/ In case a concurrent thread disarmed the nmethod, we need to ensure the new instructions\n+    \/\/ are made visible using isb. Note that this is synchronous cross modifying code, where the\n+    \/\/ existence of new instructions is communicated via data (the guard value).\n+    if (bs_asm->nmethod_patching_type() == NMethodPatchingType::conc_instruction_and_data_patch) {\n+      BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+      \/\/ We can get here despite the nmethod being good, if we have not\n+      \/\/ yet applied our cross modification fence (or data fence).\n+      Address thread_epoch_addr(rthread, in_bytes(bs_nm->thread_disarmed_guard_value_offset()) + 4);\n+      __ lea(rscratch2, ExternalAddress(bs_asm->patching_epoch_addr()));\n+      __ ldrw(rscratch2, rscratch2);\n+      __ strw(rscratch2, thread_epoch_addr);\n+      __ isb();\n+      __ membar(__ LoadLoad);\n+    }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2440,11 +2440,0 @@\n-    BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n-\n-    if (bs_asm->nmethod_patching_type() == NMethodPatchingType::conc_instruction_and_data_patch) {\n-      BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n-      Address thread_epoch_addr(xthread, in_bytes(bs_nm->thread_disarmed_guard_value_offset()) + 4);\n-      __ la(t1, ExternalAddress(bs_asm->patching_epoch_addr()));\n-      __ lwu(t1, t1);\n-      __ sw(t1, thread_epoch_addr);\n-      __ membar(__ LoadLoad);\n-    }\n-\n@@ -2465,0 +2454,11 @@\n+    BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n+\n+    if (bs_asm->nmethod_patching_type() == NMethodPatchingType::conc_instruction_and_data_patch) {\n+      BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+      Address thread_epoch_addr(xthread, in_bytes(bs_nm->thread_disarmed_guard_value_offset()) + 4);\n+      __ la(t1, ExternalAddress(bs_asm->patching_epoch_addr()));\n+      __ lwu(t1, t1);\n+      __ sw(t1, thread_epoch_addr);\n+      __ membar(__ LoadLoad);\n+    }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -3821,0 +3821,5 @@\n+    \/\/ In case a concurrent thread disarmed the nmethod, we need to ensure the new instructions\n+    \/\/ are made visible using cpuid. Note that this is synchronous cross modifying code, where the\n+    \/\/ existence of new instructions is communicated via data (the guard value).\n+    __ cpuid();\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3166,0 +3166,5 @@\n+  \/\/ In case a concurrent thread disarmed the nmethod, we need to ensure the new instructions\n+  \/\/ are made visible using cpuid. Note that this is synchronous cross modifying code, where the\n+  \/\/ existence of new instructions is communicated via data (the guard value).\n+  __ cpuid();\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -217,0 +217,1 @@\n+  bool result = nmethod_entry_barrier(nm);\n@@ -218,1 +219,1 @@\n-  return nmethod_entry_barrier(nm);\n+  return result;\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}