{"files":[{"patch":"@@ -5482,0 +5482,14 @@\n+    BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n+\n+    if (bs_asm->nmethod_patching_type() == NMethodPatchingType::conc_instruction_and_data_patch) {\n+      BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+      \/\/ We can get here despite the nmethod being good, if we have not\n+      \/\/ yet applied our cross modification fence (or data fence).\n+      Address thread_epoch_addr(rthread, in_bytes(bs_nm->thread_disarmed_guard_value_offset()) + 4);\n+      __ lea(rscratch2, ExternalAddress(bs_asm->patching_epoch_addr()));\n+      __ ldrw(rscratch2, rscratch2);\n+      __ strw(rscratch2, thread_epoch_addr);\n+      __ isb();\n+      __ membar(__ LoadLoad);\n+    }\n+\n@@ -5498,17 +5512,0 @@\n-    BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n-\n-    \/\/ In case a concurrent thread disarmed the nmethod, we need to ensure the new instructions\n-    \/\/ are made visible using isb. Note that this is synchronous cross modifying code, where the\n-    \/\/ existence of new instructions is communicated via data (the guard value).\n-    if (bs_asm->nmethod_patching_type() == NMethodPatchingType::conc_instruction_and_data_patch) {\n-      BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n-      \/\/ We can get here despite the nmethod being good, if we have not\n-      \/\/ yet applied our cross modification fence (or data fence).\n-      Address thread_epoch_addr(rthread, in_bytes(bs_nm->thread_disarmed_guard_value_offset()) + 4);\n-      __ lea(rscratch2, ExternalAddress(bs_asm->patching_epoch_addr()));\n-      __ ldrw(rscratch2, rscratch2);\n-      __ strw(rscratch2, thread_epoch_addr);\n-      __ isb();\n-      __ membar(__ LoadLoad);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":14,"deletions":17,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2404,0 +2404,11 @@\n+    BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n+\n+    if (bs_asm->nmethod_patching_type() == NMethodPatchingType::conc_instruction_and_data_patch) {\n+      BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+      Address thread_epoch_addr(xthread, in_bytes(bs_nm->thread_disarmed_guard_value_offset()) + 4);\n+      __ la(t1, ExternalAddress(bs_asm->patching_epoch_addr()));\n+      __ lwu(t1, t1);\n+      __ sw(t1, thread_epoch_addr);\n+      __ membar(__ LoadLoad);\n+    }\n+\n@@ -2418,11 +2429,0 @@\n-    BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n-\n-    if (bs_asm->nmethod_patching_type() == NMethodPatchingType::conc_instruction_and_data_patch) {\n-      BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n-      Address thread_epoch_addr(xthread, in_bytes(bs_nm->thread_disarmed_guard_value_offset()) + 4);\n-      __ la(t1, ExternalAddress(bs_asm->patching_epoch_addr()));\n-      __ lwu(t1, t1);\n-      __ sw(t1, thread_epoch_addr);\n-      __ membar(__ LoadLoad);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -3821,5 +3821,0 @@\n-    \/\/ In case a concurrent thread disarmed the nmethod, we need to ensure the new instructions\n-    \/\/ are made visible using cpuid. Note that this is synchronous cross modifying code, where the\n-    \/\/ existence of new instructions is communicated via data (the guard value).\n-    __ cpuid();\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3159,5 +3159,0 @@\n-  \/\/ In case a concurrent thread disarmed the nmethod, we need to ensure the new instructions\n-  \/\/ are made visible using cpuid. Note that this is synchronous cross modifying code, where the\n-  \/\/ existence of new instructions is communicated via data (the guard value).\n-  __ cpuid();\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -189,0 +189,5 @@\n+  \/\/ In case a concurrent thread disarmed the nmethod, we need to ensure the new instructions\n+  \/\/ are made visible using a cross modify fence. Note that this is synchronous cross modifying\n+  \/\/ code, where the existence of new instructions is communicated via data (the guard value).\n+  OrderAccess::cross_modify_fence();\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}