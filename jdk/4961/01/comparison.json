{"files":[{"patch":"@@ -382,50 +382,36 @@\n-        if (attributes[1].getBoolean() || (attributes[2].getBoolean() == false)) {\n-            return new P11PrivateKey\n-                (session, keyID, algorithm, keyLength, attributes);\n-        } else {\n-            switch (algorithm) {\n-                case \"RSA\":\n-                    \/\/ In order to decide if this is RSA CRT key, we first query\n-                    \/\/ and see if all extra CRT attributes are available.\n-                    CK_ATTRIBUTE[] attrs2 = new CK_ATTRIBUTE[] {\n-                        new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT),\n-                        new CK_ATTRIBUTE(CKA_PRIME_1),\n-                        new CK_ATTRIBUTE(CKA_PRIME_2),\n-                        new CK_ATTRIBUTE(CKA_EXPONENT_1),\n-                        new CK_ATTRIBUTE(CKA_EXPONENT_2),\n-                        new CK_ATTRIBUTE(CKA_COEFFICIENT),\n-                    };\n-                    boolean crtKey;\n-                    try {\n-                        session.token.p11.C_GetAttributeValue\n-                            (session.id(), keyID, attrs2);\n-                        crtKey = ((attrs2[0].pValue instanceof byte[]) &&\n-                                  (attrs2[1].pValue instanceof byte[]) &&\n-                                  (attrs2[2].pValue instanceof byte[]) &&\n-                                  (attrs2[3].pValue instanceof byte[]) &&\n-                                  (attrs2[4].pValue instanceof byte[]) &&\n-                                  (attrs2[5].pValue instanceof byte[])) ;\n-                    } catch (PKCS11Exception e) {\n-                        \/\/ ignore, assume not available\n-                        crtKey = false;\n-                    }\n-                    if (crtKey) {\n-                        return new P11RSAPrivateKey(session, keyID, algorithm,\n-                                keyLength, attributes, attrs2);\n-                    } else {\n-                        return new P11RSAPrivateNonCRTKey(session, keyID,\n-                                algorithm, keyLength, attributes);\n-                    }\n-                case \"DSA\":\n-                    return new P11DSAPrivateKey(session, keyID, algorithm,\n-                            keyLength, attributes);\n-                case \"DH\":\n-                    return new P11DHPrivateKey(session, keyID, algorithm,\n-                            keyLength, attributes);\n-                case \"EC\":\n-                    return new P11ECPrivateKey(session, keyID, algorithm,\n-                            keyLength, attributes);\n-                default:\n-                    throw new ProviderException\n-                            (\"Unknown private key algorithm \" + algorithm);\n-            }\n+        boolean keySensitive = (attributes[0].getBoolean() ||\n+                attributes[1].getBoolean() || !attributes[2].getBoolean());\n+        switch (algorithm) {\n+            case \"RSA\":\n+                if (keySensitive) {\n+                    \/\/ No need to determine CRT or non-CRT in\n+                    \/\/ advanced as the returned instance will be of\n+                    \/\/ P11RSAPrivateKeyInternal type in any case.\n+                    return new P11RSAPrivateKeyInternal(session, keyID,\n+                            algorithm, keyLength, attributes);\n+                }\n+                \/\/ We need to determine CRT or non-CRT in advanced to decide\n+                \/\/ which instance to return: P11RSAPrivateKey (CRT) or\n+                \/\/ P11RSAPrivateNonCRTKey (non-CRT).\n+                P11RSAAttributesFetcher attrFetcher =\n+                        new P11RSAAttributesFetcher(session.token, keyID,\n+                                false, true);\n+                if (attrFetcher.isCRTKey()) {\n+                    return new P11RSAPrivateKey(session, keyID, algorithm,\n+                            keyLength, attributes, attrFetcher);\n+                } else {\n+                    return new P11RSAPrivateNonCRTKey(session, keyID,\n+                            algorithm, keyLength, attributes, attrFetcher);\n+                }\n+            case \"DSA\":\n+                return P11DSAPrivateKey.newInstance(session, keyID, algorithm,\n+                        keyLength, attributes, keySensitive);\n+            case \"DH\":\n+                return P11DHPrivateKey.newInstance(session, keyID, algorithm,\n+                        keyLength, attributes, keySensitive);\n+            case \"EC\":\n+                return P11ECPrivateKey.newInstance(session, keyID, algorithm,\n+                        keyLength, attributes, keySensitive);\n+            default:\n+                throw new ProviderException\n+                        (\"Unknown private key algorithm \" + algorithm);\n@@ -435,2 +421,1 @@\n-    \/\/ class for sensitive and unextractable private keys\n-    private static final class P11PrivateKey extends P11Key\n+    private static class P11PrivateKey extends P11Key\n@@ -440,0 +425,1 @@\n+        protected byte[] encoded;\n@@ -525,4 +511,3 @@\n-    \/\/ RSA CRT private key\n-    private static final class P11RSAPrivateKey extends P11Key\n-                implements RSAPrivateCrtKey {\n-        private static final long serialVersionUID = 9215872438913515220L;\n+    private static final class P11RSAAttributesFetcher\n+            implements Serializable {\n+        private static final long serialVersionUID = 1L;\n@@ -530,0 +515,5 @@\n+        private P11Key p11Key;\n+        private Token token;\n+        private boolean keySensitive;\n+        private boolean isPrivateKey;\n+        private boolean isCRTKey;\n@@ -531,20 +521,25 @@\n-        private byte[] encoded;\n-        P11RSAPrivateKey(Session session, long keyID, String algorithm,\n-                int keyLength, CK_ATTRIBUTE[] attrs, CK_ATTRIBUTE[] crtAttrs) {\n-            super(PRIVATE, session, keyID, algorithm, keyLength, attrs);\n-\n-            for (CK_ATTRIBUTE a : crtAttrs) {\n-                if (a.type == CKA_PUBLIC_EXPONENT) {\n-                    e = a.getBigInteger();\n-                } else if (a.type == CKA_PRIME_1) {\n-                    p = a.getBigInteger();\n-                } else if (a.type == CKA_PRIME_2) {\n-                    q = a.getBigInteger();\n-                } else if (a.type == CKA_EXPONENT_1) {\n-                    pe = a.getBigInteger();\n-                } else if (a.type == CKA_EXPONENT_2) {\n-                    qe = a.getBigInteger();\n-                } else if (a.type == CKA_COEFFICIENT) {\n-                    coeff = a.getBigInteger();\n-                }\n-            }\n+        private P11RSAAttributesFetcher(Token token,\n+                boolean keySensitive, boolean isPrivateKey) {\n+            this.token = token;\n+            this.keySensitive = keySensitive;\n+            this.isPrivateKey = isPrivateKey;\n+        }\n+        \/\/ Constructor for sensitive RSA Private keys and RSA Public keys.\n+        \/\/ Attribute values are lazily fetched.\n+        P11RSAAttributesFetcher(P11Key p11Key, boolean keySensitive,\n+                boolean isPrivateKey) {\n+            this(p11Key.token, keySensitive, isPrivateKey);\n+            this.p11Key = p11Key;\n+        }\n+        \/\/ Constructor for non-sensitive RSA Private keys. The P11Key is not\n+        \/\/ built yet but attributes values are needed in advanced to determine\n+        \/\/ if the key type is CRT or non-CRT.\n+        \/\/\n+        \/\/ NOTE: it is assumed that the received keyID is alive. See\n+        \/\/ P11Key::getKeyID and P11Key::releaseKeyID to learn more about the\n+        \/\/ keys use pattern.\n+        P11RSAAttributesFetcher(Token token, long keyID,\n+                boolean keySensitive, boolean isPrivateKey) {\n+            this(token, keySensitive, isPrivateKey);\n+            token.ensureValid();\n+            doFetchValues(keyID);\n@@ -554,1 +549,3 @@\n-            if (n != null) {\n+            if (n != null || e != null || d != null || p != null ||\n+                    q != null || pe != null || qe != null ||\n+                    coeff != null) {\n@@ -557,7 +554,125 @@\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_MODULUS),\n-                new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT),\n-            };\n-            fetchAttributes(attributes);\n-            n = attributes[0].getBigInteger();\n-            d = attributes[1].getBigInteger();\n+            \/\/ p11Key can only be null in the non-sensitive RSA Private\n+            \/\/ key case. However, values are initialized from the\n+            \/\/ constructor in such case, so this execution point should\n+            \/\/ not be reachable with a null p11Key.\n+            assert(p11Key != null);\n+            long keyID = p11Key.getKeyID();\n+            try {\n+                doFetchValues(keyID);\n+            } finally {\n+                p11Key.releaseKeyID();\n+            }\n+        }\n+        \/\/ No need to synchronize this method. For a given instance\n+        \/\/ (fully constructed), only called from fetchValues which is\n+        \/\/ already synchronized.\n+        private void doFetchValues(long keyID) {\n+            CK_ATTRIBUTE[] attributes = null;\n+            CK_ATTRIBUTE[] tryCRTAttributes = null;\n+            if (!isPrivateKey) {\n+                attributes = new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_MODULUS),\n+                    new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT),\n+                };\n+            } else {\n+                if (!keySensitive) {\n+                    tryCRTAttributes = new CK_ATTRIBUTE[] {\n+                        new CK_ATTRIBUTE(CKA_MODULUS),\n+                        new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT),\n+                        new CK_ATTRIBUTE(CKA_PRIME_1),\n+                        new CK_ATTRIBUTE(CKA_PRIME_2),\n+                        new CK_ATTRIBUTE(CKA_EXPONENT_1),\n+                        new CK_ATTRIBUTE(CKA_EXPONENT_2),\n+                        new CK_ATTRIBUTE(CKA_COEFFICIENT),\n+                        new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT),\n+                    };\n+                } else {\n+                    tryCRTAttributes = new CK_ATTRIBUTE[] {\n+                            new CK_ATTRIBUTE(CKA_MODULUS),\n+                            new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT),\n+                    };\n+                }\n+                Session tempSession = null;\n+                try {\n+                    tempSession = token.getOpSession();\n+                    token.p11.C_GetAttributeValue(tempSession.id(), keyID,\n+                            tryCRTAttributes);\n+                    isCRTKey = true;\n+                    for (CK_ATTRIBUTE attr : tryCRTAttributes) {\n+                        isCRTKey &= attr.pValue instanceof byte[];\n+                        if (!isCRTKey)\n+                            break;\n+                    }\n+                } catch (PKCS11Exception e) {\n+                    \/\/ Non-CRT\n+                } finally {\n+                    token.releaseSession(tempSession);\n+                }\n+                if (!isCRTKey) {\n+                    if (!keySensitive) {\n+                        attributes = new CK_ATTRIBUTE[] {\n+                            new CK_ATTRIBUTE(CKA_MODULUS),\n+                            new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT),\n+                        };\n+                    } else {\n+                        attributes = new CK_ATTRIBUTE[] {\n+                            new CK_ATTRIBUTE(CKA_MODULUS),\n+                        };\n+                    }\n+                }\n+            }\n+            if (!isPrivateKey || !isCRTKey) {\n+                Session tempSession = null;\n+                try {\n+                    tempSession = token.getOpSession();\n+                    token.p11.C_GetAttributeValue(tempSession.id(), keyID,\n+                            attributes);\n+                } catch (PKCS11Exception e) {\n+                    throw new ProviderException(e);\n+                } finally {\n+                    token.releaseSession(tempSession);\n+                }\n+            }\n+            if (!isPrivateKey) {\n+                n = attributes[0].getBigInteger();\n+                e = attributes[1].getBigInteger();\n+            } else {\n+                if (!isCRTKey) {\n+                    if (!keySensitive) {\n+                        n = attributes[0].getBigInteger();\n+                        d = attributes[1].getBigInteger();\n+                    } else {\n+                        n = attributes[0].getBigInteger();\n+                    }\n+                } else {\n+                    if (!keySensitive) {\n+                        n = tryCRTAttributes[0].getBigInteger();\n+                        e = tryCRTAttributes[1].getBigInteger();\n+                        p = tryCRTAttributes[2].getBigInteger();\n+                        q = tryCRTAttributes[3].getBigInteger();\n+                        pe = tryCRTAttributes[4].getBigInteger();\n+                        qe = tryCRTAttributes[5].getBigInteger();\n+                        coeff = tryCRTAttributes[6].getBigInteger();\n+                        d = tryCRTAttributes[7].getBigInteger();\n+                    } else {\n+                        n = tryCRTAttributes[0].getBigInteger();\n+                        e = tryCRTAttributes[1].getBigInteger();\n+                    }\n+                }\n+            }\n+        }\n+        boolean isCRTKey() {\n+            fetchValues();\n+            return isCRTKey;\n+        }\n+        BigInteger getModulus() {\n+            fetchValues();\n+            return n;\n+        }\n+        BigInteger getPublicExponent() {\n+            fetchValues();\n+            return e;\n+        }\n+        BigInteger getPrivateExponent() {\n+            fetchValues();\n+            return d;\n@@ -565,0 +680,21 @@\n+        BigInteger getPrimeP() {\n+            fetchValues();\n+            return p;\n+        }\n+        BigInteger getPrimeQ() {\n+            fetchValues();\n+            return q;\n+        }\n+        BigInteger getPrimeExponentP() {\n+            fetchValues();\n+            return pe;\n+        }\n+        BigInteger getPrimeExponentQ() {\n+            fetchValues();\n+            return qe;\n+        }\n+        BigInteger getCrtCoefficient() {\n+            fetchValues();\n+            return coeff;\n+        }\n+    }\n@@ -566,0 +702,38 @@\n+    static class P11RSAPrivateKeyInternal extends P11PrivateKey {\n+        private static final long serialVersionUID = 1L;\n+\n+        protected P11RSAAttributesFetcher attrFetcher;\n+        \/\/ Constructor for non-sensitive RSA Private keys, where CRT or non-CRT\n+        \/\/ was determined in advanced with the help of a\n+        \/\/ P11RSAAttributesFetcher instance. This instance is re-used to\n+        \/\/ minimize the number of PKCS#11 queries.\n+        protected P11RSAPrivateKeyInternal(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attributes,\n+                P11RSAAttributesFetcher attrFetcher) {\n+            super(session, keyID, algorithm, keyLength, attributes);\n+            this.attrFetcher = attrFetcher;\n+        }\n+        \/\/ Constructor for sensitive RSA Private keys, where determining\n+        \/\/ CRT or non-CRT in advanced is not required.\n+        P11RSAPrivateKeyInternal(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attributes) {\n+            super(session, keyID, algorithm, keyLength, attributes);\n+            attrFetcher = new P11RSAAttributesFetcher(this, true, true);\n+        }\n+        BigInteger getModulus() {\n+            return attrFetcher.getModulus();\n+        }\n+    }\n+\n+    \/\/ RSA CRT private key\n+    private static final class P11RSAPrivateKey extends\n+            P11RSAPrivateKeyInternal implements RSAPrivateCrtKey {\n+        private static final long serialVersionUID = 9215872438913515221L;\n+\n+        P11RSAPrivateKey(Session session, long keyID, String algorithm,\n+                int keyLength, CK_ATTRIBUTE[] attributes,\n+                P11RSAAttributesFetcher attrFetcher) {\n+            super(session, keyID, algorithm, keyLength, attributes,\n+                    attrFetcher);\n+        }\n+        @Override\n@@ -570,0 +744,1 @@\n+        @Override\n@@ -573,1 +748,0 @@\n-                fetchValues();\n@@ -575,2 +749,5 @@\n-                    Key newKey = RSAPrivateCrtKeyImpl.newKey\n-                        (KeyType.RSA, null, n, e, d, p, q, pe, qe, coeff);\n+                    Key newKey = RSAPrivateCrtKeyImpl.newKey(KeyType.RSA, null,\n+                            getModulus(), getPublicExponent(),\n+                            getPrivateExponent(), getPrimeP(), getPrimeQ(),\n+                            getPrimeExponentP(), getPrimeExponentQ(),\n+                            getCrtCoefficient());\n@@ -584,0 +761,1 @@\n+        @Override\n@@ -585,2 +763,1 @@\n-            fetchValues();\n-            return n;\n+            return super.getModulus();\n@@ -589,1 +766,1 @@\n-            return e;\n+            return attrFetcher.getPublicExponent();\n@@ -592,2 +769,1 @@\n-            fetchValues();\n-            return d;\n+            return attrFetcher.getPrivateExponent();\n@@ -596,1 +772,1 @@\n-            return p;\n+            return attrFetcher.getPrimeP();\n@@ -599,1 +775,1 @@\n-            return q;\n+            return attrFetcher.getPrimeQ();\n@@ -602,1 +778,1 @@\n-            return pe;\n+            return attrFetcher.getPrimeExponentP();\n@@ -605,1 +781,1 @@\n-            return qe;\n+            return attrFetcher.getPrimeExponentQ();\n@@ -608,1 +784,1 @@\n-            return coeff;\n+            return attrFetcher.getCrtCoefficient();\n@@ -613,3 +789,3 @@\n-    private static final class P11RSAPrivateNonCRTKey extends P11Key\n-                implements RSAPrivateKey {\n-        private static final long serialVersionUID = 1137764983777411481L;\n+    private static final class P11RSAPrivateNonCRTKey\n+            extends P11RSAPrivateKeyInternal implements RSAPrivateKey {\n+        private static final long serialVersionUID = 1137764983777411482L;\n@@ -617,2 +793,0 @@\n-        private BigInteger n, d;\n-        private byte[] encoded;\n@@ -620,15 +794,4 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n-            super(PRIVATE, session, keyID, algorithm, keyLength, attributes);\n-        }\n-        private synchronized void fetchValues() {\n-            token.ensureValid();\n-            if (n != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_MODULUS),\n-                new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT),\n-            };\n-            fetchAttributes(attributes);\n-            n = attributes[0].getBigInteger();\n-            d = attributes[1].getBigInteger();\n+                int keyLength, CK_ATTRIBUTE[] attributes,\n+                P11RSAAttributesFetcher attrFetcher) {\n+            super(session, keyID, algorithm, keyLength, attributes,\n+                    attrFetcher);\n@@ -636,0 +799,1 @@\n+        @Override\n@@ -640,0 +804,1 @@\n+        @Override\n@@ -643,1 +808,0 @@\n-                fetchValues();\n@@ -657,0 +821,1 @@\n+        @Override\n@@ -658,2 +823,1 @@\n-            fetchValues();\n-            return n;\n+            return super.getModulus();\n@@ -662,2 +826,1 @@\n-            fetchValues();\n-            return d;\n+            return attrFetcher.getPrivateExponent();\n@@ -669,2 +832,3 @@\n-        private static final long serialVersionUID = -826726289023854455L;\n-        private BigInteger n, e;\n+        private static final long serialVersionUID = -826726289023854456L;\n+\n+        private P11RSAAttributesFetcher attrFetcher;\n@@ -675,13 +839,1 @@\n-        }\n-        private synchronized void fetchValues() {\n-            token.ensureValid();\n-            if (n != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_MODULUS),\n-                new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT),\n-            };\n-            fetchAttributes(attributes);\n-            n = attributes[0].getBigInteger();\n-            e = attributes[1].getBigInteger();\n+            attrFetcher = new P11RSAAttributesFetcher(this, false, false);\n@@ -696,1 +848,0 @@\n-                fetchValues();\n@@ -699,1 +850,2 @@\n-                        (KeyType.RSA, null, n, e).getEncoded();\n+                        (KeyType.RSA, null, getModulus(),\n+                                getPublicExponent()).getEncoded();\n@@ -707,2 +859,1 @@\n-            fetchValues();\n-            return n;\n+            return attrFetcher.getModulus();\n@@ -711,2 +862,1 @@\n-            fetchValues();\n-            return e;\n+            return attrFetcher.getPublicExponent();\n@@ -715,0 +865,51 @@\n+            return super.toString() +  \"\\n  modulus: \" + getModulus()\n+                + \"\\n  public exponent: \" + getPublicExponent();\n+        }\n+    }\n+\n+    private static final class P11DSAAttributesFetcher\n+            implements Serializable {\n+        private static final long serialVersionUID = 1L;\n+\n+        private P11Key p11Key;\n+        private boolean keySensitive;\n+        private BigInteger value;\n+        private DSAParams params;\n+        P11DSAAttributesFetcher(P11Key p11Key, boolean keySensitive) {\n+            this.p11Key = p11Key;\n+            this.keySensitive = keySensitive;\n+        }\n+        private synchronized void fetchValues() {\n+            p11Key.token.ensureValid();\n+            if (value != null || params != null) {\n+                return;\n+            }\n+            CK_ATTRIBUTE[] attributes = null;\n+            if (!keySensitive) {\n+                attributes = new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_VALUE),\n+                    new CK_ATTRIBUTE(CKA_PRIME),\n+                    new CK_ATTRIBUTE(CKA_SUBPRIME),\n+                    new CK_ATTRIBUTE(CKA_BASE),\n+                };\n+            } else {\n+                attributes = new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_PRIME),\n+                    new CK_ATTRIBUTE(CKA_SUBPRIME),\n+                    new CK_ATTRIBUTE(CKA_BASE),\n+                };\n+            }\n+            p11Key.fetchAttributes(attributes);\n+            {\n+                int i = 0;\n+                if (!keySensitive) {\n+                    value = attributes[i++].getBigInteger();\n+                }\n+                params = new DSAParameterSpec(\n+                    attributes[i++].getBigInteger(),\n+                    attributes[i++].getBigInteger(),\n+                    attributes[i++].getBigInteger()\n+                );\n+            }\n+        }\n+        BigInteger getValue() {\n@@ -716,2 +917,5 @@\n-            return super.toString() +  \"\\n  modulus: \" + n\n-                + \"\\n  public exponent: \" + e;\n+            return value;\n+        }\n+        DSAParams getParams() {\n+            fetchValues();\n+            return params;\n@@ -723,1 +927,1 @@\n-        private static final long serialVersionUID = 5989753793316396637L;\n+        private static final long serialVersionUID = 5989753793316396638L;\n@@ -725,2 +929,1 @@\n-        private BigInteger y;\n-        private DSAParams params;\n+        private P11DSAAttributesFetcher attrFetcher;\n@@ -731,19 +934,1 @@\n-        }\n-        private synchronized void fetchValues() {\n-            token.ensureValid();\n-            if (y != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_VALUE),\n-                new CK_ATTRIBUTE(CKA_PRIME),\n-                new CK_ATTRIBUTE(CKA_SUBPRIME),\n-                new CK_ATTRIBUTE(CKA_BASE),\n-            };\n-            fetchAttributes(attributes);\n-            y = attributes[0].getBigInteger();\n-            params = new DSAParameterSpec(\n-                attributes[1].getBigInteger(),\n-                attributes[2].getBigInteger(),\n-                attributes[3].getBigInteger()\n-            );\n+            attrFetcher = new P11DSAAttributesFetcher(this, false);\n@@ -758,1 +943,1 @@\n-                fetchValues();\n+                DSAParams params = getParams();\n@@ -760,2 +945,3 @@\n-                    Key key = new sun.security.provider.DSAPublicKey\n-                            (y, params.getP(), params.getQ(), params.getG());\n+                    Key key = new sun.security.provider.DSAPublicKey(\n+                            getY(), params.getP(), params.getQ(),\n+                            params.getG());\n@@ -770,2 +956,1 @@\n-            fetchValues();\n-            return y;\n+            return attrFetcher.getValue();\n@@ -774,2 +959,1 @@\n-            fetchValues();\n-            return params;\n+            return attrFetcher.getParams();\n@@ -778,3 +962,4 @@\n-            fetchValues();\n-            return super.toString() +  \"\\n  y: \" + y + \"\\n  p: \" + params.getP()\n-                + \"\\n  q: \" + params.getQ() + \"\\n  g: \" + params.getG();\n+            DSAParams params = getParams();\n+            return super.toString() +  \"\\n  y: \" + getY() + \"\\n  p: \" +\n+                    params.getP() + \"\\n  q: \" + params.getQ() + \"\\n  g: \" +\n+                    params.getG();\n@@ -784,3 +969,2 @@\n-    private static final class P11DSAPrivateKey extends P11Key\n-                                                implements DSAPrivateKey {\n-        private static final long serialVersionUID = 3119629997181999389L;\n+    static class P11DSAPrivateKeyInternal extends P11PrivateKey {\n+        private static final long serialVersionUID = 1L;\n@@ -788,6 +972,6 @@\n-        private BigInteger x;\n-        private DSAParams params;\n-        private byte[] encoded;\n-        P11DSAPrivateKey(Session session, long keyID, String algorithm,\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n-            super(PRIVATE, session, keyID, algorithm, keyLength, attributes);\n+        protected P11DSAAttributesFetcher attrFetcher;\n+        protected P11DSAPrivateKeyInternal(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attributes,\n+                boolean keySensitive) {\n+            super(session, keyID, algorithm, keyLength, attributes);\n+            attrFetcher = new P11DSAAttributesFetcher(this, keySensitive);\n@@ -795,4 +979,17 @@\n-        private synchronized void fetchValues() {\n-            token.ensureValid();\n-            if (x != null) {\n-                return;\n+        DSAParams getParams() {\n+            return attrFetcher.getParams();\n+        }\n+    }\n+\n+    static final class P11DSAPrivateKey extends P11DSAPrivateKeyInternal\n+            implements DSAPrivateKey {\n+        private static final long serialVersionUID = 3119629997181999390L;\n+        static P11DSAPrivateKeyInternal newInstance(Session session,\n+                long keyID, String algorithm, int keyLength, CK_ATTRIBUTE[]\n+                        attributes, boolean keySensitive) {\n+            if (keySensitive) {\n+                return new P11DSAPrivateKeyInternal(session, keyID, algorithm,\n+                        keyLength, attributes, keySensitive);\n+            } else {\n+                return new P11DSAPrivateKey(session, keyID, algorithm,\n+                        keyLength, attributes, keySensitive);\n@@ -800,13 +997,0 @@\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_VALUE),\n-                new CK_ATTRIBUTE(CKA_PRIME),\n-                new CK_ATTRIBUTE(CKA_SUBPRIME),\n-                new CK_ATTRIBUTE(CKA_BASE),\n-            };\n-            fetchAttributes(attributes);\n-            x = attributes[0].getBigInteger();\n-            params = new DSAParameterSpec(\n-                attributes[1].getBigInteger(),\n-                attributes[2].getBigInteger(),\n-                attributes[3].getBigInteger()\n-            );\n@@ -814,0 +998,8 @@\n+\n+        private P11DSAPrivateKey(Session session, long keyID, String algorithm,\n+                int keyLength, CK_ATTRIBUTE[] attributes,\n+                boolean keySensitive) {\n+            super(session, keyID, algorithm, keyLength, attributes,\n+                    keySensitive);\n+        }\n+        @Override\n@@ -818,0 +1010,1 @@\n+        @Override\n@@ -820,2 +1013,2 @@\n-            if (encoded == null) {\n-                fetchValues();\n+            if (encoded == null && getX() != null) {\n+                DSAParams params = getParams();\n@@ -823,1 +1016,1 @@\n-                        (x, params.getP(), params.getQ(), params.getG());\n+                        (getX(), params.getP(), params.getQ(), params.getG());\n@@ -829,2 +1022,1 @@\n-            fetchValues();\n-            return x;\n+            return attrFetcher.getValue();\n@@ -832,0 +1024,1 @@\n+        @Override\n@@ -833,2 +1026,1 @@\n-            fetchValues();\n-            return params;\n+            return super.getParams();\n@@ -838,3 +1030,3 @@\n-    private static final class P11DHPrivateKey extends P11Key\n-                                                implements DHPrivateKey {\n-        private static final long serialVersionUID = -1698576167364928838L;\n+    private static final class P11DHAttributesFetcher\n+            implements Serializable {\n+        private static final long serialVersionUID = 1L;\n@@ -842,1 +1034,3 @@\n-        private BigInteger x;\n+        private P11Key p11Key;\n+        private boolean keySensitive;\n+        private BigInteger value;\n@@ -844,4 +1038,3 @@\n-        private byte[] encoded;\n-        P11DHPrivateKey(Session session, long keyID, String algorithm,\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n-            super(PRIVATE, session, keyID, algorithm, keyLength, attributes);\n+        P11DHAttributesFetcher(P11Key p11Key, boolean keySensitive) {\n+            this.p11Key = p11Key;\n+            this.keySensitive = keySensitive;\n@@ -850,2 +1043,2 @@\n-            token.ensureValid();\n-            if (x != null) {\n+            p11Key.token.ensureValid();\n+            if (value != null || params != null) {\n@@ -854,11 +1047,32 @@\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_VALUE),\n-                new CK_ATTRIBUTE(CKA_PRIME),\n-                new CK_ATTRIBUTE(CKA_BASE),\n-            };\n-            fetchAttributes(attributes);\n-            x = attributes[0].getBigInteger();\n-            params = new DHParameterSpec(\n-                attributes[1].getBigInteger(),\n-                attributes[2].getBigInteger()\n-            );\n+            CK_ATTRIBUTE[] attributes = null;\n+            if (!keySensitive) {\n+                attributes = new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_VALUE),\n+                    new CK_ATTRIBUTE(CKA_PRIME),\n+                    new CK_ATTRIBUTE(CKA_BASE),\n+                };\n+            } else {\n+                attributes = new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_PRIME),\n+                    new CK_ATTRIBUTE(CKA_BASE),\n+                };\n+            }\n+            p11Key.fetchAttributes(attributes);\n+            {\n+                int i = 0;\n+                if (!keySensitive) {\n+                    value = attributes[i++].getBigInteger();\n+                }\n+                params = new DHParameterSpec(\n+                    attributes[i++].getBigInteger(),\n+                    attributes[i++].getBigInteger()\n+                );\n+            }\n+        }\n+        BigInteger getValue() {\n+            fetchValues();\n+            return value;\n+        }\n+        DHParameterSpec getParams() {\n+            fetchValues();\n+            return params;\n@@ -866,0 +1080,39 @@\n+    }\n+\n+    static class P11DHPrivateKeyInternal extends P11PrivateKey {\n+        private static final long serialVersionUID = 1L;\n+\n+        protected P11DHAttributesFetcher attrFetcher;\n+        protected P11DHPrivateKeyInternal(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attributes,\n+                boolean keySensitive) {\n+            super(session, keyID, algorithm, keyLength, attributes);\n+            attrFetcher = new P11DHAttributesFetcher(this, keySensitive);\n+        }\n+        DHParameterSpec getParams() {\n+            return attrFetcher.getParams();\n+        }\n+    }\n+\n+    static final class P11DHPrivateKey extends P11DHPrivateKeyInternal\n+            implements DHPrivateKey {\n+        private static final long serialVersionUID = -1698576167364928839L;\n+        static P11DHPrivateKeyInternal newInstance(Session session,\n+                long keyID, String algorithm, int keyLength, CK_ATTRIBUTE[]\n+                        attributes, boolean keySensitive) {\n+            if (keySensitive) {\n+                return new P11DHPrivateKeyInternal(session, keyID, algorithm,\n+                        keyLength, attributes, keySensitive);\n+            } else {\n+                return new P11DHPrivateKey(session, keyID, algorithm,\n+                        keyLength, attributes, keySensitive);\n+            }\n+        }\n+\n+        private P11DHPrivateKey(Session session, long keyID, String algorithm,\n+                int keyLength, CK_ATTRIBUTE[] attributes,\n+                boolean keySensitive) {\n+            super(session, keyID, algorithm, keyLength, attributes,\n+                    keySensitive);\n+        }\n+        @Override\n@@ -870,0 +1123,1 @@\n+        @Override\n@@ -872,2 +1126,2 @@\n-            if (encoded == null) {\n-                fetchValues();\n+            if (encoded == null && getX() != null) {\n+                DHParameterSpec params = getParams();\n@@ -876,1 +1130,1 @@\n-                        (x, params.getP(), params.getG());\n+                        (getX(), params.getP(), params.getG());\n@@ -887,8 +1141,0 @@\n-        public BigInteger getX() {\n-            fetchValues();\n-            return x;\n-        }\n-        public DHParameterSpec getParams() {\n-            fetchValues();\n-            return params;\n-        }\n@@ -899,2 +1145,2 @@\n-            fetchValues();\n-            return Objects.hash(x, params.getP(), params.getG());\n+            DHParameterSpec params = getParams();\n+            return Objects.hash(getX(), params.getP(), params.getG());\n@@ -911,1 +1157,0 @@\n-            fetchValues();\n@@ -913,0 +1158,8 @@\n+            BigInteger x = getX();\n+            BigInteger otherX = other.getX();\n+            if (x == null && otherX != null ||\n+                    x != null && otherX == null ||\n+                    x != null && x.compareTo(otherX) != 0) {\n+                return false;\n+            }\n+            DHParameterSpec params = getParams();\n@@ -914,3 +1167,9 @@\n-            return ((this.x.compareTo(other.getX()) == 0) &&\n-                    (this.params.getP().compareTo(otherParams.getP()) == 0) &&\n-                    (this.params.getG().compareTo(otherParams.getG()) == 0));\n+            return ((params.getP().compareTo(otherParams.getP()) == 0) &&\n+                    (params.getG().compareTo(otherParams.getG()) == 0));\n+        }\n+        public BigInteger getX() {\n+            return attrFetcher.getValue();\n+        }\n+        @Override\n+        public DHParameterSpec getParams() {\n+            return super.getParams();\n@@ -922,1 +1181,1 @@\n-        static final long serialVersionUID = -598383872153843657L;\n+        static final long serialVersionUID = -598383872153843658L;\n@@ -924,2 +1183,1 @@\n-        private BigInteger y;\n-        private DHParameterSpec params;\n+        private P11DHAttributesFetcher attrFetcher;\n@@ -930,17 +1188,1 @@\n-        }\n-        private synchronized void fetchValues() {\n-            token.ensureValid();\n-            if (y != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_VALUE),\n-                new CK_ATTRIBUTE(CKA_PRIME),\n-                new CK_ATTRIBUTE(CKA_BASE),\n-            };\n-            fetchAttributes(attributes);\n-            y = attributes[0].getBigInteger();\n-            params = new DHParameterSpec(\n-                attributes[1].getBigInteger(),\n-                attributes[2].getBigInteger()\n-            );\n+            attrFetcher = new P11DHAttributesFetcher(this, false);\n@@ -955,1 +1197,1 @@\n-                fetchValues();\n+                DHParameterSpec params = getParams();\n@@ -958,1 +1200,1 @@\n-                        (y, params.getP(), params.getG());\n+                        (getY(), params.getP(), params.getG());\n@@ -970,2 +1212,1 @@\n-            fetchValues();\n-            return y;\n+            return attrFetcher.getValue();\n@@ -974,2 +1215,1 @@\n-            fetchValues();\n-            return params;\n+            return attrFetcher.getParams();\n@@ -978,3 +1218,3 @@\n-            fetchValues();\n-            return super.toString() +  \"\\n  y: \" + y + \"\\n  p: \" + params.getP()\n-                + \"\\n  g: \" + params.getG();\n+            DHParameterSpec params = getParams();\n+            return super.toString() +  \"\\n  y: \" + getY() + \"\\n  p: \" +\n+                    params.getP() + \"\\n  g: \" + params.getG();\n@@ -986,2 +1226,2 @@\n-            fetchValues();\n-            return Objects.hash(y, params.getP(), params.getG());\n+            DHParameterSpec params = getParams();\n+            return Objects.hash(getY(), params.getP(), params.getG());\n@@ -998,1 +1238,0 @@\n-            fetchValues();\n@@ -1000,0 +1239,1 @@\n+            DHParameterSpec params = getParams();\n@@ -1001,3 +1241,3 @@\n-            return ((this.y.compareTo(other.getY()) == 0) &&\n-                    (this.params.getP().compareTo(otherParams.getP()) == 0) &&\n-                    (this.params.getG().compareTo(otherParams.getG()) == 0));\n+            return ((getY().compareTo(other.getY()) == 0) &&\n+                    (params.getP().compareTo(otherParams.getP()) == 0) &&\n+                    (params.getG().compareTo(otherParams.getG()) == 0));\n@@ -1007,3 +1247,2 @@\n-    private static final class P11ECPrivateKey extends P11Key\n-                                                implements ECPrivateKey {\n-        private static final long serialVersionUID = -7786054399510515515L;\n+    private static final class P11ECAttributesFetcher implements Serializable {\n+        private static final long serialVersionUID = 1L;\n@@ -1011,1 +1250,4 @@\n-        private BigInteger s;\n+        private P11Key p11Key;\n+        private boolean keySensitive;\n+        private boolean isPrivateKey;\n+        private BigInteger value;\n@@ -1013,4 +1255,6 @@\n-        private byte[] encoded;\n-        P11ECPrivateKey(Session session, long keyID, String algorithm,\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n-            super(PRIVATE, session, keyID, algorithm, keyLength, attributes);\n+        private ECPoint w;\n+        P11ECAttributesFetcher(P11Key p11Key, boolean keySensitive,\n+                boolean isPrivateKey) {\n+            this.p11Key = p11Key;\n+            this.keySensitive = keySensitive;\n+            this.isPrivateKey = isPrivateKey;\n@@ -1019,2 +1263,2 @@\n-            token.ensureValid();\n-            if (s != null) {\n+            p11Key.token.ensureValid();\n+            if (value != null || params != null || w != null) {\n@@ -1023,11 +1267,53 @@\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_VALUE),\n-                new CK_ATTRIBUTE(CKA_EC_PARAMS, params),\n-            };\n-            fetchAttributes(attributes);\n-            s = attributes[0].getBigInteger();\n-            try {\n-                params = P11ECKeyFactory.decodeParameters\n-                            (attributes[1].getByteArray());\n-            } catch (Exception e) {\n-                throw new RuntimeException(\"Could not parse key values\", e);\n+            CK_ATTRIBUTE[] attributes = null;\n+            if (!keySensitive) {\n+                if (isPrivateKey) {\n+                    attributes = new CK_ATTRIBUTE[] {\n+                        new CK_ATTRIBUTE(CKA_VALUE),\n+                        new CK_ATTRIBUTE(CKA_EC_PARAMS, params),\n+                    };\n+                } else {\n+                    attributes = new CK_ATTRIBUTE[] {\n+                        new CK_ATTRIBUTE(CKA_EC_PARAMS, params),\n+                        new CK_ATTRIBUTE(CKA_EC_POINT),\n+                    };\n+                }\n+            } else {\n+                attributes = new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_EC_PARAMS, params),\n+                };\n+            }\n+            p11Key.fetchAttributes(attributes);\n+            {\n+                int i = 0;\n+                if (!keySensitive && isPrivateKey) {\n+                    value = attributes[i++].getBigInteger();\n+                }\n+                try {\n+                    params = P11ECKeyFactory.decodeParameters\n+                                (attributes[i++].getByteArray());\n+\n+                    if (!keySensitive && !isPrivateKey) {\n+                        byte[] ecKey = attributes[i++].getByteArray();\n+\n+                        \/\/ Check whether the X9.63 encoding of an EC point is\n+                        \/\/ wrapped in an ASN.1 OCTET STRING\n+                        if (!p11Key.token.config.getUseEcX963Encoding()) {\n+                            DerValue wECPoint = new DerValue(ecKey);\n+\n+                            if (wECPoint.getTag() !=\n+                                    DerValue.tag_OctetString) {\n+                                throw new IOException(\"Could not DER decode\" +\n+                                        \" EC point. Unexpected tag: \" +\n+                                        wECPoint.getTag());\n+                            }\n+                            w = P11ECKeyFactory.decodePoint\n+                                (wECPoint.getDataBytes(), params.getCurve());\n+\n+                        } else {\n+                            w = P11ECKeyFactory.decodePoint(ecKey,\n+                                    params.getCurve());\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    throw new RuntimeException(\"Could not parse key values\", e);\n+                }\n@@ -1036,0 +1322,51 @@\n+        BigInteger getValue() {\n+            fetchValues();\n+            return value;\n+        }\n+        ECParameterSpec getParams() {\n+            fetchValues();\n+            return params;\n+        }\n+        ECPoint getW() {\n+            fetchValues();\n+            return w;\n+        }\n+    }\n+\n+    static class P11ECPrivateKeyInternal extends P11PrivateKey {\n+        private static final long serialVersionUID = 1L;\n+\n+        protected P11ECAttributesFetcher attrFetcher;\n+        protected P11ECPrivateKeyInternal(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attributes,\n+                boolean keySensitive) {\n+            super(session, keyID, algorithm, keyLength, attributes);\n+            attrFetcher = new P11ECAttributesFetcher(this, keySensitive, true);\n+        }\n+        ECParameterSpec getParams() {\n+            return attrFetcher.getParams();\n+        }\n+    }\n+\n+    private static final class P11ECPrivateKey extends P11ECPrivateKeyInternal\n+            implements ECPrivateKey {\n+        private static final long serialVersionUID = -7786054399510515516L;\n+        static P11ECPrivateKeyInternal newInstance(Session session,\n+                long keyID, String algorithm, int keyLength, CK_ATTRIBUTE[]\n+                        attributes, boolean keySensitive) {\n+            if (keySensitive) {\n+                return new P11ECPrivateKeyInternal(session, keyID, algorithm,\n+                        keyLength, attributes, keySensitive);\n+            } else {\n+                return new P11ECPrivateKey(session, keyID, algorithm,\n+                        keyLength, attributes, keySensitive);\n+            }\n+        }\n+\n+        private P11ECPrivateKey(Session session, long keyID, String algorithm,\n+                int keyLength, CK_ATTRIBUTE[] attributes,\n+                boolean keySensitive) {\n+            super(session, keyID, algorithm, keyLength, attributes,\n+                    keySensitive);\n+        }\n+        @Override\n@@ -1040,0 +1377,1 @@\n+        @Override\n@@ -1042,2 +1380,1 @@\n-            if (encoded == null) {\n-                fetchValues();\n+            if (encoded == null && getS() != null) {\n@@ -1045,1 +1382,1 @@\n-                    Key key = ECUtil.generateECPrivateKey(s, params);\n+                    Key key = ECUtil.generateECPrivateKey(getS(), getParams());\n@@ -1054,2 +1391,1 @@\n-            fetchValues();\n-            return s;\n+            return attrFetcher.getValue();\n@@ -1057,0 +1393,1 @@\n+        @Override\n@@ -1058,2 +1395,1 @@\n-            fetchValues();\n-            return params;\n+            return super.getParams();\n@@ -1065,1 +1401,1 @@\n-        private static final long serialVersionUID = -6371481375154806089L;\n+        private static final long serialVersionUID = -6371481375154806090L;\n@@ -1067,2 +1403,1 @@\n-        private ECPoint w;\n-        private ECParameterSpec params;\n+        private P11ECAttributesFetcher attrFetcher;\n@@ -1073,36 +1408,1 @@\n-        }\n-        private synchronized void fetchValues() {\n-            token.ensureValid();\n-            if (w != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_EC_POINT),\n-                new CK_ATTRIBUTE(CKA_EC_PARAMS),\n-            };\n-            fetchAttributes(attributes);\n-\n-            try {\n-                params = P11ECKeyFactory.decodeParameters\n-                            (attributes[1].getByteArray());\n-                byte[] ecKey = attributes[0].getByteArray();\n-\n-                \/\/ Check whether the X9.63 encoding of an EC point is wrapped\n-                \/\/ in an ASN.1 OCTET STRING\n-                if (!token.config.getUseEcX963Encoding()) {\n-                    DerValue wECPoint = new DerValue(ecKey);\n-\n-                    if (wECPoint.getTag() != DerValue.tag_OctetString) {\n-                        throw new IOException(\"Could not DER decode EC point.\" +\n-                            \" Unexpected tag: \" + wECPoint.getTag());\n-                    }\n-                    w = P11ECKeyFactory.decodePoint\n-                        (wECPoint.getDataBytes(), params.getCurve());\n-\n-                } else {\n-                    w = P11ECKeyFactory.decodePoint(ecKey, params.getCurve());\n-                }\n-\n-            } catch (Exception e) {\n-                throw new RuntimeException(\"Could not parse key values\", e);\n-            }\n+            attrFetcher = new P11ECAttributesFetcher(this, false, false);\n@@ -1117,1 +1417,0 @@\n-                fetchValues();\n@@ -1119,1 +1418,1 @@\n-                    return ECUtil.x509EncodeECPublicKey(w, params);\n+                    return ECUtil.x509EncodeECPublicKey(getW(), getParams());\n@@ -1127,2 +1426,1 @@\n-            fetchValues();\n-            return w;\n+            return attrFetcher.getW();\n@@ -1131,2 +1429,1 @@\n-            fetchValues();\n-            return params;\n+            return attrFetcher.getParams();\n@@ -1135,1 +1432,1 @@\n-            fetchValues();\n+            ECPoint w = getW();\n@@ -1139,1 +1436,1 @@\n-                + \"\\n  parameters: \" + params;\n+                + \"\\n  parameters: \" + getParams();\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":655,"deletions":358,"binary":false,"changes":1013,"status":"modified"},{"patch":"@@ -122,0 +122,3 @@\n+    \/\/ signature length expected or 0 for unknown\n+    private int sigLen;\n+\n@@ -288,1 +291,1 @@\n-                    token.p11.C_SignFinal(session.id(), 0);\n+                    token.p11.C_SignFinal(session.id(), sigLen);\n@@ -299,6 +302,1 @@\n-                byte[] signature;\n-                if (mechanism == CKM_DSA) {\n-                    signature = new byte[64]; \/\/ assume N = 256\n-                } else {\n-                    signature = new byte[(p11Key.length() + 7) >> 3];\n-                }\n+                byte[] signature = new byte[sigLen];\n@@ -376,0 +374,9 @@\n+        sigLen = 0;\n+        if (\"DSA\".equals(p11Key.getAlgorithm())) {\n+            if (p11Key instanceof P11Key.P11DSAPrivateKeyInternal) {\n+                sigLen = ((P11Key.P11DSAPrivateKeyInternal)p11Key).getParams()\n+                        .getQ().bitLength() >> 2;\n+            } else if (p11Key instanceof DSAKey) {\n+                sigLen = ((DSAKey)p11Key).getParams().getQ().bitLength() >> 2;\n+            }\n+        }\n@@ -621,1 +628,1 @@\n-                signature = token.p11.C_SignFinal(session.id(), 0);\n+                signature = token.p11.C_SignFinal(session.id(), sigLen);\n@@ -688,1 +695,1 @@\n-                    signature = asn1ToDSA(signature);\n+                    signature = asn1ToDSA(signature, sigLen);\n@@ -812,1 +819,2 @@\n-    private static byte[] asn1ToDSA(byte[] sig) throws SignatureException {\n+    private static byte[] asn1ToDSA(byte[] sig, int sigLen)\n+            throws SignatureException {\n@@ -827,2 +835,2 @@\n-            byte[] br = toByteArray(r, 20);\n-            byte[] bs = toByteArray(s, 20);\n+            byte[] br = toByteArray(r, sigLen\/2);\n+            byte[] bs = toByteArray(s, sigLen\/2);\n@@ -840,1 +848,1 @@\n-    private byte[] asn1ToECDSA(byte[] sig) throws SignatureException {\n+    private static byte[] asn1ToECDSA(byte[] sig) throws SignatureException {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Signature.java","additions":21,"deletions":13,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.security.AlgorithmParameterGenerator;\n+import java.security.AlgorithmParameters;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.PrivateKey;\n+import java.security.Provider;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.Signature;\n+import java.security.spec.DSAGenParameterSpec;\n+import java.security.spec.DSAParameterSpec;\n+\n+\/*\n+ * @test\n+ * @bug 8271566\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ * @run main\/othervm\/timeout=30 LargeDSAKey\n+ *\/\n+\n+public final class LargeDSAKey extends PKCS11Test {\n+\n+    private static final boolean enableDebug = false;\n+\n+    private static final String knownText =\n+            \"Known text known text known text\";\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"DSA\", p);\n+        AlgorithmParameterGenerator dsaParGen =\n+                AlgorithmParameterGenerator.getInstance(\"DSA\");\n+        DSAGenParameterSpec dsaParGenSpec =\n+                new DSAGenParameterSpec(2048, 256);\n+        dsaParGen.init(dsaParGenSpec, new SecureRandom());\n+        AlgorithmParameters params = dsaParGen.generateParameters();\n+        DSAParameterSpec dsaParams =\n+                params.getParameterSpec(DSAParameterSpec.class);\n+        kpg.initialize(dsaParams);\n+        KeyPair kp = kpg.generateKeyPair();\n+        doTestSignature(kp, p);\n+    }\n+\n+    private static void doTestSignature(KeyPair kp, Provider p)\n+            throws Exception {\n+        byte[] knownTextSig = null;\n+        Signature s = Signature.getInstance(\"SHA1withDSA\", p);\n+        PrivateKey privKey = kp.getPrivate();\n+        PublicKey pubKey = kp.getPublic();\n+        if (enableDebug) {\n+            System.out.println(\"Signature algorithm: \" + s.getAlgorithm());\n+            System.out.println(\"Signature Provider: \" + s.getProvider());\n+            System.out.println(\"Private key for signature: \" + privKey);\n+            System.out.println(\"Public key for signature: \" + pubKey);\n+        }\n+        s.initSign(privKey);\n+        s.update(knownText.getBytes());\n+        knownTextSig = s.sign();\n+        s.initVerify(pubKey);\n+        s.update(knownText.getBytes());\n+        if (s.verify(knownTextSig) == false) {\n+            throw new Exception(\"Could not verify signature\");\n+        }\n+        if (enableDebug) {\n+            System.out.println(\"Signature verified\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        main(new LargeDSAKey());\n+        System.out.println(\"TEST PASS - OK\");\n+    }\n+\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Signature\/LargeDSAKey.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"}]}