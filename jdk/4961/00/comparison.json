{"files":[{"patch":"@@ -377,0 +377,1 @@\n+        boolean keySensitive = false;\n@@ -382,6 +383,13 @@\n-        if (attributes[1].getBoolean() || (attributes[2].getBoolean() == false)) {\n-            return new P11PrivateKey\n-                (session, keyID, algorithm, keyLength, attributes);\n-        } else {\n-            switch (algorithm) {\n-                case \"RSA\":\n+        if (attributes[0].getBoolean() || attributes[1].getBoolean() ||\n+                (attributes[2].getBoolean() == false)) {\n+            keySensitive = true;\n+        }\n+        switch (algorithm) {\n+            case \"RSA\":\n+                if (keySensitive) {\n+                    \/\/ All the attributes queried to decide if the RSA key is\n+                    \/\/ CRT or not are sensitive, except for CKA_PUBLIC_EXPONENT.\n+                    \/\/ RSA private keys are rather treated with an opaque type.\n+                    return new P11PrivateKey(session, keyID, algorithm,\n+                            keyLength, attributes);\n+                } else {\n@@ -419,13 +427,13 @@\n-                case \"DSA\":\n-                    return new P11DSAPrivateKey(session, keyID, algorithm,\n-                            keyLength, attributes);\n-                case \"DH\":\n-                    return new P11DHPrivateKey(session, keyID, algorithm,\n-                            keyLength, attributes);\n-                case \"EC\":\n-                    return new P11ECPrivateKey(session, keyID, algorithm,\n-                            keyLength, attributes);\n-                default:\n-                    throw new ProviderException\n-                            (\"Unknown private key algorithm \" + algorithm);\n-            }\n+                }\n+            case \"DSA\":\n+                return new P11DSAPrivateKey(session, keyID, algorithm,\n+                        keyLength, attributes, keySensitive);\n+            case \"DH\":\n+                return new P11DHPrivateKey(session, keyID, algorithm,\n+                        keyLength, attributes, keySensitive);\n+            case \"EC\":\n+                return new P11ECPrivateKey(session, keyID, algorithm,\n+                        keyLength, attributes, keySensitive);\n+            default:\n+                throw new ProviderException\n+                        (\"Unknown private key algorithm \" + algorithm);\n@@ -788,0 +796,1 @@\n+        boolean keySensitive;\n@@ -792,1 +801,2 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n+                int keyLength, CK_ATTRIBUTE[] attributes,\n+                boolean keySensitive) {\n@@ -794,0 +804,1 @@\n+            this.keySensitive = keySensitive;\n@@ -797,1 +808,1 @@\n-            if (x != null) {\n+            if (x != null || params != null) {\n@@ -800,6 +811,15 @@\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_VALUE),\n-                new CK_ATTRIBUTE(CKA_PRIME),\n-                new CK_ATTRIBUTE(CKA_SUBPRIME),\n-                new CK_ATTRIBUTE(CKA_BASE),\n-            };\n+            CK_ATTRIBUTE[] attributes = null;\n+            if (!keySensitive) {\n+                attributes = new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_VALUE),\n+                    new CK_ATTRIBUTE(CKA_PRIME),\n+                    new CK_ATTRIBUTE(CKA_SUBPRIME),\n+                    new CK_ATTRIBUTE(CKA_BASE),\n+                };\n+            } else {\n+                attributes = new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_PRIME),\n+                    new CK_ATTRIBUTE(CKA_SUBPRIME),\n+                    new CK_ATTRIBUTE(CKA_BASE),\n+                };\n+            }\n@@ -807,6 +827,11 @@\n-            x = attributes[0].getBigInteger();\n-            params = new DSAParameterSpec(\n-                attributes[1].getBigInteger(),\n-                attributes[2].getBigInteger(),\n-                attributes[3].getBigInteger()\n-            );\n+            {\n+                int i = 0;\n+                if (!keySensitive) {\n+                    x = attributes[i++].getBigInteger();\n+                }\n+                params = new DSAParameterSpec(\n+                    attributes[i++].getBigInteger(),\n+                    attributes[i++].getBigInteger(),\n+                    attributes[i++].getBigInteger()\n+                );\n+            }\n@@ -820,1 +845,1 @@\n-            if (encoded == null) {\n+            if (encoded == null && !keySensitive) {\n@@ -842,0 +867,1 @@\n+        boolean keySensitive;\n@@ -846,1 +872,2 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n+                int keyLength, CK_ATTRIBUTE[] attributes,\n+                boolean keySensitive) {\n@@ -848,0 +875,1 @@\n+            this.keySensitive = keySensitive;\n@@ -851,1 +879,1 @@\n-            if (x != null) {\n+            if (x != null || params != null) {\n@@ -854,5 +882,13 @@\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_VALUE),\n-                new CK_ATTRIBUTE(CKA_PRIME),\n-                new CK_ATTRIBUTE(CKA_BASE),\n-            };\n+            CK_ATTRIBUTE[] attributes = null;\n+            if (!keySensitive) {\n+                attributes = new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_VALUE),\n+                    new CK_ATTRIBUTE(CKA_PRIME),\n+                    new CK_ATTRIBUTE(CKA_BASE),\n+                };\n+            } else {\n+                attributes = new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_PRIME),\n+                    new CK_ATTRIBUTE(CKA_BASE),\n+                };\n+            }\n@@ -860,5 +896,10 @@\n-            x = attributes[0].getBigInteger();\n-            params = new DHParameterSpec(\n-                attributes[1].getBigInteger(),\n-                attributes[2].getBigInteger()\n-            );\n+            {\n+                int i = 0;\n+                if (!keySensitive) {\n+                    x = attributes[i++].getBigInteger();\n+                }\n+                params = new DHParameterSpec(\n+                    attributes[i++].getBigInteger(),\n+                    attributes[i++].getBigInteger()\n+                );\n+            }\n@@ -872,1 +913,1 @@\n-            if (encoded == null) {\n+            if (encoded == null && !keySensitive) {\n@@ -913,0 +954,6 @@\n+            BigInteger otherX = other.getX();\n+            if (this.x == null && otherX != null ||\n+                    this.x != null && otherX == null ||\n+                    this.x != null && this.x.compareTo(otherX) != 0) {\n+                return false;\n+            }\n@@ -914,2 +961,1 @@\n-            return ((this.x.compareTo(other.getX()) == 0) &&\n-                    (this.params.getP().compareTo(otherParams.getP()) == 0) &&\n+            return ((this.params.getP().compareTo(otherParams.getP()) == 0) &&\n@@ -1011,0 +1057,1 @@\n+        boolean keySensitive;\n@@ -1015,1 +1062,2 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n+                int keyLength, CK_ATTRIBUTE[] attributes,\n+                boolean keySensitive) {\n@@ -1017,0 +1065,1 @@\n+            this.keySensitive = keySensitive;\n@@ -1020,1 +1069,1 @@\n-            if (s != null) {\n+            if (s != null || params != null) {\n@@ -1023,4 +1072,11 @@\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_VALUE),\n-                new CK_ATTRIBUTE(CKA_EC_PARAMS, params),\n-            };\n+            CK_ATTRIBUTE[] attributes = null;\n+            if (!keySensitive) {\n+                attributes = new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_VALUE),\n+                    new CK_ATTRIBUTE(CKA_EC_PARAMS, params),\n+                };\n+            } else {\n+                attributes = new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_EC_PARAMS, params),\n+                };\n+            }\n@@ -1028,6 +1084,11 @@\n-            s = attributes[0].getBigInteger();\n-            try {\n-                params = P11ECKeyFactory.decodeParameters\n-                            (attributes[1].getByteArray());\n-            } catch (Exception e) {\n-                throw new RuntimeException(\"Could not parse key values\", e);\n+            {\n+                int i = 0;\n+                if (!keySensitive) {\n+                    s = attributes[i++].getBigInteger();\n+                }\n+                try {\n+                    params = P11ECKeyFactory.decodeParameters\n+                                (attributes[i++].getByteArray());\n+                } catch (Exception e) {\n+                    throw new RuntimeException(\"Could not parse key values\", e);\n+                }\n@@ -1042,1 +1103,1 @@\n-            if (encoded == null) {\n+            if (encoded == null && !keySensitive) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":123,"deletions":62,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -122,0 +122,3 @@\n+    \/\/ signature length expected or 0 for unknown\n+    private int signatureLength;\n+\n@@ -288,1 +291,1 @@\n-                    token.p11.C_SignFinal(session.id(), 0);\n+                    token.p11.C_SignFinal(session.id(), signatureLength);\n@@ -299,6 +302,1 @@\n-                byte[] signature;\n-                if (mechanism == CKM_DSA) {\n-                    signature = new byte[64]; \/\/ assume N = 256\n-                } else {\n-                    signature = new byte[(p11Key.length() + 7) >> 3];\n-                }\n+                byte[] signature = new byte[signatureLength];\n@@ -376,0 +374,6 @@\n+        if (\"DSA\".equals(p11Key.getAlgorithm())) {\n+            signatureLength =\n+                    ((DSAKey)p11Key).getParams().getQ().bitLength() >> 2;\n+        } else {\n+            signatureLength = 0;\n+        }\n@@ -621,1 +625,2 @@\n-                signature = token.p11.C_SignFinal(session.id(), 0);\n+                signature = token.p11.C_SignFinal(session.id(),\n+                        signatureLength);\n@@ -812,1 +817,1 @@\n-    private static byte[] asn1ToDSA(byte[] sig) throws SignatureException {\n+    private byte[] asn1ToDSA(byte[] sig) throws SignatureException {\n@@ -827,2 +832,2 @@\n-            byte[] br = toByteArray(r, 20);\n-            byte[] bs = toByteArray(s, 20);\n+            byte[] br = toByteArray(r, signatureLength\/2);\n+            byte[] bs = toByteArray(s, signatureLength\/2);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Signature.java","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.security.AlgorithmParameterGenerator;\n+import java.security.AlgorithmParameters;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.PrivateKey;\n+import java.security.Provider;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.Signature;\n+import java.security.spec.DSAGenParameterSpec;\n+import java.security.spec.DSAParameterSpec;\n+\n+\/*\n+ * @test\n+ * @bug 8271566\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ * @run main\/othervm\/timeout=30 LargeDSAKey\n+ *\/\n+\n+public final class LargeDSAKey extends PKCS11Test {\n+\n+    private static final boolean enableDebug = false;\n+\n+    private static final String knownText =\n+            \"Known text known text known text\";\n+\n+    public void main(Provider p) throws Exception {\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"DSA\", p);\n+        AlgorithmParameterGenerator dsaParGen =\n+                AlgorithmParameterGenerator.getInstance(\"DSA\");\n+        DSAGenParameterSpec dsaParGenSpec =\n+                new DSAGenParameterSpec(2048, 256);\n+        dsaParGen.init(dsaParGenSpec, new SecureRandom());\n+        AlgorithmParameters params = dsaParGen.generateParameters();\n+        DSAParameterSpec dsaParams =\n+                params.getParameterSpec(DSAParameterSpec.class);\n+        kpg.initialize(dsaParams);\n+        KeyPair kp = kpg.generateKeyPair();\n+        doTestSignature(kp, p);\n+    }\n+\n+    private static void doTestSignature(KeyPair kp, Provider p)\n+            throws Exception {\n+        byte[] knownTextSig = null;\n+        Signature s = Signature.getInstance(\"SHA1withDSA\", p);\n+        PrivateKey privKey = kp.getPrivate();\n+        PublicKey pubKey = kp.getPublic();\n+        if (enableDebug) {\n+            System.out.println(\"Signature algorithm: \" + s.getAlgorithm());\n+            System.out.println(\"Signature Provider: \" + s.getProvider());\n+            System.out.println(\"Private key for signature: \" + privKey);\n+            System.out.println(\"Public key for signature: \" + pubKey);\n+        }\n+        s.initSign(privKey);\n+        s.update(knownText.getBytes());\n+        knownTextSig = s.sign();\n+        s.initVerify(pubKey);\n+        s.update(knownText.getBytes());\n+        if (s.verify(knownTextSig) == false) {\n+            throw new Exception(\"Could not verify signature\");\n+        }\n+        if (enableDebug) {\n+            System.out.println(\"Signature verified\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        main(new LargeDSAKey());\n+        System.out.println(\"TEST PASS - OK\");\n+    }\n+\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Signature\/LargeDSAKey.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"}]}