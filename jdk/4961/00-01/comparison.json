{"files":[{"patch":"@@ -377,1 +377,0 @@\n-        boolean keySensitive = false;\n@@ -383,4 +382,2 @@\n-        if (attributes[0].getBoolean() || attributes[1].getBoolean() ||\n-                (attributes[2].getBoolean() == false)) {\n-            keySensitive = true;\n-        }\n+        boolean keySensitive = (attributes[0].getBoolean() ||\n+                attributes[1].getBoolean() || !attributes[2].getBoolean());\n@@ -390,5 +387,15 @@\n-                    \/\/ All the attributes queried to decide if the RSA key is\n-                    \/\/ CRT or not are sensitive, except for CKA_PUBLIC_EXPONENT.\n-                    \/\/ RSA private keys are rather treated with an opaque type.\n-                    return new P11PrivateKey(session, keyID, algorithm,\n-                            keyLength, attributes);\n+                    \/\/ No need to determine CRT or non-CRT in\n+                    \/\/ advanced as the returned instance will be of\n+                    \/\/ P11RSAPrivateKeyInternal type in any case.\n+                    return new P11RSAPrivateKeyInternal(session, keyID,\n+                            algorithm, keyLength, attributes);\n+                }\n+                \/\/ We need to determine CRT or non-CRT in advanced to decide\n+                \/\/ which instance to return: P11RSAPrivateKey (CRT) or\n+                \/\/ P11RSAPrivateNonCRTKey (non-CRT).\n+                P11RSAAttributesFetcher attrFetcher =\n+                        new P11RSAAttributesFetcher(session.token, keyID,\n+                                false, true);\n+                if (attrFetcher.isCRTKey()) {\n+                    return new P11RSAPrivateKey(session, keyID, algorithm,\n+                            keyLength, attributes, attrFetcher);\n@@ -396,31 +403,2 @@\n-                    \/\/ In order to decide if this is RSA CRT key, we first query\n-                    \/\/ and see if all extra CRT attributes are available.\n-                    CK_ATTRIBUTE[] attrs2 = new CK_ATTRIBUTE[] {\n-                        new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT),\n-                        new CK_ATTRIBUTE(CKA_PRIME_1),\n-                        new CK_ATTRIBUTE(CKA_PRIME_2),\n-                        new CK_ATTRIBUTE(CKA_EXPONENT_1),\n-                        new CK_ATTRIBUTE(CKA_EXPONENT_2),\n-                        new CK_ATTRIBUTE(CKA_COEFFICIENT),\n-                    };\n-                    boolean crtKey;\n-                    try {\n-                        session.token.p11.C_GetAttributeValue\n-                            (session.id(), keyID, attrs2);\n-                        crtKey = ((attrs2[0].pValue instanceof byte[]) &&\n-                                  (attrs2[1].pValue instanceof byte[]) &&\n-                                  (attrs2[2].pValue instanceof byte[]) &&\n-                                  (attrs2[3].pValue instanceof byte[]) &&\n-                                  (attrs2[4].pValue instanceof byte[]) &&\n-                                  (attrs2[5].pValue instanceof byte[])) ;\n-                    } catch (PKCS11Exception e) {\n-                        \/\/ ignore, assume not available\n-                        crtKey = false;\n-                    }\n-                    if (crtKey) {\n-                        return new P11RSAPrivateKey(session, keyID, algorithm,\n-                                keyLength, attributes, attrs2);\n-                    } else {\n-                        return new P11RSAPrivateNonCRTKey(session, keyID,\n-                                algorithm, keyLength, attributes);\n-                    }\n+                    return new P11RSAPrivateNonCRTKey(session, keyID,\n+                            algorithm, keyLength, attributes, attrFetcher);\n@@ -429,1 +407,1 @@\n-                return new P11DSAPrivateKey(session, keyID, algorithm,\n+                return P11DSAPrivateKey.newInstance(session, keyID, algorithm,\n@@ -432,1 +410,1 @@\n-                return new P11DHPrivateKey(session, keyID, algorithm,\n+                return P11DHPrivateKey.newInstance(session, keyID, algorithm,\n@@ -435,1 +413,1 @@\n-                return new P11ECPrivateKey(session, keyID, algorithm,\n+                return P11ECPrivateKey.newInstance(session, keyID, algorithm,\n@@ -443,2 +421,1 @@\n-    \/\/ class for sensitive and unextractable private keys\n-    private static final class P11PrivateKey extends P11Key\n+    private static class P11PrivateKey extends P11Key\n@@ -448,0 +425,1 @@\n+        protected byte[] encoded;\n@@ -533,4 +511,3 @@\n-    \/\/ RSA CRT private key\n-    private static final class P11RSAPrivateKey extends P11Key\n-                implements RSAPrivateCrtKey {\n-        private static final long serialVersionUID = 9215872438913515220L;\n+    private static final class P11RSAAttributesFetcher\n+            implements Serializable {\n+        private static final long serialVersionUID = 1L;\n@@ -538,0 +515,5 @@\n+        private P11Key p11Key;\n+        private Token token;\n+        private boolean keySensitive;\n+        private boolean isPrivateKey;\n+        private boolean isCRTKey;\n@@ -539,20 +521,25 @@\n-        private byte[] encoded;\n-        P11RSAPrivateKey(Session session, long keyID, String algorithm,\n-                int keyLength, CK_ATTRIBUTE[] attrs, CK_ATTRIBUTE[] crtAttrs) {\n-            super(PRIVATE, session, keyID, algorithm, keyLength, attrs);\n-\n-            for (CK_ATTRIBUTE a : crtAttrs) {\n-                if (a.type == CKA_PUBLIC_EXPONENT) {\n-                    e = a.getBigInteger();\n-                } else if (a.type == CKA_PRIME_1) {\n-                    p = a.getBigInteger();\n-                } else if (a.type == CKA_PRIME_2) {\n-                    q = a.getBigInteger();\n-                } else if (a.type == CKA_EXPONENT_1) {\n-                    pe = a.getBigInteger();\n-                } else if (a.type == CKA_EXPONENT_2) {\n-                    qe = a.getBigInteger();\n-                } else if (a.type == CKA_COEFFICIENT) {\n-                    coeff = a.getBigInteger();\n-                }\n-            }\n+        private P11RSAAttributesFetcher(Token token,\n+                boolean keySensitive, boolean isPrivateKey) {\n+            this.token = token;\n+            this.keySensitive = keySensitive;\n+            this.isPrivateKey = isPrivateKey;\n+        }\n+        \/\/ Constructor for sensitive RSA Private keys and RSA Public keys.\n+        \/\/ Attribute values are lazily fetched.\n+        P11RSAAttributesFetcher(P11Key p11Key, boolean keySensitive,\n+                boolean isPrivateKey) {\n+            this(p11Key.token, keySensitive, isPrivateKey);\n+            this.p11Key = p11Key;\n+        }\n+        \/\/ Constructor for non-sensitive RSA Private keys. The P11Key is not\n+        \/\/ built yet but attributes values are needed in advanced to determine\n+        \/\/ if the key type is CRT or non-CRT.\n+        \/\/\n+        \/\/ NOTE: it is assumed that the received keyID is alive. See\n+        \/\/ P11Key::getKeyID and P11Key::releaseKeyID to learn more about the\n+        \/\/ keys use pattern.\n+        P11RSAAttributesFetcher(Token token, long keyID,\n+                boolean keySensitive, boolean isPrivateKey) {\n+            this(token, keySensitive, isPrivateKey);\n+            token.ensureValid();\n+            doFetchValues(keyID);\n@@ -562,1 +549,3 @@\n-            if (n != null) {\n+            if (n != null || e != null || d != null || p != null ||\n+                    q != null || pe != null || qe != null ||\n+                    coeff != null) {\n@@ -565,7 +554,117 @@\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_MODULUS),\n-                new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT),\n-            };\n-            fetchAttributes(attributes);\n-            n = attributes[0].getBigInteger();\n-            d = attributes[1].getBigInteger();\n+            \/\/ p11Key can only be null in the non-sensitive RSA Private\n+            \/\/ key case. However, values are initialized from the\n+            \/\/ constructor in such case, so this execution point should\n+            \/\/ not be reachable with a null p11Key.\n+            assert(p11Key != null);\n+            long keyID = p11Key.getKeyID();\n+            try {\n+                doFetchValues(keyID);\n+            } finally {\n+                p11Key.releaseKeyID();\n+            }\n+        }\n+        \/\/ No need to synchronize this method. For a given instance\n+        \/\/ (fully constructed), only called from fetchValues which is\n+        \/\/ already synchronized.\n+        private void doFetchValues(long keyID) {\n+            CK_ATTRIBUTE[] attributes = null;\n+            CK_ATTRIBUTE[] tryCRTAttributes = null;\n+            if (!isPrivateKey) {\n+                attributes = new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_MODULUS),\n+                    new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT),\n+                };\n+            } else {\n+                if (!keySensitive) {\n+                    tryCRTAttributes = new CK_ATTRIBUTE[] {\n+                        new CK_ATTRIBUTE(CKA_MODULUS),\n+                        new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT),\n+                        new CK_ATTRIBUTE(CKA_PRIME_1),\n+                        new CK_ATTRIBUTE(CKA_PRIME_2),\n+                        new CK_ATTRIBUTE(CKA_EXPONENT_1),\n+                        new CK_ATTRIBUTE(CKA_EXPONENT_2),\n+                        new CK_ATTRIBUTE(CKA_COEFFICIENT),\n+                        new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT),\n+                    };\n+                } else {\n+                    tryCRTAttributes = new CK_ATTRIBUTE[] {\n+                            new CK_ATTRIBUTE(CKA_MODULUS),\n+                            new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT),\n+                    };\n+                }\n+                Session tempSession = null;\n+                try {\n+                    tempSession = token.getOpSession();\n+                    token.p11.C_GetAttributeValue(tempSession.id(), keyID,\n+                            tryCRTAttributes);\n+                    isCRTKey = true;\n+                    for (CK_ATTRIBUTE attr : tryCRTAttributes) {\n+                        isCRTKey &= attr.pValue instanceof byte[];\n+                        if (!isCRTKey)\n+                            break;\n+                    }\n+                } catch (PKCS11Exception e) {\n+                    \/\/ Non-CRT\n+                } finally {\n+                    token.releaseSession(tempSession);\n+                }\n+                if (!isCRTKey) {\n+                    if (!keySensitive) {\n+                        attributes = new CK_ATTRIBUTE[] {\n+                            new CK_ATTRIBUTE(CKA_MODULUS),\n+                            new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT),\n+                        };\n+                    } else {\n+                        attributes = new CK_ATTRIBUTE[] {\n+                            new CK_ATTRIBUTE(CKA_MODULUS),\n+                        };\n+                    }\n+                }\n+            }\n+            if (!isPrivateKey || !isCRTKey) {\n+                Session tempSession = null;\n+                try {\n+                    tempSession = token.getOpSession();\n+                    token.p11.C_GetAttributeValue(tempSession.id(), keyID,\n+                            attributes);\n+                } catch (PKCS11Exception e) {\n+                    throw new ProviderException(e);\n+                } finally {\n+                    token.releaseSession(tempSession);\n+                }\n+            }\n+            if (!isPrivateKey) {\n+                n = attributes[0].getBigInteger();\n+                e = attributes[1].getBigInteger();\n+            } else {\n+                if (!isCRTKey) {\n+                    if (!keySensitive) {\n+                        n = attributes[0].getBigInteger();\n+                        d = attributes[1].getBigInteger();\n+                    } else {\n+                        n = attributes[0].getBigInteger();\n+                    }\n+                } else {\n+                    if (!keySensitive) {\n+                        n = tryCRTAttributes[0].getBigInteger();\n+                        e = tryCRTAttributes[1].getBigInteger();\n+                        p = tryCRTAttributes[2].getBigInteger();\n+                        q = tryCRTAttributes[3].getBigInteger();\n+                        pe = tryCRTAttributes[4].getBigInteger();\n+                        qe = tryCRTAttributes[5].getBigInteger();\n+                        coeff = tryCRTAttributes[6].getBigInteger();\n+                        d = tryCRTAttributes[7].getBigInteger();\n+                    } else {\n+                        n = tryCRTAttributes[0].getBigInteger();\n+                        e = tryCRTAttributes[1].getBigInteger();\n+                    }\n+                }\n+            }\n+        }\n+        boolean isCRTKey() {\n+            fetchValues();\n+            return isCRTKey;\n+        }\n+        BigInteger getModulus() {\n+            fetchValues();\n+            return n;\n@@ -573,0 +672,29 @@\n+        BigInteger getPublicExponent() {\n+            fetchValues();\n+            return e;\n+        }\n+        BigInteger getPrivateExponent() {\n+            fetchValues();\n+            return d;\n+        }\n+        BigInteger getPrimeP() {\n+            fetchValues();\n+            return p;\n+        }\n+        BigInteger getPrimeQ() {\n+            fetchValues();\n+            return q;\n+        }\n+        BigInteger getPrimeExponentP() {\n+            fetchValues();\n+            return pe;\n+        }\n+        BigInteger getPrimeExponentQ() {\n+            fetchValues();\n+            return qe;\n+        }\n+        BigInteger getCrtCoefficient() {\n+            fetchValues();\n+            return coeff;\n+        }\n+    }\n@@ -574,0 +702,38 @@\n+    static class P11RSAPrivateKeyInternal extends P11PrivateKey {\n+        private static final long serialVersionUID = 1L;\n+\n+        protected P11RSAAttributesFetcher attrFetcher;\n+        \/\/ Constructor for non-sensitive RSA Private keys, where CRT or non-CRT\n+        \/\/ was determined in advanced with the help of a\n+        \/\/ P11RSAAttributesFetcher instance. This instance is re-used to\n+        \/\/ minimize the number of PKCS#11 queries.\n+        protected P11RSAPrivateKeyInternal(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attributes,\n+                P11RSAAttributesFetcher attrFetcher) {\n+            super(session, keyID, algorithm, keyLength, attributes);\n+            this.attrFetcher = attrFetcher;\n+        }\n+        \/\/ Constructor for sensitive RSA Private keys, where determining\n+        \/\/ CRT or non-CRT in advanced is not required.\n+        P11RSAPrivateKeyInternal(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attributes) {\n+            super(session, keyID, algorithm, keyLength, attributes);\n+            attrFetcher = new P11RSAAttributesFetcher(this, true, true);\n+        }\n+        BigInteger getModulus() {\n+            return attrFetcher.getModulus();\n+        }\n+    }\n+\n+    \/\/ RSA CRT private key\n+    private static final class P11RSAPrivateKey extends\n+            P11RSAPrivateKeyInternal implements RSAPrivateCrtKey {\n+        private static final long serialVersionUID = 9215872438913515221L;\n+\n+        P11RSAPrivateKey(Session session, long keyID, String algorithm,\n+                int keyLength, CK_ATTRIBUTE[] attributes,\n+                P11RSAAttributesFetcher attrFetcher) {\n+            super(session, keyID, algorithm, keyLength, attributes,\n+                    attrFetcher);\n+        }\n+        @Override\n@@ -578,0 +744,1 @@\n+        @Override\n@@ -581,1 +748,0 @@\n-                fetchValues();\n@@ -583,2 +749,5 @@\n-                    Key newKey = RSAPrivateCrtKeyImpl.newKey\n-                        (KeyType.RSA, null, n, e, d, p, q, pe, qe, coeff);\n+                    Key newKey = RSAPrivateCrtKeyImpl.newKey(KeyType.RSA, null,\n+                            getModulus(), getPublicExponent(),\n+                            getPrivateExponent(), getPrimeP(), getPrimeQ(),\n+                            getPrimeExponentP(), getPrimeExponentQ(),\n+                            getCrtCoefficient());\n@@ -592,0 +761,1 @@\n+        @Override\n@@ -593,2 +763,1 @@\n-            fetchValues();\n-            return n;\n+            return super.getModulus();\n@@ -597,1 +766,1 @@\n-            return e;\n+            return attrFetcher.getPublicExponent();\n@@ -600,2 +769,1 @@\n-            fetchValues();\n-            return d;\n+            return attrFetcher.getPrivateExponent();\n@@ -604,1 +772,1 @@\n-            return p;\n+            return attrFetcher.getPrimeP();\n@@ -607,1 +775,1 @@\n-            return q;\n+            return attrFetcher.getPrimeQ();\n@@ -610,1 +778,1 @@\n-            return pe;\n+            return attrFetcher.getPrimeExponentP();\n@@ -613,1 +781,1 @@\n-            return qe;\n+            return attrFetcher.getPrimeExponentQ();\n@@ -616,1 +784,1 @@\n-            return coeff;\n+            return attrFetcher.getCrtCoefficient();\n@@ -621,3 +789,3 @@\n-    private static final class P11RSAPrivateNonCRTKey extends P11Key\n-                implements RSAPrivateKey {\n-        private static final long serialVersionUID = 1137764983777411481L;\n+    private static final class P11RSAPrivateNonCRTKey\n+            extends P11RSAPrivateKeyInternal implements RSAPrivateKey {\n+        private static final long serialVersionUID = 1137764983777411482L;\n@@ -625,2 +793,0 @@\n-        private BigInteger n, d;\n-        private byte[] encoded;\n@@ -628,15 +794,4 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n-            super(PRIVATE, session, keyID, algorithm, keyLength, attributes);\n-        }\n-        private synchronized void fetchValues() {\n-            token.ensureValid();\n-            if (n != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_MODULUS),\n-                new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT),\n-            };\n-            fetchAttributes(attributes);\n-            n = attributes[0].getBigInteger();\n-            d = attributes[1].getBigInteger();\n+                int keyLength, CK_ATTRIBUTE[] attributes,\n+                P11RSAAttributesFetcher attrFetcher) {\n+            super(session, keyID, algorithm, keyLength, attributes,\n+                    attrFetcher);\n@@ -644,0 +799,1 @@\n+        @Override\n@@ -648,0 +804,1 @@\n+        @Override\n@@ -651,1 +808,0 @@\n-                fetchValues();\n@@ -665,0 +821,1 @@\n+        @Override\n@@ -666,2 +823,1 @@\n-            fetchValues();\n-            return n;\n+            return super.getModulus();\n@@ -670,2 +826,1 @@\n-            fetchValues();\n-            return d;\n+            return attrFetcher.getPrivateExponent();\n@@ -677,2 +832,3 @@\n-        private static final long serialVersionUID = -826726289023854455L;\n-        private BigInteger n, e;\n+        private static final long serialVersionUID = -826726289023854456L;\n+\n+        private P11RSAAttributesFetcher attrFetcher;\n@@ -683,13 +839,1 @@\n-        }\n-        private synchronized void fetchValues() {\n-            token.ensureValid();\n-            if (n != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_MODULUS),\n-                new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT),\n-            };\n-            fetchAttributes(attributes);\n-            n = attributes[0].getBigInteger();\n-            e = attributes[1].getBigInteger();\n+            attrFetcher = new P11RSAAttributesFetcher(this, false, false);\n@@ -704,1 +848,0 @@\n-                fetchValues();\n@@ -707,1 +850,2 @@\n-                        (KeyType.RSA, null, n, e).getEncoded();\n+                        (KeyType.RSA, null, getModulus(),\n+                                getPublicExponent()).getEncoded();\n@@ -715,2 +859,1 @@\n-            fetchValues();\n-            return n;\n+            return attrFetcher.getModulus();\n@@ -719,2 +862,1 @@\n-            fetchValues();\n-            return e;\n+            return attrFetcher.getPublicExponent();\n@@ -723,0 +865,55 @@\n+            return super.toString() +  \"\\n  modulus: \" + getModulus()\n+                + \"\\n  public exponent: \" + getPublicExponent();\n+        }\n+    }\n+\n+    private static final class P11DSAAttributesFetcher\n+            implements Serializable {\n+        private static final long serialVersionUID = 1L;\n+\n+        private P11Key p11Key;\n+        private boolean keySensitive;\n+        private BigInteger value;\n+        private DSAParams params;\n+        P11DSAAttributesFetcher(P11Key p11Key, boolean keySensitive) {\n+            this.p11Key = p11Key;\n+            this.keySensitive = keySensitive;\n+        }\n+        private synchronized void fetchValues() {\n+            p11Key.token.ensureValid();\n+            if (value != null || params != null) {\n+                return;\n+            }\n+            CK_ATTRIBUTE[] attributes = null;\n+            if (!keySensitive) {\n+                attributes = new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_VALUE),\n+                    new CK_ATTRIBUTE(CKA_PRIME),\n+                    new CK_ATTRIBUTE(CKA_SUBPRIME),\n+                    new CK_ATTRIBUTE(CKA_BASE),\n+                };\n+            } else {\n+                attributes = new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_PRIME),\n+                    new CK_ATTRIBUTE(CKA_SUBPRIME),\n+                    new CK_ATTRIBUTE(CKA_BASE),\n+                };\n+            }\n+            p11Key.fetchAttributes(attributes);\n+            {\n+                int i = 0;\n+                if (!keySensitive) {\n+                    value = attributes[i++].getBigInteger();\n+                }\n+                params = new DSAParameterSpec(\n+                    attributes[i++].getBigInteger(),\n+                    attributes[i++].getBigInteger(),\n+                    attributes[i++].getBigInteger()\n+                );\n+            }\n+        }\n+        BigInteger getValue() {\n+            fetchValues();\n+            return value;\n+        }\n+        DSAParams getParams() {\n@@ -724,2 +921,1 @@\n-            return super.toString() +  \"\\n  modulus: \" + n\n-                + \"\\n  public exponent: \" + e;\n+            return params;\n@@ -731,1 +927,1 @@\n-        private static final long serialVersionUID = 5989753793316396637L;\n+        private static final long serialVersionUID = 5989753793316396638L;\n@@ -733,2 +929,1 @@\n-        private BigInteger y;\n-        private DSAParams params;\n+        private P11DSAAttributesFetcher attrFetcher;\n@@ -739,19 +934,1 @@\n-        }\n-        private synchronized void fetchValues() {\n-            token.ensureValid();\n-            if (y != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_VALUE),\n-                new CK_ATTRIBUTE(CKA_PRIME),\n-                new CK_ATTRIBUTE(CKA_SUBPRIME),\n-                new CK_ATTRIBUTE(CKA_BASE),\n-            };\n-            fetchAttributes(attributes);\n-            y = attributes[0].getBigInteger();\n-            params = new DSAParameterSpec(\n-                attributes[1].getBigInteger(),\n-                attributes[2].getBigInteger(),\n-                attributes[3].getBigInteger()\n-            );\n+            attrFetcher = new P11DSAAttributesFetcher(this, false);\n@@ -766,1 +943,1 @@\n-                fetchValues();\n+                DSAParams params = getParams();\n@@ -768,2 +945,3 @@\n-                    Key key = new sun.security.provider.DSAPublicKey\n-                            (y, params.getP(), params.getQ(), params.getG());\n+                    Key key = new sun.security.provider.DSAPublicKey(\n+                            getY(), params.getP(), params.getQ(),\n+                            params.getG());\n@@ -778,2 +956,1 @@\n-            fetchValues();\n-            return y;\n+            return attrFetcher.getValue();\n@@ -782,2 +959,1 @@\n-            fetchValues();\n-            return params;\n+            return attrFetcher.getParams();\n@@ -786,3 +962,4 @@\n-            fetchValues();\n-            return super.toString() +  \"\\n  y: \" + y + \"\\n  p: \" + params.getP()\n-                + \"\\n  q: \" + params.getQ() + \"\\n  g: \" + params.getG();\n+            DSAParams params = getParams();\n+            return super.toString() +  \"\\n  y: \" + getY() + \"\\n  p: \" +\n+                    params.getP() + \"\\n  q: \" + params.getQ() + \"\\n  g: \" +\n+                    params.getG();\n@@ -792,3 +969,2 @@\n-    private static final class P11DSAPrivateKey extends P11Key\n-                                                implements DSAPrivateKey {\n-        private static final long serialVersionUID = 3119629997181999389L;\n+    static class P11DSAPrivateKeyInternal extends P11PrivateKey {\n+        private static final long serialVersionUID = 1L;\n@@ -796,6 +972,3 @@\n-        boolean keySensitive;\n-        private BigInteger x;\n-        private DSAParams params;\n-        private byte[] encoded;\n-        P11DSAPrivateKey(Session session, long keyID, String algorithm,\n-                int keyLength, CK_ATTRIBUTE[] attributes,\n+        protected P11DSAAttributesFetcher attrFetcher;\n+        protected P11DSAPrivateKeyInternal(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attributes,\n@@ -803,2 +976,2 @@\n-            super(PRIVATE, session, keyID, algorithm, keyLength, attributes);\n-            this.keySensitive = keySensitive;\n+            super(session, keyID, algorithm, keyLength, attributes);\n+            attrFetcher = new P11DSAAttributesFetcher(this, keySensitive);\n@@ -806,13 +979,14 @@\n-        private synchronized void fetchValues() {\n-            token.ensureValid();\n-            if (x != null || params != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = null;\n-            if (!keySensitive) {\n-                attributes = new CK_ATTRIBUTE[] {\n-                    new CK_ATTRIBUTE(CKA_VALUE),\n-                    new CK_ATTRIBUTE(CKA_PRIME),\n-                    new CK_ATTRIBUTE(CKA_SUBPRIME),\n-                    new CK_ATTRIBUTE(CKA_BASE),\n-                };\n+        DSAParams getParams() {\n+            return attrFetcher.getParams();\n+        }\n+    }\n+\n+    static final class P11DSAPrivateKey extends P11DSAPrivateKeyInternal\n+            implements DSAPrivateKey {\n+        private static final long serialVersionUID = 3119629997181999390L;\n+        static P11DSAPrivateKeyInternal newInstance(Session session,\n+                long keyID, String algorithm, int keyLength, CK_ATTRIBUTE[]\n+                        attributes, boolean keySensitive) {\n+            if (keySensitive) {\n+                return new P11DSAPrivateKeyInternal(session, keyID, algorithm,\n+                        keyLength, attributes, keySensitive);\n@@ -820,17 +994,2 @@\n-                attributes = new CK_ATTRIBUTE[] {\n-                    new CK_ATTRIBUTE(CKA_PRIME),\n-                    new CK_ATTRIBUTE(CKA_SUBPRIME),\n-                    new CK_ATTRIBUTE(CKA_BASE),\n-                };\n-            }\n-            fetchAttributes(attributes);\n-            {\n-                int i = 0;\n-                if (!keySensitive) {\n-                    x = attributes[i++].getBigInteger();\n-                }\n-                params = new DSAParameterSpec(\n-                    attributes[i++].getBigInteger(),\n-                    attributes[i++].getBigInteger(),\n-                    attributes[i++].getBigInteger()\n-                );\n+                return new P11DSAPrivateKey(session, keyID, algorithm,\n+                        keyLength, attributes, keySensitive);\n@@ -839,0 +998,8 @@\n+\n+        private P11DSAPrivateKey(Session session, long keyID, String algorithm,\n+                int keyLength, CK_ATTRIBUTE[] attributes,\n+                boolean keySensitive) {\n+            super(session, keyID, algorithm, keyLength, attributes,\n+                    keySensitive);\n+        }\n+        @Override\n@@ -843,0 +1010,1 @@\n+        @Override\n@@ -845,2 +1013,2 @@\n-            if (encoded == null && !keySensitive) {\n-                fetchValues();\n+            if (encoded == null && getX() != null) {\n+                DSAParams params = getParams();\n@@ -848,1 +1016,1 @@\n-                        (x, params.getP(), params.getQ(), params.getG());\n+                        (getX(), params.getP(), params.getQ(), params.getG());\n@@ -854,2 +1022,1 @@\n-            fetchValues();\n-            return x;\n+            return attrFetcher.getValue();\n@@ -857,0 +1024,1 @@\n+        @Override\n@@ -858,2 +1026,1 @@\n-            fetchValues();\n-            return params;\n+            return super.getParams();\n@@ -863,3 +1030,3 @@\n-    private static final class P11DHPrivateKey extends P11Key\n-                                                implements DHPrivateKey {\n-        private static final long serialVersionUID = -1698576167364928838L;\n+    private static final class P11DHAttributesFetcher\n+            implements Serializable {\n+        private static final long serialVersionUID = 1L;\n@@ -867,2 +1034,3 @@\n-        boolean keySensitive;\n-        private BigInteger x;\n+        private P11Key p11Key;\n+        private boolean keySensitive;\n+        private BigInteger value;\n@@ -870,5 +1038,2 @@\n-        private byte[] encoded;\n-        P11DHPrivateKey(Session session, long keyID, String algorithm,\n-                int keyLength, CK_ATTRIBUTE[] attributes,\n-                boolean keySensitive) {\n-            super(PRIVATE, session, keyID, algorithm, keyLength, attributes);\n+        P11DHAttributesFetcher(P11Key p11Key, boolean keySensitive) {\n+            this.p11Key = p11Key;\n@@ -878,2 +1043,2 @@\n-            token.ensureValid();\n-            if (x != null || params != null) {\n+            p11Key.token.ensureValid();\n+            if (value != null || params != null) {\n@@ -895,1 +1060,1 @@\n-            fetchAttributes(attributes);\n+            p11Key.fetchAttributes(attributes);\n@@ -899,1 +1064,1 @@\n-                    x = attributes[i++].getBigInteger();\n+                    value = attributes[i++].getBigInteger();\n@@ -907,0 +1072,47 @@\n+        BigInteger getValue() {\n+            fetchValues();\n+            return value;\n+        }\n+        DHParameterSpec getParams() {\n+            fetchValues();\n+            return params;\n+        }\n+    }\n+\n+    static class P11DHPrivateKeyInternal extends P11PrivateKey {\n+        private static final long serialVersionUID = 1L;\n+\n+        protected P11DHAttributesFetcher attrFetcher;\n+        protected P11DHPrivateKeyInternal(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attributes,\n+                boolean keySensitive) {\n+            super(session, keyID, algorithm, keyLength, attributes);\n+            attrFetcher = new P11DHAttributesFetcher(this, keySensitive);\n+        }\n+        DHParameterSpec getParams() {\n+            return attrFetcher.getParams();\n+        }\n+    }\n+\n+    static final class P11DHPrivateKey extends P11DHPrivateKeyInternal\n+            implements DHPrivateKey {\n+        private static final long serialVersionUID = -1698576167364928839L;\n+        static P11DHPrivateKeyInternal newInstance(Session session,\n+                long keyID, String algorithm, int keyLength, CK_ATTRIBUTE[]\n+                        attributes, boolean keySensitive) {\n+            if (keySensitive) {\n+                return new P11DHPrivateKeyInternal(session, keyID, algorithm,\n+                        keyLength, attributes, keySensitive);\n+            } else {\n+                return new P11DHPrivateKey(session, keyID, algorithm,\n+                        keyLength, attributes, keySensitive);\n+            }\n+        }\n+\n+        private P11DHPrivateKey(Session session, long keyID, String algorithm,\n+                int keyLength, CK_ATTRIBUTE[] attributes,\n+                boolean keySensitive) {\n+            super(session, keyID, algorithm, keyLength, attributes,\n+                    keySensitive);\n+        }\n+        @Override\n@@ -911,0 +1123,1 @@\n+        @Override\n@@ -913,2 +1126,2 @@\n-            if (encoded == null && !keySensitive) {\n-                fetchValues();\n+            if (encoded == null && getX() != null) {\n+                DHParameterSpec params = getParams();\n@@ -917,1 +1130,1 @@\n-                        (x, params.getP(), params.getG());\n+                        (getX(), params.getP(), params.getG());\n@@ -928,8 +1141,0 @@\n-        public BigInteger getX() {\n-            fetchValues();\n-            return x;\n-        }\n-        public DHParameterSpec getParams() {\n-            fetchValues();\n-            return params;\n-        }\n@@ -940,2 +1145,2 @@\n-            fetchValues();\n-            return Objects.hash(x, params.getP(), params.getG());\n+            DHParameterSpec params = getParams();\n+            return Objects.hash(getX(), params.getP(), params.getG());\n@@ -952,1 +1157,0 @@\n-            fetchValues();\n@@ -954,0 +1158,1 @@\n+            BigInteger x = getX();\n@@ -955,3 +1160,3 @@\n-            if (this.x == null && otherX != null ||\n-                    this.x != null && otherX == null ||\n-                    this.x != null && this.x.compareTo(otherX) != 0) {\n+            if (x == null && otherX != null ||\n+                    x != null && otherX == null ||\n+                    x != null && x.compareTo(otherX) != 0) {\n@@ -960,0 +1165,1 @@\n+            DHParameterSpec params = getParams();\n@@ -961,2 +1167,9 @@\n-            return ((this.params.getP().compareTo(otherParams.getP()) == 0) &&\n-                    (this.params.getG().compareTo(otherParams.getG()) == 0));\n+            return ((params.getP().compareTo(otherParams.getP()) == 0) &&\n+                    (params.getG().compareTo(otherParams.getG()) == 0));\n+        }\n+        public BigInteger getX() {\n+            return attrFetcher.getValue();\n+        }\n+        @Override\n+        public DHParameterSpec getParams() {\n+            return super.getParams();\n@@ -968,1 +1181,1 @@\n-        static final long serialVersionUID = -598383872153843657L;\n+        static final long serialVersionUID = -598383872153843658L;\n@@ -970,2 +1183,1 @@\n-        private BigInteger y;\n-        private DHParameterSpec params;\n+        private P11DHAttributesFetcher attrFetcher;\n@@ -976,17 +1188,1 @@\n-        }\n-        private synchronized void fetchValues() {\n-            token.ensureValid();\n-            if (y != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_VALUE),\n-                new CK_ATTRIBUTE(CKA_PRIME),\n-                new CK_ATTRIBUTE(CKA_BASE),\n-            };\n-            fetchAttributes(attributes);\n-            y = attributes[0].getBigInteger();\n-            params = new DHParameterSpec(\n-                attributes[1].getBigInteger(),\n-                attributes[2].getBigInteger()\n-            );\n+            attrFetcher = new P11DHAttributesFetcher(this, false);\n@@ -1001,1 +1197,1 @@\n-                fetchValues();\n+                DHParameterSpec params = getParams();\n@@ -1004,1 +1200,1 @@\n-                        (y, params.getP(), params.getG());\n+                        (getY(), params.getP(), params.getG());\n@@ -1016,2 +1212,1 @@\n-            fetchValues();\n-            return y;\n+            return attrFetcher.getValue();\n@@ -1020,2 +1215,1 @@\n-            fetchValues();\n-            return params;\n+            return attrFetcher.getParams();\n@@ -1024,3 +1218,3 @@\n-            fetchValues();\n-            return super.toString() +  \"\\n  y: \" + y + \"\\n  p: \" + params.getP()\n-                + \"\\n  g: \" + params.getG();\n+            DHParameterSpec params = getParams();\n+            return super.toString() +  \"\\n  y: \" + getY() + \"\\n  p: \" +\n+                    params.getP() + \"\\n  g: \" + params.getG();\n@@ -1032,2 +1226,2 @@\n-            fetchValues();\n-            return Objects.hash(y, params.getP(), params.getG());\n+            DHParameterSpec params = getParams();\n+            return Objects.hash(getY(), params.getP(), params.getG());\n@@ -1044,1 +1238,0 @@\n-            fetchValues();\n@@ -1046,0 +1239,1 @@\n+            DHParameterSpec params = getParams();\n@@ -1047,3 +1241,3 @@\n-            return ((this.y.compareTo(other.getY()) == 0) &&\n-                    (this.params.getP().compareTo(otherParams.getP()) == 0) &&\n-                    (this.params.getG().compareTo(otherParams.getG()) == 0));\n+            return ((getY().compareTo(other.getY()) == 0) &&\n+                    (params.getP().compareTo(otherParams.getP()) == 0) &&\n+                    (params.getG().compareTo(otherParams.getG()) == 0));\n@@ -1053,3 +1247,2 @@\n-    private static final class P11ECPrivateKey extends P11Key\n-                                                implements ECPrivateKey {\n-        private static final long serialVersionUID = -7786054399510515515L;\n+    private static final class P11ECAttributesFetcher implements Serializable {\n+        private static final long serialVersionUID = 1L;\n@@ -1057,2 +1250,4 @@\n-        boolean keySensitive;\n-        private BigInteger s;\n+        private P11Key p11Key;\n+        private boolean keySensitive;\n+        private boolean isPrivateKey;\n+        private BigInteger value;\n@@ -1060,5 +1255,4 @@\n-        private byte[] encoded;\n-        P11ECPrivateKey(Session session, long keyID, String algorithm,\n-                int keyLength, CK_ATTRIBUTE[] attributes,\n-                boolean keySensitive) {\n-            super(PRIVATE, session, keyID, algorithm, keyLength, attributes);\n+        private ECPoint w;\n+        P11ECAttributesFetcher(P11Key p11Key, boolean keySensitive,\n+                boolean isPrivateKey) {\n+            this.p11Key = p11Key;\n@@ -1066,0 +1260,1 @@\n+            this.isPrivateKey = isPrivateKey;\n@@ -1068,2 +1263,2 @@\n-            token.ensureValid();\n-            if (s != null || params != null) {\n+            p11Key.token.ensureValid();\n+            if (value != null || params != null || w != null) {\n@@ -1074,4 +1269,11 @@\n-                attributes = new CK_ATTRIBUTE[] {\n-                    new CK_ATTRIBUTE(CKA_VALUE),\n-                    new CK_ATTRIBUTE(CKA_EC_PARAMS, params),\n-                };\n+                if (isPrivateKey) {\n+                    attributes = new CK_ATTRIBUTE[] {\n+                        new CK_ATTRIBUTE(CKA_VALUE),\n+                        new CK_ATTRIBUTE(CKA_EC_PARAMS, params),\n+                    };\n+                } else {\n+                    attributes = new CK_ATTRIBUTE[] {\n+                        new CK_ATTRIBUTE(CKA_EC_PARAMS, params),\n+                        new CK_ATTRIBUTE(CKA_EC_POINT),\n+                    };\n+                }\n@@ -1083,1 +1285,1 @@\n-            fetchAttributes(attributes);\n+            p11Key.fetchAttributes(attributes);\n@@ -1086,2 +1288,2 @@\n-                if (!keySensitive) {\n-                    s = attributes[i++].getBigInteger();\n+                if (!keySensitive && isPrivateKey) {\n+                    value = attributes[i++].getBigInteger();\n@@ -1092,0 +1294,23 @@\n+\n+                    if (!keySensitive && !isPrivateKey) {\n+                        byte[] ecKey = attributes[i++].getByteArray();\n+\n+                        \/\/ Check whether the X9.63 encoding of an EC point is\n+                        \/\/ wrapped in an ASN.1 OCTET STRING\n+                        if (!p11Key.token.config.getUseEcX963Encoding()) {\n+                            DerValue wECPoint = new DerValue(ecKey);\n+\n+                            if (wECPoint.getTag() !=\n+                                    DerValue.tag_OctetString) {\n+                                throw new IOException(\"Could not DER decode\" +\n+                                        \" EC point. Unexpected tag: \" +\n+                                        wECPoint.getTag());\n+                            }\n+                            w = P11ECKeyFactory.decodePoint\n+                                (wECPoint.getDataBytes(), params.getCurve());\n+\n+                        } else {\n+                            w = P11ECKeyFactory.decodePoint(ecKey,\n+                                    params.getCurve());\n+                        }\n+                    }\n@@ -1097,0 +1322,51 @@\n+        BigInteger getValue() {\n+            fetchValues();\n+            return value;\n+        }\n+        ECParameterSpec getParams() {\n+            fetchValues();\n+            return params;\n+        }\n+        ECPoint getW() {\n+            fetchValues();\n+            return w;\n+        }\n+    }\n+\n+    static class P11ECPrivateKeyInternal extends P11PrivateKey {\n+        private static final long serialVersionUID = 1L;\n+\n+        protected P11ECAttributesFetcher attrFetcher;\n+        protected P11ECPrivateKeyInternal(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attributes,\n+                boolean keySensitive) {\n+            super(session, keyID, algorithm, keyLength, attributes);\n+            attrFetcher = new P11ECAttributesFetcher(this, keySensitive, true);\n+        }\n+        ECParameterSpec getParams() {\n+            return attrFetcher.getParams();\n+        }\n+    }\n+\n+    private static final class P11ECPrivateKey extends P11ECPrivateKeyInternal\n+            implements ECPrivateKey {\n+        private static final long serialVersionUID = -7786054399510515516L;\n+        static P11ECPrivateKeyInternal newInstance(Session session,\n+                long keyID, String algorithm, int keyLength, CK_ATTRIBUTE[]\n+                        attributes, boolean keySensitive) {\n+            if (keySensitive) {\n+                return new P11ECPrivateKeyInternal(session, keyID, algorithm,\n+                        keyLength, attributes, keySensitive);\n+            } else {\n+                return new P11ECPrivateKey(session, keyID, algorithm,\n+                        keyLength, attributes, keySensitive);\n+            }\n+        }\n+\n+        private P11ECPrivateKey(Session session, long keyID, String algorithm,\n+                int keyLength, CK_ATTRIBUTE[] attributes,\n+                boolean keySensitive) {\n+            super(session, keyID, algorithm, keyLength, attributes,\n+                    keySensitive);\n+        }\n+        @Override\n@@ -1101,0 +1377,1 @@\n+        @Override\n@@ -1103,2 +1380,1 @@\n-            if (encoded == null && !keySensitive) {\n-                fetchValues();\n+            if (encoded == null && getS() != null) {\n@@ -1106,1 +1382,1 @@\n-                    Key key = ECUtil.generateECPrivateKey(s, params);\n+                    Key key = ECUtil.generateECPrivateKey(getS(), getParams());\n@@ -1115,2 +1391,1 @@\n-            fetchValues();\n-            return s;\n+            return attrFetcher.getValue();\n@@ -1118,0 +1393,1 @@\n+        @Override\n@@ -1119,2 +1395,1 @@\n-            fetchValues();\n-            return params;\n+            return super.getParams();\n@@ -1126,1 +1401,1 @@\n-        private static final long serialVersionUID = -6371481375154806089L;\n+        private static final long serialVersionUID = -6371481375154806090L;\n@@ -1128,2 +1403,1 @@\n-        private ECPoint w;\n-        private ECParameterSpec params;\n+        private P11ECAttributesFetcher attrFetcher;\n@@ -1134,36 +1408,1 @@\n-        }\n-        private synchronized void fetchValues() {\n-            token.ensureValid();\n-            if (w != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_EC_POINT),\n-                new CK_ATTRIBUTE(CKA_EC_PARAMS),\n-            };\n-            fetchAttributes(attributes);\n-\n-            try {\n-                params = P11ECKeyFactory.decodeParameters\n-                            (attributes[1].getByteArray());\n-                byte[] ecKey = attributes[0].getByteArray();\n-\n-                \/\/ Check whether the X9.63 encoding of an EC point is wrapped\n-                \/\/ in an ASN.1 OCTET STRING\n-                if (!token.config.getUseEcX963Encoding()) {\n-                    DerValue wECPoint = new DerValue(ecKey);\n-\n-                    if (wECPoint.getTag() != DerValue.tag_OctetString) {\n-                        throw new IOException(\"Could not DER decode EC point.\" +\n-                            \" Unexpected tag: \" + wECPoint.getTag());\n-                    }\n-                    w = P11ECKeyFactory.decodePoint\n-                        (wECPoint.getDataBytes(), params.getCurve());\n-\n-                } else {\n-                    w = P11ECKeyFactory.decodePoint(ecKey, params.getCurve());\n-                }\n-\n-            } catch (Exception e) {\n-                throw new RuntimeException(\"Could not parse key values\", e);\n-            }\n+            attrFetcher = new P11ECAttributesFetcher(this, false, false);\n@@ -1178,1 +1417,0 @@\n-                fetchValues();\n@@ -1180,1 +1418,1 @@\n-                    return ECUtil.x509EncodeECPublicKey(w, params);\n+                    return ECUtil.x509EncodeECPublicKey(getW(), getParams());\n@@ -1188,2 +1426,1 @@\n-            fetchValues();\n-            return w;\n+            return attrFetcher.getW();\n@@ -1192,2 +1429,1 @@\n-            fetchValues();\n-            return params;\n+            return attrFetcher.getParams();\n@@ -1196,1 +1432,1 @@\n-            fetchValues();\n+            ECPoint w = getW();\n@@ -1200,1 +1436,1 @@\n-                + \"\\n  parameters: \" + params;\n+                + \"\\n  parameters: \" + getParams();\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":596,"deletions":360,"binary":false,"changes":956,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-    private int signatureLength;\n+    private int sigLen;\n@@ -291,1 +291,1 @@\n-                    token.p11.C_SignFinal(session.id(), signatureLength);\n+                    token.p11.C_SignFinal(session.id(), sigLen);\n@@ -302,1 +302,1 @@\n-                byte[] signature = new byte[signatureLength];\n+                byte[] signature = new byte[sigLen];\n@@ -374,0 +374,1 @@\n+        sigLen = 0;\n@@ -375,4 +376,6 @@\n-            signatureLength =\n-                    ((DSAKey)p11Key).getParams().getQ().bitLength() >> 2;\n-        } else {\n-            signatureLength = 0;\n+            if (p11Key instanceof P11Key.P11DSAPrivateKeyInternal) {\n+                sigLen = ((P11Key.P11DSAPrivateKeyInternal)p11Key).getParams()\n+                        .getQ().bitLength() >> 2;\n+            } else if (p11Key instanceof DSAKey) {\n+                sigLen = ((DSAKey)p11Key).getParams().getQ().bitLength() >> 2;\n+            }\n@@ -625,2 +628,1 @@\n-                signature = token.p11.C_SignFinal(session.id(),\n-                        signatureLength);\n+                signature = token.p11.C_SignFinal(session.id(), sigLen);\n@@ -693,1 +695,1 @@\n-                    signature = asn1ToDSA(signature);\n+                    signature = asn1ToDSA(signature, sigLen);\n@@ -817,1 +819,2 @@\n-    private byte[] asn1ToDSA(byte[] sig) throws SignatureException {\n+    private static byte[] asn1ToDSA(byte[] sig, int sigLen)\n+            throws SignatureException {\n@@ -832,2 +835,2 @@\n-            byte[] br = toByteArray(r, signatureLength\/2);\n-            byte[] bs = toByteArray(s, signatureLength\/2);\n+            byte[] br = toByteArray(r, sigLen\/2);\n+            byte[] bs = toByteArray(s, sigLen\/2);\n@@ -845,1 +848,1 @@\n-    private byte[] asn1ToECDSA(byte[] sig) throws SignatureException {\n+    private static byte[] asn1ToECDSA(byte[] sig) throws SignatureException {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Signature.java","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+    @Override\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Signature\/LargeDSAKey.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}