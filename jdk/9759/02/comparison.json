{"files":[{"patch":"@@ -162,0 +162,1 @@\n+  _dumped_to_src_obj_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE),\n@@ -633,0 +634,8 @@\n+  {\n+    bool created;\n+    _dumped_to_src_obj_table.put_if_absent((address)dest, src, &created);\n+    assert(created, \"must be\");\n+    if (_dumped_to_src_obj_table.maybe_grow()) {\n+      log_info(cds, hashtables)(\"Expanded _dumped_to_src_obj_table table to %d\", _dumped_to_src_obj_table.table_size());\n+    }\n+  }\n@@ -653,0 +662,6 @@\n+address ArchiveBuilder::get_src_obj(address dumped_addr) const {\n+  address* src_obj = _dumped_to_src_obj_table.get(dumped_addr);\n+  assert(src_obj != NULL && *src_obj != NULL, \"must be\");\n+  return *src_obj;\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,0 +203,1 @@\n+  ResizeableResourceHashtable<address, address, ResourceObj::C_HEAP, mtClassShared> _dumped_to_src_obj_table;\n@@ -387,0 +388,4 @@\n+  address get_src_obj(address dumped_addr) const;\n+  template <typename T> T get_src_obj(T dumped_addr) const {\n+    return (T)get_src_obj((address)dumped_addr);\n+  }\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+SystemDictionaryShared::SavedCpCacheEntriesTable* SystemDictionaryShared::_saved_cpcache_entries_table = NULL;\n@@ -507,0 +508,1 @@\n+    _saved_cpcache_entries_table = new (ResourceObj::C_HEAP, mtClass) SavedCpCacheEntriesTable;\n@@ -519,0 +521,5 @@\n+\n+  ConstantPoolCache* cpc = k->constants()->cache();\n+  if (cpc != NULL) {\n+    remove_saved_cpcache_entries_locked(cpc);\n+  }\n@@ -1332,0 +1339,30 @@\n+void SystemDictionaryShared::set_saved_cpcache_entries(ConstantPoolCache* cpc, ConstantPoolCacheEntry* entries) {\n+  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n+  bool is_new = _saved_cpcache_entries_table->put(cpc, entries);\n+  assert(is_new, \"saved entries must never changed\");\n+}\n+\n+ConstantPoolCacheEntry* SystemDictionaryShared::get_saved_cpcache_entries_locked(ConstantPoolCache* cpc) {\n+  assert_lock_strong(DumpTimeTable_lock);\n+  ConstantPoolCacheEntry** p = _saved_cpcache_entries_table->get(cpc);\n+  if (p) {\n+    return *p;\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n+void SystemDictionaryShared::remove_saved_cpcache_entries(ConstantPoolCache* cpc) {\n+  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n+  remove_saved_cpcache_entries_locked(cpc);\n+}\n+\n+void SystemDictionaryShared::remove_saved_cpcache_entries_locked(ConstantPoolCache* cpc) {\n+  assert_lock_strong(DumpTimeTable_lock);\n+  ConstantPoolCacheEntry** p = _saved_cpcache_entries_table->get(cpc);\n+  if (p) {\n+    _saved_cpcache_entries_table->remove(cpc);\n+    FREE_C_HEAP_ARRAY(ConstantPoolCacheEntry, *p);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"utilities\/resourceHash.hpp\"\n@@ -111,0 +112,2 @@\n+class ConstantPoolCache;\n+class ConstantPoolCacheEntry;\n@@ -168,0 +171,9 @@\n+  \/\/ Doesn't need to be cloned as it's not modified during dump time.\n+  using SavedCpCacheEntriesTable = ResourceHashtable<\n+    ConstantPoolCache*,\n+    ConstantPoolCacheEntry*,\n+    15889, \/\/ prime number\n+    ResourceObj::C_HEAP,\n+    mtClassShared>;\n+  static SavedCpCacheEntriesTable* _saved_cpcache_entries_table;\n+\n@@ -239,0 +251,5 @@\n+  static void set_saved_cpcache_entries(ConstantPoolCache* cpc, ConstantPoolCacheEntry* entries);\n+  static ConstantPoolCacheEntry* get_saved_cpcache_entries_locked(ConstantPoolCache* k);\n+  static void remove_saved_cpcache_entries(ConstantPoolCache* cpc);\n+  static void remove_saved_cpcache_entries_locked(ConstantPoolCache* cpc);\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -119,4 +120,10 @@\n-    DEBUG_ONLY(\n-    if (DumpSharedSpaces) {\n-      cache->verify_just_initialized();\n-    })\n+    if (Arguments::is_dumping_archive()) {\n+      if (_pool->pool_holder()->is_shared()) {\n+        assert(DynamicDumpSharedSpaces, \"must be\");\n+        \/\/ We are linking a shared class from the base archive. This\n+        \/\/ class won't be written into the dynamic archive, so there's no\n+        \/\/ need to save its CpCaches.\n+      } else {\n+        cache->save_for_archive();\n+      }\n+    }\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -426,0 +426,1 @@\n+    \/\/ cache() is NULL if this class is not yet linked.\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/systemDictionaryShared.hpp\"\n@@ -65,18 +66,0 @@\n-void ConstantPoolCacheEntry::verify_just_initialized(bool f2_used) {\n-  assert((_indices & (~cp_index_mask)) == 0, \"sanity\");\n-  assert(_f1 == NULL, \"sanity\");\n-  assert(_flags == 0, \"sanity\");\n-  if (!f2_used) {\n-    assert(_f2 == 0, \"sanity\");\n-  }\n-}\n-\n-void ConstantPoolCacheEntry::reinitialize(bool f2_used) {\n-  _indices &= cp_index_mask;\n-  _f1 = NULL;\n-  _flags = 0;\n-  if (!f2_used) {\n-    _f2 = 0;\n-  }\n-}\n-\n@@ -703,3 +686,6 @@\n-void ConstantPoolCache::verify_just_initialized() {\n-  DEBUG_ONLY(walk_entries_for_initialization(\/*check_only = *\/ true));\n-}\n+void ConstantPoolCache::save_for_archive() {\n+#if INCLUDE_CDS\n+  ConstantPoolCacheEntry* copy = NEW_C_HEAP_ARRAY(ConstantPoolCacheEntry, length(), mtClassShared);\n+  for (int i = 0; i < length(); i++) {\n+    copy[i] = *entry_at(i);\n+  }\n@@ -707,2 +693,2 @@\n-void ConstantPoolCache::remove_unshareable_info() {\n-  walk_entries_for_initialization(\/*check_only = *\/ false);\n+  SystemDictionaryShared::set_saved_cpcache_entries(this, copy);\n+#endif\n@@ -711,1 +697,2 @@\n-void ConstantPoolCache::walk_entries_for_initialization(bool check_only) {\n+void ConstantPoolCache::remove_unshareable_info() {\n+#if INCLUDE_CDS\n@@ -713,49 +700,6 @@\n-  \/\/ When dumping the archive, we want to clean up the ConstantPoolCache\n-  \/\/ to remove any effect of linking due to the execution of Java code --\n-  \/\/ each ConstantPoolCacheEntry will have the same contents as if\n-  \/\/ ConstantPoolCache::initialize has just returned:\n-  \/\/\n-  \/\/ - We keep the ConstantPoolCache::constant_pool_index() bits for all entries.\n-  \/\/ - We keep the \"f2\" field for entries used by invokedynamic and invokehandle\n-  \/\/ - All other bits in the entries are cleared to zero.\n-  ResourceMark rm;\n-\n-  InstanceKlass* ik = constant_pool()->pool_holder();\n-  bool* f2_used = NEW_RESOURCE_ARRAY(bool, length());\n-  memset(f2_used, 0, sizeof(bool) * length());\n-\n-  Thread* current = Thread::current();\n-\n-  \/\/ Find all the slots that we need to preserve f2\n-  for (int i = 0; i < ik->methods()->length(); i++) {\n-    Method* m = ik->methods()->at(i);\n-    RawBytecodeStream bcs(methodHandle(current, m));\n-    while (!bcs.is_last_bytecode()) {\n-      Bytecodes::Code opcode = bcs.raw_next();\n-      switch (opcode) {\n-      case Bytecodes::_invokedynamic: {\n-          int index = Bytes::get_native_u4(bcs.bcp() + 1);\n-          int cp_cache_index = constant_pool()->invokedynamic_cp_cache_index(index);\n-          f2_used[cp_cache_index] = 1;\n-        }\n-        break;\n-      case Bytecodes::_invokehandle: {\n-          int cp_cache_index = Bytes::get_native_u2(bcs.bcp() + 1);\n-          f2_used[cp_cache_index] = 1;\n-        }\n-        break;\n-      default:\n-        break;\n-      }\n-    }\n-  }\n-\n-  if (check_only) {\n-    DEBUG_ONLY(\n-      for (int i=0; i<length(); i++) {\n-        entry_at(i)->verify_just_initialized(f2_used[i]);\n-      })\n-  } else {\n-    for (int i=0; i<length(); i++) {\n-      entry_at(i)->reinitialize(f2_used[i]);\n-    }\n+  ConstantPoolCache* orig_cpc = ArchiveBuilder::current()->get_src_obj(this);\n+  ConstantPoolCacheEntry* saved = SystemDictionaryShared::get_saved_cpcache_entries_locked(orig_cpc);\n+  for (int i=0; i<length(); i++) {\n+    \/\/ Restore each entry to the initial state -- just after Rewriter::make_constant_pool_cache()\n+    \/\/ has finished.\n+    *entry_at(i) = saved[i];\n@@ -763,0 +707,1 @@\n+#endif\n@@ -771,0 +716,6 @@\n+\n+#if INCLUDE_CDS\n+  if (Arguments::is_dumping_archive()) {\n+    SystemDictionaryShared::remove_saved_cpcache_entries(this);\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":24,"deletions":73,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -389,3 +389,0 @@\n-\n-  void verify_just_initialized(bool f2_used);\n-  void reinitialize(bool f2_used);\n@@ -460,1 +457,1 @@\n-  void verify_just_initialized();\n+  void save_for_archive();\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -579,0 +579,1 @@\n+  SystemDictionaryShared::handle_class_unloading(this);\n@@ -694,2 +695,0 @@\n-\n-  SystemDictionaryShared::handle_class_unloading(this);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}