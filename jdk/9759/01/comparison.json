{"files":[{"patch":"@@ -162,0 +162,1 @@\n+  _dumped_to_src_obj_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE),\n@@ -633,0 +634,8 @@\n+  {\n+    bool created;\n+    _dumped_to_src_obj_table.put_if_absent((address)dest, src, &created);\n+    assert(created, \"must be\");\n+    if (_dumped_to_src_obj_table.maybe_grow()) {\n+      log_info(cds, hashtables)(\"Expanded _dumped_to_src_obj_table table to %d\", _dumped_to_src_obj_table.table_size());\n+    }\n+  }\n@@ -653,0 +662,6 @@\n+address ArchiveBuilder::get_src_obj(address dumped_addr) const {\n+  address* src_obj = _dumped_to_src_obj_table.get(dumped_addr);\n+  assert(src_obj != NULL && *src_obj != NULL, \"must be\");\n+  return *src_obj;\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,0 +203,1 @@\n+  ResizeableResourceHashtable<address, address, ResourceObj::C_HEAP, mtClassShared> _dumped_to_src_obj_table;\n@@ -387,0 +388,1 @@\n+  address get_src_obj(address dumped_addr) const;\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,0 +77,4 @@\n+\n+  \/\/ The saved cp entries array is not modified by the ArchiveBuilder, so there's\n+  \/\/ no need to make a deep copy. It will be freed when the holder class is removed.\n+  _saved_cpcache_entries = src._saved_cpcache_entries;\n@@ -90,0 +94,12 @@\n+void DumpTimeClassInfo::save_cpcache_entries(ConstantPoolCacheEntry* entries) {\n+  free_saved_cpcache_entries(); \/\/ in case of class redefinition\n+  _saved_cpcache_entries = entries;\n+}\n+\n+void DumpTimeClassInfo::free_saved_cpcache_entries() {\n+  if (_saved_cpcache_entries != NULL) {\n+    FREE_C_HEAP_ARRAY(ConstantPoolCacheEntry, _saved_cpcache_entries);\n+    _saved_cpcache_entries = NULL;\n+  }\n+}\n+\n@@ -204,1 +220,2 @@\n-  assert(p->_klass == k, \"Sanity\");\n+  assert(p->_klass == k || p->_klass == ArchiveBuilder::get_relocated_klass(k),\n+         \"Sanity\");\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+class ConstantPoolCacheEntry;\n@@ -131,0 +132,1 @@\n+  ConstantPoolCacheEntry*              _saved_cpcache_entries;\n@@ -147,0 +149,1 @@\n+    _saved_cpcache_entries = NULL;\n@@ -217,0 +220,7 @@\n+\n+  ConstantPoolCacheEntry* get_saved_cpcache_entries() const {\n+    return _saved_cpcache_entries;\n+  }\n+\n+  void save_cpcache_entries(ConstantPoolCacheEntry* entries);\n+  void free_saved_cpcache_entries();\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -518,0 +518,1 @@\n+  get_info_locked(k)->free_saved_cpcache_entries();\n@@ -1332,0 +1333,10 @@\n+void SystemDictionaryShared::save_cpcache_entries(InstanceKlass* k, ConstantPoolCacheEntry* entries) {\n+  get_info(k)->save_cpcache_entries(entries);\n+}\n+\n+ConstantPoolCacheEntry* SystemDictionaryShared::get_saved_cpcache_entries_locked(InstanceKlass* dumped_k) {\n+  assert_lock_strong(DumpTimeTable_lock);\n+  InstanceKlass* orig_k = (InstanceKlass*)ArchiveBuilder::current()->get_src_obj((address)dumped_k);\n+  return get_info_locked(orig_k)->get_saved_cpcache_entries();\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+class ConstantPoolCacheEntry;\n@@ -239,0 +240,3 @@\n+  static void save_cpcache_entries(InstanceKlass* k, ConstantPoolCacheEntry* entries);\n+  static ConstantPoolCacheEntry* get_saved_cpcache_entries_locked(InstanceKlass* k);\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -119,4 +120,10 @@\n-    DEBUG_ONLY(\n-    if (DumpSharedSpaces) {\n-      cache->verify_just_initialized();\n-    })\n+    if (Arguments::is_dumping_archive()) {\n+      if (_pool->pool_holder()->is_shared()) {\n+        assert(DynamicDumpSharedSpaces, \"must be\");\n+        \/\/ We are linking a shared class from the base archive. This\n+        \/\/ class won't be written into the dynamic archive, so there's no\n+        \/\/ need to save its CpCaches.\n+      } else {\n+        cache->save_for_archive();\n+      }\n+    }\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -426,0 +426,1 @@\n+    \/\/ cache() is NULL if this class is not yet linked.\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/systemDictionaryShared.hpp\"\n@@ -65,18 +66,0 @@\n-void ConstantPoolCacheEntry::verify_just_initialized(bool f2_used) {\n-  assert((_indices & (~cp_index_mask)) == 0, \"sanity\");\n-  assert(_f1 == NULL, \"sanity\");\n-  assert(_flags == 0, \"sanity\");\n-  if (!f2_used) {\n-    assert(_f2 == 0, \"sanity\");\n-  }\n-}\n-\n-void ConstantPoolCacheEntry::reinitialize(bool f2_used) {\n-  _indices &= cp_index_mask;\n-  _f1 = NULL;\n-  _flags = 0;\n-  if (!f2_used) {\n-    _f2 = 0;\n-  }\n-}\n-\n@@ -703,3 +686,6 @@\n-void ConstantPoolCache::verify_just_initialized() {\n-  DEBUG_ONLY(walk_entries_for_initialization(\/*check_only = *\/ true));\n-}\n+void ConstantPoolCache::save_for_archive() {\n+#if INCLUDE_CDS\n+  ConstantPoolCacheEntry* copy = NEW_C_HEAP_ARRAY(ConstantPoolCacheEntry, length(), mtClassShared);\n+  for (int i = 0; i < length(); i++) {\n+    copy[i] = *entry_at(i);\n+  }\n@@ -707,2 +693,2 @@\n-void ConstantPoolCache::remove_unshareable_info() {\n-  walk_entries_for_initialization(\/*check_only = *\/ false);\n+  SystemDictionaryShared::save_cpcache_entries(constant_pool()->pool_holder(), copy);\n+#endif\n@@ -711,1 +697,2 @@\n-void ConstantPoolCache::walk_entries_for_initialization(bool check_only) {\n+void ConstantPoolCache::remove_unshareable_info() {\n+#if INCLUDE_CDS\n@@ -713,10 +700,0 @@\n-  \/\/ When dumping the archive, we want to clean up the ConstantPoolCache\n-  \/\/ to remove any effect of linking due to the execution of Java code --\n-  \/\/ each ConstantPoolCacheEntry will have the same contents as if\n-  \/\/ ConstantPoolCache::initialize has just returned:\n-  \/\/\n-  \/\/ - We keep the ConstantPoolCache::constant_pool_index() bits for all entries.\n-  \/\/ - We keep the \"f2\" field for entries used by invokedynamic and invokehandle\n-  \/\/ - All other bits in the entries are cleared to zero.\n-  ResourceMark rm;\n-\n@@ -724,38 +701,5 @@\n-  bool* f2_used = NEW_RESOURCE_ARRAY(bool, length());\n-  memset(f2_used, 0, sizeof(bool) * length());\n-\n-  Thread* current = Thread::current();\n-\n-  \/\/ Find all the slots that we need to preserve f2\n-  for (int i = 0; i < ik->methods()->length(); i++) {\n-    Method* m = ik->methods()->at(i);\n-    RawBytecodeStream bcs(methodHandle(current, m));\n-    while (!bcs.is_last_bytecode()) {\n-      Bytecodes::Code opcode = bcs.raw_next();\n-      switch (opcode) {\n-      case Bytecodes::_invokedynamic: {\n-          int index = Bytes::get_native_u4(bcs.bcp() + 1);\n-          int cp_cache_index = constant_pool()->invokedynamic_cp_cache_index(index);\n-          f2_used[cp_cache_index] = 1;\n-        }\n-        break;\n-      case Bytecodes::_invokehandle: {\n-          int cp_cache_index = Bytes::get_native_u2(bcs.bcp() + 1);\n-          f2_used[cp_cache_index] = 1;\n-        }\n-        break;\n-      default:\n-        break;\n-      }\n-    }\n-  }\n-\n-  if (check_only) {\n-    DEBUG_ONLY(\n-      for (int i=0; i<length(); i++) {\n-        entry_at(i)->verify_just_initialized(f2_used[i]);\n-      })\n-  } else {\n-    for (int i=0; i<length(); i++) {\n-      entry_at(i)->reinitialize(f2_used[i]);\n-    }\n+  ConstantPoolCacheEntry* saved = SystemDictionaryShared::get_saved_cpcache_entries_locked(ik);\n+  for (int i=0; i<length(); i++) {\n+    \/\/ Restore each entry to the initial state -- just after Rewriter::make_constant_pool_cache()\n+    \/\/ has finished.\n+    *entry_at(i) = saved[i];\n@@ -763,0 +707,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":17,"deletions":72,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -389,3 +389,0 @@\n-\n-  void verify_just_initialized(bool f2_used);\n-  void reinitialize(bool f2_used);\n@@ -460,1 +457,1 @@\n-  void verify_just_initialized();\n+  void save_for_archive();\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"}]}