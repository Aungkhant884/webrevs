{"files":[{"patch":"@@ -87,1 +87,1 @@\n-    int locals = f.interpreter_frame_method()->max_locals();\n+    intptr_t locals_offset = *f.addr_at(frame::interpreter_frame_locals_offset);\n@@ -91,1 +91,1 @@\n-    fp = caller.unextended_sp() - (locals + frame::sender_sp_offset) + (overlap_caller ? ContinuationHelper::InterpretedFrame::stack_argsize(f) : 0);\n+    fp = caller.unextended_sp() - 1 - locals_offset + (overlap_caller ? ContinuationHelper::InterpretedFrame::stack_argsize(f) : 0);\n@@ -100,1 +100,2 @@\n-    *hf.addr_at(frame::interpreter_frame_locals_offset) = frame::sender_sp_offset + locals - 1;\n+    \/\/ copy relativized locals from the stack frame\n+    *hf.addr_at(frame::interpreter_frame_locals_offset) = locals_offset;\n@@ -148,2 +149,2 @@\n-  \/\/ so we compute locals \"from scratch\" rather than relativizing the value in the stack frame, which might include padding,\n-  \/\/ since we don't freeze the padding word (see recurse_freeze_interpreted_frame).\n+  \/\/ because we freeze the padding word (see recurse_freeze_interpreted_frame) in order to keep the same relativized\n+  \/\/ locals value, we don't need to change the locals value here.\n@@ -153,2 +154,0 @@\n-  \/\/ This line can be changed into an assert when we have fixed the \"frame padding problem\", see JDK-8300197\n-  *hf.addr_at(frame::interpreter_frame_locals_offset) = frame::sender_sp_offset + f.interpreter_frame_method()->max_locals() - 1;\n@@ -225,1 +224,0 @@\n-    int padding = 0;\n@@ -229,1 +227,0 @@\n-      padding++;\n@@ -238,4 +235,2 @@\n-    intptr_t offset = *hf.addr_at(frame::interpreter_frame_locals_offset);\n-    assert((int)offset == frame::sender_sp_offset + locals - 1, \"\");\n-    \/\/ set relativized locals\n-    *f.addr_at(frame::interpreter_frame_locals_offset) = padding + offset;\n+    \/\/ copy relativized locals from the heap frame\n+    *f.addr_at(frame::interpreter_frame_locals_offset) = *hf.addr_at(frame::interpreter_frame_locals_offset);\n@@ -303,6 +298,0 @@\n-inline void ThawBase::set_interpreter_frame_bottom(const frame& f, intptr_t* bottom) {\n-  \/\/ set relativized locals\n-  \/\/ this line can be changed into an assert when we have fixed the \"frame padding problem\", see JDK-8300197\n-  *f.addr_at(frame::interpreter_frame_locals_offset) = (bottom - 1) - f.fp();\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":8,"deletions":19,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -73,4 +73,0 @@\n-inline void ThawBase::set_interpreter_frame_bottom(const frame& f, intptr_t* bottom) {\n-  Unimplemented();\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/continuationFreezeThaw_arm.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,3 +87,3 @@\n-  \/\/ frame, therefore we cannot use it to relativize the locals pointer.\n-  \/\/ This line can be changed into an assert when we have fixed the \"frame padding problem\", see JDK-8300197\n-  *hf.addr_at(ijava_idx(locals)) = frame::metadata_words + f.interpreter_frame_method()->max_locals() - 1;\n+  \/\/ frame, because we freeze the padding (see recurse_freeze_interpreted_frame)\n+  \/\/ in order to keep the same relativized locals pointer, we don't need to change it here.\n+\n@@ -267,1 +267,1 @@\n-    int locals = f.interpreter_frame_method()->max_locals();\n+    intptr_t locals_offset = *f.addr_at(ijava_idx(locals));\n@@ -275,1 +275,1 @@\n-    fp = caller.unextended_sp() + overlap - locals - frame::metadata_words_at_top;\n+    fp = caller.unextended_sp() - 1 - locals_offset + overlap;\n@@ -289,1 +289,1 @@\n-    *hf.addr_at(ijava_idx(locals)) = frame::metadata_words + locals - 1;\n+    *hf.addr_at(ijava_idx(locals)) = locals_offset;\n@@ -510,4 +510,2 @@\n-    intptr_t offset = *hf.addr_at(ijava_idx(locals)) + padding;\n-    assert((int)offset == hf.interpreter_frame_method()->max_locals() + frame::metadata_words_at_top + padding - 1, \"\");\n-    \/\/ set relativized locals\n-    *f.addr_at(ijava_idx(locals)) = offset;\n+    \/\/ copy relativized locals from the heap frame\n+    *f.addr_at(ijava_idx(locals)) = *hf.addr_at(ijava_idx(locals));\n@@ -552,6 +550,0 @@\n-inline void ThawBase::set_interpreter_frame_bottom(const frame& f, intptr_t* bottom) {\n-  \/\/ set relativized locals\n-  \/\/ This line can be changed into an assert when we have fixed the \"frame padding problem\", see JDK-8300197\n-  *f.addr_at(ijava_idx(locals)) = (bottom - 1) - f.fp();\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/continuationFreezeThaw_ppc.inline.hpp","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-    int locals = f.interpreter_frame_method()->max_locals();\n+    intptr_t locals_offset = *f.addr_at(frame::interpreter_frame_locals_offset);\n@@ -90,1 +90,1 @@\n-    fp = caller.unextended_sp() - (locals + frame::sender_sp_offset) + (overlap_caller ? ContinuationHelper::InterpretedFrame::stack_argsize(f) : 0);\n+    fp = caller.unextended_sp() - 1 - locals_offset + (overlap_caller ? ContinuationHelper::InterpretedFrame::stack_argsize(f) : 0);\n@@ -99,1 +99,1 @@\n-    *hf.addr_at(frame::interpreter_frame_locals_offset) = frame::sender_sp_offset + locals - 1;\n+    *hf.addr_at(frame::interpreter_frame_locals_offset) = locals_offset;\n@@ -147,2 +147,2 @@\n-  \/\/ so we compute locals \"from scratch\" rather than relativizing the value in the stack frame, which might include padding,\n-  \/\/ since we don't freeze the padding word (see recurse_freeze_interpreted_frame).\n+  \/\/ because we freeze the padding word (see recurse_freeze_interpreted_frame) in order to keep the same relativized\n+  \/\/ locals value, we don't need to change the locals value here.\n@@ -152,2 +152,0 @@\n-  \/\/ this line can be changed into an assert when we have fixed the \"frame padding problem\", see JDK-8300197\n-  *hf.addr_at(frame::interpreter_frame_locals_offset) = frame::sender_sp_offset + f.interpreter_frame_method()->max_locals() - 1;\n@@ -228,1 +226,0 @@\n-    int padding = 0;\n@@ -232,1 +229,0 @@\n-      padding++;\n@@ -241,4 +237,2 @@\n-    intptr_t offset = *hf.addr_at(frame::interpreter_frame_locals_offset);\n-    assert((int)offset == frame::sender_sp_offset + locals - 1, \"\");\n-    \/\/ set relativized locals\n-    *f.addr_at(frame::interpreter_frame_locals_offset) = padding + offset;\n+    \/\/ copy relativized locals from the heap frame\n+    *f.addr_at(frame::interpreter_frame_locals_offset) = *hf.addr_at(frame::interpreter_frame_locals_offset);\n@@ -306,6 +300,0 @@\n-inline void ThawBase::set_interpreter_frame_bottom(const frame& f, intptr_t* bottom) {\n-  \/\/ set relativized locals\n-  \/\/ This line can be changed into an assert when we have fixed the \"frame padding problem\", see JDK-8300197\n-  *f.addr_at(frame::interpreter_frame_locals_offset) = (bottom - 1) - f.fp();\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/continuationFreezeThaw_riscv.inline.hpp","additions":7,"deletions":19,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,4 +73,0 @@\n-inline void ThawBase::set_interpreter_frame_bottom(const frame& f, intptr_t* bottom) {\n-  Unimplemented();\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/continuationFreezeThaw_s390.inline.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-    int locals = f.interpreter_frame_method()->max_locals();\n+    intptr_t locals_offset = *f.addr_at(frame::interpreter_frame_locals_offset);\n@@ -88,1 +88,1 @@\n-    fp = caller.unextended_sp() - (locals + frame::sender_sp_offset) + (overlap_caller ? ContinuationHelper::InterpretedFrame::stack_argsize(f) : 0);\n+    fp = caller.unextended_sp() - 1 - locals_offset + (overlap_caller ? ContinuationHelper::InterpretedFrame::stack_argsize(f) : 0);\n@@ -97,1 +97,2 @@\n-    *hf.addr_at(frame::interpreter_frame_locals_offset) = frame::sender_sp_offset + locals - 1;\n+    \/\/ copy relativized locals from the stack frame\n+    *hf.addr_at(frame::interpreter_frame_locals_offset) = locals_offset;\n@@ -226,4 +227,4 @@\n-    intptr_t offset = *hf.addr_at(frame::interpreter_frame_locals_offset);\n-    assert((int)offset == frame::sender_sp_offset + locals - 1, \"\");\n-    \/\/ set relativized locals\n-    *f.addr_at(frame::interpreter_frame_locals_offset) = offset;\n+    intptr_t locals_offset = *hf.addr_at(frame::interpreter_frame_locals_offset);\n+    assert((int)locals_offset == frame::sender_sp_offset + locals - 1, \"\");\n+    \/\/ copy relativized locals from the heap frame\n+    *f.addr_at(frame::interpreter_frame_locals_offset) = locals_offset;\n@@ -288,4 +289,0 @@\n-inline void ThawBase::set_interpreter_frame_bottom(const frame& f, intptr_t* bottom) {\n-  \/\/ Nothing to do. Just make sure the relativized locals is already set.\n-  assert((*f.addr_at(frame::interpreter_frame_locals_offset) == (bottom - 1) - f.fp()), \"\");\n-}\n","filename":"src\/hotspot\/cpu\/x86\/continuationFreezeThaw_x86.inline.hpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -73,4 +73,0 @@\n-inline void ThawBase::set_interpreter_frame_bottom(const frame& f, intptr_t* bottom) {\n-  Unimplemented();\n-}\n-\n","filename":"src\/hotspot\/cpu\/zero\/continuationFreezeThaw_zero.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1061,4 +1061,0 @@\n-  intptr_t* const callers_sp      = ContinuationHelper::InterpretedFrame::callers_sp(f);\n-  const int locals = f.interpreter_frame_method()->max_locals();\n-  const int fsize = callers_sp + frame::metadata_words_at_top + locals - stack_frame_top;\n-\n@@ -1066,1 +1062,1 @@\n-  assert(stack_frame_bottom - stack_frame_top >= fsize, \"\"); \/\/ == on x86\n+  const int fsize = stack_frame_bottom - stack_frame_top;\n@@ -1096,3 +1092,3 @@\n-  \/\/ on AArch64 we add padding between the locals and the rest of the frame to keep the fp 16-byte-aligned\n-  copy_to_chunk(stack_frame_bottom - locals, heap_frame_bottom - locals, locals); \/\/ copy locals\n-  copy_to_chunk(stack_frame_top, heap_frame_top, fsize - locals);                 \/\/ copy rest\n+  \/\/ Some architectures (like AArch64\/PPC64\/RISC-V) add padding between the locals and the fixed_frame to keep the fp 16-byte-aligned.\n+  \/\/ On those architectures we freeze the padding in order to keep the same fp-relative offsets in the fixed_frame.\n+  copy_to_chunk(stack_frame_top, heap_frame_top, fsize);\n@@ -1757,1 +1753,0 @@\n-  static inline void set_interpreter_frame_bottom(const frame& f, intptr_t* bottom);\n@@ -2152,8 +2147,0 @@\n-  assert(hf.is_heap_frame(), \"should be\");\n-  const int fsize = heap_frame_bottom - heap_frame_top;\n-\n-  assert((stack_frame_bottom >= stack_frame_top + fsize) &&\n-         (stack_frame_bottom <= stack_frame_top + fsize + 1), \"\"); \/\/ internal alignment on aarch64\n-\n-  \/\/ on AArch64\/PPC64 we add padding between the locals and the rest of the frame to keep the fp 16-byte-aligned\n-  const int locals = hf.interpreter_frame_method()->max_locals();\n@@ -2163,2 +2150,7 @@\n-  copy_from_chunk(heap_frame_bottom - locals, stack_frame_bottom - locals, locals); \/\/ copy locals\n-  copy_from_chunk(heap_frame_top, stack_frame_top, fsize - locals);                 \/\/ copy rest\n+  \/\/ Some architectures (like AArch64\/PPC64\/RISC-V) add padding between the locals and the fixed_frame to keep the fp 16-byte-aligned.\n+  \/\/ On those architectures we freeze the padding in order to keep the same fp-relative offsets in the fixed_frame.\n+  const int fsize = heap_frame_bottom - heap_frame_top;\n+  copy_from_chunk(heap_frame_top, stack_frame_top, fsize);\n+\n+  \/\/ Make sure the relativized locals is already set.\n+  assert(f.interpreter_frame_local_at(0) == stack_frame_bottom - 1, \"invalid frame bottom\");\n@@ -2166,1 +2158,0 @@\n-  set_interpreter_frame_bottom(f, stack_frame_bottom); \/\/ the copy overwrites the metadata\n@@ -2177,0 +2168,2 @@\n+  const int locals = hf.interpreter_frame_method()->max_locals();\n+\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":13,"deletions":20,"binary":false,"changes":33,"status":"modified"}]}