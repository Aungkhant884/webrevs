{"files":[{"patch":"@@ -87,1 +87,1 @@\n-    int locals = f.interpreter_frame_method()->max_locals();\n+    intptr_t offset = *f.addr_at(frame::interpreter_frame_locals_offset);\n@@ -91,1 +91,1 @@\n-    fp = caller.unextended_sp() - (locals + frame::sender_sp_offset) + (overlap_caller ? ContinuationHelper::InterpretedFrame::stack_argsize(f) : 0);\n+    fp = caller.unextended_sp() - 1 - offset + (overlap_caller ? ContinuationHelper::InterpretedFrame::stack_argsize(f) : 0);\n@@ -100,1 +100,2 @@\n-    *hf.addr_at(frame::interpreter_frame_locals_offset) = frame::sender_sp_offset + locals - 1;\n+    \/\/ copy relativized locals from the stack frame\n+    *hf.addr_at(frame::interpreter_frame_locals_offset) = offset;\n@@ -148,2 +149,2 @@\n-  \/\/ so we compute locals \"from scratch\" rather than relativizing the value in the stack frame, which might include padding,\n-  \/\/ since we don't freeze the padding word (see recurse_freeze_interpreted_frame).\n+  \/\/ since we freeze the padding word (see recurse_freeze_interpreted_frame) in order to keep the same relativized\n+  \/\/ locals value, we don't need to change the locals value here.\n@@ -153,2 +154,0 @@\n-  \/\/ This line can be changed into an assert when we have fixed the \"frame padding problem\", see JDK-8300197\n-  *hf.addr_at(frame::interpreter_frame_locals_offset) = frame::sender_sp_offset + f.interpreter_frame_method()->max_locals() - 1;\n@@ -225,1 +224,0 @@\n-    int padding = 0;\n@@ -229,1 +227,0 @@\n-      padding++;\n@@ -238,4 +235,2 @@\n-    intptr_t offset = *hf.addr_at(frame::interpreter_frame_locals_offset);\n-    assert((int)offset == frame::sender_sp_offset + locals - 1, \"\");\n-    \/\/ set relativized locals\n-    *f.addr_at(frame::interpreter_frame_locals_offset) = padding + offset;\n+    \/\/ copy relativized locals from the heap frame\n+    *f.addr_at(frame::interpreter_frame_locals_offset) = *hf.addr_at(frame::interpreter_frame_locals_offset);\n@@ -304,3 +299,2 @@\n-  \/\/ set relativized locals\n-  \/\/ this line can be changed into an assert when we have fixed the \"frame padding problem\", see JDK-8300197\n-  *f.addr_at(frame::interpreter_frame_locals_offset) = (bottom - 1) - f.fp();\n+  \/\/ Nothing to do. Just make sure the relativized locals is already set.\n+  assert((*f.addr_at(frame::interpreter_frame_locals_offset) == (bottom - 1) - f.fp()), \"\");\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":10,"deletions":16,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -87,3 +87,3 @@\n-  \/\/ frame, therefore we cannot use it to relativize the locals pointer.\n-  \/\/ This line can be changed into an assert when we have fixed the \"frame padding problem\", see JDK-8300197\n-  *hf.addr_at(ijava_idx(locals)) = frame::metadata_words + f.interpreter_frame_method()->max_locals() - 1;\n+  \/\/ frame, since we freeze the padding (see recurse_freeze_interpreted_frame)\n+  \/\/ in order to keep the same relativized locals pointer, we don't need to change it here.\n+\n@@ -267,1 +267,1 @@\n-    int locals = f.interpreter_frame_method()->max_locals();\n+    intptr_t offset = *f.addr_at(ijava_idx(locals));\n@@ -275,1 +275,1 @@\n-    fp = caller.unextended_sp() + overlap - locals - frame::metadata_words_at_top;\n+    fp = caller.unextended_sp() - 1 - offset + overlap;\n@@ -289,1 +289,1 @@\n-    *hf.addr_at(ijava_idx(locals)) = frame::metadata_words + locals - 1;\n+    *hf.addr_at(ijava_idx(locals)) = offset;\n@@ -510,4 +510,2 @@\n-    intptr_t offset = *hf.addr_at(ijava_idx(locals)) + padding;\n-    assert((int)offset == hf.interpreter_frame_method()->max_locals() + frame::metadata_words_at_top + padding - 1, \"\");\n-    \/\/ set relativized locals\n-    *f.addr_at(ijava_idx(locals)) = offset;\n+    \/\/ copy relativized locals from the heap frame\n+    *f.addr_at(ijava_idx(locals)) = *hf.addr_at(ijava_idx(locals));\n@@ -553,3 +551,2 @@\n-  \/\/ set relativized locals\n-  \/\/ This line can be changed into an assert when we have fixed the \"frame padding problem\", see JDK-8300197\n-  *f.addr_at(ijava_idx(locals)) = (bottom - 1) - f.fp();\n+  \/\/ Nothing to do. Just make sure the relativized locals is already set.\n+  assert((*f.addr_at(ijava_idx(locals)) == (bottom - 1) - f.fp()), \"\");\n","filename":"src\/hotspot\/cpu\/ppc\/continuationFreezeThaw_ppc.inline.hpp","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-    int locals = f.interpreter_frame_method()->max_locals();\n+    intptr_t offset = *f.addr_at(frame::interpreter_frame_locals_offset);\n@@ -90,1 +90,1 @@\n-    fp = caller.unextended_sp() - (locals + frame::sender_sp_offset) + (overlap_caller ? ContinuationHelper::InterpretedFrame::stack_argsize(f) : 0);\n+    fp = caller.unextended_sp() - 1 - offset + (overlap_caller ? ContinuationHelper::InterpretedFrame::stack_argsize(f) : 0);\n@@ -99,1 +99,1 @@\n-    *hf.addr_at(frame::interpreter_frame_locals_offset) = frame::sender_sp_offset + locals - 1;\n+    *hf.addr_at(frame::interpreter_frame_locals_offset) = offset;\n@@ -147,2 +147,2 @@\n-  \/\/ so we compute locals \"from scratch\" rather than relativizing the value in the stack frame, which might include padding,\n-  \/\/ since we don't freeze the padding word (see recurse_freeze_interpreted_frame).\n+  \/\/ since we freeze the padding word (see recurse_freeze_interpreted_frame) in order to keep the same relativized\n+  \/\/ locals value, we don't need to change the locals value here.\n@@ -152,2 +152,0 @@\n-  \/\/ this line can be changed into an assert when we have fixed the \"frame padding problem\", see JDK-8300197\n-  *hf.addr_at(frame::interpreter_frame_locals_offset) = frame::sender_sp_offset + f.interpreter_frame_method()->max_locals() - 1;\n@@ -228,1 +226,0 @@\n-    int padding = 0;\n@@ -232,1 +229,0 @@\n-      padding++;\n@@ -241,4 +237,2 @@\n-    intptr_t offset = *hf.addr_at(frame::interpreter_frame_locals_offset);\n-    assert((int)offset == frame::sender_sp_offset + locals - 1, \"\");\n-    \/\/ set relativized locals\n-    *f.addr_at(frame::interpreter_frame_locals_offset) = padding + offset;\n+    \/\/ copy relativized locals from the heap frame\n+    *f.addr_at(frame::interpreter_frame_locals_offset) = *hf.addr_at(frame::interpreter_frame_locals_offset);\n@@ -307,3 +301,2 @@\n-  \/\/ set relativized locals\n-  \/\/ This line can be changed into an assert when we have fixed the \"frame padding problem\", see JDK-8300197\n-  *f.addr_at(frame::interpreter_frame_locals_offset) = (bottom - 1) - f.fp();\n+  \/\/ Nothing to do. Just make sure the relativized locals is already set.\n+  assert((*f.addr_at(frame::interpreter_frame_locals_offset) == (bottom - 1) - f.fp()), \"\");\n","filename":"src\/hotspot\/cpu\/riscv\/continuationFreezeThaw_riscv.inline.hpp","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -228,1 +228,1 @@\n-    \/\/ set relativized locals\n+    \/\/ copy relativized locals from the heap frame\n","filename":"src\/hotspot\/cpu\/x86\/continuationFreezeThaw_x86.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1061,4 +1061,0 @@\n-  intptr_t* const callers_sp      = ContinuationHelper::InterpretedFrame::callers_sp(f);\n-  const int locals = f.interpreter_frame_method()->max_locals();\n-  const int fsize = callers_sp + frame::metadata_words_at_top + locals - stack_frame_top;\n-\n@@ -1066,1 +1062,1 @@\n-  assert(stack_frame_bottom - stack_frame_top >= fsize, \"\"); \/\/ == on x86\n+  const int fsize = stack_frame_bottom - stack_frame_top;\n@@ -1096,3 +1092,3 @@\n-  \/\/ on AArch64 we add padding between the locals and the rest of the frame to keep the fp 16-byte-aligned\n-  copy_to_chunk(stack_frame_bottom - locals, heap_frame_bottom - locals, locals); \/\/ copy locals\n-  copy_to_chunk(stack_frame_top, heap_frame_top, fsize - locals);                 \/\/ copy rest\n+  \/\/ Some architectures (like AArch64\/PPC64\/RISC-V) adds padding between the locals and the fixed_frame to keep the fp 16-byte-aligned.\n+  \/\/ On those architectures we freeze the padding in order to keep the same localized pointer values.\n+  copy_to_chunk(stack_frame_top, heap_frame_top, fsize);\n@@ -2157,3 +2153,0 @@\n-\n-  \/\/ on AArch64\/PPC64 we add padding between the locals and the rest of the frame to keep the fp 16-byte-aligned\n-  const int locals = hf.interpreter_frame_method()->max_locals();\n@@ -2163,2 +2156,3 @@\n-  copy_from_chunk(heap_frame_bottom - locals, stack_frame_bottom - locals, locals); \/\/ copy locals\n-  copy_from_chunk(heap_frame_top, stack_frame_top, fsize - locals);                 \/\/ copy rest\n+  \/\/ Some architectures (like AArch64\/PPC64\/RISC-V) adds padding between the locals and the fixed_frame to keep the fp 16-byte-aligned.\n+  \/\/ On those architectures we thaw the padding in order to keep the same localized pointer values.\n+  copy_from_chunk(heap_frame_top, stack_frame_top, fsize);\n@@ -2177,0 +2171,2 @@\n+  const int locals = hf.interpreter_frame_method()->max_locals();\n+\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"}]}