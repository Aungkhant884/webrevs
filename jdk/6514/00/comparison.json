{"files":[{"patch":"@@ -1,203 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/g1\/g1CardSetFreeMemoryTask.hpp\"\n-#include \"gc\/g1\/g1CardSetMemory.inline.hpp\"\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n-#include \"gc\/g1\/g1_globals.hpp\"\n-#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n-#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n-#include \"heapRegionRemSet.hpp\"\n-#include \"ci\/ciUtilities.hpp\"\n-\n-constexpr const char* G1CardSetFreeMemoryTask::_state_names[];\n-\n-const char* G1CardSetFreeMemoryTask::get_state_name(State value) const {\n-  return _state_names[static_cast<std::underlying_type_t<State>>(value)];\n-}\n-\n-bool G1CardSetFreeMemoryTask::deadline_exceeded(jlong deadline) {\n-  return os::elapsed_counter() >= deadline;\n-}\n-\n-static size_t keep_size(size_t free, size_t used, double percent) {\n-  size_t to_keep = used * percent;\n-  return MIN2(free, to_keep);\n-}\n-\n-bool G1CardSetFreeMemoryTask::calculate_return_infos(jlong deadline) {\n-  \/\/ Ignore the deadline in this step as it is very short.\n-\n-  G1CardSetMemoryStats used = _total_used;\n-  G1CardSetMemoryStats free = G1CardSetFreePool::free_list_sizes();\n-\n-  _return_info = new G1ReturnMemoryProcessorSet(used.num_pools());\n-  for (uint i = 0; i < used.num_pools(); i++) {\n-    size_t return_to_vm_size = keep_size(free._num_mem_sizes[i],\n-                                         used._num_mem_sizes[i],\n-                                         G1RemSetFreeMemoryKeepExcessRatio);\n-    log_trace(gc, task)(\"Card Set Free Memory: Type %s: Free: %zu (%zu) \"\n-                        \"Used: %zu Keep: %zu\",\n-                        G1CardSetConfiguration::mem_object_type_name_str(i),\n-                        free._num_mem_sizes[i], free._num_buffers[i],\n-                        used._num_mem_sizes[i], return_to_vm_size);\n-\n-    _return_info->append(new G1ReturnMemoryProcessor(return_to_vm_size));\n-  }\n-\n-  G1CardSetFreePool::update_unlink_processors(_return_info);\n-  return false;\n-}\n-\n-bool G1CardSetFreeMemoryTask::return_memory_to_vm(jlong deadline) {\n-  for (int i = 0; i < _return_info->length(); i++) {\n-    G1ReturnMemoryProcessor* info = _return_info->at(i);\n-    if (!info->finished_return_to_vm()) {\n-      if (info->return_to_vm(deadline)) {\n-        return true;\n-      }\n-    }\n-  }\n-  return false;\n-}\n-\n-bool G1CardSetFreeMemoryTask::return_memory_to_os(jlong deadline) {\n-  for (int i = 0; i < _return_info->length(); i++) {\n-    G1ReturnMemoryProcessor* info = _return_info->at(i);\n-    if (!info->finished_return_to_os()) {\n-      if (info->return_to_os(deadline)) {\n-        return true;\n-      }\n-    }\n-  }\n-  return false;\n-}\n-\n-bool G1CardSetFreeMemoryTask::cleanup_return_infos() {\n-  for (int i = 0; i < _return_info->length(); i++) {\n-     G1ReturnMemoryProcessor* info = _return_info->at(i);\n-     delete info;\n-  }\n-  delete _return_info;\n-\n-  _return_info = nullptr;\n-  return false;\n-}\n-\n-bool G1CardSetFreeMemoryTask::free_excess_card_set_memory() {\n-  jlong start = os::elapsed_counter();\n-  jlong end = start +\n-              (os::elapsed_frequency() \/ 1000) * G1RemSetFreeMemoryStepDurationMillis;\n-\n-  log_trace(gc, task)(\"Card Set Free Memory: Step start %1.3f end %1.3f\",\n-                      TimeHelper::counter_to_millis(start), TimeHelper::counter_to_millis(end));\n-\n-  State next_state;\n-\n-  do {\n-    switch (_state) {\n-      case State::CalculateUsed: {\n-        if (calculate_return_infos(end)) {\n-          next_state = _state;\n-          return true;\n-        }\n-        next_state = State::ReturnToVM;\n-        break;\n-      }\n-      case State::ReturnToVM: {\n-        if (return_memory_to_vm(end)) {\n-          next_state = _state;\n-          return true;\n-        }\n-        next_state = State::ReturnToOS;\n-        break;\n-      }\n-      case State::ReturnToOS: {\n-        if (return_memory_to_os(end)) {\n-          next_state = _state;\n-          return true;\n-        }\n-        next_state = State::Cleanup;\n-        break;\n-      }\n-      case State::Cleanup: {\n-        cleanup_return_infos();\n-        next_state = State::Inactive;\n-        break;\n-      }\n-      default:\n-        log_error(gc, task)(\"Should not try to free excess card set memory in %s state\", get_state_name(_state));\n-        ShouldNotReachHere();\n-        break;\n-    }\n-\n-    set_state(next_state);\n-  } while (_state != State::Inactive && !deadline_exceeded(end));\n-\n-  log_trace(gc, task)(\"Card Set Free Memory: Step took %1.3fms, done %s\",\n-                      TimeHelper::counter_to_millis(os::elapsed_counter() - start),\n-                      bool_to_str(_state == State::CalculateUsed));\n-\n-  return is_active();\n-}\n-\n-void G1CardSetFreeMemoryTask::set_state(State new_state) {\n-  log_trace(gc, task)(\"Card Set Free Memory: State change from %s to %s\",\n-                      get_state_name(_state),\n-                      get_state_name(new_state));\n-  _state = new_state;\n-}\n-\n-bool G1CardSetFreeMemoryTask::is_active() const {\n-  return _state != State::Inactive;\n-}\n-\n-jlong G1CardSetFreeMemoryTask::reschedule_delay_ms() const {\n-  return G1RemSetFreeMemoryRescheduleDelayMillis;\n-}\n-\n-G1CardSetFreeMemoryTask::G1CardSetFreeMemoryTask(const char* name) :\n-  G1ServiceTask(name), _state(State::CalculateUsed), _return_info(nullptr) { }\n-\n-void G1CardSetFreeMemoryTask::execute() {\n-  SuspendibleThreadSetJoiner sts;\n-\n-  if (free_excess_card_set_memory()) {\n-    schedule(reschedule_delay_ms());\n-  }\n-}\n-\n-void G1CardSetFreeMemoryTask::notify_new_stats(G1CardSetMemoryStats* young_gen_stats,\n-                                               G1CardSetMemoryStats* collection_set_candidate_stats) {\n-  assert_at_safepoint_on_vm_thread();\n-\n-  _total_used = *young_gen_stats;\n-  _total_used.add(*collection_set_candidate_stats);\n-\n-  if (!is_active()) {\n-    set_state(State::CalculateUsed);\n-    G1CollectedHeap::heap()->service_thread()->schedule_task(this, 0);\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetFreeMemoryTask.cpp","additions":0,"deletions":203,"binary":false,"changes":203,"status":"deleted"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1CARDSETFREEMEMORYTASK_HPP\n-#define SHARE_GC_G1_G1CARDSETFREEMEMORYTASK_HPP\n-\n-#include \"gc\/g1\/g1ServiceThread.hpp\"\n-#include \"gc\/g1\/g1CardSetMemory.hpp\"\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-#include \"utilities\/ticks.hpp\"\n-\n-\/\/ Task handling deallocation of free card set memory.\n-class G1CardSetFreeMemoryTask : public G1ServiceTask {\n-\n-  enum class State : uint {\n-    Inactive,\n-    CalculateUsed,\n-    ReturnToVM,\n-    ReturnToOS,\n-    Cleanup\n-  };\n-\n-  static constexpr const char* _state_names[] = { \"Invalid\",\n-                                                  \"CalculateUsed\",\n-                                                  \"ReturnToVM\",\n-                                                  \"ReturnToOS\",\n-                                                  \"Cleanup\" };\n-\n-  const char* get_state_name(State value) const;\n-\n-  State _state;\n-\n-  \/\/ Current total card set memory usage.\n-  G1CardSetMemoryStats _total_used;\n-\n-  typedef G1CardSetFreePool::G1ReturnMemoryProcessor G1ReturnMemoryProcessor;\n-  typedef G1CardSetFreePool::G1ReturnMemoryProcessorSet G1ReturnMemoryProcessorSet;\n-\n-  G1ReturnMemoryProcessorSet* _return_info;\n-\n-  \/\/ Returns whether the given deadline has passed.\n-  bool deadline_exceeded(jlong deadline);\n-\n-  \/\/ Methods for the tasks to be done. They all return true if that step has\n-  \/\/ completed.\n-  bool calculate_return_infos(jlong deadline);\n-  bool return_memory_to_vm(jlong deadline);\n-  bool return_memory_to_os(jlong deadline);\n-  bool cleanup_return_infos();\n-\n-  \/\/ Free excess card set memory, main method. Returns true if there is more work\n-  \/\/ to do.\n-  bool free_excess_card_set_memory();\n-\n-  void set_state(State new_state);\n-  \/\/ Returns whether we are currently processing a recent request.\n-  bool is_active() const;\n-\n-  \/\/ The delay used to reschedule this task if not all work has been completed.\n-  jlong reschedule_delay_ms() const;\n-\n-public:\n-  explicit G1CardSetFreeMemoryTask(const char* name);\n-\n-  void execute() override;\n-\n-  \/\/ Notify the task of new used remembered set memory statistics for the young\n-  \/\/ generation and the collection set candidate sets.\n-  void notify_new_stats(G1CardSetMemoryStats* young_gen_stats,\n-                        G1CardSetMemoryStats* collection_set_candidate_stats);\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1CARDSETFREEMEMORYTASK_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetFreeMemoryTask.hpp","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -33,1 +33,0 @@\n-\n@@ -145,1 +144,1 @@\n-                                               G1CardSetFreePool* free_list_pool) : _config(config) {\n+                                               G1SegmentedArrayFreePool<mtGCCardSet>* free_list_pool) : _config(config) {\n@@ -205,2 +204,2 @@\n-G1CardSetMemoryStats G1CardSetMemoryManager::memory_stats() const {\n-  G1CardSetMemoryStats result;\n+G1SegmentedArrayMemoryStats G1CardSetMemoryManager::memory_stats() const {\n+  G1SegmentedArrayMemoryStats result;\n@@ -209,1 +208,1 @@\n-    result._num_buffers[i] += _allocators[i].num_buffers();\n+    result._num_segments[i] += _allocators[i].num_buffers();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-                         G1CardSetFreePool* free_list_pool);\n+                         G1SegmentedArrayFreePool<mtGCCardSet>* free_list_pool);\n@@ -166,1 +166,1 @@\n-  G1CardSetMemoryStats memory_stats() const;\n+  G1SegmentedArrayMemoryStats memory_stats() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"gc\/g1\/g1CardSetFreeMemoryTask.hpp\"\n@@ -68,0 +67,2 @@\n+#include \"gc\/g1\/g1SegmentedArrayFreeMemoryTask.hpp\"\n+#include \"gc\/g1\/g1ServiceThread.hpp\"\n@@ -70,1 +71,0 @@\n-#include \"gc\/g1\/g1ServiceThread.hpp\"\n@@ -73,1 +73,0 @@\n-#include \"gc\/g1\/g1YoungGCEvacFailureInjector.hpp\"\n@@ -75,0 +74,1 @@\n+#include \"gc\/g1\/g1YoungGCEvacFailureInjector.hpp\"\n@@ -90,1 +90,0 @@\n-#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n@@ -92,1 +91,1 @@\n-#include \"gc\/shared\/taskTerminator.hpp\"\n+#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n@@ -94,0 +93,1 @@\n+#include \"gc\/shared\/taskTerminator.hpp\"\n@@ -95,1 +95,0 @@\n-#include \"gc\/shared\/weakProcessor.inline.hpp\"\n@@ -97,0 +96,1 @@\n+#include \"gc\/shared\/weakProcessor.inline.hpp\"\n@@ -99,1 +99,0 @@\n-#include \"memory\/iterator.hpp\"\n@@ -101,0 +100,1 @@\n+#include \"memory\/iterator.hpp\"\n@@ -1434,1 +1434,1 @@\n-  _free_card_set_memory_task(NULL),\n+  _free_segmented_array_memory_task(NULL),\n@@ -1726,2 +1726,2 @@\n-  _free_card_set_memory_task = new G1CardSetFreeMemoryTask(\"Card Set Free Memory Task\");\n-  _service_thread->register_task(_free_card_set_memory_task);\n+  _free_segmented_array_memory_task = new G1SegmentedArrayFreeMemoryTask(\"Card Set Free Memory Task\");\n+  _service_thread->register_task(_free_segmented_array_memory_task);\n@@ -2619,2 +2619,2 @@\n-  _free_card_set_memory_task->notify_new_stats(&_young_gen_card_set_stats,\n-                                               &_collection_set_candidates_card_set_stats);\n+  _free_segmented_array_memory_task->notify_new_stats(&_young_gen_card_set_stats,\n+                                                      &_collection_set_candidates_card_set_stats);\n@@ -2944,1 +2944,1 @@\n-void G1CollectedHeap::set_collection_set_candidates_stats(G1CardSetMemoryStats& stats) {\n+void G1CollectedHeap::set_collection_set_candidates_stats(G1SegmentedArrayMemoryStats& stats) {\n@@ -2948,1 +2948,1 @@\n-void G1CollectedHeap::set_young_gen_card_set_stats(const G1CardSetMemoryStats& stats) {\n+void G1CollectedHeap::set_young_gen_card_set_stats(const G1SegmentedArrayMemoryStats& stats) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/g1\/g1CardSetFreeMemoryTask.hpp\"\n@@ -38,0 +37,1 @@\n+#include \"gc\/g1\/g1HeapRegionAttr.hpp\"\n@@ -41,1 +41,0 @@\n-#include \"gc\/g1\/g1HeapRegionAttr.hpp\"\n@@ -44,0 +43,1 @@\n+#include \"gc\/g1\/g1SegmentedArrayFreeMemoryTask.hpp\"\n@@ -146,1 +146,1 @@\n-  G1CardSetFreeMemoryTask* _free_card_set_memory_task;\n+  G1SegmentedArrayFreeMemoryTask* _free_segmented_array_memory_task;\n@@ -163,1 +163,1 @@\n-  G1CardSetMemoryStats _young_gen_card_set_stats;\n+  G1SegmentedArrayMemoryStats _young_gen_card_set_stats;\n@@ -165,1 +165,1 @@\n-  G1CardSetMemoryStats _collection_set_candidates_card_set_stats;\n+  G1SegmentedArrayMemoryStats _collection_set_candidates_card_set_stats;\n@@ -262,2 +262,2 @@\n-  void set_collection_set_candidates_stats(G1CardSetMemoryStats& stats);\n-  void set_young_gen_card_set_stats(const G1CardSetMemoryStats& stats);\n+  void set_collection_set_candidates_stats(G1SegmentedArrayMemoryStats& stats);\n+  void set_young_gen_card_set_stats(const G1SegmentedArrayMemoryStats& stats);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3043,1 +3043,1 @@\n-  _total_remset_bytes += G1CardSetFreePool::free_list_pool()->mem_size() + HeapRegionRemSet::static_mem_size();\n+  _total_remset_bytes += G1SegmentedArrayFreePool<mtGCCardSet>::free_list_pool()->mem_size() + HeapRegionRemSet::static_mem_size();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -301,1 +301,1 @@\n-    G1CardSetFreePool::free_list_pool()->print_on(out);\n+    G1SegmentedArrayFreePool<mtGCCardSet>::free_list_pool()->print_on(out);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"ci\/ciUtilities.hpp\"\n+#include \"gc\/g1\/g1CardSetMemory.inline.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1SegmentedArrayFreeMemoryTask.hpp\"\n+#include \"gc\/g1\/g1_globals.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n+#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n+#include \"runtime\/os.hpp\"\n+\n+constexpr const char* G1SegmentedArrayFreeMemoryTask::_state_names[];\n+\n+const char* G1SegmentedArrayFreeMemoryTask::get_state_name(State value) const {\n+  return _state_names[static_cast<std::underlying_type_t<State>>(value)];\n+}\n+\n+bool G1SegmentedArrayFreeMemoryTask::deadline_exceeded(jlong deadline) {\n+  return os::elapsed_counter() >= deadline;\n+}\n+\n+static size_t keep_size(size_t free, size_t used, double percent) {\n+  size_t to_keep = used * percent;\n+  return MIN2(free, to_keep);\n+}\n+\n+bool G1SegmentedArrayFreeMemoryTask::calculate_return_infos(jlong deadline) {\n+  \/\/ Ignore the deadline in this step as it is very short.\n+\n+  G1SegmentedArrayMemoryStats used = _total_used;\n+  G1SegmentedArrayMemoryStats free = G1SegmentedArrayFreePool<mtGCCardSet>::free_list_sizes();\n+\n+  _return_info = new G1ReturnMemoryProcessorSet(used.num_pools());\n+  for (uint i = 0; i < used.num_pools(); i++) {\n+    size_t return_to_vm_size = keep_size(free._num_mem_sizes[i],\n+                                         used._num_mem_sizes[i],\n+                                         G1RemSetFreeMemoryKeepExcessRatio);\n+    log_trace(gc, task)(\"Segmented Array Free Memory: Type %s: Free: %zu (%zu) \"\n+                        \"Used: %zu Keep: %zu\",\n+                        G1CardSetConfiguration::mem_object_type_name_str(i),\n+                        free._num_mem_sizes[i], free._num_segments[i],\n+                        used._num_mem_sizes[i], return_to_vm_size);\n+\n+    _return_info->append(new G1ReturnMemoryProcessor(return_to_vm_size));\n+  }\n+\n+  G1SegmentedArrayFreePool<mtGCCardSet>::update_unlink_processors(_return_info);\n+  return false;\n+}\n+\n+bool G1SegmentedArrayFreeMemoryTask::return_memory_to_vm(jlong deadline) {\n+  for (int i = 0; i < _return_info->length(); i++) {\n+    G1ReturnMemoryProcessor* info = _return_info->at(i);\n+    if (!info->finished_return_to_vm()) {\n+      if (info->return_to_vm(deadline)) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+bool G1SegmentedArrayFreeMemoryTask::return_memory_to_os(jlong deadline) {\n+  for (int i = 0; i < _return_info->length(); i++) {\n+    G1ReturnMemoryProcessor* info = _return_info->at(i);\n+    if (!info->finished_return_to_os()) {\n+      if (info->return_to_os(deadline)) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+bool G1SegmentedArrayFreeMemoryTask::cleanup_return_infos() {\n+  for (int i = 0; i < _return_info->length(); i++) {\n+     G1ReturnMemoryProcessor* info = _return_info->at(i);\n+     delete info;\n+  }\n+  delete _return_info;\n+\n+  _return_info = nullptr;\n+  return false;\n+}\n+\n+bool G1SegmentedArrayFreeMemoryTask::free_excess_segmented_array_memory() {\n+  jlong start = os::elapsed_counter();\n+  jlong end = start +\n+              (os::elapsed_frequency() \/ 1000) * G1RemSetFreeMemoryStepDurationMillis;\n+\n+  log_trace(gc, task)(\"Segmented Array Free Memory: Step start %1.3f end %1.3f\",\n+                      TimeHelper::counter_to_millis(start), TimeHelper::counter_to_millis(end));\n+\n+  State next_state;\n+\n+  do {\n+    switch (_state) {\n+      case State::CalculateUsed: {\n+        if (calculate_return_infos(end)) {\n+          next_state = _state;\n+          return true;\n+        }\n+        next_state = State::ReturnToVM;\n+        break;\n+      }\n+      case State::ReturnToVM: {\n+        if (return_memory_to_vm(end)) {\n+          next_state = _state;\n+          return true;\n+        }\n+        next_state = State::ReturnToOS;\n+        break;\n+      }\n+      case State::ReturnToOS: {\n+        if (return_memory_to_os(end)) {\n+          next_state = _state;\n+          return true;\n+        }\n+        next_state = State::Cleanup;\n+        break;\n+      }\n+      case State::Cleanup: {\n+        cleanup_return_infos();\n+        next_state = State::Inactive;\n+        break;\n+      }\n+      default:\n+        log_error(gc, task)(\"Should not try to free excess segmented array memory in %s state\", get_state_name(_state));\n+        ShouldNotReachHere();\n+        break;\n+    }\n+\n+    set_state(next_state);\n+  } while (_state != State::Inactive && !deadline_exceeded(end));\n+\n+  log_trace(gc, task)(\"Segmented Array Free Memory: Step took %1.3fms, done %s\",\n+                      TimeHelper::counter_to_millis(os::elapsed_counter() - start),\n+                      bool_to_str(_state == State::CalculateUsed));\n+\n+  return is_active();\n+}\n+\n+void G1SegmentedArrayFreeMemoryTask::set_state(State new_state) {\n+  log_trace(gc, task)(\"Segmented Array Free Memory: State change from %s to %s\",\n+                      get_state_name(_state),\n+                      get_state_name(new_state));\n+  _state = new_state;\n+}\n+\n+bool G1SegmentedArrayFreeMemoryTask::is_active() const {\n+  return _state != State::Inactive;\n+}\n+\n+jlong G1SegmentedArrayFreeMemoryTask::reschedule_delay_ms() const {\n+  return G1RemSetFreeMemoryRescheduleDelayMillis;\n+}\n+\n+G1SegmentedArrayFreeMemoryTask::G1SegmentedArrayFreeMemoryTask(const char* name) :\n+  G1ServiceTask(name), _state(State::CalculateUsed), _return_info(nullptr) { }\n+\n+void G1SegmentedArrayFreeMemoryTask::execute() {\n+  SuspendibleThreadSetJoiner sts;\n+\n+  if (free_excess_segmented_array_memory()) {\n+    schedule(reschedule_delay_ms());\n+  }\n+}\n+\n+void G1SegmentedArrayFreeMemoryTask::notify_new_stats(G1SegmentedArrayMemoryStats* young_gen_stats,\n+                                                      G1SegmentedArrayMemoryStats* collection_set_candidate_stats) {\n+  assert_at_safepoint_on_vm_thread();\n+\n+  _total_used = *young_gen_stats;\n+  _total_used.add(*collection_set_candidate_stats);\n+\n+  if (!is_active()) {\n+    set_state(State::CalculateUsed);\n+    G1CollectedHeap::heap()->service_thread()->schedule_task(this, 0);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArrayFreeMemoryTask.cpp","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1SEGMENTEDARRAYFREEMEMORYTASK_HPP\n+#define SHARE_GC_G1_G1SEGMENTEDARRAYFREEMEMORYTASK_HPP\n+\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n+#include \"gc\/g1\/g1SegmentedArrayFreePool.hpp\"\n+#include \"gc\/g1\/g1ServiceThread.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+\/\/ Task handling deallocation of free segmented array memory.\n+class G1SegmentedArrayFreeMemoryTask : public G1ServiceTask {\n+\n+  enum class State : uint {\n+    Inactive,\n+    CalculateUsed,\n+    ReturnToVM,\n+    ReturnToOS,\n+    Cleanup\n+  };\n+\n+  static constexpr const char* _state_names[] = { \"Invalid\",\n+                                                  \"CalculateUsed\",\n+                                                  \"ReturnToVM\",\n+                                                  \"ReturnToOS\",\n+                                                  \"Cleanup\" };\n+\n+  const char* get_state_name(State value) const;\n+\n+  State _state;\n+\n+  \/\/ Current total segmented array memory usage.\n+  G1SegmentedArrayMemoryStats _total_used;\n+\n+  typedef G1SegmentedArrayFreePool<mtGCCardSet>::G1ReturnMemoryProcessor G1ReturnMemoryProcessor;\n+  typedef G1SegmentedArrayFreePool<mtGCCardSet>::G1ReturnMemoryProcessorSet G1ReturnMemoryProcessorSet;\n+\n+  G1ReturnMemoryProcessorSet* _return_info;\n+\n+  \/\/ Returns whether the given deadline has passed.\n+  bool deadline_exceeded(jlong deadline);\n+\n+  \/\/ Methods for the tasks to be done. They all return true if that step has\n+  \/\/ completed.\n+  bool calculate_return_infos(jlong deadline);\n+  bool return_memory_to_vm(jlong deadline);\n+  bool return_memory_to_os(jlong deadline);\n+  bool cleanup_return_infos();\n+\n+  \/\/ Free excess segmented array memory, main method. Returns true if there is more work\n+  \/\/ to do.\n+  bool free_excess_segmented_array_memory();\n+\n+  void set_state(State new_state);\n+  \/\/ Returns whether we are currently processing a recent request.\n+  bool is_active() const;\n+\n+  \/\/ The delay used to reschedule this task if not all work has been completed.\n+  jlong reschedule_delay_ms() const;\n+\n+public:\n+  explicit G1SegmentedArrayFreeMemoryTask(const char* name);\n+\n+  void execute() override;\n+\n+  \/\/ Notify the task of new used remembered set memory statistics for the young\n+  \/\/ generation and the collection set candidate sets.\n+  void notify_new_stats(G1SegmentedArrayMemoryStats* young_gen_stats,\n+                        G1SegmentedArrayMemoryStats* collection_set_candidate_stats);\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1SEGMENTEDARRAYFREEMEMORYTASK_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArrayFreeMemoryTask.hpp","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"gc\/g1\/g1CardSetMemory.hpp\"\n@@ -36,2 +35,1 @@\n-\n-G1CardSetMemoryStats::G1CardSetMemoryStats() {\n+G1SegmentedArrayMemoryStats::G1SegmentedArrayMemoryStats() {\n@@ -41,1 +39,1 @@\n-void G1CardSetMemoryStats::clear() {\n+void G1SegmentedArrayMemoryStats::clear() {\n@@ -44,1 +42,1 @@\n-    _num_buffers[i] = 0;\n+    _num_segments[i] = 0;\n@@ -48,1 +46,2 @@\n-void G1CardSetFreePool::update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processor) {\n+template<MEMFLAGS flag>\n+void G1SegmentedArrayFreePool<flag>::update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processor) {\n@@ -56,1 +55,2 @@\n-void G1CardSetFreePool::G1ReturnMemoryProcessor::visit_free_list(G1CardSetBufferList* source) {\n+template<MEMFLAGS flag>\n+void G1SegmentedArrayFreePool<flag>::G1ReturnMemoryProcessor::visit_free_list(G1SegmentedArrayBufferList<flag>* source) {\n@@ -78,1 +78,2 @@\n-bool G1CardSetFreePool::G1ReturnMemoryProcessor::return_to_vm(jlong deadline) {\n+template<MEMFLAGS flag>\n+bool G1SegmentedArrayFreePool<flag>::G1ReturnMemoryProcessor::return_to_vm(jlong deadline) {\n@@ -85,2 +86,2 @@\n-  G1CardSetBuffer* cur = _first;\n-  G1CardSetBuffer* last = nullptr;\n+  G1SegmentedArrayBuffer<flag>* cur = _first;\n+  G1SegmentedArrayBuffer<flag>* last = nullptr;\n@@ -113,1 +114,1 @@\n-  log_trace(gc, task)(\"Card Set Free Memory: Returned to VM %zu buffers size %zu\", keep_num, keep_size);\n+  log_trace(gc, task)(\"Segmented Array Free Memory: Returned to VM %zu buffers size %zu\", keep_num, keep_size);\n@@ -127,1 +128,2 @@\n-bool G1CardSetFreePool::G1ReturnMemoryProcessor::return_to_os(jlong deadline) {\n+template<MEMFLAGS flag>\n+bool G1SegmentedArrayFreePool<flag>::G1ReturnMemoryProcessor::return_to_os(jlong deadline) {\n@@ -136,1 +138,1 @@\n-    G1CardSetBuffer* next = _first->next();\n+    G1SegmentedArrayBuffer<flag>* next = _first->next();\n@@ -148,1 +150,1 @@\n-  log_trace(gc, task)(\"Card Set Free Memory: Return to OS %zu buffers size %zu\", num_delete, mem_size_deleted);\n+  log_trace(gc, task)(\"Segmented Array Free Memory: Return to OS %zu buffers size %zu\", num_delete, mem_size_deleted);\n@@ -153,1 +155,2 @@\n-G1CardSetFreePool G1CardSetFreePool::_freelist_pool(G1CardSetConfiguration::num_mem_object_types());\n+template<MEMFLAGS flag>\n+G1SegmentedArrayFreePool<flag> G1SegmentedArrayFreePool<flag>::_freelist_pool(G1CardSetConfiguration::num_mem_object_types());\n@@ -155,1 +158,2 @@\n-G1CardSetFreePool::G1CardSetFreePool(uint num_free_lists) :\n+template<MEMFLAGS flag>\n+G1SegmentedArrayFreePool<flag>::G1SegmentedArrayFreePool(uint num_free_lists) :\n@@ -158,1 +162,1 @@\n-  _free_lists = NEW_C_HEAP_ARRAY(G1CardSetBufferList, _num_free_lists, mtGC);\n+  _free_lists = NEW_C_HEAP_ARRAY(G1SegmentedArrayBufferList<flag>, _num_free_lists, mtGC);\n@@ -160,1 +164,1 @@\n-    new (&_free_lists[i]) G1CardSetBufferList();\n+    new (&_free_lists[i]) G1SegmentedArrayBufferList<flag>();\n@@ -164,1 +168,2 @@\n-G1CardSetFreePool::~G1CardSetFreePool() {\n+template<MEMFLAGS flag>\n+G1SegmentedArrayFreePool<flag>::~G1SegmentedArrayFreePool() {\n@@ -166,1 +171,1 @@\n-    _free_lists[i].~G1CardSetBufferList();\n+    _free_lists[i].~G1SegmentedArrayBufferList<flag>();\n@@ -171,7 +176,3 @@\n-G1CardSetBufferList* G1CardSetFreePool::free_list(uint i) {\n-  assert(i < _num_free_lists, \"must be\");\n-  return &_free_lists[i];\n-}\n-\n-G1CardSetMemoryStats G1CardSetFreePool::memory_sizes() const {\n-  G1CardSetMemoryStats free_list_stats;\n+template<MEMFLAGS flag>\n+G1SegmentedArrayMemoryStats G1SegmentedArrayFreePool<flag>::memory_sizes() const {\n+  G1SegmentedArrayMemoryStats free_list_stats;\n@@ -181,1 +182,1 @@\n-    free_list_stats._num_buffers[i] = _free_lists[i].num_buffers();\n+    free_list_stats._num_segments[i] = _free_lists[i].num_buffers();\n@@ -186,1 +187,2 @@\n-size_t G1CardSetFreePool::mem_size() const {\n+template<MEMFLAGS flag>\n+size_t G1SegmentedArrayFreePool<flag>::mem_size() const {\n@@ -194,1 +196,2 @@\n-void G1CardSetFreePool::print_on(outputStream* out) {\n+template<MEMFLAGS flag>\n+void G1SegmentedArrayFreePool<flag>::print_on(outputStream* out) {\n@@ -201,0 +204,2 @@\n+\n+template class G1SegmentedArrayFreePool<mtGCCardSet>;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArrayFreePool.cpp","additions":35,"deletions":30,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+\n@@ -31,1 +32,1 @@\n-\/\/ Statistics for a fixed set of buffer lists. Contains the number of buffers and memory\n+\/\/ Statistics for a segmented array. Contains the number of segments and memory\n@@ -34,1 +35,1 @@\n-class G1CardSetMemoryStats {\n+class G1SegmentedArrayMemoryStats {\n@@ -38,1 +39,1 @@\n-  size_t _num_buffers[G1CardSetConfiguration::num_mem_object_types()];\n+  size_t _num_segments[G1CardSetConfiguration::num_mem_object_types()];\n@@ -41,1 +42,1 @@\n-  G1CardSetMemoryStats();\n+  G1SegmentedArrayMemoryStats();\n@@ -43,2 +44,2 @@\n-  void add(G1CardSetMemoryStats const other) {\n-    STATIC_ASSERT(ARRAY_SIZE(_num_buffers) == ARRAY_SIZE(_num_mem_sizes));\n+  void add(G1SegmentedArrayMemoryStats const other) {\n+    STATIC_ASSERT(ARRAY_SIZE(_num_segments) == ARRAY_SIZE(_num_mem_sizes));\n@@ -47,1 +48,1 @@\n-      _num_buffers[i] += other._num_buffers[i];\n+      _num_segments[i] += other._num_segments[i];\n@@ -56,5 +57,4 @@\n-typedef G1SegmentedArrayBuffer<mtGCCardSet> G1CardSetBuffer;\n-typedef G1SegmentedArrayBufferList<mtGCCardSet> G1CardSetBufferList;\n-\n-\/\/ A set of free lists holding memory buffers for use by G1CardSetAllocators.\n-class G1CardSetFreePool {\n+\/\/ A set of free lists holding memory buffers for use by G1SegmentedArray,\n+\/\/ e.g. G1CardSetAllocators::SegmentedArray\n+template<MEMFLAGS flag>\n+class G1SegmentedArrayFreePool {\n@@ -62,1 +62,1 @@\n-  static G1CardSetFreePool _freelist_pool;\n+  static G1SegmentedArrayFreePool<flag> _freelist_pool;\n@@ -65,1 +65,1 @@\n-  G1CardSetBufferList* _free_lists;\n+  G1SegmentedArrayBufferList<flag>* _free_lists;\n@@ -68,2 +68,2 @@\n-  static G1CardSetFreePool* free_list_pool() { return &_freelist_pool; }\n-  static G1CardSetMemoryStats free_list_sizes() { return _freelist_pool.memory_sizes(); }\n+  static G1SegmentedArrayFreePool<flag>* free_list_pool() { return &_freelist_pool; }\n+  static G1SegmentedArrayMemoryStats free_list_sizes() { return _freelist_pool.memory_sizes(); }\n@@ -76,2 +76,2 @@\n-  explicit G1CardSetFreePool(uint num_free_lists);\n-  ~G1CardSetFreePool();\n+  explicit G1SegmentedArrayFreePool<flag>(uint num_free_lists);\n+  ~G1SegmentedArrayFreePool();\n@@ -79,1 +79,4 @@\n-  G1CardSetBufferList* free_list(uint i);\n+  G1SegmentedArrayBufferList<flag>* free_list(uint i) {\n+    assert(i < _num_free_lists, \"must be\");\n+    return &_free_lists[i];\n+  }\n@@ -83,1 +86,1 @@\n-  G1CardSetMemoryStats memory_sizes() const;\n+  G1SegmentedArrayMemoryStats memory_sizes() const;\n@@ -90,3 +93,4 @@\n-\/\/ operating system for a single G1CardSetBufferList.\n-class G1CardSetFreePool::G1ReturnMemoryProcessor : public CHeapObj<mtGC> {\n-  G1CardSetBufferList* _source;\n+\/\/ operating system for a single G1SegmentedArrayBufferList.\n+template<MEMFLAGS flag>\n+class G1SegmentedArrayFreePool<flag>::G1ReturnMemoryProcessor : public CHeapObj<mtGC> {\n+  G1SegmentedArrayBufferList<flag>* _source;\n@@ -95,1 +99,1 @@\n-  G1CardSetBuffer* _first;\n+  G1SegmentedArrayBuffer<flag>* _first;\n@@ -104,4 +108,4 @@\n-  \/\/ Updates the instance members about the given card set buffer list for the purpose\n-  \/\/ of giving back memory. Only necessary members are updated, e.g. if there is\n-  \/\/ nothing to return to the VM, do not set the source list.\n-  void visit_free_list(G1CardSetBufferList* source);\n+  \/\/ Updates the instance members about the given segmented array buffer list for\n+  \/\/ the purpose of giving back memory. Only necessary members are updated,\n+  \/\/ e.g. if there is nothing to return to the VM, do not set the source list.\n+  void visit_free_list(G1SegmentedArrayBufferList<flag>* source);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArrayFreePool.hpp","additions":32,"deletions":28,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -333,1 +333,1 @@\n-    G1CardSetMemoryStats _card_set_stats;\n+    G1SegmentedArrayMemoryStats _card_set_stats;\n@@ -449,1 +449,1 @@\n-    G1CardSetMemoryStats card_set_stats() const {\n+    G1SegmentedArrayMemoryStats card_set_stats() const {\n@@ -459,1 +459,1 @@\n-  G1CardSetMemoryStats _all_card_set_stats;\n+  G1SegmentedArrayMemoryStats _all_card_set_stats;\n@@ -493,1 +493,1 @@\n-  const G1CardSetMemoryStats all_card_set_stats() const {\n+  const G1SegmentedArrayMemoryStats all_card_set_stats() const {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-class G1CardSetMemoryStats;\n@@ -52,0 +51,1 @@\n+class G1SegmentedArrayMemoryStats;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-      G1CardSetMemoryStats _total;\n+      G1SegmentedArrayMemoryStats _total;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-class G1CardSetMemoryManager;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-  _card_set_mm(config, G1CardSetFreePool::free_list_pool()),\n+  _card_set_mm(config, G1SegmentedArrayFreePool<mtGCCardSet>::free_list_pool()),\n@@ -108,0 +108,4 @@\n+G1SegmentedArrayMemoryStats HeapRegionRemSet::card_set_memory_stats() const {\n+  return _card_set_mm.memory_stats();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+class G1CardSetMemoryManager;\n@@ -128,1 +129,1 @@\n-  G1CardSetMemoryStats card_set_memory_stats() const { return _card_set_mm.memory_stats(); }\n+  G1SegmentedArrayMemoryStats card_set_memory_stats() const;\n@@ -145,1 +146,1 @@\n-    return G1CardSet::static_mem_size() + G1CodeRootSet::static_mem_size() + sizeof(G1CardSetFreePool);\n+    return G1CardSet::static_mem_size() + G1CodeRootSet::static_mem_size() + sizeof(G1SegmentedArrayFreePool<mtGCCardSet>);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1SegmentedArrayFreePool.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -215,1 +217,1 @@\n-  G1CardSetFreePool free_pool(config.num_mem_object_types());\n+  G1SegmentedArrayFreePool<mtGCCardSet> free_pool(config.num_mem_object_types());\n@@ -434,1 +436,1 @@\n-  G1CardSetFreePool free_pool(config.num_mem_object_types());\n+  G1SegmentedArrayFreePool<mtGCCardSet> free_pool(config.num_mem_object_types());\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1CardSet.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}