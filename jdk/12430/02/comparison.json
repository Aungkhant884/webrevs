{"files":[{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8301833\n+ * @build Tests\n+ * @build FdlibmTranslit\n+ * @build ExhaustingTests\n+ * @run main ExhaustingTests\n+ * @summary Compare StrictMath.foo and FdlibmTranslit.foo for many inputs.\n+ *\/\n+\n+\/*\n+ * Note on usage: for more exhaustive testing to help validate changes\n+ * to StrictMath, the DEFAULT_SHIFT setting should be set to 0. This\n+ * will test all float values against the unary methods. Running all\n+ * the float values for a single method takes on the order of a minute\n+ * or two. The default setting is a shift of 10, meaning every 1024th\n+ * float value is tested and the overall test runs within the typical\n+ * time expectations of a tier 1 test.\n+ *\/\n+\n+import java.util.function.DoubleBinaryOperator;\n+import java.util.function.DoubleUnaryOperator;\n+\n+public class ExhaustingTests {\n+    public static void main(String... args) {\n+        long failures = 0;\n+\n+        failures += testUnaryMethods();\n+        failures += testBinaryMethods();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Comparing StrictMath and FdlibmTranslit\"\n+                               + \" incurred \" + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private static final int DEFAULT_SHIFT = 10;\n+\n+    \/**\n+     * Test the unary (one-argument) StrictMath methods from FDLIBM.\n+     *\/\n+    private static long testUnaryMethods() {\n+        long failures = 0;\n+        UnaryTestCase[] testCases = {\n+         \/\/ new UnaryTestCase(\"sqrt\",  FdlibmTranslit::sqrt,  StrictMath::sqrt,  DEFAULT_SHIFT),\n+            new UnaryTestCase(\"cbrt\",  FdlibmTranslit::cbrt,  StrictMath::cbrt,  DEFAULT_SHIFT),\n+\n+            new UnaryTestCase(\"log\",   FdlibmTranslit::log,   StrictMath::log,   DEFAULT_SHIFT),\n+            new UnaryTestCase(\"log10\", FdlibmTranslit::log10, StrictMath::log10, DEFAULT_SHIFT),\n+            new UnaryTestCase(\"log1p\", FdlibmTranslit::log1p, StrictMath::log1p, DEFAULT_SHIFT),\n+\n+         \/\/ new UnaryTestCase(\"exp\",   FdlibmTranslit::exp,   StrictMath::exp,   DEFAULT_SHIFT),\n+            new UnaryTestCase(\"expm1\", FdlibmTranslit::expm1, StrictMath::expm1, DEFAULT_SHIFT),\n+\n+         \/\/ new UnaryTestCase(\"sinh\",  FdlibmTranslit::sinh,  StrictMath::sinh,  DEFAULT_SHIFT),\n+         \/\/ new UnaryTestCase(\"cosh\",  FdlibmTranslit::cosh,  StrictMath::cosh,  DEFAULT_SHIFT),\n+         \/\/ new UnaryTestCase(\"tanh\",  FdlibmTranslit::tanh,  StrictMath::tanh,  DEFAULT_SHIFT),\n+\n+         \/\/ new UnaryTestCase(\"sin\",   FdlibmTranslit::sin,   StrictMath::sin,   DEFAULT_SHIFT),\n+         \/\/ new UnaryTestCase(\"cos\",   FdlibmTranslit::cos,   StrictMath::cos,   DEFAULT_SHIFT),\n+         \/\/ new UnaryTestCase(\"tan\",   FdlibmTranslit::tan,   StrictMath::tan,   DEFAULT_SHIFT),\n+\n+         \/\/ new UnaryTestCase(\"asin\",  FdlibmTranslit::asin,  StrictMath::asin,  DEFAULT_SHIFT),\n+         \/\/ new UnaryTestCase(\"acos\",  FdlibmTranslit::acos,  StrictMath::acos,  DEFAULT_SHIFT),\n+         \/\/ new UnaryTestCase(\"atan\",  FdlibmTranslit::atan,  StrictMath::atan,  DEFAULT_SHIFT),\n+        };\n+\n+        for (var testCase : testCases) {\n+            System.out.println(\"Testing \" + testCase.name());\n+            System.out.flush();\n+            int i = Integer.MAX_VALUE; \/\/ overflow to Integer.MIN_VALUE at start of loop\n+            int increment = 1 << testCase.shiftDistance;\n+            do {\n+                i += increment;\n+                double input = (double)Float.intBitsToFloat(i);\n+                failures += Tests.test(testCase.name(),\n+                                       input,\n+                                       testCase.strictMath,\n+                                       testCase.translit.applyAsDouble(input));\n+            } while (i != Integer.MAX_VALUE);\n+        }\n+        return failures;\n+    }\n+\n+    private static record UnaryTestCase(String name,\n+                                        DoubleUnaryOperator translit,\n+                                        DoubleUnaryOperator strictMath,\n+                                        int shiftDistance) {\n+        UnaryTestCase {\n+            if (shiftDistance < 0 || shiftDistance >= 31) {\n+                throw new IllegalArgumentException(\"Shift out of range\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test the binary (two-argument) StrictMath methods from FDLIBM.\n+     *\/\n+    private static long testBinaryMethods() {\n+        long failures = 0;\n+        \/\/ Note: pow does _not_ have translit a port\n+\n+        \/\/ Shift of 16 for a binary method gives comparable running\n+        \/\/ time to exhaustive testing of a unary method (testing every\n+        \/\/ 2^16 floating point values over two arguments is 2^32\n+        \/\/ probes).\n+        BinaryTestCase[] testCases = {\n+            new BinaryTestCase(\"hypot\", FdlibmTranslit::hypot, StrictMath::hypot, 20, 20),\n+         \/\/ new BinaryTestCase(\"atan2\", FdlibmTranslit::atan2, StrictMath::atan2, 20, 20),\n+        };\n+\n+        for (var testCase : testCases) {\n+            System.out.println(\"Testing \" + testCase.name());\n+            System.out.flush();\n+\n+            int iIncrement = 1 << testCase.xShift;\n+            int jIncrement = 1 << testCase.yShift;\n+\n+            for (long i = Integer.MIN_VALUE; i <= Integer.MAX_VALUE; i += iIncrement) {\n+                for (long j = Integer.MIN_VALUE; j <= Integer.MAX_VALUE; j += jIncrement) {\n+                    double input1 = (double)Float.intBitsToFloat((int)i);\n+                    double input2 = (double)Float.intBitsToFloat((int)j);\n+                    failures += Tests.test(testCase.name(),\n+                                           input1, input2,\n+                                           testCase.strictMath,\n+                                           testCase.translit.applyAsDouble(input1, input2));\n+                }\n+            }\n+        }\n+        return failures;\n+    }\n+\n+    private static record BinaryTestCase(String name,\n+                                         DoubleBinaryOperator translit,\n+                                         DoubleBinaryOperator strictMath,\n+                                         int xShift,\n+                                         int yShift) {\n+        BinaryTestCase {\n+            if (xShift < 0 || xShift >= 31 ||\n+                yShift < 0 || yShift >= 31 ) {\n+                throw new IllegalArgumentException(\"Shift out of range\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/StrictMath\/ExhaustingTests.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"}]}