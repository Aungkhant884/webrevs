{"files":[{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8301833\n+ * @build Tests\n+ * @build FdlibmTranslit\n+ * @build ExhaustingTests\n+ * @run main\/manual ExhaustingTests\n+ * @summary Compare StrictMath.foo and FdlibmTranslit.foo for many inputs.\n+ *\/\n+\n+import java.util.function.DoubleBinaryOperator;\n+import java.util.function.DoubleUnaryOperator;\n+\n+public class ExhaustingTests {\n+    public static void main(String... args) {\n+        long failures = 0;\n+\n+        failures += testUnaryMethods();\n+        failures += testBinaryMethods();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Comparing StrictMath and FdlibmTranslit\"\n+                               + \" incurred \" + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    \/**\n+     * Test the unary (one-argument) StrictMath methods from FDLIBM.\n+     *\/\n+    private static long testUnaryMethods() {\n+        long failures = 0;\n+        UnaryTestCase[] testCases = {\n+         \/\/ new UnaryTestCase(\"sqrt\",  FdlibmTranslit::sqrt,  StrictMath::sqrt),\n+            new UnaryTestCase(\"cbrt\",  FdlibmTranslit::cbrt,  StrictMath::cbrt),\n+\n+         \/\/ new UnaryTestCase(\"log\",   FdlibmTranslit::log,   StrictMath::log),\n+            new UnaryTestCase(\"log10\", FdlibmTranslit::log10, StrictMath::log10),\n+            new UnaryTestCase(\"log1p\", FdlibmTranslit::log1p, StrictMath::log1p),\n+\n+            new UnaryTestCase(\"exp\",   FdlibmTranslit::exp,   StrictMath::exp),\n+            new UnaryTestCase(\"expm1\", FdlibmTranslit::expm1, StrictMath::expm1),\n+\n+         \/\/ new UnaryTestCase(\"sinh\",  FdlibmTranslit::sinh,  StrictMath::sinh),\n+         \/\/ new UnaryTestCase(\"cosh\",  FdlibmTranslit::cosh,  StrictMath::cosh),\n+         \/\/ new UnaryTestCase(\"tanh\",  FdlibmTranslit::tanh,  StrictMath::tanh),\n+\n+         \/\/ new UnaryTestCase(\"sin\",   FdlibmTranslit::sin,   StrictMath::sin),\n+         \/\/ new UnaryTestCase(\"cos\",   FdlibmTranslit::cos,   StrictMath::cos),\n+         \/\/ new UnaryTestCase(\"tan\",   FdlibmTranslit::tan,   StrictMath::tan),\n+\n+         \/\/ new UnaryTestCase(\"asin\",  FdlibmTranslit::asin,  StrictMath::asin),\n+         \/\/ new UnaryTestCase(\"acos\",  FdlibmTranslit::acos,  StrictMath::acos),\n+         \/\/ new UnaryTestCase(\"atan\",  FdlibmTranslit::atan,  StrictMath::atan),\n+        };\n+\n+        for (var testCase : testCases) {\n+            System.out.println(\"Testing \" + testCase.name());\n+            System.out.flush();\n+            int i = Integer.MAX_VALUE; \/\/ overflow to Integer.MIN_VALUE at start of loop\n+            do {\n+                i++;\n+                double input = (double)Float.intBitsToFloat(i);\n+                failures += Tests.test(testCase.name(),\n+                                       input,\n+                                       testCase.strictMath,\n+                                       testCase.translit.applyAsDouble(input));\n+            } while (i != Integer.MAX_VALUE);\n+        }\n+        return failures;\n+    }\n+\n+    private static record UnaryTestCase(String name,\n+                                        DoubleUnaryOperator translit,\n+                                        DoubleUnaryOperator strictMath) {}\n+\n+    \/**\n+     * Test the binary (two-argument) StrictMath methods from FDLIBM.\n+     *\/\n+    private static long testBinaryMethods() {\n+        long failures = 0;\n+        \/\/ Note: pow does _not_ have translit a port\n+        BinaryTestCase[] testCases = {\n+            new BinaryTestCase(\"hypot\", FdlibmTranslit::hypot, StrictMath::hypot),\n+         \/\/ new BinaryTestCase(\"atan2\", FdlibmTranslit::atan2, StrictMath::atan2),\n+        };\n+\n+        \/\/ to get 2^32 probes for a binary method, sample every 2^16 float values.\n+        for (var testCase : testCases) {\n+            System.out.println(\"Testing \" + testCase.name());\n+            System.out.flush();\n+\n+            for (long i = Integer.MIN_VALUE; i <= Integer.MAX_VALUE; i += 65_536) {\n+                for (long j = Integer.MIN_VALUE; j <= Integer.MAX_VALUE; j += 65_536) {\n+                    double input1 = (double)Float.intBitsToFloat((int)i);\n+                    double input2 = (double)Float.intBitsToFloat((int)j);\n+                    failures += Tests.test(testCase.name(),\n+                                           input1, input2,\n+                                           testCase.strictMath,\n+                                           testCase.translit.applyAsDouble(input1, input2));\n+                }\n+            }\n+        }\n+        return failures;\n+    }\n+\n+    private static record BinaryTestCase(String name,\n+                                         DoubleBinaryOperator translit,\n+                                         DoubleBinaryOperator strictMath) {}\n+}\n","filename":"test\/jdk\/java\/lang\/StrictMath\/ExhaustingTests.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -89,0 +89,4 @@\n+    public static double exp(double x) {\n+        return Exp.compute(x);\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StrictMath\/FdlibmTranslit.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}