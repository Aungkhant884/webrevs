{"files":[{"patch":"@@ -487,1 +487,2 @@\n-  if (!UseHeavyMonitors && UseRTMForStackLocks && use_rtm) {\n+  if (UseRTMForStackLocks && use_rtm) {\n+    assert(!UseHeavyMonitors, \"+UseHeavyMonitors and +UseRTMForStackLocks are mutually exclusive\");\n@@ -645,1 +646,2 @@\n-  if (!UseHeavyMonitors && UseRTMForStackLocks && use_rtm) {\n+  if (UseRTMForStackLocks && use_rtm) {\n+    assert(!UseHeavyMonitors, \"+UseHeavyMonitors and +UseRTMForStackLocks are mutually exclusive\");\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1708,30 +1708,35 @@\n-    \/\/ Load immediate 1 into swap_reg %rax,\n-    __ movptr(swap_reg, 1);\n-\n-    \/\/ Load (object->mark() | 1) into swap_reg %rax,\n-    __ orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-\n-    \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n-    __ movptr(Address(lock_reg, mark_word_offset), swap_reg);\n-\n-    \/\/ src -> dest iff dest == rax, else rax, <- dest\n-    \/\/ *obj_reg = lock_reg iff *obj_reg == rax, else rax, = *(obj_reg)\n-    __ lock();\n-    __ cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-    __ jcc(Assembler::equal, lock_done);\n-\n-    \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n-    \/\/  1) (mark & 3) == 0, and\n-    \/\/  2) rsp <= mark < mark + os::pagesize()\n-    \/\/ These 3 tests can be done by evaluating the following\n-    \/\/ expression: ((mark - rsp) & (3 - os::vm_page_size())),\n-    \/\/ assuming both stack pointer and pagesize have their\n-    \/\/ least significant 2 bits clear.\n-    \/\/ NOTE: the oopMark is in swap_reg %rax, as the result of cmpxchg\n-\n-    __ subptr(swap_reg, rsp);\n-    __ andptr(swap_reg, 3 - os::vm_page_size());\n-\n-    \/\/ Save the test result, for recursive case, the result is zero\n-    __ movptr(Address(lock_reg, mark_word_offset), swap_reg);\n-    __ jcc(Assembler::notEqual, slow_path_lock);\n+    if (!UseHeavyMonitors) {\n+      \/\/ Load immediate 1 into swap_reg %rax,\n+      __ movptr(swap_reg, 1);\n+\n+      \/\/ Load (object->mark() | 1) into swap_reg %rax,\n+      __ orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+\n+      \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n+      __ movptr(Address(lock_reg, mark_word_offset), swap_reg);\n+\n+      \/\/ src -> dest iff dest == rax, else rax, <- dest\n+      \/\/ *obj_reg = lock_reg iff *obj_reg == rax, else rax, = *(obj_reg)\n+      __ lock();\n+      __ cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+      __ jcc(Assembler::equal, lock_done);\n+\n+      \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n+      \/\/  1) (mark & 3) == 0, and\n+      \/\/  2) rsp <= mark < mark + os::pagesize()\n+      \/\/ These 3 tests can be done by evaluating the following\n+      \/\/ expression: ((mark - rsp) & (3 - os::vm_page_size())),\n+      \/\/ assuming both stack pointer and pagesize have their\n+      \/\/ least significant 2 bits clear.\n+      \/\/ NOTE: the oopMark is in swap_reg %rax, as the result of cmpxchg\n+\n+      __ subptr(swap_reg, rsp);\n+      __ andptr(swap_reg, 3 - os::vm_page_size());\n+\n+      \/\/ Save the test result, for recursive case, the result is zero\n+      __ movptr(Address(lock_reg, mark_word_offset), swap_reg);\n+      __ jcc(Assembler::notEqual, slow_path_lock);\n+    } else {\n+      __ jmp(slow_path_lock);\n+    }\n+\n@@ -1855,1 +1860,2 @@\n-    \/\/ Simple recursive lock?\n+    if (!UseHeavyMonitors) {\n+      \/\/ Simple recursive lock?\n@@ -1857,2 +1863,2 @@\n-    __ cmpptr(Address(rbp, lock_slot_rbp_offset), (int32_t)NULL_WORD);\n-    __ jcc(Assembler::equal, done);\n+      __ cmpptr(Address(rbp, lock_slot_rbp_offset), (int32_t)NULL_WORD);\n+      __ jcc(Assembler::equal, done);\n@@ -1860,4 +1866,4 @@\n-    \/\/ Must save rax, if if it is live now because cmpxchg must use it\n-    if (ret_type != T_FLOAT && ret_type != T_DOUBLE && ret_type != T_VOID) {\n-      save_native_result(masm, ret_type, stack_slots);\n-    }\n+      \/\/ Must save rax, if if it is live now because cmpxchg must use it\n+      if (ret_type != T_FLOAT && ret_type != T_DOUBLE && ret_type != T_VOID) {\n+        save_native_result(masm, ret_type, stack_slots);\n+      }\n@@ -1865,2 +1871,2 @@\n-    \/\/  get old displaced header\n-    __ movptr(rbx, Address(rbp, lock_slot_rbp_offset));\n+      \/\/  get old displaced header\n+      __ movptr(rbx, Address(rbp, lock_slot_rbp_offset));\n@@ -1868,2 +1874,2 @@\n-    \/\/ get address of the stack lock\n-    __ lea(rax, Address(rbp, lock_slot_rbp_offset));\n+      \/\/ get address of the stack lock\n+      __ lea(rax, Address(rbp, lock_slot_rbp_offset));\n@@ -1871,6 +1877,9 @@\n-    \/\/ Atomic swap old header if oop still contains the stack lock\n-    \/\/ src -> dest iff dest == rax, else rax, <- dest\n-    \/\/ *obj_reg = rbx, iff *obj_reg == rax, else rax, = *(obj_reg)\n-    __ lock();\n-    __ cmpxchgptr(rbx, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-    __ jcc(Assembler::notEqual, slow_path_unlock);\n+      \/\/ Atomic swap old header if oop still contains the stack lock\n+      \/\/ src -> dest iff dest == rax, else rax, <- dest\n+      \/\/ *obj_reg = rbx, iff *obj_reg == rax, else rax, = *(obj_reg)\n+      __ lock();\n+      __ cmpxchgptr(rbx, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+      __ jcc(Assembler::notEqual, slow_path_unlock);\n+    } else {\n+      __ jmp(slow_path_unlock);\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":56,"deletions":47,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2024,0 +2024,11 @@\n+#ifndef X86\n+  if (UseHeavyMonitors) {\n+    warning(\"UseHeavyMonitors is not fully implemented on this architecture\");\n+  }\n+#endif\n+ if (UseHeavyMonitors && UseRTMForStackLocks) {\n+    fatal(\"-XX:+UseHeavyMonitors and -XX:+UseRTMForStackLocks are mutually exclusive\");\n+  }\n+  if (VerifyHeavyMonitors && !UseHeavyMonitors) {\n+    fatal(\"-XX:+VerifyHeavyMonitors requires -XX:+UseHeavyMonitors\");\n+  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1069,1 +1069,2 @@\n-          \"use heavyweight instead of lightweight Java monitors\")           \\\n+          \"(Deprecated) Use heavyweight instead of lightweight Java \"       \\\n+          \"monitors\")                                                       \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -442,1 +442,1 @@\n-    current->is_lock_owned((address)mark.locker())) {\n+               current->is_lock_owned((address)mark.locker())) {\n@@ -816,1 +816,2 @@\n-    if (UseHeavyMonitors && VerifyHeavyMonitors) {\n+    if (VerifyHeavyMonitors) {\n+      assert(UseHeavyMonitors, \"+VerifyHeavyMonitors requires +UseHeavyMonitors\");\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+ * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\"\n@@ -52,1 +53,1 @@\n- * @run main\/othervm\/timeout=1600 -XX:+IgnoreUnrecognizedVMOptions -XX:+UseHeavyMonitors MapLoops\n+ * @run main\/othervm\/timeout=1600 -XX:+IgnoreUnrecognizedVMOptions -XX:+UseHeavyMonitors -XX:+VerifyHeavyMonitors MapLoops\n","filename":"test\/jdk\/java\/util\/concurrent\/ConcurrentHashMap\/MapLoops.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}