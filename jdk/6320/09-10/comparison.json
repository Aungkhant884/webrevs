{"files":[{"patch":"@@ -2663,21 +2663,26 @@\n-  \/\/ Set displaced_header to be (markWord of object | UNLOCK_VALUE).\n-  ori(displaced_header, displaced_header, markWord::unlocked_value);\n-\n-  \/\/ Load Compare Value application register.\n-\n-  \/\/ Initialize the box. (Must happen before we update the object mark!)\n-  std(displaced_header, BasicLock::displaced_header_offset_in_bytes(), box);\n-\n-  \/\/ Must fence, otherwise, preceding store(s) may float below cmpxchg.\n-  \/\/ Compare object markWord with mark and if equal exchange scratch1 with object markWord.\n-  cmpxchgd(\/*flag=*\/flag,\n-           \/*current_value=*\/current_header,\n-           \/*compare_value=*\/displaced_header,\n-           \/*exchange_value=*\/box,\n-           \/*where=*\/oop,\n-           MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-           MacroAssembler::cmpxchgx_hint_acquire_lock(),\n-           noreg,\n-           &cas_failed,\n-           \/*check without membar and ldarx first*\/true);\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+  if (!UseHeavyMonitors) {\n+    \/\/ Set displaced_header to be (markWord of object | UNLOCK_VALUE).\n+    ori(displaced_header, displaced_header, markWord::unlocked_value);\n+\n+    \/\/ Load Compare Value application register.\n+\n+    \/\/ Initialize the box. (Must happen before we update the object mark!)\n+    std(displaced_header, BasicLock::displaced_header_offset_in_bytes(), box);\n+\n+    \/\/ Must fence, otherwise, preceding store(s) may float below cmpxchg.\n+    \/\/ Compare object markWord with mark and if equal exchange scratch1 with object markWord.\n+    cmpxchgd(\/*flag=*\/flag,\n+             \/*current_value=*\/current_header,\n+             \/*compare_value=*\/displaced_header,\n+             \/*exchange_value=*\/box,\n+             \/*where=*\/oop,\n+             MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n+             MacroAssembler::cmpxchgx_hint_acquire_lock(),\n+             noreg,\n+             &cas_failed,\n+             \/*check without membar and ldarx first*\/true);\n+    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+  } else {\n+    \/\/ Set NE to indicate 'failure' -> take slow-path.\n+    crandc(flag, Assembler::equal, flag, Assembler::equal);\n+  }\n@@ -2771,2 +2776,3 @@\n-  \/\/ Find the lock address and load the displaced header from the stack.\n-  ld(displaced_header, BasicLock::displaced_header_offset_in_bytes(), box);\n+  if (!UseHeavyMonitors) {\n+    \/\/ Find the lock address and load the displaced header from the stack.\n+    ld(displaced_header, BasicLock::displaced_header_offset_in_bytes(), box);\n@@ -2774,3 +2780,4 @@\n-  \/\/ If the displaced header is 0, we have a recursive unlock.\n-  cmpdi(flag, displaced_header, 0);\n-  beq(flag, cont);\n+    \/\/ If the displaced header is 0, we have a recursive unlock.\n+    cmpdi(flag, displaced_header, 0);\n+    beq(flag, cont);\n+  }\n@@ -2785,14 +2792,18 @@\n-  \/\/ Check if it is still a light weight lock, this is is true if we see\n-  \/\/ the stack address of the basicLock in the markWord of the object.\n-  \/\/ Cmpxchg sets flag to cmpd(current_header, box).\n-  cmpxchgd(\/*flag=*\/flag,\n-           \/*current_value=*\/current_header,\n-           \/*compare_value=*\/box,\n-           \/*exchange_value=*\/displaced_header,\n-           \/*where=*\/oop,\n-           MacroAssembler::MemBarRel,\n-           MacroAssembler::cmpxchgx_hint_release_lock(),\n-           noreg,\n-           &cont);\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+  if (!UseHeavyMonitors) {\n+    \/\/ Check if it is still a light weight lock, this is is true if we see\n+    \/\/ the stack address of the basicLock in the markWord of the object.\n+    \/\/ Cmpxchg sets flag to cmpd(current_header, box).\n+    cmpxchgd(\/*flag=*\/flag,\n+             \/*current_value=*\/current_header,\n+             \/*compare_value=*\/box,\n+             \/*exchange_value=*\/displaced_header,\n+             \/*where=*\/oop,\n+             MacroAssembler::MemBarRel,\n+             MacroAssembler::cmpxchgx_hint_release_lock(),\n+             noreg,\n+             &cont);\n+    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+  } else {\n+    \/\/ Set NE to indicate 'failure' -> take slow-path.\n+    crandc(flag, Assembler::equal, flag, Assembler::equal);\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":51,"deletions":40,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -2024,1 +2024,1 @@\n-#if !defined(X86) && !defined(AARCH64)\n+#if !defined(X86) && !defined(AARCH64) && !defined(PPC64)\n@@ -2029,1 +2029,1 @@\n-#ifdef X86\n+#if defined(X86) || defined(PPC64)\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -421,1 +421,1 @@\n-#if defined(X86) || defined(AARCH64)\n+#if defined(X86) || defined(AARCH64) || defined(PPC64)\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n- * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch == \"ppc64\" | os.arch == \"ppc64le\"\n","filename":"test\/jdk\/java\/util\/concurrent\/ConcurrentHashMap\/MapLoops.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}