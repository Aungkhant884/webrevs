{"files":[{"patch":"@@ -3909,31 +3909,34 @@\n-    \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n-    __ orr(tmp, disp_hdr, markWord::unlocked_value);\n-\n-    \/\/ Initialize the box. (Must happen before we update the object mark!)\n-    __ str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-    \/\/ Compare object markWord with an unlocked value (tmp) and if\n-    \/\/ equal exchange the stack address of our box with object markWord.\n-    \/\/ On failure disp_hdr contains the possibly locked markWord.\n-    __ cmpxchg(oop, tmp, box, Assembler::xword, \/*acquire*\/ true,\n-               \/*release*\/ true, \/*weak*\/ false, disp_hdr);\n-    __ br(Assembler::EQ, cont);\n-\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-    \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-    \/\/ object, will have now locked it will continue at label cont\n-\n-    __ bind(cas_failed);\n-    \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n-    \/\/ Check if the owner is self by comparing the value in the\n-    \/\/ markWord of object (disp_hdr) with the stack pointer.\n-    __ mov(rscratch1, sp);\n-    __ sub(disp_hdr, disp_hdr, rscratch1);\n-    __ mov(tmp, (address) (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n-    \/\/ If condition is true we are cont and hence we can store 0 as the\n-    \/\/ displaced header in the box, which indicates that it is a recursive lock.\n-    __ ands(tmp\/*==0?*\/, disp_hdr, tmp);   \/\/ Sets flags for result\n-    __ str(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n+    if (!UseHeavyMonitors) {\n+      \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n+      __ orr(tmp, disp_hdr, markWord::unlocked_value);\n+\n+      \/\/ Initialize the box. (Must happen before we update the object mark!)\n+      __ str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+\n+      \/\/ Compare object markWord with an unlocked value (tmp) and if\n+      \/\/ equal exchange the stack address of our box with object markWord.\n+      \/\/ On failure disp_hdr contains the possibly locked markWord.\n+      __ cmpxchg(oop, tmp, box, Assembler::xword, \/*acquire*\/ true,\n+                 \/*release*\/ true, \/*weak*\/ false, disp_hdr);\n+      __ br(Assembler::EQ, cont);\n+\n+      assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+\n+      \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n+      \/\/ object, will have now locked it will continue at label cont\n+\n+      __ bind(cas_failed);\n+      \/\/ We did not see an unlocked object so try the fast recursive case.\n+\n+      \/\/ Check if the owner is self by comparing the value in the\n+      \/\/ markWord of object (disp_hdr) with the stack pointer.\n+      __ mov(rscratch1, sp);\n+      __ sub(disp_hdr, disp_hdr, rscratch1);\n+      __ mov(tmp, (address) (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n+      \/\/ If condition is true we are cont and hence we can store 0 as the\n+      \/\/ displaced header in the box, which indicates that it is a recursive lock.\n+      __ ands(tmp\/*==0?*\/, disp_hdr, tmp);   \/\/ Sets flags for result\n+      __ str(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+    } else {\n+      __ tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n+    }\n@@ -3985,2 +3988,3 @@\n-    \/\/ Find the lock address and load the displaced header from the stack.\n-    __ ldr(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+    if (!UseHeavyMonitors) {\n+      \/\/ Find the lock address and load the displaced header from the stack.\n+      __ ldr(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n@@ -3988,3 +3992,4 @@\n-    \/\/ If the displaced header is 0, we have a recursive unlock.\n-    __ cmp(disp_hdr, zr);\n-    __ br(Assembler::EQ, cont);\n+      \/\/ If the displaced header is 0, we have a recursive unlock.\n+      __ cmp(disp_hdr, zr);\n+      __ br(Assembler::EQ, cont);\n+    }\n@@ -3996,3 +4001,4 @@\n-    \/\/ Check if it is still a light weight lock, this is is true if we\n-    \/\/ see the stack address of the basicLock in the markWord of the\n-    \/\/ object.\n+    if (!UseHeavyMonitors) {\n+      \/\/ Check if it is still a light weight lock, this is is true if we\n+      \/\/ see the stack address of the basicLock in the markWord of the\n+      \/\/ object.\n@@ -4000,2 +4006,5 @@\n-    __ cmpxchg(oop, box, disp_hdr, Assembler::xword, \/*acquire*\/ false,\n-               \/*release*\/ true, \/*weak*\/ false, tmp);\n+      __ cmpxchg(oop, box, disp_hdr, Assembler::xword, \/*acquire*\/ false,\n+                 \/*release*\/ true, \/*weak*\/ false, tmp);\n+    } else {\n+      __ tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":50,"deletions":41,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -442,1 +442,5 @@\n-    __ unlock_object(r5, r4, r0, *stub->entry());\n+    if (UseHeavyMonitors) {\n+      __ b(*stub->entry());\n+    } else {\n+      __ unlock_object(r5, r4, r0, *stub->entry());\n+    }\n@@ -2566,1 +2570,1 @@\n-  if (!UseFastLocking) {\n+  if (UseHeavyMonitors) {\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1645,3 +1645,4 @@\n-    \/\/ Load (object->mark() | 1) into swap_reg %r0\n-    __ ldr(rscratch1, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-    __ orr(swap_reg, rscratch1, 1);\n+    if (!UseHeavyMonitors) {\n+      \/\/ Load (object->mark() | 1) into swap_reg %r0\n+      __ ldr(rscratch1, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+      __ orr(swap_reg, rscratch1, 1);\n@@ -1649,2 +1650,2 @@\n-    \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n-    __ str(swap_reg, Address(lock_reg, mark_word_offset));\n+      \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n+      __ str(swap_reg, Address(lock_reg, mark_word_offset));\n@@ -1652,4 +1653,4 @@\n-    \/\/ src -> dest iff dest == r0 else r0 <- dest\n-    { Label here;\n-      __ cmpxchg_obj_header(r0, lock_reg, obj_reg, rscratch1, lock_done, \/*fallthrough*\/NULL);\n-    }\n+      \/\/ src -> dest iff dest == r0 else r0 <- dest\n+      { Label here;\n+        __ cmpxchg_obj_header(r0, lock_reg, obj_reg, rscratch1, lock_done, \/*fallthrough*\/NULL);\n+      }\n@@ -1657,1 +1658,1 @@\n-    \/\/ Hmm should this move to the slow path code area???\n+      \/\/ Hmm should this move to the slow path code area???\n@@ -1659,8 +1660,8 @@\n-    \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n-    \/\/  1) (mark & 3) == 0, and\n-    \/\/  2) sp <= mark < mark + os::pagesize()\n-    \/\/ These 3 tests can be done by evaluating the following\n-    \/\/ expression: ((mark - sp) & (3 - os::vm_page_size())),\n-    \/\/ assuming both stack pointer and pagesize have their\n-    \/\/ least significant 2 bits clear.\n-    \/\/ NOTE: the oopMark is in swap_reg %r0 as the result of cmpxchg\n+      \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n+      \/\/  1) (mark & 3) == 0, and\n+      \/\/  2) sp <= mark < mark + os::pagesize()\n+      \/\/ These 3 tests can be done by evaluating the following\n+      \/\/ expression: ((mark - sp) & (3 - os::vm_page_size())),\n+      \/\/ assuming both stack pointer and pagesize have their\n+      \/\/ least significant 2 bits clear.\n+      \/\/ NOTE: the oopMark is in swap_reg %r0 as the result of cmpxchg\n@@ -1668,3 +1669,3 @@\n-    __ sub(swap_reg, sp, swap_reg);\n-    __ neg(swap_reg, swap_reg);\n-    __ ands(swap_reg, swap_reg, 3 - os::vm_page_size());\n+      __ sub(swap_reg, sp, swap_reg);\n+      __ neg(swap_reg, swap_reg);\n+      __ ands(swap_reg, swap_reg, 3 - os::vm_page_size());\n@@ -1672,3 +1673,6 @@\n-    \/\/ Save the test result, for recursive case, the result is zero\n-    __ str(swap_reg, Address(lock_reg, mark_word_offset));\n-    __ br(Assembler::NE, slow_path_lock);\n+      \/\/ Save the test result, for recursive case, the result is zero\n+      __ str(swap_reg, Address(lock_reg, mark_word_offset));\n+      __ br(Assembler::NE, slow_path_lock);\n+    } else {\n+      __ b(slow_path_lock);\n+    }\n@@ -1677,1 +1681,0 @@\n-\n@@ -1778,1 +1781,0 @@\n-    \/\/ Simple recursive lock?\n@@ -1780,2 +1782,4 @@\n-    __ ldr(rscratch1, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));\n-    __ cbz(rscratch1, done);\n+    if (!UseHeavyMonitors) {\n+      \/\/ Simple recursive lock?\n+      __ ldr(rscratch1, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));\n+      __ cbz(rscratch1, done);\n@@ -1783,4 +1787,4 @@\n-    \/\/ Must save r0 if if it is live now because cmpxchg must use it\n-    if (ret_type != T_FLOAT && ret_type != T_DOUBLE && ret_type != T_VOID) {\n-      save_native_result(masm, ret_type, stack_slots);\n-    }\n+      \/\/ Must save r0 if if it is live now because cmpxchg must use it\n+      if (ret_type != T_FLOAT && ret_type != T_DOUBLE && ret_type != T_VOID) {\n+        save_native_result(masm, ret_type, stack_slots);\n+      }\n@@ -1789,4 +1793,4 @@\n-    \/\/ get address of the stack lock\n-    __ lea(r0, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));\n-    \/\/  get old displaced header\n-    __ ldr(old_hdr, Address(r0, 0));\n+      \/\/ get address of the stack lock\n+      __ lea(r0, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));\n+      \/\/  get old displaced header\n+      __ ldr(old_hdr, Address(r0, 0));\n@@ -1794,4 +1798,7 @@\n-    \/\/ Atomic swap old header if oop still contains the stack lock\n-    Label succeed;\n-    __ cmpxchg_obj_header(r0, old_hdr, obj_reg, rscratch1, succeed, &slow_path_unlock);\n-    __ bind(succeed);\n+      \/\/ Atomic swap old header if oop still contains the stack lock\n+      Label succeed;\n+      __ cmpxchg_obj_header(r0, old_hdr, obj_reg, rscratch1, succeed, &slow_path_unlock);\n+      __ bind(succeed);\n+    } else {\n+      __ b(slow_path_unlock);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":47,"deletions":40,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2428,1 +2428,1 @@\n-  if (!UseFastLocking) {\n+  if (UseHeavyMonitors) {\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2692,1 +2692,1 @@\n-    if (UseFastLocking) {\n+    if (!UseHeavyMonitors) {\n@@ -2714,1 +2714,1 @@\n-    if (UseFastLocking) {\n+    if (!UseHeavyMonitors) {\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2733,1 +2733,1 @@\n-  if (!UseFastLocking) {\n+  if (UseHeavyMonitors) {\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -464,1 +464,5 @@\n-    __ unlock_object(rdi, rsi, rax, *stub->entry());\n+    if (UseHeavyMonitors) {\n+      __ jmp(*stub->entry());\n+    } else {\n+      __ unlock_object(rdi, rsi, rax, *stub->entry());\n+    }\n@@ -3501,1 +3505,1 @@\n-  if (!UseFastLocking) {\n+  if (UseHeavyMonitors) {\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -488,0 +488,1 @@\n+    assert(!UseHeavyMonitors, \"+UseHeavyMonitors and +UseRTMForStackLocks are mutually exclusive\");\n@@ -498,14 +499,19 @@\n-  \/\/ Attempt stack-locking ...\n-  orptr (tmpReg, markWord::unlocked_value);\n-  movptr(Address(boxReg, 0), tmpReg);          \/\/ Anticipate successful CAS\n-  lock();\n-  cmpxchgptr(boxReg, Address(objReg, oopDesc::mark_offset_in_bytes()));      \/\/ Updates tmpReg\n-  jcc(Assembler::equal, DONE_LABEL);           \/\/ Success\n-\n-  \/\/ Recursive locking.\n-  \/\/ The object is stack-locked: markword contains stack pointer to BasicLock.\n-  \/\/ Locked by current thread if difference with current SP is less than one page.\n-  subptr(tmpReg, rsp);\n-  \/\/ Next instruction set ZFlag == 1 (Success) if difference is less then one page.\n-  andptr(tmpReg, (int32_t) (NOT_LP64(0xFFFFF003) LP64_ONLY(7 - os::vm_page_size())) );\n-  movptr(Address(boxReg, 0), tmpReg);\n+  if (!UseHeavyMonitors) {\n+    \/\/ Attempt stack-locking ...\n+    orptr (tmpReg, markWord::unlocked_value);\n+    movptr(Address(boxReg, 0), tmpReg);          \/\/ Anticipate successful CAS\n+    lock();\n+    cmpxchgptr(boxReg, Address(objReg, oopDesc::mark_offset_in_bytes()));      \/\/ Updates tmpReg\n+    jcc(Assembler::equal, DONE_LABEL);           \/\/ Success\n+\n+    \/\/ Recursive locking.\n+    \/\/ The object is stack-locked: markword contains stack pointer to BasicLock.\n+    \/\/ Locked by current thread if difference with current SP is less than one page.\n+    subptr(tmpReg, rsp);\n+    \/\/ Next instruction set ZFlag == 1 (Success) if difference is less then one page.\n+    andptr(tmpReg, (int32_t) (NOT_LP64(0xFFFFF003) LP64_ONLY(7 - os::vm_page_size())) );\n+    movptr(Address(boxReg, 0), tmpReg);\n+  } else {\n+    \/\/ Clear ZF so that we take the slow path at the DONE label. objReg is known to be not 0.\n+    testptr(objReg, objReg);\n+  }\n@@ -641,0 +647,1 @@\n+    assert(!UseHeavyMonitors, \"+UseHeavyMonitors and +UseRTMForStackLocks are mutually exclusive\");\n@@ -652,2 +659,4 @@\n-  cmpptr(Address(boxReg, 0), (int32_t)NULL_WORD);                   \/\/ Examine the displaced header\n-  jcc   (Assembler::zero, DONE_LABEL);                              \/\/ 0 indicates recursive stack-lock\n+  if (!UseHeavyMonitors) {\n+    cmpptr(Address(boxReg, 0), (int32_t)NULL_WORD);                   \/\/ Examine the displaced header\n+    jcc   (Assembler::zero, DONE_LABEL);                              \/\/ 0 indicates recursive stack-lock\n+  }\n@@ -655,2 +664,4 @@\n-  testptr(tmpReg, markWord::monitor_value);                         \/\/ Inflated?\n-  jccb  (Assembler::zero, Stacked);\n+  if (!UseHeavyMonitors) {\n+    testptr(tmpReg, markWord::monitor_value);                         \/\/ Inflated?\n+    jccb  (Assembler::zero, Stacked);\n+  }\n@@ -798,5 +809,6 @@\n-  bind  (Stacked);\n-  movptr(tmpReg, Address (boxReg, 0));      \/\/ re-fetch\n-  lock();\n-  cmpxchgptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); \/\/ Uses RAX which is box\n-\n+  if (!UseHeavyMonitors) {\n+    bind  (Stacked);\n+    movptr(tmpReg, Address (boxReg, 0));      \/\/ re-fetch\n+    lock();\n+    cmpxchgptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); \/\/ Uses RAX which is box\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":35,"deletions":23,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1708,30 +1708,35 @@\n-    \/\/ Load immediate 1 into swap_reg %rax,\n-    __ movptr(swap_reg, 1);\n-\n-    \/\/ Load (object->mark() | 1) into swap_reg %rax,\n-    __ orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-\n-    \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n-    __ movptr(Address(lock_reg, mark_word_offset), swap_reg);\n-\n-    \/\/ src -> dest iff dest == rax, else rax, <- dest\n-    \/\/ *obj_reg = lock_reg iff *obj_reg == rax, else rax, = *(obj_reg)\n-    __ lock();\n-    __ cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-    __ jcc(Assembler::equal, lock_done);\n-\n-    \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n-    \/\/  1) (mark & 3) == 0, and\n-    \/\/  2) rsp <= mark < mark + os::pagesize()\n-    \/\/ These 3 tests can be done by evaluating the following\n-    \/\/ expression: ((mark - rsp) & (3 - os::vm_page_size())),\n-    \/\/ assuming both stack pointer and pagesize have their\n-    \/\/ least significant 2 bits clear.\n-    \/\/ NOTE: the oopMark is in swap_reg %rax, as the result of cmpxchg\n-\n-    __ subptr(swap_reg, rsp);\n-    __ andptr(swap_reg, 3 - os::vm_page_size());\n-\n-    \/\/ Save the test result, for recursive case, the result is zero\n-    __ movptr(Address(lock_reg, mark_word_offset), swap_reg);\n-    __ jcc(Assembler::notEqual, slow_path_lock);\n+    if (!UseHeavyMonitors) {\n+      \/\/ Load immediate 1 into swap_reg %rax,\n+      __ movptr(swap_reg, 1);\n+\n+      \/\/ Load (object->mark() | 1) into swap_reg %rax,\n+      __ orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+\n+      \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n+      __ movptr(Address(lock_reg, mark_word_offset), swap_reg);\n+\n+      \/\/ src -> dest iff dest == rax, else rax, <- dest\n+      \/\/ *obj_reg = lock_reg iff *obj_reg == rax, else rax, = *(obj_reg)\n+      __ lock();\n+      __ cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+      __ jcc(Assembler::equal, lock_done);\n+\n+      \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n+      \/\/  1) (mark & 3) == 0, and\n+      \/\/  2) rsp <= mark < mark + os::pagesize()\n+      \/\/ These 3 tests can be done by evaluating the following\n+      \/\/ expression: ((mark - rsp) & (3 - os::vm_page_size())),\n+      \/\/ assuming both stack pointer and pagesize have their\n+      \/\/ least significant 2 bits clear.\n+      \/\/ NOTE: the oopMark is in swap_reg %rax, as the result of cmpxchg\n+\n+      __ subptr(swap_reg, rsp);\n+      __ andptr(swap_reg, 3 - os::vm_page_size());\n+\n+      \/\/ Save the test result, for recursive case, the result is zero\n+      __ movptr(Address(lock_reg, mark_word_offset), swap_reg);\n+      __ jcc(Assembler::notEqual, slow_path_lock);\n+    } else {\n+      __ jmp(slow_path_lock);\n+    }\n+\n@@ -1855,1 +1860,2 @@\n-    \/\/ Simple recursive lock?\n+    if (!UseHeavyMonitors) {\n+      \/\/ Simple recursive lock?\n@@ -1857,2 +1863,2 @@\n-    __ cmpptr(Address(rbp, lock_slot_rbp_offset), (int32_t)NULL_WORD);\n-    __ jcc(Assembler::equal, done);\n+      __ cmpptr(Address(rbp, lock_slot_rbp_offset), (int32_t)NULL_WORD);\n+      __ jcc(Assembler::equal, done);\n@@ -1860,4 +1866,4 @@\n-    \/\/ Must save rax, if if it is live now because cmpxchg must use it\n-    if (ret_type != T_FLOAT && ret_type != T_DOUBLE && ret_type != T_VOID) {\n-      save_native_result(masm, ret_type, stack_slots);\n-    }\n+      \/\/ Must save rax, if if it is live now because cmpxchg must use it\n+      if (ret_type != T_FLOAT && ret_type != T_DOUBLE && ret_type != T_VOID) {\n+        save_native_result(masm, ret_type, stack_slots);\n+      }\n@@ -1865,2 +1871,2 @@\n-    \/\/  get old displaced header\n-    __ movptr(rbx, Address(rbp, lock_slot_rbp_offset));\n+      \/\/  get old displaced header\n+      __ movptr(rbx, Address(rbp, lock_slot_rbp_offset));\n@@ -1868,2 +1874,2 @@\n-    \/\/ get address of the stack lock\n-    __ lea(rax, Address(rbp, lock_slot_rbp_offset));\n+      \/\/ get address of the stack lock\n+      __ lea(rax, Address(rbp, lock_slot_rbp_offset));\n@@ -1871,6 +1877,9 @@\n-    \/\/ Atomic swap old header if oop still contains the stack lock\n-    \/\/ src -> dest iff dest == rax, else rax, <- dest\n-    \/\/ *obj_reg = rbx, iff *obj_reg == rax, else rax, = *(obj_reg)\n-    __ lock();\n-    __ cmpxchgptr(rbx, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-    __ jcc(Assembler::notEqual, slow_path_unlock);\n+      \/\/ Atomic swap old header if oop still contains the stack lock\n+      \/\/ src -> dest iff dest == rax, else rax, <- dest\n+      \/\/ *obj_reg = rbx, iff *obj_reg == rax, else rax, = *(obj_reg)\n+      __ lock();\n+      __ cmpxchgptr(rbx, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+      __ jcc(Assembler::notEqual, slow_path_unlock);\n+    } else {\n+      __ jmp(slow_path_unlock);\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":56,"deletions":47,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -1921,31 +1921,35 @@\n-    \/\/ Load immediate 1 into swap_reg %rax\n-    __ movl(swap_reg, 1);\n-\n-    \/\/ Load (object->mark() | 1) into swap_reg %rax\n-    __ orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-\n-    \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n-    __ movptr(Address(lock_reg, mark_word_offset), swap_reg);\n-\n-    \/\/ src -> dest iff dest == rax else rax <- dest\n-    __ lock();\n-    __ cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-    __ jcc(Assembler::equal, lock_done);\n-\n-    \/\/ Hmm should this move to the slow path code area???\n-\n-    \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n-    \/\/  1) (mark & 3) == 0, and\n-    \/\/  2) rsp <= mark < mark + os::pagesize()\n-    \/\/ These 3 tests can be done by evaluating the following\n-    \/\/ expression: ((mark - rsp) & (3 - os::vm_page_size())),\n-    \/\/ assuming both stack pointer and pagesize have their\n-    \/\/ least significant 2 bits clear.\n-    \/\/ NOTE: the oopMark is in swap_reg %rax as the result of cmpxchg\n-\n-    __ subptr(swap_reg, rsp);\n-    __ andptr(swap_reg, 3 - os::vm_page_size());\n-\n-    \/\/ Save the test result, for recursive case, the result is zero\n-    __ movptr(Address(lock_reg, mark_word_offset), swap_reg);\n-    __ jcc(Assembler::notEqual, slow_path_lock);\n+    if (!UseHeavyMonitors) {\n+      \/\/ Load immediate 1 into swap_reg %rax\n+      __ movl(swap_reg, 1);\n+\n+      \/\/ Load (object->mark() | 1) into swap_reg %rax\n+      __ orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+\n+      \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n+      __ movptr(Address(lock_reg, mark_word_offset), swap_reg);\n+\n+      \/\/ src -> dest iff dest == rax else rax <- dest\n+      __ lock();\n+      __ cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+      __ jcc(Assembler::equal, lock_done);\n+\n+      \/\/ Hmm should this move to the slow path code area???\n+\n+      \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n+      \/\/  1) (mark & 3) == 0, and\n+      \/\/  2) rsp <= mark < mark + os::pagesize()\n+      \/\/ These 3 tests can be done by evaluating the following\n+      \/\/ expression: ((mark - rsp) & (3 - os::vm_page_size())),\n+      \/\/ assuming both stack pointer and pagesize have their\n+      \/\/ least significant 2 bits clear.\n+      \/\/ NOTE: the oopMark is in swap_reg %rax as the result of cmpxchg\n+\n+      __ subptr(swap_reg, rsp);\n+      __ andptr(swap_reg, 3 - os::vm_page_size());\n+\n+      \/\/ Save the test result, for recursive case, the result is zero\n+      __ movptr(Address(lock_reg, mark_word_offset), swap_reg);\n+      __ jcc(Assembler::notEqual, slow_path_lock);\n+    } else {\n+      __ jmp(slow_path_lock);\n+    }\n@@ -2058,1 +2062,0 @@\n-    \/\/ Simple recursive lock?\n@@ -2060,2 +2063,4 @@\n-    __ cmpptr(Address(rsp, lock_slot_offset * VMRegImpl::stack_slot_size), (int32_t)NULL_WORD);\n-    __ jcc(Assembler::equal, done);\n+    if (!UseHeavyMonitors) {\n+      \/\/ Simple recursive lock?\n+      __ cmpptr(Address(rsp, lock_slot_offset * VMRegImpl::stack_slot_size), (int32_t)NULL_WORD);\n+      __ jcc(Assembler::equal, done);\n@@ -2063,4 +2068,4 @@\n-    \/\/ Must save rax if if it is live now because cmpxchg must use it\n-    if (ret_type != T_FLOAT && ret_type != T_DOUBLE && ret_type != T_VOID) {\n-      save_native_result(masm, ret_type, stack_slots);\n-    }\n+      \/\/ Must save rax if if it is live now because cmpxchg must use it\n+      if (ret_type != T_FLOAT && ret_type != T_DOUBLE && ret_type != T_VOID) {\n+        save_native_result(masm, ret_type, stack_slots);\n+      }\n@@ -2069,4 +2074,4 @@\n-    \/\/ get address of the stack lock\n-    __ lea(rax, Address(rsp, lock_slot_offset * VMRegImpl::stack_slot_size));\n-    \/\/  get old displaced header\n-    __ movptr(old_hdr, Address(rax, 0));\n+      \/\/ get address of the stack lock\n+      __ lea(rax, Address(rsp, lock_slot_offset * VMRegImpl::stack_slot_size));\n+      \/\/  get old displaced header\n+      __ movptr(old_hdr, Address(rax, 0));\n@@ -2074,4 +2079,7 @@\n-    \/\/ Atomic swap old header if oop still contains the stack lock\n-    __ lock();\n-    __ cmpxchgptr(old_hdr, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-    __ jcc(Assembler::notEqual, slow_path_unlock);\n+      \/\/ Atomic swap old header if oop still contains the stack lock\n+      __ lock();\n+      __ cmpxchgptr(old_hdr, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+      __ jcc(Assembler::notEqual, slow_path_unlock);\n+    } else {\n+      __ jmp(slow_path_unlock);\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":54,"deletions":46,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -623,1 +623,1 @@\n-  CodeStub* slow_path = new MonitorExitStub(lock, UseFastLocking, monitor_no);\n+  CodeStub* slow_path = new MonitorExitStub(lock, !UseHeavyMonitors, monitor_no);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -742,1 +742,1 @@\n-  if (!UseFastLocking) {\n+  if (UseHeavyMonitors) {\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -245,3 +245,0 @@\n-  develop(bool, UseFastLocking, true,                                       \\\n-          \"Use fast inlined locking code\")                                  \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/c1\/c1_globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -535,0 +535,3 @@\n+#ifdef PRODUCT\n+  { \"UseHeavyMonitors\",             JDK_Version::jdk(18), JDK_Version::jdk(19), JDK_Version::jdk(20) },\n+#endif\n@@ -2021,0 +2024,14 @@\n+#if !defined(X86) && !defined(AARCH64)\n+  if (UseHeavyMonitors) {\n+    warning(\"UseHeavyMonitors is not fully implemented on this architecture\");\n+  }\n+#endif\n+#ifdef X86\n+  if (UseHeavyMonitors && UseRTMForStackLocks) {\n+    fatal(\"-XX:+UseHeavyMonitors and -XX:+UseRTMForStackLocks are mutually exclusive\");\n+  }\n+#endif\n+  if (VerifyHeavyMonitors && !UseHeavyMonitors) {\n+    fatal(\"-XX:+VerifyHeavyMonitors requires -XX:+UseHeavyMonitors\");\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1069,1 +1069,6 @@\n-          \"use heavyweight instead of lightweight Java monitors\")           \\\n+          \"(Deprecated) Use heavyweight instead of lightweight Java \"       \\\n+          \"monitors\")                                                       \\\n+                                                                            \\\n+  develop(bool, VerifyHeavyMonitors, false,                                 \\\n+          \"Checks that no stack locking happens when using \"                \\\n+          \"+UseHeavyMonitors\")                                              \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -431,6 +431,15 @@\n-  markWord mark = obj->mark();\n-  if (mark.is_neutral()) {\n-    \/\/ Anticipate successful CAS -- the ST of the displaced mark must\n-    \/\/ be visible <= the ST performed by the CAS.\n-    lock->set_displaced_header(mark);\n-    if (mark == obj()->cas_set_mark(markWord::from_pointer(lock), mark)) {\n+  if (!UseHeavyMonitors) {\n+    markWord mark = obj->mark();\n+    if (mark.is_neutral()) {\n+      \/\/ Anticipate successful CAS -- the ST of the displaced mark must\n+      \/\/ be visible <= the ST performed by the CAS.\n+      lock->set_displaced_header(mark);\n+      if (mark == obj()->cas_set_mark(markWord::from_pointer(lock), mark)) {\n+        return;\n+      }\n+      \/\/ Fall through to inflate() ...\n+    } else if (mark.has_locker() &&\n+               current->is_lock_owned((address)mark.locker())) {\n+      assert(lock != mark.locker(), \"must not re-lock the same lock\");\n+      assert(lock != (BasicLock*)obj->mark().value(), \"don't relock with same BasicLock\");\n+      lock->set_displaced_header(markWord::from_pointer(NULL));\n@@ -439,7 +448,8 @@\n-    \/\/ Fall through to inflate() ...\n-  } else if (mark.has_locker() &&\n-             current->is_lock_owned((address)mark.locker())) {\n-    assert(lock != mark.locker(), \"must not re-lock the same lock\");\n-    assert(lock != (BasicLock*)obj->mark().value(), \"don't relock with same BasicLock\");\n-    lock->set_displaced_header(markWord::from_pointer(NULL));\n-    return;\n+\n+    \/\/ The object header will never be displaced to this lock,\n+    \/\/ so it does not matter what the value is, except that it\n+    \/\/ must be non-zero to avoid looking like a re-entrant lock,\n+    \/\/ and must not look locked either.\n+    lock->set_displaced_header(markWord::unused_mark());\n+  } else if (VerifyHeavyMonitors) {\n+    guarantee(!obj->mark().has_locker(), \"must not be stack-locked\");\n@@ -448,5 +458,0 @@\n-  \/\/ The object header will never be displaced to this lock,\n-  \/\/ so it does not matter what the value is, except that it\n-  \/\/ must be non-zero to avoid looking like a re-entrant lock,\n-  \/\/ and must not look locked either.\n-  lock->set_displaced_header(markWord::unused_mark());\n@@ -465,1 +470,2 @@\n-  markWord mark = object->mark();\n+  if (!UseHeavyMonitors) {\n+    markWord mark = object->mark();\n@@ -467,4 +473,4 @@\n-  markWord dhw = lock->displaced_header();\n-  if (dhw.value() == 0) {\n-    \/\/ If the displaced header is NULL, then this exit matches up with\n-    \/\/ a recursive enter. No real work to do here except for diagnostics.\n+    markWord dhw = lock->displaced_header();\n+    if (dhw.value() == 0) {\n+      \/\/ If the displaced header is NULL, then this exit matches up with\n+      \/\/ a recursive enter. No real work to do here except for diagnostics.\n@@ -472,19 +478,20 @@\n-    if (mark != markWord::INFLATING()) {\n-      \/\/ Only do diagnostics if we are not racing an inflation. Simply\n-      \/\/ exiting a recursive enter of a Java Monitor that is being\n-      \/\/ inflated is safe; see the has_monitor() comment below.\n-      assert(!mark.is_neutral(), \"invariant\");\n-      assert(!mark.has_locker() ||\n-             current->is_lock_owned((address)mark.locker()), \"invariant\");\n-      if (mark.has_monitor()) {\n-        \/\/ The BasicLock's displaced_header is marked as a recursive\n-        \/\/ enter and we have an inflated Java Monitor (ObjectMonitor).\n-        \/\/ This is a special case where the Java Monitor was inflated\n-        \/\/ after this thread entered the stack-lock recursively. When a\n-        \/\/ Java Monitor is inflated, we cannot safely walk the Java\n-        \/\/ Monitor owner's stack and update the BasicLocks because a\n-        \/\/ Java Monitor can be asynchronously inflated by a thread that\n-        \/\/ does not own the Java Monitor.\n-        ObjectMonitor* m = mark.monitor();\n-        assert(m->object()->mark() == mark, \"invariant\");\n-        assert(m->is_entered(current), \"invariant\");\n+      if (mark != markWord::INFLATING()) {\n+        \/\/ Only do diagnostics if we are not racing an inflation. Simply\n+        \/\/ exiting a recursive enter of a Java Monitor that is being\n+        \/\/ inflated is safe; see the has_monitor() comment below.\n+        assert(!mark.is_neutral(), \"invariant\");\n+        assert(!mark.has_locker() ||\n+        current->is_lock_owned((address)mark.locker()), \"invariant\");\n+        if (mark.has_monitor()) {\n+          \/\/ The BasicLock's displaced_header is marked as a recursive\n+          \/\/ enter and we have an inflated Java Monitor (ObjectMonitor).\n+          \/\/ This is a special case where the Java Monitor was inflated\n+          \/\/ after this thread entered the stack-lock recursively. When a\n+          \/\/ Java Monitor is inflated, we cannot safely walk the Java\n+          \/\/ Monitor owner's stack and update the BasicLocks because a\n+          \/\/ Java Monitor can be asynchronously inflated by a thread that\n+          \/\/ does not own the Java Monitor.\n+          ObjectMonitor* m = mark.monitor();\n+          assert(m->object()->mark() == mark, \"invariant\");\n+          assert(m->is_entered(current), \"invariant\");\n+        }\n@@ -492,1 +499,0 @@\n-    }\n@@ -494,8 +500,0 @@\n-    return;\n-  }\n-\n-  if (mark == markWord::from_pointer(lock)) {\n-    \/\/ If the object is stack-locked by the current thread, try to\n-    \/\/ swing the displaced header from the BasicLock back to the mark.\n-    assert(dhw.is_neutral(), \"invariant\");\n-    if (object->cas_set_mark(dhw, mark) == mark) {\n@@ -504,0 +502,11 @@\n+\n+    if (mark == markWord::from_pointer(lock)) {\n+      \/\/ If the object is stack-locked by the current thread, try to\n+      \/\/ swing the displaced header from the BasicLock back to the mark.\n+      assert(dhw.is_neutral(), \"invariant\");\n+      if (object->cas_set_mark(dhw, mark) == mark) {\n+        return;\n+      }\n+    }\n+  } else if (VerifyHeavyMonitors) {\n+    guarantee(!object->mark().has_locker(), \"must not be stack-locked\");\n@@ -807,1 +816,4 @@\n-\n+    if (VerifyHeavyMonitors) {\n+      assert(UseHeavyMonitors, \"+VerifyHeavyMonitors requires +UseHeavyMonitors\");\n+      guarantee(!mark.has_locker(), \"must not be stack locked\");\n+    }\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":64,"deletions":52,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -24,0 +24,4 @@\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+\n+import jdk.test.lib.Platform;\n@@ -42,12 +46,15 @@\n-    public static final String[][] DEPRECATED_OPTIONS = {\n-        \/\/ deprecated non-alias flags:\n-        {\"MaxGCMinorPauseMillis\",     \"1032\"},\n-        {\"MaxRAMFraction\",            \"8\"},\n-        {\"MinRAMFraction\",            \"2\"},\n-        {\"InitialRAMFraction\",        \"64\"},\n-        {\"TLABStats\",                 \"false\"},\n-        {\"AllowRedefinitionToAddDeleteMethods\", \"true\"},\n-        {\"UseSharedSpaces\",           \"false\"},\n-        {\"RequireSharedSpaces\",       \"false\"},\n-        {\"DumpSharedSpaces\",          \"false\"},\n-        {\"DynamicDumpSharedSpaces\",   \"false\"},\n+    public static final String[][] DEPRECATED_OPTIONS;\n+    static {\n+        ArrayList<String[]> deprecated = new ArrayList(\n+          Arrays.asList(new String[][] {\n+            \/\/ deprecated non-alias flags:\n+            {\"MaxGCMinorPauseMillis\",     \"1032\"},\n+            {\"MaxRAMFraction\",            \"8\"},\n+            {\"MinRAMFraction\",            \"2\"},\n+            {\"InitialRAMFraction\",        \"64\"},\n+            {\"TLABStats\",                 \"false\"},\n+            {\"AllowRedefinitionToAddDeleteMethods\", \"true\"},\n+            {\"UseSharedSpaces\",           \"false\"},\n+            {\"RequireSharedSpaces\",       \"false\"},\n+            {\"DumpSharedSpaces\",          \"false\"},\n+            {\"DynamicDumpSharedSpaces\",   \"false\"},\n@@ -55,3 +62,9 @@\n-        \/\/ deprecated alias flags (see also aliased_jvm_flags):\n-        {\"DefaultMaxRAMFraction\", \"4\"},\n-        {\"CreateMinidumpOnCrash\", \"false\"}\n+            \/\/ deprecated alias flags (see also aliased_jvm_flags):\n+            {\"DefaultMaxRAMFraction\", \"4\"},\n+            {\"CreateMinidumpOnCrash\", \"false\"}\n+          }\n+        ));\n+        if (!Platform.isDebugBuild()) {\n+            deprecated.add(new String[]{\"UseHeavyMonitors\", \"false\"});\n+        }\n+        DEPRECATED_OPTIONS = deprecated.toArray(new String[][]{});\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/VMDeprecatedOptions.java","additions":28,"deletions":15,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -48,0 +48,8 @@\n+\/*\n+ * @test\n+ * @summary Exercise multithreaded maps, using only heavy monitors.\n+ * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @library \/test\/lib\n+ * @run main\/othervm\/timeout=1600 -XX:+IgnoreUnrecognizedVMOptions -XX:+UseHeavyMonitors -XX:+VerifyHeavyMonitors MapLoops\n+ *\/\n+\n","filename":"test\/jdk\/java\/util\/concurrent\/ConcurrentHashMap\/MapLoops.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}