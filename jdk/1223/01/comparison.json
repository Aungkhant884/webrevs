{"files":[{"patch":"@@ -96,1 +96,1 @@\n-          range(0, max_jint)                                                \\\n+          range(1, max_jint)                                                \\\n@@ -100,1 +100,1 @@\n-          range(0, max_jint)                                                \\\n+          range(1, max_jint)                                                \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -660,1 +660,1 @@\n-void Node::grow( uint len ) {\n+void Node::grow(uint len) {\n@@ -2266,18 +2266,0 @@\n-\/\/------------------------------walk-------------------------------------------\n-\/\/ Graph walk, with both pre-order and post-order functions\n-void Node::walk(NFunc pre, NFunc post, void *env) {\n-  VectorSet visited; \/\/ Setup for local walk\n-  walk_(pre, post, env, visited);\n-}\n-\n-void Node::walk_(NFunc pre, NFunc post, void *env, VectorSet &visited) {\n-  if( visited.test_set(_idx) ) return;\n-  pre(*this,env);               \/\/ Call the pre-order walk function\n-  for( uint i=0; i<_max; i++ )\n-    if( in(i) )                 \/\/ Input exists and is not walked?\n-      in(i)->walk_(pre,post,env,visited); \/\/ Walk it with pre & post functions\n-  post(*this,env);              \/\/ Call the post-order walk function\n-}\n-\n-void Node::nop(Node &, void*) {}\n-\n@@ -2291,1 +2273,0 @@\n-static RegMask _not_used_at_all;\n@@ -2295,1 +2276,1 @@\n-  return _not_used_at_all;\n+  return RegMask::Empty;\n@@ -2300,1 +2281,1 @@\n-  return _not_used_at_all;\n+  return RegMask::Empty;\n@@ -2303,10 +2284,0 @@\n-\/\/=============================================================================\n-\/\/-----------------------------------------------------------------------------\n-void Node_Array::reset( Arena *new_arena ) {\n-  _a->Afree(_nodes,_max*sizeof(Node*));\n-  _max   = 0;\n-  _nodes = NULL;\n-  _a     = new_arena;\n-}\n-\n-\/\/------------------------------clear------------------------------------------\n@@ -2318,7 +2289,2 @@\n-\/\/-----------------------------------------------------------------------------\n-void Node_Array::grow( uint i ) {\n-  if( !_max ) {\n-    _max = 1;\n-    _nodes = (Node**)_a->Amalloc( _max * sizeof(Node*) );\n-    _nodes[0] = NULL;\n-  }\n+void Node_Array::grow(uint i) {\n+  assert(_max > 0, \"invariant\");\n@@ -2331,4 +2297,5 @@\n-\/\/-----------------------------------------------------------------------------\n-void Node_Array::insert( uint i, Node *n ) {\n-  if( _nodes[_max-1] ) grow(_max);      \/\/ Get more space if full\n-  Copy::conjoint_words_to_higher((HeapWord*)&_nodes[i], (HeapWord*)&_nodes[i+1], ((_max-i-1)*sizeof(Node*)));\n+void Node_Array::insert(uint i, Node* n) {\n+  if (_nodes[_max - 1]) {\n+    grow(_max);\n+  }\n+  Copy::conjoint_words_to_higher((HeapWord*)&_nodes[i], (HeapWord*)&_nodes[i + 1], ((_max - i - 1) * sizeof(Node*)));\n@@ -2338,9 +2305,3 @@\n-\/\/-----------------------------------------------------------------------------\n-void Node_Array::remove( uint i ) {\n-  Copy::conjoint_words_to_lower((HeapWord*)&_nodes[i+1], (HeapWord*)&_nodes[i], ((_max-i-1)*sizeof(Node*)));\n-  _nodes[_max-1] = NULL;\n-}\n-\n-\/\/-----------------------------------------------------------------------------\n-void Node_Array::sort( C_sort_func_t func) {\n-  qsort( _nodes, _max, sizeof( Node* ), func );\n+void Node_Array::remove(uint i) {\n+  Copy::conjoint_words_to_lower((HeapWord*)&_nodes[i + 1], (HeapWord*)&_nodes[i], ((_max - i - 1) * sizeof(Node*)));\n+  _nodes[_max - 1] = NULL;\n@@ -2349,1 +2310,0 @@\n-\/\/-----------------------------------------------------------------------------\n@@ -2352,3 +2312,3 @@\n-  for( uint i = 0; i < _max; i++ ) {\n-    Node *nn = _nodes[i];\n-    if( nn != NULL ) {\n+  for (uint i = 0; i < _max; i++) {\n+    Node* nn = _nodes[i];\n+    if (nn != NULL) {\n@@ -2417,1 +2377,3 @@\n-      if (found != NULL) return NULL;\n+      if (found != NULL) {\n+        return NULL;\n+      }\n@@ -2460,2 +2422,2 @@\n-  for( i = 0; i < _cnt; i++ )\n-    if( _nodes[i] == n )\n+  for (i = 0; i < _cnt; i++) {\n+    if (_nodes[i] == n) {\n@@ -2463,0 +2425,2 @@\n+    }\n+  }\n@@ -2464,1 +2428,1 @@\n-  if( i < _cnt )\n+  if (i < _cnt) {\n@@ -2466,0 +2430,1 @@\n+  }\n@@ -2471,3 +2436,3 @@\n-  for( uint i = 0; i < _cnt; i++ )\n-    if( _nodes[i] ) {\n-      tty->print(\"%5d--> \",i);\n+  for (uint i = 0; i < _cnt; i++) {\n+    if (_nodes[i]) {\n+      tty->print(\"%5d--> \", i);\n@@ -2476,0 +2441,1 @@\n+  }\n@@ -2481,1 +2447,1 @@\n-  for( uint i = 0; i < _cnt; i++ )\n+  for (uint i = 0; i < _cnt; i++) {\n@@ -2487,0 +2453,1 @@\n+  }\n@@ -2508,1 +2475,0 @@\n-\n@@ -2514,5 +2480,1 @@\n-      map(i,Node_List::pop());\n-      \/\/ Node *replacement = Node_List::pop();\n-      \/\/ if( i != size() ) { \/\/ Check if removing last entry\n-      \/\/   _nodes[i] = replacement;\n-      \/\/ }\n+      map(i, Node_List::pop());\n@@ -2538,2 +2500,2 @@\n-  for (uint i=0; i < sz; i++) {\n-    if (idx == index_at(i) )\n+  for (uint i = 0; i < sz; i++) {\n+    if (idx == index_at(i)) {\n@@ -2541,0 +2503,1 @@\n+    }\n@@ -2549,1 +2512,1 @@\n-  if( !Verbose && !WizardMode ) {\n+  if (!Verbose && !WizardMode) {\n@@ -2563,3 +2526,4 @@\n-bool TypeNode::cmp( const Node &n ) const\n-{ return !Type::cmp( _type, ((TypeNode&)n)._type ); }\n-const Type *TypeNode::bottom_type() const { return _type; }\n+bool TypeNode::cmp(const Node& n) const {\n+  return !Type::cmp(_type, ((TypeNode&)n)._type);\n+}\n+const Type* TypeNode::bottom_type() const { return _type; }\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":40,"deletions":76,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -161,4 +161,0 @@\n-typedef void (*NFunc)(Node&,void*);\n-extern \"C\" {\n-  typedef int (*C_sort_func_t)(const void *, const void *);\n-}\n@@ -1120,10 +1116,0 @@\n-\/\/----------------- Graph walking\n-public:\n-  \/\/ Walk and apply member functions recursively.\n-  \/\/ Supplied (this) pointer is root.\n-  void walk(NFunc pre, NFunc post, void *env);\n-  static void nop(Node &, void*); \/\/ Dummy empty function\n-  static void packregion( Node &n, void* );\n-private:\n-  void walk_(NFunc pre, NFunc post, void *env, VectorSet &visited);\n-\n@@ -1132,0 +1118,1 @@\n+ private:\n@@ -1485,1 +1472,1 @@\n-  Arena *_a;                    \/\/ Arena to allocate in\n+  Arena* _a;                    \/\/ Arena to allocate in\n@@ -1487,1 +1474,1 @@\n-  Node **_nodes;\n+  Node** _nodes;\n@@ -1490,3 +1477,3 @@\n-  Node_Array(Arena *a) : _a(a), _max(OptoNodeListSize) {\n-    _nodes = NEW_ARENA_ARRAY( a, Node *, OptoNodeListSize );\n-    for( int i = 0; i < OptoNodeListSize; i++ ) {\n+  Node_Array(Arena* a) : _a(a), _max(OptoNodeListSize) {\n+    _nodes = NEW_ARENA_ARRAY(a, Node*, OptoNodeListSize);\n+    for (int i = 0; i < OptoNodeListSize; i++) {\n@@ -1497,1 +1484,1 @@\n-  Node_Array(Node_Array *na) : _a(na->_a), _max(na->_max), _nodes(na->_nodes) {}\n+  Node_Array(Node_Array* na) : _a(na->_a), _max(na->_max), _nodes(na->_nodes) {}\n@@ -1500,2 +1487,2 @@\n-  Node *at( uint i ) const { assert(i<_max,\"oob\"); return _nodes[i]; }\n-  Node **adr() { return _nodes; }\n+  Node* at(uint i) const { assert(i<_max,\"oob\"); return _nodes[i]; }\n+  Node** adr() { return _nodes; }\n@@ -1506,2 +1493,0 @@\n-  void sort( C_sort_func_t func);\n-  void reset( Arena *new_a );   \/\/ Zap mapping to empty; reclaim storage\n@@ -1530,1 +1515,0 @@\n-  Node *rpop() { Node *b = _nodes[0]; _nodes[0]=_nodes[--_cnt]; return b;}\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":9,"deletions":25,"binary":false,"changes":34,"status":"modified"}]}