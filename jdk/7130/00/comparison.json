{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+import java.util.Locale;\n@@ -49,0 +50,3 @@\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n@@ -51,0 +55,1 @@\n+import java.util.regex.Pattern;\n@@ -66,0 +71,1 @@\n+import jdk.internal.org.jline.reader.Highlighter;\n@@ -82,0 +88,3 @@\n+import jdk.internal.org.jline.utils.AttributedString;\n+import jdk.internal.org.jline.utils.AttributedStringBuilder;\n+import jdk.internal.org.jline.utils.AttributedStyle;\n@@ -89,0 +98,1 @@\n+import jdk.jshell.SourceCodeAnalysis.Attribute;\n@@ -90,0 +100,1 @@\n+import jdk.jshell.SourceCodeAnalysis.Highlight;\n@@ -98,0 +109,1 @@\n+    private final ExecutorService backgroundWork = Executors.newFixedThreadPool(1);\n@@ -123,0 +135,1 @@\n+        boolean useCrossOut = false;\n@@ -124,0 +137,2 @@\n+            boolean enableHighlighter;\n+            setupReader = r -> {};\n@@ -126,0 +141,1 @@\n+                enableHighlighter = Boolean.getBoolean(\"test.enable.highlighter\");\n@@ -131,1 +147,1 @@\n-                    setupReader = r -> r.unsetOpt(Option.BRACKETED_PASTE);\n+                    setupReader = setupReader.andThen(r -> r.unsetOpt(Option.BRACKETED_PASTE));\n@@ -134,0 +150,1 @@\n+                enableHighlighter = interactive;\n@@ -135,0 +152,1 @@\n+            setupReader = setupReader.andThen(r -> r.option(Option.DISABLE_HIGHLIGHTER, !enableHighlighter));\n@@ -141,0 +159,1 @@\n+            useCrossOut = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT).contains(\"linux\");\n@@ -148,48 +167,1 @@\n-        LineReaderImpl reader = new LineReaderImpl(terminal, \"jshell\", variables) {\n-            {\n-                \/\/jline can handle the CONT signal on its own, but (currently) requires sun.misc for it\n-                try {\n-                    Signal.handle(new Signal(\"CONT\"), new Handler() {\n-                        @Override public void handle(Signal sig) {\n-                            try {\n-                                handleSignal(jdk.internal.org.jline.terminal.Terminal.Signal.CONT);\n-                            } catch (Exception ex) {\n-                                ex.printStackTrace();\n-                            }\n-                        }\n-                    });\n-                } catch (IllegalArgumentException ignored) {\n-                    \/\/the CONT signal does not exist on this platform\n-                }\n-            }\n-            CompletionState completionState = new CompletionState();\n-            @Override\n-            protected boolean doComplete(CompletionType lst, boolean useMenu, boolean prefix) {\n-                return ConsoleIOContext.this.complete(completionState);\n-            }\n-            @Override\n-            public Binding readBinding(KeyMap<Binding> keys, KeyMap<Binding> local) {\n-                completionState.actionCount++;\n-                return super.readBinding(keys, local);\n-            }\n-            @Override\n-            protected boolean insertCloseParen() {\n-                Object oldIndent = getVariable(INDENTATION);\n-                try {\n-                    setVariable(INDENTATION, 0);\n-                    return super.insertCloseParen();\n-                } finally {\n-                    setVariable(INDENTATION, oldIndent);\n-                }\n-            }\n-            @Override\n-            protected boolean insertCloseSquare() {\n-                Object oldIndent = getVariable(INDENTATION);\n-                try {\n-                    setVariable(INDENTATION, 0);\n-                    return super.insertCloseSquare();\n-                } finally {\n-                    setVariable(INDENTATION, oldIndent);\n-                }\n-            }\n-        };\n+        LineReaderImpl reader = new JShellLineReader(terminal, \"jshell\", variables);\n@@ -208,0 +180,1 @@\n+        reader.setHighlighter(new HighlighterImpl(useCrossOut));\n@@ -299,0 +272,1 @@\n+        backgroundWork.shutdown();\n@@ -1369,0 +1343,145 @@\n+    private class HighlighterImpl implements Highlighter {\n+\n+        private final boolean useCrossOut;\n+        private List<UIHighlight> highlights;\n+        private String prevBuffer;\n+\n+        public HighlighterImpl(boolean useCrossOut) {\n+            this.useCrossOut = useCrossOut;\n+        }\n+\n+        @Override\n+        public AttributedString highlight(LineReader reader, String buffer) {\n+            AttributedStringBuilder builder = new AttributedStringBuilder();\n+            List<UIHighlight> highlights;\n+            synchronized (this) {\n+                highlights = this.highlights;\n+            }\n+            int idx = 0;\n+            if (highlights != null) {\n+                for (UIHighlight h : highlights) {\n+                    if (h.end <= buffer.length() && h.content.equals(buffer.substring(h.start, h.end))) {\n+                        builder.append(buffer.substring(idx, h.start));\n+                        builder.append(buffer.substring(h.start, h.end), h.style);\n+                        idx = h.end;\n+                    }\n+                }\n+            }\n+            builder.append(buffer.substring(idx, buffer.length()));\n+            synchronized (this) {\n+                if (!buffer.equals(prevBuffer)) {\n+                    prevBuffer = buffer;\n+                    backgroundWork.submit(() -> {\n+                        synchronized (HighlighterImpl.this) {\n+                            if (!buffer.equals(prevBuffer)) {\n+                                return ;\n+                            }\n+                        }\n+                        List<UIHighlight> computedHighlights = new ArrayList<>();\n+                        for (Highlight h : repl.analysis.highlights(buffer)) {\n+                            computedHighlights.add(new UIHighlight(h.start(), h.end(), buffer.substring(h.start(), h.end()), toAttributedStyle(h.attributes())));\n+                        }\n+                        synchronized (HighlighterImpl.this) {\n+                            if (buffer.equals(prevBuffer)) {\n+                                HighlighterImpl.this.highlights = computedHighlights;\n+                            }\n+                        }\n+                        ((JShellLineReader) reader).repaint();\n+                    });\n+                }\n+            }\n+            return builder.toAttributedString();\n+        }\n+\n+        private AttributedStyle toAttributedStyle(Set<Attribute> attributes) {\n+            AttributedStyle result = AttributedStyle.DEFAULT;\n+            if (attributes.contains(Attribute.DECLARATION)) {\n+                result = result.bold();\n+            }\n+            if (attributes.contains(Attribute.DEPRECATED)) {\n+                result = useCrossOut ? result.crossedOut()\n+                                     : result.inverse();\n+            }\n+            if (attributes.contains(Attribute.KEYWORD)) {\n+                result = result.underline();\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public void setErrorPattern(Pattern errorPattern) {\n+        }\n+\n+        @Override\n+        public void setErrorIndex(int errorIndex) {\n+        }\n+\n+        record UIHighlight(int start, int end, String content, AttributedStyle style) {}\n+    }\n+\n+    private class JShellLineReader extends LineReaderImpl {\n+\n+        public JShellLineReader(Terminal terminal, String appName, Map<String, Object> variables) {\n+            super(terminal, appName, variables);\n+            \/\/jline can handle the CONT signal on its own, but (currently) requires sun.misc for it\n+            try {\n+                Signal.handle(new Signal(\"CONT\"), new Handler() {\n+                    @Override public void handle(Signal sig) {\n+                        try {\n+                            handleSignal(jdk.internal.org.jline.terminal.Terminal.Signal.CONT);\n+                        } catch (Exception ex) {\n+                            ex.printStackTrace();\n+                        }\n+                    }\n+                });\n+            } catch (IllegalArgumentException ignored) {\n+                \/\/the CONT signal does not exist on this platform\n+            }\n+        }\n+\n+        CompletionState completionState = new CompletionState();\n+\n+        @Override\n+        protected boolean doComplete(CompletionType lst, boolean useMenu, boolean prefix) {\n+            return ConsoleIOContext.this.complete(completionState);\n+        }\n+\n+        @Override\n+        public Binding readBinding(KeyMap<Binding> keys, KeyMap<Binding> local) {\n+            completionState.actionCount++;\n+            return super.readBinding(keys, local);\n+        }\n+\n+        @Override\n+        protected boolean insertCloseParen() {\n+            Object oldIndent = getVariable(INDENTATION);\n+            try {\n+                setVariable(INDENTATION, 0);\n+                return super.insertCloseParen();\n+            } finally {\n+                setVariable(INDENTATION, oldIndent);\n+            }\n+        }\n+\n+        @Override\n+        protected boolean insertCloseSquare() {\n+            Object oldIndent = getVariable(INDENTATION);\n+            try {\n+                setVariable(INDENTATION, 0);\n+                return super.insertCloseSquare();\n+            } finally {\n+                setVariable(INDENTATION, oldIndent);\n+            }\n+        }\n+\n+        void repaint() {\n+            try {\n+                lock.lock();\n+                if (isReading()) {\n+                    redisplay();\n+                }\n+            } finally {\n+                lock.unlock();\n+            }\n+        }\n+    }\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/ConsoleIOContext.java","additions":169,"deletions":50,"binary":false,"changes":219,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.Set;\n@@ -173,0 +174,13 @@\n+    \/**\n+     * Returns a collection of {@code Highlight}s which can be used to color\n+     * the given snippet.\n+     * <p>\n+     * The returned {@code Highlight}s do not overlap, and are sorted by their\n+     * start position.\n+     *\n+     * @param snippet the snippet for which the {@code Highlight}s should be computed\n+     * @return the computed {@code Highlight}s.\n+     * @since 19\n+     *\/\n+    public abstract List<Highlight> highlights(String snippet);\n+\n@@ -463,0 +477,28 @@\n+\n+    \/**Assigns attributes usable for coloring to spans inside a snippet.\n+     *\n+     * @param start the starting position of the span\n+     * @param end the ending position of the span\n+     * @param attributes the attributes assigned to the span\n+     * @since 19\n+     *\/\n+    public record Highlight(int start, int end, Set<Attribute> attributes) {}\n+\n+    \/**\n+     * A span attribute which can be used to derive a coloring.\n+     * @since 19\n+     *\/\n+    public enum Attribute {\n+        \/**\n+         * The span refers to a declaration of an element.\n+         *\/\n+        DECLARATION,\n+        \/**\n+         * The span refers to a deprecated element.\n+         *\/\n+        DEPRECATED,\n+        \/**\n+         * The span is a keyword.\n+         *\/\n+        KEYWORD;\n+    }\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/SourceCodeAnalysis.java","additions":43,"deletions":1,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.source.tree.AnnotationTree;\n@@ -39,0 +40,1 @@\n+import com.sun.source.tree.ModifiersTree;\n@@ -43,0 +45,1 @@\n+import static com.sun.source.tree.Tree.Kind.METHOD;\n@@ -45,0 +48,1 @@\n+import com.sun.source.tree.YieldTree;\n@@ -48,0 +52,1 @@\n+import com.sun.source.util.Trees;\n@@ -55,0 +60,6 @@\n+import com.sun.tools.javac.parser.Scanner;\n+import com.sun.tools.javac.parser.ScannerFactory;\n+import com.sun.tools.javac.parser.Tokens.Token;\n+import com.sun.tools.javac.parser.Tokens.TokenKind;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.util.Context;\n@@ -101,0 +112,2 @@\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n@@ -591,0 +604,250 @@\n+    @Override\n+    public List<Highlight> highlights(String snippet) {\n+        if (snippet.isEmpty()) {\n+            snippet += \";\";\n+        }\n+        \/\/TODO: OuterWrap duplicated\n+        OuterWrap codeWrap = switch (guessKind(snippet)) {\n+            case IMPORT -> proc.outerMap.wrapImport(Wrap.simpleWrap(snippet + \"any.any\"), null);\n+            case CLASS, METHOD -> proc.outerMap.wrapInTrialClass(Wrap.classMemberWrap(snippet));\n+            default -> proc.outerMap.wrapInTrialClass(Wrap.methodWrap(snippet));\n+        };\n+        String wrappedCode = codeWrap.wrapped();\n+        return this.proc.taskFactory.analyze(codeWrap, task -> {\n+            List<Highlight> result = new ArrayList<>();\n+            CompilationUnitTree cut = task.cuTrees().iterator().next();\n+            Trees trees = task.trees();\n+            SourcePositions sp = trees.getSourcePositions();\n+            List<Token> tokens = new ArrayList<>();\n+            Scanner scanner = ScannerFactory.instance(new Context()).newScanner(wrappedCode, false);\n+            scanner.nextToken();\n+            BiConsumer<Integer, Integer> addKeywordForSpan = (spanStart, spanEnd) -> {\n+                int start = codeWrap.wrapIndexToSnippetIndex(spanStart);\n+                int end = codeWrap.wrapIndexToSnippetIndex(spanEnd);\n+                result.add(new Highlight(start, end, EnumSet.of(Attribute.KEYWORD)));\n+            };\n+            Consumer<Token> addKeyword = token -> addKeywordForSpan.accept(token.pos, token.endPos);\n+            while (scanner.token().kind != TokenKind.EOF) {\n+                Token token = scanner.token();\n+\n+                tokens.add(token);\n+                switch (token.kind) {\n+                    case ABSTRACT, ASSERT, BOOLEAN, BREAK, BYTE, CASE, CATCH, CHAR, CLASS, CONST,\n+                         CONTINUE, DEFAULT, DO, DOUBLE, ELSE, ENUM, EXTENDS, FINAL, FINALLY, FLOAT,\n+                         FOR, GOTO, IF, IMPLEMENTS, IMPORT, INSTANCEOF, INT, INTERFACE, LONG,\n+                         NATIVE, NEW, PACKAGE, PRIVATE, PROTECTED, PUBLIC, RETURN, SHORT, STATIC,\n+                         STRICTFP, SUPER, SWITCH, SYNCHRONIZED, THIS, THROW, THROWS, TRANSIENT, TRY,\n+                         VOID, VOLATILE, WHILE, UNDERSCORE -> {\n+                        addKeyword.accept(token);\n+                    }\n+                }\n+\n+                scanner.nextToken();\n+            }\n+            new TreePathScanner<Void, Void>() {\n+                @Override\n+                public Void visitIdentifier(IdentifierTree node, Void p) {\n+                    long start = sp.getStartPosition(cut, node);\n+                    long end = sp.getEndPosition(cut, node);\n+                    handleElement(false, start, end);\n+                    return super.visitIdentifier(node, p);\n+                }\n+                @Override\n+                public Void visitMemberSelect(MemberSelectTree node, Void p) {\n+                    long exprEnd = sp.getEndPosition(cut, node.getExpression());\n+                    Token ident = findTokensFrom(exprEnd, TokenKind.DOT, TokenKind.IDENTIFIER);\n+                    if (ident != null) {\n+                        handleElement(false, ident.pos, ident.endPos);\n+                    }\n+                    return super.visitMemberSelect(node, p);\n+                }\n+                @Override\n+                public Void visitClass(ClassTree node, Void p) {\n+                    ModifiersTree mods = node.getModifiers();\n+                    if (mods.getFlags().contains(Modifier.SEALED) ||\n+                        mods.getFlags().contains(Modifier.NON_SEALED)) {\n+                        List<Token> modifierTokens = new ArrayList<>();\n+                        long modsStart = sp.getStartPosition(cut, mods);\n+                        long modsEnd = sp.getEndPosition(cut, mods);\n+                        for (Token t : tokens) {\n+                            if (t.pos >= modsStart && t.endPos <= modsEnd) {\n+                                modifierTokens.add(t);\n+                            }\n+                        }\n+                        for (AnnotationTree at : mods.getAnnotations()) {\n+                            long annStart = sp.getStartPosition(cut, at);\n+                            long annEnd = sp.getEndPosition(cut, at);\n+                            modifierTokens.removeIf(t -> t.pos >= annStart && t.endPos <= annEnd);\n+                        }\n+                        OUTER: for (int i = 0; i < modifierTokens.size(); i++) {\n+                            if (modifierTokens.get(i).kind == TokenKind.IDENTIFIER) {\n+                                switch (modifierTokens.get(i).name().toString()) {\n+                                    case \"non\" -> {\n+                                        addKeywordForSpan.accept(modifierTokens.get(i).pos,\n+                                                                 modifierTokens.get(i + 2).endPos);\n+                                        break OUTER;\n+                                    }\n+                                    case \"sealed\" -> {\n+                                        addKeyword.accept(modifierTokens.get(i));\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                    int pos = ((JCTree) node).pos;\n+                    Token ident = switch (node.getKind()) {\n+                        case ANNOTATION_TYPE, INTERFACE ->\n+                            findTokensFrom(pos, TokenKind.INTERFACE, TokenKind.IDENTIFIER);\n+                        case CLASS -> findTokensFrom(pos, TokenKind.CLASS, TokenKind.IDENTIFIER);\n+                        case ENUM -> findTokensFrom(pos, TokenKind.ENUM, TokenKind.IDENTIFIER);\n+                        case RECORD -> {\n+                            Token recordCandidate = findTokensFrom(pos, TokenKind.IDENTIFIER);\n+                            if (recordCandidate != null && recordCandidate.name().contentEquals(\"record\")) {\n+                                addKeyword.accept(recordCandidate);\n+                            }\n+                            yield findTokensFrom(pos, TokenKind.IDENTIFIER, TokenKind.IDENTIFIER);\n+                        }\n+                        default -> throw new IllegalStateException(\"Unsupported token kind: \" + node.getKind());\n+                    };\n+                    if (ident != null) {\n+                        handleElement(true, ident.pos, ident.endPos);\n+                    }\n+                    if (!node.getPermitsClause().isEmpty()) {\n+                        long start = sp.getStartPosition(cut, node.getPermitsClause().get(0));\n+                        Token permitsCandidate = findTokensBefore(start, TokenKind.IDENTIFIER);\n+                        if (permitsCandidate != null && permitsCandidate.name().contentEquals(\"permits\")) {\n+                            addKeyword.accept(permitsCandidate);\n+                        }\n+                    }\n+                    return super.visitClass(node, p);\n+                }\n+                @Override\n+                public Void visitMethod(MethodTree node, Void p) {\n+                    int pos = ((JCTree) node).pos;\n+                    Token ident = findTokensFrom(pos, TokenKind.IDENTIFIER);\n+                    if (ident != null) {\n+                        handleElement(true, ident.pos, ident.endPos);\n+                    }\n+                    return super.visitMethod(node, p);\n+                }\n+                @Override\n+                public Void visitVariable(VariableTree node, Void p) {\n+                    int pos = ((JCTree) node).pos;\n+                    if (sp.getEndPosition(cut, node.getType()) == (-1)) {\n+                        Token varCandidate = findTokensBefore(pos, TokenKind.IDENTIFIER);\n+                        if (varCandidate != null && \"var\".equals(varCandidate.name().toString())) {\n+                            addKeyword.accept(varCandidate);\n+                        }\n+                    }\n+                    Token ident = findTokensFrom(pos, TokenKind.IDENTIFIER);\n+                    if (ident != null) {\n+                        handleElement(true, ident.pos, ident.endPos);\n+                    }\n+                    return super.visitVariable(node, p);\n+                }\n+                @Override\n+                public Void visitYield(YieldTree node, Void p) {\n+                    long start = sp.getStartPosition(cut, node);\n+                    Token yield = findTokensFrom(start, TokenKind.IDENTIFIER);\n+                    addKeyword.accept(yield);\n+                    return super.visitYield(node, p);\n+                }\n+                @Override\n+                public Void visitErroneous(ErroneousTree node, Void p) {\n+                    for (Tree err : node.getErrorTrees()) {\n+                        scan(err, p);\n+                    }\n+                    return null;\n+                }\n+                @Override\n+                public Void scan(Tree tree, Void p) {\n+                    if (tree != null) {\n+                        long end = sp.getEndPosition(cut, tree);\n+                        if (end == (-1)) {\n+                            \/\/synthetic\n+                            return null;\n+                        }\n+                    }\n+                    return super.scan(tree, p);\n+                }\n+                private void handleElement(boolean declaration, long codeStart, long codeEnd) {\n+                    Element el = trees.getElement(getCurrentPath());\n+                    if (getCurrentPath().getParentPath().getLeaf().getKind() == Kind.NEW_CLASS) {\n+                        NewClassTree nct = (NewClassTree) getCurrentPath().getParentPath().getLeaf();\n+                        if (nct.getIdentifier() == getCurrentPath().getLeaf()) {\n+                            el = trees.getElement(getCurrentPath().getParentPath());\n+                        }\n+                    }\n+                    if (el != null) {\n+                        boolean deprecated = task.getElements().isDeprecated(el);\n+                        if (declaration || deprecated) {\n+                            Set<Attribute> attributes = EnumSet.noneOf(Attribute.class);\n+                            if (declaration) {\n+                                attributes.add(Attribute.DECLARATION);\n+                            }\n+                            if (deprecated) {\n+                                attributes.add(Attribute.DEPRECATED);\n+                            }\n+                            int start = codeWrap.wrapIndexToSnippetIndex(codeStart);\n+                            int end = codeWrap.wrapIndexToSnippetIndex(codeEnd);\n+                            result.add(new Highlight(start, end, attributes));\n+                        }\n+                    }\n+                }\n+                private Token findTokensFrom(long pos, TokenKind... expectedKinds) {\n+                    int tokenIdx = 0;\n+\n+                    while (tokenIdx < tokens.size() && tokens.get(tokenIdx).pos < pos) {\n+                        tokenIdx++;\n+                    }\n+\n+                    if (tokenIdx + expectedKinds.length - 1 < tokens.size()) {\n+                        Token t = null;\n+                        for (TokenKind expectedKind : expectedKinds) {\n+                            t = tokens.get(tokenIdx);\n+\n+                            if (t.kind != expectedKind) {\n+                                return null;\n+                            }\n+\n+                            tokenIdx++;\n+                        }\n+\n+                        return t;\n+                    }\n+\n+                    return null;\n+                }\n+                private Token findTokensBefore(long pos, TokenKind... expectedKinds) {\n+                    int tokenIdx = 0;\n+\n+                    while (tokenIdx < tokens.size() && tokens.get(tokenIdx).pos < pos) {\n+                        tokenIdx++;\n+                    }\n+\n+                    tokenIdx--;\n+\n+                    if (tokenIdx >= expectedKinds.length) {\n+                        Token t = null;\n+                        for (TokenKind expectedKind : expectedKinds) {\n+                            t = tokens.get(tokenIdx);\n+\n+                            if (t.kind != expectedKind) {\n+                                return null;\n+                            }\n+\n+                            tokenIdx--;\n+                        }\n+\n+                        return t;\n+                    }\n+\n+                    return null;\n+                }\n+            }.scan(cut, null);\n+            result.removeIf(h -> h.start() == h.end());\n+            Collections.sort(result, (h1, h2) -> h1.start() - h2.start());\n+            return result;\n+        });\n+    }\n+\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/SourceCodeAnalysisImpl.java","additions":264,"deletions":1,"binary":false,"changes":265,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-    private <S, T extends BaseTask<S>, Z> Z runTask(Stream<S> inputs,\n+    private synchronized <S, T extends BaseTask<S>, Z> Z runTask(Stream<S> inputs,\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/TaskFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8274148\n+ * @summary Check the UI behavior of snippet highligting\n+ * @modules\n+ *     jdk.compiler\/com.sun.tools.javac.api\n+ *     jdk.compiler\/com.sun.tools.javac.main\n+ *     jdk.jshell\/jdk.internal.jshell.tool:open\n+ *     jdk.jshell\/jdk.internal.jshell.tool.resources:open\n+ *     jdk.jshell\/jdk.jshell:open\n+ * @library \/tools\/lib\n+ * @build toolbox.ToolBox toolbox.JarTask toolbox.JavacTask\n+ * @build Compiler UITesting\n+ * @compile HighlightUITest.java\n+ * @run testng HighlightUITest\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+@Test\n+public class HighlightUITest extends UITesting {\n+\n+    public HighlightUITest() {\n+        super(true);\n+    }\n+\n+    public void testHighlight() throws Exception {\n+        System.setProperty(\"test.enable.highlighter\", \"true\");\n+        doRunTest((inputSink, out) -> {\n+            inputSink.write(\"var s = new String(byte[0], 0);\");\n+            waitOutput(out, \"var s = new String\\\\(byte\\\\[0]\\u001B\\\\[3D\\u001B\\\\[3C, 0\\\\)\\u001B\\\\[12D\\u001B\\\\[12C;\\r\" +\n+                            \"\\u001B\\\\[4mvar\\u001B\\\\[0m \\u001B\\\\[1ms\\u001B\\\\[0m = \\u001B\\\\[4mnew\\u001B\\\\[0m String\\\\(\\u001B\\\\[4mbyte\\u001B\\\\[0m\\\\u001B\\\\[8C\");\n+        });\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/jdk\/jshell\/HighlightUITest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8274148\n+ * @summary Check snippet highlighting\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.jdeps\/com.sun.tools.javap\n+ *          jdk.jshell\/jdk.jshell:open\n+ * @build toolbox.ToolBox toolbox.JarTask toolbox.JavacTask\n+ * @build KullaTesting TestingInputStream Compiler\n+ * @run testng SnippetHighlightTest\n+ *\/\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.testng.annotations.Test;\n+\n+import jdk.jshell.SourceCodeAnalysis.Highlight;\n+\n+import static org.testng.Assert.*;\n+\n+@Test\n+public class SnippetHighlightTest extends KullaTesting {\n+\n+    public void testMemberExpr() {\n+        assertEval(\"@Deprecated class TestClass { }\");\n+        assertEval(\"class TestConstructor { @Deprecated TestConstructor() {} }\");\n+        assertEval(\"class TestMethod { @Deprecated void test() {} }\");\n+        assertHighlights(\"TestClass t\", \"Highlight[start=0, end=9, attributes=[DEPRECATED]]\",\n+                                        \"Highlight[start=10, end=11, attributes=[DECLARATION]]\");\n+        assertHighlights(\"TestClass.class\", \"Highlight[start=0, end=9, attributes=[DEPRECATED]]\",\n+                                            \"Highlight[start=10, end=15, attributes=[KEYWORD]]\");\n+        assertHighlights(\"new TestConstructor()\", \"Highlight[start=0, end=3, attributes=[KEYWORD]]\",\n+                                                  \"Highlight[start=4, end=19, attributes=[DEPRECATED]]\");\n+        assertHighlights(\"new TestMethod().test()\", \"Highlight[start=0, end=3, attributes=[KEYWORD]]\",\n+                                                    \"Highlight[start=17, end=21, attributes=[DEPRECATED]]\");\n+        assertHighlights(\"var v = 0;\", \"Highlight[start=0, end=3, attributes=[KEYWORD]]\",\n+                                       \"Highlight[start=4, end=5, attributes=[DECLARATION]]\");\n+        assertHighlights(\"int i = switch (0) { case 0: yield 0;};\",\n+                         \"Highlight[start=0, end=3, attributes=[KEYWORD]]\",\n+                         \"Highlight[start=4, end=5, attributes=[DECLARATION]]\",\n+                         \"Highlight[start=8, end=14, attributes=[KEYWORD]]\",\n+                         \"Highlight[start=21, end=25, attributes=[KEYWORD]]\",\n+                         \"Highlight[start=29, end=34, attributes=[KEYWORD]]\");\n+        assertHighlights(\"sealed class C permits A {}\",\n+                         \"Highlight[start=0, end=6, attributes=[KEYWORD]]\",\n+                         \"Highlight[start=7, end=12, attributes=[KEYWORD]]\",\n+                         \"Highlight[start=13, end=14, attributes=[DECLARATION]]\",\n+                         \"Highlight[start=15, end=22, attributes=[KEYWORD]]\");\n+        assertHighlights(\"non-sealed class C extends A {}\",\n+                         \"Highlight[start=0, end=10, attributes=[KEYWORD]]\",\n+                         \"Highlight[start=11, end=16, attributes=[KEYWORD]]\",\n+                         \"Highlight[start=17, end=18, attributes=[DECLARATION]]\",\n+                         \"Highlight[start=19, end=26, attributes=[KEYWORD]]\");\n+        assertHighlights(\"interface I {}\",\n+                         \"Highlight[start=0, end=9, attributes=[KEYWORD]]\",\n+                         \"Highlight[start=10, end=11, attributes=[DECLARATION]]\");\n+        assertHighlights(\"@interface I {}\",\n+                         \"Highlight[start=1, end=10, attributes=[KEYWORD]]\",\n+                         \"Highlight[start=11, end=12, attributes=[DECLARATION]]\");\n+        assertHighlights(\"enum E {A, B;}\",\n+                         \"Highlight[start=0, end=4, attributes=[KEYWORD]]\",\n+                         \"Highlight[start=5, end=6, attributes=[DECLARATION]]\",\n+                         \"Highlight[start=8, end=9, attributes=[DECLARATION]]\",\n+                         \"Highlight[start=11, end=12, attributes=[DECLARATION]]\");\n+        assertHighlights(\"record R(int i) {}\",\n+                         \"Highlight[start=0, end=6, attributes=[KEYWORD]]\",\n+                         \"Highlight[start=7, end=8, attributes=[DECLARATION]]\",\n+                         \"Highlight[start=9, end=12, attributes=[KEYWORD]]\",\n+                         \"Highlight[start=13, end=14, attributes=[DECLARATION]]\");\n+        assertHighlights(\"void method() {}\",\n+                         \"Highlight[start=0, end=4, attributes=[KEYWORD]]\",\n+                         \"Highlight[start=5, end=11, attributes=[DECLARATION]]\");\n+    }\n+\n+    private void assertHighlights(String code, String... expected) {\n+        List<String> completions = computeHighlights(code);\n+        assertEquals(completions, Arrays.asList(expected), \"Input: \" + code + \", \" + completions.toString());\n+    }\n+\n+    private List<String> computeHighlights(String code) {\n+        waitIndexingFinished();\n+\n+        List<Highlight> highlights =\n+                getAnalysis().highlights(code);\n+        return highlights.stream()\n+                          .map(h -> h.toString())\n+                          .distinct()\n+                          .collect(Collectors.toList());\n+    }\n+}\n","filename":"test\/langtools\/jdk\/jshell\/SnippetHighlightTest.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"}]}