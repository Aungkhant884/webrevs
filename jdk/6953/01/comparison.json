{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,2 +43,0 @@\n-import sun.nio.ch.ChannelInputStream;\n-import sun.nio.ch.ChannelOutputStream;\n@@ -90,1 +88,1 @@\n-        return new ChannelInputStream(ch);\n+        return sun.nio.ch.Streams.of(ch);\n@@ -109,1 +107,1 @@\n-        return new ChannelOutputStream(ch);\n+        return sun.nio.ch.Streams.of(ch);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/Channels.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,2 +43,1 @@\n- * This class is defined here rather than in java.nio.channels.Channels\n- * so that code can be shared with SocketAdaptor.\n+ * An InputStream that reads bytes from a channel.\n@@ -48,1 +47,0 @@\n- * @since 1.4\n@@ -50,4 +48,1 @@\n-\n-public class ChannelInputStream\n-    extends InputStream\n-{\n+class ChannelInputStream extends InputStream {\n@@ -56,4 +51,16 @@\n-    public static int read(ReadableByteChannel ch, ByteBuffer bb,\n-                           boolean block)\n-        throws IOException\n-    {\n+    private final ReadableByteChannel ch;\n+    private ByteBuffer bb;\n+    private byte[] bs;       \/\/ Invoker's previous array\n+    private byte[] b1;\n+\n+    \/**\n+     * Initialize a ChannelInputStream that reads from the given channel.\n+     *\/\n+    ChannelInputStream(ReadableByteChannel ch) {\n+        this.ch = ch;\n+    }\n+\n+    \/**\n+     * Reads a sequence of bytes from the channel into the given buffer.\n+     *\/\n+    private int read(ByteBuffer bb) throws IOException {\n@@ -62,2 +69,1 @@\n-                boolean bm = sc.isBlocking();\n-                if (!bm)\n+                if (!sc.isBlocking())\n@@ -65,6 +71,1 @@\n-                if (bm != block)\n-                    sc.configureBlocking(block);\n-                int n = ch.read(bb);\n-                if (bm != block)\n-                    sc.configureBlocking(bm);\n-                return n;\n+                return ch.read(bb);\n@@ -77,9 +78,1 @@\n-    protected final ReadableByteChannel ch;\n-    private ByteBuffer bb = null;\n-    private byte[] bs = null;           \/\/ Invoker's previous array\n-    private byte[] b1 = null;\n-\n-    public ChannelInputStream(ReadableByteChannel ch) {\n-        this.ch = ch;\n-    }\n-\n+    @Override\n@@ -89,1 +82,1 @@\n-        int n = this.read(b1);\n+        int n = read(b1);\n@@ -95,0 +88,1 @@\n+    @Override\n@@ -112,6 +106,0 @@\n-    protected int read(ByteBuffer bb)\n-        throws IOException\n-    {\n-        return ChannelInputStream.read(ch, bb, true);\n-    }\n-\n@@ -204,0 +192,1 @@\n+    @Override\n@@ -213,0 +202,1 @@\n+    @Override\n@@ -233,4 +223,0 @@\n-    public void close() throws IOException {\n-        ch.close();\n-    }\n-\n@@ -241,9 +227,4 @@\n-        if (out instanceof ChannelOutputStream cos\n-                && ch instanceof FileChannel fc) {\n-            WritableByteChannel wbc = cos.channel();\n-\n-            if (wbc instanceof FileChannel dst) {\n-                return transfer(fc, dst);\n-            }\n-\n-            if (wbc instanceof SelectableChannel sc) {\n+        if (ch instanceof FileChannel fc) {\n+            \/\/ FileChannel -> SocketChannel\n+            if (out instanceof SocketOutputStream sos) {\n+                SocketChannelImpl sc = sos.channel();\n@@ -253,1 +234,1 @@\n-                    return transfer(fc, wbc);\n+                    return transfer(fc, sc);\n@@ -257,1 +238,14 @@\n-            return transfer(fc, wbc);\n+            \/\/ FileChannel -> WritableByteChannel\n+            if (out instanceof ChannelOutputStream cos) {\n+                WritableByteChannel wbc = cos.channel();\n+\n+                if (wbc instanceof SelectableChannel sc) {\n+                    synchronized (sc.blockingLock()) {\n+                        if (!sc.isBlocking())\n+                            throw new IllegalBlockingModeException();\n+                        return transfer(fc, wbc);\n+                    }\n+                }\n+\n+                return transfer(fc, wbc);\n+            }\n@@ -263,2 +257,9 @@\n-    private static long transfer(FileChannel src, WritableByteChannel dst) throws IOException {\n-        long initialPos = src.position();\n+    \/**\n+     * Transfers all bytes from a channel's file to a target writeable byte channel.\n+     * If the writeable byte channel is a selectable channel then it must be in\n+     * blocking mode.\n+     *\/\n+    private static long transfer(FileChannel fc, WritableByteChannel target)\n+        throws IOException\n+    {\n+        long initialPos = fc.position();\n@@ -267,2 +268,2 @@\n-            while (pos < src.size()) {\n-                pos += src.transferTo(pos, Long.MAX_VALUE, dst);\n+            while (pos < fc.size()) {\n+                pos += fc.transferTo(pos, Long.MAX_VALUE, target);\n@@ -271,1 +272,1 @@\n-            src.position(pos);\n+            fc.position(pos);\n@@ -275,0 +276,5 @@\n+\n+    @Override\n+    public void close() throws IOException {\n+        ch.close();\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelInputStream.java","additions":62,"deletions":56,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,6 @@\n-import java.io.*;\n-import java.nio.*;\n-import java.nio.channels.*;\n-import java.nio.channels.spi.*;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.IllegalBlockingModeException;\n+import java.nio.channels.SelectableChannel;\n+import java.nio.channels.WritableByteChannel;\n@@ -35,4 +37,1 @@\n- * This class is defined here rather than in java.nio.channels.Channels\n- * so that it will be accessible from java.nio.channels.Channels and\n- * sun.nio.ch.ChannelInputStream.\n- *\n+ * An OutputStream that writes bytes to a channel.\n@@ -42,2 +41,0 @@\n- * @author JSR-51 Expert Group\n- * @since 18\n@@ -45,2 +42,1 @@\n-public class ChannelOutputStream extends OutputStream {\n-\n+class ChannelOutputStream extends OutputStream {\n@@ -53,35 +49,1 @@\n-     * Write all remaining bytes in buffer to the given channel.\n-     * If the channel is selectable then it must be configured blocking.\n-     *\/\n-    private static void writeFullyImpl(WritableByteChannel ch, ByteBuffer bb)\n-        throws IOException\n-    {\n-        while (bb.remaining() > 0) {\n-            int n = ch.write(bb);\n-            if (n <= 0)\n-                throw new RuntimeException(\"no bytes written\");\n-        }\n-    }\n-\n-    \/**\n-     * Write all remaining bytes in buffer to the given channel.\n-     *\n-     * @throws  IllegalBlockingModeException\n-     *          If the channel is selectable and configured non-blocking.\n-     *\/\n-    private static void writeFully(WritableByteChannel ch, ByteBuffer bb)\n-        throws IOException\n-    {\n-        if (ch instanceof SelectableChannel sc) {\n-            synchronized (sc.blockingLock()) {\n-                if (!sc.isBlocking())\n-                    throw new IllegalBlockingModeException();\n-                writeFullyImpl(ch, bb);\n-            }\n-        } else {\n-            writeFullyImpl(ch, bb);\n-        }\n-    }\n-\n-    \/**\n-     * @param ch The channel wrapped by this stream.\n+     * Initialize a ChannelOutputStream that writes to the given channel.\n@@ -89,1 +51,1 @@\n-    public ChannelOutputStream(WritableByteChannel ch) {\n+    ChannelOutputStream(WritableByteChannel ch) {\n@@ -100,0 +62,12 @@\n+    \/**\n+     * Write all remaining bytes in buffer to the channel.\n+     * If the channel is selectable then it must be configured blocking.\n+     *\/\n+    private void writeFully(ByteBuffer bb) throws IOException {\n+        while (bb.remaining() > 0) {\n+            int n = ch.write(bb);\n+            if (n <= 0)\n+                throw new RuntimeException(\"no bytes written\");\n+        }\n+    }\n+\n@@ -105,1 +79,1 @@\n-        this.write(b1);\n+        write(b1);\n@@ -110,1 +84,2 @@\n-        throws IOException {\n+        throws IOException\n+    {\n@@ -122,1 +97,10 @@\n-        writeFully(ch, bb);\n+\n+        if (ch instanceof SelectableChannel sc) {\n+            synchronized (sc.blockingLock()) {\n+                if (!sc.isBlocking())\n+                    throw new IllegalBlockingModeException();\n+                writeFully(bb);\n+            }\n+        } else {\n+            writeFully(bb);\n+        }\n@@ -129,1 +113,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelOutputStream.java","additions":36,"deletions":53,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -180,26 +180,1 @@\n-        return new InputStream() {\n-            @Override\n-            public int read() throws IOException {\n-                byte[] a = new byte[1];\n-                int n = read(a, 0, 1);\n-                return (n > 0) ? (a[0] & 0xff) : -1;\n-            }\n-            @Override\n-            public int read(byte[] b, int off, int len) throws IOException {\n-                int timeout = SocketAdaptor.this.timeout;\n-                if (timeout > 0) {\n-                    long nanos = MILLISECONDS.toNanos(timeout);\n-                    return sc.blockingRead(b, off, len, nanos);\n-                } else {\n-                    return sc.blockingRead(b, off, len, 0);\n-                }\n-            }\n-            @Override\n-            public int available() throws IOException {\n-                return sc.available();\n-            }\n-            @Override\n-            public void close() throws IOException {\n-                sc.close();\n-            }\n-        };\n+        return new SocketInputStream(sc, () -> timeout);\n@@ -216,15 +191,1 @@\n-        return new OutputStream() {\n-            @Override\n-            public void write(int b) throws IOException {\n-                byte[] a = new byte[]{(byte) b};\n-                write(a, 0, 1);\n-            }\n-            @Override\n-            public void write(byte[] b, int off, int len) throws IOException {\n-                sc.blockingWriteFully(b, off, len);\n-            }\n-            @Override\n-            public void close() throws IOException {\n-                sc.close();\n-            }\n-        };\n+        return new SocketOutputStream(sc);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketAdaptor.java","additions":3,"deletions":42,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.nio.ch;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.function.IntSupplier;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+\/**\n+ * An InputStream that reads bytes from a socket channel.\n+ *\/\n+class SocketInputStream extends InputStream {\n+    private final SocketChannelImpl sc;\n+    private final IntSupplier timeoutSupplier;\n+\n+    \/**\n+     * Initialize a SocketInputStream that reads from the given socket channel.\n+     * @param sc the socket channel\n+     * @param timeoutSupplier supplies the read timeout, in milliseconds\n+     *\/\n+    SocketInputStream(SocketChannelImpl sc, IntSupplier timeoutSupplier) {\n+        this.sc = sc;\n+        this.timeoutSupplier = timeoutSupplier;\n+    }\n+\n+    \/**\n+     * Initialize a SocketInputStream that reads from the given socket channel.\n+     *\/\n+    SocketInputStream(SocketChannelImpl sc) {\n+        this(sc, () -> 0);\n+    }\n+\n+    @Override\n+    public int read() throws IOException {\n+        byte[] a = new byte[1];\n+        int n = read(a, 0, 1);\n+        return (n > 0) ? (a[0] & 0xff) : -1;\n+    }\n+\n+    @Override\n+    public int read(byte[] b, int off, int len) throws IOException {\n+        int timeout = timeoutSupplier.getAsInt();\n+        if (timeout > 0) {\n+            long nanos = MILLISECONDS.toNanos(timeout);\n+            return sc.blockingRead(b, off, len, nanos);\n+        } else {\n+            return sc.blockingRead(b, off, len, 0);\n+        }\n+    }\n+\n+    @Override\n+    public int available() throws IOException {\n+        return sc.available();\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        sc.close();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketInputStream.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.nio.ch;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+\/**\n+ * An OutputStream that writes bytes to a socket channel.\n+ *\/\n+class SocketOutputStream extends OutputStream {\n+    private final SocketChannelImpl sc;\n+\n+    \/**\n+     * Initialize a SocketOutputStream that writes to the given socket channel.\n+     *\/\n+    SocketOutputStream(SocketChannelImpl sc) {\n+        this.sc = sc;\n+    }\n+\n+    \/**\n+     * Returns the socket channel.\n+     *\/\n+    SocketChannelImpl channel() {\n+        return sc;\n+    }\n+\n+    @Override\n+    public void write(int b) throws IOException {\n+        byte[] a = new byte[]{(byte) b};\n+        write(a, 0, 1);\n+    }\n+\n+    @Override\n+    public void write(byte[] b, int off, int len) throws IOException {\n+        sc.blockingWriteFully(b, off, len);\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        sc.close();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketOutputStream.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.nio.ch;\n+\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+\n+\/**\n+ * Factory methods for input\/output streams based on channels.\n+ *\/\n+public class Streams {\n+    private Streams() { }\n+\n+    \/**\n+     * Return an input stream that reads bytes from the given channel.\n+     *\/\n+    public static InputStream of(ReadableByteChannel ch) {\n+        if (ch instanceof SocketChannelImpl sc) {\n+            return new SocketInputStream(sc);\n+        } else {\n+            return new ChannelInputStream(ch);\n+        }\n+    }\n+\n+    \/**\n+     * Return an output stream that writes bytes to the given channel.\n+     *\/\n+    public static OutputStream of(WritableByteChannel ch) {\n+        if (ch instanceof SocketChannelImpl sc) {\n+            return new SocketOutputStream(sc);\n+        } else {\n+            return new ChannelOutputStream(ch);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Streams.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,480 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8279339\n+ * @run testng SocketChannelStreams\n+ * @summary Exercise InputStream\/OutputStream returned by Channels.newXXXStream\n+ *    when channel is a SocketChannel\n+ *\/\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.nio.channels.Channels;\n+import java.nio.channels.IllegalBlockingModeException;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.testng.annotations.*;\n+import static org.testng.Assert.*;\n+\n+@Test\n+public class SocketChannelStreams {\n+    private ScheduledExecutorService executor;\n+\n+    @BeforeClass()\n+    public void init() {\n+        executor = Executors.newSingleThreadScheduledExecutor();\n+    }\n+\n+    @AfterClass\n+    public void finish() {\n+        executor.shutdown();\n+    }\n+\n+    \/**\n+     * Test read when bytes are available.\n+     *\/\n+    public void testRead1() throws Exception {\n+        withConnection((sc, peer) -> {\n+            write(peer, 99);\n+            int n = Channels.newInputStream(sc).read();\n+            assertEquals(n, 99);\n+        });\n+    }\n+\n+    \/**\n+     * Test read blocking before bytes are available.\n+     *\/\n+    public void testRead2() throws Exception {\n+        withConnection((sc, peer) -> {\n+            scheduleWrite(peer, 99, 1000);\n+            int n = Channels.newInputStream(sc).read();\n+            assertEquals(n, 99);\n+        });\n+    }\n+\n+    \/**\n+     * Test read after peer has closed connection.\n+     *\/\n+    public void testRead3() throws Exception {\n+        withConnection((sc, peer) -> {\n+            peer.close();\n+            int n = Channels.newInputStream(sc).read();\n+            assertEquals(n, -1);\n+        });\n+    }\n+\n+    \/**\n+     * Test read blocking before peer closes connection.\n+     *\/\n+    public void testRead4() throws Exception {\n+        withConnection((sc, peer) -> {\n+            scheduleClose(peer, 1000);\n+            int n = Channels.newInputStream(sc).read();\n+            assertEquals(n, -1);\n+        });\n+    }\n+\n+    \/**\n+     * Test async close of channel when thread blocked in read.\n+     *\/\n+    public void testRead5() throws Exception {\n+        withConnection((sc, peer) -> {\n+            scheduleClose(sc, 2000);\n+            InputStream in = Channels.newInputStream(sc);\n+            expectThrows(IOException.class, () -> in.read());\n+        });\n+    }\n+\n+    \/**\n+     * Test async close of input stream, when thread blocked in read.\n+     *\/\n+    public void testRead6() throws Exception {\n+        withConnection((sc, peer) -> {\n+            InputStream in = Channels.newInputStream(sc);\n+            scheduleClose(in, 2000);\n+            expectThrows(IOException.class, () -> in.read());\n+        });\n+    }\n+\n+    \/**\n+     * Test interrupt status set before read.\n+     *\/\n+    public void testRead7() throws Exception {\n+        withConnection((sc, peer) -> {\n+            Thread.currentThread().interrupt();\n+            try {\n+                InputStream in = Channels.newInputStream(sc);\n+                expectThrows(IOException.class, () -> in.read());\n+            } finally {\n+                Thread.interrupted();  \/\/ clear interrupt\n+            }\n+            assertFalse(sc.isOpen());\n+        });\n+    }\n+\n+    \/**\n+     * Test interrupt of thread blocked in read.\n+     *\/\n+    public void testRead8() throws Exception {\n+        withConnection((sc, peer) -> {\n+            Future<?> interrupter = scheduleInterrupt(Thread.currentThread(), 2000);\n+            try {\n+                InputStream in = Channels.newInputStream(sc);\n+                expectThrows(IOException.class, () -> in.read());\n+            } finally {\n+                interrupter.cancel(true);\n+                Thread.interrupted();  \/\/ clear interrupt\n+            }\n+            assertFalse(sc.isOpen());\n+        });\n+    }\n+\n+    \/**\n+     * Test that read is untimed when SO_TIMEOUT is set on the Socket adaptor.\n+     *\/\n+    public void testRead9() throws Exception {\n+        withConnection((sc, peer) -> {\n+            sc.socket().setSoTimeout(100);\n+            scheduleWrite(peer, 99, 2000);\n+            \/\/ read should block until bytes are available\n+            int b = Channels.newInputStream(sc).read();\n+            assertTrue(b == 99);\n+        });\n+    }\n+\n+    \/**\n+     * Test write.\n+     *\/\n+    public void testWrite1() throws Exception {\n+        withConnection((sc, peer) -> {\n+            OutputStream out = Channels.newOutputStream(sc);\n+            out.write(99);\n+            int n = read(peer);\n+            assertEquals(n, 99);\n+        });\n+    }\n+\n+    \/**\n+     * Test async close of channel when thread blocked in write.\n+     *\/\n+    public void testWrite2() throws Exception {\n+        withConnection((sc, peer) -> {\n+            scheduleClose(sc, 2000);\n+            expectThrows(IOException.class, () -> {\n+                OutputStream out = Channels.newOutputStream(sc);\n+                byte[] data = new byte[64*1000];\n+                while (true) {\n+                    out.write(data);\n+                }\n+            });\n+        });\n+    }\n+\n+    \/**\n+     * Test async close of output stream when thread blocked in write.\n+     *\/\n+    public void testWrite3() throws Exception {\n+        withConnection((sc, peer) -> {\n+            OutputStream out = Channels.newOutputStream(sc);\n+            scheduleClose(out, 2000);\n+            expectThrows(IOException.class, () -> {\n+                byte[] data = new byte[64*1000];\n+                while (true) {\n+                    out.write(data);\n+                }\n+            });\n+        });\n+    }\n+\n+    \/**\n+     * Test interrupt status set before write.\n+     *\/\n+    public void testWrite4() throws Exception {\n+        withConnection((sc, peer) -> {\n+            Thread.currentThread().interrupt();\n+            try {\n+                OutputStream out = Channels.newOutputStream(sc);\n+                expectThrows(IOException.class, () -> out.write(99));\n+            } finally {\n+                Thread.interrupted();  \/\/ clear interrupt\n+            }\n+            assertFalse(sc.isOpen());\n+        });\n+    }\n+\n+    \/**\n+     * Test interrupt of thread blocked in write.\n+     *\/\n+    public void testWrite5() throws Exception {\n+        withConnection((sc, peer) -> {\n+            Future<?> interrupter = scheduleInterrupt(Thread.currentThread(), 2000);\n+            try {\n+                expectThrows(IOException.class, () -> {\n+                    OutputStream out = Channels.newOutputStream(sc);\n+                    byte[] data = new byte[64*1000];\n+                    while (true) {\n+                        out.write(data);\n+                    }\n+                });\n+            } finally {\n+                interrupter.cancel(true);\n+                Thread.interrupted();  \/\/ clear interrupt\n+            }\n+            assertFalse(sc.isOpen());\n+        });\n+    }\n+\n+    \/**\n+     * Test read when another thread is blocked in write. The read should\n+     * complete immediately.\n+     *\/\n+    public void testConcurrentReadWrite1() throws Exception {\n+        withConnection((sc, peer) -> {\n+            InputStream in = Channels.newInputStream(sc);\n+            OutputStream out = Channels.newOutputStream(sc);\n+\n+            \/\/ block thread in write\n+            fork(() -> {\n+                var data = new byte[64*1024];\n+                for (;;) {\n+                    out.write(data);\n+                }\n+            });\n+            Thread.sleep(1000); \/\/ give writer time to block\n+\n+            \/\/ test read, should not be blocked by writer thread\n+            write(peer, 99);\n+            int n = in.read();\n+            assertEquals(n, 99);\n+        });\n+    }\n+\n+    \/**\n+     * Test read when another thread is blocked in write. The read should\n+     * block until bytes are available.\n+     *\/\n+    public void testConcurrentReadWrite2() throws Exception {\n+        withConnection((sc, peer) -> {\n+            InputStream in = Channels.newInputStream(sc);\n+            OutputStream out = Channels.newOutputStream(sc);\n+\n+            \/\/ block thread in write\n+            fork(() -> {\n+                var data = new byte[64*1024];\n+                for (;;) {\n+                    out.write(data);\n+                }\n+            });\n+            Thread.sleep(1000); \/\/ give writer time to block\n+\n+            \/\/ test read, should not be blocked by writer thread\n+            scheduleWrite(peer, 99, 500);\n+            int n = in.read();\n+            assertEquals(n, 99);\n+        });\n+    }\n+\n+    \/**\n+     * Test writing when another thread is blocked in read.\n+     *\/\n+    public void testConcurrentReadWrite3() throws Exception {\n+        withConnection((sc, peer) -> {\n+            InputStream in = Channels.newInputStream(sc);\n+            OutputStream out = Channels.newOutputStream(sc);\n+\n+            \/\/ block thread in read\n+            fork(() -> {\n+                in.read();\n+            });\n+            Thread.sleep(100); \/\/ give reader time to block\n+\n+            \/\/ test write, should not be blocked by reader thread\n+            out.write(99);\n+            int n = read(peer);\n+            assertEquals(n, 99);\n+        });\n+    }\n+\n+    \/**\n+     * Test read\/write when channel configured non-blocking.\n+     *\/\n+    public void testIllegalBlockingMode() throws Exception {\n+        withConnection((sc, peer) -> {\n+            InputStream in = Channels.newInputStream(sc);\n+            OutputStream out = Channels.newOutputStream(sc);\n+\n+            sc.configureBlocking(false);\n+            expectThrows(IllegalBlockingModeException.class, () -> in.read());\n+            expectThrows(IllegalBlockingModeException.class, () -> out.write(99));\n+        });\n+    }\n+\n+    \/**\n+     * Test NullPointerException.\n+     *\/\n+    public void testNullPointerException() throws Exception {\n+        withConnection((sc, peer) -> {\n+            InputStream in = Channels.newInputStream(sc);\n+            OutputStream out = Channels.newOutputStream(sc);\n+\n+            expectThrows(NullPointerException.class, () -> in.read(null));\n+            expectThrows(NullPointerException.class, () -> in.read(null, 0, 0));\n+\n+            expectThrows(NullPointerException.class, () -> out.write(null));\n+            expectThrows(NullPointerException.class, () -> out.write(null, 0, 0));\n+        });\n+    }\n+\n+    \/**\n+     * Test IndexOutOfBoundsException.\n+     *\/\n+    public void testIndexOutOfBoundsException() throws Exception {\n+        withConnection((sc, peer) -> {\n+            InputStream in = Channels.newInputStream(sc);\n+            OutputStream out = Channels.newOutputStream(sc);\n+            byte[] ba = new byte[100];\n+\n+            expectThrows(IndexOutOfBoundsException.class, () -> in.read(ba, -1, 1));\n+            expectThrows(IndexOutOfBoundsException.class, () -> in.read(ba, 0, -1));\n+            expectThrows(IndexOutOfBoundsException.class, () -> in.read(ba, 0, 1000));\n+            expectThrows(IndexOutOfBoundsException.class, () -> in.read(ba, 1, 100));\n+\n+            expectThrows(IndexOutOfBoundsException.class, () -> out.write(ba, -1, 1));\n+            expectThrows(IndexOutOfBoundsException.class, () -> out.write(ba, 0, -1));\n+            expectThrows(IndexOutOfBoundsException.class, () -> out.write(ba, 0, 1000));\n+            expectThrows(IndexOutOfBoundsException.class, () -> out.write(ba, 1, 100));\n+        });\n+    }\n+\n+    \/\/ -- test infrastructure --\n+\n+    private interface ThrowingTask {\n+        void run() throws Exception;\n+    }\n+\n+    private interface ThrowingBiConsumer<T, U> {\n+        void accept(T t, U u) throws Exception;\n+    }\n+\n+    \/**\n+     * Invokes the consumer with a connected pair of socket channels.\n+     *\/\n+    private static void withConnection(ThrowingBiConsumer<SocketChannel, SocketChannel> consumer)\n+        throws Exception\n+    {\n+        var loopback = InetAddress.getLoopbackAddress();\n+        try (ServerSocketChannel listener = ServerSocketChannel.open()) {\n+            listener.bind(new InetSocketAddress(loopback, 0));\n+            try (SocketChannel sc = SocketChannel.open(listener.getLocalAddress())) {\n+                try (SocketChannel peer = listener.accept()) {\n+                    consumer.accept(sc, peer);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Forks a thread to execute the given task.\n+     *\/\n+    private Future<?> fork(ThrowingTask task) {\n+        ExecutorService pool = Executors.newFixedThreadPool(1);\n+        try {\n+            return pool.submit(() -> {\n+                task.run();\n+                return null;\n+            });\n+        } finally {\n+            pool.shutdown();\n+        }\n+    }\n+\n+    \/**\n+     * Read a byte from the given socket channel.\n+     *\/\n+    private int read(SocketChannel sc) throws IOException {\n+        return sc.socket().getInputStream().read();\n+    }\n+\n+    \/**\n+     * Write a byte to the given socket channel.\n+     *\/\n+    private void write(SocketChannel sc, int b) throws IOException {\n+        sc.socket().getOutputStream().write(b);\n+    }\n+\n+    \/**\n+     * Writes the given data to the socket channel after a delay.\n+     *\/\n+    private Future<?> scheduleWrite(SocketChannel sc, byte[] data, long delay) {\n+        return schedule(() -> {\n+            try {\n+                sc.socket().getOutputStream().write(data);\n+            } catch (IOException ioe) { }\n+        }, delay);\n+    }\n+\n+    \/**\n+     * Writes a byte to the socket channel after a delay.\n+     *\/\n+    private Future<?> scheduleWrite(SocketChannel sc, int b, long delay) {\n+        return scheduleWrite(sc, new byte[] { (byte)b }, delay);\n+    }\n+\n+    \/**\n+     * Closes the given object after a delay.\n+     *\/\n+    private Future<?> scheduleClose(Closeable c, long delay) {\n+        return schedule(() -> {\n+            try {\n+                c.close();\n+            } catch (IOException ioe) { }\n+        }, delay);\n+    }\n+\n+    \/**\n+     * Interrupts the given Thread after a delay.\n+     *\/\n+    private Future<?> scheduleInterrupt(Thread t, long delay) {\n+        return schedule(() -> t.interrupt(), delay);\n+    }\n+\n+    \/**\n+     * Schedules the given task to run after a delay.\n+     *\/\n+    private Future<?> schedule(Runnable task, long delay) {\n+        return executor.schedule(task, delay, TimeUnit.MILLISECONDS);\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/SocketChannelStreams.java","additions":480,"deletions":0,"binary":false,"changes":480,"status":"added"}]}