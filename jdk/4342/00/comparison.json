{"files":[{"patch":"@@ -1098,0 +1098,11 @@\n+bool G1CollectedHeap::upgrade_to_full_collection() {\n+  log_info(gc, ergo)(\"Attempting full compaction clearing soft references\");\n+  bool success = do_full_collection(false \/* explicit gc *\/,\n+                                    true  \/* clear_all_soft_refs *\/,\n+                                    false \/* do_maximum_compaction *\/);\n+  \/\/ do_full_collection only fails if blocked by GC locker and that can't\n+  \/\/ be the case here since we only call this when already completed one gc.\n+  assert(success, \"invariant\");\n+  return success;\n+}\n+\n@@ -1115,1 +1126,1 @@\n-                                                            bool clear_all_soft_refs,\n+                                                            bool maximum_compaction,\n@@ -1137,3 +1148,0 @@\n-    \/\/ When clear_all_soft_refs is set we want to do a maximum compaction\n-    \/\/ not leaving any dead wood.\n-    bool do_maximum_compaction = clear_all_soft_refs;\n@@ -1141,0 +1149,7 @@\n+    \/\/ If maximum_compaction is set we clear all soft references and don't\n+    \/\/ allow any dead wood to be left on the heap.\n+    if (maximum_compaction) {\n+      log_info(gc, ergo)(\"Attempting maximum full compaction clearing soft references\");\n+    } else {\n+      log_info(gc, ergo)(\"Attempting full compaction\");\n+    }\n@@ -1142,2 +1157,2 @@\n-                                       clear_all_soft_refs,\n-                                       do_maximum_compaction);\n+                                       maximum_compaction \/* clear_all_soft_refs *\/ ,\n+                                       maximum_compaction \/* do_maximum_compaction *\/);\n@@ -1157,1 +1172,1 @@\n-                                     false, \/* clear_all_soft_refs *\/\n+                                     false, \/* maximum_collection *\/\n@@ -1168,1 +1183,1 @@\n-                                            true, \/* clear_all_soft_refs *\/\n+                                            true, \/* maximum_collection *\/\n@@ -1179,1 +1194,1 @@\n-                                            false, \/* clear_all_soft_refs *\/\n+                                            false, \/* maximum_collection *\/\n@@ -2837,9 +2852,0 @@\n-  if (should_upgrade_to_full_gc(gc_cause())) {\n-    log_info(gc, ergo)(\"Attempting maximally compacting collection\");\n-    bool result = do_full_collection(false \/* explicit gc *\/,\n-                                     true  \/* clear_all_soft_refs *\/,\n-                                     false \/* do_maximum_compaction *\/);\n-    \/\/ do_full_collection only fails if blocked by GC locker, but\n-    \/\/ we've already checked for that above.\n-    assert(result, \"invariant\");\n-  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":24,"deletions":18,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -519,0 +519,3 @@\n+  \/\/ Helper to do a full collection that clears soft references.\n+  bool upgrade_to_full_collection();\n+\n@@ -537,1 +540,1 @@\n-                                             bool clear_all_soft_refs,\n+                                             bool maximum_compaction,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -97,3 +97,1 @@\n-  } else if (g1h->do_collection_pause_at_safepoint(_target_pause_time_ms)) {\n-    _gc_succeeded = true;\n-  } else {\n+  } else if (!g1h->do_collection_pause_at_safepoint(_target_pause_time_ms)) {\n@@ -105,0 +103,4 @@\n+  } else if (g1h->should_upgrade_to_full_gc(_gc_cause)) {\n+    _gc_succeeded = g1h->upgrade_to_full_collection();\n+  } else {\n+    _gc_succeeded = true;\n@@ -141,4 +143,11 @@\n-  if (_gc_succeeded && (_word_size > 0)) {\n-    \/\/ An allocation had been requested. Do it, eventually trying a stronger\n-    \/\/ kind of GC.\n-    _result = g1h->satisfy_failed_allocation(_word_size, &_gc_succeeded);\n+  if (_gc_succeeded) {\n+    if (_word_size > 0) {\n+      \/\/ An allocation had been requested. Do it, eventually trying a stronger\n+      \/\/ kind of GC.\n+      _result = g1h->satisfy_failed_allocation(_word_size, &_gc_succeeded);\n+    } else if (g1h->should_upgrade_to_full_gc(_gc_cause)) {\n+      \/\/ There has been a request to perform a GC to free some space. We have no\n+      \/\/ information on how much memory has been asked for. In case there are\n+      \/\/ absolutely no regions left to allocate into, do a full compaction.\n+      _gc_succeeded = g1h->upgrade_to_full_collection();\n+    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"}]}