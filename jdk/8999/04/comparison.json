{"files":[{"patch":"@@ -941,0 +941,2 @@\n+  \/\/ Note: Any modifications to following suppressed feature list for KNL target\n+  \/\/ should also be applied to test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -101,0 +101,21 @@\n+    \/**\n+     * Accepts a single feature pair which is composed of CPU feature string followed by a true\/false\n+     * value where a true value necessities existence of CPU feature and vice-versa.\n+     * IR verifications checks are enforced only if the specified feature constraint is met.\n+     *\/\n+    String[] applyIfCPUFeature() default {};\n+\n+    \/**\n+     * Accepts a list of feature pairs where each pair is composed of target feature string followed by a true\/false\n+     * value where a true value necessities existence of target feature and vice-versa.\n+     * IR verifications checks are enforced only if all the specified feature constraints are met.\n+     *\/\n+    String[] applyIfCPUFeatureAnd() default {};\n+\n+     \/**\n+     * Accepts a list of feature pairs where each pair is composed of target feature string followed by a true\/false\n+     * value where a true value necessities existence of target feature and vice-versa.\n+     * IR verifications checks are enforced if any of the specified feature constraint is met.\n+     *\/\n+    String[] applyIfCPUFeatureOr() default {};\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IR.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -169,0 +169,1 @@\n+    public static final String ADD_VI = START + \"AddVI\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.HashSet;\n@@ -75,1 +76,1 @@\n-                    if (shouldApplyIrRule(irAnno)) {\n+                    if (shouldApplyIrRule(irAnno, m.getName())) {\n@@ -97,1 +98,1 @@\n-    private boolean shouldApplyIrRule(IR irAnno) {\n+    private boolean shouldApplyIrRule(IR irAnno, String m) {\n@@ -103,1 +104,6 @@\n-            return hasAllRequiredFlags(irAnno.applyIf(), \"applyIf\");\n+            boolean check = hasAllRequiredFlags(irAnno.applyIf(), \"applyIf\");\n+            if (!check) {\n+                TestFrameworkSocket.write(\"Disabling IR matching for \" + m + \": Flag constraint not met.\",\n+                                     \"[IREncodingPrinter]\", true);\n+            }\n+            return check;\n@@ -107,1 +113,6 @@\n-            return hasNoRequiredFlags(irAnno.applyIfNot(), \"applyIfNot\");\n+            boolean check = hasNoRequiredFlags(irAnno.applyIfNot(), \"applyIfNot\");\n+            if (!check) {\n+                TestFrameworkSocket.write(\"Disabling IR matching for \" + m + \": Flag constraint not met.\",\n+                                     \"[IREncodingPrinter]\", true);\n+            }\n+            return check;\n@@ -111,1 +122,6 @@\n-            return hasAllRequiredFlags(irAnno.applyIfAnd(), \"applyIfAnd\");\n+            boolean check = hasAllRequiredFlags(irAnno.applyIfAnd(), \"applyIfAnd\");\n+            if (!check) {\n+                TestFrameworkSocket.write(\"Disabling IR matching for \" + m + \": All flag constraints not met.\",\n+                                     \"[IREncodingPrinter]\", true);\n+            }\n+            return check;\n@@ -115,1 +131,33 @@\n-            return !hasNoRequiredFlags(irAnno.applyIfOr(), \"applyIfOr\");\n+            boolean check = hasNoRequiredFlags(irAnno.applyIfOr(), \"applyIfOr\");\n+            if (check) {\n+                TestFrameworkSocket.write(\"Disabling IR matching for \" + m + \": None of the flag constraint met.\",\n+                                     \"[IREncodingPrinter]\", true);\n+            }\n+            return !check;\n+        }\n+\n+        if (irAnno.applyIfCPUFeature().length != 0) {\n+            boolean check = hasAllRequiredCPUFeature(irAnno.applyIfCPUFeature());\n+            if (!check) {\n+                TestFrameworkSocket.write(\"Disabling IR matching for \" + m + \": Feature constraint not met.\",\n+                                     \"[IREncodingPrinter]\", true);\n+            }\n+            return check;\n+        }\n+\n+        if (irAnno.applyIfCPUFeatureAnd().length != 0) {\n+            boolean check = hasAllRequiredCPUFeature(irAnno.applyIfCPUFeatureAnd());\n+            if (!check) {\n+                TestFrameworkSocket.write(\"Disabling IR matching for \" + m + \": All feature constraints not met.\",\n+                                     \"[IREncodingPrinter]\", true);\n+            }\n+            return check;\n+        }\n+\n+        if (irAnno.applyIfCPUFeatureOr().length != 0) {\n+            boolean check = hasAnyRequiredCPUFeature(irAnno.applyIfCPUFeatureOr());\n+            if (!check) {\n+                TestFrameworkSocket.write(\"Disabling IR matching for \" + m + \": None of the feature constraint met.\",\n+                                     \"[IREncodingPrinter]\", true);\n+            }\n+            return check;\n@@ -124,1 +172,2 @@\n-        int applyRules = 0;\n+        int flagConstraints = 0;\n+        int cpuFeatureConstraints = 0;\n@@ -126,1 +175,1 @@\n-            applyRules++;\n+            flagConstraints++;\n@@ -131,1 +180,1 @@\n-            applyRules++;\n+            flagConstraints++;\n@@ -136,1 +185,1 @@\n-            applyRules++;\n+            flagConstraints++;\n@@ -140,0 +189,15 @@\n+        if (irAnno.applyIfCPUFeature().length != 0) {\n+            cpuFeatureConstraints++;\n+            TestFormat.checkNoThrow(irAnno.applyIfCPUFeature().length == 2,\n+                                    \"applyIfCPUFeature expects single CPU feature pair\" + failAt());\n+        }\n+        if (irAnno.applyIfCPUFeatureAnd().length != 0) {\n+            cpuFeatureConstraints++;\n+            TestFormat.checkNoThrow((irAnno.applyIfCPUFeatureAnd().length % 2) == 0 && irAnno.applyIfCPUFeatureAnd().length >= 2,\n+                                    \"applyIfCPUFeatureAnd expects more than one CPU feature pair\" + failAt());\n+        }\n+        if (irAnno.applyIfCPUFeatureOr().length != 0) {\n+            cpuFeatureConstraints++;\n+            TestFormat.checkNoThrow((irAnno.applyIfCPUFeatureOr().length % 2) == 0 && irAnno.applyIfCPUFeatureOr().length >= 2,\n+                                    \"applyIfCPUFeatureOr expects more than one CPU feature pair\" + failAt());\n+        }\n@@ -141,1 +205,1 @@\n-            applyRules++;\n+            flagConstraints++;\n@@ -145,2 +209,2 @@\n-        TestFormat.checkNoThrow(applyRules <= 1,\n-                                \"Can only specify one apply constraint \" + failAt());\n+        TestFormat.checkNoThrow(flagConstraints <= 1, \"Can only specify one flag constraint\" + failAt());\n+        TestFormat.checkNoThrow(cpuFeatureConstraints <= 1, \"Can only specify one CPU feature constraint\" + failAt());\n@@ -179,0 +243,66 @@\n+    private boolean hasAllRequiredCPUFeature(String[] andRules) {\n+        boolean returnValue = true;\n+        for (int i = 0; i < andRules.length; i++) {\n+            String feature = andRules[i].trim();\n+            i++;\n+            String value = andRules[i].trim();\n+            returnValue &= checkCPUFeature(feature, value);\n+        }\n+        return returnValue;\n+    }\n+\n+    private boolean hasAnyRequiredCPUFeature(String[] orRules) {\n+        boolean returnValue = false;\n+        for (int i = 0; i < orRules.length; i++) {\n+            String feature = orRules[i].trim();\n+            i++;\n+            String value = orRules[i].trim();\n+            returnValue |= checkCPUFeature(feature, value);\n+        }\n+        return returnValue;\n+    }\n+\n+    private boolean checkCPUFeature(String feature, String value) {\n+        if (feature.isEmpty()) {\n+            TestFormat.failNoThrow(\"Provided empty feature\" + failAt());\n+            return false;\n+        }\n+        if (value.isEmpty()) {\n+            TestFormat.failNoThrow(\"Provided empty value for feature \" + feature + failAt());\n+            return false;\n+        }\n+\n+        boolean trueValue = value.contains(\"true\");\n+        boolean falseValue = value.contains(\"false\");\n+\n+        if (!trueValue && !falseValue) {\n+            TestFormat.failNoThrow(\"Provided incorrect value for feature \" + feature + failAt());\n+            return false;\n+        }\n+        String cpuFeatures = WHITE_BOX.getCPUFeatures();\n+        \/\/ Following feature list is in sync with suppressed feature list for KNL target.\n+        \/\/ Please refer vm_version_x86.cpp for details.\n+        HashSet<String> knlFeatureSet = new HashSet<>();\n+        knlFeatureSet.add(\"AVX512BW\");\n+        knlFeatureSet.add(\"AVX512VL\");\n+        knlFeatureSet.add(\"AVX512DQ\");\n+        knlFeatureSet.add(\"AVX512_VNNI\");\n+        knlFeatureSet.add(\"AVX512_VAES\");\n+        knlFeatureSet.add(\"AVX512_VPOPCNTDQ\");\n+        knlFeatureSet.add(\"AVX512_VPCLMULQDQ\");\n+        knlFeatureSet.add(\"AVX512_VBMI\");\n+        knlFeatureSet.add(\"AVX512_VBMI2\");\n+        knlFeatureSet.add(\"CLWB\");\n+        knlFeatureSet.add(\"FLUSHOPT\");\n+        knlFeatureSet.add(\"GFNI\");\n+        knlFeatureSet.add(\"AVX512_BITALG\");\n+        Boolean isKNLFlagEnabled = WHITE_BOX.getBooleanVMFlag(\"UseKNLSetting\");\n+        \/\/ Perform the feature check if UseKNLSetting flag is set to off or if\n+        \/\/ feature is supported by KNL target.\n+        if (isKNLFlagEnabled == null ||\n+             (isKNLFlagEnabled && (!knlFeatureSet.contains(feature.toUpperCase()) || falseValue))) {\n+            return (trueValue && cpuFeatures.contains(feature)) || (falseValue && !cpuFeatures.contains(feature));\n+        }\n+        return false;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":143,"deletions":13,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.driver.irmatching.IRViolationException;\n+\n+\/*\n+ * @test 8287525\n+ * @summary Extend IR annotation with new options to test specific target feature.\n+ * @requires vm.cpu.features ~= \".*avx512f.*\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorapi.TestCPUFeatureCheck\n+ *\/\n+\n+public class TestCPUFeatureCheck {\n+    private static int a[] = new int[1000];\n+    private static int b[] = new int[1000];\n+    private static int res[] = new int[1000];\n+\n+    public static void setup() {\n+        for (int i = 0; i < 1000; i++) {\n+            a[i] = i;\n+            b[i] = i;\n+        }\n+    }\n+\n+    public static void main(String args[]) {\n+        setup();\n+        TestFramework.runWithFlags(\"-XX:-TieredCompilation\",\n+                                   \"-XX:UseAVX=3\",\n+                                   \"-XX:+UseKNLSetting\",\n+                                   \"-XX:CompileThresholdScaling=0.3\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\"}, applyIfCPUFeature = {\"avx512bw\", \"false\"})\n+    public static void test1() {\n+        for (int i = 0; i < 1000; i++) {\n+            res[i] = a[i] + b[i];\n+        }\n+    }\n+\n+    \/\/ IR rule is enforced if all the feature conditions holds good\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\"}, applyIfCPUFeatureAnd = {\"avx512bw\", \"false\", \"avx512f\", \"true\"})\n+    public static void test2() {\n+        for (int i = 0; i < 1000; i++) {\n+            res[i] = a[i] + b[i];\n+        }\n+    }\n+\n+    \/\/ IR rule is enforced if any of the feature condition holds good\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI,  \"> 0\"}, applyIfCPUFeatureOr = {\"avx512bw\", \"true\", \"avx512f\", \"true\"})\n+    public static void test3() {\n+        for (int i = 0; i < 1000; i++) {\n+            res[i] = a[i] + b[i];\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestCPUFeatureCheck.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"}]}