{"files":[{"patch":"@@ -645,43 +645,1 @@\n-\n-  \/\/ Special handling for NMT preinit phase before arguments are parsed\n-  void* rc = nullptr;\n-  if (NMTPreInit::handle_malloc(&rc, size)) {\n-    \/\/ No need to fill with 0 because DumpSharedSpaces doesn't use these\n-    \/\/ early allocations.\n-    return rc;\n-  }\n-\n-  DEBUG_ONLY(check_crash_protection());\n-\n-  \/\/ On malloc(0), implementations of malloc(3) have the choice to return either\n-  \/\/ null or a unique non-null pointer. To unify libc behavior across our platforms\n-  \/\/ we chose the latter.\n-  size = MAX2((size_t)1, size);\n-\n-  \/\/ For the test flag -XX:MallocMaxTestWords\n-  if (has_reached_max_malloc_test_peak(size)) {\n-    return nullptr;\n-  }\n-\n-  const size_t outer_size = size + MemTracker::overhead_per_malloc();\n-\n-  \/\/ Check for overflow.\n-  if (outer_size < size) {\n-    return nullptr;\n-  }\n-\n-  ALLOW_C_FUNCTION(::malloc, void* const outer_ptr = ::malloc(outer_size);)\n-  if (outer_ptr == nullptr) {\n-    return nullptr;\n-  }\n-\n-  void* const inner_ptr = MemTracker::record_malloc((address)outer_ptr, size, memflags, stack);\n-\n-  if (DumpSharedSpaces) {\n-    \/\/ Need to deterministically fill all the alignment gaps in C++ structures.\n-    ::memset(inner_ptr, 0, size);\n-  } else {\n-    DEBUG_ONLY(::memset(inner_ptr, uninitBlockPad, size);)\n-  }\n-  DEBUG_ONLY(break_if_ptr_caught(inner_ptr);)\n-  return inner_ptr;\n+  return os::realloc(nullptr, size, memflags, stack);\n@@ -702,5 +660,1 @@\n-  if (memblock == nullptr) {\n-    return os::malloc(size, memflags, stack);\n-  }\n-\n-  DEBUG_ONLY(check_crash_protection());\n+  DEBUG_ONLY(check_crash_protection();)\n@@ -718,2 +672,1 @@\n-  if (MemTracker::enabled()) {\n-    \/\/ NMT realloc handling\n+  const size_t outer_size = size + MemTracker::overhead_per_malloc();\n@@ -721,1 +674,4 @@\n-    const size_t new_outer_size = size + MemTracker::overhead_per_malloc();\n+  \/\/ Check for overflow.\n+  if (outer_size < size) {\n+    return nullptr;\n+  }\n@@ -723,3 +679,11 @@\n-    \/\/ Handle size overflow.\n-    if (new_outer_size < size) {\n-      return nullptr;\n+  if (MemTracker::enabled()) {\n+    MallocHeader* header = nullptr;\n+    MallocHeader::FreeInfo free_info;\n+    size_t old_size = 0;\n+    if (memblock != nullptr) {\n+      \/\/ Perform integrity checks on and mark the old block as dead *before* calling the real realloc(3)\n+      \/\/ since it may invalidate the old block, including its header.\n+      header = MallocHeader::resolve_checked(memblock);\n+      free_info = header->free_info();\n+      old_size = free_info.size;\n+      header->mark_block_as_dead();\n@@ -728,8 +692,0 @@\n-    \/\/ Perform integrity checks on and mark the old block as dead *before* calling the real realloc(3) since it\n-    \/\/ may invalidate the old block, including its header.\n-    MallocHeader* header = MallocHeader::resolve_checked(memblock);\n-    assert(memflags == header->flags(), \"weird NMT flags mismatch (new:\\\"%s\\\" != old:\\\"%s\\\")\\n\",\n-           NMTUtil::flag_to_name(memflags), NMTUtil::flag_to_name(header->flags()));\n-    const MallocHeader::FreeInfo free_info = header->free_info();\n-    header->mark_block_as_dead();\n-\n@@ -737,6 +693,7 @@\n-    ALLOW_C_FUNCTION(::realloc, void* const new_outer_ptr = ::realloc(header, new_outer_size);)\n-\n-    if (new_outer_ptr == nullptr) {\n-      \/\/ realloc(3) failed and the block still exists.\n-      \/\/ We have however marked it as dead, revert this change.\n-      header->revive();\n+    ALLOW_C_FUNCTION(::realloc, rc = ::realloc(header, outer_size);)\n+    if (rc == nullptr) {\n+      if (header != nullptr) {\n+        \/\/ realloc(3) failed and the block still exists.\n+        \/\/ We have however marked it as dead, revert this change.\n+        header->revive();\n+      }\n@@ -745,2 +702,0 @@\n-    \/\/ realloc(3) succeeded, variable header now points to invalid memory and we need to deaccount the old block.\n-    MemTracker::deaccount(free_info);\n@@ -748,9 +703,4 @@\n-    \/\/ After a successful realloc(3), we account the resized block with its new size\n-    \/\/ to NMT.\n-    void* const new_inner_ptr = MemTracker::record_malloc(new_outer_ptr, size, memflags, stack);\n-\n-#ifdef ASSERT\n-    size_t old_size = free_info.size;\n-    if (old_size < size) {\n-      \/\/ We also zap the newly extended region.\n-      ::memset((char*)new_inner_ptr + old_size, uninitBlockPad, size - old_size);\n+    if (header != nullptr) {\n+      \/\/ realloc(3) succeeded, variable header now points to invalid memory\n+      \/\/ and we need to deaccount the old block.\n+      MemTracker::deaccount(free_info);\n@@ -758,1 +708,0 @@\n-#endif\n@@ -760,1 +709,2 @@\n-    rc = new_inner_ptr;\n+    \/\/ After a successful realloc(3), we account the resized block with its new size to NMT.\n+    rc = MemTracker::record_malloc(rc, size, memflags, stack);\n@@ -762,0 +712,11 @@\n+    if (old_size < size) {\n+      if (DumpSharedSpaces) {\n+        \/\/ Need to deterministically fill all the alignment gaps in C++ structures.\n+        ::memset((char*)rc + old_size, 0, size - old_size);\n+#ifdef ASSERT\n+      } else {\n+        \/\/ We also zap the newly allocated region.\n+        DEBUG_ONLY(::memset((char*)rc + old_size, uninitBlockPad, size - old_size);)\n+#endif\n+      }\n+    }\n@@ -777,1 +738,1 @@\n-void  os::free(void *memblock) {\n+void os::free(void *memblock) {\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":43,"deletions":82,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -123,3 +123,3 @@\n-    const size_t size;\n-    const MEMFLAGS flags;\n-    const uint32_t mst_marker;\n+    size_t size;\n+    MEMFLAGS flags;\n+    uint32_t mst_marker;\n","filename":"src\/hotspot\/share\/services\/mallocHeader.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,3 +34,2 @@\n-\/\/ Obviously we cannot use os::malloc for any dynamic allocation during pre-NMT-init, so we must use\n-\/\/ raw malloc; to make this very clear, wrap them.\n-static void* raw_malloc(size_t s)               { ALLOW_C_FUNCTION(::malloc, return ::malloc(s);) }\n+\/\/ Obviously we cannot use os::realloc for any dynamic allocation during pre-NMT-init,\n+\/\/ so we must use raw realloc; to make this very clear, wrap them.\n@@ -54,8 +53,1 @@\n-  const size_t outer_size = sizeof(NMTPreInitAllocation) + payload_size;\n-  guarantee(outer_size > payload_size, \"Overflow\");\n-  void* p = raw_malloc(outer_size);\n-  if (p == nullptr) {\n-    fail_oom(outer_size);\n-  }\n-  NMTPreInitAllocation* a = new(p) NMTPreInitAllocation(payload_size);\n-  return a;\n+  return do_reallocate(nullptr, payload_size);\n@@ -65,1 +57,2 @@\n-  assert(old->next == nullptr, \"unhang from map first\");\n+  DEBUG_ONLY(if (old != nullptr) assert(old->next == nullptr, \"unhang from map first\");)\n+\n@@ -164,1 +157,0 @@\n-unsigned NMTPreInit::_num_mallocs_pre = 0;\n@@ -170,1 +162,1 @@\n-  void* p = raw_malloc(sizeof(NMTPreInitAllocationTable));\n+  void* p = raw_realloc(nullptr, sizeof(NMTPreInitAllocationTable));\n@@ -191,2 +183,1 @@\n-  assert(_num_reallocs_pre <= _num_mallocs_pre &&\n-         _num_frees_pre <= _num_mallocs_pre, \"stats are off\");\n+  assert(_num_frees_pre <= _num_reallocs_pre, \"stats are off\");\n@@ -201,2 +192,1 @@\n-  st->print_cr(\"pre-init mallocs: %u, pre-init reallocs: %u, pre-init frees: %u\",\n-               _num_mallocs_pre, _num_reallocs_pre, _num_frees_pre);\n+  st->print_cr(\"pre-init reallocs: %u, pre-init frees: %u\", _num_reallocs_pre, _num_frees_pre);\n","filename":"src\/hotspot\/share\/services\/nmtPreInit.cpp","additions":8,"deletions":18,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -223,1 +223,0 @@\n-  static unsigned _num_mallocs_pre;           \/\/ Number of pre-init mallocs\n@@ -262,12 +261,2 @@\n-  static bool handle_malloc(void** rc, size_t size) {\n-    size = MAX2((size_t)1, size);         \/\/ malloc(0)\n-    if (!MemTracker::is_initialized()) {\n-      \/\/ pre-NMT-init:\n-      \/\/ Allocate entry and add address to lookup table\n-      NMTPreInitAllocation* a = NMTPreInitAllocation::do_alloc(size);\n-      add_to_map(a);\n-      (*rc) = a->payload();\n-      _num_mallocs_pre++;\n-      return true;\n-    }\n-    return false;\n+  static bool handle_malloc(void** rc, size_t size, MEMFLAGS memflags) {\n+    return handle_realloc(rc, nullptr, size, memflags);\n@@ -280,4 +269,0 @@\n-    if (old_p == nullptr) {                  \/\/ realloc(null, n)\n-      return handle_malloc(rc, new_size);\n-    }\n-    new_size = MAX2((size_t)1, new_size); \/\/ realloc(.., 0)\n@@ -286,3 +271,8 @@\n-      \/\/ - the address must already be in the lookup table\n-      \/\/ - find the old entry, remove from table, reallocate, add to table\n-      NMTPreInitAllocation* a = find_and_remove_in_map(old_p);\n+      new_size = MAX2((size_t)1, new_size); \/\/ realloc(.., 0)\n+      NMTPreInitAllocation* a = nullptr;\n+      if (old_p != nullptr) {\n+        \/\/ - the address must already be in the lookup table\n+        \/\/ - find the old entry, remove from table\n+        a = find_and_remove_in_map(old_p);\n+      }\n+      \/\/ - reallocate\n@@ -290,0 +280,1 @@\n+      \/\/ - add address to lookup table\n","filename":"src\/hotspot\/share\/services\/nmtPreInit.hpp","additions":11,"deletions":20,"binary":false,"changes":31,"status":"modified"}]}