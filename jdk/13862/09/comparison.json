{"files":[{"patch":"@@ -1314,0 +1314,3 @@\n+  \/\/ Vector Slide Instructions\n+  INSN(vslidedown_vi, 0b1010111, 0b011, 0b001111);\n+\n@@ -1514,0 +1517,3 @@\n+  \/\/ Vector Slide Instructions\n+  INSN(vslidedown_vx, 0b1010111, 0b100, 0b001111);\n+\n@@ -1526,0 +1532,10 @@\n+#define INSN(NAME, op, funct3, vm, funct6)                                                         \\\n+  void NAME(VectorRegister Vd, VectorRegister Vs2, FloatRegister Rs1) {                            \\\n+    patch_VArith(op, Vd, funct3, Rs1->raw_encoding(), Vs2, vm, funct6);                            \\\n+  }\n+\n+  \/\/ Vector Floating-Point Merge Instruction\n+  INSN(vfmerge_vfm,  0b1010111, 0b101, 0b0, 0b010111);\n+\n+#undef INSN\n+\n@@ -1764,2 +1780,0 @@\n-  INSN(vluxei8_v,  0b0000111, 0b000, 0b01, 0b0);\n-  INSN(vluxei16_v, 0b0000111, 0b101, 0b01, 0b0);\n@@ -1767,1 +1781,0 @@\n-  INSN(vluxei64_v, 0b0000111, 0b111, 0b01, 0b0);\n@@ -1769,5 +1782,3 @@\n-  \/\/ Vector ordered indexed load instructions\n-  INSN(vloxei8_v,  0b0000111, 0b000, 0b11, 0b0);\n-  INSN(vloxei16_v, 0b0000111, 0b101, 0b11, 0b0);\n-  INSN(vloxei32_v, 0b0000111, 0b110, 0b11, 0b0);\n-  INSN(vloxei64_v, 0b0000111, 0b111, 0b11, 0b0);\n+  \/\/ Vector unordered indexed store instructions\n+  INSN(vsuxei32_v, 0b0100111, 0b110, 0b01, 0b0);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1642,0 +1642,24 @@\n+\/\/ Set dst to NaN if any NaN input.\n+\/\/ The destination vector register elements corresponding to masked-off elements\n+\/\/ are handled with a mask-undisturbed policy.\n+void C2_MacroAssembler::minmax_fp_masked_v(VectorRegister dst, VectorRegister src1, VectorRegister src2,\n+                                           VectorRegister vmask, VectorRegister tmp1, VectorRegister tmp2,\n+                                           bool is_double, bool is_min, int vector_length) {\n+  assert_different_registers(src1, src2, tmp1, tmp2);\n+  vsetvli_helper(is_double ? T_DOUBLE : T_FLOAT, vector_length);\n+\n+  \/\/ Check vector elements of src1 and src2 for NaN.\n+  vmfeq_vv(tmp1, src1, src1);\n+  vmfeq_vv(tmp2, src2, src2);\n+\n+  vmandn_mm(v0, vmask, tmp1);\n+  vfadd_vv(dst, src1, src1, Assembler::v0_t);\n+  vmandn_mm(v0, vmask, tmp2);\n+  vfadd_vv(dst, src2, src2, Assembler::v0_t);\n+\n+  vmand_mm(tmp2, tmp1, tmp2);\n+  vmand_mm(v0, vmask, tmp2);\n+  is_min ? vfmin_vv(dst, src1, src2, Assembler::v0_t)\n+         : vfmax_vv(dst, src1, src2, Assembler::v0_t);\n+}\n+\n@@ -1646,1 +1670,2 @@\n-                                           bool is_double, bool is_min, int vector_length) {\n+                                           bool is_double, bool is_min, int vector_length, VectorMask vm) {\n+  assert_different_registers(dst, src1);\n@@ -1649,1 +1674,6 @@\n-  Label L_done, L_NaN;\n+  Label L_done, L_NaN_1, L_NaN_2;\n+  \/\/ Set dst to src1 if src1 is NaN\n+  is_double ? feq_d(t0, src1, src1)\n+            : feq_s(t0, src1, src1);\n+  beqz(t0, L_NaN_2);\n+\n@@ -1653,2 +1683,3 @@\n-  is_min ? vfredmin_vs(tmp1, src2, tmp2)\n-         : vfredmax_vs(tmp1, src2, tmp2);\n+  is_min ? vfredmin_vs(tmp1, src2, tmp2, vm)\n+         : vfredmax_vs(tmp1, src2, tmp2, vm);\n+  vfmv_f_s(dst, tmp1);\n@@ -1656,6 +1687,4 @@\n-  fsflags(zr);\n-  \/\/ Checking NaNs\n-  vmflt_vf(tmp2, src2, src1);\n-  frflags(t0);\n-  bnez(t0, L_NaN);\n-  j(L_done);\n+  \/\/ Checking NaNs in src2\n+  vmfne_vv(tmp1, src2, src2, vm);\n+  vcpop_m(t0, tmp1, vm);\n+  beqz(t0, L_done);\n@@ -1663,3 +1692,4 @@\n-  bind(L_NaN);\n-  vfmv_s_f(tmp2, src1);\n-  vfredusum_vs(tmp1, src2, tmp2);\n+  bind(L_NaN_1);\n+  vfredusum_vs(tmp1, src2, tmp2, vm);\n+  vfmv_f_s(dst, tmp1);\n+  j(L_done);\n@@ -1667,0 +1697,3 @@\n+  bind(L_NaN_2);\n+  is_double ? fmv_d(dst, src1)\n+            : fmv_s(dst, src1);\n@@ -1668,1 +1701,0 @@\n-  vfmv_f_s(dst, tmp1);\n@@ -1681,3 +1713,3 @@\n-void C2_MacroAssembler::reduce_integral_v(Register dst, VectorRegister tmp,\n-                                          Register src1, VectorRegister src2,\n-                                          BasicType bt, int opc, int vector_length) {\n+void C2_MacroAssembler::reduce_integral_v(Register dst, Register src1,\n+                                          VectorRegister src2, VectorRegister tmp,\n+                                          int opc, BasicType bt, int vector_length, VectorMask vm) {\n@@ -1685,1 +1717,0 @@\n-\n@@ -1687,1 +1718,0 @@\n-\n@@ -1689,1 +1719,0 @@\n-\n@@ -1693,1 +1722,1 @@\n-      vredsum_vs(tmp, src2, tmp);\n+      vredsum_vs(tmp, src2, tmp, vm);\n@@ -1696,1 +1725,1 @@\n-      vredand_vs(tmp, src2, tmp);\n+      vredand_vs(tmp, src2, tmp, vm);\n@@ -1699,1 +1728,1 @@\n-      vredor_vs(tmp, src2, tmp);\n+      vredor_vs(tmp, src2, tmp, vm);\n@@ -1702,1 +1731,1 @@\n-      vredxor_vs(tmp, src2, tmp);\n+      vredxor_vs(tmp, src2, tmp, vm);\n@@ -1705,1 +1734,1 @@\n-      vredmax_vs(tmp, src2, tmp);\n+      vredmax_vs(tmp, src2, tmp, vm);\n@@ -1708,1 +1737,1 @@\n-      vredmin_vs(tmp, src2, tmp);\n+      vredmin_vs(tmp, src2, tmp, vm);\n@@ -1713,1 +1742,0 @@\n-\n@@ -1731,2 +1759,2 @@\n-void C2_MacroAssembler::compare_integral_v(VectorRegister vd, BasicType bt, int vector_length,\n-                                           VectorRegister src1, VectorRegister src2, int cond, VectorMask vm) {\n+void C2_MacroAssembler::compare_integral_v(VectorRegister vd, VectorRegister src1, VectorRegister src2,\n+                                           int cond, BasicType bt, int vector_length, VectorMask vm) {\n@@ -1750,4 +1778,2 @@\n-void C2_MacroAssembler::compare_floating_point_v(VectorRegister vd, BasicType bt, int vector_length,\n-                                                 VectorRegister src1, VectorRegister src2,\n-                                                 VectorRegister tmp1, VectorRegister tmp2,\n-                                                 VectorRegister vmask, int cond, VectorMask vm) {\n+void C2_MacroAssembler::compare_fp_v(VectorRegister vd, VectorRegister src1, VectorRegister src2,\n+                                     int cond, BasicType bt, int vector_length, VectorMask vm) {\n@@ -1755,2 +1781,1 @@\n-  assert(vd != v0, \"should be different registers\");\n-  assert(vm == Assembler::v0_t ? vmask != v0 : true, \"vmask should not be v0\");\n+  assert(vm == Assembler::v0_t ? vd != v0 : true, \"should be different registers\");\n@@ -1758,19 +1783,0 @@\n-  \/\/ Check vector elements of src1 and src2 for quiet and signaling NaN.\n-  vfclass_v(tmp1, src1);\n-  vfclass_v(tmp2, src2);\n-  vsrl_vi(tmp1, tmp1, 8);\n-  vsrl_vi(tmp2, tmp2, 8);\n-  vmseq_vx(tmp1, tmp1, zr);\n-  vmseq_vx(tmp2, tmp2, zr);\n-  if (vm == Assembler::v0_t) {\n-    vmand_mm(tmp2, tmp1, tmp2);\n-    if (cond == BoolTest::ne) {\n-      vmandn_mm(tmp1, vmask, tmp2);\n-    }\n-    vmand_mm(v0, vmask, tmp2);\n-  } else {\n-    vmand_mm(v0, tmp1, tmp2);\n-    if (cond == BoolTest::ne) {\n-      vmnot_m(tmp1, v0);\n-    }\n-  }\n@@ -1779,7 +1785,6 @@\n-    case BoolTest::eq: vmfeq_vv(vd, src1, src2, Assembler::v0_t); break;\n-    case BoolTest::ne: vmfne_vv(vd, src1, src2, Assembler::v0_t);\n-                       vmor_mm(vd, vd, tmp1); break;\n-    case BoolTest::le: vmfle_vv(vd, src1, src2, Assembler::v0_t); break;\n-    case BoolTest::ge: vmfge_vv(vd, src1, src2, Assembler::v0_t); break;\n-    case BoolTest::lt: vmflt_vv(vd, src1, src2, Assembler::v0_t); break;\n-    case BoolTest::gt: vmfgt_vv(vd, src1, src2, Assembler::v0_t); break;\n+    case BoolTest::eq: vmfeq_vv(vd, src1, src2, vm); break;\n+    case BoolTest::ne: vmfne_vv(vd, src1, src2, vm); break;\n+    case BoolTest::le: vmfle_vv(vd, src1, src2, vm); break;\n+    case BoolTest::ge: vmfge_vv(vd, src1, src2, vm); break;\n+    case BoolTest::lt: vmflt_vv(vd, src1, src2, vm); break;\n+    case BoolTest::gt: vmfgt_vv(vd, src1, src2, vm); break;\n@@ -1866,1 +1871,0 @@\n-  vfclass_v(v0, src);                                                              \\\n@@ -1868,2 +1872,1 @@\n-  vsrl_vi(v0, v0, 8);                                                              \\\n-  vmseq_vx(v0, v0, zr);                                                            \\\n+  vmfeq_vv(v0, src, src);                                                          \\\n@@ -1878,0 +1881,40 @@\n+\n+\/\/ Extract a scalar element from an vector at position 'idx'.\n+\/\/ The input elements in src are expected to be of integral type.\n+void C2_MacroAssembler::extract_v(Register dst, VectorRegister src, BasicType bt,\n+                                  int idx, VectorRegister tmp) {\n+  assert(is_integral_type(bt), \"unsupported element type\");\n+  assert(idx >= 0, \"idx cannot be negative\");\n+  \/\/ Only need the first element after vector slidedown\n+  vsetvli_helper(bt, 1);\n+  if (idx == 0) {\n+    vmv_x_s(dst, src);\n+  } else if (idx <= 31) {\n+    vslidedown_vi(tmp, src, idx);\n+    vmv_x_s(dst, tmp);\n+  } else {\n+    mv(t0, idx);\n+    vslidedown_vx(tmp, src, t0);\n+    vmv_x_s(dst, tmp);\n+  }\n+}\n+\n+\/\/ Extract a scalar element from an vector at position 'idx'.\n+\/\/ The input elements in src are expected to be of floating point type.\n+void C2_MacroAssembler::extract_fp_v(FloatRegister dst, VectorRegister src, BasicType bt,\n+                                     int idx, VectorRegister tmp) {\n+  assert(is_floating_point_type(bt), \"unsupported element type\");\n+  assert(idx >= 0, \"idx cannot be negative\");\n+  \/\/ Only need the first element after vector slidedown\n+  vsetvli_helper(bt, 1);\n+  if (idx == 0) {\n+    vfmv_f_s(dst, src);\n+  } else if (idx <= 31) {\n+    vslidedown_vi(tmp, src, idx);\n+    vfmv_f_s(dst, tmp);\n+  } else {\n+    mv(t0, idx);\n+    vslidedown_vx(tmp, src, t0);\n+    vfmv_f_s(dst, tmp);\n+  }\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":107,"deletions":64,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -192,0 +192,4 @@\n+ void minmax_fp_masked_v(VectorRegister dst, VectorRegister src1, VectorRegister src2,\n+                         VectorRegister vmask, VectorRegister tmp1, VectorRegister tmp2,\n+                         bool is_double, bool is_min, int vector_length);\n+\n@@ -195,1 +199,2 @@\n-                         bool is_double, bool is_min, int vector_length);\n+                         bool is_double, bool is_min, int vector_length,\n+                         VectorMask vm = Assembler::unmasked);\n@@ -197,3 +202,4 @@\n- void reduce_integral_v(Register dst, VectorRegister tmp,\n-                        Register src1, VectorRegister src2,\n-                        BasicType bt, int opc, int vector_length);\n+ void reduce_integral_v(Register dst, Register src1,\n+                        VectorRegister src2, VectorRegister tmp,\n+                        int opc, BasicType bt, int vector_length,\n+                        VectorMask vm = Assembler::unmasked);\n@@ -203,2 +209,2 @@\n- void compare_integral_v(VectorRegister dst, BasicType bt, int vector_length,\n-                         VectorRegister src1, VectorRegister src2, int cond, VectorMask vm = Assembler::unmasked);\n+ void compare_integral_v(VectorRegister dst, VectorRegister src1, VectorRegister src2, int cond,\n+                         BasicType bt, int vector_length, VectorMask vm = Assembler::unmasked);\n@@ -206,3 +212,2 @@\n- void compare_floating_point_v(VectorRegister dst, BasicType bt, int vector_length,\n-                               VectorRegister src1, VectorRegister src2, VectorRegister tmp1, VectorRegister tmp2,\n-                               VectorRegister vmask, int cond, VectorMask vm = Assembler::unmasked);\n+ void compare_fp_v(VectorRegister dst, VectorRegister src1, VectorRegister src2, int cond,\n+                   BasicType bt, int vector_length, VectorMask vm = Assembler::unmasked);\n@@ -243,0 +248,3 @@\n+  void extract_v(Register dst, VectorRegister src, BasicType bt, int idx, VectorRegister tmp);\n+  void extract_fp_v(FloatRegister dst, VectorRegister src, BasicType bt, int idx, VectorRegister tmp);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1276,2 +1276,2 @@\n-  inline void vneg_v(VectorRegister vd, VectorRegister vs) {\n-    vrsub_vx(vd, vs, x0);\n+  inline void vneg_v(VectorRegister vd, VectorRegister vs, VectorMask vm = unmasked) {\n+    vrsub_vx(vd, vs, x0, vm);\n@@ -1280,2 +1280,2 @@\n-  inline void vfneg_v(VectorRegister vd, VectorRegister vs) {\n-    vfsgnjn_vv(vd, vs, vs);\n+  inline void vfneg_v(VectorRegister vd, VectorRegister vs, VectorMask vm = unmasked) {\n+    vfsgnjn_vv(vd, vs, vs, vm);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1890,79 +1890,0 @@\n-const bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n-  return match_rule_supported_vector(opcode, vlen, bt);\n-}\n-\n-\/\/ Identify extra cases that we might want to provide match rules for vector nodes and\n-\/\/ other intrinsics guarded with vector length (vlen) and element type (bt).\n-const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n-  if (!match_rule_supported(opcode) || !vector_size_supported(bt, vlen)) {\n-    return false;\n-  }\n-\n-  return op_vec_supported(opcode);\n-}\n-\n-const bool Matcher::match_rule_supported_vector_masked(int opcode, int vlen, BasicType bt) {\n-  if (!UseRVV) {\n-    return false;\n-  }\n-  switch (opcode) {\n-    case Op_AddVB:\n-    case Op_AddVS:\n-    case Op_AddVI:\n-    case Op_AddVL:\n-    case Op_AddVF:\n-    case Op_AddVD:\n-    case Op_SubVB:\n-    case Op_SubVS:\n-    case Op_SubVI:\n-    case Op_SubVL:\n-    case Op_SubVF:\n-    case Op_SubVD:\n-    case Op_MulVB:\n-    case Op_MulVS:\n-    case Op_MulVI:\n-    case Op_MulVL:\n-    case Op_MulVF:\n-    case Op_MulVD:\n-    case Op_DivVF:\n-    case Op_DivVD:\n-    case Op_VectorLoadMask:\n-    case Op_VectorMaskCmp:\n-    case Op_AndVMask:\n-    case Op_XorVMask:\n-    case Op_OrVMask:\n-    case Op_RShiftVB:\n-    case Op_RShiftVS:\n-    case Op_RShiftVI:\n-    case Op_RShiftVL:\n-    case Op_LShiftVB:\n-    case Op_LShiftVS:\n-    case Op_LShiftVI:\n-    case Op_LShiftVL:\n-    case Op_URShiftVB:\n-    case Op_URShiftVS:\n-    case Op_URShiftVI:\n-    case Op_URShiftVL:\n-    case Op_VectorBlend:\n-    case Op_VectorReinterpret:\n-      break;\n-    case Op_LoadVector:\n-      opcode = Op_LoadVectorMasked;\n-      break;\n-    case Op_StoreVector:\n-      opcode = Op_StoreVectorMasked;\n-      break;\n-    default:\n-      return false;\n-  }\n-  return match_rule_supported_vector(opcode, vlen, bt);\n-}\n-\n-const bool Matcher::vector_needs_partial_operations(Node* node, const TypeVect* vt) {\n-  return false;\n-}\n-\n-const bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":0,"deletions":79,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -31,4 +31,0 @@\n-source_hpp %{\n-  bool op_vec_supported(int opcode);\n-%}\n-\n@@ -53,1 +49,15 @@\n-  bool op_vec_supported(int opcode) {\n+  const bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n+    return match_rule_supported_vector(opcode, vlen, bt);\n+  }\n+\n+  \/\/ Identify extra cases that we might want to provide match rules for vector nodes\n+  \/\/ and other intrinsics guarded with vector length (vlen) and element type (bt).\n+  const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n+    if (!UseRVV) {\n+      return false;\n+    }\n+\n+    if (!match_rule_supported(opcode) || !vector_size_supported(bt, vlen)) {\n+      return false;\n+    }\n+\n@@ -55,23 +65,11 @@\n-      \/\/ No multiply reduction instructions\n-      case Op_MulReductionVD:\n-      case Op_MulReductionVF:\n-      case Op_MulReductionVI:\n-      case Op_MulReductionVL:\n-      \/\/ Others\n-      case Op_Extract:\n-      case Op_ExtractB:\n-      case Op_ExtractC:\n-      case Op_ExtractD:\n-      case Op_ExtractF:\n-      case Op_ExtractI:\n-      case Op_ExtractL:\n-      case Op_ExtractS:\n-      case Op_ExtractUB:\n-      \/\/ Vector API specific\n-      case Op_LoadVectorGather:\n-      case Op_StoreVectorScatter:\n-      case Op_VectorInsert:\n-      case Op_VectorTest:\n-      case Op_PopCountVI:\n-      case Op_PopCountVL:\n-        return false;\n+      case Op_VectorMaskLastTrue:\n+        if (!UseZbb || vlen > XLEN) {\n+          return false;\n+        }\n+        break;\n+      case Op_VectorMaskToLong:\n+      case Op_VectorLongToMask:\n+        if (vlen > XLEN) {\n+          return false;\n+        }\n+        break;\n@@ -79,1 +77,1 @@\n-        return UseRVV;\n+        break;\n@@ -81,0 +79,1 @@\n+    return true;\n@@ -83,0 +82,14 @@\n+  const bool Matcher::match_rule_supported_vector_masked(int opcode, int vlen, BasicType bt) {\n+    if (!UseRVV) {\n+      return false;\n+    }\n+    return match_rule_supported_vector(opcode, vlen, bt);\n+  }\n+\n+  const bool Matcher::vector_needs_partial_operations(Node* node, const TypeVect* vt) {\n+    return false;\n+  }\n+\n+  const bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n+    return false;\n+  }\n@@ -164,2 +177,3 @@\n-    __ compare_integral_v(as_VectorRegister($dst$$reg), bt, vector_length, as_VectorRegister($src1$$reg),\n-                          as_VectorRegister($src2$$reg), (int)($cond$$constant));\n+    __ compare_integral_v(as_VectorRegister($dst$$reg),\n+                          as_VectorRegister($src1$$reg), as_VectorRegister($src2$$reg),\n+                          (int)($cond$$constant), bt, vector_length);\n@@ -181,2 +195,3 @@\n-    __ compare_integral_v(as_VectorRegister($dst$$reg), bt, vector_length, as_VectorRegister($src1$$reg),\n-                          as_VectorRegister($src2$$reg), (int)($cond$$constant), Assembler::v0_t);\n+    __ compare_integral_v(as_VectorRegister($dst$$reg),\n+                          as_VectorRegister($src1$$reg), as_VectorRegister($src2$$reg),\n+                          (int)($cond$$constant), bt, vector_length, Assembler::v0_t);\n@@ -189,1 +204,1 @@\n-instruct vmaskcmp_fp(vRegMask dst, vReg src1, vReg src2, immI cond, vRegMask_V0 v0, vReg tmp1, vReg tmp2) %{\n+instruct vmaskcmp_fp(vRegMask dst, vReg src1, vReg src2, immI cond) %{\n@@ -193,2 +208,2 @@\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP v0);\n-  format %{ \"vmaskcmp_fp $dst, $src1, $src2, $cond\\t# KILL $tmp1, $tmp2\" %}\n+  effect(TEMP_DEF dst);\n+  format %{ \"vmaskcmp_fp $dst, $src1, $src2, $cond\" %}\n@@ -198,4 +213,3 @@\n-    __ compare_floating_point_v(as_VectorRegister($dst$$reg), bt, vector_length,\n-                                as_VectorRegister($src1$$reg), as_VectorRegister($src2$$reg),\n-                                as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n-                                as_VectorRegister($v0$$reg), (int)($cond$$constant));\n+    __ compare_fp_v(as_VectorRegister($dst$$reg),\n+                    as_VectorRegister($src1$$reg), as_VectorRegister($src2$$reg),\n+                    (int)($cond$$constant), bt, vector_length);\n@@ -206,1 +220,1 @@\n-instruct vmaskcmp_fp_masked(vRegMask dst, vReg src1, vReg src2, immI cond, vRegMask vmask, vReg tmp1, vReg tmp2, vRegMask_V0 v0) %{\n+instruct vmaskcmp_fp_masked(vRegMask dst, vReg src1, vReg src2, immI cond, vRegMask_V0 v0) %{\n@@ -209,3 +223,3 @@\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) (Binary cond vmask)));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP v0);\n-  format %{ \"vmaskcmp_fp_masked $dst, $src1, $src2, $cond, $vmask\\t# KILL $tmp1, $tmp2, $v0\" %}\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) (Binary cond v0)));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vmaskcmp_fp_masked $dst, $src1, $src2, $cond, $v0\" %}\n@@ -215,4 +229,3 @@\n-    __ compare_floating_point_v(as_VectorRegister($dst$$reg), bt, vector_length,\n-                                as_VectorRegister($src1$$reg), as_VectorRegister($src2$$reg),\n-                                as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n-                                as_VectorRegister($vmask$$reg), (int)($cond$$constant), Assembler::v0_t);\n+    __ compare_fp_v(as_VectorRegister($dst$$reg),\n+                    as_VectorRegister($src1$$reg), as_VectorRegister($src2$$reg),\n+                    (int)($cond$$constant), bt, vector_length, Assembler::v0_t);\n@@ -303,0 +316,35 @@\n+\/\/ vector abs - predicated\n+\n+instruct vabs_masked(vReg dst_src, vRegMask_V0 v0, vReg tmp) %{\n+  match(Set dst_src (AbsVB dst_src v0));\n+  match(Set dst_src (AbsVS dst_src v0));\n+  match(Set dst_src (AbsVI dst_src v0));\n+  match(Set dst_src (AbsVL dst_src v0));\n+  ins_cost(VEC_COST);\n+  effect(TEMP tmp);\n+  format %{ \"vabs_masked $dst_src, $dst_src, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vrsub_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($dst_src$$reg), 0,\n+                Assembler::v0_t);\n+    __ vmax_vv(as_VectorRegister($dst_src$$reg), as_VectorRegister($tmp$$reg),\n+               as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabs_fp_masked(vReg dst_src, vRegMask_V0 v0) %{\n+  match(Set dst_src (AbsVF dst_src v0));\n+  match(Set dst_src (AbsVD dst_src v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vabs_fp_masked $dst_src, $dst_src, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vfsgnjx_vv(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+                  as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -433,0 +481,16 @@\n+\/\/ vector and - predicated\n+\n+instruct vand_masked(vReg dst_src1, vReg src2, vRegMask_V0 v0) %{\n+  match(Set dst_src1 (AndV (Binary dst_src1 src2) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vand_masked $dst_src1, $src2, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vand_vv(as_VectorRegister($dst_src1$$reg),\n+               as_VectorRegister($dst_src1$$reg),\n+               as_VectorRegister($src2$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -449,0 +513,16 @@\n+\/\/ vector or - predicated\n+\n+instruct vor_masked(vReg dst_src1, vReg src2, vRegMask_V0 v0) %{\n+  match(Set dst_src1 (OrV (Binary dst_src1 src2) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vor_masked $dst_src1, $src2, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vor_vv(as_VectorRegister($dst_src1$$reg),\n+              as_VectorRegister($dst_src1$$reg),\n+              as_VectorRegister($src2$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -465,0 +545,16 @@\n+\/\/ vector xor - predicated\n+\n+instruct vxor_masked(vReg dst_src1, vReg src2, vRegMask_V0 v0) %{\n+  match(Set dst_src1 (XorV (Binary dst_src1 src2) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vxor_masked $dst_src1, $src2, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vxor_vv(as_VectorRegister($dst_src1$$reg),\n+               as_VectorRegister($dst_src1$$reg),\n+               as_VectorRegister($src2$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -542,0 +638,32 @@\n+\/\/ vector integer max\/min - predicated\n+\n+instruct vmax_masked(vReg dst_src1, vReg src2, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) != T_FLOAT &&\n+            Matcher::vector_element_basic_type(n) != T_DOUBLE);\n+  match(Set dst_src1 (MaxV (Binary dst_src1 src2) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vmax_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vmax_vv(as_VectorRegister($dst_src1$$reg), as_VectorRegister($dst_src1$$reg),\n+               as_VectorRegister($src2$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmin_masked(vReg dst_src1, vReg src2, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) != T_FLOAT &&\n+            Matcher::vector_element_basic_type(n) != T_DOUBLE);\n+  match(Set dst_src1 (MinV (Binary dst_src1 src2) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vmin_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vmin_vv(as_VectorRegister($dst_src1$$reg), as_VectorRegister($dst_src1$$reg),\n+               as_VectorRegister($src2$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -544,1 +672,1 @@\n-instruct vmaxF(vReg dst, vReg src1, vReg src2) %{\n+instruct vmaxF(vReg dst, vReg src1, vReg src2, vRegMask_V0 v0) %{\n@@ -547,1 +675,1 @@\n-  effect(TEMP_DEF dst);\n+  effect(TEMP_DEF dst, TEMP v0);\n@@ -558,1 +686,1 @@\n-instruct vmaxD(vReg dst, vReg src1, vReg src2) %{\n+instruct vmaxD(vReg dst, vReg src1, vReg src2, vRegMask_V0 v0) %{\n@@ -561,1 +689,1 @@\n-  effect(TEMP_DEF dst);\n+  effect(TEMP_DEF dst, TEMP v0);\n@@ -572,1 +700,1 @@\n-instruct vminF(vReg dst, vReg src1, vReg src2) %{\n+instruct vminF(vReg dst, vReg src1, vReg src2, vRegMask_V0 v0) %{\n@@ -575,1 +703,1 @@\n-  effect(TEMP_DEF dst);\n+  effect(TEMP_DEF dst, TEMP v0);\n@@ -586,1 +714,1 @@\n-instruct vminD(vReg dst, vReg src1, vReg src2) %{\n+instruct vminD(vReg dst, vReg src1, vReg src2, vRegMask_V0 v0) %{\n@@ -589,1 +717,1 @@\n-  effect(TEMP_DEF dst);\n+  effect(TEMP_DEF dst, TEMP v0);\n@@ -600,0 +728,62 @@\n+\/\/ vector float-point max\/min - predicated\n+\n+instruct vmaxF_masked(vReg dst_src1, vReg src2, vRegMask vmask, vReg tmp1, vReg tmp2, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst_src1 (MaxV (Binary dst_src1 src2) vmask));\n+  effect(TEMP_DEF dst_src1, TEMP tmp1, TEMP tmp2, TEMP v0);\n+  ins_cost(VEC_COST);\n+  format %{ \"vmaxF_masked $dst_src1, $dst_src1, $src2, $vmask\\t# KILL $tmp1, $tmp2, $v0\" %}\n+  ins_encode %{\n+    __ minmax_fp_masked_v(as_VectorRegister($dst_src1$$reg), as_VectorRegister($dst_src1$$reg),\n+                          as_VectorRegister($src2$$reg), as_VectorRegister($vmask$$reg),\n+                          as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n+                          false \/* is_double *\/, false \/* is_min *\/, Matcher::vector_length(this));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaxD_masked(vReg dst_src1, vReg src2, vRegMask vmask, vReg tmp1, vReg tmp2, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst_src1 (MaxV (Binary dst_src1 src2) vmask));\n+  effect(TEMP_DEF dst_src1, TEMP tmp1, TEMP tmp2, TEMP v0);\n+  ins_cost(VEC_COST);\n+  format %{ \"vmaxD_masked $dst_src1, $dst_src1, $src2, $vmask\\t# KILL $tmp1, $tmp2, $v0\" %}\n+  ins_encode %{\n+    __ minmax_fp_masked_v(as_VectorRegister($dst_src1$$reg), as_VectorRegister($dst_src1$$reg),\n+                          as_VectorRegister($src2$$reg), as_VectorRegister($vmask$$reg),\n+                          as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n+                          true \/* is_double *\/, false \/* is_min *\/, Matcher::vector_length(this));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vminF_masked(vReg dst_src1, vReg src2, vRegMask vmask, vReg tmp1, vReg tmp2, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst_src1 (MinV (Binary dst_src1 src2) vmask));\n+  effect(TEMP_DEF dst_src1, TEMP tmp1, TEMP tmp2, TEMP v0);\n+  ins_cost(VEC_COST);\n+  format %{ \"vminF_masked $dst_src1, $dst_src1, $src2, $vmask\\t# KILL $tmp1, $tmp2, $v0\" %}\n+  ins_encode %{\n+    __ minmax_fp_masked_v(as_VectorRegister($dst_src1$$reg), as_VectorRegister($dst_src1$$reg),\n+                          as_VectorRegister($src2$$reg), as_VectorRegister($vmask$$reg),\n+                          as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n+                          false \/* is_double *\/, true \/* is_min *\/, Matcher::vector_length(this));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vminD_masked(vReg dst_src1, vReg src2, vRegMask vmask, vReg tmp1, vReg tmp2, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst_src1 (MinV (Binary dst_src1 src2) vmask));\n+  effect(TEMP_DEF dst_src1, TEMP tmp1, TEMP tmp2, TEMP v0);\n+  ins_cost(VEC_COST);\n+  format %{ \"vminD_masked $dst_src1, $dst_src1, $src2, $vmask\\t# KILL $tmp1, $tmp2, $v0\" %}\n+  ins_encode %{\n+    __ minmax_fp_masked_v(as_VectorRegister($dst_src1$$reg), as_VectorRegister($dst_src1$$reg),\n+                          as_VectorRegister($src2$$reg), as_VectorRegister($vmask$$reg),\n+                          as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n+                          true \/* is_double *\/, true \/* is_min *\/, Matcher::vector_length(this));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -630,0 +820,17 @@\n+\/\/ vector fmadd - predicated\n+\/\/ dst_src1 = dst_src1 * src2 + src3\n+\n+instruct vfmadd_masked(vReg dst_src1, vReg src2, vReg src3, vRegMask_V0 v0) %{\n+  predicate(UseFMA);\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 src2) (Binary src3 v0)));\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 src2) (Binary src3 v0)));\n+  format %{ \"vfmadd_masked $dst_src1, $src2, $src3, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vfmadd_vv(as_VectorRegister($dst_src1$$reg), as_VectorRegister($src2$$reg),\n+                 as_VectorRegister($src3$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -664,0 +871,17 @@\n+\/\/ vector fnmsub - predicated\n+\n+\/\/ dst_src1 = dst_src1 * -src2 + src3\n+instruct vfnmsub_masked(vReg dst_src1, vReg src2, vReg src3, vRegMask_V0 v0) %{\n+  predicate(UseFMA);\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 (NegVF src2)) (Binary src3 v0)));\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 (NegVD src2)) (Binary src3 v0)));\n+  format %{ \"vfnmsub_masked $dst_src1, $src2, $src3, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vfnmsub_vv(as_VectorRegister($dst_src1$$reg), as_VectorRegister($src2$$reg),\n+                  as_VectorRegister($src3$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -698,0 +922,17 @@\n+\/\/ vector fnmadd - predicated\n+\n+\/\/ dst_src1 = -src3 + dst_src1 * -src2\n+instruct vfnmadd_masked(vReg dst_src1, vReg src2, vReg src3, vRegMask_V0 v0) %{\n+  predicate(UseFMA);\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 (NegVF src2)) (Binary (NegVF src3) v0)));\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 (NegVD src2)) (Binary (NegVD src3) v0)));\n+  format %{ \"vfnmadd_masked $dst_src1, $src2, $src3, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vfnmadd_vv(as_VectorRegister($dst_src1$$reg), as_VectorRegister($src2$$reg),\n+                  as_VectorRegister($src3$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -728,0 +969,17 @@\n+\/\/ vector vfmsub - predicated\n+\n+\/\/ dst_src1 = -src3 + dst_src1 * src2\n+instruct vfmsub_masked(vReg dst_src1, vReg src2, vReg src3, vRegMask_V0 v0) %{\n+  predicate(UseFMA);\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 src2) (Binary (NegVF src3) v0)));\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 src2) (Binary (NegVD src3) v0)));\n+  format %{ \"vfmsub_masked $dst_src1, $src2, $src3, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vfmsub_vv(as_VectorRegister($dst_src1$$reg), as_VectorRegister($src2$$reg),\n+                 as_VectorRegister($src3$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -782,0 +1040,17 @@\n+\/\/ vector mla - predicated\n+\n+instruct vmla_masked(vReg dst_src1, vReg src2, vReg src3, vRegMask_V0 v0) %{\n+  match(Set dst_src1 (AddVB (Binary dst_src1 (MulVB src2 src3)) v0));\n+  match(Set dst_src1 (AddVS (Binary dst_src1 (MulVS src2 src3)) v0));\n+  match(Set dst_src1 (AddVI (Binary dst_src1 (MulVI src2 src3)) v0));\n+  match(Set dst_src1 (AddVL (Binary dst_src1 (MulVL src2 src3)) v0));\n+  format %{ \"vmla_masked $dst_src1, $src2, $src3, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vmacc_vv(as_VectorRegister($dst_src1$$reg), as_VectorRegister($src2$$reg),\n+                as_VectorRegister($src3$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -836,0 +1111,17 @@\n+\/\/ vector mls - predicated\n+\n+instruct vmls_masked(vReg dst_src1, vReg src2, vReg src3, vRegMask_V0 v0) %{\n+  match(Set dst_src1 (SubVB (Binary dst_src1 (MulVB src2 src3)) v0));\n+  match(Set dst_src1 (SubVS (Binary dst_src1 (MulVS src2 src3)) v0));\n+  match(Set dst_src1 (SubVI (Binary dst_src1 (MulVI src2 src3)) v0));\n+  match(Set dst_src1 (SubVL (Binary dst_src1 (MulVL src2 src3)) v0));\n+  format %{ \"vmls_masked $dst_src1, $src2, $src3, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vnmsac_vv(as_VectorRegister($dst_src1$$reg), as_VectorRegister($src2$$reg),\n+                 as_VectorRegister($src3$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -967,0 +1259,16 @@\n+\/\/ vector neg - predicated\n+\n+instruct vneg_masked(vReg dst_src, vRegMask_V0 v0) %{\n+  match(Set dst_src (NegVI dst_src v0));\n+  match(Set dst_src (NegVL dst_src v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vneg_masked $dst_src, $dst_src, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vneg_v(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+              Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -991,0 +1299,16 @@\n+\/\/ vector fneg  - predicated\n+\n+instruct vfneg_masked(vReg dst_src, vRegMask_V0 v0) %{\n+  match(Set dst_src (NegVF dst_src v0));\n+  match(Set dst_src (NegVD dst_src v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vfneg_masked $dst_src, $dst_src, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vfneg_v(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+               Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1005,3 +1329,3 @@\n-    __ reduce_integral_v($dst$$Register, as_VectorRegister($tmp$$reg),\n-                         $src1$$Register, as_VectorRegister($src2$$reg), bt,\n-                         this->ideal_Opcode(), Matcher::vector_length(this, $src2));\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2));\n@@ -1022,3 +1346,39 @@\n-    __ reduce_integral_v($dst$$Register, as_VectorRegister($tmp$$reg),\n-                         $src1$$Register, as_VectorRegister($src2$$reg), bt,\n-                         this->ideal_Opcode(), Matcher::vector_length(this, $src2));\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector and reduction - predicated\n+\n+instruct reduce_andI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n->in(2)) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n->in(2)) == T_INT);\n+  match(Set dst (AndReductionV (Binary src1 src2) v0));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"reduce_andI_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2),\n+                         Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_andL_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (AndReductionV (Binary src1 src2) v0));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"reduce_andL_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2),\n+                         Assembler::v0_t);\n@@ -1043,3 +1403,3 @@\n-    __ reduce_integral_v($dst$$Register, as_VectorRegister($tmp$$reg),\n-                         $src1$$Register, as_VectorRegister($src2$$reg), bt,\n-                         this->ideal_Opcode(), Matcher::vector_length(this, $src2));\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2));\n@@ -1060,3 +1420,39 @@\n-    __ reduce_integral_v($dst$$Register, as_VectorRegister($tmp$$reg),\n-                         $src1$$Register, as_VectorRegister($src2$$reg), bt,\n-                         this->ideal_Opcode(), Matcher::vector_length(this, $src2));\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector or reduction - predicated\n+\n+instruct reduce_orI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n->in(2)) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n->in(2)) == T_INT);\n+  match(Set dst (OrReductionV (Binary src1 src2) v0));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"reduce_orI_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2),\n+                         Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_orL_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (OrReductionV (Binary src1 src2) v0));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"reduce_orL_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2),\n+                         Assembler::v0_t);\n@@ -1081,3 +1477,3 @@\n-    __ reduce_integral_v($dst$$Register, as_VectorRegister($tmp$$reg),\n-                         $src1$$Register, as_VectorRegister($src2$$reg), bt,\n-                         this->ideal_Opcode(), Matcher::vector_length(this, $src2));\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2));\n@@ -1098,3 +1494,3 @@\n-    __ reduce_integral_v($dst$$Register, as_VectorRegister($tmp$$reg),\n-                         $src1$$Register, as_VectorRegister($src2$$reg), bt,\n-                         this->ideal_Opcode(), Matcher::vector_length(this, $src2));\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2));\n@@ -1105,1 +1501,1 @@\n-\/\/ vector add reduction\n+\/\/ vector xor reduction - predicated\n@@ -1107,1 +1503,1 @@\n-instruct reduce_addI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vReg tmp) %{\n+instruct reduce_xorI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n@@ -1111,1 +1507,1 @@\n-  match(Set dst (AddReductionVI src1 src2));\n+  match(Set dst (XorReductionV (Binary src1 src2) v0));\n@@ -1114,3 +1510,1 @@\n-  format %{ \"vmv.s.x $tmp, $src1\\t#@reduce_addI\\n\\t\"\n-            \"vredsum.vs $tmp, $src2, $tmp\\n\\t\"\n-            \"vmv.x.s $dst, $tmp\" %}\n+  format %{ \"reduce_xorI_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n@@ -1119,3 +1513,4 @@\n-    __ reduce_integral_v($dst$$Register, as_VectorRegister($tmp$$reg),\n-                         $src1$$Register, as_VectorRegister($src2$$reg), bt,\n-                         this->ideal_Opcode(), Matcher::vector_length(this, $src2));\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2),\n+                         Assembler::v0_t);\n@@ -1126,1 +1521,1 @@\n-instruct reduce_addL(iRegLNoSp dst, iRegL src1, vReg src2, vReg tmp) %{\n+instruct reduce_xorL_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n@@ -1128,1 +1523,1 @@\n-  match(Set dst (AddReductionVL src1 src2));\n+  match(Set dst (XorReductionV (Binary src1 src2) v0));\n@@ -1131,3 +1526,1 @@\n-  format %{ \"vmv.s.x $tmp, $src1\\t#@reduce_addL\\n\\t\"\n-            \"vredsum.vs $tmp, $src2, $tmp\\n\\t\"\n-            \"vmv.x.s $dst, $tmp\" %}\n+  format %{ \"reduce_xorL_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n@@ -1136,3 +1529,4 @@\n-    __ reduce_integral_v($dst$$Register, as_VectorRegister($tmp$$reg),\n-                         $src1$$Register, as_VectorRegister($src2$$reg), bt,\n-                         this->ideal_Opcode(), Matcher::vector_length(this, $src2));\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2),\n+                         Assembler::v0_t);\n@@ -1143,2 +1537,40 @@\n-instruct reduce_addF(fRegF src1_dst, vReg src2, vReg tmp) %{\n-  match(Set src1_dst (AddReductionVF src1_dst src2));\n+\/\/ vector add reduction\n+\n+instruct reduce_addI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n->in(2)) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n->in(2)) == T_INT);\n+  match(Set dst (AddReductionVI src1 src2));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"vmv.s.x $tmp, $src1\\t#@reduce_addI\\n\\t\"\n+            \"vredsum.vs $tmp, $src2, $tmp\\n\\t\"\n+            \"vmv.x.s $dst, $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addL(iRegLNoSp dst, iRegL src1, vReg src2, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (AddReductionVL src1 src2));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"vmv.s.x $tmp, $src1\\t#@reduce_addL\\n\\t\"\n+            \"vredsum.vs $tmp, $src2, $tmp\\n\\t\"\n+            \"vmv.x.s $dst, $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addF(fRegF src1_dst, vReg src2, vReg tmp) %{\n+  match(Set src1_dst (AddReductionVF src1_dst src2));\n@@ -1177,0 +1609,66 @@\n+\/\/ vector add reduction - predicated\n+\n+instruct reduce_addI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n->in(2)) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n->in(2)) == T_INT);\n+  match(Set dst (AddReductionVI (Binary src1 src2) v0));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"reduce_addI_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2),\n+                         Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addL_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (AddReductionVL (Binary src1 src2) v0));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"reduce_addL_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2),\n+                         Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addF_masked(fRegF src1_dst, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  match(Set src1_dst (AddReductionVF (Binary src1_dst src2) v0));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"reduce_addF_masked $src1_dst, $src2, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this, $src2));\n+    __ vfmv_s_f(as_VectorRegister($tmp$$reg), $src1_dst$$FloatRegister);\n+    __ vfredosum_vs(as_VectorRegister($tmp$$reg), as_VectorRegister($src2$$reg),\n+                    as_VectorRegister($tmp$$reg), Assembler::v0_t);\n+    __ vfmv_f_s($src1_dst$$FloatRegister, as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addD_masked(fRegD src1_dst, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  match(Set src1_dst (AddReductionVD (Binary src1_dst src2) v0));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"reduce_addD_masked $src1_dst, $src2, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_DOUBLE, Matcher::vector_length(this, $src2));\n+    __ vfmv_s_f(as_VectorRegister($tmp$$reg), $src1_dst$$FloatRegister);\n+    __ vfredosum_vs(as_VectorRegister($tmp$$reg), as_VectorRegister($src2$$reg),\n+                    as_VectorRegister($tmp$$reg), Assembler::v0_t);\n+    __ vfmv_f_s($src1_dst$$FloatRegister, as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1189,3 +1687,3 @@\n-    __ reduce_integral_v($dst$$Register, as_VectorRegister($tmp$$reg),\n-                         $src1$$Register, as_VectorRegister($src2$$reg), bt,\n-                         this->ideal_Opcode(), Matcher::vector_length(this, $src2));\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2));\n@@ -1204,3 +1702,39 @@\n-    __ reduce_integral_v($dst$$Register, as_VectorRegister($tmp$$reg),\n-                         $src1$$Register, as_VectorRegister($src2$$reg), bt,\n-                         this->ideal_Opcode(), Matcher::vector_length(this, $src2));\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector integer max reduction - predicated\n+\n+instruct vreduce_maxI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n->in(2)) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n->in(2)) == T_INT);\n+  match(Set dst (MaxReductionV (Binary src1 src2) v0));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"vreduce_maxI_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2),\n+                         Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vreduce_maxL_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (MaxReductionV (Binary src1 src2) v0));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"vreduce_maxL_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2),\n+                         Assembler::v0_t);\n@@ -1223,3 +1757,3 @@\n-    __ reduce_integral_v($dst$$Register, as_VectorRegister($tmp$$reg),\n-                         $src1$$Register, as_VectorRegister($src2$$reg), bt,\n-                         this->ideal_Opcode(), Matcher::vector_length(this, $src2));\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2));\n@@ -1238,3 +1772,39 @@\n-    __ reduce_integral_v($dst$$Register, as_VectorRegister($tmp$$reg),\n-                         $src1$$Register, as_VectorRegister($src2$$reg), bt,\n-                         this->ideal_Opcode(), Matcher::vector_length(this, $src2));\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector integer min reduction - predicated\n+\n+instruct vreduce_minI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n->in(2)) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n->in(2)) == T_INT);\n+  match(Set dst (MinReductionV (Binary src1 src2) v0));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"vreduce_minI_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2),\n+                         Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vreduce_minL_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (MinReductionV (Binary src1 src2) v0));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"vreduce_minL_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2),\n+                         Assembler::v0_t);\n@@ -1277,0 +1847,34 @@\n+\/\/ vector float max reduction - predicated\n+\n+instruct vreduce_maxF_masked(fRegF dst, fRegF src1, vReg src2, vRegMask_V0 v0, vReg tmp1, vReg tmp2) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT);\n+  match(Set dst (MaxReductionV (Binary src1 src2) v0));\n+  ins_cost(VEC_COST);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n+  format %{ \"vreduce_maxF_masked $dst, $src1, $src2, $v0\\t# KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    __ reduce_minmax_fp_v($dst$$FloatRegister,\n+                          $src1$$FloatRegister, as_VectorRegister($src2$$reg),\n+                          as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n+                          false \/* is_double *\/, false \/* is_min *\/,\n+                          Matcher::vector_length(this, $src2), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vreduce_maxD_masked(fRegD dst, fRegD src1, vReg src2, vRegMask_V0 v0, vReg tmp1, vReg tmp2) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE);\n+  match(Set dst (MaxReductionV (Binary src1 src2) v0));\n+  ins_cost(VEC_COST);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n+  format %{ \"vreduce_maxD_masked $dst, $src1, $src2, $v0\\t# KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    __ reduce_minmax_fp_v($dst$$FloatRegister,\n+                          $src1$$FloatRegister, as_VectorRegister($src2$$reg),\n+                          as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n+                          true \/* is_double *\/, false \/* is_min *\/,\n+                          Matcher::vector_length(this, $src2), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1309,0 +1913,34 @@\n+\/\/ vector float min reduction - predicated\n+\n+instruct vreduce_minF_masked(fRegF dst, fRegF src1, vReg src2, vRegMask_V0 v0, vReg tmp1, vReg tmp2) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT);\n+  match(Set dst (MinReductionV (Binary src1 src2) v0));\n+  ins_cost(VEC_COST);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n+  format %{ \"vreduce_minF_masked $dst, $src1, $src2, $v0\\t# KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    __ reduce_minmax_fp_v($dst$$FloatRegister,\n+                          $src1$$FloatRegister, as_VectorRegister($src2$$reg),\n+                          as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n+                          false \/* is_double *\/, true \/* is_min *\/,\n+                          Matcher::vector_length(this, $src2), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vreduce_minD_masked(fRegD dst, fRegD src1, vReg src2, vRegMask_V0 v0, vReg tmp1, vReg tmp2) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE);\n+  match(Set dst (MinReductionV (Binary src1 src2) v0));\n+  ins_cost(VEC_COST);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n+  format %{ \"vreduce_minD_masked $dst, $src1, $src2, $v0\\t# KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    __ reduce_minmax_fp_v($dst$$FloatRegister,\n+                          $src1$$FloatRegister, as_VectorRegister($src2$$reg),\n+                          as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n+                          true \/* is_double *\/, true \/* is_min *\/,\n+                          Matcher::vector_length(this, $src2), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1878,0 +2516,67 @@\n+instruct vasrB_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (RShiftVB (Binary dst_src (RShiftCntV shift)) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vasrB_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  ins_encode %{\n+    uint32_t con = (unsigned)$shift$$constant & 0x1f;\n+    if (con == 0) {\n+      return;\n+    }\n+    if (con >= BitsPerByte) con = BitsPerByte - 1;\n+    __ vsetvli_helper(T_BYTE, Matcher::vector_length(this));\n+    __ vsra_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con,\n+               Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrS_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (RShiftVS (Binary dst_src (RShiftCntV shift)) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vasrS_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  ins_encode %{\n+    uint32_t con = (unsigned)$shift$$constant & 0x1f;\n+    if (con == 0) {\n+      return;\n+    }\n+    if (con >= BitsPerShort) con = BitsPerShort - 1;\n+    __ vsetvli_helper(T_SHORT, Matcher::vector_length(this));\n+    __ vsra_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con,\n+               Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrI_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (RShiftVI (Binary dst_src (RShiftCntV shift)) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vasrI_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  ins_encode %{\n+    uint32_t con = (unsigned)$shift$$constant & 0x1f;\n+    if (con == 0) {\n+      return;\n+    }\n+    __ vsetvli_helper(T_INT, Matcher::vector_length(this));\n+    __ vsra_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con,\n+               Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrL_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  predicate((n->in(1)->in(2)->in(1)->get_int() & 0x3f) < 32);\n+  match(Set dst_src (RShiftVL (Binary dst_src (RShiftCntV shift)) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vasrL_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  ins_encode %{\n+    uint32_t con = (unsigned)$shift$$constant & 0x1f;\n+    if (con == 0) {\n+      return;\n+    }\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vsra_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con,\n+               Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1952,1 +2657,76 @@\n-    __ vsrl_vi(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), con);\n+    __ vsrl_vi(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrB_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (URShiftVB (Binary dst_src (RShiftCntV shift)) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vlsrB_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  ins_encode %{\n+    uint32_t con = (unsigned)$shift$$constant & 0x1f;\n+    if (con == 0) {\n+      return;\n+    }\n+    __ vsetvli_helper(T_BYTE, Matcher::vector_length(this));\n+    if (con >= BitsPerByte) {\n+      __ vxor_vv(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+                 as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n+      return;\n+    }\n+    __ vsrl_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con,\n+               Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrS_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (URShiftVS (Binary dst_src (RShiftCntV shift)) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vlsrS_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  ins_encode %{\n+    uint32_t con = (unsigned)$shift$$constant & 0x1f;\n+    if (con == 0) {\n+      return;\n+    }\n+    __ vsetvli_helper(T_SHORT, Matcher::vector_length(this));\n+    if (con >= BitsPerShort) {\n+      __ vxor_vv(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+                 as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n+      return;\n+    }\n+    __ vsrl_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con,\n+               Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrI_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (URShiftVI (Binary dst_src (RShiftCntV shift)) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vlsrI_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  ins_encode %{\n+    uint32_t con = (unsigned)$shift$$constant & 0x1f;\n+    if (con == 0) {\n+      return;\n+    }\n+    __ vsetvli_helper(T_INT, Matcher::vector_length(this));\n+    __ vsrl_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con,\n+               Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrL_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  predicate((n->in(1)->in(2)->in(1)->get_int() & 0x3f) < 32);\n+  match(Set dst_src (URShiftVL (Binary dst_src (RShiftCntV shift)) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vlsrL_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  ins_encode %{\n+    uint32_t con = (unsigned)$shift$$constant & 0x1f;\n+    if (con == 0) {\n+      return;\n+    }\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vsrl_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con,\n+               Assembler::v0_t);\n@@ -2016,0 +2796,63 @@\n+instruct vlslB_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (LShiftVB (Binary dst_src (LShiftCntV shift)) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vlslB_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  ins_encode %{\n+    uint32_t con = (unsigned)$shift$$constant & 0x1f;\n+    __ vsetvli_helper(T_BYTE, Matcher::vector_length(this));\n+    if (con >= BitsPerByte) {\n+      __ vxor_vv(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+                 as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n+      return;\n+    }\n+    __ vsll_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con,\n+               Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslS_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (LShiftVS (Binary dst_src (LShiftCntV shift)) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vlslS_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  ins_encode %{\n+    uint32_t con = (unsigned)$shift$$constant & 0x1f;\n+    __ vsetvli_helper(T_SHORT, Matcher::vector_length(this));\n+    if (con >= BitsPerShort) {\n+      __ vxor_vv(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+                 as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n+      return;\n+    }\n+    __ vsll_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con,\n+               Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslI_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (LShiftVI (Binary dst_src (LShiftCntV shift)) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vlslI_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  ins_encode %{\n+    uint32_t con = (unsigned)$shift$$constant & 0x1f;\n+    __ vsetvli_helper(T_INT, Matcher::vector_length(this));\n+    __ vsll_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con,\n+               Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslL_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  predicate((n->in(1)->in(2)->in(1)->get_int() & 0x3f) < 32);\n+  match(Set dst_src (LShiftVL (Binary dst_src (LShiftCntV shift)) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vlslL_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  ins_encode %{\n+    uint32_t con = (unsigned)$shift$$constant & 0x1f;\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vsll_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con,\n+               Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2054,0 +2897,26 @@\n+\/\/ vector sqrt - predicated\n+\n+instruct vsqrtF_masked(vReg dst_src, vRegMask_V0 v0) %{\n+  match(Set dst_src (SqrtVF dst_src v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vsqrtF_masked $dst_src, $v0\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this));\n+    __ vfsqrt_v(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+                Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsqrtD_masked(vReg dst_src, vRegMask_V0 v0) %{\n+  match(Set dst_src (SqrtVD dst_src v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vsqrtD_masked $dst_src, $v0\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_DOUBLE, Matcher::vector_length(this));\n+    __ vfsqrt_v(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+                Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2443,0 +3312,2 @@\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vmclr_m(as_VectorRegister($dst$$reg));\n@@ -2455,0 +3326,2 @@\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vmclr_m(as_VectorRegister($dst$$reg));\n@@ -2466,0 +3339,4 @@\n+    if ($con$$constant != Matcher::vector_length(this)) {\n+      __ vsetvli_helper(bt, Matcher::vector_length(this));\n+      __ vmclr_m(as_VectorRegister($dst$$reg));\n+    }\n@@ -2489,1 +3366,1 @@\n-instruct vmaskAllI(vRegMask dst, iRegI src) %{\n+instruct vmaskAllI(vRegMask dst, iRegIorL2I src) %{\n@@ -2881,1 +3758,1 @@\n-\/\/ vector reinterpret\n+\/\/ ------------------------------ Vector reinterpret ---------------------------\n@@ -2954,1 +3831,449 @@\n-    __ vrgather_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), as_VectorRegister($shuffle$$reg));\n+    __ vrgather_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg),\n+                   as_VectorRegister($shuffle$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct rearrange_masked(vReg dst, vReg src, vReg shuffle, vRegMask_V0 v0) %{\n+  match(Set dst (VectorRearrange (Binary src shuffle) v0));\n+  effect(TEMP_DEF dst);\n+  format %{ \"rearrange_masked $dst, $src, $shuffle, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vxor_vv(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg),\n+               as_VectorRegister($dst$$reg));\n+    __ vrgather_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg),\n+                   as_VectorRegister($shuffle$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector extract ---------------------------------\n+\n+instruct extract(iRegINoSp dst, vReg src, immI idx, vReg tmp)\n+%{\n+  match(Set dst (ExtractB src idx));\n+  match(Set dst (ExtractS src idx));\n+  match(Set dst (ExtractI src idx));\n+  effect(TEMP tmp);\n+  format %{ \"extract $dst, $src, $idx\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ extract_v($dst$$Register, as_VectorRegister($src$$reg),\n+                 Matcher::vector_element_basic_type(this, $src), (int)($idx$$constant),\n+                 as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct extractL(iRegLNoSp dst, vReg src, immI idx, vReg tmp)\n+%{\n+  match(Set dst (ExtractL src idx));\n+  effect(TEMP tmp);\n+  format %{ \"extractL $dst, $src, $idx\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ extract_v($dst$$Register, as_VectorRegister($src$$reg), T_LONG,\n+                 (int)($idx$$constant), as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n+instruct extractF(fRegF dst, vReg src, immI idx, vReg tmp)\n+%{\n+  match(Set dst (ExtractF src idx));\n+  effect(TEMP tmp);\n+  format %{ \"extractF $dst, $src, $idx\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ extract_fp_v($dst$$FloatRegister, as_VectorRegister($src$$reg), T_FLOAT,\n+                    (int)($idx$$constant), as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct extractD(fRegD dst, vReg src, immI idx, vReg tmp)\n+%{\n+  match(Set dst (ExtractD src idx));\n+  effect(TEMP tmp);\n+  format %{ \"extractD $dst, $src, $idx\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ extract_fp_v($dst$$FloatRegister, as_VectorRegister($src$$reg), T_DOUBLE,\n+                    (int)($idx$$constant), as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Compress\/Expand Operations -------------------\n+\n+instruct mcompress(vRegMask dst, vRegMask src, iRegLNoSp tmp) %{\n+  match(Set dst (CompressM src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"mcompress $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SEW sew = Assembler::elemtype_to_sew(bt);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vmclr_m(as_VectorRegister($dst$$reg));\n+    __ vcpop_m($tmp$$Register, as_VectorRegister($src$$reg));\n+    __ vsetvli(t0, $tmp$$Register, sew);\n+    __ vmset_m(as_VectorRegister($dst$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompress(vReg dst, vReg src, vRegMask_V0 v0) %{\n+  match(Set dst (CompressV src v0));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vcompress $dst, $src, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vxor_vv(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg),\n+               as_VectorRegister($dst$$reg));\n+    __ vcompress_vm(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg),\n+                    as_VectorRegister($v0$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vexpand(vReg dst, vReg src, vRegMask_V0 v0, vReg tmp) %{\n+  match(Set dst (ExpandV src v0));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vexpand $dst, $src, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ viota_m(as_VectorRegister($tmp$$reg), as_VectorRegister($v0$$reg));\n+    __ vxor_vv(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg),\n+               as_VectorRegister($dst$$reg));\n+    __ vrgather_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg),\n+                   as_VectorRegister($tmp$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector Load Gather ---------------------------\n+\n+instruct gather_load(vReg dst, indirect mem, vReg idx) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n)) == 4 ||\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) == 8);\n+  match(Set dst (LoadVectorGather mem idx));\n+  effect(TEMP_DEF dst);\n+  format %{ \"gather_load $dst, $mem, $idx\" %}\n+  ins_encode %{\n+    __ vmv1r_v(as_VectorRegister($dst$$reg), as_VectorRegister($idx$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SEW sew = Assembler::elemtype_to_sew(bt);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vsll_vi(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg), (int)sew);\n+    __ vluxei32_v(as_VectorRegister($dst$$reg), as_Register($mem$$base),\n+                  as_VectorRegister($dst$$reg));\n+ %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gather_load_masked(vReg dst, indirect mem, vReg idx, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n)) == 4 ||\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) == 8);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx v0)));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"gather_load_masked $dst, $mem, $idx, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ vmv1r_v(as_VectorRegister($tmp$$reg), as_VectorRegister($idx$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SEW sew = Assembler::elemtype_to_sew(bt);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vsll_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($tmp$$reg), (int)sew);\n+    __ vxor_vv(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg),\n+               as_VectorRegister($dst$$reg));\n+    __ vluxei32_v(as_VectorRegister($dst$$reg), as_Register($mem$$base),\n+                  as_VectorRegister($tmp$$reg), Assembler::v0_t);\n+ %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector Store Scatter -------------------------\n+\n+instruct scatter_store(indirect mem, vReg src, vReg idx, vReg tmp) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 4 ||\n+            type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 8);\n+  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n+  effect(TEMP tmp);\n+  format %{ \"scatter_store $mem, $idx, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ vmv1r_v(as_VectorRegister($tmp$$reg), as_VectorRegister($idx$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SEW sew = Assembler::elemtype_to_sew(bt);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this, $src));\n+    __ vsll_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($tmp$$reg), (int)sew);\n+    __ vsuxei32_v(as_VectorRegister($src$$reg), as_Register($mem$$base),\n+                  as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scatter_store_masked(indirect mem, vReg src, vReg idx, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 4 ||\n+            type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 8);\n+  match(Set mem (StoreVectorScatterMasked mem (Binary src (Binary idx v0))));\n+  effect(TEMP tmp);\n+  format %{ \"scatter_store_masked $mem, $idx, $src, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ vmv1r_v(as_VectorRegister($tmp$$reg), as_VectorRegister($idx$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SEW sew = Assembler::elemtype_to_sew(bt);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this, $src));\n+    __ vsll_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($tmp$$reg), (int)sew);\n+    __ vsuxei32_v(as_VectorRegister($src$$reg), as_Register($mem$$base),\n+                  as_VectorRegister($tmp$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Populate Index to a Vector -------------------\n+\n+instruct populateindex(vReg dst, iRegIorL2I src1, iRegIorL2I src2, vReg tmp1) %{\n+  match(Set dst (PopulateIndex src1 src2));\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  format %{ \"populateindex $dst, $src1, $src2\\t# KILL $tmp1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SEW sew = Assembler::elemtype_to_sew(bt);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vmv_v_x(as_VectorRegister($dst$$reg), as_Register($src1$$reg));\n+    __ vid_v(as_VectorRegister($tmp1$$reg));\n+    __ vmacc_vx(as_VectorRegister($dst$$reg), as_Register($src2$$reg), as_VectorRegister($tmp1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector insert --------------------------------\n+\n+\/\/ BYTE, SHORT, INT\n+\n+instruct insertI_index_lt32(vReg dst, vReg src, iRegIorL2I val, immI idx, vRegMask_V0 v0) %{\n+  predicate(n->in(2)->get_int() < 32 &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n) == T_INT));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP v0);\n+  format %{ \"insertI_index_lt32 $dst, $src, $val, $idx\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vid_v(as_VectorRegister($v0$$reg));\n+    __ vadd_vi(as_VectorRegister($v0$$reg), as_VectorRegister($v0$$reg), -16);\n+    __ vmseq_vi(as_VectorRegister($v0$$reg), as_VectorRegister($v0$$reg), (int)($idx$$constant) - 16);\n+    __ vmerge_vxm(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertI_index(vReg dst, vReg src, iRegIorL2I val, iRegIorL2I idx, vReg tmp1, vRegMask_V0 v0) %{\n+  predicate(n->in(2)->get_int() >= 32 &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n) == T_INT));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp1, TEMP v0);\n+  format %{ \"insertI_index $dst, $src, $val, $idx\\t# KILL $tmp1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vid_v(as_VectorRegister($v0$$reg));\n+    __ vmv_v_x(as_VectorRegister($tmp1$$reg), $idx$$Register);\n+    __ vmseq_vv(as_VectorRegister($v0$$reg), as_VectorRegister($v0$$reg), as_VectorRegister($tmp1$$reg));\n+    __ vmerge_vxm(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ LONG\n+\n+instruct insertL_index_lt32(vReg dst, vReg src, iRegL val, immI idx, vRegMask_V0 v0) %{\n+  predicate(n->in(2)->get_int() < 32 &&\n+            (Matcher::vector_element_basic_type(n) == T_LONG));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP v0);\n+  format %{ \"insertL_index_lt32 $dst, $src, $val, $idx\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vid_v(as_VectorRegister($v0$$reg));\n+    __ vadd_vi(as_VectorRegister($v0$$reg), as_VectorRegister($v0$$reg), -16);\n+    __ vmseq_vi(as_VectorRegister($v0$$reg), as_VectorRegister($v0$$reg), (int)($idx$$constant) - 16);\n+    __ vmerge_vxm(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertL_index(vReg dst, vReg src, iRegL val, iRegIorL2I idx, vReg tmp1, vRegMask_V0 v0) %{\n+  predicate(n->in(2)->get_int() >= 32 &&\n+            (Matcher::vector_element_basic_type(n) == T_LONG));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp1, TEMP v0);\n+  format %{ \"insertL_index $dst, $src, $val, $idx\\t# KILL $tmp1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vid_v(as_VectorRegister($v0$$reg));\n+    __ vmv_v_x(as_VectorRegister($tmp1$$reg), $idx$$Register);\n+    __ vmseq_vv(as_VectorRegister($v0$$reg), as_VectorRegister($v0$$reg), as_VectorRegister($tmp1$$reg));\n+    __ vmerge_vxm(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ FLOAT\n+\n+instruct insertF_index_lt32(vReg dst, vReg src, fRegF val, immI idx, vRegMask_V0 v0) %{\n+  predicate(n->in(2)->get_int() < 32 &&\n+            (Matcher::vector_element_basic_type(n) == T_FLOAT));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP v0);\n+  format %{ \"insertF_index_lt32 $dst, $src, $val, $idx\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this));\n+    __ vid_v(as_VectorRegister($v0$$reg));\n+    __ vadd_vi(as_VectorRegister($v0$$reg), as_VectorRegister($v0$$reg), -16);\n+    __ vmseq_vi(as_VectorRegister($v0$$reg), as_VectorRegister($v0$$reg), (int)($idx$$constant) - 16);\n+    __ vfmerge_vfm(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), $val$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertF_index(vReg dst, vReg src, fRegF val, iRegIorL2I idx, vReg tmp1, vRegMask_V0 v0) %{\n+  predicate(n->in(2)->get_int() >= 32 &&\n+            (Matcher::vector_element_basic_type(n) == T_FLOAT));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp1, TEMP v0);\n+  format %{ \"insertF_index $dst, $src, $val, $idx\\t# KILL $tmp1\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this));\n+    __ vid_v(as_VectorRegister($v0$$reg));\n+    __ vmv_v_x(as_VectorRegister($tmp1$$reg), $idx$$Register);\n+    __ vmseq_vv(as_VectorRegister($v0$$reg), as_VectorRegister($v0$$reg), as_VectorRegister($tmp1$$reg));\n+    __ vfmerge_vfm(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), $val$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ DOUBLE\n+\n+instruct insertD_index_lt32(vReg dst, vReg src, fRegD val, immI idx, vRegMask_V0 v0) %{\n+  predicate(n->in(2)->get_int() < 32 &&\n+            (Matcher::vector_element_basic_type(n) == T_DOUBLE));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP v0);\n+  format %{ \"insertD_index_lt32 $dst, $src, $val, $idx\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_DOUBLE, Matcher::vector_length(this));\n+    __ vid_v(as_VectorRegister($v0$$reg));\n+    __ vadd_vi(as_VectorRegister($v0$$reg), as_VectorRegister($v0$$reg), -16);\n+    __ vmseq_vi(as_VectorRegister($v0$$reg), as_VectorRegister($v0$$reg), (int)($idx$$constant) - 16);\n+    __ vfmerge_vfm(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), $val$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertD_index(vReg dst, vReg src, fRegD val, iRegIorL2I idx, vReg tmp1, vRegMask_V0 v0) %{\n+  predicate(n->in(2)->get_int() >= 32 &&\n+            (Matcher::vector_element_basic_type(n) == T_DOUBLE));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp1, TEMP v0);\n+  format %{ \"insertD_index $dst, $src, $val, $idx\\t# KILL $tmp1\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_DOUBLE, Matcher::vector_length(this));\n+    __ vid_v(as_VectorRegister($v0$$reg));\n+    __ vmv_v_x(as_VectorRegister($tmp1$$reg), $idx$$Register);\n+    __ vmseq_vv(as_VectorRegister($v0$$reg), as_VectorRegister($v0$$reg), as_VectorRegister($tmp1$$reg));\n+    __ vfmerge_vfm(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), $val$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector mask reductions -----------------------\n+\n+\/\/ true count\n+\n+instruct vmask_truecount(iRegINoSp dst, vRegMask src) %{\n+  match(Set dst (VectorMaskTrueCount src));\n+  format %{ \"vmask_truecount $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this, $src));\n+    __ vcpop_m($dst$$Register, as_VectorRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ first true\n+\n+\/\/ Return the index of the first mask lane that is set, or vector length if none of\n+\/\/ them are set.\n+\n+instruct vmask_firsttrue(iRegINoSp dst, vRegMask src, vRegMask tmp) %{\n+  match(Set dst (VectorMaskFirstTrue src));\n+  effect(TEMP tmp);\n+  format %{ \"vmask_firsttrue $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this, $src));\n+    __ vmsbf_m(as_VectorRegister($tmp$$reg), as_VectorRegister($src$$reg));\n+    __ vcpop_m($dst$$Register, as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ last true\n+\n+\/\/ Return the index of the first last lane that is set, or -1 if none of\n+\/\/ them are set.\n+\n+instruct vmask_lasttrue(iRegINoSp dst, vRegMask src) %{\n+  match(Set dst (VectorMaskLastTrue src));\n+  format %{ \"vmask_lasttrue $dst, $src\" %}\n+  ins_encode %{\n+    uint vector_length = Matcher::vector_length(this, $src);\n+    assert(UseZbb && vector_length <= XLEN, \"precondition\");\n+    __ vsetvli_helper(T_LONG, 1);\n+    __ vmv_x_s($dst$$Register, as_VectorRegister($src$$reg));\n+    if (XLEN != vector_length) {\n+      __ slli($dst$$Register, $dst$$Register, XLEN - vector_length);\n+      __ srli($dst$$Register, $dst$$Register, XLEN - vector_length);\n+    }\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ mv(t0, XLEN - 1);\n+    __ sub($dst$$Register, t0, $dst$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ tolong\n+\n+instruct vmask_tolong(iRegLNoSp dst, vRegMask src) %{\n+  match(Set dst (VectorMaskToLong src));\n+  format %{ \"vmask_tolong $dst, $src\" %}\n+  ins_encode %{\n+    uint vector_length = Matcher::vector_length(this, $src);\n+    assert(vector_length <= XLEN, \"precondition\");\n+    __ vsetvli_helper(T_LONG, 1);\n+    __ vmv_x_s($dst$$Register, as_VectorRegister($src$$reg));\n+    if (XLEN != vector_length) {\n+      __ slli($dst$$Register, $dst$$Register, XLEN - vector_length);\n+      __ srli($dst$$Register, $dst$$Register, XLEN - vector_length);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ fromlong\n+\n+instruct vmask_fromlong(vRegMask dst, iRegL src) %{\n+  match(Set dst (VectorLongToMask src));\n+  format %{ \"vmask_fromlong $dst, $src\" %}\n+  ins_encode %{\n+    assert(Matcher::vector_length(this) <= XLEN, \"precondition\");\n+    __ vsetvli_helper(T_LONG, 1);\n+    __ vmv_s_x(as_VectorRegister($dst$$reg), $src$$Register);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":1434,"deletions":109,"binary":false,"changes":1543,"status":"modified"}]}