{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-    STRING_KEYWORDS := VM_OPTIONS JAVA_OPTIONS AOT_MODULES, \\\n+    STRING_KEYWORDS := VM_OPTIONS JAVA_OPTIONS, \\\n@@ -137,90 +137,0 @@\n-################################################################################\n-# Optionally create AOT libraries for specified modules before running tests.\n-# Note, this could not be done during JDK build time.\n-################################################################################\n-# Parameter 1 is the name of the rule.\n-#\n-# Remaining parameters are named arguments.\n-#   MODULE      The module to generate a library for\n-#   BIN         Output directory in which to put the library\n-#   VM_OPTIONS  List of JVM arguments to use when creating library\n-#   OPTIONS_VAR Name of variable to put AOT java options in\n-#   PREREQS_VAR Name of variable to put all AOT prerequisite rule targets in\n-#               for test rules to depend on\n-#\n-SetupAotModule = $(NamedParamsMacroTemplate)\n-define SetupAotModuleBody\n-  $1_AOT_LIB := $$($1_BIN)\/$$(call SHARED_LIBRARY,$$($1_MODULE))\n-  $1_AOT_CCLIST := $$(wildcard $$(TOPDIR)\/test\/hotspot\/jtreg\/compiler\/aot\/scripts\/$$($1_MODULE)-list.txt)\n-\n-  # Create jaotc flags.\n-  # VM flags which don't affect AOT code generation are filtered out:\n-  # -Xcomp, -XX:+-TieredCompilation\n-  $1_JAOTC_OPTS := \\\n-      -J-Xmx4g --info \\\n-      $$(addprefix -J, $$(filter-out -Xcomp %TieredCompilation, $$($1_VM_OPTIONS))) \\\n-      $$(addprefix --compile-commands$(SPACE), $$($1_AOT_CCLIST)) \\\n-      --linker-path $$(LD_JAOTC) \\\n-      #\n-\n-  ifneq ($$(filter -ea, $$($1_VM_OPTIONS)), )\n-    $1_JAOTC_OPTS += --compile-with-assertions\n-  endif\n-\n-  ifneq ($$(filter -XX:+VerifyOops, $$($1_VM_OPTIONS)), )\n-    $1_JAOTC_OPTS += -J-Dgraal.AOTVerifyOops=true\n-  endif\n-\n-  $$($1_AOT_LIB): $$(JDK_UNDER_TEST)\/release \\\n-      $$(call DependOnVariable, $1_JAOTC_OPTS) \\\n-      $$(call DependOnVariable, JDK_UNDER_TEST)\n-\t$$(call LogWarn, Generating $$(patsubst $$(OUTPUTDIR)\/%, %, $$@))\n-\t$$(call MakeTargetDir)\n-\t$$(call ExecuteWithLog, $$@, \\\n-\t    $((COV_ENVIRONMENT) \\\n-\t    $$(FIXPATH) $$(JDK_UNDER_TEST)\/bin\/jaotc \\\n-\t        $$($1_JAOTC_OPTS) --output $$@ --module $$($1_MODULE) \\\n-\t)\n-\t$$(call ExecuteWithLog, $$@.check, ( \\\n-\t    $$(FIXPATH) $$(JDK_UNDER_TEST)\/bin\/java \\\n-\t        $$($1_VM_OPTIONS) -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions \\\n-\t        -XX:+PrintAOT -XX:+UseAOTStrictLoading \\\n-\t        -XX:AOTLibrary=$$@ -version \\\n-\t         > $$@.verify-aot \\\n-\t))\n-\n-  $1_AOT_OPTIONS += -XX:+UnlockExperimentalVMOptions\n-  $1_AOT_OPTIONS += -XX:AOTLibrary=$$($1_AOT_LIB)\n-  $1_AOT_TARGETS += $$($1_AOT_LIB)\n-endef\n-\n-################################################################################\n-# Optionally create AOT libraries before running tests.\n-# Note, this could not be done during JDK build time.\n-################################################################################\n-# Parameter 1 is the name of the rule.\n-#\n-# Remaining parameters are named arguments.\n-#   MODULES     The modules to generate a library for\n-#   VM_OPTIONS  List of JVM arguments to use when creating libraries\n-#\n-# After calling this, the following variables are defined\n-#   $1_AOT_OPTIONS List of all java options needed to use the AOT libraries\n-#   $1_AOT_TARGETS List of all targets that the test rule will need to depend on\n-#\n-SetupAot = $(NamedParamsMacroTemplate)\n-define SetupAotBody\n-  $$(info Running with AOTd libraries for $$($1_MODULES))\n-  # Put aot libraries in a separate directory so they are not deleted between\n-  # test runs and may be reused between make invocations.\n-  $$(foreach m, $$($1_MODULES), \\\n-    $$(eval $$(call SetupAotModule, $1_$$m, \\\n-        MODULE := $$m, \\\n-        BIN := $$(TEST_SUPPORT_DIR)\/aot\/$1, \\\n-        VM_OPTIONS := $$($1_VM_OPTIONS), \\\n-    )) \\\n-    $$(eval $1_AOT_OPTIONS += $$($1_$$m_AOT_OPTIONS)) \\\n-    $$(eval $1_AOT_TARGETS += $$($1_$$m_AOT_TARGETS)) \\\n-  )\n-endef\n-\n@@ -285,1 +195,0 @@\n-$(eval $(call SetTestOpt,AOT_MODULES,JTREG))\n@@ -296,1 +205,1 @@\n-        EXTRA_PROBLEM_LISTS AOT_MODULES LAUNCHER_OPTIONS, \\\n+        EXTRA_PROBLEM_LISTS LAUNCHER_OPTIONS, \\\n@@ -308,1 +217,0 @@\n-$(eval $(call SetTestOpt,AOT_MODULES,GTEST))\n@@ -312,1 +220,1 @@\n-    STRING_KEYWORDS := OPTIONS VM_OPTIONS JAVA_OPTIONS AOT_MODULES, \\\n+    STRING_KEYWORDS := OPTIONS VM_OPTIONS JAVA_OPTIONS, \\\n@@ -595,8 +503,1 @@\n-  ifneq ($$(GTEST_AOT_MODULES), )\n-    $$(eval $$(call SetupAot, $1, \\\n-        MODULES := $$(GTEST_AOT_MODULES), \\\n-        VM_OPTIONS := $$(GTEST_VM_OPTIONS) $$(GTEST_JAVA_OPTIONS), \\\n-    ))\n-  endif\n-\n-  run-test-$1: pre-run-test $$($1_AOT_TARGETS)\n+  run-test-$1: pre-run-test\n@@ -613,1 +514,1 @@\n-\t        $$(GTEST_JAVA_OPTIONS) $$($1_AOT_OPTIONS) \\\n+\t        $$(GTEST_JAVA_OPTIONS) \\\n@@ -937,11 +838,0 @@\n-  ifneq ($$(JTREG_AOT_MODULES), )\n-    $$(eval $$(call SetupAot, $1, \\\n-        MODULES := $$(JTREG_AOT_MODULES), \\\n-        VM_OPTIONS := $$(JTREG_VM_OPTIONS) $$(JTREG_JAVA_OPTIONS), \\\n-    ))\n-  endif\n-\n-  ifneq ($$($1_AOT_OPTIONS), )\n-    $1_JTREG_BASIC_OPTIONS += -vmoptions:\"$$($1_AOT_OPTIONS)\"\n-  endif\n-\n@@ -982,1 +872,1 @@\n-  run-test-$1: pre-run-test clean-workdir-$1 $$($1_AOT_TARGETS)\n+  run-test-$1: pre-run-test clean-workdir-$1\n","filename":"make\/RunTests.gmk","additions":7,"deletions":117,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -225,19 +225,0 @@\n-# Setup LD for AOT support\n-ifneq ($(DEVKIT_HOME), )\n-  ifeq ($(OPENJDK_TARGET_OS), windows)\n-    LD_JAOTC := $(DEVKIT_HOME)\/VC\/bin\/x64\/link.exe\n-    LIBRARY_PREFIX :=\n-    SHARED_LIBRARY_SUFFIX := .dll\n-  else ifeq ($(OPENJDK_TARGET_OS), linux)\n-    LD_JAOTC := $(DEVKIT_HOME)\/bin\/ld\n-    LIBRARY_PREFIX := lib\n-    SHARED_LIBRARY_SUFFIX := .so\n-  else ifeq ($(OPENJDK_TARGET_OS), macosx)\n-    LD_JAOTC := $(DEVKIT_HOME)\/Xcode.app\/Contents\/Developer\/Toolchains\/XcodeDefault.xctoolchain\/usr\/bin\/ld\n-    LIBRARY_PREFIX := lib\n-    SHARED_LIBRARY_SUFFIX := .dylib\n-  endif\n-else\n-  LD := ld\n-endif\n-\n@@ -289,3 +270,0 @@\n-    LD_JAOTC := $(LD_JAOTC), \\\n-    LIBRARY_PREFIX := $(LIBRARY_PREFIX), \\\n-    SHARED_LIBRARY_SUFFIX := $(SHARED_LIBRARY_SUFFIX), \\\n","filename":"make\/RunTestsPrebuilt.gmk","additions":1,"deletions":23,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    aot cds compiler1 compiler2 dtrace epsilongc g1gc graal jfr jni-check \\\n+    cds compiler1 compiler2 dtrace epsilongc g1gc graal jfr jni-check \\\n@@ -58,1 +58,0 @@\n-m4_define(jvm_feature_desc_aot, [enable ahead of time compilation (AOT)])\n@@ -97,1 +96,0 @@\n-  UTIL_ALIASED_ARG_ENABLE(aot, --enable-jvm-feature-aot)\n@@ -232,28 +230,0 @@\n-###############################################################################\n-# Check if the feature 'aot' is available on this platform.\n-#\n-AC_DEFUN_ONCE([JVM_FEATURES_CHECK_AOT],\n-[\n-  JVM_FEATURES_CHECK_AVAILABILITY(aot, [\n-    AC_MSG_CHECKING([if platform is supported by AOT])\n-    # AOT is only available where JVMCI is available since it requires JVMCI.\n-    if test \"x$OPENJDK_TARGET_CPU\" = \"xx86_64\"; then\n-      AC_MSG_RESULT([yes])\n-    elif test \"x$OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU\" = \"xlinux-aarch64\"; then\n-      AC_MSG_RESULT([yes])\n-    else\n-      AC_MSG_RESULT([no, $OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU])\n-      AVAILABLE=false\n-    fi\n-\n-    AC_MSG_CHECKING([if AOT source code is present])\n-    if test -e \"${TOPDIR}\/src\/jdk.internal.vm.compiler\" && \\\n-        test -e \"${TOPDIR}\/src\/jdk.aot\"; then\n-      AC_MSG_RESULT([yes])\n-    else\n-      AC_MSG_RESULT([no, missing src\/jdk.internal.vm.compiler or src\/jdk.aot])\n-      AVAILABLE=false\n-    fi\n-  ])\n-])\n-\n@@ -442,1 +412,0 @@\n-  JVM_FEATURES_CHECK_AOT\n@@ -478,1 +447,1 @@\n-    JVM_FEATURES_VARIANT_UNAVAILABLE=\"aot cds compiler1 compiler2 \\\n+    JVM_FEATURES_VARIANT_UNAVAILABLE=\"cds compiler1 compiler2 \\\n@@ -486,1 +455,1 @@\n-    JVM_FEATURES_VARIANT_FILTER=\"aot compiler2 graal jvmci link-time-opt opt-size\"\n+    JVM_FEATURES_VARIANT_FILTER=\"compiler2 graal jvmci link-time-opt opt-size\"\n@@ -488,1 +457,1 @@\n-    JVM_FEATURES_VARIANT_FILTER=\"aot cds compiler2 dtrace epsilongc g1gc \\\n+    JVM_FEATURES_VARIANT_FILTER=\"cds compiler2 dtrace epsilongc g1gc \\\n@@ -499,1 +468,1 @@\n-    JVM_FEATURES_VARIANT_FILTER=\"aot compiler1 compiler2 graal jvmci \\\n+    JVM_FEATURES_VARIANT_FILTER=\"compiler1 compiler2 graal jvmci \\\n@@ -576,4 +545,0 @@\n-  if JVM_FEATURES_IS_ACTIVE(aot) && ! JVM_FEATURES_IS_ACTIVE(graal); then\n-    AC_MSG_ERROR([Specified JVM feature 'aot' requires feature 'graal' for variant '$variant'])\n-  fi\n-\n@@ -599,3 +564,0 @@\n-  if ! JVM_FEATURES_IS_ACTIVE(aot); then\n-    ENABLE_AOT=\"false\"\n-  fi\n@@ -632,1 +594,0 @@\n-  ENABLE_AOT=\"true\"\n@@ -671,1 +632,0 @@\n-  AC_SUBST(ENABLE_AOT)\n","filename":"make\/autoconf\/jvm-features.m4","additions":5,"deletions":45,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -526,3 +526,0 @@\n-# Linker used by the jaotc tool for AOT compilation.\n-LD_JAOTC:=@LD_JAOTC@\n-\n@@ -768,1 +765,0 @@\n-ENABLE_AOT:=@ENABLE_AOT@\n","filename":"make\/autoconf\/spec.gmk.in","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -667,3 +667,0 @@\n-    # jaotc being a windows program expects the linker to be supplied with exe suffix.but without\n-    # fixpath\n-    LD_JAOTC=\"${LD##$FIXPATH }\"\n@@ -674,2 +671,0 @@\n-    # jaotc expects 'ld' as the linker rather than the compiler.\n-    UTIL_LOOKUP_TOOLCHAIN_PROGS(LD_JAOTC, ld)\n@@ -678,1 +673,0 @@\n-  AC_SUBST(LD_JAOTC)\n","filename":"make\/autoconf\/toolchain.m4","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,5 +73,0 @@\n-# Filter out aot specific modules if aot is disabled\n-ifeq ($(ENABLE_AOT), false)\n-  MODULES_FILTER += jdk.aot\n-endif\n-\n","filename":"make\/common\/Modules.gmk","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-    jdk.aot \\\n","filename":"make\/conf\/build-module-sets.conf","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -254,1 +254,0 @@\n-            \"--disable-jvm-feature-aot\",\n","filename":"make\/conf\/jib-profiles.js","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,0 @@\n-    jdk.aot \\\n","filename":"make\/conf\/module-loader-map.conf","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -145,8 +145,0 @@\n-ifneq ($(call check-jvm-feature, aot), true)\n-  JVM_CFLAGS_FEATURES += -DINCLUDE_AOT=0\n-  JVM_EXCLUDE_FILES += \\\n-      compiledIC_aot_x86_64.cpp compiledIC_aot_aarch64.cpp      \\\n-      compilerRuntime.cpp aotCodeHeap.cpp aotCompiledMethod.cpp \\\n-      aotLoader.cpp compiledIC_aot.cpp\n-endif\n-\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,1 +114,0 @@\n-      -hidePath jdk.aot \\\n","filename":"make\/ide\/visualstudio\/hotspot\/CreateVSProject.gmk","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,54 +0,0 @@\n-#\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# -parameters provides method's parameters information in class file,\n-# JVMCI compilers make use of that information for various sanity checks.\n-# Don't use Indy strings concatenation to have good JAOTC startup performance.\n-# The exports are needed since JVMCI is dynamically exported (see\n-# jdk.vm.ci.services.internal.ReflectionAccessJDK::openJVMCITo).\n-\n-JAVAC_FLAGS += -parameters -XDstringConcat=inline \\\n-    --add-exports jdk.internal.vm.ci\/jdk.vm.ci.aarch64=jdk.internal.vm.compiler,jdk.aot \\\n-    --add-exports jdk.internal.vm.ci\/jdk.vm.ci.amd64=jdk.internal.vm.compiler,jdk.aot \\\n-    --add-exports jdk.internal.vm.ci\/jdk.vm.ci.code=jdk.internal.vm.compiler,jdk.aot \\\n-    --add-exports jdk.internal.vm.ci\/jdk.vm.ci.code.site=jdk.internal.vm.compiler,jdk.aot \\\n-    --add-exports jdk.internal.vm.ci\/jdk.vm.ci.code.stack=jdk.internal.vm.compiler,jdk.aot \\\n-    --add-exports jdk.internal.vm.ci\/jdk.vm.ci.common=jdk.internal.vm.compiler,jdk.aot \\\n-    --add-exports jdk.internal.vm.ci\/jdk.vm.ci.hotspot=jdk.internal.vm.compiler,jdk.aot \\\n-    --add-exports jdk.internal.vm.ci\/jdk.vm.ci.hotspot.aarch64=jdk.internal.vm.compiler,jdk.aot \\\n-    --add-exports jdk.internal.vm.ci\/jdk.vm.ci.hotspot.amd64=jdk.internal.vm.compiler,jdk.aot \\\n-    --add-exports jdk.internal.vm.ci\/jdk.vm.ci.meta=jdk.internal.vm.compiler,jdk.aot \\\n-    --add-exports jdk.internal.vm.ci\/jdk.vm.ci.runtime=jdk.internal.vm.compiler,jdk.aot \\\n-    #\n-\n-EXCLUDES += \\\n-    jdk.tools.jaotc.test\n-    #\n-\n-## WORKAROUND jdk.aot source structure issue\n-AOT_MODULESOURCEPATH := $(MODULESOURCEPATH) \\\n-    $(subst \/$(MODULE)\/,\/*\/, $(filter-out %processor\/src, \\\n-        $(wildcard $(TOPDIR)\/src\/$(MODULE)\/share\/classes\/*\/src)))\n-MODULESOURCEPATH := $(call PathList, $(AOT_MODULESOURCEPATH))\n","filename":"make\/modules\/jdk.aot\/Java.gmk","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-#\n-# Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-include LauncherCommon.gmk\n-\n-# The JVMCI exports are needed since JVMCI is normally dynamically exported\n-# (see jdk.vm.ci.services.internal.ReflectionAccessJDK::openJVMCITo).\n-\n-$(eval $(call SetupBuildLauncher, jaotc, \\\n-    MAIN_CLASS := jdk.tools.jaotc.Main, \\\n-    EXTRA_JAVA_ARGS := -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI \\\n-        --add-exports=jdk.internal.vm.ci\/jdk.vm.ci.aarch64=$(call CommaList, jdk.internal.vm.compiler  jdk.aot) \\\n-        --add-exports=jdk.internal.vm.ci\/jdk.vm.ci.amd64=$(call CommaList, jdk.internal.vm.compiler  jdk.aot) \\\n-        --add-exports=jdk.internal.vm.ci\/jdk.vm.ci.code=$(call CommaList, jdk.internal.vm.compiler  jdk.aot) \\\n-        --add-exports=jdk.internal.vm.ci\/jdk.vm.ci.code.site=$(call CommaList, jdk.internal.vm.compiler  jdk.aot) \\\n-        --add-exports=jdk.internal.vm.ci\/jdk.vm.ci.code.stack=$(call CommaList, jdk.internal.vm.compiler  jdk.aot) \\\n-        --add-exports=jdk.internal.vm.ci\/jdk.vm.ci.common=$(call CommaList, jdk.internal.vm.compiler  jdk.aot) \\\n-        --add-exports=jdk.internal.vm.ci\/jdk.vm.ci.hotspot=$(call CommaList, jdk.internal.vm.compiler  jdk.aot) \\\n-    , \\\n-    JAVA_ARGS := --add-exports=jdk.internal.vm.ci\/jdk.vm.ci.hotspot.aarch64=$(call CommaList, jdk.internal.vm.compiler  jdk.aot) \\\n-        --add-exports=jdk.internal.vm.ci\/jdk.vm.ci.hotspot.amd64=$(call CommaList, jdk.internal.vm.compiler  jdk.aot) \\\n-        --add-exports=jdk.internal.vm.ci\/jdk.vm.ci.hotspot.aarch64=$(call CommaList, jdk.internal.vm.compiler  jdk.aot) \\\n-        --add-exports=jdk.internal.vm.ci\/jdk.vm.ci.meta=$(call CommaList, jdk.internal.vm.compiler  jdk.aot) \\\n-        --add-exports=jdk.internal.vm.ci\/jdk.vm.ci.runtime=$(call CommaList, jdk.internal.vm.compiler  jdk.aot) \\\n-        -XX:+UnlockExperimentalVMOptions -XX:+UseAOT \\\n-        -XX:+CalculateClassFingerprint \\\n-        -Djvmci.UseProfilingInformation=false \\\n-        -Dgraal.UseExceptionProbability=false \\\n-        -Djvmci.Compiler=graal \\\n-        --add-modules ALL-DEFAULT \\\n-    , \\\n-))\n","filename":"make\/modules\/jdk.aot\/Launcher.gmk","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,0 @@\n-    jdk.tools.jaotc.test \\\n","filename":"make\/modules\/jdk.internal.vm.compiler\/Java.gmk","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1363,1 +1363,1 @@\n-    if (UseCompressedOops && (CompressedOops::ptrs_base() != NULL || UseAOT)) {\n+    if (UseCompressedOops && (CompressedOops::ptrs_base() != NULL)) {\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,0 @@\n-    _call_aot_stub_size = 0,\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1414,1 +1414,1 @@\n-  if (!CompilerConfig::is_c1_only_no_aot_or_jvmci()) {\n+  if (!CompilerConfig::is_c1_only_no_jvmci()) {\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,9 +63,0 @@\n-#if INCLUDE_AOT\n-  \/\/ Don't create a Metadata reloc if we're generating immutable PIC.\n-  if (cbuf.immutable_PIC()) {\n-    __ movptr(rmethod, 0);\n-    __ movptr(rscratch1, 0);\n-    __ br(rscratch1);\n-\n-  } else\n-#endif\n@@ -99,55 +90,0 @@\n-#if INCLUDE_AOT\n-#define __ _masm.\n-void CompiledStaticCall::emit_to_aot_stub(CodeBuffer &cbuf, address mark) {\n-  if (!UseAOT) {\n-    return;\n-  }\n-  \/\/ Stub is fixed up when the corresponding call is converted from\n-  \/\/ calling compiled code to calling aot code.\n-  \/\/ mov r, imm64_aot_code_address\n-  \/\/ jmp r\n-\n-  if (mark == NULL) {\n-    mark = cbuf.insts_mark();  \/\/ Get mark within main instrs section.\n-  }\n-\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a stub.\n-  MacroAssembler _masm(&cbuf);\n-\n-  address base =\n-  __ start_a_stub(to_aot_stub_size());\n-  guarantee(base != NULL, \"out of space\");\n-\n-  \/\/ Static stub relocation stores the instruction address of the call.\n-  __ relocate(static_stub_Relocation::spec(mark, true \/* is_aot *\/));\n-  \/\/ Load destination AOT code address.\n-  __ movptr(rscratch1, 0);  \/\/ address is zapped till fixup time.\n-  \/\/ This is recognized as unresolved by relocs\/nativeinst\/ic code.\n-  __ br(rscratch1);\n-\n-  assert(__ pc() - base <= to_aot_stub_size(), \"wrong stub size\");\n-\n-  \/\/ Update current stubs pointer and restore insts_end.\n-  __ end_a_stub();\n-}\n-#undef __\n-\n-int CompiledStaticCall::to_aot_stub_size() {\n-  if (UseAOT) {\n-    return 5 * 4;  \/\/ movz; movk; movk; movk; br\n-  } else {\n-    return 0;\n-  }\n-}\n-\n-\/\/ Relocation entries for call stub, compiled java to aot.\n-int CompiledStaticCall::reloc_to_aot_stub() {\n-  if (UseAOT) {\n-    return 5 * 4;  \/\/ movz; movk; movk; movk; br\n-  } else {\n-    return 0;\n-  }\n-}\n-#endif \/\/ INCLUDE_AOT\n-\n@@ -155,1 +91,1 @@\n-  address stub = find_stub(false \/* is_aot *\/);\n+  address stub = find_stub();\n@@ -191,4 +127,2 @@\n-  if (!static_stub->is_aot()) {\n-    NativeJump* jump = nativeJump_at(method_holder->next_instruction_address());\n-    jump->set_jump_destination((address)-1);\n-  }\n+  NativeJump* jump = nativeJump_at(method_holder->next_instruction_address());\n+  jump->set_jump_destination((address)-1);\n@@ -207,1 +141,1 @@\n-  address stub = find_stub(false \/* is_aot *\/);\n+  address stub = find_stub();\n","filename":"src\/hotspot\/cpu\/aarch64\/compiledIC_aarch64.cpp","additions":5,"deletions":71,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -1,104 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"aot\/compiledIC_aot.hpp\"\n-#include \"code\/codeCache.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"memory\/universe.hpp\"\n-\n-void CompiledDirectStaticCall::set_to_far(const methodHandle& callee, address entry) {\n-  if (TraceICs) {\n-    ResourceMark rm;\n-    tty->print_cr(\"CompiledDirectStaticCall@\" INTPTR_FORMAT \": set_to_far %s\",\n-                  p2i(instruction_address()),\n-                  callee->name_and_sig_as_C_string());\n-  }\n-\n-  set_destination_mt_safe(entry);\n-}\n-\n-void CompiledPltStaticCall::set_to_interpreted(const methodHandle& callee, address entry) {\n-  address stub = find_stub();\n-  guarantee(stub != NULL, \"stub not found\");\n-  if (TraceICs) {\n-    ResourceMark rm;\n-    tty->print_cr(\"CompiledPltStaticCall@\" INTPTR_FORMAT \": set_to_interpreted %s\",\n-                  p2i(instruction_address()),\n-                  callee->name_and_sig_as_C_string());\n-  }\n-\n-  \/\/ Creation also verifies the object.\n-  NativeLoadGot* method_loader = nativeLoadGot_at(stub);\n-  NativeGotJump* jump          = nativeGotJump_at(method_loader->next_instruction_address());\n-\n-  intptr_t data = method_loader->data();\n-  address destination = jump->destination();\n-  assert(data == 0 || data == (intptr_t)callee(),\n-         \"a) MT-unsafe modification of inline cache\");\n-  assert(destination == (address)Universe::non_oop_word()\n-         || destination == entry,\n-         \"b) MT-unsafe modification of inline cache\");\n-\n-  \/\/ Update stub.\n-  method_loader->set_data((intptr_t)callee());\n-  jump->set_jump_destination(entry);\n-\n-  \/\/ Update jump to call.\n-  set_destination_mt_safe(stub);\n-}\n-\n-#ifdef NEVER_CALLED\n-void CompiledPltStaticCall::set_stub_to_clean(static_stub_Relocation* static_stub) {\n-  \/\/ Reset stub.\n-  address stub = static_stub->addr();\n-  assert(stub != NULL, \"stub not found\");\n-  assert(CompiledICLocker::is_safe(stub), \"mt unsafe call\");\n-  \/\/ Creation also verifies the object.\n-  NativeLoadGot* method_loader = nativeLoadGot_at(stub);\n-  NativeGotJump* jump          = nativeGotJump_at(method_loader->next_instruction_address());\n-  method_loader->set_data(0);\n-  jump->set_jump_destination((address)-1);\n-}\n-#endif\n-\n-#ifndef PRODUCT\n-void CompiledPltStaticCall::verify() {\n-  \/\/ Verify call.\n-  _call->verify();\n-\n-#ifdef ASSERT\n-  CodeBlob *cb = CodeCache::find_blob_unsafe((address) _call);\n-  assert(cb && cb->is_aot(), \"CompiledPltStaticCall can only be used on AOTCompiledMethod\");\n-#endif\n-\n-  \/\/ Verify stub.\n-  address stub = find_stub();\n-  assert(stub != NULL, \"no stub found for static call\");\n-  \/\/ Creation also verifies the object.\n-  NativeLoadGot*     method_loader = nativeLoadGot_at(stub);\n-  NativeGotJump*     jump          = nativeGotJump_at(method_loader->next_instruction_address());\n-  \/\/ Verify state.\n-  assert(is_clean() || is_call_to_compiled() || is_call_to_interpreted(), \"sanity check\");\n-}\n-#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/cpu\/aarch64\/compiledIC_aot_aarch64.cpp","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"},{"patch":"@@ -54,1 +54,1 @@\n-  if (CompilerConfig::is_c1_only_no_aot_or_jvmci()) {\n+  if (CompilerConfig::is_c1_only_no_jvmci()) {\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1087,1 +1087,1 @@\n-    return ReservedCodeCacheSize > branch_range || UseAOT;\n+    return ReservedCodeCacheSize > branch_range;\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -479,10 +479,3 @@\n-\n-#ifdef ASSERT\n-  \/\/ This may be the temporary nmethod generated while we're AOT\n-  \/\/ compiling.  Such an nmethod doesn't begin with a NOP but with an ADRP.\n-  if (! (CalculateClassFingerprint && UseAOT && is_adrp_at(verified_entry))) {\n-    assert(nativeInstruction_at(verified_entry)->is_jump_or_nop()\n-           || nativeInstruction_at(verified_entry)->is_sigill_zombie_not_entrant(),\n-           \"Aarch64 cannot replace non-jump with jump\");\n-  }\n-#endif\n+  assert(nativeInstruction_at(verified_entry)->is_jump_or_nop()\n+         || nativeInstruction_at(verified_entry)->is_sigill_zombie_not_entrant(),\n+         \"Aarch64 cannot replace non-jump with jump\");\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -233,10 +233,0 @@\n-#if INCLUDE_AOT\n-  \/\/ Return true iff a call from instr to target is out of range.\n-  \/\/ Used for calls from JIT- to AOT-compiled code.\n-  static bool is_far_call(address instr, address target) {\n-    \/\/ On AArch64 we use trampolines which can reach anywhere in the\n-    \/\/ address space, so calls are never out of range.\n-    return false;\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -596,1 +596,1 @@\n-  if (EnableJVMCI || UseAOT) {\n+  if (EnableJVMCI) {\n@@ -2179,1 +2179,1 @@\n-  if (EnableJVMCI || UseAOT) {\n+  if (EnableJVMCI) {\n@@ -2254,1 +2254,1 @@\n-  if (EnableJVMCI || UseAOT) {\n+  if (EnableJVMCI) {\n@@ -2380,1 +2380,1 @@\n-  if (EnableJVMCI || UseAOT) {\n+  if (EnableJVMCI) {\n@@ -2543,1 +2543,1 @@\n-  if (EnableJVMCI || UseAOT) {\n+  if (EnableJVMCI) {\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -505,1 +505,1 @@\n-  if ((EnableJVMCI || UseAOT) && state == vtos && step == 0) {\n+  if (EnableJVMCI && state == vtos && step == 0) {\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2428,1 +2428,1 @@\n-  if (!CompilerConfig::is_c1_or_interpreter_only_no_aot_or_jvmci()){\n+  if (!CompilerConfig::is_c1_or_interpreter_only_no_jvmci()){\n@@ -3031,1 +3031,1 @@\n-  if (!CompilerConfig::is_c1_or_interpreter_only_no_aot_or_jvmci()) {\n+  if (!CompilerConfig::is_c1_or_interpreter_only_no_jvmci()) {\n@@ -3093,1 +3093,1 @@\n-  if (!CompilerConfig::is_c1_or_interpreter_only_no_aot_or_jvmci()) {\n+  if (!CompilerConfig::is_c1_or_interpreter_only_no_jvmci()) {\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,0 @@\n-    _call_aot_stub_size = 0,\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,1 @@\n-  address stub = find_stub(\/*is_aot*\/ false);\n+  address stub = find_stub();\n@@ -152,1 +152,1 @@\n-  address stub = find_stub(\/*is_aot*\/ false);\n+  address stub = find_stub();\n","filename":"src\/hotspot\/cpu\/arm\/compiledIC_arm.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,0 @@\n-  _call_aot_stub_size = 0,\n@@ -73,5 +72,1 @@\n-    if (UseAOT) {\n-      return _static_call_stub_size + _call_aot_stub_size;\n-    } else {\n-      return _static_call_stub_size;\n-    }\n+    return _static_call_stub_size;\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -167,1 +167,1 @@\n-  address stub = find_stub(\/*is_aot*\/ false);\n+  address stub = find_stub();\n@@ -213,1 +213,1 @@\n-  address stub = find_stub(\/*is_aot*\/ false);\n+  address stub = find_stub();\n","filename":"src\/hotspot\/cpu\/ppc\/compiledIC_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,0 @@\n-    _call_aot_stub_size = 0,\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-  address stub = find_stub(\/*is_aot*\/ false);\n+  address stub = find_stub();\n@@ -140,1 +140,1 @@\n-  address stub = find_stub(\/*is_aot*\/ false);\n+  address stub = find_stub();\n","filename":"src\/hotspot\/cpu\/s390\/compiledIC_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2921,1 +2921,1 @@\n-  __ relocate(static_stub_Relocation::spec(call_pc, false \/* is_aot *\/));\n+  __ relocate(static_stub_Relocation::spec(call_pc));\n@@ -2928,10 +2928,0 @@\n-  if (UseAOT) {\n-    \/\/ Trampoline to aot code\n-    __ relocate(static_stub_Relocation::spec(call_pc, true \/* is_aot *\/));\n-#ifdef _LP64\n-    __ mov64(rax, CONST64(0));  \/\/ address is zapped till fixup time.\n-#else\n-    __ movl(rax, 0xdeadffff);  \/\/ address is zapped till fixup time.\n-#endif\n-    __ jmp(rax);\n-  }\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,0 @@\n-    _call_aot_stub_size = NOT_LP64(7) LP64_ONLY(12),\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -339,1 +339,1 @@\n-  if (UseSSE < 2 && !CompilerConfig::is_c1_only_no_aot_or_jvmci()) {\n+  if (UseSSE < 2 && !CompilerConfig::is_c1_only_no_jvmci()) {\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -725,1 +725,1 @@\n-  if (UseSSE < 2 && !CompilerConfig::is_c1_only_no_aot_or_jvmci()) {\n+  if (UseSSE < 2 && !CompilerConfig::is_c1_only_no_jvmci()) {\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#include \"aot\/compiledIC_aot.hpp\"\n-#include \"code\/codeCache.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-\n-void CompiledDirectStaticCall::set_to_far(const methodHandle& callee, address entry) {\n-  address stub = find_stub(true \/* is_far *\/);\n-  guarantee(stub != NULL, \"stub not found\");\n-\n-  if (TraceICs) {\n-    ResourceMark rm;\n-    tty->print_cr(\"CompiledDirectStaticCall@\" INTPTR_FORMAT \": set_to_far %s\",\n-                  p2i(instruction_address()),\n-                  callee->name_and_sig_as_C_string());\n-  }\n-\n-  \/\/ Creation also verifies the object.\n-  \/\/ mov rax,imm_aot_addr\n-  \/\/ jmp rax\n-  NativeMovConstReg* destination_holder = nativeMovConstReg_at(stub);\n-\n-#ifdef ASSERT\n-  \/\/ read the value once\n-  intptr_t data = destination_holder->data();\n-  assert(data == 0 || data == (intptr_t)entry,\n-         \"MT-unsafe modification of inline cache\");\n-#endif\n-\n-  \/\/ Update stub.\n-  destination_holder->set_data((intptr_t)entry);\n-\n-  \/\/ Update jump to call.\n-  set_destination_mt_safe(stub);\n-}\n-\n-void CompiledPltStaticCall::set_to_interpreted(const methodHandle& callee, address entry) {\n-  address stub = find_stub();\n-  guarantee(stub != NULL, \"stub not found\");\n-  if (TraceICs) {\n-    ResourceMark rm;\n-    tty->print_cr(\"CompiledPltStaticCall@\" INTPTR_FORMAT \": set_to_interpreted %s\",\n-                  p2i(instruction_address()),\n-                  callee->name_and_sig_as_C_string());\n-  }\n-\n-  \/\/ Creation also verifies the object.\n-  NativeLoadGot* method_loader = nativeLoadGot_at(stub);\n-  NativeGotJump* jump          = nativeGotJump_at(method_loader->next_instruction_address());\n-\n-  intptr_t data = method_loader->data();\n-  address destination = jump->destination();\n-  assert(data == 0 || data == (intptr_t)callee(),\n-         \"a) MT-unsafe modification of inline cache\");\n-  assert(destination == (address)-1 || destination == entry,\n-         \"b) MT-unsafe modification of inline cache\");\n-\n-  \/\/ Update stub.\n-  method_loader->set_data((intptr_t)callee());\n-  jump->set_jump_destination(entry);\n-\n-  \/\/ Update jump to call.\n-  set_destination_mt_safe(stub);\n-}\n-\n-#ifdef NEVER_CALLED\n-void CompiledPltStaticCall::set_stub_to_clean(static_stub_Relocation* static_stub) {\n-  \/\/ Reset stub.\n-  address stub = static_stub->addr();\n-  assert(stub != NULL, \"stub not found\");\n-  assert(CompiledICLocker::is_safe(stub), \"mt unsafe call\");\n-  \/\/ Creation also verifies the object.\n-  NativeLoadGot* method_loader = nativeLoadGot_at(stub);\n-  NativeGotJump* jump          = nativeGotJump_at(method_loader->next_instruction_address());\n-  method_loader->set_data(0);\n-  jump->set_jump_destination((address)-1);\n-}\n-#endif\n-\n-#ifndef PRODUCT\n-void CompiledPltStaticCall::verify() {\n-  \/\/ Verify call.\n-  _call->verify();\n-\n-#ifdef ASSERT\n-  CodeBlob *cb = CodeCache::find_blob_unsafe((address) _call);\n-  assert(cb && cb->is_aot(), \"CompiledPltStaticCall can only be used on AOTCompiledMethod\");\n-#endif\n-\n-  \/\/ Verify stub.\n-  address stub = find_stub();\n-  assert(stub != NULL, \"no stub found for static call\");\n-  \/\/ Creation also verifies the object.\n-  NativeLoadGot*     method_loader = nativeLoadGot_at(stub);\n-  NativeGotJump*     jump          = nativeGotJump_at(method_loader->next_instruction_address());\n-  \/\/ Verify state.\n-  assert(is_clean() || is_call_to_compiled() || is_call_to_interpreted(), \"sanity check\");\n-}\n-#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/cpu\/x86\/compiledIC_aot_x86_64.cpp","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-  __ relocate(static_stub_Relocation::spec(mark, false), Assembler::imm_operand);\n+  __ relocate(static_stub_Relocation::spec(mark), Assembler::imm_operand);\n@@ -86,60 +86,0 @@\n-#if INCLUDE_AOT\n-#define __ _masm.\n-void CompiledStaticCall::emit_to_aot_stub(CodeBuffer &cbuf, address mark) {\n-  if (!UseAOT) {\n-    return;\n-  }\n-  \/\/ Stub is fixed up when the corresponding call is converted from\n-  \/\/ calling compiled code to calling aot code.\n-  \/\/ movq rax, imm64_aot_code_address\n-  \/\/ jmp  rax\n-\n-  if (mark == NULL) {\n-    mark = cbuf.insts_mark();  \/\/ Get mark within main instrs section.\n-  }\n-\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a stub.\n-  MacroAssembler _masm(&cbuf);\n-\n-  address base =\n-  __ start_a_stub(to_aot_stub_size());\n-  guarantee(base != NULL, \"out of space\");\n-\n-  \/\/ Static stub relocation stores the instruction address of the call.\n-  __ relocate(static_stub_Relocation::spec(mark, true \/* is_aot *\/), Assembler::imm_operand);\n-  \/\/ Load destination AOT code address.\n-#ifdef _LP64\n-  __ mov64(rax, CONST64(0));  \/\/ address is zapped till fixup time.\n-#else\n-  __ movl(rax, 0);  \/\/ address is zapped till fixup time.\n-#endif\n-  \/\/ This is recognized as unresolved by relocs\/nativeinst\/ic code.\n-  __ jmp(rax);\n-\n-  assert(__ pc() - base <= to_aot_stub_size(), \"wrong stub size\");\n-\n-  \/\/ Update current stubs pointer and restore insts_end.\n-  __ end_a_stub();\n-}\n-#undef __\n-\n-int CompiledStaticCall::to_aot_stub_size() {\n-  if (UseAOT) {\n-    return NOT_LP64(7)    \/\/ movl; jmp\n-           LP64_ONLY(12);  \/\/ movq (1+1+8); jmp (2)\n-  } else {\n-    return 0;\n-  }\n-}\n-\n-\/\/ Relocation entries for call stub, compiled java to aot.\n-int CompiledStaticCall::reloc_to_aot_stub() {\n-  if (UseAOT) {\n-    return 2; \/\/ 1 in emit_to_aot_stub + 1 in emit_call\n-  } else {\n-    return 0;\n-  }\n-}\n-#endif \/\/ INCLUDE_AOT\n-\n@@ -147,1 +87,1 @@\n-  address stub = find_stub(false \/* is_aot *\/);\n+  address stub = find_stub();\n@@ -178,4 +118,2 @@\n-  if (!static_stub->is_aot()) {\n-    NativeJump* jump = nativeJump_at(method_holder->next_instruction_address());\n-    jump->set_jump_destination((address)-1);\n-  }\n+  NativeJump* jump = nativeJump_at(method_holder->next_instruction_address());\n+  jump->set_jump_destination((address)-1);\n@@ -196,1 +134,1 @@\n-  assert(cb && !cb->is_aot(), \"CompiledDirectStaticCall cannot be used on AOTCompiledMethod\");\n+  assert(cb, \"sanity\");\n@@ -200,1 +138,1 @@\n-  address stub = find_stub(false \/* is_aot *\/);\n+  address stub = find_stub();\n","filename":"src\/hotspot\/cpu\/x86\/compiledIC_x86.cpp","additions":7,"deletions":69,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-#define COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS (EnableJVMCI || UseAOT)\n+#define COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS (EnableJVMCI)\n","filename":"src\/hotspot\/cpu\/x86\/globalDefinitions_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -202,7 +202,0 @@\n-#if INCLUDE_AOT\n-  static bool is_far_call(address instr, address target) {\n-    intptr_t disp = target - (instr + sizeof(int32_t));\n-    return !Assembler::is_simm32(disp);\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -861,1 +861,1 @@\n-  if (EnableJVMCI || UseAOT) {\n+  if (EnableJVMCI) {\n@@ -2650,1 +2650,1 @@\n-  if (EnableJVMCI || UseAOT) {\n+  if (EnableJVMCI) {\n@@ -2724,1 +2724,1 @@\n-  if (EnableJVMCI || UseAOT) {\n+  if (EnableJVMCI) {\n@@ -2839,1 +2839,1 @@\n-  if (EnableJVMCI || UseAOT) {\n+  if (EnableJVMCI) {\n@@ -3002,1 +3002,1 @@\n-  if (EnableJVMCI || UseAOT) {\n+  if (EnableJVMCI) {\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -264,1 +264,1 @@\n-  if ((EnableJVMCI || UseAOT) && state == vtos && step == 0) {\n+  if (EnableJVMCI && state == vtos && step == 0) {\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2232,3 +2232,0 @@\n-#if INCLUDE_AOT\n-      CompiledStaticCall::emit_to_aot_stub(cbuf, mark);\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -133,3 +133,0 @@\n-#elif INCLUDE_AOT\n-PVOID  topLevelVectoredExceptionHandler = NULL;\n-LONG WINAPI topLevelVectoredExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo);\n@@ -156,1 +153,1 @@\n-#if defined(USE_VECTORED_EXCEPTION_HANDLING) || INCLUDE_AOT\n+#if defined(USE_VECTORED_EXCEPTION_HANDLING)\n@@ -2708,1 +2705,1 @@\n-#if defined(USE_VECTORED_EXCEPTION_HANDLING) || INCLUDE_AOT\n+#if defined(USE_VECTORED_EXCEPTION_HANDLING)\n@@ -2724,3 +2721,1 @@\n-  \/\/ Handle the case where we get an implicit exception in AOT generated\n-  \/\/ code.  AOT DLL's loaded are not registered for structured exceptions.\n-  \/\/ If the exception occurred in the codeCache or AOT code, pass control\n+  \/\/ If the exception occurred in the codeCache, pass control\n@@ -4175,8 +4170,0 @@\n-#elif INCLUDE_AOT\n-  \/\/ If AOT is enabled we need to install a vectored exception handler\n-  \/\/ in order to forward implicit exceptions from code in AOT\n-  \/\/ generated DLLs.  This is necessary since these DLLs are not\n-  \/\/ registered for structured exceptions like codecache methods are.\n-  if (AOTLibrary != NULL && (UseAOT || FLAG_IS_DEFAULT(UseAOT))) {\n-    topLevelVectoredExceptionHandler = AddVectoredExceptionHandler( 1, topLevelVectoredExceptionFilter);\n-  }\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1,1116 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"jvm_io.h\"\n-#include \"aot\/aotCodeHeap.hpp\"\n-#include \"aot\/aotLoader.hpp\"\n-#include \"ci\/ciUtilities.inline.hpp\"\n-#include \"classfile\/javaAssertions.hpp\"\n-#include \"classfile\/systemDictionary.hpp\"\n-#include \"classfile\/vmClasses.hpp\"\n-#include \"classfile\/vmSymbols.hpp\"\n-#include \"gc\/shared\/cardTable.hpp\"\n-#include \"gc\/shared\/cardTableBarrierSet.hpp\"\n-#include \"gc\/shared\/gcConfig.hpp\"\n-#include \"gc\/shared\/tlab_globals.hpp\"\n-#include \"gc\/g1\/heapRegion.hpp\"\n-#include \"interpreter\/abstractInterpreter.hpp\"\n-#include \"jvmci\/compilerRuntime.hpp\"\n-#include \"jvmci\/jvmciRuntime.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"memory\/universe.hpp\"\n-#include \"oops\/compressedOops.hpp\"\n-#include \"oops\/klass.inline.hpp\"\n-#include \"oops\/method.inline.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"runtime\/deoptimization.hpp\"\n-#include \"runtime\/handles.inline.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"runtime\/java.hpp\"\n-#include \"runtime\/safepointVerifiers.hpp\"\n-#include \"runtime\/sharedRuntime.hpp\"\n-#include \"runtime\/stubRoutines.hpp\"\n-#include \"runtime\/vmOperations.hpp\"\n-#include \"utilities\/powerOfTwo.hpp\"\n-#include \"utilities\/sizes.hpp\"\n-\n-bool AOTLib::_narrow_oop_shift_initialized = false;\n-int  AOTLib::_narrow_oop_shift = 0;\n-int  AOTLib::_narrow_klass_shift = 0;\n-\n-address AOTLib::load_symbol(const char *name) {\n-  address symbol = (address) os::dll_lookup(_dl_handle, name);\n-  if (symbol == NULL) {\n-    tty->print_cr(\"Shared file %s error: missing %s\", _name, name);\n-    vm_exit(1);\n-  }\n-  return symbol;\n-}\n-\n-Klass* AOTCodeHeap::get_klass_from_got(const char* klass_name, int klass_len, const Method* method) {\n-  AOTKlassData* klass_data = (AOTKlassData*)_lib->load_symbol(klass_name);\n-  Klass* k = (Klass*)_klasses_got[klass_data->_got_index];\n-  if (k == NULL) {\n-    Thread* thread = Thread::current();\n-    k = lookup_klass(klass_name, klass_len, method, thread);\n-    \/\/ Note, exceptions are cleared.\n-    if (k == NULL) {\n-      fatal(\"Shared file %s error: klass %s should be resolved already\", _lib->name(), klass_name);\n-      vm_exit(1);\n-    }\n-    \/\/ Patch now to avoid extra runtime lookup\n-    _klasses_got[klass_data->_got_index] = k;\n-    if (k->is_instance_klass()) {\n-      InstanceKlass* ik = InstanceKlass::cast(k);\n-      if (ik->is_initialized()) {\n-        _klasses_got[klass_data->_got_index - 1] = ik;\n-      }\n-    }\n-  }\n-  return k;\n-}\n-\n-Klass* AOTCodeHeap::lookup_klass(const char* name, int len, const Method* method, Thread* thread) {\n-  ResourceMark rm(thread);\n-  assert(method != NULL, \"incorrect call parameter\");\n-  methodHandle caller(thread, (Method*)method);\n-\n-  \/\/ Use class loader of aot method.\n-  Handle loader(thread, caller->method_holder()->class_loader());\n-  Handle protection_domain(thread, caller->method_holder()->protection_domain());\n-\n-  \/\/ Ignore wrapping L and ;\n-  if (name[0] == JVM_SIGNATURE_CLASS) {\n-    assert(len > 2, \"small name %s\", name);\n-    name++;\n-    len -= 2;\n-  }\n-  TempNewSymbol sym = SymbolTable::probe(name, len);\n-  if (sym == NULL) {\n-    log_debug(aot, class, resolve)(\"Probe failed for AOT class %s\", name);\n-    return NULL;\n-  }\n-  Klass* k = SystemDictionary::find_instance_or_array_klass(sym, loader, protection_domain);\n-\n-  if (k != NULL) {\n-    log_info(aot, class, resolve)(\"%s %s (lookup)\", caller->method_holder()->external_name(), k->external_name());\n-  }\n-  return k;\n-}\n-\n-void AOTLib::handle_config_error(const char* format, ...) {\n-  if (PrintAOT) {\n-    va_list ap;\n-    va_start(ap, format);\n-    tty->vprint_cr(format, ap);\n-    va_end(ap);\n-  }\n-  if (UseAOTStrictLoading) {\n-    vm_exit(1);\n-  }\n-  _valid = false;\n-}\n-\n-void AOTLib::verify_flag(bool aot_flag, bool flag, const char* name) {\n-  if (_valid && aot_flag != flag) {\n-    handle_config_error(\"Shared file %s error: %s has different value '%s' from current '%s'\", _name, name , (aot_flag ? \"true\" : \"false\"), (flag ? \"true\" : \"false\"));\n-  }\n-}\n-\n-void AOTLib::verify_flag(int aot_flag, int flag, const char* name) {\n-  if (_valid && aot_flag != flag) {\n-    handle_config_error(\"Shared file %s error: %s has different value '%d' from current '%d'\", _name, name , aot_flag, flag);\n-  }\n-}\n-\n-void AOTLib::verify_config() {\n-  GrowableArray<AOTLib*>* libraries = AOTLoader::libraries();\n-  for (GrowableArrayIterator<AOTLib*> lib = libraries->begin(); lib != libraries->end(); ++lib) {\n-    if ((*lib)->_config == _config) {\n-      handle_config_error(\"AOT library %s already loaded.\", (*lib)->_name);\n-      return;\n-    }\n-  }\n-\n-  if (_header->_version != AOTHeader::AOT_SHARED_VERSION) {\n-    handle_config_error(\"Invalid version of the shared file %s. Expected %d but was %d\", _name, _header->_version, AOTHeader::AOT_SHARED_VERSION);\n-    return;\n-  }\n-\n-  const char* aot_jvm_version = (const char*)_header + _header->_jvm_version_offset + 2;\n-  if (strcmp(aot_jvm_version, VM_Version::jre_release_version()) != 0) {\n-    handle_config_error(\"JVM version '%s' recorded in the shared file %s does not match current version '%s'\", aot_jvm_version, _name, VM_Version::jre_release_version());\n-    return;\n-  }\n-\n-  \/\/ Debug VM has different layout of runtime and metadata structures\n-#ifdef ASSERT\n-  verify_flag(_config->_debug_VM, true, \"Debug VM version\");\n-#else\n-  verify_flag(!(_config->_debug_VM), true, \"Product VM version\");\n-#endif\n-  \/\/ Check configuration size\n-  verify_flag(_config->_config_size, AOTConfiguration::CONFIG_SIZE, \"AOT configuration size\");\n-\n-  \/\/ Check GC\n-  CollectedHeap::Name gc = (CollectedHeap::Name)_config->_gc;\n-  if (_valid && !GCConfig::is_gc_selected(gc)) {\n-    handle_config_error(\"Shared file %s error: used '%s' is different from current '%s'\", _name, GCConfig::hs_err_name(gc), GCConfig::hs_err_name());\n-  }\n-\n-  \/\/ Check flags\n-  verify_flag(_config->_useCompressedOops, UseCompressedOops, \"UseCompressedOops\");\n-  verify_flag(_config->_useCompressedClassPointers, UseCompressedClassPointers, \"UseCompressedClassPointers\");\n-  verify_flag(_config->_useTLAB, UseTLAB, \"UseTLAB\");\n-  verify_flag(_config->_useBiasedLocking, UseBiasedLocking, \"UseBiasedLocking\");\n-  verify_flag(_config->_objectAlignment, ObjectAlignmentInBytes, \"ObjectAlignmentInBytes\");\n-  verify_flag(_config->_contendedPaddingWidth, ContendedPaddingWidth, \"ContendedPaddingWidth\");\n-  verify_flag(_config->_enableContended, EnableContended, \"EnableContended\");\n-  verify_flag(_config->_restrictContended, RestrictContended, \"RestrictContended\");\n-\n-  \/\/ Shifts are static values which initialized by 0 until java heap initialization.\n-  \/\/ AOT libs are loaded before heap initialized so shift values are not set.\n-  \/\/ It is okay since ObjectAlignmentInBytes flag which defines shifts value is set before AOT libs are loaded.\n-  \/\/ Set shifts value based on first AOT library config.\n-  if (UseCompressedOops && _valid) {\n-    if (!_narrow_oop_shift_initialized) {\n-      _narrow_oop_shift = _config->_narrowOopShift;\n-      if (UseCompressedClassPointers) { \/\/ It is set only if UseCompressedOops is set\n-        _narrow_klass_shift = _config->_narrowKlassShift;\n-      }\n-      _narrow_oop_shift_initialized = true;\n-    } else {\n-      verify_flag(_config->_narrowOopShift, _narrow_oop_shift, \"aot_config->_narrowOopShift\");\n-      if (UseCompressedClassPointers) { \/\/ It is set only if UseCompressedOops is set\n-        verify_flag(_config->_narrowKlassShift, _narrow_klass_shift, \"aot_config->_narrowKlassShift\");\n-      }\n-    }\n-  }\n-}\n-\n-AOTLib::~AOTLib() {\n-  os::free((void*) _name);\n-}\n-\n-AOTCodeHeap::~AOTCodeHeap() {\n-  FREE_C_HEAP_ARRAY(AOTClass, _classes);\n-  FREE_C_HEAP_ARRAY(CodeToAMethod, _code_to_aot);\n-}\n-\n-AOTLib::AOTLib(void* handle, const char* name, int dso_id) : _valid(true), _dl_handle(handle), _dso_id(dso_id) {\n-  _name = (const char*) os::strdup(name);\n-\n-  \/\/ Verify that VM runs with the same parameters as AOT tool.\n-  _config = (AOTConfiguration*) load_symbol(\"A.config\");\n-  _header = (AOTHeader*) load_symbol(\"A.header\");\n-\n-  verify_config();\n-\n-  if (!_valid && PrintAOT) {\n-      tty->print(\"%7d \", (int) tty->time_stamp().milliseconds());\n-      tty->print_cr(\"%4d     skipped %s  aot library\", _dso_id, _name);\n-  }\n-}\n-\n-AOTCodeHeap::AOTCodeHeap(AOTLib* lib) :\n-    CodeHeap(\"CodeHeap 'AOT'\", CodeBlobType::AOT), _lib(lib), _classes(NULL), _code_to_aot(NULL) {\n-  assert(_lib->is_valid(), \"invalid library\");\n-\n-  _lib_symbols_initialized = false;\n-  _aot_id = 0;\n-\n-  _class_count = _lib->header()->_class_count;\n-  _method_count = _lib->header()->_method_count;\n-\n-  \/\/ Collect metaspace info: names -> address in .got section\n-  _metaspace_names = (const char*) _lib->load_symbol(\"A.meta.names\");\n-  _method_metadata =     (address) _lib->load_symbol(\"A.meth.metadata\");\n-  _methods_offsets =     (address) _lib->load_symbol(\"A.meth.offsets\");\n-  _klasses_offsets =     (address) _lib->load_symbol(\"A.kls.offsets\");\n-  _dependencies    =     (address) _lib->load_symbol(\"A.kls.dependencies\");\n-  _code_space      =     (address) _lib->load_symbol(\"A.text\");\n-\n-  \/\/ First cell is number of elements.\n-  _klasses_got      = (Metadata**) _lib->load_symbol(\"A.kls.got\");\n-  _klasses_got_size = _lib->header()->_klasses_got_size;\n-\n-  _metadata_got      = (Metadata**) _lib->load_symbol(\"A.meta.got\");\n-  _metadata_got_size = _lib->header()->_metadata_got_size;\n-\n-  _oop_got      = (oop*) _lib->load_symbol(\"A.oop.got\");\n-  _oop_got_size = _lib->header()->_oop_got_size;\n-\n-  \/\/ Collect stubs info\n-  _stubs_offsets = (int*) _lib->load_symbol(\"A.stubs.offsets\");\n-\n-  \/\/ code segments table\n-  _code_segments = (address) _lib->load_symbol(\"A.code.segments\");\n-\n-  \/\/ method state\n-  _method_state = (jlong*) _lib->load_symbol(\"A.meth.state\");\n-\n-  \/\/ Create a table for mapping classes\n-  _classes = NEW_C_HEAP_ARRAY(AOTClass, _class_count, mtCode);\n-  memset(_classes, 0, _class_count * sizeof(AOTClass));\n-\n-  \/\/ Create table for searching AOTCompiledMethod based on pc.\n-  _code_to_aot = NEW_C_HEAP_ARRAY(CodeToAMethod, _method_count, mtCode);\n-  memset(_code_to_aot, 0, _method_count * sizeof(CodeToAMethod));\n-\n-  _memory.set_low_boundary((char *)_code_space);\n-  _memory.set_high_boundary((char *)_code_space);\n-  _memory.set_low((char *)_code_space);\n-  _memory.set_high((char *)_code_space);\n-\n-  _segmap.set_low_boundary((char *)_code_segments);\n-  _segmap.set_low((char *)_code_segments);\n-\n-  _log2_segment_size = exact_log2(_lib->config()->_codeSegmentSize);\n-\n-  \/\/ Register aot stubs\n-  register_stubs();\n-\n-  if (PrintAOT || (PrintCompilation && PrintAOT)) {\n-    tty->print(\"%7d \", (int) tty->time_stamp().milliseconds());\n-    tty->print_cr(\"%4d     loaded    %s  aot library\", _lib->id(), _lib->name());\n-  }\n-}\n-\n-void AOTCodeHeap::publish_aot(const methodHandle& mh, AOTMethodData* method_data, int code_id) {\n-  \/\/ The method may be explicitly excluded by the user.\n-  \/\/ Or Interpreter uses an intrinsic for this method.\n-  \/\/ Or method has breakpoints.\n-  if (CompilerOracle::should_exclude(mh) ||\n-      !AbstractInterpreter::can_be_compiled(mh) ||\n-      (mh->number_of_breakpoints() > 0)) {\n-    return;\n-  }\n-  \/\/ Make sure no break points were set in the method in case of a safepoint\n-  \/\/ in the following code until aot code is registered.\n-  NoSafepointVerifier nsv;\n-\n-  address code = method_data->_code;\n-  const char* name = method_data->_name;\n-  aot_metadata* meta = method_data->_meta;\n-\n-  if (meta->scopes_pcs_begin() == meta->scopes_pcs_end()) {\n-    \/\/ Switch off NoSafepointVerifier because log_info() may cause safepoint\n-    \/\/ and it is fine because aot code will not be registered here.\n-    PauseNoSafepointVerifier pnsv(&nsv);\n-\n-    \/\/ When the AOT compiler compiles something big we fail to generate metadata\n-    \/\/ in CodeInstaller::gather_metadata. In that case the scopes_pcs_begin == scopes_pcs_end.\n-    \/\/ In all successful cases we always have 2 entries of scope pcs.\n-    log_info(aot, class, resolve)(\"Failed to load %s (no metadata available)\", mh->name_and_sig_as_C_string());\n-    _code_to_aot[code_id]._state = invalid;\n-    return;\n-  }\n-\n-  jlong* state_adr = &_method_state[code_id];\n-  address metadata_table = method_data->_metadata_table;\n-  int metadata_size = method_data->_metadata_size;\n-  assert(code_id < _method_count, \"sanity\");\n-  _aot_id++;\n-\n-#ifdef ASSERT\n-  if (_aot_id > CIStop || _aot_id < CIStart) {\n-    \/\/ Skip compilation\n-    return;\n-  }\n-#endif\n-  \/\/ Check one more time.\n-  if (_code_to_aot[code_id]._state == invalid) {\n-    return;\n-  }\n-  AOTCompiledMethod *aot = new AOTCompiledMethod(code, mh(), meta, metadata_table, metadata_size, state_adr, this, name, code_id, _aot_id);\n-  assert(_code_to_aot[code_id]._aot == NULL, \"should be not initialized\");\n-  _code_to_aot[code_id]._aot = aot; \/\/ Should set this first\n-  if (Atomic::cmpxchg(&_code_to_aot[code_id]._state, not_set, in_use) != not_set) {\n-    _code_to_aot[code_id]._aot = NULL; \/\/ Clean\n-  } else { \/\/ success\n-    \/\/ Publish method\n-#if COMPILER1_OR_COMPILER2\n-    mh->set_aot_code(aot);\n-#endif\n-    {\n-      MutexLocker pl(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n-      Method::set_code(mh, aot);\n-    }\n-    if (PrintAOT || (PrintCompilation && PrintAOT)) {\n-      PauseNoSafepointVerifier pnsv(&nsv); \/\/ aot code is registered already\n-      aot->print_on(tty, NULL);\n-    }\n-    \/\/ Publish oop only after we are visible to CompiledMethodIterator\n-    aot->set_oop(mh()->method_holder()->klass_holder());\n-  }\n-}\n-\n-void AOTCodeHeap::link_klass(const Klass* klass) {\n-  ResourceMark rm;\n-  assert(klass != NULL, \"Should be given a klass\");\n-  AOTKlassData* klass_data = (AOTKlassData*) os::dll_lookup(_lib->dl_handle(), klass->signature_name());\n-  if (klass_data != NULL) {\n-    \/\/ Set both GOT cells, resolved and initialized klass pointers.\n-    \/\/ _got_index points to second cell - resolved klass pointer.\n-    _klasses_got[klass_data->_got_index-1] = (Metadata*)klass; \/\/ Initialized\n-    _klasses_got[klass_data->_got_index  ] = (Metadata*)klass; \/\/ Resolved\n-    if (PrintAOT) {\n-      tty->print_cr(\"[Found  %s  in  %s]\", klass->internal_name(), _lib->name());\n-    }\n-  }\n-}\n-\n-void AOTCodeHeap::link_known_klasses() {\n-  for (int i = T_BOOLEAN; i <= T_CONFLICT; i++) {\n-    BasicType t = (BasicType)i;\n-    if (is_java_primitive(t)) {\n-      const Klass* arr_klass = Universe::typeArrayKlassObj(t);\n-      link_klass(arr_klass);\n-    }\n-  }\n-  link_klass(vmClasses::Reference_klass());\n-}\n-\n-void AOTCodeHeap::register_stubs() {\n-  int stubs_count = _stubs_offsets[0]; \/\/ contains number\n-  _stubs_offsets++;\n-  AOTMethodOffsets* stub_offsets = (AOTMethodOffsets*)_stubs_offsets;\n-  for (int i = 0; i < stubs_count; ++i) {\n-    const char* stub_name = _metaspace_names + stub_offsets[i]._name_offset;\n-    address entry = _code_space  + stub_offsets[i]._code_offset;\n-    aot_metadata* meta = (aot_metadata *) (_method_metadata + stub_offsets[i]._meta_offset);\n-    address metadata_table = (address)_metadata_got + stub_offsets[i]._metadata_got_offset;\n-    int metadata_size = stub_offsets[i]._metadata_got_size;\n-    int code_id = stub_offsets[i]._code_id;\n-    assert(code_id < _method_count, \"sanity\");\n-    jlong* state_adr = &_method_state[code_id];\n-    int len = Bytes::get_Java_u2((address)stub_name);\n-    stub_name += 2;\n-    char* full_name = NEW_C_HEAP_ARRAY(char, len+5, mtCode);\n-    memcpy(full_name, \"AOT \", 4);\n-    memcpy(full_name+4, stub_name, len);\n-    full_name[len+4] = 0;\n-    guarantee(_code_to_aot[code_id]._state != invalid, \"stub %s can't be invalidated\", full_name);\n-    AOTCompiledMethod* aot = new AOTCompiledMethod(entry, NULL, meta, metadata_table, metadata_size, state_adr, this, full_name, code_id, i);\n-    assert(_code_to_aot[code_id]._aot  == NULL, \"should be not initialized\");\n-    _code_to_aot[code_id]._aot  = aot;\n-    if (Atomic::cmpxchg(&_code_to_aot[code_id]._state, not_set, in_use) != not_set) {\n-      fatal(\"stab '%s' code state is %d\", full_name, _code_to_aot[code_id]._state);\n-    }\n-    \/\/ Adjust code buffer boundaries only for stubs because they are last in the buffer.\n-    adjust_boundaries(aot);\n-    if (PrintAOT && Verbose) {\n-      aot->print_on(tty, NULL);\n-    }\n-  }\n-}\n-\n-#define SET_AOT_GLOBAL_SYMBOL_VALUE(AOTSYMNAME, AOTSYMTYPE, VMSYMVAL) \\\n-  {                                                                   \\\n-    AOTSYMTYPE * adr = (AOTSYMTYPE *) os::dll_lookup(_lib->dl_handle(), AOTSYMNAME);  \\\n-    \/* Check for a lookup error *\/                                    \\\n-    guarantee(adr != NULL, \"AOT Symbol not found %s\", AOTSYMNAME);    \\\n-    *adr = (AOTSYMTYPE) VMSYMVAL;                                     \\\n-  }\n-\n-void AOTCodeHeap::link_graal_runtime_symbols()  {\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_monitorenter\", address, JVMCIRuntime::monitorenter);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_monitorexit\", address, JVMCIRuntime::monitorexit);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_log_object\", address, JVMCIRuntime::log_object);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_log_printf\", address, JVMCIRuntime::log_printf);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_log_primitive\", address, JVMCIRuntime::log_primitive);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_new_instance\", address, JVMCIRuntime::new_instance);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_new_array\", address, JVMCIRuntime::new_array);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_new_multi_array\", address, JVMCIRuntime::new_multi_array);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_dynamic_new_instance\", address, JVMCIRuntime::dynamic_new_instance);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_dynamic_new_array\", address, JVMCIRuntime::dynamic_new_array);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_new_instance_or_null\", address, JVMCIRuntime::new_instance_or_null);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_new_array_or_null\", address, JVMCIRuntime::new_array_or_null);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_new_multi_array_or_null\", address, JVMCIRuntime::new_multi_array_or_null);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_dynamic_new_instance_or_null\", address, JVMCIRuntime::dynamic_new_instance_or_null);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_dynamic_new_array_or_null\", address, JVMCIRuntime::dynamic_new_array_or_null);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_validate_object\", address, JVMCIRuntime::validate_object);\n-#if INCLUDE_G1GC\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_write_barrier_pre\", address, JVMCIRuntime::write_barrier_pre);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_write_barrier_post\", address, JVMCIRuntime::write_barrier_post);\n-#endif\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_identity_hash_code\", address, JVMCIRuntime::identity_hash_code);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_exception_handler_for_pc\", address, JVMCIRuntime::exception_handler_for_pc);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_test_deoptimize_call_int\", address, JVMCIRuntime::test_deoptimize_call_int);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_throw_and_post_jvmti_exception\", address, JVMCIRuntime::throw_and_post_jvmti_exception);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_throw_klass_external_name_exception\", address, JVMCIRuntime::throw_klass_external_name_exception);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_throw_class_cast_exception\", address, JVMCIRuntime::throw_class_cast_exception);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_vm_message\", address, JVMCIRuntime::vm_message);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_jvmci_runtime_vm_error\", address, JVMCIRuntime::vm_error);\n-}\n-\n-void AOTCodeHeap::link_shared_runtime_symbols() {\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_resolve_static_entry\", address, SharedRuntime::get_resolve_static_call_stub());\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_resolve_virtual_entry\", address, SharedRuntime::get_resolve_virtual_call_stub());\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_resolve_opt_virtual_entry\", address, SharedRuntime::get_resolve_opt_virtual_call_stub());\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_deopt_blob_unpack\", address, SharedRuntime::deopt_blob()->unpack());\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_deopt_blob_unpack_with_exception_in_tls\", address, SharedRuntime::deopt_blob()->unpack_with_exception_in_tls());\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_deopt_blob_uncommon_trap\", address, SharedRuntime::deopt_blob()->uncommon_trap());\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_ic_miss_stub\", address, SharedRuntime::get_ic_miss_stub());\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_handle_wrong_method_stub\", address, SharedRuntime::get_handle_wrong_method_stub());\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_exception_handler_for_return_address\", address, SharedRuntime::exception_handler_for_return_address);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_register_finalizer\", address, SharedRuntime::register_finalizer);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_object_notify\", address, JVMCIRuntime::object_notify);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_object_notifyAll\", address, JVMCIRuntime::object_notifyAll);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_OSR_migration_end\", address, SharedRuntime::OSR_migration_end);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_enable_stack_reserved_zone\", address, SharedRuntime::enable_stack_reserved_zone);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_resolve_dynamic_invoke\", address, CompilerRuntime::resolve_dynamic_invoke);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_resolve_string_by_symbol\", address, CompilerRuntime::resolve_string_by_symbol);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_resolve_klass_by_symbol\", address, CompilerRuntime::resolve_klass_by_symbol);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_resolve_method_by_symbol_and_load_counters\", address, CompilerRuntime::resolve_method_by_symbol_and_load_counters);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_initialize_klass_by_symbol\", address, CompilerRuntime::initialize_klass_by_symbol);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_invocation_event\", address, CompilerRuntime::invocation_event);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_backedge_event\", address, CompilerRuntime::backedge_event);\n-\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_shared_runtime_dpow\", address, SharedRuntime::dpow);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_shared_runtime_dexp\", address, SharedRuntime::dexp);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_shared_runtime_dcos\", address, SharedRuntime::dcos);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_shared_runtime_dsin\", address, SharedRuntime::dsin);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_shared_runtime_dtan\", address, SharedRuntime::dtan);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_shared_runtime_dlog\", address, SharedRuntime::dlog);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_shared_runtime_dlog10\", address, SharedRuntime::dlog10);\n-}\n-\n-void AOTCodeHeap::link_stub_routines_symbols() {\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_jbyte_arraycopy\", address, StubRoutines::_jbyte_arraycopy);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_jshort_arraycopy\", address, StubRoutines::_jshort_arraycopy);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_jint_arraycopy\", address, StubRoutines::_jint_arraycopy);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_jlong_arraycopy\", address, StubRoutines::_jlong_arraycopy);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_oop_arraycopy\", address, StubRoutines::_oop_arraycopy);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_oop_arraycopy_uninit\", address, StubRoutines::_oop_arraycopy_uninit);\n-\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_jbyte_disjoint_arraycopy\", address, StubRoutines::_jbyte_disjoint_arraycopy);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_jshort_disjoint_arraycopy\", address, StubRoutines::_jshort_disjoint_arraycopy);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_jint_disjoint_arraycopy\", address, StubRoutines::_jint_disjoint_arraycopy);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_jlong_disjoint_arraycopy\", address, StubRoutines::_jlong_disjoint_arraycopy);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_oop_disjoint_arraycopy\", address, StubRoutines::_oop_disjoint_arraycopy);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_oop_disjoint_arraycopy_uninit\", address, StubRoutines::_oop_disjoint_arraycopy_uninit);\n-\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_arrayof_jbyte_arraycopy\", address, StubRoutines::_arrayof_jbyte_arraycopy);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_arrayof_jshort_arraycopy\", address, StubRoutines::_arrayof_jshort_arraycopy);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_arrayof_jint_arraycopy\", address, StubRoutines::_arrayof_jint_arraycopy);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_arrayof_jlong_arraycopy\", address, StubRoutines::_arrayof_jlong_arraycopy);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_arrayof_oop_arraycopy\", address, StubRoutines::_arrayof_oop_arraycopy);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_arrayof_oop_arraycopy_uninit\", address, StubRoutines::_arrayof_oop_arraycopy_uninit);\n-\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_arrayof_jbyte_disjoint_arraycopy\", address, StubRoutines::_arrayof_jbyte_disjoint_arraycopy);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_arrayof_jshort_disjoint_arraycopy\", address, StubRoutines::_arrayof_jshort_disjoint_arraycopy);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_arrayof_jint_disjoint_arraycopy\", address, StubRoutines::_arrayof_jint_disjoint_arraycopy);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_arrayof_jlong_disjoint_arraycopy\", address, StubRoutines::_arrayof_jlong_disjoint_arraycopy);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_arrayof_oop_disjoint_arraycopy\", address, StubRoutines::_arrayof_oop_disjoint_arraycopy);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_arrayof_oop_disjoint_arraycopy_uninit\", address, StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit);\n-\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_unsafe_arraycopy\", address, StubRoutines::_unsafe_arraycopy);\n-\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_checkcast_arraycopy\", address, StubRoutines::_checkcast_arraycopy);\n-\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_generic_arraycopy\", address, StubRoutines::_generic_arraycopy);\n-\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_aescrypt_encryptBlock\", address, StubRoutines::_aescrypt_encryptBlock);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_aescrypt_decryptBlock\", address, StubRoutines::_aescrypt_decryptBlock);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_cipherBlockChaining_encryptAESCrypt\", address, StubRoutines::_cipherBlockChaining_encryptAESCrypt);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_cipherBlockChaining_decryptAESCrypt\", address, StubRoutines::_cipherBlockChaining_decryptAESCrypt);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_electronicCodeBook_encryptAESCrypt\", address, StubRoutines::_electronicCodeBook_encryptAESCrypt);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_electronicCodeBook_decryptAESCrypt\", address, StubRoutines::_electronicCodeBook_decryptAESCrypt);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_update_bytes_crc32\", address, StubRoutines::_updateBytesCRC32);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_crc_table_adr\", address, StubRoutines::_crc_table_adr);\n-\n-\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_sha1_implCompress\", address, StubRoutines::_sha1_implCompress);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_sha1_implCompressMB\", address, StubRoutines::_sha1_implCompressMB);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_sha256_implCompress\", address, StubRoutines::_sha256_implCompress);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_sha256_implCompressMB\", address, StubRoutines::_sha256_implCompressMB);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_sha512_implCompress\", address, StubRoutines::_sha512_implCompress);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_sha512_implCompressMB\", address, StubRoutines::_sha512_implCompressMB);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_multiplyToLen\", address, StubRoutines::_multiplyToLen);\n-\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_counterMode_AESCrypt\", address, StubRoutines::_counterMode_AESCrypt);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_ghash_processBlocks\", address, StubRoutines::_ghash_processBlocks);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_base64_encodeBlock\", address, StubRoutines::_base64_encodeBlock);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_crc32c_table_addr\", address, StubRoutines::_crc32c_table_addr);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_updateBytesCRC32C\", address, StubRoutines::_updateBytesCRC32C);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_updateBytesAdler32\", address, StubRoutines::_updateBytesAdler32);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_squareToLen\", address, StubRoutines::_squareToLen);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_mulAdd\", address, StubRoutines::_mulAdd);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_montgomeryMultiply\",  address, StubRoutines::_montgomeryMultiply);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_montgomerySquare\", address, StubRoutines::_montgomerySquare);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_vectorizedMismatch\", address, StubRoutines::_vectorizedMismatch);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_bigIntegerRightShiftWorker\", address, StubRoutines::_bigIntegerRightShiftWorker);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_bigIntegerLeftShiftWorker\", address, StubRoutines::_bigIntegerLeftShiftWorker);\n-\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_stub_routines_throw_delayed_StackOverflowError_entry\", address, StubRoutines::_throw_delayed_StackOverflowError_entry);\n-\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_verify_oops\", intptr_t, VerifyOops);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_verify_oop_count_address\", jint *, &StubRoutines::_verify_oop_count);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_verify_oop_bits\", intptr_t, Universe::verify_oop_bits());\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_verify_oop_mask\", intptr_t, Universe::verify_oop_mask());\n-}\n-\n-void AOTCodeHeap::link_os_symbols() {\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_os_javaTimeMillis\", address, os::javaTimeMillis);\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_os_javaTimeNanos\", address, os::javaTimeNanos);\n-}\n-\n-\/*\n- * Link any global symbols in precompiled DSO with dlopen() _dl_handle\n- * dso_handle.\n- *\/\n-\n-void AOTCodeHeap::link_global_lib_symbols() {\n-  if (!_lib_symbols_initialized) {\n-    _lib_symbols_initialized = true;\n-\n-    CollectedHeap* heap = Universe::heap();\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_card_table_address\", address, (BarrierSet::barrier_set()->is_a(BarrierSet::CardTableBarrierSet) ? ci_card_table_address() : NULL));\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_heap_top_address\", address, (heap->supports_inline_contig_alloc() ? heap->top_addr() : NULL));\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_heap_end_address\", address, (heap->supports_inline_contig_alloc() ? heap->end_addr() : NULL));\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_narrow_klass_base_address\", address, CompressedKlassPointers::base());\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_narrow_oop_base_address\", address, CompressedOops::base());\n-#if INCLUDE_G1GC\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_log_of_heap_region_grain_bytes\", int, HeapRegion::LogOfHRGrainBytes);\n-#endif\n-    SET_AOT_GLOBAL_SYMBOL_VALUE(\"_aot_inline_contiguous_allocation_supported\", bool, heap->supports_inline_contig_alloc());\n-    link_shared_runtime_symbols();\n-    link_stub_routines_symbols();\n-    link_os_symbols();\n-    link_graal_runtime_symbols();\n-    link_known_klasses();\n-  }\n-}\n-\n-#ifndef PRODUCT\n-int AOTCodeHeap::klasses_seen = 0;\n-int AOTCodeHeap::aot_klasses_found = 0;\n-int AOTCodeHeap::aot_klasses_fp_miss = 0;\n-int AOTCodeHeap::aot_klasses_cl_miss = 0;\n-int AOTCodeHeap::aot_methods_found = 0;\n-\n-void AOTCodeHeap::print_statistics() {\n-  tty->print_cr(\"Classes seen: %d  AOT classes found: %d  AOT methods found: %d\", klasses_seen, aot_klasses_found, aot_methods_found);\n-  tty->print_cr(\"AOT fingerprint mismatches: %d  AOT class loader mismatches: %d\", aot_klasses_fp_miss, aot_klasses_cl_miss);\n-}\n-#endif\n-\n-Method* AOTCodeHeap::find_method(Klass* klass, Thread* thread, const char* method_name) {\n-  int method_name_len = Bytes::get_Java_u2((address)method_name);\n-  method_name += 2;\n-  const char* signature_name = method_name + method_name_len;\n-  int signature_name_len = Bytes::get_Java_u2((address)signature_name);\n-  signature_name += 2;\n-  \/\/ The class should have been loaded so the method and signature should already be\n-  \/\/ in the symbol table.  If they're not there, the method doesn't exist.\n-  TempNewSymbol name = SymbolTable::probe(method_name, method_name_len);\n-  TempNewSymbol signature = SymbolTable::probe(signature_name, signature_name_len);\n-\n-  Method* m;\n-  if (name == NULL || signature == NULL) {\n-    m = NULL;\n-  } else if (name == vmSymbols::object_initializer_name() ||\n-             name == vmSymbols::class_initializer_name()) {\n-    \/\/ Never search superclasses for constructors\n-    if (klass->is_instance_klass()) {\n-      m = InstanceKlass::cast(klass)->find_method(name, signature);\n-    } else {\n-      m = NULL;\n-    }\n-  } else {\n-    m = klass->lookup_method(name, signature);\n-    if (m == NULL && klass->is_instance_klass()) {\n-      m = InstanceKlass::cast(klass)->lookup_method_in_ordered_interfaces(name, signature);\n-    }\n-  }\n-  if (m == NULL) {\n-    \/\/ Fatal error because we assume classes and methods should not be changed since aot compilation.\n-    const char* klass_name = klass->external_name();\n-    int klass_len = (int)strlen(klass_name);\n-    char* meta_name = NEW_RESOURCE_ARRAY(char, klass_len + 1 + method_name_len + signature_name_len + 1);\n-    memcpy(meta_name, klass_name, klass_len);\n-    meta_name[klass_len] = '.';\n-    memcpy(&meta_name[klass_len + 1], method_name, method_name_len);\n-    memcpy(&meta_name[klass_len + 1 + method_name_len], signature_name, signature_name_len);\n-    meta_name[klass_len + 1 + method_name_len + signature_name_len] = '\\0';\n-    Handle exception = Exceptions::new_exception(thread, vmSymbols::java_lang_NoSuchMethodError(), meta_name);\n-    java_lang_Throwable::print(exception(), tty);\n-    tty->cr();\n-    java_lang_Throwable::print_stack_trace(exception, tty);\n-    tty->cr();\n-    fatal(\"Failed to find method '%s'\", meta_name);\n-  }\n-  NOT_PRODUCT( aot_methods_found++; )\n-  return m;\n-}\n-\n-AOTKlassData* AOTCodeHeap::find_klass(const char *name) {\n-  return (AOTKlassData*) os::dll_lookup(_lib->dl_handle(), name);\n-}\n-\n-AOTKlassData* AOTCodeHeap::find_klass(InstanceKlass* ik) {\n-  ResourceMark rm;\n-  AOTKlassData* klass_data = find_klass(ik->signature_name());\n-  return klass_data;\n-}\n-\n-bool AOTCodeHeap::is_dependent_method(Klass* dependee, AOTCompiledMethod* aot) {\n-  InstanceKlass *dependee_ik = InstanceKlass::cast(dependee);\n-  AOTKlassData* klass_data = find_klass(dependee_ik);\n-  if (klass_data == NULL) {\n-    return false; \/\/ no AOT records for this class - no dependencies\n-  }\n-  if (!dependee_ik->has_passed_fingerprint_check()) {\n-    return false; \/\/ different class\n-  }\n-\n-  int methods_offset = klass_data->_dependent_methods_offset;\n-  if (methods_offset >= 0) {\n-    address methods_cnt_adr = _dependencies + methods_offset;\n-    int methods_cnt = *(int*)methods_cnt_adr;\n-    int* indexes = (int*)(methods_cnt_adr + 4);\n-    for (int i = 0; i < methods_cnt; ++i) {\n-      int code_id = indexes[i];\n-      if (_code_to_aot[code_id]._aot == aot) {\n-        return true; \/\/ found dependent method\n-      }\n-    }\n-  }\n-  return false;\n-}\n-\n-void AOTCodeHeap::mark_evol_dependent_methods(InstanceKlass* dependee) {\n-  AOTKlassData* klass_data = find_klass(dependee);\n-  if (klass_data == NULL) {\n-    return; \/\/ no AOT records for this class - no dependencies\n-  }\n-  if (!dependee->has_passed_fingerprint_check()) {\n-    return; \/\/ different class\n-  }\n-\n-  int methods_offset = klass_data->_dependent_methods_offset;\n-  if (methods_offset >= 0) {\n-    address methods_cnt_adr = _dependencies + methods_offset;\n-    int methods_cnt = *(int*)methods_cnt_adr;\n-    int* indexes = (int*)(methods_cnt_adr + 4);\n-    for (int i = 0; i < methods_cnt; ++i) {\n-      int code_id = indexes[i];\n-      AOTCompiledMethod* aot = _code_to_aot[code_id]._aot;\n-      if (aot != NULL) {\n-        aot->mark_for_deoptimization(false);\n-      }\n-    }\n-  }\n-}\n-\n-void AOTCodeHeap::sweep_dependent_methods(int* indexes, int methods_cnt) {\n-  int marked = 0;\n-  for (int i = 0; i < methods_cnt; ++i) {\n-    int code_id = indexes[i];\n-    \/\/ Invalidate aot code.\n-    if (Atomic::cmpxchg(&_code_to_aot[code_id]._state, not_set, invalid) != not_set) {\n-      if (_code_to_aot[code_id]._state == in_use) {\n-        AOTCompiledMethod* aot = _code_to_aot[code_id]._aot;\n-        assert(aot != NULL, \"aot should be set\");\n-        if (!aot->is_runtime_stub()) { \/\/ Something is wrong - should not invalidate stubs.\n-          aot->mark_for_deoptimization(false);\n-          marked++;\n-        }\n-      }\n-    }\n-  }\n-  if (marked > 0) {\n-    Deoptimization::deoptimize_all_marked();\n-  }\n-}\n-\n-void AOTCodeHeap::sweep_dependent_methods(AOTKlassData* klass_data) {\n-  \/\/ Make dependent methods non_entrant forever.\n-  int methods_offset = klass_data->_dependent_methods_offset;\n-  if (methods_offset >= 0) {\n-    address methods_cnt_adr = _dependencies + methods_offset;\n-    int methods_cnt = *(int*)methods_cnt_adr;\n-    int* indexes = (int*)(methods_cnt_adr + 4);\n-    sweep_dependent_methods(indexes, methods_cnt);\n-  }\n-}\n-\n-void AOTCodeHeap::sweep_dependent_methods(InstanceKlass* ik) {\n-  AOTKlassData* klass_data = find_klass(ik);\n-  vmassert(klass_data != NULL, \"dependency data missing\");\n-  sweep_dependent_methods(klass_data);\n-}\n-\n-void AOTCodeHeap::sweep_method(AOTCompiledMethod *aot) {\n-  int indexes[] = {aot->method_index()};\n-  sweep_dependent_methods(indexes, 1);\n-  vmassert(aot->method()->code() != aot COMPILER1_OR_COMPILER2_PRESENT( && aot->method()->aot_code() == NULL), \"method still active\");\n-}\n-\n-\n-bool AOTCodeHeap::load_klass_data(InstanceKlass* ik, Thread* thread) {\n-  ResourceMark rm;\n-\n-  NOT_PRODUCT( klasses_seen++; )\n-\n-  \/\/ AOT does not support custom class loaders.\n-  ClassLoaderData* cld = ik->class_loader_data();\n-  if (!cld->is_builtin_class_loader_data()) {\n-    log_trace(aot, class, load)(\"skip class  %s  for custom classloader %s (%p) tid=\" INTPTR_FORMAT,\n-                                ik->internal_name(), cld->loader_name(), cld, p2i(thread));\n-    return false;\n-  }\n-\n-  AOTKlassData* klass_data = find_klass(ik);\n-  if (klass_data == NULL) {\n-    return false;\n-  }\n-\n-  if (!ik->has_passed_fingerprint_check()) {\n-    NOT_PRODUCT( aot_klasses_fp_miss++; )\n-    log_trace(aot, class, fingerprint)(\"class  %s%s  has bad fingerprint in  %s tid=\" INTPTR_FORMAT,\n-                                       ik->internal_name(), ik->is_shared() ? \" (shared)\" : \"\",\n-                                       _lib->name(), p2i(thread));\n-    sweep_dependent_methods(klass_data);\n-    return false;\n-  }\n-\n-  if (ik->has_been_redefined()) {\n-    log_trace(aot, class, load)(\"class  %s%s in %s  has been redefined tid=\" INTPTR_FORMAT,\n-                                ik->internal_name(), ik->is_shared() ? \" (shared)\" : \"\",\n-                                _lib->name(), p2i(thread));\n-    sweep_dependent_methods(klass_data);\n-    return false;\n-  }\n-\n-  assert(klass_data->_class_id < _class_count, \"invalid class id\");\n-  AOTClass* aot_class = &_classes[klass_data->_class_id];\n-  ClassLoaderData* aot_cld = aot_class->_classloader;\n-  if (aot_cld != NULL && aot_cld != cld) {\n-    log_trace(aot, class, load)(\"class  %s  in  %s already loaded for classloader %s (%p) vs %s (%p) tid=\" INTPTR_FORMAT,\n-                                ik->internal_name(), _lib->name(), aot_cld->loader_name(), aot_cld, cld->loader_name(), cld, p2i(thread));\n-    NOT_PRODUCT( aot_klasses_cl_miss++; )\n-    return false;\n-  }\n-\n-  if (_lib->config()->_omitAssertions && JavaAssertions::enabled(ik->name()->as_C_string(), ik->class_loader() == NULL)) {\n-    log_trace(aot, class, load)(\"class  %s  in  %s does not have java assertions in compiled code, but assertions are enabled for this execution.\", ik->internal_name(), _lib->name());\n-    sweep_dependent_methods(klass_data);\n-    return false;\n-  }\n-\n-  NOT_PRODUCT( aot_klasses_found++; )\n-\n-  log_trace(aot, class, load)(\"found  %s  in  %s for classloader %s (%p) tid=\" INTPTR_FORMAT, ik->internal_name(), _lib->name(), cld->loader_name(), cld, p2i(thread));\n-\n-  aot_class->_classloader = cld;\n-  \/\/ Set klass's Resolve (second) got cell.\n-  _klasses_got[klass_data->_got_index] = ik;\n-  if (ik->is_initialized()) {\n-    _klasses_got[klass_data->_got_index - 1] = ik;\n-  }\n-\n-  \/\/ Initialize global symbols of the DSO to the corresponding VM symbol values.\n-  link_global_lib_symbols();\n-\n-  int methods_offset = klass_data->_compiled_methods_offset;\n-  if (methods_offset >= 0) {\n-    address methods_cnt_adr = _methods_offsets + methods_offset;\n-    int methods_cnt = *(int*)methods_cnt_adr;\n-    \/\/ Collect data about compiled methods\n-    AOTMethodData* methods_data = NEW_RESOURCE_ARRAY(AOTMethodData, methods_cnt);\n-    AOTMethodOffsets* methods_offsets = (AOTMethodOffsets*)(methods_cnt_adr + 4);\n-    for (int i = 0; i < methods_cnt; ++i) {\n-      AOTMethodOffsets* method_offsets = &methods_offsets[i];\n-      int code_id = method_offsets->_code_id;\n-      if (_code_to_aot[code_id]._state == invalid) {\n-        continue; \/\/ skip AOT methods slots which have been invalidated\n-      }\n-      AOTMethodData* method_data = &methods_data[i];\n-      const char* aot_name = _metaspace_names + method_offsets->_name_offset;\n-      method_data->_name = aot_name;\n-      method_data->_code = _code_space  + method_offsets->_code_offset;\n-      method_data->_meta = (aot_metadata*)(_method_metadata + method_offsets->_meta_offset);\n-      method_data->_metadata_table = (address)_metadata_got + method_offsets->_metadata_got_offset;\n-      method_data->_metadata_size  = method_offsets->_metadata_got_size;\n-      \/\/ aot_name format: \"<u2_size>Ljava\/lang\/ThreadGroup;<u2_size>addUnstarted<u2_size>()V\"\n-      int klass_len = Bytes::get_Java_u2((address)aot_name);\n-      const char* method_name = aot_name + 2 + klass_len;\n-      Method* m = AOTCodeHeap::find_method(ik, thread, method_name);\n-      methodHandle mh(thread, m);\n-      if (mh->code() != NULL) { \/\/ Does it have already compiled code?\n-        continue; \/\/ Don't overwrite\n-      }\n-      publish_aot(mh, method_data, code_id);\n-    }\n-  }\n-  return true;\n-}\n-\n-AOTCompiledMethod* AOTCodeHeap::next_in_use_at(int start) const {\n-  for (int index = start; index < _method_count; index++) {\n-    if (_code_to_aot[index]._state != in_use) {\n-      continue; \/\/ Skip uninitialized entries.\n-    }\n-    AOTCompiledMethod* aot = _code_to_aot[index]._aot;\n-    return aot;\n-  }\n-  return NULL;\n-}\n-\n-void* AOTCodeHeap::first() const {\n-  return next_in_use_at(0);\n-}\n-\n-void* AOTCodeHeap::next(void* p) const {\n-  AOTCompiledMethod *aot = (AOTCompiledMethod *)p;\n-  int next_index = aot->method_index() + 1;\n-  assert(next_index <= _method_count, \"\");\n-  if (next_index == _method_count) {\n-    return NULL;\n-  }\n-  return next_in_use_at(next_index);\n-}\n-\n-void* AOTCodeHeap::find_start(void* p) const {\n-  if (!contains(p)) {\n-    return NULL;\n-  }\n-  size_t offset = pointer_delta(p, low_boundary(), 1);\n-  \/\/ Use segments table\n-  size_t seg_idx = offset \/ _lib->config()->_codeSegmentSize;\n-  if ((int)(_code_segments[seg_idx]) == 0xff) {\n-    return NULL;\n-  }\n-  while (_code_segments[seg_idx] > 0) {\n-    seg_idx -= (int)_code_segments[seg_idx];\n-  }\n-  int code_offset = (int)seg_idx * _lib->config()->_codeSegmentSize;\n-  int aot_index = *(int*)(_code_space + code_offset);\n-  AOTCompiledMethod* aot = _code_to_aot[aot_index]._aot;\n-  assert(aot != NULL, \"should find registered aot method\");\n-  return aot;\n-}\n-\n-AOTCompiledMethod* AOTCodeHeap::find_aot(address p) const {\n-  assert(contains(p), \"should be here\");\n-  return (AOTCompiledMethod *)find_start(p);\n-}\n-\n-CodeBlob* AOTCodeHeap::find_blob_unsafe(void* start) const {\n-  return (CodeBlob*)AOTCodeHeap::find_start(start);\n-}\n-\n-void AOTCodeHeap::oops_do(OopClosure* f) {\n-  for (int i = 0; i < _oop_got_size; i++) {\n-    oop* p = &_oop_got[i];\n-    if (*p == NULL)  continue;  \/\/ skip non-oops\n-    f->do_oop(p);\n-  }\n-  for (int index = 0; index < _method_count; index++) {\n-    if (_code_to_aot[index]._state != in_use) {\n-      continue; \/\/ Skip uninitialized entries.\n-    }\n-    AOTCompiledMethod* aot = _code_to_aot[index]._aot;\n-    aot->do_oops(f);\n-  }\n-}\n-\n-\/\/ Scan only klasses_got cells which should have only Klass*,\n-\/\/ metadata_got cells are scanned only for alive AOT methods\n-\/\/ by AOTCompiledMethod::metadata_do().\n-void AOTCodeHeap::got_metadata_do(MetadataClosure* f) {\n-  for (int i = 1; i < _klasses_got_size; i++) {\n-    Metadata** p = &_klasses_got[i];\n-    Metadata* md = *p;\n-    if (md == NULL)  continue;  \/\/ skip non-oops\n-    if (Metaspace::contains(md)) {\n-      f->do_metadata(md);\n-    } else {\n-      intptr_t meta = (intptr_t)md;\n-      fatal(\"Invalid value in _klasses_got[%d] = \" INTPTR_FORMAT, i, meta);\n-    }\n-  }\n-}\n-\n-void AOTCodeHeap::cleanup_inline_caches() {\n-  for (int index = 0; index < _method_count; index++) {\n-    if (_code_to_aot[index]._state != in_use) {\n-      continue; \/\/ Skip uninitialized entries.\n-    }\n-    AOTCompiledMethod* aot = _code_to_aot[index]._aot;\n-    aot->cleanup_inline_caches(false);\n-  }\n-}\n-\n-#ifdef ASSERT\n-int AOTCodeHeap::verify_icholder_relocations() {\n-  int count = 0;\n-  for (int index = 0; index < _method_count; index++) {\n-    if (_code_to_aot[index]._state != in_use) {\n-      continue; \/\/ Skip uninitialized entries.\n-    }\n-    AOTCompiledMethod* aot = _code_to_aot[index]._aot;\n-    count += aot->verify_icholder_relocations();\n-  }\n-  return count;\n-}\n-#endif\n-\n-void AOTCodeHeap::metadata_do(MetadataClosure* f) {\n-  for (int index = 0; index < _method_count; index++) {\n-    if (_code_to_aot[index]._state != in_use) {\n-      continue; \/\/ Skip uninitialized entries.\n-    }\n-    AOTCompiledMethod* aot = _code_to_aot[index]._aot;\n-    if (aot->_is_alive()) {\n-      aot->metadata_do(f);\n-    }\n-  }\n-  \/\/ Scan klasses_got cells.\n-  got_metadata_do(f);\n-}\n-\n-bool AOTCodeHeap::reconcile_dynamic_klass(AOTCompiledMethod *caller, InstanceKlass* holder, int index, Klass *dyno_klass, const char *descriptor1, const char *descriptor2) {\n-  const char * const descriptors[2] = {descriptor1, descriptor2};\n-  JavaThread *thread = JavaThread::current();\n-  ResourceMark rm(thread);\n-\n-  AOTKlassData* holder_data = find_klass(holder);\n-  vmassert(holder_data != NULL, \"klass %s not found\", holder->signature_name());\n-  vmassert(is_dependent_method(holder, caller), \"sanity\");\n-\n-  AOTKlassData* dyno_data = NULL;\n-  bool adapter_failed = false;\n-  char buf[64];\n-  int descriptor_index = 0;\n-  \/\/ descriptors[0] specific name (\"adapter:<method_id>\") for matching\n-  \/\/ descriptors[1] fall-back name (\"adapter\") for depdencies\n-  while (descriptor_index < 2) {\n-    const char *descriptor = descriptors[descriptor_index];\n-    if (descriptor == NULL) {\n-      break;\n-    }\n-    jio_snprintf(buf, sizeof buf, \"%s<%d:%d>\", descriptor, holder_data->_class_id, index);\n-    dyno_data = find_klass(buf);\n-    if (dyno_data != NULL) {\n-      break;\n-    }\n-    \/\/ If match failed then try fall-back for dependencies\n-    ++descriptor_index;\n-    adapter_failed = true;\n-  }\n-\n-  if (dyno_data == NULL && dyno_klass == NULL) {\n-    \/\/ all is well, no (appendix) at compile-time, and still none\n-    return true;\n-  }\n-\n-  if (dyno_data == NULL) {\n-    \/\/ no (appendix) at build-time, but now there is\n-    sweep_dependent_methods(holder_data);\n-    return false;\n-  }\n-\n-  if (adapter_failed) {\n-    \/\/ adapter method mismatch\n-    sweep_dependent_methods(holder_data);\n-    sweep_dependent_methods(dyno_data);\n-    return false;\n-  }\n-\n-  if (dyno_klass == NULL) {\n-    \/\/ (appendix) at build-time, none now\n-    sweep_dependent_methods(holder_data);\n-    sweep_dependent_methods(dyno_data);\n-    return false;\n-  }\n-\n-  \/\/ TODO: support array appendix object\n-  if (!dyno_klass->is_instance_klass()) {\n-    sweep_dependent_methods(holder_data);\n-    sweep_dependent_methods(dyno_data);\n-    return false;\n-  }\n-\n-  InstanceKlass* dyno = InstanceKlass::cast(dyno_klass);\n-\n-  if (!dyno->is_hidden() && !dyno->is_unsafe_anonymous()) {\n-    if (_klasses_got[dyno_data->_got_index] != dyno) {\n-      \/\/ compile-time class different from runtime class, fail and deoptimize\n-      sweep_dependent_methods(holder_data);\n-      sweep_dependent_methods(dyno_data);\n-      return false;\n-    }\n-\n-    if (dyno->is_initialized()) {\n-      _klasses_got[dyno_data->_got_index - 1] = dyno;\n-    }\n-    return true;\n-  }\n-\n-  \/\/ TODO: support anonymous supers\n-  if (!dyno->supers_have_passed_fingerprint_checks() || dyno->get_stored_fingerprint() != dyno_data->_fingerprint) {\n-      NOT_PRODUCT( aot_klasses_fp_miss++; )\n-      log_trace(aot, class, fingerprint)(\"class  %s%s  has bad fingerprint in  %s tid=\" INTPTR_FORMAT,\n-          dyno->internal_name(), dyno->is_shared() ? \" (shared)\" : \"\",\n-          _lib->name(), p2i(thread));\n-    sweep_dependent_methods(holder_data);\n-    sweep_dependent_methods(dyno_data);\n-    return false;\n-  }\n-\n-  _klasses_got[dyno_data->_got_index] = dyno;\n-  if (dyno->is_initialized()) {\n-    _klasses_got[dyno_data->_got_index - 1] = dyno;\n-  }\n-\n-  \/\/ TODO: hook up any AOT code\n-  \/\/ load_klass_data(dyno_data, thread);\n-  return true;\n-}\n-\n-bool AOTCodeHeap::reconcile_dynamic_method(AOTCompiledMethod *caller, InstanceKlass* holder, int index, Method *adapter_method) {\n-    InstanceKlass *adapter_klass = adapter_method->method_holder();\n-    char buf[64];\n-    jio_snprintf(buf, sizeof buf, \"adapter:%d\", adapter_method->method_idnum());\n-    if (!reconcile_dynamic_klass(caller, holder, index, adapter_klass, buf, \"adapter\")) {\n-      return false;\n-    }\n-    return true;\n-}\n-\n-bool AOTCodeHeap::reconcile_dynamic_invoke(AOTCompiledMethod* caller, InstanceKlass* holder, int index, Method* adapter_method, Klass *appendix_klass) {\n-    if (!reconcile_dynamic_klass(caller, holder, index, appendix_klass, \"appendix\")) {\n-      return false;\n-    }\n-\n-    if (!reconcile_dynamic_method(caller, holder, index, adapter_method)) {\n-      return false;\n-    }\n-\n-    return true;\n-}\n","filename":"src\/hotspot\/share\/aot\/aotCodeHeap.cpp","additions":0,"deletions":1116,"binary":false,"changes":1116,"status":"deleted"},{"patch":"@@ -1,310 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_AOT_AOTCODEHEAP_HPP\n-#define SHARE_AOT_AOTCODEHEAP_HPP\n-\n-#include \"aot\/aotCompiledMethod.hpp\"\n-#include \"classfile\/symbolTable.hpp\"\n-#include \"metaprogramming\/integralConstant.hpp\"\n-#include \"oops\/metadata.hpp\"\n-#include \"oops\/method.hpp\"\n-\n-enum CodeState {\n-  not_set = 0, \/\/ _aot fields is not set yet\n-  in_use  = 1, \/\/ _aot field is set to corresponding AOTCompiledMethod\n-  invalid = 2  \/\/ AOT code is invalidated because dependencies failed\n-};\n-\n-typedef struct {\n-  AOTCompiledMethod* _aot;\n-  CodeState _state; \/\/ State change cases: not_set->in_use, not_set->invalid\n-} CodeToAMethod;\n-\n-class ClassLoaderData;\n-\n-class AOTClass {\n-public:\n-  ClassLoaderData* _classloader;\n-};\n-\n-typedef struct {\n-  int _name_offset;\n-  int _code_offset;\n-  int _meta_offset;\n-  int _metadata_got_offset;\n-  int _metadata_got_size;\n-  int _code_id;\n-} AOTMethodOffsets;\n-\n-typedef struct {\n-  const char* _name;\n-  address     _code;\n-  aot_metadata* _meta;\n-  jlong*      _state_adr;\n-  address     _metadata_table;\n-  int         _metadata_size;\n-} AOTMethodData;\n-\n-typedef struct {\n-  int _got_index;\n-  int _class_id;\n-  int _compiled_methods_offset;\n-  int _dependent_methods_offset;\n-  uint64_t _fingerprint;\n-} AOTKlassData;\n-\n-typedef struct {\n-  int _version;\n-  int _class_count;\n-  int _method_count;\n-  int _klasses_got_size;\n-  int _metadata_got_size;\n-  int _oop_got_size;\n-  int _jvm_version_offset;\n-\n-  enum {\n-    AOT_SHARED_VERSION = 1\n-  };\n-} AOTHeader;\n-\n-typedef struct {\n-  enum { CONFIG_SIZE = 7 * jintSize + 9 };\n-  \/\/ 7 int values\n-  int _config_size;\n-  int _narrowOopShift;\n-  int _narrowKlassShift;\n-  int _contendedPaddingWidth;\n-  int _objectAlignment;\n-  int _codeSegmentSize;\n-  int _gc;\n-  \/\/ byte[9] array map to boolean values here\n-  bool _debug_VM;\n-  bool _useCompressedOops;\n-  bool _useCompressedClassPointers;\n-  bool _useTLAB;\n-  bool _useBiasedLocking;\n-  bool _tieredAOT;\n-  bool _enableContended;\n-  bool _restrictContended;\n-  bool _omitAssertions;\n-} AOTConfiguration;\n-\n-class AOTLib : public CHeapObj<mtCode> {\n-  static bool _narrow_oop_shift_initialized;\n-  static int _narrow_oop_shift;\n-  static int _narrow_klass_shift;\n-\n-  bool _valid;\n-  void* _dl_handle;\n-  const int _dso_id;\n-  const char* _name;\n-  \/\/ VM configuration during AOT compilation\n-  AOTConfiguration* _config;\n-  AOTHeader* _header;\n-\n-  void handle_config_error(const char* format, ...) ATTRIBUTE_PRINTF(2, 3);\n-public:\n-  AOTLib(void* handle, const char* name, int dso_id);\n-  virtual ~AOTLib();\n-  static int  narrow_oop_shift() { return _narrow_oop_shift; }\n-  static int  narrow_klass_shift() { return _narrow_klass_shift; }\n-  static bool narrow_oop_shift_initialized() { return _narrow_oop_shift_initialized; }\n-\n-  bool is_valid() const {\n-    return _valid;\n-  }\n-  const char* name() const {\n-    return _name;\n-  }\n-  void* dl_handle() const {\n-    return _dl_handle;\n-  }\n-  int id() const {\n-    return _dso_id;\n-  }\n-  AOTHeader* header() const {\n-    return _header;\n-  }\n-  AOTConfiguration* config() const {\n-    return _config;\n-  }\n-  void verify_config();\n-  void verify_flag(bool aot_flag, bool flag, const char* name);\n-  void verify_flag(int  aot_flag, int  flag, const char* name);\n-\n-  address load_symbol(const char *name);\n-};\n-\n-\n-class AOTCodeHeap : public CodeHeap {\n-  AOTLib* _lib;\n-  int _aot_id;\n-\n-  int _class_count;\n-  int _method_count;\n-  AOTClass* _classes;\n-  CodeToAMethod* _code_to_aot;\n-\n-  address _code_space;\n-  address _code_segments;\n-  jlong*  _method_state;\n-\n-\n-  \/\/ Collect metaspace info: names -> address in .got section\n-  const char* _metaspace_names;\n-  address _method_metadata;\n-\n-  address _methods_offsets;\n-  address _klasses_offsets;\n-  address _dependencies;\n-\n-  Metadata** _klasses_got;\n-  Metadata** _metadata_got;\n-  oop*    _oop_got;\n-\n-  int _klasses_got_size;\n-  int _metadata_got_size;\n-  int _oop_got_size;\n-\n-  \/\/ Collect stubs info\n-  int* _stubs_offsets;\n-\n-  bool _lib_symbols_initialized;\n-\n-  void adjust_boundaries(AOTCompiledMethod* method) {\n-    char* low = (char*)method->code_begin();\n-    if (low < low_boundary()) {\n-      _memory.set_low_boundary(low);\n-      _memory.set_low(low);\n-    }\n-    char* high = (char *)method->code_end();\n-    if (high > high_boundary()) {\n-      _memory.set_high_boundary(high);\n-      _memory.set_high(high);\n-    }\n-    assert(_method_count > 0, \"methods count should be set already\");\n-  }\n-\n-  void register_stubs();\n-\n-  void link_shared_runtime_symbols();\n-  void link_stub_routines_symbols();\n-  void link_os_symbols();\n-  void link_graal_runtime_symbols();\n-\n-  void link_global_lib_symbols();\n-  void link_klass(const Klass* klass);\n-  void link_known_klasses();\n-  void publish_aot(const methodHandle& mh, AOTMethodData* method_data, int code_id);\n-\n-\n-  AOTCompiledMethod* next_in_use_at(int index) const;\n-\n-  \/\/ Find klass in SystemDictionary for aot metadata.\n-  static Klass* lookup_klass(const char* name, int len, const Method* method, Thread* THREAD);\n-public:\n-  AOTCodeHeap(AOTLib* lib);\n-  virtual ~AOTCodeHeap();\n-\n-  AOTCompiledMethod* find_aot(address p) const;\n-\n-  virtual void* find_start(void* p)     const;\n-  virtual CodeBlob* find_blob_unsafe(void* start) const;\n-  virtual void* first() const;\n-  virtual void* next(void *p) const;\n-\n-  AOTKlassData* find_klass(InstanceKlass* ik);\n-  bool load_klass_data(InstanceKlass* ik, Thread* thread);\n-  Klass* get_klass_from_got(const char* klass_name, int klass_len, const Method* method);\n-\n-  bool is_dependent_method(Klass* dependee, AOTCompiledMethod* aot);\n-  void mark_evol_dependent_methods(InstanceKlass* dependee);\n-\n-  const char* get_name_at(int offset) {\n-    return _metaspace_names + offset;\n-  }\n-\n-\n-  void oops_do(OopClosure* f);\n-  void metadata_do(MetadataClosure* f);\n-  void got_metadata_do(MetadataClosure* f);\n-\n-#ifdef ASSERT\n-  bool got_contains(Metadata **p) {\n-    return (p >= &_metadata_got[0] && p < &_metadata_got[_metadata_got_size]) ||\n-           (p >= &_klasses_got[0] && p < &_klasses_got[_klasses_got_size]);\n-  }\n-#endif\n-\n-  int dso_id() const { return _lib->id(); }\n-  int aot_id() const { return _aot_id; }\n-\n-  int method_count() { return _method_count; }\n-\n-  AOTCompiledMethod* get_code_desc_at_index(int index) {\n-    if (index < _method_count && _code_to_aot[index]._state == in_use) {\n-        AOTCompiledMethod* m = _code_to_aot[index]._aot;\n-        assert(m != NULL, \"AOT method should be set\");\n-        if (!m->is_runtime_stub()) {\n-          return m;\n-        }\n-    }\n-    return NULL;\n-  }\n-\n-  static Method* find_method(Klass* klass, Thread* thread, const char* method_name);\n-\n-  void cleanup_inline_caches();\n-\n-  DEBUG_ONLY( int verify_icholder_relocations(); )\n-\n-  void alive_methods_do(void f(CompiledMethod* nm));\n-\n-#ifndef PRODUCT\n-  static int klasses_seen;\n-  static int aot_klasses_found;\n-  static int aot_klasses_fp_miss;\n-  static int aot_klasses_cl_miss;\n-  static int aot_methods_found;\n-\n-  static void print_statistics();\n-#endif\n-\n-  bool reconcile_dynamic_invoke(AOTCompiledMethod* caller, InstanceKlass* holder, int index, Method* adapter_method, Klass *appendix_klass);\n-\n-private:\n-  AOTKlassData* find_klass(const char* name);\n-\n-  void sweep_dependent_methods(int* indexes, int methods_cnt);\n-  void sweep_dependent_methods(AOTKlassData* klass_data);\n-  void sweep_dependent_methods(InstanceKlass* ik);\n-  void sweep_method(AOTCompiledMethod* aot);\n-\n-  bool reconcile_dynamic_klass(AOTCompiledMethod *caller, InstanceKlass* holder, int index, Klass *dyno, const char *descriptor1, const char *descriptor2 = NULL);\n-\n-  bool reconcile_dynamic_method(AOTCompiledMethod *caller, InstanceKlass* holder, int index, Method *adapter_method);\n-\n-};\n-\n-#endif \/\/ SHARE_AOT_AOTCODEHEAP_HPP\n","filename":"src\/hotspot\/share\/aot\/aotCodeHeap.hpp","additions":0,"deletions":310,"binary":false,"changes":310,"status":"deleted"},{"patch":"@@ -1,441 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#include \"aot\/aotCodeHeap.hpp\"\n-#include \"aot\/aotLoader.hpp\"\n-#include \"aot\/compiledIC_aot.hpp\"\n-#include \"code\/codeCache.hpp\"\n-#include \"code\/compiledIC.hpp\"\n-#include \"code\/nativeInst.hpp\"\n-#include \"compiler\/compilerOracle.hpp\"\n-#include \"gc\/shared\/cardTableBarrierSet.hpp\"\n-#include \"gc\/shared\/collectedHeap.hpp\"\n-#include \"oops\/klass.inline.hpp\"\n-#include \"oops\/method.inline.hpp\"\n-#include \"runtime\/frame.inline.hpp\"\n-#include \"runtime\/handles.inline.hpp\"\n-#include \"runtime\/java.hpp\"\n-#include \"runtime\/orderAccess.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"runtime\/safepointVerifiers.hpp\"\n-#include \"runtime\/sharedRuntime.hpp\"\n-#include \"utilities\/sizes.hpp\"\n-#include \"utilities\/xmlstream.hpp\"\n-\n-#include <stdio.h>\n-\n-#if 0\n-static void metadata_oops_do(Metadata** metadata_begin, Metadata **metadata_end, OopClosure* f) {\n-  \/\/ Visit the metadata\/oops section\n-  for (Metadata** p = metadata_begin; p < metadata_end; p++) {\n-    Metadata* m = *p;\n-\n-    intptr_t meta = (intptr_t)m;\n-    if ((meta & 1) == 1) {\n-      \/\/ already resolved\n-      m = (Metadata*)(meta & ~1);\n-    } else {\n-      continue;\n-    }\n-    assert(Metaspace::contains(m), \"\");\n-    if (m->is_method()) {\n-      m = ((Method*)m)->method_holder();\n-    }\n-    assert(m->is_klass(), \"must be\");\n-    oop o = ((Klass*)m)->klass_holder();\n-    if (o != NULL) {\n-      f->do_oop(&o);\n-    }\n-  }\n-}\n-#endif\n-\n-address* AOTCompiledMethod::orig_pc_addr(const frame* fr) {\n-  return (address*) ((address)fr->unextended_sp() + _meta->orig_pc_offset());\n-}\n-\n-oop AOTCompiledMethod::oop_at(int index) const {\n-  if (index == 0) { \/\/ 0 is reserved\n-    return NULL;\n-  }\n-  Metadata** entry = _metadata_got + (index - 1);\n-  intptr_t meta = (intptr_t)*entry;\n-  if ((meta & 1) == 1) {\n-    \/\/ already resolved\n-    Klass* k = (Klass*)(meta & ~1);\n-    return k->java_mirror();\n-  }\n-  \/\/ The entry is string which we need to resolve.\n-  const char* meta_name = _heap->get_name_at((int)meta);\n-  int klass_len = Bytes::get_Java_u2((address)meta_name);\n-  const char* klass_name = meta_name + 2;\n-  \/\/ Quick check the current method's holder.\n-  Klass* k = _method->method_holder();\n-\n-  ResourceMark rm; \/\/ for signature_name()\n-  if (strncmp(k->signature_name(), klass_name, klass_len) != 0) { \/\/ Does not match?\n-    \/\/ Search klass in got cells in DSO which have this compiled method.\n-    k = _heap->get_klass_from_got(klass_name, klass_len, _method);\n-  }\n-  int method_name_len = Bytes::get_Java_u2((address)klass_name + klass_len);\n-  guarantee(method_name_len == 0, \"only klass is expected here\");\n-  meta = ((intptr_t)k) | 1;\n-  *entry = (Metadata*)meta; \/\/ Should be atomic on x64\n-  return k->java_mirror();\n-}\n-\n-Metadata* AOTCompiledMethod::metadata_at(int index) const {\n-  if (index == 0) { \/\/ 0 is reserved\n-    return NULL;\n-  }\n-  assert(index - 1 < _metadata_size, \"\");\n-  {\n-    Metadata** entry = _metadata_got + (index - 1);\n-    intptr_t meta = (intptr_t)*entry;\n-    if ((meta & 1) == 1) {\n-      \/\/ already resolved\n-      Metadata *m = (Metadata*)(meta & ~1);\n-      return m;\n-    }\n-    \/\/ The entry is string which we need to resolve.\n-    const char* meta_name = _heap->get_name_at((int)meta);\n-    int klass_len = Bytes::get_Java_u2((address)meta_name);\n-    const char* klass_name = meta_name + 2;\n-    \/\/ Quick check the current method's holder.\n-    Klass* k = _method->method_holder();\n-    bool klass_matched = true;\n-\n-    ResourceMark rm; \/\/ for signature_name() and find_method()\n-    if (strncmp(k->signature_name(), klass_name, klass_len) != 0) { \/\/ Does not match?\n-      \/\/ Search klass in got cells in DSO which have this compiled method.\n-      k = _heap->get_klass_from_got(klass_name, klass_len, _method);\n-      klass_matched = false;\n-    }\n-    int method_name_len = Bytes::get_Java_u2((address)klass_name + klass_len);\n-    if (method_name_len == 0) { \/\/ Array or Klass name only?\n-      meta = ((intptr_t)k) | 1;\n-      *entry = (Metadata*)meta; \/\/ Should be atomic on x64\n-      return (Metadata*)k;\n-    } else { \/\/ Method\n-      \/\/ Quick check the current method's name.\n-      Method* m = _method;\n-      int signature_len = Bytes::get_Java_u2((address)klass_name + klass_len + 2 + method_name_len);\n-      int full_len = 2 + klass_len + 2 + method_name_len + 2 + signature_len;\n-      if (!klass_matched || memcmp(_name, meta_name, full_len) != 0) { \/\/ Does not match?\n-        Thread* thread = Thread::current();\n-        const char* method_name = klass_name + klass_len;\n-        m = AOTCodeHeap::find_method(k, thread, method_name);\n-      }\n-      meta = ((intptr_t)m) | 1;\n-      *entry = (Metadata*)meta; \/\/ Should be atomic on x64\n-      return (Metadata*)m;\n-    }\n-  }\n-  ShouldNotReachHere(); return NULL;\n-}\n-\n-void AOTCompiledMethod::do_unloading(bool unloading_occurred) {\n-  unload_nmethod_caches(unloading_occurred);\n-}\n-\n-bool AOTCompiledMethod::make_not_entrant_helper(int new_state) {\n-  NoSafepointVerifier nsv;\n-\n-  {\n-    \/\/ Enter critical section.  Does not block for safepoint.\n-    MutexLocker pl(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n-\n-    if (*_state_adr == new_state) {\n-      \/\/ another thread already performed this transition so nothing\n-      \/\/ to do, but return false to indicate this.\n-      return false;\n-    }\n-\n-    \/\/ Change state\n-    OrderAccess::storestore();\n-    *_state_adr = new_state;\n-\n-    \/\/ Log the transition once\n-    log_state_change();\n-\n-#if COMPILER1_OR_COMPILER2\n-    \/\/ Remain non-entrant forever\n-    if (new_state == not_entrant && method() != NULL) {\n-        method()->set_aot_code(NULL);\n-    }\n-#endif \/\/ COMPILER1_OR_COMPILER2\n-\n-    \/\/ Remove AOTCompiledMethod from method.\n-    if (method() != NULL) {\n-      method()->unlink_code(this);\n-    }\n-  } \/\/ leave critical region under CompiledMethod_lock\n-\n-\n-  if (TraceCreateZombies) {\n-    ResourceMark m;\n-    const char *new_state_str = (new_state == not_entrant) ? \"not entrant\" : \"not used\";\n-    tty->print_cr(\"aot method <\" INTPTR_FORMAT \"> %s code made %s\", p2i(this), this->method() ? this->method()->name_and_sig_as_C_string() : \"null\", new_state_str);\n-  }\n-\n-  return true;\n-}\n-\n-bool AOTCompiledMethod::make_entrant() {\n-#if COMPILER1_OR_COMPILER2\n-  assert(!method()->is_old(), \"reviving evolved method!\");\n-\n-  NoSafepointVerifier nsv;\n-  {\n-    \/\/ Enter critical section.  Does not block for safepoint.\n-    MutexLocker pl(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n-\n-    if (*_state_adr == in_use || *_state_adr == not_entrant) {\n-      \/\/ another thread already performed this transition so nothing\n-      \/\/ to do, but return false to indicate this.\n-      return false;\n-    }\n-\n-    \/\/ Change state\n-    OrderAccess::storestore();\n-    *_state_adr = in_use;\n-\n-    \/\/ Log the transition once\n-    log_state_change();\n-  } \/\/ leave critical region under CompiledMethod_lock\n-\n-\n-  if (TraceCreateZombies) {\n-    ResourceMark m;\n-    tty->print_cr(\"aot method <\" INTPTR_FORMAT \"> %s code made entrant\", p2i(this), this->method() ? this->method()->name_and_sig_as_C_string() : \"null\");\n-  }\n-\n-  return true;\n-#else\n-  return false;\n-#endif \/\/ COMPILER1_OR_COMPILER2\n-}\n-\n-\/\/ Iterate over metadata calling this function.   Used by RedefineClasses\n-\/\/ Copied from nmethod::metadata_do\n-void AOTCompiledMethod::metadata_do(MetadataClosure* f) {\n-  address low_boundary = verified_entry_point();\n-  {\n-    \/\/ Visit all immediate references that are embedded in the instruction stream.\n-    RelocIterator iter(this, low_boundary);\n-    while (iter.next()) {\n-      if (iter.type() == relocInfo::metadata_type ) {\n-        metadata_Relocation* r = iter.metadata_reloc();\n-        \/\/ In this metadata, we must only follow those metadatas directly embedded in\n-        \/\/ the code.  Other metadatas (oop_index>0) are seen as part of\n-        \/\/ the metadata section below.\n-        assert(1 == (r->metadata_is_immediate()) +\n-               (r->metadata_addr() >= metadata_begin() && r->metadata_addr() < metadata_end()),\n-               \"metadata must be found in exactly one place\");\n-        if (r->metadata_is_immediate() && r->metadata_value() != NULL) {\n-          Metadata* md = r->metadata_value();\n-          if (md != _method) f->do_metadata(md);\n-        }\n-      } else if (iter.type() == relocInfo::virtual_call_type) {\n-        ResourceMark rm;\n-        \/\/ Check compiledIC holders associated with this nmethod\n-        CompiledIC *ic = CompiledIC_at(&iter);\n-        if (ic->is_icholder_call()) {\n-          CompiledICHolder* cichk = ic->cached_icholder();\n-          f->do_metadata(cichk->holder_metadata());\n-          f->do_metadata(cichk->holder_klass());\n-        } else {\n-          \/\/ Get Klass* or NULL (if value is -1) from GOT cell of virtual call PLT stub.\n-          Metadata* ic_oop = ic->cached_metadata();\n-          if (ic_oop != NULL) {\n-            f->do_metadata(ic_oop);\n-          }\n-        }\n-      } else if (iter.type() == relocInfo::static_call_type ||\n-                 iter.type() == relocInfo::opt_virtual_call_type) {\n-        \/\/ Check Method* in AOT c2i stub for other calls.\n-        Metadata* meta = (Metadata*)nativeLoadGot_at(nativePltCall_at(iter.addr())->plt_c2i_stub())->data();\n-        if (meta != NULL) {\n-          f->do_metadata(meta);\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ Visit the metadata section\n-  for (Metadata** p = metadata_begin(); p < metadata_end(); p++) {\n-    Metadata* m = *p;\n-\n-    intptr_t meta = (intptr_t)m;\n-    if ((meta & 1) == 1) {\n-      \/\/ already resolved\n-      m = (Metadata*)(meta & ~1);\n-    } else {\n-      continue;\n-    }\n-    assert(Metaspace::contains(m), \"\");\n-    f->do_metadata(m);\n-  }\n-\n-  \/\/ Visit metadata not embedded in the other places.\n-  if (_method != NULL) f->do_metadata(_method);\n-}\n-\n-void AOTCompiledMethod::print() const {\n-  print_on(tty, \"AOTCompiledMethod\");\n-}\n-\n-void AOTCompiledMethod::print_on(outputStream* st) const {\n-  print_on(st, \"AOTCompiledMethod\");\n-}\n-\n-\/\/ Print out more verbose output usually for a newly created aot method.\n-void AOTCompiledMethod::print_on(outputStream* st, const char* msg) const {\n-  if (st != NULL) {\n-    ttyLocker ttyl;\n-    st->print(\"%7d \", (int) tty->time_stamp().milliseconds());\n-    st->print(\"%4d \", _aot_id);    \/\/ print compilation number\n-    st->print(\"    aot[%2d]\", _heap->dso_id());\n-    \/\/ Stubs have _method == NULL\n-    if (_method == NULL) {\n-      st->print(\"   %s\", _name);\n-    } else {\n-      ResourceMark m;\n-      st->print(\"   %s\", _method->name_and_sig_as_C_string());\n-    }\n-    if (Verbose) {\n-      st->print(\" entry at \" INTPTR_FORMAT, p2i(_code));\n-    }\n-    if (msg != NULL) {\n-      st->print(\"   %s\", msg);\n-    }\n-    st->cr();\n-  }\n-}\n-\n-void AOTCompiledMethod::print_value_on(outputStream* st) const {\n-  st->print(\"AOTCompiledMethod \");\n-  print_on(st, NULL);\n-}\n-\n-\/\/ Print a short set of xml attributes to identify this aot method.  The\n-\/\/ output should be embedded in some other element.\n-void AOTCompiledMethod::log_identity(xmlStream* log) const {\n-  log->print(\" aot_id='%d'\", _aot_id);\n-  log->print(\" aot='%2d'\", _heap->dso_id());\n-}\n-\n-void AOTCompiledMethod::log_state_change() const {\n-  if (LogCompilation) {\n-    ResourceMark m;\n-    if (xtty != NULL) {\n-      ttyLocker ttyl;  \/\/ keep the following output all in one block\n-      if (*_state_adr == not_entrant) {\n-        xtty->begin_elem(\"make_not_entrant thread='\" UINTX_FORMAT \"'\",\n-                         os::current_thread_id());\n-      } else if (*_state_adr == not_used) {\n-        xtty->begin_elem(\"make_not_used thread='\" UINTX_FORMAT \"'\",\n-                         os::current_thread_id());\n-      } else if (*_state_adr == in_use) {\n-        xtty->begin_elem(\"make_entrant thread='\" UINTX_FORMAT \"'\",\n-                         os::current_thread_id());\n-      }\n-      log_identity(xtty);\n-      xtty->stamp();\n-      xtty->end_elem();\n-    }\n-  }\n-  if (PrintCompilation) {\n-    ResourceMark m;\n-    if (*_state_adr == not_entrant) {\n-      print_on(tty, \"made not entrant\");\n-    } else if (*_state_adr == not_used) {\n-      print_on(tty, \"made not used\");\n-    } else if (*_state_adr == in_use) {\n-      print_on(tty, \"made entrant\");\n-    }\n-  }\n-}\n-\n-\n-NativeInstruction* PltNativeCallWrapper::get_load_instruction(virtual_call_Relocation* r) const {\n-  return nativeLoadGot_at(_call->plt_load_got());\n-}\n-\n-void PltNativeCallWrapper::verify_resolve_call(address dest) const {\n-  CodeBlob* db = CodeCache::find_blob_unsafe(dest);\n-  if (db == NULL) {\n-    assert(dest == _call->plt_resolve_call(), \"sanity\");\n-  }\n-}\n-\n-void PltNativeCallWrapper::set_to_interpreted(const methodHandle& method, CompiledICInfo& info) {\n-  assert(!info.to_aot(), \"only for nmethod\");\n-  CompiledPltStaticCall* csc = CompiledPltStaticCall::at(instruction_address());\n-  csc->set_to_interpreted(method, info.entry());\n-}\n-\n-NativeCallWrapper* AOTCompiledMethod::call_wrapper_at(address call) const {\n-  return new PltNativeCallWrapper((NativePltCall*) call);\n-}\n-\n-NativeCallWrapper* AOTCompiledMethod::call_wrapper_before(address return_pc) const {\n-  return new PltNativeCallWrapper(nativePltCall_before(return_pc));\n-}\n-\n-CompiledStaticCall* AOTCompiledMethod::compiledStaticCall_at(Relocation* call_site) const {\n-  return CompiledPltStaticCall::at(call_site);\n-}\n-\n-CompiledStaticCall* AOTCompiledMethod::compiledStaticCall_at(address call_site) const {\n-  return CompiledPltStaticCall::at(call_site);\n-}\n-\n-CompiledStaticCall* AOTCompiledMethod::compiledStaticCall_before(address return_addr) const {\n-  return CompiledPltStaticCall::before(return_addr);\n-}\n-\n-address AOTCompiledMethod::call_instruction_address(address pc) const {\n-  NativePltCall* pltcall = nativePltCall_before(pc);\n-  return pltcall->instruction_address();\n-}\n-\n-void AOTCompiledMethod::clear_inline_caches() {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"cleaning of IC's only allowed at safepoint\");\n-  if (is_zombie()) {\n-    return;\n-  }\n-\n-  ResourceMark rm;\n-  RelocIterator iter(this);\n-  while (iter.next()) {\n-    iter.reloc()->clear_inline_cache();\n-    if (iter.type() == relocInfo::opt_virtual_call_type) {\n-      CompiledIC* cic = CompiledIC_at(&iter);\n-      assert(cic->is_clean(), \"!\");\n-      nativePltCall_at(iter.addr())->set_stub_to_clean();\n-    }\n-  }\n-}\n","filename":"src\/hotspot\/share\/aot\/aotCompiledMethod.cpp","additions":0,"deletions":441,"binary":false,"changes":441,"status":"deleted"},{"patch":"@@ -1,323 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_AOT_AOTCOMPILEDMETHOD_HPP\n-#define SHARE_AOT_AOTCOMPILEDMETHOD_HPP\n-\n-#include \"code\/codeCache.hpp\"\n-#include \"code\/compiledIC.hpp\"\n-#include \"code\/compiledMethod.hpp\"\n-#include \"code\/pcDesc.hpp\"\n-#include \"code\/relocInfo.hpp\"\n-\n-class AOTCodeHeap;\n-\n-class aot_metadata {\n-private:\n-  int _size;\n-  int _code_size;\n-  int _entry;\n-  int _verified_entry;\n-  int _exception_handler_offset;\n-  int _deopt_handler_offset;\n-  int _deopt_mh_handler_offset;\n-  int _stubs_offset;\n-  int _frame_size;\n-  \/\/ location in frame (offset for sp) that deopt can store the original\n-  \/\/ pc during a deopt.\n-  int _orig_pc_offset;\n-  int _unsafe_access;\n-\n-  int _pc_desc_begin;\n-  int _scopes_begin;\n-  int _reloc_begin;\n-  int _exception_table_begin;\n-  int _nul_chk_table_begin;\n-  int _oopmap_begin;\n-  address at_offset(size_t offset) const { return ((address) this) + offset; }\n-public:\n-  int code_size() const { return _code_size; }\n-  int frame_size() const { return _frame_size \/ HeapWordSize; }\n-  PcDesc *scopes_pcs_begin() const { return (PcDesc *) at_offset(_pc_desc_begin); }\n-  PcDesc *scopes_pcs_end() const { return (PcDesc *) at_offset(_scopes_begin); }\n-  address scopes_data_begin() const { return at_offset(_scopes_begin); }\n-  address scopes_data_end() const { return at_offset(_reloc_begin); }\n-  relocInfo* relocation_begin() const { return (relocInfo*) at_offset(_reloc_begin); }\n-  relocInfo* relocation_end() const { return (relocInfo*) at_offset(_exception_table_begin); }\n-  address handler_table_begin   () const { return at_offset(_exception_table_begin); }\n-  address handler_table_end() const { return at_offset(_nul_chk_table_begin); }\n-\n-  address nul_chk_table_begin() const { return at_offset(_nul_chk_table_begin); }\n-  address nul_chk_table_end() const { return at_offset(_oopmap_begin); }\n-\n-  ImmutableOopMapSet* oopmap_set() const { return (ImmutableOopMapSet*) at_offset(_oopmap_begin); }\n-\n-  address consts_begin() const { return at_offset(_size); }\n-  address consts_end() const { return at_offset(_size); }\n-  int stub_offset() const { return _stubs_offset; }\n-  int entry_offset() const { return _entry; }\n-  int verified_entry_offset() const { return _verified_entry; }\n-  int exception_handler_offset() const { return _exception_handler_offset; }\n-  int deopt_handler_offset() const { return _deopt_handler_offset; }\n-  int deopt_mh_handler_offset() const { return _deopt_mh_handler_offset; }\n-  int orig_pc_offset() const { return _orig_pc_offset; }\n-\n-  int handler_table_size() const { return handler_table_end() - handler_table_begin(); }\n-  int nul_chk_table_size() const { return nul_chk_table_end() - nul_chk_table_begin(); }\n-  bool has_unsafe_access() const { return _unsafe_access != 0; }\n-\n-};\n-\n-\/*\n- * Use this for AOTCompiledMethods since a lot of the fields in CodeBlob gets the same\n- * value when they come from AOT. code_begin == content_begin, etc... *\/\n-class AOTCompiledMethodLayout : public CodeBlobLayout {\n-public:\n-  AOTCompiledMethodLayout(address code_begin, address code_end, address relocation_begin, address relocation_end) :\n-    CodeBlobLayout(\n-        code_begin, \/\/ code_begin\n-        code_end, \/\/ code_end\n-        code_begin, \/\/ content_begin\n-        code_end, \/\/ content_end\n-        code_end, \/\/ data_end\n-        relocation_begin, \/\/ relocation_begin\n-        relocation_end\n-        ) {\n-    }\n-};\n-\n-class AOTCompiledMethod : public CompiledMethod, public CHeapObj<mtCode> {\n-private:\n-  address       _code;\n-  aot_metadata* _meta;\n-  Metadata**    _metadata_got;\n-  jlong*        _state_adr; \/\/ Address of cell to indicate aot method state (in_use or not_entrant)\n-  AOTCodeHeap*  _heap;    \/\/ code heap which has this method\n-  const char*   _name;    \/\/ For stub: \"AOT Stub<name>\" for stub,\n-                          \/\/ For nmethod: \"<u2_size>Ljava\/lang\/ThreadGroup;<u2_size>addUnstarted<u2_size>()V\"\n-  const int _metadata_size; \/\/ size of _metadata_got\n-  const int _aot_id;\n-  const int _method_index;\n-  oop _oop;  \/\/ method()->method_holder()->klass_holder()\n-\n-  address* orig_pc_addr(const frame* fr);\n-  bool make_not_entrant_helper(int new_state);\n-\n- public:\n-  using CHeapObj<mtCode>::operator new;\n-  using CHeapObj<mtCode>::operator delete;\n-\n-  int method_index() const { return _method_index; }\n-  void set_oop(oop o) { _oop = o; }\n-\n-  AOTCompiledMethod(address code, Method* method, aot_metadata* meta, address metadata_got, int metadata_size, jlong* state_adr, AOTCodeHeap* heap, const char* name, int method_index, int aot_id) :\n-    CompiledMethod(method, name, compiler_jvmci, \/\/ AOT code is generated by JVMCI compiler\n-        AOTCompiledMethodLayout(code, code + meta->code_size(), (address) meta->relocation_begin(), (address) meta->relocation_end()),\n-        0 \/* frame_complete_offset *\/, meta->frame_size() \/* frame_size *\/, meta->oopmap_set(), false \/* caller_must_gc_arguments *\/),\n-    _code(code),\n-    _meta(meta),\n-    _metadata_got((Metadata**) metadata_got),\n-    _state_adr(state_adr),\n-    _heap(heap),\n-    _name(name),\n-    _metadata_size(metadata_size),\n-    _aot_id(aot_id),\n-    _method_index(method_index) {\n-\n-    _is_far_code = CodeCache::is_far_target(code) ||\n-                   CodeCache::is_far_target(code + meta->code_size());\n-    _exception_cache = NULL;\n-\n-    _scopes_data_begin = (address) _meta->scopes_data_begin();\n-    _deopt_handler_begin = (address) _code + _meta->deopt_handler_offset();\n-    if (_meta->deopt_mh_handler_offset() != -1) {\n-      _deopt_mh_handler_begin = (address) _code + _meta->deopt_mh_handler_offset();\n-    } else {\n-      _deopt_mh_handler_begin = (address) this;\n-    }\n-\n-    _pc_desc_container.reset_to(scopes_pcs_begin());\n-\n-    \/\/ Mark the AOTCompiledMethod as in_use\n-    *_state_adr = nmethod::in_use;\n-    set_has_unsafe_access(_meta->has_unsafe_access());\n-    _oop = NULL;\n-  }\n-\n-  virtual bool is_aot() const { return true; }\n-  virtual bool is_runtime_stub() const { return is_aot_runtime_stub(); }\n-\n-  virtual bool is_compiled() const     { return !is_aot_runtime_stub(); }\n-\n-  virtual bool is_locked_by_vm() const { return false; }\n-\n-  int state() const { return *_state_adr; }\n-\n-  \/\/ Non-virtual for speed\n-  bool _is_alive() const { return state() < unloaded; }\n-\n-  virtual bool is_zombie() const { return state() == zombie; }\n-  virtual bool is_unloaded() const { return state() == unloaded; }\n-  virtual bool is_not_entrant() const { return state() == not_entrant ||\n-                                                 state() == not_used; }\n-  virtual bool is_alive() const { return _is_alive(); }\n-  virtual bool is_in_use() const { return state() == in_use; }\n-\n-  virtual bool is_unloading() { return false; }\n-\n-  address exception_begin() const { return (address) _code + _meta->exception_handler_offset(); }\n-\n-  virtual const char* name() const { return _name; }\n-\n-  virtual int compile_id() const { return _aot_id; }\n-\n-  void print_on(outputStream* st) const;\n-  void print_on(outputStream* st, const char* msg) const;\n-  void print() const;\n-\n-  virtual void print_value_on(outputStream *stream) const;\n-  virtual void print_block_comment(outputStream *stream, address block_begin) const { }\n-  virtual void verify() {}\n-\n-  virtual int comp_level() const { return CompLevel_aot; }\n-  virtual address verified_entry_point() const { return _code + _meta->verified_entry_offset(); }\n-  virtual void log_identity(xmlStream* stream) const;\n-  virtual void log_state_change() const;\n-  virtual bool make_entrant();\n-  virtual bool make_not_entrant() { return make_not_entrant_helper(not_entrant); }\n-  virtual bool make_not_used() { return make_not_entrant_helper(not_used); }\n-  virtual address entry_point() const { return _code + _meta->entry_offset(); }\n-  virtual bool make_zombie() { ShouldNotReachHere(); return false; }\n-  virtual bool is_osr_method() const { return false; }\n-  virtual int osr_entry_bci() const { ShouldNotReachHere(); return -1; }\n-  \/\/ AOT compiled methods do not get into zombie state\n-  virtual bool can_convert_to_zombie() { return false; }\n-\n-  virtual bool is_dependent_on_method(Method* dependee) { return true; }\n-\n-  virtual void clear_inline_caches();\n-\n-  virtual void print_pcs() {}\n-\n-  virtual address scopes_data_end() const { return _meta->scopes_data_end(); }\n-\n-  virtual oop oop_at(int index) const;\n-  virtual Metadata* metadata_at(int index) const;\n-\n-  virtual PcDesc* scopes_pcs_begin() const { return _meta->scopes_pcs_begin(); }\n-  virtual PcDesc* scopes_pcs_end() const { return _meta->scopes_pcs_end(); }\n-\n-  virtual address handler_table_begin() const { return _meta->handler_table_begin(); }\n-  virtual address handler_table_end() const { return _meta->handler_table_end(); }\n-\n-  virtual address nul_chk_table_begin() const { return _meta->nul_chk_table_begin(); }\n-  virtual address nul_chk_table_end() const { return _meta->nul_chk_table_end(); }\n-\n-  virtual address consts_begin() const { return _meta->consts_begin(); }\n-  virtual address consts_end() const { return _meta->consts_end(); }\n-\n-  virtual address stub_begin() const { return code_begin() + _meta->stub_offset(); }\n-  virtual address stub_end() const { return code_end(); }\n-\n-  virtual oop* oop_addr_at(int index) const { ShouldNotReachHere(); return NULL; }\n-  virtual Metadata** metadata_addr_at(int index) const { ShouldNotReachHere(); return NULL; }\n-\n-  \/\/ Accessor\/mutator for the original pc of a frame before a frame was deopted.\n-  address get_original_pc(const frame* fr) { return *orig_pc_addr(fr); }\n-  void    set_original_pc(const frame* fr, address pc) { *orig_pc_addr(fr) = pc; }\n-\n-  virtual void metadata_do(MetadataClosure* f);\n-\n-  bool metadata_got_contains(Metadata **p) {\n-    return p >= &_metadata_got[0] && p < &_metadata_got[_metadata_size];\n-  }\n-\n-  Metadata** metadata_begin() const { return &_metadata_got[0] ; }\n-  Metadata** metadata_end()   const { return &_metadata_got[_metadata_size] ; }\n-  const char* compile_kind() const { return \"AOT\"; }\n-\n-  int get_state() const {\n-    return (int) (*_state_adr);\n-  }\n-\n-  \/\/ inlined and non-virtual for AOTCodeHeap::oops_do\n-  void do_oops(OopClosure* f) {\n-    assert(_is_alive(), \"\");\n-    if (_oop != NULL) {\n-      f->do_oop(&_oop);\n-    }\n-#if 0\n-    metadata_oops_do(metadata_begin(), metadata_end(), f);\n-#endif\n-  }\n-\n-  virtual void do_unloading(bool unloading_occurred);\n-\n-protected:\n-  \/\/ AOT compiled methods are not flushed\n-  void flush() {};\n-\n-  NativeCallWrapper* call_wrapper_at(address call) const;\n-  NativeCallWrapper* call_wrapper_before(address return_pc) const;\n-  address call_instruction_address(address pc) const;\n-\n-  CompiledStaticCall* compiledStaticCall_at(Relocation* call_site) const;\n-  CompiledStaticCall* compiledStaticCall_at(address addr) const;\n-  CompiledStaticCall* compiledStaticCall_before(address addr) const;\n-private:\n-  bool is_aot_runtime_stub() const { return _method == NULL; }\n-};\n-\n-class PltNativeCallWrapper: public NativeCallWrapper {\n-private:\n-  NativePltCall* _call;\n-\n-public:\n-  PltNativeCallWrapper(NativePltCall* call) : _call(call) {}\n-\n-  virtual address destination() const { return _call->destination(); }\n-  virtual address instruction_address() const { return _call->instruction_address(); }\n-  virtual address next_instruction_address() const { return _call->next_instruction_address(); }\n-  virtual address return_address() const { return _call->return_address(); }\n-  virtual address get_resolve_call_stub(bool is_optimized) const { return _call->plt_resolve_call(); }\n-  virtual void set_destination_mt_safe(address dest) { _call->set_destination_mt_safe(dest); }\n-  virtual void set_to_interpreted(const methodHandle& method, CompiledICInfo& info);\n-  virtual void verify() const { _call->verify(); }\n-  virtual void verify_resolve_call(address dest) const;\n-\n-  virtual bool is_call_to_interpreted(address dest) const { return (dest == _call->plt_c2i_stub()); }\n-  \/\/ TODO: assume for now that patching of aot code (got cell) is safe.\n-  virtual bool is_safe_for_patching() const { return true; }\n-\n-  virtual NativeInstruction* get_load_instruction(virtual_call_Relocation* r) const;\n-\n-  virtual void *get_data(NativeInstruction* instruction) const {\n-    return (void*)((NativeLoadGot*) instruction)->data();\n-  }\n-\n-  virtual void set_data(NativeInstruction* instruction, intptr_t data) {\n-    ((NativeLoadGot*) instruction)->set_data(data);\n-  }\n-};\n-\n-#endif \/\/ SHARE_AOT_AOTCOMPILEDMETHOD_HPP\n","filename":"src\/hotspot\/share\/aot\/aotCompiledMethod.hpp","additions":0,"deletions":323,"binary":false,"changes":323,"status":"deleted"},{"patch":"@@ -1,334 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"aot\/aotCodeHeap.hpp\"\n-#include \"aot\/aotLoader.inline.hpp\"\n-#include \"classfile\/javaClasses.hpp\"\n-#include \"jvm.h\"\n-#include \"jvmci\/jvmci.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"oops\/compressedOops.hpp\"\n-#include \"oops\/method.hpp\"\n-#include \"prims\/jvmtiExport.hpp\"\n-#include \"runtime\/arguments.hpp\"\n-#include \"runtime\/globals_extension.hpp\"\n-#include \"runtime\/handles.inline.hpp\"\n-#include \"runtime\/os.inline.hpp\"\n-#include \"runtime\/timerTrace.hpp\"\n-\n-GrowableArray<AOTCodeHeap*>* AOTLoader::_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray<AOTCodeHeap*> (2, mtCode);\n-GrowableArray<AOTLib*>* AOTLoader::_libraries = new(ResourceObj::C_HEAP, mtCode) GrowableArray<AOTLib*> (2, mtCode);\n-\n-\/\/ Iterate over all AOT CodeHeaps\n-#define FOR_ALL_AOT_HEAPS(heap) for (GrowableArrayIterator<AOTCodeHeap*> heap = heaps()->begin(); heap != heaps()->end(); ++heap)\n-\/\/ Iterate over all AOT Libraries\n-#define FOR_ALL_AOT_LIBRARIES(lib) for (GrowableArrayIterator<AOTLib*> lib = libraries()->begin(); lib != libraries()->end(); ++lib)\n-\n-void AOTLoader::load_for_klass(InstanceKlass* ik, Thread* thread) {\n-  if (ik->is_hidden() || ik->is_unsafe_anonymous()) {\n-    \/\/ don't even bother\n-    return;\n-  }\n-  if (UseAOT) {\n-    \/\/ We allow hotswap to be enabled after the onload phase, but not breakpoints\n-    assert(!JvmtiExport::can_post_breakpoint(), \"AOT should have been disabled.\");\n-    FOR_ALL_AOT_HEAPS(heap) {\n-      (*heap)->load_klass_data(ik, thread);\n-    }\n-  }\n-}\n-\n-uint64_t AOTLoader::get_saved_fingerprint(InstanceKlass* ik) {\n-  assert(UseAOT, \"called only when AOT is enabled\");\n-  if (ik->is_hidden() || ik->is_unsafe_anonymous()) {\n-    \/\/ don't even bother\n-    return 0;\n-  }\n-  FOR_ALL_AOT_HEAPS(heap) {\n-    AOTKlassData* klass_data = (*heap)->find_klass(ik);\n-    if (klass_data != NULL) {\n-      return klass_data->_fingerprint;\n-    }\n-  }\n-  return 0;\n-}\n-\n-void AOTLoader::oops_do(OopClosure* f) {\n-  if (UseAOT) {\n-    FOR_ALL_AOT_HEAPS(heap) {\n-      (*heap)->oops_do(f);\n-    }\n-  }\n-}\n-\n-void AOTLoader::metadata_do(MetadataClosure* f) {\n-  if (UseAOT) {\n-    FOR_ALL_AOT_HEAPS(heap) {\n-      (*heap)->metadata_do(f);\n-    }\n-  }\n-}\n-\n-void AOTLoader::mark_evol_dependent_methods(InstanceKlass* dependee) {\n-  if (UseAOT) {\n-    FOR_ALL_AOT_HEAPS(heap) {\n-      (*heap)->mark_evol_dependent_methods(dependee);\n-    }\n-  }\n-}\n-\n-\/**\n- * List of core modules for which we search for shared libraries.\n- *\/\n-static const char* modules[] = {\n-  \"java.base\",\n-  \"java.logging\",\n-  \"jdk.compiler\",\n-  \"jdk.internal.vm.ci\",\n-  \"jdk.internal.vm.compiler\"\n-};\n-\n-void AOTLoader::initialize() {\n-  TraceTime timer(\"AOT initialization\", TRACETIME_LOG(Info, aot, startuptime));\n-\n-  if (FLAG_IS_DEFAULT(UseAOT) && AOTLibrary != NULL) {\n-    \/\/ Don't need to set UseAOT on command line when AOTLibrary is specified\n-    FLAG_SET_DEFAULT(UseAOT, true);\n-  }\n-  if (UseAOT) {\n-    \/\/ EagerInitialization is not compatible with AOT\n-    if (EagerInitialization) {\n-      if (PrintAOT) {\n-        warning(\"EagerInitialization is not compatible with AOT (switching AOT off)\");\n-      }\n-      FLAG_SET_DEFAULT(UseAOT, false);\n-      return;\n-    }\n-\n-    if (JvmtiExport::can_post_breakpoint()) {\n-      if (PrintAOT) {\n-        warning(\"JVMTI capability to post breakpoint is not compatible with AOT (switching AOT off)\");\n-      }\n-      FLAG_SET_DEFAULT(UseAOT, false);\n-      return;\n-    }\n-\n-    \/\/ -Xint is not compatible with AOT\n-    if (Arguments::is_interpreter_only()) {\n-      if (PrintAOT) {\n-        warning(\"-Xint is not compatible with AOT (switching AOT off)\");\n-      }\n-      FLAG_SET_DEFAULT(UseAOT, false);\n-      return;\n-    }\n-\n-#ifdef _WINDOWS\n-    const char pathSep = ';';\n-#else\n-    const char pathSep = ':';\n-#endif\n-\n-    \/\/ Scan the AOTLibrary option.\n-    if (AOTLibrary != NULL) {\n-      const int len = (int)strlen(AOTLibrary);\n-      char* cp  = NEW_C_HEAP_ARRAY(char, len+1, mtCode);\n-      memcpy(cp, AOTLibrary, len);\n-      cp[len] = '\\0';\n-      char* end = cp + len;\n-      while (cp < end) {\n-        const char* name = cp;\n-        while ((*cp) != '\\0' && (*cp) != '\\n' && (*cp) != ',' && (*cp) != pathSep) cp++;\n-        cp[0] = '\\0';  \/\/ Terminate name\n-        cp++;\n-        load_library(name, true);\n-      }\n-    }\n-\n-    \/\/ Load well-know AOT libraries from Java installation directory.\n-    const char* home = Arguments::get_java_home();\n-    const char* file_separator = os::file_separator();\n-\n-    for (int i = 0; i < (int) (sizeof(modules) \/ sizeof(const char*)); i++) {\n-      char library[JVM_MAXPATHLEN];\n-      jio_snprintf(library, sizeof(library), \"%s%slib%slib%s%s%s%s\", home, file_separator, file_separator, modules[i], UseCompressedOops ? \"-coop\" : \"\", UseG1GC ? \"\" : \"-nong1\", os::dll_file_extension());\n-      load_library(library, false);\n-    }\n-  }\n-}\n-\n-void AOTLoader::universe_init() {\n-  if (UseAOT && libraries_count() > 0) {\n-    \/\/ Shifts are static values which initialized by 0 until java heap initialization.\n-    \/\/ AOT libs are loaded before heap initialized so shift values are not set.\n-    \/\/ It is okay since ObjectAlignmentInBytes flag which defines shifts value is set before AOT libs are loaded.\n-    \/\/ AOT sets shift values during heap and metaspace initialization.\n-    \/\/ Check shifts value to make sure thay did not change.\n-    if (UseCompressedOops && AOTLib::narrow_oop_shift_initialized()) {\n-      int oop_shift = CompressedOops::shift();\n-      FOR_ALL_AOT_LIBRARIES(lib) {\n-        (*lib)->verify_flag((*lib)->config()->_narrowOopShift, oop_shift, \"CompressedOops::shift\");\n-      }\n-      if (UseCompressedClassPointers) { \/\/ It is set only if UseCompressedOops is set\n-        int klass_shift = CompressedKlassPointers::shift();\n-        FOR_ALL_AOT_LIBRARIES(lib) {\n-          (*lib)->verify_flag((*lib)->config()->_narrowKlassShift, klass_shift, \"CompressedKlassPointers::shift\");\n-        }\n-      }\n-    }\n-    \/\/ Create heaps for all valid libraries\n-    FOR_ALL_AOT_LIBRARIES(lib) {\n-      if ((*lib)->is_valid()) {\n-        AOTCodeHeap* heap = new AOTCodeHeap(*lib);\n-        {\n-          MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-          add_heap(heap);\n-          CodeCache::add_heap(heap);\n-        }\n-      } else {\n-        \/\/ Unload invalid libraries\n-        os::dll_unload((*lib)->dl_handle());\n-      }\n-    }\n-  }\n-  if (heaps_count() == 0) {\n-    if (FLAG_IS_DEFAULT(UseAOT)) {\n-      FLAG_SET_DEFAULT(UseAOT, false);\n-    }\n-  }\n-}\n-\n-\/\/ Set shift value for compressed oops and classes based on first AOT library config.\n-\/\/ AOTLoader::universe_init(), which is called later, will check the shift value again to make sure nobody change it.\n-\/\/ This code is not executed during CDS dump because it runs in Interpreter mode and AOT is disabled in this mode.\n-\n-void AOTLoader::set_narrow_oop_shift() {\n-  \/\/ This method is called from Universe::initialize_heap().\n-  if (UseAOT && libraries_count() > 0 &&\n-      UseCompressedOops && AOTLib::narrow_oop_shift_initialized()) {\n-    if (CompressedOops::shift() == 0) {\n-      \/\/ 0 is valid shift value for small heap but we can safely increase it\n-      \/\/ at this point when nobody used it yet.\n-      CompressedOops::set_shift(AOTLib::narrow_oop_shift());\n-    }\n-  }\n-}\n-\n-void AOTLoader::set_narrow_klass_shift() {\n-  \/\/ This method is called from Metaspace::set_narrow_klass_base_and_shift().\n-  if (UseAOT && libraries_count() > 0 &&\n-      UseCompressedOops && AOTLib::narrow_oop_shift_initialized() &&\n-      UseCompressedClassPointers) {\n-    if (CompressedKlassPointers::shift() == 0) {\n-      CompressedKlassPointers::set_shift(AOTLib::narrow_klass_shift());\n-    }\n-  }\n-}\n-\n-void AOTLoader::load_library(const char* name, bool exit_on_error) {\n-  \/\/ Skip library if a library with the same name is already loaded.\n-  const int file_separator = *os::file_separator();\n-  const char* start = strrchr(name, file_separator);\n-  const char* new_name = (start == NULL) ? name : (start + 1);\n-  FOR_ALL_AOT_LIBRARIES(lib) {\n-    const char* lib_name = (*lib)->name();\n-    start = strrchr(lib_name, file_separator);\n-    const char* old_name = (start == NULL) ? lib_name : (start + 1);\n-    if (strcmp(old_name, new_name) == 0) {\n-      if (PrintAOT) {\n-        warning(\"AOT library %s is already loaded as %s.\", name, lib_name);\n-      }\n-      return;\n-    }\n-  }\n-  char ebuf[1024];\n-  void* handle = os::dll_load(name, ebuf, sizeof ebuf);\n-  if (handle == NULL) {\n-    if (exit_on_error) {\n-      tty->print_cr(\"error opening file: %s\", ebuf);\n-      vm_exit(1);\n-    }\n-    return;\n-  }\n-  const int dso_id = libraries_count() + 1;\n-  AOTLib* lib = new AOTLib(handle, name, dso_id);\n-  if (!lib->is_valid()) {\n-    delete lib;\n-    os::dll_unload(handle);\n-    return;\n-  }\n-  add_library(lib);\n-}\n-\n-#ifndef PRODUCT\n-void AOTLoader::print_statistics() {\n-  { ttyLocker ttyl;\n-    tty->print_cr(\"--- AOT Statistics ---\");\n-    tty->print_cr(\"AOT libraries loaded: %d\", heaps_count());\n-    AOTCodeHeap::print_statistics();\n-  }\n-}\n-#endif\n-\n-\n-bool AOTLoader::reconcile_dynamic_invoke(InstanceKlass* holder, int index, Method* adapter_method, Klass* appendix_klass) {\n-  if (!UseAOT) {\n-    return true;\n-  }\n-  JavaThread* thread = JavaThread::current();\n-  ResourceMark rm(thread);\n-  RegisterMap map(thread, false);\n-  frame caller_frame = thread->last_frame().sender(&map); \/\/ Skip stub\n-  CodeBlob* caller_cb = caller_frame.cb();\n-  guarantee(caller_cb != NULL && caller_cb->is_compiled(), \"must be called from compiled method\");\n-  CompiledMethod* cm = caller_cb->as_compiled_method();\n-\n-  if (!cm->is_aot()) {\n-    return true;\n-  }\n-  AOTCompiledMethod* aot = (AOTCompiledMethod*)cm;\n-\n-  AOTCodeHeap* caller_heap = NULL;\n-  FOR_ALL_AOT_HEAPS(heap) {\n-    if ((*heap)->contains_blob(aot)) {\n-      caller_heap = *heap;\n-      break;\n-    }\n-  }\n-  guarantee(caller_heap != NULL, \"CodeHeap not found\");\n-  bool success = caller_heap->reconcile_dynamic_invoke(aot, holder, index, adapter_method, appendix_klass);\n-  vmassert(success || thread->last_frame().sender(&map).is_deoptimized_frame(), \"caller not deoptimized on failure\");\n-  return success;\n-}\n-\n-\n-\/\/ This should be called very early during startup before any of the AOTed methods that use boxes can deoptimize.\n-\/\/ Deoptimization machinery expects the caches to be present and populated.\n-void AOTLoader::initialize_box_caches(TRAPS) {\n-  if (!UseAOT || libraries_count() == 0) {\n-    return;\n-  }\n-  TraceTime timer(\"AOT initialization of box caches\", TRACETIME_LOG(Info, aot, startuptime));\n-  JVMCI::ensure_box_caches_initialized(CHECK);\n-}\n","filename":"src\/hotspot\/share\/aot\/aotLoader.cpp","additions":0,"deletions":334,"binary":false,"changes":334,"status":"deleted"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_AOT_AOTLOADER_HPP\n-#define SHARE_AOT_AOTLOADER_HPP\n-\n-#include \"runtime\/globals_extension.hpp\"\n-#include \"runtime\/handles.hpp\"\n-\n-class AOTCodeHeap;\n-class AOTCompiledMethod;\n-class AOTLib;\n-class CodeBlob;\n-template <class T> class GrowableArray;\n-class InstanceKlass;\n-class JavaThread;\n-class Metadata;\n-class OopClosure;\n-\n-class AOTLoader {\n-private:\n-#if INCLUDE_AOT\n-  static GrowableArray<AOTCodeHeap*>* _heaps;\n-  static GrowableArray<AOTLib*>* _libraries;\n-#endif\n-  static void load_library(const char* name, bool exit_on_error);\n-\n-public:\n-#if INCLUDE_AOT\n-  static GrowableArray<AOTCodeHeap*>* heaps();\n-  static GrowableArray<AOTLib*>* libraries();\n-  static int heaps_count();\n-  static int libraries_count();\n-  static void add_heap(AOTCodeHeap *heap);\n-  static void add_library(AOTLib *lib);\n-#endif\n-  static void initialize() NOT_AOT({ FLAG_SET_ERGO(UseAOT, false); });\n-\n-  static void universe_init() NOT_AOT_RETURN;\n-  static void set_narrow_oop_shift() NOT_AOT_RETURN;\n-  static void set_narrow_klass_shift() NOT_AOT_RETURN;\n-  static void load_for_klass(InstanceKlass* ik, Thread* thread) NOT_AOT_RETURN;\n-  static uint64_t get_saved_fingerprint(InstanceKlass* ik) NOT_AOT({ return 0; });\n-  static void oops_do(OopClosure* f) NOT_AOT_RETURN;\n-  static void metadata_do(MetadataClosure* f) NOT_AOT_RETURN;\n-  static void mark_evol_dependent_methods(InstanceKlass* dependee) NOT_AOT_RETURN;\n-  static void initialize_box_caches(TRAPS) NOT_AOT_RETURN;\n-\n-  NOT_PRODUCT( static void print_statistics() NOT_AOT_RETURN; )\n-\n-  static bool reconcile_dynamic_invoke(InstanceKlass* holder, int index, Method* adapter_method, Klass *appendix_klass) NOT_AOT({ return true; });\n-};\n-\n-#endif \/\/ SHARE_AOT_AOTLOADER_HPP\n","filename":"src\/hotspot\/share\/aot\/aotLoader.hpp","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_AOT_AOTLOADER_INLINE_HPP\n-#define SHARE_AOT_AOTLOADER_INLINE_HPP\n-\n-#include \"aot\/aotLoader.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-\n-#if INCLUDE_AOT\n-GrowableArray<AOTCodeHeap*>* AOTLoader::heaps() { return _heaps; }\n-GrowableArray<AOTLib*>* AOTLoader::libraries() { return _libraries; }\n-int AOTLoader::heaps_count() { return heaps()->length(); }\n-int AOTLoader::libraries_count() { return libraries()->length(); }\n-void AOTLoader::add_heap(AOTCodeHeap *heap) { heaps()->append(heap); }\n-void AOTLoader::add_library(AOTLib *lib) { libraries()->append(lib); }\n-#endif\n-\n-#endif \/\/ SHARE_AOT_AOTLOADER_INLINE_HPP\n","filename":"src\/hotspot\/share\/aot\/aotLoader.inline.hpp","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#include \"aot\/compiledIC_aot.hpp\"\n-\n-bool CompiledPltStaticCall::is_call_to_interpreted() const {\n-  \/\/ It is a call to interpreted, if it calls to a stub. Hence, the destination\n-  \/\/ must be in the stub part of the nmethod that contains the call\n-  return destination() == _call->plt_c2i_stub();\n-}\n-\n-address CompiledPltStaticCall::find_stub() {\n-  \/\/ It is static NativePltCall. Return c2i stub address.\n-  return _call->plt_c2i_stub();\n-}\n","filename":"src\/hotspot\/share\/aot\/compiledIC_aot.cpp","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_AOT_COMPILEDIC_AOT_HPP\n-#define SHARE_AOT_COMPILEDIC_AOT_HPP\n-\n-#include \"code\/compiledIC.hpp\"\n-#include \"code\/nativeInst.hpp\"\n-#include \"interpreter\/linkResolver.hpp\"\n-#include \"oops\/compiledICHolder.hpp\"\n-\n-class CompiledPltStaticCall: public CompiledStaticCall {\n-  friend class CompiledIC;\n-  friend class PltNativeCallWrapper;\n-\n-  \/\/ Also used by CompiledIC\n-  void set_to_interpreted(const methodHandle& callee, address entry);\n-\n-  address instruction_address() const { return _call->instruction_address(); }\n-  void set_destination_mt_safe(address dest) { _call->set_destination_mt_safe(dest); }\n-\n-  NativePltCall* _call;\n-\n-  CompiledPltStaticCall(NativePltCall* call) : _call(call) {}\n-\n- public:\n-\n-  inline static CompiledPltStaticCall* before(address return_addr) {\n-    CompiledPltStaticCall* st = new CompiledPltStaticCall(nativePltCall_before(return_addr));\n-    st->verify();\n-    return st;\n-  }\n-\n-  static inline CompiledPltStaticCall* at(address native_call) {\n-    CompiledPltStaticCall* st = new CompiledPltStaticCall(nativePltCall_at(native_call));\n-    st->verify();\n-    return st;\n-  }\n-\n-  static inline CompiledPltStaticCall* at(Relocation* call_site) {\n-    return at(call_site->addr());\n-  }\n-\n-  \/\/ Delegation\n-  address destination() const { return _call->destination(); }\n-\n-  virtual bool is_call_to_interpreted() const;\n-\n-  \/\/ Stub support\n-  address find_stub();\n-  static void set_stub_to_clean(static_stub_Relocation* static_stub);\n-\n-  \/\/ Misc.\n-  void print()  PRODUCT_RETURN;\n-  void verify() PRODUCT_RETURN;\n-\n- protected:\n-  virtual address resolve_call_stub() const { return _call->plt_resolve_call(); }\n-  virtual void set_to_far(const methodHandle& callee, address entry) { set_to_compiled(entry); }\n-  virtual const char* name() const { return \"CompiledPltStaticCall\"; }\n-};\n-\n-#endif \/\/ SHARE_AOT_COMPILEDIC_AOT_HPP\n","filename":"src\/hotspot\/share\/aot\/compiledIC_aot.hpp","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -409,4 +409,0 @@\n-#if INCLUDE_AOT\n-  bool         _immutable_PIC;\n-#endif\n-\n@@ -429,3 +425,0 @@\n-#if INCLUDE_AOT\n-    _immutable_PIC   = false;\n-#endif\n@@ -678,7 +671,0 @@\n-#if INCLUDE_AOT\n-  \/\/ True if this is a code buffer used for immutable PIC, i.e. AOT\n-  \/\/ compilation.\n-  bool immutable_PIC() { return _immutable_PIC; }\n-  void set_immutable_PIC(bool pic) { _immutable_PIC = pic; }\n-#endif\n-\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -269,1 +269,1 @@\n-    return CompilerConfig::is_c1_only_no_aot_or_jvmci() && !is_profiling() &&\n+    return CompilerConfig::is_c1_only_no_jvmci() && !is_profiling() &&\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -484,1 +484,1 @@\n-  if (UseSSE < 2 && !CompilerConfig::is_c1_only_no_aot_or_jvmci()) {\n+  if (UseSSE < 2 && !CompilerConfig::is_c1_only_no_jvmci()) {\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -262,5 +262,1 @@\n-    if (UseAOT) {\n-      return _call_stub_size + _call_aot_stub_size;\n-    } else {\n-      return _call_stub_size;\n-    }\n+    return _call_stub_size;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -464,1 +464,1 @@\n-  if ((!CompilerConfig::is_c1_only_no_aot_or_jvmci() && need_resolve) || !obj->is_loaded() || PatchALot) {\n+  if ((!CompilerConfig::is_c1_only_no_jvmci() && need_resolve) || !obj->is_loaded() || PatchALot) {\n@@ -664,1 +664,1 @@\n-  } else if (PrintNotLoaded && (!CompilerConfig::is_c1_only_no_aot_or_jvmci() && new_instance->is_unresolved())) {\n+  } else if (PrintNotLoaded && (!CompilerConfig::is_c1_only_no_jvmci() && new_instance->is_unresolved())) {\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"aot\/aotLoader.hpp\"\n@@ -5357,19 +5356,0 @@\n-\n-  if (ik->should_store_fingerprint()) {\n-    ik->store_fingerprint(_stream->compute_fingerprint());\n-  }\n-\n-  ik->set_has_passed_fingerprint_check(false);\n-  if (UseAOT && ik->supers_have_passed_fingerprint_checks()) {\n-    uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);\n-    uint64_t fp = ik->has_stored_fingerprint() ? ik->get_stored_fingerprint() : _stream->compute_fingerprint();\n-    if (aot_fp != 0 && aot_fp == fp) {\n-      \/\/ This class matches with a class saved in an AOT library\n-      ik->set_has_passed_fingerprint_check(true);\n-    } else {\n-      ResourceMark rm;\n-      log_info(class, fingerprint)(\"%s :  expected = \" PTR64_FORMAT \" actual = \" PTR64_FORMAT,\n-                                 ik->external_name(), aot_fp, _stream->compute_fingerprint());\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -78,9 +78,0 @@\n-\n-uint64_t ClassFileStream::compute_fingerprint() const {\n-  int classfile_size = length();\n-  int classfile_crc = ClassLoader::crc32(0, (const char*)buffer(), length());\n-  uint64_t fingerprint = (uint64_t(classfile_size) << 32) | uint64_t(uint32_t(classfile_crc));\n-  assert(fingerprint != 0, \"must not be zero\");\n-\n-  return fingerprint;\n-}\n","filename":"src\/hotspot\/share\/classfile\/classFileStream.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"aot\/aotLoader.hpp\"\n@@ -1233,15 +1232,0 @@\n-\n-  ik->set_has_passed_fingerprint_check(false);\n-  if (UseAOT && ik->supers_have_passed_fingerprint_checks()) {\n-    uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);\n-    uint64_t cds_fp = ik->get_stored_fingerprint();\n-    if (aot_fp != 0 && aot_fp == cds_fp) {\n-      \/\/ This class matches with a class saved in an AOT library\n-      ik->set_has_passed_fingerprint_check(true);\n-    } else {\n-      if (log_is_enabled(Info, class, fingerprint)) {\n-        ResourceMark rm;\n-        log_info(class, fingerprint)(\"%s :  expected = \" PTR64_FORMAT \" actual = \" PTR64_FORMAT, ik->external_name(), aot_fp, cds_fp);\n-      }\n-    }\n-  }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,1 @@\n-    AOT                 = 4,    \/\/ AOT methods\n-    NumTypes            = 5     \/\/ Number of CodeBlobTypes\n+    NumTypes            = 4     \/\/ Number of CodeBlobTypes\n@@ -54,4 +53,0 @@\n-\/\/   AOTCompiledMethod   : AOT Compiled Java methods - Not in the CodeCache!\n-\/\/                         AOTCompiledMethod objects are allocated in the C-Heap, the code they\n-\/\/                         point to is allocated in the AOTCodeHeap which is in the C-Heap as\n-\/\/                         well (i.e. it's the memory where the shared library was loaded to)\n@@ -71,1 +66,1 @@\n-\/\/ Layout (all except AOTCompiledMethod) : continuous in the CodeCache\n+\/\/ Layout : continuous in the CodeCache\n@@ -77,5 +72,0 @@\n-\/\/\n-\/\/ Layout (AOTCompiledMethod) : in the C-Heap\n-\/\/   - header -\\\n-\/\/     ...     |\n-\/\/   - code  <-\/\n@@ -145,1 +135,0 @@\n-  virtual bool is_aot() const                         { return false; }\n@@ -246,1 +235,0 @@\n-    assert(!is_aot(), \"invalid on aot\");\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"aot\/aotLoader.hpp\"\n@@ -685,1 +684,0 @@\n-  AOTLoader::metadata_do(f);\n@@ -974,5 +972,0 @@\n-void AOTLoader_init() {\n-  \/\/ Load AOT libraries and add AOT code heaps.\n-  AOTLoader::initialize();\n-}\n-\n@@ -1040,9 +1033,0 @@\n-bool CodeCache::is_far_target(address target) {\n-#if INCLUDE_AOT\n-  return NativeCall::is_far_call(_low_bound,  target) ||\n-         NativeCall::is_far_call(_high_bound, target);\n-#else\n-  return false;\n-#endif\n-}\n-\n@@ -1098,5 +1082,0 @@\n-\n-  \/\/ Mark dependent AOT nmethods, which are only found via the class redefined.\n-  \/\/ TODO: add dependencies to aotCompiledMethod's metadata section so this isn't\n-  \/\/ needed.\n-  AOTLoader::mark_evol_dependent_methods(dependee);\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -208,3 +208,0 @@\n-  \/\/ Have to use far call instructions to call this pc.\n-  static bool is_far_target(address pc);\n-\n@@ -232,1 +229,0 @@\n-    AOT_ONLY( result = result || type == CodeBlobType::AOT; )\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -428,1 +428,1 @@\n-  if (info.to_interpreter() || info.to_aot()) {\n+  if (info.to_interpreter()) {\n@@ -442,1 +442,1 @@\n-         tty->print_cr (\"IC@\" INTPTR_FORMAT \": monomorphic to %s: %s\",\n+         tty->print_cr (\"IC@\" INTPTR_FORMAT \": monomorphic to interpreter: %s\",\n@@ -444,1 +444,0 @@\n-           (info.to_aot() ? \"aot\" : \"interpreter\"),\n@@ -544,3 +543,2 @@\n-  bool far_c2a = entry != NULL && caller_is_nmethod && method_code->is_far_code();\n-  if (entry != NULL && !far_c2a) {\n-    \/\/ Call to near compiled code (nmethod or aot).\n+  if (entry != NULL) {\n+    \/\/ Call to near compiled code.\n@@ -550,7 +548,2 @@\n-      if (far_c2a) {\n-        \/\/ Call to aot code from nmethod.\n-        info.set_aot_entry(entry, method());\n-      } else {\n-        \/\/ Use stub entry\n-        info.set_interpreter_entry(method()->get_c2i_entry(), method());\n-      }\n+      \/\/ Use stub entry\n+      info.set_interpreter_entry(method()->get_c2i_entry(), method());\n@@ -617,7 +610,0 @@\n-bool CompiledDirectStaticCall::is_call_to_far() const {\n-  \/\/ It is a call to aot method, if it calls to a stub. Hence, the destination\n-  \/\/ must be in the stub part of the nmethod that contains the call\n-  CodeBlob* desc = CodeCache::find_blob(instruction_address());\n-  return desc->as_compiled_method()->stub_contains(destination());\n-}\n-\n@@ -648,5 +634,0 @@\n-#if INCLUDE_AOT\n-  } else if (info._to_aot) {\n-    \/\/ Call to far code\n-    set_to_far(info.callee(), info.entry());\n-#endif\n@@ -664,6 +645,0 @@\n-    if (caller_is_nmethod && m_code->is_far_code()) {\n-      \/\/ Call to far aot code from nmethod.\n-      info._to_aot = true;\n-    } else {\n-      info._to_aot = false;\n-    }\n@@ -681,1 +656,1 @@\n-address CompiledDirectStaticCall::find_stub_for(address instruction, bool is_aot) {\n+address CompiledDirectStaticCall::find_stub_for(address instruction) {\n@@ -688,1 +663,1 @@\n-          return iter.static_call_reloc()->static_stub(is_aot);\n+          return iter.static_call_reloc()->static_stub();\n@@ -692,1 +667,1 @@\n-          return iter.opt_virtual_call_reloc()->static_stub(is_aot);\n+          return iter.opt_virtual_call_reloc()->static_stub();\n@@ -703,2 +678,2 @@\n-address CompiledDirectStaticCall::find_stub(bool is_aot) {\n-  return CompiledDirectStaticCall::find_stub_for(instruction_address(), is_aot);\n+address CompiledDirectStaticCall::find_stub() {\n+  return CompiledDirectStaticCall::find_stub_for(instruction_address());\n@@ -737,2 +712,0 @@\n-  } else if (is_call_to_far()) {\n-    tty->print(\"far\");\n@@ -741,0 +714,2 @@\n+  } else {\n+    tty->print(\"unknown\");\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":13,"deletions":38,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,0 @@\n-  bool    _to_aot;             \/\/ Call it to aot code\n@@ -102,1 +101,0 @@\n-  bool          to_aot() const { return _to_aot; }\n@@ -108,1 +106,0 @@\n-    _to_aot = false;\n@@ -118,11 +115,0 @@\n-    _to_aot = false;\n-    _is_icholder = false;\n-    _is_optimized = true;\n-    _release_icholder = false;\n-  }\n-\n-  void set_aot_entry(address entry, Method* method) {\n-    _entry      = entry;\n-    _cached_value = (void*)method;\n-    _to_interpreter = false;\n-    _to_aot = true;\n@@ -138,1 +124,0 @@\n-    _to_aot = false;\n@@ -145,1 +130,1 @@\n-                    _is_optimized(false), _to_interpreter(false), _to_aot(false), _release_icholder(false) {\n+                    _is_optimized(false), _to_interpreter(false), _release_icholder(false) {\n@@ -344,1 +329,0 @@\n-  bool         _to_aot;         \/\/ call to aot method (otherwise compiled)\n@@ -361,3 +345,0 @@\n-  static void emit_to_aot_stub(CodeBuffer &cbuf, address mark = NULL);\n-  static int to_aot_stub_size();\n-  static int reloc_to_aot_stub();\n@@ -389,3 +370,0 @@\n-#if INCLUDE_AOT\n-  virtual void set_to_far(const methodHandle& callee, address entry) = 0;\n-#endif\n@@ -408,3 +386,0 @@\n-#if INCLUDE_AOT\n-  void set_to_far(const methodHandle& callee, address entry);\n-#endif\n@@ -440,1 +415,0 @@\n-  bool is_call_to_far() const;\n@@ -443,2 +417,2 @@\n-  static address find_stub_for(address instruction, bool is_aot);\n-  address find_stub(bool is_aot);\n+  static address find_stub_for(address instruction);\n+  address find_stub();\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":4,"deletions":30,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-    _is_far_code                = false;\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -155,3 +155,0 @@\n-  bool _is_far_code; \/\/ Code is far from CodeCache.\n-                     \/\/ Have to use far call instructions to call it from code in CodeCache.\n-\n@@ -337,2 +334,0 @@\n-  bool is_far_code() const { return _is_far_code; }\n-\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -441,1 +441,0 @@\n-  _is_far_code                = false; \/\/ nmethods are located in CodeCache\n@@ -2311,1 +2310,0 @@\n-  if (cm->is_aot()) return;  \/\/ FIXME: Revisit once _lock_count is added to aot_method\n@@ -2319,1 +2317,0 @@\n-  if (cm->is_aot()) return;  \/\/ FIXME: Revisit once _lock_count is added to aot_method\n@@ -2467,1 +2464,1 @@\n-        stub = iter.opt_virtual_call_reloc()->static_stub(false);\n+        stub = iter.opt_virtual_call_reloc()->static_stub();\n@@ -2471,1 +2468,1 @@\n-        stub = iter.static_call_reloc()->static_stub(false);\n+        stub = iter.static_call_reloc()->static_stub();\n@@ -3411,12 +3408,0 @@\n-#if INCLUDE_AOT\n-    if (UseAOT) {\n-      CodeBlob* callee = CodeCache::find_blob(dest);\n-      CompiledMethod* cm = callee->as_compiled_method_or_null();\n-      if (cm != NULL && cm->is_far_code()) {\n-        \/\/ Temporary fix, see JDK-8143106\n-        CompiledDirectStaticCall* csc = CompiledDirectStaticCall::at(instruction_address());\n-        csc->set_to_far(methodHandle(Thread::current(), cm->method()), dest);\n-        return;\n-      }\n-    }\n-#endif\n@@ -3428,5 +3413,0 @@\n-#if INCLUDE_AOT\n-    if (info.to_aot()) {\n-      csc->set_to_far(method, info.entry());\n-    } else\n-#endif\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":2,"deletions":22,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -418,2 +418,1 @@\n-  jint is_aot = _is_aot ? 1 : 0;\n-  p = pack_2_ints_to(p, scaled_offset(_static_call, insts->start()), is_aot);\n+  p = pack_1_int_to(p, scaled_offset(_static_call, insts->start()));\n@@ -425,3 +424,1 @@\n-  jint offset;\n-  jint is_aot;\n-  unpack_2_ints(offset, is_aot);\n+  jint offset = unpack_1_int();\n@@ -429,1 +426,0 @@\n-  _is_aot = (is_aot == 1);\n@@ -651,1 +647,1 @@\n-address opt_virtual_call_Relocation::static_stub(bool is_aot) {\n+address opt_virtual_call_Relocation::static_stub() {\n@@ -658,1 +654,1 @@\n-      if (stub_reloc->static_call() == static_call_addr && stub_reloc->is_aot() == is_aot) {\n+      if (stub_reloc->static_call() == static_call_addr) {\n@@ -692,1 +688,1 @@\n-address static_call_Relocation::static_stub(bool is_aot) {\n+address static_call_Relocation::static_stub() {\n@@ -699,1 +695,1 @@\n-      if (stub_reloc->static_call() == static_call_addr && stub_reloc->is_aot() == is_aot) {\n+      if (stub_reloc->static_call() == static_call_addr) {\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1069,1 +1069,1 @@\n-  address static_stub(bool is_aot);\n+  address static_stub();\n@@ -1101,1 +1101,1 @@\n-  address static_stub(bool is_aot);\n+  address static_stub();\n@@ -1106,1 +1106,1 @@\n-  static RelocationHolder spec(address static_call, bool is_aot = false) {\n+  static RelocationHolder spec(address static_call) {\n@@ -1108,1 +1108,1 @@\n-    new(rh) static_stub_Relocation(static_call, is_aot);\n+    new(rh) static_stub_Relocation(static_call);\n@@ -1114,1 +1114,0 @@\n-  bool _is_aot;          \/\/ trampoline to aot code\n@@ -1116,1 +1115,1 @@\n-  static_stub_Relocation(address static_call, bool is_aot)\n+  static_stub_Relocation(address static_call)\n@@ -1118,1 +1117,1 @@\n-      _static_call(static_call), _is_aot(is_aot) { }\n+      _static_call(static_call) { }\n@@ -1127,1 +1126,0 @@\n-  bool is_aot() { return _is_aot; }\n","filename":"src\/hotspot\/share\/code\/relocInfo.hpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -238,2 +238,0 @@\n-    case CompLevel_aot:\n-      return b >= Tier3AOTBackEdgeThreshold * scale;\n@@ -253,4 +251,0 @@\n-    case CompLevel_aot: {\n-      k = CompilationModeFlag::disable_intermediate() ? 1 : CompilationPolicy::threshold_scale(CompLevel_full_profile, Tier3LoadFeedback);\n-      break;\n-    }\n@@ -282,3 +276,0 @@\n-    case CompLevel_aot:\n-      return (i >= Tier3AOTInvocationThreshold * scale) ||\n-             (i >= Tier3AOTMinInvocationThreshold * scale && i + b >= Tier3AOTCompileThreshold * scale);\n@@ -300,4 +291,0 @@\n-    case CompLevel_aot: {\n-      k = CompilationModeFlag::disable_intermediate() ? 1 : CompilationPolicy::threshold_scale(CompLevel_full_profile, Tier3LoadFeedback);\n-      break;\n-    }\n@@ -523,2 +510,2 @@\n-  \/\/ AOT and interpreter levels are always valid.\n-  if (level == CompLevel_aot || level == CompLevel_none) {\n+  \/\/ Interpreter level is always valid.\n+  if (level == CompLevel_none) {\n@@ -762,1 +749,1 @@\n-      \/\/ Happens when we switch from AOT to interpreter to profile.\n+      \/\/ Happens when we switch to interpreter to profile.\n@@ -776,18 +763,0 @@\n-  if (level == CompLevel_aot) {\n-    if (mh->has_aot_code()) {\n-      if (PrintTieredEvents) {\n-        print_event(COMPILE, mh(), mh(), bci, level);\n-      }\n-      MutexLocker ml(Compile_lock);\n-      NoSafepointVerifier nsv;\n-      if (mh->has_aot_code() && mh->code() != mh->aot_code()) {\n-        mh->aot_code()->make_entrant();\n-        if (mh->has_compiled_code()) {\n-          mh->code()->make_not_entrant();\n-        }\n-        MutexLocker pl(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n-        Method::set_code(mh, mh->aot_code());\n-      }\n-    }\n-    return;\n-  }\n@@ -1041,10 +1010,0 @@\n-      case CompLevel_aot:\n-        \/\/ If we were at full profile level, would we switch to full opt?\n-        if (common<Predicate>(method, CompLevel_full_profile, disable_feedback) == CompLevel_full_optimization) {\n-          next_level = CompLevel_full_optimization;\n-        } else if (disable_feedback || (CompileBroker::queue_size(CompLevel_full_optimization) <=\n-                                        Tier3DelayOff * compiler_count(CompLevel_full_optimization) &&\n-                                       Predicate::apply(i, b, cur_level, method))) {\n-            next_level = CompilationModeFlag::disable_intermediate() ? CompLevel_none : CompLevel_full_profile;\n-        }\n-        break;\n@@ -1155,20 +1114,0 @@\n-bool CompilationPolicy::maybe_switch_to_aot(const methodHandle& mh, CompLevel cur_level, CompLevel next_level, Thread* thread) {\n-  if (UseAOT) {\n-    if (cur_level == CompLevel_full_profile || cur_level == CompLevel_none) {\n-      \/\/ If the current level is full profile or interpreter and we're switching to any other level,\n-      \/\/ activate the AOT code back first so that we won't waste time overprofiling.\n-      compile(mh, InvocationEntryBci, CompLevel_aot, thread);\n-      \/\/ Fall through for JIT compilation.\n-    }\n-    if (next_level == CompLevel_limited_profile && cur_level != CompLevel_aot && mh->has_aot_code()) {\n-      \/\/ If the next level is limited profile, use the aot code (if there is any),\n-      \/\/ since it's essentially the same thing.\n-      compile(mh, InvocationEntryBci, CompLevel_aot, thread);\n-      \/\/ Not need to JIT, we're done.\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-\n@@ -1183,4 +1122,0 @@\n-    if (maybe_switch_to_aot(mh, level, next_level, THREAD)) {\n-      \/\/ No JITting necessary\n-      return;\n-    }\n@@ -1217,8 +1152,1 @@\n-      if (level == CompLevel_aot) {\n-        \/\/ Recompile the enclosing method to prevent infinite OSRs. Stay at AOT level while it's compiling.\n-        if (max_osr_level != CompLevel_none && !CompileBroker::compilation_is_in_queue(mh)) {\n-          CompLevel enclosing_level = limit_level(CompLevel_full_profile);\n-          compile(mh, InvocationEntryBci, enclosing_level, THREAD);\n-        }\n-      } else {\n-        \/\/ Current loop event level is not AOT\n+      {\n@@ -1256,1 +1184,1 @@\n-          if (!maybe_switch_to_aot(mh, cur_level, next_level, THREAD) && !CompileBroker::compilation_is_in_queue(mh)) {\n+          if (!CompileBroker::compilation_is_in_queue(mh)) {\n@@ -1265,1 +1193,1 @@\n-        if (!maybe_switch_to_aot(mh, cur_level, next_level, THREAD) && !CompileBroker::compilation_is_in_queue(mh)) {\n+        if (!CompileBroker::compilation_is_in_queue(mh)) {\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":6,"deletions":78,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -213,2 +213,0 @@\n-  static bool maybe_switch_to_aot(const methodHandle& mh, CompLevel cur_level, CompLevel next_level, Thread* thread);\n-\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -169,3 +169,0 @@\n-#endif\n-#if INCLUDE_AOT\n-  FLAG_SET_ERGO(UseAOT, false);\n@@ -207,1 +204,0 @@\n-         !FLAG_IS_DEFAULT(UseAOT)            ||\n@@ -278,8 +274,0 @@\n-#if INCLUDE_AOT\n-      if (UseAOT) {\n-        FLAG_SET_ERGO(Tier3AOTInvocationThreshold, threshold);\n-        FLAG_SET_ERGO(Tier3AOTMinInvocationThreshold, threshold);\n-        FLAG_SET_ERGO(Tier3AOTCompileThreshold, threshold);\n-        FLAG_SET_ERGO(Tier3AOTBackEdgeThreshold, CompilerConfig::is_c1_only() ? osr_threshold : osr_profile_threshold);\n-      }\n-#endif\n@@ -334,17 +322,0 @@\n-#if INCLUDE_AOT\n-    if (UseAOT) {\n-      if (FLAG_IS_DEFAULT(Tier3AOTInvocationThreshold)) {\n-        FLAG_SET_DEFAULT(Tier3AOTInvocationThreshold, 200);\n-      }\n-      if (FLAG_IS_DEFAULT(Tier3AOTMinInvocationThreshold)) {\n-        FLAG_SET_DEFAULT(Tier3AOTMinInvocationThreshold, 100);\n-      }\n-      if (FLAG_IS_DEFAULT(Tier3AOTCompileThreshold)) {\n-        FLAG_SET_DEFAULT(Tier3AOTCompileThreshold, 2000);\n-      }\n-      if (FLAG_IS_DEFAULT(Tier3AOTBackEdgeThreshold)) {\n-        FLAG_SET_DEFAULT(Tier3AOTBackEdgeThreshold, 2000);\n-      }\n-    }\n-#endif\n-\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -58,3 +58,2 @@\n-  CompLevel_any               = -2,        \/\/ Used for querying the state\n-  CompLevel_all               = -2,        \/\/ Used for changing the state\n-  CompLevel_aot               = -1,\n+  CompLevel_any               = -1,        \/\/ Used for querying the state\n+  CompLevel_all               = -1,        \/\/ Used for changing the state\n@@ -141,1 +140,0 @@\n-  constexpr static bool has_aot()    { return AOT_ONLY(true) NOT_AOT(false);                }\n@@ -143,1 +141,0 @@\n-  static bool is_aot()               { return AOT_ONLY(has_aot() && UseAOT) NOT_AOT(false);                 }\n@@ -150,1 +147,1 @@\n-  \/\/ deliberately ignore the fact that there may also be AOT methods and methods installed\n+  \/\/ deliberately ignore the fact that there may also be methods installed\n@@ -152,1 +149,1 @@\n-  \/\/ to check for those (using is_jvmci() and is_aot()) in situations where it matters.\n+  \/\/ to check for those (using is_jvmci()) in situations where it matters.\n@@ -166,1 +163,1 @@\n-  static bool is_c1_or_interpreter_only_no_aot_or_jvmci() {\n+  static bool is_c1_or_interpreter_only_no_jvmci() {\n@@ -168,1 +165,1 @@\n-    return !is_aot() && !is_jvmci() && (is_interpreter_only() || is_c1_only());\n+    return !is_jvmci() && (is_interpreter_only() || is_c1_only());\n@@ -171,2 +168,2 @@\n-  static bool is_c1_only_no_aot_or_jvmci() {\n-    return is_c1_only() && !is_aot() && !is_jvmci();\n+  static bool is_c1_only_no_jvmci() {\n+    return is_c1_only() && !is_jvmci();\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.hpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -193,27 +193,0 @@\n-  product(intx, Tier3AOTInvocationThreshold, 10000,                         \\\n-          \"Compile if number of method invocations crosses this \"           \\\n-          \"threshold if coming from AOT;\"                                   \\\n-          \"with CompilationMode=high-only|high-only-quick-internal)\"        \\\n-          \"determines when to transition from AOT to interpreter\")          \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3AOTMinInvocationThreshold, 1000,                       \\\n-          \"Minimum invocation to compile at tier 3 if coming from AOT;\"     \\\n-          \"with CompilationMode=high-only|high-only-quick-internal)\"        \\\n-          \"determines when to transition from AOT to interpreter\")          \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3AOTCompileThreshold, 15000,                            \\\n-          \"Threshold at which tier 3 compilation is invoked (invocation \"   \\\n-          \"minimum must be satisfied) if coming from AOT;\"                  \\\n-          \"with CompilationMode=high-only|high-only-quick-internal)\"        \\\n-          \"determines when to transition from AOT to interpreter\")          \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3AOTBackEdgeThreshold,  120000,                         \\\n-          \"Back edge threshold at which tier 3 OSR compilation is invoked \" \\\n-          \"if coming from AOT;\"                                             \\\n-          \"with CompilationMode=high-only|high-only-quick-internal)\"        \\\n-          \"determines when to transition from AOT to interpreter\")          \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/compiler\/compiler_globals.hpp","additions":0,"deletions":27,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -885,17 +885,3 @@\n-  if (cb->is_aot()) {\n-    env.output()->print(\"A \");\n-    if (cb->is_compiled()) {\n-      CompiledMethod* cm = (CompiledMethod*)cb;\n-      env.output()->print(\"%d \",cm->compile_id());\n-      cm->method()->method_holder()->name()->print_symbol_on(env.output());\n-      env.output()->print(\".\");\n-      cm->method()->name()->print_symbol_on(env.output());\n-      cm->method()->signature()->print_symbol_on(env.output());\n-    } else {\n-      env.output()->print_cr(\"%s\", cb->name());\n-    }\n-  } else {\n-    env.output()->print(\"Decoding CodeBlob\");\n-    if (cb->name() != NULL) {\n-      env.output()->print(\", name: %s,\", cb->name());\n-    }\n+  env.output()->print(\"Decoding CodeBlob\");\n+  if (cb->name() != NULL) {\n+    env.output()->print(\", name: %s,\", cb->name());\n","filename":"src\/hotspot\/share\/compiler\/disassembler.cpp","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-  AOT_ONLY(_gc_par_phases[AOTCodeRoots] = new WorkerDataArray<double>(\"AOTCodeRoots\", \"AOT Root Scan (ms):\", max_gc_threads);)\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-    AOT_ONLY(AOTCodeRoots COMMA)\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"aot\/aotLoader.hpp\"\n@@ -189,9 +188,0 @@\n-#if INCLUDE_AOT\n-  if (_process_strong_tasks.try_claim_task(G1RP_PS_aot_oops_do)) {\n-    if (UseAOT) {\n-      G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::AOTCodeRoots, worker_id);\n-      AOTLoader::oops_do(strong_roots);\n-    }\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RootProcessor.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,0 @@\n-    AOT_ONLY(G1RP_PS_aot_oops_do COMMA)\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RootProcessor.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"aot\/aotLoader.hpp\"\n@@ -2013,1 +2012,0 @@\n-      AOTLoader::oops_do(&mark_and_push_closure);\n@@ -2223,1 +2221,0 @@\n-    PSAdjustSubTask_aot,\n@@ -2267,3 +2264,0 @@\n-    if (_sub_tasks.try_claim_task(PSAdjustSubTask_aot)) {\n-      AOT_ONLY(AOTLoader::oops_do(&adjust);)\n-    }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"aot\/aotLoader.hpp\"\n@@ -106,1 +105,0 @@\n-        AOTLoader::oops_do(&roots_closure);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"aot\/aotLoader.hpp\"\n@@ -812,5 +811,0 @@\n-#if INCLUDE_AOT\n-  if (UseAOT) {\n-    AOTLoader::oops_do(strong_roots);\n-  }\n-#endif\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -160,8 +160,0 @@\n-  \/\/ AOT is not supported yet\n-  if (UseAOT) {\n-    if (!FLAG_IS_DEFAULT(UseAOT)) {\n-      warning(\"Shenandoah does not support AOT at this moment, disabling UseAOT\");\n-    }\n-    FLAG_SET_DEFAULT(UseAOT, false);\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"aot\/aotLoader.hpp\"\n@@ -75,1 +74,0 @@\n-  AOTLoader::oops_do(this);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/rootSetClosure.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"aot\/aotLoader.hpp\"\n@@ -103,1 +102,0 @@\n-  bool do_aot_loader_roots();\n@@ -152,7 +150,0 @@\n-bool ReferenceToRootClosure::do_aot_loader_roots() {\n-  assert(!complete(), \"invariant\");\n-  ReferenceLocateClosure rcl(_callback, OldObjectRoot::_aot, OldObjectRoot::_type_undetermined, NULL);\n-  AOTLoader::oops_do(&rcl);\n-  return rcl.complete();\n-}\n-\n@@ -174,5 +165,0 @@\n-  if (do_aot_loader_roots()) {\n-   _complete = true;\n-    return true;\n-  }\n-\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/rootResolver.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -60,2 +60,0 @@\n-    case _aot:\n-      return \"AOT\";\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/utilities\/rootType.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-    _aot,\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/utilities\/rootType.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,280 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"aot\/aotLoader.hpp\"\n-#include \"classfile\/stringTable.hpp\"\n-#include \"classfile\/symbolTable.hpp\"\n-#include \"classfile\/systemDictionary.hpp\"\n-#include \"classfile\/vmSymbols.hpp\"\n-#include \"compiler\/compilationPolicy.hpp\"\n-#include \"interpreter\/linkResolver.hpp\"\n-#include \"jvmci\/compilerRuntime.hpp\"\n-#include \"oops\/cpCache.inline.hpp\"\n-#include \"oops\/klass.inline.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"runtime\/deoptimization.hpp\"\n-#include \"runtime\/frame.inline.hpp\"\n-#include \"runtime\/handles.inline.hpp\"\n-#include \"runtime\/interfaceSupport.inline.hpp\"\n-#include \"runtime\/vframe.inline.hpp\"\n-#include \"utilities\/sizes.hpp\"\n-\n-\/\/ Resolve and allocate String\n-JRT_BLOCK_ENTRY(void, CompilerRuntime::resolve_string_by_symbol(JavaThread *thread, void* string_result, const char* name))\n-  JRT_BLOCK\n-    oop str = *(oop*)string_result; \/\/ Is it resolved already?\n-    if (str == NULL) { \/\/ Do resolution\n-      \/\/ First 2 bytes of name contains length (number of bytes).\n-      int len = Bytes::get_Java_u2((address)name);\n-      name += 2;\n-      TempNewSymbol sym = SymbolTable::new_symbol(name, len);\n-      str = StringTable::intern(sym, CHECK);\n-      assert(java_lang_String::is_instance(str), \"must be string\");\n-      *(oop*)string_result = str; \/\/ Store result\n-    }\n-    assert(str != NULL, \"Should be allocated!\");\n-    thread->set_vm_result(str);\n-  JRT_BLOCK_END\n-JRT_END\n-\n-\n-\n-Klass* CompilerRuntime::resolve_klass_helper(JavaThread *thread, const char* name, int len, TRAPS) {\n-  ResourceMark rm(THREAD);\n-  \/\/ last java frame on stack (which includes native call frames)\n-  RegisterMap cbl_map(thread, false);\n-  \/\/ Skip stub\n-  frame caller_frame = thread->last_frame().sender(&cbl_map);\n-  CodeBlob* caller_cb = caller_frame.cb();\n-  guarantee(caller_cb != NULL && caller_cb->is_compiled(), \"must be called from compiled method\");\n-  CompiledMethod* caller_nm = caller_cb->as_compiled_method_or_null();\n-  methodHandle caller(THREAD, caller_nm->method());\n-\n-  \/\/ Use class loader of aot method.\n-  Handle loader(THREAD, caller->method_holder()->class_loader());\n-  Handle protection_domain(THREAD, caller->method_holder()->protection_domain());\n-\n-  TempNewSymbol sym = SymbolTable::new_symbol(name, len);\n-  if (sym != NULL && Signature::has_envelope(sym)) {\n-    \/\/ Ignore wrapping L and ;\n-    sym = Signature::strip_envelope(sym);\n-  }\n-  if (sym == NULL) {\n-    return NULL;\n-  }\n-  Klass* k = SystemDictionary::resolve_or_fail(sym, loader, protection_domain, true, CHECK_NULL);\n-\n-  return k;\n-}\n-\n-\/\/ Resolve Klass\n-JRT_BLOCK_ENTRY(Klass*, CompilerRuntime::resolve_klass_by_symbol(JavaThread *thread, Klass** klass_result, const char* name))\n-  Klass* k = NULL;\n-  JRT_BLOCK\n-    k = *klass_result; \/\/ Is it resolved already?\n-    if (k == NULL) { \/\/ Do resolution\n-      \/\/ First 2 bytes of name contains length (number of bytes).\n-      int len = Bytes::get_Java_u2((address)name);\n-      name += 2;\n-      k = CompilerRuntime::resolve_klass_helper(thread, name, len, CHECK_NULL);\n-      *klass_result = k; \/\/ Store result\n-    }\n-  JRT_BLOCK_END\n-  assert(k != NULL, \" Should be loaded!\");\n-  return k;\n-JRT_END\n-\n-\n-Method* CompilerRuntime::resolve_method_helper(Klass* klass, const char* method_name, int method_name_len,\n-                                                               const char* signature_name, int signature_name_len) {\n-  Method* m = NULL;\n-  TempNewSymbol name_symbol = SymbolTable::probe(method_name, method_name_len);\n-  TempNewSymbol signature_symbol = SymbolTable::probe(signature_name, signature_name_len);\n-  if (name_symbol != NULL && signature_symbol != NULL) {\n-    if (name_symbol == vmSymbols::object_initializer_name() ||\n-        name_symbol == vmSymbols::class_initializer_name()) {\n-      \/\/ Never search superclasses for constructors\n-      if (klass->is_instance_klass()) {\n-        m = InstanceKlass::cast(klass)->find_method(name_symbol, signature_symbol);\n-      }\n-    } else {\n-      m = klass->lookup_method(name_symbol, signature_symbol);\n-      if (m == NULL && klass->is_instance_klass()) {\n-        m = InstanceKlass::cast(klass)->lookup_method_in_ordered_interfaces(name_symbol, signature_symbol);\n-      }\n-    }\n-  }\n-  return m;\n-}\n-\n-JRT_BLOCK_ENTRY(void, CompilerRuntime::resolve_dynamic_invoke(JavaThread *thread, oop* appendix_result))\n-  JRT_BLOCK\n-  {\n-    ResourceMark rm(THREAD);\n-    vframeStream vfst(thread, true);  \/\/ Do not skip and javaCalls\n-    assert(!vfst.at_end(), \"Java frame must exist\");\n-    methodHandle caller(THREAD, vfst.method());\n-    InstanceKlass* holder = caller->method_holder();\n-    int bci = vfst.bci();\n-    Bytecode_invoke bytecode(caller, bci);\n-    int index = bytecode.index();\n-\n-    \/\/ Make sure it's resolved first\n-    CallInfo callInfo;\n-    constantPoolHandle cp(THREAD, holder->constants());\n-    ConstantPoolCacheEntry* cp_cache_entry = cp->cache()->entry_at(cp->decode_cpcache_index(index, true));\n-    Bytecodes::Code invoke_code = bytecode.invoke_code();\n-    if (!cp_cache_entry->is_resolved(invoke_code)) {\n-        LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, invoke_code, CHECK);\n-        if (bytecode.is_invokedynamic()) {\n-            cp_cache_entry->set_dynamic_call(cp, callInfo);\n-        } else {\n-            cp_cache_entry->set_method_handle(cp, callInfo);\n-        }\n-        vmassert(cp_cache_entry->is_resolved(invoke_code), \"sanity\");\n-    }\n-\n-    Handle appendix(THREAD, cp_cache_entry->appendix_if_resolved(cp));\n-    Klass *appendix_klass = appendix.is_null() ? NULL : appendix->klass();\n-\n-    methodHandle adapter_method(THREAD, cp_cache_entry->f1_as_method());\n-    InstanceKlass *adapter_klass = adapter_method->method_holder();\n-\n-    if (appendix_klass != NULL && appendix_klass->is_instance_klass()) {\n-        vmassert(InstanceKlass::cast(appendix_klass)->is_initialized(), \"sanity\");\n-    }\n-    if (!adapter_klass->is_initialized()) {\n-        \/\/ Force initialization of adapter class\n-        adapter_klass->initialize(CHECK);\n-        \/\/ Double-check that it was really initialized,\n-        \/\/ because we could be doing a recursive call\n-        \/\/ from inside <clinit>.\n-    }\n-\n-    int cpi = cp_cache_entry->constant_pool_index();\n-    if (!AOTLoader::reconcile_dynamic_invoke(holder, cpi, adapter_method(),\n-      appendix_klass)) {\n-      return;\n-    }\n-\n-    *appendix_result = appendix();\n-    thread->set_vm_result(appendix());\n-  }\n-  JRT_BLOCK_END\n-JRT_END\n-\n-JRT_BLOCK_ENTRY(MethodCounters*, CompilerRuntime::resolve_method_by_symbol_and_load_counters(JavaThread *thread, MethodCounters** counters_result, Klass* klass, const char* data))\n-  MethodCounters* c = *counters_result; \/\/ Is it resolved already?\n-  JRT_BLOCK\n-     if (c == NULL) { \/\/ Do resolution\n-       \/\/ Get method name and its length\n-       int method_name_len = Bytes::get_Java_u2((address)data);\n-       data += sizeof(u2);\n-       const char* method_name = data;\n-       data += method_name_len;\n-\n-       \/\/ Get signature and its length\n-       int signature_name_len = Bytes::get_Java_u2((address)data);\n-       data += sizeof(u2);\n-       const char* signature_name = data;\n-\n-       assert(klass != NULL, \"Klass parameter must not be null\");\n-       Method* m = resolve_method_helper(klass, method_name, method_name_len, signature_name, signature_name_len);\n-       assert(m != NULL, \"Method must resolve successfully\");\n-\n-       \/\/ Create method counters immediately to avoid check at runtime.\n-       c = m->get_method_counters(thread);\n-       if (c == NULL) {\n-         THROW_MSG_NULL(vmSymbols::java_lang_OutOfMemoryError(), \"Cannot allocate method counters\");\n-       }\n-\n-       *counters_result = c;\n-     }\n-  JRT_BLOCK_END\n-  return c;\n-JRT_END\n-\n-\/\/ Resolve and initialize Klass\n-JRT_BLOCK_ENTRY(Klass*, CompilerRuntime::initialize_klass_by_symbol(JavaThread *thread, Klass** klass_result, const char* name))\n-  Klass* k = NULL;\n-  JRT_BLOCK\n-    k = klass_result[0]; \/\/ Is it initialized already?\n-    if (k == NULL) { \/\/ Do initialized\n-      k = klass_result[1]; \/\/ Is it resolved already?\n-      if (k == NULL) { \/\/ Do resolution\n-        \/\/ First 2 bytes of name contains length (number of bytes).\n-        int len = Bytes::get_Java_u2((address)name);\n-        const char *cname = name + 2;\n-        k = CompilerRuntime::resolve_klass_helper(thread,  cname, len, CHECK_NULL);\n-        klass_result[1] = k; \/\/ Store resolved result\n-      }\n-      Klass* k0 = klass_result[0]; \/\/ Is it initialized already?\n-      if (k0 == NULL && k != NULL && k->is_instance_klass()) {\n-        \/\/ Force initialization of instance class\n-        InstanceKlass::cast(k)->initialize(CHECK_NULL);\n-        \/\/ Double-check that it was really initialized,\n-        \/\/ because we could be doing a recursive call\n-        \/\/ from inside <clinit>.\n-        if (InstanceKlass::cast(k)->is_initialized()) {\n-          klass_result[0] = k; \/\/ Store initialized result\n-        }\n-      }\n-    }\n-  JRT_BLOCK_END\n-  assert(k != NULL, \" Should be loaded!\");\n-  return k;\n-JRT_END\n-\n-\n-JRT_BLOCK_ENTRY(void, CompilerRuntime::invocation_event(JavaThread *thread, MethodCounters* counters))\n-  JRT_BLOCK\n-    methodHandle mh(THREAD, counters->method());\n-    RegisterMap map(thread, false);\n-    \/\/ Compute the enclosing method\n-    frame fr = thread->last_frame().sender(&map);\n-    CompiledMethod* cm = fr.cb()->as_compiled_method_or_null();\n-    assert(cm != NULL && cm->is_compiled(), \"Sanity check\");\n-    methodHandle emh(THREAD, cm->method());\n-    CompilationPolicy::event(emh, mh, InvocationEntryBci, InvocationEntryBci, CompLevel_aot, cm, THREAD);\n-  JRT_BLOCK_END\n-JRT_END\n-\n-JRT_BLOCK_ENTRY(void, CompilerRuntime::backedge_event(JavaThread *thread, MethodCounters* counters, int branch_bci, int target_bci))\n-  assert(branch_bci != InvocationEntryBci && target_bci != InvocationEntryBci, \"Wrong bci\");\n-  assert(target_bci <= branch_bci, \"Expected a back edge\");\n-  JRT_BLOCK\n-    methodHandle mh(THREAD, counters->method());\n-    RegisterMap map(thread, false);\n-\n-    \/\/ Compute the enclosing method\n-    frame fr = thread->last_frame().sender(&map);\n-    CompiledMethod* cm = fr.cb()->as_compiled_method_or_null();\n-    assert(cm != NULL && cm->is_compiled(), \"Sanity check\");\n-    methodHandle emh(THREAD, cm->method());\n-    nmethod* osr_nm = CompilationPolicy::event(emh, mh, branch_bci, target_bci, CompLevel_aot, cm, THREAD);\n-    if (osr_nm != NULL) {\n-      Deoptimization::deoptimize_frame(thread, fr.id());\n-    }\n-  JRT_BLOCK_END\n-JRT_END\n","filename":"src\/hotspot\/share\/jvmci\/compilerRuntime.cpp","additions":0,"deletions":280,"binary":false,"changes":280,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_JVMCI_COMPILERRUNTIME_HPP\n-#define SHARE_JVMCI_COMPILERRUNTIME_HPP\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"oops\/klass.hpp\"\n-#include \"oops\/method.hpp\"\n-#include \"utilities\/exceptions.hpp\"\n-\n-class CompilerRuntime : AllStatic {\n- public:\n-  \/\/ Resolves klass for aot compiled method.\n-  static Klass* resolve_klass_helper(JavaThread *thread, const char* name, int len, TRAPS);\n-  \/\/ Resolves method for aot compiled method.\n-  static Method* resolve_method_helper(Klass* klass, const char* method_name, int method_name_len,\n-                                       const char* signature_name, int signature_name_len);\n-  \/\/ Resolution methods for aot compiled code.\n-  static void resolve_string_by_symbol(JavaThread *thread, void* string_result, const char* name);\n-  static void resolve_dynamic_invoke(JavaThread *thread, oop* appendix_result);\n-\n-  static Klass* resolve_klass_by_symbol(JavaThread *thread, Klass** klass_result, const char* name);\n-  static Klass* initialize_klass_by_symbol(JavaThread *thread, Klass** klass_result, const char* name);\n-  static MethodCounters* resolve_method_by_symbol_and_load_counters(JavaThread *thread, MethodCounters** counters_result, Klass* klass_hint, const char* data);\n-  static void invocation_event(JavaThread *thread, MethodCounters* counters);\n-  static void backedge_event(JavaThread *thread, MethodCounters* counters, int branch_bci, int target_bci);\n-};\n-\n-#endif \/\/ SHARE_JVMCI_COMPILERRUNTIME_HPP\n","filename":"src\/hotspot\/share\/jvmci\/compilerRuntime.hpp","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,64 +174,0 @@\n-#if INCLUDE_AOT\n-AOTOopRecorder::AOTOopRecorder(CodeInstaller* code_inst, Arena* arena, bool deduplicate) : OopRecorder(arena, deduplicate) {\n-  _code_inst = code_inst;\n-  _meta_refs = new GrowableArray<jobject>();\n-}\n-\n-int AOTOopRecorder::nr_meta_refs() const {\n-  return _meta_refs->length();\n-}\n-\n-jobject AOTOopRecorder::meta_element(int pos) const {\n-  return _meta_refs->at(pos);\n-}\n-\n-int AOTOopRecorder::find_index(Metadata* h) {\n-  JavaThread* THREAD = JavaThread::current();\n-  JVMCIEnv* JVMCIENV = _code_inst->jvmci_env();\n-  int oldCount = metadata_count();\n-  int index =  this->OopRecorder::find_index(h);\n-  int newCount = metadata_count();\n-\n-  if (oldCount == newCount) {\n-    \/\/ found a match\n-    return index;\n-  }\n-\n-  vmassert(index + 1 == newCount, \"must be last\");\n-\n-  JVMCIKlassHandle klass(THREAD);\n-  JVMCIObject result;\n-  guarantee(h != NULL,\n-            \"If DebugInformationRecorder::describe_scope passes NULL oldCount == newCount must hold.\");\n-  if (h->is_klass()) {\n-    klass = (Klass*) h;\n-    result = JVMCIENV->get_jvmci_type(klass, JVMCI_CATCH);\n-  } else if (h->is_method()) {\n-    Method* method = (Method*) h;\n-    methodHandle mh(THREAD, method);\n-    result = JVMCIENV->get_jvmci_method(mh, JVMCI_CATCH);\n-  }\n-  jobject ref = JVMCIENV->get_jobject(result);\n-  record_meta_ref(ref, index);\n-\n-  return index;\n-}\n-\n-int AOTOopRecorder::find_index(jobject h) {\n-  if (h == NULL) {\n-    return 0;\n-  }\n-  oop javaMirror = JNIHandles::resolve(h);\n-  Klass* klass = java_lang_Class::as_Klass(javaMirror);\n-  return find_index(klass);\n-}\n-\n-void AOTOopRecorder::record_meta_ref(jobject o, int index) {\n-  assert(index > 0, \"must be 1..n\");\n-  index -= 1; \/\/ reduce by one to convert to array index\n-\n-  assert(index == _meta_refs->length(), \"must be last\");\n-  _meta_refs->append(o);\n-}\n-#endif \/\/ INCLUDE_AOT\n-\n@@ -540,63 +476,0 @@\n-#if INCLUDE_AOT\n-RelocBuffer::~RelocBuffer() {\n-  FREE_C_HEAP_ARRAY(char, _buffer);\n-}\n-\n-address RelocBuffer::begin() const {\n-  if (_buffer != NULL) {\n-    return (address) _buffer;\n-  }\n-  return (address) _static_buffer;\n-}\n-\n-void RelocBuffer::set_size(size_t bytes) {\n-  assert(bytes <= _size, \"can't grow in size!\");\n-  _size = bytes;\n-}\n-\n-void RelocBuffer::ensure_size(size_t bytes) {\n-  assert(_buffer == NULL, \"can only be used once\");\n-  assert(_size == 0, \"can only be used once\");\n-  if (bytes >= RelocBuffer::stack_size) {\n-    _buffer = NEW_C_HEAP_ARRAY(char, bytes, mtJVMCI);\n-  }\n-  _size = bytes;\n-}\n-\n-JVMCI::CodeInstallResult CodeInstaller::gather_metadata(JVMCIObject target, JVMCIObject compiled_code, CodeMetadata& metadata, JVMCI_TRAPS) {\n-  assert(JVMCIENV->is_hotspot(), \"AOT code is executed only in HotSpot mode\");\n-  CodeBuffer buffer(\"JVMCI Compiler CodeBuffer for Metadata\");\n-  AOTOopRecorder* recorder = new AOTOopRecorder(this, &_arena, true);\n-  initialize_dependencies(compiled_code, recorder, JVMCI_CHECK_OK);\n-\n-  metadata.set_oop_recorder(recorder);\n-\n-  \/\/ Get instructions and constants CodeSections early because we need it.\n-  _instructions = buffer.insts();\n-  _constants = buffer.consts();\n-  buffer.set_immutable_PIC(_immutable_pic_compilation);\n-\n-  initialize_fields(target, compiled_code, JVMCI_CHECK_OK);\n-  JVMCI::CodeInstallResult result = initialize_buffer(buffer, false, JVMCI_CHECK_OK);\n-  if (result != JVMCI::ok) {\n-    return result;\n-  }\n-\n-  _debug_recorder->pcs_size(); \/\/ create the sentinel record\n-\n-  assert(_debug_recorder->pcs_length() >= 2, \"must be at least 2\");\n-\n-  metadata.set_pc_desc(_debug_recorder->pcs(), _debug_recorder->pcs_length());\n-  metadata.set_scopes(_debug_recorder->stream()->buffer(), _debug_recorder->data_size());\n-  metadata.set_exception_table(&_exception_handler_table);\n-  metadata.set_implicit_exception_table(&_implicit_exception_table);\n-\n-  RelocBuffer* reloc_buffer = metadata.get_reloc_buffer();\n-\n-  reloc_buffer->ensure_size(buffer.total_relocation_size());\n-  size_t size = (size_t) buffer.copy_relocations_to(reloc_buffer->begin(), (CodeBuffer::csize_t) reloc_buffer->size(), true);\n-  reloc_buffer->set_size(size);\n-  return JVMCI::ok;\n-}\n-#endif \/\/ INCLUDE_AOT\n-\n@@ -621,3 +494,0 @@\n-#if INCLUDE_AOT\n-  buffer.set_immutable_PIC(_immutable_pic_compilation);\n-#endif\n@@ -743,1 +613,1 @@\n-  \/\/ Estimate the number of static and aot call stubs that might be emitted.\n+  \/\/ Estimate the number of static call stubs that might be emitted.\n@@ -745,1 +615,0 @@\n-  int aot_call_stubs = 0;\n@@ -773,9 +642,0 @@\n-#if INCLUDE_AOT\n-      if (UseAOT && jvmci_env()->isa_site_Call(site)) {\n-        JVMCIObject target = jvmci_env()-> get_site_Call_target(site);\n-        if (!jvmci_env()->isa_HotSpotForeignCallTarget(target)) {\n-          \/\/ Add far aot trampolines.\n-          aot_call_stubs++;\n-        }\n-      }\n-#endif\n@@ -786,3 +646,0 @@\n-#if INCLUDE_AOT\n-  size += aot_call_stubs * CompiledStaticCall::to_aot_stub_size();\n-#endif\n@@ -1294,4 +1151,0 @@\n-#if INCLUDE_AOT\n-    \/\/ Trampoline to far aot code.\n-    CompiledStaticCall::emit_to_aot_stub(buffer, _instructions->start() + pc_offset);\n-#endif\n@@ -1334,6 +1187,0 @@\n-#if INCLUDE_AOT\n-    } else if (jvmci_env()->isa_HotSpotSentinelConstant(constant)) {\n-      if (!_immutable_pic_compilation) {\n-        JVMCI_ERROR(\"sentinel constant not supported for normal compiles: %s\", jvmci_env()->klass_name(constant));\n-      }\n-#endif\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":2,"deletions":155,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,36 +33,0 @@\n-#if INCLUDE_AOT\n-class RelocBuffer : public StackObj {\n-  enum { stack_size = 1024 };\n-public:\n-  RelocBuffer() : _size(0), _buffer(0) {}\n-  ~RelocBuffer();\n-  void ensure_size(size_t bytes);\n-  void set_size(size_t bytes);\n-  address begin() const;\n-  size_t size() const { return _size; }\n-private:\n-  size_t _size;\n-  char _static_buffer[stack_size];\n-  char *_buffer;\n-};\n-\n-class CodeInstaller;\n-\n-class AOTOopRecorder : public OopRecorder {\n-public:\n-  AOTOopRecorder(CodeInstaller* code_inst, Arena* arena = NULL, bool deduplicate = false);\n-\n-  virtual int find_index(Metadata* h);\n-  virtual int find_index(jobject h);\n-  int nr_meta_refs() const;\n-  jobject meta_element(int pos) const;\n-\n-private:\n-  void record_meta_ref(jobject ref, int index);\n-\n-  GrowableArray<jobject>* _meta_refs;\n-\n-  CodeInstaller* _code_inst;\n-};\n-#endif \/\/ INCLUDE_AOT\n-\n@@ -81,5 +45,0 @@\n-#if INCLUDE_AOT\n-  RelocBuffer* get_reloc_buffer() { return &_reloc_buffer; }\n-  AOTOopRecorder* get_oop_recorder() { return _oop_recorder; }\n-#endif\n-\n@@ -100,6 +59,0 @@\n-#if INCLUDE_AOT\n-  void set_oop_recorder(AOTOopRecorder* recorder) {\n-    _oop_recorder = recorder;\n-  }\n-#endif\n-\n@@ -122,4 +75,0 @@\n-#if INCLUDE_AOT\n-  RelocBuffer _reloc_buffer;\n-  AOTOopRecorder* _oop_recorder;\n-#endif\n@@ -240,3 +189,0 @@\n-#if INCLUDE_AOT\n-  JVMCI::CodeInstallResult gather_metadata(JVMCIObject target, JVMCIObject compiled_code, CodeMetadata& metadata, JVMCI_TRAPS);\n-#endif\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.hpp","additions":1,"deletions":55,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-  assert(!CompilerConfig::is_c1_or_interpreter_only_no_aot_or_jvmci(), \"JVMCI is launched, it's not c1\/interpreter only mode\");\n+  assert(!CompilerConfig::is_c1_or_interpreter_only_no_jvmci(), \"JVMCI is launched, it's not c1\/interpreter only mode\");\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -890,77 +890,0 @@\n-#if INCLUDE_AOT\n-  HandleMark hm(THREAD);\n-  assert(JVMCIENV->is_hotspot(), \"AOT code is executed only in HotSpot mode\");\n-\n-  JVMCIObject target_handle = JVMCIENV->wrap(target);\n-  JVMCIObject compiled_code_handle = JVMCIENV->wrap(compiled_code);\n-  JVMCIObject metadata_handle = JVMCIENV->wrap(metadata);\n-\n-  CodeMetadata code_metadata;\n-\n-  CodeInstaller installer(JVMCIENV, true \/* immutable PIC compilation *\/);\n-  JVMCI::CodeInstallResult result = installer.gather_metadata(target_handle, compiled_code_handle, code_metadata, JVMCI_CHECK_0);\n-  if (result != JVMCI::ok) {\n-    return result;\n-  }\n-\n-  if (code_metadata.get_nr_pc_desc() > 0) {\n-    int size = sizeof(PcDesc) * code_metadata.get_nr_pc_desc();\n-    JVMCIPrimitiveArray array = JVMCIENV->new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));\n-    JVMCIENV->copy_bytes_from((jbyte*) code_metadata.get_pc_desc(), array, 0, size);\n-    HotSpotJVMCI::HotSpotMetaData::set_pcDescBytes(JVMCIENV, metadata_handle, array);\n-  }\n-\n-  if (code_metadata.get_scopes_size() > 0) {\n-    int size = code_metadata.get_scopes_size();\n-    JVMCIPrimitiveArray array = JVMCIENV->new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));\n-    JVMCIENV->copy_bytes_from((jbyte*) code_metadata.get_scopes_desc(), array, 0, size);\n-    HotSpotJVMCI::HotSpotMetaData::set_scopesDescBytes(JVMCIENV, metadata_handle, array);\n-  }\n-\n-  RelocBuffer* reloc_buffer = code_metadata.get_reloc_buffer();\n-  int size = (int) reloc_buffer->size();\n-  JVMCIPrimitiveArray array = JVMCIENV->new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));\n-  JVMCIENV->copy_bytes_from((jbyte*) reloc_buffer->begin(), array, 0, size);\n-  HotSpotJVMCI::HotSpotMetaData::set_relocBytes(JVMCIENV, metadata_handle, array);\n-\n-  const OopMapSet* oopMapSet = installer.oopMapSet();\n-  {\n-    ResourceMark mark;\n-    ImmutableOopMapBuilder builder(oopMapSet);\n-    int size = builder.heap_size();\n-    JVMCIPrimitiveArray array = JVMCIENV->new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));\n-    builder.generate_into((address) HotSpotJVMCI::resolve(array)->byte_at_addr(0));\n-    HotSpotJVMCI::HotSpotMetaData::set_oopMaps(JVMCIENV, metadata_handle, array);\n-  }\n-\n-  AOTOopRecorder* recorder = code_metadata.get_oop_recorder();\n-\n-  int nr_meta_refs = recorder->nr_meta_refs();\n-  JVMCIObjectArray metadataArray = JVMCIENV->new_Object_array(nr_meta_refs, JVMCI_CHECK_(JVMCI::cache_full));\n-  for (int i = 0; i < nr_meta_refs; ++i) {\n-    jobject element = recorder->meta_element(i);\n-    if (element == NULL) {\n-      return JVMCI::cache_full;\n-    }\n-    JVMCIENV->put_object_at(metadataArray, i, JVMCIENV->wrap(element));\n-  }\n-  HotSpotJVMCI::HotSpotMetaData::set_metadata(JVMCIENV, metadata_handle, metadataArray);\n-\n-  ExceptionHandlerTable* handler = code_metadata.get_exception_table();\n-  int table_size = handler->size_in_bytes();\n-  JVMCIPrimitiveArray exceptionArray = JVMCIENV->new_byteArray(table_size, JVMCI_CHECK_(JVMCI::cache_full));\n-  if (table_size > 0) {\n-    handler->copy_bytes_to((address) HotSpotJVMCI::resolve(exceptionArray)->byte_at_addr(0));\n-  }\n-  HotSpotJVMCI::HotSpotMetaData::set_exceptionBytes(JVMCIENV, metadata_handle, exceptionArray);\n-\n-  ImplicitExceptionTable* implicit = code_metadata.get_implicit_exception_table();\n-  int implicit_table_size = implicit->size_in_bytes();\n-  JVMCIPrimitiveArray implicitExceptionArray = JVMCIENV->new_byteArray(implicit_table_size, JVMCI_CHECK_(JVMCI::cache_full));\n-  if (implicit_table_size > 0) {\n-    implicit->copy_bytes_to((address) HotSpotJVMCI::resolve(implicitExceptionArray)->byte_at_addr(0), implicit_table_size);\n-  }\n-  HotSpotJVMCI::HotSpotMetaData::set_implicitExceptionBytes(JVMCIENV, metadata_handle, implicitExceptionArray);\n-\n-  return result;\n-#else\n@@ -968,1 +891,0 @@\n-#endif\n@@ -1620,8 +1542,0 @@\n-#if INCLUDE_AOT\n-  Klass *k = (Klass*) (address) metaspace_klass;\n-  if (k->is_instance_klass()) {\n-    return InstanceKlass::cast(k)->get_stored_fingerprint();\n-  } else {\n-    return 0;\n-  }\n-#else\n@@ -1629,1 +1543,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":0,"deletions":87,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_JVMCI_VMSTRUCTS_COMPILER_RUNTIME_HPP\n-#define SHARE_JVMCI_VMSTRUCTS_COMPILER_RUNTIME_HPP\n-\n-#if INCLUDE_AOT\n-#include \"jvmci\/compilerRuntime.hpp\"\n-\n-#define VM_ADDRESSES_COMPILER_RUNTIME(declare_address, declare_preprocessor_address, declare_function) \\\n-  declare_function(CompilerRuntime::resolve_dynamic_invoke)                       \\\n-  declare_function(CompilerRuntime::resolve_string_by_symbol)                     \\\n-  declare_function(CompilerRuntime::resolve_klass_by_symbol)                      \\\n-  declare_function(CompilerRuntime::resolve_method_by_symbol_and_load_counters)   \\\n-  declare_function(CompilerRuntime::initialize_klass_by_symbol)                   \\\n-  declare_function(CompilerRuntime::invocation_event)                             \\\n-  declare_function(CompilerRuntime::backedge_event)\n-\n-#else \/\/ INCLUDE_AOT\n-\n-#define VM_ADDRESSES_COMPILER_RUNTIME(declare_address, declare_preprocessor_address, declare_function)\n-\n-#endif \/\/ INCLUDE_AOT\n-\n-#endif \/\/ SHARE_JVMCI_VMSTRUCTS_COMPILER_RUNTIME_HPP\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_compiler_runtime.hpp","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"jvmci\/vmStructs_compiler_runtime.hpp\"\n@@ -236,1 +235,0 @@\n-  AOT_ONLY(nonstatic_field(MethodCounters,     _method,                                       Method*))                              \\\n@@ -923,3 +921,0 @@\n-  VM_ADDRESSES_COMPILER_RUNTIME(GENERATE_VM_ADDRESS_ENTRY,\n-               GENERATE_PREPROCESSOR_VM_ADDRESS_ENTRY,\n-               GENERATE_VM_FUNCTION_ENTRY)\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-  LOG_TAG(aot) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,9 +174,1 @@\n-    \/\/ AOT CodeBlobs (i.e. AOTCompiledMethod) objects aren't allocated in the AOTCodeHeap but on the C-Heap.\n-    \/\/ Only the code they are pointing to is located in the AOTCodeHeap. All other CodeBlobs are allocated\n-    \/\/ directly in their corresponding CodeHeap with their code appended to the actual C++ object.\n-    \/\/ So all CodeBlobs except AOTCompiledMethod are continuous in memory with their data and code while\n-    \/\/ AOTCompiledMethod and their code\/data is distributed in the C-Heap. This means we can use the\n-    \/\/ address of a CodeBlob object in order to locate it in its heap while we have to use the address\n-    \/\/ of the actual code an AOTCompiledMethod object is pointing to in order to locate it.\n-    \/\/ Notice that for an ordinary CodeBlob with code size zero, code_begin() may point beyond the object!\n-    const void* start = AOT_ONLY( (code_blob_type() == CodeBlobType::AOT) ? blob->code_begin() : ) (void*)blob;\n+    const void* start = (void*)blob;\n","filename":"src\/hotspot\/share\/memory\/heap.hpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"aot\/aotLoader.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"aot\/aotLoader.hpp\"\n@@ -756,2 +755,0 @@\n-  AOTLoader::universe_init();\n-\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -197,8 +197,0 @@\n-#if INCLUDE_AOT\n-  \/\/ Set boundaries for code section in AOT library.\n-  void set_low_boundary(char *p)  { _low_boundary = p; }\n-  void set_high_boundary(char *p) { _high_boundary = p; }\n-  void set_low(char *p)           { _low = p; }\n-  void set_high(char *p)          { _high = p; }\n-#endif\n-\n","filename":"src\/hotspot\/share\/memory\/virtualspace.hpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"aot\/aotLoader.hpp\"\n@@ -68,2 +67,0 @@\n-  AOTLoader::set_narrow_oop_shift();\n-\n@@ -257,3 +254,0 @@\n-\n-  \/\/ Note: this may modify our shift.\n-  AOTLoader::set_narrow_klass_shift();\n","filename":"src\/hotspot\/share\/oops\/compressedOops.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"aot\/aotLoader.hpp\"\n@@ -470,2 +469,1 @@\n-                                       parser.is_unsafe_anonymous(),\n-                                       should_store_fingerprint(is_hidden_or_anonymous));\n+                                       parser.is_unsafe_anonymous());\n@@ -1150,3 +1148,0 @@\n-  \/\/ Look for aot compiled methods for this klass, including class initializer.\n-  AOTLoader::load_for_klass(this, THREAD);\n-\n@@ -2376,71 +2371,0 @@\n-bool InstanceKlass::supers_have_passed_fingerprint_checks() {\n-  if (java_super() != NULL && !java_super()->has_passed_fingerprint_check()) {\n-    ResourceMark rm;\n-    log_trace(class, fingerprint)(\"%s : super %s not fingerprinted\", external_name(), java_super()->external_name());\n-    return false;\n-  }\n-\n-  Array<InstanceKlass*>* local_interfaces = this->local_interfaces();\n-  if (local_interfaces != NULL) {\n-    int length = local_interfaces->length();\n-    for (int i = 0; i < length; i++) {\n-      InstanceKlass* intf = local_interfaces->at(i);\n-      if (!intf->has_passed_fingerprint_check()) {\n-        ResourceMark rm;\n-        log_trace(class, fingerprint)(\"%s : interface %s not fingerprinted\", external_name(), intf->external_name());\n-        return false;\n-      }\n-    }\n-  }\n-\n-  return true;\n-}\n-\n-bool InstanceKlass::should_store_fingerprint(bool is_hidden_or_anonymous) {\n-#if INCLUDE_AOT\n-  \/\/ We store the fingerprint into the InstanceKlass only in the following 2 cases:\n-  if (CalculateClassFingerprint) {\n-    \/\/ (1) We are running AOT to generate a shared library.\n-    return true;\n-  }\n-  if (Arguments::is_dumping_archive()) {\n-    \/\/ (2) We are running -Xshare:dump or -XX:ArchiveClassesAtExit to create a shared archive\n-    return true;\n-  }\n-  if (UseAOT && is_hidden_or_anonymous) {\n-    \/\/ (3) We are using AOT code from a shared library and see a hidden or unsafe anonymous class\n-    return true;\n-  }\n-#endif\n-\n-  \/\/ In all other cases we might set the _misc_has_passed_fingerprint_check bit,\n-  \/\/ but do not store the 64-bit fingerprint to save space.\n-  return false;\n-}\n-\n-bool InstanceKlass::has_stored_fingerprint() const {\n-#if INCLUDE_AOT\n-  return should_store_fingerprint() || is_shared();\n-#else\n-  return false;\n-#endif\n-}\n-\n-uint64_t InstanceKlass::get_stored_fingerprint() const {\n-  address adr = adr_fingerprint();\n-  if (adr != NULL) {\n-    return (uint64_t)Bytes::get_native_u8(adr); \/\/ adr may not be 64-bit aligned\n-  }\n-  return 0;\n-}\n-\n-void InstanceKlass::store_fingerprint(uint64_t fingerprint) {\n-  address adr = adr_fingerprint();\n-  if (adr != NULL) {\n-    Bytes::put_native_u8(adr, (u8)fingerprint); \/\/ adr may not be 64-bit aligned\n-\n-    ResourceMark rm;\n-    log_trace(class, fingerprint)(\"stored as \" PTR64_FORMAT \" for class %s\", fingerprint, external_name());\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":77,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-\/\/    [EMBEDDED fingerprint       ] only if should_store_fingerprint()==true\n@@ -258,2 +257,1 @@\n-    _misc_has_passed_fingerprint_check        = 1 << 8,  \/\/ when this class was loaded, the fingerprint computed from its\n-                                                         \/\/ code source was found to be matching the value recorded by AOT.\n+    _unused                                   = 1 << 8,  \/\/\n@@ -790,18 +788,0 @@\n-  bool has_passed_fingerprint_check() const {\n-    return (_misc_flags & _misc_has_passed_fingerprint_check) != 0;\n-  }\n-  void set_has_passed_fingerprint_check(bool b) {\n-    if (b) {\n-      _misc_flags |= _misc_has_passed_fingerprint_check;\n-    } else {\n-      _misc_flags &= ~_misc_has_passed_fingerprint_check;\n-    }\n-  }\n-  bool supers_have_passed_fingerprint_checks();\n-\n-  static bool should_store_fingerprint(bool is_hidden_or_anonymous);\n-  bool should_store_fingerprint() const { return should_store_fingerprint(is_hidden() || is_unsafe_anonymous()); }\n-  bool has_stored_fingerprint() const;\n-  uint64_t get_stored_fingerprint() const;\n-  void store_fingerprint(uint64_t fingerprint);\n-\n@@ -1065,1 +1045,1 @@\n-                  bool is_interface, bool is_unsafe_anonymous, bool has_stored_fingerprint) {\n+                  bool is_interface, bool is_unsafe_anonymous) {\n@@ -1071,2 +1051,1 @@\n-           (is_unsafe_anonymous ? (int)sizeof(Klass*)\/wordSize : 0) +\n-           (has_stored_fingerprint ? (int)sizeof(uint64_t*)\/wordSize : 0));\n+           (is_unsafe_anonymous ? (int)sizeof(Klass*)\/wordSize : 0));\n@@ -1078,2 +1057,1 @@\n-                                               is_unsafe_anonymous(),\n-                                               has_stored_fingerprint());\n+                                               is_unsafe_anonymous());\n@@ -1092,1 +1070,0 @@\n-  inline address adr_fingerprint() const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":4,"deletions":27,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -98,18 +98,0 @@\n-inline address InstanceKlass::adr_fingerprint() const {\n-  if (has_stored_fingerprint()) {\n-    InstanceKlass** adr_host = adr_unsafe_anonymous_host();\n-    if (adr_host != NULL) {\n-      return (address)(adr_host + 1);\n-    }\n-\n-    InstanceKlass* volatile* adr_impl = adr_implementor();\n-    if (adr_impl != NULL) {\n-      return (address)(adr_impl + 1);\n-    }\n-\n-    return (address)end_of_nonstatic_oop_maps();\n-  } else {\n-    return NULL;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -117,4 +117,0 @@\n-#if INCLUDE_AOT\n-  CompiledMethod* _aot_code;\n-#endif\n-\n@@ -407,12 +403,0 @@\n-#if INCLUDE_AOT\n-  void set_aot_code(CompiledMethod* aot_code) {\n-    _aot_code = aot_code;\n-  }\n-\n-  CompiledMethod* aot_code() const {\n-    return _aot_code;\n-  }\n-#else\n-  CompiledMethod* aot_code() const { return NULL; }\n-#endif \/\/ INCLUDE_AOT\n-\n@@ -678,2 +662,0 @@\n-  bool has_aot_code() const                      { return aot_code() != NULL; }\n-\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -32,3 +32,0 @@\n-#if INCLUDE_AOT\n-  _method(mh()),\n-#endif\n@@ -82,3 +79,0 @@\n-#if INCLUDE_AOT\n-  it->push(&_method);\n-#endif\n","filename":"src\/hotspot\/share\/oops\/methodCounters.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,3 +42,0 @@\n-#if INCLUDE_AOT\n-  Method*           _method;                     \/\/ Back link to Method\n-#endif\n@@ -77,2 +74,0 @@\n-  AOT_ONLY(Method* method() const { return _method; })\n-\n","filename":"src\/hotspot\/share\/oops\/methodCounters.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-  assert(!CompilerConfig::is_c1_or_interpreter_only_no_aot_or_jvmci(), \"C2 compiler is launched, it's not c1\/interpreter only mode\");\n+  assert(!CompilerConfig::is_c1_or_interpreter_only_no_jvmci(), \"C2 compiler is launched, it's not c1\/interpreter only mode\");\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -575,4 +575,0 @@\n-#if INCLUDE_AOT\n-            stub_size  += CompiledStaticCall::to_aot_stub_size();\n-            reloc_size += CompiledStaticCall::reloc_to_aot_stub();\n-#endif\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"aot\/aotLoader.hpp\"\n@@ -4410,4 +4409,0 @@\n-  \/\/ Replace fingerprint data\n-  the_class->set_has_passed_fingerprint_check(scratch_class->has_passed_fingerprint_check());\n-  the_class->store_fingerprint(scratch_class->get_stored_fingerprint());\n-\n@@ -4416,6 +4411,0 @@\n-  if (!the_class->should_be_initialized()) {\n-    \/\/ Class was already initialized, so AOT has only seen the original version.\n-    \/\/ We need to let AOT look at it again.\n-    AOTLoader::load_for_klass(the_class, current);\n-  }\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2602,1 +2602,1 @@\n-            \/\/ Code generated by JIT and AOT compilers might not resolve constant\n+            \/\/ Code generated by JIT compilers might not resolve constant\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -117,3 +117,0 @@\n-#if INCLUDE_AOT\n-#include \"aot\/aotLoader.hpp\"\n-#endif \/\/ INCLUDE_AOT\n@@ -1450,3 +1447,0 @@\n-  if (code->is_aot()) {\n-    return -1;\n-  }\n@@ -1510,1 +1504,1 @@\n-  int insts_size = comp_level == CompLevel_aot ? code->code_end() - code->code_begin() : code->insts_size();\n+  int insts_size = code->insts_size();\n@@ -2252,8 +2246,0 @@\n-WB_ENTRY(jint, WB_AotLibrariesCount(JNIEnv* env, jobject o))\n-  jint result = 0;\n-#if INCLUDE_AOT\n-  result = (jint) AOTLoader::heaps_count();\n-#endif\n-  return result;\n-WB_END\n-\n@@ -2606,1 +2592,0 @@\n-  {CC\"aotLibrariesCount\", CC\"()I\",                    (void*)&WB_AotLibrariesCount },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -131,3 +131,1 @@\n-        if (UseAOT) {\n-          return \"mixed mode, aot, sharing\";\n-        } else if (CompilationModeFlag::quick_only()) {\n+        if (CompilationModeFlag::quick_only()) {\n@@ -139,3 +137,1 @@\n-        if (UseAOT) {\n-          return \"mixed mode, aot\";\n-        } else if (CompilationModeFlag::quick_only()) {\n+        if (CompilationModeFlag::quick_only()) {\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3128,15 +3128,0 @@\n-#if !INCLUDE_AOT\n-  UNSUPPORTED_OPTION(UseAOT);\n-  UNSUPPORTED_OPTION(PrintAOT);\n-  UNSUPPORTED_OPTION(UseAOTStrictLoading);\n-  UNSUPPORTED_OPTION_NULL(AOTLibrary);\n-\n-  UNSUPPORTED_OPTION_INIT(Tier3AOTInvocationThreshold, 0);\n-  UNSUPPORTED_OPTION_INIT(Tier3AOTMinInvocationThreshold, 0);\n-  UNSUPPORTED_OPTION_INIT(Tier3AOTCompileThreshold, 0);\n-  UNSUPPORTED_OPTION_INIT(Tier3AOTBackEdgeThreshold, 0);\n-#ifndef PRODUCT\n-  UNSUPPORTED_OPTION(PrintAOTStatistics);\n-#endif\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -899,3 +899,1 @@\n-\n-\n-#if COMPILER2_OR_JVMCI || INCLUDE_AOT\n+#if COMPILER2_OR_JVMCI\n@@ -1029,1 +1027,0 @@\n-#endif \/\/ COMPILER2_OR_JVMCI || INCLUDE_AOT\n@@ -1031,1 +1028,0 @@\n-#if COMPILER2_OR_JVMCI\n@@ -1048,1 +1044,0 @@\n-#if COMPILER2_OR_JVMCI || INCLUDE_AOT\n@@ -1057,1 +1052,1 @@\n-#endif \/\/ COMPILER2_OR_JVMCI || INCLUDE_AOT\n+\n@@ -1399,1 +1394,1 @@\n-#if COMPILER2_OR_JVMCI || INCLUDE_AOT\n+\n@@ -1404,1 +1399,0 @@\n-#endif \/\/ COMPILER2_OR_JVMCI || INCLUDE_AOT\n@@ -1977,1 +1971,1 @@\n-    if (nm->is_compiled_by_jvmci() && nm->is_nmethod()) { \/\/ Exclude AOTed methods\n+    if (nm->is_compiled_by_jvmci()) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -570,1 +570,0 @@\n-\/\/    A: Java frame (aot compiled)\n@@ -612,3 +611,1 @@\n-        if (cm->is_aot()) {\n-          st->print(\"A %d \", cm->compile_id());\n-        } else if (cm->is_nmethod()) {\n+        if (cm->is_nmethod()) {\n@@ -1211,1 +1208,1 @@\n-                    FormatBuffer<1024>(\"#%d nmethod \" INTPTR_FORMAT \" for method %s%s%s\", frame_no,\n+                    FormatBuffer<1024>(\"#%d nmethod \" INTPTR_FORMAT \" for method J %s%s\", frame_no,\n@@ -1213,1 +1210,0 @@\n-                                       (cm->is_aot() ? \"A \": \"J \"),\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1656,19 +1656,0 @@\n-  \/* AOT parameters *\/                                                      \\\n-  product(bool, UseAOT, false, EXPERIMENTAL,                                \\\n-          \"Use AOT compiled files\")                                         \\\n-                                                                            \\\n-  product(ccstrlist, AOTLibrary, NULL, EXPERIMENTAL,                        \\\n-          \"AOT library\")                                                    \\\n-                                                                            \\\n-  product(bool, PrintAOT, false, EXPERIMENTAL,                              \\\n-          \"Print used AOT klasses and methods\")                             \\\n-                                                                            \\\n-  notproduct(bool, PrintAOTStatistics, false,                               \\\n-          \"Print AOT statistics\")                                           \\\n-                                                                            \\\n-  product(bool, UseAOTStrictLoading, false, DIAGNOSTIC,                     \\\n-          \"Exit the VM if any of the AOT libraries has invalid config\")     \\\n-                                                                            \\\n-  product(bool, CalculateClassFingerprint, false,                           \\\n-          \"Calculate class fingerprint\")                                    \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-void AOTLoader_init();\n@@ -120,1 +119,0 @@\n-  AOTLoader_init();               \/\/ depends on VM_Version_init to adjust vm options\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"aot\/aotLoader.hpp\"\n@@ -275,4 +274,0 @@\n-  if (PrintAOTStatistics) {\n-    AOTLoader::print_statistics();\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"aot\/aotLoader.hpp\"\n@@ -1325,2 +1324,2 @@\n-            callee != NULL && (callee->is_compiled_by_jvmci() || callee->is_aot())) {\n-          return true; \/\/ skip patching for JVMCI or AOT code\n+            callee != NULL && callee->is_compiled_by_jvmci()) {\n+          return true; \/\/ skip patching for JVMCI\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"aot\/aotLoader.hpp\"\n@@ -3022,3 +3021,0 @@\n-\n-  \/\/ Eager box cache initialization only if AOT is on and any library is loaded.\n-  AOTLoader::initialize_box_caches(CHECK);\n@@ -3231,2 +3227,2 @@\n-  \/\/ to initially define it have been changed. This is needed for both CDS and\n-  \/\/ AOT, since UseSharedSpaces and UseAOT may be changed after java.vm.info\n+  \/\/ to initially define it have been changed. This is needed for both CDS\n+  \/\/ since UseSharedSpaces may be changed after java.vm.info\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -231,1 +231,1 @@\n-    assert(method->is_native() || nm->is_aot(), \"Expect a native method or precompiled method\");\n+    assert(method->is_native(), \"Expect a native method\");\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -303,1 +303,0 @@\n-  AOT_ONLY(nonstatic_field(MethodCounters,     _method,                                       Method*))                              \\\n@@ -2307,1 +2306,0 @@\n-  declare_constant(InstanceKlass::_misc_has_passed_fingerprint_check)     \\\n@@ -2498,1 +2496,0 @@\n-  declare_constant(CompLevel_aot)                                         \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -276,8 +276,0 @@\n-#ifndef INCLUDE_AOT\n-#define INCLUDE_AOT 1\n-#endif\n-\n-#if INCLUDE_AOT && !INCLUDE_JVMCI\n-#  error \"Must have JVMCI for AOT\"\n-#endif\n-\n@@ -294,10 +286,0 @@\n-#if INCLUDE_AOT\n-#define AOT_ONLY(code) code\n-#define NOT_AOT(code)\n-#define NOT_AOT_RETURN \/* next token must be ; *\/\n-#else\n-#define AOT_ONLY(code)\n-#define NOT_AOT(code) code\n-#define NOT_AOT_RETURN {}\n-#endif \/\/ INCLUDE_AOT\n-\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-    st->print_cr(\"Native frames: (J=compiled Java code, A=aot compiled Java code, j=interpreted, Vv=VM code, C=native code)\");\n+    st->print_cr(\"Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)\");\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,959 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat;\n-\n-import static org.graalvm.compiler.hotspot.meta.HotSpotAOTProfilingPlugin.Options.TieredAOT;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.DataOutputStream;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;\n-import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;\n-import org.graalvm.compiler.options.OptionValues;\n-import org.graalvm.compiler.serviceprovider.JavaVersionUtil;\n-\n-import jdk.tools.jaotc.binformat.Symbol.Binding;\n-import jdk.tools.jaotc.binformat.Symbol.Kind;\n-import jdk.tools.jaotc.binformat.elf.JELFRelocObject;\n-import jdk.tools.jaotc.binformat.macho.JMachORelocObject;\n-import jdk.tools.jaotc.binformat.pecoff.JPECoffRelocObject;\n-\n-\/**\n- * A format-agnostic container class that holds various components of a binary.\n- *\n- * <p>\n- * This class holds information necessary to create platform-specific binary containers such as\n- * ELFContainer for Linux or MachOContainer for Mac OS or PEContainer for MS Windows operating\n- * systems.\n- *\n- * <p>\n- * Method APIs provided by this class are used to construct and populate platform-independent\n- * contents of a binary as the first step to create a binary representation of code generated by a\n- * compiler backend such as Graal.\n- *\n- * <p>\n- * Methods to record and access code section contents, symbols and relocations are provided.\n- *\/\n-public final class BinaryContainer implements SymbolTable {\n-    private final OptionValues graalOptions;\n-\n-    private final int codeSegmentSize;\n-\n-    private final int codeEntryAlignment;\n-\n-    private final boolean threadLocalHandshakes;\n-\n-    \/**\n-     * Container holding code bits and any other related information.\n-     *\/\n-    private final CodeContainer codeContainer;\n-\n-    \/**\n-     * Container holding global offset data for hotspot linkage.\n-     *\/\n-    private final ByteContainer extLinkageGOTContainer;\n-\n-    \/**\n-     * Patched by HotSpot, contains Klass pointers.\n-     *\/\n-    private final ByteContainer klassesGotContainer;\n-\n-    \/**\n-     * Patched by HotSpot, contains MethodCounters pointers.\n-     *\/\n-    private final ByteContainer countersGotContainer;\n-\n-    \/**\n-     * Patched lazily by hotspot, contains klass\/method pointers.\n-     *\/\n-    private final ByteContainer metadataGotContainer;\n-\n-    \/**\n-     * BSS container, contains method state array.\n-     *\/\n-    private final ByteContainer methodStateContainer;\n-\n-    \/**\n-     * Patched by hotspot, contains java object pointers.\n-     *\/\n-    private final ByteContainer oopGotContainer;\n-\n-    \/\/ Containers holding read-only data\n-    private final ReadOnlyDataContainer configContainer;\n-    private final ReadOnlyDataContainer metaspaceNamesContainer;\n-    private final ReadOnlyDataContainer methodsOffsetsContainer;\n-    private final ReadOnlyDataContainer klassesOffsetsContainer;\n-    private final ReadOnlyDataContainer klassesDependenciesContainer;\n-    private final HeaderContainer headerContainer;\n-    private final ReadOnlyDataContainer stubsOffsetsContainer;\n-    private final ReadOnlyDataContainer codeSegmentsContainer;\n-\n-    \/\/ This cannot be read only since we need to patch the metadata at runtime..\n-    private final ReadOnlyDataContainer methodMetadataContainer;\n-\n-    \/**\n-     * Container containing constant data used by code.\n-     *\/\n-    private final ReadOnlyDataContainer constantDataContainer;\n-\n-    \/**\n-     * Map holding the Strings table.\n-     *\/\n-    private final Map<String, Integer> offsetStringTable = new HashMap<>();\n-\n-    private final Map<String, Integer> metaspaceNames = new HashMap<>();\n-\n-    \/\/ List of relocation table entries - (symbolName, relocationInfo)\n-    private final Map<String, Symbol> symbolTable = new HashMap<>();\n-    private final Map<Symbol, List<Relocation>> relocationTable = new HashMap<>();\n-    private final Map<Symbol, Relocation> uniqueRelocationTable = new HashMap<>();\n-\n-    \/**\n-     * Mapping of local VM function names to known global symbols generated in the output binary.\n-     *\/\n-    private static final HashMap<String, String> functionNamesToAOTSymbols = new HashMap<>();\n-\n-    \/\/@formatter:off\n-    private static final String[][] map = {\n-        {\"CompilerToVM::Data::SharedRuntime_deopt_blob_unpack\",         \"_aot_deopt_blob_unpack\"},\n-        {\"CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap\",  \"_aot_deopt_blob_uncommon_trap\"},\n-        {\"CompilerToVM::Data::SharedRuntime_deopt_blob_unpack_with_exception_in_tls\",  \"_aot_deopt_blob_unpack_with_exception_in_tls\"},\n-        {\"CompilerToVM::Data::SharedRuntime_ic_miss_stub\",              \"_aot_ic_miss_stub\"},\n-        {\"CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub\",  \"_aot_handle_wrong_method_stub\"},\n-        {\"SharedRuntime::exception_handler_for_return_address\",         \"_aot_exception_handler_for_return_address\"},\n-        {\"SharedRuntime::register_finalizer\",                           \"_aot_register_finalizer\"},\n-        {\"SharedRuntime::OSR_migration_end\",                            \"_aot_OSR_migration_end\"},\n-        {\"SharedRuntime::enable_stack_reserved_zone\",                   \"_aot_enable_stack_reserved_zone\"},\n-        {\"CompilerRuntime::resolve_dynamic_invoke\",                     \"_aot_resolve_dynamic_invoke\"},\n-        {\"CompilerRuntime::resolve_string_by_symbol\",                   \"_aot_resolve_string_by_symbol\"},\n-        {\"CompilerRuntime::resolve_klass_by_symbol\",                    \"_aot_resolve_klass_by_symbol\"},\n-        {\"CompilerRuntime::resolve_method_by_symbol_and_load_counters\", \"_aot_resolve_method_by_symbol_and_load_counters\"},\n-        {\"CompilerRuntime::initialize_klass_by_symbol\",                 \"_aot_initialize_klass_by_symbol\"},\n-        {\"CompilerRuntime::invocation_event\",                           \"_aot_invocation_event\"},\n-        {\"CompilerRuntime::backedge_event\",                             \"_aot_backedge_event\"},\n-\n-        {\"CompilerToVM::Data::dpow\", \"_aot_shared_runtime_dpow\"},\n-        {\"CompilerToVM::Data::dexp\", \"_aot_shared_runtime_dexp\"},\n-        {\"CompilerToVM::Data::dcos\", \"_aot_shared_runtime_dcos\"},\n-        {\"CompilerToVM::Data::dsin\", \"_aot_shared_runtime_dsin\"},\n-        {\"CompilerToVM::Data::dtan\", \"_aot_shared_runtime_dtan\"},\n-        {\"CompilerToVM::Data::dlog\", \"_aot_shared_runtime_dlog\"},\n-        {\"CompilerToVM::Data::dlog10\", \"_aot_shared_runtime_dlog10\"},\n-\n-        {\"StubRoutines::_jbyte_arraycopy\", \"_aot_stub_routines_jbyte_arraycopy\"},\n-        {\"StubRoutines::_jshort_arraycopy\", \"_aot_stub_routines_jshort_arraycopy\"},\n-        {\"StubRoutines::_jint_arraycopy\", \"_aot_stub_routines_jint_arraycopy\"},\n-        {\"StubRoutines::_jlong_arraycopy\", \"_aot_stub_routines_jlong_arraycopy\"},\n-        {\"StubRoutines::_oop_arraycopy\", \"_aot_stub_routines_oop_arraycopy\"},\n-        {\"StubRoutines::_oop_arraycopy_uninit\", \"_aot_stub_routines_oop_arraycopy_uninit\"},\n-\n-        {\"StubRoutines::_jbyte_disjoint_arraycopy\", \"_aot_stub_routines_jbyte_disjoint_arraycopy\"},\n-        {\"StubRoutines::_jshort_disjoint_arraycopy\", \"_aot_stub_routines_jshort_disjoint_arraycopy\"},\n-        {\"StubRoutines::_jint_disjoint_arraycopy\", \"_aot_stub_routines_jint_disjoint_arraycopy\"},\n-        {\"StubRoutines::_jlong_disjoint_arraycopy\", \"_aot_stub_routines_jlong_disjoint_arraycopy\"},\n-        {\"StubRoutines::_oop_disjoint_arraycopy\", \"_aot_stub_routines_oop_disjoint_arraycopy\"},\n-        {\"StubRoutines::_oop_disjoint_arraycopy_uninit\", \"_aot_stub_routines_oop_disjoint_arraycopy_uninit\"},\n-\n-        {\"StubRoutines::_arrayof_jbyte_arraycopy\", \"_aot_stub_routines_arrayof_jbyte_arraycopy\"},\n-        {\"StubRoutines::_arrayof_jshort_arraycopy\", \"_aot_stub_routines_arrayof_jshort_arraycopy\"},\n-        {\"StubRoutines::_arrayof_jint_arraycopy\", \"_aot_stub_routines_arrayof_jint_arraycopy\"},\n-        {\"StubRoutines::_arrayof_jlong_arraycopy\", \"_aot_stub_routines_arrayof_jlong_arraycopy\"},\n-        {\"StubRoutines::_arrayof_oop_arraycopy\", \"_aot_stub_routines_arrayof_oop_arraycopy\"},\n-        {\"StubRoutines::_arrayof_oop_arraycopy_uninit\", \"_aot_stub_routines_arrayof_oop_arraycopy_uninit\"},\n-\n-        {\"StubRoutines::_arrayof_jbyte_disjoint_arraycopy\", \"_aot_stub_routines_arrayof_jbyte_disjoint_arraycopy\"},\n-        {\"StubRoutines::_arrayof_jshort_disjoint_arraycopy\", \"_aot_stub_routines_arrayof_jshort_disjoint_arraycopy\"},\n-        {\"StubRoutines::_arrayof_jint_disjoint_arraycopy\", \"_aot_stub_routines_arrayof_jint_disjoint_arraycopy\"},\n-        {\"StubRoutines::_arrayof_jlong_disjoint_arraycopy\", \"_aot_stub_routines_arrayof_jlong_disjoint_arraycopy\"},\n-        {\"StubRoutines::_arrayof_oop_disjoint_arraycopy\", \"_aot_stub_routines_arrayof_oop_disjoint_arraycopy\"},\n-        {\"StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit\", \"_aot_stub_routines_arrayof_oop_disjoint_arraycopy_uninit\"},\n-\n-        {\"StubRoutines::_unsafe_arraycopy\", \"_aot_stub_routines_unsafe_arraycopy\"},\n-\n-        {\"StubRoutines::_checkcast_arraycopy\", \"_aot_stub_routines_checkcast_arraycopy\"},\n-\n-        {\"StubRoutines::_generic_arraycopy\", \"_aot_stub_routines_generic_arraycopy\"},\n-\n-        {\"StubRoutines::_aescrypt_encryptBlock\", \"_aot_stub_routines_aescrypt_encryptBlock\"},\n-        {\"StubRoutines::_aescrypt_decryptBlock\", \"_aot_stub_routines_aescrypt_decryptBlock\"},\n-        {\"StubRoutines::_cipherBlockChaining_encryptAESCrypt\", \"_aot_stub_routines_cipherBlockChaining_encryptAESCrypt\"},\n-        {\"StubRoutines::_cipherBlockChaining_decryptAESCrypt\", \"_aot_stub_routines_cipherBlockChaining_decryptAESCrypt\"},\n-        {\"StubRoutines::_electronicCodeBook_encryptAESCrypt\", \"_aot_stub_routines_electronicCodeBook_encryptAESCrypt\"},\n-        {\"StubRoutines::_electronicCodeBook_decryptAESCrypt\", \"_aot_stub_routines_electronicCodeBook_decryptAESCrypt\"},\n-        {\"StubRoutines::_updateBytesCRC32\", \"_aot_stub_routines_update_bytes_crc32\"},\n-        {\"StubRoutines::_crc_table_adr\", \"_aot_stub_routines_crc_table_adr\"},\n-\n-        {\"StubRoutines::_sha1_implCompress\", \"_aot_stub_routines_sha1_implCompress\" },\n-        {\"StubRoutines::_sha1_implCompressMB\", \"_aot_stub_routines_sha1_implCompressMB\" },\n-        {\"StubRoutines::_sha256_implCompress\", \"_aot_stub_routines_sha256_implCompress\" },\n-        {\"StubRoutines::_sha256_implCompressMB\", \"_aot_stub_routines_sha256_implCompressMB\" },\n-        {\"StubRoutines::_sha512_implCompress\", \"_aot_stub_routines_sha512_implCompress\" },\n-        {\"StubRoutines::_sha512_implCompressMB\", \"_aot_stub_routines_sha512_implCompressMB\" },\n-        {\"StubRoutines::_multiplyToLen\", \"_aot_stub_routines_multiplyToLen\" },\n-\n-        {\"StubRoutines::_counterMode_AESCrypt\", \"_aot_stub_routines_counterMode_AESCrypt\" },\n-        {\"StubRoutines::_ghash_processBlocks\", \"_aot_stub_routines_ghash_processBlocks\" },\n-        {\"StubRoutines::_base64_encodeBlock\", \"_aot_stub_routines_base64_encodeBlock\" },\n-        {\"StubRoutines::_crc32c_table_addr\", \"_aot_stub_routines_crc32c_table_addr\" },\n-        {\"StubRoutines::_updateBytesCRC32C\", \"_aot_stub_routines_updateBytesCRC32C\" },\n-        {\"StubRoutines::_updateBytesAdler32\", \"_aot_stub_routines_updateBytesAdler32\" },\n-        {\"StubRoutines::_squareToLen\", \"_aot_stub_routines_squareToLen\" },\n-        {\"StubRoutines::_mulAdd\", \"_aot_stub_routines_mulAdd\" },\n-        {\"StubRoutines::_montgomeryMultiply\", \"_aot_stub_routines_montgomeryMultiply\" },\n-        {\"StubRoutines::_montgomerySquare\", \"_aot_stub_routines_montgomerySquare\" },\n-        {\"StubRoutines::_vectorizedMismatch\", \"_aot_stub_routines_vectorizedMismatch\" },\n-        {\"StubRoutines::_bigIntegerRightShiftWorker\", \"_aot_stub_routines_bigIntegerRightShiftWorker\" },\n-        {\"StubRoutines::_bigIntegerLeftShiftWorker\", \"_aot_stub_routines_bigIntegerLeftShiftWorker\" },\n-\n-        {\"StubRoutines::_throw_delayed_StackOverflowError_entry\", \"_aot_stub_routines_throw_delayed_StackOverflowError_entry\" },\n-\n-\n-        {\"os::javaTimeMillis\", \"_aot_os_javaTimeMillis\"},\n-        {\"os::javaTimeNanos\", \"_aot_os_javaTimeNanos\"},\n-\n-        {\"JVMCIRuntime::monitorenter\", \"_aot_jvmci_runtime_monitorenter\"},\n-        {\"JVMCIRuntime::monitorexit\", \"_aot_jvmci_runtime_monitorexit\"},\n-        {\"JVMCIRuntime::object_notify\", \"_aot_object_notify\"},\n-        {\"JVMCIRuntime::object_notifyAll\", \"_aot_object_notifyAll\"},\n-        {\"JVMCIRuntime::log_object\", \"_aot_jvmci_runtime_log_object\"},\n-        {\"JVMCIRuntime::log_printf\", \"_aot_jvmci_runtime_log_printf\"},\n-        {\"JVMCIRuntime::vm_message\", \"_aot_jvmci_runtime_vm_message\"},\n-        {\"JVMCIRuntime::new_instance\", \"_aot_jvmci_runtime_new_instance\"},\n-        {\"JVMCIRuntime::new_array\", \"_aot_jvmci_runtime_new_array\"},\n-        {\"JVMCIRuntime::new_multi_array\", \"_aot_jvmci_runtime_new_multi_array\"},\n-        {\"JVMCIRuntime::dynamic_new_instance\", \"_aot_jvmci_runtime_dynamic_new_instance\"},\n-        {\"JVMCIRuntime::dynamic_new_array\", \"_aot_jvmci_runtime_dynamic_new_array\"},\n-        {\"JVMCIRuntime::new_instance_or_null\", \"_aot_jvmci_runtime_new_instance_or_null\"},\n-        {\"JVMCIRuntime::new_array_or_null\", \"_aot_jvmci_runtime_new_array_or_null\"},\n-        {\"JVMCIRuntime::new_multi_array_or_null\", \"_aot_jvmci_runtime_new_multi_array_or_null\"},\n-        {\"JVMCIRuntime::dynamic_new_instance_or_null\", \"_aot_jvmci_runtime_dynamic_new_instance_or_null\"},\n-        {\"JVMCIRuntime::dynamic_new_array_or_null\", \"_aot_jvmci_runtime_dynamic_new_array_or_null\"},\n-        {\"JVMCIRuntime::log_primitive\", \"_aot_jvmci_runtime_log_primitive\"},\n-        {\"JVMCIRuntime::validate_object\", \"_aot_jvmci_runtime_validate_object\"},\n-        {\"JVMCIRuntime::write_barrier_pre\", \"_aot_jvmci_runtime_write_barrier_pre\"},\n-        {\"JVMCIRuntime::identity_hash_code\", \"_aot_jvmci_runtime_identity_hash_code\"},\n-        {\"JVMCIRuntime::write_barrier_post\", \"_aot_jvmci_runtime_write_barrier_post\"},\n-        {\"JVMCIRuntime::thread_is_interrupted\", \"_aot_jvmci_runtime_thread_is_interrupted\"},\n-        {\"JVMCIRuntime::exception_handler_for_pc\", \"_aot_jvmci_runtime_exception_handler_for_pc\"},\n-        {\"JVMCIRuntime::test_deoptimize_call_int\", \"_aot_jvmci_runtime_test_deoptimize_call_int\"},\n-\n-        {\"JVMCIRuntime::throw_and_post_jvmti_exception\",      \"_aot_jvmci_runtime_throw_and_post_jvmti_exception\"},\n-        {\"JVMCIRuntime::throw_klass_external_name_exception\", \"_aot_jvmci_runtime_throw_klass_external_name_exception\"},\n-        {\"JVMCIRuntime::throw_class_cast_exception\",          \"_aot_jvmci_runtime_throw_class_cast_exception\"},\n-\n-        {\"JVMCIRuntime::vm_error\", \"_aot_jvmci_runtime_vm_error\"}\n-    };\n-    \/\/@formatter:on\n-\n-    static {\n-        for (String[] entry : map) {\n-            functionNamesToAOTSymbols.put(entry[0], entry[1]);\n-        }\n-    }\n-\n-    \/**\n-     * Allocates a {@code BinaryContainer} object whose content will be generated in a file with the\n-     * prefix {@code prefix}. It also initializes internal code container, symbol table and\n-     * relocation tables.\n-     *\n-     * @param graalOptions\n-     *\/\n-    public BinaryContainer(OptionValues graalOptions, GraalHotSpotVMConfig graalHotSpotVMConfig, GraphBuilderConfiguration graphBuilderConfig, int gc, String jvmVersion) {\n-        this.graalOptions = graalOptions;\n-\n-        this.codeSegmentSize = graalHotSpotVMConfig.codeSegmentSize;\n-        if (codeSegmentSize < 1 || codeSegmentSize > 1024) {\n-            throw new InternalError(\"codeSegmentSize is not in range [1, 1024] bytes: (\" + codeSegmentSize + \"), update JPECoffRelocObject\");\n-        }\n-        if ((codeSegmentSize & (codeSegmentSize - 1)) != 0) {\n-            throw new InternalError(\"codeSegmentSize is not power of 2: (\" + codeSegmentSize + \"), update JPECoffRelocObject\");\n-        }\n-\n-        this.codeEntryAlignment = graalHotSpotVMConfig.codeEntryAlignment;\n-\n-        this.threadLocalHandshakes = graalHotSpotVMConfig.useThreadLocalPolling;\n-\n-        \/\/ Section unique name is limited to 8 characters due to limitation on Windows.\n-        \/\/ Name could be longer but only first 8 characters are stored on Windows.\n-\n-        \/\/ read only, code\n-        codeContainer = new CodeContainer(\".text\", this);\n-\n-        \/\/ read only, info\n-        headerContainer = new HeaderContainer(jvmVersion, new ReadOnlyDataContainer(\".header\", this));\n-        configContainer = new ReadOnlyDataContainer(\".config\", this);\n-        metaspaceNamesContainer = new ReadOnlyDataContainer(\".meta.names\", this);\n-        methodsOffsetsContainer = new ReadOnlyDataContainer(\".meth.offsets\", this);\n-        klassesOffsetsContainer = new ReadOnlyDataContainer(\".kls.offsets\", this);\n-        klassesDependenciesContainer = new ReadOnlyDataContainer(\".kls.dependencies\", this);\n-\n-        stubsOffsetsContainer = new ReadOnlyDataContainer(\".stubs.offsets\", this);\n-        codeSegmentsContainer = new ReadOnlyDataContainer(\".code.segments\", this);\n-        constantDataContainer = new ReadOnlyDataContainer(\".meth.constdata\", this);\n-        methodMetadataContainer = new ReadOnlyDataContainer(\".meth.metadata\", this);\n-\n-        \/\/ writable sections\n-        oopGotContainer = new ByteContainer(\".oop.got\", this);\n-        klassesGotContainer = new ByteContainer(\".kls.got\", this);\n-        countersGotContainer = new ByteContainer(\".cnt.got\", this);\n-        metadataGotContainer = new ByteContainer(\".meta.got\", this);\n-        methodStateContainer = new ByteContainer(\".meth.state\", this);\n-        extLinkageGOTContainer = new ByteContainer(\".got.linkage\", this);\n-\n-        addGlobalSymbols();\n-\n-        recordConfiguration(graalHotSpotVMConfig, graphBuilderConfig, gc);\n-    }\n-\n-    private void recordConfiguration(GraalHotSpotVMConfig graalHotSpotVMConfig, GraphBuilderConfiguration graphBuilderConfig, int gc) {\n-        \/\/ @Checkstyle: stop\n-        \/\/ @formatter:off\n-        ArrayList<Boolean> booleanFlagsList = new ArrayList<>();\n-\n-        booleanFlagsList.addAll(Arrays.asList(graalHotSpotVMConfig.cAssertions, \/\/ Debug VM\n-                                              graalHotSpotVMConfig.useCompressedOops,\n-                                              graalHotSpotVMConfig.useCompressedClassPointers));\n-        if (JavaVersionUtil.JAVA_SPEC < 15) {\n-            \/\/ See JDK-8236224. FieldsAllocationStyle and CompactFields flags were removed in JDK15.\n-            booleanFlagsList.add(graalHotSpotVMConfig.compactFields);\n-        }\n-        booleanFlagsList.addAll(Arrays.asList(graalHotSpotVMConfig.useTLAB,\n-                                              graalHotSpotVMConfig.useBiasedLocking,\n-                                              TieredAOT.getValue(graalOptions),\n-                                              graalHotSpotVMConfig.enableContended,\n-                                              graalHotSpotVMConfig.restrictContended,\n-                                              graphBuilderConfig.omitAssertions()));\n-        if (JavaVersionUtil.JAVA_SPEC < 14) {\n-            \/\/ See JDK-8220049. Thread local handshakes are on by default since JDK14, the command line option has been removed.\n-            booleanFlagsList.add(graalHotSpotVMConfig.useThreadLocalPolling);\n-        }\n-\n-        ArrayList<Integer> intFlagsList = new ArrayList<>();\n-        intFlagsList.addAll(Arrays.asList(graalHotSpotVMConfig.getOopEncoding().getShift(),\n-                                          graalHotSpotVMConfig.getKlassEncoding().getShift(),\n-                                          graalHotSpotVMConfig.contendedPaddingWidth));\n-        if (JavaVersionUtil.JAVA_SPEC < 15) {\n-            \/\/ See JDK-8236224. FieldsAllocationStyle and CompactFields flags were removed in JDK15.\n-            intFlagsList.add(graalHotSpotVMConfig.fieldsAllocationStyle);\n-        }\n-        intFlagsList.addAll(Arrays.asList(1 << graalHotSpotVMConfig.logMinObjAlignment(),\n-                                          graalHotSpotVMConfig.codeSegmentSize,\n-                                          gc));\n-\n-        \/\/ @formatter:on\n-        \/\/ @Checkstyle: resume\n-\n-        byte[] booleanFlagsAsBytes = booleanListToByteArray(booleanFlagsList);\n-        int[] intFlags = intFlagsList.stream().mapToInt(i -> i).toArray();\n-        int size0 = configContainer.getByteStreamSize();\n-\n-        \/\/ @formatter:off\n-        int computedSize = booleanFlagsAsBytes.length * Byte.BYTES    + \/\/ size of boolean flags\n-                           intFlags.length            * Integer.BYTES + \/\/ size of int flags\n-                           Integer.BYTES;                               \/\/ size of the \"computedSize\"\n-\n-        configContainer.appendInt(computedSize).\n-                        appendInts(intFlags).\n-                        appendBytes(booleanFlagsAsBytes);\n-        \/\/ @formatter:on\n-\n-        int size = configContainer.getByteStreamSize() - size0;\n-        assert size == computedSize;\n-    }\n-\n-    private static byte[] booleanListToByteArray(ArrayList<Boolean> list) {\n-        byte[] byteArray = new byte[list.size()];\n-        for (int i = 0; i < list.size(); ++i) {\n-            byteArray[i] = boolToByte(list.get(i));\n-        }\n-        return byteArray;\n-    }\n-\n-    private static byte boolToByte(boolean flag) {\n-        return (byte) (flag ? 1 : 0);\n-    }\n-\n-    \/**\n-     * Free some memory.\n-     *\/\n-    public void freeMemory() {\n-        offsetStringTable.clear();\n-        metaspaceNames.clear();\n-    }\n-\n-    \/*\n-     * Global symbol names in generated DSO corresponding to VM's symbols. VM needs to look up this\n-     * symbol in DSO and link it with VM's corresponding symbol: store VM's symbol address or value\n-     * in the named GOT cell.\n-     *\/\n-\n-    public static String getCardTableAddressSymbolName() {\n-        return \"_aot_card_table_address\";\n-    }\n-\n-    public static String getHeapTopAddressSymbolName() {\n-        return \"_aot_heap_top_address\";\n-    }\n-\n-    public static String getHeapEndAddressSymbolName() {\n-        return \"_aot_heap_end_address\";\n-    }\n-\n-    public static String getCrcTableAddressSymbolName() {\n-        return \"_aot_stub_routines_crc_table_adr\";\n-    }\n-\n-    public static String getPollingPageSymbolName() {\n-        return \"_aot_polling_page\";\n-    }\n-\n-    public static String getResolveStaticEntrySymbolName() {\n-        return \"_resolve_static_entry\";\n-    }\n-\n-    public static String getResolveVirtualEntrySymbolName() {\n-        return \"_resolve_virtual_entry\";\n-    }\n-\n-    public static String getResolveOptVirtualEntrySymbolName() {\n-        return \"_resolve_opt_virtual_entry\";\n-    }\n-\n-    public static String getNarrowKlassBaseAddressSymbolName() {\n-        return \"_aot_narrow_klass_base_address\";\n-    }\n-\n-    public static String getNarrowOopBaseAddressSymbolName() {\n-        return \"_aot_narrow_oop_base_address\";\n-    }\n-\n-    public static String getLogOfHeapRegionGrainBytesSymbolName() {\n-        return \"_aot_log_of_heap_region_grain_bytes\";\n-    }\n-\n-    public static String getInlineContiguousAllocationSupportedSymbolName() {\n-        return \"_aot_inline_contiguous_allocation_supported\";\n-    }\n-\n-    public static String getVerifyOopsSymbolName() {\n-        return \"_aot_verify_oops\";\n-    }\n-\n-    public static String getVerifyOopCountAddressSymbolName() {\n-        return \"_aot_verify_oop_count_address\";\n-    }\n-\n-    public static String getVerifyOopBitsSymbolName() {\n-        return \"_aot_verify_oop_bits\";\n-    }\n-\n-    public static String getVerifyOopMaskSymbolName() {\n-        return \"_aot_verify_oop_mask\";\n-    }\n-\n-    public int getCodeSegmentSize() {\n-        return codeSegmentSize;\n-    }\n-\n-    public int getCodeEntryAlignment() {\n-        return codeEntryAlignment;\n-    }\n-\n-    public boolean getThreadLocalHandshakes() {\n-        return threadLocalHandshakes;\n-    }\n-\n-    \/**\n-     * Gets the global AOT symbol associated with the function name.\n-     *\n-     * @param functionName function name\n-     * @return AOT symbol for the given function name, or null if there is no mapping.\n-     *\/\n-    public static String getAOTSymbolForVMFunctionName(String functionName) {\n-        return functionNamesToAOTSymbols.get(functionName);\n-    }\n-\n-    private void addGlobalSymbols() {\n-        \/\/ Create global symbols for all containers.\n-        createContainerSymbol(codeContainer);\n-        createContainerSymbol(configContainer);\n-        createContainerSymbol(methodsOffsetsContainer);\n-        createContainerSymbol(klassesOffsetsContainer);\n-        createContainerSymbol(klassesDependenciesContainer);\n-        createContainerSymbol(klassesGotContainer);\n-        createContainerSymbol(countersGotContainer);\n-        createContainerSymbol(metadataGotContainer);\n-        createContainerSymbol(methodStateContainer);\n-        createContainerSymbol(oopGotContainer);\n-        createContainerSymbol(metaspaceNamesContainer);\n-        createContainerSymbol(methodMetadataContainer);\n-        createContainerSymbol(stubsOffsetsContainer);\n-        createContainerSymbol(headerContainer.getContainer());\n-        createContainerSymbol(codeSegmentsContainer);\n-\n-        createGotSymbol(getResolveStaticEntrySymbolName());\n-        createGotSymbol(getResolveVirtualEntrySymbolName());\n-        createGotSymbol(getResolveOptVirtualEntrySymbolName());\n-        createGotSymbol(getCardTableAddressSymbolName());\n-        createGotSymbol(getHeapTopAddressSymbolName());\n-        createGotSymbol(getHeapEndAddressSymbolName());\n-        createGotSymbol(getNarrowKlassBaseAddressSymbolName());\n-        createGotSymbol(getNarrowOopBaseAddressSymbolName());\n-        createGotSymbol(getPollingPageSymbolName());\n-        createGotSymbol(getLogOfHeapRegionGrainBytesSymbolName());\n-        createGotSymbol(getInlineContiguousAllocationSupportedSymbolName());\n-        createGotSymbol(getVerifyOopsSymbolName());\n-        createGotSymbol(getVerifyOopCountAddressSymbolName());\n-        createGotSymbol(getVerifyOopBitsSymbolName());\n-        createGotSymbol(getVerifyOopMaskSymbolName());\n-\n-        for (HashMap.Entry<String, String> entry : functionNamesToAOTSymbols.entrySet()) {\n-            createGotSymbol(entry.getValue());\n-        }\n-    }\n-\n-    \/**\n-     * Creates a global symbol of the form {@code \"A\" + container name}. Note, linker on Windows\n-     * does not allow names which start with '.'\n-     *\n-     * @param container container to create a symbol for\n-     *\/\n-    private static void createContainerSymbol(ByteContainer container) {\n-        container.createSymbol(0, Kind.OBJECT, Binding.GLOBAL, 0, \"A\" + container.getContainerName());\n-    }\n-\n-    \/**\n-     * Creates a global GOT symbol of the form {@code \"got.\" + name}.\n-     *\n-     * @param name name for the GOT symbol\n-     *\/\n-    private void createGotSymbol(String name) {\n-        String s = \"got.\" + name;\n-        Symbol gotSymbol = extLinkageGOTContainer.createGotSymbol(s);\n-        extLinkageGOTContainer.createSymbol(gotSymbol.getOffset(), Kind.OBJECT, Binding.GLOBAL, 8, name);\n-    }\n-\n-    \/**\n-     * Create a platform-specific binary file representing the content of the\n-     * {@code BinaryContainer} object.\n-     *\n-     * This method is called after creating and performing any necessary changes to the contents of\n-     * code stream, symbol tables and relocation tables is completely finalized\n-     *\n-     * @param outputFileName name of output file\n-     *\n-     * @throws IOException in case of file creation failure\n-     *\/\n-    public void createBinary(String outputFileName) throws IOException {\n-        String osName = System.getProperty(\"os.name\");\n-        switch (osName) {\n-            case \"Linux\":\n-                JELFRelocObject elfobj = JELFRelocObject.newInstance(this, outputFileName);\n-                elfobj.createELFRelocObject(relocationTable, symbolTable.values());\n-                break;\n-            case \"Mac OS X\":\n-                JMachORelocObject machobj = new JMachORelocObject(this, outputFileName);\n-                machobj.createMachORelocObject(relocationTable, symbolTable.values());\n-                break;\n-            default:\n-                if (osName.startsWith(\"Windows\")) {\n-                    JPECoffRelocObject pecoffobj = new JPECoffRelocObject(this, outputFileName);\n-                    pecoffobj.createPECoffRelocObject(relocationTable, symbolTable.values());\n-                    break;\n-                } else {\n-                    throw new InternalError(\"Unsupported platform: \" + osName);\n-                }\n-        }\n-    }\n-\n-    \/**\n-     * Add symbol to the symbol table. If the existing symbol is undefined and the specified symbol\n-     * is not undefined, replace the existing symbol information with that specified.\n-     *\n-     * @param symInfo symbol information to be added\n-     *\/\n-    @Override\n-    public void addSymbol(Symbol symInfo) {\n-        if (symInfo.getName().startsWith(\"got.\") && !(symInfo instanceof GotSymbol)) {\n-            throw new InternalError(\"adding got. without being GotSymbol\");\n-        }\n-        if (symbolTable.containsKey(symInfo.getName())) {\n-            throw new InternalError(\"Symbol: \" + symInfo.getName() + \" already exists in SymbolTable\");\n-        } else {\n-            \/\/ System.out.println(\"# Symbol [\" + name + \"] [\" + symInfo.getValue() + \"] [\" +\n-            \/\/ symInfo.getSection().getContainerName() + \"] [\" + symInfo.getSize() + \"]\");\n-            symbolTable.put(symInfo.getName(), symInfo);\n-        }\n-    }\n-\n-    public boolean addStringOffset(String name, Integer offset) {\n-        offsetStringTable.put(name, offset);\n-        return true;\n-    }\n-\n-    \/**\n-     * Add relocation entry for {@code symName}. Multiple relocation entries for a given symbol may\n-     * exist.\n-     *\n-     * @param info relocation information to be added\n-     *\/\n-    public void addRelocation(Relocation info) {\n-        \/\/ System.out.println(\"# Relocation [\" + info.getSymbol() + \"] [\" + info.getOffset() + \"] [\"\n-        \/\/ +\n-        \/\/ info.getSection().getContainerName() + \"] [\" + info.getSymbol().getName() + \"] [\" +\n-        \/\/ info.getSymbol().getOffset() + \" @ \" + info.getSymbol().getSection().getContainerName() +\n-        \/\/ \"]\");\n-        if (relocationTable.containsKey(info.getSymbol())) {\n-            relocationTable.get(info.getSymbol()).add(info);\n-        } else if (uniqueRelocationTable.containsKey(info.getSymbol())) {\n-            \/\/ promote\n-            ArrayList<Relocation> list = new ArrayList<>(2);\n-            list.add(uniqueRelocationTable.get(info.getSymbol()));\n-            list.add(info);\n-            relocationTable.put(info.getSymbol(), list);\n-            uniqueRelocationTable.remove(info.getSymbol());\n-        } else {\n-            uniqueRelocationTable.put(info.getSymbol(), info);\n-        }\n-    }\n-\n-    \/**\n-     * Get symbol with name {@code symName}.\n-     *\n-     * @param symName name of symbol for which symbol table information is being queried\n-     * @return success or failure of insertion operation\n-     *\/\n-    @Override\n-    public Symbol getSymbol(String symName) {\n-        return symbolTable.get(symName);\n-    }\n-\n-    @Override\n-    public Symbol createSymbol(int offset, Kind kind, Binding binding, int size, String name) {\n-        if (kind != Kind.NATIVE_FUNCTION) {\n-            throw new UnsupportedOperationException(\"Must be external functions: \" + name);\n-        }\n-        Symbol symbol = new Symbol(offset, kind, binding, null, size, name);\n-        addSymbol(symbol);\n-        return symbol;\n-    }\n-\n-    \/**\n-     * Get offset in got section with name {@code symName}.\n-     *\n-     * @param name for which String table information is being queried\n-     * @return success or failure of insertion operation\n-     *\/\n-    public Integer getStringOffset(String name) {\n-        return offsetStringTable.get(name);\n-    }\n-\n-    \/**\n-     * Insert {@code targetCode} to code stream with {@code size} at {@code offset}.\n-     *\n-     * @param targetCode byte array of native code\n-     * @param offset offset at which {@code targetCode} is to be inserted\n-     * @param size size of {@code targetCode}\n-     *\/\n-    private static void appendBytes(ByteContainer byteContainer, byte[] targetCode, int offset, int size) {\n-        byteContainer.appendBytes(targetCode, offset, size);\n-    }\n-\n-    public void appendCodeBytes(byte[] targetCode, int offset, int size) {\n-        appendBytes(codeContainer, targetCode, offset, size);\n-    }\n-\n-    public void appendIntToCode(int value) {\n-        codeContainer.appendInt(value);\n-    }\n-\n-    public int appendExtLinkageGotBytes(byte[] bytes, int offset, int size) {\n-        int startOffset = extLinkageGOTContainer.getByteStreamSize();\n-        appendBytes(extLinkageGOTContainer, bytes, offset, size);\n-        return startOffset;\n-    }\n-\n-    public void addMetadataGotEntry(int offset) {\n-        metadataGotContainer.appendLong(offset);\n-    }\n-\n-    public int addMetaspaceName(String name) {\n-        Integer value = metaspaceNames.get(name);\n-        if (value != null) {\n-            return value.intValue();\n-        }\n-        \/\/ Get the current length of the stubsNameContainer\n-        \/\/ align on 8-byte boundary\n-        int nameOffset = alignUp(metaspaceNamesContainer, 8);\n-\n-        try {\n-            \/\/ Add the name of the symbol to the .stubs.names section\n-            \/\/ Modify them to sequence of utf8 strings with length:\n-            \/\/ \"<u2_size>Ljava\/lang\/ThreadGroup;<u2_size>addUnstarted<u2_size>()V\"\n-            ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-            DataOutputStream out = new DataOutputStream(bout);\n-            int len = name.length();\n-            if (name.startsWith(\"Stub\")) { \/\/ Stub\n-                out.writeUTF(name);\n-            } else { \/\/ Method or Klass\n-                int parenthesesIndex = name.lastIndexOf('(', len - 1);\n-                if (parenthesesIndex > 0) {  \/\/ Method name\n-                    int dotIndex = name.lastIndexOf('.', parenthesesIndex - 1);\n-                    assert dotIndex > 0 : \"method's full name should have '.' : \" + name;\n-                    String klassName = name.substring(0, dotIndex);\n-                    out.writeUTF(klassName);\n-                    String methodName = name.substring(dotIndex + 1, parenthesesIndex);\n-                    out.writeUTF(methodName);\n-                    String signature = name.substring(parenthesesIndex, len);\n-                    out.writeUTF(signature);\n-                } else {\n-                    out.writeUTF(name); \/\/ Klass\n-                }\n-            }\n-            out.writeShort(0); \/\/ Terminate by 0.\n-            byte[] b = bout.toByteArray();\n-            metaspaceNamesContainer.appendBytes(b, 0, b.length);\n-\n-            metaspaceNames.put(name, nameOffset);\n-            return nameOffset;\n-        } catch (IOException e) {\n-            throw new InternalError(\"Failed to append bytes to stubs sections\", e);\n-        }\n-    }\n-\n-    \/**\n-     * Add oop symbol by as follows. Extend the oop.got section with another slot for the VM to\n-     * patch.\n-     *\n-     * @param oopName name of the oop symbol\n-     *\/\n-    public Integer addOopSymbol(String oopName) {\n-        Integer oopGotOffset = getStringOffset(oopName);\n-        if (oopGotOffset != null) {\n-            return oopGotOffset;\n-        }\n-        return newOopSymbol(oopName);\n-    }\n-\n-    private Integer newOopSymbol(String oopName) {\n-        \/\/ Reference to String resolution (ldc).\n-        int offset = oopGotContainer.getByteStreamSize();\n-        String gotName = \"got.ldc.\" + offset;\n-        Symbol relocationSymbol = oopGotContainer.createGotSymbol(gotName);\n-\n-        if (offset != relocationSymbol.getOffset()) {\n-            throw new InternalError(\"offset must equal! (\" + offset + \" vs \" + relocationSymbol.getOffset());\n-        }\n-\n-        addStringOffset(oopName, relocationSymbol.getOffset());\n-        return relocationSymbol.getOffset();\n-    }\n-\n-    public int addCountersSymbol(String metaspaceName) {\n-        String gotName = \"got.\" + metaspaceName;\n-        Symbol relocationSymbol = getGotSymbol(gotName);\n-        int metaspaceOffset = -1;\n-        if (relocationSymbol == null) {\n-            \/\/ Add slots when asked in the .metaspace.got section:\n-            countersGotContainer.createGotSymbol(gotName);\n-        }\n-        return metaspaceOffset;\n-    }\n-\n-    public Symbol getGotSymbol(String name) {\n-        assert name.startsWith(\"got.\");\n-        return symbolTable.get(name);\n-    }\n-\n-    \/**\n-     * Add klass symbol by as follows. - Adding the symbol name to the metaspace.names section - Add\n-     * the offset of the name in metaspace.names to metaspace.offsets - Extend the klasses.got\n-     * section with another slot for the VM to patch\n-     *\n-     * @param klassName name of the metaspace symbol\n-     * @return the got offset in the klasses.got of the metaspace symbol\n-     *\/\n-    public int addTwoSlotKlassSymbol(String klassName) {\n-        String gotName = \"got.\" + klassName;\n-        Symbol previous = getGotSymbol(gotName);\n-        assert previous == null : \"should be called only once for: \" + klassName;\n-        \/\/ Add slots when asked in the .metaspace.got section:\n-        \/\/ First slot\n-        String gotInitName = \"got.init.\" + klassName;\n-        GotSymbol slot1Symbol = klassesGotContainer.createGotSymbol(gotInitName);\n-        GotSymbol slot2Symbol = klassesGotContainer.createGotSymbol(gotName);\n-\n-        slot1Symbol.getIndex(); \/\/ check alignment and ignore result\n-        \/\/ Get the index (offset\/8) to the got in the .metaspace.got section\n-        return slot2Symbol.getIndex();\n-    }\n-\n-    public static int addMethodsCount(int count, ReadOnlyDataContainer container) {\n-        return appendInt(count, container);\n-    }\n-\n-    private static int appendInt(int count, ReadOnlyDataContainer container) {\n-        int offset = container.getByteStreamSize();\n-        container.appendInt(count);\n-        return offset;\n-    }\n-\n-    \/**\n-     * Add constant data as follows. - Adding the data to the meth.constdata section\n-     *\n-     * @param data\n-     * @param alignment\n-     * @return the offset in the meth.constdata of the data\n-     *\/\n-    public int addConstantData(byte[] data, int alignment) {\n-        \/\/ Get the current length of the metaspaceNameContainer\n-        int constantDataOffset = alignUp(constantDataContainer, alignment);\n-        constantDataContainer.appendBytes(data, 0, data.length);\n-        alignUp(constantDataContainer, alignment); \/\/ Post alignment\n-        return constantDataOffset;\n-    }\n-\n-    public static int alignUp(ByteContainer container, int alignment) {\n-        if (Integer.bitCount(alignment) != 1) {\n-            throw new IllegalArgumentException(\"Must be a power of 2\");\n-        }\n-        int offset = container.getByteStreamSize();\n-        int aligned = (offset + (alignment - 1)) & -alignment;\n-        if (aligned < offset || (aligned & (alignment - 1)) != 0) {\n-            throw new RuntimeException(\"Error aligning: \" + offset + \" -> \" + aligned);\n-        }\n-        if (aligned != offset) {\n-            int nullArraySz = aligned - offset;\n-            byte[] nullArray = new byte[nullArraySz];\n-            container.appendBytes(nullArray, 0, nullArraySz);\n-            offset = aligned;\n-        }\n-        return offset;\n-    }\n-\n-    public void addCodeSegments(int start, int end) {\n-        assert (start % codeSegmentSize) == 0 : \"not aligned code\";\n-        int currentOffset = codeSegmentsContainer.getByteStreamSize();\n-        int offset = start \/ codeSegmentSize;\n-        int emptySize = offset - currentOffset;\n-        \/\/ add empty segments if needed\n-        if (emptySize > 0) {\n-            byte[] emptyArray = new byte[emptySize];\n-            for (int i = 0; i < emptySize; i++) {\n-                emptyArray[i] = (byte) 0xff;\n-            }\n-            appendBytes(codeSegmentsContainer, emptyArray, 0, emptySize);\n-        }\n-        int alignedEnd = (end + (codeSegmentSize - 1)) & -codeSegmentSize;\n-        int segmentsCount = (alignedEnd \/ codeSegmentSize) - offset;\n-        byte[] segments = new byte[segmentsCount];\n-        int idx = 0;\n-        for (int i = 0; i < segmentsCount; i++) {\n-            segments[i] = (byte) idx;\n-            idx = (idx == 0xfe) ? 1 : (idx + 1);\n-        }\n-        appendBytes(codeSegmentsContainer, segments, 0, segmentsCount);\n-    }\n-\n-    public ByteContainer getExtLinkageGOTContainer() {\n-        return extLinkageGOTContainer;\n-    }\n-\n-    public ReadOnlyDataContainer getMethodMetadataContainer() {\n-        return methodMetadataContainer;\n-    }\n-\n-    public ReadOnlyDataContainer getMetaspaceNamesContainer() {\n-        return metaspaceNamesContainer;\n-    }\n-\n-    public ReadOnlyDataContainer getMethodsOffsetsContainer() {\n-        return methodsOffsetsContainer;\n-    }\n-\n-    public ReadOnlyDataContainer getKlassesOffsetsContainer() {\n-        return klassesOffsetsContainer;\n-    }\n-\n-    public ReadOnlyDataContainer getKlassesDependenciesContainer() {\n-        return klassesDependenciesContainer;\n-    }\n-\n-    public ReadOnlyDataContainer getStubsOffsetsContainer() {\n-        return stubsOffsetsContainer;\n-    }\n-\n-    public ReadOnlyDataContainer getCodeSegmentsContainer() {\n-        return codeSegmentsContainer;\n-    }\n-\n-    public ReadOnlyDataContainer getConstantDataContainer() {\n-        return constantDataContainer;\n-    }\n-\n-    public ByteContainer getKlassesGotContainer() {\n-        return klassesGotContainer;\n-    }\n-\n-    public ByteContainer getCountersGotContainer() {\n-        return countersGotContainer;\n-    }\n-\n-    public ByteContainer getMetadataGotContainer() {\n-        return metadataGotContainer;\n-    }\n-\n-    public ByteContainer getMethodStateContainer() {\n-        return methodStateContainer;\n-    }\n-\n-    public ByteContainer getOopGotContainer() {\n-        return oopGotContainer;\n-    }\n-\n-    public CodeContainer getCodeContainer() {\n-        return codeContainer;\n-    }\n-\n-    public ReadOnlyDataContainer getConfigContainer() {\n-        return configContainer;\n-    }\n-\n-    public Map<Symbol, Relocation> getUniqueRelocationTable() {\n-        return uniqueRelocationTable;\n-    }\n-\n-    public HeaderContainer getHeaderContainer() {\n-        return headerContainer;\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/BinaryContainer.java","additions":0,"deletions":959,"binary":false,"changes":959,"status":"deleted"},{"patch":"@@ -1,261 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat;\n-\n-import jdk.tools.jaotc.binformat.Symbol.Binding;\n-import jdk.tools.jaotc.binformat.Symbol.Kind;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-import java.util.Arrays;\n-\n-\/**\n- * Base class that represents content of all sections with byte-level granularity. The ByteContainer\n- * class is backed by a ByteArrayOutputStream. This class supports writing all desired byte content\n- * to the container using the method {@code appendBytes} and accessing the byte array using the\n- * method {@code getByteArray}.\n- *\n- * The method {@code putIntAt} updates the content of {@code contentBytes}. Changes are not\n- * reflected in {@code contentStream}.\n- *\/\n-public class ByteContainer implements Container {\n-    \/**\n-     * {@code ByteBuffer} representation of {@code BinaryContainer}.\n-     *\/\n-    private ByteBuffer contentBytes;\n-\n-    \/**\n-     * {@code ByteArrayoutputStream} to which all appends are done.\n-     *\/\n-    private ByteArrayOutputStream contentStream;\n-\n-    \/**\n-     * Boolean to indicate if contentBytes was modified.\n-     *\/\n-    private boolean bufferModified;\n-\n-    \/**\n-     * Boolean to indicate if this section contains any relocations.\n-     *\/\n-    private boolean hasRelocations;\n-\n-    \/**\n-     * Name of this container, used as section name.\n-     *\/\n-    private String containerName;\n-    private final SymbolTable symbolTable;\n-\n-    \/**\n-     * Contains a unique id.\n-     *\/\n-    private int sectionId = -1;\n-\n-    \/**\n-     * Construct a {@code ByteContainer} object.\n-     *\/\n-    public ByteContainer(String containerName, SymbolTable symbolTable) {\n-        this.containerName = containerName;\n-        this.symbolTable = symbolTable;\n-        this.contentBytes = null;\n-        this.bufferModified = false;\n-        this.hasRelocations = false;\n-        this.contentStream = new ByteArrayOutputStream();\n-    }\n-\n-    \/**\n-     * Update byte buffer to reflect the current contents of byte stream.\n-     *\n-     * @throws InternalError throws {@code InternalError} if buffer byte array was modified\n-     *\/\n-    private void updateByteBuffer() {\n-        if (!bufferModified) {\n-            contentBytes = ByteBuffer.wrap(contentStream.toByteArray());\n-            \/\/ Default byte order of ByteBuffer is BIG_ENDIAN.\n-            \/\/ Set it appropriately\n-            this.contentBytes.order(ByteOrder.nativeOrder());\n-        } else {\n-            throw new InternalError(\"Backing byte buffer no longer in sync with byte stream\");\n-        }\n-    }\n-\n-    \/**\n-     * Get the byte array of {@code ByteContainer}.\n-     *\n-     * @return byte array\n-     * @throws InternalError throws {@code InternalError} if buffer byte array was modified\n-     *\/\n-    public byte[] getByteArray() {\n-        if (!bufferModified) {\n-            updateByteBuffer();\n-        }\n-        return contentBytes.array();\n-    }\n-\n-    \/**\n-     * Append to byte stream. It is an error to append to stream if the byte buffer version is\n-     * changed.\n-     *\n-     * @param newBytes new content\n-     * @param off offset start offset in {@code newBytes}\n-     * @param len length of data to write\n-     * @throws InternalError throws {@code InternalError} if buffer byte array was modified\n-     *\/\n-    public ByteContainer appendBytes(byte[] newBytes, int off, int len) {\n-        if (bufferModified) {\n-            throw new InternalError(\"Backing byte buffer no longer in sync with byte stream\");\n-        }\n-        contentStream.write(newBytes, off, len);\n-        return this;\n-    }\n-\n-    public ByteContainer appendBytes(byte[] newBytes) {\n-        appendBytes(newBytes, 0, newBytes.length);\n-        return this;\n-    }\n-\n-    public ByteContainer appendInt(int i) {\n-        if (bufferModified) {\n-            throw new InternalError(\"Backing byte buffer no longer in sync with byte stream\");\n-        }\n-        ByteBuffer b = ByteBuffer.allocate(Integer.BYTES);\n-        b.order(ByteOrder.nativeOrder());\n-        b.putInt(i);\n-        byte[] result = b.array();\n-        contentStream.write(result, 0, result.length);\n-        return this;\n-    }\n-\n-    public ByteContainer appendInts(int[] newInts) {\n-        if (bufferModified) {\n-            throw new InternalError(\"Backing byte buffer no longer in sync with byte stream\");\n-        }\n-        ByteBuffer b = ByteBuffer.allocate(Integer.BYTES * newInts.length).order(ByteOrder.nativeOrder());\n-        Arrays.stream(newInts).forEach(i -> b.putInt(i));\n-        byte[] result = b.array();\n-        contentStream.write(result, 0, result.length);\n-        return this;\n-    }\n-\n-    public void appendLong(long l) {\n-        if (bufferModified) {\n-            throw new InternalError(\"Backing byte buffer no longer in sync with byte stream\");\n-        }\n-        ByteBuffer b = ByteBuffer.allocate(8);\n-        b.order(ByteOrder.nativeOrder());\n-        b.putLong(l);\n-        byte[] result = b.array();\n-        contentStream.write(result, 0, result.length);\n-    }\n-\n-    \/**\n-     * Return the current size of byte stream backing the BinaryContainer.\n-     *\n-     * @return size of buffer stream\n-     *\/\n-    public int getByteStreamSize() {\n-        return contentStream.size();\n-    }\n-\n-    \/**\n-     * Return the name of this container.\n-     *\n-     * @return string containing name\n-     *\/\n-    @Override\n-    public String getContainerName() {\n-        return containerName;\n-    }\n-\n-    \/**\n-     * Modify the byte buffer version of the byte output stream. Note that after calling this method\n-     * all further updates to BinaryContainer will be out of sync with byte buffer content.\n-     *\n-     * @param index index of byte to be changed\n-     * @param value new value\n-     *\/\n-    public void putIntAt(int index, int value) {\n-        if (!bufferModified) {\n-            updateByteBuffer();\n-        }\n-        contentBytes.putInt(index, value);\n-        bufferModified = true;\n-    }\n-\n-    public void putLongAt(int index, long value) {\n-        if (!bufferModified) {\n-            updateByteBuffer();\n-        }\n-        contentBytes.putLong(index, value);\n-        bufferModified = true;\n-    }\n-\n-    public void setSectionId(int id) {\n-        if (sectionId != -1) {\n-            throw new InternalError(\"Assigning new sectionId (old: \" + sectionId + \", new: \" + id + \")\");\n-        }\n-        sectionId = id;\n-    }\n-\n-    @Override\n-    public int getSectionId() {\n-        if (sectionId == -1) {\n-            throw new InternalError(\"Using sectionId before assigned\");\n-        }\n-        return sectionId;\n-    }\n-\n-    public Symbol createSymbol(int offset, Kind kind, Binding binding, int size, String name) {\n-        Symbol symbol = new Symbol(offset, kind, binding, this, size, name);\n-        symbolTable.addSymbol(symbol);\n-        return symbol;\n-    }\n-\n-    public GotSymbol createGotSymbol(String name) {\n-        GotSymbol symbol = new GotSymbol(Kind.OBJECT, Binding.LOCAL, this, name);\n-        symbolTable.addSymbol(symbol);\n-        return symbol;\n-    }\n-\n-    public GotSymbol createGotSymbol(int offset, String name) {\n-        GotSymbol symbol = new GotSymbol(offset, Kind.OBJECT, Binding.LOCAL, this, name);\n-        symbolTable.addSymbol(symbol);\n-        return symbol;\n-    }\n-\n-    public void clear() {\n-        this.contentBytes = null;\n-        this.contentStream = null;\n-    }\n-\n-    public void setHasRelocations() {\n-        this.hasRelocations = true;\n-    }\n-\n-    public boolean hasRelocations() {\n-        return this.hasRelocations;\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/ByteContainer.java","additions":0,"deletions":261,"binary":false,"changes":261,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat;\n-\n-\/**\n- * A container that holds information about code section. This is simply a ByteContainer.\n- *\/\n-public final class CodeContainer extends ByteContainer {\n-\n-    public CodeContainer(String containerName, SymbolTable symbolTable) {\n-        super(containerName, symbolTable);\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/CodeContainer.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat;\n-\n-interface Container {\n-\n-    String getContainerName();\n-\n-    int getSectionId();\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/Container.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat;\n-\n-public final class GotSymbol extends Symbol {\n-\n-    private static final int GOT_SIZE = 8;\n-\n-    public int getIndex() {\n-        int offset = getOffset();\n-        assert (offset % GOT_SIZE) == 0 : \"got cells should be aligned: \" + offset;\n-        return offset \/ GOT_SIZE;\n-    }\n-\n-    \/**\n-     * Create GOT symbol info.\n-     *\n-     * @param type type of the symbol (UNDEFINED, FUNC, etc)\n-     * @param binding binding of the symbol (LOCAL, GLOBAL, ...)\n-     * @param container section in which this symbol is \"defined\"\n-     * @param name name of the symbol\n-     *\/\n-    public GotSymbol(Kind type, Binding binding, ByteContainer container, String name) {\n-        this(container.getByteStreamSize(), type, binding, container, name);\n-        container.appendBytes(new byte[GOT_SIZE], 0, GOT_SIZE);\n-    }\n-\n-    \/**\n-     * Create GOT symbol info.\n-     *\n-     * @param offset section offset for the defined symbol\n-     * @param type type of the symbol (UNDEFINED, FUNC, etc)\n-     * @param binding binding of the symbol (LOCAL, GLOBAL, ...)\n-     * @param sec section in which this symbol is \"defined\"\n-     * @param name name of the symbol\n-     *\/\n-    public GotSymbol(int offset, Kind type, Binding binding, ByteContainer sec, String name) {\n-        super(offset, type, binding, sec, GOT_SIZE, name);\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/GotSymbol.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.DataOutputStream;\n-import java.io.IOException;\n-\n-public final class HeaderContainer {\n-\n-    private static final int CURRENT_VERSION = 1;\n-    private final ReadOnlyDataContainer container;\n-\n-    \/\/ int _version;\n-    \/\/ int _class_count;\n-    \/\/ int _method_count;\n-    \/\/ int _klasses_got_size;\n-    \/\/ int _metadata_got_size;\n-    \/\/ int _oop_got_size;\n-    \/\/ int _jvm_version_offset;\n-\n-    public HeaderContainer(String jvmVersion, ReadOnlyDataContainer container) {\n-        try {\n-            byte[] filler = new byte[4 * 7];\n-            container.appendBytes(filler);\n-\n-            \/\/ Store JVM version string at the end of header section.\n-            ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-            DataOutputStream out = new DataOutputStream(bout);\n-            out.writeUTF(jvmVersion);\n-            out.writeShort(0); \/\/ Terminate by 0.\n-            byte[] b = bout.toByteArray();\n-            container.appendBytes(b, 0, b.length);\n-        } catch (IOException e) {\n-            throw new InternalError(\"Failed to append bytes to header section\", e);\n-        }\n-\n-        this.container = container;\n-        this.container.putIntAt(0 * 4, CURRENT_VERSION);\n-        this.container.putIntAt(6 * 4, 7 * 4); \/\/ JVM version string offset\n-    }\n-\n-    public String getContainerName() {\n-        return container.getContainerName();\n-    }\n-\n-    public ReadOnlyDataContainer getContainer() {\n-        return container;\n-    }\n-\n-    public void setClassesCount(int count) {\n-        this.container.putIntAt(1 * 4, count);\n-    }\n-\n-    public void setMethodsCount(int count) {\n-        this.container.putIntAt(2 * 4, count);\n-    }\n-\n-    public void setKlassesGotSize(int size) {\n-        this.container.putIntAt(3 * 4, size);\n-    }\n-\n-    public void setMetadataGotSize(int size) {\n-        this.container.putIntAt(4 * 4, size);\n-    }\n-\n-    public void setOopGotSize(int size) {\n-        this.container.putIntAt(5 * 4, size);\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/HeaderContainer.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat;\n-\n-\/**\n- * This class represents a native OS specific Symbol.\n- *\/\n-public abstract class NativeSymbol {\n-\n-    \/** String table index. *\/\n-    private int index;\n-\n-    public NativeSymbol(int index) {\n-        this.index = index;\n-    }\n-\n-    \/**\n-     * @return the index\n-     *\/\n-    public int getIndex() {\n-        return index;\n-    }\n-\n-    \/**\n-     * @index\n-     *\/\n-    public void setIndex(int index) {\n-        this.index = index;\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/NativeSymbol.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat;\n-\n-public final class ReadOnlyDataContainer extends ByteContainer {\n-\n-    ReadOnlyDataContainer(String containerName, SymbolTable symbolTable) {\n-        super(containerName, symbolTable);\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/ReadOnlyDataContainer.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,97 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat;\n-\n-public final class Relocation {\n-\n-    \/\/ @formatter:off (workaround for Eclipse formatting bug)\n-    public enum RelocType {\n-        UNDEFINED,\n-        JAVA_CALL_INDIRECT,\n-        JAVA_CALL_DIRECT,\n-        FOREIGN_CALL_INDIRECT_GOT, \/\/ Call to address in GOT cell\n-        STUB_CALL_DIRECT,\n-        METASPACE_GOT_REFERENCE,\n-        EXTERNAL_GOT_TO_PLT,\n-        EXTERNAL_PLT_TO_GOT\n-    }\n-    \/\/ @formatter:on\n-\n-    private final RelocType type;\n-\n-    \/**\n-     * Byte offset from the beginning of the file affected by relocation.\n-     *\/\n-    private final int offset;\n-\n-    \/**\n-     * Size of relocation.\n-     *\/\n-    private final int size;\n-\n-    \/**\n-     * Symbol associated with this relocation.\n-     *\/\n-    private final Symbol symbol;\n-\n-    \/**\n-     * Section this relocation entry modifies.\n-     *\/\n-    private final ByteContainer section;\n-\n-    public Relocation(int offset, RelocType type, int size, ByteContainer section, Symbol sym) {\n-        if (sym == null) {\n-            throw new InternalError(\"must have symbol\");\n-        }\n-        this.offset = offset;\n-        this.type = type;\n-        this.size = size;\n-        this.symbol = sym;\n-        this.section = section;\n-        section.setHasRelocations();\n-    }\n-\n-    public RelocType getType() {\n-        return type;\n-    }\n-\n-    public int getOffset() {\n-        return offset;\n-    }\n-\n-    public int getSize() {\n-        return size;\n-    }\n-\n-    public Symbol getSymbol() {\n-        return symbol;\n-    }\n-\n-    public ByteContainer getSection() {\n-        return section;\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/Relocation.java","additions":0,"deletions":97,"binary":false,"changes":97,"status":"deleted"},{"patch":"@@ -1,154 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat;\n-\n-import java.util.Objects;\n-\n-public class Symbol {\n-\n-    \/\/ @formatter:off (workaround for Eclipse formatting bug)\n-    public enum Binding {\n-        UNDEFINED,\n-        LOCAL,\n-        GLOBAL\n-    }\n-\n-    public enum Kind {\n-        UNDEFINED,\n-        NATIVE_FUNCTION,\n-        JAVA_FUNCTION,\n-        OBJECT,\n-        NOTYPE\n-    }\n-    \/\/ @formatter:on\n-\n-    private final String name;\n-    private final int size;\n-    private final int offset;\n-    private final Binding binding;\n-    private final Kind kind;\n-\n-    private ByteContainer section;\n-    private NativeSymbol nativeSymbol;\n-\n-    \/**\n-     * Create symbol info.\n-     *\n-     * @param offset section offset for the defined symbol\n-     * @param kind kind of the symbol (UNDEFINED, FUNC, etc)\n-     * @param binding binding of the symbol (LOCAL, GLOBAL, ...)\n-     * @param section section in which this symbol is \"defined\"\n-     * @param size size of the symbol\n-     * @param name name of the symbol\n-     *\/\n-\n-    public Symbol(int offset, Kind kind, Binding binding, ByteContainer section, int size, String name) {\n-        this.binding = binding;\n-        this.kind = kind;\n-        this.section = section;\n-        this.size = size;\n-        this.offset = offset;\n-        this.name = name;\n-    }\n-\n-    public String getName() {\n-        return name;\n-    }\n-\n-    public NativeSymbol getNativeSymbol() {\n-        return nativeSymbol;\n-    }\n-\n-    public void setNativeSymbol(NativeSymbol nativeSym) {\n-        this.nativeSymbol = nativeSym;\n-    }\n-\n-    public Binding getBinding() {\n-        return binding;\n-    }\n-\n-    public Kind getKind() {\n-        return kind;\n-    }\n-\n-    public int getSize() {\n-        return size;\n-    }\n-\n-    public ByteContainer getSection() {\n-        return section;\n-    }\n-\n-    public int getOffset() {\n-        return offset;\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (this == obj) {\n-            return true;\n-        }\n-        if (!(obj instanceof Symbol)) {\n-            return false;\n-        }\n-        if (getClass() != obj.getClass()) {\n-            return false;\n-        }\n-\n-        Symbol symbol = (Symbol) obj;\n-\n-        if (size != symbol.size) {\n-            return false;\n-        }\n-        if (offset != symbol.offset) {\n-            return false;\n-        }\n-        if (!name.equals(symbol.name)) {\n-            return false;\n-        }\n-        if (binding != symbol.binding) {\n-            return false;\n-        }\n-        if (kind != symbol.kind) {\n-            return false;\n-        }\n-        return !(section != null ? !section.equals(symbol.section) : symbol.section != null);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        int result = Objects.hash(name, binding, kind, section);\n-        result = 31 * result + size;\n-        result = 31 * result + offset;\n-        return result;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"[\" + name + \", \" + size + \", \" + offset + \", \" + binding + \", \" + kind + \", \" + section + \"]\";\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/Symbol.java","additions":0,"deletions":154,"binary":false,"changes":154,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat;\n-\n-public interface SymbolTable {\n-    void addSymbol(Symbol symInfo);\n-\n-    Symbol getSymbol(String symName);\n-\n-    Symbol createSymbol(int offset, Symbol.Kind kind, Symbol.Binding binding, int size, String name);\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/SymbolTable.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -1,118 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.elf;\n-\n-import jdk.tools.jaotc.binformat.BinaryContainer;\n-import jdk.tools.jaotc.binformat.Relocation;\n-import jdk.tools.jaotc.binformat.Relocation.RelocType;\n-import jdk.tools.jaotc.binformat.Symbol;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Ehdr;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Rela;\n-\n-public class AArch64JELFRelocObject extends JELFRelocObject {\n-\n-    AArch64JELFRelocObject(BinaryContainer binContainer, String outputFileName) {\n-        super(binContainer, outputFileName);\n-    }\n-\n-    @Override\n-    void createRelocation(Symbol symbol, Relocation reloc, ElfRelocTable elfRelocTable) {\n-        RelocType relocType = reloc.getType();\n-\n-        int elfRelocType = getELFRelocationType(relocType);\n-        ElfSymbol sym = (ElfSymbol) symbol.getNativeSymbol();\n-        int symno = sym.getIndex();\n-        int sectindex = reloc.getSection().getSectionId();\n-        int offset = reloc.getOffset();\n-        int addend = 0;\n-\n-        switch (relocType) {\n-            case STUB_CALL_DIRECT:\n-            case JAVA_CALL_DIRECT: {\n-                break;\n-            }\n-            case EXTERNAL_PLT_TO_GOT:\n-                offset -= 16;\n-                elfRelocTable.createRelocationEntry(sectindex, offset, symno, Elf64_Rela.R_AARCH64_ADR_PREL_PG_HI21, addend);\n-                elfRelocTable.createRelocationEntry(sectindex, offset + 4, symno, Elf64_Rela.R_AARCH64_ADD_ABS_LO12_NC, addend);\n-                return;\n-\n-            case FOREIGN_CALL_INDIRECT_GOT: {\n-                break;\n-            }\n-            case METASPACE_GOT_REFERENCE: {\n-                offset -= 4;\n-\n-                elfRelocTable.createRelocationEntry(sectindex, offset, symno, Elf64_Rela.R_AARCH64_ADR_PREL_PG_HI21, addend);\n-                elfRelocTable.createRelocationEntry(sectindex, offset + 4, symno, Elf64_Rela.R_AARCH64_ADD_ABS_LO12_NC, addend);\n-                return;\n-            }\n-            \/\/ break;\n-            case JAVA_CALL_INDIRECT: {\n-                addend = -4;\n-                offset = offset + addend;\n-                break;\n-            }\n-            case EXTERNAL_GOT_TO_PLT: {\n-                \/\/ this is load time relocations\n-                break;\n-            }\n-            default:\n-                throw new InternalError(\"Unhandled relocation type: \" + relocType);\n-        }\n-\n-        elfRelocTable.createRelocationEntry(sectindex, offset, symno, elfRelocType, addend);\n-    }\n-\n-    int getELFRelocationType(RelocType relocType) {\n-        int elfRelocType = 0; \/\/ R_<ARCH>_NONE if #define'd to 0 for all values of ARCH\n-        switch (ElfTargetInfo.getElfArch()) {\n-            case Elf64_Ehdr.EM_AARCH64:\n-                \/\/ Return R_X86_64_* entries based on relocType\n-                if (relocType == RelocType.JAVA_CALL_DIRECT ||\n-                                relocType == RelocType.FOREIGN_CALL_INDIRECT_GOT) {\n-                    elfRelocType = Elf64_Rela.R_AARCH64_CALL26;\n-                } else if (relocType == RelocType.STUB_CALL_DIRECT) {\n-                    elfRelocType = Elf64_Rela.R_AARCH64_CALL26;\n-                } else if (relocType == RelocType.JAVA_CALL_INDIRECT) {\n-                    elfRelocType = Elf64_Rela.R_AARCH64_CALL26;\n-                } else if (relocType == RelocType.METASPACE_GOT_REFERENCE ||\n-                                relocType == RelocType.EXTERNAL_PLT_TO_GOT) {\n-                    elfRelocType = Elf64_Rela.R_AARCH64_NONE;\n-                } else if (relocType == RelocType.EXTERNAL_GOT_TO_PLT) {\n-                    elfRelocType = Elf64_Rela.R_AARCH64_ABS64;\n-                } else {\n-                    assert false : \"Unhandled relocation type: \" + relocType;\n-                }\n-                break;\n-\n-            default:\n-                System.out.println(\"Relocation Type mapping: Unhandled architecture: \" + ElfTargetInfo.getElfArch());\n-        }\n-        return elfRelocType;\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/elf\/AArch64JELFRelocObject.java","additions":0,"deletions":118,"binary":false,"changes":118,"status":"deleted"},{"patch":"@@ -1,111 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.elf;\n-\n-import jdk.tools.jaotc.binformat.BinaryContainer;\n-import jdk.tools.jaotc.binformat.Relocation;\n-import jdk.tools.jaotc.binformat.Relocation.RelocType;\n-import jdk.tools.jaotc.binformat.Symbol;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Ehdr;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Rela;\n-\n-public class AMD64JELFRelocObject extends JELFRelocObject {\n-\n-    AMD64JELFRelocObject(BinaryContainer binContainer, String outputFileName) {\n-        super(binContainer, outputFileName);\n-    }\n-\n-    @Override\n-    protected void createRelocation(Symbol symbol, Relocation reloc, ElfRelocTable elfRelocTable) {\n-        RelocType relocType = reloc.getType();\n-\n-        int elfRelocType = getELFRelocationType(relocType);\n-        ElfSymbol sym = (ElfSymbol) symbol.getNativeSymbol();\n-        int symno = sym.getIndex();\n-        int sectindex = reloc.getSection().getSectionId();\n-        int offset = reloc.getOffset();\n-        int addend = 0;\n-\n-        switch (relocType) {\n-            case JAVA_CALL_DIRECT:\n-            case STUB_CALL_DIRECT:\n-            case FOREIGN_CALL_INDIRECT_GOT: {\n-                \/\/ Create relocation entry\n-                addend = -4; \/\/ Size in bytes of the patch location\n-                \/\/ Relocation should be applied at the location after call operand\n-                offset = offset + reloc.getSize() + addend;\n-                break;\n-            }\n-            case JAVA_CALL_INDIRECT:\n-            case METASPACE_GOT_REFERENCE:\n-            case EXTERNAL_PLT_TO_GOT: {\n-                addend = -4; \/\/ Size of 32-bit address of the GOT\n-                \/*\n-                 * Relocation should be applied before the test instruction to the move instruction.\n-                 * reloc.getOffset() points to the test instruction after the instruction that loads\n-                 * the address of polling page. So set the offset appropriately.\n-                 *\/\n-                offset = offset + addend;\n-                break;\n-            }\n-            case EXTERNAL_GOT_TO_PLT: {\n-                \/\/ this is load time relocations\n-                break;\n-            }\n-            default:\n-                throw new InternalError(\"Unhandled relocation type: \" + relocType);\n-        }\n-        elfRelocTable.createRelocationEntry(sectindex, offset, symno, elfRelocType, addend);\n-    }\n-\n-    private static int getELFRelocationType(RelocType relocType) {\n-        int elfRelocType = 0; \/\/ R_<ARCH>_NONE if #define'd to 0 for all values of ARCH\n-        switch (ElfTargetInfo.getElfArch()) {\n-            case Elf64_Ehdr.EM_X86_64:\n-                \/\/ Return R_X86_64_* entries based on relocType\n-                if (relocType == RelocType.JAVA_CALL_DIRECT ||\n-                                relocType == RelocType.FOREIGN_CALL_INDIRECT_GOT) {\n-                    elfRelocType = Elf64_Rela.R_X86_64_PLT32;\n-                } else if (relocType == RelocType.STUB_CALL_DIRECT) {\n-                    elfRelocType = Elf64_Rela.R_X86_64_PC32;\n-                } else if (relocType == RelocType.JAVA_CALL_INDIRECT) {\n-                    elfRelocType = Elf64_Rela.R_X86_64_NONE;\n-                } else if (relocType == RelocType.METASPACE_GOT_REFERENCE ||\n-                                relocType == RelocType.EXTERNAL_PLT_TO_GOT) {\n-                    elfRelocType = Elf64_Rela.R_X86_64_PC32;\n-                } else if (relocType == RelocType.EXTERNAL_GOT_TO_PLT) {\n-                    elfRelocType = Elf64_Rela.R_X86_64_64;\n-                } else {\n-                    assert false : \"Unhandled relocation type: \" + relocType;\n-                }\n-                break;\n-\n-            default:\n-                System.out.println(\"Relocation Type mapping: Unhandled architecture: \" + ElfTargetInfo.getElfArch());\n-        }\n-        return elfRelocType;\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/elf\/AMD64JELFRelocObject.java","additions":0,"deletions":111,"binary":false,"changes":111,"status":"deleted"},{"patch":"@@ -1,277 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.elf;\n-\n-\/\/@Checkstyle: stop\n-\/\/@formatter:off\n-\n-\/**\n- * Support for the creation of Elf Object files. Current support is limited to 64 bit x86_64.\n- *\/\n-final class Elf {\n-    \/**\n-     * Elf64_Ehdr structure defines.\n-     *\/\n-    enum Elf64_Ehdr {\n-               e_ident( 0,16),\n-                e_type(16, 2),\n-             e_machine(18, 2),\n-             e_version(20, 4),\n-               e_entry(24, 8),\n-               e_phoff(32, 8),\n-               e_shoff(40, 8),\n-               e_flags(48, 4),\n-              e_ehsize(52, 2),\n-           e_phentsize(54, 2),\n-               e_phnum(56, 2),\n-           e_shentsize(58, 2),\n-               e_shnum(60, 2),\n-            e_shstrndx(62, 2);\n-\n-        final int off;\n-        final int sz;\n-\n-        Elf64_Ehdr(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 64;\n-\n-        \/**\n-         * Elf64_Ehdr defines\n-         *\/\n-\n-        \/**\n-         * e_ident\n-         *\/\n-        static final int  EI_MAG0        = 0;\n-        static final byte ELFMAG0        = 0x7f;\n-        static final int  EI_MAG1        = 1;\n-        static final byte ELFMAG1        = 0x45;\n-        static final int  EI_MAG2        = 2;\n-        static final byte ELFMAG2        = 0x4c;\n-        static final int  EI_MAG3        = 3;\n-        static final byte ELFMAG3        = 0x46;\n-        static final int  EI_CLASS       = 4;\n-        static final byte ELFCLASS64     = 0x2;\n-\n-        static final int  EI_DATA        = 5;\n-        static final byte ELFDATA2LSB    = 0x1;\n-\n-        static final int  EI_VERSION     = 6;\n-        static final byte EV_CURRENT     = 0x1;\n-\n-        static final int  EI_OSABI       = 7;\n-        static final byte ELFOSABI_NONE  = 0x0;\n-\n-        \/**\n-         * e_type\n-         *\/\n-        static final char ET_REL         = 0x1;\n-\n-        \/**\n-         * e_machine\n-         *\/\n-        static final char EM_NONE        = 0;\n-        static final char EM_X86_64      = 62;\n-        static final char EM_AARCH64     = 183;\n-\n-    }\n-\n-    \/**\n-     * Elf64_Shdr structure defines.\n-     *\/\n-    enum Elf64_Shdr {\n-               sh_name( 0, 4),\n-               sh_type( 4, 4),\n-              sh_flags( 8, 8),\n-               sh_addr(16, 8),\n-             sh_offset(24, 8),\n-               sh_size(32, 8),\n-               sh_link(40, 4),\n-               sh_info(44, 4),\n-          sh_addralign(48, 8),\n-            sh_entsize(56, 8);\n-\n-        final int off;\n-        final int sz;\n-\n-        Elf64_Shdr(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 64;\n-\n-        \/**\n-         * Elf64_Shdr defines\n-         *\/\n-\n-        \/**\n-         * sh_type\n-         *\/\n-        static final int SHT_PROGBITS   = 0x1;\n-        static final int SHT_SYMTAB     = 0x2;\n-        static final int SHT_STRTAB     = 0x3;\n-        static final int SHT_RELA       = 0x4;\n-        static final int SHT_NOBITS     = 0x8;\n-        static final int SHT_REL        = 0x9;\n-\n-        static final byte SHN_UNDEF     = 0x0;\n-\n-        \/**\n-         * sh_flag\n-         *\/\n-        static final int SHF_WRITE      = 0x1;\n-        static final int SHF_ALLOC      = 0x2;\n-        static final int SHF_EXECINSTR  = 0x4;\n-\n-    }\n-\n-    \/**\n-     * Symbol table entry definitions\n-     *\n-     * Elf64_Sym structure defines\n-     *\/\n-    enum Elf64_Sym {\n-               st_name( 0, 4),\n-               st_info( 4, 1),\n-              st_other( 5, 1),\n-              st_shndx( 6, 2),\n-              st_value( 8, 8),\n-               st_size(16, 8);\n-\n-        final int off;\n-        final int sz;\n-\n-        Elf64_Sym(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 24;\n-\n-        \/* ST_BIND is in bits 4-7 of st_info.  ST_TYPE is in low 4 bits *\/\n-        static final byte STB_LOCAL   = 0x0;\n-        static final byte STB_GLOBAL  = 0x1;\n-\n-        static final byte STT_NOTYPE  = 0x0;\n-        static final byte STT_OBJECT  = 0x1;\n-        static final byte STT_FUNC    = 0x2;\n-\n-        static byte ELF64_ST_INFO(byte bind, byte type) {\n-            return (byte)(((bind) << 4) + ((type) & 0xf));\n-        }\n-\n-    }\n-\n-    \/**\n-     * Elf64_Rel structure defines.\n-     *\/\n-    enum Elf64_Rel {\n-              r_offset( 0, 8),\n-                r_info( 8, 8);\n-\n-        final int off;\n-        final int sz;\n-\n-        Elf64_Rel(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 16;\n-\n-        \/**\n-         * Relocation types.\n-         *\/\n-\n-        static final int R_X86_64_NONE     = 0x0;\n-        static final int R_X86_64_64       = 0x1;\n-        static final int R_X86_64_PC32     = 0x2;\n-        static final int R_X86_64_PLT32    = 0x4;\n-        static final int R_X86_64_GOTPCREL = 0x9;\n-\n-        static final int R_AARCH64_NONE     = 256;\n-        static final int R_AARCH64_ABS64    = 257;\n-        static final int R_AARCH64_CALL26   = 283;\n-        static final int R_AARCH64_ADR_GOT_PAGE = 311;\n-        static final int R_AARCH64_LD64_GOT_LO12_NC = 312;\n-\n-        static final int R_AARCH64_MOVW_UABS_G0_NC = 264;\n-        static final int R_AARCH64_MOVW_UABS_G1_NC = 266;\n-        static final int R_AARCH64_MOVW_UABS_G2_NC = 268;\n-\n-        static final int R_AARCH64_ADR_PREL_PG_HI21 = 275;\n-        static final int R_AARCH64_ADD_ABS_LO12_NC = 277;\n-        static final int R_AARCH64_LDST64_ABS_LO12_NC = 286;\n-    }\n-\n-    \/**\n-     * Elf64_Rela structure defines\n-     *\/\n-    enum Elf64_Rela {\n-              r_offset( 0, 8),\n-                r_info( 8, 8),\n-              r_addend(16, 8);\n-\n-        final int off;\n-        final int sz;\n-\n-        Elf64_Rela(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 24;\n-\n-        static final int R_X86_64_NONE     = 0x0;\n-        static final int R_X86_64_64       = 0x1;\n-        static final int R_X86_64_PC32     = 0x2;\n-        static final int R_X86_64_PLT32    = 0x4;\n-        static final int R_X86_64_GOTPCREL = 0x9;\n-\n-        static final int R_AARCH64_NONE     = 256;\n-        static final int R_AARCH64_ABS64    = 257;\n-        static final int R_AARCH64_CALL26   = 283;\n-        static final int R_AARCH64_ADR_GOT_PAGE = 311;\n-        static final int R_AARCH64_LD64_GOT_LO12_NC = 312;\n-\n-        static final int R_AARCH64_MOVW_UABS_G0_NC = 264;\n-        static final int R_AARCH64_MOVW_UABS_G1_NC = 266;\n-        static final int R_AARCH64_MOVW_UABS_G2_NC = 268;\n-\n-        static final int R_AARCH64_ADR_PREL_PG_HI21 = 275;\n-        static final int R_AARCH64_ADD_ABS_LO12_NC = 277;\n-        static final int R_AARCH64_LDST64_ABS_LO12_NC = 286;\n-\n-        static long ELF64_R_INFO(int symidx, int type) {\n-            return (((long) symidx << 32) + type);\n-        }\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/elf\/Elf.java","additions":0,"deletions":277,"binary":false,"changes":277,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.elf;\n-\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Ehdr;\n-\n-final class ElfByteBuffer {\n-\n-    static ByteBuffer allocate(int size) {\n-        ByteBuffer buf = ByteBuffer.allocate(size);\n-        if (ElfTargetInfo.getElfEndian() == Elf64_Ehdr.ELFDATA2LSB) {\n-            buf.order(ByteOrder.LITTLE_ENDIAN);\n-        } else {\n-            buf.order(ByteOrder.BIG_ENDIAN);\n-        }\n-        return (buf);\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/elf\/ElfByteBuffer.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,89 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.elf;\n-\n-import java.io.File;\n-import java.io.FileOutputStream;\n-\n-final class ElfContainer {\n-\n-    private final File outputFile;\n-    private FileOutputStream outputStream;\n-    private long fileOffset;\n-\n-    ElfContainer(String fileName) {\n-\n-        outputFile = new File(fileName);\n-        if (outputFile.exists()) {\n-            outputFile.delete();\n-        }\n-\n-        try {\n-            outputStream = new FileOutputStream(outputFile);\n-        } catch (Exception e) {\n-            System.out.println(\"ElfContainer: Can't create file \" + fileName);\n-        }\n-        fileOffset = 0;\n-    }\n-\n-    void close() {\n-        try {\n-            outputStream.close();\n-        } catch (Exception e) {\n-            System.out.println(\"ElfContainer: close failed\");\n-        }\n-    }\n-\n-    void writeBytes(byte[] bytes) {\n-        if (bytes == null) {\n-            return;\n-        }\n-        try {\n-            outputStream.write(bytes);\n-        } catch (Exception e) {\n-            System.out.println(\"ElfContainer: writeBytes failed\");\n-        }\n-        fileOffset += bytes.length;\n-    }\n-\n-    \/\/ Write bytes to output file with up front alignment padding\n-    void writeBytes(byte[] bytes, int alignment) {\n-        if (bytes == null) {\n-            return;\n-        }\n-        try {\n-            \/\/ Pad to alignment\n-            while ((fileOffset & (alignment - 1)) != 0) {\n-                outputStream.write(0);\n-                fileOffset++;\n-            }\n-            outputStream.write(bytes);\n-        } catch (Exception e) {\n-            System.out.println(\"ElfContainer: writeBytes failed\");\n-        }\n-        fileOffset += bytes.length;\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/elf\/ElfContainer.java","additions":0,"deletions":89,"binary":false,"changes":89,"status":"deleted"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.elf;\n-\n-import java.nio.ByteBuffer;\n-\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Ehdr;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Shdr;\n-\n-final class ElfHeader {\n-    private final ByteBuffer header;\n-\n-    ElfHeader() {\n-        header = ElfByteBuffer.allocate(Elf64_Ehdr.totalsize);\n-\n-        header.put(Elf64_Ehdr.e_ident.off + Elf64_Ehdr.EI_MAG0, Elf64_Ehdr.ELFMAG0);\n-        header.put(Elf64_Ehdr.e_ident.off + Elf64_Ehdr.EI_MAG1, Elf64_Ehdr.ELFMAG1);\n-        header.put(Elf64_Ehdr.e_ident.off + Elf64_Ehdr.EI_MAG2, Elf64_Ehdr.ELFMAG2);\n-        header.put(Elf64_Ehdr.e_ident.off + Elf64_Ehdr.EI_MAG3, Elf64_Ehdr.ELFMAG3);\n-        header.put(Elf64_Ehdr.e_ident.off + Elf64_Ehdr.EI_CLASS, Elf64_Ehdr.ELFCLASS64);\n-        header.put(Elf64_Ehdr.e_ident.off + Elf64_Ehdr.EI_DATA, Elf64_Ehdr.ELFDATA2LSB);\n-        header.put(Elf64_Ehdr.e_ident.off + Elf64_Ehdr.EI_VERSION, Elf64_Ehdr.EV_CURRENT);\n-        header.put(Elf64_Ehdr.e_ident.off + Elf64_Ehdr.EI_OSABI, Elf64_Ehdr.ELFOSABI_NONE);\n-\n-        header.putChar(Elf64_Ehdr.e_type.off, Elf64_Ehdr.ET_REL);\n-        header.putChar(Elf64_Ehdr.e_machine.off, ElfTargetInfo.getElfArch());\n-        header.putInt(Elf64_Ehdr.e_version.off, Elf64_Ehdr.EV_CURRENT);\n-        header.putChar(Elf64_Ehdr.e_ehsize.off, (char) Elf64_Ehdr.totalsize);\n-        header.putChar(Elf64_Ehdr.e_shentsize.off, (char) Elf64_Shdr.totalsize);\n-\n-    }\n-\n-    \/\/ Update header with file offset of first section\n-    void setSectionOff(int offset) {\n-        header.putLong(Elf64_Ehdr.e_shoff.off, offset);\n-    }\n-\n-    \/\/ Update header with the number of total sections\n-    void setSectionNum(int count) {\n-        header.putChar(Elf64_Ehdr.e_shnum.off, (char) count);\n-    }\n-\n-    \/\/ Update header with the section index containing the\n-    \/\/ string table for section names\n-    void setSectionStrNdx(int index) {\n-        header.putChar(Elf64_Ehdr.e_shstrndx.off, (char) index);\n-    }\n-\n-    byte[] getArray() {\n-        return header.array();\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/elf\/ElfHeader.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.elf;\n-\n-import java.nio.ByteBuffer;\n-\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Rela;\n-\n-final class ElfRelocEntry {\n-    private final ByteBuffer entry;\n-\n-    ElfRelocEntry(int offset, int symno, int type, int addend) {\n-\n-        entry = ElfByteBuffer.allocate(Elf64_Rela.totalsize);\n-\n-        entry.putLong(Elf64_Rela.r_offset.off, offset);\n-        entry.putLong(Elf64_Rela.r_info.off, Elf64_Rela.ELF64_R_INFO(symno, type));\n-        entry.putLong(Elf64_Rela.r_addend.off, addend);\n-    }\n-\n-    byte[] getArray() {\n-        return entry.array();\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/elf\/ElfRelocEntry.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.elf;\n-\n-import java.nio.ByteBuffer;\n-import java.util.ArrayList;\n-\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Rela;\n-\n-final class ElfRelocTable {\n-    private final ArrayList<ArrayList<ElfRelocEntry>> relocEntries;\n-\n-    ElfRelocTable(int numsects) {\n-        relocEntries = new ArrayList<>(numsects);\n-        for (int i = 0; i < numsects; i++) {\n-            relocEntries.add(new ArrayList<ElfRelocEntry>());\n-        }\n-    }\n-\n-    void createRelocationEntry(int sectindex, int offset, int symno, int type, int addend) {\n-        ElfRelocEntry entry = new ElfRelocEntry(offset, symno, type, addend);\n-        relocEntries.get(sectindex).add(entry);\n-    }\n-\n-    int getNumRelocs(int sectionIndex) {\n-        return relocEntries.get(sectionIndex).size();\n-    }\n-\n-    \/\/ Return the relocation entries for a single section\n-    \/\/ or null if no entries added to section\n-    byte[] getRelocData(int sectionIndex) {\n-        ArrayList<ElfRelocEntry> entryList = relocEntries.get(sectionIndex);\n-\n-        if (entryList.size() == 0) {\n-            return null;\n-        }\n-        ByteBuffer relocData = ElfByteBuffer.allocate(entryList.size() * Elf64_Rela.totalsize);\n-\n-        \/\/ Copy each entry to a single ByteBuffer\n-        for (int i = 0; i < entryList.size(); i++) {\n-            ElfRelocEntry entry = entryList.get(i);\n-            relocData.put(entry.getArray());\n-        }\n-\n-        return (relocData.array());\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/elf\/ElfRelocTable.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -1,157 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.elf;\n-\n-import java.nio.ByteBuffer;\n-\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Rel;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Rela;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Shdr;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Sym;\n-\n-final class ElfSection {\n-    private final String name;\n-    private final ByteBuffer section;\n-    private final byte[] data;\n-    private final boolean hasrelocations;\n-    private final int sectionIndex;\n-\n-    \/**\n-     * String holding section name strings.\n-     *\/\n-    private static final StringBuilder sectNameTab = new StringBuilder();\n-\n-    \/**\n-     * Keeps track of bytes in section string table since strTabContent.length() is number of chars,\n-     * not bytes.\n-     *\/\n-    private static int shStrTabNrOfBytes = 0;\n-\n-    ElfSection(String sectName, byte[] sectData, int sectFlags, int sectType,\n-                    boolean hasRelocations, int align, int sectIndex) {\n-\n-        section = ElfByteBuffer.allocate(Elf64_Shdr.totalsize);\n-        name = sectName;\n-        \/\/ Return all 0's for NULL section\n-        if (sectIndex == 0) {\n-            sectNameTab.append('\\0');\n-            shStrTabNrOfBytes += 1;\n-            data = null;\n-            hasrelocations = false;\n-            sectionIndex = 0;\n-            return;\n-        }\n-\n-        section.putInt(Elf64_Shdr.sh_name.off, shStrTabNrOfBytes);\n-        sectNameTab.append(sectName).append('\\0');\n-        shStrTabNrOfBytes += (sectName.getBytes().length + 1);\n-\n-        section.putInt(Elf64_Shdr.sh_type.off, sectType);\n-        section.putLong(Elf64_Shdr.sh_flags.off, sectFlags);\n-        section.putLong(Elf64_Shdr.sh_addr.off, 0);\n-        section.putLong(Elf64_Shdr.sh_offset.off, 0);\n-\n-        if (sectName.equals(\".shstrtab\")) {\n-            section.putLong(Elf64_Shdr.sh_size.off, shStrTabNrOfBytes);\n-            data = sectNameTab.toString().getBytes();\n-        } else {\n-            data = sectData;\n-            section.putLong(Elf64_Shdr.sh_size.off, sectData.length);\n-        }\n-\n-        section.putLong(Elf64_Shdr.sh_entsize.off, 0);\n-\n-        \/\/ Determine the entrysize\n-        \/\/ based on type of section\n-        switch (sectType) {\n-            case Elf64_Shdr.SHT_SYMTAB:\n-                section.putLong(Elf64_Shdr.sh_entsize.off, Elf64_Sym.totalsize);\n-                break;\n-            case Elf64_Shdr.SHT_RELA:\n-                section.putLong(Elf64_Shdr.sh_entsize.off, Elf64_Rela.totalsize);\n-                break;\n-            case Elf64_Shdr.SHT_REL:\n-                section.putLong(Elf64_Shdr.sh_entsize.off, Elf64_Rel.totalsize);\n-                break;\n-            default:\n-                break;\n-        }\n-        section.putLong(Elf64_Shdr.sh_addralign.off, align);\n-\n-        hasrelocations = hasRelocations;\n-        sectionIndex = sectIndex;\n-    }\n-\n-    String getName() {\n-        return name;\n-    }\n-\n-    long getSize() {\n-        return section.getLong(Elf64_Shdr.sh_size.off);\n-    }\n-\n-    int getDataAlign() {\n-        return ((int) section.getLong(Elf64_Shdr.sh_addralign.off));\n-    }\n-\n-    \/\/ Alignment requirements for the Elf64_Shdr structures\n-    static int getShdrAlign() {\n-        return (4);\n-    }\n-\n-    byte[] getArray() {\n-        return section.array();\n-    }\n-\n-    byte[] getDataArray() {\n-        return data;\n-    }\n-\n-    void setOffset(long offset) {\n-        section.putLong(Elf64_Shdr.sh_offset.off, offset);\n-    }\n-\n-    void setLink(int link) {\n-        section.putInt(Elf64_Shdr.sh_link.off, link);\n-    }\n-\n-    void setInfo(int info) {\n-        section.putInt(Elf64_Shdr.sh_info.off, info);\n-    }\n-\n-    long getOffset() {\n-        return (section.getLong(Elf64_Shdr.sh_offset.off));\n-    }\n-\n-    boolean hasRelocations() {\n-        return hasrelocations;\n-    }\n-\n-    int getSectionId() {\n-        return sectionIndex;\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/elf\/ElfSection.java","additions":0,"deletions":157,"binary":false,"changes":157,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.elf;\n-\n-import java.nio.ByteBuffer;\n-\n-import jdk.tools.jaotc.binformat.NativeSymbol;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Sym;\n-\n-final class ElfSymbol extends NativeSymbol {\n-    private final ByteBuffer sym;\n-\n-    ElfSymbol(int symbolindex, int strindex, byte type, byte bind, byte sectindex, long offset, long size) {\n-        super(symbolindex);\n-        sym = ElfByteBuffer.allocate(Elf64_Sym.totalsize);\n-\n-        sym.putInt(Elf64_Sym.st_name.off, strindex);\n-        sym.put(Elf64_Sym.st_info.off, Elf64_Sym.ELF64_ST_INFO(bind, type));\n-        sym.put(Elf64_Sym.st_other.off, (byte) 0);\n-        \/\/ Section indexes start at 1 but we manage the index internally\n-        \/\/ as 0 relative\n-        sym.putChar(Elf64_Sym.st_shndx.off, (char) (sectindex));\n-        sym.putLong(Elf64_Sym.st_value.off, offset);\n-        sym.putLong(Elf64_Sym.st_size.off, size);\n-    }\n-\n-    byte[] getArray() {\n-        return sym.array();\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/elf\/ElfSymbol.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,146 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.elf;\n-\n-import java.nio.ByteBuffer;\n-import java.util.ArrayList;\n-\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Sym;\n-\n-final class ElfSymtab {\n-\n-    private final ArrayList<ElfSymbol> localSymbols = new ArrayList<>();\n-    private final ArrayList<ElfSymbol> globalSymbols = new ArrayList<>();\n-\n-    \/**\n-     * Number of symbols added.\n-     *\/\n-    private int symbolCount;\n-\n-    \/**\n-     * String holding symbol table strings.\n-     *\/\n-    private final StringBuilder strTabContent = new StringBuilder();\n-\n-    \/**\n-     * Keeps track of bytes in string table since strTabContent.length() is number of chars, not\n-     * bytes.\n-     *\/\n-    private int strTabNrOfBytes = 0;\n-\n-    ElfSymtab() {\n-        symbolCount = 0;\n-    }\n-\n-    ElfSymbol addSymbolEntry(String name, byte type, byte bind, byte secHdrIndex, long offset, long size) {\n-        \/\/ Get the current symbol index and append symbol name to string table.\n-        int index;\n-        ElfSymbol sym;\n-\n-        if (name.isEmpty()) {\n-            index = 0;\n-            strTabContent.append('\\0');\n-            strTabNrOfBytes += 1;\n-            sym = new ElfSymbol(symbolCount, index, type, bind, secHdrIndex, offset, size);\n-            localSymbols.add(sym);\n-        } else {\n-            \/\/ We can't trust strTabContent.length() since that is\n-            \/\/ chars (UTF16), keep track of bytes on our own.\n-            index = strTabNrOfBytes;\n-            \/\/ strTabContent.append(\"_\").append(name).append('\\0');\n-            strTabContent.append(name).append('\\0');\n-            \/\/ + 1 for null, + 1 for \"_\"\n-            \/\/ strTabNrOfBytes += (name.getBytes().length + 1 + 1);\n-            strTabNrOfBytes += (name.getBytes().length + 1);\n-\n-            sym = new ElfSymbol(symbolCount, index, type, bind, secHdrIndex, offset, size);\n-            if ((bind & Elf64_Sym.STB_GLOBAL) != 0) {\n-                globalSymbols.add(sym);\n-            } else {\n-                localSymbols.add(sym);\n-            }\n-        }\n-        symbolCount++;\n-        return (sym);\n-    }\n-\n-    \/\/ Update the symbol indexes once all symbols have been added.\n-    \/\/ This is required since we'll be reordering the symbols in the\n-    \/\/ file to be in the order of Local then global.\n-    void updateIndexes() {\n-        int index = 0;\n-\n-        \/\/ Update the local symbol indexes\n-        for (int i = 0; i < localSymbols.size(); i++) {\n-            ElfSymbol sym = localSymbols.get(i);\n-            sym.setIndex(index++);\n-        }\n-\n-        \/\/ Update the global symbol indexes\n-        for (int i = 0; i < globalSymbols.size(); i++) {\n-            ElfSymbol sym = globalSymbols.get(i);\n-            sym.setIndex(index++);\n-        }\n-    }\n-\n-    int getNumLocalSyms() {\n-        return localSymbols.size();\n-    }\n-\n-    int getNumGlobalSyms() {\n-        return globalSymbols.size();\n-    }\n-\n-    \/\/ Create a single byte array that contains the symbol table entries\n-    byte[] getSymtabArray() {\n-        ByteBuffer symtabData = ElfByteBuffer.allocate(symbolCount * Elf64_Sym.totalsize);\n-        byte[] retarray;\n-\n-        updateIndexes();\n-\n-        \/\/ Add the local symbols\n-        for (int i = 0; i < localSymbols.size(); i++) {\n-            ElfSymbol sym = localSymbols.get(i);\n-            byte[] arr = sym.getArray();\n-            symtabData.put(arr);\n-        }\n-        \/\/ Add the global symbols\n-        for (int i = 0; i < globalSymbols.size(); i++) {\n-            ElfSymbol sym = globalSymbols.get(i);\n-            byte[] arr = sym.getArray();\n-            symtabData.put(arr);\n-        }\n-        retarray = symtabData.array();\n-\n-        return (retarray);\n-    }\n-\n-    \/\/ Return the string table array\n-    byte[] getStrtabArray() {\n-        byte[] strs = strTabContent.toString().getBytes();\n-        return (strs);\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/elf\/ElfSymtab.java","additions":0,"deletions":146,"binary":false,"changes":146,"status":"deleted"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.elf;\n-\n-import java.nio.ByteOrder;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Ehdr;\n-\n-\/**\n- * Class that abstracts MACH-O target details.\n- *\n- *\/\n-final class ElfTargetInfo {\n-    \/**\n-     * Target architecture.\n-     *\/\n-    private static final char arch;\n-\n-    \/**\n-     * Architecture endian-ness.\n-     *\/\n-    private static final int endian = Elf64_Ehdr.ELFDATA2LSB;\n-\n-    \/**\n-     * Target OS string.\n-     *\/\n-    private static String osName;\n-\n-    static {\n-        \/\/ Find the target arch details\n-        String archStr = System.getProperty(\"os.arch\").toLowerCase();\n-        if (ByteOrder.nativeOrder() != ByteOrder.LITTLE_ENDIAN) {\n-            System.out.println(\"Only Little Endian byte order supported!\");\n-        }\n-\n-        if (archStr.equals(\"amd64\") || archStr.equals(\"x86_64\")) {\n-            arch = Elf64_Ehdr.EM_X86_64;\n-        } else if (archStr.equals(\"aarch64\")) {\n-            arch = Elf64_Ehdr.EM_AARCH64;\n-        } else {\n-            System.out.println(\"Unsupported architecture \" + archStr);\n-            arch = Elf64_Ehdr.EM_NONE;\n-        }\n-\n-        osName = System.getProperty(\"os.name\").toLowerCase();\n-        if (!osName.equals(\"linux\")) {\n-            System.out.println(\"Unsupported Operating System \" + osName);\n-            osName = \"Unknown\";\n-        }\n-    }\n-\n-    static char getElfArch() {\n-        return arch;\n-    }\n-\n-    static int getElfEndian() {\n-        return endian;\n-    }\n-\n-    static String getOsName() {\n-        return osName;\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/elf\/ElfTargetInfo.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -1,328 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.elf;\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.Map;\n-\n-import jdk.tools.jaotc.binformat.BinaryContainer;\n-import jdk.tools.jaotc.binformat.ByteContainer;\n-import jdk.tools.jaotc.binformat.CodeContainer;\n-import jdk.tools.jaotc.binformat.ReadOnlyDataContainer;\n-import jdk.tools.jaotc.binformat.Relocation;\n-import jdk.tools.jaotc.binformat.Symbol;\n-import jdk.tools.jaotc.binformat.Symbol.Binding;\n-import jdk.tools.jaotc.binformat.Symbol.Kind;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Ehdr;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Shdr;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Sym;\n-\n-public abstract class JELFRelocObject {\n-\n-    private final BinaryContainer binContainer;\n-\n-    private final ElfContainer elfContainer;\n-\n-    private final int segmentSize;\n-\n-    protected JELFRelocObject(BinaryContainer binContainer, String outputFileName) {\n-        this.binContainer = binContainer;\n-        this.elfContainer = new ElfContainer(outputFileName);\n-        this.segmentSize = binContainer.getCodeSegmentSize();\n-    }\n-\n-    public static JELFRelocObject newInstance(BinaryContainer binContainer, String outputFileName) {\n-        String archStr = System.getProperty(\"os.arch\").toLowerCase();\n-        if (archStr.equals(\"amd64\") || archStr.equals(\"x86_64\")) {\n-            return new AMD64JELFRelocObject(binContainer, outputFileName);\n-        } else if (archStr.equals(\"aarch64\")) {\n-            return new AArch64JELFRelocObject(binContainer, outputFileName);\n-        }\n-        throw new InternalError(\"Unsupported platform: \" + archStr);\n-    }\n-\n-    private static ElfSection createByteSection(ArrayList<ElfSection> sections,\n-                    String sectName,\n-                    byte[] scnData,\n-                    boolean hasRelocs,\n-                    int align,\n-                    int scnFlags,\n-                    int scnType) {\n-\n-        ElfSection sect = new ElfSection(sectName, scnData, scnFlags, scnType,\n-                        hasRelocs, align, sections.size());\n-        \/\/ Add this section to our list\n-        sections.add(sect);\n-\n-        return (sect);\n-    }\n-\n-    private void createByteSection(ArrayList<ElfSection> sections,\n-                    ByteContainer c, int scnFlags) {\n-        ElfSection sect;\n-        boolean hasRelocs = c.hasRelocations();\n-        byte[] scnData = c.getByteArray();\n-\n-        int scnType = Elf64_Shdr.SHT_PROGBITS;\n-        boolean zeros = !hasRelocs;\n-        if (zeros) {\n-            for (byte b : scnData) {\n-                if (b != 0) {\n-                    zeros = false;\n-                    break;\n-                }\n-            }\n-            if (zeros) {\n-                scnType = Elf64_Shdr.SHT_NOBITS;\n-            }\n-        }\n-\n-        sect = createByteSection(sections, c.getContainerName(),\n-                        scnData, hasRelocs, segmentSize,\n-                        scnFlags, scnType);\n-        c.setSectionId(sect.getSectionId());\n-    }\n-\n-    private void createCodeSection(ArrayList<ElfSection> sections, CodeContainer c) {\n-        createByteSection(sections, c, Elf64_Shdr.SHF_ALLOC | Elf64_Shdr.SHF_EXECINSTR);\n-    }\n-\n-    private void createReadOnlySection(ArrayList<ElfSection> sections, ReadOnlyDataContainer c) {\n-        createByteSection(sections, c, Elf64_Shdr.SHF_ALLOC);\n-    }\n-\n-    private void createReadWriteSection(ArrayList<ElfSection> sections, ByteContainer c) {\n-        createByteSection(sections, c, Elf64_Shdr.SHF_ALLOC | Elf64_Shdr.SHF_WRITE);\n-    }\n-\n-    \/**\n-     * Creates an ELF relocatable object.\n-     *\n-     * @param relocationTable\n-     * @param symbols\n-     * @throws IOException throws {@code IOException} as a result of file system access failures.\n-     *\/\n-    public void createELFRelocObject(Map<Symbol, List<Relocation>> relocationTable, Collection<Symbol> symbols) throws IOException {\n-        \/\/ Allocate ELF Header\n-        ElfHeader eh = new ElfHeader();\n-\n-        ArrayList<ElfSection> sections = new ArrayList<>();\n-\n-        \/\/ Create the null section\n-        createByteSection(sections, null, null, false, 1, 0, 0);\n-\n-        \/\/ Create text section\n-        createCodeSection(sections, binContainer.getCodeContainer());\n-        createReadOnlySection(sections, binContainer.getMetaspaceNamesContainer());\n-        createReadOnlySection(sections, binContainer.getKlassesOffsetsContainer());\n-        createReadOnlySection(sections, binContainer.getMethodsOffsetsContainer());\n-        createReadOnlySection(sections, binContainer.getKlassesDependenciesContainer());\n-        createReadOnlySection(sections, binContainer.getMethodMetadataContainer());\n-        createReadOnlySection(sections, binContainer.getStubsOffsetsContainer());\n-        createReadOnlySection(sections, binContainer.getHeaderContainer().getContainer());\n-        createReadOnlySection(sections, binContainer.getCodeSegmentsContainer());\n-        createReadOnlySection(sections, binContainer.getConstantDataContainer());\n-        createReadOnlySection(sections, binContainer.getConfigContainer());\n-        createReadWriteSection(sections, binContainer.getKlassesGotContainer());\n-        createReadWriteSection(sections, binContainer.getCountersGotContainer());\n-        createReadWriteSection(sections, binContainer.getMetadataGotContainer());\n-        createReadWriteSection(sections, binContainer.getOopGotContainer());\n-        createReadWriteSection(sections, binContainer.getMethodStateContainer());\n-        createReadWriteSection(sections, binContainer.getExtLinkageGOTContainer());\n-\n-        \/\/ Get ELF symbol data from BinaryContainer object's symbol tables\n-        ElfSymtab symtab = createELFSymbolTables(symbols);\n-\n-        \/\/ Create string table section and symbol table sections in\n-        \/\/ that order since symtab section needs to set the index of\n-        \/\/ strtab in sh_link field\n-        ElfSection strTabSection = createByteSection(sections, \".strtab\",\n-                        symtab.getStrtabArray(),\n-                        false, 1, 0,\n-                        Elf64_Shdr.SHT_STRTAB);\n-\n-        \/\/ Now create .symtab section with the symtab data constructed.\n-        \/\/ On Linux, sh_link of symtab contains the index of string table\n-        \/\/ its symbols reference and sh_info contains the index of first\n-        \/\/ non-local symbol\n-        ElfSection symTabSection = createByteSection(sections, \".symtab\",\n-                        symtab.getSymtabArray(),\n-                        false, 8, 0,\n-                        Elf64_Shdr.SHT_SYMTAB);\n-        symTabSection.setLink(strTabSection.getSectionId());\n-        symTabSection.setInfo(symtab.getNumLocalSyms());\n-\n-        ElfRelocTable elfRelocTable = createElfRelocTable(sections, relocationTable);\n-\n-        createElfRelocSections(sections, elfRelocTable, symTabSection.getSectionId());\n-\n-        \/\/ Now, finally, after creating all sections, create shstrtab section\n-        ElfSection shStrTabSection = createByteSection(sections, \".shstrtab\",\n-                        null, false, 1, 0,\n-                        Elf64_Shdr.SHT_STRTAB);\n-        eh.setSectionStrNdx(shStrTabSection.getSectionId());\n-\n-        \/\/ Update all section offsets and the Elf header section offset\n-        \/\/ Write the Header followed by the contents of each section\n-        \/\/ and then the section structures (section table).\n-        int fileOffset = Elf64_Ehdr.totalsize;\n-\n-        \/\/ and round it up\n-        fileOffset = (fileOffset + (sections.get(1).getDataAlign() - 1)) &\n-                        ~((sections.get(1).getDataAlign() - 1));\n-\n-        \/\/ Calc file offsets for section data skipping null section\n-        for (int i = 1; i < sections.size(); i++) {\n-            ElfSection sect = sections.get(i);\n-            fileOffset = (fileOffset + (sect.getDataAlign() - 1)) &\n-                            ~((sect.getDataAlign() - 1));\n-            sect.setOffset(fileOffset);\n-            fileOffset += sect.getSize();\n-        }\n-\n-        \/\/ Align the section table\n-        fileOffset = (fileOffset + (ElfSection.getShdrAlign() - 1)) &\n-                        ~((ElfSection.getShdrAlign() - 1));\n-\n-        \/\/ Update the Elf Header with the offset of the first Elf64_Shdr\n-        \/\/ and the number of sections.\n-        eh.setSectionOff(fileOffset);\n-        eh.setSectionNum(sections.size());\n-\n-        \/\/ Write out the Header\n-        elfContainer.writeBytes(eh.getArray());\n-\n-        \/\/ Write out each section contents skipping null section\n-        for (int i = 1; i < sections.size(); i++) {\n-            ElfSection sect = sections.get(i);\n-            elfContainer.writeBytes(sect.getDataArray(), sect.getDataAlign());\n-        }\n-\n-        \/\/ Write out the section table\n-        for (int i = 0; i < sections.size(); i++) {\n-            ElfSection sect = sections.get(i);\n-            elfContainer.writeBytes(sect.getArray(), ElfSection.getShdrAlign());\n-        }\n-\n-        elfContainer.close();\n-    }\n-\n-    \/**\n-     * Construct ELF symbol data from BinaryContainer object's symbol tables. Both dynamic ELF\n-     * symbol table and ELF symbol table are created from BinaryContainer's symbol info.\n-     *\n-     * @param symbols\n-     *\/\n-    private static ElfSymtab createELFSymbolTables(Collection<Symbol> symbols) {\n-        ElfSymtab symtab = new ElfSymtab();\n-\n-        \/\/ First, create the initial null symbol. This is a local symbol.\n-        symtab.addSymbolEntry(\"\", (byte) 0, (byte) 0, Elf64_Shdr.SHN_UNDEF, 0, 0);\n-\n-        \/\/ Now create ELF symbol entries for all symbols.\n-        for (Symbol symbol : symbols) {\n-            \/\/ Get the index of section this symbol is defined in.\n-            int secHdrIndex = symbol.getSection().getSectionId();\n-            ElfSymbol elfSymbol = symtab.addSymbolEntry(symbol.getName(), getELFTypeOf(symbol), getELFBindOf(symbol), (byte) secHdrIndex, symbol.getOffset(), symbol.getSize());\n-            symbol.setNativeSymbol(elfSymbol);\n-        }\n-        return (symtab);\n-    }\n-\n-    private static byte getELFTypeOf(Symbol sym) {\n-        Kind kind = sym.getKind();\n-        if (kind == Symbol.Kind.NATIVE_FUNCTION || kind == Symbol.Kind.JAVA_FUNCTION) {\n-            return Elf64_Sym.STT_FUNC;\n-        } else if (kind == Symbol.Kind.OBJECT) {\n-            return Elf64_Sym.STT_OBJECT;\n-        }\n-        return Elf64_Sym.STT_NOTYPE;\n-    }\n-\n-    private static byte getELFBindOf(Symbol sym) {\n-        Binding binding = sym.getBinding();\n-        if (binding == Symbol.Binding.GLOBAL) {\n-            return Elf64_Sym.STB_GLOBAL;\n-        }\n-        return Elf64_Sym.STB_LOCAL;\n-    }\n-\n-    \/**\n-     * Construct a Elf relocation table from BinaryContainer object's relocation tables.\n-     *\n-     * @param sections\n-     * @param relocationTable\n-     *\/\n-    private ElfRelocTable createElfRelocTable(ArrayList<ElfSection> sections,\n-                    Map<Symbol, List<Relocation>> relocationTable) {\n-\n-        ElfRelocTable elfRelocTable = new ElfRelocTable(sections.size());\n-        \/*\n-         * For each of the symbols with associated relocation records, create a Elf relocation\n-         * entry.\n-         *\/\n-        for (Map.Entry<Symbol, List<Relocation>> entry : relocationTable.entrySet()) {\n-            List<Relocation> relocs = entry.getValue();\n-            Symbol symbol = entry.getKey();\n-\n-            for (Relocation reloc : relocs) {\n-                createRelocation(symbol, reloc, elfRelocTable);\n-            }\n-        }\n-\n-        for (Map.Entry<Symbol, Relocation> entry : binContainer.getUniqueRelocationTable().entrySet()) {\n-            createRelocation(entry.getKey(), entry.getValue(), elfRelocTable);\n-        }\n-\n-        return (elfRelocTable);\n-    }\n-\n-    private static void createElfRelocSections(ArrayList<ElfSection> sections,\n-                    ElfRelocTable elfRelocTable,\n-                    int symtabsectidx) {\n-\n-        \/\/ Grab count before we create new sections\n-        int count = sections.size();\n-\n-        for (int i = 0; i < count; i++) {\n-            if (elfRelocTable.getNumRelocs(i) > 0) {\n-                ElfSection sect = sections.get(i);\n-                String relname = \".rela\" + sect.getName();\n-                ElfSection relocSection = createByteSection(sections, relname,\n-                                elfRelocTable.getRelocData(i),\n-                                false, 8, 0, Elf64_Shdr.SHT_RELA);\n-                relocSection.setLink(symtabsectidx);\n-                relocSection.setInfo(sect.getSectionId());\n-            }\n-        }\n-    }\n-\n-    abstract void createRelocation(Symbol symbol, Relocation reloc, ElfRelocTable elfRelocTable);\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/elf\/JELFRelocObject.java","additions":0,"deletions":328,"binary":false,"changes":328,"status":"deleted"},{"patch":"@@ -1,429 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- *\n- * File Layout generated by JMachORelocObject\n- *\n- * MachO Header\n- * Load Commands\n- *   LC_SEGMENT_64\n- *    - Sections\n- *   LC_VERSION_MIN_MAX\n- *   LC_SYMTAB\n- *   LC_DYSYMTAB\n- * Section Data\n- * Relocation entries\n- * Symbol table\n- *\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.macho;\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.Map;\n-\n-import jdk.tools.jaotc.binformat.BinaryContainer;\n-import jdk.tools.jaotc.binformat.ByteContainer;\n-import jdk.tools.jaotc.binformat.CodeContainer;\n-import jdk.tools.jaotc.binformat.ReadOnlyDataContainer;\n-import jdk.tools.jaotc.binformat.Relocation;\n-import jdk.tools.jaotc.binformat.Relocation.RelocType;\n-import jdk.tools.jaotc.binformat.Symbol;\n-import jdk.tools.jaotc.binformat.Symbol.Kind;\n-import jdk.tools.jaotc.binformat.macho.MachO.dysymtab_command;\n-import jdk.tools.jaotc.binformat.macho.MachO.mach_header_64;\n-import jdk.tools.jaotc.binformat.macho.MachO.nlist_64;\n-import jdk.tools.jaotc.binformat.macho.MachO.reloc_info;\n-import jdk.tools.jaotc.binformat.macho.MachO.section_64;\n-import jdk.tools.jaotc.binformat.macho.MachO.segment_command_64;\n-import jdk.tools.jaotc.binformat.macho.MachO.symtab_command;\n-import jdk.tools.jaotc.binformat.macho.MachO.version_min_command;\n-\n-public class JMachORelocObject {\n-\n-    private final BinaryContainer binContainer;\n-\n-    private final MachOContainer machoContainer;\n-\n-    private final int segmentSize;\n-\n-    public JMachORelocObject(BinaryContainer binContainer, String outputFileName) {\n-        this.binContainer = binContainer;\n-        this.machoContainer = new MachOContainer(outputFileName);\n-        this.segmentSize = binContainer.getCodeSegmentSize();\n-    }\n-\n-    private void createByteSection(ArrayList<MachOSection> sections,\n-                    ByteContainer c, String sectName, String segName, int scnFlags) {\n-\n-        if (c.getByteArray().length == 0) {\n-            \/\/ System.out.println(\"Skipping creation of \" + sectName + \" section, no data\\n\");\n-        }\n-\n-        MachOSection sect = new MachOSection(sectName,\n-                        segName,\n-                        c.getByteArray(),\n-                        scnFlags,\n-                        c.hasRelocations(),\n-                        segmentSize);\n-        \/\/ Add this section to our list\n-        sections.add(sect);\n-\n-        \/\/ Record the section Id (0 relative)\n-        c.setSectionId(sections.size() - 1);\n-\n-        \/\/ TODO: Clear out code section data to allow for GC\n-        \/\/ c.clear();\n-    }\n-\n-    private void createCodeSection(ArrayList<MachOSection> sections, CodeContainer c) {\n-        createByteSection(sections, c, \/* c.getContainerName() *\/ \"__text\", \"__TEXT\",\n-                        section_64.S_ATTR_PURE_INSTRUCTIONS |\n-                                        section_64.S_ATTR_SOME_INSTRUCTIONS);\n-    }\n-\n-    private void createReadOnlySection(ArrayList<MachOSection> sections, ReadOnlyDataContainer c) {\n-        createByteSection(sections, c, c.getContainerName(), \"__TEXT\",\n-                        section_64.S_ATTR_SOME_INSTRUCTIONS);\n-    }\n-\n-    private void createReadWriteSection(ArrayList<MachOSection> sections, ByteContainer c) {\n-        createByteSection(sections, c, c.getContainerName(), \"__DATA\", section_64.S_REGULAR);\n-    }\n-\n-    \/**\n-     * Creates an MachO relocatable object.\n-     *\n-     * @param relocationTable\n-     * @param symbols\n-     * @throws IOException throws {@code IOException} as a result of file system access failures.\n-     *\/\n-    public void createMachORelocObject(Map<Symbol, List<Relocation>> relocationTable, Collection<Symbol> symbols) throws IOException {\n-        \/\/ Allocate MachO Header\n-        \/\/ with 4 load commands\n-        \/\/ LC_SEGMENT_64\n-        \/\/ LC_VERSION_MIN_MACOSX\n-        \/\/ LC_SYMTAB\n-        \/\/ LC_DYSYMTAB\n-\n-        MachOHeader mh = new MachOHeader();\n-\n-        ArrayList<MachOSection> sections = new ArrayList<>();\n-\n-        \/\/ Create Sections contained in the main Segment LC_SEGMENT_64\n-\n-        createCodeSection(sections, binContainer.getCodeContainer());\n-        createReadOnlySection(sections, binContainer.getMetaspaceNamesContainer());\n-        createReadOnlySection(sections, binContainer.getKlassesOffsetsContainer());\n-        createReadOnlySection(sections, binContainer.getMethodsOffsetsContainer());\n-        createReadOnlySection(sections, binContainer.getKlassesDependenciesContainer());\n-        createReadOnlySection(sections, binContainer.getMethodMetadataContainer());\n-        createReadOnlySection(sections, binContainer.getStubsOffsetsContainer());\n-        createReadOnlySection(sections, binContainer.getHeaderContainer().getContainer());\n-        createReadOnlySection(sections, binContainer.getCodeSegmentsContainer());\n-        createReadOnlySection(sections, binContainer.getConstantDataContainer());\n-        createReadOnlySection(sections, binContainer.getConfigContainer());\n-        createReadWriteSection(sections, binContainer.getKlassesGotContainer());\n-        createReadWriteSection(sections, binContainer.getCountersGotContainer());\n-        createReadWriteSection(sections, binContainer.getMetadataGotContainer());\n-        createReadWriteSection(sections, binContainer.getMethodStateContainer());\n-        createReadWriteSection(sections, binContainer.getOopGotContainer());\n-        createReadWriteSection(sections, binContainer.getExtLinkageGOTContainer());\n-\n-        \/\/ Update the Header sizeofcmds size.\n-        \/\/ This doesn't include the Header struct size\n-        mh.setCmdSizes(4, segment_command_64.totalsize +\n-                        (section_64.totalsize * sections.size()) +\n-                        version_min_command.totalsize +\n-                        symtab_command.totalsize +\n-                        dysymtab_command.totalsize);\n-\n-        \/\/ Initialize file offset for data past commands\n-        int fileOffset = mach_header_64.totalsize + mh.getCmdSize();\n-        \/\/ and round it up\n-        fileOffset = (fileOffset + (sections.get(0).getAlign() - 1)) & ~((sections.get(0).getAlign() - 1));\n-        long address = 0;\n-        int segmentOffset = fileOffset;\n-\n-        for (int i = 0; i < sections.size(); i++) {\n-            MachOSection sect = sections.get(i);\n-            fileOffset = (fileOffset + (sect.getAlign() - 1)) & ~((sect.getAlign() - 1));\n-            address = (address + (sect.getAlign() - 1)) & ~((sect.getAlign() - 1));\n-            sect.setOffset(fileOffset);\n-            sect.setAddr(address);\n-            fileOffset += sect.getSize();\n-            address += sect.getSize();\n-        }\n-\n-        \/\/ File size for Segment data\n-        int segSize = fileOffset - segmentOffset;\n-\n-        \/\/ Create the LC_SEGMENT_64 Segment which contains the MachOSections\n-        MachOSegment seg = new MachOSegment(segment_command_64.totalsize +\n-                        (section_64.totalsize * sections.size()),\n-                        segmentOffset,\n-                        segSize,\n-                        sections.size());\n-\n-        MachOVersion vers = new MachOVersion();\n-\n-        \/\/ Get symbol data from BinaryContainer object's symbol tables\n-        MachOSymtab symtab = createMachOSymbolTables(sections, symbols);\n-\n-        \/\/ Create LC_DYSYMTAB command\n-        MachODySymtab dysymtab = new MachODySymtab(symtab.getNumLocalSyms(),\n-                        symtab.getNumGlobalSyms(),\n-                        symtab.getNumUndefSyms());\n-\n-        \/\/ Create the Relocation Tables\n-        MachORelocTable machORelocs = createMachORelocTable(sections, relocationTable, symtab);\n-        \/\/ Calculate file offset for relocation data\n-        fileOffset = (fileOffset + (MachORelocTable.getAlign() - 1)) & ~((MachORelocTable.getAlign() - 1));\n-\n-        \/\/ Update relocation sizing information in each section\n-        for (int i = 0; i < sections.size(); i++) {\n-            MachOSection sect = sections.get(i);\n-            if (sect.hasRelocations()) {\n-                int nreloc = machORelocs.getNumRelocs(i);\n-                sect.setReloff(fileOffset);\n-                sect.setRelcount(nreloc);\n-                fileOffset += (nreloc * reloc_info.totalsize);\n-            }\n-        }\n-\n-        \/\/ Calculate and set file offset for symbol table data\n-        fileOffset = (fileOffset + (MachOSymtab.getAlign() - 1)) & ~((MachOSymtab.getAlign() - 1));\n-        symtab.setOffset(fileOffset);\n-\n-        \/\/ Write Out Header\n-        machoContainer.writeBytes(mh.getArray());\n-        \/\/ Write out first Segment\n-        machoContainer.writeBytes(seg.getArray());\n-        \/\/ Write out sections within first Segment\n-        for (int i = 0; i < sections.size(); i++) {\n-            MachOSection sect = sections.get(i);\n-            machoContainer.writeBytes(sect.getArray());\n-        }\n-\n-        \/\/ Write out LC_VERSION_MIN_MACOSX command\n-        machoContainer.writeBytes(vers.getArray());\n-\n-        \/\/ Write out LC_SYMTAB command\n-        symtab.calcSizes();\n-        machoContainer.writeBytes(symtab.getCmdArray());\n-\n-        \/\/ Write out LC_DYSYMTAB command\n-        machoContainer.writeBytes(dysymtab.getArray());\n-\n-        \/\/ Write out data associated with each Section\n-        for (int i = 0; i < sections.size(); i++) {\n-            MachOSection sect = sections.get(i);\n-            machoContainer.writeBytes(sect.getDataArray(), sect.getAlign());\n-        }\n-\n-        \/\/ Write out the relocation tables for all sections\n-        for (int i = 0; i < sections.size(); i++) {\n-            if (machORelocs.getNumRelocs(i) > 0) {\n-                machoContainer.writeBytes(machORelocs.getRelocData(i), MachORelocTable.getAlign());\n-            }\n-        }\n-\n-        \/\/ Write out data associated with LC_SYMTAB\n-        machoContainer.writeBytes(symtab.getDataArray(), MachOSymtab.getAlign());\n-\n-        machoContainer.close();\n-    }\n-\n-    \/**\n-     * Construct MachO symbol data from BinaryContainer object's symbol tables. Both dynamic MachO\n-     * symbol table and MachO symbol table are created from BinaryContainer's symbol info.\n-     *\n-     * @param sections\n-     * @param symbols\n-     *\/\n-    private static MachOSymtab createMachOSymbolTables(ArrayList<MachOSection> sections,\n-                    Collection<Symbol> symbols) {\n-        MachOSymtab symtab = new MachOSymtab();\n-        \/\/ First, create the initial null symbol. This is a local symbol.\n-        symtab.addSymbolEntry(\"\", (byte) nlist_64.N_UNDF, (byte) 0, 0);\n-\n-        \/\/ Now create MachO symbol entries for all symbols.\n-        for (Symbol symbol : symbols) {\n-            int sectionId = symbol.getSection().getSectionId();\n-\n-            \/\/ Symbol offsets are relative to the section memory addr\n-            long sectionAddr = sections.get(sectionId).getAddr();\n-\n-            MachOSymbol machoSymbol = symtab.addSymbolEntry(symbol.getName(),\n-                            getMachOTypeOf(symbol),\n-                            (byte) sectionId,\n-                            symbol.getOffset() + sectionAddr);\n-            symbol.setNativeSymbol(machoSymbol);\n-        }\n-\n-        \/\/ Now that all symbols are enterred, update the\n-        \/\/ symbol indexes. This is necessary since they will\n-        \/\/ be reordered based on local, global and undefined.\n-        symtab.updateIndexes();\n-\n-        return (symtab);\n-    }\n-\n-    private static byte getMachOTypeOf(Symbol sym) {\n-        Kind kind = sym.getKind();\n-        byte type = nlist_64.N_UNDF;\n-\n-        \/\/ Global or Local\n-        if (sym.getBinding() == Symbol.Binding.GLOBAL) {\n-            type = nlist_64.N_EXT;\n-        }\n-        \/\/ If Function or Data, add section type\n-        if (kind == Symbol.Kind.NATIVE_FUNCTION ||\n-                        kind == Symbol.Kind.JAVA_FUNCTION ||\n-                        kind == Symbol.Kind.OBJECT) {\n-            type |= (nlist_64.N_SECT);\n-        }\n-\n-        return (type);\n-    }\n-\n-    \/**\n-     * Construct a MachO relocation table from BinaryContainer object's relocation tables.\n-     *\n-     * @param sections\n-     * @param relocationTable\n-     * @param symtab\n-     *\/\n-    private MachORelocTable createMachORelocTable(ArrayList<MachOSection> sections,\n-                    Map<Symbol, List<Relocation>> relocationTable,\n-                    MachOSymtab symtab) {\n-\n-        MachORelocTable machORelocTable = new MachORelocTable(sections.size());\n-        \/*\n-         * For each of the symbols with associated relocation records, create a MachO relocation\n-         * entry.\n-         *\/\n-        for (Map.Entry<Symbol, List<Relocation>> entry : relocationTable.entrySet()) {\n-            List<Relocation> relocs = entry.getValue();\n-            Symbol symbol = entry.getKey();\n-\n-            for (Relocation reloc : relocs) {\n-                createRelocation(symbol, reloc, machORelocTable);\n-            }\n-        }\n-\n-        for (Map.Entry<Symbol, Relocation> entry : binContainer.getUniqueRelocationTable().entrySet()) {\n-            createRelocation(entry.getKey(), entry.getValue(), machORelocTable);\n-        }\n-\n-        return (machORelocTable);\n-    }\n-\n-    private static void createRelocation(Symbol symbol, Relocation reloc, MachORelocTable machORelocTable) {\n-        RelocType relocType = reloc.getType();\n-\n-        int machORelocType = getMachORelocationType(relocType);\n-        MachOSymbol sym = (MachOSymbol) symbol.getNativeSymbol();\n-        int symno = sym.getIndex();\n-        int sectindex = reloc.getSection().getSectionId();\n-        int offset = reloc.getOffset();\n-        int pcrel = 0;\n-        int length = 0;\n-        int isextern = 1;\n-\n-        switch (relocType) {\n-            case JAVA_CALL_DIRECT:\n-            case STUB_CALL_DIRECT:\n-            case FOREIGN_CALL_INDIRECT_GOT: {\n-                \/\/ Create relocation entry\n-                int addend = -4; \/\/ Size in bytes of the patch location\n-                \/\/ Relocation should be applied at the location after call operand\n-                offset = offset + reloc.getSize() + addend;\n-                pcrel = 1;\n-                length = 2;\n-                break;\n-            }\n-            case JAVA_CALL_INDIRECT: {\n-                \/\/ Do nothing.\n-                return;\n-            }\n-            case METASPACE_GOT_REFERENCE:\n-            case EXTERNAL_PLT_TO_GOT: {\n-                int addend = -4; \/\/ Size of 32-bit address of the GOT\n-                \/*\n-                 * Relocation should be applied before the test instruction to the move instruction.\n-                 * reloc.getOffset() points to the test instruction after the instruction that loads\n-                 * the address of polling page. So set the offset appropriately.\n-                 *\/\n-                offset = offset + addend;\n-                pcrel = 1;\n-                length = 2;\n-                break;\n-            }\n-            case EXTERNAL_GOT_TO_PLT: {\n-                \/\/ this is load time relocations\n-                pcrel = 0;\n-                length = 3;\n-                break;\n-            }\n-            default:\n-                throw new InternalError(\"Unhandled relocation type: \" + relocType);\n-        }\n-        machORelocTable.createRelocationEntry(sectindex, offset, symno,\n-                        pcrel, length, isextern,\n-                        machORelocType);\n-    }\n-\n-    private static int getMachORelocationType(RelocType relocType) {\n-        int machORelocType = 0;\n-        switch (MachOTargetInfo.getMachOArch()) {\n-            case mach_header_64.CPU_TYPE_X86_64:\n-                \/\/ Return X86_64_RELOC_* entries based on relocType\n-                if (relocType == RelocType.JAVA_CALL_DIRECT ||\n-                                relocType == RelocType.FOREIGN_CALL_INDIRECT_GOT) {\n-                    machORelocType = reloc_info.X86_64_RELOC_BRANCH;\n-                } else if (relocType == RelocType.STUB_CALL_DIRECT) {\n-                    machORelocType = reloc_info.X86_64_RELOC_BRANCH;\n-                } else if (relocType == RelocType.JAVA_CALL_INDIRECT) {\n-                    machORelocType = reloc_info.X86_64_RELOC_NONE;\n-                } else if (relocType == RelocType.METASPACE_GOT_REFERENCE ||\n-                                relocType == RelocType.EXTERNAL_PLT_TO_GOT) {\n-                    machORelocType = reloc_info.X86_64_RELOC_BRANCH;\n-                } else if (relocType == RelocType.EXTERNAL_GOT_TO_PLT) {\n-                    machORelocType = reloc_info.X86_64_RELOC_UNSIGNED;\n-                } else {\n-                    assert false : \"Unhandled relocation type: \" + relocType;\n-                }\n-                break;\n-            default:\n-                System.out.println(\"Relocation Type mapping: Unhandled architecture\");\n-        }\n-        return machORelocType;\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/macho\/JMachORelocObject.java","additions":0,"deletions":429,"binary":false,"changes":429,"status":"deleted"},{"patch":"@@ -1,311 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.macho;\n-\n-\/\/@formatter:off\n-\/\/@Checkstyle: stop\n-\n-\/**\n- *\n- * Support for the creation of Mach-o Object files. Current support is limited to 64 bit x86_64.\n- *\n- * File Format Overview:\n- *\n- *   mach_header\n- *   load_commands\n- *      Typical Mac OSX 64-bit object files have these 4 load_commands\n- *      (LC_SEGMENT_64, LC_SYMTAB, LC_VERSIN_MIN_MACOSX, LC_DYSYMTAB)\n- *   Segments corresponding to load_commands\n- *      (which each include multiple Sections)\n- *\/\n-\n-final class MachO {\n-\n-    \/**\n-     * mach_header_64 structure defines\n-     *\/\n-    enum mach_header_64 {\n-                 magic( 0, 4),\n-               cputype( 4, 4),\n-            cpusubtype( 8, 4),\n-              filetype(12, 4),\n-                 ncmds(16, 4),\n-            sizeofcmds(20, 4),\n-                 flags(24, 4),\n-              reserved(28, 4);\n-\n-        final int off;\n-        final int sz;\n-\n-        mach_header_64(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 32;\n-\n-        \/**\n-         * mach_header_64 defines\n-         *\/\n-        static final int MH_MAGIC                   = 0xfeedface;\n-        static final int MH_MAGIC_64                = 0xfeedfacf;\n-        static final int MH_SUBSECTIONS_VIA_SYMBOLS = 0x2000;\n-\n-        \/**\n-         * filetype\n-         *\/\n-        static final int MH_OBJECT = 0x1;\n-\n-        \/**\n-         * cputype\n-         *\/\n-        static final int CPU_TYPE_ANY              = -1;\n-        static final int CPU_ARCH_ABI64            = 0x1000000;\n-        static final int CPU_TYPE_X86_64           = 0x1000007;\n-        static final int CPU_TYPE_ARM64            = 0x100000c;\n-        \/**\n-         * cpusubtype\n-         *\/\n-        static final int CPU_SUBTYPE_I386_ALL      = 3;\n-        static final int CPU_SUBTYPE_ARM64_ALL     = 0;\n-        static final int CPU_SUBTYPE_LITTLE_ENDIAN = 0;\n-        static final int CPU_SUBTYPE_BIG_ENDIAN    = 1;\n-\n-    }\n-\n-    \/**\n-     * segment_command_64 structure defines\n-     *\/\n-    enum segment_command_64 {\n-                   cmd( 0, 4),\n-               cmdsize( 4, 4),\n-               segname( 8,16),\n-                vmaddr(24, 8),\n-                vmsize(32, 8),\n-               fileoff(40, 8),\n-              filesize(48, 8),\n-               maxprot(56, 4),\n-              initprot(60, 4),\n-                nsects(64, 4),\n-                 flags(68, 4);\n-\n-        final int off;\n-        final int sz;\n-\n-        segment_command_64(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 72;\n-\n-        static final int LC_SEGMENT_64           = 0x19;\n-    }\n-\n-    \/**\n-     * section_64 structure defines\n-     *\/\n-    enum section_64 {\n-              sectname( 0,16),\n-               segname(16,16),\n-                  addr(32, 8),\n-                  size(40, 8),\n-                offset(48, 4),\n-                 align(52, 4),\n-                reloff(56, 4),\n-                nreloc(60, 4),\n-                 flags(64, 4),\n-             reserved1(68, 4),\n-             reserved2(72, 4),\n-             reserved3(76, 4);\n-\n-        final int off;\n-        final int sz;\n-\n-        section_64(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 80;\n-\n-        static int S_REGULAR                = 0x0;\n-        static int S_CSTRING_LITERALS       = 0x2;\n-        static int S_ATTR_PURE_INSTRUCTIONS = 0x80000000;\n-        static int S_ATTR_SOME_INSTRUCTIONS = 0x400;\n-    }\n-\n-    \/**\n-     * version_min_command structure defines\n-     *\/\n-    enum version_min_command {\n-                   cmd( 0, 4),\n-               cmdsize( 4, 4),\n-               version( 8, 4),\n-                   sdk(12, 4);\n-\n-        final int off;\n-        final int sz;\n-\n-        version_min_command(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 16;\n-\n-        static final int LC_VERSION_MIN_MACOSX   = 0x24;\n-        static final int LC_VERSION_MIN_IPHONEOS = 0x25;\n-    }\n-\n-    \/**\n-     * symtab_command structure defines\n-     *\/\n-    enum symtab_command {\n-                   cmd( 0, 4),\n-               cmdsize( 4, 4),\n-                symoff( 8, 4),\n-                 nsyms(12, 4),\n-                stroff(16, 4),\n-               strsize(20, 4);\n-\n-        final int off;\n-        final int sz;\n-\n-        symtab_command(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 24;\n-\n-        static final int LC_SYMTAB               = 0x2;\n-    }\n-\n-    \/**\n-     * Symbol table entry definitions\n-     *\n-     * nlist_64 structure defines\n-     *\/\n-    enum nlist_64 {\n-                n_strx( 0, 4),\n-                n_type( 4, 1),\n-                n_sect( 5, 1),\n-                n_desc( 6, 2),\n-               n_value( 8, 8);\n-\n-        final int off;\n-        final int sz;\n-\n-        nlist_64(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 16;\n-\n-        static final int N_EXT                = 0x1;\n-        static final int N_TYPE               = 0xe;\n-        static final int N_UNDF               = 0x0;\n-        static final int N_SECT               = 0xe;\n-    }\n-\n-    \/**\n-     * dysymtab_command structure defines\n-     *\/\n-    enum dysymtab_command {\n-                   cmd( 0, 4),\n-               cmdsize( 4, 4),\n-             ilocalsym( 8, 4),\n-             nlocalsym(12, 4),\n-            iextdefsym(16, 4),\n-            nextdefsym(20, 4),\n-             iundefsym(24, 4),\n-             nundefsym(28, 4),\n-                tocoff(32, 4),\n-                  ntoc(36, 4),\n-             modtaboff(40, 4),\n-               nmodtab(44, 4),\n-          extrefsymoff(48, 4),\n-           nextrefsyms(52, 4),\n-        indirectsymoff(56, 4),\n-         nindirectsyms(60, 4),\n-             extreloff(64, 4),\n-               nextrel(68, 4),\n-             locreloff(72, 4),\n-               nlocrel(76, 4);\n-\n-        final int off;\n-        final int sz;\n-\n-        dysymtab_command(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 80;\n-\n-        static final int LC_DYSYMTAB             = 0xb;\n-    }\n-\n-    \/**\n-     * relocation_info structure defines\n-     *\/\n-    enum reloc_info {\n-             r_address( 0, 4),\n-           r_relocinfo( 4, 4);\n-\n-        final int off;\n-        final int sz;\n-\n-        reloc_info(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 8;\n-\n-        static final int REL_SYMNUM_MASK         = 0xffffff;\n-        static final int REL_SYMNUM_SHIFT        = 0x0;\n-        static final int REL_PCREL_MASK          = 0x1;\n-        static final int REL_PCREL_SHIFT         = 0x18;\n-        static final int REL_LENGTH_MASK         = 0x3;\n-        static final int REL_LENGTH_SHIFT        = 0x19;\n-        static final int REL_EXTERN_MASK         = 0x1;\n-        static final int REL_EXTERN_SHIFT        = 0x1b;\n-        static final int REL_TYPE_MASK           = 0xf;\n-        static final int REL_TYPE_SHIFT          = 0x1c;\n-\n-        \/* reloc_type_x86_64 defines *\/\n-\n-        static final int X86_64_RELOC_NONE      = 0x0;\n-        static final int X86_64_RELOC_BRANCH    = 0x2;\n-        static final int X86_64_RELOC_GOT       = 0x4;\n-        static final int X86_64_RELOC_GOT_LOAD  = 0x3;\n-        static final int X86_64_RELOC_SIGNED    = 0x1;\n-        static final int X86_64_RELOC_UNSIGNED  = 0x0;\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/macho\/MachO.java","additions":0,"deletions":311,"binary":false,"changes":311,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.macho;\n-\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-\n-final class MachOByteBuffer {\n-\n-    static ByteBuffer allocate(int size) {\n-        ByteBuffer buf = ByteBuffer.allocate(size);\n-        if (MachOTargetInfo.getMachOEndian() == MachO.mach_header_64.CPU_SUBTYPE_LITTLE_ENDIAN) {\n-            buf.order(ByteOrder.LITTLE_ENDIAN);\n-        } else {\n-            buf.order(ByteOrder.BIG_ENDIAN);\n-        }\n-        return (buf);\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/macho\/MachOByteBuffer.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.macho;\n-\n-import java.io.File;\n-import java.io.FileOutputStream;\n-\n-final class MachOContainer {\n-\n-    private final File outputFile;\n-    private FileOutputStream outputStream;\n-    private long fileOffset;\n-\n-    MachOContainer(String fileName) {\n-\n-        outputFile = new File(fileName);\n-        if (outputFile.exists()) {\n-            outputFile.delete();\n-        }\n-\n-        try {\n-            outputStream = new FileOutputStream(outputFile);\n-        } catch (Exception e) {\n-            System.out.println(\"MachOContainer: Can't create file \" + fileName);\n-        }\n-        fileOffset = 0;\n-    }\n-\n-    void close() {\n-        try {\n-            outputStream.close();\n-        } catch (Exception e) {\n-            System.out.println(\"MachOContainer: close failed\");\n-        }\n-    }\n-\n-    void writeBytes(byte[] bytes) {\n-        try {\n-            outputStream.write(bytes);\n-        } catch (Exception e) {\n-            System.out.println(\"MachOContainer: writeBytes failed\");\n-        }\n-        fileOffset += bytes.length;\n-    }\n-\n-    \/\/ Write bytes to output file with up front alignment padding\n-    void writeBytes(byte[] bytes, int alignment) {\n-        try {\n-            \/\/ Pad to alignment\n-            while ((fileOffset & (alignment - 1)) != 0) {\n-                outputStream.write(0);\n-                fileOffset++;\n-            }\n-            outputStream.write(bytes);\n-        } catch (Exception e) {\n-            System.out.println(\"MachOContainer: writeBytes failed\");\n-        }\n-        fileOffset += bytes.length;\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/macho\/MachOContainer.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.macho;\n-\n-import java.nio.ByteBuffer;\n-\n-import jdk.tools.jaotc.binformat.macho.MachO.dysymtab_command;\n-\n-final class MachODySymtab {\n-    private final ByteBuffer dysymtab;\n-\n-    MachODySymtab(int nlocal, int nglobal, int nundef) {\n-        dysymtab = MachOByteBuffer.allocate(dysymtab_command.totalsize);\n-\n-        dysymtab.putInt(dysymtab_command.cmd.off, dysymtab_command.LC_DYSYMTAB);\n-        dysymtab.putInt(dysymtab_command.cmdsize.off, dysymtab_command.totalsize);\n-        dysymtab.putInt(dysymtab_command.ilocalsym.off, 0);\n-        dysymtab.putInt(dysymtab_command.nlocalsym.off, nlocal);\n-        dysymtab.putInt(dysymtab_command.iextdefsym.off, nlocal);\n-        dysymtab.putInt(dysymtab_command.nextdefsym.off, nglobal);\n-        dysymtab.putInt(dysymtab_command.iundefsym.off, nlocal + nglobal);\n-        dysymtab.putInt(dysymtab_command.nundefsym.off, nundef);\n-    }\n-\n-    byte[] getArray() {\n-        return dysymtab.array();\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/macho\/MachODySymtab.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.macho;\n-\n-import java.nio.ByteBuffer;\n-\n-import jdk.tools.jaotc.binformat.macho.MachO.mach_header_64;\n-\n-final class MachOHeader {\n-    private final ByteBuffer header;\n-\n-    MachOHeader() {\n-        header = MachOByteBuffer.allocate(mach_header_64.totalsize);\n-\n-        header.putInt(mach_header_64.magic.off, mach_header_64.MH_MAGIC_64);\n-        header.putInt(mach_header_64.cputype.off, MachOTargetInfo.getMachOArch());\n-        header.putInt(mach_header_64.cpusubtype.off, MachOTargetInfo.getMachOSubArch());\n-        header.putInt(mach_header_64.flags.off, 0x2000);\n-        header.putInt(mach_header_64.filetype.off, mach_header_64.MH_OBJECT);\n-    }\n-\n-    void setCmdSizes(int ncmds, int sizeofcmds) {\n-        header.putInt(mach_header_64.ncmds.off, ncmds);\n-        header.putInt(mach_header_64.sizeofcmds.off, sizeofcmds);\n-    }\n-\n-    int getCmdSize() {\n-        return (header.getInt(mach_header_64.sizeofcmds.off));\n-    }\n-\n-    byte[] getArray() {\n-        return header.array();\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/macho\/MachOHeader.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.macho;\n-\n-import java.nio.ByteBuffer;\n-\n-import jdk.tools.jaotc.binformat.macho.MachO.reloc_info;\n-\n-final class MachORelocEntry {\n-    private final ByteBuffer entry;\n-\n-    MachORelocEntry(int offset, int symno, int pcrel, int length, int isextern, int type) {\n-\n-        entry = MachOByteBuffer.allocate(reloc_info.totalsize);\n-\n-        entry.putInt(reloc_info.r_address.off, offset);\n-\n-        \/\/ Encode and store the relocation entry bitfields\n-        \/\/ @formatter:off\n-        entry.putInt(reloc_info.r_relocinfo.off,\n-            ((symno    & reloc_info.REL_SYMNUM_MASK) << reloc_info.REL_SYMNUM_SHIFT) |\n-            ((pcrel    & reloc_info.REL_PCREL_MASK)  << reloc_info.REL_PCREL_SHIFT)  |\n-            ((length   & reloc_info.REL_LENGTH_MASK) << reloc_info.REL_LENGTH_SHIFT) |\n-            ((isextern & reloc_info.REL_EXTERN_MASK) << reloc_info.REL_EXTERN_SHIFT) |\n-            ((type     & reloc_info.REL_TYPE_MASK)   << reloc_info.REL_TYPE_SHIFT));\n-        \/\/ @formatter:on\n-    }\n-\n-    byte[] getArray() {\n-        return entry.array();\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/macho\/MachORelocEntry.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.macho;\n-\n-import java.nio.ByteBuffer;\n-import java.util.ArrayList;\n-\n-import jdk.tools.jaotc.binformat.macho.MachO.reloc_info;\n-\n-final class MachORelocTable {\n-    private final ArrayList<ArrayList<MachORelocEntry>> relocEntries;\n-    int fileOffset;\n-\n-    MachORelocTable(int numsects) {\n-        relocEntries = new ArrayList<>(numsects);\n-        for (int i = 0; i < numsects; i++) {\n-            relocEntries.add(new ArrayList<MachORelocEntry>());\n-        }\n-    }\n-\n-    void createRelocationEntry(int sectindex, int offset, int symno, int pcrel, int length, int isextern, int type) {\n-        MachORelocEntry entry = new MachORelocEntry(offset, symno, pcrel, length, isextern, type);\n-        relocEntries.get(sectindex).add(entry);\n-    }\n-\n-    static int getAlign() {\n-        return (4);\n-    }\n-\n-    int getNumRelocs(int sectionIndex) {\n-        return relocEntries.get(sectionIndex).size();\n-    }\n-\n-    \/\/ Return the relocation entries for a single section\n-    \/\/ or null if no entries added to section\n-    byte[] getRelocData(int sectionIndex) {\n-        ArrayList<MachORelocEntry> entryList = relocEntries.get(sectionIndex);\n-\n-        if (entryList.size() == 0) {\n-            return null;\n-        }\n-        ByteBuffer relocData = MachOByteBuffer.allocate(entryList.size() * reloc_info.totalsize);\n-\n-        \/\/ Copy each entry to a single ByteBuffer\n-        for (int i = 0; i < entryList.size(); i++) {\n-            MachORelocEntry entry = entryList.get(i);\n-            relocData.put(entry.getArray());\n-        }\n-\n-        return (relocData.array());\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/macho\/MachORelocTable.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -1,109 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.macho;\n-\n-import java.nio.ByteBuffer;\n-\n-import jdk.tools.jaotc.binformat.macho.MachO.section_64;\n-\n-final class MachOSection {\n-    private final ByteBuffer section;\n-    private final byte[] data;\n-    private final boolean hasrelocations;\n-\n-    MachOSection(String sectName, String segName, byte[] sectData, int sectFlags, boolean hasRelocations, int align) {\n-        section = MachOByteBuffer.allocate(section_64.totalsize);\n-\n-        \/\/ TODO: Hotspot uses long section names.\n-        \/\/ They are getting truncated.\n-        \/\/ Is this a problem??\n-        byte[] sectNameBytes = sectName.getBytes();\n-        int sectNameMax = section_64.sectname.sz < sectNameBytes.length ? section_64.sectname.sz : sectNameBytes.length;\n-\n-        for (int i = 0; i < sectNameMax; i++) {\n-            section.put(section_64.sectname.off + i, sectNameBytes[i]);\n-        }\n-        byte[] segNameBytes = segName.getBytes();\n-        int segNameMax = section_64.segname.sz < segNameBytes.length ? section_64.segname.sz : segNameBytes.length;\n-\n-        for (int i = 0; i < segNameMax; i++) {\n-            section.put(section_64.segname.off + i, segNameBytes[i]);\n-        }\n-        section.putLong(section_64.size.off, sectData.length);\n-\n-        section.putInt(section_64.align.off, 31 - Integer.numberOfLeadingZeros(align));\n-\n-        section.putInt(section_64.flags.off, sectFlags);\n-\n-        data = sectData;\n-\n-        hasrelocations = hasRelocations;\n-    }\n-\n-    long getSize() {\n-        return section.getLong(section_64.size.off);\n-    }\n-\n-    int getAlign() {\n-        return (1 << section.getInt(section_64.align.off));\n-    }\n-\n-    byte[] getArray() {\n-        return section.array();\n-    }\n-\n-    byte[] getDataArray() {\n-        return data;\n-    }\n-\n-    void setAddr(long addr) {\n-        section.putLong(section_64.addr.off, addr);\n-    }\n-\n-    long getAddr() {\n-        return (section.getLong(section_64.addr.off));\n-    }\n-\n-    void setOffset(int offset) {\n-        section.putInt(section_64.offset.off, offset);\n-    }\n-\n-    int getOffset() {\n-        return (section.getInt(section_64.offset.off));\n-    }\n-\n-    void setReloff(int offset) {\n-        section.putInt(section_64.reloff.off, offset);\n-    }\n-\n-    void setRelcount(int count) {\n-        section.putInt(section_64.nreloc.off, count);\n-    }\n-\n-    boolean hasRelocations() {\n-        return hasrelocations;\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/macho\/MachOSection.java","additions":0,"deletions":109,"binary":false,"changes":109,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.macho;\n-\n-import java.nio.ByteBuffer;\n-\n-import jdk.tools.jaotc.binformat.macho.MachO.segment_command_64;\n-\n-public class MachOSegment {\n-    ByteBuffer segment;\n-\n-    public MachOSegment(int size, int fileoff, int filesize, int nsects) {\n-        segment = MachOByteBuffer.allocate(segment_command_64.totalsize);\n-\n-        segment.putInt(segment_command_64.cmd.off, segment_command_64.LC_SEGMENT_64);\n-        segment.putInt(segment_command_64.cmdsize.off, size);\n-        segment.putInt(segment_command_64.maxprot.off, 7);\n-        segment.putInt(segment_command_64.initprot.off, 7);\n-        segment.putInt(segment_command_64.nsects.off, nsects);\n-        segment.putInt(segment_command_64.flags.off, 0);\n-        segment.putLong(segment_command_64.vmaddr.off, 0);\n-        segment.putLong(segment_command_64.vmsize.off, filesize);\n-        segment.putLong(segment_command_64.fileoff.off, fileoff);\n-        segment.putLong(segment_command_64.filesize.off, filesize);\n-    }\n-\n-    public byte[] getArray() {\n-        return segment.array();\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/macho\/MachOSegment.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.macho;\n-\n-import java.nio.ByteBuffer;\n-\n-import jdk.tools.jaotc.binformat.NativeSymbol;\n-import jdk.tools.jaotc.binformat.macho.MachO.nlist_64;\n-\n-final class MachOSymbol extends NativeSymbol {\n-    private final ByteBuffer sym;\n-\n-    MachOSymbol(int symbolindex, int strindex, byte type, byte sectindex, long offset) {\n-        super(symbolindex);\n-        sym = MachOByteBuffer.allocate(nlist_64.totalsize);\n-\n-        sym.putInt(nlist_64.n_strx.off, strindex);\n-        sym.put(nlist_64.n_type.off, type);\n-        \/\/ Section indexes start at 1 but we manage the index internally\n-        \/\/ as 0 relative\n-        sym.put(nlist_64.n_sect.off, (byte) (sectindex + 1));\n-        sym.putChar(nlist_64.n_desc.off, (char) 0);\n-        sym.putLong(nlist_64.n_value.off, offset);\n-    }\n-\n-    byte[] getArray() {\n-        return sym.array();\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/macho\/MachOSymbol.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,209 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.macho;\n-\n-import java.nio.ByteBuffer;\n-import java.util.ArrayList;\n-\n-import jdk.tools.jaotc.binformat.macho.MachO.nlist_64;\n-import jdk.tools.jaotc.binformat.macho.MachO.symtab_command;\n-\n-final class MachOSymtab {\n-\n-    \/**\n-     * ByteBuffer holding the LC_SYMTAB command contents.\n-     *\/\n-    private final ByteBuffer symtabCmd;\n-\n-    private int symtabDataSize;\n-\n-    private final ArrayList<MachOSymbol> localSymbols = new ArrayList<>();\n-    private final ArrayList<MachOSymbol> globalSymbols = new ArrayList<>();\n-    private final ArrayList<MachOSymbol> undefSymbols = new ArrayList<>();\n-\n-    \/**\n-     * Number of symbols added.\n-     *\/\n-    private int symbolCount;\n-\n-    \/**\n-     * String holding symbol table strings.\n-     *\/\n-    private final StringBuilder strTabContent = new StringBuilder();\n-\n-    \/**\n-     * Keeps track of bytes in string table since strTabContent.length() is number of chars, not\n-     * bytes.\n-     *\/\n-    private int strTabNrOfBytes = 0;\n-\n-    MachOSymtab() {\n-        symtabCmd = MachOByteBuffer.allocate(symtab_command.totalsize);\n-\n-        symtabCmd.putInt(symtab_command.cmd.off, symtab_command.LC_SYMTAB);\n-        symtabCmd.putInt(symtab_command.cmdsize.off, symtab_command.totalsize);\n-\n-        symbolCount = 0;\n-\n-    }\n-\n-    static int getAlign() {\n-        return (4);\n-    }\n-\n-    MachOSymbol addSymbolEntry(String name, byte type, byte secHdrIndex, long offset) {\n-        \/\/ Get the current symbol index and append symbol name to string table.\n-        int index;\n-        MachOSymbol sym;\n-\n-        if (name.isEmpty()) {\n-            index = 0;\n-            strTabContent.append('\\0');\n-            strTabNrOfBytes += 1;\n-            sym = new MachOSymbol(symbolCount, index, type, secHdrIndex, offset);\n-            localSymbols.add(sym);\n-        } else {\n-            \/\/ We can't trust strTabContent.length() since that is\n-            \/\/ chars (UTF16), keep track of bytes on our own.\n-            index = strTabNrOfBytes;\n-            strTabContent.append(\"_\").append(name).append('\\0');\n-            \/\/ + 1 for null, + 1 for \"_\"\n-            strTabNrOfBytes += (name.getBytes().length + 1 + 1);\n-\n-            sym = new MachOSymbol(symbolCount, index, type, secHdrIndex, offset);\n-            switch (type) {\n-                case nlist_64.N_EXT:\n-                    undefSymbols.add(sym);\n-                    break;\n-                case nlist_64.N_SECT:\n-                case nlist_64.N_UNDF:  \/\/ null symbol\n-                    localSymbols.add(sym);\n-                    break;\n-                case nlist_64.N_SECT | nlist_64.N_EXT:\n-                    globalSymbols.add(sym);\n-                    break;\n-                default:\n-                    System.out.println(\"Unsupported Symbol type \" + type);\n-                    break;\n-            }\n-        }\n-        symbolCount++;\n-        return (sym);\n-    }\n-\n-    void setOffset(int symoff) {\n-        symtabCmd.putInt(symtab_command.symoff.off, symoff);\n-    }\n-\n-    \/\/ Update the symbol indexes once all symbols have been added.\n-    \/\/ This is required since we'll be reordering the symbols in the\n-    \/\/ file to be in the order of Local, global and Undefined.\n-    void updateIndexes() {\n-        int index = 0;\n-\n-        \/\/ Update the local symbol indexes\n-        for (int i = 0; i < localSymbols.size(); i++) {\n-            MachOSymbol sym = localSymbols.get(i);\n-            sym.setIndex(index++);\n-        }\n-\n-        \/\/ Update the global symbol indexes\n-        for (int i = 0; i < globalSymbols.size(); i++) {\n-            MachOSymbol sym = globalSymbols.get(i);\n-            sym.setIndex(index++);\n-        }\n-\n-        \/\/ Update the undefined symbol indexes\n-        for (int i = index; i < undefSymbols.size(); i++) {\n-            MachOSymbol sym = undefSymbols.get(i);\n-            sym.setIndex(index++);\n-        }\n-    }\n-\n-    \/\/ Update LC_SYMTAB command fields based on the number of symbols added\n-    \/\/ return the file size taken up by symbol table entries and strings\n-    int calcSizes() {\n-        int stroff;\n-\n-        stroff = symtabCmd.getInt(symtab_command.symoff.off) + (nlist_64.totalsize * symbolCount);\n-        symtabCmd.putInt(symtab_command.nsyms.off, symbolCount);\n-        symtabCmd.putInt(symtab_command.stroff.off, stroff);\n-        symtabCmd.putInt(symtab_command.strsize.off, strTabNrOfBytes);\n-        symtabDataSize = (nlist_64.totalsize * symbolCount) + strTabNrOfBytes;\n-\n-        return (symtabDataSize);\n-    }\n-\n-    int getNumLocalSyms() {\n-        return localSymbols.size();\n-    }\n-\n-    int getNumGlobalSyms() {\n-        return globalSymbols.size();\n-    }\n-\n-    int getNumUndefSyms() {\n-        return undefSymbols.size();\n-    }\n-\n-    byte[] getCmdArray() {\n-        return symtabCmd.array();\n-    }\n-\n-    \/\/ Create a single byte array that contains the symbol table entries\n-    \/\/ and string table\n-    byte[] getDataArray() {\n-        ByteBuffer symtabData = MachOByteBuffer.allocate(symtabDataSize);\n-        byte[] retarray;\n-\n-        \/\/ Add the local symbols\n-        for (int i = 0; i < localSymbols.size(); i++) {\n-            MachOSymbol sym = localSymbols.get(i);\n-            byte[] arr = sym.getArray();\n-            symtabData.put(arr);\n-        }\n-        \/\/ Add the global symbols\n-        for (int i = 0; i < globalSymbols.size(); i++) {\n-            MachOSymbol sym = globalSymbols.get(i);\n-            byte[] arr = sym.getArray();\n-            symtabData.put(arr);\n-        }\n-        \/\/ Add the undefined symbols\n-        for (int i = 0; i < undefSymbols.size(); i++) {\n-            MachOSymbol sym = undefSymbols.get(i);\n-            byte[] arr = sym.getArray();\n-            symtabData.put(arr);\n-        }\n-\n-        \/\/ Add the stringtable\n-        byte[] strs = strTabContent.toString().getBytes();\n-        symtabData.put(strs);\n-\n-        retarray = symtabData.array();\n-\n-        return (retarray);\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/macho\/MachOSymtab.java","additions":0,"deletions":209,"binary":false,"changes":209,"status":"deleted"},{"patch":"@@ -1,87 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.macho;\n-\n-import java.nio.ByteOrder;\n-import jdk.tools.jaotc.binformat.macho.MachO.mach_header_64;\n-\n-\/**\n- * Class that abstracts MACH-O target details.\n- *\n- *\/\n-final class MachOTargetInfo {\n-    \/**\n-     * Target architecture and subtype.\n-     *\/\n-    private static final int arch;\n-    private static final int subarch;\n-\n-    \/**\n-     * Architecture endian-ness.\n-     *\/\n-    private static final int endian = mach_header_64.CPU_SUBTYPE_LITTLE_ENDIAN;\n-\n-    \/**\n-     * Target OS string.\n-     *\/\n-    private static final String osName;\n-\n-    static {\n-        \/\/ Find the target arch details\n-        String archStr = System.getProperty(\"os.arch\").toLowerCase();\n-\n-        if (ByteOrder.nativeOrder() != ByteOrder.LITTLE_ENDIAN) {\n-            System.out.println(\"Only Little Endian byte order supported!\");\n-        }\n-\n-        if (archStr.equals(\"amd64\") || archStr.equals(\"x86_64\")) {\n-            arch = mach_header_64.CPU_TYPE_X86_64;\n-            subarch = mach_header_64.CPU_SUBTYPE_I386_ALL;\n-        } else {\n-            System.out.println(\"Unsupported architecture \" + archStr);\n-            arch = mach_header_64.CPU_TYPE_ANY;\n-            subarch = 0;\n-        }\n-\n-        osName = System.getProperty(\"os.name\").toLowerCase();\n-    }\n-\n-    static int getMachOArch() {\n-        return arch;\n-    }\n-\n-    static int getMachOSubArch() {\n-        return subarch;\n-    }\n-\n-    static int getMachOEndian() {\n-        return endian;\n-    }\n-\n-    static String getOsName() {\n-        return osName;\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/macho\/MachOTargetInfo.java","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.macho;\n-\n-import java.nio.ByteBuffer;\n-\n-import jdk.tools.jaotc.binformat.macho.MachO.version_min_command;\n-\n-final class MachOVersion {\n-    private final ByteBuffer version;\n-\n-    MachOVersion() {\n-        version = MachOByteBuffer.allocate(version_min_command.totalsize);\n-\n-        version.putInt(version_min_command.cmd.off, version_min_command.LC_VERSION_MIN_MACOSX);\n-        version.putInt(version_min_command.cmdsize.off, version_min_command.totalsize);\n-        version.putInt(version_min_command.version.off, (10 << 16) | (10 << 8)); \/* MacOSX 10.10 *\/\n-        version.putInt(version_min_command.sdk.off, 0); \/* N\/A SDK *\/\n-    }\n-\n-    byte[] getArray() {\n-        return version.array();\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/macho\/MachOVersion.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,365 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.pecoff;\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.Map;\n-\n-import jdk.tools.jaotc.binformat.BinaryContainer;\n-import jdk.tools.jaotc.binformat.ByteContainer;\n-import jdk.tools.jaotc.binformat.CodeContainer;\n-import jdk.tools.jaotc.binformat.ReadOnlyDataContainer;\n-import jdk.tools.jaotc.binformat.Relocation;\n-import jdk.tools.jaotc.binformat.Relocation.RelocType;\n-import jdk.tools.jaotc.binformat.Symbol;\n-import jdk.tools.jaotc.binformat.Symbol.Binding;\n-import jdk.tools.jaotc.binformat.Symbol.Kind;\n-import jdk.tools.jaotc.binformat.pecoff.PECoff.IMAGE_FILE_HEADER;\n-import jdk.tools.jaotc.binformat.pecoff.PECoff.IMAGE_RELOCATION;\n-import jdk.tools.jaotc.binformat.pecoff.PECoff.IMAGE_SECTION_HEADER;\n-import jdk.tools.jaotc.binformat.pecoff.PECoff.IMAGE_SYMBOL;\n-\n-public class JPECoffRelocObject {\n-\n-    private final BinaryContainer binContainer;\n-\n-    private final PECoffContainer pecoffContainer;\n-\n-    private final int sectionAlignment;\n-\n-    public JPECoffRelocObject(BinaryContainer binContainer, String outputFileName) {\n-        this.binContainer = binContainer;\n-        this.pecoffContainer = new PECoffContainer(outputFileName);\n-        this.sectionAlignment = binContainer.getCodeSegmentSize();\n-    }\n-\n-    private static PECoffSection createByteSection(ArrayList<PECoffSection> sections, String sectName, byte[] scnData,\n-                    boolean hasRelocs, int scnFlags, int sectAlign) {\n-\n-        PECoffSection sect = new PECoffSection(sectName, scnData, scnFlags, sectAlign, hasRelocs, sections.size());\n-        \/\/ Add this section to our list\n-        sections.add(sect);\n-\n-        return (sect);\n-    }\n-\n-    private static void createByteSection(ArrayList<PECoffSection> sections, ByteContainer c, int scnFlags, int sectAlign) {\n-        PECoffSection sect;\n-        boolean hasRelocs = c.hasRelocations();\n-        byte[] scnData = c.getByteArray();\n-\n-        sect = createByteSection(sections, c.getContainerName(), scnData, hasRelocs, scnFlags, sectAlign);\n-\n-        c.setSectionId(sect.getSectionId());\n-    }\n-\n-    private void createCodeSection(ArrayList<PECoffSection> sections, CodeContainer c) {\n-        int scnFlags = IMAGE_SECTION_HEADER.IMAGE_SCN_MEM_READ | IMAGE_SECTION_HEADER.IMAGE_SCN_MEM_EXECUTE | IMAGE_SECTION_HEADER.IMAGE_SCN_CNT_CODE;\n-        createByteSection(sections, c, scnFlags, sectionAlignment);\n-    }\n-\n-    private void createReadOnlySection(ArrayList<PECoffSection> sections, ReadOnlyDataContainer c) {\n-        int scnFlags = IMAGE_SECTION_HEADER.IMAGE_SCN_MEM_READ | IMAGE_SECTION_HEADER.IMAGE_SCN_CNT_INITIALIZED_DATA;\n-        createByteSection(sections, c, scnFlags, sectionAlignment);\n-    }\n-\n-    private void createReadWriteSection(ArrayList<PECoffSection> sections, ByteContainer c) {\n-        int scnFlags = IMAGE_SECTION_HEADER.IMAGE_SCN_MEM_READ | IMAGE_SECTION_HEADER.IMAGE_SCN_MEM_WRITE;\n-\n-        if (c.getByteArray().length > 0) {\n-            scnFlags |= IMAGE_SECTION_HEADER.IMAGE_SCN_CNT_INITIALIZED_DATA;\n-        } else {\n-            scnFlags |= IMAGE_SECTION_HEADER.IMAGE_SCN_CNT_UNINITIALIZED_DATA;\n-        }\n-        createByteSection(sections, c, scnFlags, sectionAlignment);\n-    }\n-\n-    \/**\n-     * Creates a PECoff relocatable object.\n-     *\n-     * @param relocationTable\n-     * @param symbols\n-     * @throws IOException throws {@code IOException} as a result of file system access failures.\n-     *\/\n-    public void createPECoffRelocObject(Map<Symbol, List<Relocation>> relocationTable, Collection<Symbol> symbols) throws IOException {\n-        ArrayList<PECoffSection> sections = new ArrayList<>();\n-\n-        \/\/ Create text section\n-        createCodeSection(sections, binContainer.getCodeContainer());\n-        createReadOnlySection(sections, binContainer.getMetaspaceNamesContainer());\n-        createReadOnlySection(sections, binContainer.getKlassesOffsetsContainer());\n-        createReadOnlySection(sections, binContainer.getMethodsOffsetsContainer());\n-        createReadOnlySection(sections, binContainer.getKlassesDependenciesContainer());\n-        createReadOnlySection(sections, binContainer.getMethodMetadataContainer());\n-        createReadOnlySection(sections, binContainer.getStubsOffsetsContainer());\n-        createReadOnlySection(sections, binContainer.getHeaderContainer().getContainer());\n-        createReadOnlySection(sections, binContainer.getCodeSegmentsContainer());\n-        createReadOnlySection(sections, binContainer.getConstantDataContainer());\n-        createReadOnlySection(sections, binContainer.getConfigContainer());\n-        createReadWriteSection(sections, binContainer.getKlassesGotContainer());\n-        createReadWriteSection(sections, binContainer.getCountersGotContainer());\n-        createReadWriteSection(sections, binContainer.getMetadataGotContainer());\n-        createReadWriteSection(sections, binContainer.getMethodStateContainer());\n-        createReadWriteSection(sections, binContainer.getOopGotContainer());\n-        createReadWriteSection(sections, binContainer.getExtLinkageGOTContainer());\n-\n-        \/\/ Allocate PECoff Header\n-        PECoffHeader header = new PECoffHeader();\n-\n-        \/\/ Get PECoff symbol data from BinaryContainer object's symbol tables\n-        PECoffSymtab symtab = createPECoffSymbolTables(symbols);\n-\n-        \/\/ Add Linker Directives Section\n-        int scnFlags = IMAGE_SECTION_HEADER.IMAGE_SCN_LNK_INFO | IMAGE_SECTION_HEADER.IMAGE_SCN_LNK_REMOVE;\n-        createByteSection(sections, \".drectve\", symtab.getDirectiveArray(), false, scnFlags, 1 \/*\n-                                                                                                * 1\n-                                                                                                * byte\n-                                                                                                * alignment\n-                                                                                                *\/);\n-\n-        \/\/ Create the Relocation Tables\n-        PECoffRelocTable pecoffRelocs = createPECoffRelocTable(sections, relocationTable);\n-\n-        \/\/ File Output Order\n-        \/\/\n-        \/\/ HEADER (Need address of Symbol Table + symbol count)\n-        \/\/ SECTIONS (Need pointer to Section Data, Relocation Table)\n-        \/\/ DIRECTIVES\n-        \/\/ SYMBOL TABLE\n-        \/\/ SYMBOLS\n-        \/\/ SECTION DATA\n-        \/\/ RELOCATION TABLE\n-\n-        \/\/ Calculate Offset for Symbol table\n-        int fileOffset = IMAGE_FILE_HEADER.totalsize +\n-                        (IMAGE_SECTION_HEADER.totalsize * sections.size());\n-\n-        \/\/ Update Header fields\n-        header.setSectionCount(sections.size());\n-        header.setSymbolCount(symtab.getSymtabCount());\n-        header.setSymbolOff(fileOffset);\n-\n-        \/\/ Calculate file offset for first section\n-        fileOffset += ((symtab.getSymtabCount() * IMAGE_SYMBOL.totalsize) +\n-                        symtab.getStrtabSize());\n-        \/\/ And round it up\n-        fileOffset = (fileOffset + (sections.get(0).getDataAlign() - 1)) &\n-                        ~((sections.get(0).getDataAlign() - 1));\n-\n-        \/\/ Calc file offsets for section data\n-        for (int i = 0; i < sections.size(); i++) {\n-            PECoffSection sect = sections.get(i);\n-            fileOffset = (fileOffset + (sect.getDataAlign() - 1)) &\n-                            ~((sect.getDataAlign() - 1));\n-            sect.setOffset(fileOffset);\n-            fileOffset += sect.getSize();\n-        }\n-\n-        \/\/ Update relocation sizing information in each section\n-        for (int i = 0; i < sections.size(); i++) {\n-            PECoffSection sect = sections.get(i);\n-            if (sect.hasRelocations()) {\n-                int nreloc = pecoffRelocs.getNumRelocs(i);\n-                sect.setReloff(fileOffset);\n-                sect.setRelcount(nreloc);\n-                \/\/ extended relocations add an addition entry\n-                if (nreloc > 0xFFFF) {\n-                    nreloc++;\n-                }\n-                fileOffset += (nreloc * IMAGE_RELOCATION.totalsize);\n-            }\n-        }\n-\n-        \/\/ Write out the Header\n-        pecoffContainer.writeBytes(header.getArray());\n-\n-        \/\/ Write out the section table\n-        for (int i = 0; i < sections.size(); i++) {\n-            PECoffSection sect = sections.get(i);\n-            pecoffContainer.writeBytes(sect.getArray(), PECoffSection.getShdrAlign());\n-        }\n-\n-        \/\/ Write out the symbol table and string table\n-        pecoffContainer.writeBytes(symtab.getSymtabArray(), 4);\n-        pecoffContainer.writeBytes(symtab.getStrtabArray(), 1);\n-\n-        \/\/ Write out each section contents\n-        for (int i = 0; i < sections.size(); i++) {\n-            PECoffSection sect = sections.get(i);\n-            pecoffContainer.writeBytes(sect.getDataArray(), sect.getDataAlign());\n-        }\n-\n-        \/\/ Write out Relocation Tables\n-        for (int i = 0; i < sections.size(); i++) {\n-            if (pecoffRelocs.getNumRelocs(i) > 0) {\n-                pecoffContainer.writeBytes(pecoffRelocs.getRelocData(i));\n-            }\n-        }\n-        pecoffContainer.close();\n-    }\n-\n-    \/**\n-     * Construct PECoff symbol data from BinaryContainer object's symbol tables. Both dynamic PECoff\n-     * symbol table and PECoff symbol table are created from BinaryContainer's symbol info.\n-     *\n-     * @param symbols\n-     *\/\n-    private static PECoffSymtab createPECoffSymbolTables(Collection<Symbol> symbols) {\n-        PECoffSymtab symtab = new PECoffSymtab();\n-\n-        \/\/ First, create the initial null symbol. This is a local symbol.\n-        \/\/ symtab.addSymbolEntry(\"\", (byte)0, (byte)0, (byte)0, 0, 0);\n-\n-        \/\/ Now create PECoff symbol entries for all symbols.\n-        for (Symbol symbol : symbols) {\n-            \/\/ Get the index of section this symbol is defined in.\n-            int secHdrIndex = symbol.getSection().getSectionId();\n-            PECoffSymbol pecoffSymbol = symtab.addSymbolEntry(symbol.getName(), getPECoffTypeOf(symbol), getPECoffClassOf(symbol), (byte) secHdrIndex, symbol.getOffset());\n-            symbol.setNativeSymbol(pecoffSymbol);\n-        }\n-        return (symtab);\n-    }\n-\n-    private static byte getPECoffTypeOf(Symbol sym) {\n-        Kind kind = sym.getKind();\n-        if (kind == Symbol.Kind.NATIVE_FUNCTION || kind == Symbol.Kind.JAVA_FUNCTION) {\n-            return IMAGE_SYMBOL.IMAGE_SYM_DTYPE_FUNCTION;\n-        }\n-        return IMAGE_SYMBOL.IMAGE_SYM_DTYPE_NONE;\n-    }\n-\n-    private static byte getPECoffClassOf(Symbol sym) {\n-        Binding binding = sym.getBinding();\n-        if (binding == Symbol.Binding.GLOBAL) {\n-            return IMAGE_SYMBOL.IMAGE_SYM_CLASS_EXTERNAL;\n-        }\n-        return IMAGE_SYMBOL.IMAGE_SYM_CLASS_STATIC;\n-    }\n-\n-    \/**\n-     * Construct a PECoff relocation table from BinaryContainer object's relocation tables.\n-     *\n-     * @param sections\n-     * @param relocationTable\n-     *\/\n-    private PECoffRelocTable createPECoffRelocTable(ArrayList<PECoffSection> sections, Map<Symbol, List<Relocation>> relocationTable) {\n-\n-        PECoffRelocTable pecoffRelocTable = new PECoffRelocTable(sections.size());\n-        \/*\n-         * For each of the symbols with associated relocation records, create a PECoff relocation\n-         * entry.\n-         *\/\n-        for (Map.Entry<Symbol, List<Relocation>> entry : relocationTable.entrySet()) {\n-            List<Relocation> relocs = entry.getValue();\n-            Symbol symbol = entry.getKey();\n-\n-            for (Relocation reloc : relocs) {\n-                createRelocation(symbol, reloc, pecoffRelocTable);\n-            }\n-        }\n-\n-        for (Map.Entry<Symbol, Relocation> entry : binContainer.getUniqueRelocationTable().entrySet()) {\n-            createRelocation(entry.getKey(), entry.getValue(), pecoffRelocTable);\n-        }\n-\n-        return (pecoffRelocTable);\n-    }\n-\n-    private static void createRelocation(Symbol symbol, Relocation reloc, PECoffRelocTable pecoffRelocTable) {\n-        RelocType relocType = reloc.getType();\n-\n-        int pecoffRelocType = getPECoffRelocationType(relocType);\n-        PECoffSymbol sym = (PECoffSymbol) symbol.getNativeSymbol();\n-        int symno = sym.getIndex();\n-        int sectindex = reloc.getSection().getSectionId();\n-        int offset = reloc.getOffset();\n-        int addend = 0;\n-\n-        switch (relocType) {\n-            case JAVA_CALL_DIRECT:\n-            case STUB_CALL_DIRECT:\n-            case FOREIGN_CALL_INDIRECT_GOT: {\n-                \/\/ Create relocation entry\n-                addend = -4; \/\/ Size in bytes of the patch location\n-                \/\/ Relocation should be applied at the location after call operand\n-                offset = offset + reloc.getSize() + addend;\n-                break;\n-            }\n-            case JAVA_CALL_INDIRECT: {\n-                \/\/ Do nothing.\n-                return;\n-            }\n-            case METASPACE_GOT_REFERENCE:\n-            case EXTERNAL_PLT_TO_GOT: {\n-                addend = -4; \/\/ Size of 32-bit address of the GOT\n-                \/*\n-                 * Relocation should be applied before the test instruction to the move instruction.\n-                 * reloc.getOffset() points to the test instruction after the instruction that loads\n-                 * the address of polling page. So set the offset appropriately.\n-                 *\/\n-                offset = offset + addend;\n-                break;\n-            }\n-            case EXTERNAL_GOT_TO_PLT: {\n-                \/\/ this is load time relocations\n-                break;\n-            }\n-            default:\n-                throw new InternalError(\"Unhandled relocation type: \" + relocType);\n-        }\n-        pecoffRelocTable.createRelocationEntry(sectindex, offset, symno, pecoffRelocType);\n-    }\n-\n-    \/\/ Return IMAGE_RELOCATION Type based on relocType\n-    private static int getPECoffRelocationType(RelocType relocType) {\n-        int pecoffRelocType = 0; \/\/ R_<ARCH>_NONE if #define'd to 0 for all values of ARCH\n-        switch (PECoffTargetInfo.getPECoffArch()) {\n-            case IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_AMD64:\n-                if (relocType == RelocType.JAVA_CALL_DIRECT ||\n-                                relocType == RelocType.FOREIGN_CALL_INDIRECT_GOT) {\n-                    pecoffRelocType = IMAGE_RELOCATION.IMAGE_REL_AMD64_REL32;\n-                } else if (relocType == RelocType.STUB_CALL_DIRECT) {\n-                    pecoffRelocType = IMAGE_RELOCATION.IMAGE_REL_AMD64_REL32;\n-                } else if (relocType == RelocType.JAVA_CALL_INDIRECT) {\n-                    pecoffRelocType = IMAGE_RELOCATION.IMAGE_REL_AMD64_ABSOLUTE;\n-                } else if (relocType == RelocType.METASPACE_GOT_REFERENCE ||\n-                                relocType == RelocType.EXTERNAL_PLT_TO_GOT) {\n-                    pecoffRelocType = IMAGE_RELOCATION.IMAGE_REL_AMD64_REL32;\n-                } else if (relocType == RelocType.EXTERNAL_GOT_TO_PLT) {\n-                    pecoffRelocType = IMAGE_RELOCATION.IMAGE_REL_AMD64_ADDR64;\n-                } else {\n-                    assert false : \"Unhandled relocation type: \" + relocType;\n-                }\n-                break;\n-            default:\n-                System.out.println(\"Relocation Type mapping: Unhandled architecture\");\n-        }\n-        return pecoffRelocType;\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/pecoff\/JPECoffRelocObject.java","additions":0,"deletions":365,"binary":false,"changes":365,"status":"deleted"},{"patch":"@@ -1,207 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.pecoff;\n-\n-\/**\n- *\n- * Support for the creation of Coff files. Current support is limited to 64 bit x86_64.\n- *\n- *\/\n-\n-final class PECoff {\n-    \/\/@formatter:off\n-    \/**\n-     * IMAGE_FILE_HEADER structure defines.\n-     *\/\n-    enum IMAGE_FILE_HEADER {\n-                     Machine(0, 2),\n-            NumberOfSections(2, 2),\n-               TimeDateStamp(4, 4),\n-        PointerToSymbolTable(8, 4),\n-             NumberOfSymbols(12, 4),\n-        SizeOfOptionalHeader(16, 2),\n-             Characteristics(18, 2);\n-\n-        final int off;\n-        final int sz;\n-\n-        IMAGE_FILE_HEADER(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 20;\n-\n-        \/**\n-         * IMAGE_FILE_HEADER defines\n-         *\/\n-\n-        \/**\n-         * Machine.\n-         *\/\n-        static final char IMAGE_FILE_MACHINE_UNKNOWN = 0x0;\n-        static final char IMAGE_FILE_MACHINE_AMD64   = 0x8664;\n-\n-    }\n-\n-    \/**\n-     * IMAGE_SECTION_HEADER structure defines.\n-     *\/\n-    enum IMAGE_SECTION_HEADER {\n-                        Name(0, 8),\n-             PhysicalAddress(8, 4),\n-                 VirtualSize(8, 4),\n-              VirtualAddress(12, 4),\n-               SizeOfRawData(16, 4),\n-            PointerToRawData(20, 4),\n-        PointerToRelocations(24, 4),\n-        PointerToLinenumbers(28, 4),\n-         NumberOfRelocations(32, 2),\n-         NumberOfLinenumbers(34, 2),\n-             Characteristics(36, 4);\n-\n-        final int off;\n-        final int sz;\n-\n-        IMAGE_SECTION_HEADER(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 40;\n-\n-        \/**\n-         * IMAGE_SECTION_HEADER defines\n-         *\/\n-\n-        \/**\n-         * Characteristics.\n-         *\/\n-        static final int IMAGE_SCN_CNT_CODE               = 0x20;\n-        static final int IMAGE_SCN_CNT_INITIALIZED_DATA   = 0x40;\n-        static final int IMAGE_SCN_CNT_UNINITIALIZED_DATA = 0x80;\n-        static final int IMAGE_SCN_LNK_COMDAT             = 0x1000;\n-        static final int IMAGE_SCN_LNK_INFO               = 0x200;\n-        static final int IMAGE_SCN_LNK_REMOVE             = 0x800;\n-\n-        static final int IMAGE_SCN_ALIGN_1BYTES           = 0x100000;\n-        static final int IMAGE_SCN_ALIGN_2BYTES           = 0x200000;\n-        static final int IMAGE_SCN_ALIGN_4BYTES           = 0x300000;\n-        static final int IMAGE_SCN_ALIGN_8BYTES           = 0x400000;\n-        static final int IMAGE_SCN_ALIGN_16BYTES          = 0x500000;\n-        static final int IMAGE_SCN_ALIGN_32BYTES          = 0x600000;\n-        static final int IMAGE_SCN_ALIGN_64BYTES          = 0x700000;\n-        static final int IMAGE_SCN_ALIGN_128BYTES         = 0x800000;\n-        static final int IMAGE_SCN_ALIGN_256BYTES         = 0x900000;\n-        static final int IMAGE_SCN_ALIGN_512BYTES         = 0xa00000;\n-        static final int IMAGE_SCN_ALIGN_1024BYTES        = 0xb00000;\n-        static final int IMAGE_SCN_ALIGN_MASK             = 0xf00000;\n-        static final int IMAGE_SCN_ALIGN_SHIFT            = 20;\n-\n-        static final int IMAGE_SCN_LNK_NRELOC_OVFL        = 0x01000000;\n-\n-        static final int IMAGE_SCN_MEM_SHARED             = 0x10000000;\n-        static final int IMAGE_SCN_MEM_EXECUTE            = 0x20000000;\n-        static final int IMAGE_SCN_MEM_READ               = 0x40000000;\n-        static final int IMAGE_SCN_MEM_WRITE              = 0x80000000;\n-\n-    }\n-\n-    \/**\n-     * Symbol table entry definitions.\n-     *\n-     * IMAGE_SYMBOL structure defines\n-     *\/\n-    enum IMAGE_SYMBOL {\n-                   ShortName(0, 8),\n-                       Short(0, 4),\n-                        Long(4, 4),\n-                       Value(8, 4),\n-               SectionNumber(12, 2),\n-                        Type(14, 2),\n-                StorageClass(16, 1),\n-          NumberOfAuxSymbols(17, 1);\n-\n-        final int off;\n-        final int sz;\n-\n-        IMAGE_SYMBOL(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 18;\n-\n-        \/**\n-         * Type.\n-         *\/\n-        static final int IMAGE_SYM_DTYPE_NONE     = 0x0;\n-        static final int IMAGE_SYM_DTYPE_FUNCTION = 0x20;\n-\n-        \/**\n-         * StorageClass.\n-         *\/\n-        static final int IMAGE_SYM_CLASS_NULL     = 0x0;\n-        static final int IMAGE_SYM_CLASS_EXTERNAL = 0x2;\n-        static final int IMAGE_SYM_CLASS_STATIC   = 0x3;\n-        static final int IMAGE_SYM_CLASS_LABEL    = 0x6;\n-\n-    }\n-\n-    \/**\n-     * IMAGE_RELOCATION structure defines.\n-     *\/\n-    enum IMAGE_RELOCATION {\n-              VirtualAddress(0, 4),\n-            SymbolTableIndex(4, 4),\n-                        Type(8, 2);\n-\n-        final int off;\n-        final int sz;\n-\n-        IMAGE_RELOCATION(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 10;\n-\n-        \/**\n-         * Relocation types.\n-         *\/\n-        static final int IMAGE_REL_AMD64_ABSOLUTE = 0x0;\n-        static final int IMAGE_REL_AMD64_ADDR32   = 0x2;\n-        static final int IMAGE_REL_AMD64_ADDR64   = 0x1;\n-        static final int IMAGE_REL_AMD64_REL32    = 0x4;\n-        static final int IMAGE_REL_AMD64_REL32_1  = 0x5;\n-        static final int IMAGE_REL_AMD64_REL32_2  = 0x6;\n-        static final int IMAGE_REL_AMD64_REL32_3  = 0x7;\n-        static final int IMAGE_REL_AMD64_REL32_4  = 0x8;\n-        static final int IMAGE_REL_AMD64_REL32_5  = 0x9;\n-\n-    }\n-    \/\/@formatter:on\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/pecoff\/PECoff.java","additions":0,"deletions":207,"binary":false,"changes":207,"status":"deleted"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.pecoff;\n-\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-\n-final class PECoffByteBuffer {\n-\n-    static ByteBuffer allocate(int size) {\n-        ByteBuffer buf = ByteBuffer.allocate(size);\n-        \/\/ Only support Little Endian on Windows\n-        buf.order(ByteOrder.LITTLE_ENDIAN);\n-        return (buf);\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/pecoff\/PECoffByteBuffer.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -1,89 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.pecoff;\n-\n-import java.io.File;\n-import java.io.FileOutputStream;\n-\n-final class PECoffContainer {\n-\n-    private final File outputFile;\n-    private FileOutputStream outputStream;\n-    private long fileOffset;\n-\n-    PECoffContainer(String fileName) {\n-\n-        outputFile = new File(fileName);\n-        if (outputFile.exists()) {\n-            outputFile.delete();\n-        }\n-\n-        try {\n-            outputStream = new FileOutputStream(outputFile);\n-        } catch (Exception e) {\n-            System.out.println(\"PECoffContainer: Can't create file \" + fileName);\n-        }\n-        fileOffset = 0;\n-    }\n-\n-    void close() {\n-        try {\n-            outputStream.close();\n-        } catch (Exception e) {\n-            System.out.println(\"PECoffContainer: close failed\");\n-        }\n-    }\n-\n-    void writeBytes(byte[] bytes) {\n-        if (bytes == null) {\n-            return;\n-        }\n-        try {\n-            outputStream.write(bytes);\n-        } catch (Exception e) {\n-            System.out.println(\"PECoffContainer: writeBytes failed\");\n-        }\n-        fileOffset += bytes.length;\n-    }\n-\n-    \/\/ Write bytes to output file with up front alignment padding\n-    void writeBytes(byte[] bytes, int alignment) {\n-        if (bytes == null) {\n-            return;\n-        }\n-        try {\n-            \/\/ Pad to alignment\n-            while ((fileOffset & (alignment - 1)) != 0) {\n-                outputStream.write(0);\n-                fileOffset++;\n-            }\n-            outputStream.write(bytes);\n-        } catch (Exception e) {\n-            System.out.println(\"PECoffContainer: writeBytes failed\");\n-        }\n-        fileOffset += bytes.length;\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/pecoff\/PECoffContainer.java","additions":0,"deletions":89,"binary":false,"changes":89,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.pecoff;\n-\n-import java.nio.ByteBuffer;\n-\n-import jdk.tools.jaotc.binformat.pecoff.PECoff.IMAGE_FILE_HEADER;\n-\n-final class PECoffHeader {\n-    private final ByteBuffer header;\n-\n-    PECoffHeader() {\n-        header = PECoffByteBuffer.allocate(IMAGE_FILE_HEADER.totalsize);\n-\n-        header.putChar(IMAGE_FILE_HEADER.Machine.off, IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_AMD64);\n-        header.putInt(IMAGE_FILE_HEADER.TimeDateStamp.off, (int) (System.currentTimeMillis() \/ 1000));\n-        header.putInt(IMAGE_FILE_HEADER.PointerToSymbolTable.off, 0);\n-        header.putInt(IMAGE_FILE_HEADER.NumberOfSymbols.off, 0);\n-        header.putChar(IMAGE_FILE_HEADER.SizeOfOptionalHeader.off, (char) 0);\n-        header.putChar(IMAGE_FILE_HEADER.Characteristics.off, (char) 0);\n-\n-    }\n-\n-    \/\/ Update header with the number of total sections\n-    void setSectionCount(int count) {\n-        header.putChar(IMAGE_FILE_HEADER.NumberOfSections.off, (char) count);\n-    }\n-\n-    \/\/ Update header with the number of total symbols\n-    void setSymbolCount(int count) {\n-        header.putInt(IMAGE_FILE_HEADER.NumberOfSymbols.off, count);\n-    }\n-\n-    \/\/ Update header with the offset of symbol table\n-    void setSymbolOff(int offset) {\n-        header.putInt(IMAGE_FILE_HEADER.PointerToSymbolTable.off, offset);\n-    }\n-\n-    byte[] getArray() {\n-        return header.array();\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/pecoff\/PECoffHeader.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.pecoff;\n-\n-import java.nio.ByteBuffer;\n-\n-import jdk.tools.jaotc.binformat.pecoff.PECoff.IMAGE_RELOCATION;\n-\n-final class PECoffRelocEntry {\n-    private final ByteBuffer entry;\n-\n-    PECoffRelocEntry(int offset, int symno, int type) {\n-\n-        entry = PECoffByteBuffer.allocate(IMAGE_RELOCATION.totalsize);\n-\n-        entry.putInt(IMAGE_RELOCATION.VirtualAddress.off, offset);\n-        entry.putInt(IMAGE_RELOCATION.SymbolTableIndex.off, symno);\n-        entry.putChar(IMAGE_RELOCATION.Type.off, (char) type);\n-    }\n-\n-    byte[] getArray() {\n-        return entry.array();\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/pecoff\/PECoffRelocEntry.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.pecoff;\n-\n-import java.nio.ByteBuffer;\n-import java.util.ArrayList;\n-\n-import jdk.tools.jaotc.binformat.pecoff.PECoff.IMAGE_RELOCATION;\n-\n-final class PECoffRelocTable {\n-    ArrayList<ArrayList<PECoffRelocEntry>> relocEntries;\n-\n-    PECoffRelocTable(int numsects) {\n-        relocEntries = new ArrayList<>(numsects);\n-        for (int i = 0; i < numsects; i++) {\n-            relocEntries.add(new ArrayList<PECoffRelocEntry>());\n-        }\n-    }\n-\n-    void createRelocationEntry(int sectindex, int offset, int symno, int type) {\n-        PECoffRelocEntry entry = new PECoffRelocEntry(offset, symno, type);\n-        relocEntries.get(sectindex).add(entry);\n-    }\n-\n-    static int getAlign() {\n-        return (4);\n-    }\n-\n-    int getNumRelocs(int sectionIndex) {\n-        return relocEntries.get(sectionIndex).size();\n-    }\n-\n-    \/\/ Return the relocation entries for a single section\n-    \/\/ or null if no entries added to section\n-    byte[] getRelocData(int sectionIndex) {\n-        ArrayList<PECoffRelocEntry> entryList = relocEntries.get(sectionIndex);\n-        int entryCount = entryList.size();\n-        int allocCount = entryCount;\n-\n-        if (entryCount == 0) {\n-            return null;\n-        }\n-        if (entryCount > 0xFFFF) {\n-            allocCount++;\n-        }\n-        ByteBuffer relocData = PECoffByteBuffer.allocate(allocCount * IMAGE_RELOCATION.totalsize);\n-\n-        \/\/ If number of relocs exceeds 65K, add the real size\n-        \/\/ in a dummy first reloc entry\n-        if (entryCount > 0xFFFF) {\n-            PECoffRelocEntry entry = new PECoffRelocEntry(allocCount, 0, 0);\n-            relocData.put(entry.getArray());\n-        }\n-\n-        \/\/ Copy each entry to a single ByteBuffer\n-        for (int i = 0; i < entryCount; i++) {\n-            PECoffRelocEntry entry = entryList.get(i);\n-            relocData.put(entry.getArray());\n-        }\n-\n-        return (relocData.array());\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/pecoff\/PECoffRelocTable.java","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -1,133 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.pecoff;\n-\n-import java.nio.ByteBuffer;\n-\n-import jdk.tools.jaotc.binformat.pecoff.PECoff.IMAGE_SECTION_HEADER;\n-\n-final class PECoffSection {\n-    private final ByteBuffer section;\n-    private final byte[] data;\n-    private final boolean hasrelocations;\n-    private final int sectionIndex;\n-    private final int align;\n-\n-    PECoffSection(String sectName, byte[] sectData0, int sectFlags0, int sectAlign, boolean hasRelocations, int sectIndex) {\n-\n-        section = PECoffByteBuffer.allocate(IMAGE_SECTION_HEADER.totalsize);\n-\n-        \/\/ If .oop.got section is empty, VM exits since .oop.got\n-        \/\/ symbol ends up as external forwarded reference.\n-        byte[] sectData = sectData0;\n-        if (sectData0.length == 0) {\n-            sectData = new byte[8];\n-        }\n-\n-        \/\/ Copy only Max allowed bytes to Section Entry\n-        byte[] name = sectName.getBytes();\n-        int max = name.length <= IMAGE_SECTION_HEADER.Name.sz ? name.length : IMAGE_SECTION_HEADER.Name.sz;\n-\n-        assert !(sectAlign < 1 || sectAlign > 1024 || (sectAlign & (sectAlign - 1)) != 0) : \"section alignment is not valid: \" + sectAlign;\n-        align = sectAlign;\n-\n-        \/\/ Using 32 because IMAGE_SCN_ALIGN_*BYTES is value + 1\n-        int sectAlignBits = (32 - Integer.numberOfLeadingZeros(align)) << IMAGE_SECTION_HEADER.IMAGE_SCN_ALIGN_SHIFT;\n-        \/\/ Clear and set alignment bits\n-        int sectFlags = (sectFlags0 & ~IMAGE_SECTION_HEADER.IMAGE_SCN_ALIGN_MASK) | (sectAlignBits & IMAGE_SECTION_HEADER.IMAGE_SCN_ALIGN_MASK);\n-\n-        section.put(name, IMAGE_SECTION_HEADER.Name.off, max);\n-\n-        section.putInt(IMAGE_SECTION_HEADER.VirtualSize.off, 0);\n-        section.putInt(IMAGE_SECTION_HEADER.VirtualAddress.off, 0);\n-        section.putInt(IMAGE_SECTION_HEADER.SizeOfRawData.off, sectData.length);\n-        section.putInt(IMAGE_SECTION_HEADER.PointerToLinenumbers.off, 0);\n-        section.putChar(IMAGE_SECTION_HEADER.NumberOfLinenumbers.off, (char) 0);\n-\n-        section.putInt(IMAGE_SECTION_HEADER.Characteristics.off, sectFlags);\n-\n-        data = sectData;\n-        hasrelocations = hasRelocations;\n-        sectionIndex = sectIndex;\n-    }\n-\n-    long getSize() {\n-        return section.getInt(IMAGE_SECTION_HEADER.SizeOfRawData.off);\n-    }\n-\n-    int getDataAlign() {\n-        return (align);\n-    }\n-\n-    \/\/ Alignment requirements for the IMAGE_SECTION_HEADER structures\n-    static int getShdrAlign() {\n-        return (4);\n-    }\n-\n-    byte[] getArray() {\n-        return section.array();\n-    }\n-\n-    byte[] getDataArray() {\n-        return data;\n-    }\n-\n-    void setOffset(long offset) {\n-        section.putInt(IMAGE_SECTION_HEADER.PointerToRawData.off, (int) offset);\n-    }\n-\n-    long getOffset() {\n-        return (section.getInt(IMAGE_SECTION_HEADER.PointerToRawData.off));\n-    }\n-\n-    void setReloff(int offset) {\n-        section.putInt(IMAGE_SECTION_HEADER.PointerToRelocations.off, offset);\n-    }\n-\n-    void setRelcount(int count) {\n-        \/\/ If the number of relocs is larger than 65K, then set\n-        \/\/ the overflow bit. The real count will be written to\n-        \/\/ the first reloc entry for this section.\n-        if (count > 0xFFFF) {\n-            int flags;\n-            section.putChar(IMAGE_SECTION_HEADER.NumberOfRelocations.off, (char) 0xFFFF);\n-            flags = section.getInt(IMAGE_SECTION_HEADER.Characteristics.off);\n-            flags |= IMAGE_SECTION_HEADER.IMAGE_SCN_LNK_NRELOC_OVFL;\n-            section.putInt(IMAGE_SECTION_HEADER.Characteristics.off, flags);\n-        } else {\n-            section.putChar(IMAGE_SECTION_HEADER.NumberOfRelocations.off, (char) count);\n-        }\n-    }\n-\n-    boolean hasRelocations() {\n-        return hasrelocations;\n-    }\n-\n-    int getSectionId() {\n-        return sectionIndex;\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/pecoff\/PECoffSection.java","additions":0,"deletions":133,"binary":false,"changes":133,"status":"deleted"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.pecoff;\n-\n-import java.nio.ByteBuffer;\n-\n-import jdk.tools.jaotc.binformat.NativeSymbol;\n-import jdk.tools.jaotc.binformat.pecoff.PECoff.IMAGE_SYMBOL;\n-\n-final class PECoffSymbol extends NativeSymbol {\n-    private final ByteBuffer sym;\n-\n-    PECoffSymbol(int symbolindex, int strindex, byte type, byte storageclass, byte sectindex, long offset) {\n-        super(symbolindex);\n-        sym = PECoffByteBuffer.allocate(IMAGE_SYMBOL.totalsize);\n-\n-        \/\/ We don't use short names\n-        sym.putInt(IMAGE_SYMBOL.Short.off, 0);\n-\n-        sym.putInt(IMAGE_SYMBOL.Long.off, strindex);\n-        sym.putInt(IMAGE_SYMBOL.Value.off, (int) offset);\n-\n-        \/\/ Section indexes start at 1 but we manage the index internally\n-        \/\/ as 0 relative except in this structure\n-        sym.putChar(IMAGE_SYMBOL.SectionNumber.off, (char) (sectindex + 1));\n-\n-        sym.putChar(IMAGE_SYMBOL.Type.off, (char) type);\n-        sym.put(IMAGE_SYMBOL.StorageClass.off, storageclass);\n-        sym.put(IMAGE_SYMBOL.NumberOfAuxSymbols.off, (byte) 0);\n-    }\n-\n-    byte[] getArray() {\n-        return sym.array();\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/pecoff\/PECoffSymbol.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -1,150 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.pecoff;\n-\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-import java.util.ArrayList;\n-\n-import jdk.tools.jaotc.binformat.pecoff.PECoff.IMAGE_SYMBOL;\n-\n-final class PECoffSymtab {\n-    ArrayList<PECoffSymbol> symbols = new ArrayList<>();\n-\n-    \/**\n-     * Number of symbols added.\n-     *\/\n-    private int symbolCount;\n-\n-    \/**\n-     * String holding symbol table strings.\n-     *\/\n-    private final StringBuilder strTabContent;\n-\n-    \/**\n-     * Keeps track of bytes in string table since strTabContent.length() is number of chars, not\n-     * bytes.\n-     *\/\n-    private int strTabNrOfBytes;\n-\n-    \/**\n-     * String holding Linker Directives.\n-     *\/\n-    private final StringBuilder directives;\n-\n-    PECoffSymtab() {\n-        symbolCount = 0;\n-        strTabContent = new StringBuilder();\n-        directives = new StringBuilder();\n-\n-        \/\/ The first 4 bytes of the string table contain\n-        \/\/ the length of the table (including this length field).\n-        strTabNrOfBytes = 4;\n-\n-        \/\/ Make room for the 4 byte length field\n-        strTabContent.append('\\0').append('\\0').append('\\0').append('\\0');\n-\n-        \/\/ Linker Directives start with 3 spaces to signify ANSI\n-        directives.append(\"   \");\n-    }\n-\n-    PECoffSymbol addSymbolEntry(String name, byte type, byte storageclass, byte secHdrIndex, long offset) {\n-        \/\/ Get the current symbol index and append symbol name to string table.\n-        int index;\n-        PECoffSymbol sym;\n-\n-        if (name.isEmpty()) {\n-            index = 0;\n-            strTabContent.append('\\0');\n-            strTabNrOfBytes += 1;\n-            sym = new PECoffSymbol(symbolCount, index, type, storageclass, secHdrIndex, offset);\n-            symbols.add(sym);\n-        } else {\n-            int nameSize = name.getBytes().length;\n-\n-            \/\/ We can't trust strTabContent.length() since that is\n-            \/\/ chars (UTF16), keep track of bytes on our own.\n-            index = strTabNrOfBytes;\n-            \/\/ strTabContent.append('_').append(name).append('\\0');\n-            strTabContent.append(name).append('\\0');\n-            strTabNrOfBytes += (nameSize + 1);\n-\n-            sym = new PECoffSymbol(symbolCount, index, type, storageclass, secHdrIndex, offset);\n-            symbols.add(sym);\n-            if (storageclass == IMAGE_SYMBOL.IMAGE_SYM_CLASS_EXTERNAL) {\n-                addDirective(name, type);\n-            }\n-        }\n-        symbolCount++;\n-        return (sym);\n-    }\n-\n-    private void addDirective(String name, byte type) {\n-        directives.append(\"\/EXPORT:\" + name);\n-        if (type != IMAGE_SYMBOL.IMAGE_SYM_DTYPE_FUNCTION) {\n-            directives.append(\",DATA\");\n-        }\n-        directives.append(\" \");\n-    }\n-\n-    int getSymtabCount() {\n-        return symbolCount;\n-    }\n-\n-    int getStrtabSize() {\n-        return strTabNrOfBytes;\n-    }\n-\n-    \/\/ Return a byte array that contains the symbol table entries\n-    byte[] getSymtabArray() {\n-        ByteBuffer symtabData = PECoffByteBuffer.allocate(symbolCount * IMAGE_SYMBOL.totalsize);\n-        symtabData.order(ByteOrder.LITTLE_ENDIAN);\n-\n-        \/\/ copy all symbols\n-        for (int i = 0; i < symbolCount; i++) {\n-            PECoffSymbol sym = symbols.get(i);\n-            byte[] arr = sym.getArray();\n-            symtabData.put(arr);\n-        }\n-        return (symtabData.array());\n-    }\n-\n-    \/\/ Return the string table array\n-    byte[] getStrtabArray() {\n-        byte[] strs = strTabContent.toString().getBytes();\n-\n-        \/\/ Update the size of the string table\n-        ByteBuffer buff = ByteBuffer.wrap(strs);\n-        buff.order(ByteOrder.LITTLE_ENDIAN);\n-        buff.putInt(0, strTabNrOfBytes);\n-\n-        return (strs);\n-    }\n-\n-    byte[] getDirectiveArray() {\n-        return (directives.toString().getBytes());\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/pecoff\/PECoffSymtab.java","additions":0,"deletions":150,"binary":false,"changes":150,"status":"deleted"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.binformat.pecoff;\n-\n-import java.nio.ByteOrder;\n-import jdk.tools.jaotc.binformat.pecoff.PECoff.IMAGE_FILE_HEADER;\n-\n-\/**\n- * Class that abstracts MACH-O target details.\n- *\n- *\/\n-final class PECoffTargetInfo {\n-    \/**\n-     * Target architecture.\n-     *\/\n-    private static final char arch;\n-\n-    \/**\n-     * Target OS string.\n-     *\/\n-    private static String osName;\n-\n-    static {\n-        \/\/ Find the target arch details\n-        String archStr = System.getProperty(\"os.arch\").toLowerCase();\n-        if (ByteOrder.nativeOrder() != ByteOrder.LITTLE_ENDIAN) {\n-            System.out.println(\"Only Little Endian byte order supported!\");\n-        }\n-\n-        if (archStr.equals(\"amd64\") || archStr.equals(\"x86_64\")) {\n-            arch = IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_AMD64;\n-        } else {\n-            System.out.println(\"Unsupported architecture \" + archStr);\n-            arch = IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_UNKNOWN;\n-        }\n-\n-        osName = System.getProperty(\"os.name\").toLowerCase();\n-        if (!osName.contains(\"windows\")) {\n-            System.out.println(\"Unsupported Operating System \" + osName);\n-            osName = \"Unknown\";\n-        }\n-    }\n-\n-    static char getPECoffArch() {\n-        return arch;\n-    }\n-\n-    static String getOsName() {\n-        return osName;\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/pecoff\/PECoffTargetInfo.java","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-package jdk.tools.jaotc.test;\n-\n-public class HelloWorld {\n-    public static void main(String[] args) {\n-        System.out.println(\"Hello, world!\");\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.test\/src\/jdk\/tools\/jaotc\/test\/HelloWorld.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -1,136 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @requires vm.aot\n- * @modules jdk.aot\/jdk.tools.jaotc.utils\n- * @run junit\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI jdk.tools.jaotc.test.NativeOrderOutputStreamTest\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.test;\n-\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-\n-import org.junit.Assert;\n-import org.junit.Test;\n-\n-import jdk.tools.jaotc.utils.NativeOrderOutputStream;\n-\n-public class NativeOrderOutputStreamTest {\n-\n-    @Test\n-    public void shouldAdd4BytesForInt() {\n-        NativeOrderOutputStream target = new NativeOrderOutputStream();\n-        target.putInt(5);\n-        Assert.assertEquals(4, target.position());\n-    }\n-\n-    @Test\n-    public void shouldAdd8BytesForLong() {\n-        NativeOrderOutputStream target = new NativeOrderOutputStream();\n-        target.putLong(8);\n-        Assert.assertEquals(8, target.position());\n-    }\n-\n-    @Test\n-    public void shouldHaveCorrectSizeBeforePatch() {\n-        NativeOrderOutputStream target = new NativeOrderOutputStream();\n-        target.patchableInt();\n-        Assert.assertEquals(4, target.position());\n-    }\n-\n-    @Test\n-    public void shouldHaveCorrectSizeAfterPatch() {\n-        NativeOrderOutputStream target = new NativeOrderOutputStream();\n-        NativeOrderOutputStream.PatchableInt patchableInt = target.patchableInt();\n-        patchableInt.set(12);\n-        Assert.assertEquals(4, target.position());\n-    }\n-\n-    @Test\n-    public void shouldSetCorrectValueInPatch() {\n-        NativeOrderOutputStream target = new NativeOrderOutputStream();\n-        NativeOrderOutputStream.PatchableInt patchableInt = target.patchableInt();\n-        patchableInt.set(42);\n-        Assert.assertEquals(42, getInt(target, 0));\n-    }\n-\n-    private static int getInt(NativeOrderOutputStream target, int pos) {\n-        ByteBuffer buffer = ByteBuffer.wrap(target.array());\n-        buffer.order(ByteOrder.nativeOrder());\n-        return buffer.getInt(pos);\n-    }\n-\n-    @Test\n-    public void shouldPutArrayCorrectly() {\n-        NativeOrderOutputStream target = new NativeOrderOutputStream();\n-        target.put(new byte[]{42, 5, 43, 44});\n-        Assert.assertEquals(4, target.position());\n-        Assert.assertEquals(42, target.array()[0]);\n-        Assert.assertEquals(4, target.position());\n-    }\n-\n-    @Test\n-    public void shouldOnlyPatchSlot() {\n-        NativeOrderOutputStream target = new NativeOrderOutputStream();\n-        NativeOrderOutputStream.PatchableInt patchableInt = target.patchableInt();\n-        target.putInt(7);\n-        patchableInt.set(39);\n-        Assert.assertEquals(39, getInt(target, 0));\n-        Assert.assertEquals(7, getInt(target, 4));\n-    }\n-\n-    @Test\n-    public void shouldBeAbleToPatchAnywhere() {\n-        NativeOrderOutputStream target = new NativeOrderOutputStream();\n-        target.putInt(19);\n-        NativeOrderOutputStream.PatchableInt patchableInt = target.patchableInt();\n-        patchableInt.set(242);\n-\n-        Assert.assertEquals(19, getInt(target, 0));\n-        Assert.assertEquals(242, getInt(target, 4));\n-    }\n-\n-    @Test\n-    public void shouldHavePatchableAtRightOffset() {\n-        NativeOrderOutputStream target = new NativeOrderOutputStream();\n-        target.putInt(27);\n-        Assert.assertEquals(4, target.position());\n-        NativeOrderOutputStream.PatchableInt patchableInt = target.patchableInt();\n-        Assert.assertEquals(4, patchableInt.position());\n-    }\n-\n-    @Test\n-    public void shouldAlign() {\n-        NativeOrderOutputStream target = new NativeOrderOutputStream();\n-        target.putInt(9);\n-        target.align(16);\n-        target.put(new byte[]{3});\n-        target.align(8);\n-        Assert.assertEquals(24, target.position());\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.test\/src\/jdk\/tools\/jaotc\/test\/NativeOrderOutputStreamTest.java","additions":0,"deletions":136,"binary":false,"changes":136,"status":"deleted"},{"patch":"@@ -1,219 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @requires vm.aot\n- * @modules jdk.aot\/jdk.tools.jaotc\n- *          jdk.aot\/jdk.tools.jaotc.collect\n- * @run junit\/othervm jdk.tools.jaotc.test.collect.ClassSearchTest\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.test.collect;\n-\n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.function.BiConsumer;\n-import java.util.function.BiFunction;\n-\n-import org.junit.Assert;\n-import org.junit.Test;\n-\n-import jdk.tools.jaotc.LoadedClass;\n-import jdk.tools.jaotc.collect.ClassSearch;\n-import jdk.tools.jaotc.collect.ClassSource;\n-import jdk.tools.jaotc.collect.SearchFor;\n-import jdk.tools.jaotc.collect.SearchPath;\n-import jdk.tools.jaotc.collect.SourceProvider;\n-\n-public class ClassSearchTest {\n-    @Test(expected = InternalError.class)\n-    public void itShouldThrowExceptionIfNoProvidersAvailable() {\n-        ClassSearch target = new ClassSearch();\n-        SearchPath searchPath = new SearchPath();\n-        target.search(list(new SearchFor(\"foo\")), searchPath);\n-    }\n-\n-    @Test\n-    public void itShouldFindAProviderForEachEntry() {\n-        Set<String> searched = new HashSet<>();\n-        ClassSearch target = new ClassSearch();\n-        target.addProvider(provider(\"\", (name, searchPath) -> {\n-            searched.add(name);\n-            return new NoopSource();\n-        }));\n-        target.search(searchForList(\"foo\", \"bar\", \"foobar\"), null);\n-        Assert.assertEquals(hashset(\"foo\", \"bar\", \"foobar\"), searched);\n-    }\n-\n-    private static SourceProvider provider(String supports, BiFunction<String, SearchPath, ClassSource> fn) {\n-        return new SourceProvider() {\n-            @Override\n-            public ClassSource findSource(String name, SearchPath searchPath) {\n-                return fn.apply(name, searchPath);\n-            }\n-\n-            @Override\n-            public boolean supports(String type) {\n-                return supports.equals(type);\n-            }\n-        };\n-    }\n-\n-    @Test\n-    public void itShouldOnlySearchSupportedProvidersForKnownType() {\n-        Set<String> visited = new HashSet<>();\n-        ClassSearch target = new ClassSearch();\n-\n-        target.addProvider(provider(\"jar\", (name, searchPath) -> {\n-            visited.add(\"jar\");\n-            return null;\n-        }));\n-\n-        target.addProvider(provider(\"dir\", (name, searchPath) -> {\n-            visited.add(\"dir\");\n-            return null;\n-        }));\n-\n-        try {\n-            target.search(list(new SearchFor(\"some\", \"dir\")), null);\n-        } catch (InternalError e) {\n-            \/\/ throws because no provider gives a source\n-        }\n-\n-        Assert.assertEquals(hashset(\"dir\"), visited);\n-    }\n-\n-    @Test(expected = InternalError.class)\n-    public void itShouldThrowErrorIfMultipleSourcesAreAvailable() {\n-        ClassSearch target = new ClassSearch();\n-        target.addProvider(provider(\"\", (name, searchPath) -> consumer -> Assert.fail()));\n-        target.addProvider(provider(\"\", (name, searchPath) -> consumer -> Assert.fail()));\n-\n-        target.search(searchForList(\"somethign\"), null);\n-    }\n-\n-    @Test\n-    public void itShouldSearchAllProvidersForUnknownType() {\n-        Set<String> visited = new HashSet<>();\n-        ClassSearch target = new ClassSearch();\n-        target.addProvider(provider(\"\", (name, searchPath) -> {\n-            visited.add(\"1\");\n-            return null;\n-        }));\n-        target.addProvider(provider(\"\", (name, searchPath) -> {\n-            visited.add(\"2\");\n-            return null;\n-        }));\n-\n-        try {\n-            target.search(searchForList(\"foo\"), null);\n-        } catch (InternalError e) {\n-            \/\/ throws because no provider gives a source\n-        }\n-\n-        Assert.assertEquals(hashset(\"1\", \"2\"), visited);\n-    }\n-\n-    @Test\n-    public void itShouldTryToLoadSaidClassFromClassLoader() {\n-        Set<String> loaded = new HashSet<>();\n-\n-        ClassSearch target = new ClassSearch();\n-        target.addProvider(new SourceProvider() {\n-            @Override\n-            public boolean supports(String type) {\n-                return true;\n-            }\n-\n-            @Override\n-            public ClassSource findSource(String name, SearchPath searchPath) {\n-                return new ClassSource() {\n-                    @Override\n-                    public void eachClass(BiConsumer<String, ClassLoader> consumer) {\n-                        consumer.accept(\"foo.Bar\", new ClassLoader() {\n-                            @Override\n-                            public Class<?> loadClass(String nm) throws ClassNotFoundException {\n-                                loaded.add(nm);\n-                                return null;\n-                            }\n-                        });\n-                    }\n-                };\n-            }\n-        });\n-\n-        java.util.List<LoadedClass> search = target.search(searchForList(\"\/tmp\/something\"), null);\n-        Assert.assertEquals(list(new LoadedClass(\"foo.Bar\", null)), search);\n-    }\n-\n-    @Test(expected = InternalError.class)\n-    public void itShouldThrowInternalErrorWhenClassLoaderFails() {\n-        ClassLoader classLoader = new ClassLoader() {\n-            @Override\n-            public Class<?> loadClass(String name1) throws ClassNotFoundException {\n-                throw new ClassNotFoundException(\"failed to find \" + name1);\n-            }\n-        };\n-\n-        ClassSearch target = new ClassSearch();\n-        target.addProvider(provider(\"\", (name, searchPath) -> consumer -> consumer.accept(\"foo.Bar\", classLoader)));\n-        target.search(searchForList(\"foobar\"), null);\n-    }\n-\n-    private static List<SearchFor> searchForList(String... entries) {\n-        List<SearchFor> list = new ArrayList<>();\n-        for (String entry : entries) {\n-            list.add(new SearchFor(entry));\n-        }\n-        return list;\n-    }\n-\n-    @SafeVarargs\n-    private static <T> List<T> list(T... entries) {\n-        List<T> list = new ArrayList<>();\n-        for (T entry : entries) {\n-            list.add(entry);\n-        }\n-        return list;\n-    }\n-\n-    @SafeVarargs\n-    private static <T> Set<T> hashset(T... entries) {\n-        Set<T> set = new HashSet<>();\n-        for (T entry : entries) {\n-            set.add(entry);\n-        }\n-        return set;\n-    }\n-\n-    private static class NoopSource implements ClassSource {\n-        @Override\n-        public void eachClass(BiConsumer<String, ClassLoader> consumer) {\n-        }\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.test\/src\/jdk\/tools\/jaotc\/test\/collect\/ClassSearchTest.java","additions":0,"deletions":219,"binary":false,"changes":219,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @requires vm.aot\n- * @modules jdk.aot\/jdk.tools.jaotc\n- *          jdk.aot\/jdk.tools.jaotc.collect\n- * @build jdk.tools.jaotc.test.collect.Utils\n- * @run junit\/othervm jdk.tools.jaotc.test.collect.ClassSourceTest\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.test.collect;\n-\n-import org.junit.Assert;\n-import org.junit.Test;\n-\n-import java.nio.file.Paths;\n-\n-import static jdk.tools.jaotc.collect.ClassSource.makeClassName;\n-\n-import static jdk.tools.jaotc.test.collect.Utils.getpath;\n-\n-public class ClassSourceTest {\n-    @Test(expected = IllegalArgumentException.class)\n-    public void itShouldThrowExceptionIfPathDoesntEndWithClass() {\n-        makeClassName(Paths.get(\"Bar.clazz\"));\n-    }\n-\n-    @Test\n-    public void itShouldReplaceSlashesWithDots() {\n-        Assert.assertEquals(\"foo.Bar\", makeClassName(getpath(\"foo\/Bar.class\")));\n-    }\n-\n-    @Test\n-    public void itShouldStripLeadingSlash() {\n-        Assert.assertEquals(\"Hello\", makeClassName(getpath(\"\/Hello.class\")));\n-    }\n-\n-    @Test\n-    public void itShouldReplaceMultipleDots() {\n-        Assert.assertEquals(\"some.foo.bar.FooBar\", makeClassName(getpath(\"\/some\/foo\/bar\/FooBar.class\")));\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.test\/src\/jdk\/tools\/jaotc\/test\/collect\/ClassSourceTest.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,114 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-package jdk.tools.jaotc.test.collect;\n-\n-import java.net.MalformedURLException;\n-import java.nio.file.Path;\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-import jdk.tools.jaotc.collect.FileSupport;\n-\n-public class FakeFileSupport extends FileSupport {\n-    private final Set<String> exists = new HashSet<>();\n-    private final Set<String> directories = new HashSet<>();\n-\n-    private final Set<String> checkedExists = new HashSet<>();\n-    private final Set<String> checkedDirectory = new HashSet<>();\n-    private final Set<String> checkedJarFileSystemRoots = new HashSet<>();\n-    private final Set<String> classloaderPaths = new HashSet<>();\n-\n-    private Path jarFileSystemRoot = null;\n-    private final ClassLoader classLoader;\n-\n-    public FakeFileSupport(Set<String> existing, Set<String> directories) {\n-        this.exists.addAll(existing);\n-        this.directories.addAll(directories);\n-\n-        classLoader = new ClassLoader() {\n-            @Override\n-            public Class<?> loadClass(String name) throws ClassNotFoundException {\n-                return null;\n-            }\n-        };\n-    }\n-\n-    public void setJarFileSystemRoot(Path path) {\n-        jarFileSystemRoot = path;\n-    }\n-\n-    @Override\n-    public boolean exists(Path path) {\n-        checkedExists.add(path.toString());\n-        return exists.contains(path.toString());\n-    }\n-\n-    @Override\n-    public boolean isDirectory(Path path) {\n-        checkedDirectory.add(path.toString());\n-        return directories.contains(path.toString());\n-    }\n-\n-    @Override\n-    public ClassLoader createClassLoader(Path path) throws MalformedURLException {\n-        classloaderPaths.add(path.toString());\n-        return classLoader;\n-    }\n-\n-    @Override\n-    public Path getJarFileSystemRoot(Path jarFile) {\n-        checkedJarFileSystemRoots.add(jarFile.toString());\n-        return jarFileSystemRoot;\n-    }\n-\n-    @Override\n-    public boolean isAbsolute(Path entry) {\n-        return entry.toString().startsWith(\"\/\");\n-    }\n-\n-    public void addExist(String name) {\n-        exists.add(name);\n-    }\n-\n-    public void addDirectory(String name) {\n-        directories.add(name);\n-    }\n-\n-    public Set<String> getCheckedExists() {\n-        return checkedExists;\n-    }\n-\n-    public Set<String> getCheckedDirectory() {\n-        return checkedDirectory;\n-    }\n-\n-    public Set<String> getCheckedJarFileSystemRoots() {\n-        return checkedJarFileSystemRoots;\n-    }\n-\n-    public Set<String> getClassloaderPaths() {\n-        return classloaderPaths;\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.test\/src\/jdk\/tools\/jaotc\/test\/collect\/FakeFileSupport.java","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-package jdk.tools.jaotc.test.collect;\n-\n-import jdk.tools.jaotc.collect.SearchPath;\n-\n-import java.nio.file.FileSystem;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.Set;\n-\n-import static jdk.tools.jaotc.test.collect.Utils.set;\n-\n-public class FakeSearchPath extends SearchPath {\n-    private Path path = null;\n-    public Set<String> entries = set();\n-\n-    public FakeSearchPath(String name) {\n-        if (name != null) {\n-            path = Paths.get(name);\n-        }\n-    }\n-\n-    @Override\n-    public Path find(FileSystem fileSystem, Path entry, String... defaults) {\n-        entries.add(entry.toString());\n-        return path;\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.test\/src\/jdk\/tools\/jaotc\/test\/collect\/FakeSearchPath.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @requires vm.aot\n- * @modules jdk.aot\/jdk.tools.jaotc\n- *          jdk.aot\/jdk.tools.jaotc.collect\n- *\n- * @build jdk.tools.jaotc.test.collect.Utils\n- * @build jdk.tools.jaotc.test.collect.FakeFileSupport\n- * @run junit\/othervm jdk.tools.jaotc.test.collect.SearchPathTest\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.test.collect;\n-\n-import static jdk.tools.jaotc.test.collect.Utils.mkpath;\n-import static jdk.tools.jaotc.test.collect.Utils.mkpaths;\n-import static jdk.tools.jaotc.test.collect.Utils.set;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertSame;\n-\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-import jdk.tools.jaotc.collect.SearchPath;\n-\n-public class SearchPathTest {\n-    private FakeFileSupport fileSupport;\n-    private FileSystem fs;\n-\n-    @Before\n-    public void setUp() throws Exception {\n-        fs = FileSystems.getDefault();\n-    }\n-\n-    @Test\n-    public void itShouldUsePathIfPathIsAbsoluteAndExisting() {\n-        fileSupport = new FakeFileSupport(mkpaths(\"\/foo\"), set());\n-        SearchPath target = new SearchPath(fileSupport);\n-        Path foo = Paths.get(mkpath(\"\/foo\"));\n-        Path result = target.find(fs, foo);\n-        assertSame(result, foo);\n-    }\n-\n-    @Test\n-    public void itShouldReturnNullIfPathIsAbsoluteAndNonExisting() {\n-        fileSupport = new FakeFileSupport(set(), set());\n-        SearchPath target = new SearchPath(fileSupport);\n-        Path result = target.find(fs, Paths.get(mkpath(\"\/bar\")));\n-        assertNull(result);\n-    }\n-\n-    @Test\n-    public void itShouldUseRelativeExisting() {\n-        fileSupport = new FakeFileSupport(mkpaths(\"hello\", \"tmp\/hello\", \"search\/hello\"), set());\n-        SearchPath target = new SearchPath(fileSupport);\n-        target.add(\"search\");\n-        Path hello = Paths.get(\"hello\");\n-        Path result = target.find(fs, hello, \"tmp\");\n-        assertSame(result, hello);\n-    }\n-\n-    @Test\n-    public void itShouldSearchDefaultsBeforeSearchPaths() {\n-        fileSupport = new FakeFileSupport(mkpaths(\"bar\/foobar\"), set());\n-        SearchPath target = new SearchPath(fileSupport);\n-        Path result = target.find(fs, Paths.get(\"foobar\"), \"default1\", \"bar\");\n-        assertEquals(mkpath(\"bar\/foobar\"), result.toString());\n-        assertEquals(mkpaths(\"foobar\", \"default1\/foobar\", \"bar\/foobar\"), fileSupport.getCheckedExists());\n-    }\n-\n-    @Test\n-    public void itShouldUseSearchPathsIfNotInDefaults() {\n-        fileSupport = new FakeFileSupport(mkpaths(\"bar\/tmp\/foobar\"), set());\n-        SearchPath target = new SearchPath(fileSupport);\n-        target.add(\"foo\/tmp\", \"bar\/tmp\");\n-\n-        Path result = target.find(fs, Paths.get(\"foobar\"), \"foo\", \"bar\");\n-        assertEquals(mkpath(\"bar\/tmp\/foobar\"), result.toString());\n-        assertEquals(mkpaths(\"foobar\", \"foo\/foobar\", \"bar\/foobar\", \"bar\/tmp\/foobar\", \"foo\/tmp\/foobar\"), fileSupport.getCheckedExists());\n-    }\n-\n-    @Test\n-    public void itShouldReturnNullIfNoExistingPathIsFound() {\n-        fileSupport = new FakeFileSupport(set(), set());\n-        SearchPath target = new SearchPath(fileSupport);\n-        target.add(\"dir1\", \"dir2\");\n-\n-        Path result = target.find(fs, Paths.get(\"entry\"), \"dir3\", \"dir4\");\n-        assertNull(result);\n-        assertEquals(mkpaths(\"entry\", \"dir1\/entry\", \"dir2\/entry\", \"dir3\/entry\", \"dir4\/entry\"), fileSupport.getCheckedExists());\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.test\/src\/jdk\/tools\/jaotc\/test\/collect\/SearchPathTest.java","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-package jdk.tools.jaotc.test.collect;\n-\n-import java.io.File;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-public class Utils {\n-    @SafeVarargs\n-    public static <T> Set<T> set(T... entries) {\n-        Set<T> set = new HashSet<>();\n-        for (T entry : entries) {\n-            set.add(entry);\n-        }\n-        return set;\n-    }\n-\n-    public static String mkpath(String path) {\n-        return getpath(path).toString();\n-    }\n-\n-    public static Set<String> mkpaths(String... paths) {\n-        Set<String> set = new HashSet<>();\n-        for (String entry : paths) {\n-            set.add(mkpath(entry));\n-        }\n-        return set;\n-    }\n-\n-    public static Path getpath(String path) {\n-        if (path.startsWith(\"\/\") && System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n-            return Paths.get(new File(path).getAbsolutePath());\n-        } else {\n-            return Paths.get(path);\n-        }\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.test\/src\/jdk\/tools\/jaotc\/test\/collect\/Utils.java","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @requires vm.aot\n- * @modules jdk.aot\/jdk.tools.jaotc\n- *          jdk.aot\/jdk.tools.jaotc.collect\n- *          jdk.aot\/jdk.tools.jaotc.collect.directory\n- * @compile ..\/Utils.java\n- * @compile ..\/FakeFileSupport.java\n- * @run junit\/othervm jdk.tools.jaotc.test.collect.directory.DirectorySourceProviderTest\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.test.collect.directory;\n-\n-import jdk.tools.jaotc.collect.ClassSource;\n-import jdk.tools.jaotc.collect.directory.DirectorySourceProvider;\n-import jdk.tools.jaotc.test.collect.FakeFileSupport;\n-import jdk.tools.jaotc.collect.FileSupport;\n-import org.junit.Assert;\n-import org.junit.Test;\n-\n-import java.net.MalformedURLException;\n-import java.nio.file.Path;\n-import java.util.Set;\n-\n-import static jdk.tools.jaotc.test.collect.Utils.set;\n-\n-public class DirectorySourceProviderTest {\n-    @Test\n-    public void itShouldReturnNullForNonExistantPath() {\n-        DirectorySourceProvider target = new DirectorySourceProvider(new FakeFileSupport(set(), set()));\n-        ClassSource result = target.findSource(\"hello\", null);\n-        Assert.assertNull(result);\n-    }\n-\n-    @Test\n-    public void itShouldReturnNullForNonDirectory() {\n-        DirectorySourceProvider target = new DirectorySourceProvider(new FakeFileSupport(set(\"foobar\"), set()));\n-        ClassSource result = target.findSource(\"foobar\", null);\n-        Assert.assertNull(result);\n-    }\n-\n-    @Test\n-    public void itShouldReturnNullForMalformedURI() {\n-        Set<String> visited = set();\n-        DirectorySourceProvider target = new DirectorySourceProvider(new FakeFileSupport(set(\"foobar\"), set(\"foobar\")) {\n-            @Override\n-            public ClassLoader createClassLoader(Path path) throws MalformedURLException {\n-                visited.add(\"1\");\n-                throw new MalformedURLException(\"...\");\n-            }\n-        });\n-        ClassSource result = target.findSource(\"foobar\", null);\n-        Assert.assertNull(result);\n-        Assert.assertEquals(set(\"1\"), visited);\n-    }\n-\n-    @Test\n-    public void itShouldCreateSourceIfNameExistsAndIsADirectory() {\n-        FileSupport fileSupport = new FakeFileSupport(set(\"foo\"), set(\"foo\"));\n-        DirectorySourceProvider target = new DirectorySourceProvider(fileSupport);\n-        ClassSource foo = target.findSource(\"foo\", null);\n-        Assert.assertNotNull(foo);\n-        Assert.assertEquals(\"directory:foo\", foo.toString());\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.test\/src\/jdk\/tools\/jaotc\/test\/collect\/directory\/DirectorySourceProviderTest.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -1,127 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @requires vm.aot\n- * @modules jdk.aot\/jdk.tools.jaotc\n- *          jdk.aot\/jdk.tools.jaotc.collect\n- *          jdk.aot\/jdk.tools.jaotc.collect.jar\n- * @compile ..\/Utils.java\n- * @compile ..\/FakeFileSupport.java\n- * @compile ..\/FakeSearchPath.java\n- *\n- * @run junit\/othervm jdk.tools.jaotc.test.collect.jar.JarSourceProviderTest\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.test.collect.jar;\n-\n-import static jdk.tools.jaotc.test.collect.Utils.mkpath;\n-import static jdk.tools.jaotc.test.collect.Utils.set;\n-\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.ProviderNotFoundException;\n-\n-import org.junit.Assert;\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-import jdk.tools.jaotc.collect.ClassSource;\n-import jdk.tools.jaotc.collect.jar.JarSourceProvider;\n-import jdk.tools.jaotc.test.collect.FakeFileSupport;\n-import jdk.tools.jaotc.test.collect.FakeSearchPath;\n-\n-public class JarSourceProviderTest {\n-\n-    private FakeFileSupport fileSupport;\n-    private JarSourceProvider target;\n-\n-    @Before\n-    public void setUp() throws Exception {\n-        fileSupport = new FakeFileSupport(set(), set());\n-        target = new JarSourceProvider(fileSupport);\n-    }\n-\n-    @Test\n-    public void itShouldUseSearchPathToFindPath() {\n-        FakeSearchPath searchPath = new FakeSearchPath(null);\n-        target.findSource(\"hello\", searchPath);\n-\n-        Assert.assertEquals(set(\"hello\"), searchPath.entries);\n-    }\n-\n-    @Test\n-    public void itShouldReturnNullIfPathIsNull() {\n-        ClassSource source = target.findSource(\"foobar\", new FakeSearchPath(null));\n-        Assert.assertNull(source);\n-    }\n-\n-    @Test\n-    public void itShouldReturnNullIfPathIsDirectory() {\n-        fileSupport.addDirectory(\"hello\/foobar\");\n-        ClassSource source = target.findSource(\"foobar\", new FakeSearchPath(\"hello\/foobar\"));\n-\n-        Assert.assertNull(source);\n-        Assert.assertEquals(set(mkpath(\"hello\/foobar\")), fileSupport.getCheckedDirectory());\n-    }\n-\n-    @Test\n-    public void itShouldReturnNullIfUnableToMakeJarFileSystem() {\n-        fileSupport.setJarFileSystemRoot(null);\n-        ClassSource result = target.findSource(\"foobar\", new FakeSearchPath(\"foo\/bar\"));\n-\n-        Assert.assertEquals(set(mkpath(\"foo\/bar\")), fileSupport.getCheckedJarFileSystemRoots());\n-        Assert.assertNull(result);\n-    }\n-\n-    @Test\n-    public void itShouldReturnNullIfNotValidJarProvider() {\n-        fileSupport = new FakeFileSupport(set(), set()) {\n-\n-            @Override\n-            public Path getJarFileSystemRoot(Path jarFile) {\n-                super.getJarFileSystemRoot(jarFile);\n-                throw new ProviderNotFoundException();\n-            }\n-        };\n-        fileSupport.setJarFileSystemRoot(null);\n-        target = new JarSourceProvider(fileSupport);\n-\n-        ClassSource result = target.findSource(\"foobar\", new FakeSearchPath(\"foo\/bar\"));\n-\n-        Assert.assertEquals(set(mkpath(\"foo\/bar\")), fileSupport.getCheckedJarFileSystemRoots());\n-        Assert.assertNull(result);\n-    }\n-\n-    @Test\n-    public void itShouldReturnSourceWhenAllIsValid() {\n-        fileSupport.setJarFileSystemRoot(Paths.get(\"some\/bar\"));\n-        ClassSource result = target.findSource(\"foobar\", new FakeSearchPath(\"this\/bar\"));\n-\n-        Assert.assertEquals(set(mkpath(\"this\/bar\")), fileSupport.getClassloaderPaths());\n-        Assert.assertEquals(\"jar:\" + mkpath(\"this\/bar\"), result.toString());\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.test\/src\/jdk\/tools\/jaotc\/test\/collect\/jar\/JarSourceProviderTest.java","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @requires vm.aot\n- * @modules jdk.aot\/jdk.tools.jaotc\n- *          jdk.aot\/jdk.tools.jaotc.collect\n- *          jdk.aot\/jdk.tools.jaotc.collect.module\n- * @compile ..\/Utils.java\n- * @run junit\/othervm jdk.tools.jaotc.test.collect.module.ModuleSourceProviderTest\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.test.collect.module;\n-\n-import static jdk.tools.jaotc.test.collect.Utils.mkpath;\n-import static org.junit.Assert.assertEquals;\n-\n-import java.io.IOException;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.function.BiFunction;\n-\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-import jdk.tools.jaotc.collect.FileSupport;\n-import jdk.tools.jaotc.collect.module.ModuleSource;\n-import jdk.tools.jaotc.collect.module.ModuleSourceProvider;\n-\n-public class ModuleSourceProviderTest {\n-    private ClassLoader classLoader;\n-    private ModuleSourceProvider target;\n-    private FileSupport fileSupport;\n-    private BiFunction<Path, Path, Path> getSubDirectory = null;\n-\n-    @Before\n-    public void setUp() {\n-        classLoader = new FakeClassLoader();\n-        fileSupport = new FileSupport() {\n-\n-            @Override\n-            public boolean isDirectory(Path path) {\n-                return true;\n-            }\n-\n-            @Override\n-            public Path getSubDirectory(FileSystem fileSystem, Path root, Path path) throws IOException {\n-                if (getSubDirectory == null) {\n-                    throw new IOException(\"Nope\");\n-                }\n-                return getSubDirectory.apply(root, path);\n-            }\n-        };\n-        target = new ModuleSourceProvider(FileSystems.getDefault(), classLoader, fileSupport);\n-    }\n-\n-    @Test\n-    public void itShouldUseFileSupport() {\n-        getSubDirectory = (root, path) -> {\n-            if (root.toString().equals(\"modules\") && path.toString().equals(\"test.module\")) {\n-                return Paths.get(\"modules\/test.module\");\n-            }\n-            return null;\n-        };\n-\n-        ModuleSource source = (ModuleSource) target.findSource(\"test.module\", null);\n-        assertEquals(mkpath(\"modules\/test.module\"), source.getModulePath().toString());\n-        assertEquals(\"module:\" + mkpath(\"modules\/test.module\"), source.toString());\n-    }\n-\n-    private static class FakeClassLoader extends ClassLoader {\n-        @Override\n-        public Class<?> loadClass(String name) throws ClassNotFoundException {\n-            return null;\n-        }\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.test\/src\/jdk\/tools\/jaotc\/test\/collect\/module\/ModuleSourceProviderTest.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -1,176 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import java.util.ListIterator;\n-\n-import org.graalvm.compiler.code.CompilationResult;\n-import org.graalvm.compiler.core.GraalCompiler;\n-import org.graalvm.compiler.core.common.CompilationIdentifier;\n-import org.graalvm.compiler.debug.DebugContext;\n-import org.graalvm.compiler.hotspot.HotSpotBackend;\n-import org.graalvm.compiler.hotspot.HotSpotCompiledCodeBuilder;\n-import org.graalvm.compiler.hotspot.meta.HotSpotInvokeDynamicPlugin;\n-import org.graalvm.compiler.hotspot.meta.HotSpotProviders;\n-import org.graalvm.compiler.java.GraphBuilderPhase;\n-import org.graalvm.compiler.lir.asm.CompilationResultBuilderFactory;\n-import org.graalvm.compiler.lir.phases.LIRSuites;\n-import org.graalvm.compiler.nodes.StructuredGraph;\n-import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;\n-import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;\n-import org.graalvm.compiler.options.OptionValues;\n-import org.graalvm.compiler.phases.BasePhase;\n-import org.graalvm.compiler.phases.OptimisticOptimizations;\n-import org.graalvm.compiler.phases.PhaseSuite;\n-import org.graalvm.compiler.phases.tiers.HighTierContext;\n-import org.graalvm.compiler.phases.tiers.Suites;\n-\n-import jdk.vm.ci.code.InstalledCode;\n-import jdk.vm.ci.hotspot.HotSpotCodeCacheProvider;\n-import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;\n-import jdk.vm.ci.meta.DefaultProfilingInfo;\n-import jdk.vm.ci.meta.ProfilingInfo;\n-import jdk.vm.ci.meta.ResolvedJavaMethod;\n-import jdk.vm.ci.meta.TriState;\n-\n-final class AOTBackend {\n-    private final Main main;\n-    private final OptionValues graalOptions;\n-    private final HotSpotBackend backend;\n-    private final HotSpotProviders providers;\n-    private final HotSpotCodeCacheProvider codeCache;\n-    private final PhaseSuite<HighTierContext> graphBuilderSuite;\n-    private final HighTierContext highTierContext;\n-\n-    AOTBackend(Main main, OptionValues graalOptions, HotSpotBackend backend, HotSpotInvokeDynamicPlugin inokeDynamicPlugin) {\n-        this.main = main;\n-        this.graalOptions = graalOptions;\n-        this.backend = backend;\n-        providers = backend.getProviders();\n-        codeCache = providers.getCodeCache();\n-        graphBuilderSuite = initGraphBuilderSuite(backend, main.options.compileWithAssertions, inokeDynamicPlugin);\n-        highTierContext = new HighTierContext(providers, graphBuilderSuite, OptimisticOptimizations.ALL);\n-    }\n-\n-    PhaseSuite<HighTierContext> getGraphBuilderSuite() {\n-        return graphBuilderSuite;\n-    }\n-\n-    HotSpotBackend getBackend() {\n-        return backend;\n-    }\n-\n-    HotSpotProviders getProviders() {\n-        return providers;\n-    }\n-\n-    private Suites getSuites() {\n-        \/\/ create suites every time, as we modify options for the compiler\n-        return backend.getSuites().getDefaultSuites(graalOptions);\n-    }\n-\n-    private LIRSuites getLirSuites() {\n-        \/\/ create suites every time, as we modify options for the compiler\n-        return backend.getSuites().getDefaultLIRSuites(graalOptions);\n-    }\n-\n-    @SuppressWarnings(\"try\")\n-    CompilationResult compileMethod(ResolvedJavaMethod resolvedMethod, DebugContext debug) {\n-        StructuredGraph graph = buildStructuredGraph(resolvedMethod, debug);\n-        if (graph != null) {\n-            return compileGraph(resolvedMethod, graph, debug);\n-        }\n-        return null;\n-    }\n-\n-    \/**\n-     * Build a structured graph for the member.\n-     *\n-     * @param javaMethod method for whose code the graph is to be created\n-     * @param debug\n-     * @return structured graph\n-     *\/\n-    @SuppressWarnings(\"try\")\n-    private StructuredGraph buildStructuredGraph(ResolvedJavaMethod javaMethod, DebugContext debug) {\n-        try (DebugContext.Scope s = debug.scope(\"AOTParseMethod\")) {\n-            StructuredGraph graph = new StructuredGraph.Builder(graalOptions, debug).method(javaMethod).useProfilingInfo(false).build();\n-            graphBuilderSuite.apply(graph, highTierContext);\n-            return graph;\n-        } catch (Throwable e) {\n-            main.handleError(javaMethod, e, \" (building graph)\");\n-        }\n-        return null;\n-    }\n-\n-    @SuppressWarnings(\"try\")\n-    private CompilationResult compileGraph(ResolvedJavaMethod resolvedMethod, StructuredGraph graph, DebugContext debug) {\n-        try (DebugContext.Scope s = debug.scope(\"AOTCompileMethod\")) {\n-            ProfilingInfo profilingInfo = DefaultProfilingInfo.get(TriState.FALSE);\n-\n-            final boolean isImmutablePIC = true;\n-            CompilationIdentifier id = new CompilationIdentifier() {\n-                @Override\n-                public String toString(Verbosity verbosity) {\n-                    return resolvedMethod.getName();\n-                }\n-            };\n-            CompilationResult compilationResult = new CompilationResult(id, isImmutablePIC);\n-\n-            return GraalCompiler.compileGraph(graph, resolvedMethod, providers, backend, graphBuilderSuite, OptimisticOptimizations.ALL, profilingInfo, getSuites(), getLirSuites(),\n-                            compilationResult, CompilationResultBuilderFactory.Default, true);\n-\n-        } catch (Throwable e) {\n-            main.handleError(resolvedMethod, e, \" (compiling graph)\");\n-        }\n-        return null;\n-    }\n-\n-    private static PhaseSuite<HighTierContext> initGraphBuilderSuite(HotSpotBackend backend, boolean compileWithAssertions, HotSpotInvokeDynamicPlugin inokeDynamicPlugin) {\n-        PhaseSuite<HighTierContext> graphBuilderSuite = backend.getSuites().getDefaultGraphBuilderSuite().copy();\n-        ListIterator<BasePhase<? super HighTierContext>> iterator = graphBuilderSuite.findPhase(GraphBuilderPhase.class);\n-        GraphBuilderConfiguration baseConfig = ((GraphBuilderPhase) iterator.previous()).getGraphBuilderConfig();\n-\n-        \/\/ Use all default plugins.\n-        Plugins plugins = baseConfig.getPlugins();\n-        plugins.setInvokeDynamicPlugin(inokeDynamicPlugin);\n-        GraphBuilderConfiguration aotConfig = GraphBuilderConfiguration.getDefault(plugins).withEagerResolving(true).withOmitAssertions(!compileWithAssertions);\n-\n-        iterator.next();\n-        iterator.remove();\n-        iterator.add(new GraphBuilderPhase(aotConfig));\n-\n-        return graphBuilderSuite;\n-    }\n-\n-    void printCompiledMethod(HotSpotResolvedJavaMethod resolvedMethod, CompilationResult compResult) {\n-        \/\/ This is really not installing the method.\n-        InstalledCode installedCode = codeCache.addCode(resolvedMethod, HotSpotCompiledCodeBuilder.createCompiledCode(codeCache, resolvedMethod, null, compResult, graalOptions), null, null);\n-        String disassembly = codeCache.disassemble(installedCode);\n-        if (disassembly != null) {\n-            main.printer.printlnDebug(disassembly);\n-        }\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/AOTBackend.java","additions":0,"deletions":176,"binary":false,"changes":176,"status":"deleted"},{"patch":"@@ -1,211 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;\n-import org.graalvm.compiler.code.CompilationResult;\n-import org.graalvm.compiler.core.GraalCompilerOptions;\n-import org.graalvm.compiler.debug.DebugContext;\n-import org.graalvm.compiler.debug.DebugContext.Activation;\n-import org.graalvm.compiler.debug.DebugContext.Builder;\n-import org.graalvm.compiler.debug.TTY;\n-import org.graalvm.compiler.options.OptionValues;\n-import org.graalvm.compiler.printer.GraalDebugHandlersFactory;\n-import org.graalvm.compiler.serviceprovider.GraalServices;\n-\n-import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;\n-import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;\n-import jdk.vm.ci.meta.ResolvedJavaMethod;\n-import jdk.vm.ci.runtime.JVMCICompiler;\n-\n-\/**\n- * Represents a task in the compile queue.\n- *\n- * This class encapsulates all Graal-specific information that is used during offline AOT\n- * compilation of classes. It also defines methods that parse compilation result of Graal to create\n- * target-independent representation {@code BinaryContainer} of the intended target binary.\n- *\/\n-final class AOTCompilationTask implements Runnable, Comparable<Object> {\n-\n-    private static final AtomicInteger ids = new AtomicInteger();\n-\n-    private final Main main;\n-\n-    private OptionValues graalOptions;\n-\n-    \/**\n-     * The compilation id of this task.\n-     *\/\n-    private final int id;\n-\n-    private final AOTCompiledClass holder;\n-\n-    \/**\n-     * Method this task represents.\n-     *\/\n-    private final ResolvedJavaMethod method;\n-\n-    private final AOTBackend aotBackend;\n-\n-    \/**\n-     * The result of this compilation task.\n-     *\/\n-    private CompiledMethodInfo result;\n-\n-    AOTCompilationTask(Main main, OptionValues graalOptions, AOTCompiledClass holder, ResolvedJavaMethod method, AOTBackend aotBackend) {\n-        this.main = main;\n-        this.graalOptions = graalOptions;\n-        this.id = ids.incrementAndGet();\n-        this.holder = holder;\n-        this.method = method;\n-        this.aotBackend = aotBackend;\n-    }\n-\n-    \/**\n-     * Compile a method or a constructor.\n-     *\/\n-    @Override\n-    @SuppressWarnings(\"try\")\n-    public void run() {\n-        \/\/ Ensure a JVMCI runtime is initialized prior to Debug being initialized as the former\n-        \/\/ may include processing command line options used by the latter.\n-        HotSpotJVMCIRuntime.runtime();\n-\n-        AOTCompiler.logCompilation(JavaMethodInfo.uniqueMethodName(method), \"Compiling\");\n-\n-        final long threadId = Thread.currentThread().getId();\n-\n-        final boolean printCompilation = GraalCompilerOptions.PrintCompilation.getValue(graalOptions) && !TTY.isSuppressed() && GraalServices.isThreadAllocatedMemorySupported();\n-        if (printCompilation) {\n-            TTY.println(getMethodDescription() + \"...\");\n-        }\n-\n-        final long start;\n-        final long allocatedBytesBefore;\n-        if (printCompilation) {\n-            start = System.currentTimeMillis();\n-            allocatedBytesBefore = GraalServices.getThreadAllocatedBytes(threadId);\n-        } else {\n-            start = 0L;\n-            allocatedBytesBefore = 0L;\n-        }\n-\n-        CompilationResult compResult = null;\n-        final long startTime = System.currentTimeMillis();\n-        SnippetReflectionProvider snippetReflection = aotBackend.getProviders().getSnippetReflection();\n-        try (DebugContext debug = new Builder(graalOptions, new GraalDebugHandlersFactory(snippetReflection)).build(); Activation a = debug.activate()) {\n-            compResult = aotBackend.compileMethod(method, debug);\n-        }\n-        final long endTime = System.currentTimeMillis();\n-\n-        if (printCompilation) {\n-            final long stop = System.currentTimeMillis();\n-            final int targetCodeSize = compResult != null ? compResult.getTargetCodeSize() : -1;\n-            final long allocatedBytesAfter = GraalServices.getThreadAllocatedBytes(threadId);\n-            final long allocatedBytes = (allocatedBytesAfter - allocatedBytesBefore) \/ 1024;\n-\n-            TTY.println(getMethodDescription() + String.format(\" | %4dms %5dB %5dkB\", stop - start, targetCodeSize, allocatedBytes));\n-        }\n-\n-        if (compResult == null) {\n-            result = null;\n-            return;\n-        }\n-\n-        \/\/ For now precision to the nearest second is sufficient.\n-        LogPrinter.writeLog(\"    Compile Time: \" + TimeUnit.MILLISECONDS.toSeconds(endTime - startTime) + \"secs\");\n-        if (main.options.debug) {\n-            aotBackend.printCompiledMethod((HotSpotResolvedJavaMethod) method, compResult);\n-        }\n-\n-        result = new CompiledMethodInfo(compResult, new AOTHotSpotResolvedJavaMethod((HotSpotResolvedJavaMethod) method, aotBackend.getBackend(), graalOptions));\n-    }\n-\n-    private String getMethodDescription() {\n-        return String.format(\"%-6d aot %s %s\", getId(), JavaMethodInfo.uniqueMethodName(method),\n-                        getEntryBCI() == JVMCICompiler.INVOCATION_ENTRY_BCI ? \"\" : \"(OSR@\" + getEntryBCI() + \") \");\n-    }\n-\n-    private int getId() {\n-        return id;\n-    }\n-\n-    private static int getEntryBCI() {\n-        return JVMCICompiler.INVOCATION_ENTRY_BCI;\n-    }\n-\n-    ResolvedJavaMethod getMethod() {\n-        return method;\n-    }\n-\n-    \/**\n-     * Returns the holder of this method as a {@link AOTCompiledClass}.\n-     *\n-     * @return the holder of this method\n-     *\/\n-    AOTCompiledClass getHolder() {\n-        return holder;\n-    }\n-\n-    \/**\n-     * Returns the result of this compilation task.\n-     *\n-     * @return result of this compilation task\n-     *\/\n-    CompiledMethodInfo getResult() {\n-        return result;\n-    }\n-\n-    @Override\n-    public int compareTo(Object obj) {\n-        AOTCompilationTask other = (AOTCompilationTask) obj;\n-        return this.id - other.id;\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (this == obj) {\n-            return true;\n-        }\n-        if (obj == null) {\n-            return false;\n-        }\n-        if (getClass() != obj.getClass()) {\n-            return false;\n-        }\n-        AOTCompilationTask other = (AOTCompilationTask) obj;\n-        return (this.id == other.id);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return 31 + id;\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/AOTCompilationTask.java","additions":0,"deletions":211,"binary":false,"changes":211,"status":"deleted"},{"patch":"@@ -1,471 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Set;\n-\n-import jdk.tools.jaotc.AOTDynamicTypeStore.AdapterLocation;\n-import jdk.tools.jaotc.AOTDynamicTypeStore.AppendixLocation;\n-import jdk.tools.jaotc.AOTDynamicTypeStore.Location;\n-import jdk.tools.jaotc.binformat.BinaryContainer;\n-import jdk.tools.jaotc.binformat.ReadOnlyDataContainer;\n-import jdk.tools.jaotc.binformat.Symbol.Binding;\n-import jdk.tools.jaotc.binformat.Symbol.Kind;\n-import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;\n-import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;\n-import jdk.vm.ci.meta.ResolvedJavaField;\n-import jdk.vm.ci.meta.ResolvedJavaMethod;\n-import jdk.vm.ci.meta.ResolvedJavaType;\n-\n-\/**\n- * Class encapsulating Graal-compiled output of a Java class. The compilation result of all methods\n- * of a class {@code className} are maintained in an array list.\n- *\/\n-final class AOTCompiledClass {\n-\n-    private static AOTDynamicTypeStore dynoStore;\n-\n-    static void setDynamicTypeStore(AOTDynamicTypeStore s) {\n-        dynoStore = s;\n-    }\n-\n-    static class AOTKlassData {\n-        private int gotIndex; \/\/ Index (offset\/8) to the got in the .metaspace.got section\n-        private int classId;  \/\/ Unique ID\n-        \/\/ Offset to compiled methods data in the .methods.offsets section.\n-        private int compiledMethodsOffset;\n-        \/\/ Offset to dependent methods data.\n-        private int dependentMethodsOffset;\n-\n-        private final String metadataName;\n-        HotSpotResolvedObjectType type;\n-\n-        \/**\n-         * List of dependent compiled methods which have a reference to this class.\n-         *\/\n-        private ArrayList<CompiledMethodInfo> dependentMethods;\n-\n-        AOTKlassData(BinaryContainer binaryContainer, HotSpotResolvedObjectType type, int classId) {\n-            this.dependentMethods = new ArrayList<>();\n-            this.classId = classId;\n-            this.type = type;\n-            this.metadataName = type.isAnonymous() ? \"anon<\" + classId + \">\" : type.getName();\n-            this.gotIndex = binaryContainer.addTwoSlotKlassSymbol(metadataName);\n-            this.compiledMethodsOffset = -1; \/\/ Not compiled classes do not have compiled methods.\n-            this.dependentMethodsOffset = -1;\n-        }\n-\n-        private String[] getMetaspaceNames() {\n-            String name = metadataName;\n-            Set<Location> locs = dynoStore.getDynamicClassLocationsForType(type);\n-            if (locs == null) {\n-                return new String[]{name};\n-            } else {\n-                ArrayList<String> names = new ArrayList<>();\n-                names.add(name);\n-                for (Location l : locs) {\n-                    HotSpotResolvedObjectType cpType = l.getHolder();\n-                    AOTKlassData data = getAOTKlassData(cpType);\n-                    \/\/ We collect dynamic types at parse time, but late inlining\n-                    \/\/ may record types that don't make it into the final graph.\n-                    \/\/ We can safely ignore those here.\n-                    if (data == null) {\n-                        \/\/ Not a compiled or inlined method\n-                        continue;\n-                    }\n-                    int cpi = l.getCpi();\n-                    String location = \"<\" + data.classId + \":\" + cpi + \">\";\n-                    if (l instanceof AdapterLocation) {\n-                        names.add(\"adapter\" + location);\n-                        AdapterLocation a = (AdapterLocation) l;\n-                        names.add(\"adapter:\" + a.getMethodId() + location);\n-                    } else {\n-                        assert l instanceof AppendixLocation;\n-                        names.add(\"appendix\" + location);\n-                    }\n-                }\n-                return names.toArray(new String[names.size()]);\n-            }\n-        }\n-\n-        HotSpotResolvedObjectType getType() {\n-            return type;\n-        }\n-\n-        String getMetadataName() {\n-            return metadataName;\n-        }\n-\n-        \/**\n-         * Add a method to the list of dependent methods.\n-         *\/\n-        synchronized boolean addDependentMethod(CompiledMethodInfo cm) {\n-            return dependentMethods.add(cm);\n-        }\n-\n-        \/**\n-         * Return the array list of dependent class methods.\n-         *\n-         * @return array list of dependent methods\n-         *\/\n-        ArrayList<CompiledMethodInfo> getDependentMethods() {\n-            return dependentMethods;\n-        }\n-\n-        \/**\n-         * Returns if this class has dependent methods.\n-         *\n-         * @return true if dependent methods exist, false otherwise\n-         *\/\n-        boolean hasDependentMethods() {\n-            return !dependentMethods.isEmpty();\n-        }\n-\n-        void setCompiledMethodsOffset(int offset) {\n-            compiledMethodsOffset = offset;\n-        }\n-\n-        protected void putAOTKlassData(BinaryContainer binaryContainer, ReadOnlyDataContainer container) {\n-            int cntDepMethods = dependentMethods.size();\n-            \/\/ Create array of dependent methods IDs. First word is count.\n-            ReadOnlyDataContainer dependenciesContainer = binaryContainer.getKlassesDependenciesContainer();\n-            this.dependentMethodsOffset = BinaryContainer.addMethodsCount(cntDepMethods, dependenciesContainer);\n-            for (CompiledMethodInfo methodInfo : dependentMethods) {\n-                dependenciesContainer.appendInt(methodInfo.getCodeId());\n-            }\n-\n-            verify();\n-\n-            \/\/ @formatter:off\n-            \/*\n-             * The offsets layout should match AOTKlassData structure in AOT JVM runtime\n-             *\/\n-            int offset = container.getByteStreamSize();\n-            for (String name : getMetaspaceNames()) {\n-                container.createSymbol(offset, Kind.OBJECT, Binding.GLOBAL, 0, name);\n-            }\n-                      \/\/ Add index (offset\/8) to the got in the .metaspace.got section\n-            container.appendInt(gotIndex).\n-                      \/\/ Add unique ID\n-                      appendInt(classId).\n-                      \/\/ Add the offset to compiled methods data in the .metaspace.offsets section.\n-                      appendInt(compiledMethodsOffset).\n-                      \/\/ Add the offset to dependent methods data in the .metaspace.offsets section.\n-                      appendInt(dependentMethodsOffset).\n-                      \/\/ Add fingerprint.\n-                      appendLong(type.getFingerprint());\n-\n-            \/\/ @formatter:on\n-        }\n-\n-        private void verify() {\n-            String name = type.getName();\n-            assert gotIndex > 0 : \"incorrect gotIndex: \" + gotIndex + \" for klass: \" + name;\n-            long fingerprint = type.getFingerprint();\n-            assert type.isArray() || fingerprint != 0 : \"incorrect fingerprint: \" + fingerprint + \" for klass: \" + name;\n-            assert compiledMethodsOffset >= -1 : \"incorrect compiledMethodsOffset: \" + compiledMethodsOffset + \" for klass: \" + name;\n-            assert dependentMethodsOffset >= -1 : \"incorrect dependentMethodsOffset: \" + dependentMethodsOffset + \" for klass: \" + name;\n-            assert classId >= 0 : \"incorrect classId: \" + classId + \" for klass: \" + name;\n-        }\n-\n-    }\n-\n-    private final HotSpotResolvedObjectType resolvedJavaType;\n-\n-    \/**\n-     * List of all collected class data.\n-     *\/\n-    private static HashMap<String, AOTKlassData> klassData = new HashMap<>();\n-\n-    \/**\n-     * List of all methods to be compiled.\n-     *\/\n-    private ArrayList<ResolvedJavaMethod> methods = new ArrayList<>();\n-\n-    \/**\n-     * List of all compiled class methods.\n-     *\/\n-    private ArrayList<CompiledMethodInfo> compiledMethods;\n-\n-    \/**\n-     * If this class represents Graal stub code.\n-     *\/\n-    private final boolean representsStubs;\n-\n-    \/**\n-     * Classes count used to generate unique global method id.\n-     *\/\n-    private static int classesCount = 0;\n-\n-    \/**\n-     * Construct an object with compiled methods. Intended to be used for code with no corresponding\n-     * Java method name in the user application.\n-     *\n-     * @param compiledMethods AOT compiled methods\n-     *\/\n-    AOTCompiledClass(ArrayList<CompiledMethodInfo> compiledMethods) {\n-        this.resolvedJavaType = null;\n-        this.compiledMethods = compiledMethods;\n-        this.representsStubs = true;\n-    }\n-\n-    \/**\n-     * Construct an object with compiled versions of the named class.\n-     *\/\n-    AOTCompiledClass(ResolvedJavaType resolvedJavaType) {\n-        this.resolvedJavaType = (HotSpotResolvedObjectType) resolvedJavaType;\n-        this.compiledMethods = new ArrayList<>();\n-        this.representsStubs = false;\n-    }\n-\n-    \/**\n-     * @return the ResolvedJavaType of this class\n-     *\/\n-    ResolvedJavaType getResolvedJavaType() {\n-        return resolvedJavaType;\n-    }\n-\n-    \/**\n-     * Get the list of methods which should be compiled.\n-     *\/\n-    ArrayList<ResolvedJavaMethod> getMethods() {\n-        ArrayList<ResolvedJavaMethod> m = methods;\n-        methods = null; \/\/ Free - it is not used after that.\n-        return m;\n-    }\n-\n-    \/**\n-     * Get the number of all AOT classes.\n-     *\/\n-    static int getClassesCount() {\n-        return classesCount;\n-    }\n-\n-    \/**\n-     * Get the number of methods which should be compiled.\n-     *\n-     * @return number of methods which should be compiled\n-     *\/\n-    int getMethodCount() {\n-        return methods.size();\n-    }\n-\n-    \/**\n-     * Add a method to the list of methods to be compiled.\n-     *\/\n-    void addMethod(ResolvedJavaMethod method) {\n-        methods.add(method);\n-    }\n-\n-    \/**\n-     * Returns if this class has methods which should be compiled.\n-     *\n-     * @return true if this class contains methods which should be compiled, false otherwise\n-     *\/\n-    boolean hasMethods() {\n-        return !methods.isEmpty();\n-    }\n-\n-    \/**\n-     * Add a method to the list of compiled methods. This method needs to be thread-safe.\n-     *\/\n-    synchronized boolean addCompiledMethod(CompiledMethodInfo cm) {\n-        return compiledMethods.add(cm);\n-    }\n-\n-    \/**\n-     * Return the array list of compiled class methods.\n-     *\n-     * @return array list of compiled methods\n-     *\/\n-    ArrayList<CompiledMethodInfo> getCompiledMethods() {\n-        return compiledMethods;\n-    }\n-\n-    \/**\n-     * Returns if this class has successfully compiled methods.\n-     *\n-     * @return true if methods were compiled, false otherwise\n-     *\/\n-    boolean hasCompiledMethods() {\n-        return !compiledMethods.isEmpty();\n-    }\n-\n-    \/**\n-     * Add a klass data.\n-     *\/\n-    static synchronized AOTKlassData addAOTKlassData(BinaryContainer binaryContainer, HotSpotResolvedObjectType type) {\n-        AOTKlassData data = getAOTKlassData(type);\n-        if (data == null) {\n-            data = new AOTKlassData(binaryContainer, type, classesCount++);\n-            klassData.put(type.getName(), data);\n-        }\n-        return data;\n-    }\n-\n-    static synchronized AOTKlassData getAOTKlassData(HotSpotResolvedObjectType type) {\n-        String name = type.getName();\n-        AOTKlassData data = klassData.get(name);\n-        if (data != null) {\n-            HotSpotResolvedObjectType oldType = data.getType();\n-            assert oldType.equals(type) : \"duplicate classes for name \" + type.getName();\n-        }\n-        return data;\n-    }\n-\n-    void addAOTKlassData(BinaryContainer binaryContainer) {\n-        for (CompiledMethodInfo methodInfo : compiledMethods) {\n-            \/\/ Record methods holder\n-            methodInfo.addDependentKlassData(binaryContainer, resolvedJavaType);\n-            \/\/ Record inlinee classes\n-            ResolvedJavaMethod[] inlinees = methodInfo.getCompilationResult().getMethods();\n-            if (inlinees != null) {\n-                for (ResolvedJavaMethod m : inlinees) {\n-                    methodInfo.addDependentKlassData(binaryContainer, (HotSpotResolvedObjectType) m.getDeclaringClass());\n-                }\n-            }\n-            \/\/ Record classes of fields that were accessed\n-            ResolvedJavaField[] fields = methodInfo.getCompilationResult().getFields();\n-            if (fields != null) {\n-                for (ResolvedJavaField f : fields) {\n-                    methodInfo.addDependentKlassData(binaryContainer, (HotSpotResolvedObjectType) f.getDeclaringClass());\n-                }\n-            }\n-        }\n-    }\n-\n-    static synchronized AOTKlassData addFingerprintKlassData(BinaryContainer binaryContainer, HotSpotResolvedObjectType type) {\n-        if (type.isArray()) {\n-            return addAOTKlassData(binaryContainer, type);\n-        }\n-        assert type.getFingerprint() != 0 : \"no fingerprint for \" + type.getName();\n-        AOTKlassData old = getAOTKlassData(type);\n-        if (old != null) {\n-            if (areAssertionsEnabled()) {\n-                HotSpotResolvedObjectType s = type.getSuperclass();\n-                if (s != null) {\n-                    assert getAOTKlassData(s) != null : \"fingerprint for super \" + s.getName() + \" needed for \" + type.getName();\n-                }\n-                for (HotSpotResolvedObjectType i : type.getInterfaces()) {\n-                    assert getAOTKlassData(i) != null : \"fingerprint for interface \" + i.getName() + \" needed for \" + type.getName();\n-                }\n-            }\n-            return old;\n-        }\n-\n-        \/\/ Fingerprinting requires super classes and super interfaces\n-        HotSpotResolvedObjectType s = type.getSuperclass();\n-        if (s != null) {\n-            addFingerprintKlassData(binaryContainer, s);\n-        }\n-        for (HotSpotResolvedObjectType i : type.getInterfaces()) {\n-            addFingerprintKlassData(binaryContainer, i);\n-        }\n-\n-        return addAOTKlassData(binaryContainer, type);\n-    }\n-\n-    @SuppressWarnings(\"all\")\n-    private static boolean areAssertionsEnabled() {\n-        boolean assertsEnabled = false;\n-        \/\/ Next assignment will be executed when asserts are enabled.\n-        assert assertsEnabled = true;\n-        return assertsEnabled;\n-    }\n-\n-    \/*\n-     * Put methods data to contained.\n-     *\/\n-    void putMethodsData(BinaryContainer binaryContainer) {\n-        ReadOnlyDataContainer container = binaryContainer.getMethodsOffsetsContainer();\n-        int cntMethods = compiledMethods.size();\n-        int startMethods = BinaryContainer.addMethodsCount(cntMethods, container);\n-        for (CompiledMethodInfo methodInfo : compiledMethods) {\n-            methodInfo.addMethodOffsets(binaryContainer, container);\n-        }\n-        String name = resolvedJavaType.getName();\n-        AOTKlassData data = getAOTKlassData(resolvedJavaType);\n-        assert data != null : \"missing data for klass: \" + name;\n-        int cntDepMethods = data.dependentMethods.size();\n-        assert cntDepMethods > 0 : \"no dependent methods for compiled klass: \" + name;\n-        data.setCompiledMethodsOffset(startMethods);\n-    }\n-\n-    static void putAOTKlassData(BinaryContainer binaryContainer) {\n-        \/\/ record dynamic types\n-        Set<HotSpotResolvedObjectType> dynoTypes = dynoStore.getDynamicTypes();\n-        if (dynoTypes != null) {\n-            for (HotSpotResolvedObjectType dynoType : dynoTypes) {\n-                addFingerprintKlassData(binaryContainer, dynoType);\n-            }\n-        }\n-\n-        ReadOnlyDataContainer container = binaryContainer.getKlassesOffsetsContainer();\n-        for (AOTKlassData data : klassData.values()) {\n-            data.putAOTKlassData(binaryContainer, container);\n-        }\n-    }\n-\n-    static HotSpotResolvedObjectType getType(Object ref) {\n-        return (ref instanceof HotSpotResolvedObjectType) ? (HotSpotResolvedObjectType) ref : ((HotSpotResolvedJavaMethod) ref).getDeclaringClass();\n-    }\n-\n-    static String metadataName(HotSpotResolvedObjectType type) {\n-        AOTKlassData data = getAOTKlassData(type);\n-        assert data != null : \"no data for \" + type;\n-        return getAOTKlassData(type).getMetadataName();\n-    }\n-\n-    private static String metadataName(HotSpotResolvedJavaMethod m) {\n-        return metadataName(m.getDeclaringClass()) + \".\" + m.getName() + m.getSignature().toMethodDescriptor();\n-    }\n-\n-    static String metadataName(Object ref) {\n-        if (ref instanceof HotSpotResolvedJavaMethod) {\n-            HotSpotResolvedJavaMethod m = (HotSpotResolvedJavaMethod) ref;\n-            return metadataName(m);\n-        } else {\n-            assert ref instanceof HotSpotResolvedObjectType : \"unexpected object type \" + ref.getClass().getName();\n-            HotSpotResolvedObjectType type = (HotSpotResolvedObjectType) ref;\n-            return metadataName(type);\n-        }\n-    }\n-\n-    boolean representsStubs() {\n-        return representsStubs;\n-    }\n-\n-    void clear() {\n-        for (CompiledMethodInfo c : compiledMethods) {\n-            c.clear();\n-        }\n-        this.compiledMethods = null;\n-        this.methods = null;\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/AOTCompiledClass.java","additions":0,"deletions":471,"binary":false,"changes":471,"status":"deleted"},{"patch":"@@ -1,169 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.concurrent.PriorityBlockingQueue;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.ThreadPoolExecutor;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import org.graalvm.compiler.options.OptionValues;\n-\n-import jdk.vm.ci.meta.ResolvedJavaMethod;\n-\n-final class AOTCompiler {\n-\n-    private final Main main;\n-\n-    private final OptionValues graalOptions;\n-\n-    private CompileQueue compileQueue;\n-\n-    private final AOTBackend backend;\n-\n-    \/**\n-     * Compile queue.\n-     *\/\n-    private class CompileQueue extends ThreadPoolExecutor {\n-\n-        \/**\n-         * Time of the start of this queue.\n-         *\/\n-        private final long startTime;\n-\n-        \/**\n-         * Method counter for successful compilations.\n-         *\/\n-        private final AtomicInteger successfulMethodCount = new AtomicInteger();\n-\n-        \/**\n-         * Method counter for failed compilations.\n-         *\/\n-        private final AtomicInteger failedMethodCount = new AtomicInteger();\n-\n-        \/**\n-         * Create a compile queue with the given number of threads.\n-         *\/\n-        CompileQueue(final int threads) {\n-            super(threads, threads, 0L, TimeUnit.MILLISECONDS, new PriorityBlockingQueue<>());\n-            startTime = System.currentTimeMillis();\n-        }\n-\n-        @Override\n-        protected void afterExecute(Runnable r, Throwable t) {\n-            AOTCompilationTask task = (AOTCompilationTask) r;\n-            if (task.getResult() != null) {\n-                final int count = successfulMethodCount.incrementAndGet();\n-                if (count % 100 == 0) {\n-                    main.printer.printInfo(\".\");\n-                }\n-                CompiledMethodInfo result = task.getResult();\n-                if (result != null) {\n-                    task.getHolder().addCompiledMethod(result);\n-                }\n-            } else {\n-                failedMethodCount.incrementAndGet();\n-                main.printer.printlnVerbose(\"\");\n-                ResolvedJavaMethod method = task.getMethod();\n-                main.printer.printlnVerbose(\" failed \" + method.getName() + method.getSignature().toMethodDescriptor());\n-            }\n-        }\n-\n-        @Override\n-        protected void terminated() {\n-            final long endTime = System.currentTimeMillis();\n-            final int success = successfulMethodCount.get();\n-            final int failed = failedMethodCount.get();\n-            main.printer.printlnInfo(\"\");\n-            main.printer.printlnInfo(success + \" methods compiled, \" + failed + \" methods failed (\" + (endTime - startTime) + \" ms)\");\n-        }\n-\n-    }\n-\n-    \/**\n-     * @param main\n-     * @param graalOptions\n-     * @param aotBackend\n-     * @param threads number of compilation threads\n-     *\/\n-    AOTCompiler(Main main, OptionValues graalOptions, AOTBackend aotBackend, final int threads) {\n-        this.main = main;\n-        this.graalOptions = graalOptions;\n-        this.compileQueue = new CompileQueue(threads);\n-        this.backend = aotBackend;\n-    }\n-\n-    \/**\n-     * Compile all methods in all classes passed.\n-     *\n-     * @param classes a list of class to compile\n-     * @throws InterruptedException\n-     *\/\n-    List<AOTCompiledClass> compileClasses(List<AOTCompiledClass> classes) throws InterruptedException {\n-        main.printer.printlnInfo(\"Compiling with \" + compileQueue.getCorePoolSize() + \" threads\");\n-        main.printer.printInfo(\".\"); \/\/ Compilation progress indication.\n-\n-        for (AOTCompiledClass c : classes) {\n-            for (ResolvedJavaMethod m : c.getMethods()) {\n-                enqueueMethod(c, m);\n-            }\n-        }\n-\n-        \/\/ Shutdown queue and wait for all tasks to complete.\n-        compileQueue.shutdown();\n-        compileQueue.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);\n-\n-        List<AOTCompiledClass> compiledClasses = new ArrayList<>();\n-        for (AOTCompiledClass compiledClass : classes) {\n-            if (compiledClass.hasCompiledMethods()) {\n-                compiledClasses.add(compiledClass);\n-            }\n-        }\n-        return compiledClasses;\n-    }\n-\n-    \/**\n-     * Enqueue a method in the {@link #compileQueue}.\n-     *\n-     * @param method method to be enqueued\n-     *\/\n-    private void enqueueMethod(AOTCompiledClass aotClass, ResolvedJavaMethod method) {\n-        AOTCompilationTask task = new AOTCompilationTask(main, graalOptions, aotClass, method, backend);\n-        try {\n-            compileQueue.execute(task);\n-        } catch (RejectedExecutionException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    static void logCompilation(String methodName, String message) {\n-        LogPrinter.writeLog(message + \" \" + methodName);\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/AOTCompiler.java","additions":0,"deletions":169,"binary":false,"changes":169,"status":"deleted"},{"patch":"@@ -1,172 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-package jdk.tools.jaotc;\n-\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-import org.graalvm.compiler.hotspot.meta.HotSpotInvokeDynamicPlugin.DynamicTypeStore;\n-\n-import jdk.vm.ci.hotspot.HotSpotConstantPool;\n-import jdk.vm.ci.hotspot.HotSpotConstantPoolObject;\n-import jdk.vm.ci.hotspot.HotSpotObjectConstant;\n-import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;\n-import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;\n-import jdk.vm.ci.meta.JavaConstant;\n-\n-final class AOTDynamicTypeStore implements DynamicTypeStore {\n-\n-    public static class Location {\n-        private HotSpotResolvedObjectType holder;\n-        private int cpi;\n-\n-        Location(HotSpotResolvedObjectType holder, int cpi) {\n-            this.holder = holder;\n-            this.cpi = cpi;\n-        }\n-\n-        public HotSpotResolvedObjectType getHolder() {\n-            return holder;\n-        }\n-\n-        public int getCpi() {\n-            return cpi;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return getHolder().getName() + \"@\" + cpi;\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return holder.hashCode() + getClass().hashCode() + cpi;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) {\n-                return true;\n-            }\n-            if (getClass() != o.getClass()) {\n-                return false;\n-            }\n-            Location l = (Location) o;\n-            return cpi == l.cpi && holder.equals(l.holder);\n-        }\n-    }\n-\n-    public static class AdapterLocation extends Location {\n-        private int methodId;\n-\n-        AdapterLocation(HotSpotResolvedObjectType holder, int cpi, int methodId) {\n-            super(holder, cpi);\n-            this.methodId = methodId;\n-        }\n-\n-        public int getMethodId() {\n-            return methodId;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"adapter:\" + methodId + \"@\" + super.toString();\n-        }\n-    }\n-\n-    public static class AppendixLocation extends Location {\n-        AppendixLocation(HotSpotResolvedObjectType holder, int cpi) {\n-            super(holder, cpi);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"appendix@\" + super.toString();\n-        }\n-    }\n-\n-    private HashMap<HotSpotResolvedObjectType, HashSet<Location>> typeMap = new HashMap<>();\n-    private HashMap<HotSpotResolvedObjectType, HashSet<HotSpotResolvedObjectType>> holderMap = new HashMap<>();\n-\n-    public Set<HotSpotResolvedObjectType> getDynamicTypes() {\n-        synchronized (typeMap) {\n-            return typeMap.keySet();\n-        }\n-    }\n-\n-    public Set<HotSpotResolvedObjectType> getDynamicHolders() {\n-        synchronized (holderMap) {\n-            return holderMap.keySet();\n-        }\n-    }\n-\n-    @Override\n-    public void recordAdapter(int opcode, HotSpotResolvedObjectType holder, int index, HotSpotResolvedJavaMethod adapter) {\n-        int cpi = ((HotSpotConstantPool) holder.getConstantPool()).rawIndexToConstantPoolIndex(index, opcode);\n-        int methodId = adapter.methodIdnum();\n-        HotSpotResolvedObjectType adapterType = adapter.getDeclaringClass();\n-        recordDynamicTypeLocation(new AdapterLocation(holder, cpi, methodId), adapterType);\n-    }\n-\n-    @Override\n-    public JavaConstant recordAppendix(int opcode, HotSpotResolvedObjectType holder, int index, JavaConstant appendix) {\n-        int cpi = ((HotSpotConstantPool) holder.getConstantPool()).rawIndexToConstantPoolIndex(index, opcode);\n-        HotSpotResolvedObjectType appendixType = ((HotSpotObjectConstant) appendix).getType();\n-        recordDynamicTypeLocation(new AppendixLocation(holder, cpi), appendixType);\n-        \/\/ Make the constant locatable\n-        return HotSpotConstantPoolObject.forObject(holder, cpi, appendix);\n-    }\n-\n-    private static <T> void recordDynamicMapValue(HashMap<HotSpotResolvedObjectType, HashSet<T>> map, HotSpotResolvedObjectType type, T v) {\n-        synchronized (map) {\n-            HashSet<T> set = map.get(type);\n-            if (set == null) {\n-                set = new HashSet<>();\n-                map.put(type, set);\n-            }\n-            set.add(v);\n-        }\n-    }\n-\n-    private void recordDynamicTypeLocation(Location l, HotSpotResolvedObjectType type) {\n-        recordDynamicMapValue(typeMap, type, l);\n-        HotSpotResolvedObjectType holder = l.getHolder();\n-        recordDynamicMapValue(holderMap, holder, type);\n-    }\n-\n-    public Set<Location> getDynamicClassLocationsForType(HotSpotResolvedObjectType type) {\n-        synchronized (typeMap) {\n-            return typeMap.get(type);\n-        }\n-    }\n-\n-    public Set<HotSpotResolvedObjectType> getDynamicTypesForHolder(HotSpotResolvedObjectType holder) {\n-        synchronized (holderMap) {\n-            return holderMap.get(holder);\n-        }\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/AOTDynamicTypeStore.java","additions":0,"deletions":172,"binary":false,"changes":172,"status":"deleted"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import org.graalvm.compiler.code.CompilationResult;\n-import org.graalvm.compiler.core.target.Backend;\n-import org.graalvm.compiler.hotspot.HotSpotCompiledCodeBuilder;\n-import org.graalvm.compiler.options.OptionValues;\n-\n-import jdk.vm.ci.hotspot.HotSpotCompiledCode;\n-import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;\n-\n-final class AOTHotSpotResolvedJavaMethod implements JavaMethodInfo {\n-\n-    private final HotSpotResolvedJavaMethod method;\n-    private final Backend backend;\n-    private final OptionValues options;\n-\n-    AOTHotSpotResolvedJavaMethod(HotSpotResolvedJavaMethod method, Backend backend, OptionValues options) {\n-        this.method = method;\n-        this.backend = backend;\n-        this.options = options;\n-    }\n-\n-    @Override\n-    public String getSymbolName() {\n-        return JavaMethodInfo.uniqueMethodName(method);\n-    }\n-\n-    @Override\n-    public String getNameAndSignature() {\n-        String className = method.getDeclaringClass().getName();\n-        return className + \".\" + method.getName() + method.getSignature().toMethodDescriptor();\n-    }\n-\n-    @Override\n-    public HotSpotCompiledCode compiledCode(CompilationResult result) {\n-        return HotSpotCompiledCodeBuilder.createCompiledCode(backend.getCodeCache(), method, null, result, options);\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/AOTHotSpotResolvedJavaMethod.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import org.graalvm.compiler.code.CompilationResult;\n-import org.graalvm.compiler.core.target.Backend;\n-import org.graalvm.compiler.hotspot.HotSpotCompiledCodeBuilder;\n-import org.graalvm.compiler.hotspot.stubs.Stub;\n-import org.graalvm.compiler.options.OptionValues;\n-\n-import jdk.vm.ci.hotspot.HotSpotCompiledCode;\n-\n-final class AOTStub implements JavaMethodInfo {\n-\n-    private final Stub stub;\n-    private final Backend backend;\n-    private OptionValues options;\n-\n-    AOTStub(Stub stub, Backend backend, OptionValues options) {\n-        this.stub = stub;\n-        this.backend = backend;\n-        this.options = options;\n-    }\n-\n-    @Override\n-    public String getSymbolName() {\n-        return stub.toString();\n-    }\n-\n-    @Override\n-    public String getNameAndSignature() {\n-        return stub.toString();\n-    }\n-\n-    @Override\n-    public HotSpotCompiledCode compiledCode(CompilationResult result) {\n-        return HotSpotCompiledCodeBuilder.createCompiledCode(backend.getCodeCache(), null, null, result, options);\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/AOTStub.java","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import org.graalvm.compiler.bytecode.Bytecodes;\n-import org.graalvm.compiler.hotspot.HotSpotMarkId;\n-\n-import jdk.vm.ci.code.BytecodePosition;\n-import jdk.vm.ci.code.site.Call;\n-import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;\n-import jdk.vm.ci.meta.ResolvedJavaMethod;\n-\n-final class CallInfo {\n-\n-    static boolean isStaticTarget(Call call) {\n-        return !((HotSpotResolvedJavaMethod) call.target).hasReceiver();\n-    }\n-\n-    private static boolean isStaticOpcode(Call call) {\n-        int opcode = getByteCode(call) & 0xFF;\n-        return opcode == Bytecodes.INVOKESTATIC || opcode == Bytecodes.INVOKEDYNAMIC ||\n-                        opcode == Bytecodes.INVOKEVIRTUAL \/* invokehandle *\/;\n-    }\n-\n-    static boolean isStaticCall(Call call) {\n-        if (isJavaCall(call) && isStaticTarget(call)) {\n-            assert isStaticOpcode(call);\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    static boolean isSpecialCall(Call call) {\n-        if (isJavaCall(call)) {\n-            return ((getByteCode(call) & 0xFF) == Bytecodes.INVOKESPECIAL);\n-        }\n-        return false;\n-    }\n-\n-    private static boolean isInvokeVirtual(Call call) {\n-        if (isJavaCall(call)) {\n-            return ((getByteCode(call) & 0xFF) == Bytecodes.INVOKEVIRTUAL) || ((getByteCode(call) & 0xFF) == Bytecodes.INVOKEINTERFACE);\n-        }\n-        return false;\n-    }\n-\n-    static boolean isVirtualCall(CompiledMethodInfo methodInfo, Call call) {\n-        return isInvokeVirtual(call) && !methodInfo.hasMark(call, HotSpotMarkId.INVOKESPECIAL) && !isStaticTarget(call);\n-    }\n-\n-    static boolean isOptVirtualCall(CompiledMethodInfo methodInfo, Call call) {\n-        return isInvokeVirtual(call) && methodInfo.hasMark(call, HotSpotMarkId.INVOKESPECIAL);\n-    }\n-\n-    private static boolean isJavaCall(Call call) {\n-        \/\/ If there is no associated debug info return false\n-        if (call.debugInfo == null) {\n-            return false;\n-        }\n-        BytecodePosition bcpos = call.debugInfo.getBytecodePosition();\n-        ResolvedJavaMethod method = bcpos.getMethod();\n-        \/\/ If bytecode position indicates a special value (negative value) it is\n-        \/\/ not a normal java call\n-        if (bcpos.getBCI() < 0) {\n-            return false;\n-        }\n-        \/\/ If there is no method associated with the debuginfo, return false\n-        if (method == null) {\n-            return false;\n-        }\n-        assert (method instanceof HotSpotResolvedJavaMethod) : \"Not a resolved Java call\";\n-        return true;\n-    }\n-\n-    private static byte getByteCode(Call call) {\n-        ResolvedJavaMethod m = call.debugInfo.getBytecodePosition().getMethod();\n-        int callPosition = call.debugInfo.getBytecodePosition().getBCI();\n-        byte[] code = m.getCode();\n-        return code[callPosition];\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/CallInfo.java","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import jdk.tools.jaotc.binformat.Relocation.RelocType;\n-\n-\/**\n- * Describes a call site relocation. Contains a name of the callee and a relocation type, describing\n- * which relocation to use at the call site.\n- *\/\n-abstract class CallSiteRelocationInfo {\n-\n-    final String targetSymbol;\n-    final RelocType type;\n-\n-    CallSiteRelocationInfo(String targetSymbol, RelocType type) {\n-        this.targetSymbol = targetSymbol;\n-        this.type = type;\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/CallSiteRelocationInfo.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import jdk.tools.jaotc.binformat.BinaryContainer;\n-import jdk.tools.jaotc.binformat.ByteContainer;\n-import jdk.tools.jaotc.binformat.CodeContainer;\n-import jdk.tools.jaotc.binformat.Relocation;\n-import jdk.tools.jaotc.binformat.Relocation.RelocType;\n-import jdk.tools.jaotc.binformat.Symbol;\n-import jdk.tools.jaotc.binformat.Symbol.Binding;\n-import jdk.tools.jaotc.binformat.Symbol.Kind;\n-\n-\/**\n- * Describes a relocation symbol of a call site. That is, WHERE to do a relocation.\n- *\/\n-abstract class CallSiteRelocationSymbol {\n-\n-    final Symbol symbol;\n-\n-    CallSiteRelocationSymbol(Symbol symbol) {\n-        assert symbol != null;\n-        this.symbol = symbol;\n-    }\n-\n-    protected static Symbol createCodeContainerSymbol(BinaryContainer binaryContainer, String symbolName, int symbolOffset) {\n-        return binaryContainer.getCodeContainer().createSymbol(symbolOffset, Kind.OBJECT, Binding.LOCAL, 0, symbolName);\n-    }\n-\n-    protected static void addCodeContainerRelocation(BinaryContainer binaryContainer, String symbolName, int symbolOffset, int relocationOffset) {\n-        Symbol symbol = createCodeContainerSymbol(binaryContainer, symbolName, symbolOffset);\n-        addExternalGotToPltRelocation(binaryContainer, symbol, relocationOffset);\n-    }\n-\n-    protected static void addExtLinkageGotContainerRelocation(BinaryContainer binaryContainer, String symbolName, int symbolOffset, int relocationOffset) {\n-        ByteContainer container = binaryContainer.getExtLinkageGOTContainer();\n-        Symbol symbol = container.createGotSymbol(symbolOffset, symbolName);\n-        addExternalPltToGotRelocation(binaryContainer, symbol, relocationOffset);\n-    }\n-\n-    \/**\n-     * Add an {@link RelocType#EXTERNAL_GOT_TO_PLT} relocation to the\n-     * {@link BinaryContainer#getExtLinkageGOTContainer()}.\n-     *\/\n-    private static void addExternalGotToPltRelocation(BinaryContainer binaryContainer, Symbol symbol, int relocationOffset) {\n-        ByteContainer container = binaryContainer.getExtLinkageGOTContainer();\n-        Relocation relocation = new Relocation(relocationOffset, RelocType.EXTERNAL_GOT_TO_PLT, 8, container, symbol);\n-        binaryContainer.addRelocation(relocation);\n-    }\n-\n-    \/**\n-     * Add an {@link RelocType#EXTERNAL_PLT_TO_GOT} relocation to the\n-     * {@link BinaryContainer#getCodeContainer()}.\n-     *\/\n-    protected static void addExternalPltToGotRelocation(BinaryContainer binaryContainer, Symbol symbol, int relocationOffset) {\n-        CodeContainer container = binaryContainer.getCodeContainer();\n-        Relocation relocation = new Relocation(relocationOffset, RelocType.EXTERNAL_PLT_TO_GOT, 8, container, symbol);\n-        binaryContainer.addRelocation(relocation);\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/CallSiteRelocationSymbol.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import java.util.List;\n-\n-import org.graalvm.compiler.code.CompilationResult;\n-import org.graalvm.compiler.hotspot.HotSpotMarkId;\n-\n-final class CodeOffsets {\n-    private final int entry;\n-    private final int verifiedEntry;\n-    private final int exceptionHandler;\n-    private final int deoptHandler;\n-    private final int deoptMHHandler;\n-\n-    private CodeOffsets(int entry, int verifiedEntry, int exceptionHandler, int deoptHandler, int deoptMHHandler) {\n-        this.entry = entry;\n-        this.verifiedEntry = verifiedEntry;\n-        this.exceptionHandler = exceptionHandler;\n-        this.deoptHandler = deoptHandler;\n-        this.deoptMHHandler = deoptMHHandler;\n-    }\n-\n-    static CodeOffsets buildFrom(List<CompilationResult.CodeMark> marks) {\n-        int entry = 0;\n-        int verifiedEntry = 0;\n-        int exceptionHandler = -1;\n-        int deoptHandler = -1;\n-        int deoptMHHandler = -1;\n-\n-        for (CompilationResult.CodeMark mark : marks) {\n-            HotSpotMarkId markId = (HotSpotMarkId) mark.id;\n-            switch (markId) {\n-                case UNVERIFIED_ENTRY:\n-                    entry = mark.pcOffset;\n-                    break;\n-                case VERIFIED_ENTRY:\n-                    verifiedEntry = mark.pcOffset;\n-                    break;\n-                case OSR_ENTRY:\n-                    \/\/ Unhandled\n-                    break;\n-                case EXCEPTION_HANDLER_ENTRY:\n-                    exceptionHandler = mark.pcOffset;\n-                    break;\n-                case DEOPT_HANDLER_ENTRY:\n-                    deoptHandler = mark.pcOffset;\n-                    break;\n-                case DEOPT_MH_HANDLER_ENTRY:\n-                    deoptMHHandler = mark.pcOffset;\n-                    break;\n-                default:\n-                    break; \/\/ Ignore others\n-            }\n-        }\n-        return new CodeOffsets(entry, verifiedEntry, exceptionHandler, deoptHandler, deoptMHHandler);\n-    }\n-\n-    int entry() {\n-        return entry;\n-    }\n-\n-    int verifiedEntry() {\n-        return verifiedEntry;\n-    }\n-\n-    int exceptionHandler() {\n-        return exceptionHandler;\n-    }\n-\n-    int deoptHandler() {\n-        return deoptHandler;\n-    }\n-\n-    int deoptMHHandler() {\n-        return deoptMHHandler;\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/CodeOffsets.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -1,149 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import java.util.ArrayList;\n-\n-import org.graalvm.compiler.code.CompilationResult;\n-import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage;\n-import org.graalvm.compiler.options.OptionValues;\n-\n-import jdk.tools.jaotc.binformat.BinaryContainer;\n-import jdk.tools.jaotc.binformat.CodeContainer;\n-import jdk.tools.jaotc.binformat.Symbol;\n-import jdk.vm.ci.amd64.AMD64;\n-import jdk.vm.ci.code.TargetDescription;\n-import jdk.vm.ci.code.site.Call;\n-import jdk.vm.ci.code.site.Infopoint;\n-import jdk.vm.ci.code.site.InfopointReason;\n-import jdk.vm.ci.meta.ResolvedJavaMethod;\n-\n-final class CodeSectionProcessor {\n-\n-    private final OptionValues optionValues;\n-\n-    private final TargetDescription target;\n-\n-    private final BinaryContainer binaryContainer;\n-\n-    CodeSectionProcessor(DataBuilder dataBuilder) {\n-        this.target = dataBuilder.getBackend().getTarget();\n-        this.binaryContainer = dataBuilder.getBinaryContainer();\n-        this.optionValues = dataBuilder.getBackend().getRuntime().getOptions();\n-    }\n-\n-    \/**\n-     * Method that looks at code section of a compiled result {@code compClass} and records function\n-     * entry point symbols along with the text section contents. Note that the text section contents\n-     * are not yet ready to be written in the form of a binary text section since the contents may\n-     * need to be patched with references to other sections.\n-     *\n-     * @param compClass Graal compilation result.\n-     *\/\n-    void process(AOTCompiledClass compClass) {\n-        ArrayList<CompiledMethodInfo> compiledMethods = compClass.getCompiledMethods();\n-\n-        for (CompiledMethodInfo methodInfo : compiledMethods) {\n-            CompilationResult compResult = methodInfo.getCompilationResult();\n-\n-            byte[] targetCode = compResult.getTargetCode();\n-            int targetCodeSize = compResult.getTargetCodeSize();\n-            JavaMethodInfo compMethod = methodInfo.getMethodInfo();\n-\n-            \/\/ Step through all foreign calls, for every call, clear destination.\n-            \/\/ Otherwise libelf may not patch them correctly.\n-            for (Infopoint infopoint : compResult.getInfopoints()) {\n-                if (infopoint.reason == InfopointReason.CALL) {\n-                    final Call callInfopoint = (Call) infopoint;\n-                    if (callInfopoint.target instanceof HotSpotForeignCallLinkage &&\n-                                    target.arch instanceof AMD64) {\n-                        \/\/ TODO 4 is x86 size of relative displacement.\n-                        \/\/ For SPARC need something different.\n-                        int destOffset = infopoint.pcOffset + callInfopoint.size - 4;\n-                        targetCode[destOffset + 0] = 0;\n-                        targetCode[destOffset + 1] = 0;\n-                        targetCode[destOffset + 2] = 0;\n-                        targetCode[destOffset + 3] = 0;\n-                    }\n-                }\n-            }\n-\n-            String entry = compMethod.getSymbolName();\n-            assert entry != null : \"missing name for compiled method\";\n-\n-            \/\/ Align and pad method entry\n-            CodeContainer codeSection = binaryContainer.getCodeContainer();\n-            int codeIdOffset = BinaryContainer.alignUp(codeSection, binaryContainer.getCodeSegmentSize());\n-            \/\/ Store CodeId into code. It will be use by find_aot() using code.segments\n-            methodInfo.setCodeId();\n-            binaryContainer.appendIntToCode(methodInfo.getCodeId());\n-            int textBaseOffset = BinaryContainer.alignUp(codeSection, binaryContainer.getCodeEntryAlignment());\n-\n-            codeSection.createSymbol(textBaseOffset, Symbol.Kind.JAVA_FUNCTION, Symbol.Binding.LOCAL, targetCodeSize, entry);\n-\n-            \/\/ Set the offset at which the text section of this method would be layed out\n-            methodInfo.setTextSectionOffset(textBaseOffset);\n-\n-            \/\/ Write code bytes of the current method into byte stream\n-            binaryContainer.appendCodeBytes(targetCode, 0, targetCodeSize);\n-            int currentStubOffset = BinaryContainer.alignUp(codeSection, 8);\n-            \/\/ Set the offset at which stubs of this method would be laid out\n-            methodInfo.setStubsOffset(currentStubOffset - textBaseOffset);\n-            \/\/ step through all calls, for every call, add a stub\n-            for (Infopoint infopoint : compResult.getInfopoints()) {\n-                if (infopoint.reason == InfopointReason.CALL) {\n-                    final Call callInfopoint = (Call) infopoint;\n-                    if (callInfopoint.target instanceof ResolvedJavaMethod) {\n-                        ResolvedJavaMethod call = (ResolvedJavaMethod) callInfopoint.target;\n-                        StubInformation stub = addCallStub(CallInfo.isVirtualCall(methodInfo, callInfopoint));\n-                        \/\/ Get the targetSymbol. A symbol for this will be created later during plt\n-                        \/\/ creation\n-                        String targetSymbol = JavaMethodInfo.uniqueMethodName(call) + \".at.\" + infopoint.pcOffset;\n-                        methodInfo.addStubCode(targetSymbol, stub);\n-                        currentStubOffset += stub.getSize();\n-                    }\n-                }\n-            }\n-            assert currentStubOffset == codeSection.getByteStreamSize() : \"wrong offset\";\n-            binaryContainer.addCodeSegments(codeIdOffset, currentStubOffset);\n-        }\n-    }\n-\n-    private StubInformation addCallStub(boolean isVirtualCall) {\n-        final int startOffset = binaryContainer.getCodeContainer().getByteStreamSize();\n-        StubInformation stub = new StubInformation(startOffset, isVirtualCall);\n-        ELFMacroAssembler masm = ELFMacroAssembler.getELFMacroAssembler(target, optionValues);\n-        byte[] code;\n-        if (isVirtualCall) {\n-            code = masm.getPLTVirtualEntryCode(stub);\n-        } else {\n-            code = masm.getPLTStaticEntryCode(stub);\n-        }\n-        binaryContainer.appendCodeBytes(code, 0, code.length);\n-        return stub;\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/CodeSectionProcessor.java","additions":0,"deletions":149,"binary":false,"changes":149,"status":"deleted"},{"patch":"@@ -1,214 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import java.io.BufferedReader;\n-import java.io.FileNotFoundException;\n-import java.io.FileReader;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n-\n-import jdk.tools.jaotc.collect.ClassSearch;\n-import jdk.tools.jaotc.collect.FileSupport;\n-import jdk.tools.jaotc.collect.classname.ClassNameSourceProvider;\n-import jdk.tools.jaotc.collect.directory.DirectorySourceProvider;\n-import jdk.tools.jaotc.collect.jar.JarSourceProvider;\n-import jdk.tools.jaotc.collect.module.ModuleSourceProvider;\n-import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;\n-import jdk.vm.ci.meta.MetaAccessProvider;\n-import jdk.vm.ci.meta.ResolvedJavaMethod;\n-import jdk.vm.ci.meta.ResolvedJavaType;\n-\n-final class Collector {\n-\n-    private final Main main;\n-\n-    Collector(Main main) {\n-        this.main = main;\n-    }\n-\n-    Set<Class<?>> collectClassesToCompile() {\n-        Set<Class<?>> classesToCompile = new HashSet<>();\n-        FileSupport fileSupport = new FileSupport();\n-        ClassSearch lookup = new ClassSearch();\n-        lookup.addProvider(new ModuleSourceProvider());\n-        lookup.addProvider(new ClassNameSourceProvider(fileSupport));\n-        lookup.addProvider(new JarSourceProvider());\n-        lookup.addProvider(new DirectorySourceProvider(fileSupport));\n-\n-        List<LoadedClass> foundClasses = null;\n-        try {\n-            foundClasses = lookup.search(main.options.files, main.options.searchPath, this::handleLoadingError);\n-        } catch (InternalError e) {\n-            main.printer.reportError(e);\n-            return null;\n-        }\n-\n-        for (LoadedClass loadedClass : foundClasses) {\n-            classesToCompile.add(loadedClass.getLoadedClass());\n-        }\n-        return classesToCompile;\n-    }\n-\n-    private void addMethods(AOTCompiledClass aotClass, ResolvedJavaMethod[] methods, CompilationSpec compilationRestrictions) {\n-        for (ResolvedJavaMethod m : methods) {\n-            addMethod(aotClass, m, compilationRestrictions);\n-        }\n-    }\n-\n-    private void addMethod(AOTCompiledClass aotClass, ResolvedJavaMethod method, CompilationSpec compilationRestrictions) {\n-        \/\/ Don't compile native or abstract methods.\n-        if (!method.hasBytecodes()) {\n-            return;\n-        }\n-        if (!compilationRestrictions.shouldCompileMethod(method)) {\n-            return;\n-        }\n-        if (!main.filters.shouldCompileMethod(method)) {\n-            return;\n-        }\n-        assert ((HotSpotResolvedObjectType) method.getDeclaringClass()).getFingerprint() != 0 : \"no fingerprint for \" + method.getDeclaringClass().getName();\n-\n-        aotClass.addMethod(method);\n-        main.printer.printlnVerbose(\"  added \" + method.getName() + method.getSignature().toMethodDescriptor());\n-    }\n-\n-    \/**\n-     * Collect all method we should compile.\n-     *\n-     * @return array list of AOT classes which have compiled methods.\n-     *\/\n-    List<AOTCompiledClass> collectMethodsToCompile(Set<Class<?>> classesToCompile, MetaAccessProvider metaAccess) {\n-        int total = 0;\n-        int count = 0;\n-        List<AOTCompiledClass> classes = new ArrayList<>();\n-        CompilationSpec compilationRestrictions = collectSpecifiedMethods();\n-\n-        for (Class<?> c : classesToCompile) {\n-            ResolvedJavaType resolvedJavaType = metaAccess.lookupJavaType(c);\n-            if (main.filters.shouldCompileAnyMethodInClass(resolvedJavaType)) {\n-                AOTCompiledClass aotClass = new AOTCompiledClass(resolvedJavaType);\n-                main.printer.printlnVerbose(\" Scanning \" + c.getName());\n-\n-                \/\/ Constructors\n-                try {\n-                    ResolvedJavaMethod[] ctors = resolvedJavaType.getDeclaredConstructors();\n-                    addMethods(aotClass, ctors, compilationRestrictions);\n-                    total += ctors.length;\n-                } catch (Throwable e) {\n-                    handleLoadingError(c.getName(), e);\n-                }\n-\n-                \/\/ Methods\n-                try {\n-                    ResolvedJavaMethod[] methods = resolvedJavaType.getDeclaredMethods();\n-                    addMethods(aotClass, methods, compilationRestrictions);\n-                    total += methods.length;\n-                } catch (Throwable e) {\n-                    handleLoadingError(c.getName(), e);\n-                }\n-\n-                \/\/ Class initializer\n-                try {\n-                    ResolvedJavaMethod clinit = resolvedJavaType.getClassInitializer();\n-                    if (clinit != null) {\n-                        addMethod(aotClass, clinit, compilationRestrictions);\n-                        total++;\n-                    }\n-                } catch (Throwable e) {\n-                    handleLoadingError(c.getName(), e);\n-                }\n-\n-                \/\/ Found any methods to compile? Add the class.\n-                if (aotClass.hasMethods()) {\n-                    classes.add(aotClass);\n-                    count += aotClass.getMethodCount();\n-                }\n-            }\n-        }\n-        main.printer.printInfo(total + \" methods total, \" + count + \" methods to compile\");\n-        return classes;\n-    }\n-\n-    \/**\n-     * If a file with compilation limitations is specified using flag --compile-commands, read the\n-     * file's contents and collect the restrictions.\n-     *\/\n-    private CompilationSpec collectSpecifiedMethods() {\n-        CompilationSpec compilationRestrictions = new CompilationSpec();\n-        String methodListFileName = main.options.methodList;\n-\n-        if (methodListFileName != null && !methodListFileName.equals(\"\")) {\n-            try {\n-                FileReader methListFile = new FileReader(methodListFileName);\n-                BufferedReader readBuf = new BufferedReader(methListFile);\n-                String line = null;\n-                while ((line = readBuf.readLine()) != null) {\n-                    String trimmedLine = line.trim();\n-                    if (!trimmedLine.startsWith(\"#\")) {\n-                        String[] components = trimmedLine.split(\" \");\n-                        if (components.length == 2) {\n-                            String directive = components[0];\n-                            String pattern = components[1];\n-                            switch (directive) {\n-                                case \"compileOnly\":\n-                                    compilationRestrictions.addCompileOnlyPattern(pattern);\n-                                    break;\n-                                case \"exclude\":\n-                                    compilationRestrictions.addExcludePattern(pattern);\n-                                    break;\n-                                default:\n-                                    System.out.println(\"Unrecognized command \" + directive + \". Ignoring\\n\\t\" + line + \"\\n encountered in \" + methodListFileName);\n-                            }\n-                        } else {\n-                            if (!trimmedLine.equals(\"\")) {\n-                                System.out.println(\"Ignoring malformed line:\\n\\t \" + line + \"\\n\");\n-                            }\n-                        }\n-                    }\n-                }\n-                readBuf.close();\n-            } catch (FileNotFoundException e) {\n-                throw new InternalError(\"Unable to open method list file: \" + methodListFileName, e);\n-            } catch (IOException e) {\n-                throw new InternalError(\"Unable to read method list file: \" + methodListFileName, e);\n-            }\n-        }\n-\n-        return compilationRestrictions;\n-    }\n-\n-    private void handleLoadingError(String name, Throwable t) {\n-        if (main.options.ignoreClassLoadingErrors) {\n-            main.printer.printError(name + \": \" + t);\n-        } else {\n-            throw new InternalError(t);\n-        }\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/Collector.java","additions":0,"deletions":214,"binary":false,"changes":214,"status":"deleted"},{"patch":"@@ -1,127 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.regex.Pattern;\n-\n-import jdk.vm.ci.meta.ResolvedJavaMethod;\n-\n-\/**\n- * A class encapsulating any user-specified compilation restrictions.\n- *\/\n-final class CompilationSpec {\n-\n-    \/**\n-     * Set of method names to restrict compilation to.\n-     *\/\n-    private HashSet<String> compileOnlyStrings = new HashSet<>();\n-    private HashSet<Pattern> compileOnlyPatterns = new HashSet<>();\n-\n-    \/**\n-     * Set of method names that should be excluded from compilation.\n-     *\/\n-    private HashSet<String> excludeStrings = new HashSet<>();\n-    private HashSet<Pattern> excludePatterns = new HashSet<>();\n-\n-    \/**\n-     * Add a {@code compileOnly} directive to the compile-only list.\n-     *\n-     * @param pattern regex or non-regex pattern string\n-     *\/\n-    void addCompileOnlyPattern(String pattern) {\n-        if (pattern.contains(\"*\")) {\n-            compileOnlyPatterns.add(Pattern.compile(pattern));\n-        } else {\n-            compileOnlyStrings.add(pattern);\n-        }\n-    }\n-\n-    \/**\n-     * Add an {@code exclude} directive to the exclude list.\n-     *\n-     * @param pattern regex or non-regex pattern string\n-     *\/\n-    void addExcludePattern(String pattern) {\n-        if (pattern.contains(\"*\")) {\n-            excludePatterns.add(Pattern.compile(pattern));\n-        } else {\n-            excludeStrings.add(pattern);\n-        }\n-    }\n-\n-    \/**\n-     * Check if a given method is part of a restrictive compilation.\n-     *\n-     * @param method method to be checked\n-     * @return true or false\n-     *\/\n-    boolean shouldCompileMethod(ResolvedJavaMethod method) {\n-        if (compileWithRestrictions()) {\n-            \/\/ If there are user-specified compileOnly patterns, default action\n-            \/\/ is not to compile the method.\n-            boolean compileMethod = compileOnlyStrings.isEmpty() && compileOnlyPatterns.isEmpty();\n-\n-            \/\/ Check if the method matches with any of the specified compileOnly patterns.\n-            String methodName = JavaMethodInfo.uniqueMethodName(method);\n-\n-            \/\/ compileOnly\n-            if (!compileMethod) {\n-                compileMethod = compileOnlyStrings.contains(methodName);\n-            }\n-            if (!compileMethod) {\n-                Iterator<Pattern> it = compileOnlyPatterns.iterator();\n-                while (!compileMethod && it.hasNext()) {\n-                    Pattern pattern = it.next();\n-                    compileMethod = pattern.matcher(methodName).matches();\n-                }\n-            }\n-\n-            \/\/ exclude\n-            if (compileMethod) {\n-                compileMethod = !excludeStrings.contains(methodName);\n-            }\n-            if (compileMethod) {\n-                Iterator<Pattern> it = excludePatterns.iterator();\n-                while (compileMethod && it.hasNext()) {\n-                    Pattern pattern = it.next();\n-                    compileMethod = !(pattern.matcher(methodName).matches());\n-                }\n-            }\n-            return compileMethod;\n-        }\n-        return true;\n-    }\n-\n-    \/**\n-     * Return true if compilation restrictions are specified.\n-     *\/\n-    private boolean compileWithRestrictions() {\n-        return !(compileOnlyStrings.isEmpty() && compileOnlyPatterns.isEmpty() && excludeStrings.isEmpty() && excludePatterns.isEmpty());\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/CompilationSpec.java","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -1,341 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import org.graalvm.compiler.code.CompilationResult;\n-import org.graalvm.compiler.hotspot.HotSpotMarkId;\n-\n-import jdk.tools.jaotc.AOTCompiledClass.AOTKlassData;\n-import jdk.tools.jaotc.binformat.BinaryContainer;\n-import jdk.tools.jaotc.binformat.ReadOnlyDataContainer;\n-import jdk.vm.ci.code.site.Call;\n-import jdk.vm.ci.hotspot.HotSpotCompiledCode;\n-import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;\n-\n-final class CompiledMethodInfo {\n-\n-    static final String archStr = System.getProperty(\"os.arch\").toLowerCase();\n-\n-    private static final int UNINITIALIZED_OFFSET = -1;\n-\n-    private static class AOTMethodOffsets {\n-        \/**\n-         * Offset in metaspace names section.\n-         *\/\n-        private int nameOffset;\n-\n-        \/**\n-         * Offset in the text section at which compiled code starts.\n-         *\/\n-        private int textSectionOffset;\n-\n-        \/**\n-         * Offset in the metadata section.\n-         *\/\n-        private int metadataOffset;\n-\n-        \/**\n-         * Offset to the metadata in the GOT table.\n-         *\/\n-        private int metadataGotOffset;\n-\n-        \/**\n-         * Size of the metadata.\n-         *\/\n-        private int metadataGotSize;\n-\n-        \/**\n-         * The sequential number corresponding to the order of methods code in code buffer.\n-         *\/\n-        private int codeId;\n-\n-        AOTMethodOffsets() {\n-            this.nameOffset = UNINITIALIZED_OFFSET;\n-            this.textSectionOffset = UNINITIALIZED_OFFSET;\n-            this.metadataOffset = UNINITIALIZED_OFFSET;\n-            this.metadataGotOffset = UNINITIALIZED_OFFSET;\n-            this.metadataGotSize = -1;\n-            this.codeId = -1;\n-        }\n-\n-        void addMethodOffsets(ReadOnlyDataContainer container, String name) {\n-            verify(name);\n-            \/\/ @formatter:off\n-            \/*\n-             * The offsets layout should match AOTMethodOffsets structure in AOT JVM runtime\n-             *\/\n-                      \/\/ Add the offset to the name in the .metaspace.names section\n-            container.appendInt(nameOffset).\n-                      \/\/ Add the offset to the code in the .text section\n-                      appendInt(textSectionOffset).\n-                      \/\/ Add the offset to the metadata in the .method.metadata section\n-                      appendInt(metadataOffset).\n-                      \/\/ Add the offset to the metadata in the .metadata.got section\n-                      appendInt(metadataGotOffset).\n-                      \/\/ Add the size of the metadata\n-                      appendInt(metadataGotSize).\n-                      \/\/ Add code ID.\n-                      appendInt(codeId);\n-            \/\/ @formatter:on\n-        }\n-\n-        private void verify(String name) {\n-            assert nameOffset >= 0 : \"incorrect nameOffset: \" + nameOffset + \" for method: \" + name;\n-            assert textSectionOffset > 0 : \"incorrect textSectionOffset: \" + textSectionOffset + \" for method: \" + name;\n-            assert metadataOffset >= 0 : \"incorrect metadataOffset: \" + metadataOffset + \" for method: \" + name;\n-            assert metadataGotOffset >= 0 : \"incorrect metadataGotOffset: \" + metadataGotOffset + \" for method: \" + name;\n-            assert metadataGotSize >= 0 : \"incorrect metadataGotSize: \" + metadataGotSize + \" for method: \" + name;\n-            assert codeId >= 0 : \"incorrect codeId: \" + codeId + \" for method: \" + name;\n-        }\n-\n-        protected void setNameOffset(int offset) {\n-            nameOffset = offset;\n-        }\n-\n-        protected void setTextSectionOffset(int textSectionOffset) {\n-            this.textSectionOffset = textSectionOffset;\n-        }\n-\n-        protected int getTextSectionOffset() {\n-            return textSectionOffset;\n-        }\n-\n-        protected void setCodeId(int codeId) {\n-            this.codeId = codeId;\n-        }\n-\n-        protected int getCodeId() {\n-            return codeId;\n-        }\n-\n-        protected void setMetadataOffset(int offset) {\n-            metadataOffset = offset;\n-        }\n-\n-        protected void setMetadataGotOffset(int metadataGotOffset) {\n-            this.metadataGotOffset = metadataGotOffset;\n-        }\n-\n-        protected void setMetadataGotSize(int length) {\n-            this.metadataGotSize = length;\n-        }\n-    }\n-\n-    \/**\n-     * Method name.\n-     *\/\n-    private String name;\n-\n-    \/**\n-     * Result of graal compilation.\n-     *\/\n-    private CompilationResult compilationResult;\n-\n-    \/**\n-     * HotSpotResolvedJavaMethod or Stub corresponding to the compilation result.\n-     *\/\n-    private JavaMethodInfo methodInfo;\n-\n-    \/**\n-     * Compiled code from installation.\n-     *\/\n-    private HotSpotCompiledCode code;\n-\n-    \/**\n-     * Offset to stubs.\n-     *\/\n-    private int stubsOffset;\n-\n-    \/**\n-     * The total size in bytes of the stub section.\n-     *\/\n-    private int totalStubSize;\n-\n-    \/**\n-     * Method's offsets.\n-     *\/\n-    private AOTMethodOffsets methodOffsets;\n-\n-    \/**\n-     * List of stubs (PLT trampoline).\n-     *\/\n-    private HashMap<String, StubInformation> stubs = new HashMap<>();\n-\n-    \/**\n-     * List of referenced classes.\n-     *\/\n-    private HashSet<AOTKlassData> dependentKlasses = new HashSet<>();\n-\n-    \/**\n-     * Methods count used to generate unique global method id.\n-     *\/\n-    private static final AtomicInteger methodsCount = new AtomicInteger();\n-\n-    CompiledMethodInfo(CompilationResult compilationResult, JavaMethodInfo methodInfo) {\n-        this.name = methodInfo.getNameAndSignature();\n-        this.compilationResult = compilationResult;\n-        this.methodInfo = methodInfo;\n-        this.stubsOffset = UNINITIALIZED_OFFSET;\n-        this.methodOffsets = new AOTMethodOffsets();\n-    }\n-\n-    String name() {\n-        return name;\n-    }\n-\n-    void addMethodOffsets(BinaryContainer binaryContainer, ReadOnlyDataContainer container) {\n-        this.methodOffsets.setNameOffset(binaryContainer.addMetaspaceName(name));\n-        this.methodOffsets.addMethodOffsets(container, name);\n-        for (AOTKlassData data : dependentKlasses) {\n-            data.addDependentMethod(this);\n-        }\n-    }\n-\n-    CompilationResult getCompilationResult() {\n-        return compilationResult;\n-    }\n-\n-    JavaMethodInfo getMethodInfo() {\n-        return methodInfo;\n-    }\n-\n-    void setTextSectionOffset(int textSectionOffset) {\n-        methodOffsets.setTextSectionOffset(textSectionOffset);\n-    }\n-\n-    public int getTextSectionOffset() {\n-        return methodOffsets.getTextSectionOffset();\n-    }\n-\n-    void setCodeId() {\n-        methodOffsets.setCodeId(CompiledMethodInfo.getNextCodeId());\n-    }\n-\n-    int getCodeId() {\n-        return this.methodOffsets.getCodeId();\n-    }\n-\n-    static int getMethodsCount() {\n-        return methodsCount.get();\n-    }\n-\n-    static int getNextCodeId() {\n-        return methodsCount.getAndIncrement();\n-    }\n-\n-    int getCodeSize() {\n-        return stubsOffset + getStubCodeSize();\n-    }\n-\n-    int getStubCodeSize() {\n-        return totalStubSize;\n-    }\n-\n-    void setMetadataOffset(int offset) {\n-        this.methodOffsets.setMetadataOffset(offset);\n-    }\n-\n-    \/**\n-     * Offset into the code of this method where the stub section starts.\n-     *\/\n-    void setStubsOffset(int offset) {\n-        stubsOffset = offset;\n-    }\n-\n-    int getStubsOffset() {\n-        return stubsOffset;\n-    }\n-\n-    void setMetadataGotOffset(int metadataGotOffset) {\n-        this.methodOffsets.setMetadataGotOffset(metadataGotOffset);\n-    }\n-\n-    void setMetadataGotSize(int length) {\n-        this.methodOffsets.setMetadataGotSize(length);\n-    }\n-\n-    void addStubCode(String call, StubInformation stub) {\n-        stubs.put(call, stub);\n-        totalStubSize += stub.getSize();\n-    }\n-\n-    StubInformation getStubFor(String call) {\n-        StubInformation stub = stubs.get(call);\n-        assert stub != null : \"missing stub for call \" + call;\n-        stub.verify();\n-        return stub;\n-    }\n-\n-    void addDependentKlassData(BinaryContainer binaryContainer, HotSpotResolvedObjectType type) {\n-        AOTKlassData klassData = AOTCompiledClass.addFingerprintKlassData(binaryContainer, type);\n-        dependentKlasses.add(klassData);\n-    }\n-\n-    AOTKlassData getDependentKlassData(HotSpotResolvedObjectType type) {\n-        AOTKlassData klassData = AOTCompiledClass.getAOTKlassData(type);\n-        if (dependentKlasses.contains(klassData)) {\n-            return klassData;\n-        }\n-        return null;\n-    }\n-\n-    boolean hasMark(Call call, HotSpotMarkId id) {\n-        assert id == HotSpotMarkId.INVOKESTATIC || id == HotSpotMarkId.INVOKESPECIAL;\n-        CompilationResult.CodeMark mark = compilationResult.getAssociatedMark(call);\n-        if (mark != null) {\n-            return mark.id == id;\n-        }\n-        return false;\n-    }\n-\n-    String asTag() {\n-        return \"[\" + methodInfo.getSymbolName() + \"]\";\n-    }\n-\n-    HotSpotCompiledCode compiledCode() {\n-        if (code == null) {\n-            code = methodInfo.compiledCode(compilationResult);\n-        }\n-        return code;\n-    }\n-\n-    \/\/ Free memory\n-    void clear() {\n-        this.dependentKlasses = null;\n-        this.name = null;\n-    }\n-\n-    void clearCompileData() {\n-        this.code = null;\n-        this.stubs = null;\n-        this.compilationResult = null;\n-        this.methodInfo = null;\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/CompiledMethodInfo.java","additions":0,"deletions":341,"binary":false,"changes":341,"status":"deleted"},{"patch":"@@ -1,243 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map.Entry;\n-\n-import org.graalvm.compiler.code.CompilationResult;\n-import org.graalvm.compiler.debug.DebugContext;\n-import org.graalvm.compiler.hotspot.HotSpotHostBackend;\n-import org.graalvm.compiler.hotspot.meta.HotSpotForeignCallsProvider;\n-import org.graalvm.compiler.hotspot.stubs.Stub;\n-\n-import jdk.tools.jaotc.binformat.BinaryContainer;\n-import jdk.tools.jaotc.binformat.ByteContainer;\n-import jdk.tools.jaotc.binformat.HeaderContainer;\n-import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;\n-import jdk.vm.ci.hotspot.HotSpotVMConfigStore;\n-import jdk.vm.ci.hotspot.VMField;\n-\n-final class DataBuilder {\n-\n-    private final Main main;\n-\n-    private final HotSpotHostBackend backend;\n-\n-    private final List<AOTCompiledClass> classes;\n-\n-    \/**\n-     * Target-independent container in which text symbols and code bytes are created.\n-     *\/\n-    private final BinaryContainer binaryContainer;\n-\n-    private static final HashMap<Long, String> vmAddresses = new HashMap<>();\n-\n-    DataBuilder(Main main, HotSpotHostBackend backend, List<AOTCompiledClass> classes, BinaryContainer binaryContainer) {\n-        this.main = main;\n-        this.backend = backend;\n-        this.classes = classes;\n-        this.binaryContainer = binaryContainer;\n-        fillVMAddresses(HotSpotJVMCIRuntime.runtime().getConfigStore());\n-    }\n-\n-    \/**\n-     * Returns a value-name map of all {@link VMField} fields.\n-     *\/\n-    private static void fillVMAddresses(HotSpotVMConfigStore config) {\n-        for (VMField vmField : config.getFields().values()) {\n-            if (vmField.value != null && vmField.value instanceof Long) {\n-                final long address = (Long) vmField.value;\n-                String value = vmField.name;\n-                \/*\n-                 * Some fields don't contain addresses but integer values. At least don't add zero\n-                 * entries to avoid matching null addresses.\n-                 *\/\n-                if (address != 0) {\n-                    vmAddresses.put(address, value);\n-                }\n-            }\n-        }\n-        for (Entry<String, Long> vmAddress : config.getAddresses().entrySet()) {\n-            final long address = vmAddress.getValue();\n-            String value = vmAddress.getKey();\n-            String old = vmAddresses.put(address, value);\n-            if (old != null) {\n-                throw new InternalError(\"already in map: address: \" + address + \", current: \" + value + \", old: \" + old);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Get the C\/C++ function name associated with the foreign call target {@code address}.\n-     *\n-     * @param address native address\n-     * @return C\/C++ functio name associated with the native address\n-     *\/\n-    static String getVMFunctionNameForAddress(long address) {\n-        return vmAddresses.get(address);\n-    }\n-\n-    \/**\n-     * Returns the host backend used for this compilation.\n-     *\n-     * @return host backend\n-     *\/\n-    HotSpotHostBackend getBackend() {\n-        return backend;\n-    }\n-\n-    \/**\n-     * Returns the binary container for this compilation.\n-     *\n-     * @return binary container\n-     *\/\n-    BinaryContainer getBinaryContainer() {\n-        return binaryContainer;\n-    }\n-\n-    \/**\n-     * Prepare data with all compiled classes and stubs.\n-     *\n-     * @param debug\n-     *\n-     * @throws Exception\n-     *\/\n-    @SuppressWarnings(\"try\")\n-    void prepareData(DebugContext debug) throws Exception {\n-        try (Timer t = new Timer(main, \"Parsing compiled code\")) {\n-            \/*\n-             * Copy compiled code into code section container and calls stubs (PLT trampoline).\n-             *\/\n-            CodeSectionProcessor codeSectionProcessor = new CodeSectionProcessor(this);\n-            for (AOTCompiledClass c : classes) {\n-                \/\/ For each class we need 2 GOT slots:\n-                \/\/ first - for initialized klass\n-                \/\/ second - only for loaded klass\n-                c.addAOTKlassData(binaryContainer);\n-                codeSectionProcessor.process(c);\n-            }\n-        }\n-\n-        AOTCompiledClass stubCompiledCode = retrieveStubCode(debug);\n-\n-        \/\/ Free memory!\n-        try (Timer t = main.options.verbose ? new Timer(main, \"Freeing memory\") : null) {\n-            main.printer.printMemoryUsage();\n-            System.gc();\n-        }\n-\n-        MetadataBuilder metadataBuilder = null;\n-        try (Timer t = new Timer(main, \"Processing metadata\")) {\n-            \/*\n-             * Generate metadata for compiled code and copy it into metadata section. Create\n-             * relocation information for all references (call, constants, etc) in compiled code.\n-             *\/\n-            metadataBuilder = new MetadataBuilder(this);\n-            metadataBuilder.processMetadata(classes, stubCompiledCode);\n-        }\n-\n-        \/\/ Free memory!\n-        try (Timer t = main.options.verbose ? new Timer(main, \"Freeing memory\") : null) {\n-            main.printer.printMemoryUsage();\n-            System.gc();\n-        }\n-\n-        try (Timer t = new Timer(main, \"Preparing stubs binary\")) {\n-            prepareStubsBinary(stubCompiledCode);\n-        }\n-        try (Timer t = new Timer(main, \"Preparing compiled binary\")) {\n-            \/\/ Should be called after Stubs because they can set dependent klasses.\n-            prepareCompiledBinary();\n-        }\n-    }\n-\n-    \/**\n-     * Get all stubs from Graal and add them to the code section.\n-     *\n-     * @param debug\n-     *\/\n-    @SuppressWarnings(\"try\")\n-    private AOTCompiledClass retrieveStubCode(DebugContext debug) {\n-        ArrayList<CompiledMethodInfo> stubs = new ArrayList<>();\n-        HotSpotForeignCallsProvider foreignCallsProvider = backend.getProviders().getForeignCalls();\n-        for (Stub stub : foreignCallsProvider.getStubs()) {\n-            try (DebugContext.Scope scope = debug.scope(\"CompileStubs\")) {\n-                CompilationResult result = stub.getCompilationResult(debug, backend);\n-                CompiledMethodInfo cm = new CompiledMethodInfo(result, new AOTStub(stub, backend, debug.getOptions()));\n-                stubs.add(cm);\n-            } catch (Throwable e) {\n-                throw debug.handle(e);\n-            }\n-        }\n-        AOTCompiledClass stubCompiledCode = new AOTCompiledClass(stubs);\n-        CodeSectionProcessor codeSectionProcessor = new CodeSectionProcessor(this);\n-        codeSectionProcessor.process(stubCompiledCode);\n-        return stubCompiledCode;\n-    }\n-\n-    \/**\n-     * Prepare metaspace.offsets section.\n-     *\/\n-    private void prepareCompiledBinary() {\n-        for (AOTCompiledClass c : classes) {\n-            \/\/ Create records for compiled AOT methods.\n-            c.putMethodsData(binaryContainer);\n-        }\n-        \/\/ Create records for compiled AOT classes.\n-        AOTCompiledClass.putAOTKlassData(binaryContainer);\n-\n-        \/\/ Fill in AOTHeader\n-        HeaderContainer header = binaryContainer.getHeaderContainer();\n-        header.setClassesCount(AOTCompiledClass.getClassesCount());\n-        header.setMethodsCount(CompiledMethodInfo.getMethodsCount());\n-        \/\/ Record size of got sections\n-        ByteContainer bc = binaryContainer.getKlassesGotContainer();\n-        header.setKlassesGotSize((bc.getByteStreamSize() \/ 8));\n-        bc = binaryContainer.getMetadataGotContainer();\n-        header.setMetadataGotSize((bc.getByteStreamSize() \/ 8));\n-        bc = binaryContainer.getOopGotContainer();\n-        header.setOopGotSize((bc.getByteStreamSize() \/ 8));\n-    }\n-\n-    \/**\n-     * Prepare stubs.offsets section.\n-     *\/\n-    private void prepareStubsBinary(AOTCompiledClass compiledClass) {\n-        \/\/ For each of the compiled stubs, create records holding information about\n-        \/\/ them.\n-        ArrayList<CompiledMethodInfo> compiledStubs = compiledClass.getCompiledMethods();\n-        int cntStubs = compiledStubs.size();\n-        BinaryContainer.addMethodsCount(cntStubs, binaryContainer.getStubsOffsetsContainer());\n-        for (CompiledMethodInfo methodInfo : compiledStubs) {\n-            \/\/ Note, stubs have different offsets container.\n-            methodInfo.addMethodOffsets(binaryContainer, binaryContainer.getStubsOffsetsContainer());\n-        }\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/DataBuilder.java","additions":0,"deletions":243,"binary":false,"changes":243,"status":"deleted"},{"patch":"@@ -1,165 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-\n-import org.graalvm.compiler.code.DataSection;\n-import org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction;\n-\n-import jdk.tools.jaotc.binformat.BinaryContainer;\n-import jdk.tools.jaotc.binformat.Relocation;\n-import jdk.tools.jaotc.binformat.Relocation.RelocType;\n-import jdk.tools.jaotc.binformat.Symbol;\n-import jdk.tools.jaotc.binformat.Symbol.Binding;\n-import jdk.tools.jaotc.binformat.Symbol.Kind;\n-import jdk.vm.ci.code.TargetDescription;\n-import jdk.vm.ci.code.site.ConstantReference;\n-import jdk.vm.ci.code.site.DataPatch;\n-import jdk.vm.ci.code.site.DataSectionReference;\n-import jdk.vm.ci.code.site.Reference;\n-import jdk.vm.ci.hotspot.HotSpotConstantPoolObject;\n-import jdk.vm.ci.hotspot.HotSpotMetaspaceConstant;\n-import jdk.vm.ci.hotspot.HotSpotObjectConstant;\n-import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;\n-import jdk.vm.ci.hotspot.HotSpotSentinelConstant;\n-import jdk.vm.ci.meta.JavaConstant;\n-import jdk.vm.ci.meta.VMConstant;\n-\n-final class DataPatchProcessor {\n-\n-    private final TargetDescription target;\n-\n-    private final BinaryContainer binaryContainer;\n-\n-    DataPatchProcessor(DataBuilder dataBuilder) {\n-        this.target = dataBuilder.getBackend().getTarget();\n-        this.binaryContainer = dataBuilder.getBinaryContainer();\n-    }\n-\n-    \/**\n-     * Process a {@link DataPatch} generated by the compiler and create all needed binary section\n-     * constructs.\n-     *\/\n-    void process(CompiledMethodInfo methodInfo, DataPatch dataPatch) {\n-        Reference reference = dataPatch.reference;\n-        if (reference instanceof ConstantReference) {\n-            processConstantReference(dataPatch, methodInfo);\n-        } else if (reference instanceof DataSectionReference) {\n-            processDataSectionReference(dataPatch, methodInfo);\n-        } else {\n-            throw new InternalError(\"Unknown data patch reference: \" + reference);\n-        }\n-    }\n-\n-    private void processConstantReference(DataPatch dataPatch, CompiledMethodInfo methodInfo) {\n-        HotSpotConstantLoadAction action = (HotSpotConstantLoadAction) dataPatch.note;\n-        ConstantReference constantReference = (ConstantReference) dataPatch.reference;\n-        assert action != null : \"action should be set\";\n-\n-        VMConstant constant = constantReference.getConstant();\n-        String targetSymbol = null;\n-        String gotName = null;\n-        if (constant instanceof HotSpotMetaspaceConstant) {\n-            HotSpotMetaspaceConstant metaspaceConstant = (HotSpotMetaspaceConstant) constant;\n-            if (metaspaceConstant.asResolvedJavaType() != null) {\n-                HotSpotResolvedObjectType type = metaspaceConstant.asResolvedJavaType();\n-                methodInfo.addDependentKlassData(binaryContainer, type);\n-                targetSymbol = AOTCompiledClass.metadataName(type);\n-                gotName = ((action == HotSpotConstantLoadAction.INITIALIZE) ? \"got.init.\" : \"got.\") + targetSymbol;\n-            } else if (metaspaceConstant.asResolvedJavaMethod() != null && action == HotSpotConstantLoadAction.LOAD_COUNTERS) {\n-                targetSymbol = \"counters.\" + JavaMethodInfo.uniqueMethodName(metaspaceConstant.asResolvedJavaMethod());\n-                gotName = \"got.\" + targetSymbol;\n-                binaryContainer.addCountersSymbol(targetSymbol);\n-            }\n-        } else if (constant instanceof JavaConstant) {\n-            JavaConstant jConstant = (JavaConstant) constant;\n-            if (jConstant instanceof HotSpotConstantPoolObject) {\n-                HotSpotConstantPoolObject cpo = (HotSpotConstantPoolObject) jConstant;\n-                \/\/ Even if two locations use the same object, resolve separately\n-                targetSymbol = \"ldc.\" + cpo.toValueString();\n-                Integer offset = binaryContainer.addOopSymbol(targetSymbol);\n-                gotName = \"got.ldc.\" + offset;\n-            } else if (jConstant instanceof HotSpotObjectConstant) {\n-                HotSpotObjectConstant oopConstant = (HotSpotObjectConstant) jConstant;\n-                \/\/ String constant.\n-                targetSymbol = \"ldc.\" + oopConstant.toValueString();\n-                Integer offset = binaryContainer.addOopSymbol(targetSymbol);\n-                gotName = \"got.ldc.\" + offset;\n-            } else if (jConstant instanceof HotSpotSentinelConstant) {\n-                targetSymbol = \"state.M\" + methodInfo.getCodeId();\n-                gotName = \"got.\" + targetSymbol;\n-            }\n-        }\n-\n-        assert gotName != null : \"Unknown constant type: \" + constant;\n-\n-        InstructionDecoder decoder = InstructionDecoder.getInstructionDecoder(target);\n-        decoder.decodePosition(methodInfo.getCompilationResult().getTargetCode(), dataPatch.pcOffset);\n-        int instructionEndOffset = decoder.currentEndOfInstruction();\n-\n-        int textBaseOffset = methodInfo.getTextSectionOffset();\n-        int relocOffset = textBaseOffset + instructionEndOffset;\n-\n-        Symbol relocationSymbol = binaryContainer.getSymbol(gotName);\n-        assert relocationSymbol != null : \"symbol for \" + gotName + \" missing\";\n-        Relocation reloc = new Relocation(relocOffset, RelocType.METASPACE_GOT_REFERENCE, 0, binaryContainer.getCodeContainer(), relocationSymbol);\n-        binaryContainer.addRelocation(reloc);\n-    }\n-\n-    private void processDataSectionReference(DataPatch dataPatch, CompiledMethodInfo methodInfo) {\n-        DataSectionReference dataReference = (DataSectionReference) dataPatch.reference;\n-\n-        InstructionDecoder decoder = InstructionDecoder.getInstructionDecoder(target);\n-        decoder.decodePosition(methodInfo.getCompilationResult().getTargetCode(), dataPatch.pcOffset);\n-        int instructionEndOffset = decoder.currentEndOfInstruction();\n-\n-        int textBaseOffset = methodInfo.getTextSectionOffset();\n-        int relocOffset = textBaseOffset + instructionEndOffset;\n-        int dataOffset = dataReference.getOffset();\n-\n-        DataSection dataSection = methodInfo.getCompilationResult().getDataSection();\n-        DataSection.Data data = dataSection.findData(dataReference);\n-        int size = data.getSize();\n-        int alignment = data.getAlignment();\n-        byte[] value = new byte[size];\n-        ByteBuffer buffer = ByteBuffer.wrap(value).order(ByteOrder.nativeOrder());\n-        DataSection.emit(buffer, data, (p, c) -> {\n-        });\n-        String targetSymbol = \"data.M\" + methodInfo.getCodeId() + \".\" + dataOffset;\n-        Symbol relocationSymbol = binaryContainer.getSymbol(targetSymbol);\n-        if (relocationSymbol == null) {\n-            int symSize = Math.max(8, size);\n-            int symAlig = Math.max(8, alignment);\n-            int offsetInConstantDataSection = binaryContainer.addConstantData(value, symAlig);\n-            relocationSymbol = binaryContainer.getConstantDataContainer().createSymbol(offsetInConstantDataSection, Kind.OBJECT, Binding.LOCAL, symSize, targetSymbol);\n-        }\n-        Relocation reloc = new Relocation(relocOffset, RelocType.METASPACE_GOT_REFERENCE, 0, binaryContainer.getCodeContainer(), relocationSymbol);\n-        binaryContainer.addRelocation(reloc);\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/DataPatchProcessor.java","additions":0,"deletions":165,"binary":false,"changes":165,"status":"deleted"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import org.graalvm.compiler.options.OptionValues;\n-\n-import jdk.tools.jaotc.aarch64.AArch64ELFMacroAssembler;\n-import jdk.tools.jaotc.amd64.AMD64ELFMacroAssembler;\n-import jdk.vm.ci.aarch64.AArch64;\n-import jdk.vm.ci.amd64.AMD64;\n-import jdk.vm.ci.code.Architecture;\n-import jdk.vm.ci.code.TargetDescription;\n-\n-public interface ELFMacroAssembler {\n-\n-    static ELFMacroAssembler getELFMacroAssembler(TargetDescription target, OptionValues optionValues) {\n-        Architecture architecture = target.arch;\n-        if (architecture instanceof AMD64) {\n-            return new AMD64ELFMacroAssembler(target, optionValues);\n-        } else if (architecture instanceof AArch64) {\n-            return new AArch64ELFMacroAssembler(target);\n-        } else {\n-            throw new InternalError(\"Unsupported architecture \" + architecture);\n-        }\n-    }\n-\n-    int currentEndOfInstruction();\n-\n-    byte[] getPLTJumpCode();\n-\n-    byte[] getPLTStaticEntryCode(StubInformation stub);\n-\n-    byte[] getPLTVirtualEntryCode(StubInformation stub);\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/ELFMacroAssembler.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import jdk.tools.jaotc.binformat.BinaryContainer;\n-import jdk.tools.jaotc.binformat.Relocation.RelocType;\n-import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage;\n-\n-import jdk.vm.ci.code.site.Call;\n-\n-\/**\n- * This is a foreign call site. This means either a call to the VM or a call to a Graal stub. If\n- * it's a call directly to the VM, mangle the name. The call should go through regular .plt used by\n- * the system loader, at least for now. If it's a call to a Graal stub, it should always be a direct\n- * call, since the Graal stubs are contained within the .so file.\n- *\/\n-final class ForeignCallSiteRelocationInfo extends CallSiteRelocationInfo {\n-\n-    ForeignCallSiteRelocationInfo(Call call, HotSpotForeignCallLinkage callTarget) {\n-        super(getTargetSymbol(call, callTarget), getRelocType(callTarget));\n-    }\n-\n-    private static String getTargetSymbol(Call call, HotSpotForeignCallLinkage callTarget) {\n-        \/\/ If it specifies a foreign call linkage, find the symbol corresponding to the address in\n-        \/\/ HotSpotVMConfig's fields.\n-        final long foreignCallTargetAddress = callTarget.getAddress();\n-\n-        \/\/ Get the C\/C++ function name associated with the foreign call target address.\n-        String functionName = DataBuilder.getVMFunctionNameForAddress(foreignCallTargetAddress);\n-        if (functionName != null) {\n-            \/\/ Use the known global AOT symbol associated with function name, if one exists\n-            String aotSymbol = BinaryContainer.getAOTSymbolForVMFunctionName(functionName);\n-            if (aotSymbol == null) {\n-                throw new InternalError(\"no global symbol found for: \" + functionName);\n-            }\n-            return aotSymbol;\n-        }\n-\n-        \/\/ Is it a Graal stub we are calling?\n-        if (callTarget.isCompiledStub()) {\n-            assert call.direct : \"Should always be a direct call to stubs\";\n-            return callTarget.getSymbol();\n-        }\n-\n-        throw new InternalError(\"no symbol found for: \" + callTarget);\n-    }\n-\n-    private static RelocType getRelocType(HotSpotForeignCallLinkage callTarget) {\n-        return callTarget.isCompiledStub() ? RelocType.STUB_CALL_DIRECT : RelocType.FOREIGN_CALL_INDIRECT_GOT;\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/ForeignCallSiteRelocationInfo.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import jdk.tools.jaotc.binformat.BinaryContainer;\n-import jdk.tools.jaotc.binformat.Symbol.Binding;\n-import jdk.tools.jaotc.binformat.Symbol.Kind;\n-\n-\/**\n- * Native function call, symbol is to a VM method.\n- *\/\n-final class ForeignCallSiteRelocationSymbol extends CallSiteRelocationSymbol {\n-\n-    ForeignCallSiteRelocationSymbol(CallSiteRelocationInfo callSiteRelocation, BinaryContainer binaryContainer) {\n-        super(binaryContainer.createSymbol(0, Kind.NATIVE_FUNCTION, Binding.GLOBAL, 0, callSiteRelocation.targetSymbol));\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/ForeignCallSiteRelocationSymbol.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import jdk.tools.jaotc.binformat.BinaryContainer;\n-import jdk.tools.jaotc.binformat.Symbol;\n-\n-import jdk.vm.ci.code.site.Call;\n-\n-final class ForeignGotCallSiteRelocationSymbol extends CallSiteRelocationSymbol {\n-\n-    ForeignGotCallSiteRelocationSymbol(CompiledMethodInfo mi, Call call, CallSiteRelocationInfo callSiteRelocation, DataBuilder dataBuilder) {\n-        super(createPltSymbol(dataBuilder, mi, call, callSiteRelocation));\n-    }\n-\n-    private static Symbol createPltSymbol(DataBuilder dataBuilder, CompiledMethodInfo mi, Call call, CallSiteRelocationInfo callSiteRelocation) {\n-        BinaryContainer binaryContainer = dataBuilder.getBinaryContainer();\n-        String vmSymbolName = callSiteRelocation.targetSymbol;\n-\n-        \/\/ Add relocation to GOT cell for call resolution jump.\n-        String pltSymbolName = \"plt.\" + vmSymbolName;\n-        Symbol pltSymbol = binaryContainer.getSymbol(pltSymbolName);\n-\n-        if (pltSymbol == null) {\n-            String gotSymbolName = \"got.\" + vmSymbolName;\n-            Symbol gotSymbol = binaryContainer.getGotSymbol(gotSymbolName);\n-            assert gotSymbol != null : \"undefined VM got symbol '\" + gotSymbolName + \"' for call at \" + call.pcOffset + \" in \" + mi.getMethodInfo().getSymbolName();\n-\n-            \/\/ Generate PLT jump (do it only once).\n-            final int pltStartOffset = binaryContainer.getCodeContainer().getByteStreamSize();\n-            final int pltEndOffset = pltStartOffset + addPltJump(dataBuilder);\n-\n-            \/\/ Link GOT cell to PLT jump.\n-            pltSymbol = createCodeContainerSymbol(binaryContainer, pltSymbolName, pltStartOffset);\n-            addExternalPltToGotRelocation(binaryContainer, gotSymbol, pltEndOffset);\n-        }\n-\n-        return pltSymbol;\n-    }\n-\n-    private static int addPltJump(DataBuilder dataBuilder) {\n-        ELFMacroAssembler masm = ELFMacroAssembler.getELFMacroAssembler(dataBuilder.getBackend().getTarget(), dataBuilder.getBackend().getRuntime().getOptions());\n-        byte[] code = masm.getPLTJumpCode(); \/\/ It includes alignment nops.\n-        int size = masm.currentEndOfInstruction();\n-        dataBuilder.getBinaryContainer().appendCodeBytes(code, 0, code.length);\n-        return size;\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/ForeignGotCallSiteRelocationSymbol.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,147 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import java.lang.annotation.Annotation;\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import org.graalvm.compiler.api.directives.GraalDirectives;\n-import org.graalvm.compiler.api.replacements.ClassSubstitution;\n-import org.graalvm.compiler.api.replacements.MethodSubstitution;\n-import org.graalvm.compiler.api.replacements.Snippet;\n-import org.graalvm.compiler.debug.GraalError;\n-import org.graalvm.compiler.graph.Node.NodeIntrinsic;\n-import org.graalvm.compiler.hotspot.replacements.HotSpotClassSubstitutions;\n-import org.graalvm.compiler.hotspot.word.MetaspacePointer;\n-import org.graalvm.compiler.replacements.Snippets;\n-import jdk.internal.vm.compiler.word.WordBase;\n-\n-import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;\n-import jdk.vm.ci.meta.MetaAccessProvider;\n-import jdk.vm.ci.meta.ResolvedJavaMethod;\n-import jdk.vm.ci.meta.ResolvedJavaType;\n-import jdk.vm.ci.hotspot.HotSpotConstantPool;\n-\n-final class GraalFilters {\n-    private List<ResolvedJavaType> specialClasses;\n-    private List<ResolvedJavaType> specialArgumentAndReturnTypes;\n-\n-    private static Set<Class<?>> skipAnnotations = new HashSet<>();\n-\n-    static {\n-        skipAnnotations.add(NodeIntrinsic.class);\n-        skipAnnotations.add(Snippet.class);\n-        skipAnnotations.add(MethodSubstitution.class);\n-    }\n-\n-    boolean shouldCompileMethod(ResolvedJavaMethod method) {\n-        \/\/ NodeIntrinsics cannot be compiled.\n-        if (hasExcludedAnnotation(method)) {\n-            return false;\n-        }\n-\n-        ResolvedJavaType declaringClass = method.getDeclaringClass();\n-        \/\/ Check for special magical types in the signature, like Word or MetaspacePointer. Those\n-        \/\/ are definitely snippets.\n-        List<ResolvedJavaType> signatureTypes = Arrays.asList(method.toParameterTypes()).stream().map(p -> p.resolve(declaringClass)).collect(Collectors.toList());\n-        signatureTypes.add(method.getSignature().getReturnType(null).resolve(declaringClass));\n-        if (signatureTypes.stream().flatMap(t -> specialArgumentAndReturnTypes.stream().filter(s -> s.isAssignableFrom(t))).findAny().isPresent()) {\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    private static boolean hasExcludedAnnotation(ResolvedJavaMethod method) {\n-        for (Annotation annotation : method.getAnnotations()) {\n-            if (skipAnnotations.contains(annotation.annotationType())) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    boolean shouldCompileAnyMethodInClass(ResolvedJavaType klass) {\n-        if (specialClasses.stream().filter(s -> s.isAssignableFrom(klass)).findAny().isPresent()) {\n-            return false;\n-        }\n-        \/\/ Skip klass with Condy until Graal is fixed.\n-        if (((HotSpotConstantPool) ((HotSpotResolvedObjectType) klass).getConstantPool()).hasDynamicConstant()) {\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    \/\/ Don't compile methods in classes and their subtypes that are in the list.\n-    private static List<ResolvedJavaType> getSpecialClasses(MetaAccessProvider meta) {\n-        \/\/ @formatter:off\n-        return Arrays.asList(meta.lookupJavaType(Snippets.class),\n-            meta.lookupJavaType(HotSpotClassSubstitutions.class),\n-            meta.lookupJavaType(GraalDirectives.class),\n-            meta.lookupJavaType(ClassSubstitution.class));\n-        \/\/ @formatter:on\n-    }\n-\n-    \/\/ Don't compile methods that have have the listed class or their subtypes in their signature.\n-    private static List<ResolvedJavaType> getSpecialArgumentAndReturnTypes(MetaAccessProvider meta) {\n-        \/\/ @formatter:off\n-        return Arrays.asList(meta.lookupJavaType(WordBase.class),\n-            meta.lookupJavaType(MetaspacePointer.class));\n-        \/\/ @formatter:on\n-    }\n-\n-    GraalFilters(MetaAccessProvider metaAccess) {\n-        specialClasses = getSpecialClasses(metaAccess);\n-        specialArgumentAndReturnTypes = getSpecialArgumentAndReturnTypes(metaAccess);\n-    }\n-\n-    static boolean shouldIgnoreException(Throwable e) {\n-        if (e instanceof GraalError) {\n-            String m = e.getMessage();\n-            if (m.contains(\"ArrayKlass::_component_mirror\")) {\n-                \/\/ When compiling Graal, ignore errors in JDK8 snippets.\n-                return true;\n-            }\n-        }\n-\n-        if (e instanceof org.graalvm.compiler.java.BytecodeParser.BytecodeParserError) {\n-            Throwable cause = e.getCause();\n-            if (cause instanceof GraalError) {\n-                String m = cause.getMessage();\n-                \/\/ When compiling Graal suppress attempts to compile snippet fragments that bottom\n-                \/\/ out with node intrinsics. These are unfortunately not explicitly marked, so we\n-                \/\/ have to try to compile them and bail out if we think it's a snippet.\n-                if (m.contains(\"@NodeIntrinsic method\") && m.contains(\"must only be called from within a replacement\")) {\n-                    return true;\n-                }\n-            }\n-        }\n-        return false;\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/GraalFilters.java","additions":0,"deletions":147,"binary":false,"changes":147,"status":"deleted"},{"patch":"@@ -1,149 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import jdk.tools.jaotc.binformat.BinaryContainer;\n-import jdk.tools.jaotc.binformat.Relocation;\n-import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage;\n-\n-import jdk.vm.ci.code.BytecodePosition;\n-import jdk.vm.ci.code.VirtualObject;\n-import jdk.vm.ci.code.site.Call;\n-import jdk.vm.ci.code.site.Infopoint;\n-import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;\n-import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;\n-import jdk.vm.ci.meta.InvokeTarget;\n-\n-final class InfopointProcessor {\n-\n-    private final DataBuilder dataBuilder;\n-\n-    private final BinaryContainer binaryContainer;\n-\n-    InfopointProcessor(DataBuilder dataBuilder) {\n-        this.dataBuilder = dataBuilder;\n-        this.binaryContainer = dataBuilder.getBinaryContainer();\n-    }\n-\n-    \/**\n-     * Parse an {@link Infopoint} generated by the compiler and create all needed binary section\n-     * constructs.\n-     *\n-     * @param methodInfo compiled method info\n-     * @param info info point being processed\n-     *\/\n-    void process(CompiledMethodInfo methodInfo, Infopoint info) {\n-        switch (info.reason) {\n-            case CALL:\n-                \/\/ All calls in compiled code need a symbol and relocation entry.\n-                processCallInfoPoint(methodInfo, (Call) info);\n-                break;\n-            case SAFEPOINT:\n-            case IMPLICIT_EXCEPTION:\n-            case METHOD_START:\n-            case METHOD_END:\n-            case BYTECODE_POSITION:\n-                break;\n-            default:\n-                throw new InternalError(\"Unknown info point reason: \" + info.reason);\n-        }\n-        if (info.debugInfo == null) {\n-            return;\n-        }\n-        BytecodePosition bcp = info.debugInfo.getBytecodePosition();\n-        if (bcp == null) {\n-            return;\n-        }\n-        recordScopeKlasses(methodInfo, bcp, info.debugInfo.getVirtualObjectMapping());\n-    }\n-\n-    private void recordScopeKlasses(CompiledMethodInfo methodInfo, BytecodePosition bcp, VirtualObject[] vos) {\n-        BytecodePosition caller = bcp.getCaller();\n-        if (caller != null) {\n-            recordScopeKlasses(methodInfo, caller, vos);\n-        }\n-\n-        HotSpotResolvedJavaMethod m = (HotSpotResolvedJavaMethod) bcp.getMethod();\n-        HotSpotResolvedObjectType klass = m.getDeclaringClass();\n-        methodInfo.addDependentKlassData(binaryContainer, klass);\n-\n-        if (vos == null) {\n-            return;\n-        }\n-        for (VirtualObject vo : vos) {\n-            HotSpotResolvedObjectType vk = (HotSpotResolvedObjectType) vo.getType();\n-            methodInfo.addDependentKlassData(binaryContainer, vk);\n-        }\n-\n-    }\n-\n-    \/**\n-     * Process Call info points in Graal generated compilation result. We want to create one of the\n-     * following relocations: .text -> .hotspot.plt.linkage - Java method to Java method call .text\n-     * -> .text - Java method \/ Graal stub to Graal stub call .text -> .plt - Java method \/ Graal\n-     * stub to VM method call.\n-     *\n-     * @param methodInfo compiled method info\n-     * @param call call\n-     *\/\n-    private void processCallInfoPoint(CompiledMethodInfo methodInfo, Call call) {\n-        CallSiteRelocationInfo callSiteRelocation = getCallSiteRelocationInfo(call);\n-        CallSiteRelocationSymbol callSiteRelocationSymbol = getCallSiteRelocationSymbol(methodInfo, call, callSiteRelocation);\n-\n-        Relocation relocation = new Relocation(methodInfo.getTextSectionOffset() + call.pcOffset, callSiteRelocation.type, call.size, binaryContainer.getCodeContainer(),\n-                        callSiteRelocationSymbol.symbol);\n-        binaryContainer.addRelocation(relocation);\n-    }\n-\n-    \/**\n-     * Get information about the call site. Name of the callee and relocation call type.\n-     *\/\n-    private static CallSiteRelocationInfo getCallSiteRelocationInfo(Call call) {\n-        InvokeTarget callTarget = call.target;\n-        if (callTarget instanceof HotSpotResolvedJavaMethod) {\n-            return new JavaCallSiteRelocationInfo(call, (HotSpotResolvedJavaMethod) callTarget);\n-        } else if (callTarget instanceof HotSpotForeignCallLinkage) {\n-            return new ForeignCallSiteRelocationInfo(call, (HotSpotForeignCallLinkage) callTarget);\n-        } else {\n-            throw new InternalError(\"Unhandled call type found in infopoint: \" + callTarget);\n-        }\n-    }\n-\n-    \/**\n-     * Return a relocation symbol for the given call site.\n-     *\/\n-    private CallSiteRelocationSymbol getCallSiteRelocationSymbol(CompiledMethodInfo mi, Call call, CallSiteRelocationInfo callSiteRelocation) {\n-        switch (callSiteRelocation.type) {\n-            case STUB_CALL_DIRECT:\n-                return new StubDirectCallSiteRelocationSymbol(callSiteRelocation, binaryContainer);\n-            case FOREIGN_CALL_INDIRECT_GOT:\n-                return new ForeignGotCallSiteRelocationSymbol(mi, call, callSiteRelocation, dataBuilder);\n-            default:\n-                return new JavaCallSiteRelocationSymbol(mi, call, callSiteRelocation, binaryContainer);\n-        }\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/InfopointProcessor.java","additions":0,"deletions":149,"binary":false,"changes":149,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import jdk.tools.jaotc.amd64.AMD64InstructionDecoder;\n-import jdk.tools.jaotc.aarch64.AArch64InstructionDecoder;\n-\n-import jdk.vm.ci.amd64.AMD64;\n-import jdk.vm.ci.aarch64.AArch64;\n-import jdk.vm.ci.code.Architecture;\n-import jdk.vm.ci.code.TargetDescription;\n-\n-public abstract class InstructionDecoder {\n-\n-    public static InstructionDecoder getInstructionDecoder(TargetDescription target) {\n-        Architecture architecture = target.arch;\n-        if (architecture instanceof AMD64) {\n-            return new AMD64InstructionDecoder(target);\n-        } else if (architecture instanceof AArch64) {\n-            return new AArch64InstructionDecoder();\n-        } else {\n-            throw new InternalError(\"Unsupported architecture \" + architecture);\n-        }\n-    }\n-\n-    public abstract void decodePosition(byte[] code, int pcOffset);\n-\n-    public abstract int currentEndOfInstruction();\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/InstructionDecoder.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import jdk.tools.jaotc.binformat.Relocation.RelocType;\n-\n-import jdk.vm.ci.code.site.Call;\n-import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;\n-\n-\/**\n- * This is a Java call site. Get the Java method name and correct call relocation type. All static\n- * Java calls should be direct. All virtual Java calls should be indirect.\n- *\/\n-final class JavaCallSiteRelocationInfo extends CallSiteRelocationInfo {\n-\n-    JavaCallSiteRelocationInfo(Call call, HotSpotResolvedJavaMethod callTarget) {\n-        super(JavaMethodInfo.uniqueMethodName(callTarget), call.direct ? RelocType.JAVA_CALL_DIRECT : RelocType.JAVA_CALL_INDIRECT);\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/JavaCallSiteRelocationInfo.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,155 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import org.graalvm.compiler.hotspot.HotSpotMarkId;\n-\n-import jdk.tools.jaotc.binformat.BinaryContainer;\n-import jdk.tools.jaotc.binformat.Symbol;\n-import jdk.vm.ci.code.site.Call;\n-import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;\n-\n-\/**\n- * Symbol for a regular Java call. This method also creates additional relocations for {@code .plt}\n- * to {@code .got} and {@code .got} to {@code .plt}.\n- *\/\n-final class JavaCallSiteRelocationSymbol extends CallSiteRelocationSymbol {\n-\n-    private static final byte[] zeroSlot = new byte[8];\n-    \/\/ -1 represents Universe::non_oop_word() value\n-    private static final byte[] minusOneSlot;\n-\n-    static {\n-        String archStr = System.getProperty(\"os.arch\").toLowerCase();\n-        if (archStr.equals(\"aarch64\")) {\n-            \/\/ AArch64 is a special case: it uses 48-bit addresses.\n-            byte[] nonOopWord = {-1, -1, -1, -1, -1, -1, 0, 0};\n-            minusOneSlot = nonOopWord;\n-        } else {\n-            byte[] nonOopWord = {-1, -1, -1, -1, -1, -1, -1, -1};\n-            minusOneSlot = nonOopWord;\n-        }\n-    }\n-\n-    JavaCallSiteRelocationSymbol(CompiledMethodInfo mi, Call call, CallSiteRelocationInfo callSiteRelocation, BinaryContainer binaryContainer) {\n-        super(createPltEntrySymbol(binaryContainer, mi, call, callSiteRelocation));\n-        StubInformation stub = getStub(mi, call);\n-        addRelocations(mi, stub, binaryContainer, call, callSiteRelocation);\n-    }\n-\n-    \/**\n-     * Returns a unique symbol name with the {@code suffix} appended.\n-     *\/\n-    private static String relocationSymbolName(String suffix, CompiledMethodInfo mi, Call call, CallSiteRelocationInfo callSiteRelocation) {\n-        return \"M\" + mi.getCodeId() + \"_\" + call.pcOffset + \"_\" + callSiteRelocation.targetSymbol + \"_\" + suffix;\n-    }\n-\n-    private static Symbol createPltEntrySymbol(BinaryContainer binaryContainer, CompiledMethodInfo mi, Call call, CallSiteRelocationInfo callSiteRelocation) {\n-        String symbolName = relocationSymbolName(\"plt.entry\", mi, call, callSiteRelocation);\n-        StubInformation stub = getStub(mi, call);\n-        return createCodeContainerSymbol(binaryContainer, symbolName, stub.getOffset());\n-    }\n-\n-    private static StubInformation getStub(CompiledMethodInfo mi, Call call) {\n-        HotSpotResolvedJavaMethod callTarget = (HotSpotResolvedJavaMethod) call.target;\n-        String callTargetSymbol = JavaMethodInfo.uniqueMethodName(callTarget) + \".at.\" + call.pcOffset;\n-        return mi.getStubFor(callTargetSymbol);\n-    }\n-\n-    \/**\n-     * Add all the required relocations.\n-     *\/\n-    private static void addRelocations(CompiledMethodInfo mi, StubInformation stub, BinaryContainer binaryContainer, Call call, CallSiteRelocationInfo callSiteRelocation) {\n-        final boolean isVirtualCall = CallInfo.isVirtualCall(mi, call);\n-\n-        final int gotStartOffset = binaryContainer.appendExtLinkageGotBytes(zeroSlot, 0, zeroSlot.length);\n-        if (isVirtualCall) {\n-            \/\/ Nothing.\n-        } else {\n-            \/\/ For c2i stub we need slot with -1 value.\n-            binaryContainer.appendExtLinkageGotBytes(minusOneSlot, 0, minusOneSlot.length);\n-        }\n-\n-        \/\/ Add relocation to GOT cell for call resolution jump.\n-        \/\/ This GOT cell will be initialized during JVM startup with address\n-        \/\/ of JVM runtime call resolution function.\n-        String gotSymbolName = \"got.\" + getResolveSymbolName(mi, call);\n-        Symbol gotSymbol = binaryContainer.getGotSymbol(gotSymbolName);\n-        addExternalPltToGotRelocation(binaryContainer, gotSymbol, stub.getResolveJumpOffset());\n-\n-        \/\/ Add relocation to resolve call jump instruction address for GOT cell.\n-        \/\/ This GOT cell will be initialized with address of resolution jump instruction and\n-        \/\/ will be updated with call destination address by JVM runtime call resolution code.\n-        String pltJmpSymbolName = relocationSymbolName(\"plt.jmp\", mi, call, callSiteRelocation);\n-        addCodeContainerRelocation(binaryContainer, pltJmpSymbolName, stub.getResolveJumpStart(), gotStartOffset);\n-\n-        \/\/ Add relocation to GOT cell for dispatch jump.\n-        \/\/ The dispatch jump loads destination address from this GOT cell.\n-        String gotEntrySymbolName = relocationSymbolName(\"got.entry\", mi, call, callSiteRelocation);\n-        addExtLinkageGotContainerRelocation(binaryContainer, gotEntrySymbolName, gotStartOffset, stub.getDispatchJumpOffset());\n-\n-        \/\/ Virtual call needs initial -1 value for Klass pointer.\n-        \/\/ Non virtual call needs initial 0 value for Method pointer to call c2i adapter.\n-        byte[] slot = isVirtualCall ? minusOneSlot : zeroSlot;\n-        final int gotMetaOffset = binaryContainer.appendExtLinkageGotBytes(slot, 0, slot.length);\n-\n-        \/\/ Add relocation to GOT cell for move instruction (Klass* for virtual, Method* otherwise).\n-        String gotMoveSymbolName = relocationSymbolName(\"got.move\", mi, call, callSiteRelocation);\n-        addExtLinkageGotContainerRelocation(binaryContainer, gotMoveSymbolName, gotMetaOffset, stub.getMovOffset());\n-\n-        if (isVirtualCall) {\n-            \/\/ Nothing.\n-        } else {\n-            \/\/ Add relocation to GOT cell for c2i adapter jump.\n-            \/\/ The c2i jump instruction loads destination address from this GOT cell.\n-            \/\/ This GOT cell is initialized with -1 and will be updated\n-            \/\/ by JVM runtime call resolution code.\n-            String gotC2ISymbolName = relocationSymbolName(\"got.c2i\", mi, call, callSiteRelocation);\n-            addExtLinkageGotContainerRelocation(binaryContainer, gotC2ISymbolName, gotStartOffset + 8, stub.getC2IJumpOffset());\n-        }\n-    }\n-\n-    \/**\n-     * Returns the name of the resolve method for this particular call.\n-     *\/\n-    private static String getResolveSymbolName(CompiledMethodInfo mi, Call call) {\n-        String resolveSymbolName;\n-        if (CallInfo.isStaticCall(call)) {\n-            assert mi.hasMark(call, HotSpotMarkId.INVOKESTATIC);\n-            resolveSymbolName = BinaryContainer.getResolveStaticEntrySymbolName();\n-        } else if (CallInfo.isSpecialCall(call)) {\n-            resolveSymbolName = BinaryContainer.getResolveOptVirtualEntrySymbolName();\n-        } else if (CallInfo.isOptVirtualCall(mi, call)) {\n-            resolveSymbolName = BinaryContainer.getResolveOptVirtualEntrySymbolName();\n-        } else if (CallInfo.isVirtualCall(mi, call)) {\n-            resolveSymbolName = BinaryContainer.getResolveVirtualEntrySymbolName();\n-        } else {\n-            throw new InternalError(\"Unknown call type in \" + mi.asTag() + \" @ \" + call.pcOffset + \" for call\" + call.target);\n-        }\n-        return resolveSymbolName;\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/JavaCallSiteRelocationSymbol.java","additions":0,"deletions":155,"binary":false,"changes":155,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import org.graalvm.compiler.code.CompilationResult;\n-\n-import jdk.vm.ci.hotspot.HotSpotCompiledCode;\n-import jdk.vm.ci.meta.ResolvedJavaMethod;\n-\n-interface JavaMethodInfo {\n-\n-    \/**\n-     * @return unique symbol name for this method.\n-     *\/\n-    String getSymbolName();\n-\n-    \/**\n-     * Name a java method with J.L.S. class name and signature.\n-     *\n-     * @return unique name for this method including class and signature\n-     *\/\n-    String getNameAndSignature();\n-\n-    HotSpotCompiledCode compiledCode(CompilationResult result);\n-\n-    \/**\n-     * Name a java method with class and signature to make it unique.\n-     *\n-     * @param method to generate unique identifier for\n-     * @return Unique name for this method including class and signature\n-     **\/\n-    static String uniqueMethodName(ResolvedJavaMethod method) {\n-        String className = method.getDeclaringClass().toClassName();\n-        String name = className + \".\" + method.getName() + method.getSignature().toMethodDescriptor();\n-        return name;\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/JavaMethodInfo.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -1,261 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import java.io.BufferedReader;\n-import java.io.File;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.List;\n-import java.util.stream.Stream;\n-\n-final class Linker {\n-\n-    private final Options options;\n-    private String objectFileName;\n-    private String libraryFileName;\n-    private String linkerCmd;\n-\n-    String objFile() {\n-        return objectFileName;\n-    }\n-\n-    String libFile() {\n-        return libraryFileName;\n-    }\n-\n-    private static Stream<String> getLines(InputStream stream) {\n-        return new BufferedReader(new InputStreamReader(stream)).lines();\n-    }\n-\n-    private static String getString(InputStream stream) {\n-        Stream<String> lines = getLines(stream);\n-        StringBuilder sb = new StringBuilder();\n-        lines.iterator().forEachRemaining(e -> sb.append(e));\n-        return sb.toString();\n-    }\n-\n-    Linker(Main main) throws Exception {\n-        this.options = main.options;\n-        String name = options.outputName;\n-        objectFileName = name;\n-        libraryFileName = name;\n-\n-        if (options.linkerpath != null && !(new File(options.linkerpath).exists())) {\n-            throw new InternalError(\"Invalid linker path: \" + options.linkerpath);\n-        }\n-        String linkerPath;\n-        String linkerCheck;\n-\n-        switch (options.osName) {\n-            case \"Linux\":\n-                if (name.endsWith(\".so\")) {\n-                    objectFileName = name.substring(0, name.length() - \".so\".length());\n-                }\n-                objectFileName = objectFileName + \".o\";\n-                linkerPath = (options.linkerpath != null) ? options.linkerpath : \"ld\";\n-                linkerCmd = linkerPath + \" -shared -z noexecstack -o \" + libraryFileName + \" \" + objectFileName;\n-                linkerCheck = linkerPath + \" -v\";\n-                break;\n-            case \"Mac OS X\":\n-                if (name.endsWith(\".dylib\")) {\n-                    objectFileName = name.substring(0, name.length() - \".dylib\".length());\n-                }\n-                objectFileName = objectFileName + \".o\";\n-                linkerPath = (options.linkerpath != null) ? options.linkerpath : \"ld\";\n-                linkerCmd = linkerPath + \" -dylib -o \" + libraryFileName + \" \" + objectFileName;\n-                linkerCheck = linkerPath + \" -v\";\n-                break;\n-            default:\n-                if (options.osName.startsWith(\"Windows\")) {\n-                    if (name.endsWith(\".dll\")) {\n-                        objectFileName = name.substring(0, name.length() - \".dll\".length());\n-                    }\n-                    objectFileName = objectFileName + \".obj\";\n-                    linkerPath = (options.linkerpath != null) ? options.linkerpath : getWindowsLinkPath(main);\n-                    if (linkerPath == null) {\n-                        throw new InternalError(\"Can't locate Microsoft Visual Studio amd64 link.exe\");\n-                    }\n-                    linkerCmd = linkerPath + \" \/DLL \/OPT:NOREF \/NOLOGO \/NOENTRY\" + \" \/OUT:\" + libraryFileName + \" \" + objectFileName;\n-                    linkerCheck = null; \/\/ link.exe presence is verified already\n-                    break;\n-                } else {\n-                    throw new InternalError(\"Unsupported platform: \" + options.osName);\n-                }\n-        }\n-\n-        \/\/ Check linker presence on platforms by printing its version\n-        if (linkerCheck != null) {\n-            Process p = Runtime.getRuntime().exec(linkerCheck);\n-            final int exitCode = p.waitFor();\n-            if (exitCode != 0) {\n-                throw new InternalError(getString(p.getErrorStream()));\n-            }\n-        }\n-\n-        main.printer.printlnVerbose(\"Found linker: \" + linkerPath);\n-    }\n-\n-    void link() throws Exception {\n-        Process p = Runtime.getRuntime().exec(linkerCmd);\n-        final int exitCode = p.waitFor();\n-        if (exitCode != 0) {\n-            String errorMessage = getString(p.getErrorStream());\n-            if (errorMessage.isEmpty()) {\n-                errorMessage = getString(p.getInputStream());\n-            }\n-            throw new InternalError(errorMessage);\n-        }\n-        File objFile = new File(objectFileName);\n-        boolean keepObjFile = Boolean.parseBoolean(System.getProperty(\"aot.keep.objFile\", \"false\"));\n-        if (objFile.exists() && !keepObjFile) {\n-            if (!objFile.delete()) {\n-                throw new InternalError(\"Failed to delete \" + objectFileName + \" file\");\n-            }\n-        }\n-        \/\/ Make non-executable for all.\n-        File libFile = new File(libraryFileName);\n-        if (libFile.exists() && !options.osName.startsWith(\"Windows\")) {\n-            if (!libFile.setExecutable(false, false)) {\n-                throw new InternalError(\"Failed to change attribute for \" + libraryFileName + \" file\");\n-            }\n-        }\n-\n-    }\n-\n-    \/**\n-     * Search for Visual Studio link.exe Search Order is: VS2017+, VS2013, VS2015, VS2012.\n-     *\/\n-    private static String getWindowsLinkPath(Main main) throws Exception {\n-        try {\n-            Path vc141NewerLinker = getVC141AndNewerLinker();\n-            if (vc141NewerLinker != null) {\n-                return vc141NewerLinker.toString();\n-            }\n-        } catch (Exception e) {\n-            main.printer.printlnVerbose(\"Could not find VC14 or newer version of linker: \" + e.getMessage());\n-            if (main.options.debug) {\n-                e.printStackTrace();\n-            }\n-        }\n-\n-        String link = \"\\\\VC\\\\bin\\\\amd64\\\\link.exe\";\n-\n-        \/**\n-         * First try searching the paths pointed to by the VS environment variables.\n-         *\/\n-        for (VSVERSIONS vs : VSVERSIONS.values()) {\n-            String vspath = System.getenv(vs.getEnvVariable());\n-            if (vspath != null) {\n-                File commonTools = new File(vspath);\n-                File vsRoot = commonTools.getParentFile().getParentFile();\n-                File linkPath = new File(vsRoot, link);\n-                if (linkPath.exists()) {\n-                    return linkPath.getPath();\n-                }\n-            }\n-        }\n-\n-        \/**\n-         * If we didn't find via the VS environment variables, try the well known paths\n-         *\/\n-        for (VSVERSIONS vs : VSVERSIONS.values()) {\n-            String wkp = vs.getWellKnownPath();\n-            if (new File(wkp).exists()) {\n-                return wkp;\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    private static Path getVC141AndNewerLinker() throws Exception {\n-        String programFilesX86 = System.getenv(\"ProgramFiles(x86)\");\n-        if (programFilesX86 == null) {\n-            throw new IllegalStateException(\"Could not read the ProgramFiles(x86) environment variable\");\n-        }\n-        String vswherePath = programFilesX86 + \"\\\\Microsoft Visual Studio\\\\Installer\\\\vswhere.exe\";\n-        Path vswhere = Paths.get(vswherePath);\n-        if (!Files.exists(vswhere)) {\n-            throw new IllegalStateException(\"Could not find \" + vswherePath);\n-        }\n-\n-        ProcessBuilder processBuilder = new ProcessBuilder(vswhere.toString(), \"-requires\",\n-                        \"Microsoft.VisualStudio.Component.VC.Tools.x86.x64\", \"-property\", \"installationPath\", \"-latest\");\n-        processBuilder.redirectOutput(ProcessBuilder.Redirect.PIPE);\n-        processBuilder.redirectError(ProcessBuilder.Redirect.PIPE);\n-        Process process = processBuilder.start();\n-        final int exitCode = process.waitFor();\n-        if (exitCode != 0) {\n-            String errorMessage = getString(process.getErrorStream());\n-            if (errorMessage.isEmpty()) {\n-                errorMessage = getString(process.getInputStream());\n-            }\n-            throw new IllegalStateException(\"vswhere error: \" + errorMessage);\n-        }\n-\n-        String installationPath = getLines(process.getInputStream()).findFirst().orElseThrow(() -> new IllegalStateException(\"Unexpected empty output from vswhere\"));\n-        Path vcToolsVersionFilePath = Paths.get(installationPath, \"VC\\\\Auxiliary\\\\Build\\\\Microsoft.VCToolsVersion.default.txt\");\n-        List<String> vcToolsVersionFileLines = Files.readAllLines(vcToolsVersionFilePath);\n-        if (vcToolsVersionFileLines.isEmpty()) {\n-            throw new IllegalStateException(vcToolsVersionFilePath.toString() + \" is empty\");\n-        }\n-        String vcToolsVersion = vcToolsVersionFileLines.get(0);\n-        Path linkPath = Paths.get(installationPath, \"VC\\\\Tools\\\\MSVC\", vcToolsVersion, \"bin\\\\Hostx64\\\\x64\\\\link.exe\");\n-        if (!Files.exists(linkPath)) {\n-            throw new IllegalStateException(\"Linker at path \" + linkPath.toString() + \" does not exist\");\n-        }\n-\n-        return linkPath;\n-    }\n-\n-    \/\/ @formatter:off (workaround for Eclipse formatting bug)\n-    enum VSVERSIONS {\n-        VS2013(\"VS120COMNTOOLS\", \"C:\\\\Program Files (x86)\\\\Microsoft Visual Studio 12.0\\\\VC\\\\bin\\\\amd64\\\\link.exe\"),\n-        VS2015(\"VS140COMNTOOLS\", \"C:\\\\Program Files (x86)\\\\Microsoft Visual Studio 14.0\\\\VC\\\\bin\\\\amd64\\\\link.exe\"),\n-        VS2012(\"VS110COMNTOOLS\", \"C:\\\\Program Files (x86)\\\\Microsoft Visual Studio 11.0\\\\VC\\\\bin\\\\amd64\\\\link.exe\");\n-\n-        private final String envvariable;\n-        private final String wkp;\n-\n-        VSVERSIONS(String envvariable, String wellknownpath) {\n-            this.envvariable = envvariable;\n-            this.wkp = wellknownpath;\n-        }\n-\n-        String getEnvVariable() {\n-            return envvariable;\n-        }\n-\n-        String getWellKnownPath() {\n-            return wkp;\n-        }\n-    }\n-    \/\/ @formatter:on\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/Linker.java","additions":0,"deletions":261,"binary":false,"changes":261,"status":"deleted"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-public class LoadedClass {\n-    private final String name;\n-    private final Class<?> clz;\n-\n-    public LoadedClass(String name, Class<?> clz) {\n-        this.name = name;\n-        this.clz = clz;\n-    }\n-\n-    public String getName() {\n-        return name;\n-    }\n-\n-    public Class<?> getLoadedClass() {\n-        return clz;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return name;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (!(o instanceof LoadedClass)) {\n-            return false;\n-        }\n-        LoadedClass that = (LoadedClass) o;\n-\n-        if (name != null ? !name.equals(that.name) : that.name != null) {\n-            return false;\n-        }\n-        return clz != null ? clz.equals(that.clz) : that.clz == null;\n-\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        int result = name != null ? name.hashCode() : 0;\n-        result = 31 * result + (clz != null ? clz.hashCode() : 0);\n-        return result;\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/LoadedClass.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -1,198 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import java.io.FileWriter;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.lang.management.ManagementFactory;\n-import java.lang.management.MemoryUsage;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.text.MessageFormat;\n-import java.util.Date;\n-\n-import jdk.tools.jaotc.binformat.ByteContainer;\n-import jdk.tools.jaotc.binformat.BinaryContainer;\n-\n-final class LogPrinter {\n-\n-    private static FileWriter logFile = null;\n-    private final Options options;\n-    private final PrintWriter log;\n-\n-    LogPrinter(Main main, PrintWriter log) {\n-        this.options = main.options;\n-        this.log = log;\n-    }\n-\n-    void printInfo(String message) {\n-        if (options.info) {\n-            log.print(message);\n-            log.flush();\n-        }\n-    }\n-\n-    void printlnInfo(String message) {\n-        if (options.info) {\n-            log.println(message);\n-            log.flush();\n-        }\n-    }\n-\n-    void printVerbose(String message) {\n-        if (options.verbose) {\n-            log.print(message);\n-            log.flush();\n-        }\n-    }\n-\n-    void printlnVerbose(String message) {\n-        if (options.verbose) {\n-            log.println(message);\n-            log.flush();\n-        }\n-    }\n-\n-    void printDebug(String message) {\n-        if (options.debug) {\n-            log.print(message);\n-            log.flush();\n-        }\n-    }\n-\n-    void printlnDebug(String message) {\n-        if (options.debug) {\n-            log.println(message);\n-            log.flush();\n-        }\n-    }\n-\n-    void printError(String message) {\n-        log.println(\"Error: \" + message);\n-        log.flush();\n-    }\n-\n-    void reportError(Throwable e) {\n-        log.println(\"Error: \" + e.getMessage());\n-        if (options.info) {\n-            e.printStackTrace(log);\n-        }\n-        log.flush();\n-    }\n-\n-    void reportError(String key, Object... args) {\n-        printError(MessageFormat.format(key, args));\n-    }\n-\n-    private static String humanReadableByteCount(long bytes) {\n-        int unit = 1024;\n-\n-        if (bytes < unit) {\n-            return bytes + \" B\";\n-        }\n-\n-        int exp = (int) (Math.log(bytes) \/ Math.log(unit));\n-        char pre = \"KMGTPE\".charAt(exp - 1);\n-        return String.format(\"%.1f %cB\", bytes \/ Math.pow(unit, exp), pre);\n-    }\n-\n-    void printMemoryUsage() {\n-        if (options.verbose) {\n-            MemoryUsage memusage = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage();\n-            float freeratio = 1f - (float) memusage.getUsed() \/ memusage.getCommitted();\n-            log.format(\" [used: %-7s, comm: %-7s, freeRatio ~= %.1f%%]\",\n-                            humanReadableByteCount(memusage.getUsed()),\n-                            humanReadableByteCount(memusage.getCommitted()),\n-                            freeratio * 100);\n-        }\n-    }\n-\n-    private void printContainerInfo(ByteContainer container) {\n-        printlnVerbose(container.getContainerName() + \": \" + container.getByteStreamSize() + \" bytes\");\n-    }\n-\n-    void containersInfo(BinaryContainer binaryContainer) {\n-        printContainerInfo(binaryContainer.getHeaderContainer().getContainer());\n-        printContainerInfo(binaryContainer.getConfigContainer());\n-        printContainerInfo(binaryContainer.getKlassesOffsetsContainer());\n-        printContainerInfo(binaryContainer.getMethodsOffsetsContainer());\n-        printContainerInfo(binaryContainer.getKlassesDependenciesContainer());\n-        printContainerInfo(binaryContainer.getStubsOffsetsContainer());\n-        printContainerInfo(binaryContainer.getMethodMetadataContainer());\n-        printContainerInfo(binaryContainer.getCodeContainer());\n-        printContainerInfo(binaryContainer.getCodeSegmentsContainer());\n-        printContainerInfo(binaryContainer.getConstantDataContainer());\n-        printContainerInfo(binaryContainer.getKlassesGotContainer());\n-        printContainerInfo(binaryContainer.getCountersGotContainer());\n-        printContainerInfo(binaryContainer.getMetadataGotContainer());\n-        printContainerInfo(binaryContainer.getMethodStateContainer());\n-        printContainerInfo(binaryContainer.getOopGotContainer());\n-        printContainerInfo(binaryContainer.getMetaspaceNamesContainer());\n-    }\n-\n-    static void openLog() {\n-        int v = Integer.getInteger(\"jdk.tools.jaotc.logCompilation\", 0);\n-        if (v == 0) {\n-            logFile = null;\n-            return;\n-        }\n-        \/\/ Create log file in current directory\n-        String fileName = \"aot_compilation\" + new Date().getTime() + \".log\";\n-        Path logFilePath = Paths.get(\".\/\", fileName);\n-        String logFileName = logFilePath.toString();\n-        try {\n-            \/\/ Create file to which we do not append\n-            logFile = new FileWriter(logFileName, false);\n-        } catch (IOException e) {\n-            System.out.println(\"Unable to open logfile :\" + logFileName + \"\\nNo logs will be created\");\n-            logFile = null;\n-        }\n-    }\n-\n-    static void writeLog(String str) {\n-        if (logFile != null) {\n-            try {\n-                logFile.write(str + \"\\n\");\n-                logFile.flush();\n-            } catch (IOException e) {\n-                \/\/ Print to console\n-                System.out.println(str + \"\\n\");\n-            }\n-        }\n-    }\n-\n-    static void closeLog() {\n-        if (logFile != null) {\n-            try {\n-                logFile.close();\n-            } catch (IOException e) {\n-                \/\/ Do nothing\n-            }\n-        }\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/LogPrinter.java","additions":0,"deletions":198,"binary":false,"changes":198,"status":"deleted"},{"patch":"@@ -1,356 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;\n-import static org.graalvm.compiler.core.common.GraalOptions.ImmutableCode;\n-import static org.graalvm.compiler.hotspot.meta.HotSpotAOTProfilingPlugin.Options.TieredAOT;\n-\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n-import java.text.MessageFormat;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.ListIterator;\n-import java.util.Set;\n-import java.util.StringTokenizer;\n-import java.util.stream.Stream;\n-\n-import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;\n-import org.graalvm.compiler.api.runtime.GraalJVMCICompiler;\n-import org.graalvm.compiler.debug.DebugContext;\n-import org.graalvm.compiler.debug.DebugContext.Activation;\n-import org.graalvm.compiler.debug.DebugContext.Builder;\n-import org.graalvm.compiler.hotspot.CompilerConfigurationFactory;\n-import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;\n-import org.graalvm.compiler.hotspot.HotSpotGraalCompilerFactory;\n-import org.graalvm.compiler.hotspot.HotSpotGraalOptionValues;\n-import org.graalvm.compiler.hotspot.HotSpotGraalRuntime;\n-import org.graalvm.compiler.hotspot.HotSpotGraalRuntime.HotSpotGC;\n-import org.graalvm.compiler.hotspot.HotSpotHostBackend;\n-import org.graalvm.compiler.hotspot.HotSpotMarkId;\n-import org.graalvm.compiler.hotspot.meta.HotSpotInvokeDynamicPlugin;\n-import org.graalvm.compiler.java.GraphBuilderPhase;\n-import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;\n-import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;\n-import org.graalvm.compiler.options.OptionValues;\n-import org.graalvm.compiler.phases.BasePhase;\n-import org.graalvm.compiler.phases.PhaseSuite;\n-import org.graalvm.compiler.phases.tiers.HighTierContext;\n-import org.graalvm.compiler.printer.GraalDebugHandlersFactory;\n-import org.graalvm.compiler.runtime.RuntimeProvider;\n-\n-import jdk.tools.jaotc.Options.Option;\n-import jdk.tools.jaotc.binformat.BinaryContainer;\n-import jdk.vm.ci.meta.MetaAccessProvider;\n-import jdk.vm.ci.meta.ResolvedJavaMethod;\n-import jdk.vm.ci.runtime.JVMCI;\n-\n-public final class Main {\n-\n-    final Options options = new Options();\n-    private PrintWriter log;\n-    LogPrinter printer;\n-    GraalFilters filters;\n-\n-    private static final int EXIT_OK = 0;        \/\/ No errors.\n-    private static final int EXIT_CMDERR = 2;    \/\/ Bad command-line arguments and\/or switches.\n-    private static final int EXIT_ABNORMAL = 4;  \/\/ Terminated abnormally.\n-\n-    private static final String PROGNAME = \"jaotc\";\n-\n-    private static final String JVM_VERSION = System.getProperty(\"java.runtime.version\");\n-\n-    public static void main(String[] args) throws Exception {\n-        Main t = new Main();\n-        final int exitCode = t.run(parse(args));\n-        System.exit(exitCode);\n-    }\n-\n-    \/**\n-     * Expands '@file' in command line arguments by replacing '@file' with the content of 'file'\n-     * parsed by StringTokenizer. '@' character can be quoted as '@@'.\n-     *\/\n-    private static String[] parse(String[] args) throws IOException {\n-        List<String> result = new ArrayList<>();\n-        for (String arg : args) {\n-            if (arg.length() > 1 && arg.charAt(0) == '@') {\n-                String v = arg.substring(1);\n-                if (v.charAt(0) == '@') {\n-                    result.add(v);\n-                } else {\n-                    try (Stream<String> file = Files.lines(Paths.get(v))) {\n-                        file.map(StringTokenizer::new).map(Collections::list).flatMap(l -> l.stream().map(o -> (String) o)).forEachOrdered(result::add);\n-                    }\n-                }\n-            } else {\n-                result.add(arg);\n-            }\n-        }\n-        return result.toArray(String[]::new);\n-    }\n-\n-    private int run(String[] args) {\n-        log = new PrintWriter(System.out);\n-        printer = new LogPrinter(this, log);\n-\n-        try {\n-            Options.handleOptions(this, args);\n-            if (options.help) {\n-                showHelp();\n-                return EXIT_OK;\n-            }\n-            if (options.version) {\n-                showVersion();\n-                return EXIT_OK;\n-            }\n-\n-            printer.printlnInfo(\"Compiling \" + options.outputName + \"...\");\n-            final long start = System.currentTimeMillis();\n-            if (!run()) {\n-                return EXIT_ABNORMAL;\n-            }\n-            final long end = System.currentTimeMillis();\n-            printer.printlnInfo(\"Total time: \" + (end - start) + \" ms\");\n-\n-            return EXIT_OK;\n-        } catch (Options.BadArgs e) {\n-            printer.reportError(e.key, e.args);\n-            if (e.showUsage) {\n-                showUsage();\n-            }\n-            return EXIT_CMDERR;\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-            return EXIT_ABNORMAL;\n-        } finally {\n-            log.flush();\n-        }\n-    }\n-\n-    @SuppressWarnings(\"try\")\n-    private boolean run() throws Exception {\n-        LogPrinter.openLog();\n-\n-        try {\n-\n-            final Linker linker = new Linker(this);\n-            final String objectFileName = linker.objFile();\n-            final Collector collector = new Collector(this);\n-            Set<Class<?>> classesToCompile;\n-\n-            try (Timer t = new Timer(this, \"\")) {\n-                classesToCompile = collector.collectClassesToCompile();\n-                printer.printInfo(classesToCompile.size() + \" classes found\");\n-            }\n-\n-            OptionValues graalOptions = HotSpotGraalOptionValues.defaultOptions();\n-            \/\/ Setting -Dgraal.TieredAOT overrides --compile-for-tiered\n-            if (!TieredAOT.hasBeenSet(graalOptions)) {\n-                graalOptions = new OptionValues(graalOptions, TieredAOT, options.tiered);\n-            }\n-            graalOptions = new OptionValues(graalOptions, GeneratePIC, true, ImmutableCode, true);\n-            GraalJVMCICompiler graalCompiler = HotSpotGraalCompilerFactory.createCompiler(\"JAOTC\", JVMCI.getRuntime(), graalOptions, CompilerConfigurationFactory.selectFactory(null, graalOptions));\n-            HotSpotGraalRuntime runtime = (HotSpotGraalRuntime) graalCompiler.getGraalRuntime();\n-            GraalHotSpotVMConfig graalHotSpotVMConfig = runtime.getVMConfig();\n-\n-            if (graalHotSpotVMConfig.verifyOops) {\n-                if (!HotSpotMarkId.VERIFY_OOPS.isAvailable() || !HotSpotMarkId.VERIFY_OOP_COUNT_ADDRESS.isAvailable()) {\n-                    System.err.println(\"Running jaotc with -XX:+VerifyOops is not supported by this JDK\");\n-                    return false;\n-                }\n-            }\n-\n-            HotSpotHostBackend backend = (HotSpotHostBackend) runtime.getCapability(RuntimeProvider.class).getHostBackend();\n-            MetaAccessProvider metaAccess = backend.getProviders().getMetaAccess();\n-            filters = new GraalFilters(metaAccess);\n-\n-            List<AOTCompiledClass> classes;\n-\n-            try (Timer t = new Timer(this, \"\")) {\n-                classes = collector.collectMethodsToCompile(classesToCompile, metaAccess);\n-            }\n-\n-            \/\/ Free memory!\n-            try (Timer t = options.verbose ? new Timer(this, \"Freeing memory\") : null) {\n-                printer.printMemoryUsage();\n-                classesToCompile = null;\n-                System.gc();\n-            }\n-\n-            AOTDynamicTypeStore dynoStore = new AOTDynamicTypeStore();\n-            AOTCompiledClass.setDynamicTypeStore(dynoStore);\n-\n-            \/\/ AOTBackend aotBackend = new AOTBackend(this, graalOptions, backend, new\n-            \/\/ HotSpotInvokeDynamicPlugin(dynoStore));\n-            \/\/ Temporary workaround until JDK-8223533 is fixed.\n-            \/\/ Disable invokedynamic support.\n-            var indyPlugin = new HotSpotInvokeDynamicPlugin(dynoStore) {\n-                @Override\n-                public boolean supportsDynamicInvoke(GraphBuilderContext builder, int index, int opcode) {\n-                    return false;\n-                }\n-            };\n-\n-            AOTBackend aotBackend = new AOTBackend(this, graalOptions, backend, indyPlugin);\n-            SnippetReflectionProvider snippetReflection = aotBackend.getProviders().getSnippetReflection();\n-            AOTCompiler compiler = new AOTCompiler(this, graalOptions, aotBackend, options.threads);\n-            classes = compiler.compileClasses(classes);\n-\n-            PhaseSuite<HighTierContext> graphBuilderSuite = aotBackend.getGraphBuilderSuite();\n-            ListIterator<BasePhase<? super HighTierContext>> iterator = graphBuilderSuite.findPhase(GraphBuilderPhase.class);\n-            GraphBuilderConfiguration graphBuilderConfig = ((GraphBuilderPhase) iterator.previous()).getGraphBuilderConfig();\n-\n-            \/\/ Free memory!\n-            try (Timer t = options.verbose ? new Timer(this, \"Freeing memory\") : null) {\n-                printer.printMemoryUsage();\n-                aotBackend = null;\n-                compiler = null;\n-                System.gc();\n-            }\n-\n-            HotSpotGC graalGC = runtime.getGarbageCollector();\n-            \/\/ Prior to JDK 14, the Graal HotSpotGC enum order matched the JDK CollectedHeap enum\n-            \/\/ order, so using the ordinal value worked fine. In JDK 14, CMS was removed on the\n-            \/\/ JDK side, so we need a symbolic lookup of the JDK value.\n-            int def = graalGC.ordinal() + 1;\n-            \/\/ The GC names are spelled the same in both enums, so no clever remapping is needed\n-            \/\/ here.\n-            String name = \"CollectedHeap::\" + graalGC.name();\n-            int gc = graalHotSpotVMConfig.getConstant(name, Integer.class, def, true);\n-\n-            BinaryContainer binaryContainer = new BinaryContainer(graalOptions, graalHotSpotVMConfig, graphBuilderConfig, gc, JVM_VERSION);\n-            DataBuilder dataBuilder = new DataBuilder(this, backend, classes, binaryContainer);\n-\n-            try (DebugContext debug = new Builder(graalOptions, new GraalDebugHandlersFactory(snippetReflection)).build(); Activation a = debug.activate()) {\n-                dataBuilder.prepareData(debug);\n-            }\n-\n-            \/\/ Print information about section sizes\n-            printer.containersInfo(binaryContainer);\n-\n-            \/\/ Free memory!\n-            try (Timer t = options.verbose ? new Timer(this, \"Freeing memory\") : null) {\n-                printer.printMemoryUsage();\n-                backend = null;\n-                for (AOTCompiledClass aotCompClass : classes) {\n-                    aotCompClass.clear();\n-                }\n-                classes.clear();\n-                classes = null;\n-                dataBuilder = null;\n-                binaryContainer.freeMemory();\n-                System.gc();\n-            }\n-\n-            try (Timer t = new Timer(this, \"Creating binary: \" + objectFileName)) {\n-                binaryContainer.createBinary(objectFileName);\n-            }\n-\n-            \/\/ Free memory!\n-            try (Timer t = options.verbose ? new Timer(this, \"Freeing memory\") : null) {\n-                printer.printMemoryUsage();\n-                binaryContainer = null;\n-                System.gc();\n-            }\n-\n-            try (Timer t = new Timer(this, \"Creating shared library: \" + linker.libFile())) {\n-                linker.link();\n-            }\n-\n-            printer.printVerbose(\"Final memory  \");\n-            printer.printMemoryUsage();\n-            printer.printlnVerbose(\"\");\n-\n-        } finally {\n-            LogPrinter.closeLog();\n-        }\n-        return true;\n-    }\n-\n-    void handleError(ResolvedJavaMethod resolvedMethod, Throwable e, String message) {\n-        String methodName = JavaMethodInfo.uniqueMethodName(resolvedMethod);\n-\n-        if (options.debug) {\n-            printer.printError(\"Failed compilation: \" + methodName + \": \" + e);\n-        }\n-\n-        \/\/ Ignore some exceptions when meta-compiling Graal.\n-        if (GraalFilters.shouldIgnoreException(e)) {\n-            return;\n-        }\n-\n-        LogPrinter.writeLog(\"Failed compilation of method \" + methodName + message);\n-\n-        if (!options.debug) {\n-            printer.printError(\"Failed compilation: \" + methodName + \": \" + e);\n-        }\n-\n-        if (options.verbose) {\n-            e.printStackTrace(log);\n-        }\n-\n-        if (options.exitOnError) {\n-            System.exit(1);\n-        }\n-    }\n-\n-    void warning(String key, Object... args) {\n-        log.println(\"Warning: \" + MessageFormat.format(key, args));\n-        log.flush();\n-    }\n-\n-    private void showUsage() {\n-        log.println(\"Usage: \" + PROGNAME + \" <options> list\");\n-        log.println(\"use --help for a list of possible options\");\n-        log.flush();\n-    }\n-\n-    private void showHelp() {\n-        log.println(\"Usage: \" + PROGNAME + \" <options> list\");\n-        log.println();\n-        log.println(\"  list       A : separated list of class names, modules, jar files\");\n-        log.println(\"             or directories which contain class files.\");\n-        log.println();\n-        log.println(\"where options include:\");\n-        for (Option o : Options.recognizedOptions) {\n-            String name = o.aliases[0].substring(1); \/\/ there must always be at least one name\n-            name = name.charAt(0) == '-' ? name.substring(1) : name;\n-            if (o.isHidden() || name.equals(\"h\")) {\n-                continue;\n-            }\n-            log.println(o.help);\n-        }\n-        log.flush();\n-    }\n-\n-    private void showVersion() {\n-        log.println(PROGNAME + \" \" + JVM_VERSION);\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/Main.java","additions":0,"deletions":356,"binary":false,"changes":356,"status":"deleted"},{"patch":"@@ -1,137 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import org.graalvm.compiler.code.CompilationResult;\n-import org.graalvm.compiler.hotspot.HotSpotMarkId;\n-\n-import jdk.tools.jaotc.binformat.BinaryContainer;\n-import jdk.tools.jaotc.binformat.Relocation;\n-import jdk.tools.jaotc.binformat.Relocation.RelocType;\n-import jdk.tools.jaotc.binformat.Symbol;\n-import jdk.vm.ci.code.site.Mark;\n-\n-final class MarkProcessor {\n-\n-    private final BinaryContainer binaryContainer;\n-\n-    MarkProcessor(DataBuilder dataBuilder) {\n-        binaryContainer = dataBuilder.getBinaryContainer();\n-    }\n-\n-    \/**\n-     * Parse a {@link Mark} generated by the compiler and create all needed binary section\n-     * constructs.\n-     *\n-     * @param methodInfo compiled method info\n-     * @param mark mark being processed\n-     *\/\n-    @SuppressWarnings(\"fallthrough\")\n-    void process(CompiledMethodInfo methodInfo, CompilationResult.CodeMark mark) {\n-        HotSpotMarkId markId = (HotSpotMarkId) mark.id;\n-        switch (markId) {\n-            case EXCEPTION_HANDLER_ENTRY:\n-            case DEOPT_HANDLER_ENTRY:\n-            case DEOPT_MH_HANDLER_ENTRY:\n-                break;\n-            case POLL_FAR:\n-            case POLL_RETURN_FAR:\n-                if (binaryContainer.getThreadLocalHandshakes()) {\n-                    \/\/ skip relocation\n-                    break;\n-                }\n-                \/\/ fallthrough\n-            case CARD_TABLE_ADDRESS:\n-            case NARROW_KLASS_BASE_ADDRESS:\n-            case NARROW_OOP_BASE_ADDRESS:\n-            case CRC_TABLE_ADDRESS:\n-            case LOG_OF_HEAP_REGION_GRAIN_BYTES:\n-            case VERIFY_OOPS:\n-            case VERIFY_OOP_BITS:\n-            case VERIFY_OOP_MASK:\n-            case VERIFY_OOP_COUNT_ADDRESS:\n-                String vmSymbolName;\n-                switch (markId) {\n-                    case POLL_FAR:\n-                    case POLL_RETURN_FAR:\n-                        vmSymbolName = BinaryContainer.getPollingPageSymbolName();\n-                        break;\n-                    case CARD_TABLE_ADDRESS:\n-                        vmSymbolName = BinaryContainer.getCardTableAddressSymbolName();\n-                        break;\n-                    case NARROW_KLASS_BASE_ADDRESS:\n-                        vmSymbolName = BinaryContainer.getNarrowKlassBaseAddressSymbolName();\n-                        break;\n-                    case NARROW_OOP_BASE_ADDRESS:\n-                        vmSymbolName = BinaryContainer.getNarrowOopBaseAddressSymbolName();\n-                        break;\n-                    case CRC_TABLE_ADDRESS:\n-                        vmSymbolName = BinaryContainer.getCrcTableAddressSymbolName();\n-                        break;\n-                    case LOG_OF_HEAP_REGION_GRAIN_BYTES:\n-                        vmSymbolName = BinaryContainer.getLogOfHeapRegionGrainBytesSymbolName();\n-                        break;\n-                    case VERIFY_OOPS:\n-                        vmSymbolName = BinaryContainer.getVerifyOopsSymbolName();\n-                        break;\n-                    case VERIFY_OOP_COUNT_ADDRESS:\n-                        vmSymbolName = BinaryContainer.getVerifyOopCountAddressSymbolName();\n-                        break;\n-                    case VERIFY_OOP_BITS:\n-                        vmSymbolName = BinaryContainer.getVerifyOopBitsSymbolName();\n-                        break;\n-                    case VERIFY_OOP_MASK:\n-                        vmSymbolName = BinaryContainer.getVerifyOopMaskSymbolName();\n-                        break;\n-                    default:\n-                        throw new InternalError(\"Unhandled mark: \" + mark);\n-                }\n-                String s = \"got.\" + vmSymbolName;\n-                Symbol gotSymbol = binaryContainer.getGotSymbol(s);\n-                assert gotSymbol != null : \" Processing Mark: Encountered undefined got symbol for  \" + mark;\n-                final int textBaseOffset = methodInfo.getTextSectionOffset();\n-                final int textOffset = textBaseOffset + mark.pcOffset;\n-                Relocation reloc = new Relocation(textOffset, RelocType.EXTERNAL_PLT_TO_GOT, 8, binaryContainer.getCodeContainer(), gotSymbol);\n-                binaryContainer.addRelocation(reloc);\n-                break;\n-            case VERIFIED_ENTRY:\n-            case UNVERIFIED_ENTRY:\n-            case OSR_ENTRY:\n-            case FRAME_COMPLETE:\n-            case INVOKEINTERFACE:\n-            case INVOKEVIRTUAL:\n-            case INVOKESTATIC:\n-            case INVOKESPECIAL:\n-            case INLINE_INVOKE:\n-            case POLL_NEAR:\n-            case POLL_RETURN_NEAR:\n-                \/\/ Nothing to do.\n-                break;\n-            default:\n-                throw new InternalError(\"Unexpected mark found: \" + mark);\n-        }\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/MarkProcessor.java","additions":0,"deletions":137,"binary":false,"changes":137,"status":"deleted"},{"patch":"@@ -1,251 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import static jdk.tools.jaotc.AOTCompiledClass.getType;\n-import static jdk.tools.jaotc.AOTCompiledClass.metadataName;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import org.graalvm.compiler.code.CompilationResult;\n-import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;\n-import org.graalvm.compiler.hotspot.HotSpotGraalServices;\n-\n-import jdk.tools.jaotc.binformat.BinaryContainer;\n-import jdk.tools.jaotc.binformat.ByteContainer;\n-import jdk.tools.jaotc.binformat.GotSymbol;\n-import jdk.tools.jaotc.utils.NativeOrderOutputStream;\n-import jdk.vm.ci.code.StackSlot;\n-import jdk.vm.ci.code.site.DataPatch;\n-import jdk.vm.ci.code.site.Infopoint;\n-import jdk.vm.ci.code.site.Mark;\n-import jdk.vm.ci.hotspot.HotSpotCompiledCode;\n-import jdk.vm.ci.hotspot.HotSpotMetaData;\n-\n-final class MetadataBuilder {\n-\n-    private final DataBuilder dataBuilder;\n-\n-    private final BinaryContainer binaryContainer;\n-\n-    MetadataBuilder(DataBuilder dataBuilder) {\n-        this.dataBuilder = dataBuilder;\n-        this.binaryContainer = dataBuilder.getBinaryContainer();\n-    }\n-\n-    \/**\n-     * Process compiled methods and create method metadata.\n-     *\/\n-    void processMetadata(List<AOTCompiledClass> classes, AOTCompiledClass stubCompiledCode) {\n-        for (AOTCompiledClass c : classes) {\n-            processMetadataClass(c);\n-        }\n-        processMetadataClass(stubCompiledCode);\n-    }\n-\n-    private void processMetadataClass(AOTCompiledClass c) {\n-        processInfopointsAndMarks(c);\n-        createMethodMetadata(c);\n-    }\n-\n-    \/**\n-     * Add metadata for each of the compiled methods in {@code compiledClass} to read-only section\n-     * of {@code binaryContainer}.\n-     *\n-     * @param compiledClass AOT Graal compilation result\n-     *\/\n-    private void createMethodMetadata(AOTCompiledClass compiledClass) {\n-        HotSpotGraalRuntimeProvider runtime = dataBuilder.getBackend().getRuntime();\n-        ByteContainer methodMetadataContainer = binaryContainer.getMethodMetadataContainer();\n-\n-        \/\/ For each of the compiled java methods, create records holding information about them.\n-        for (CompiledMethodInfo methodInfo : compiledClass.getCompiledMethods()) {\n-            \/\/ Get the current offset in the methodmetadata container.\n-            final int startOffset = methodMetadataContainer.getByteStreamSize();\n-            assert startOffset % 8 == 0 : \"Must be aligned on 8\";\n-\n-            methodInfo.setMetadataOffset(startOffset);\n-\n-            HotSpotCompiledCode compiledMethod = methodInfo.compiledCode();\n-            \/\/ pc and scope description\n-            HotSpotMetaData metaData = new HotSpotMetaData(runtime.getTarget(), compiledMethod);\n-\n-            byte[] pcDesc = metaData.pcDescBytes();\n-            byte[] scopeDesc = metaData.scopesDescBytes();\n-            byte[] relocationInfo = metaData.relocBytes();\n-            byte[] oopMapInfo = metaData.oopMaps();\n-            \/\/ this may be null as the field does not exist before JDK 13\n-            byte[] implicitExceptionBytes = HotSpotGraalServices.getImplicitExceptionBytes(metaData);\n-            byte[] exceptionBytes = metaData.exceptionBytes();\n-\n-            \/\/ create a global symbol at this position for this method\n-            NativeOrderOutputStream metadataStream = new NativeOrderOutputStream();\n-\n-            \/\/ get the code size\n-            int codeSize = methodInfo.getCodeSize();\n-\n-            \/\/ get code offsets\n-            CodeOffsets co = CodeOffsets.buildFrom(methodInfo.getCompilationResult().getMarks());\n-            int unverifiedEntry = co.entry();\n-            int verifiedEntry = co.verifiedEntry();\n-            int exceptionHandler = co.exceptionHandler();\n-            int deoptHandler = co.deoptHandler();\n-            int deoptMHHandler = co.deoptMHHandler();\n-            int frameSize = methodInfo.getCompilationResult().getTotalFrameSize();\n-            StackSlot deoptRescueSlot = methodInfo.getCompilationResult().getCustomStackArea();\n-            int origPcOffset = deoptRescueSlot != null ? deoptRescueSlot.getOffset(frameSize) : -1;\n-\n-            \/\/ get stubs offset\n-            int stubsOffset = methodInfo.getStubsOffset();\n-\n-            int offset = addMetadataEntries(binaryContainer, metaData, methodInfo);\n-            methodInfo.setMetadataGotOffset(offset);\n-            methodInfo.setMetadataGotSize(metaData.metadataEntries().length);\n-            int unsafeAccess = methodInfo.getCompilationResult().hasUnsafeAccess() ? 1 : 0;\n-            try {\n-                \/\/ calculate total size of the container\n-                NativeOrderOutputStream.PatchableInt totalSize = metadataStream.patchableInt();\n-\n-                \/\/ @formatter:off\n-                metadataStream.putInt(codeSize).\n-                               putInt(unverifiedEntry).\n-                               putInt(verifiedEntry).\n-                               putInt(exceptionHandler).\n-                               putInt(deoptHandler).\n-                               putInt(deoptMHHandler).\n-                               putInt(stubsOffset).\n-                               putInt(frameSize).\n-                               putInt(origPcOffset).\n-                               putInt(unsafeAccess);\n-                \/\/ @formatter:on\n-\n-                NativeOrderOutputStream.PatchableInt pcDescOffset = metadataStream.patchableInt();\n-                NativeOrderOutputStream.PatchableInt scopeOffset = metadataStream.patchableInt();\n-                NativeOrderOutputStream.PatchableInt relocationOffset = metadataStream.patchableInt();\n-                NativeOrderOutputStream.PatchableInt exceptionOffset = metadataStream.patchableInt();\n-                NativeOrderOutputStream.PatchableInt implictTableOffset = null;\n-                if (implicitExceptionBytes != null) {\n-                    implictTableOffset = metadataStream.patchableInt();\n-                }\n-                NativeOrderOutputStream.PatchableInt oopMapOffset = metadataStream.patchableInt();\n-                metadataStream.align(8);\n-\n-                pcDescOffset.set(metadataStream.position());\n-                metadataStream.put(pcDesc).align(8);\n-\n-                scopeOffset.set(metadataStream.position());\n-                metadataStream.put(scopeDesc).align(8);\n-\n-                relocationOffset.set(metadataStream.position());\n-                metadataStream.put(relocationInfo).align(8);\n-\n-                exceptionOffset.set(metadataStream.position());\n-                metadataStream.put(exceptionBytes).align(8);\n-\n-                if (implicitExceptionBytes != null) {\n-                    implictTableOffset.set(metadataStream.position());\n-                    metadataStream.put(implicitExceptionBytes).align(8);\n-                }\n-\n-                \/\/ oopmaps should be last\n-                oopMapOffset.set(metadataStream.position());\n-                metadataStream.put(oopMapInfo).align(8);\n-\n-                totalSize.set(metadataStream.position());\n-\n-                byte[] data = metadataStream.array();\n-\n-                methodMetadataContainer.appendBytes(data, 0, data.length);\n-            } catch (Exception e) {\n-                throw new InternalError(\"Exception occurred during compilation of \" + methodInfo.getMethodInfo().getSymbolName(), e);\n-            }\n-            methodInfo.clearCompileData(); \/\/ Clear unused anymore compilation data\n-        }\n-    }\n-\n-    private static int addMetadataEntries(BinaryContainer binaryContainer, HotSpotMetaData metaData, CompiledMethodInfo methodInfo) {\n-        Object[] metaDataEntries = metaData.metadataEntries();\n-\n-        if (metaDataEntries.length == 0) {\n-            return 0;\n-        }\n-\n-        int metadataGotSlotsStart = binaryContainer.getMetadataGotContainer().getByteStreamSize(); \/\/ binaryContainer.reserveMetadataGOTSlots(metaDataEntries.length);\n-\n-        for (int index = 0; index < metaDataEntries.length; index++) {\n-            Object ref = metaDataEntries[index];\n-            String name = metadataName(ref);\n-            \/\/ Create GOT cells for klasses referenced in metadata\n-            addMetadataEntry(binaryContainer, name);\n-            \/\/ We should already have added entries for this klass\n-            assert AOTCompiledClass.getAOTKlassData(getType(ref)) != null;\n-            assert methodInfo.getDependentKlassData(getType(ref)) != null;\n-        }\n-\n-        return metadataGotSlotsStart;\n-    }\n-\n-    private static void addMetadataEntry(BinaryContainer binaryContainer, String name) {\n-        int stringOffset = binaryContainer.addMetaspaceName(name);\n-        binaryContainer.addMetadataGotEntry(stringOffset);\n-    }\n-\n-    \/**\n-     * Process {@link Infopoint}s, {@link Mark}s and {@link DataPatch}es generated by the compiler\n-     * to create all needed binary section constructs.\n-     *\n-     * @param compiledClass compilation result\n-     *\/\n-    private void processInfopointsAndMarks(AOTCompiledClass compiledClass) {\n-        ArrayList<CompiledMethodInfo> compiledMethods = compiledClass.getCompiledMethods();\n-\n-        MarkProcessor markProcessor = new MarkProcessor(dataBuilder);\n-        DataPatchProcessor dataPatchProcessor = new DataPatchProcessor(dataBuilder);\n-        InfopointProcessor infopointProcessor = new InfopointProcessor(dataBuilder);\n-\n-        for (CompiledMethodInfo methodInfo : compiledMethods) {\n-            CompilationResult compilationResult = methodInfo.getCompilationResult();\n-            String targetSymbol = \"state.M\" + methodInfo.getCodeId();\n-            String gotName = \"got.\" + targetSymbol;\n-            GotSymbol symbol = binaryContainer.getMethodStateContainer().createGotSymbol(gotName);\n-            assert (symbol.getIndex() == methodInfo.getCodeId()) : \"wrong offset\";\n-\n-            for (Infopoint infoPoint : compilationResult.getInfopoints()) {\n-                infopointProcessor.process(methodInfo, infoPoint);\n-            }\n-\n-            for (CompilationResult.CodeMark mark : compilationResult.getMarks()) {\n-                markProcessor.process(methodInfo, mark);\n-            }\n-\n-            for (DataPatch dataPatch : compilationResult.getDataPatches()) {\n-                dataPatchProcessor.process(methodInfo, dataPatch);\n-            }\n-        }\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/MetadataBuilder.java","additions":0,"deletions":251,"binary":false,"changes":251,"status":"deleted"},{"patch":"@@ -1,300 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import java.text.MessageFormat;\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-import jdk.tools.jaotc.collect.ClassSearch;\n-import jdk.tools.jaotc.collect.ClassSource;\n-import jdk.tools.jaotc.collect.SearchFor;\n-import jdk.tools.jaotc.collect.SearchPath;\n-import jdk.tools.jaotc.collect.classname.ClassNameSourceProvider;\n-import jdk.tools.jaotc.collect.directory.DirectorySourceProvider;\n-import jdk.tools.jaotc.collect.jar.JarSourceProvider;\n-import jdk.tools.jaotc.collect.module.ModuleSourceProvider;\n-\n-final class Options {\n-    List<SearchFor> files = new LinkedList<>();\n-    String osName;\n-    String outputName = defaultOutputName();\n-    String methodList;\n-    List<ClassSource> sources = new ArrayList<>();\n-    String linkerpath = null;\n-    SearchPath searchPath = new SearchPath();\n-\n-    \/**\n-     * We don't see scaling beyond 16 threads.\n-     *\/\n-    private static final int COMPILER_THREADS = 16;\n-\n-    int threads = Integer.min(COMPILER_THREADS, Runtime.getRuntime().availableProcessors());\n-\n-    boolean ignoreClassLoadingErrors;\n-    boolean exitOnError;\n-    boolean info;\n-    boolean verbose;\n-    boolean debug;\n-    boolean help;\n-    boolean version;\n-    boolean compileWithAssertions;\n-    boolean tiered;\n-\n-    private String defaultOutputName() {\n-        osName = System.getProperty(\"os.name\");\n-        String name = \"unnamed.\";\n-        String ext;\n-\n-        switch (osName) {\n-            case \"Linux\":\n-                ext = \"so\";\n-                break;\n-            case \"Mac OS X\":\n-                ext = \"dylib\";\n-                break;\n-            default:\n-                if (osName.startsWith(\"Windows\")) {\n-                    ext = \"dll\";\n-                } else {\n-                    ext = \"so\";\n-                }\n-        }\n-\n-        return name + ext;\n-    }\n-\n-    static class BadArgs extends Exception {\n-        private static final long serialVersionUID = 1L;\n-        final String key;\n-        final Object[] args;\n-        boolean showUsage;\n-\n-        BadArgs(String key, Object... args) {\n-            super(MessageFormat.format(key, args));\n-            this.key = key;\n-            this.args = args;\n-        }\n-\n-        BadArgs showUsage(boolean b) {\n-            showUsage = b;\n-            return this;\n-        }\n-    }\n-\n-    abstract static class Option {\n-        final String help;\n-        final boolean hasArg;\n-        final String[] aliases;\n-\n-        Option(String help, boolean hasArg, String... aliases) {\n-            this.help = help;\n-            this.hasArg = hasArg;\n-            this.aliases = aliases;\n-        }\n-\n-        boolean isHidden() {\n-            return false;\n-        }\n-\n-        boolean matches(String opt) {\n-            for (String a : aliases) {\n-                if (a.equals(opt)) {\n-                    return true;\n-                } else if (opt.startsWith(\"--\") && hasArg && opt.startsWith(a + \"=\")) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        boolean ignoreRest() {\n-            return false;\n-        }\n-\n-        abstract void process(Main task, String opt, String arg) throws BadArgs;\n-    }\n-\n-    static Option[] recognizedOptions = {new Option(\"  --output <file>            Output file name\", true, \"--output\") {\n-        @Override\n-        void process(Main task, String opt, String arg) {\n-            String name = arg;\n-            task.options.outputName = name;\n-        }\n-    }, new Option(\"  --class-name <class names> List of classes to compile\", true, \"--class-name\", \"--classname\") {\n-        @Override\n-        void process(Main task, String opt, String arg) {\n-            task.options.files.addAll(ClassSearch.makeList(ClassNameSourceProvider.TYPE, arg));\n-        }\n-    }, new Option(\"  --jar <jarfiles>           List of jar files to compile\", true, \"--jar\") {\n-        @Override\n-        void process(Main task, String opt, String arg) {\n-            task.options.files.addAll(ClassSearch.makeList(JarSourceProvider.TYPE, arg));\n-        }\n-    }, new Option(\"  --module <modules>         List of modules to compile\", true, \"--module\") {\n-        @Override\n-        void process(Main task, String opt, String arg) {\n-            task.options.files.addAll(ClassSearch.makeList(ModuleSourceProvider.TYPE, arg));\n-        }\n-    }, new Option(\"  --directory <dirs>         List of directories where to search for files to compile\", true, \"--directory\") {\n-        @Override\n-        void process(Main task, String opt, String arg) {\n-            task.options.files.addAll(ClassSearch.makeList(DirectorySourceProvider.TYPE, arg));\n-        }\n-    }, new Option(\"  --search-path <dirs>       List of directories where to search for specified files\", true, \"--search-path\") {\n-        @Override\n-        void process(Main task, String opt, String arg) {\n-            String[] elements = arg.split(\":\");\n-            task.options.searchPath.add(elements);\n-        }\n-    }, new Option(\"  --compile-commands <file>  Name of file with compile commands\", true, \"--compile-commands\") {\n-        @Override\n-        void process(Main task, String opt, String arg) {\n-            task.options.methodList = arg;\n-        }\n-    }, new Option(\"  --compile-for-tiered       Generate profiling code for tiered compilation\", false, \"--compile-for-tiered\") {\n-        @Override\n-        void process(Main task, String opt, String arg) {\n-            task.options.tiered = true;\n-        }\n-    }, new Option(\"  --compile-with-assertions  Compile with java assertions\", false, \"--compile-with-assertions\") {\n-        @Override\n-        void process(Main task, String opt, String arg) {\n-            task.options.compileWithAssertions = true;\n-        }\n-    }, new Option(\"  --compile-threads <number> Number of compilation threads to be used\", true, \"--compile-threads\", \"--threads\") {\n-        @Override\n-        void process(Main task, String opt, String arg) {\n-            int threads = Integer.parseInt(arg);\n-            final int available = Runtime.getRuntime().availableProcessors();\n-            if (threads <= 0) {\n-                task.warning(\"invalid number of threads specified: {0}, using: {1}\", threads, available);\n-                threads = available;\n-            }\n-            if (threads > available) {\n-                task.warning(\"too many threads specified: {0}, limiting to: {1}\", threads, available);\n-            }\n-            task.options.threads = Integer.min(threads, available);\n-        }\n-    }, new Option(\"  --ignore-errors            Ignores all exceptions thrown during class loading\", false, \"--ignore-errors\") {\n-        @Override\n-        void process(Main task, String opt, String arg) {\n-            task.options.ignoreClassLoadingErrors = true;\n-        }\n-    }, new Option(\"  --exit-on-error            Exit on compilation errors\", false, \"--exit-on-error\") {\n-        @Override\n-        void process(Main task, String opt, String arg) {\n-            task.options.exitOnError = true;\n-        }\n-    }, new Option(\"  --info                     Print information during compilation\", false, \"--info\") {\n-        @Override\n-        void process(Main task, String opt, String arg) throws BadArgs {\n-            task.options.info = true;\n-        }\n-    }, new Option(\"  --verbose                  Print verbose information\", false, \"--verbose\") {\n-        @Override\n-        void process(Main task, String opt, String arg) throws BadArgs {\n-            task.options.info = true;\n-            task.options.verbose = true;\n-        }\n-    }, new Option(\"  --debug                    Print debug information\", false, \"--debug\") {\n-        @Override\n-        void process(Main task, String opt, String arg) throws BadArgs {\n-            task.options.info = true;\n-            task.options.verbose = true;\n-            task.options.debug = true;\n-        }\n-    }, new Option(\"  -? -h --help               Print this help message\", false, \"--help\", \"-h\", \"-?\") {\n-        @Override\n-        void process(Main task, String opt, String arg) {\n-            task.options.help = true;\n-        }\n-    }, new Option(\"  --version                  Version information\", false, \"--version\") {\n-        @Override\n-        void process(Main task, String opt, String arg) {\n-            task.options.version = true;\n-        }\n-    }, new Option(\"  --linker-path              Full path to linker executable\", true, \"--linker-path\") {\n-        @Override\n-        void process(Main task, String opt, String arg) {\n-            task.options.linkerpath = arg;\n-        }\n-    }, new Option(\"  -J<flag>                   Pass <flag> directly to the runtime system\", false, \"-J\") {\n-        @Override\n-        void process(Main task, String opt, String arg) {\n-        }\n-    }};\n-\n-    static void handleOptions(Main task, String[] args) throws BadArgs {\n-        if (args.length == 0) {\n-            task.options.help = true;\n-            return;\n-        }\n-\n-        \/\/ Make checkstyle happy.\n-        int i = 0;\n-        while (i < args.length) {\n-            String arg = args[i];\n-\n-            if (arg.charAt(0) == '-') {\n-                Option option = getOption(arg);\n-                String param = null;\n-\n-                if (option.hasArg) {\n-                    if (arg.startsWith(\"--\") && arg.indexOf('=') > 0) {\n-                        param = arg.substring(arg.indexOf('=') + 1, arg.length());\n-                    } else if (i + 1 < args.length) {\n-                        param = args[++i];\n-                    }\n-\n-                    if (param == null || param.isEmpty() || param.charAt(0) == '-') {\n-                        throw new BadArgs(\"missing argument for option: {0}\", arg).showUsage(true);\n-                    }\n-                }\n-\n-                option.process(task, arg, param);\n-\n-                if (option.ignoreRest()) {\n-                    break;\n-                }\n-            } else {\n-                task.options.files.add(new SearchFor(arg));\n-            }\n-            i++;\n-        }\n-    }\n-\n-    static Option getOption(String name) throws BadArgs {\n-        for (Option o : recognizedOptions) {\n-            if (o.matches(name)) {\n-                return o;\n-            }\n-        }\n-        throw new BadArgs(\"unknown option: {0}\", name).showUsage(true);\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/Options.java","additions":0,"deletions":300,"binary":false,"changes":300,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-import jdk.tools.jaotc.binformat.BinaryContainer;\n-import jdk.tools.jaotc.binformat.Symbol.Binding;\n-\n-\/**\n- * Call to a Graal stub, the symbol name should be direct.\n- *\/\n-final class StubDirectCallSiteRelocationSymbol extends CallSiteRelocationSymbol {\n-\n-    StubDirectCallSiteRelocationSymbol(CallSiteRelocationInfo callSiteRelocation, BinaryContainer binaryContainer) {\n-        super(binaryContainer.getSymbol(callSiteRelocation.targetSymbol));\n-        assert symbol != null && symbol.getBinding() == Binding.LOCAL : \"Stub symbol must exist and must be LOCAL\";\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/StubDirectCallSiteRelocationSymbol.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,124 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-public final class StubInformation {\n-    private int stubOffset;         \/\/ the offset inside the code (text + stubOffset)\n-    private int stubSize;           \/\/ the stub size\n-    private int dispatchJumpOffset; \/\/ offset after main dispatch jump instruction\n-    private int resolveJumpOffset;  \/\/ offset after jump instruction to runtime call resolution\n-                                    \/\/ function.\n-    private int resolveJumpStart;   \/\/ offset of jump instruction to VM runtime call resolution\n-                                    \/\/ function.\n-    private int c2iJumpOffset;      \/\/ offset after jump instruction to c2i adapter for static\n-                                    \/\/ calls.\n-    private int movOffset;          \/\/ offset after move instruction which loads from got cell:\n-                                    \/\/ - Method* for static call\n-                                    \/\/ - Klass* for virtual call\n-\n-    private boolean isVirtual;  \/\/ virtual call stub\n-\n-    \/\/ maybe add type of stub as well, right now we only have static stubs\n-\n-    StubInformation(int stubOffset, boolean isVirtual) {\n-        this.stubOffset = stubOffset;\n-        this.isVirtual = isVirtual;\n-        this.stubSize = -1;\n-        this.movOffset = -1;\n-        this.c2iJumpOffset = -1;\n-        this.resolveJumpOffset = -1;\n-        this.resolveJumpStart = -1;\n-        this.dispatchJumpOffset = -1;\n-    }\n-\n-    int getOffset() {\n-        return stubOffset;\n-    }\n-\n-    boolean isVirtual() {\n-        return isVirtual;\n-    }\n-\n-    public void setSize(int stubSize) {\n-        this.stubSize = stubSize;\n-    }\n-\n-    int getSize() {\n-        return stubSize;\n-    }\n-\n-    public void setMovOffset(int movOffset) {\n-        this.movOffset = movOffset + stubOffset;\n-    }\n-\n-    int getMovOffset() {\n-        return movOffset;\n-    }\n-\n-    public void setC2IJumpOffset(int c2iJumpOffset) {\n-        this.c2iJumpOffset = c2iJumpOffset + stubOffset;\n-    }\n-\n-    int getC2IJumpOffset() {\n-        return c2iJumpOffset;\n-    }\n-\n-    public void setResolveJumpOffset(int resolveJumpOffset) {\n-        this.resolveJumpOffset = resolveJumpOffset + stubOffset;\n-    }\n-\n-    int getResolveJumpOffset() {\n-        return resolveJumpOffset;\n-    }\n-\n-    public void setResolveJumpStart(int resolveJumpStart) {\n-        this.resolveJumpStart = resolveJumpStart + stubOffset;\n-    }\n-\n-    int getResolveJumpStart() {\n-        return resolveJumpStart;\n-    }\n-\n-    public void setDispatchJumpOffset(int dispatchJumpOffset) {\n-        this.dispatchJumpOffset = dispatchJumpOffset + stubOffset;\n-    }\n-\n-    int getDispatchJumpOffset() {\n-        return dispatchJumpOffset;\n-    }\n-\n-    void verify() {\n-        assert stubOffset > 0 : \"incorrect stubOffset: \" + stubOffset;\n-        assert stubSize > 0 : \"incorrect stubSize: \" + stubSize;\n-        assert movOffset > 0 : \"incorrect movOffset: \" + movOffset;\n-        assert dispatchJumpOffset > 0 : \"incorrect dispatchJumpOffset: \" + dispatchJumpOffset;\n-        assert resolveJumpStart > 0 : \"incorrect resolveJumpStart: \" + resolveJumpStart;\n-        assert resolveJumpOffset > 0 : \"incorrect resolveJumpOffset: \" + resolveJumpOffset;\n-        if (!isVirtual) {\n-            assert c2iJumpOffset > 0 : \"incorrect c2iJumpOffset: \" + c2iJumpOffset;\n-        }\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/StubInformation.java","additions":0,"deletions":124,"binary":false,"changes":124,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc;\n-\n-final class Timer implements AutoCloseable {\n-\n-    private final Main main;\n-    private final long start;\n-\n-    Timer(Main main, String message) {\n-        this.main = main;\n-        start = System.currentTimeMillis();\n-        main.printer.printInfo(message);\n-    }\n-\n-    @Override\n-    public void close() {\n-        final long end = System.currentTimeMillis();\n-        main.printer.printlnInfo(\" (\" + (end - start) + \" ms)\");\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/Timer.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,131 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.aarch64;\n-\n-import static jdk.vm.ci.aarch64.AArch64.r12;\n-import static jdk.vm.ci.aarch64.AArch64.r16;\n-import static jdk.vm.ci.aarch64.AArch64.r17;\n-import static jdk.vm.ci.aarch64.AArch64.r9;\n-\n-import org.graalvm.compiler.asm.aarch64.AArch64Address;\n-import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;\n-\n-import jdk.tools.jaotc.ELFMacroAssembler;\n-import jdk.tools.jaotc.StubInformation;\n-import jdk.vm.ci.code.TargetDescription;\n-\n-public final class AArch64ELFMacroAssembler extends AArch64MacroAssembler implements ELFMacroAssembler {\n-\n-    private int currentEndOfInstruction;\n-\n-    public AArch64ELFMacroAssembler(TargetDescription target) {\n-        super(target);\n-    }\n-\n-    @Override\n-    public int currentEndOfInstruction() {\n-        return currentEndOfInstruction;\n-    }\n-\n-    @Override\n-    public byte[] getPLTJumpCode() {\n-        \/\/ The main dispatch instruction\n-        addressOf(r16);\n-        ldr(64, r16, AArch64Address.createBaseRegisterOnlyAddress(r16));\n-        jmp(r16);\n-\n-        currentEndOfInstruction = position();\n-\n-        align(8);\n-\n-        return close(true);\n-    }\n-\n-    @Override\n-    public byte[] getPLTStaticEntryCode(StubInformation stub) {\n-        \/\/ The main dispatch instruction\n-        addressOf(r16);\n-        ldr(64, r16, AArch64Address.createBaseRegisterOnlyAddress(r16));\n-        jmp(r16);\n-        stub.setDispatchJumpOffset(position());\n-\n-        \/\/ C2I stub used to call interpreter. First load r12\n-        \/\/ (i.e. rmethod) with a pointer to the Method structure ...\n-        addressOf(r12);\n-        ldr(64, r12, AArch64Address.createBaseRegisterOnlyAddress(r12));\n-        nop();\n-        stub.setMovOffset(position());\n-\n-        \/\/ ... then jump to the interpreter.\n-        addressOf(r16);\n-        ldr(64, r16, AArch64Address.createBaseRegisterOnlyAddress(r16));\n-        jmp(r16);\n-        stub.setC2IJumpOffset(position());\n-\n-        \/\/ Call to VM runtime to resolve the call.\n-        stub.setResolveJumpStart(position());\n-        addressOf(r16);\n-        ldr(64, r16, AArch64Address.createBaseRegisterOnlyAddress(r16));\n-        jmp(r16);\n-        stub.setResolveJumpOffset(position());\n-        currentEndOfInstruction = position();\n-\n-        align(8);\n-        stub.setSize(position());\n-\n-        return close(true);\n-    }\n-\n-    @Override\n-    public byte[] getPLTVirtualEntryCode(StubInformation stub) {\n-        \/\/ Fixup an inline cache.\n-        \/\/ Load r9 with a pointer to the Klass.\n-        addressOf(r17);\n-        ldr(64, r9, AArch64Address.createBaseRegisterOnlyAddress(r17));\n-        nop();\n-        stub.setMovOffset(position());\n-\n-        \/\/ Jump to the method.\n-        addressOf(r16);\n-        ldr(64, r16, AArch64Address.createBaseRegisterOnlyAddress(r16));\n-        jmp(r16);\n-        stub.setDispatchJumpOffset(position());\n-\n-        \/\/ Call to VM runtime to resolve the call.\n-        stub.setResolveJumpStart(position());\n-        addressOf(r16);\n-        ldr(64, r16, AArch64Address.createBaseRegisterOnlyAddress(r16));\n-        jmp(r16);\n-        stub.setResolveJumpOffset(position());\n-        currentEndOfInstruction = position();\n-\n-        align(8);\n-        stub.setSize(position());\n-\n-        return close(true);\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/aarch64\/AArch64ELFMacroAssembler.java","additions":0,"deletions":131,"binary":false,"changes":131,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.aarch64;\n-\n-import jdk.tools.jaotc.InstructionDecoder;\n-\n-public final class AArch64InstructionDecoder extends InstructionDecoder {\n-\n-    private int currentEndOfInstruction;\n-\n-    public AArch64InstructionDecoder() {\n-    }\n-\n-    @Override\n-    public int currentEndOfInstruction() {\n-        return currentEndOfInstruction;\n-    }\n-\n-    @Override\n-    public void decodePosition(final byte[] code, int pcOffset) {\n-        currentEndOfInstruction = pcOffset + 4;\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/aarch64\/AArch64InstructionDecoder.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.amd64;\n-\n-import static jdk.vm.ci.amd64.AMD64.rax;\n-import static jdk.vm.ci.amd64.AMD64.rbx;\n-import static jdk.vm.ci.amd64.AMD64.rip;\n-\n-import jdk.tools.jaotc.StubInformation;\n-import jdk.tools.jaotc.ELFMacroAssembler;\n-import org.graalvm.compiler.asm.amd64.AMD64Address;\n-import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;\n-\n-import jdk.vm.ci.code.TargetDescription;\n-import org.graalvm.compiler.options.OptionValues;\n-\n-public final class AMD64ELFMacroAssembler extends AMD64MacroAssembler implements ELFMacroAssembler {\n-\n-    private int currentEndOfInstruction;\n-\n-    public AMD64ELFMacroAssembler(TargetDescription target, OptionValues optionValues) {\n-        super(target, optionValues);\n-    }\n-\n-    @Override\n-    public int currentEndOfInstruction() {\n-        return currentEndOfInstruction;\n-    }\n-\n-    @Override\n-    public byte[] getPLTJumpCode() {\n-        \/\/ The main dispatch instruction\n-        \/\/ jmpq *0x00000000(%rip)\n-        jmp(new AMD64Address(rip, 0));\n-        currentEndOfInstruction = position();\n-\n-        \/\/ Align to 8 bytes\n-        align(8);\n-\n-        return close(true);\n-    }\n-\n-    @Override\n-    public byte[] getPLTStaticEntryCode(StubInformation stub) {\n-        \/\/ The main dispatch instruction\n-        \/\/ jmpq *0x00000000(%rip)\n-        jmp(new AMD64Address(rip, 0));\n-        stub.setDispatchJumpOffset(position());\n-\n-        \/\/ C2I stub used to call interpreter.\n-        \/\/ mov 0x00000000(%rip),%rbx Loading Method*\n-        movq(rbx, new AMD64Address(rip, 0));\n-        stub.setMovOffset(position());\n-\n-        \/\/ jmpq *0x00000000(%rip) [c2i addr]\n-        jmp(new AMD64Address(rip, 0));\n-        stub.setC2IJumpOffset(position());\n-\n-        \/\/ Call to VM runtime to resolve the call.\n-        \/\/ jmpq *0x00000000(%rip)\n-        stub.setResolveJumpStart(position());\n-        jmp(new AMD64Address(rip, 0));\n-        stub.setResolveJumpOffset(position());\n-        currentEndOfInstruction = position();\n-\n-        \/\/ Align to 8 bytes\n-        align(8);\n-        stub.setSize(position());\n-\n-        return close(true);\n-    }\n-\n-    @Override\n-    public byte[] getPLTVirtualEntryCode(StubInformation stub) {\n-        \/\/ Klass loading instruction\n-        \/\/ mov 0x00000000(%rip),%rax\n-        movq(rax, new AMD64Address(rip, 0));\n-        stub.setMovOffset(position());\n-\n-        \/\/ The main dispatch instruction\n-        \/\/ jmpq *0x00000000(%rip)\n-        jmp(new AMD64Address(rip, 0));\n-        stub.setDispatchJumpOffset(position());\n-\n-        \/\/ Call to VM runtime to resolve the call.\n-        \/\/ jmpq *0x00000000(%rip)\n-        stub.setResolveJumpStart(position());\n-        jmp(new AMD64Address(rip, 0));\n-        stub.setResolveJumpOffset(position());\n-        currentEndOfInstruction = position();\n-\n-        \/\/ Align to 8 bytes\n-        align(8);\n-        stub.setSize(position());\n-\n-        return close(true);\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/amd64\/AMD64ELFMacroAssembler.java","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -1,569 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.amd64;\n-\n-import jdk.tools.jaotc.InstructionDecoder;\n-\n-import jdk.vm.ci.code.TargetDescription;\n-\n-public final class AMD64InstructionDecoder extends InstructionDecoder {\n-\n-    private boolean targetIs64Bit;\n-    private int currentEndOfInstruction;\n-\n-    private static class Prefix {\n-\n-        \/\/ segment overrides\n-        static final int CSSegment = 0x2e;\n-        static final int SSSegment = 0x36;\n-        static final int DSSegment = 0x3e;\n-        static final int ESSegment = 0x26;\n-        static final int FSSegment = 0x64;\n-        static final int GSSegment = 0x65;\n-        static final int REX = 0x40;\n-        static final int REXB = 0x41;\n-        static final int REXX = 0x42;\n-        static final int REXXB = 0x43;\n-        static final int REXR = 0x44;\n-        static final int REXRB = 0x45;\n-        static final int REXRX = 0x46;\n-        static final int REXRXB = 0x47;\n-        static final int REXW = 0x48;\n-        static final int REXWB = 0x49;\n-        static final int REXWX = 0x4A;\n-        static final int REXWXB = 0x4B;\n-        static final int REXWR = 0x4C;\n-        static final int REXWRB = 0x4D;\n-        static final int REXWRX = 0x4E;\n-        static final int REXWRXB = 0x4F;\n-        static final int VEX_3BYTES = 0xC4;\n-        static final int VEX_2BYTES = 0xC5;\n-    }\n-\n-    @SuppressWarnings(\"unused\")\n-    private static class VexPrefix {\n-        static final int VEX_R = 0x80;\n-        static final int VEX_W = 0x80;\n-    }\n-\n-    @SuppressWarnings(\"unused\")\n-    private static class VexOpcode {\n-        static final int VEX_OPCODE_NONE = 0x0;\n-        static final int VEX_OPCODE_0F = 0x1;\n-        static final int VEX_OPCODE_0F_38 = 0x2;\n-        static final int VEX_OPCODE_0F_3A = 0x3;\n-        static final int VEX_OPCODE_MASK = 0x1F;\n-    }\n-\n-    public AMD64InstructionDecoder(TargetDescription target) {\n-        this.targetIs64Bit = target.wordSize == 8;\n-    }\n-\n-    @Override\n-    public int currentEndOfInstruction() {\n-        return currentEndOfInstruction;\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"fallthrough\")\n-    public void decodePosition(final byte[] code, int pcOffset) {\n-        assert pcOffset >= 0 && pcOffset < code.length;\n-\n-        \/\/ Decode the given instruction, and return the Pointer of\n-        \/\/ an embedded 32-bit operand word.\n-\n-        \/\/ If \"which\" is WhichOperand.disp32operand, selects the displacement portion\n-        \/\/ of an effective Pointer specifier.\n-        \/\/ If \"which\" is imm64Operand, selects the trailing immediate constant.\n-        \/\/ If \"which\" is WhichOperand.call32operand, selects the displacement of a call or jump.\n-        \/\/ Caller is responsible for ensuring that there is such an operand,\n-        \/\/ and that it is 32\/64 bits wide.\n-\n-        \/\/ If \"which\" is endPcOperand, find the end of the instruction.\n-\n-        int ip = pcOffset;\n-        boolean is64bit = false;\n-\n-        boolean hasDisp32 = false;\n-        int tailSize = 0; \/\/ other random bytes (#32, #16, etc.) at end of insn\n-\n-        boolean againAfterPrefix = true;\n-\n-        while (againAfterPrefix) {\n-            againAfterPrefix = false;\n-            switch (0xFF & code[ip++]) {\n-\n-                \/\/ These convenience macros generate groups of \"case\" labels for the switch.\n-\n-                case Prefix.CSSegment:\n-                case Prefix.SSSegment:\n-                case Prefix.DSSegment:\n-                case Prefix.ESSegment:\n-                case Prefix.FSSegment:\n-                case Prefix.GSSegment:\n-                    \/\/ Seems dubious\n-                    assert !targetIs64Bit : \"shouldn't have that prefix\";\n-                    assert ip == pcOffset + 1 : \"only one prefix allowed\";\n-                    againAfterPrefix = true;\n-                    break;\n-\n-                case 0x67:\n-                case Prefix.REX:\n-                case Prefix.REXB:\n-                case Prefix.REXX:\n-                case Prefix.REXXB:\n-                case Prefix.REXR:\n-                case Prefix.REXRB:\n-                case Prefix.REXRX:\n-                case Prefix.REXRXB:\n-                    assert targetIs64Bit : \"64bit prefixes\";\n-                    againAfterPrefix = true;\n-                    break;\n-\n-                case Prefix.REXW:\n-                case Prefix.REXWB:\n-                case Prefix.REXWX:\n-                case Prefix.REXWXB:\n-                case Prefix.REXWR:\n-                case Prefix.REXWRB:\n-                case Prefix.REXWRX:\n-                case Prefix.REXWRXB:\n-                    assert targetIs64Bit : \"64bit prefixes\";\n-                    is64bit = true;\n-                    againAfterPrefix = true;\n-                    break;\n-\n-                case 0xFF: \/\/ pushq a; decl a; incl a; call a; jmp a\n-                case 0x88: \/\/ movb a, r\n-                case 0x89: \/\/ movl a, r\n-                case 0x8A: \/\/ movb r, a\n-                case 0x8B: \/\/ movl r, a\n-                case 0x8F: \/\/ popl a\n-                    hasDisp32 = true;\n-                    break;\n-\n-                case 0x68: \/\/ pushq #32\n-                    currentEndOfInstruction = ip + 4;\n-                    return; \/\/ not produced by emitOperand\n-\n-                case 0x66: \/\/ movw ... (size prefix)\n-                    boolean againAfterSizePrefix2 = true;\n-                    while (againAfterSizePrefix2) {\n-                        againAfterSizePrefix2 = false;\n-                        switch (0xFF & code[ip++]) {\n-                            case Prefix.REX:\n-                            case Prefix.REXB:\n-                            case Prefix.REXX:\n-                            case Prefix.REXXB:\n-                            case Prefix.REXR:\n-                            case Prefix.REXRB:\n-                            case Prefix.REXRX:\n-                            case Prefix.REXRXB:\n-                            case Prefix.REXW:\n-                            case Prefix.REXWB:\n-                            case Prefix.REXWX:\n-                            case Prefix.REXWXB:\n-                            case Prefix.REXWR:\n-                            case Prefix.REXWRB:\n-                            case Prefix.REXWRX:\n-                            case Prefix.REXWRXB:\n-                                assert targetIs64Bit : \"64bit prefix found\";\n-                                againAfterSizePrefix2 = true;\n-                                break;\n-                            case 0x8B: \/\/ movw r, a\n-                            case 0x89: \/\/ movw a, r\n-                                hasDisp32 = true;\n-                                break;\n-                            case 0xC7: \/\/ movw a, #16\n-                                hasDisp32 = true;\n-                                tailSize = 2; \/\/ the imm16\n-                                break;\n-                            case 0x0F: \/\/ several SSE\/SSE2 variants\n-                                ip--; \/\/ reparse the 0x0F\n-                                againAfterPrefix = true;\n-                                break;\n-                            default:\n-                                throw new InternalError(\"should not reach here\");\n-                        }\n-                    }\n-                    break;\n-\n-                case 0xB8: \/\/ movl\/q r, #32\/#64(oop?)\n-                case 0xB9:\n-                case 0xBA:\n-                case 0xBB:\n-                case 0xBC:\n-                case 0xBD:\n-                case 0xBE:\n-                case 0xBF:\n-                    currentEndOfInstruction = ip + (is64bit ? 8 : 4);\n-                    return;\n-\n-                case 0x69: \/\/ imul r, a, #32\n-                case 0xC7: \/\/ movl a, #32(oop?)\n-                    tailSize = 4;\n-                    hasDisp32 = true; \/\/ has both kinds of operands!\n-                    break;\n-\n-                case 0x0F: \/\/ movx..., etc.\n-                    switch (0xFF & code[ip++]) {\n-                        case 0x3A: \/\/ pcmpestri\n-                            ip++; \/\/ skip opcode\n-                            tailSize = 1;\n-                            hasDisp32 = true; \/\/ has both kinds of operands!\n-                            break;\n-\n-                        case 0x38: \/\/ ptest, pmovzxbw\n-                            ip++; \/\/ skip opcode\n-                            hasDisp32 = true; \/\/ has both kinds of operands!\n-                            break;\n-\n-                        case 0x70: \/\/ pshufd r, r\/a, #8\n-                            hasDisp32 = true; \/\/ has both kinds of operands!\n-                            tailSize = 1;\n-                            break;\n-\n-                        case 0x73: \/\/ psrldq r, #8\n-                            tailSize = 1;\n-                            break;\n-\n-                        case 0x12: \/\/ movlps\n-                        case 0x28: \/\/ movaps\n-                        case 0x2E: \/\/ ucomiss\n-                        case 0x2F: \/\/ comiss\n-                        case 0x54: \/\/ andps\n-                        case 0x55: \/\/ andnps\n-                        case 0x56: \/\/ orps\n-                        case 0x57: \/\/ xorps\n-                        case 0x58: \/\/ addpd\n-                        case 0x59: \/\/ mulpd\n-                        case 0x6E: \/\/ movd\n-                        case 0x7E: \/\/ movd\n-                        case 0xAE: \/\/ ldmxcsr, stmxcsr, fxrstor, fxsave, clflush\n-                        case 0xFE: \/\/ paddd\n-                            \/\/ 64bit side says it these have both operands but that doesn't\n-                            \/\/ appear to be true\n-                            hasDisp32 = true;\n-                            break;\n-\n-                        case 0xAD: \/\/ shrd r, a, %cl\n-                        case 0xAF: \/\/ imul r, a\n-                        case 0xBE: \/\/ movsbl r, a (movsxb)\n-                        case 0xBF: \/\/ movswl r, a (movsxw)\n-                        case 0xB6: \/\/ movzbl r, a (movzxb)\n-                        case 0xB7: \/\/ movzwl r, a (movzxw)\n-                        case 0x40: \/\/ cmovl cc, r, a\n-                        case 0x41:\n-                        case 0x42:\n-                        case 0x43:\n-                        case 0x44:\n-                        case 0x45:\n-                        case 0x46:\n-                        case 0x47:\n-                        case 0x48:\n-                        case 0x49:\n-                        case 0x4A:\n-                        case 0x4B:\n-                        case 0x4C:\n-                        case 0x4D:\n-                        case 0x4E:\n-                        case 0x4F:\n-                        case 0xB0: \/\/ cmpxchgb\n-                        case 0xB1: \/\/ cmpxchg\n-                        case 0xC1: \/\/ xaddl\n-                        case 0xC7: \/\/ cmpxchg8\n-                        case 0x90: \/\/ setcc a\n-                        case 0x91:\n-                        case 0x92:\n-                        case 0x93:\n-                        case 0x94:\n-                        case 0x95:\n-                        case 0x96:\n-                        case 0x97:\n-                        case 0x98:\n-                        case 0x99:\n-                        case 0x9A:\n-                        case 0x9B:\n-                        case 0x9C:\n-                        case 0x9D:\n-                        case 0x9E:\n-                        case 0x9F:\n-                            hasDisp32 = true;\n-                            \/\/ fall out of the switch to decode the Pointer\n-                            break;\n-\n-                        case 0xC4: \/\/ pinsrw r, a, #8\n-                            hasDisp32 = true;\n-                            tailSize = 1;  \/\/ the imm8\n-                            break;\n-\n-                        case 0xC5: \/\/ pextrw r, r, #8\n-                            tailSize = 1;  \/\/ the imm8\n-                            break;\n-\n-                        case 0xAC: \/\/ shrd r, a, #8\n-                            hasDisp32 = true;\n-                            tailSize = 1; \/\/ the imm8\n-                            break;\n-\n-                        case 0x80: \/\/ jcc rdisp32\n-                        case 0x81:\n-                        case 0x82:\n-                        case 0x83:\n-                        case 0x84:\n-                        case 0x85:\n-                        case 0x86:\n-                        case 0x87:\n-                        case 0x88:\n-                        case 0x89:\n-                        case 0x8A:\n-                        case 0x8B:\n-                        case 0x8C:\n-                        case 0x8D:\n-                        case 0x8E:\n-                        case 0x8F:\n-                            currentEndOfInstruction = ip + 4;\n-                            return;\n-                        default:\n-                            throw new InternalError(\"should not reach here\");\n-                    }\n-                    break;\n-\n-                case 0x81: \/\/ addl a, #32; addl r, #32\n-                    \/\/ also: orl, adcl, sbbl, andl, subl, xorl, cmpl\n-                    \/\/ on 32bit in the case of cmpl, the imm might be an oop\n-                    tailSize = 4;\n-                    hasDisp32 = true; \/\/ has both kinds of operands!\n-                    break;\n-\n-                case 0x83: \/\/ addl a, #8; addl r, #8\n-                    \/\/ also: orl, adcl, sbbl, andl, subl, xorl, cmpl\n-                    hasDisp32 = true; \/\/ has both kinds of operands!\n-                    tailSize = 1;\n-                    break;\n-\n-                case 0x9B:\n-                    switch (0xFF & code[ip++]) {\n-                        case 0xD9: \/\/ fnstcw a\n-                            hasDisp32 = true;\n-                            break;\n-                        default:\n-                            throw new InternalError(\"should not reach here\");\n-                    }\n-                    break;\n-\n-                case 0x00: \/\/ addb a, r; addl a, r; addb r, a; addl r, a\n-                case 0x01:\n-                case 0x02:\n-                case 0x03:\n-                case 0x10: \/\/ adc...\n-                case 0x11:\n-                case 0x12:\n-                case 0x13:\n-                case 0x20: \/\/ and...\n-                case 0x21:\n-                case 0x22:\n-                case 0x23:\n-                case 0x30: \/\/ xor...\n-                case 0x31:\n-                case 0x32:\n-                case 0x33:\n-                case 0x08: \/\/ or...\n-                case 0x09:\n-                case 0x0a:\n-                case 0x0b:\n-                case 0x18: \/\/ sbb...\n-                case 0x19:\n-                case 0x1a:\n-                case 0x1b:\n-                case 0x28: \/\/ sub...\n-                case 0x29:\n-                case 0x2a:\n-                case 0x2b:\n-                case 0xF7: \/\/ mull a\n-                case 0x8D: \/\/ lea r, a\n-                case 0x87: \/\/ xchg r, a\n-                case 0x38: \/\/ cmp...\n-                case 0x39:\n-                case 0x3a:\n-                case 0x3b:\n-                case 0x85: \/\/ test r, a\n-                    hasDisp32 = true; \/\/ has both kinds of operands!\n-                    break;\n-\n-                case 0xC1: \/\/ sal a, #8; sar a, #8; shl a, #8; shr a, #8\n-                case 0xC6: \/\/ movb a, #8\n-                case 0x80: \/\/ cmpb a, #8\n-                case 0x6B: \/\/ imul r, a, #8\n-                    hasDisp32 = true; \/\/ has both kinds of operands!\n-                    tailSize = 1; \/\/ the imm8\n-                    break;\n-\n-                case Prefix.VEX_3BYTES:\n-                case Prefix.VEX_2BYTES:\n-                    assert ip == pcOffset + 1 : \"no prefixes allowed\";\n-                    int vexOpcode;\n-                    \/\/ First byte\n-                    if ((code[pcOffset] & 0xFF) == Prefix.VEX_3BYTES) {\n-                        vexOpcode = VexOpcode.VEX_OPCODE_MASK & code[ip];\n-                        ip++; \/\/ third byte\n-                        is64bit = ((VexPrefix.VEX_W & code[ip]) == VexPrefix.VEX_W);\n-                    } else {\n-                        vexOpcode = VexOpcode.VEX_OPCODE_0F;\n-                    }\n-                    ip++; \/\/ opcode\n-                    \/\/ To find the end of instruction (which == end_pc_operand).\n-                    switch (vexOpcode) {\n-                        case VexOpcode.VEX_OPCODE_0F:\n-                            switch (0xFF & code[ip]) {\n-                                case 0x70: \/\/ pshufd r, r\/a, #8\n-                                case 0x71: \/\/ ps[rl|ra|ll]w r, #8\n-                                case 0x72: \/\/ ps[rl|ra|ll]d r, #8\n-                                case 0x73: \/\/ ps[rl|ra|ll]q r, #8\n-                                case 0xC2: \/\/ cmp[ps|pd|ss|sd] r, r, r\/a, #8\n-                                case 0xC4: \/\/ pinsrw r, r, r\/a, #8\n-                                case 0xC5: \/\/ pextrw r\/a, r, #8\n-                                case 0xC6: \/\/ shufp[s|d] r, r, r\/a, #8\n-                                    tailSize = 1;  \/\/ the imm8\n-                                    break;\n-                                default:\n-                                    break; \/\/ no imm8\n-                            }\n-                            break;\n-                        case VexOpcode.VEX_OPCODE_0F_3A:\n-                            tailSize = 1;\n-                            break;\n-                        default:\n-                            throw new InternalError(\"should not reach here\");\n-                    }\n-                    ip++; \/\/ skip opcode\n-                    hasDisp32 = true;\n-                    break;\n-\n-                case 0xE8: \/\/ call rdisp32\n-                case 0xE9: \/\/ jmp rdisp32\n-                    currentEndOfInstruction = ip + 4;\n-                    return;\n-\n-                case 0xD1: \/\/ sal a, 1; sar a, 1; shl a, 1; shr a, 1\n-                case 0xD3: \/\/ sal a, %cl; sar a, %cl; shl a, %cl; shr a, %cl\n-                case 0xD9: \/\/ fldS a; fstS a; fstpS a; fldcw a\n-                case 0xDD: \/\/ fldD a; fstD a; fstpD a\n-                case 0xDB: \/\/ fildS a; fistpS a; fldX a; fstpX a\n-                case 0xDF: \/\/ fildD a; fistpD a\n-                case 0xD8: \/\/ faddS a; fsubrS a; fmulS a; fdivrS a; fcompS a\n-                case 0xDC: \/\/ faddD a; fsubrD a; fmulD a; fdivrD a; fcompD a\n-                case 0xDE: \/\/ faddpD a; fsubrpD a; fmulpD a; fdivrpD a; fcomppD a\n-                    hasDisp32 = true;\n-                    break;\n-\n-                case 0xF0: \/\/ Lock\n-                    againAfterPrefix = true;\n-                    break;\n-\n-                case 0xF3: \/\/ For SSE\n-                case 0xF2: \/\/ For SSE2\n-                    switch (0xFF & code[ip++]) {\n-                        case Prefix.REX:\n-                        case Prefix.REXB:\n-                        case Prefix.REXX:\n-                        case Prefix.REXXB:\n-                        case Prefix.REXR:\n-                        case Prefix.REXRB:\n-                        case Prefix.REXRX:\n-                        case Prefix.REXRXB:\n-                        case Prefix.REXW:\n-                        case Prefix.REXWB:\n-                        case Prefix.REXWX:\n-                        case Prefix.REXWXB:\n-                        case Prefix.REXWR:\n-                        case Prefix.REXWRB:\n-                        case Prefix.REXWRX:\n-                        case Prefix.REXWRXB:\n-                            assert targetIs64Bit : \"found 64bit prefix\";\n-                            ip++;\n-                            ip++;\n-                            break;\n-                        default:\n-                            ip++;\n-                    }\n-                    hasDisp32 = true; \/\/ has both kinds of operands!\n-                    break;\n-\n-                default:\n-                    throw new InternalError(\"should not reach here\");\n-            }\n-        }\n-\n-        assert hasDisp32 : \"(tw) not sure if this holds: instruction has no disp32 field\";\n-\n-        \/\/ parse the output of emitOperand\n-        int op2 = 0xFF & code[ip++];\n-        int base = op2 & 0x07;\n-        int op3 = -1;\n-        int b100 = 4;\n-        int b101 = 5;\n-        if (base == b100 && (op2 >> 6) != 3) {\n-            op3 = 0xFF & code[ip++];\n-            base = op3 & 0x07; \/\/ refetch the base\n-        }\n-        \/\/ now ip points at the disp (if any)\n-\n-        switch (op2 >> 6) {\n-            case 0:\n-                \/\/ [00 reg 100][ss index base]\n-                \/\/ [00 reg 100][00 100 esp]\n-                \/\/ [00 reg base]\n-                \/\/ [00 reg 100][ss index 101][disp32]\n-                \/\/ [00 reg 101] [disp32]\n-                if (base == b101) {\n-                    ip += 4; \/\/ skip the disp32\n-                }\n-                break;\n-\n-            case 1:\n-                \/\/ [01 reg 100][ss index base][disp8]\n-                \/\/ [01 reg 100][00 100 esp][disp8]\n-                \/\/ [01 reg base] [disp8]\n-                ip += 1; \/\/ skip the disp8\n-                break;\n-\n-            case 2:\n-                \/\/ [10 reg 100][ss index base][disp32]\n-                \/\/ [10 reg 100][00 100 esp][disp32]\n-                \/\/ [10 reg base] [disp32]\n-                ip += 4; \/\/ skip the disp32\n-                break;\n-\n-            case 3:\n-                \/\/ [11 reg base] (not a memory addressing mode)\n-                break;\n-        }\n-\n-        currentEndOfInstruction = ip + tailSize;\n-    }\n-\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/amd64\/AMD64InstructionDecoder.java","additions":0,"deletions":569,"binary":false,"changes":569,"status":"deleted"},{"patch":"@@ -1,116 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.collect;\n-\n-import jdk.tools.jaotc.LoadedClass;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.function.BiConsumer;\n-import java.io.File;\n-\n-public final class ClassSearch {\n-    private final List<SourceProvider> providers = new ArrayList<>();\n-\n-    public void addProvider(SourceProvider provider) {\n-        providers.add(provider);\n-    }\n-\n-    public List<LoadedClass> search(List<SearchFor> search, SearchPath searchPath) {\n-        return search(search, searchPath, (s, t) -> {\n-            throw new InternalError(s + \" : \" + t, t);\n-        });\n-    }\n-\n-    public List<LoadedClass> search(List<SearchFor> search, SearchPath searchPath, BiConsumer<String, Throwable> classLoadingErrorsHandler) {\n-        List<LoadedClass> loaded = new ArrayList<>();\n-\n-        List<ClassSource> sources = new ArrayList<>();\n-\n-        for (SearchFor entry : search) {\n-            sources.add(findSource(entry, searchPath, classLoadingErrorsHandler));\n-        }\n-\n-        for (ClassSource source : sources) {\n-            if (source != null) {\n-                source.eachClass((name, loader) -> {\n-                    LoadedClass x = loadClass(name, loader, classLoadingErrorsHandler);\n-                    if (x != null) {\n-                        loaded.add(x);\n-                    }\n-                });\n-            }\n-        }\n-\n-        return loaded;\n-    }\n-\n-    private static LoadedClass loadClass(String name, ClassLoader loader, BiConsumer<String, Throwable> classLoadingErrorsHandler) {\n-        try {\n-            Class<?> clzz = loader.loadClass(name);\n-            return new LoadedClass(name, clzz);\n-        } catch (Throwable e) {\n-            classLoadingErrorsHandler.accept(name, e);\n-            return null;\n-        }\n-    }\n-\n-    private ClassSource findSource(SearchFor searchFor, SearchPath searchPath, BiConsumer<String, Throwable> classLoadingErrorsHandler) {\n-        ClassSource found = null;\n-\n-        for (SourceProvider provider : providers) {\n-            if (!searchFor.isUnknown() && !provider.supports(searchFor.getType())) {\n-                continue;\n-            }\n-            ClassSource source = null;\n-            try {\n-                source = provider.findSource(searchFor.getName(), searchPath);\n-            } catch (Throwable e) {\n-                classLoadingErrorsHandler.accept(searchFor.getName(), e);\n-            }\n-            if (source != null) {\n-                if (found != null) {\n-                    throw new InternalError(\"Multiple possible sources: \" + source + \" and: \" + found);\n-                }\n-                found = source;\n-            }\n-        }\n-\n-        if (found == null) {\n-            classLoadingErrorsHandler.accept(searchFor.getName(), new InternalError(\"Failed to find \" + searchFor.getType() + \" file: \" + searchFor.getName()));\n-        }\n-        return found;\n-    }\n-\n-    public static List<SearchFor> makeList(String type, String argument) {\n-        List<SearchFor> list = new ArrayList<>();\n-        String[] elements = argument.split(File.pathSeparator);\n-        for (String element : elements) {\n-            list.add(new SearchFor(element, type));\n-        }\n-        return list;\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/collect\/ClassSearch.java","additions":0,"deletions":116,"binary":false,"changes":116,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.collect;\n-\n-import java.nio.file.Path;\n-import java.util.function.BiConsumer;\n-\n-public interface ClassSource {\n-    static boolean pathIsClassFile(Path entry) {\n-        String fileName = entry.getFileName().toString();\n-        return fileName.endsWith(\".class\") && !fileName.endsWith(\"module-info.class\");\n-    }\n-\n-    static String stripRoot(Path path) {\n-        if (path.getRoot() != null) {\n-            String root = path.getRoot().toString();\n-            String filename = path.toString().substring(root.length());\n-            String separator = path.getFileSystem().getSeparator();\n-            while (filename.startsWith(separator)) {\n-                filename = filename.substring(separator.length());\n-            }\n-            return filename;\n-        }\n-\n-        return path.toString();\n-    }\n-\n-    static String makeClassName(Path path) {\n-        String fileName = path.toString();\n-\n-        if (!fileName.endsWith(\".class\")) {\n-            throw new IllegalArgumentException(\"File doesn't end with .class: '\" + fileName + \"'\");\n-        }\n-\n-        fileName = stripRoot(path);\n-\n-        String className = fileName.substring(0, fileName.length() - \".class\".length());\n-        className = className.replace(path.getFileSystem().getSeparator(), \".\");\n-        return className;\n-    }\n-\n-    void eachClass(BiConsumer<String, ClassLoader> consumer);\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/collect\/ClassSource.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,103 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.collect;\n-\n-import java.io.IOException;\n-import java.net.MalformedURLException;\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n-import java.nio.file.DirectoryStream;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.HashMap;\n-\n-public class FileSupport {\n-    public boolean exists(Path path) {\n-        return Files.exists(path);\n-    }\n-\n-    public boolean isDirectory(Path path) {\n-        return Files.isDirectory(path);\n-    }\n-\n-    private static FileSystem makeJarFileSystem(Path path) {\n-        try {\n-            return FileSystems.newFileSystem(makeJarFileURI(path), new HashMap<>());\n-        } catch (IOException e) {\n-            throw new InternalError(e);\n-        }\n-    }\n-\n-    private static URI makeJarFileURI(Path path) {\n-        try {\n-            String name = path.toAbsolutePath().toString();\n-            name = name.replace('\\\\', '\/');\n-            return new URI(\"jar:file\", null, \"\/\/\/\" + name + \"!\/\", null);\n-        } catch (URISyntaxException e) {\n-            throw new InternalError(e);\n-        }\n-    }\n-\n-    public ClassLoader createClassLoader(Path path, ClassLoader parent) {\n-        try {\n-            return URLClassLoader.newInstance(buildUrls(path), parent);\n-        } catch (MalformedURLException e) {\n-            throw new InternalError(e);\n-        }\n-    }\n-\n-    public ClassLoader createClassLoader(Path path) throws MalformedURLException {\n-        return URLClassLoader.newInstance(buildUrls(path));\n-    }\n-\n-    private static URL[] buildUrls(Path path) throws MalformedURLException {\n-        return new URL[]{path.toUri().toURL()};\n-    }\n-\n-    public Path getJarFileSystemRoot(Path jarFile) {\n-        FileSystem fileSystem = makeJarFileSystem(jarFile);\n-        return fileSystem.getPath(\"\/\");\n-    }\n-\n-    public boolean isAbsolute(Path entry) {\n-        return entry.isAbsolute();\n-    }\n-\n-    public Path getSubDirectory(FileSystem fileSystem, Path root, Path path) throws IOException {\n-        DirectoryStream<Path> paths = fileSystem.provider().newDirectoryStream(root, null);\n-        for (Path entry : paths) {\n-            Path relative = root.relativize(entry);\n-            if (relative.equals(path)) {\n-                return entry;\n-            }\n-        }\n-        return null;\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/collect\/FileSupport.java","additions":0,"deletions":103,"binary":false,"changes":103,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.collect;\n-\n-import static java.nio.file.FileVisitResult.CONTINUE;\n-\n-import java.io.IOException;\n-import java.nio.file.FileVisitResult;\n-import java.nio.file.FileVisitor;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.PathMatcher;\n-import java.nio.file.SimpleFileVisitor;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-\n-\/**\n- * {@link FileVisitor} implementation to find class files recursively.\n- *\/\n-public final class FileSystemFinder extends SimpleFileVisitor<Path> implements Iterable<Path> {\n-    private final ArrayList<Path> fileNames = new ArrayList<>();\n-    private final PathMatcher filter;\n-\n-    public FileSystemFinder(Path combinedPath, PathMatcher filter) {\n-        this.filter = filter;\n-        try {\n-            Files.walkFileTree(combinedPath, this);\n-        } catch (IOException e) {\n-            throw new InternalError(e);\n-        }\n-    }\n-\n-    \/**\n-     * Compares the glob pattern against the file name.\n-     *\/\n-    private void find(Path file) {\n-        Path name = file.getFileName();\n-        if (name != null && filter.matches(name)) {\n-            fileNames.add(file);\n-        }\n-    }\n-\n-    @Override\n-    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n-        find(file);\n-        return CONTINUE;\n-    }\n-\n-    @Override\n-    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n-        find(dir);\n-        return CONTINUE;\n-    }\n-\n-    @Override\n-    public Iterator<Path> iterator() {\n-        return fileNames.iterator();\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/collect\/FileSystemFinder.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.collect;\n-\n-public final class SearchFor {\n-    private final String name;\n-    private final String type;\n-\n-    public SearchFor(String name) {\n-        this(name, \"\");\n-    }\n-\n-    public SearchFor(String name, String type) {\n-        this.name = name;\n-        this.type = type;\n-    }\n-\n-    boolean isUnknown() {\n-        return \"\".equals(type);\n-    }\n-\n-    String getType() {\n-        return this.type;\n-    }\n-\n-    String getName() {\n-        return this.name;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return type + \": \" + name;\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/collect\/SearchFor.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -1,89 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.collect;\n-\n-import java.nio.file.FileSystem;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-public class SearchPath {\n-    private final List<Path> searchPaths = new ArrayList<>();\n-    private final FileSupport fileSupport;\n-\n-    public SearchPath() {\n-        this(new FileSupport());\n-    }\n-\n-    public SearchPath(FileSupport fileSupport) {\n-        this.fileSupport = fileSupport;\n-    }\n-\n-    public Path find(FileSystem fileSystem, Path entry, String... defaults) {\n-        if (isAbsolute(entry)) {\n-            if (exists(entry)) {\n-                return entry;\n-            }\n-            return null;\n-        }\n-\n-        if (exists(entry)) {\n-            return entry;\n-        }\n-\n-        for (String searchPath : defaults) {\n-            Path newPath = fileSystem.getPath(searchPath, entry.toString());\n-            if (exists(newPath)) {\n-                return newPath;\n-            }\n-        }\n-\n-        for (Path searchPath : searchPaths) {\n-            Path newPath = fileSystem.getPath(searchPath.toString(), entry.toString());\n-            if (exists(newPath)) {\n-                return newPath;\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    private boolean isAbsolute(Path entry) {\n-        return fileSupport.isAbsolute(entry);\n-    }\n-\n-    private boolean exists(Path entry) {\n-        return fileSupport.exists(entry);\n-    }\n-\n-    public void add(String... paths) {\n-        for (String name : paths) {\n-            Path path = Paths.get(name);\n-            searchPaths.add(path);\n-        }\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/collect\/SearchPath.java","additions":0,"deletions":89,"binary":false,"changes":89,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.collect;\n-\n-public interface SourceProvider {\n-    ClassSource findSource(String name, SearchPath searchPath);\n-\n-    boolean supports(String type);\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/collect\/SourceProvider.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.collect.classname;\n-\n-import jdk.tools.jaotc.collect.ClassSource;\n-\n-import java.util.function.BiConsumer;\n-\n-public final class ClassNameSource implements ClassSource {\n-    private final String name;\n-    private final ClassLoader classLoader;\n-\n-    ClassNameSource(String name, ClassLoader classLoader) {\n-        this.name = name;\n-        this.classLoader = classLoader;\n-    }\n-\n-    @Override\n-    public void eachClass(BiConsumer<String, ClassLoader> consumer) {\n-        consumer.accept(name, classLoader);\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/collect\/classname\/ClassNameSource.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.collect.classname;\n-\n-import jdk.tools.jaotc.collect.ClassSource;\n-import jdk.tools.jaotc.collect.FileSupport;\n-import jdk.tools.jaotc.collect.SearchPath;\n-import jdk.tools.jaotc.collect.SourceProvider;\n-\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-\n-public final class ClassNameSourceProvider implements SourceProvider {\n-    public static final String TYPE = \"class\";\n-    private final ClassLoader classLoader;\n-\n-    public ClassNameSourceProvider(FileSupport fileSupport) {\n-        String classPath = System.getProperty(\"java.class.path\");\n-        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\n-        if (classPath != null && !classPath.isEmpty()) {\n-            classLoader = systemClassLoader;\n-        } else {\n-            Path path = Paths.get(\".\").toAbsolutePath();\n-            classLoader = fileSupport.createClassLoader(path, systemClassLoader);\n-        }\n-    }\n-\n-    @Override\n-    public ClassSource findSource(String name0, SearchPath searchPath) {\n-        String name = name0;\n-        Path path = Paths.get(name);\n-        if (ClassSource.pathIsClassFile(path)) {\n-            name = ClassSource.makeClassName(path);\n-        }\n-        try {\n-            classLoader.loadClass(name);\n-            return new ClassNameSource(name, classLoader);\n-        } catch (ClassNotFoundException e) {\n-            return null;\n-        }\n-    }\n-\n-    @Override\n-    public boolean supports(String type) {\n-        return TYPE.equals(type);\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/collect\/classname\/ClassNameSourceProvider.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.collect.directory;\n-\n-import jdk.tools.jaotc.collect.ClassSource;\n-import jdk.tools.jaotc.collect.FileSystemFinder;\n-\n-import java.nio.file.Path;\n-import java.util.function.BiConsumer;\n-\n-public final class DirectorySource implements ClassSource {\n-    private final Path directoryPath;\n-    private final ClassLoader classLoader;\n-\n-    DirectorySource(Path directoryPath, ClassLoader classLoader) {\n-        this.directoryPath = directoryPath;\n-        this.classLoader = classLoader;\n-    }\n-\n-    @Override\n-    public void eachClass(BiConsumer<String, ClassLoader> consumer) {\n-        FileSystemFinder finder = new FileSystemFinder(directoryPath, ClassSource::pathIsClassFile);\n-\n-        for (Path path : finder) {\n-            consumer.accept(ClassSource.makeClassName(directoryPath.relativize(path).normalize()), classLoader);\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"directory:\" + directoryPath.toString();\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/collect\/directory\/DirectorySource.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.collect.directory;\n-\n-import jdk.tools.jaotc.collect.ClassSource;\n-import jdk.tools.jaotc.collect.FileSupport;\n-import jdk.tools.jaotc.collect.SearchPath;\n-import jdk.tools.jaotc.collect.SourceProvider;\n-\n-import java.net.MalformedURLException;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Path;\n-\n-public final class DirectorySourceProvider implements SourceProvider {\n-    private final FileSupport fileSupport;\n-    private final FileSystem fileSystem;\n-    public static final String TYPE = \"directory\";\n-\n-    public DirectorySourceProvider(FileSupport fileSupport) {\n-        this.fileSupport = fileSupport;\n-        fileSystem = FileSystems.getDefault();\n-    }\n-\n-    @Override\n-    public ClassSource findSource(String name, SearchPath searchPath) {\n-        Path directoryPath = fileSystem.getPath(name);\n-\n-        if (!fileSupport.exists(directoryPath)) {\n-            return null;\n-        }\n-        if (!fileSupport.isDirectory(directoryPath)) {\n-            return null;\n-        }\n-\n-        try {\n-            ClassLoader classLoader = fileSupport.createClassLoader(directoryPath);\n-            return new DirectorySource(directoryPath, classLoader);\n-        } catch (MalformedURLException e) {\n-            return null;\n-        }\n-    }\n-\n-    @Override\n-    public boolean supports(String type) {\n-        return TYPE.equals(type);\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/collect\/directory\/DirectorySourceProvider.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.collect.jar;\n-\n-import jdk.tools.jaotc.collect.ClassSource;\n-import jdk.tools.jaotc.collect.FileSystemFinder;\n-\n-import java.nio.file.Path;\n-import java.util.function.BiConsumer;\n-\n-public final class JarFileSource implements ClassSource {\n-    private final Path jarFile;\n-    private final Path jarRootPath;\n-    private final ClassLoader classLoader;\n-\n-    JarFileSource(Path jarFile, Path jarRootPath, ClassLoader classLoader) {\n-        this.jarFile = jarFile;\n-        this.jarRootPath = jarRootPath;\n-        this.classLoader = classLoader;\n-    }\n-\n-    @Override\n-    public void eachClass(BiConsumer<String, ClassLoader> consumer) {\n-        FileSystemFinder finder = new FileSystemFinder(jarRootPath, ClassSource::pathIsClassFile);\n-\n-        for (Path path : finder) {\n-            consumer.accept(ClassSource.makeClassName(jarRootPath.relativize(path).normalize()), classLoader);\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"jar:\" + jarFile.toString();\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/collect\/jar\/JarFileSource.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.collect.jar;\n-\n-import jdk.tools.jaotc.collect.ClassSource;\n-import jdk.tools.jaotc.collect.FileSupport;\n-import jdk.tools.jaotc.collect.SearchPath;\n-import jdk.tools.jaotc.collect.SourceProvider;\n-\n-import java.net.MalformedURLException;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Path;\n-import java.nio.file.ProviderNotFoundException;\n-\n-public final class JarSourceProvider implements SourceProvider {\n-    private final FileSystem fileSystem;\n-    private final FileSupport fileSupport;\n-    public static final String TYPE = \"jar\";\n-\n-    public JarSourceProvider() {\n-        this(new FileSupport());\n-    }\n-\n-    public JarSourceProvider(FileSupport fileSupport) {\n-        this.fileSupport = fileSupport;\n-        fileSystem = FileSystems.getDefault();\n-    }\n-\n-    @Override\n-    public ClassSource findSource(String name, SearchPath searchPath) {\n-        Path fileName = fileSystem.getPath(name);\n-        Path jarFile = searchPath.find(fileSystem, fileName);\n-\n-        if (!validPath(jarFile)) {\n-            return null;\n-        }\n-\n-        return createSource(jarFile);\n-    }\n-\n-    private ClassSource createSource(Path jarFile) {\n-        try {\n-            Path jarRootPath = fileSupport.getJarFileSystemRoot(jarFile);\n-            if (jarRootPath == null) {\n-                return null;\n-            }\n-            ClassLoader classLoader = fileSupport.createClassLoader(jarFile);\n-            return new JarFileSource(jarFile, jarRootPath, classLoader);\n-        } catch (ProviderNotFoundException | MalformedURLException e) {\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public boolean supports(String type) {\n-        return TYPE.equals(type);\n-    }\n-\n-    private boolean validPath(Path jarFile) {\n-        return jarFile != null && !fileSupport.isDirectory(jarFile);\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/collect\/jar\/JarSourceProvider.java","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.collect.module;\n-\n-import jdk.tools.jaotc.collect.ClassSource;\n-import jdk.tools.jaotc.collect.FileSystemFinder;\n-\n-import java.nio.file.Path;\n-import java.util.function.BiConsumer;\n-\n-public final class ModuleSource implements ClassSource {\n-    private final Path modulePath;\n-    private final ClassLoader classLoader;\n-\n-    ModuleSource(Path modulePath, ClassLoader classLoader) {\n-        this.modulePath = modulePath;\n-        this.classLoader = classLoader;\n-    }\n-\n-    public Path getModulePath() {\n-        return modulePath;\n-    }\n-\n-    @Override\n-    public void eachClass(BiConsumer<String, ClassLoader> consumer) {\n-        FileSystemFinder finder = new FileSystemFinder(modulePath, ClassSource::pathIsClassFile);\n-\n-        for (Path path : finder) {\n-            consumer.accept(ClassSource.makeClassName(modulePath.relativize(path).normalize()), classLoader);\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"module:\" + modulePath.toString();\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/collect\/module\/ModuleSource.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.collect.module;\n-\n-import jdk.tools.jaotc.collect.ClassSource;\n-import jdk.tools.jaotc.collect.FileSupport;\n-import jdk.tools.jaotc.collect.SearchPath;\n-import jdk.tools.jaotc.collect.SourceProvider;\n-\n-import java.io.IOException;\n-import java.net.URI;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Path;\n-\n-public final class ModuleSourceProvider implements SourceProvider {\n-    private final FileSystem fileSystem;\n-    private final ClassLoader classLoader;\n-    private final FileSupport fileSupport;\n-    public static final String TYPE = \"module\";\n-\n-    public ModuleSourceProvider() {\n-        this(FileSystems.getFileSystem(URI.create(\"jrt:\/\")), ClassLoader.getSystemClassLoader(), new FileSupport());\n-    }\n-\n-    public ModuleSourceProvider(FileSystem fileSystem, ClassLoader classLoader, FileSupport fileSupport) {\n-        this.fileSystem = fileSystem;\n-        this.classLoader = classLoader;\n-        this.fileSupport = fileSupport;\n-    }\n-\n-    @Override\n-    public ClassSource findSource(String name, SearchPath searchPath) {\n-        Path path = fileSystem.getPath(name);\n-        Path dir = fileSystem.getPath(\"modules\");\n-\n-        if (dir == null || !fileSupport.isDirectory(dir)) {\n-            return null;\n-        }\n-\n-        Path found = findModuleDirectory(dir, path);\n-\n-        if (found == null) {\n-            return null;\n-        }\n-\n-        return new ModuleSource(found, classLoader);\n-    }\n-\n-    private Path findModuleDirectory(Path root, Path path) {\n-        try {\n-            return fileSupport.getSubDirectory(fileSystem, root, path);\n-        } catch (IOException e) {\n-            throw new InternalError(e);\n-        }\n-    }\n-\n-    @Override\n-    public boolean supports(String type) {\n-        return TYPE.equals(type);\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/collect\/module\/ModuleSourceProvider.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -1,193 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-package jdk.tools.jaotc.utils;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-public final class NativeOrderOutputStream {\n-    private final PatchableByteOutputStream os = new PatchableByteOutputStream();\n-    private final byte[] backingArray = new byte[8];\n-    private final ByteBuffer buffer;\n-    private final List<Patchable> patches = new ArrayList<>();\n-    private int size;\n-\n-    public NativeOrderOutputStream() {\n-        buffer = ByteBuffer.wrap(backingArray);\n-        buffer.order(ByteOrder.nativeOrder());\n-    }\n-\n-    public static int alignUp(int value, int alignment) {\n-        if (Integer.bitCount(alignment) != 1) {\n-            throw new IllegalArgumentException(\"Must be a power of 2\");\n-        }\n-\n-        int aligned = (value + (alignment - 1)) & -alignment;\n-\n-        if (aligned < value || (aligned & (alignment - 1)) != 0) {\n-            throw new RuntimeException(\"Error aligning: \" + value + \" -> \" + aligned);\n-        }\n-        return aligned;\n-    }\n-\n-    public NativeOrderOutputStream putLong(long value) {\n-        fillLong(value);\n-        os.write(backingArray, 0, 8);\n-        size += 8;\n-        return this;\n-    }\n-\n-    public NativeOrderOutputStream putInt(int value) {\n-        fillInt(value);\n-        os.write(backingArray, 0, 4);\n-        size += 4;\n-        return this;\n-    }\n-\n-    public NativeOrderOutputStream align(int alignment) {\n-        int aligned = alignUp(position(), alignment);\n-\n-        int diff = aligned - position();\n-        if (diff > 0) {\n-            byte[] b = new byte[diff];\n-            os.write(b, 0, b.length);\n-            size += diff;\n-        }\n-\n-        assert aligned == position();\n-        return this;\n-    }\n-\n-    public int position() {\n-        return os.size();\n-    }\n-\n-    private void fillInt(int value) {\n-        buffer.putInt(0, value);\n-    }\n-\n-    private void fillLong(long value) {\n-        buffer.putLong(0, value);\n-    }\n-\n-    private NativeOrderOutputStream putAt(byte[] data, int length, int position) {\n-        os.writeAt(data, length, position);\n-        return this;\n-    }\n-\n-    public NativeOrderOutputStream put(byte[] data) {\n-        os.write(data, 0, data.length);\n-        size += data.length;\n-        return this;\n-    }\n-\n-    public byte[] array() {\n-        checkPatches();\n-        byte[] bytes = os.toByteArray();\n-        assert size == bytes.length;\n-        return bytes;\n-    }\n-\n-    private void checkPatches() {\n-        for (Patchable patch : patches) {\n-            if (!patch.patched()) {\n-                throw new RuntimeException(\"Not all patches patched, missing at offset: \" + patch);\n-            }\n-        }\n-    }\n-\n-    public PatchableInt patchableInt() {\n-        int position = os.size();\n-        PatchableInt patchableInt = new PatchableInt(position);\n-        putInt(0);\n-        patches.add(patchableInt);\n-        return patchableInt;\n-    }\n-\n-    public abstract class Patchable {\n-        private final int position;\n-        private boolean patched = false;\n-\n-        Patchable(int position) {\n-            this.position = position;\n-        }\n-\n-        protected boolean patched() {\n-            return patched;\n-        }\n-\n-        protected void patch(int length) {\n-            putAt(backingArray, length, position);\n-            patched = true;\n-        }\n-\n-        public int position() {\n-            return position;\n-        }\n-    }\n-\n-    public class PatchableInt extends Patchable {\n-        private int value = 0;\n-\n-        public PatchableInt(int position) {\n-            super(position);\n-        }\n-\n-        public void set(int value) {\n-            this.value = value;\n-            fillInt(value);\n-            patch(4);\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            final StringBuilder sb = new StringBuilder(\"PatchableInt{\");\n-            sb.append(\"position=\").append(super.position()).append(\", \");\n-            sb.append(\"patched=\").append(patched()).append(\", \");\n-            sb.append(\"value=\").append(value);\n-            sb.append('}');\n-            return sb.toString();\n-        }\n-    }\n-\n-    private static class PatchableByteOutputStream extends ByteArrayOutputStream {\n-\n-        public void writeAt(byte[] data, int length, int position) {\n-            long end = (long) position + (long) length;\n-            if (buf.length < end) {\n-                throw new IllegalArgumentException(\"Array not properly sized\");\n-            }\n-            System.arraycopy(data, 0, buf, position, length);\n-        }\n-    }\n-}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/utils\/NativeOrderOutputStream.java","additions":0,"deletions":193,"binary":false,"changes":193,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * Defines the Ahead-of-Time (AOT) compiler, <em>{@index jaotc jaotc tool}<\/em>,\n- * for compiling Java classes into AOT library.\n- *\n- * @moduleGraph\n- * @since 9\n- *\/\n-module jdk.aot {\n-    requires jdk.internal.vm.ci;\n-    requires jdk.internal.vm.compiler;\n-    requires jdk.management;\n-}\n","filename":"src\/jdk.aot\/share\/classes\/module-info.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,209 +0,0 @@\n-.\\\" Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n-.\\\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-.\\\"\n-.\\\" This code is free software; you can redistribute it and\/or modify it\n-.\\\" under the terms of the GNU General Public License version 2 only, as\n-.\\\" published by the Free Software Foundation.\n-.\\\"\n-.\\\" This code is distributed in the hope that it will be useful, but WITHOUT\n-.\\\" ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-.\\\" FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-.\\\" version 2 for more details (a copy is included in the LICENSE file that\n-.\\\" accompanied this code).\n-.\\\"\n-.\\\" You should have received a copy of the GNU General Public License version\n-.\\\" 2 along with this work; if not, write to the Free Software Foundation,\n-.\\\" Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-.\\\"\n-.\\\" Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-.\\\" or visit www.oracle.com if you need additional information or have any\n-.\\\" questions.\n-.\\\"\n-.\\\" Automatically generated by Pandoc 2.3.1\n-.\\\"\n-.TH \"JAOTC\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n-.hy\n-.SH NAME\n-.PP\n-jaotc \\- The Java static compiler that produces native code for compiled\n-Java methods\n-.SH SYNOPSIS\n-.PP\n-\\f[CB]jaotc\\f[R] [\\f[I]options\\f[R]] [\\f[I]name\\f[R] | \\f[I]list\\f[R]]\n-.TP\n-.B \\f[I]options\\f[R]\n-Command\\-line options separated by spaces.\n-See \\f[B]jaotc Options\\f[R].\n-.RS\n-.RE\n-.TP\n-.B \\f[I]name\\f[R]\n-The Java class or jar file from which Java methods will be compiled.\n-.RS\n-.RE\n-.TP\n-.B \\f[I]list\\f[R]\n-Colon (\\f[CB]:\\f[R]) separated list of class names, modules, jar files or\n-directories which contain class files.\n-.RS\n-.RE\n-.SH DESCRIPTION\n-.PP\n-The \\f[CB]jaotc\\f[R] command is a Java Ahead\\-Of\\-Time (AOT) static\n-compiler which produces native code in the form of a shared library for\n-the Java methods in specified Java class files.\n-The Java Virtual Machine can load these AOT libraries and use native\n-code from them when corresponding Java methods are called.\n-By using \\f[CB]jaotc\\f[R], there is no need to wait for the JIT compiler\n-to generate (by compiling bytecode) the fast native code for these Java\n-methods.\n-The code is already generated by \\f[CB]jaotc\\f[R] and ready to be\n-immediately used.\n-For the same reason, there is no need to execute these methods in the\n-Interpreter because fast compiled native code can be executed instead.\n-.PP\n-\\f[B]Note:\\f[R]\n-.PP\n-The \\f[CB]jaotc\\f[R] command is experimental.\n-See \\f[B]JEP 295: Ahead\\-of\\-Time Compilation\\f[R]\n-[https:\/\/openjdk.java.net\/jeps\/295] for complete details.\n-.SH JAOTC OPTIONS\n-.TP\n-.B \\f[CB]\\-\\-output\\f[R] \\f[I]file\\f[R]\n-Output file name.\n-Default name is \"unnamed.so\".\n-.RS\n-.RE\n-.TP\n-.B \\f[CB]\\-\\-class\\-name\\f[R] \\f[I]class\\-names\\f[R]\n-List of Java classes to compile.\n-.RS\n-.RE\n-.TP\n-.B \\f[CB]\\-\\-jar\\f[R] \\f[I]jar\\-files\\f[R]\n-List of JAR files to compile.\n-.RS\n-.RE\n-.TP\n-.B \\f[CB]\\-\\-module\\f[R] \\f[I]modules\\f[R]\n-List of Java modules to compile.\n-.RS\n-.RE\n-.TP\n-.B \\f[CB]\\-\\-directory\\f[R] \\f[I]dirs\\f[R]\n-List of directories to search for files to compile.\n-.RS\n-.RE\n-.TP\n-.B \\f[CB]\\-\\-search\\-path\\f[R] \\f[I]dirs\\f[R]\n-List of directories to search for specified files.\n-.RS\n-.RE\n-.TP\n-.B \\f[CB]\\-\\-compile\\-commands\\f[R] \\f[I]file\\f[R]\n-Name of the file containing the compile commands:\n-.RS\n-.TP\n-.B \\f[CB]exclude\\f[R]\n-Excludes compilation of specified methods.\n-.RS\n-.RE\n-.TP\n-.B \\f[CB]compileOnly\\f[R]\n-Compiles only specified methods.\n-.RS\n-.RE\n-.PP\n-Regular expressions are used to specify classes and methods.\n-For example:\n-.IP\n-.nf\n-\\f[CB]\n-exclude\\ sun.util.resources..*.TimeZoneNames_.*.getContents\\\\(\\\\)\\\\[\\\\[Ljava\/lang\/Object;\\ \n-exclude\\ sun.security.ssl.*\\ \n-compileOnly\\ java.lang.String.*\n-\\f[R]\n-.fi\n-.RE\n-.TP\n-.B \\f[CB]\\-\\-compile\\-for\\-tiered\\f[R]\n-Generates profiling code for tiered compilation.\n-By default, profiling code is not generated (could be changed in a\n-future).\n-.RS\n-.RE\n-.TP\n-.B \\f[CB]\\-\\-compile\\-with\\-assertions\\f[R]\n-Generates code with java assertions.\n-By default, assertions code is not generated.\n-.RS\n-.RE\n-.TP\n-.B \\f[CB]\\-\\-compile\\-threads\\f[R] \\f[I]number\\f[R]\n-Sets the number of compilation threads used.\n-The default value is \\f[CB]min(16,\\ available_cpus)\\f[R].\n-.RS\n-.RE\n-.TP\n-.B \\f[CB]\\-\\-ignore\\-errors\\f[R]\n-Ignores all exceptions thrown during class loading.\n-By default, the tool will exit compilation if class loading throws an\n-exception.\n-.RS\n-.RE\n-.TP\n-.B \\f[CB]\\-\\-exit\\-on\\-error\\f[R]\n-Exits on compilation errors.\n-By default, failed compilation is skipped and compilation of other\n-methods continues.\n-.RS\n-.RE\n-.TP\n-.B \\f[CB]\\-\\-info\\f[R]\n-Prints information about compilation phases.\n-.RS\n-.RE\n-.TP\n-.B \\f[CB]\\-\\-verbose\\f[R]\n-Prints more details about compilation phases.\n-.RS\n-.RE\n-.TP\n-.B \\f[CB]\\-\\-debug\\f[R]\n-Prints comprehensive details.\n-.RS\n-.RE\n-.TP\n-.B \\f[CB]\\-\\-help\\f[R] or \\f[CB]\\-h\\f[R] or \\f[CB]\\-?\\f[R]\n-Prints a summary of standard options and exits the tool.\n-.RS\n-.RE\n-.TP\n-.B \\f[CB]\\-\\-version\\f[R]\n-Prints version information.\n-.RS\n-.RE\n-.TP\n-.B \\f[CB]\\-J\\f[R]\\f[I]flag\\f[R]\n-Provides a flag to pass to the runtime system.\n-To pass more than one flag, provide an instance of this option for each\n-flag or flag argument needed.\n-.RS\n-.RE\n-.SH JAOTC EXAMPLES\n-.PP\n-Use the \\f[CB]jaotc\\f[R] tool to execute AOT compilation.\n-.IP\n-.nf\n-\\f[CB]\n-jaotc\\ \\-\\-output\\ libHelloWorld.so\\ HelloWorld.class\n-\\f[R]\n-.fi\n-.PP\n-Specify a generated AOT library during application execution:\n-.IP\n-.nf\n-\\f[CB]\n-java\\ \\-XX:+UnlockExperimentalVMOptions\\ \\-XX:AOTLibrary=.\/libHelloWorld.so\\ HelloWorld\n-\\f[R]\n-.fi\n","filename":"src\/jdk.aot\/share\/man\/jaotc.1","additions":0,"deletions":209,"binary":false,"changes":209,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,2 +136,0 @@\n-  public boolean isAOT()                { return false; }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CodeBlob.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,0 @@\n-  private static int MISC_HAS_PASSED_FINGERPRINT_CHECK;\n@@ -137,1 +136,0 @@\n-    MISC_HAS_PASSED_FINGERPRINT_CHECK = db.lookupIntConstant(\"InstanceKlass::_misc_has_passed_fingerprint_check\").intValue();\n@@ -291,3 +289,0 @@\n-    if (hasStoredFingerprint()) {\n-      size += 8; \/\/ uint64_t\n-    }\n@@ -305,20 +300,0 @@\n-  public static boolean shouldStoreFingerprint() {\n-    VM vm = VM.getVM();\n-    if (vm.getCommandLineBooleanFlag(\"EnableJVMCI\") && !vm.getCommandLineBooleanFlag(\"UseJVMCICompiler\")) {\n-      return true;\n-    }\n-    if (vm.getCommandLineBooleanFlag(\"DumpSharedSpaces\")) {\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  public boolean hasStoredFingerprint() {\n-    \/\/ has_stored_fingerprint() @ instanceKlass.cpp can return true only if INCLUDE_AOT is\n-    \/\/ set during compilation.\n-    if (!VM.getVM().hasAOT()) {\n-      return false;\n-    }\n-    return shouldStoreFingerprint() || isShared();\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/InstanceKlass.java","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,2 +92,0 @@\n-  \/** Flag indicating if AOT is enabled in the build *\/\n-  private boolean      hasAOT;\n@@ -449,10 +447,0 @@\n-    \/\/ We infer AOT if _method @ methodCounters is declared.\n-    {\n-      Type type = db.lookupType(\"MethodCounters\");\n-      if (type.getField(\"_method\", false, false) == null) {\n-        hasAOT = false;\n-      } else {\n-        hasAOT = true;\n-      }\n-    }\n-\n@@ -844,5 +832,0 @@\n-  \/** Returns true if AOT is enabled, false otherwise *\/\n-  public boolean hasAOT() {\n-    return hasAOT;\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/VM.java","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1,82 +0,0 @@\n-#\n-# Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#############################################################################\n-#\n-# List of quarantined tests for testing with AOT.\n-#\n-#############################################################################\n-\n-serviceability\/sa\/CDSJMapClstats.java                   8216181   generic-all\n-serviceability\/sa\/ClhsdbAttach.java                     8216181   generic-all\n-serviceability\/sa\/ClhsdbCDSCore.java                    8216181   generic-all\n-serviceability\/sa\/ClhsdbCDSJstackPrintAll.java          8216181   generic-all\n-serviceability\/sa\/ClhsdbField.java                      8216181   generic-all\n-serviceability\/sa\/ClhsdbFindPC.java#id0                 8216181   generic-all\n-serviceability\/sa\/ClhsdbFindPC.java#id1                 8216181   generic-all\n-serviceability\/sa\/ClhsdbFlags.java                      8216181   generic-all\n-serviceability\/sa\/ClhsdbInspect.java                    8216181   generic-all\n-serviceability\/sa\/ClhsdbJdis.java                       8216181   generic-all\n-serviceability\/sa\/ClhsdbJhisto.java                     8216181   generic-all\n-serviceability\/sa\/ClhsdbJstack.java#id0                 8216181   generic-all\n-serviceability\/sa\/ClhsdbJstack.java#id1                 8216181   generic-all\n-serviceability\/sa\/ClhsdbJstackXcompStress.java          8216181   generic-all\n-serviceability\/sa\/ClhsdbLongConstant.java               8216181   generic-all\n-serviceability\/sa\/ClhsdbPmap.java                       8216181   generic-all\n-serviceability\/sa\/ClhsdbPrintAll.java                   8216181   generic-all\n-serviceability\/sa\/ClhsdbPrintAs.java                    8216181   generic-all\n-serviceability\/sa\/ClhsdbPrintStatics.java               8216181   generic-all\n-serviceability\/sa\/ClhsdbPstack.java                     8216181   generic-all\n-serviceability\/sa\/ClhsdbRegionDetailsScanOopsForG1.java 8216181   generic-all\n-serviceability\/sa\/ClhsdbScanOops.java#id0               8216181   generic-all\n-serviceability\/sa\/ClhsdbScanOops.java#id1               8216181   generic-all\n-serviceability\/sa\/ClhsdbSource.java                     8216181   generic-all\n-serviceability\/sa\/ClhsdbThread.java                     8216181   generic-all\n-serviceability\/sa\/ClhsdbVmStructsDump.java              8216181   generic-all\n-serviceability\/sa\/ClhsdbWhere.java                      8216181   generic-all\n-serviceability\/sa\/DeadlockDetectionTest.java            8216181   generic-all\n-serviceability\/sa\/JhsdbThreadInfoTest.java              8216181   generic-all\n-serviceability\/sa\/jmap-hprof\/JMapHProfLargeHeapTest.java 8216181   generic-all\n-serviceability\/sa\/sadebugd\/DebugdConnectTest.java       8216181   generic-all\n-serviceability\/sa\/sadebugd\/SADebugDTest.java            8216181   generic-all\n-serviceability\/sa\/TestClassDump.java                    8216181   generic-all\n-serviceability\/sa\/TestClhsdbJstackLock.java             8216181   generic-all\n-serviceability\/sa\/TestCpoolForInvokeDynamic.java        8216181   generic-all\n-serviceability\/sa\/TestDefaultMethods.java               8216181   generic-all\n-serviceability\/sa\/TestG1HeapRegion.java                 8216181   generic-all\n-serviceability\/sa\/TestHeapDumpForInvokeDynamic.java     8216181   generic-all\n-serviceability\/sa\/TestHeapDumpForLargeArray.java        8216181   generic-all\n-serviceability\/sa\/TestInstanceKlassSizeForInterface.java 8216181   generic-all\n-serviceability\/sa\/TestInstanceKlassSize.java            8216181   generic-all\n-serviceability\/sa\/TestIntConstant.java                  8216181   generic-all\n-serviceability\/sa\/TestJhsdbJstackLock.java              8216181   generic-all\n-serviceability\/sa\/TestJhsdbJstackMixed.java             8216181   generic-all\n-serviceability\/sa\/TestJmapCore.java                     8216181   generic-all\n-serviceability\/sa\/TestJmapCoreMetaspace.java            8216181   generic-all\n-serviceability\/sa\/TestPrintMdo.java                     8216181   generic-all\n-serviceability\/sa\/TestRevPtrsForInvokeDynamic.java      8216181   generic-all\n-serviceability\/sa\/TestType.java                         8216181   generic-all\n-serviceability\/sa\/TestUniverse.java                     8216181   generic-all\n-\n-vmTestbase\/vm\/mlvm\/indy\/stress\/java\/relinkMutableCallSiteFreq\/Test.java   8226689 generic-all\n-vmTestbase\/vm\/mlvm\/indy\/stress\/java\/relinkVolatileCallSiteFreq\/Test.java  8226689 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-aot.txt","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -68,2 +68,0 @@\n-    vm.aot \\\n-    vm.aot.enabled \\\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  -:tier1_compiler_aot_jvmci \\\n+  -compiler\/jvmci \\\n@@ -154,1 +154,0 @@\n-  compiler\/aot \\\n@@ -157,4 +156,0 @@\n-tier1_compiler_aot_jvmci = \\\n-  compiler\/aot \\\n-  compiler\/jvmci\n-\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary run CTW for all classes from jdk.aot module\n- *\n- * @library \/test\/lib \/ \/testlibrary\/ctw\/src\n- * @modules java.base\/jdk.internal.access\n- *          java.base\/jdk.internal.jimage\n- *          java.base\/jdk.internal.misc\n- *          java.base\/jdk.internal.reflect\n- * @modules jdk.aot\n- *\n- * @build sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver\/timeout=7200 sun.hotspot.tools.ctw.CtwRunner modules:jdk.aot\n- *\/\n","filename":"test\/hotspot\/jtreg\/applications\/ctw\/modules\/jdk_aot.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -1,280 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.aot;\n-\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.artifacts.Artifact;\n-import jdk.test.lib.artifacts.ArtifactResolver;\n-import jdk.test.lib.artifacts.ArtifactResolverException;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import java.io.File;\n-import java.io.IOException;\n-import java.lang.annotation.Annotation;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.StandardOpenOption;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import jdk.test.lib.JDKToolLauncher;\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.process.ProcessTools;\n-\n-\/**\n- * A simple class calling AOT compiler over requested items\n- *\/\n-public class AotCompiler {\n-\n-    private final static String METHODS_LIST_FILENAME = \"methodsList.txt\";\n-\n-    public static void main(String args[]) {\n-        String className = null;\n-        List<String> compileList = new ArrayList<>();\n-        String libName = null;\n-        List<String> extraopts = new ArrayList<>();\n-        for (int i = 0; i < args.length; i++) {\n-            switch (args[i]) {\n-                case \"-class\":\n-                    className = args[++i];\n-                    break;\n-                case \"-compile\":\n-                    compileList.add(\"compileOnly \" + args[++i]);\n-                    break;\n-                case \"-libname\":\n-                    libName = args[++i];\n-                    break;\n-                case \"-extraopt\":\n-                    extraopts.add(args[++i]);\n-                    break;\n-                default:\n-                    throw new Error(\"Unknown option: \" + args[i]);\n-            }\n-        }\n-        extraopts.add(\"-classpath\");\n-        extraopts.add(Utils.TEST_CLASS_PATH + File.pathSeparator + Utils.TEST_SRC);\n-        if (className != null && libName != null) {\n-            OutputAnalyzer oa = launchCompiler(libName, className, extraopts, compileList);\n-            oa.shouldHaveExitValue(0);\n-        } else {\n-            printUsage();\n-            throw new Error(\"Mandatory arguments aren't passed\");\n-        }\n-    }\n-\n-    public static OutputAnalyzer launchCompilerSimple(String... args) {\n-        return launchJaotc(Arrays.asList(args), null);\n-    }\n-\n-    public static OutputAnalyzer launchCompiler(String libName, String item, List<String> extraopts,\n-            List<String> compList) {\n-        Path file = null;\n-        if (compList != null && !compList.isEmpty()) {\n-            file = Paths.get(METHODS_LIST_FILENAME);\n-            try {\n-                Files.write(file, compList, StandardOpenOption.CREATE);\n-            } catch (IOException e) {\n-                throw new Error(\"Couldn't write \" + METHODS_LIST_FILENAME + \" \" + e, e);\n-            }\n-        }\n-        List<String> args = new ArrayList<>();\n-        args.add(\"--compile-with-assertions\");\n-        args.add(\"--info\");\n-        args.add(\"--output\");\n-        args.add(libName);\n-        if (file != null) {\n-            args.add(\"--compile-commands\");\n-            args.add(file.toString());\n-        }\n-        args.add(\"--class-name\");\n-        args.add(item);\n-        String linker = resolveLinker();\n-        if (linker != null) {\n-            args.add(\"--linker-path\");\n-            args.add(linker);\n-        }\n-        \/\/ Execute with asserts\n-        args.add(\"-J-ea\");\n-        args.add(\"-J-esa\");\n-        \/\/ we don't want to run jaotc w\/ Xcomp even if it's in extraopts\n-        args.add(\"-J-Xmixed\");\n-        return launchJaotc(args, extraopts);\n-    }\n-\n-    private static OutputAnalyzer launchJaotc(List<String> args, List<String> extraVmOpts) {\n-        JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(\"jaotc\");\n-        for (String vmOpt : Utils.getTestJavaOpts()) {\n-            launcher.addVMArg(vmOpt);\n-        }\n-        if (extraVmOpts != null) {\n-            for (String vmOpt : extraVmOpts) {\n-                launcher.addVMArg(vmOpt);\n-            }\n-        }\n-        for (String arg : args) {\n-            launcher.addToolArg(arg);\n-        }\n-        try {\n-            return ProcessTools.executeCommand(new ProcessBuilder(launcher.getCommand()).redirectErrorStream(true));\n-        } catch (Throwable e) {\n-            throw new Error(\"Can't start test process: \" + e, e);\n-        }\n-    }\n-\n-    public static void printUsage() {\n-        System.err.println(\"Usage: \" + AotCompiler.class.getName()\n-                + \" -class <class> -libname <.so name>\"\n-                + \" [-compile <compileItems>]* [-extraopt <java option>]*\");\n-    }\n-\n-    \/\/ runs ld -v and check its exit code\n-    private static boolean checkLd(Path bin) {\n-        try {\n-            return 0 == ProcessTools.executeCommand(bin.toString(), \"-v\")\n-                                    .getExitValue();\n-        } catch (Throwable t) {\n-            \/\/ any errors mean ld doesn't work\n-            return false;\n-        }\n-    }\n-\n-    public static String resolveLinker() {\n-        Path linker = null;\n-        \/\/ if non windows, 1st, check if PATH has ld\n-        if (!Platform.isWindows()) {\n-            String bin = \"ld\";\n-            for (String path : System.getenv(\"PATH\").split(File.pathSeparator)) {\n-                Path ld = Paths.get(path).resolve(\"ld\");\n-                if (Files.exists(ld)) {\n-                    \/\/ there is ld in PATH\n-                    if (checkLd(ld)) {\n-                        System.out.println(\"found working linker: \" + ld);\n-                        \/\/ ld works, jaotc is supposed to find and use it\n-                        return null;\n-                    } else {\n-                        System.out.println(\"found broken linker: \" + ld);\n-                        \/\/ ld exists in PATH, but doesn't work, have to use devkit\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-        \/\/ there is no ld in PATH, will use ld from devkit\n-        \/\/ artifacts are got from common\/conf\/jib-profiles.js\n-        try {\n-            if (Platform.isWindows()) {\n-                if (Platform.isX64()) {\n-                    @Artifact(organization = \"jpg.infra.builddeps\",\n-                            name = \"devkit-windows_x64\",\n-                            revision = \"VS2017-15.5.5+1.0\",\n-                            extension = \"tar.gz\")\n-                    class DevkitWindowsX64 { }\n-                    String artifactName = \"jpg.infra.builddeps.\"\n-                            + \"devkit-windows_x64-\"\n-                            + \"VS2017-15.5.5+1.0\";\n-                    Path devkit = ArtifactResolver.resolve(DevkitWindowsX64.class)\n-                                                  .get(artifactName);\n-                    linker = devkit.resolve(\"VC\")\n-                                   .resolve(\"bin\")\n-                                   .resolve(\"x64\")\n-                                   .resolve(\"link.exe\");\n-                }\n-            } else if (Platform.isOSX()) {\n-                @Artifact(organization =  \"jpg.infra.builddeps\",\n-                        name = \"devkit-macosx_x64\",\n-                        revision = \"Xcode6.3-MacOSX10.9+1.0\",\n-                        extension = \"tar.gz\")\n-                class DevkitMacosx { }\n-                String artifactName = \"jpg.infra.builddeps.\"\n-                        + \"devkit-macosx_x64-\"\n-                        + \"Xcode6.3-MacOSX10.9+1.0\";\n-                Path devkit = ArtifactResolver.resolve(DevkitMacosx.class)\n-                                              .get(artifactName);\n-                linker = devkit.resolve(\"Xcode.app\")\n-                               .resolve(\"Contents\")\n-                               .resolve(\"Developer\")\n-                               .resolve(\"Toolchains\")\n-                               .resolve(\"XcodeDefault.xctoolchain\")\n-                               .resolve(\"usr\")\n-                               .resolve(\"bin\")\n-                               .resolve(\"ld\");\n-            } else if (Platform.isLinux()) {\n-                if (Platform.isAArch64()) {\n-                    @Artifact(organization = \"jpg.infra.builddeps\",\n-                            name = \"devkit-linux_aarch64\",\n-                            revision = \"gcc-linaro-aarch64-linux-gnu-4.8-2013.11_linux+1.0\",\n-                            extension = \"tar.gz\")\n-                    class DevkitLinuxAArch64 { }\n-\n-                    String artifactName = \"jpg.infra.builddeps.\"\n-                            + \"devkit-linux_aarch64-\"\n-                            + \"gcc-linaro-aarch64-linux-gnu-4.8-2013.11_linux+1.0\";\n-                    Path devkit = ArtifactResolver.resolve(DevkitLinuxAArch64.class)\n-                                                  .get(artifactName);\n-                    linker = devkit.resolve(\"aarch64-linux-gnu\")\n-                                   .resolve(\"bin\")\n-                                   .resolve(\"ld\");\n-                } else if (Platform.isARM()) {\n-                    @Artifact(organization = \"jpg.infra.builddeps\",\n-                            name = \"devkit-linux_arm\",\n-                            revision = \"gcc-linaro-arm-linux-gnueabihf-raspbian-2012.09-20120921_linux+1.0\",\n-                            extension = \"tar.gz\")\n-                    class DevkitLinuxARM { }\n-\n-                    String artifactName = \"jpg.infra.builddeps.\"\n-                            + \"devkit-linux_arm-\"\n-                            + \"gcc-linaro-arm-linux-gnueabihf-raspbian-2012.09-20120921_linux+1.0\";\n-                    Path devkit = ArtifactResolver.resolve(DevkitLinuxARM.class)\n-                                                  .get(artifactName);\n-                    linker = devkit.resolve(\"arm-linux-gnueabihf\")\n-                                   .resolve(\"bin\")\n-                                   .resolve(\"ld\");\n-                } else if (Platform.isX64()) {\n-                    @Artifact(organization = \"jpg.infra.builddeps\",\n-                            name = \"devkit-linux_x64\",\n-                            revision = \"gcc7.3.0-OEL6.4+1.0\",\n-                            extension = \"tar.gz\")\n-                    class DevkitLinuxX64 { }\n-\n-                    String artifactName = \"jpg.infra.builddeps.\"\n-                            + \"devkit-linux_x64-\"\n-                            + \"gcc7.3.0-OEL6.4+1.0\";\n-                    Path devkit = ArtifactResolver.resolve(DevkitLinuxX64.class)\n-                                                  .get(artifactName);\n-                    linker = devkit.resolve(\"bin\")\n-                                   .resolve(\"ld\");\n-                }\n-            }\n-        } catch (ArtifactResolverException e) {\n-            System.err.println(\"artifact resolution error: \" + e);\n-            e.printStackTrace(System.err);\n-            \/\/ let jaotc try to find linker\n-            return null;\n-        }\n-        if (linker != null) {\n-            return linker.toAbsolutePath().toString();\n-        }\n-        return null;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/AotCompiler.java","additions":0,"deletions":280,"binary":false,"changes":280,"status":"deleted"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.aot.DeoptimizationTest\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler -libname libDeoptimizationTest.so\n- *     -class compiler.aot.DeoptimizationTest\n- *     -compile compiler.aot.DeoptimizationTest.testMethod()D\n- *     -extraopt -XX:-UseCompressedOops\n- * @run main\/othervm -Xmixed -XX:+UnlockExperimentalVMOptions -XX:+UseAOT -XX:+TieredCompilation\n- *     -XX:-UseCompressedOops\n- *     -XX:CompileCommand=dontinline,compiler.aot.DeoptimizationTest::*\n- *     -XX:AOTLibrary=.\/libDeoptimizationTest.so -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     compiler.aot.DeoptimizationTest\n- * @summary check if aot code can be deoptimized\n- *\/\n-\n-package compiler.aot;\n-\n-import java.lang.reflect.Method;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.Utils;\n-import sun.hotspot.WhiteBox;\n-import compiler.whitebox.CompilerWhiteBoxTest;\n-\n-public final class DeoptimizationTest {\n-    private static final String TEST_METHOD = \"testMethod\";\n-    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n-    private final Method testMethod;\n-\n-    private DeoptimizationTest() {\n-        try {\n-            testMethod = getClass().getDeclaredMethod(TEST_METHOD);\n-        } catch (NoSuchMethodException e) {\n-            throw new Error(\"TEST BUG: no test method found\", e);\n-        }\n-    }\n-\n-    public static void main(String args[]) {\n-        new DeoptimizationTest().test();\n-    }\n-\n-    private double testMethod() {\n-        return 42 \/ 0;\n-    }\n-\n-    private void test() {\n-        Asserts.assertTrue(WB.isMethodCompiled(testMethod),\n-                \"Method expected to be compiled\");\n-        Asserts.assertEQ(WB.getMethodCompilationLevel(testMethod),\n-                CompilerWhiteBoxTest.COMP_LEVEL_AOT,\n-                \"Unexpected compilation level at start\");\n-        Utils.runAndCheckException(() -> testMethod(), ArithmeticException.class);\n-        Asserts.assertFalse(WB.isMethodCompiled(testMethod),\n-                \"Method is unexpectedly compiled after deoptimization\");\n-        Asserts.assertEQ(WB.getMethodCompilationLevel(testMethod), 0,\n-                \"Unexpected compilation level after deoptimization\");\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/DeoptimizationTest.java","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.aot;\n-\n-public class HelloWorldPrinter {\n-    public static final String MESSAGE = \"Hello world\";\n-    public static final String CLINIT_MESSAGE = \"Hello <clinit> world\";\n-\n-    static {\n-        System.out.println(CLINIT_MESSAGE);\n-    }\n-\n-    public static void main(String args[]) {\n-        print();\n-    }\n-\n-    public static void print() {\n-        System.out.println(MESSAGE);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/HelloWorldPrinter.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,110 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.aot.RecompilationTest\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler -libname libRecompilationTest1.so\n- *     -class compiler.whitebox.SimpleTestCaseHelper\n- *     -extraopt -Dgraal.TieredAOT=true -extraopt -Dgraal.ProfileSimpleMethods=true\n- *     -extraopt -Dgraal.ProbabilisticProfiling=false\n- *     -extraopt -XX:+UnlockDiagnosticVMOptions -extraopt -XX:+WhiteBoxAPI -extraopt -Xbootclasspath\/a:.\n- *     -extraopt -XX:-UseCompressedOops\n- *     -extraopt -XX:CompileCommand=dontinline,compiler.whitebox.SimpleTestCaseHelper::*\n- * @run driver compiler.aot.AotCompiler -libname libRecompilationTest2.so\n- *     -class compiler.whitebox.SimpleTestCaseHelper\n- *     -extraopt -Dgraal.TieredAOT=false\n- *     -extraopt -XX:+UnlockDiagnosticVMOptions -extraopt -XX:+WhiteBoxAPI -extraopt -Xbootclasspath\/a:.\n- *     -extraopt -XX:-UseCompressedOops\n- *     -extraopt -XX:CompileCommand=dontinline,compiler.whitebox.SimpleTestCaseHelper::*\n- * @run main\/othervm -Xmixed -Xbatch -XX:+UnlockExperimentalVMOptions -XX:+UseAOT -XX:-TieredCompilation\n- *     -XX:-UseCounterDecay -XX:-UseCompressedOops\n- *     -XX:-Inline\n- *     -XX:AOTLibrary=.\/libRecompilationTest2.so -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     -Dcompiler.aot.RecompilationTest.check_level=-1\n- *     compiler.aot.RecompilationTest\n- * @summary check if recompilation after aot goes fine\n- *\/\n-\n- \/* having whitebox-related options for aot compiler is a temporary solution,\n-    because of JDK-8146201\n- *\/\n-\n-package compiler.aot;\n-\n-import compiler.whitebox.CompilerWhiteBoxTest;\n-import java.lang.reflect.Executable;\n-import jdk.test.lib.Asserts;\n-\n-public final class RecompilationTest extends CompilerWhiteBoxTest {\n-    private static final int CHECK_LEVEL = Integer.getInteger(\n-                \"compiler.aot.RecompilationTest.check_level\");\n-\n-    public static void main(String args[]) {\n-        CompilerWhiteBoxTest.main(RecompilationTest::new, args);\n-    }\n-\n-    private RecompilationTest(TestCase testCase) {\n-        super(testCase);\n-    }\n-\n-    @Override\n-    protected void test() throws Exception {\n-        if (testCase.isOsr()) {\n-            \/* aot compiler is not using osr compilation *\/\n-            System.out.println(\"Skipping OSR case\");\n-            return;\n-        }\n-        Executable e = testCase.getExecutable();\n-        Asserts.assertTrue(WHITE_BOX.isMethodCompiled(e),\n-                testCase.name() +  \": an executable expected to be compiled\");\n-        Asserts.assertEQ(WHITE_BOX.getMethodCompilationLevel(e),\n-                COMP_LEVEL_AOT,\n-                String.format(\"%s: unexpected compilation level at start\",\n-                        testCase.name()));\n-        compile();\n-        Asserts.assertTrue(WHITE_BOX.isMethodCompiled(e), testCase.name()\n-                + \": method expected to be compiled\");\n-        \/* a case with AOT'ed code checks exact compilation level equality\n-           while another case checks minimum level and if method compiled\n-           because there might be different compilation level transitions *\/\n-        if (CHECK_LEVEL != COMP_LEVEL_AOT) {\n-            Asserts.assertGTE(WHITE_BOX.getMethodCompilationLevel(e),\n-                CHECK_LEVEL,\n-                String.format(\"%s: expected compilation level\"\n-                        + \" after compilation to be no less than %d for %s\",\n-                        testCase.name(), CHECK_LEVEL, testCase.name()));\n-        } else {\n-            Asserts.assertEQ(WHITE_BOX.getMethodCompilationLevel(e),\n-                COMP_LEVEL_AOT, String.format(\"%s: expected compilation\"\n-                        + \" level after compilation to be equal to %d for %s\",\n-                        testCase.name(), COMP_LEVEL_AOT, testCase.name()));\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/RecompilationTest.java","additions":0,"deletions":110,"binary":false,"changes":110,"status":"deleted"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.aot.SharedUsageTest\n- *        compiler.aot.AotCompiler\n- * @run driver compiler.aot.AotCompiler -libname libSharedUsageTest.so\n- *      -class compiler.aot.SharedUsageTest\n- *      -extraopt -XX:-UseCompressedOops\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/libSharedUsageTest.so\n- *      -XX:-UseCompressedOops\n- *      -Dcompiler.aot.SharedUsageTest.parent=true\n- *      compiler.aot.SharedUsageTest\n- * @summary check if .so can be successfully shared with 2 java processes\n- *\/\n-\n-package compiler.aot;\n-\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.ExitCode;\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-public class SharedUsageTest {\n-    private static final String HELLO_MSG = \"HelloWorld\";\n-    private static final boolean ADD_TEST_VM_OPTION = false;\n-    private static boolean shouldBeFalseInParent = false;\n-    private static final boolean IS_PARENT = Boolean.getBoolean(\n-        \"compiler.aot.SharedUsageTest.parent\");\n-\n-    public static void main(String args[]) throws Throwable {\n-        Asserts.assertFalse(shouldBeFalseInParent,\n-                \"A test invariant is broken\");\n-        if (IS_PARENT) {\n-            \/* An output of .so being used is verified after launch.\n-               A respective message is triggered by PrintAOT option. *\/\n-            CommandLineOptionTest.verifyJVMStartup(\n-                    new String[]{\"libSharedUsageTest.so  aot library\",\n-                        HELLO_MSG}, null, \"Unexpected exit code\",\n-                    \"Unexpected output\", ExitCode.OK, ADD_TEST_VM_OPTION,\n-                    \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseAOT\", \"-XX:+PrintAOT\",\n-                    \"-Dtest.jdk=\" + Utils.TEST_JDK,\n-                    \"-XX:AOTLibrary=.\/libSharedUsageTest.so\",\n-                    SharedUsageTest.class.getName());\n-            Asserts.assertFalse(shouldBeFalseInParent, \"A static member got \"\n-                    + \"unexpectedly changed\");\n-        } else {\n-            shouldBeFalseInParent = true;\n-            Asserts.assertTrue(shouldBeFalseInParent, \"A static member wasn't\"\n-                    + \"changed as expected\");\n-            System.out.println(HELLO_MSG);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/SharedUsageTest.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Arm Limited. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8244164\n- * @requires vm.aot & vm.bits == 64\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.aot.TestHeapBase\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler -libname libTestHeapBase.so\n- *     -class compiler.aot.TestHeapBase\n- *     -compile compiler.aot.TestHeapBase.test()V\n- *     -extraopt -XX:+UseCompressedOops -extraopt -Xmx1g\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *     -XX:+UseCompressedOops -XX:HeapBaseMinAddress=32g\n- *     -XX:AOTLibrary=.\/libTestHeapBase.so -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xlog:aot+class+load=trace\n- *     compiler.aot.TestHeapBase\n- * @summary check for crash when jaotc is run with zero-based compressed oops then\n- *          generated code is loaded in vm with non-zero-based compressed oops.\n- *\/\n-\n-package compiler.aot;\n-\n-import java.lang.reflect.Method;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.Utils;\n-import sun.hotspot.WhiteBox;\n-import compiler.whitebox.CompilerWhiteBoxTest;\n-\n-public final class TestHeapBase {\n-    private static final String TEST_METHOD = \"test\";\n-    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n-    private final Method testMethod;\n-\n-    private TestHeapBase() {\n-        try {\n-            testMethod = getClass().getDeclaredMethod(TEST_METHOD);\n-        } catch (NoSuchMethodException e) {\n-            throw new Error(\"TEST BUG: no test method found\", e);\n-        }\n-    }\n-\n-    public static void main(String args[]) {\n-        new TestHeapBase().test();\n-    }\n-\n-    private void test() {\n-        System.out.println(\"Hello, World!\");\n-\n-        Asserts.assertTrue(WB.isMethodCompiled(testMethod),\n-                \"Method expected to be compiled\");\n-        Asserts.assertEQ(WB.getMethodCompilationLevel(testMethod),\n-                CompilerWhiteBoxTest.COMP_LEVEL_AOT,\n-                \"Expected method to be AOT compiled\");\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/TestHeapBase.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeDynamic\n- *        sun.hotspot.WhiteBox\n- * @run driver compiler.calls.common.InvokeDynamicPatcher\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler -libname AotInvokeDynamic2AotTest.so\n- *      -class compiler.calls.common.InvokeDynamic\n- *      -extraopt -XX:+UnlockDiagnosticVMOptions -extraopt -XX:+WhiteBoxAPI -extraopt -Xbootclasspath\/a:.\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/AotInvokeDynamic2AotTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeDynamic\n- *      -checkCallerCompileLevel -1 -checkCalleeCompileLevel -1\n- * @summary check calls from aot to aot code using invokedynamic\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromAot\/AotInvokeDynamic2AotTest.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeDynamic\n- *        sun.hotspot.WhiteBox\n- * @run driver compiler.calls.common.InvokeDynamicPatcher\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler -libname AotInvokeDynamic2CompiledTest.so\n- *      -class compiler.calls.common.InvokeDynamic\n- *      -compile compiler.calls.common.InvokeDynamic.caller()V\n- * @run main\/othervm -Xbatch -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/AotInvokeDynamic2CompiledTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeDynamic -compileCallee 1\n- *      -checkCalleeCompileLevel 1\n- * @run main\/othervm -Xbatch -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/AotInvokeDynamic2CompiledTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeDynamic -compileCallee 4\n- *      -checkCalleeCompileLevel 4\n- * @summary check calls from aot to jit-compiled code using invokedynamic\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromAot\/AotInvokeDynamic2CompiledTest.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeDynamic\n- *        sun.hotspot.WhiteBox\n- * @run driver compiler.calls.common.InvokeDynamicPatcher\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler\n- *      -libname AotInvokeDynamic2InterpretedTest.so\n- *      -class compiler.calls.common.InvokeDynamic\n- *      -compile compiler.calls.common.InvokeDynamic.caller()V\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions\n- *      -XX:AOTLibrary=.\/AotInvokeDynamic2InterpretedTest.so\n- *      -XX:CompileCommand=exclude,compiler.calls.common.InvokeDynamic::callee\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      -XX:+UseAOT compiler.calls.common.InvokeDynamic -checkCallerCompileLevel -1\n- * @summary check calls from aot to interpreted code using invokedynamic\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromAot\/AotInvokeDynamic2InterpretedTest.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeDynamic\n- *        sun.hotspot.WhiteBox\n- * @run driver compiler.calls.common.InvokeDynamicPatcher\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler -libname AotInvokeDynamic2NativeTest.so\n- *      -class compiler.calls.common.InvokeDynamic\n- *      -compile compiler.calls.common.InvokeDynamic.caller()V\n- * @run main\/othervm\/native -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *       -XX:AOTLibrary=.\/AotInvokeDynamic2NativeTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *       compiler.calls.common.InvokeDynamic -nativeCallee -checkCallerCompileLevel -1\n- * @summary check calls from aot to native code using invokedynamic\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromAot\/AotInvokeDynamic2NativeTest.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeInterface\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler -libname AotInvokeInterface2AotTest.so\n- *      -class compiler.calls.common.InvokeInterface\n- *      -extraopt -XX:+UnlockDiagnosticVMOptions -extraopt -XX:+WhiteBoxAPI -extraopt -Xbootclasspath\/a:.\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/AotInvokeInterface2AotTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeInterface\n- *      -checkCallerCompileLevel -1 -checkCalleeCompileLevel -1\n- * @summary check calls from aot to aot code using invokeinterface\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromAot\/AotInvokeInterface2AotTest.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeInterface\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler\n- *      -libname AotInvokeInterface2CompiledTest.so\n- *      -class compiler.calls.common.InvokeInterface\n- *      -compile compiler.calls.common.InvokeInterface.caller()V\n- * @run main\/othervm -Xbatch -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/AotInvokeInterface2CompiledTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeInterface -compileCallee 1\n- *      -checkCalleeCompileLevel 1\n- * @run main\/othervm -Xbatch -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/AotInvokeInterface2CompiledTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeInterface -compileCallee 4\n- *      -checkCalleeCompileLevel 4\n- * @summary check calls from aot to jit-compiled code using invokeinterface\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromAot\/AotInvokeInterface2CompiledTest.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeInterface\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler\n- *      -libname AotInvokeInterface2InterpretedTest.so\n- *      -class compiler.calls.common.InvokeInterface\n- *      -compile compiler.calls.common.InvokeInterface.caller()V\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/AotInvokeInterface2InterpretedTest.so\n- *      -XX:CompileCommand=exclude,compiler.calls.common.InvokeInterface::callee\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeInterface -checkCallerCompileLevel -1\n- * @summary check calls from aot to interpreted code using invokeinterface\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromAot\/AotInvokeInterface2InterpretedTest.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeInterface\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler -libname AotInvokeInterface2NativeTest.so\n- *      -class compiler.calls.common.InvokeInterface\n- *      -compile compiler.calls.common.InvokeInterface.caller()V\n- * @run main\/othervm\/native -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/AotInvokeInterface2NativeTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeInterface -nativeCallee -checkCallerCompileLevel -1\n- * @summary check calls from aot to native code using invokeinterface\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromAot\/AotInvokeInterface2NativeTest.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeSpecial\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler -libname AotInvokeSpecial2AotTest.so\n- *      -class compiler.calls.common.InvokeSpecial\n- *      -extraopt -XX:+UnlockDiagnosticVMOptions -extraopt -XX:+WhiteBoxAPI -extraopt -Xbootclasspath\/a:.\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/AotInvokeSpecial2AotTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeSpecial\n- *      -checkCallerCompileLevel -1 -checkCalleeCompileLevel -1\n- * @summary check calls from aot to aot code using invokespecial\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromAot\/AotInvokeSpecial2AotTest.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeSpecial\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler -libname AotInvokeSpecial2CompiledTest.so\n- *      -class compiler.calls.common.InvokeSpecial\n- *      -compile compiler.calls.common.InvokeSpecial.caller()V\n- * @run main\/othervm -Xbatch -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/AotInvokeSpecial2CompiledTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeSpecial -compileCallee 1\n- *      -checkCalleeCompileLevel 1\n- * @run main\/othervm -Xbatch -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/AotInvokeSpecial2CompiledTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeSpecial -compileCallee 4\n- *      -checkCalleeCompileLevel 4\n- * @summary check calls from aot to jit-compiled code using invokespecial\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromAot\/AotInvokeSpecial2CompiledTest.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeSpecial\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler\n- *      -libname AotInvokeSpecial2InterpretedTest.so\n- *      -class compiler.calls.common.InvokeSpecial\n- *      -compile compiler.calls.common.InvokeSpecial.caller()V\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/AotInvokeSpecial2InterpretedTest.so\n- *      -XX:CompileCommand=exclude,compiler.calls.common.InvokeSpecial::callee\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeSpecial -checkCallerCompileLevel -1\n- * @summary check calls from aot to interpreted code using invokespecial\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromAot\/AotInvokeSpecial2InterpretedTest.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeSpecial\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler -libname AotInvokeSpecial2NativeTest.so\n- *      -class compiler.calls.common.InvokeSpecial\n- *      -compile compiler.calls.common.InvokeSpecial.caller()V\n- * @run main\/othervm\/native -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/AotInvokeSpecial2NativeTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeSpecial -nativeCallee -checkCallerCompileLevel -1\n- * @summary check calls from aot to interpreted code using invokespecial\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromAot\/AotInvokeSpecial2NativeTest.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeStatic\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler -libname AotInvokeStatic2AotTest.so\n- *      -class compiler.calls.common.InvokeStatic\n- *      -extraopt -XX:+UnlockDiagnosticVMOptions -extraopt -XX:+WhiteBoxAPI -extraopt -Xbootclasspath\/a:.\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/AotInvokeStatic2AotTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeStatic\n- *      -checkCallerCompileLevel -1 -checkCalleeCompileLevel -1\n- * @summary check calls from aot to aot code using invokestatic\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromAot\/AotInvokeStatic2AotTest.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeStatic\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler -libname AotInvokeStatic2CompiledTest.so\n- *      -class compiler.calls.common.InvokeStatic\n- *      -compile compiler.calls.common.InvokeStatic.caller()V\n- * @run main\/othervm -Xbatch -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/AotInvokeStatic2CompiledTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeStatic -compileCallee 1\n- *      -checkCalleeCompileLevel 1\n- * @run main\/othervm -Xbatch -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/AotInvokeStatic2CompiledTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeStatic -compileCallee 4\n- *      -checkCalleeCompileLevel 4\n- * @summary check calls from aot to jit-compiled code using invokestatic\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromAot\/AotInvokeStatic2CompiledTest.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeStatic\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler\n- *      -libname AotInvokeStatic2InterpretedTest.so\n- *      -class compiler.calls.common.InvokeStatic\n- *      -compile compiler.calls.common.InvokeStatic.caller()V\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/AotInvokeStatic2InterpretedTest.so\n- *      -XX:CompileCommand=exclude,compiler.calls.common.InvokeStatic::callee\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeStatic -checkCallerCompileLevel -1\n- * @summary check calls from aot to interpreted code using invokestatic\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromAot\/AotInvokeStatic2InterpretedTest.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeStatic\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler -libname AotInvokeStatic2NativeTest.so\n- *      -class compiler.calls.common.InvokeStatic\n- *      -compile compiler.calls.common.InvokeStatic.caller()V\n- * @run main\/othervm\/native -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/AotInvokeStatic2NativeTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeStatic -nativeCallee -checkCallerCompileLevel -1\n- * @summary check calls from aot to native code using invokestatic\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromAot\/AotInvokeStatic2NativeTest.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeVirtual\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler -libname AotInvokeVirtual2AotTest.so\n- *      -class compiler.calls.common.InvokeVirtual\n- *      -extraopt -XX:+UnlockDiagnosticVMOptions -extraopt -XX:+WhiteBoxAPI -extraopt -Xbootclasspath\/a:.\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/AotInvokeVirtual2AotTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeVirtual\n- *      -checkCallerCompileLevel -1 -checkCalleeCompileLevel -1\n- * @summary check calls from aot to aot code, using invokevirtual\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromAot\/AotInvokeVirtual2AotTest.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeVirtual\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler -libname AotInvokeVirtual2CompiledTest.so\n- *      -class compiler.calls.common.InvokeVirtual\n- *      -compile compiler.calls.common.InvokeVirtual.caller()V\n- * @run main\/othervm -Xbatch -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/AotInvokeVirtual2CompiledTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeVirtual -compileCallee 1\n- *      -checkCalleeCompileLevel 1\n- * @run main\/othervm -Xbatch -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/AotInvokeVirtual2CompiledTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeVirtual -compileCallee 4\n- *      -checkCalleeCompileLevel 4\n- * @summary check calls from aot to jit-compiled code, using invokevirtual\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromAot\/AotInvokeVirtual2CompiledTest.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeVirtual\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler\n- *      -libname AotInvokeVirtual2InterpretedTest.so\n- *      -class compiler.calls.common.InvokeVirtual\n- *      -compile compiler.calls.common.InvokeVirtual.caller()V\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/AotInvokeVirtual2InterpretedTest.so\n- *      -XX:CompileCommand=exclude,compiler.calls.common.InvokeVirtual::callee\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeVirtual -checkCallerCompileLevel -1\n- * @summary check calls from aot to interpreted code, using invokevirtual\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromAot\/AotInvokeVirtual2InterpretedTest.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeVirtual\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler -libname AotInvokeVirtual2NativeTest.so\n- *      -class compiler.calls.common.InvokeVirtual\n- *      -compile compiler.calls.common.InvokeVirtual.caller()V\n- * @run main\/othervm\/native -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/AotInvokeVirtual2NativeTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeVirtual -nativeCallee -checkCallerCompileLevel -1\n- * @summary check calls from aot to native code, using invokevirtual\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromAot\/AotInvokeVirtual2NativeTest.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeDynamic\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.calls.common.InvokeDynamicPatcher\n- * @run driver compiler.aot.AotCompiler -libname CompiledInvokeDynamic2AotTest.so\n- *      -class compiler.calls.common.InvokeDynamic\n- *      -compile compiler.calls.common.InvokeDynamic.callee.*\n- * @run main\/othervm -Xbatch -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/CompiledInvokeDynamic2AotTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeDynamic -compileCaller 1\n- *      -checkCalleeCompileLevel -1 -checkCallerCompileLevel 1\n- * @run main\/othervm -Xbatch -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/CompiledInvokeDynamic2AotTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeDynamic -compileCaller 4\n- *      -checkCallerCompileLevel 4 -checkCalleeCompileLevel -1\n- * @summary check calls from jit-compiled to aot code using invokedynamic\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromCompiled\/CompiledInvokeDynamic2AotTest.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeInterface\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler\n- *      -libname CompiledInvokeInterface2AotTest.so\n- *      -class compiler.calls.common.InvokeInterface\n- *      -compile compiler.calls.common.InvokeInterface.callee.*\n- * @run main\/othervm -Xbatch -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/CompiledInvokeInterface2AotTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeInterface -compileCaller 1\n- *      -checkCalleeCompileLevel -1 -checkCallerCompileLevel 1\n- * @run main\/othervm -Xbatch -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/CompiledInvokeInterface2AotTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeInterface -compileCaller 4\n- *      -checkCallerCompileLevel 4 -checkCalleeCompileLevel -1\n- * @summary check calls from jit-compiled to aot code using invokeinterface\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromCompiled\/CompiledInvokeInterface2AotTest.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeSpecial\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler -libname CompiledInvokeSpecial2AotTest.so\n- *      -class compiler.calls.common.InvokeSpecial\n- *      -compile compiler.calls.common.InvokeSpecial.callee.*\n- * @run main\/othervm -Xbatch -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/CompiledInvokeSpecial2AotTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeSpecial -compileCaller 1\n- *      -checkCalleeCompileLevel -1 -checkCallerCompileLevel 1\n- * @run main\/othervm -Xbatch -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/CompiledInvokeSpecial2AotTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeSpecial -compileCaller 4\n- *      -checkCallerCompileLevel 4 -checkCalleeCompileLevel -1\n- * @summary check calls from jit-compiled to aot code using invokespecial\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromCompiled\/CompiledInvokeSpecial2AotTest.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeStatic\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler -libname CompiledInvokeStatic2AotTest.so\n- *      -class compiler.calls.common.InvokeStatic\n- *      -compile compiler.calls.common.InvokeStatic.callee.*\n- * @run main\/othervm -Xbatch -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/CompiledInvokeStatic2AotTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeStatic -compileCaller 1\n- *      -checkCalleeCompileLevel -1 -checkCallerCompileLevel 1\n- * @run main\/othervm -Xbatch -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/CompiledInvokeStatic2AotTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeStatic -compileCaller 4\n- *      -checkCallerCompileLevel 4 -checkCalleeCompileLevel -1\n- * @summary check calls from jit-compiled to aot code using invokestatic\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromCompiled\/CompiledInvokeStatic2AotTest.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeVirtual\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler -libname CompiledInvokeVirtual2AotTest.so\n- *      -class compiler.calls.common.InvokeVirtual\n- *      -compile compiler.calls.common.InvokeVirtual.callee.*\n- * @run main\/othervm -Xbatch -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/CompiledInvokeVirtual2AotTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeVirtual -compileCaller 1\n- *      -checkCalleeCompileLevel -1 -checkCallerCompileLevel 1\n- * @run main\/othervm -Xbatch -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/CompiledInvokeVirtual2AotTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeVirtual -compileCaller 4\n- *      -checkCallerCompileLevel 4 -checkCalleeCompileLevel -1\n- * @summary check calls from jit-compiled to aot code using invokevirtual\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromCompiled\/CompiledInvokeVirtual2AotTest.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeDynamic\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.calls.common.InvokeDynamicPatcher\n- * @run driver compiler.aot.AotCompiler\n- *      -libname InterpretedInvokeDynamic2AotTest.so\n- *      -class compiler.calls.common.InvokeDynamic\n- *      -compile compiler.calls.common.InvokeDynamic.callee.*\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/InterpretedInvokeDynamic2AotTest.so\n- *      -XX:CompileCommand=exclude,compiler.calls.common.InvokeDynamic::caller\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeDynamic -checkCalleeCompileLevel -1\n- * @summary check calls from interpreted to aot code using invokedynamic\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromInterpreted\/InterpretedInvokeDynamic2AotTest.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeInterface\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler\n- *      -libname InterpretedInvokeInterface2AotTest.so\n- *      -class compiler.calls.common.InvokeInterface\n- *      -compile compiler.calls.common.InvokeInterface.callee.*\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/InterpretedInvokeInterface2AotTest.so\n- *      -XX:CompileCommand=exclude,compiler.calls.common.InvokeInterface::caller\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeInterface -checkCalleeCompileLevel -1\n- * @summary check calls from interpreted to aot code using invokeinterface\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromInterpreted\/InterpretedInvokeInterface2AotTest.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeSpecial\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler\n- *      -libname InterpretedInvokeSpecial2AotTest.so\n- *      -class compiler.calls.common.InvokeSpecial\n- *      -compile compiler.calls.common.InvokeSpecial.callee.*\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/InterpretedInvokeSpecial2AotTest.so\n- *      -XX:CompileCommand=exclude,compiler.calls.common.InvokeSpecial::caller\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeSpecial -checkCalleeCompileLevel -1\n- * @summary check calls from interpreted to aot code using invokespecial\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromInterpreted\/InterpretedInvokeSpecial2AotTest.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeStatic\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler\n- *      -libname InterpretedInvokeStatic2AotTest.so\n- *      -class compiler.calls.common.InvokeStatic\n- *      -compile compiler.calls.common.InvokeStatic.callee.*\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/InterpretedInvokeStatic2AotTest.so\n- *      -XX:CompileCommand=exclude,compiler.calls.common.InvokeStatic::caller\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeStatic -checkCalleeCompileLevel -1\n- * @summary check calls from interpreted to aot code using invokestatic\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromInterpreted\/InterpretedInvokeStatic2AotTest.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeVirtual\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler\n- *      -libname InterpretedInvokeVirtual2AotTest.so\n- *      -class compiler.calls.common.InvokeVirtual\n- *      -compile compiler.calls.common.InvokeVirtual.callee.*\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/InterpretedInvokeVirtual2AotTest.so\n- *      -XX:CompileCommand=exclude,compiler.calls.common.InvokeVirtual::caller\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeVirtual -checkCalleeCompileLevel -1\n- * @summary check calls from interpreted to aot code using invokevirtual\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromInterpreted\/InterpretedInvokeVirtual2AotTest.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeSpecial\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler -libname NativeInvokeSpecial2AotTest.so\n- *      -class compiler.calls.common.InvokeSpecial\n- *      -compile compiler.calls.common.InvokeSpecial.callee.*\n- * @run main\/othervm\/native -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/NativeInvokeSpecial2AotTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeSpecial -nativeCaller -checkCalleeCompileLevel -1\n- * @summary check calls from native to aot code using invokespecial\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromNative\/NativeInvokeSpecial2AotTest.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeStatic\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler -libname NativeInvokeStatic2AotTest.so\n- *      -class compiler.calls.common.InvokeStatic\n- *      -compile compiler.calls.common.InvokeStatic.callee.*\n- * @run main\/othervm\/native -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/NativeInvokeStatic2AotTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeStatic -nativeCaller -checkCalleeCompileLevel -1\n- * @summary check calls from native to aot code using invokestatic\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromNative\/NativeInvokeStatic2AotTest.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.calls.common.InvokeVirtual\n- *        sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run driver compiler.aot.AotCompiler -libname NativeInvokeVirtual2AotTest.so\n- *      -class compiler.calls.common.InvokeVirtual\n- *      -compile compiler.calls.common.InvokeVirtual.callee.*\n- * @run main\/othervm\/native -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- *      -XX:AOTLibrary=.\/NativeInvokeVirtual2AotTest.so\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *      compiler.calls.common.InvokeVirtual -nativeCaller -checkCalleeCompileLevel -1\n- * @summary check calls from native to aot code using invokevirtual\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/calls\/fromNative\/NativeInvokeVirtual2AotTest.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.aot.cli;\n-\n-import compiler.aot.HelloWorldPrinter;\n-import jdk.test.lib.process.ExitCode;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-public class AotLibraryNegativeBase {\n-    private static final String[] UNEXPECTED_MESSAGES = new String[] {\n-        HelloWorldPrinter.MESSAGE\n-    };\n-\n-    public static void launchTest(String option, String expectedMessages[]) {\n-        try {\n-            boolean addTestVMOptions = true;\n-            CommandLineOptionTest.verifyJVMStartup(expectedMessages,\n-                    UNEXPECTED_MESSAGES,\n-                    \"Unexpected exit code using \" + option,\n-                    \"Unexpected output using \" + option, ExitCode.FAIL,\n-                    addTestVMOptions, \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseAOT\",\n-                    \"-XX:+PrintAOT\", option, HelloWorldPrinter.class.getName());\n-        } catch (Throwable t) {\n-            throw new Error(\"Problems executing test using \" + option\n-                    + \": \" + t, t);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/cli\/AotLibraryNegativeBase.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @build compiler.aot.cli.DisabledAOTWithLibraryTest\n- *        compiler.aot.AotCompiler\n- * @run driver compiler.aot.AotCompiler -libname libDisabledAOTWithLibraryTest.so\n- *      -class compiler.aot.HelloWorldPrinter\n- *      -compile compiler.aot.HelloWorldPrinter.print()V\n- * @run driver compiler.aot.cli.DisabledAOTWithLibraryTest\n- * @summary check if providing aot library with aot disabled is handled properly\n- *\/\n-\n-package compiler.aot.cli;\n-\n-import compiler.aot.HelloWorldPrinter;\n-import jdk.test.lib.process.ExitCode;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-public class DisabledAOTWithLibraryTest {\n-    private final static String LIB_NAME = \"libDisabledAOTWithLibraryTest.so\";\n-    private final static String[] UNEXPECTED_MESSAGES = new String[] {\n-        LIB_NAME + \"  aot library\"\n-    };\n-\n-    private final static String[] EXPECTED_MESSAGES = new String[] {\n-        HelloWorldPrinter.MESSAGE\n-    };\n-\n-    public static void main(String args[]) {\n-        try {\n-            boolean addTestVMOptions = true;\n-            CommandLineOptionTest.verifyJVMStartup(EXPECTED_MESSAGES,\n-                    UNEXPECTED_MESSAGES, \"Unexpected exit code\",\n-                    \"Unexpected output\", ExitCode.OK, addTestVMOptions,\n-                    \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseAOT\", \"-XX:+PrintAOT\",\n-                    \"-XX:AOTLibrary=.\/\" + LIB_NAME,\n-                    HelloWorldPrinter.class.getName());\n-        } catch (Throwable t) {\n-            throw new Error(\"Problems executing test \" + t, t);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/cli\/DisabledAOTWithLibraryTest.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.lib.helpers.ClassFileInstaller\n- * @run driver compiler.aot.cli.IncorrectAOTLibraryTest\n- * @summary check if incorrect aot library is handled properly\n- *\/\n-\n-package compiler.aot.cli;\n-\n-import java.nio.file.Paths;\n-\n-public class IncorrectAOTLibraryTest {\n-    private static final String OPTION\n-            = \"-XX:AOTLibrary=.\/\" + Paths.get(\"jdk\", \"test\", \"lib\", \"helpers\", \"ClassFileInstaller.class\").toString();\n-    private static final String[] EXPECTED_MESSAGES = new String[] {\n-        \"error opening file:\"\n-    };\n-\n-    public static void main(String args[]) {\n-        AotLibraryNegativeBase.launchTest(OPTION, EXPECTED_MESSAGES);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/cli\/IncorrectAOTLibraryTest.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.aot.cli.MultipleAOTLibraryTest\n- *        compiler.aot.AotCompiler\n- * @run driver compiler.aot.AotCompiler\n- *      -libname libMultipleAOTLibraryTest1.so\n- *      -class compiler.aot.HelloWorldPrinter\n- *      -compile compiler.aot.HelloWorldPrinter.*\n- *      -extraopt -XX:+UseCompressedOops\n- * @run driver compiler.aot.AotCompiler\n- *      -libname libMultipleAOTLibraryTest2.so\n- *      -class compiler.aot.HelloWorldPrinter\n- *      -compile compiler.aot.HelloWorldPrinter.print()V\n- *      -extraopt -XX:+UseCompressedOops\n- * @run driver compiler.aot.cli.MultipleAOTLibraryTest -XX:+UseCompressedOops\n- * @run driver compiler.aot.AotCompiler -libname libMultipleAOTLibraryTest1.so\n- *      -class compiler.aot.HelloWorldPrinter\n- *      -compile compiler.aot.HelloWorldPrinter.*\n- *      -extraopt -XX:-UseCompressedOops\n- * @run driver compiler.aot.AotCompiler -libname libMultipleAOTLibraryTest2.so\n- *      -class compiler.aot.HelloWorldPrinter\n- *      -compile compiler.aot.HelloWorldPrinter.print()V\n- *      -extraopt -XX:-UseCompressedOops\n- * @run driver compiler.aot.cli.MultipleAOTLibraryTest -XX:-UseCompressedOops\n- * @summary check if multiple aot libraries are loaded successfully\n- *\/\n-\n-package compiler.aot.cli;\n-\n-import compiler.aot.HelloWorldPrinter;\n-import java.io.File;\n-import java.util.Arrays;\n-import jdk.test.lib.process.ExitCode;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-public final class MultipleAOTLibraryTest {\n-    private final static String EXPECTED_OUTPUT[] = new String[] {\n-                \"libMultipleAOTLibraryTest1.so  aot library\",\n-                \"libMultipleAOTLibraryTest2.so  aot library\",\n-                HelloWorldPrinter.MESSAGE\n-    };\n-    private final static String UNEXPECTED_OUTPUT[] = null;\n-\n-    public static void main(String args[]) {\n-        new MultipleAOTLibraryTest().runTest(args);\n-    }\n-\n-    private void runTest(String args[]) {\n-        try {\n-            boolean addTestVMOptions = true;\n-            String[] allArgs = Arrays.copyOf(args, args.length + 5);\n-            allArgs[args.length] = \"-XX:+UnlockExperimentalVMOptions\";\n-            allArgs[args.length + 1] = \"-XX:AOTLibrary=\"\n-                    + \".\" + File.separator\n-                    + \"libMultipleAOTLibraryTest1.so\"\n-                    + File.pathSeparator\n-                    + \".\" + File.separator\n-                    + \"libMultipleAOTLibraryTest2.so\";\n-            allArgs[args.length + 2] = \"-XX:+PrintAOT\";\n-            allArgs[args.length + 3] = \"-XX:+UseAOT\";\n-            allArgs[args.length + 4] = HelloWorldPrinter.class.getName();\n-            CommandLineOptionTest.verifyJVMStartup(EXPECTED_OUTPUT,\n-                    UNEXPECTED_OUTPUT, \"Unexpected exit code\",\n-                    \"Unexpected output\", ExitCode.OK, addTestVMOptions,\n-                    allArgs);\n-        } catch (Throwable t) {\n-            throw new Error(\"Problems executing test: \" + t, t);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/cli\/MultipleAOTLibraryTest.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @run driver compiler.aot.cli.NonExistingAOTLibraryTest\n- * @summary check if non-existing aot library is handled properly\n- *\/\n-\n-package compiler.aot.cli;\n-\n-import java.io.File;\n-\n-public class NonExistingAOTLibraryTest {\n-    private static final String PATH = \".\/NonExisting.so\";\n-    private static final String OPTION = \"-XX:AOTLibrary=\" + PATH;\n-    private static final String[] EXPECTED_MESSAGES = new String[] {\n-        \"error opening file\"\n-    };\n-\n-    public static void main(String args[]) {\n-        if (new File(PATH).exists()) {\n-            throw new Error(\"TESTBUG: \" + PATH + \" unexpectedly exists\");\n-        }\n-        AotLibraryNegativeBase.launchTest(OPTION, EXPECTED_MESSAGES);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/cli\/NonExistingAOTLibraryTest.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/ \/testlibrary\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.aot.cli.SingleAOTLibraryTest\n- *        compiler.aot.AotCompiler\n- * @run driver compiler.aot.AotCompiler -libname libSingleAOTLibraryTest.so\n- *      -class compiler.aot.HelloWorldPrinter\n- *      -compile compiler.aot.HelloWorldPrinter.print()V\n- *      -extraopt -XX:+UseCompressedOops\n- * @run driver compiler.aot.cli.SingleAOTLibraryTest -XX:+UseCompressedOops\n- * @run driver compiler.aot.AotCompiler -libname libSingleAOTLibraryTest.so\n- *      -class compiler.aot.HelloWorldPrinter\n- *      -compile compiler.aot.HelloWorldPrinter.print()V\n- *      -extraopt -XX:-UseCompressedOops\n- * @run driver compiler.aot.cli.SingleAOTLibraryTest -XX:-UseCompressedOops\n- * @summary check if single aot library is loaded successfully\n- *\/\n-\n-package compiler.aot.cli;\n-\n-import compiler.aot.HelloWorldPrinter;\n-import jdk.test.lib.process.ExitCode;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-public final class SingleAOTLibraryTest {\n-    private static final String[] EXPECTED_MESSAGES = new String[] {\n-        \"libSingleAOTLibraryTest.so  aot library\",\n-        HelloWorldPrinter.MESSAGE\n-    };\n-    private static final String[] UNEXPECTED_MESSAGES = null;\n-    public static void main(String args[]) {\n-        if (args.length == 1) {\n-            new SingleAOTLibraryTest().runTest(args[0]);\n-        } else {\n-            throw new Error(\"Test expects 1 parameter\");\n-        }\n-    }\n-\n-    private void runTest(String arg) {\n-        try {\n-            boolean addTestVMOptions = true;\n-            CommandLineOptionTest.verifyJVMStartup(EXPECTED_MESSAGES,\n-                    UNEXPECTED_MESSAGES, \"Unexpected exit code using \" + arg,\n-                    \"Unexpected output using \" + arg, ExitCode.OK,\n-                    addTestVMOptions, \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseAOT\",\n-                    \"-XX:+PrintAOT\", arg, \"-XX:AOTLibrary=.\/libSingleAOTLibraryTest.so\",\n-                    HelloWorldPrinter.class.getName());\n-        } catch (Throwable t) {\n-            throw new Error(\"Problems executing test: \" + t, t);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/cli\/SingleAOTLibraryTest.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.aot.cli.SingleAOTOptionTest\n- *        compiler.aot.AotCompiler\n- * @run driver compiler.aot.AotCompiler -libname libSingleAOTOptionTest.so\n- *      -class compiler.aot.HelloWorldPrinter\n- *      -compile compiler.aot.HelloWorldPrinter.print()V\n- *      -extraopt -XX:+UseCompressedOops\n- * @run driver compiler.aot.cli.SingleAOTOptionTest -XX:+UseCompressedOops\n- *      -XX:+UnlockExperimentalVMOptions -XX:AOTLibrary=.\/libSingleAOTOptionTest.so\n- * @run main compiler.aot.cli.SingleAOTOptionTest\n- *      -XX:+UseCompressedOops -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- * @run driver compiler.aot.AotCompiler -libname libSingleAOTOptionTest.so\n- *      -class compiler.aot.HelloWorldPrinter\n- *      -compile compiler.aot.HelloWorldPrinter.print()V\n- *      -extraopt -XX:-UseCompressedOops\n- * @run driver compiler.aot.cli.SingleAOTOptionTest -XX:-UseCompressedOops\n- *      -XX:+UnlockExperimentalVMOptions -XX:AOTLibrary=.\/libSingleAOTOptionTest.so\n- * @run driver compiler.aot.cli.SingleAOTOptionTest\n- *      -XX:-UseCompressedOops -XX:+UnlockExperimentalVMOptions -XX:+UseAOT\n- * @summary check if specifying only one aot option handled properly\n- *\/\n-\n-package compiler.aot.cli;\n-\n-import compiler.aot.HelloWorldPrinter;\n-import jdk.test.lib.process.ExitCode;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-public class SingleAOTOptionTest {\n-    private static final String[] EXPECTED_MESSAGES = new String[] {\n-        HelloWorldPrinter.MESSAGE\n-    };\n-    private static final String[] UNEXPECTED_MESSAGES = null;\n-\n-    public static void main(String args[]) {\n-        if (args.length == 3) {\n-            new SingleAOTOptionTest().runTest(args[0], args[1], args[2]);\n-        } else {\n-            throw new Error(\"Test expects 2 parameters\");\n-        }\n-    }\n-\n-    private void runTest(String arg1, String arg2, String arg3) {\n-        try {\n-            String exitCodeErrorMessage = String.format(\"Unexpected exit code \"\n-                    + \"using %s %s %s\", arg1, arg2, arg3);\n-            String outputErrorMessage = String.format(\"Unexpected output using\"\n-                    + \" %s %s\", arg1, arg2, arg3);\n-            boolean addTestVMOptions = true;\n-            CommandLineOptionTest.verifyJVMStartup(EXPECTED_MESSAGES,\n-                    UNEXPECTED_MESSAGES, exitCodeErrorMessage,\n-                    outputErrorMessage, ExitCode.OK, addTestVMOptions, arg1,\n-                    arg2, arg3, HelloWorldPrinter.class.getName());\n-        } catch (Throwable t) {\n-            throw new Error(\"Problems executing test: \" + t, t);\n-        }\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/cli\/SingleAOTOptionTest.java","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary check at-file jaotc support\n- * @comment based on CompileClassTest with arguments wrote in 'jaotc.cmd' file\n- * @requires vm.aot\n- * @bug 8215322\n- * @library \/ \/test\/lib \/testlibrary\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.aot.cli.jaotc.AtFileTest\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller compiler.aot.cli.jaotc.data.HelloWorldOne\n- * @run driver compiler.aot.cli.jaotc.AtFileTest\n- *\/\n-\n-package compiler.aot.cli.jaotc;\n-\n-import compiler.aot.cli.jaotc.data.HelloWorldOne;\n-import java.io.File;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.Files;\n-import java.util.List;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public class AtFileTest {\n-    public static void main(String[] args) throws Exception {\n-        Path file = Paths.get(\"jaotc.cmd\");\n-        Files.write(file, List.of(\"--class-name\",\n-                JaotcTestHelper.getClassAotCompilationName(HelloWorldOne.class)));\n-        OutputAnalyzer oa = JaotcTestHelper.compileLibrary(\"@\" + file.toString());\n-        oa.shouldHaveExitValue(0);\n-        File compiledLibrary = new File(JaotcTestHelper.DEFAULT_LIB_PATH);\n-        Asserts.assertTrue(compiledLibrary.exists(), \"Compiled library file missing\");\n-        Asserts.assertGT(compiledLibrary.length(), 0L, \"Unexpected compiled library size\");\n-        JaotcTestHelper.checkLibraryUsage(HelloWorldOne.class.getName());\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/cli\/jaotc\/AtFileTest.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/ \/testlibrary\/ \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- * @compile data\/HelloWorldOne.java\n- * @run driver compiler.aot.cli.jaotc.ClasspathOptionUnknownClassTest\n- * @summary check jaotc can't compile class not from classpath\n- *\/\n-\n-package compiler.aot.cli.jaotc;\n-\n-import java.io.File;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public class ClasspathOptionUnknownClassTest {\n-    public static void main(String[] args) {\n-        OutputAnalyzer oa = JaotcTestHelper.compileLibrary(\"--class-name\", \"HelloWorldOne\");\n-        Asserts.assertNE(oa.getExitValue(), 0, \"Unexpected compilation exit code\");\n-        File compiledLibrary = new File(JaotcTestHelper.DEFAULT_LIB_PATH);\n-        Asserts.assertFalse(compiledLibrary.exists(), \"Compiler library unexpectedly exists\");\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/cli\/jaotc\/ClasspathOptionUnknownClassTest.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/ \/test\/lib \/testlibrary\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.aot.cli.jaotc.CompileAbsoluteDirectoryTest\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller compiler.aot.cli.jaotc.data.HelloWorldOne\n- *                                compiler.aot.cli.jaotc.data.HelloWorldTwo\n- * @run driver compiler.aot.cli.jaotc.CompileAbsoluteDirectoryTest\n- * @summary check jaotc can compile directory with classes where directory is specified by absolute path\n- * @bug 8218859\n- *\/\n-package compiler.aot.cli.jaotc;\n-\n-import compiler.aot.cli.jaotc.data.HelloWorldOne;\n-import compiler.aot.cli.jaotc.data.HelloWorldTwo;\n-import java.io.File;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public class CompileAbsoluteDirectoryTest {\n-    public static void main(String[] args) {\n-        try {\n-            String dir = new java.io.File(\".\").getAbsolutePath();\n-            System.out.println(\"Do test --directory \" + dir);\n-            OutputAnalyzer oa = JaotcTestHelper.compileLibrary(\"--directory\", dir);\n-            oa.shouldHaveExitValue(0);\n-            File compiledLibrary = new File(JaotcTestHelper.DEFAULT_LIB_PATH);\n-            Asserts.assertTrue(compiledLibrary.exists(), \"Compiled library file missing\");\n-            Asserts.assertGT(compiledLibrary.length(), 0L, \"Unexpected compiled library size\");\n-            JaotcTestHelper.checkLibraryUsage(HelloWorldOne.class.getName());\n-            JaotcTestHelper.checkLibraryUsage(HelloWorldTwo.class.getName());\n-        } catch (Exception e) {\n-            throw new Error(\"Can't get full path name for '.', got exception \" + e, e);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/cli\/jaotc\/CompileAbsoluteDirectoryTest.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/ \/test\/lib \/testlibrary\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.aot.cli.jaotc.CompileClassTest\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller compiler.aot.cli.jaotc.data.HelloWorldOne\n- * @run driver compiler.aot.cli.jaotc.CompileClassTest\n- * @summary check jaotc can compile class\n- *\/\n-\n-package compiler.aot.cli.jaotc;\n-\n-import compiler.aot.cli.jaotc.data.HelloWorldOne;\n-import java.io.File;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public class CompileClassTest {\n-    public static void main(String[] args) {\n-        OutputAnalyzer oa = JaotcTestHelper.compileLibrary(\"--class-name\", JaotcTestHelper\n-                .getClassAotCompilationName(HelloWorldOne.class));\n-        oa.shouldHaveExitValue(0);\n-        File compiledLibrary = new File(JaotcTestHelper.DEFAULT_LIB_PATH);\n-        Asserts.assertTrue(compiledLibrary.exists(), \"Compiled library file missing\");\n-        Asserts.assertGT(compiledLibrary.length(), 0L, \"Unexpected compiled library size\");\n-        JaotcTestHelper.checkLibraryUsage(HelloWorldOne.class.getName());\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/cli\/jaotc\/CompileClassTest.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/ \/test\/lib \/testlibrary\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.aot.cli.jaotc.CompileClassWithDebugTest\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller compiler.aot.cli.jaotc.data.HelloWorldOne\n- * @run driver compiler.aot.cli.jaotc.CompileClassWithDebugTest\n- * @summary check that jaotc can compile a class with a --debug flag\n- *\/\n-\n-package compiler.aot.cli.jaotc;\n-\n-import compiler.aot.cli.jaotc.data.HelloWorldOne;\n-import java.io.File;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public class CompileClassWithDebugTest {\n-    public static void main(String[] args) {\n-        OutputAnalyzer oa = JaotcTestHelper.compileLibrary(\"--debug\", \"--class-name\", JaotcTestHelper\n-                .getClassAotCompilationName(HelloWorldOne.class));\n-        oa.shouldHaveExitValue(0);\n-        File compiledLibrary = new File(JaotcTestHelper.DEFAULT_LIB_PATH);\n-        Asserts.assertTrue(compiledLibrary.exists(), \"Compiled library file missing\");\n-        Asserts.assertGT(compiledLibrary.length(), 0L, \"Unexpected compiled library size\");\n-        JaotcTestHelper.checkLibraryUsage(HelloWorldOne.class.getName());\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/cli\/jaotc\/CompileClassWithDebugTest.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/ \/test\/lib \/testlibrary\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.aot.cli.jaotc.CompileDirectoryTest\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller compiler.aot.cli.jaotc.data.HelloWorldOne\n- *                                compiler.aot.cli.jaotc.data.HelloWorldTwo\n- * @run driver compiler.aot.cli.jaotc.CompileDirectoryTest\n- * @summary check jaotc can compile directory with classes where directory is specified by relative path\n- *\/\n-package compiler.aot.cli.jaotc;\n-\n-import compiler.aot.cli.jaotc.data.HelloWorldOne;\n-import compiler.aot.cli.jaotc.data.HelloWorldTwo;\n-import java.io.File;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public class CompileDirectoryTest {\n-    public static void main(String[] args) {\n-        OutputAnalyzer oa =JaotcTestHelper.compileLibrary(\"--directory\", \".\");\n-        oa.shouldHaveExitValue(0);\n-        File compiledLibrary = new File(JaotcTestHelper.DEFAULT_LIB_PATH);\n-        Asserts.assertTrue(compiledLibrary.exists(), \"Compiled library file missing\");\n-        Asserts.assertGT(compiledLibrary.length(), 0L, \"Unexpected compiled library size\");\n-        JaotcTestHelper.checkLibraryUsage(HelloWorldOne.class.getName());\n-        JaotcTestHelper.checkLibraryUsage(HelloWorldTwo.class.getName());\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/cli\/jaotc\/CompileDirectoryTest.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/ \/test\/lib \/testlibrary\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.aot.cli.jaotc.CompileJarTest\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller compiler.aot.cli.jaotc.data.HelloWorldOne\n- *                                compiler.aot.cli.jaotc.data.HelloWorldTwo\n- * @run driver compiler.aot.cli.jaotc.CompileJarTest\n- * @summary check jaotc can compile jar\n- *\/\n-\n-package compiler.aot.cli.jaotc;\n-\n-import compiler.aot.cli.jaotc.data.HelloWorldOne;\n-import compiler.aot.cli.jaotc.data.HelloWorldTwo;\n-import java.io.File;\n-import java.io.IOException;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.JDKToolLauncher;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public class CompileJarTest {\n-    private static final String JAR_NAME = \"test.jar\";\n-\n-    public static void main(String[] args) {\n-        createJar();\n-        OutputAnalyzer oa = JaotcTestHelper.compileLibrary(\"--jar\", JAR_NAME);\n-        oa.shouldHaveExitValue(0);\n-        File compiledLibrary = new File(JaotcTestHelper.DEFAULT_LIB_PATH);\n-        Asserts.assertTrue(compiledLibrary.exists(), \"Compiled library file missing\");\n-        Asserts.assertGT(compiledLibrary.length(), 0L, \"Unexpected compiled library size\");\n-        JaotcTestHelper.checkLibraryUsage(HelloWorldOne.class.getName());\n-        JaotcTestHelper.checkLibraryUsage(HelloWorldTwo.class.getName());\n-    }\n-\n-    private static void createJar() {\n-        JDKToolLauncher jar = JDKToolLauncher.create(\"jar\")\n-                .addToolArg(\"-cf\")\n-                .addToolArg(JAR_NAME)\n-                .addToolArg(\"-C\")\n-                .addToolArg(\".\")\n-                .addToolArg(\".\");\n-        OutputAnalyzer oa;\n-        try {\n-            oa = new OutputAnalyzer(new ProcessBuilder(jar.getCommand()).start());\n-        } catch (IOException e) {\n-            throw new Error(\"Problems launching jar: \" + e, e);\n-        }\n-        oa.shouldHaveExitValue(0);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/cli\/jaotc\/CompileJarTest.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/ \/test\/lib \/testlibrary\n- * @modules java.base\/jdk.internal.misc\n- * @run driver compiler.aot.cli.jaotc.CompileModuleTest\n- * @summary check jaotc can compile module\n- *\/\n-\n-package compiler.aot.cli.jaotc;\n-\n-import compiler.aot.cli.jaotc.data.HelloWorldTwo;\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.StandardOpenOption;\n-import java.util.Arrays;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public class CompileModuleTest {\n-    private static final String TESTED_CLASS_NAME = HelloWorldTwo.class.getName();\n-    private static final String STRING_LENGTH = String.class.getName() + \".length\";\n-    private static final String COMPILE_COMMAND = \"compileOnly \" + STRING_LENGTH + \".*\";\n-    private static final Path COMPILE_COMMAND_FILE = Paths.get(\"stringLengthOnly.list\");\n-    private static final String[] EXPECTED = new String[]{\n-        JaotcTestHelper.DEFAULT_LIBRARY_LOAD_MESSAGE,\n-        STRING_LENGTH\n-    };\n-    private static final String[] UNEXPECTED = new String[]{\n-        TESTED_CLASS_NAME\n-    };\n-\n-    public static void main(String[] args) {\n-        \/\/ compile only java.lang.String::length from java.base module to have reasonable compilation time\n-        try {\n-            Files.write(COMPILE_COMMAND_FILE, Arrays.asList(COMPILE_COMMAND),\n-                    StandardOpenOption.WRITE, StandardOpenOption.CREATE_NEW);\n-        } catch (IOException e) {\n-            throw new Error(\"TESTBUG: can't write list file \" + e, e);\n-        }\n-        OutputAnalyzer oa = JaotcTestHelper.compileLibrary(\"--compile-commands\",\n-                COMPILE_COMMAND_FILE.toString(), \"--module\", \"java.base\");\n-        oa.shouldHaveExitValue(0);\n-        File compiledLibrary = new File(JaotcTestHelper.DEFAULT_LIB_PATH);\n-        Asserts.assertTrue(compiledLibrary.exists(), \"Compiled library file missing\");\n-        Asserts.assertGT(compiledLibrary.length(), 0L, \"Unexpected compiled library size\");\n-        JaotcTestHelper.checkLibraryUsage(TESTED_CLASS_NAME, EXPECTED, UNEXPECTED);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/cli\/jaotc\/CompileModuleTest.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/ \/test\/lib \/testlibrary\n- * @compile IllegalClass.jasm\n- * @run driver\/timeout=360 compiler.aot.cli.jaotc.IgnoreErrorsTest\n- *\/\n-\n-package compiler.aot.cli.jaotc;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.StandardOpenOption;\n-\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public class IgnoreErrorsTest {\n-    public static void main(String[] args) {\n-        try {\n-            Files.write(Paths.get(\"Empty.class\"), new byte[] { }, StandardOpenOption.CREATE_NEW);\n-        } catch (IOException e) {\n-            throw new Error(\"can't create empty class file\", e);\n-        }\n-        File compiledLibrary = new File(JaotcTestHelper.DEFAULT_LIB_PATH);\n-        OutputAnalyzer oa;\n-\n-        System.out.println(\"Compiling empty class file w\/o --ignore-errors\");\n-        oa = JaotcTestHelper.compileLibrary(\n-            \"--class-name\", \"Empty\",\n-            \"--class-name\", \"java.lang.Object\");\n-        oa.shouldNotHaveExitValue(0);\n-        Asserts.assertTrue(!compiledLibrary.exists(), \"Compiled library file exists\");\n-\n-        System.out.println(\"Compiling empty class file w\/ --ignore-errors\");\n-        oa = JaotcTestHelper.compileLibrary(\n-            \"--ignore-errors\",\n-            \"--class-name\", \"Empty\",\n-            \"--class-name\", \"java.lang.Object\");\n-        oa.shouldHaveExitValue(0);\n-        Asserts.assertTrue(compiledLibrary.exists(), \"Compiled library file is missed\");\n-        JaotcTestHelper.checkLibraryUsage(\"-version\");\n-        compiledLibrary.delete();\n-\n-        System.out.println(\"Compiling illegal class file w\/o --ignore-errors\");\n-        oa = JaotcTestHelper.compileLibrary(\n-            \"--class-name\", \"IllegalClass\",\n-            \"--class-name\", \"java.lang.Object\");\n-        oa.shouldNotHaveExitValue(0);\n-        Asserts.assertTrue(!compiledLibrary.exists(), \"Compiled library file exists\");\n-\n-        System.out.println(\"Compiling illegal class file w\/ --ignore-errors\");\n-        oa = JaotcTestHelper.compileLibrary(\n-            \"--ignore-errors\",\n-            \"--class-name\", \"IllegalClass\",\n-            \"--class-name\", \"java.lang.Object\");\n-        oa.shouldHaveExitValue(0);\n-        Asserts.assertTrue(compiledLibrary.exists(), \"Compiled library file is missed\");\n-        JaotcTestHelper.checkLibraryUsage(\"-version\");\n-        compiledLibrary.delete();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/cli\/jaotc\/IgnoreErrorsTest.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -1,27 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-super public class IllegalClass\n-    extends java\/lang\/String\n-    version 46:0\n-{ }\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/cli\/jaotc\/IllegalClass.jasm","additions":0,"deletions":27,"binary":false,"changes":27,"status":"deleted"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.aot.cli.jaotc;\n-\n-import compiler.aot.AotCompiler;\n-\n-import java.io.File;\n-import java.io.IOException;\n-\n-import jdk.test.lib.process.ExitCode;\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.JDKToolLauncher;\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class JaotcTestHelper {\n-    public static final String DEFAULT_LIB_PATH = \".\/unnamed.\" + Platform.sharedLibraryExt();\n-    public static final String DEFAULT_LIBRARY_LOAD_MESSAGE = \"loaded    \" + DEFAULT_LIB_PATH\n-            + \"  aot library\";\n-    private static final String UNLOCK_EXPERIMENTAL_VM_OPTIONS = \"-XX:+UnlockExperimentalVMOptions\";\n-    private static final String ENABLE_AOT = \"-XX:+UseAOT\";\n-    private static final String AOT_LIBRARY = \"-XX:AOTLibrary=\" + DEFAULT_LIB_PATH;\n-    private static final String PRINT_AOT = \"-XX:+PrintAOT\";\n-\n-    public static OutputAnalyzer compileLibrary(String... args) {\n-        JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(\"jaotc\");\n-        for (String vmOpt : Utils.getTestJavaOpts()) {\n-            launcher.addVMArg(vmOpt);\n-        }\n-        launcher.addToolArg(\"--compile-with-assertions\");\n-        for (String arg : args) {\n-            launcher.addToolArg(arg);\n-        }\n-        String linker = AotCompiler.resolveLinker();\n-        if (linker != null) {\n-            launcher.addToolArg(\"--linker-path\");\n-            launcher.addToolArg(linker);\n-        }\n-        String[] cmd = launcher.getCommand();\n-        try {\n-            return ProcessTools.executeCommand(cmd);\n-        } catch (Throwable e) {\n-            throw new Error(\"Can't start test process: \" + e, e);\n-        }\n-    }\n-\n-    public static void checkLibraryUsage(String classToRun) {\n-        checkLibraryUsage(classToRun, new String[]{DEFAULT_LIBRARY_LOAD_MESSAGE}, null);\n-    }\n-\n-    public static void checkLibraryUsage(String classToRun, String[] expectedOutput,\n-            String[] unexpectedOutput) {\n-        try {\n-            CommandLineOptionTest.verifyJVMStartup(expectedOutput, unexpectedOutput,\n-                    \"Unexpected exit code\", \"Unexpected output\", ExitCode.OK,\n-                    \/* addTestVMOpts *\/ true, UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                    ENABLE_AOT, AOT_LIBRARY, PRINT_AOT, classToRun);\n-        } catch (Throwable t) {\n-            throw new Error(\"Library usage verification failed: \" + t, t);\n-        }\n-    }\n-\n-    public static String getClassAotCompilationFilename(Class<?> classToCompile) {\n-        return classToCompile.getName().replaceAll(\"\\\\.\",\"\/\") + \".class\";\n-    }\n-\n-    public static String getClassAotCompilationName(Class<?> classToCompile) {\n-        return classToCompile.getName();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/cli\/jaotc\/JaotcTestHelper.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/ \/test\/lib \/testlibrary\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.aot.cli.jaotc.ListOptionNotExistingTest\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller compiler.aot.cli.jaotc.data.HelloWorldOne\n- * @run driver compiler.aot.cli.jaotc.ListOptionNotExistingTest\n- * @summary check jaotc can handle situation with missing --compile-commands file\n- *\/\n-\n-package compiler.aot.cli.jaotc;\n-\n-import compiler.aot.cli.jaotc.data.HelloWorldOne;\n-import java.io.File;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public class ListOptionNotExistingTest {\n-    private static final String COMPILE_ITEM\n-            = JaotcTestHelper.getClassAotCompilationName(HelloWorldOne.class);\n-\n-    public static void main(String[] args) {\n-        OutputAnalyzer oa = JaotcTestHelper.compileLibrary(\"--compile-commands\", \".\/notExisting.list\",\n-                \"--class-name\", COMPILE_ITEM);\n-        int exitCode = oa.getExitValue();\n-        Asserts.assertNE(exitCode, 0, \"Unexpected compilation exit code\");\n-        File compiledLibrary = new File(JaotcTestHelper.DEFAULT_LIB_PATH);\n-        Asserts.assertFalse(compiledLibrary.exists(), \"Compiler library unexpectedly exists\");\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/cli\/jaotc\/ListOptionNotExistingTest.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/ \/test\/lib \/testlibrary\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.aot.cli.jaotc.ListOptionTest\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller compiler.aot.cli.jaotc.data.HelloWorldOne\n- * @run driver compiler.aot.cli.jaotc.ListOptionTest\n- * @summary check jaotc can use --compile-commands option successfully and respective compileCommand is applied\n- *\/\n-\n-package compiler.aot.cli.jaotc;\n-\n-import compiler.aot.cli.jaotc.data.HelloWorldOne;\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.StandardOpenOption;\n-import java.util.Arrays;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public class ListOptionTest {\n-    private static final String TESTED_CLASS_NAME = HelloWorldOne.class.getName();\n-    private static final String HELLOWORLDONE_MAIN = TESTED_CLASS_NAME + \".main\";\n-    private static final String COMPILE_COMMAND = \"compileOnly \" + HELLOWORLDONE_MAIN + \".*\";\n-    private static final Path COMPILE_COMMAND_FILE = Paths.get(\"helloWorldMainMethodOnly.list\");\n-    private static final String[] EXPECTED = new String[]{\n-        JaotcTestHelper.DEFAULT_LIBRARY_LOAD_MESSAGE,\n-        TESTED_CLASS_NAME + \".main\"\n-    };\n-    private static final String[] UNEXPECTED = new String[]{\n-        TESTED_CLASS_NAME + \".<init>\"\n-    };\n-\n-    public static void main(String[] args) {\n-        try {\n-            Files.write(COMPILE_COMMAND_FILE, Arrays.asList(COMPILE_COMMAND),\n-                    StandardOpenOption.WRITE, StandardOpenOption.CREATE_NEW);\n-        } catch (IOException e) {\n-            throw new Error(\"TESTBUG: can't write list file \" + e, e);\n-        }\n-        OutputAnalyzer oa = JaotcTestHelper.compileLibrary(\"--compile-commands\", COMPILE_COMMAND_FILE.toString(),\n-                \"--class-name\", JaotcTestHelper.getClassAotCompilationName(HelloWorldOne.class));\n-        oa.shouldHaveExitValue(0);\n-        File compiledLibrary = new File(JaotcTestHelper.DEFAULT_LIB_PATH);\n-        Asserts.assertTrue(compiledLibrary.exists(), \"Compiled library file missing\");\n-        Asserts.assertGT(compiledLibrary.length(), 0L, \"Unexpected compiled library size\");\n-        JaotcTestHelper.checkLibraryUsage(TESTED_CLASS_NAME, EXPECTED, UNEXPECTED);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/cli\/jaotc\/ListOptionTest.java","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/ \/test\/lib \/testlibrary\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.aot.cli.jaotc.ListOptionWrongFileTest\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller compiler.aot.cli.jaotc.data.HelloWorldOne\n- * @run driver compiler.aot.cli.jaotc.ListOptionWrongFileTest\n- * @summary check jaotc can handle incorrect --compile-commands file\n- *\/\n-\n-package compiler.aot.cli.jaotc;\n-\n-import compiler.aot.cli.jaotc.data.HelloWorldOne;\n-import java.io.File;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public class ListOptionWrongFileTest {\n-    private static final String TESTED_CLASS_NAME = HelloWorldOne.class.getName();\n-    private static final String[] EXPECTED = new String[]{\n-        JaotcTestHelper.DEFAULT_LIBRARY_LOAD_MESSAGE,\n-        TESTED_CLASS_NAME\n-    };\n-\n-    private static final String COMPILE_ITEM\n-            = JaotcTestHelper.getClassAotCompilationName(HelloWorldOne.class);\n-\n-    private static final String COMPILE_FILE\n-            = JaotcTestHelper.getClassAotCompilationFilename(HelloWorldOne.class);\n-\n-    public static void main(String[] args) {\n-        \/\/ expecting wrong file to be read but no compilation directive recognized, so, all compiled\n-        OutputAnalyzer oa = JaotcTestHelper.compileLibrary(\"--compile-commands\", COMPILE_FILE, \"--class-name\", COMPILE_ITEM);\n-        oa.shouldHaveExitValue(0);\n-        File compiledLibrary = new File(JaotcTestHelper.DEFAULT_LIB_PATH);\n-        Asserts.assertTrue(compiledLibrary.exists(), \"Expected compiler library to exist\");\n-        JaotcTestHelper.checkLibraryUsage(HelloWorldOne.class.getName(), EXPECTED, null);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/cli\/jaotc\/ListOptionWrongFileTest.java","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.aot.cli.jaotc.data;\n-\n-public class HelloWorldOne {\n-    public static final String MESSAGE = \"HelloWorld1\";\n-\n-    public static void main(String args[]) {\n-        System.out.println(MESSAGE);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/cli\/jaotc\/data\/HelloWorldOne.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.aot.cli.jaotc.data;\n-\n-public class HelloWorldTwo {\n-    public static final String MESSAGE = \"HelloWorld2\";\n-\n-    public static void main(String args[]) {\n-        System.out.println(MESSAGE);\n-        System.out.println(\"Message length = \" + MESSAGE.length());\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/cli\/jaotc\/data\/HelloWorldTwo.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.aot.fingerprint;\n-\n-import java.io.File;\n-import java.io.FileOutputStream;\n-import java.io.PrintStream;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-\/\/ Usage:\n-\/\/ java CDSDumper <classpath> <classlist> <archive> <heapsize> <class1> <class2> ...\n-public class CDSDumper {\n-    public static void main(String[] args) throws Exception {\n-        String classpath = args[0];\n-        String classlist = args[1];\n-        String archive = args[2];\n-        String heapsize = args[3];\n-\n-        \/\/ Prepare the classlist\n-        FileOutputStream fos = new FileOutputStream(classlist);\n-        PrintStream ps = new PrintStream(fos);\n-\n-        for (int i=4; i<args.length; i++) {\n-            ps.println(args[i].replace('.', '\/'));\n-        }\n-        ps.close();\n-        fos.close();\n-\n-        \/\/ Dump the archive\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-            heapsize,\n-            \"-XX:+IgnoreUnrecognizedVMOptions\",\n-            \"-cp\", classpath,\n-            \"-XX:ExtraSharedClassListFile=\" + classlist,\n-            \"-XX:SharedArchiveFile=\" + archive,\n-            \"-Xshare:dump\",\n-            \"-Xlog:gc+heap+coops\",\n-            \"-Xlog:cds\");\n-\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        System.out.println(\"[stdout = \" + output.getStdout() + \"]\");\n-        System.out.println(\"[stderr = \" + output.getStderr() + \"]\");\n-        output.shouldContain(\"Loading classes to share\");\n-        output.shouldHaveExitValue(0);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/fingerprint\/CDSDumper.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.aot.fingerprint;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-\/\/ Usage:\n-\/\/ java CDSRunner <vmargs> <class> <args> ...\n-public class CDSRunner {\n-    public static void main(String[] args) throws Exception {\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(args);\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-\n-        System.out.println(\"[stdout = \" + output.getStdout() + \"]\");\n-        System.out.println(\"[stderr = \" + output.getStderr() + \"]\");\n-\n-        output.shouldContain(\"PASSED\");\n-        output.shouldHaveExitValue(0);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/fingerprint\/CDSRunner.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,132 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary AOT methods should be swept if a super class has changed.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.aot\n- * @build compiler.aot.fingerprint.SelfChanged\n- *        compiler.aot.AotCompiler\n- *\n- * @run main\n- *      compiler.aot.fingerprint.SelfChanged WRITE-UNMODIFIED-CLASS\n- * @run driver compiler.aot.AotCompiler -libname libSelfChanged.so\n- *      -class compiler.aot.fingerprint.Blah\n- *\n- * @run main\/othervm\n- *      compiler.aot.fingerprint.SelfChanged TEST-UNMODIFIED\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseAOT -XX:+PrintAOT\n- *      -XX:AOTLibrary=.\/libSelfChanged.so\n- *      -Xlog:aot+class+fingerprint=trace -Xlog:aot+class+load=trace\n- *      compiler.aot.fingerprint.SelfChanged TEST-UNMODIFIED\n- *\n- * @run main\n- *      compiler.aot.fingerprint.SelfChanged WRITE-MODIFIED-CLASS\n- * @run main\n- *      compiler.aot.fingerprint.SelfChanged TEST-MODIFIED\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseAOT -XX:+PrintAOT\n- *      -XX:AOTLibrary=.\/libSelfChanged.so\n- *      -Xlog:aot+class+fingerprint=trace -Xlog:aot+class+load=trace\n- *      compiler.aot.fingerprint.SelfChanged TEST-MODIFIED\n- *\/\n-\n-package compiler.aot.fingerprint;\n-\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.compiler.InMemoryJavaCompiler;\n-\n-import java.io.*;\n-\n-class Blah {\n-    volatile int z;\n-    int getX() {\n-        for (z = 0; z < 10000; z++) {\n-            if (z % 7 == 1) {\n-                z += 2;\n-            }\n-        }\n-        return 0;\n-    }\n-}\n-\n-public class SelfChanged {\n-    public static void main(String args[]) throws Throwable {\n-        Blah f = new Blah();\n-        System.out.println(\"f.getX = \" + f.getX());\n-        switch (args[0]) {\n-        case \"WRITE-UNMODIFIED-CLASS\":\n-            compileClass(false);\n-            break;\n-        case \"WRITE-MODIFIED-CLASS\":\n-            compileClass(true);\n-            break;\n-        case \"TEST-UNMODIFIED\":\n-            Asserts.assertTrue(f.getX() == 0, \"getX from unmodified Blah class should return 0\");\n-            break;\n-        case \"TEST-MODIFIED\":\n-            Asserts.assertTrue(f.getX() == 1, \"getX from modified Blah class should return 1\");\n-            break;\n-        default:\n-            throw new RuntimeException(\"unexpected option: \" + args[0]);\n-        }\n-    }\n-\n-    static void compileClass(boolean isModified) throws Throwable {\n-        String src =\n-               \"package compiler.aot.fingerprint;\"\n-             + \"public class Blah {\"\n-             + \"    volatile int z;\"\n-             + \"    int getX() {\"\n-             + \"        for (z = 0; z < 10000; z++) {\"\n-             + \"            if (z % 7 == 1) {\"\n-             + \"                z += 2;\"\n-             + \"            }\"\n-             + \"        }\"\n-             + \"        return \" + ((isModified) ? \"1\" : \"0\") + \";\"\n-             + \"    }\"\n-             + \"    int getY() {return 255;}\"\n-\n-            \/\/ The following is for the SelfChangedCDS.java test case. We always load an unmodified\n-            \/\/ version of Blah from the CDS archive. However, we would load an AOT library that\n-            \/\/ was compiled using a modified version of Blah. The getX method in this AOT library should\n-            \/\/ not be used.\n-\n-            + \"    public static void main(String args[]) {\"\n-             + \"        Blah b = new Blah();\"\n-             + \"        int n = b.getX();\"\n-             + \"        if (n != 0) {\"\n-             + \"            throw new RuntimeException(args[0] +  \\\" : \\\" + n);\"\n-             + \"        }\"\n-             + \"        System.out.println(\\\"PASSED\\\");\"\n-             + \"    }\"\n-             + \"}\";\n-\n-        String filename = System.getProperty(\"test.classes\") + \"\/compiler\/aot\/fingerprint\/Blah.class\";\n-        FileOutputStream fos = new FileOutputStream(filename);\n-        fos.write(InMemoryJavaCompiler.compile(\"compiler.aot.fingerprint.Blah\", src));\n-        fos.close();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/fingerprint\/SelfChanged.java","additions":0,"deletions":132,"binary":false,"changes":132,"status":"deleted"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary AOT methods should be swept if a super class has changed (with CDS).\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.aot & vm.cds\n- * @build compiler.aot.fingerprint.SelfChanged\n- *        sun.hotspot.WhiteBox\n- *\n- * @run driver compiler.aot.fingerprint.SelfChanged WRITE-UNMODIFIED-CLASS\n- * @run driver compiler.aot.AotCompiler -libname libSelfChanged.so\n- *      -class compiler.aot.fingerprint.Blah\n- *\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar SelfChangedCDS.jar compiler.aot.fingerprint.Blah\n- * @run driver compiler.aot.fingerprint.CDSDumper SelfChangedCDS.jar SelfChangedCDS.classlist SelfChangedCDS.jsa -showversion\n- *      compiler.aot.fingerprint.Blah\n- *\n- * @run driver compiler.aot.fingerprint.CDSRunner -cp SelfChangedCDS.jar\n- *      compiler.aot.fingerprint.Blah TEST-UNMODIFIED\n- * @run driver compiler.aot.fingerprint.CDSRunner -cp SelfChangedCDS.jar\n- *      -XX:+UnlockExperimentalVMOptions -XX:+UseAOT -XX:+PrintAOT\n- *      -XX:AOTLibrary=.\/libSelfChanged.so\n- *      -XX:SharedArchiveFile=SelfChangedCDS.jsa\n- *      -XX:+IgnoreUnrecognizedVMOptions\n- *      -Xshare:auto -showversion\n- *      -Xlog:cds -Xlog:gc+heap+coops\n- *      -Xlog:aot+class+fingerprint=trace -Xlog:aot+class+load=trace\n- *      compiler.aot.fingerprint.Blah TEST-UNMODIFIED\n- *\n- * @run driver\n- *      compiler.aot.fingerprint.SelfChanged WRITE-MODIFIED-CLASS\n- * @run driver compiler.aot.AotCompiler -libname libSelfChanged.so\n- *      -class compiler.aot.fingerprint.Blah\n- *\n- * @run driver compiler.aot.fingerprint.CDSRunner -cp SelfChangedCDS.jar\n- *      compiler.aot.fingerprint.Blah TEST-MODIFIED\n- * @run driver compiler.aot.fingerprint.CDSRunner -cp SelfChangedCDS.jar\n- *      -XX:+UnlockExperimentalVMOptions -XX:+UseAOT -XX:+PrintAOT\n- *      -XX:AOTLibrary=.\/libSelfChanged.so\n- *      -XX:SharedArchiveFile=SelfChangedCDS.jsa\n- *      -XX:+IgnoreUnrecognizedVMOptions\n- *      -Xshare:auto -showversion\n- *      -Xlog:cds -Xlog:gc+heap+coops\n- *      -Xlog:aot+class+fingerprint=trace -Xlog:aot+class+load=trace\n- *      compiler.aot.fingerprint.Blah TEST-MODIFIED\n- *\n- *\n- * @run driver compiler.aot.AotCompiler -libname libSelfChanged.so\n- *      -class compiler.aot.fingerprint.Blah\n- *      -extraopt -Xmx512m\n- *\n- * @run driver compiler.aot.fingerprint.CDSDumper SelfChangedCDS.jar SelfChangedCDS.classlist SelfChangedCDS.jsa -Xmx512m\n- *      compiler.aot.fingerprint.Blah\n- *\n- * @run driver compiler.aot.fingerprint.CDSRunner -Xmx512m -cp SelfChangedCDS.jar\n- *      compiler.aot.fingerprint.Blah TEST-UNMODIFIED\n- * @run driver compiler.aot.fingerprint.CDSRunner -Xmx512m -cp SelfChangedCDS.jar\n- *      -XX:+UnlockExperimentalVMOptions -XX:+UseAOT -XX:+PrintAOT\n- *      -XX:AOTLibrary=.\/libSelfChanged.so\n- *      -XX:SharedArchiveFile=SelfChangedCDS.jsa\n- *      -XX:+IgnoreUnrecognizedVMOptions\n- *      -Xshare:auto -showversion\n- *      -Xlog:cds -Xlog:gc+heap+coops\n- *      -Xlog:aot+class+fingerprint=trace -Xlog:aot+class+load=trace\n- *      compiler.aot.fingerprint.Blah TEST-UNMODIFIED\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/fingerprint\/SelfChangedCDS.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary AOT methods should be swept if a super class has changed.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.aot\n- * @build compiler.aot.fingerprint.SuperChanged\n- *        compiler.aot.AotCompiler\n- *\n- * @run main\n- *      compiler.aot.fingerprint.SuperChanged WRITE-UNMODIFIED-CLASS\n- * @run driver compiler.aot.AotCompiler -libname libSuperChanged.so\n- *      -class compiler.aot.fingerprint.Foo\n- *\n- * @run main\n- *      compiler.aot.fingerprint.SuperChanged TEST-UNMODIFIED\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseAOT -XX:+PrintAOT\n- *      -XX:AOTLibrary=.\/libSuperChanged.so\n- *      -Xlog:aot+class+fingerprint=trace -Xlog:aot+class+load=trace\n- *      compiler.aot.fingerprint.SuperChanged TEST-UNMODIFIED\n-  *\n- * @run main\n- *      compiler.aot.fingerprint.SuperChanged WRITE-MODIFIED-CLASS\n- * @run main\n- *      compiler.aot.fingerprint.SuperChanged TEST-MODIFIED\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseAOT -XX:+PrintAOT\n- *      -XX:AOTLibrary=.\/libSuperChanged.so\n- *      -Xlog:aot+class+fingerprint=trace -Xlog:aot+class+load=trace\n- *      compiler.aot.fingerprint.SuperChanged TEST-MODIFIED\n- *\/\n-\n-package compiler.aot.fingerprint;\n-\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.compiler.InMemoryJavaCompiler;\n-\n-import java.io.*;\n-\n-class Bar {\n-    volatile int x = 0;\n-    volatile int y = 1;\n-}\n-\n-class Foo extends Bar {\n-\n-    volatile int z;\n-    int getX() {\n-        for (z = 0; z < 10000; z++) {\n-            if (z % 7 == 1) {\n-                z += 2;\n-            }\n-        }\n-        return x;\n-    }\n-}\n-\n-public class SuperChanged {\n-    public static void main(String args[]) throws Throwable {\n-        Foo f = new Foo();\n-        System.out.println(\"f.getX = \" + f.getX());\n-        switch (args[0]) {\n-        case \"WRITE-UNMODIFIED-CLASS\":\n-            compileClass(false);\n-            break;\n-        case \"WRITE-MODIFIED-CLASS\":\n-            compileClass(true);\n-            break;\n-        case \"TEST-UNMODIFIED\":\n-            Asserts.assertTrue(f.getX() == 0, \"getX from unmodified Foo class should return 0\");\n-            break;\n-        case \"TEST-MODIFIED\":\n-            Asserts.assertTrue(f.getX() == 1, \"getX from modified Foo class should return 1\");\n-            break;\n-        default:\n-            throw new RuntimeException(\"unexpected option: \" + args[0]);\n-        }\n-    }\n-\n-    static void compileClass(boolean isModified) throws Throwable {\n-        String class_src_0 = \"package compiler.aot.fingerprint; class Bar {volatile int x = 0;  volatile int y = 1;}\";\n-        String class_src_1 = \"package compiler.aot.fingerprint; class Bar {volatile int y = 0;  volatile int x = 1;}\";\n-        String src = (isModified) ? class_src_1 : class_src_0;\n-\n-        String filename = System.getProperty(\"test.classes\") + \"\/compiler\/aot\/fingerprint\/Bar.class\";\n-        FileOutputStream fos = new FileOutputStream(filename);\n-        fos.write(InMemoryJavaCompiler.compile(\"compiler.aot.fingerprint.Bar\", src));\n-        fos.close();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/fingerprint\/SuperChanged.java","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"},{"patch":"@@ -1,131 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @requires vm.aot\n- * @modules jdk.aot\/jdk.tools.jaotc.utils\n- * @run junit\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI jdk.tools.jaotc.test.NativeOrderOutputStreamTest\n- *\/\n-\n-package jdk.tools.jaotc.test;\n-\n-import jdk.tools.jaotc.utils.NativeOrderOutputStream;\n-import org.junit.Assert;\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-\n-public class NativeOrderOutputStreamTest {\n-\n-    private NativeOrderOutputStream target;\n-\n-    @Before\n-    public void setup() {\n-        target = new NativeOrderOutputStream();\n-    }\n-\n-    @Test\n-    public void shouldAdd4BytesForInt() {\n-        target.putInt(5);\n-        Assert.assertEquals(4, target.position());\n-    }\n-\n-    @Test\n-    public void shouldAdd8BytesForLong() {\n-        target.putLong(8);\n-        Assert.assertEquals(8, target.position());\n-    }\n-\n-    @Test\n-    public void shouldHaveCorrectSizeBeforePatch() {\n-        target.patchableInt();\n-        Assert.assertEquals(4, target.position());\n-    }\n-\n-    @Test\n-    public void shouldHaveCorrectSizeAfterPatch() {\n-        NativeOrderOutputStream.PatchableInt patchableInt = target.patchableInt();\n-        patchableInt.set(12);\n-        Assert.assertEquals(4, target.position());\n-    }\n-\n-    @Test\n-    public void shouldSetCorrectValueInPatch() {\n-        NativeOrderOutputStream.PatchableInt patchableInt = target.patchableInt();\n-        patchableInt.set(42);\n-        Assert.assertEquals(42, getInt(0));\n-    }\n-\n-    private int getInt(int pos) {\n-        ByteBuffer buffer = ByteBuffer.wrap(target.array());\n-        buffer.order(ByteOrder.nativeOrder());\n-        return buffer.getInt(pos);\n-    }\n-\n-    @Test\n-    public void shouldPutArrayCorrectly() {\n-        target.put(new byte[]{42, 5, 43, 44});\n-        Assert.assertEquals(4, target.position());\n-        Assert.assertEquals(42, target.array()[0]);\n-        Assert.assertEquals(4, target.position());\n-    }\n-\n-    @Test\n-    public void shouldOnlyPatchSlot() {\n-        NativeOrderOutputStream.PatchableInt patchableInt = target.patchableInt();\n-        target.putInt(7);\n-        patchableInt.set(39);\n-        Assert.assertEquals(39, getInt(0));\n-        Assert.assertEquals(7, getInt(4));\n-    }\n-\n-    @Test\n-    public void shouldBeAbleToPatchAnywhere() {\n-        target.putInt(19);\n-        NativeOrderOutputStream.PatchableInt patchableInt = target.patchableInt();\n-        patchableInt.set(242);\n-\n-        Assert.assertEquals(19, getInt(0));\n-        Assert.assertEquals(242, getInt(4));\n-    }\n-\n-    @Test\n-    public void shouldHavePatchableAtRightOffset() {\n-        target.putInt(27);\n-        Assert.assertEquals(4, target.position());\n-        NativeOrderOutputStream.PatchableInt patchableInt = target.patchableInt();\n-        Assert.assertEquals(4, patchableInt.position());\n-    }\n-\n-    @Test\n-    public void shouldAlign() {\n-        target.putInt(9);\n-        target.align(16);\n-        target.put(new byte[]{3});\n-        target.align(8);\n-        Assert.assertEquals(24, target.position());\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/jdk.tools.jaotc.test\/src\/jdk\/tools\/jaotc\/test\/NativeOrderOutputStreamTest.java","additions":0,"deletions":131,"binary":false,"changes":131,"status":"deleted"},{"patch":"@@ -1,211 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @requires vm.aot\n- * @modules jdk.aot\/jdk.tools.jaotc\n- *          jdk.aot\/jdk.tools.jaotc.collect\n- * @run junit\/othervm jdk.tools.jaotc.test.collect.ClassSearchTest\n- *\/\n-\n-package jdk.tools.jaotc.test.collect;\n-\n-\n-import jdk.tools.jaotc.LoadedClass;\n-import jdk.tools.jaotc.collect.*;\n-import org.junit.Assert;\n-import org.junit.Test;\n-\n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.function.BiConsumer;\n-import java.util.function.BiFunction;\n-\n-public class ClassSearchTest {\n-    @Test(expected = InternalError.class)\n-    public void itShouldThrowExceptionIfNoProvidersAvailable() {\n-        ClassSearch target = new ClassSearch();\n-        SearchPath searchPath = new SearchPath();\n-        target.search(list(new SearchFor(\"foo\")), searchPath);\n-    }\n-\n-    @Test\n-    public void itShouldFindAProviderForEachEntry() {\n-        Set<String> searched = new HashSet<>();\n-        ClassSearch target = new ClassSearch();\n-        target.addProvider(provider(\"\", (name, searchPath) -> {\n-                searched.add(name);\n-                return new NoopSource();\n-        }));\n-        target.search(searchForList(\"foo\", \"bar\", \"foobar\"), null);\n-        Assert.assertEquals(hashset(\"foo\", \"bar\", \"foobar\"), searched);\n-    }\n-\n-    private SourceProvider provider(String supports, BiFunction<String, SearchPath, ClassSource> fn) {\n-        return new SourceProvider() {\n-            @Override\n-            public ClassSource findSource(String name, SearchPath searchPath) {\n-                return fn.apply(name, searchPath);\n-            }\n-\n-            @Override\n-            public boolean supports(String type) {\n-                return supports.equals(type);\n-            }\n-        };\n-    }\n-\n-    @Test\n-    public void itShouldOnlySearchSupportedProvidersForKnownType() {\n-        Set<String> visited = new HashSet<>();\n-        ClassSearch target = new ClassSearch();\n-\n-        target.addProvider(provider(\"jar\", (name, searchPath) -> {\n-            visited.add(\"jar\");\n-            return null;\n-        }));\n-\n-        target.addProvider(provider(\"dir\", (name, searchPath) -> {\n-            visited.add(\"dir\");\n-            return null;\n-        }));\n-\n-        try {\n-            target.search(list(new SearchFor(\"some\", \"dir\")), null);\n-        } catch (InternalError e) {\n-            \/\/ throws because no provider gives a source\n-        }\n-\n-        Assert.assertEquals(hashset(\"dir\"), visited);\n-    }\n-\n-    @Test(expected = InternalError.class)\n-    public void itShouldThrowErrorIfMultipleSourcesAreAvailable() {\n-        ClassSearch target = new ClassSearch();\n-        target.addProvider(provider(\"\", (name, searchPath) -> consumer -> Assert.fail()));\n-        target.addProvider(provider(\"\", (name, searchPath) -> consumer -> Assert.fail()));\n-\n-        target.search(searchForList(\"somethign\"), null);\n-    }\n-\n-    @Test\n-    public void itShouldSearchAllProvidersForUnknownType() {\n-        Set<String> visited = new HashSet<>();\n-        ClassSearch target = new ClassSearch();\n-        target.addProvider(provider(\"\", (name, searchPath) -> {\n-            visited.add(\"1\");\n-            return null;\n-        }));\n-        target.addProvider(provider(\"\", (name, searchPath) -> {\n-            visited.add(\"2\");\n-            return null;\n-        }));\n-\n-        try {\n-            target.search(searchForList(\"foo\"), null);\n-        } catch (InternalError e) {\n-            \/\/ throws because no provider gives a source\n-        }\n-\n-        Assert.assertEquals(hashset(\"1\", \"2\"), visited);\n-    }\n-\n-    @Test\n-    public void itShouldTryToLoadSaidClassFromClassLoader() {\n-        Set<String> loaded = new HashSet<>();\n-\n-        ClassSearch target = new ClassSearch();\n-        target.addProvider(new SourceProvider() {\n-            @Override\n-            public boolean supports(String type) {\n-                return true;\n-            }\n-\n-            @Override\n-            public ClassSource findSource(String name, SearchPath searchPath) {\n-                return new ClassSource() {\n-                    @Override\n-                    public void eachClass(BiConsumer<String, ClassLoader> consumer) {\n-                        consumer.accept(\"foo.Bar\", new ClassLoader() {\n-                            @Override\n-                            public Class<?> loadClass(String name) throws ClassNotFoundException {\n-                                loaded.add(name);\n-                                return null;\n-                            }\n-                        });\n-                    }\n-                };\n-            }\n-        });\n-\n-        java.util.List<LoadedClass> search = target.search(searchForList(\"\/tmp\/something\"), null);\n-        Assert.assertEquals(list(new LoadedClass(\"foo.Bar\", null)), search);\n-    }\n-\n-    @Test(expected = InternalError.class)\n-    public void itShouldThrowInternalErrorWhenClassLoaderFails() {\n-        ClassLoader classLoader = new ClassLoader() {\n-            @Override\n-            public Class<?> loadClass(String name1) throws ClassNotFoundException {\n-                throw new ClassNotFoundException(\"failed to find \" + name1);\n-            }\n-        };\n-\n-        ClassSearch target = new ClassSearch();\n-        target.addProvider(provider(\"\", (name, searchPath) -> consumer -> consumer.accept(\"foo.Bar\", classLoader)));\n-        target.search(searchForList(\"foobar\"), null);\n-    }\n-\n-    private List<SearchFor> searchForList(String... entries) {\n-        List<SearchFor> list = new ArrayList<>();\n-        for (String entry : entries) {\n-            list.add(new SearchFor(entry));\n-        }\n-        return list;\n-    }\n-\n-    private <T> List<T> list(T... entries) {\n-        List<T> list = new ArrayList<T>();\n-        for (T entry : entries) {\n-            list.add(entry);\n-        }\n-        return list;\n-    }\n-\n-    private <T> Set<T> hashset(T... entries) {\n-        Set<T> set = new HashSet<T>();\n-        for (T entry : entries) {\n-            set.add(entry);\n-        }\n-        return set;\n-    }\n-\n-    private static class NoopSource implements ClassSource {\n-        @Override\n-        public void eachClass(BiConsumer<String, ClassLoader> consumer) {\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/jdk.tools.jaotc.test\/src\/jdk\/tools\/jaotc\/test\/collect\/ClassSearchTest.java","additions":0,"deletions":211,"binary":false,"changes":211,"status":"deleted"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @requires vm.aot\n- * @modules jdk.aot\/jdk.tools.jaotc\n- *          jdk.aot\/jdk.tools.jaotc.collect\n- * @build jdk.tools.jaotc.test.collect.Utils\n- * @run junit\/othervm jdk.tools.jaotc.test.collect.ClassSourceTest\n- *\/\n-\n-package jdk.tools.jaotc.test.collect;\n-\n-import org.junit.Assert;\n-import org.junit.Test;\n-\n-import java.nio.file.Paths;\n-\n-import static jdk.tools.jaotc.collect.ClassSource.makeClassName;\n-\n-import static jdk.tools.jaotc.test.collect.Utils.getpath;\n-\n-public class ClassSourceTest {\n-    @Test(expected=IllegalArgumentException.class)\n-    public void itShouldThrowExceptionIfPathDoesntEndWithClass() {\n-        makeClassName(Paths.get(\"Bar.clazz\"));\n-    }\n-\n-    @Test\n-    public void itShouldReplaceSlashesWithDots() {\n-        Assert.assertEquals(\"foo.Bar\", makeClassName(getpath(\"foo\/Bar.class\")));\n-    }\n-\n-    @Test\n-    public void itShouldStripLeadingSlash() {\n-        Assert.assertEquals(\"Hello\", makeClassName(getpath(\"\/Hello.class\")));\n-    }\n-\n-    @Test\n-    public void itShouldReplaceMultipleDots() {\n-        Assert.assertEquals(\"some.foo.bar.FooBar\", makeClassName(getpath(\"\/some\/foo\/bar\/FooBar.class\")));\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/jdk.tools.jaotc.test\/src\/jdk\/tools\/jaotc\/test\/collect\/ClassSourceTest.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -1,112 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.tools.jaotc.test.collect;\n-\n-import java.net.MalformedURLException;\n-import java.nio.file.Path;\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-import jdk.tools.jaotc.collect.FileSupport;\n-\n-public class FakeFileSupport extends FileSupport {\n-    private final Set<String> exists = new HashSet<>();\n-    private final Set<String> directories = new HashSet<>();\n-\n-    private final Set<String> checkedExists = new HashSet<>();\n-    private final Set<String> checkedDirectory = new HashSet<>();\n-    private final Set<String> checkedJarFileSystemRoots = new HashSet<>();\n-    private final Set<String> classloaderPaths = new HashSet<>();\n-\n-    private Path jarFileSystemRoot = null;\n-    private final ClassLoader classLoader;\n-\n-    public FakeFileSupport(Set<String> existing, Set<String> directories) {\n-        this.exists.addAll(existing);\n-        this.directories.addAll(directories);\n-\n-        classLoader = new ClassLoader() {\n-            @Override\n-            public Class<?> loadClass(String name) throws ClassNotFoundException {\n-                return null;\n-            }\n-        };\n-    }\n-\n-    public void setJarFileSystemRoot(Path path) {\n-        jarFileSystemRoot = path;\n-    }\n-\n-    @Override\n-    public boolean exists(Path path) {\n-        checkedExists.add(path.toString());\n-        return exists.contains(path.toString());\n-    }\n-\n-    @Override\n-    public boolean isDirectory(Path path) {\n-        checkedDirectory.add(path.toString());\n-        return directories.contains(path.toString());\n-    }\n-\n-    @Override\n-    public ClassLoader createClassLoader(Path path) throws MalformedURLException {\n-        classloaderPaths.add(path.toString());\n-        return classLoader;\n-    }\n-\n-    @Override\n-    public Path getJarFileSystemRoot(Path jarFile) {\n-        checkedJarFileSystemRoots.add(jarFile.toString());\n-        return jarFileSystemRoot;\n-    }\n-\n-    @Override\n-    public boolean isAbsolute(Path entry) {\n-        return entry.toString().startsWith(\"\/\");\n-    }\n-\n-    public void addExist(String name) {\n-        exists.add(name);\n-    }\n-\n-    public void addDirectory(String name) {\n-        directories.add(name);\n-    }\n-\n-    public Set<String> getCheckedExists() {\n-        return checkedExists;\n-    }\n-\n-    public Set<String> getCheckedDirectory() {\n-        return checkedDirectory;\n-    }\n-\n-    public Set<String> getCheckedJarFileSystemRoots() {\n-        return checkedJarFileSystemRoots;\n-    }\n-\n-    public Set<String> getClassloaderPaths() {\n-        return classloaderPaths;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/jdk.tools.jaotc.test\/src\/jdk\/tools\/jaotc\/test\/collect\/FakeFileSupport.java","additions":0,"deletions":112,"binary":false,"changes":112,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.tools.jaotc.test.collect;\n-\n-import jdk.tools.jaotc.collect.SearchPath;\n-\n-import java.nio.file.FileSystem;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.Set;\n-\n-import static jdk.tools.jaotc.test.collect.Utils.set;\n-\n-public class FakeSearchPath extends SearchPath {\n-    private Path path = null;\n-    public Set<String> entries = set();\n-\n-    public FakeSearchPath(String name) {\n-        if (name != null) {\n-            path = Paths.get(name);\n-        }\n-    }\n-\n-    @Override\n-    public Path find(FileSystem fileSystem, Path entry, String... defaults) {\n-        entries.add(entry.toString());\n-        return path;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/jdk.tools.jaotc.test\/src\/jdk\/tools\/jaotc\/test\/collect\/FakeSearchPath.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,118 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @requires vm.aot\n- * @modules jdk.aot\/jdk.tools.jaotc\n- *          jdk.aot\/jdk.tools.jaotc.collect\n- *\n- * @build jdk.tools.jaotc.test.collect.Utils\n- * @build jdk.tools.jaotc.test.collect.FakeFileSupport\n- * @run junit\/othervm jdk.tools.jaotc.test.collect.SearchPathTest\n- *\/\n-\n-package jdk.tools.jaotc.test.collect;\n-\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-\n-import jdk.tools.jaotc.collect.*;\n-\n-import static jdk.tools.jaotc.test.collect.Utils.set;\n-import static jdk.tools.jaotc.test.collect.Utils.mkpath;\n-import static jdk.tools.jaotc.test.collect.Utils.mkpaths;\n-import static org.junit.Assert.*;\n-\n-public class SearchPathTest {\n-    private FakeFileSupport fileSupport;\n-    private FileSystem fs;\n-\n-    @Before\n-    public void setUp() throws Exception {\n-        fs = FileSystems.getDefault();\n-    }\n-\n-    @Test\n-    public void itShouldUsePathIfPathIsAbsoluteAndExisting() {\n-        fileSupport = new FakeFileSupport(mkpaths(\"\/foo\"), set());\n-        SearchPath target = new SearchPath(fileSupport);\n-        Path foo = Paths.get(mkpath(\"\/foo\"));\n-        Path result = target.find(fs, foo);\n-        assertSame(result, foo);\n-    }\n-\n-    @Test\n-    public void itShouldReturnNullIfPathIsAbsoluteAndNonExisting() {\n-        fileSupport = new FakeFileSupport(set(), set());\n-        SearchPath target = new SearchPath(fileSupport);\n-        Path result = target.find(fs, Paths.get(mkpath(\"\/bar\")));\n-        assertNull(result);\n-    }\n-\n-    @Test\n-    public void itShouldUseRelativeExisting() {\n-        fileSupport = new FakeFileSupport(mkpaths(\"hello\", \"tmp\/hello\", \"search\/hello\"), set());\n-        SearchPath target = new SearchPath(fileSupport);\n-        target.add(\"search\");\n-        Path hello = Paths.get(\"hello\");\n-        Path result = target.find(fs, hello, \"tmp\");\n-        assertSame(result, hello);\n-    }\n-\n-    @Test\n-    public void itShouldSearchDefaultsBeforeSearchPaths() {\n-        fileSupport = new FakeFileSupport(mkpaths(\"bar\/foobar\"), set());\n-        SearchPath target = new SearchPath(fileSupport);\n-        Path result = target.find(fs, Paths.get(\"foobar\"), \"default1\", \"bar\");\n-        assertEquals(mkpath(\"bar\/foobar\"), result.toString());\n-        assertEquals(mkpaths(\"foobar\", \"default1\/foobar\", \"bar\/foobar\"), fileSupport.getCheckedExists());\n-    }\n-\n-    @Test\n-    public void itShouldUseSearchPathsIfNotInDefaults() {\n-        fileSupport = new FakeFileSupport(mkpaths(\"bar\/tmp\/foobar\"), set());\n-        SearchPath target = new SearchPath(fileSupport);\n-        target.add(\"foo\/tmp\", \"bar\/tmp\");\n-\n-        Path result = target.find(fs, Paths.get(\"foobar\"), \"foo\", \"bar\");\n-        assertEquals(mkpath(\"bar\/tmp\/foobar\"), result.toString());\n-        assertEquals(mkpaths(\"foobar\", \"foo\/foobar\", \"bar\/foobar\", \"bar\/tmp\/foobar\", \"foo\/tmp\/foobar\"), fileSupport.getCheckedExists());\n-    }\n-\n-    @Test\n-    public void itShouldReturnNullIfNoExistingPathIsFound() {\n-        fileSupport = new FakeFileSupport(set(), set());\n-        SearchPath target = new SearchPath(fileSupport);\n-        target.add(\"dir1\", \"dir2\");\n-\n-        Path result = target.find(fs, Paths.get(\"entry\"), \"dir3\", \"dir4\");\n-        assertNull(result);\n-        assertEquals(mkpaths(\"entry\", \"dir1\/entry\", \"dir2\/entry\", \"dir3\/entry\", \"dir4\/entry\"), fileSupport.getCheckedExists());\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/jdk.tools.jaotc.test\/src\/jdk\/tools\/jaotc\/test\/collect\/SearchPathTest.java","additions":0,"deletions":118,"binary":false,"changes":118,"status":"deleted"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.tools.jaotc.test.collect;\n-\n-import java.io.File;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-public class Utils {\n-    public static <T> Set<T> set(T... entries) {\n-        Set<T> set = new HashSet<T>();\n-        for (T entry : entries) {\n-            set.add(entry);\n-        }\n-        return set;\n-    }\n-\n-    public static String mkpath(String path) {\n-        return getpath(path).toString();\n-    }\n-\n-    public static Set<String> mkpaths(String... paths) {\n-        Set<String> set = new HashSet<String>();\n-        for (String entry : paths) {\n-            set.add(mkpath(entry));\n-        }\n-        return set;\n-    }\n-\n-    public static Path getpath(String path) {\n-        if (path.startsWith(\"\/\") && System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n-            path = new File(path).getAbsolutePath();\n-        }\n-        return Paths.get(path);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/jdk.tools.jaotc.test\/src\/jdk\/tools\/jaotc\/test\/collect\/Utils.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -1,89 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @requires vm.aot\n- * @modules jdk.aot\/jdk.tools.jaotc\n- *          jdk.aot\/jdk.tools.jaotc.collect\n- *          jdk.aot\/jdk.tools.jaotc.collect.directory\n- * @compile ..\/Utils.java\n- * @compile ..\/FakeFileSupport.java\n- * @run junit\/othervm jdk.tools.jaotc.test.collect.directory.DirectorySourceProviderTest\n- *\/\n-\n-package jdk.tools.jaotc.test.collect.directory;\n-\n-import jdk.tools.jaotc.collect.ClassSource;\n-import jdk.tools.jaotc.collect.directory.DirectorySourceProvider;\n-import jdk.tools.jaotc.test.collect.FakeFileSupport;\n-import jdk.tools.jaotc.collect.FileSupport;\n-import org.junit.Assert;\n-import org.junit.Test;\n-\n-import java.net.MalformedURLException;\n-import java.nio.file.Path;\n-import java.util.Set;\n-\n-import static jdk.tools.jaotc.test.collect.Utils.set;\n-\n-public class DirectorySourceProviderTest {\n-    @Test\n-    public void itShouldReturnNullForNonExistantPath() {\n-        DirectorySourceProvider target = new DirectorySourceProvider(new FakeFileSupport(set(), set()));\n-        ClassSource result = target.findSource(\"hello\", null);\n-        Assert.assertNull(result);\n-    }\n-\n-    @Test\n-    public void itShouldReturnNullForNonDirectory() {\n-        DirectorySourceProvider target = new DirectorySourceProvider(new FakeFileSupport(set(\"foobar\"), set()));\n-        ClassSource result = target.findSource(\"foobar\", null);\n-        Assert.assertNull(result);\n-    }\n-\n-    @Test\n-    public void itShouldReturnNullForMalformedURI() {\n-        Set<String> visited = set();\n-        DirectorySourceProvider target = new DirectorySourceProvider(new FakeFileSupport(set(\"foobar\"), set(\"foobar\")) {\n-            @Override\n-            public ClassLoader createClassLoader(Path path) throws MalformedURLException {\n-                visited.add(\"1\");\n-                throw new MalformedURLException(\"...\");\n-            }\n-        });\n-        ClassSource result = target.findSource(\"foobar\", null);\n-        Assert.assertNull(result);\n-        Assert.assertEquals(set(\"1\"), visited);\n-    }\n-\n-    @Test\n-    public void itShouldCreateSourceIfNameExistsAndIsADirectory() {\n-        FileSupport fileSupport = new FakeFileSupport(set(\"foo\"), set(\"foo\"));\n-        DirectorySourceProvider target = new DirectorySourceProvider(fileSupport);\n-        ClassSource foo = target.findSource(\"foo\", null);\n-        Assert.assertNotNull(foo);\n-        Assert.assertEquals(\"directory:foo\", foo.toString());\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/jdk.tools.jaotc.test\/src\/jdk\/tools\/jaotc\/test\/collect\/directory\/DirectorySourceProviderTest.java","additions":0,"deletions":89,"binary":false,"changes":89,"status":"deleted"},{"patch":"@@ -1,128 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @requires vm.aot\n- * @modules jdk.aot\/jdk.tools.jaotc\n- *          jdk.aot\/jdk.tools.jaotc.collect\n- *          jdk.aot\/jdk.tools.jaotc.collect.jar\n- * @compile ..\/Utils.java\n- * @compile ..\/FakeFileSupport.java\n- * @compile ..\/FakeSearchPath.java\n- *\n- * @run junit\/othervm jdk.tools.jaotc.test.collect.jar.JarSourceProviderTest\n- *\/\n-\n-package jdk.tools.jaotc.test.collect.jar;\n-\n-import jdk.tools.jaotc.collect.ClassSource;\n-import jdk.tools.jaotc.collect.jar.JarSourceProvider;\n-import jdk.tools.jaotc.test.collect.FakeFileSupport;\n-import jdk.tools.jaotc.test.collect.FakeSearchPath;\n-import org.junit.Assert;\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.ProviderNotFoundException;\n-import java.util.Set;\n-\n-import static jdk.tools.jaotc.test.collect.Utils.mkpath;\n-import static jdk.tools.jaotc.test.collect.Utils.set;\n-\n-public class JarSourceProviderTest {\n-\n-    private FakeFileSupport fileSupport;\n-    private JarSourceProvider target;\n-\n-    @Before\n-    public void setUp() throws Exception {\n-        fileSupport = new FakeFileSupport(set(), set());\n-        target = new JarSourceProvider(fileSupport);\n-    }\n-\n-    @Test\n-    public void itShouldUseSearchPathToFindPath() {\n-        Set<String> visited = set();\n-        JarSourceProvider target = new JarSourceProvider(fileSupport);\n-        FakeSearchPath searchPath = new FakeSearchPath(null);\n-        ClassSource source = target.findSource(\"hello\", searchPath);\n-\n-        Assert.assertEquals(set(\"hello\"), searchPath.entries);\n-    }\n-\n-    @Test\n-    public void itShouldReturnNullIfPathIsNull() {\n-        JarSourceProvider target = new JarSourceProvider(fileSupport);\n-        ClassSource source = target.findSource(\"foobar\", new FakeSearchPath(null));\n-        Assert.assertNull(source);\n-    }\n-\n-    @Test\n-    public void itShouldReturnNullIfPathIsDirectory() {\n-        fileSupport.addDirectory(\"hello\/foobar\");\n-        ClassSource source = target.findSource(\"foobar\", new FakeSearchPath(\"hello\/foobar\"));\n-\n-        Assert.assertNull(source);\n-        Assert.assertEquals(set(mkpath(\"hello\/foobar\")), fileSupport.getCheckedDirectory());\n-    }\n-\n-    @Test\n-    public void itShouldReturnNullIfUnableToMakeJarFileSystem() {\n-        fileSupport.setJarFileSystemRoot(null);\n-        ClassSource result = target.findSource(\"foobar\", new FakeSearchPath(\"foo\/bar\"));\n-\n-        Assert.assertEquals(set(mkpath(\"foo\/bar\")), fileSupport.getCheckedJarFileSystemRoots());\n-        Assert.assertNull(result);\n-    }\n-\n-    @Test\n-    public void itShouldReturnNullIfNotValidJarProvider() {\n-        fileSupport = new FakeFileSupport(set(), set()) {\n-\n-            @Override\n-            public Path getJarFileSystemRoot(Path jarFile) {\n-                super.getJarFileSystemRoot(jarFile);\n-                throw new ProviderNotFoundException();\n-            }\n-        };\n-        fileSupport.setJarFileSystemRoot(null);\n-        target = new JarSourceProvider(fileSupport);\n-\n-        ClassSource result = target.findSource(\"foobar\", new FakeSearchPath(\"foo\/bar\"));\n-\n-        Assert.assertEquals(set(mkpath(\"foo\/bar\")), fileSupport.getCheckedJarFileSystemRoots());\n-        Assert.assertNull(result);\n-    }\n-\n-    @Test\n-    public void itShouldReturnSourceWhenAllIsValid() {\n-        fileSupport.setJarFileSystemRoot(Paths.get(\"some\/bar\"));\n-        ClassSource result = target.findSource(\"foobar\", new FakeSearchPath(\"this\/bar\"));\n-\n-        Assert.assertEquals(set(mkpath(\"this\/bar\")), fileSupport.getClassloaderPaths());\n-        Assert.assertEquals(\"jar:\" + mkpath(\"this\/bar\"), result.toString());\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/jdk.tools.jaotc.test\/src\/jdk\/tools\/jaotc\/test\/collect\/jar\/JarSourceProviderTest.java","additions":0,"deletions":128,"binary":false,"changes":128,"status":"deleted"},{"patch":"@@ -1,103 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @requires vm.aot\n- * @modules jdk.aot\/jdk.tools.jaotc\n- *          jdk.aot\/jdk.tools.jaotc.collect\n- *          jdk.aot\/jdk.tools.jaotc.collect.module\n- * @compile ..\/Utils.java\n- * @run junit\/othervm jdk.tools.jaotc.test.collect.module.ModuleSourceProviderTest\n- *\/\n-\n-package jdk.tools.jaotc.test.collect.module;\n-\n-import jdk.tools.jaotc.collect.FileSupport;\n-import jdk.tools.jaotc.collect.module.ModuleSource;\n-import jdk.tools.jaotc.collect.module.ModuleSourceProvider;\n-import jdk.tools.jaotc.test.collect.Utils;\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-import java.io.IOException;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.function.BiFunction;\n-\n-import static jdk.tools.jaotc.test.collect.Utils.mkpath;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNull;\n-\n-\n-public class ModuleSourceProviderTest {\n-    private ClassLoader classLoader;\n-    private ModuleSourceProvider target;\n-    private FileSupport fileSupport;\n-    private BiFunction<Path, Path, Path> getSubDirectory = null;\n-\n-    @Before\n-    public void setUp() {\n-        classLoader = new FakeClassLoader();\n-        fileSupport = new FileSupport() {\n-\n-            @Override\n-            public boolean isDirectory(Path path) {\n-                return true;\n-            }\n-\n-            @Override\n-            public Path getSubDirectory(FileSystem fileSystem, Path root, Path path) throws IOException {\n-                if (getSubDirectory == null) {\n-                    throw new IOException(\"Nope\");\n-                }\n-                return getSubDirectory.apply(root, path);\n-            }\n-        };\n-        target = new ModuleSourceProvider(FileSystems.getDefault(), classLoader, fileSupport);\n-    }\n-\n-    @Test\n-    public void itShouldUseFileSupport() {\n-        getSubDirectory = (root, path) -> {\n-            if (root.toString().equals(\"modules\") && path.toString().equals(\"test.module\")) {\n-                return Paths.get(\"modules\/test.module\");\n-            }\n-            return null;\n-        };\n-\n-        ModuleSource source = (ModuleSource) target.findSource(\"test.module\", null);\n-        assertEquals(mkpath(\"modules\/test.module\"), source.getModulePath().toString());\n-        assertEquals(\"module:\" + mkpath(\"modules\/test.module\"), source.toString());\n-    }\n-\n-    private static class FakeClassLoader extends ClassLoader {\n-        @Override\n-        public Class<?> loadClass(String name) throws ClassNotFoundException {\n-            return null;\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/jdk.tools.jaotc.test\/src\/jdk\/tools\/jaotc\/test\/collect\/module\/ModuleSourceProviderTest.java","additions":0,"deletions":103,"binary":false,"changes":103,"status":"deleted"},{"patch":"@@ -1,5 +0,0 @@\n-public class HelloWorld {\n-    public static void main(String[] args) {\n-        System.out.println(\"Hello, world!\");\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/scripts\/HelloWorld.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.vm.ci.hotspot.*;\n-\n-public class InitGraal {\n-    public static void main(String[] args) throws Throwable {\n-        HotSpotJVMCIRuntime.runtime().getCompiler();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/scripts\/InitGraal.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-or visit www.oracle.com if you need additional information or have any\n-questions.\n-\n---------------------------------------------\n-This directory contains scripts to test AOT.\n-\n-JAVA_HOME should point to local JDK (scripts will install AOT libraries into it) which supports AOT.\n-\n-Use 'bash' shell to run scripts.\n-\n-Execute build-bootmodules.sh first before running test* scripts.\n-\n-Download dacapo-9.12-bach.jar and execute build-jdk.vm-modules.sh before running test-graal.sh\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/scripts\/README","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,106 +0,0 @@\n-# Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-\n-pushd `dirname $0` > \/dev\/null\n-DIR=`pwd`\n-popd > \/dev\/null\n-\n-# set env variables\n-. $DIR\/test-env.sh\n-\n-MODULES=\"java.base\"\n-\n-TEST=HelloWorld\n-\n-for m in $MODULES; do\n-    rm -f $JAVA_HOME\/lib\/lib$m*.$SO_TYPE\n-done\n-\n-$JAVA_HOME\/bin\/javac -d . $DIR\/$TEST.java\n-\n-JAOTC_OPTS=\"-J-ea -J-Xmx4g --compile-for-tiered --info\"\n-JAVA_OPTS=\"-Xmx4g -XX:+UnlockExperimentalVMOptions -XX:+UseAOT -XX:+UnlockDiagnosticVMOptions -XX:+UseAOTStrictLoading\"\n-\n-# Compile with: +UseCompressedOops +UseG1GC\n-LIBRARIES=\"\"\n-for m in $MODULES; do\n-    if [ -f $DIR\/$m-list.txt ]; then\n-\tLIST=\"--compile-commands $DIR\/$m-list.txt\"\n-    else\n-\tLIST=\"\"\n-    fi\n-    $JAVA_HOME\/bin\/jaotc -J-XX:+UseCompressedOops -J-XX:+UseG1GC $JAOTC_OPTS $LIST --output lib$m-coop.$SO_TYPE --module $m || exit 1\n-    LIBRARIES=\"$LIBRARIES$PWD\/lib$m-coop.$SO_TYPE:\"\n-done\n-$JAVA_HOME\/bin\/java $JAVA_OPTS -XX:+UseCompressedOops -XX:+UseG1GC -XX:AOTLibrary=$LIBRARIES $TEST || exit 1\n-\n-# Compile with: +UseCompressedOops +UseParallelGC\n-LIBRARIES=\"\"\n-for m in $MODULES; do\n-    if [ -f $DIR\/$m-list.txt ]; then\n-\tLIST=\"--compile-commands $DIR\/$m-list.txt\"\n-    else\n-\tLIST=\"\"\n-    fi\n-    $JAVA_HOME\/bin\/jaotc -J-XX:+UseCompressedOops -J-XX:+UseParallelGC $JAOTC_OPTS $LIST --output lib$m-coop-nong1.$SO_TYPE --module $m || exit 1\n-    LIBRARIES=\"$LIBRARIES$PWD\/lib$m-coop-nong1.$SO_TYPE:\"\n-done\n-$JAVA_HOME\/bin\/java $JAVA_OPTS -XX:+UseCompressedOops -XX:+UseParallelGC -XX:AOTLibrary=$LIBRARIES $TEST || exit 1\n-\n-# Compile with: -UseCompressedOops +UseG1GC\n-LIBRARIES=\"\"\n-for m in $MODULES; do\n-    if [ -f $DIR\/$m-list.txt ]; then\n-\tLIST=\"--compile-commands $DIR\/$m-list.txt\"\n-    else\n-\tLIST=\"\"\n-    fi\n-    $JAVA_HOME\/bin\/jaotc -J-XX:-UseCompressedOops -J-XX:+UseG1GC $JAOTC_OPTS $LIST --output lib$m.$SO_TYPE --module $m || exit 1\n-    LIBRARIES=\"$LIBRARIES$PWD\/lib$m.$SO_TYPE:\"\n-done\n-$JAVA_HOME\/bin\/java $JAVA_OPTS -XX:-UseCompressedOops -XX:+UseG1GC -XX:AOTLibrary=$LIBRARIES $TEST || exit 1\n-\n-# Compile with: -UseCompressedOops +UseParallelGC\n-LIBRARIES=\"\"\n-for m in $MODULES; do\n-    if [ -f $DIR\/$m-list.txt ]; then\n-\tLIST=\"--compile-commands $DIR\/$m-list.txt\"\n-    else\n-\tLIST=\"\"\n-    fi\n-    $JAVA_HOME\/bin\/jaotc -J-XX:-UseCompressedOops -J-XX:+UseParallelGC $JAOTC_OPTS $LIST --output lib$m-nong1.$SO_TYPE --module $m || exit 1\n-    LIBRARIES=\"$LIBRARIES$PWD\/lib$m-nong1.$SO_TYPE:\"\n-done\n-$JAVA_HOME\/bin\/java $JAVA_OPTS -XX:-UseCompressedOops -XX:+UseParallelGC -XX:AOTLibrary=$LIBRARIES $TEST || exit 1\n-\n-echo \"Installing shared libraries in: $JAVA_HOME\/lib\/\"\n-for m in $MODULES; do\n-    mv -f lib$m*.$SO_TYPE $JAVA_HOME\/lib\/\n-done\n-\n-# Test installed libraries.\n-$JAVA_HOME\/bin\/java $JAVA_OPTS -XX:-UseCompressedOops -XX:+UseG1GC       -XX:+PrintAOT $TEST | grep \"aot library\" || exit 1\n-$JAVA_HOME\/bin\/java $JAVA_OPTS -XX:-UseCompressedOops -XX:+UseParallelGC -XX:+PrintAOT $TEST | grep \"aot library\" || exit 1\n-$JAVA_HOME\/bin\/java $JAVA_OPTS -XX:+UseCompressedOops -XX:+UseG1GC       -XX:+PrintAOT $TEST | grep \"aot library\" || exit 1\n-$JAVA_HOME\/bin\/java $JAVA_OPTS -XX:+UseCompressedOops -XX:+UseParallelGC -XX:+PrintAOT $TEST | grep \"aot library\" || exit 1\n-\n-rm -f $TEST.class\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/scripts\/build-bootmodules.sh","additions":0,"deletions":106,"binary":false,"changes":106,"status":"deleted"},{"patch":"@@ -1,110 +0,0 @@\n-# Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-\n-pushd `dirname $0` > \/dev\/null\n-DIR=`pwd`\n-popd > \/dev\/null\n-\n-# set env variables\n-. $DIR\/test-env.sh\n-\n-MODULES=\"jdk.internal.vm.ci jdk.internal.vm.compiler\"\n-\n-TEST=InitGraal\n-\n-for m in $MODULES; do\n-    rm -f $JAVA_HOME\/lib\/lib$m*.$SO_TYPE\n-done\n-\n-$JAVA_HOME\/bin\/javac --add-modules jdk.internal.vm.ci --add-exports jdk.internal.vm.ci\/jdk.vm.ci.hotspot=ALL-UNNAMED $DIR\/$TEST.java\n-\n-# AOT compile non-tiered code version.\n-JAOTC_OPTS=\"-J-Xmx4g --info\"\n-JAVA_OPTS=\"-Xmx4g -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:+UseAOT -XX:+UnlockDiagnosticVMOptions -XX:+UseAOTStrictLoading --add-modules jdk.internal.vm.ci --add-exports jdk.internal.vm.ci\/jdk.vm.ci.hotspot=ALL-UNNAMED\"\n-\n-# Compile with: +UseCompressedOops +UseG1GC\n-RT_OPTS=\"-J-XX:+UseCompressedOops -J-XX:+UseG1GC\"\n-LIBRARIES=\"\"\n-for m in $MODULES; do\n-    if [ -f $DIR\/$m-list.txt ]; then\n-\tLIST=\"--compile-commands $DIR\/$m-list.txt\"\n-    else\n-\tLIST=\"\"\n-    fi\n-    $JAVA_HOME\/bin\/jaotc $RT_OPTS $JAOTC_OPTS $LIST --output lib$m-coop.$SO_TYPE --module $m -J-XX:AOTLibrary=$LIBRARIES || exit 1\n-    LIBRARIES=\"$LIBRARIES$PWD\/lib$m-coop.$SO_TYPE:\"\n-done\n-$JAVA_HOME\/bin\/java $JAVA_OPTS -XX:+UseCompressedOops -XX:+UseG1GC -XX:+PrintAOT -XX:AOTLibrary=$LIBRARIES $TEST | grep \"aot library\" || exit 1\n-\n-# Compile with: +UseCompressedOops +UseParallelGC\n-RT_OPTS=\"-J-XX:+UseCompressedOops -J-XX:+UseParallelGC\"\n-LIBRARIES=\"\"\n-for m in $MODULES; do\n-    if [ -f $DIR\/$m-list.txt ]; then\n-\tLIST=\"--compile-commands $DIR\/$m-list.txt\"\n-    else\n-\tLIST=\"\"\n-    fi\n-    $JAVA_HOME\/bin\/jaotc $RT_OPTS $JAOTC_OPTS $LIST --output lib$m-coop-nong1.$SO_TYPE --module $m -J-XX:AOTLibrary=$LIBRARIES || exit 1\n-    LIBRARIES=\"$LIBRARIES$PWD\/lib$m-coop-nong1.$SO_TYPE:\"\n-done\n-$JAVA_HOME\/bin\/java $JAVA_OPTS -XX:+UseCompressedOops -XX:+UseParallelGC -XX:+PrintAOT -XX:AOTLibrary=$LIBRARIES $TEST | grep \"aot library\" || exit 1\n-\n-# Compile with: -UseCompressedOops +UseG1GC\n-RT_OPTS=\"-J-XX:-UseCompressedOops -J-XX:+UseG1GC\"\n-LIBRARIES=\"\"\n-for m in $MODULES; do\n-    if [ -f $DIR\/$m-list.txt ]; then\n-\tLIST=\"--compile-commands $DIR\/$m-list.txt\"\n-    else\n-\tLIST=\"\"\n-    fi\n-    $JAVA_HOME\/bin\/jaotc $RT_OPTS $JAOTC_OPTS $LIST --output lib$m.$SO_TYPE --module $m -J-XX:AOTLibrary=$LIBRARIES || exit 1\n-    LIBRARIES=\"$LIBRARIES$PWD\/lib$m.$SO_TYPE:\"\n-done\n-$JAVA_HOME\/bin\/java $JAVA_OPTS -XX:-UseCompressedOops -XX:+UseG1GC -XX:+PrintAOT -XX:AOTLibrary=$LIBRARIES $TEST | grep \"aot library\" || exit 1\n-\n-# Compile with: -UseCompressedOops +UseParallelGC\n-RT_OPTS=\"-J-XX:-UseCompressedOops -J-XX:+UseParallelGC\"\n-LIBRARIES=\"\"\n-for m in $MODULES; do\n-    if [ -f $DIR\/$m-list.txt ]; then\n-\tLIST=\"--compile-commands $DIR\/$m-list.txt\"\n-    else\n-\tLIST=\"\"\n-    fi\n-    $JAVA_HOME\/bin\/jaotc $RT_OPTS $JAOTC_OPTS $LIST --output lib$m-nong1.$SO_TYPE --module $m -J-XX:AOTLibrary=$LIBRARIES || exit 1\n-    LIBRARIES=\"$LIBRARIES$PWD\/lib$m-nong1.$SO_TYPE:\"\n-done\n-$JAVA_HOME\/bin\/java $JAVA_OPTS -XX:-UseCompressedOops -XX:+UseParallelGC -XX:+PrintAOT -XX:AOTLibrary=$LIBRARIES $TEST | grep \"aot library\" || exit 1\n-\n-echo \"Installing shared libraries in: $JAVA_HOME\/lib\/\"\n-for m in $MODULES; do\n-    mv -f lib$m*.$SO_TYPE $JAVA_HOME\/lib\/\n-done\n-\n-# Test installed libraries.\n-$JAVA_HOME\/bin\/java $JAVA_OPTS -XX:-UseCompressedOops -XX:+UseG1GC       -XX:+PrintAOT $TEST | grep \"aot library\" || exit 1\n-$JAVA_HOME\/bin\/java $JAVA_OPTS -XX:-UseCompressedOops -XX:+UseParallelGC -XX:+PrintAOT $TEST | grep \"aot library\" || exit 1\n-$JAVA_HOME\/bin\/java $JAVA_OPTS -XX:+UseCompressedOops -XX:+UseG1GC       -XX:+PrintAOT $TEST | grep \"aot library\" || exit 1\n-$JAVA_HOME\/bin\/java $JAVA_OPTS -XX:+UseCompressedOops -XX:+UseParallelGC -XX:+PrintAOT $TEST | grep \"aot library\" || exit 1\n-\n-rm -f $TEST.class\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/scripts\/build-jdk.vm-modules.sh","additions":0,"deletions":110,"binary":false,"changes":110,"status":"deleted"},{"patch":"@@ -1,1 +0,0 @@\n-i = 0;\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/scripts\/empty.js","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -1,20 +0,0 @@\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/scripts\/java.base-list.txt","additions":0,"deletions":20,"binary":false,"changes":20,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-\n-#\n-exclude org.graalvm.compiler.hotspot.replacements.arraycopy.ArrayCopyCallNode.*\n-exclude org.graalvm.compiler.hotspot.replacements.AESCryptSubstitutions.*\n-exclude org.graalvm.compiler.hotspot.replacements.CipherBlockChainingSubstitutions.crypt(Ljava\/lang\/Object;[BII[BILjava\/lang\/Object;ZZ)V\n-exclude org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.arrayAllocationSize(III)I\n-exclude org.graalvm.compiler.hotspot.replacements.PluginFactory_HotSpotReplacementsUtil\\$config.execute(.*).*\n-exclude org.graalvm.compiler.hotspot.replacements.PluginFactory_HotSpotReplacementsUtil\\$getWordKind.execute(.*).*\n-exclude org.graalvm.compiler.hotspot.replacements.PluginFactory_HotSpotReplacementsUtil\\$getConfig.execute(.*).\n-#\n-exclude org.graalvm.compiler.hotspot.stubs.StubUtil.printf(.*).*\n-exclude org.graalvm.compiler.hotspot.stubs.StubUtil.decipher(J)V\n-exclude org.graalvm.compiler.hotspot.stubs.StubUtil.fatal(.*).*\n-#\n-exclude org.graalvm.compiler.nodes.java.NewArrayNode.newUninitializedArray(Ljava\/lang\/Class;I)Ljava\/lang\/Object;\n-exclude org.graalvm.compiler.nodes.java.DynamicNewArrayNode.newArray(Ljava\/lang\/Class;ILjdk\/vm\/ci\/meta\/JavaKind;)Ljava\/lang\/Object;\n-exclude org.graalvm.compiler.nodes.java.DynamicNewArrayNode.newUninitializedArray(Ljava\/lang\/Class;ILjdk\/vm\/ci\/meta\/JavaKind;)Ljava\/lang\/Object;\n-exclude org.graalvm.compiler.nodes.PiNode.piCastNonNull(Ljava\/lang\/Object;Ljava\/lang\/Class;)Ljava\/lang\/Object;\n-#\n-exclude org.graalvm.compiler.replacements.nodes.ArrayEqualsNode.equals(.*).*\n-exclude org.graalvm.compiler.replacements.Log.print.*\n-exclude org.graalvm.compiler.replacements.ReplacementsUtil.*\n-exclude org.graalvm.compiler.replacements.SnippetCounter.*\n-exclude org.graalvm.compiler.replacements.SnippetCounterNode.*\n-exclude org.graalvm.compiler.replacements.SnippetIntegerHistogram.inc(J)V\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/scripts\/jdk.internal.vm.compiler-list.txt","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-# Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-\n-# set platform-dependent variables\n-OS=`uname -s`\n-case \"$OS\" in\n-  Linux )\n-    SO_TYPE=so\n-    ;;\n-  Darwin )\n-    SO_TYPE=dylib\n-    ;;\n-  Windows_* )\n-    SO_TYPE=dll\n-    ;;\n-  CYGWIN_* )\n-    SO_TYPE=dll\n-    ;;\n-  * )\n-    echo \"Unrecognized system!\"\n-    exit 1;\n-    ;;\n-esac\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/scripts\/test-env.sh","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-# Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-\n-JAR=\"dacapo-9.12-bach.jar\"\n-\n-if [ ! -f $JAR ]; then\n-    echo \"$JAR not found.\"\n-    exit 1\n-fi\n-\n-pushd `dirname $0` > \/dev\/null\n-DIR=`pwd`\n-popd > \/dev\/null\n-\n-APP=\"-jar $JAR -s small -n 5\"\n-\n-JAVA_OPTS=\"-XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:+UseJVMCICompiler -XX:-BootstrapJVMCI -XX:-TieredCompilation -Xmx4g -XX:+UseCompressedOops -XX:+UseG1GC\"\n-\n-MODULE_OPTS=\"--add-modules jdk.internal.vm.ci --add-exports jdk.internal.vm.ci\/jdk.vm.ci.hotspot=ALL-UNNAMED\"\n-\n-$JAVA_HOME\/bin\/java $JAVA_OPTS -version || exit 1\n-\n-$JAVA_HOME\/bin\/javac $MODULE_OPTS InitGraal.java || exit 1\n-\n-PATTERN=\"(aot library|DONE:.*HotSpotVMConfig|DONE:.*HotSpotJVMCIRuntime|DONE:.*HotSpotGraalRuntime)\"\n-echo \"----------\"\n-$JAVA_HOME\/bin\/java $JAVA_OPTS $MODULE_OPTS -XX:+TieredCompilation -XX:-UseAOT -XX:+PrintAOT -Djvmci.InitTimer=true InitGraal | grep -E \"$PATTERN\" || exit 1\n-echo \"----------\"\n-$JAVA_HOME\/bin\/java $JAVA_OPTS $MODULE_OPTS -XX:+TieredCompilation             -XX:+PrintAOT -Djvmci.InitTimer=true InitGraal | grep -E \"$PATTERN\" || exit 1\n-echo \"----------\"\n-$JAVA_HOME\/bin\/java $JAVA_OPTS $MODULE_OPTS                                    -XX:+PrintAOT -Djvmci.InitTimer=true InitGraal | grep -E \"$PATTERN\" || exit 1\n-echo \"----------\"\n-\n-rm -f InitGraal.class\n-\n-# eclipse started to fail again with JDK 9.\n-#BENCHMARKS=\"avrora batik eclipse fop jython h2 luindex lusearch pmd sunflow tradebeans tradesoap xalan\"\n-BENCHMARKS=\"avrora batik fop jython h2 luindex lusearch pmd sunflow xalan\"\n-\n-for i in $BENCHMARKS; do\n-    $JAVA_HOME\/bin\/java $JAVA_OPTS $APP $i || exit 1\n-    rm -rf .\/scratch\n-done\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/scripts\/test-graal.sh","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -1,97 +0,0 @@\n-# Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-\n-pushd `dirname $0` > \/dev\/null\n-DIR=`pwd`\n-popd > \/dev\/null\n-\n-# set env variables\n-. $DIR\/test-env.sh\n-\n-rm -f libHelloWorld*.$SO_TYPE HelloWorld.class\n-\n-$JAVA_HOME\/bin\/javac -d . $DIR\/HelloWorld.java\n-\n-# Run once with non-compressed oops.\n-OPTS=\"-J-Xmx4g -J-XX:-UseCompressedOops --info --verbose\"\n-$JAVA_HOME\/bin\/jaotc $OPTS --output libHelloWorld.$SO_TYPE HelloWorld.class || exit 1\n-\n-JAVA_OPTS=\"-Xmx4g -XX:-UseCompressedOops -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseAOTStrictLoading -XX:AOTLibrary=.\/libHelloWorld.$SO_TYPE\"\n-\n-$JAVA_HOME\/bin\/java $JAVA_OPTS -XX:+PrintAOT -version | grep \"aot library\" || exit 1\n-$JAVA_HOME\/bin\/java $JAVA_OPTS HelloWorld || exit 1\n-\n-TIMEFORMAT=\"%3R\"\n-N=5\n-\n-LIBRARY=libHelloWorld-coop.$SO_TYPE\n-\n-for gc in UseG1GC UseParallelGC; do\n-    # Now with compressed oops.\n-    OPTS=\"-J-XX:+UseCompressedOops -J-XX:+$gc --info --verbose\"\n-    $JAVA_HOME\/bin\/jaotc $OPTS --output $LIBRARY HelloWorld.class\n-\n-    # Dump CDS archive.\n-    $JAVA_HOME\/bin\/java -Xshare:dump -XX:+UnlockExperimentalVMOptions -XX:-UseAOT -XX:+$gc || exit 1\n-\n-    JAVA_OPTS=\"-Xmx256m\"\n-\n-    echo \"Tiered C1 $gc:\"\n-    for i in `seq 1 $N`; do\n-        OUT=`time $JAVA_HOME\/bin\/java -XX:+$gc -XX:-UseCompressedOops -XX:+UnlockExperimentalVMOptions -XX:-UseAOT -XX:TieredStopAtLevel=1 $JAVA_OPTS HelloWorld`\n-        if [ \"$OUT\" != \"Hello, world!\" ]; then\n-            echo $OUT\n-            exit 1\n-        fi\n-    done\n-\n-    echo \"Tiered C1\/C2 $gc:\"\n-    for i in `seq 1 $N`; do\n-        OUT=`time $JAVA_HOME\/bin\/java -XX:+$gc -XX:-UseCompressedOops -XX:+UnlockExperimentalVMOptions -XX:-UseAOT $JAVA_OPTS HelloWorld`\n-        if [ \"$OUT\" != \"Hello, world!\" ]; then\n-            echo $OUT\n-            exit 1\n-        fi\n-    done\n-\n-    JAVA_OPTS=\"-Xmx256m -XX:+UseCompressedOops -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseAOTStrictLoading -XX:AOTLibrary=.\/$LIBRARY\"\n-\n-\n-    echo \"AOT $gc:\"\n-    for i in `seq 1 $N`; do\n-        OUT=`time $JAVA_HOME\/bin\/java -XX:+$gc $JAVA_OPTS HelloWorld`\n-        if [ \"$OUT\" != \"Hello, world!\" ]; then\n-            echo $OUT\n-            exit 1\n-        fi\n-    done\n-\n-    echo \"AOT -Xshare:on $gc:\"\n-    for i in `seq 1 $N`; do\n-        OUT=`time $JAVA_HOME\/bin\/java -Xshare:on -XX:+$gc $JAVA_OPTS HelloWorld`\n-        if [ \"$OUT\" != \"Hello, world!\" ]; then\n-            echo $OUT\n-            exit 1\n-        fi\n-    done\n-done\n-\n-rm -f libHelloWorld*.$SO_TYPE HelloWorld.class\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/scripts\/test-helloworld.sh","additions":0,"deletions":97,"binary":false,"changes":97,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-# Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-\n-pushd `dirname $0` > \/dev\/null\n-DIR=`pwd`\n-popd > \/dev\/null\n-\n-# set env variables\n-. $DIR\/test-env.sh\n-\n-JAOTC_OPTS=\"-J-Xmx4g -J-XX:-UseCompressedOops\"\n-\n-rm -f libjdk.aot.$SO_TYPE\n-\n-$JAVA_HOME\/bin\/jaotc $JAOTC_OPTS --info --module jdk.aot --output libjdk.aot.$SO_TYPE || exit 1\n-\n-rm -f libjava.base-aot.$SO_TYPE\n-\n-$JAVA_HOME\/bin\/jaotc $JAOTC_OPTS -J-XX:AOTLibrary=.\/libjdk.aot.$SO_TYPE --info --compile-commands $DIR\/java.base-list.txt --output libjava.base-aot.$SO_TYPE --module java.base || exit 1\n-\n-$JAVA_HOME\/bin\/javac -d . $DIR\/HelloWorld.java\n-\n-$JAVA_HOME\/bin\/java -XX:-UseCompressedOops -XX:+UnlockExperimentalVMOptions -XX:AOTLibrary=.\/libjava.base-aot.$SO_TYPE HelloWorld\n-\n-rm -f HelloWorld.class libjdk.aot.$SO_TYPE libjava.base-aot.$SO_TYPE\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/scripts\/test-jaotc.sh","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,157 +0,0 @@\n-# Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-\n-pushd `dirname $0` > \/dev\/null\n-DIR=`pwd`\n-popd > \/dev\/null\n-\n-AOT_OPTS=\"-XX:+UnlockExperimentalVMOptions -XX:+UseAOT\"\n-\n-$JAVA_HOME\/bin\/java $AOT_OPTS -XX:+PrintAOT -version | grep \"aot library\" || exit 1\n-\n-# Dump CDS archive.\n-$JAVA_HOME\/bin\/java $AOT_OPTS -Xshare:dump || exit 1\n-\n-FILE=\"HelloWorld\"\n-\n-APP=\"com.sun.tools.javac.Main\"\n-\n-JAVA_OPTS=\"-XX:-UseCompressedOops\"\n-\n-rm -f $FILE.class\n-\n-$JAVA_HOME\/bin\/java $JAVA_OPTS $AOT_OPTS $APP -verbose $FILE.java || exit 1\n-$JAVA_HOME\/bin\/java $AOT_OPTS $FILE || exit 1\n-\n-JAVA_OPTS=\"-XX:+UseCompressedOops\"\n-\n-rm -f $FILE.class\n-\n-$JAVA_HOME\/bin\/java $JAVA_OPTS $AOT_OPTS $APP -verbose $FILE.java || exit 1\n-$JAVA_HOME\/bin\/java $AOT_OPTS $FILE || exit 1\n-\n-rm -f $FILE.class\n-\n-TIMEFORMAT=\"%3R\"\n-N=5\n-\n-#echo \"-Xint:\"\n-#for i in `seq 1 10`; do\n-#    time $JAVA_HOME\/bin\/java -Xint $JAVA_OPTS $APP $FILE.java\n-#    if [ $? -ne 0 ]; then\n-#        exit 1\n-#    fi\n-#    rm -f $FILE.class\n-#done\n-\n-echo \"Tiered C1:\"\n-for i in `seq 1 $N`; do\n-    time $JAVA_HOME\/bin\/java $JAVA_OPTS -XX:+UnlockExperimentalVMOptions -XX:-UseAOT -XX:TieredStopAtLevel=1 $APP $FILE.java\n-    if [ $? -ne 0 ]; then\n-        exit 1\n-    fi\n-    rm -f $FILE.class\n-done\n-\n-echo \"Tiered C1\/C2:\"\n-for i in `seq 1 $N`; do\n-    time $JAVA_HOME\/bin\/java $JAVA_OPTS -XX:+UnlockExperimentalVMOptions -XX:-UseAOT $APP $FILE.java\n-    if [ $? -ne 0 ]; then\n-        exit 1\n-    fi\n-    rm -f $FILE.class\n-done\n-\n-echo \"Tiered C1\/C2 -Xshare:on:\"\n-for i in `seq 1 $N`; do\n-    time $JAVA_HOME\/bin\/java $JAVA_OPTS -XX:+UnlockExperimentalVMOptions -XX:-UseAOT -Xshare:on $APP $FILE.java\n-    if [ $? -ne 0 ]; then\n-        exit 1\n-    fi\n-    rm -f $FILE.class\n-done\n-\n-echo \"Tiered AOT:\"\n-for i in `seq 1 $N`; do\n-    time $JAVA_HOME\/bin\/java $JAVA_OPTS $AOT_OPTS $APP $FILE.java\n-    if [ $? -ne 0 ]; then\n-        exit 1\n-    fi\n-    rm -f $FILE.class\n-done\n-\n-echo \"Tiered AOT -Xshare:on:\"\n-for i in `seq 1 $N`; do\n-    time $JAVA_HOME\/bin\/java $JAVA_OPTS $AOT_OPTS -Xshare:on $APP $FILE.java\n-    if [ $? -ne 0 ]; then\n-        exit 1\n-    fi\n-    rm -f $FILE.class\n-done\n-\n-NAME=\"jvmci\"\n-DIR=\"$DIR\/..\/..\/..\/..\/..\/..\/src\/jdk.internal.vm.ci\"\n-FILES=`find $DIR -type f -name '*.java'`\n-COUNT=`find $DIR -type f -name '*.java' | wc -l`\n-\n-rm -rf tmp\n-\n-echo \"Tiered C1 (compiling $NAME: $COUNT classes):\"\n-for i in `seq 1 $N`; do\n-    mkdir tmp\n-    time $JAVA_HOME\/bin\/javac -J-XX:+UnlockExperimentalVMOptions -J-XX:-UseAOT -J-XX:TieredStopAtLevel=1 -XDignore.symbol.file -d tmp $FILES\n-    if [ $? -ne 0 ]; then\n-        exit 1\n-    fi\n-    rm -rf tmp\n-done\n-\n-echo \"Tiered C1\/C2 (compiling $NAME: $COUNT classes):\"\n-for i in `seq 1 $N`; do\n-    mkdir tmp\n-    time $JAVA_HOME\/bin\/javac -J-XX:+UnlockExperimentalVMOptions -J-XX:-UseAOT -XDignore.symbol.file -cp \/java\/devtools\/share\/junit\/latest\/junit.jar -d tmp $FILES\n-    if [ $? -ne 0 ]; then\n-        exit 1\n-    fi\n-    rm -rf tmp\n-done\n-\n-echo \"Tiered AOT (compiling $NAME: $COUNT classes):\"\n-for i in `seq 1 $N`; do\n-    mkdir tmp\n-    time $JAVA_HOME\/bin\/javac -J-XX:+UnlockExperimentalVMOptions -J-XX:+UseAOT -XDignore.symbol.file -cp \/java\/devtools\/share\/junit\/latest\/junit.jar -d tmp $FILES\n-    if [ $? -ne 0 ]; then\n-        exit 1\n-    fi\n-    rm -rf tmp\n-done\n-\n-echo \"Tiered AOT -Xshare:on (compiling $NAME: $COUNT classes):\"\n-for i in `seq 1 $N`; do\n-    mkdir tmp\n-    time $JAVA_HOME\/bin\/javac -J-Xshare:on -J-XX:+UnlockExperimentalVMOptions -J-XX:+UseAOT -XDignore.symbol.file -cp \/java\/devtools\/share\/junit\/latest\/junit.jar -d tmp $FILES\n-    if [ $? -ne 0 ]; then\n-        exit 1\n-    fi\n-    rm -rf tmp\n-done\n-\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/scripts\/test-javac.sh","additions":0,"deletions":157,"binary":false,"changes":157,"status":"deleted"},{"patch":"@@ -1,124 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.aot.verification.ClassAndLibraryNotMatchTest\n- * @run driver compiler.aot.verification.ClassAndLibraryNotMatchTest\n- * @summary check if class and aot library are properly bound to each other\n- *\/\n-\n-package compiler.aot.verification;\n-\n-import compiler.aot.AotCompiler;\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n-import java.nio.file.StandardOpenOption;\n-import java.util.Arrays;\n-import jdk.test.lib.JDKToolFinder;\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class ClassAndLibraryNotMatchTest {\n-    private static final String HELLO_WORLD_CLASS_NAME = \"HelloWorld\";\n-    private static final String LIB_NAME = \"lib\" + HELLO_WORLD_CLASS_NAME + \".so\";\n-    private static final String HELLO_WORLD_MSG1 = \"HelloWorld1\";\n-    private static final String HELLO_WORLD_MSG2 = \"HelloWorld2\";\n-    private static final String HELLO_WORLD_FILE = \".\/\" + HELLO_WORLD_CLASS_NAME + \".java\";\n-    private static final String HELLO_WORLD_PRE = \"public class \"\n-            + HELLO_WORLD_CLASS_NAME + \" {\\n\"\n-            + \"    public static void main(String args[]) {\\n\"\n-            + \"        System.out.println(\\\"\";\n-    private static final String HELLO_WORLD_POST = \"\\\");\\n\"\n-            + \"    }\\n\"\n-            + \"}\\n\";\n-\n-    public static void main(String args[]) {\n-        new ClassAndLibraryNotMatchTest().runTest();\n-    }\n-\n-    private void writeHelloWorld(String message) {\n-        String src = HELLO_WORLD_PRE + message + HELLO_WORLD_POST;\n-        try{\n-            Files.write(Paths.get(HELLO_WORLD_FILE), src.getBytes(), StandardOpenOption.CREATE);\n-        } catch (IOException e) {\n-            throw new Error(\"Can't write HelloWorld \" + e, e);\n-        }\n-    }\n-\n-    private void compileHelloWorld() {\n-        String javac = JDKToolFinder.getCompileJDKTool(\"javac\");\n-        ProcessBuilder pb = new ProcessBuilder(javac, HELLO_WORLD_FILE);\n-        OutputAnalyzer oa;\n-        try {\n-            oa = ProcessTools.executeProcess(pb);\n-        } catch (Exception e) {\n-            throw new Error(\"Can't compile class \" + e, e);\n-        }\n-        oa.shouldHaveExitValue(0);\n-    }\n-\n-    private void compileAotLibrary() {\n-        AotCompiler.launchCompiler(LIB_NAME, HELLO_WORLD_CLASS_NAME,\n-                Arrays.asList(\"-classpath\", Utils.TEST_CLASS_PATH + File.pathSeparator + \".\"), null);\n-    }\n-\n-    private void runAndCheckHelloWorld(String checkString) {\n-        ProcessBuilder pb;\n-        try {\n-            pb = ProcessTools.createTestJvm(\"-cp\", \".\",\n-                    \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseAOT\",\n-                    \"-XX:AOTLibrary=.\/\" + LIB_NAME, HELLO_WORLD_CLASS_NAME);\n-        } catch (Exception e) {\n-            throw new Error(\"Can't create ProcessBuilder to run \"\n-                    + HELLO_WORLD_CLASS_NAME + \" \" + e, e);\n-        }\n-        OutputAnalyzer oa;\n-        try {\n-            oa = ProcessTools.executeProcess(pb);\n-        } catch (Exception e) {\n-            throw new Error(\"Can't execute \" + HELLO_WORLD_CLASS_NAME + \" \" + e, e);\n-        }\n-        oa.shouldHaveExitValue(0);\n-        oa.shouldContain(checkString);\n-    }\n-\n-    private void createHelloWorld(String msg) {\n-        writeHelloWorld(msg);\n-        compileHelloWorld();\n-    }\n-\n-    private void runTest() {\n-        createHelloWorld(HELLO_WORLD_MSG1);\n-        compileAotLibrary();\n-        runAndCheckHelloWorld(HELLO_WORLD_MSG1);\n-        createHelloWorld(HELLO_WORLD_MSG2);\n-        runAndCheckHelloWorld(HELLO_WORLD_MSG2);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/verification\/ClassAndLibraryNotMatchTest.java","additions":0,"deletions":124,"binary":false,"changes":124,"status":"deleted"},{"patch":"@@ -1,112 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.aot.verification.vmflags;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.Utils;\n-import compiler.aot.HelloWorldPrinter;\n-import compiler.aot.AotCompiler;\n-import java.io.File;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-\/**\n- * A class with common launch and check logic for testing vm flags change\n- *\/\n-public class BasicFlagsChange {\n-    private static final boolean CAN_LOAD = true;\n-    \/**\n-     * A main method which parse arguments, expecting vm option name to\n-     *     be present, launch java process with combinations of provided flag\n-     *     enabled\/disable in aot library and vm flag expecting different flag\n-     *     values in library and vm to be negative cases\n-     * @param args should have true\/false treated as \"loadAlways\" for\n-     *     tracked\/non-tracked options and vm option name\n-     *\/\n-    public static void main(String args[]) {\n-        if (args.length != 2) {\n-            throw new Error(\"TESTBUG: Unexpected number of arguments: \"\n-                    + args.length);\n-        }\n-        if (!\"false\".equals(args[0]) && !\"true\".equals(args[0])) {\n-            throw new Error(\"TESTBUG: unexpected value of 1st parameter: \"\n-                    + args[0]);\n-        }\n-        boolean loadAlways = Boolean.parseBoolean(args[0]);\n-        String optName = args[1];\n-        String optEnabled = \"-XX:+\" + optName;\n-        String optDisabled = \"-XX:-\" + optName;\n-        String enabledLibName = \"libEnabled.so\";\n-        String disabledLibName = \"libDisabled.so\";\n-        \/\/ compile libraries\n-        compileLibrary(optEnabled, enabledLibName);\n-        compileLibrary(optDisabled, disabledLibName);\n-        \/\/ run 4 combinations\n-        runAndCheck(optEnabled, enabledLibName, CAN_LOAD || loadAlways);\n-        runAndCheck(optDisabled, enabledLibName, !CAN_LOAD || loadAlways);\n-        runAndCheck(optEnabled, disabledLibName, !CAN_LOAD || loadAlways);\n-        runAndCheck(optDisabled, disabledLibName, CAN_LOAD || loadAlways);\n-    }\n-\n-    private static void compileLibrary(String option, String libName) {\n-        String className = BasicFlagsChange.class.getName();\n-        List<String> extraOpts = new ArrayList<>();\n-        extraOpts.add(option);\n-        extraOpts.add(\"-classpath\");\n-        extraOpts.add(Utils.TEST_CLASS_PATH + File.pathSeparator + Utils.TEST_SRC);\n-        AotCompiler.launchCompiler(libName, className, extraOpts, null);\n-    }\n-\n-    private static void runAndCheck(String option, String libName,\n-            boolean positiveCase) {\n-        ProcessBuilder pb;\n-        try {\n-            \/* using +PrintAOT to check if library has been loaded or skipped,\n-               so, a message like \"skipped $pathTolibrary aot library\" or\n-               \"loaded    $pathToLibrary  aot library\" is present for cases of\n-               incompatible or compatible flags respectively *\/\n-            pb = ProcessTools.createTestJvm(\"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseAOT\", \"-XX:+PrintAOT\", \"-XX:AOTLibrary=.\/\" + libName, option,\n-                    HelloWorldPrinter.class.getName());\n-        } catch (Exception ex) {\n-            throw new Error(\"Problems creating ProcessBuilder using \" + option\n-                    + \" Caused by: \" + ex, ex);\n-        }\n-        OutputAnalyzer oa;\n-        try {\n-            oa = ProcessTools.executeProcess(pb);\n-        } catch (Exception ex) {\n-            throw new Error(\"Problems execution child process using case \"\n-                    + option + \" Caused by: \" + ex, ex);\n-        }\n-        oa.shouldHaveExitValue(0);\n-        oa.shouldContain(HelloWorldPrinter.MESSAGE);\n-        if (positiveCase) {\n-            oa.shouldContain(\"loaded    .\/\" + libName + \"  aot library\");\n-        } else {\n-            oa.shouldContain(\"skipped .\/\" + libName + \"  aot library\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/verification\/vmflags\/BasicFlagsChange.java","additions":0,"deletions":112,"binary":false,"changes":112,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.aot.verification.vmflags.BasicFlagsChange\n- * @run driver compiler.aot.verification.vmflags.BasicFlagsChange\n- *     true PrintCommandLineFlags\n- * @summary check if some not aot-related vm flag change doesn't affect aot library loading\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/verification\/vmflags\/NotTrackedFlagTest.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.aot\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- * @build compiler.aot.verification.vmflags.BasicFlagsChange\n- * @run driver compiler.aot.verification.vmflags.BasicFlagsChange\n- *      false UseCompressedOops\n- * @summary check if tracked flag UseCompressedOops is controlled properly\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/verification\/vmflags\/TrackedFlagTest.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n- * @comment the test disables intrinsics, so it can't be run w\/ AOT'ed java.base\n- * @requires !vm.aot.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bigInteger\/TestMulAdd.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n- * @comment the test verifies compilation of java.base methods, so it can't be run w\/ AOT'ed java.base\n- * @requires !vm.aot.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/sanity\/TestMD5Intrinsics.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n- * @comment the test verifies compilation of java.base methods, so it can't be run w\/ AOT'ed java.base\n- * @requires !vm.aot.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/sanity\/TestMD5MultiBlockIntrinsics.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n- * @comment the test verifies compilation of java.base methods, so it can't be run w\/ AOT'ed java.base\n- * @requires !vm.aot.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/sanity\/TestSHA1Intrinsics.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n- * @comment the test verifies compilation of java.base methods, so it can't be run w\/ AOT'ed java.base\n- * @requires !vm.aot.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/sanity\/TestSHA1MultiBlockIntrinsics.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n- * @comment the test verifies compilation of java.base methods, so it can't be run w\/ AOT'ed java.base\n- * @requires !vm.aot.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/sanity\/TestSHA256Intrinsics.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n- * @comment the test verifies compilation of java.base methods, so it can't be run w\/ AOT'ed java.base\n- * @requires !vm.aot.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/sanity\/TestSHA256MultiBlockIntrinsics.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +29,0 @@\n- * @comment the test verifies compilation of java.base methods, so it can't be run w\/ AOT'ed java.base\n- * @requires !vm.aot.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/sanity\/TestSHA3Intrinsics.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +29,0 @@\n- * @comment the test verifies compilation of java.base methods, so it can't be run w\/ AOT'ed java.base\n- * @requires !vm.aot.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/sanity\/TestSHA3MultiBlockIntrinsics.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n- * @comment the test verifies compilation of java.base methods, so it can't be run w\/ AOT'ed java.base\n- * @requires !vm.aot.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/sanity\/TestSHA512Intrinsics.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n- * @comment the test verifies compilation of java.base methods, so it can't be run w\/ AOT'ed java.base\n- * @requires !vm.aot.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/sanity\/TestSHA512MultiBlockIntrinsics.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,3 +45,1 @@\n-    public static final int COMP_LEVEL_ANY = -2;\n-    \/** {@code CompLevel::CompLevel_aot} -- AOT *\/\n-    public static final int COMP_LEVEL_AOT = -1;\n+    public static final int COMP_LEVEL_ANY = -1;\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/CompilerWhiteBoxTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,1 +96,0 @@\n-            \"-XX:-UseAOT\", \/\/ AOT explicitly set klass shift to 3.\n@@ -122,1 +121,0 @@\n-            \"-XX:-UseAOT\", \/\/ AOT explicitly set klass shift to 3.\n@@ -242,1 +240,0 @@\n-            \"-XX:-UseAOT\", \/\/ AOT explicitly set klass shift to 3.\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedClassPointers.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,0 @@\n- * @comment the test disables intrinsics, so it can't be run w\/ AOT'ed java module\n- * @requires !vm.aot.enabled\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/TestInterpreterMethodEntries.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-                Assert.assertTrue(compileLevel >= -1, \"CompileLevel must be at least -1 (AOT)\");\n+                Assert.assertTrue(compileLevel >= -1, \"CompileLevel must be at least -1 (Any)\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/CodelistTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-install: clean_testbase testgroup testroot copytestlibrary copyaot $(DIST_JAR) cleantmp\n+install: clean_testbase testgroup testroot copytestlibrary $(DIST_JAR) cleantmp\n@@ -125,3 +125,0 @@\n-copyaot: $(TESTBASE_DIR)\/compiler\/aot\n-\t@cp ..\/..\/compiler\/aot\/AotCompiler.java $(TESTBASE_DIR)\/compiler\/aot\n-\n@@ -136,4 +133,0 @@\n-\t@echo 'aot_tests = \\' >> $(TESTGROUP_FILE)\n-\t@echo ' aot_bytecode_tests \\' >> $(TESTGROUP_FILE)\n-\t@echo ' aot_java_tests' >> $(TESTGROUP_FILE)\n-\t@echo '' >> $(TESTGROUP_FILE)\n@@ -144,1 +137,1 @@\n-$(TESTBASE_DIR) $(DIST_DIR) $(TESTBASE_DIR)\/jdk\/test\/lib\/jittester\/jtreg $(TESTBASE_DIR)\/compiler\/aot:\n+$(TESTBASE_DIR) $(DIST_DIR) $(TESTBASE_DIR)\/jdk\/test\/lib\/jittester\/jtreg:\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/Makefile","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -12,1 +12,1 @@\n-generatorsFactories=jdk.test.lib.jittester.TestGeneratorsFactory,jdk.test.lib.jittester.AotTestGeneratorsFactory\n+generatorsFactories=jdk.test.lib.jittester.TestGeneratorsFactory\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/conf\/default.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.jittester;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.function.Function;\n-\n-public class AotTestGeneratorsFactory implements Function<String[], List<TestsGenerator>> {\n-    private static final String AOT_OPTIONS\n-            = \"-XX:+UnlockExperimentalVMOptions -XX:+UseAOT -XX:AOTLibrary=.\/aottest.so\";\n-    private static final String AOT_COMPILER_BUILD_ACTION\n-            = \"@build compiler.aot.AotCompiler\";\n-    private static final String AOT_COMPILER_RUN_ACTION_PREFIX\n-            = \"@run driver compiler.aot.AotCompiler -extraopt -Xmixed -libname aottest.so -class \";\n-\n-    @Override\n-    public List<TestsGenerator> apply(String[] input) {\n-        List<TestsGenerator> result = new ArrayList<>();\n-        for (String generatorName : input) {\n-            switch (generatorName) {\n-                case \"ByteCode\":\n-                    result.add(new ByteCodeGenerator(\"aot_bytecode_tests\",\n-                            AotTestGeneratorsFactory::generateBytecodeHeader, AOT_OPTIONS));\n-                    break;\n-                case \"JavaCode\":\n-                    result.add(new JavaCodeGenerator(\"aot_java_tests\",\n-                            AotTestGeneratorsFactory::generateJavaHeader, AOT_OPTIONS));\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException(\"Unknown generator: \" + generatorName);\n-            }\n-        }\n-        return result;\n-    }\n-\n-    private static String[] generateBytecodeHeader(String mainClassName) {\n-        return new String[]{\n-            AOT_COMPILER_BUILD_ACTION,\n-            AOT_COMPILER_RUN_ACTION_PREFIX + mainClassName\n-        };\n-    }\n-\n-    private static String[] generateJavaHeader(String mainClassName) {\n-        return new String[]{\n-            \"@compile \" + mainClassName + \".java\",\n-            AOT_COMPILER_BUILD_ACTION,\n-            AOT_COMPILER_RUN_ACTION_PREFIX + mainClassName\n-        };\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/AotTestGeneratorsFactory.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -65,9 +65,0 @@\n-        \/\/ check if AOT is enabled\n-        if (WhiteBox.getWhiteBox().aotLibrariesCount() > 0) {\n-            System.out.println(\"AOT is enabled\");\n-            String aotSegment = \"CodeHeap 'AOT':\" + p1 + p2;\n-            segPrefix += aotSegment;\n-            nosegPrefix += aotSegment;\n-        } else {\n-            System.out.println(\"AOT is not enabled\");\n-        }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/compiler\/CodeCacheInfo\/Test.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,34 +0,0 @@\n-#\n-# Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#############################################################################\n-#\n-# List of quarantined tests for testing AOT.\n-#\n-#############################################################################\n-\n-java\/lang\/invoke\/VarHandles\/VarHandleTestByteArrayAsShort.java  8222445 windows-x64\n-java\/lang\/invoke\/VarHandles\/VarHandleTestByteArrayAsChar.java   8222445 windows-x64\n-java\/lang\/invoke\/VarHandles\/VarHandleTestAccessBoolean.java     8222445 windows-x64\n-java\/lang\/reflect\/PublicMethods\/PublicMethodsTest.java          8226309 generic-all\n-java\/lang\/constant\/MethodTypeDescTest.java                      8225349 windows-x64\n","filename":"test\/jdk\/ProblemList-aot.txt","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -291,2 +291,2 @@\n-                \/\/ exported to jdk.internal.vm.compiler and jdk.aot\n-                \"jdk.internal.vm.compiler\", \"jdk.aot\"\n+                \/\/ exported to jdk.internal.vm.compiler\n+                \"jdk.internal.vm.compiler\"\n","filename":"test\/jdk\/java\/lang\/Class\/getDeclaredField\/FieldSetAccessibleTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-                \"jdk.aot\",\n","filename":"test\/jdk\/jdk\/modules\/etc\/UpgradeableModules.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -201,2 +201,2 @@\n-            \/\/ exported to jdk.internal.vm.compiler and jdk.aot\n-            \"jdk.internal.vm.compiler\", \"jdk.aot\"\n+            \/\/ exported to jdk.internal.vm.compiler\n+            \"jdk.internal.vm.compiler\"\n","filename":"test\/jdk\/tools\/jimage\/VerifyJimage.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,1 +123,0 @@\n-        new ToolHelpSpec(\"jaotc\",       1,   1,   1,   0,         0,    0,     2),     \/\/ -?, -h, --help\n","filename":"test\/jdk\/tools\/launcher\/HelpFlagsTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,0 @@\n-        \"jaotc\",\n@@ -76,1 +75,0 @@\n-        \"jaotc\",\n","filename":"test\/jdk\/tools\/launcher\/VersionCheck.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -110,2 +110,0 @@\n-        map.put(\"vm.aot\", this::vmAOT);\n-        map.put(\"vm.aot.enabled\", this::vmAotEnabled);\n@@ -362,40 +360,0 @@\n-    \/**\n-     * @return true if VM supports AOT and false otherwise\n-     *\/\n-    protected String vmAOT() {\n-        \/\/ builds with aot have jaotc in <JDK>\/bin\n-        Path bin = Paths.get(System.getProperty(\"java.home\"))\n-                        .resolve(\"bin\");\n-        Path jaotc;\n-        if (Platform.isWindows()) {\n-            jaotc = bin.resolve(\"jaotc.exe\");\n-        } else {\n-            jaotc = bin.resolve(\"jaotc\");\n-        }\n-\n-        if (!Files.exists(jaotc)) {\n-            \/\/ No jaotc => no AOT\n-            return \"false\";\n-        }\n-\n-        switch (GC.selected()) {\n-            case Serial:\n-            case Parallel:\n-            case G1:\n-                \/\/ These GCs are supported with AOT\n-                return \"true\";\n-            default:\n-                break;\n-        }\n-\n-        \/\/ Every other GC is not supported\n-        return \"false\";\n-    }\n-\n-    \/*\n-     * @return true if there is at least one loaded AOT'ed library.\n-     *\/\n-    protected String vmAotEnabled() {\n-        return \"\" + (WB.aotLibrariesCount() > 0);\n-    }\n-\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -253,1 +253,1 @@\n-    return isMethodCompilable(method, -2 \/*any*\/);\n+    return isMethodCompilable(method, -1 \/*any*\/);\n@@ -301,1 +301,1 @@\n-    makeMethodNotCompilable(method, -2 \/*any*\/);\n+    makeMethodNotCompilable(method, -1 \/*any*\/);\n@@ -325,1 +325,1 @@\n-    return getCompileQueueSize(-2 \/*any*\/);\n+    return getCompileQueueSize(-1 \/*any*\/);\n@@ -628,3 +628,0 @@\n-  \/\/ Number of loaded AOT libraries\n-  public native int aotLibrariesCount();\n-\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,6 +53,2 @@\n-    if (blob_type_index == -1) { \/\/ AOT\n-      code_blob_type = null;\n-    } else {\n-      code_blob_type = BlobType.values()[blob_type_index];\n-      assert code_blob_type.id == (Integer) obj[2];\n-    }\n+    code_blob_type = BlobType.values()[blob_type_index];\n+    assert code_blob_type.id == (Integer) obj[2];\n","filename":"test\/lib\/sun\/hotspot\/code\/CodeBlob.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"}]}