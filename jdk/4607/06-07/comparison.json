{"files":[{"patch":"@@ -44,1 +44,1 @@\n- * @bug 8190753\n+ * @bug 8190753 8011146\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/LargeCompressedEntrySizeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,137 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n-\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.IOException;\n-import java.io.OutputStream;\n-import java.io.RandomAccessFile;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.StandardOpenOption;\n-import java.util.List;\n-import java.util.zip.ZipEntry;\n-import java.util.zip.ZipOutputStream;\n-\n-\/**\n- * @test\n- * @bug 8190753\n- * @summary Verify that using zip filesystem for opening an outputstream for a large zip entry doesn't\n- * run into \"Negative initial size\" exception\n- * @run testng LargeEntrySizeTest\n- *\/\n-public class LargeEntrySizeTest {\n-\n-    \/\/ a value which when cast to an integer, becomes a negative value\n-    private static final long LARGE_FILE_SIZE = Integer.MAX_VALUE + 1L;\n-    private static final long SMALL_FILE_SIZE = 0x100000L; \/\/ 1024L x 1024L;\n-    private static final String LARGE_FILE_NAME = \"LargeZipEntry.txt\";\n-    \/\/ File that will be created with a size less than 0xFFFFFFFF\n-    private static final String SMALL_FILE_NAME = \"SmallZipEntry.txt\";\n-    \/\/ List of files to be added to the ZIP file\n-    private static final List<String> ZIP_ENTRIES = List.of(LARGE_FILE_NAME, SMALL_FILE_NAME);\n-    private static final String ZIP_FILE_NAME = \"8190753-test.zip\";\n-\n-    @BeforeMethod\n-    public void setUp() throws IOException {\n-        deleteFiles();\n-    }\n-\n-    @AfterMethod\n-    public void tearDown() throws IOException {\n-        deleteFiles();\n-    }\n-\n-    \/**\n-     * Delete the files created for use by the test\n-     *\n-     * @throws IOException if an error occurs deleting the files\n-     *\/\n-    private static void deleteFiles() throws IOException {\n-        Files.deleteIfExists(Path.of(ZIP_FILE_NAME));\n-        Files.deleteIfExists(Path.of(LARGE_FILE_NAME));\n-        Files.deleteIfExists(Path.of(SMALL_FILE_NAME));\n-    }\n-\n-\n-    \/**\n-     * Verifies that large entry (whose size is greater than {@link Integer#MAX_VALUE}) in a zip file\n-     * can be opened as an {@link OutputStream} using the zip filesystem\n-     *\/\n-    @Test\n-    public void testLargeEntryZipFSOutputStream() throws Exception {\n-        final Path zipFile = Path.of(ZIP_FILE_NAME);\n-        createZipFile(zipFile);\n-        try (FileSystem fs = FileSystems.newFileSystem(zipFile)) {\n-            for (String entryName : ZIP_ENTRIES) {\n-                try (OutputStream os = Files.newOutputStream(fs.getPath(entryName), StandardOpenOption.WRITE)) {\n-                    \/\/ just a dummy write\n-                    os.write(0x01);\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Creates a zip file with an entry whose size is larger than {@link Integer#MAX_VALUE}\n-     *\/\n-    private static void createZipFile(final Path zipFile) throws IOException {\n-        createFiles();\n-        try (OutputStream os = Files.newOutputStream(zipFile);\n-             ZipOutputStream zos = new ZipOutputStream(os)) {\n-            System.out.println(\"Creating Zip file: \" + zipFile.getFileName());\n-            for (String srcFile : ZIP_ENTRIES) {\n-                File fileToZip = new File(srcFile);\n-                long fileSize = fileToZip.length();\n-                System.out.println(\"Adding entry \" + srcFile + \" of size \" + fileSize + \" bytes\");\n-                try (FileInputStream fis = new FileInputStream(fileToZip)) {\n-                    ZipEntry zipEntry = new ZipEntry(fileToZip.getName());\n-                    zipEntry.setSize(fileSize);\n-                    zos.putNextEntry(zipEntry);\n-                    fis.transferTo(zos);\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Create the files that will be added to the ZIP file\n-     *\/\n-    private static void createFiles() throws IOException {\n-        try (RandomAccessFile largeFile = new RandomAccessFile(LARGE_FILE_NAME, \"rw\");\n-             RandomAccessFile smallFile = new RandomAccessFile(SMALL_FILE_NAME, \"rw\")) {\n-            System.out.printf(\"Creating %s%n\", LARGE_FILE_NAME);\n-            largeFile.setLength(LARGE_FILE_SIZE);\n-            System.out.printf(\"Creating %s%n\", SMALL_FILE_NAME);\n-            smallFile.setLength(SMALL_FILE_SIZE);\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/LargeEntrySizeTest.java","additions":0,"deletions":137,"binary":false,"changes":137,"status":"deleted"},{"patch":"@@ -34,1 +34,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -46,3 +45,3 @@\n- * works fine for varying sizes of the zip file entries and various different values of tempFileThreshold\n- * @bug 8190753\n- * @run testng ZipFSOutputStreamTest\n+ * works fine for varying sizes of the zip file entries\n+ * @bug 8190753 8011146\n+ * @run testng\/timeout=300 ZipFSOutputStreamTest\n@@ -53,3 +52,4 @@\n-            \"LargeSize\", 25L * 1024L * 1024L, \/\/ 25 MB\n-            \"d1\/SmallSize\", 1234L,\n-            \"d1\/d2\/ZeroSize\", 0L);\n+            \"f1\", Integer.MAX_VALUE + 1L, \/\/ a value which when cast to an integer, becomes a negative value\n+            \"f2\", 25L * 1024L * 1024L, \/\/ 25 MB\n+            \"d1\/f3\", 1234L,\n+            \"d1\/d2\/f4\", 0L);\n@@ -73,3 +73,2 @@\n-    @DataProvider(name = \"zipfsThresholdValueParsing\")\n-    private Object[][] zipfsThresholdValueParsing() {\n-        \/\/ various different values passed to the \"tempFileThreshold\", some valid some invalid\n+    @DataProvider(name = \"zipFSCreationEnv\")\n+    private Object[][] zipFSCreationEnv() {\n@@ -77,47 +76,2 @@\n-                {Map.of(\"create\", \"true\", \"tempFileThreshold\", \"1024\")},\n-                {Map.of(\"create\", \"true\", \"tempFileThreshold\", \"1\")},\n-                {Map.of(\"create\", \"true\", \"tempFileThreshold\", \"-1\")},\n-                {Map.of(\"create\", \"true\", \"tempFileThreshold\", \"-2\")},\n-                {Map.of(\"create\", \"true\", \"tempFileThreshold\", \"0\")},\n-                {Map.of(\"create\", \"true\", \"tempFileThreshold\", Integer.MAX_VALUE)},\n-                {Map.of(\"create\", \"true\", \"tempFileThreshold\", Long.MAX_VALUE)},\n-                {Map.of(\"create\", \"true\", \"tempFileThreshold\", \"helloworld\")},\n-                {Map.of(\"create\", \"true\", \"tempFileThreshold\", 124232.232d)},\n-                {Map.of(\"create\", \"true\", \"tempFileThreshold\", 122.232f)}\n-        };\n-    }\n-\n-    \/**\n-     * Create a zip filesystem with various different values of tempFileThreshold, some valid and\n-     * some invalid. Make sure that in all these cases, the zip filesystem creation works fine\n-     * and entries can be added to the zip file and read from and the content is as expected.\n-     *\/\n-    @Test(dataProvider = \"zipfsThresholdValueParsing\")\n-    public void testThresholdValueParsing(final Map<String, ?> env) throws Exception {\n-        try (final FileSystem zipfs = FileSystems.newFileSystem(ZIP_FILE, env)) {\n-            \/\/ create the zip file with just a simple entry\n-            try (final OutputStream os = Files.newOutputStream(zipfs.getPath(\"helloworld.txt\"))) {\n-                os.write(\"hi\".getBytes(StandardCharsets.UTF_8));\n-            }\n-            \/\/ now verify the written content\n-            try (final InputStream is = Files.newInputStream(zipfs.getPath(\"helloworld.txt\"))) {\n-                Assert.assertEquals(is.readAllBytes(), \"hi\".getBytes(StandardCharsets.UTF_8),\n-                        \"Unexpected content in zip entry\");\n-            }\n-        }\n-    }\n-\n-    @DataProvider(name = \"zipfsVaryingThreshold\")\n-    private Object[][] zipfsVaryingThreshold() {\n-        return new Object[][]{\n-                \/\/ default tempfile threshold, for both DEFLATED and STORED compression modes\n-                {Map.of(\"create\", \"true\", \"noCompression\", \"true\")},\n-                {Map.of(\"create\", \"true\", \"noCompression\", \"false\")},\n-                \/\/ specific threshold for both DEFLATED and STORED compression modes\n-                {Map.of(\"create\", \"true\", \"noCompression\", \"true\", \"tempFileThreshold\", \"1024\")},\n-                {Map.of(\"create\", \"true\", \"noCompression\", \"false\", \"tempFileThreshold\", \"1024\")},\n-                \/\/ threshold disabled\n-                {Map.of(\"create\", \"true\", \"noCompression\", \"true\", \"tempFileThreshold\", \"-1\")},\n-                {Map.of(\"create\", \"true\", \"noCompression\", \"false\", \"tempFileThreshold\", \"-1\")},\n-                {Map.of(\"create\", \"true\", \"noCompression\", \"true\", \"tempFileThreshold\", \"0\")},\n-                {Map.of(\"create\", \"true\", \"noCompression\", \"false\", \"tempFileThreshold\", \"0\")},\n+                {Map.of(\"create\", \"true\", \"noCompression\", \"true\")}, \/\/ STORED\n+                {Map.of(\"create\", \"true\", \"noCompression\", \"false\")} \/\/ DEFLATED\n@@ -129,2 +83,2 @@\n-     * Create a zip filesystem using different outputstream temp file creation threshold and write\n-     * out entries of varying sizes. Then verify that the generated zip file entries are as expected,\n+     * Create a zip filesystem and write out entries of varying sizes using the outputstream returned\n+     * by the ZipFileSystem. Then verify that the generated zip file entries are as expected,\n@@ -133,2 +87,2 @@\n-    @Test(dataProvider = \"zipfsVaryingThreshold\")\n-    public void testOutputStreamWithDifferentThreshold(final Map<String, ?> env) throws Exception {\n+    @Test(dataProvider = \"zipFSCreationEnv\")\n+    public void testOutputStream(final Map<String, ?> env) throws Exception {\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/ZipFSOutputStreamTest.java","additions":15,"deletions":61,"binary":false,"changes":76,"status":"modified"}]}