{"files":[{"patch":"@@ -36,0 +36,1 @@\n+import java.io.UncheckedIOException;\n@@ -108,0 +109,2 @@\n+    \/\/ The maximum size of array to allocate. Some VMs reserve some header words in an array.\n+    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n@@ -122,0 +125,7 @@\n+\n+    private static final int DEFAULT_TEMP_FILE_CREATION_THRESHOLD = 10 * 1024 * 1024; \/\/ 10 MB\n+    \/\/ a threshold, in bytes, to decide whether to create a temp file\n+    \/\/ for outputstream of a zip entry, when useTempFile\n+    \/\/ isn't explicitly enabled\n+    private final int tempFileCreationThreshold;\n+\n@@ -146,0 +156,1 @@\n+        this.tempFileCreationThreshold = initTempFileThreshold(env);\n@@ -238,0 +249,18 @@\n+    private static int initTempFileThreshold(Map<String, ?> env) {\n+        final Object val = env.get(\"tempFileThreshold\");\n+        if (val == null) {\n+            return DEFAULT_TEMP_FILE_CREATION_THRESHOLD;\n+        }\n+        if (val instanceof String v) {\n+            try {\n+                return Math.min(Integer.parseInt(v), MAX_ARRAY_SIZE);\n+            } catch (NumberFormatException nfe) {\n+                return DEFAULT_TEMP_FILE_CREATION_THRESHOLD;\n+            }\n+        }\n+        if (val instanceof Integer v) {\n+            return Math.min(v, MAX_ARRAY_SIZE);\n+        }\n+        return DEFAULT_TEMP_FILE_CREATION_THRESHOLD;\n+    }\n+\n@@ -1947,1 +1976,1 @@\n-        if (useTempFile) {\n+        if (useTempFile || (tempFileCreationThreshold > 0 && e.size >= tempFileCreationThreshold)) {\n@@ -1951,1 +1980,1 @@\n-            os = new ByteArrayOutputStream((e.size > 0)? (int)e.size : 8192);\n+            os = new FileRolloverOutputStream(e);\n@@ -1973,1 +2002,5 @@\n-            out.write(b);\n+            try {\n+                out.write(b);\n+            } catch (UncheckedIOException uioe) {\n+                throw uioe.getCause();\n+            }\n@@ -1980,1 +2013,5 @@\n-            out.write(b, off, len);\n+            try {\n+                out.write(b, off, len);\n+            } catch (UncheckedIOException uioe) {\n+                throw uioe.getCause();\n+            }\n@@ -1991,2 +2028,3 @@\n-            if (out instanceof ByteArrayOutputStream)\n-                e.bytes = ((ByteArrayOutputStream)out).toByteArray();\n+            if (out instanceof FileRolloverOutputStream fros && fros.tmpFileOS == null) {\n+                e.bytes = fros.toByteArray();\n+            }\n@@ -2014,1 +2052,5 @@\n-            super.write(b, off, len);\n+            try {\n+                super.write(b, off, len);\n+            } catch (UncheckedIOException uioe) {\n+                throw uioe.getCause();\n+            }\n@@ -2027,2 +2069,3 @@\n-            if (out instanceof ByteArrayOutputStream)\n-                e.bytes = ((ByteArrayOutputStream)out).toByteArray();\n+            if (out instanceof FileRolloverOutputStream fros && fros.tmpFileOS == null) {\n+                e.bytes = fros.toByteArray();\n+            }\n@@ -2110,0 +2153,109 @@\n+    \/\/ A wrapper around the ByteArrayOutputStream. This FileRolloverOutputStream\n+    \/\/ uses a threshold size to decide if the contents being written need to be\n+    \/\/ rolled over into a temporary file. Until the threshold is reached, writes\n+    \/\/ on this outputstream just write it to the internal in-memory byte array\n+    \/\/ held by the ByteArrayOutputStream. Once the threshold is reached, the\n+    \/\/ write operation on this outputstream first (and only once) creates a temporary file\n+    \/\/ and transfers the data that has so far been written in the internal\n+    \/\/ byte array, to that newly created file. The temp file is then opened\n+    \/\/ in append mode and any subsequent writes, including the one which triggered\n+    \/\/ the temporary file creation, will be written to the file.\n+    \/\/ A threshold value of <= 0 implies rollover is disabled, in which case this\n+    \/\/ FileRolloverOutputStream behaves just like a ByteArrayOutputStream and just passes\n+    \/\/ on the write operations to the ByteArrayOutputStream implementation.\n+    private class FileRolloverOutputStream extends ByteArrayOutputStream {\n+        private final Entry entry;\n+        private long totalWritten = 0;\n+        private OutputStream tmpFileOS;\n+\n+        FileRolloverOutputStream(final Entry e) {\n+            super(tempFileCreationThreshold <= 0\n+                    ? ((e.size > 0 && e.size <= MAX_ARRAY_SIZE) ? (int) e.size : 8192)\n+                    : ((e.size > 0 && e.size <= tempFileCreationThreshold) ? (int) e.size : 8192));\n+            this.entry = e;\n+        }\n+\n+        @Override\n+        public synchronized void write(int b) throws UncheckedIOException {\n+            if (tmpFileOS != null) {\n+                \/\/ already rolled over, write to the file that has been created previously\n+                writeToFile(b);\n+                return;\n+            }\n+            if (tempFileCreationThreshold <= 0 || (totalWritten + 1 < tempFileCreationThreshold)) {\n+                \/\/ write to our in-memory byte array\n+                super.write(b);\n+                totalWritten++;\n+                return;\n+            }\n+            \/\/ rollover into a file\n+            try {\n+                transferToFile();\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+            writeToFile(b);\n+        }\n+\n+        @Override\n+        public synchronized void write(byte[] b, int off, int len) throws UncheckedIOException {\n+            if (tmpFileOS != null) {\n+                \/\/ already rolled over, write to the file that has been created previously\n+                writeToFile(b, off, len);\n+                return;\n+            }\n+            if (tempFileCreationThreshold <= 0 || (totalWritten + len < tempFileCreationThreshold)) {\n+                \/\/ write to our in-memory byte array\n+                super.write(b, off, len);\n+                totalWritten += len;\n+                return;\n+            }\n+            \/\/ rollover into a file\n+            try {\n+                transferToFile();\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+            writeToFile(b, off, len);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            if (tmpFileOS != null) {\n+                tmpFileOS.close();\n+            }\n+        }\n+\n+        private void writeToFile(int b) throws UncheckedIOException {\n+            try {\n+                tmpFileOS.write(b);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+            totalWritten++;\n+        }\n+\n+        private void writeToFile(byte[] b, int off, int len) throws UncheckedIOException {\n+            try {\n+                tmpFileOS.write(b, off, len);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+            totalWritten += len;\n+        }\n+\n+        private void transferToFile() throws IOException {\n+            \/\/ create a tempfile\n+            entry.file = getTempPathForEntry(null);\n+            \/\/ transfer the already written data from the byte array buffer into this tempfile\n+            try (OutputStream os = new BufferedOutputStream(Files.newOutputStream(entry.file))) {\n+                new ByteArrayInputStream(buf, 0, count).transferTo(os);\n+            }\n+            \/\/ clear the in-memory buffer and shrink the buffer\n+            reset();\n+            buf = new byte[0];\n+            \/\/ append any further data to the file with buffering enabled\n+            tmpFileOS = new BufferedOutputStream(Files.newOutputStream(entry.file, APPEND));\n+        }\n+    }\n+\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java","additions":161,"deletions":9,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * This is intentionally a manual test. The (jtreg) configurations below are here only\n+ * for reference about runtime expectations of this test.\n+ *\n+ * @bug 8190753\n+ * @summary Verify that using zip filesystem for opening an outputstream for a zip entry whose\n+ * compressed size is large, doesn't run into \"Negative initial size\" exception\n+ * @run testng\/othervm\/timeout=300 LargeCompressedEntrySizeTest\n+ *\/\n+public class LargeCompressedEntrySizeTest {\n+\n+    private static final String LARGE_FILE_NAME = \"LargeZipEntry.txt\";\n+    private static final String ZIP_FILE_NAME = \"8190753-test-compressed-size.zip\";\n+\n+    @BeforeMethod\n+    public void setUp() throws IOException {\n+        deleteFiles();\n+    }\n+\n+    @AfterMethod\n+    public void tearDown() throws IOException {\n+        deleteFiles();\n+    }\n+\n+    \/**\n+     * Delete the files created for use by the test\n+     *\n+     * @throws IOException if an error occurs deleting the files\n+     *\/\n+    private static void deleteFiles() throws IOException {\n+        Files.deleteIfExists(Path.of(ZIP_FILE_NAME));\n+    }\n+\n+\n+    \/**\n+     * Using zip filesystem, creates a zip file and writes out a zip entry whose compressed size is\n+     * expected to be greater than 2gb.\n+     *\/\n+    @Test\n+    public void testLargeCompressedSizeWithZipFS() throws Exception {\n+        final Path zipFile = Path.of(ZIP_FILE_NAME);\n+        final long largeEntrySize = 6L * 1024L * 1024L * 1024L; \/\/ large value which exceeds Integer.MAX_VALUE\n+        try (FileSystem fs = FileSystems.newFileSystem(zipFile, Collections.singletonMap(\"create\", \"true\"))) {\n+            try (OutputStream os = Files.newOutputStream(fs.getPath(LARGE_FILE_NAME))) {\n+                long remaining = largeEntrySize;\n+                \/\/ create a chunk of random bytes which we keep writing out\n+                final int chunkSize = 102400;\n+                final byte[] chunk = new byte[chunkSize];\n+                new Random().nextBytes(chunk);\n+                final long start = System.currentTimeMillis();\n+                for (long l = 0; l < largeEntrySize; l += chunkSize) {\n+                    final int numToWrite = (int) Math.min(remaining, chunkSize);\n+                    os.write(chunk, 0, numToWrite);\n+                    remaining -= numToWrite;\n+                }\n+                System.out.println(\"Took \" + TimeUnit.SECONDS.toSeconds(System.currentTimeMillis() - start)\n+                        + \" seconds to generate entry of size \" + largeEntrySize);\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/LargeCompressedEntrySizeTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.RandomAccessFile;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+\/**\n+ * @test\n+ * @bug 8190753\n+ * @summary Verify that using zip filesystem for opening an outputstream for a large zip entry doesn't\n+ * run into \"Negative initial size\" exception\n+ * @run testng LargeEntrySizeTest\n+ *\/\n+public class LargeEntrySizeTest {\n+\n+    \/\/ a value which when cast to an integer, becomes a negative value\n+    private static final long LARGE_FILE_SIZE = Integer.MAX_VALUE + 1L;\n+    private static final long SMALL_FILE_SIZE = 0x100000L; \/\/ 1024L x 1024L;\n+    private static final String LARGE_FILE_NAME = \"LargeZipEntry.txt\";\n+    \/\/ File that will be created with a size less than 0xFFFFFFFF\n+    private static final String SMALL_FILE_NAME = \"SmallZipEntry.txt\";\n+    \/\/ List of files to be added to the ZIP file\n+    private static final List<String> ZIP_ENTRIES = List.of(LARGE_FILE_NAME, SMALL_FILE_NAME);\n+    private static final String ZIP_FILE_NAME = \"8190753-test.zip\";\n+\n+    @BeforeMethod\n+    public void setUp() throws IOException {\n+        deleteFiles();\n+    }\n+\n+    @AfterMethod\n+    public void tearDown() throws IOException {\n+        deleteFiles();\n+    }\n+\n+    \/**\n+     * Delete the files created for use by the test\n+     *\n+     * @throws IOException if an error occurs deleting the files\n+     *\/\n+    private static void deleteFiles() throws IOException {\n+        Files.deleteIfExists(Path.of(ZIP_FILE_NAME));\n+        Files.deleteIfExists(Path.of(LARGE_FILE_NAME));\n+        Files.deleteIfExists(Path.of(SMALL_FILE_NAME));\n+    }\n+\n+\n+    \/**\n+     * Verifies that large entry (whose size is greater than {@link Integer#MAX_VALUE}) in a zip file\n+     * can be opened as an {@link OutputStream} using the zip filesystem\n+     *\/\n+    @Test\n+    public void testLargeEntryZipFSOutputStream() throws Exception {\n+        final Path zipFile = Path.of(ZIP_FILE_NAME);\n+        createZipFile(zipFile);\n+        try (FileSystem fs = FileSystems.newFileSystem(zipFile)) {\n+            for (String entryName : ZIP_ENTRIES) {\n+                try (OutputStream os = Files.newOutputStream(fs.getPath(entryName), StandardOpenOption.WRITE)) {\n+                    \/\/ just a dummy write\n+                    os.write(0x01);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Creates a zip file with an entry whose size is larger than {@link Integer#MAX_VALUE}\n+     *\/\n+    private static void createZipFile(final Path zipFile) throws IOException {\n+        createFiles();\n+        try (OutputStream os = Files.newOutputStream(zipFile);\n+             ZipOutputStream zos = new ZipOutputStream(os)) {\n+            System.out.println(\"Creating Zip file: \" + zipFile.getFileName());\n+            for (String srcFile : ZIP_ENTRIES) {\n+                File fileToZip = new File(srcFile);\n+                long fileSize = fileToZip.length();\n+                System.out.println(\"Adding entry \" + srcFile + \" of size \" + fileSize + \" bytes\");\n+                try (FileInputStream fis = new FileInputStream(fileToZip)) {\n+                    ZipEntry zipEntry = new ZipEntry(fileToZip.getName());\n+                    zipEntry.setSize(fileSize);\n+                    zos.putNextEntry(zipEntry);\n+                    fis.transferTo(zos);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Create the files that will be added to the ZIP file\n+     *\/\n+    private static void createFiles() throws IOException {\n+        try (RandomAccessFile largeFile = new RandomAccessFile(LARGE_FILE_NAME, \"rw\");\n+             RandomAccessFile smallFile = new RandomAccessFile(SMALL_FILE_NAME, \"rw\")) {\n+            System.out.printf(\"Creating %s%n\", LARGE_FILE_NAME);\n+            largeFile.setLength(LARGE_FILE_SIZE);\n+            System.out.printf(\"Creating %s%n\", SMALL_FILE_NAME);\n+            smallFile.setLength(SMALL_FILE_SIZE);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/LargeEntrySizeTest.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Map;\n+import java.util.Random;\n+\n+\n+\/**\n+ * @test\n+ * @summary Verify that the outputstream created for zip file entries, through the ZipFileSystem\n+ * works fine for varying sizes of the zip file entries and various different values of tempFileThreshold\n+ * @bug 8190753\n+ * @run testng ZipFSOutputStreamTest\n+ *\/\n+public class ZipFSOutputStreamTest {\n+    \/\/ List of files to be added to the ZIP file along with their sizes in bytes\n+    private static final Map<String, Long> ZIP_ENTRIES = Map.of(\n+            \"LargeSize\", 25L * 1024L * 1024L, \/\/ 25 MB\n+            \"d1\/SmallSize\", 1234L,\n+            \"d1\/d2\/ZeroSize\", 0L);\n+\n+    private static final Path ZIP_FILE = Path.of(\"zipfs-outputstream-test.zip\");\n+\n+    @BeforeMethod\n+    public void setUp() throws IOException {\n+        deleteFiles();\n+    }\n+\n+    @AfterMethod\n+    public void tearDown() throws IOException {\n+        deleteFiles();\n+    }\n+\n+    private static void deleteFiles() throws IOException {\n+        Files.deleteIfExists(ZIP_FILE);\n+    }\n+\n+    @DataProvider(name = \"zipfsThresholdValueParsing\")\n+    private Object[][] zipfsThresholdValueParsing() {\n+        \/\/ various different values passed to the \"tempFileThreshold\", some valid some invalid\n+        return new Object[][]{\n+                {Map.of(\"create\", \"true\", \"tempFileThreshold\", \"1024\")},\n+                {Map.of(\"create\", \"true\", \"tempFileThreshold\", \"1\")},\n+                {Map.of(\"create\", \"true\", \"tempFileThreshold\", \"-1\")},\n+                {Map.of(\"create\", \"true\", \"tempFileThreshold\", \"-2\")},\n+                {Map.of(\"create\", \"true\", \"tempFileThreshold\", \"0\")},\n+                {Map.of(\"create\", \"true\", \"tempFileThreshold\", Integer.MAX_VALUE)},\n+                {Map.of(\"create\", \"true\", \"tempFileThreshold\", Long.MAX_VALUE)},\n+                {Map.of(\"create\", \"true\", \"tempFileThreshold\", \"helloworld\")},\n+                {Map.of(\"create\", \"true\", \"tempFileThreshold\", 124232.232d)},\n+                {Map.of(\"create\", \"true\", \"tempFileThreshold\", 122.232f)}\n+        };\n+    }\n+\n+    \/**\n+     * Create a zip filesystem with various different values of tempFileThreshold, some valid and\n+     * some invalid. Make sure that in all these cases, the zip filesystem creation works fine\n+     * and entries can be added to the zip file and read from and the content is as expected.\n+     *\/\n+    @Test(dataProvider = \"zipfsThresholdValueParsing\")\n+    public void testThresholdValueParsing(final Map<String, ?> env) throws Exception {\n+        try (final FileSystem zipfs = FileSystems.newFileSystem(ZIP_FILE, env)) {\n+            \/\/ create the zip file with just a simple entry\n+            try (final OutputStream os = Files.newOutputStream(zipfs.getPath(\"helloworld.txt\"))) {\n+                os.write(\"hi\".getBytes(StandardCharsets.UTF_8));\n+            }\n+            \/\/ now verify the written content\n+            try (final InputStream is = Files.newInputStream(zipfs.getPath(\"helloworld.txt\"))) {\n+                Assert.assertEquals(is.readAllBytes(), \"hi\".getBytes(StandardCharsets.UTF_8),\n+                        \"Unexpected content in zip entry\");\n+            }\n+        }\n+    }\n+\n+    @DataProvider(name = \"zipfsVaryingThreshold\")\n+    private Object[][] zipfsVaryingThreshold() {\n+        return new Object[][]{\n+                \/\/ default tempfile threshold, for both DEFLATED and STORED compression modes\n+                {Map.of(\"create\", \"true\", \"noCompression\", \"true\")},\n+                {Map.of(\"create\", \"true\", \"noCompression\", \"false\")},\n+                \/\/ specific threshold for both DEFLATED and STORED compression modes\n+                {Map.of(\"create\", \"true\", \"noCompression\", \"true\", \"tempFileThreshold\", \"1024\")},\n+                {Map.of(\"create\", \"true\", \"noCompression\", \"false\", \"tempFileThreshold\", \"1024\")},\n+                \/\/ threshold disabled\n+                {Map.of(\"create\", \"true\", \"noCompression\", \"true\", \"tempFileThreshold\", \"-1\")},\n+                {Map.of(\"create\", \"true\", \"noCompression\", \"false\", \"tempFileThreshold\", \"-1\")},\n+                {Map.of(\"create\", \"true\", \"noCompression\", \"true\", \"tempFileThreshold\", \"0\")},\n+                {Map.of(\"create\", \"true\", \"noCompression\", \"false\", \"tempFileThreshold\", \"0\")},\n+\n+        };\n+    }\n+\n+    \/**\n+     * Create a zip filesystem using different outputstream temp file creation threshold and write\n+     * out entries of varying sizes. Then verify that the generated zip file entries are as expected,\n+     * both in size and content\n+     *\/\n+    @Test(dataProvider = \"zipfsVaryingThreshold\")\n+    public void testOutputStreamWithDifferentThreshold(final Map<String, ?> env) throws Exception {\n+        final byte[] chunk = new byte[1024];\n+        new Random().nextBytes(chunk);\n+        try (final FileSystem zipfs = FileSystems.newFileSystem(ZIP_FILE, env)) {\n+            \/\/ create the zip with varying sized entries\n+            for (final Map.Entry<String, Long> entry : ZIP_ENTRIES.entrySet()) {\n+                final Path entryPath = zipfs.getPath(entry.getKey());\n+                if (entryPath.getParent() != null) {\n+                    Files.createDirectories(entryPath.getParent());\n+                }\n+                try (final OutputStream os = Files.newOutputStream(entryPath)) {\n+                    writeAsChunks(os, chunk, entry.getValue());\n+                }\n+            }\n+        }\n+        \/\/ now verify the written content\n+        try (final FileSystem zipfs = FileSystems.newFileSystem(ZIP_FILE)) {\n+            for (final Map.Entry<String, Long> entry : ZIP_ENTRIES.entrySet()) {\n+                final Path entryPath = zipfs.getPath(entry.getKey());\n+                try (final InputStream is = Files.newInputStream(entryPath)) {\n+                    final byte[] buf = new byte[chunk.length];\n+                    int numRead;\n+                    long totalRead = 0;\n+                    while ((numRead = is.read(buf)) != -1) {\n+                        totalRead += numRead;\n+                        \/\/ verify the content\n+                        for (int i = 0, chunkoffset = (int) ((totalRead - numRead) % chunk.length);\n+                             i < numRead; i++, chunkoffset++) {\n+                            Assert.assertEquals(buf[i], chunk[chunkoffset % chunk.length],\n+                                    \"Unexpected content in \" + entryPath);\n+                        }\n+                    }\n+                    Assert.assertEquals(totalRead, (long) entry.getValue(),\n+                            \"Unexpected number of bytes read from zip entry \" + entryPath);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Repeatedly writes out to the outputstream, the chunk of data, till the number of bytes\n+     * written to the stream equals the totalSize\n+     *\/\n+    private static void writeAsChunks(final OutputStream os, final byte[] chunk,\n+                                      final long totalSize) throws IOException {\n+        long remaining = totalSize;\n+        for (long l = 0; l < totalSize; l += chunk.length) {\n+            final int numToWrite = (int) Math.min(remaining, chunk.length);\n+            os.write(chunk, 0, numToWrite);\n+            remaining -= numToWrite;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/ZipFSOutputStreamTest.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"}]}