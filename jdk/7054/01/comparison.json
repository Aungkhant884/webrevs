{"files":[{"patch":"@@ -28,3 +28,0 @@\n-import java.lang.ref.Reference;\n-import java.lang.ref.ReferenceQueue;\n-import java.lang.ref.WeakReference;\n@@ -36,2 +33,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n@@ -1675,2 +1670,0 @@\n-    \/* Replace with ConcurrentReferenceHashMap when\/if it appears in a future\n-     * release *\/\n@@ -1679,6 +1672,7 @@\n-        static final ConcurrentMap<WeakClassKey,Boolean> subclassAudits =\n-            new ConcurrentHashMap<>();\n-\n-        \/** queue for WeakReferences to audited subclasses *\/\n-        static final ReferenceQueue<Class<?>> subclassAuditsQueue =\n-            new ReferenceQueue<>();\n+        static final ClassValue<Boolean> subclassAudits =\n+            new ClassValue<>() {\n+                @Override\n+                protected Boolean computeValue(Class<?> type) {\n+                    return auditSubclass(type);\n+                }\n+            };\n@@ -1697,9 +1691,1 @@\n-        processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);\n-        WeakClassKey key = new WeakClassKey(cl, Caches.subclassAuditsQueue);\n-        Boolean result = Caches.subclassAudits.get(key);\n-        if (result == null) {\n-            result = Boolean.valueOf(auditSubclass(cl));\n-            Caches.subclassAudits.putIfAbsent(key, result);\n-        }\n-\n-        return result.booleanValue();\n+        return Caches.subclassAudits.get(cl);\n@@ -2011,63 +1997,0 @@\n-    \/**\n-     * Removes from the specified map any keys that have been enqueued\n-     * on the specified reference queue.\n-     *\/\n-    static void processQueue(ReferenceQueue<Class<?>> queue,\n-                             ConcurrentMap<? extends\n-                             WeakReference<Class<?>>, ?> map)\n-    {\n-        Reference<? extends Class<?>> ref;\n-        while((ref = queue.poll()) != null) {\n-            map.remove(ref);\n-        }\n-    }\n-\n-    \/**\n-     *  Weak key for Class objects.\n-     **\/\n-    static class WeakClassKey extends WeakReference<Class<?>> {\n-        \/**\n-         * saved value of the referent's identity hash code, to maintain\n-         * a consistent hash code after the referent has been cleared\n-         *\/\n-        private final int hash;\n-\n-        \/**\n-         * Create a new WeakClassKey to the given object, registered\n-         * with a queue.\n-         *\/\n-        WeakClassKey(Class<?> cl, ReferenceQueue<Class<?>> refQueue) {\n-            super(cl, refQueue);\n-            hash = System.identityHashCode(cl);\n-        }\n-\n-        \/**\n-         * Returns the identity hash code of the original referent.\n-         *\/\n-        @Override\n-        public int hashCode() {\n-            return hash;\n-        }\n-\n-        \/**\n-         * Returns true if the given object is this identical\n-         * WeakClassKey instance, or, if this object's referent has not\n-         * been cleared, if the given object is another WeakClassKey\n-         * instance with the identical non-null referent as this one.\n-         *\/\n-        @Override\n-        public boolean equals(Object obj) {\n-            if (obj == this)\n-                return true;\n-\n-            if (obj instanceof WeakClassKey) {\n-                Class<?> referent = get();\n-                return (referent != null) &&\n-                        (((WeakClassKey) obj).refersTo(referent));\n-            } else {\n-                return false;\n-            }\n-        }\n-    }\n-\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":8,"deletions":85,"binary":false,"changes":93,"status":"modified"}]}