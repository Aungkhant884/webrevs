{"files":[{"patch":"@@ -104,0 +104,21 @@\n+  static Assembler::SIMD_RegVariant elemBytes_to_regVariant(int esize) {\n+    switch(esize) {\n+      case 1:\n+        return Assembler::B;\n+      case 2:\n+        return Assembler::H;\n+      case 4:\n+        return Assembler::S;\n+      case 8:\n+        return Assembler::D;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+    return Assembler::INVALID;\n+  }\n+\n+  static Assembler::SIMD_RegVariant elemType_to_regVariant(BasicType bt) {\n+    return elemBytes_to_regVariant(type2aelembytes(bt));\n+  }\n+\n@@ -467,27 +488,1 @@\n-\/\/ vector max\n-\n-instruct vmaxF(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst_src1 (MaxV dst_src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmax $dst_src1, $dst_src1, $src2\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fmax(as_FloatRegister($dst_src1$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmaxD(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst_src1 (MaxV dst_src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmax $dst_src1, $dst_src1, $src2\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fmax(as_FloatRegister($dst_src1$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n+\/\/ vector min\/max\n@@ -495,3 +490,2 @@\n-instruct vminF(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+instruct vmin(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n@@ -500,1 +494,1 @@\n-  format %{ \"sve_fmin $dst_src1, $dst_src1, $src2\\t # vector (sve) (S)\" %}\n+  format %{ \"sve_min $dst_src1, $dst_src1, $src2\\t # vector (sve)\" %}\n@@ -502,2 +496,10 @@\n-    __ sve_fmin(as_FloatRegister($dst_src1$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg));\n+    BasicType bt = vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n+    if (is_floating_point_type(bt)) {\n+      __ sve_fmin(as_FloatRegister($dst_src1$$reg), size,\n+                  ptrue, as_FloatRegister($src2$$reg));\n+    } else {\n+      assert(is_integral_type(bt), \"Unsupported type\");\n+      __ sve_smin(as_FloatRegister($dst_src1$$reg), size,\n+                  ptrue, as_FloatRegister($src2$$reg));\n+    }\n@@ -508,4 +510,3 @@\n-instruct vminD(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst_src1 (MinV dst_src1 src2));\n+instruct vmax(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  match(Set dst_src1 (MaxV dst_src1 src2));\n@@ -513,1 +514,1 @@\n-  format %{ \"sve_fmin $dst_src1, $dst_src1, $src2\\t # vector (sve) (D)\" %}\n+  format %{ \"sve_max $dst_src1, $dst_src1, $src2\\t # vector (sve)\" %}\n@@ -515,2 +516,10 @@\n-    __ sve_fmin(as_FloatRegister($dst_src1$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg));\n+    BasicType bt = vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n+    if (is_floating_point_type(bt)) {\n+      __ sve_fmax(as_FloatRegister($dst_src1$$reg), size,\n+                  ptrue, as_FloatRegister($src2$$reg));\n+    } else {\n+      assert(is_integral_type(bt), \"Unsupported type\");\n+      __ sve_smax(as_FloatRegister($dst_src1$$reg), size,\n+                  ptrue, as_FloatRegister($src2$$reg));\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":49,"deletions":40,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -91,0 +91,21 @@\n+  static Assembler::SIMD_RegVariant elemBytes_to_regVariant(int esize) {\n+    switch(esize) {\n+      case 1:\n+        return Assembler::B;\n+      case 2:\n+        return Assembler::H;\n+      case 4:\n+        return Assembler::S;\n+      case 8:\n+        return Assembler::D;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+    return Assembler::INVALID;\n+  }\n+\n+  static Assembler::SIMD_RegVariant elemType_to_regVariant(BasicType bt) {\n+    return elemBytes_to_regVariant(type2aelembytes(bt));\n+  }\n+\n@@ -322,8 +343,5 @@\n-dnl\n-dnl BINARY_OP_TRUE_PREDICATE_ETYPE($1,        $2,      $3,           $4,   $5,          $6  )\n-dnl BINARY_OP_TRUE_PREDICATE_ETYPE(insn_name, op_name, element_type, size, min_vec_len, insn)\n-define(`BINARY_OP_TRUE_PREDICATE_ETYPE', `\n-instruct $1(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= $5 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == $3);\n-  match(Set dst_src1 ($2 dst_src1 src2));\n+\/\/ vector min\/max\n+\n+instruct vmin(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  match(Set dst_src1 (MinV dst_src1 src2));\n@@ -331,1 +349,1 @@\n-  format %{ \"$6 $dst_src1, $dst_src1, $src2\\t # vector (sve) ($4)\" %}\n+  format %{ \"sve_min $dst_src1, $dst_src1, $src2\\t # vector (sve)\" %}\n@@ -333,2 +351,10 @@\n-    __ $6(as_FloatRegister($dst_src1$$reg), __ $4,\n-         ptrue, as_FloatRegister($src2$$reg));\n+    BasicType bt = vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n+    if (is_floating_point_type(bt)) {\n+      __ sve_fmin(as_FloatRegister($dst_src1$$reg), size,\n+                  ptrue, as_FloatRegister($src2$$reg));\n+    } else {\n+      assert(is_integral_type(bt), \"Unsupported type\");\n+      __ sve_smin(as_FloatRegister($dst_src1$$reg), size,\n+                  ptrue, as_FloatRegister($src2$$reg));\n+    }\n@@ -337,7 +363,21 @@\n-%}')dnl\n-dnl\n-\/\/ vector max\n-BINARY_OP_TRUE_PREDICATE_ETYPE(vmaxF, MaxV, T_FLOAT,  S, 4,  sve_fmax)\n-BINARY_OP_TRUE_PREDICATE_ETYPE(vmaxD, MaxV, T_DOUBLE, D, 2,  sve_fmax)\n-BINARY_OP_TRUE_PREDICATE_ETYPE(vminF, MinV, T_FLOAT,  S, 4,  sve_fmin)\n-BINARY_OP_TRUE_PREDICATE_ETYPE(vminD, MinV, T_DOUBLE, D, 2,  sve_fmin)\n+%}\n+\n+instruct vmax(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  match(Set dst_src1 (MaxV dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_max $dst_src1, $dst_src1, $src2\\t # vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n+    if (is_floating_point_type(bt)) {\n+      __ sve_fmax(as_FloatRegister($dst_src1$$reg), size,\n+                  ptrue, as_FloatRegister($src2$$reg));\n+    } else {\n+      assert(is_integral_type(bt), \"Unsupported type\");\n+      __ sve_smax(as_FloatRegister($dst_src1$$reg), size,\n+                  ptrue, as_FloatRegister($src2$$reg));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":58,"deletions":18,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -1538,1 +1538,1 @@\n-    B, H, S, D, Q\n+    B, H, S, D, Q, INVALID\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}