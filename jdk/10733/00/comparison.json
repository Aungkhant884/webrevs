{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,65 @@\n+static void printFrame(jvmtiEnv *jvmti, jmethodID method, jint depth) {\n+    char *className = NULL;\n+    char *classSig = NULL;\n+    jclass cls;\n+    jvmtiError err = jvmti->GetMethodDeclaringClass(method, &cls);\n+    if (err == JVMTI_ERROR_NONE) {\n+        err = jvmti->GetClassSignature(cls, &classSig, NULL);\n+        if (err == JVMTI_ERROR_NONE) {\n+            \/\/ drop leading 'L' and trailing ';'\n+            className = classSig + 1;\n+            className[strlen(classSig) - 2] = '\\0';\n+        } else {\n+            printf(\"GetClassSignature error: %s (%d)\\n\", TranslateError(err), err);\n+        }\n+    } else {\n+        printf(\"GetMethodDeclaringClass error: %s (%d)\\n\", TranslateError(err), err);\n+    }\n+\n+    char *methodName = NULL;\n+    char *methodSig = NULL;\n+    err = jvmti->GetMethodName(method, &methodName, &methodSig, NULL);\n+    if (err != JVMTI_ERROR_NONE) {\n+        printf(\"GetMethodName error: %s (%d)\\n\", TranslateError(err), err);\n+    }\n+\n+    printf(\"%02d: %s %s%s\\n\", depth,\n+           className != NULL ? className : \"<class name is not available>\",\n+           methodName != NULL ? methodName : \"<method name is not available>\",\n+           methodSig != NULL ? methodSig : \"<method signature is not available>\");\n+    jvmti->Deallocate((unsigned char*)classSig);\n+    jvmti->Deallocate((unsigned char*)methodName);\n+    jvmti->Deallocate((unsigned char*)methodSig);\n+}\n+\n+static void printStackTrace(jvmtiEnv *jvmti, jthread thread) {\n+    jvmtiThreadInfo threadInfo;\n+    memset(&threadInfo, 0, sizeof(threadInfo));\n+    jvmtiError err = jvmti->GetThreadInfo(thread, &threadInfo);\n+    if (err != JVMTI_ERROR_NONE) {\n+        printf(\"GetThreadInfo error: %s (%d)\\n\", TranslateError(err), err);\n+    }\n+\n+    jvmtiFrameInfo frames[64];\n+    jint count = 0;\n+    err = jvmti->GetStackTrace(thread, 0, 64, frames, &count);\n+    if (err != JVMTI_ERROR_NONE) {\n+        printf(\"Failed to get stack trace: %s (%d)\\n\", TranslateError(err), err);\n+    }\n+\n+    printf(\"Stack trace for thread %s: frame count: %d\\n\",\n+           threadInfo.name != NULL ? threadInfo.name : \"<name is not available>\",\n+           count);\n+    jvmti->Deallocate((unsigned char*)threadInfo.name);\n+\n+    if (err != JVMTI_ERROR_NONE) { \/\/ GetStackTrace error\n+        printf(\"  Not Available\\n\");\n+    } else {\n+        for (int depth = 0; depth < count; depth++) {\n+            printFrame(jvmti, frames[depth].method, depth);\n+        }\n+    }\n+    printf(\"\\n\");\n+    fflush(0);\n+}\n+\n@@ -123,1 +188,1 @@\n-        jobject frameThr) {\n+        jthread frameThr) {\n@@ -155,0 +220,2 @@\n+    bool gotError = false;\n+\n@@ -163,1 +230,1 @@\n-        tot_result = STATUS_FAILED;\n+        gotError = true;\n@@ -176,1 +243,1 @@\n-        tot_result = STATUS_FAILED;\n+        gotError = true;\n@@ -184,1 +251,1 @@\n-        tot_result = STATUS_FAILED;\n+        gotError = true;\n@@ -190,0 +257,5 @@\n+    if (gotError) {\n+        tot_result = STATUS_FAILED;\n+        printStackTrace(jvmti, frameThr);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/PopFrame\/popframe004\/popframe004.cpp","additions":77,"deletions":5,"binary":false,"changes":82,"status":"modified"}]}