{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include \"oops\/oop.inline.hpp\"\n@@ -35,0 +36,1 @@\n+#include \"utilities\/align.hpp\"\n@@ -36,1 +38,0 @@\n-#include \"oops\/oop.inline.hpp\"\n@@ -44,7 +45,10 @@\n-relocInfo::relocInfo(relocType t, int off, int f) {\n-  assert(t != data_prefix_tag, \"cannot build a prefix this way\");\n-  assert((t & type_mask) == t, \"wrong type\");\n-  assert((f & format_mask) == f, \"wrong format\");\n-  assert(off >= 0 && off < offset_limit(), \"offset out off bounds\");\n-  assert((off & (offset_unit-1)) == 0, \"misaligned offset\");\n-  (*this) = relocInfo(t, RAW_BITS, off, f);\n+relocInfo::relocType relocInfo::check_relocType(relocType type) {\n+  assert(type != data_prefix_tag, \"cannot build a prefix this way\");\n+  assert((type & type_mask) == type, \"wrong type\");\n+  return type;\n+}\n+\n+void relocInfo::check_offset_and_format(int offset, int format) {\n+  assert(offset >= 0 && offset < offset_limit(), \"offset out off bounds\");\n+  assert(is_aligned(offset, offset_unit), \"misaligned offset\");\n+  assert((format & format_mask) == format, \"wrong format\");\n@@ -52,1 +56,1 @@\n-#endif\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,4 +56,0 @@\n-\/\/    BoundRelocation\n-\/\/      An _internal_ type shared by packers and unpackers of relocations.\n-\/\/      It pastes together a RelocationHolder with some pointers into\n-\/\/      code and relocInfo streams.\n@@ -278,1 +274,1 @@\n- protected:\n+ private:\n@@ -281,2 +277,3 @@\n-  enum RawBitsToken { RAW_BITS };\n-  relocInfo(relocType type, RawBitsToken ignore, int bits)\n+  static const enum class RawBitsToken {} RAW_BITS{};\n+\n+  relocInfo(relocType type, RawBitsToken, int bits)\n@@ -285,2 +282,8 @@\n-  relocInfo(relocType type, RawBitsToken ignore, int off, int f)\n-    : _value((type << nontype_width) + (off \/ (unsigned)offset_unit) + (f << offset_width)) { }\n+  static relocType check_relocType(relocType type) NOT_DEBUG({ return type; });\n+\n+  static void check_offset_and_format(int offset, int format) NOT_DEBUG_RETURN;\n+\n+  static int compute_bits(int offset, int format) {\n+    check_offset_and_format(offset, format);\n+    return (offset \/ offset_unit) + (format << offset_width);\n+  }\n@@ -289,1 +292,0 @@\n-  \/\/ constructor\n@@ -291,8 +293,1 @@\n-#ifndef ASSERT\n-  {\n-    (*this) = relocInfo(type, RAW_BITS, offset, format);\n-  }\n-#else\n-  \/\/ Put a bunch of assertions out-of-line.\n-  ;\n-#endif\n+    : relocInfo(check_relocType(type), RAW_BITS, compute_bits(offset, format)) {}\n@@ -379,1 +374,1 @@\n- protected:\n+ private:\n@@ -495,2 +490,2 @@\n-\/\/ It is a variable BoundRelocation which is able to take on successive\n-\/\/ values as it is advanced through a code stream.\n+\/\/ It provides access to successive relocations as it is advanced through a\n+\/\/ code stream.\n","filename":"src\/hotspot\/share\/code\/relocInfo.hpp","additions":17,"deletions":22,"binary":false,"changes":39,"status":"modified"}]}