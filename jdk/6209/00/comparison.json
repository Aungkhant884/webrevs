{"files":[{"patch":"@@ -1683,1 +1683,2 @@\n-            List<Type> coveredTypes = List.nil();\n+            List<Type> coveredTypesForPatterns = List.nil();\n+            List<Type> coveredTypesForConstants = List.nil();\n@@ -1721,1 +1722,1 @@\n-                                checkCaseLabelDominated(pat.pos(), coveredTypes, sym.type);\n+                                checkCaseLabelDominated(pat.pos(), coveredTypesForConstants, sym.type);\n@@ -1754,1 +1755,1 @@\n-                                    checkCaseLabelDominated(pat.pos(), coveredTypes, types.boxedTypeOrType(pattype));\n+                                    checkCaseLabelDominated(pat.pos(), coveredTypesForConstants, types.boxedTypeOrType(pattype));\n@@ -1787,3 +1788,6 @@\n-                        checkCaseLabelDominated(pat.pos(), coveredTypes, patternType);\n-                        if (primary.unconditional() && !patternType.isErroneous()) {\n-                            coveredTypes = coveredTypes.prepend(patternType);\n+                        checkCaseLabelDominated(pat.pos(), coveredTypesForPatterns, patternType);\n+                        if (!patternType.isErroneous()) {\n+                            coveredTypesForConstants = coveredTypesForConstants.prepend(patternType);\n+                            if (primary.unconditional()) {\n+                                coveredTypesForPatterns = coveredTypesForPatterns.prepend(patternType);\n+                            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -754,1 +754,1 @@\n-        private void transitiveCovers(Set<Symbol> covered) {\n+        private void transitiveCovers(Type seltype, Set<Symbol> covered) {\n@@ -776,1 +776,1 @@\n-                                if (isTransitivelyCovered(sup.tsym, covered) &&\n+                                if (isTransitivelyCovered(seltype, sup.tsym, covered) &&\n@@ -787,1 +787,1 @@\n-        private boolean isTransitivelyCovered(Symbol sealed, Set<Symbol> covered) {\n+        private boolean isTransitivelyCovered(Type seltype, Symbol sealed, Set<Symbol> covered) {\n@@ -796,1 +796,4 @@\n-                                                 .allMatch(s -> isTransitivelyCovered(s, covered));\n+                                                 .filter(s -> {\n+                                                     return types.isCastable(seltype, s.type\/*, types.noWarnings*\/);\n+                                                 })\n+                                                 .allMatch(s -> isTransitivelyCovered(seltype, s, covered));\n@@ -808,1 +811,1 @@\n-            transitiveCovers(covered);\n+            transitiveCovers(seltype, covered);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -71,0 +71,14 @@\n+    int testDominatesStringConstant2(String str) {\n+        switch (str) {\n+            case (String s && s.isEmpty()): return 1;\n+            case \"\": return -1;\n+        }\n+    }\n+\n+    int testDominatesStringConstant3(String str) {\n+        switch (str) {\n+            case (String s && !s.isEmpty()): return 1;\n+            case \"\": return -1;\n+        }\n+    }\n+\n@@ -78,0 +92,14 @@\n+    int testDominatesIntegerConstant2(Integer i) {\n+        switch (i) {\n+            case (Integer j && j == 0): return 1;\n+            case 0: return -1;\n+        }\n+    }\n+\n+    int testDominatesIntegerConstant3(Integer i) {\n+        switch (i) {\n+            case (Integer j && j == 1): return 1;\n+            case 0: return -1;\n+        }\n+    }\n+\n@@ -89,0 +117,22 @@\n+    int testDominatesEnumConstant2() {\n+        enum E {\n+            A, B;\n+        }\n+        E e = E.A;\n+        switch (e) {\n+            case (E d && d == E.A): return 1;\n+            case A: return -1;\n+        }\n+    }\n+\n+    int testDominatesEnumConstant3() {\n+        enum E {\n+            A, B;\n+        }\n+        E e = E.A;\n+        switch (e) {\n+            case (E d && d == E.B): return 1;\n+            case A: return -1;\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Domination.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -6,1 +6,7 @@\n-Domination.java:85:18: compiler.err.pattern.dominated\n+Domination.java:81:18: compiler.err.pattern.dominated\n+Domination.java:88:18: compiler.err.pattern.dominated\n+Domination.java:95:18: compiler.err.pattern.dominated\n+Domination.java:102:18: compiler.err.pattern.dominated\n+Domination.java:113:18: compiler.err.pattern.dominated\n+Domination.java:124:18: compiler.err.pattern.dominated\n+Domination.java:135:18: compiler.err.pattern.dominated\n@@ -9,1 +15,1 @@\n-6 errors\n+12 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/Domination.out","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-            case EnumTypeChangesEnum e1 && false -> throw new AssertionError();\n@@ -57,0 +56,1 @@\n+            case EnumTypeChangesEnum e1 && false -> throw new AssertionError();\n@@ -64,1 +64,0 @@\n-            case EnumTypeChangesEnum e1 && false -> throw new AssertionError();\n@@ -66,0 +65,1 @@\n+            case EnumTypeChangesEnum e1 && false -> throw new AssertionError();\n","filename":"test\/langtools\/tools\/javac\/patterns\/EnumTypeChanges.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -802,0 +802,88 @@\n+    @Test\n+    public void testOnlyApplicable(Path base) throws Exception {\n+        record TestCase(String cases, String... errors) {}\n+        TestCase[] subCases = new TestCase[] {\n+            new TestCase(\"\"\"\n+                                     case C3<Integer> c -> {}\n+                                     case C5<Integer, ?> c -> {}\n+                                     case C6<?, Integer> c -> {}\n+                         \"\"\"), \/\/OK\n+            new TestCase(\"\"\"\n+                                     case C5<Integer, ?> c -> {}\n+                                     case C6<?, Integer> c -> {}\n+                         \"\"\",\n+                         \"Test.java:11:9: compiler.err.not.exhaustive.statement\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                                     case C3<Integer> c -> {}\n+                                     case C6<?, Integer> c -> {}\n+                         \"\"\",\n+                         \"Test.java:11:9: compiler.err.not.exhaustive.statement\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                                     case C3<Integer> c -> {}\n+                                     case C5<Integer, ?> c -> {}\n+                         \"\"\",\n+                         \"Test.java:11:9: compiler.err.not.exhaustive.statement\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                                     case C1 c -> {}\n+                                     case C3<Integer> c -> {}\n+                                     case C5<Integer, ?> c -> {}\n+                                     case C6<?, Integer> c -> {}\n+                         \"\"\",\n+                         \"Test.java:12:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: test.Test.I<java.lang.Integer>, test.Test.C1)\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                                     case C2<?> c -> {}\n+                                     case C3<Integer> c -> {}\n+                                     case C5<Integer, ?> c -> {}\n+                                     case C6<?, Integer> c -> {}\n+                         \"\"\",\n+                         \"Test.java:12:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: test.Test.I<java.lang.Integer>, test.Test.C2<?>)\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                                     case C4<?, ?> c -> {}\n+                                     case C3<Integer> c -> {}\n+                                     case C5<Integer, ?> c -> {}\n+                                     case C6<?, Integer> c -> {}\n+                         \"\"\",\n+                         \"Test.java:12:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: test.Test.I<java.lang.Integer>, test.Test.C4<?,?>)\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+        };\n+        for (TestCase tc : subCases) {\n+            doTest(base,\n+                   new String[0],\n+                   \"\"\"\n+                   package test;\n+                   public class Test {\n+                       sealed interface I<T> {}\n+                       final class C1 implements I<String> {}\n+                       final class C2<T> implements I<String> {}\n+                       final class C3<T> implements I<T> {}\n+                       final class C4<T, E> implements I<String> {}\n+                       final class C5<T, E> implements I<T> {}\n+                       final class C6<T, E> implements I<E> {}\n+                       void t(I<Integer> i) {\n+                           switch (i) {\n+                   ${cases}\n+                           }\n+                       }\n+                   }\n+                   \"\"\".replace(\"${cases}\", tc.cases),\n+                   tc.errors);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -188,1 +188,10 @@\n-    void test8269146a(Integer i) {\n+    void test8269146a1(Integer i) {\n+        switch (i) {\n+            \/\/error - illegal combination of pattern and constant:\n+            case 1, Integer o && o != null:\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+    void test8269146a2(Integer i) {\n@@ -213,1 +222,8 @@\n-    void test8269301(Integer i) {\n+    void test8269301a(Integer i) {\n+        switch (i) {\n+            \/\/error - illegal combination of pattern, constant and default\n+            case 1, Integer o && o != null, default:\n+                break;\n+        }\n+    }\n+    void test8269301b(Integer i) {\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -34,6 +34,9 @@\n-SwitchErrors.java:191:42: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:200:24: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:209:29: compiler.err.total.pattern.and.default\n-SwitchErrors.java:216:42: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:216:45: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:228:18: compiler.err.duplicate.total.pattern\n+SwitchErrors.java:191:21: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:200:42: compiler.err.pattern.dominated\n+SwitchErrors.java:209:24: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:218:29: compiler.err.total.pattern.and.default\n+SwitchErrors.java:225:21: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:225:45: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:232:42: compiler.err.pattern.dominated\n+SwitchErrors.java:232:45: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:244:18: compiler.err.duplicate.total.pattern\n@@ -51,1 +54,1 @@\n-SwitchErrors.java:221:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:237:9: compiler.err.not.exhaustive.statement\n@@ -54,1 +57,1 @@\n-51 errors\n+54 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.out","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -268,1 +268,0 @@\n-            case E x && \"A\".equals(x.name()): return \"broken\";\n@@ -270,0 +269,1 @@\n+            case E x && \"A\".equals(x.name()): return \"broken\";\n@@ -278,1 +278,0 @@\n-            case E x && \"A\".equals(x.name()) -> \"broken\";\n@@ -280,0 +279,1 @@\n+            case E x && \"A\".equals(x.name()) -> \"broken\";\n@@ -289,2 +289,1 @@\n-            case C: return \"broken\";\n-            case null, E x: return String.valueOf(x);\n+            case null, E x: return e == E.C ? \"broken\" : String.valueOf(x);\n@@ -299,2 +298,1 @@\n-            case C -> \"broken\";\n-            case null, E x -> String.valueOf(x);\n+            case null, E x -> e == E.C ? \"broken\" : String.valueOf(x);\n@@ -309,2 +307,1 @@\n-            case C: return \"broken\";\n-            case null, E x: return String.valueOf(x);\n+            case null, E x: return e == E.C ? \"broken\" : String.valueOf(x);\n@@ -319,2 +316,1 @@\n-            case C -> \"broken\";\n-            case null, E x -> String.valueOf(x);\n+            case null, E x -> e == E.C ? \"broken\" : String.valueOf(x);\n@@ -329,2 +325,1 @@\n-            case C: return \"broken\";\n-            case null, E x: return String.valueOf(x);\n+            case null, E x: return e == E.C ? \"broken\" : String.valueOf(x);\n@@ -339,2 +334,1 @@\n-            case C -> \"broken\";\n-            case null, E x -> String.valueOf(x);\n+            case null, E x -> e == E.C ? \"broken\" : String.valueOf(x);\n@@ -349,2 +343,1 @@\n-            case \"C\": return \"broken\";\n-            case null, String x: return String.valueOf(x);\n+            case null, String x: return \"C\".equals(x) ? \"broken\" : String.valueOf(x);\n@@ -359,2 +352,1 @@\n-            case \"C\" -> \"broken\";\n-            case null, String x -> String.valueOf(x);\n+            case null, String x -> e == E.C ? \"broken\" : String.valueOf(x);\n@@ -369,2 +361,1 @@\n-            case 2: return \"broken\";\n-            case null, Integer x: return String.valueOf(x);\n+            case null, Integer x: return Objects.equals(x, 2) ? \"broken\" : String.valueOf(x);\n@@ -379,2 +370,1 @@\n-            case 2 -> \"broken\";\n-            case null, Integer x -> String.valueOf(x);\n+            case null, Integer x -> Objects.equals(x, 2) ? \"broken\" : String.valueOf(x);\n@@ -415,1 +405,0 @@\n-            case -1: r = 1;\n@@ -427,1 +416,0 @@\n-            case -1: r = 1;\n","filename":"test\/langtools\/tools\/javac\/patterns\/Switches.java","additions":12,"deletions":24,"binary":false,"changes":36,"status":"modified"}]}