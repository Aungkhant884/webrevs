{"files":[{"patch":"@@ -164,2 +164,1 @@\n-  _total_closed_heap_region_size(0),\n-  _total_open_heap_region_size(0),\n+  _total_heap_region_size(0),\n@@ -1054,30 +1053,23 @@\n-  \/\/ open and closed archive regions\n-  static void log_heap_regions(const char* which, GrowableArray<MemRegion> *regions) {\n-    for (int i = 0; i < regions->length(); i++) {\n-      address start = address(regions->at(i).start());\n-      address end = address(regions->at(i).end());\n-      log_region(which, start, end, to_requested(start));\n-\n-      while (start < end) {\n-        size_t byte_size;\n-        oop original_oop = ArchiveHeapWriter::buffered_addr_to_source_obj(start);\n-        if (original_oop != nullptr) {\n-          ResourceMark rm;\n-          log_info(cds, map)(PTR_FORMAT \": @@ Object %s\",\n-                             p2i(to_requested(start)), original_oop->klass()->external_name());\n-          byte_size = original_oop->size() * BytesPerWord;\n-        } else if (start == ArchiveHeapWriter::buffered_heap_roots_addr()) {\n-          \/\/ HeapShared::roots() is copied specially so it doesn't exist in\n-          \/\/ HeapShared::OriginalObjectTable. See HeapShared::copy_roots().\n-          log_info(cds, map)(PTR_FORMAT \": @@ Object HeapShared::roots (ObjArray)\",\n-                             p2i(to_requested(start)));\n-          byte_size = ArchiveHeapWriter::heap_roots_word_size() * BytesPerWord;\n-        } else {\n-          \/\/ We have reached the end of the region\n-          break;\n-        }\n-        address oop_end = start + byte_size;\n-        log_data(start, oop_end, to_requested(start), \/*is_heap=*\/true);\n-        start = oop_end;\n-      }\n-      if (start < end) {\n+  static void log_heap_region(ArchiveHeapInfo* heap_info) {\n+    MemRegion r = heap_info->memregion();\n+    address start = address(r.start());\n+    address end = address(r.end());\n+    log_region(\"heap\", start, end, to_requested(start));\n+\n+    while (start < end) {\n+      size_t byte_size;\n+      oop original_oop = ArchiveHeapWriter::buffered_addr_to_source_obj(start);\n+      if (original_oop != nullptr) {\n+        ResourceMark rm;\n+        log_info(cds, map)(PTR_FORMAT \": @@ Object %s\",\n+                           p2i(to_requested(start)), original_oop->klass()->external_name());\n+        byte_size = original_oop->size() * BytesPerWord;\n+      } else if (start == ArchiveHeapWriter::buffered_heap_roots_addr()) {\n+        \/\/ HeapShared::roots() is copied specially so it doesn't exist in\n+        \/\/ HeapShared::OriginalObjectTable. See HeapShared::copy_roots().\n+        log_info(cds, map)(PTR_FORMAT \": @@ Object HeapShared::roots (ObjArray)\",\n+                           p2i(to_requested(start)));\n+        byte_size = ArchiveHeapWriter::heap_roots_word_size() * BytesPerWord;\n+      } else {\n+        \/\/ We have reached the end of the region, but have some unused space\n+        \/\/ at the end.\n@@ -1087,0 +1079,1 @@\n+        break;\n@@ -1088,0 +1081,3 @@\n+      address oop_end = start + byte_size;\n+      log_data(start, oop_end, to_requested(start), \/*is_heap=*\/true);\n+      start = oop_end;\n@@ -1090,0 +1086,1 @@\n+\n@@ -1121,2 +1118,1 @@\n-                  GrowableArray<MemRegion> *closed_heap_regions,\n-                  GrowableArray<MemRegion> *open_heap_regions,\n+                  ArchiveHeapInfo* heap_info,\n@@ -1143,5 +1139,2 @@\n-    if (closed_heap_regions != nullptr) {\n-      log_heap_regions(\"closed heap region\", closed_heap_regions);\n-    }\n-    if (open_heap_regions != nullptr) {\n-      log_heap_regions(\"open heap region\", open_heap_regions);\n+    if (heap_info->is_used()) {\n+      log_heap_region(heap_info);\n@@ -1164,5 +1157,1 @@\n-void ArchiveBuilder::write_archive(FileMapInfo* mapinfo,\n-                                   GrowableArray<MemRegion>* closed_heap_regions,\n-                                   GrowableArray<MemRegion>* open_heap_regions,\n-                                   GrowableArray<ArchiveHeapBitmapInfo>* closed_heap_bitmaps,\n-                                   GrowableArray<ArchiveHeapBitmapInfo>* open_heap_bitmaps) {\n+void ArchiveBuilder::write_archive(FileMapInfo* mapinfo, ArchiveHeapInfo* heap_info) {\n@@ -1177,1 +1166,1 @@\n-  char* bitmap = mapinfo->write_bitmap_region(ArchivePtrMarker::ptrmap(), closed_heap_bitmaps, open_heap_bitmaps,\n+  char* bitmap = mapinfo->write_bitmap_region(ArchivePtrMarker::ptrmap(), heap_info,\n@@ -1180,11 +1169,2 @@\n-  if (closed_heap_regions != nullptr) {\n-    _total_closed_heap_region_size = mapinfo->write_heap_regions(\n-                                        closed_heap_regions,\n-                                        closed_heap_bitmaps,\n-                                        MetaspaceShared::first_closed_heap_region,\n-                                        MetaspaceShared::max_num_closed_heap_regions);\n-    _total_open_heap_region_size = mapinfo->write_heap_regions(\n-                                        open_heap_regions,\n-                                        open_heap_bitmaps,\n-                                        MetaspaceShared::first_open_heap_region,\n-                                        MetaspaceShared::max_num_open_heap_regions);\n+  if (heap_info->is_used()) {\n+    _total_heap_region_size = mapinfo->write_heap_region(heap_info);\n@@ -1193,1 +1173,1 @@\n-  print_region_stats(mapinfo, closed_heap_regions, open_heap_regions);\n+  print_region_stats(mapinfo, heap_info);\n@@ -1207,1 +1187,1 @@\n-    CDSMapLogger::log(this, mapinfo, closed_heap_regions, open_heap_regions,\n+    CDSMapLogger::log(this, mapinfo, heap_info,\n@@ -1218,3 +1198,1 @@\n-void ArchiveBuilder::print_region_stats(FileMapInfo *mapinfo,\n-                                        GrowableArray<MemRegion>* closed_heap_regions,\n-                                        GrowableArray<MemRegion>* open_heap_regions) {\n+void ArchiveBuilder::print_region_stats(FileMapInfo *mapinfo, ArchiveHeapInfo* heap_info) {\n@@ -1226,2 +1204,1 @@\n-                                _total_closed_heap_region_size +\n-                                _total_open_heap_region_size;\n+                                _total_heap_region_size;\n@@ -1230,2 +1207,1 @@\n-                             _total_closed_heap_region_size +\n-                             _total_open_heap_region_size;\n+                             _total_heap_region_size;\n@@ -1239,3 +1215,2 @@\n-  if (closed_heap_regions != nullptr) {\n-    print_heap_region_stats(closed_heap_regions, \"ca\", total_reserved);\n-    print_heap_region_stats(open_heap_regions, \"oa\", total_reserved);\n+  if (heap_info->is_used()) {\n+    print_heap_region_stats(heap_info, total_reserved);\n@@ -1244,1 +1219,1 @@\n-  log_debug(cds)(\"total    : \" SIZE_FORMAT_W(9) \" [100.0%% of total] out of \" SIZE_FORMAT_W(9) \" bytes [%5.1f%% used]\",\n+  log_debug(cds)(\"total   : \" SIZE_FORMAT_W(9) \" [100.0%% of total] out of \" SIZE_FORMAT_W(9) \" bytes [%5.1f%% used]\",\n@@ -1249,1 +1224,1 @@\n-  log_debug(cds)(\"bm  space: \" SIZE_FORMAT_W(9) \" [ %4.1f%% of total] out of \" SIZE_FORMAT_W(9) \" bytes [100.0%% used]\",\n+  log_debug(cds)(\"bm space: \" SIZE_FORMAT_W(9) \" [ %4.1f%% of total] out of \" SIZE_FORMAT_W(9) \" bytes [100.0%% used]\",\n@@ -1253,10 +1228,6 @@\n-void ArchiveBuilder::print_heap_region_stats(GrowableArray<MemRegion>* regions,\n-                                             const char *name, size_t total_size) {\n-  int arr_len = regions == nullptr ? 0 : regions->length();\n-  for (int i = 0; i < arr_len; i++) {\n-      char* start = (char*)regions->at(i).start();\n-      size_t size = regions->at(i).byte_size();\n-      char* top = start + size;\n-      log_debug(cds)(\"%s%d space: \" SIZE_FORMAT_W(9) \" [ %4.1f%% of total] out of \" SIZE_FORMAT_W(9) \" bytes [100.0%% used] at \" INTPTR_FORMAT,\n-                     name, i, size, size\/double(total_size)*100.0, size, p2i(start));\n-  }\n+void ArchiveBuilder::print_heap_region_stats(ArchiveHeapInfo *info, size_t total_size) {\n+  char* start = info->start();\n+  size_t size = info->byte_size();\n+  char* top = start + size;\n+  log_debug(cds)(\"hp space: \" SIZE_FORMAT_W(9) \" [ %4.1f%% of total] out of \" SIZE_FORMAT_W(9) \" bytes [100.0%% used] at \" INTPTR_FORMAT,\n+                     size, size\/double(total_size)*100.0, size, p2i(start));\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":51,"deletions":80,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-struct ArchiveHeapBitmapInfo;\n+class ArchiveHeapInfo;\n@@ -237,2 +237,1 @@\n-  size_t _total_closed_heap_region_size;\n-  size_t _total_open_heap_region_size;\n+  size_t _total_heap_region_size;\n@@ -240,3 +239,1 @@\n-  void print_region_stats(FileMapInfo *map_info,\n-                          GrowableArray<MemRegion>* closed_heap_regions,\n-                          GrowableArray<MemRegion>* open_heap_regions);\n+  void print_region_stats(FileMapInfo *map_info, ArchiveHeapInfo* heap_info);\n@@ -244,2 +241,1 @@\n-  void print_heap_region_stats(GrowableArray<MemRegion>* regions,\n-                               const char *name, size_t total_size);\n+  void print_heap_region_stats(ArchiveHeapInfo* heap_info, size_t total_size);\n@@ -406,5 +402,1 @@\n-  void write_archive(FileMapInfo* mapinfo,\n-                     GrowableArray<MemRegion>* closed_heap_regions,\n-                     GrowableArray<MemRegion>* open_heap_regions,\n-                     GrowableArray<ArchiveHeapBitmapInfo>* closed_heap_oopmaps,\n-                     GrowableArray<ArchiveHeapBitmapInfo>* open_heap_oopmaps);\n+  void write_archive(FileMapInfo* mapinfo, ArchiveHeapInfo* heap_info);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -41,2 +41,1 @@\n-bool ArchiveHeapLoader::_closed_regions_mapped = false;\n-bool ArchiveHeapLoader::_open_regions_mapped = false;\n+bool ArchiveHeapLoader::_is_mapped = false;\n@@ -52,9 +51,3 @@\n-uintptr_t ArchiveHeapLoader::_dumptime_base_0 = UINTPTR_MAX;\n-uintptr_t ArchiveHeapLoader::_dumptime_base_1 = UINTPTR_MAX;\n-uintptr_t ArchiveHeapLoader::_dumptime_base_2 = UINTPTR_MAX;\n-uintptr_t ArchiveHeapLoader::_dumptime_base_3 = UINTPTR_MAX;\n-uintptr_t ArchiveHeapLoader::_dumptime_top    = 0;\n-intx ArchiveHeapLoader::_runtime_offset_0 = 0;\n-intx ArchiveHeapLoader::_runtime_offset_1 = 0;\n-intx ArchiveHeapLoader::_runtime_offset_2 = 0;\n-intx ArchiveHeapLoader::_runtime_offset_3 = 0;\n+uintptr_t ArchiveHeapLoader::_dumptime_base = UINTPTR_MAX;\n+uintptr_t ArchiveHeapLoader::_dumptime_top = 0;\n+intx ArchiveHeapLoader::_runtime_offset = 0;\n@@ -87,1 +80,1 @@\n-void ArchiveHeapLoader::fixup_regions() {\n+void ArchiveHeapLoader::fixup_region() {\n@@ -90,1 +83,1 @@\n-    mapinfo->fixup_mapped_heap_regions();\n+    mapinfo->fixup_mapped_heap_region();\n@@ -163,1 +156,0 @@\n-                                                  FileMapRegion* map_region,\n@@ -165,1 +157,1 @@\n-  narrowOop dt_encoded_bottom = info->encoded_heap_region_dumptime_address(map_region);\n+  narrowOop dt_encoded_bottom = info->encoded_heap_region_dumptime_address();\n@@ -191,1 +183,0 @@\n-                                                FileMapRegion* map_region,\n@@ -203,1 +194,1 @@\n-    patch_compressed_embedded_pointers(bm, info, map_region, region);\n+    patch_compressed_embedded_pointers(bm, info, region);\n@@ -222,13 +213,0 @@\n-\n-  static int comparator(const void* a, const void* b) {\n-    LoadedArchiveHeapRegion* reg_a = (LoadedArchiveHeapRegion*)a;\n-    LoadedArchiveHeapRegion* reg_b = (LoadedArchiveHeapRegion*)b;\n-    if (reg_a->_dumptime_base < reg_b->_dumptime_base) {\n-      return -1;\n-    } else if (reg_a->_dumptime_base == reg_b->_dumptime_base) {\n-      return 0;\n-    } else {\n-      return 1;\n-    }\n-  }\n-\n@@ -240,20 +218,4 @@\n-void ArchiveHeapLoader::init_loaded_heap_relocation(LoadedArchiveHeapRegion* loaded_regions,\n-                                                    int num_loaded_regions) {\n-  _dumptime_base_0 = loaded_regions[0]._dumptime_base;\n-  _dumptime_base_1 = loaded_regions[1]._dumptime_base;\n-  _dumptime_base_2 = loaded_regions[2]._dumptime_base;\n-  _dumptime_base_3 = loaded_regions[3]._dumptime_base;\n-  _dumptime_top = loaded_regions[num_loaded_regions-1].top();\n-\n-  _runtime_offset_0 = loaded_regions[0]._runtime_offset;\n-  _runtime_offset_1 = loaded_regions[1]._runtime_offset;\n-  _runtime_offset_2 = loaded_regions[2]._runtime_offset;\n-  _runtime_offset_3 = loaded_regions[3]._runtime_offset;\n-\n-  assert(2 <= num_loaded_regions && num_loaded_regions <= 4, \"must be\");\n-  if (num_loaded_regions < 4) {\n-    _dumptime_base_3 = UINTPTR_MAX;\n-  }\n-  if (num_loaded_regions < 3) {\n-    _dumptime_base_2 = UINTPTR_MAX;\n-  }\n+void ArchiveHeapLoader::init_loaded_heap_relocation(LoadedArchiveHeapRegion* loaded_region) {\n+  _dumptime_base = loaded_region->_dumptime_base;\n+  _dumptime_top = loaded_region->top();\n+  _runtime_offset = loaded_region->_runtime_offset;\n@@ -270,2 +232,1 @@\n-template <int NUM_LOADED_REGIONS>\n-class PatchLoadedRegionPointers: public BitMapClosure {\n+class ArchiveHeapLoader::PatchLoadedRegionPointers: public BitMapClosure {\n@@ -273,8 +234,2 @@\n-  intx _offset_0;\n-  intx _offset_1;\n-  intx _offset_2;\n-  intx _offset_3;\n-  uintptr_t _base_0;\n-  uintptr_t _base_1;\n-  uintptr_t _base_2;\n-  uintptr_t _base_3;\n+  intx _offset;\n+  uintptr_t _base;\n@@ -283,4 +238,0 @@\n-  static_assert(MetaspaceShared::max_num_heap_regions == 4, \"can't handle more than 4 regions\");\n-  static_assert(NUM_LOADED_REGIONS >= 2, \"we have at least 2 loaded regions\");\n-  static_assert(NUM_LOADED_REGIONS <= 4, \"we have at most 4 loaded regions\");\n-\n@@ -288,1 +239,1 @@\n-  PatchLoadedRegionPointers(narrowOop* start, LoadedArchiveHeapRegion* loaded_regions)\n+  PatchLoadedRegionPointers(narrowOop* start, LoadedArchiveHeapRegion* loaded_region)\n@@ -290,10 +241,3 @@\n-      _offset_0(loaded_regions[0]._runtime_offset),\n-      _offset_1(loaded_regions[1]._runtime_offset),\n-      _offset_2(loaded_regions[2]._runtime_offset),\n-      _offset_3(loaded_regions[3]._runtime_offset),\n-      _base_0(loaded_regions[0]._dumptime_base),\n-      _base_1(loaded_regions[1]._dumptime_base),\n-      _base_2(loaded_regions[2]._dumptime_base),\n-      _base_3(loaded_regions[3]._dumptime_base) {\n-    _top = loaded_regions[NUM_LOADED_REGIONS-1].top();\n-  }\n+      _offset(loaded_region->_runtime_offset),\n+      _base(loaded_region->_dumptime_base),\n+      _top(loaded_region->top()) {}\n@@ -307,12 +251,3 @@\n-    assert(_base_0 <= o && o < _top, \"must be\");\n-\n-    \/\/ We usually have only 2 regions for the default archive. Use template to avoid unnecessary comparisons.\n-    if (NUM_LOADED_REGIONS > 3 && o >= _base_3) {\n-      o += _offset_3;\n-    } else if (NUM_LOADED_REGIONS > 2 && o >= _base_2) {\n-      o += _offset_2;\n-    } else if (o >= _base_1) {\n-      o += _offset_1;\n-    } else {\n-      o += _offset_0;\n-    }\n+    assert(_base <= o && o < _top, \"must be\");\n+\n+    o += _offset;\n@@ -325,1 +260,1 @@\n-int ArchiveHeapLoader::init_loaded_regions(FileMapInfo* mapinfo, LoadedArchiveHeapRegion* loaded_regions,\n+bool ArchiveHeapLoader::init_loaded_region(FileMapInfo* mapinfo, LoadedArchiveHeapRegion* loaded_region,\n@@ -328,13 +263,4 @@\n-  int num_loaded_regions = 0;\n-  for (int i = MetaspaceShared::first_archive_heap_region;\n-       i <= MetaspaceShared::last_archive_heap_region; i++) {\n-    FileMapRegion* r = mapinfo->region_at(i);\n-    r->assert_is_heap_region();\n-    if (r->used() > 0) {\n-      assert(is_aligned(r->used(), HeapWordSize), \"must be\");\n-      total_bytes += r->used();\n-      LoadedArchiveHeapRegion* ri = &loaded_regions[num_loaded_regions++];\n-      ri->_region_index = i;\n-      ri->_region_size = r->used();\n-      ri->_dumptime_base = (uintptr_t)mapinfo->heap_region_dumptime_address(r);\n-    }\n+  FileMapRegion* r = mapinfo->region_at(MetaspaceShared::hp);\n+  r->assert_is_heap_region();\n+  if (r->used() == 0) {\n+    return false;\n@@ -343,0 +269,6 @@\n+  assert(is_aligned(r->used(), HeapWordSize), \"must be\");\n+  total_bytes += r->used();\n+  loaded_region->_region_index = MetaspaceShared::hp;\n+  loaded_region->_region_size = r->used();\n+  loaded_region->_dumptime_base = (uintptr_t)mapinfo->heap_region_dumptime_address();\n+\n@@ -347,1 +279,1 @@\n-    return 0;\n+    return false;\n@@ -354,2 +286,1 @@\n-  return num_loaded_regions;\n-}\n+  loaded_region->_runtime_offset = _loaded_heap_bottom - loaded_region->_dumptime_base;\n@@ -357,15 +288,1 @@\n-void ArchiveHeapLoader::sort_loaded_regions(LoadedArchiveHeapRegion* loaded_regions, int num_loaded_regions,\n-                                            uintptr_t buffer) {\n-  \/\/ Find the relocation offset of the pointers in each region\n-  qsort(loaded_regions, num_loaded_regions, sizeof(LoadedArchiveHeapRegion),\n-        LoadedArchiveHeapRegion::comparator);\n-\n-  uintptr_t p = buffer;\n-  for (int i = 0; i < num_loaded_regions; i++) {\n-    \/\/ This region will be loaded at p, so all objects inside this\n-    \/\/ region will be shifted by ri->offset\n-    LoadedArchiveHeapRegion* ri = &loaded_regions[i];\n-    ri->_runtime_offset = p - ri->_dumptime_base;\n-    p += ri->_region_size;\n-  }\n-  assert(p == _loaded_heap_top, \"must be\");\n+  return true;\n@@ -374,2 +291,2 @@\n-bool ArchiveHeapLoader::load_regions(FileMapInfo* mapinfo, LoadedArchiveHeapRegion* loaded_regions,\n-                                     int num_loaded_regions, uintptr_t buffer) {\n+bool ArchiveHeapLoader::load_heap_region_impl(FileMapInfo* mapinfo, LoadedArchiveHeapRegion* loaded_region,\n+                                              uintptr_t load_address) {\n@@ -381,16 +298,0 @@\n-  uintptr_t load_address = buffer;\n-  for (int i = 0; i < num_loaded_regions; i++) {\n-    LoadedArchiveHeapRegion* ri = &loaded_regions[i];\n-    FileMapRegion* r = mapinfo->region_at(ri->_region_index);\n-\n-    if (!mapinfo->read_region(ri->_region_index, (char*)load_address, r->used(), \/* do_commit = *\/ false)) {\n-      \/\/ There's no easy way to free the buffer, so we will fill it with zero later\n-      \/\/ in fill_failed_loaded_heap(), and it will eventually be GC'ed.\n-      log_warning(cds)(\"Loading of heap region %d has failed. Archived objects are disabled\", i);\n-      _loading_failed = true;\n-      return false;\n-    }\n-    log_info(cds)(\"Loaded heap    region #%d at base \" INTPTR_FORMAT \" top \" INTPTR_FORMAT\n-                  \" size \" SIZE_FORMAT_W(6) \" delta \" INTX_FORMAT,\n-                  ri->_region_index, load_address, load_address + ri->_region_size,\n-                  ri->_region_size, ri->_runtime_offset);\n@@ -398,17 +299,7 @@\n-    uintptr_t oopmap = bitmap_base + r->oopmap_offset();\n-    BitMapView bm((BitMap::bm_word_t*)oopmap, r->oopmap_size_in_bits());\n-\n-    if (num_loaded_regions == 4) {\n-      PatchLoadedRegionPointers<4> patcher((narrowOop*)load_address, loaded_regions);\n-      bm.iterate(&patcher);\n-    } else if (num_loaded_regions == 3) {\n-      PatchLoadedRegionPointers<3> patcher((narrowOop*)load_address, loaded_regions);\n-      bm.iterate(&patcher);\n-    } else {\n-      assert(num_loaded_regions == 2, \"must be\");\n-      PatchLoadedRegionPointers<2> patcher((narrowOop*)load_address, loaded_regions);\n-      bm.iterate(&patcher);\n-    }\n-\n-    assert(r->mapped_base() == (char*)load_address, \"sanity\");\n-    load_address += r->used();\n+  FileMapRegion* r = mapinfo->region_at(loaded_region->_region_index);\n+  if (!mapinfo->read_region(loaded_region->_region_index, (char*)load_address, r->used(), \/* do_commit = *\/ false)) {\n+    \/\/ There's no easy way to free the buffer, so we will fill it with zero later\n+    \/\/ in fill_failed_loaded_heap(), and it will eventually be GC'ed.\n+    log_warning(cds)(\"Loading of heap region %d has failed. Archived objects are disabled\", loaded_region->_region_index);\n+    _loading_failed = true;\n+    return false;\n@@ -416,0 +307,8 @@\n+  assert(r->mapped_base() == (char*)load_address, \"sanity\");\n+  log_info(cds)(\"Loaded heap    region #%d at base \" INTPTR_FORMAT \" top \" INTPTR_FORMAT\n+                \" size \" SIZE_FORMAT_W(6) \" delta \" INTX_FORMAT,\n+                loaded_region->_region_index, load_address, load_address + loaded_region->_region_size,\n+                loaded_region->_region_size, loaded_region->_runtime_offset);\n+\n+  uintptr_t oopmap = bitmap_base + r->oopmap_offset();\n+  BitMapView bm((BitMap::bm_word_t*)oopmap, r->oopmap_size_in_bits());\n@@ -417,0 +316,2 @@\n+  PatchLoadedRegionPointers patcher((narrowOop*)load_address, loaded_region);\n+  bm.iterate(&patcher);\n@@ -420,1 +321,1 @@\n-bool ArchiveHeapLoader::load_heap_regions(FileMapInfo* mapinfo) {\n+bool ArchiveHeapLoader::load_heap_region(FileMapInfo* mapinfo) {\n@@ -424,2 +325,2 @@\n-  LoadedArchiveHeapRegion loaded_regions[MetaspaceShared::max_num_heap_regions];\n-  memset(loaded_regions, 0, sizeof(loaded_regions));\n+  LoadedArchiveHeapRegion loaded_region;\n+  memset(&loaded_region, 0, sizeof(loaded_region));\n@@ -428,2 +329,1 @@\n-  int num_loaded_regions = init_loaded_regions(mapinfo, loaded_regions, archive_space);\n-  if (num_loaded_regions <= 0) {\n+  if (!init_loaded_region(mapinfo, &loaded_region, archive_space)) {\n@@ -432,2 +332,2 @@\n-  sort_loaded_regions(loaded_regions, num_loaded_regions, (uintptr_t)archive_space.start());\n-  if (!load_regions(mapinfo, loaded_regions, num_loaded_regions, (uintptr_t)archive_space.start())) {\n+\n+  if (!load_heap_region_impl(mapinfo, &loaded_region, (uintptr_t)archive_space.start())) {\n@@ -438,1 +338,1 @@\n-  init_loaded_heap_relocation(loaded_regions, num_loaded_regions);\n+  init_loaded_heap_relocation(&loaded_region);\n@@ -451,2 +351,2 @@\n-    \/\/ This should be called before the loaded regions are modified, so all the embedded pointers\n-    \/\/ must be null, or must point to a valid object in the loaded regions.\n+    \/\/ This should be called before the loaded region is modified, so all the embedded pointers\n+    \/\/ must be null, or must point to a valid object in the loaded region.\n@@ -458,1 +358,1 @@\n-      guarantee(_table->contains(u), \"must point to beginning of object in loaded archived regions\");\n+      guarantee(_table->contains(u), \"must point to beginning of object in loaded archived region\");\n@@ -542,9 +442,6 @@\n-  for (int i = MetaspaceShared::first_archive_heap_region;\n-       i <= MetaspaceShared::last_archive_heap_region; i++) {\n-    FileMapRegion* r = FileMapInfo::current_info()->region_at(i);\n-    if (r->mapped_base() != nullptr && r->has_ptrmap()) {\n-      log_info(cds, heap)(\"Patching native pointers in heap region %d\", i);\n-      BitMapView bm = r->ptrmap_view();\n-      PatchNativePointers patcher((Metadata**)r->mapped_base());\n-      bm.iterate(&patcher);\n-    }\n+  FileMapRegion* r = FileMapInfo::current_info()->region_at(MetaspaceShared::hp);\n+  if (r->mapped_base() != nullptr && r->has_ptrmap()) {\n+    log_info(cds, heap)(\"Patching native pointers in heap region\");\n+    BitMapView bm = r->ptrmap_view();\n+    PatchNativePointers patcher((Metadata**)r->mapped_base());\n+    bm.iterate(&patcher);\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.cpp","additions":71,"deletions":174,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-  \/\/ At runtime, heap regions in the CDS archive can be used in two different ways,\n+  \/\/ At runtime, the heap region in the CDS archive can be used in two different ways,\n@@ -45,2 +45,2 @@\n-  \/\/ - Mapped: (G1 only) the regions are directly mapped into the Java heap\n-  \/\/ - Loaded: At VM start-up, the objects in the heap regions are copied into the\n+  \/\/ - Mapped: (G1 only) the region is directly mapped into the Java heap\n+  \/\/ - Loaded: At VM start-up, the objects in the heap region are copied into the\n@@ -51,1 +51,1 @@\n-  \/\/ Can this VM map archived heap regions? Currently only G1+compressed{oops,cp}\n+  \/\/ Can this VM map archived heap region? Currently only G1+compressed{oops,cp}\n@@ -56,3 +56,0 @@\n-  static bool is_mapped() {\n-    return closed_regions_mapped() && open_regions_mapped();\n-  }\n@@ -60,1 +57,1 @@\n-  \/\/ Can this VM load the objects from archived heap regions into the heap at start-up?\n+  \/\/ Can this VM load the objects from archived heap region into the heap at start-up?\n@@ -79,10 +76,2 @@\n-  static void set_closed_regions_mapped() {\n-    CDS_JAVA_HEAP_ONLY(_closed_regions_mapped = true;)\n-    NOT_CDS_JAVA_HEAP_RETURN;\n-  }\n-  static bool closed_regions_mapped() {\n-    CDS_JAVA_HEAP_ONLY(return _closed_regions_mapped;)\n-    NOT_CDS_JAVA_HEAP_RETURN_(false);\n-  }\n-  static void set_open_regions_mapped() {\n-    CDS_JAVA_HEAP_ONLY(_open_regions_mapped = true;)\n+  static void set_mapped() {\n+    CDS_JAVA_HEAP_ONLY(_is_mapped = true;)\n@@ -91,2 +80,2 @@\n-  static bool open_regions_mapped() {\n-    CDS_JAVA_HEAP_ONLY(return _open_regions_mapped;)\n+  static bool is_mapped() {\n+    CDS_JAVA_HEAP_ONLY(return _is_mapped;)\n@@ -97,1 +86,1 @@\n-  \/\/ than CompressedOops::{base,shift} -- see FileMapInfo::map_heap_regions_impl.\n+  \/\/ than CompressedOops::{base,shift} -- see FileMapInfo::map_heap_region_impl.\n@@ -107,1 +96,0 @@\n-                                                 FileMapRegion* map_region,\n@@ -111,1 +99,0 @@\n-                                      FileMapRegion* map_region,\n@@ -115,1 +102,1 @@\n-  static void fixup_regions() NOT_CDS_JAVA_HEAP_RETURN;\n+  static void fixup_region() NOT_CDS_JAVA_HEAP_RETURN;\n@@ -120,2 +107,1 @@\n-  static bool _closed_regions_mapped;\n-  static bool _open_regions_mapped;\n+  static bool _is_mapped;\n@@ -126,4 +112,1 @@\n-  static uintptr_t _dumptime_base_0;\n-  static uintptr_t _dumptime_base_1;\n-  static uintptr_t _dumptime_base_2;\n-  static uintptr_t _dumptime_base_3;\n+  static uintptr_t _dumptime_base;\n@@ -131,4 +114,1 @@\n-  static intx _runtime_offset_0;\n-  static intx _runtime_offset_1;\n-  static intx _runtime_offset_2;\n-  static intx _runtime_offset_3;\n+  static intx _runtime_offset;\n@@ -151,1 +131,1 @@\n-  static int init_loaded_regions(FileMapInfo* mapinfo, LoadedArchiveHeapRegion* loaded_regions,\n+  static bool init_loaded_region(FileMapInfo* mapinfo, LoadedArchiveHeapRegion* loaded_region,\n@@ -153,6 +133,2 @@\n-  static void sort_loaded_regions(LoadedArchiveHeapRegion* loaded_regions, int num_loaded_regions,\n-                                  uintptr_t buffer);\n-  static bool load_regions(FileMapInfo* mapinfo, LoadedArchiveHeapRegion* loaded_regions,\n-                           int num_loaded_regions, uintptr_t buffer);\n-  static void init_loaded_heap_relocation(LoadedArchiveHeapRegion* reloc_info,\n-                                          int num_loaded_regions);\n+  static bool load_heap_region_impl(FileMapInfo* mapinfo, LoadedArchiveHeapRegion* loaded_region, uintptr_t buffer);\n+  static void init_loaded_heap_relocation(LoadedArchiveHeapRegion* reloc_info);\n@@ -171,0 +147,2 @@\n+  class PatchLoadedRegionPointers;\n+\n@@ -173,1 +151,1 @@\n-  static bool load_heap_regions(FileMapInfo* mapinfo);\n+  static bool load_heap_region(FileMapInfo* mapinfo);\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.hpp","additions":20,"deletions":42,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,2 @@\n-    assert(_dumptime_base_0 == UINTPTR_MAX, \"must be\");\n-  } else if (p >= _dumptime_base_0) {\n+    assert(_dumptime_base == UINTPTR_MAX, \"must be\");\n+  } else if (p >= _dumptime_base) {\n@@ -44,9 +44,1 @@\n-    if (p >= _dumptime_base_3) {\n-      p += _runtime_offset_3;\n-    } else if (p >= _dumptime_base_2) {\n-      p += _runtime_offset_2;\n-    } else if (p >= _dumptime_base_1) {\n-      p += _runtime_offset_1;\n-    } else {\n-      p += _runtime_offset_0;\n-    }\n+    p += _runtime_offset;\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.inline.hpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-\n@@ -54,6 +53,2 @@\n-size_t ArchiveHeapWriter::_buffer_top;\n-size_t ArchiveHeapWriter::_open_bottom;\n-size_t ArchiveHeapWriter::_open_top;\n-size_t ArchiveHeapWriter::_closed_bottom;\n-size_t ArchiveHeapWriter::_closed_top;\n-size_t ArchiveHeapWriter::_heap_roots_bottom;\n+size_t ArchiveHeapWriter::_buffer_used;\n+size_t ArchiveHeapWriter::_heap_roots_bottom_offset;\n@@ -63,7 +58,2 @@\n-address ArchiveHeapWriter::_requested_open_region_bottom;\n-address ArchiveHeapWriter::_requested_open_region_top;\n-address ArchiveHeapWriter::_requested_closed_region_bottom;\n-address ArchiveHeapWriter::_requested_closed_region_top;\n-\n-ResourceBitMap* ArchiveHeapWriter::_closed_oopmap;\n-ResourceBitMap* ArchiveHeapWriter::_open_oopmap;\n+address ArchiveHeapWriter::_requested_bottom;\n+address ArchiveHeapWriter::_requested_top;\n@@ -83,4 +73,2 @@\n-    _requested_open_region_bottom = nullptr;\n-    _requested_open_region_top = nullptr;\n-    _requested_closed_region_bottom = nullptr;\n-    _requested_closed_region_top = nullptr;\n+    _requested_bottom = nullptr;\n+    _requested_top = nullptr;\n@@ -100,2 +88,0 @@\n-\/\/ For the time being, always support two regions (to be strictly compatible with existing G1\n-\/\/ mapping code. We might eventually use a single region (JDK-8298048).\n@@ -103,3 +89,1 @@\n-                              GrowableArray<MemRegion>* closed_regions, GrowableArray<MemRegion>* open_regions,\n-                              GrowableArray<ArchiveHeapBitmapInfo>* closed_bitmaps,\n-                              GrowableArray<ArchiveHeapBitmapInfo>* open_bitmaps) {\n+                              ArchiveHeapInfo* heap_info) {\n@@ -109,2 +93,2 @@\n-  set_requested_address_for_regions(closed_regions, open_regions);\n-  relocate_embedded_oops(roots, closed_bitmaps, open_bitmaps);\n+  set_requested_address(heap_info);\n+  relocate_embedded_oops(roots, heap_info);\n@@ -136,4 +120,2 @@\n-bool ArchiveHeapWriter::is_in_requested_regions(oop o) {\n-  assert(_requested_open_region_bottom != nullptr, \"do not call before this is initialized\");\n-  assert(_requested_closed_region_bottom != nullptr, \"do not call before this is initialized\");\n-\n+bool ArchiveHeapWriter::is_in_requested_range(oop o) {\n+  assert(_requested_bottom != nullptr, \"do not call before _requested_bottom is initialized\");\n@@ -141,2 +123,1 @@\n-  return (_requested_open_region_bottom <= a && a < _requested_open_region_top) ||\n-         (_requested_closed_region_bottom <= a && a < _requested_closed_region_top);\n+  return (_requested_bottom <= a && a < _requested_top);\n@@ -146,2 +127,2 @@\n-  oop req_obj = cast_to_oop(_requested_open_region_bottom + offset);\n-  assert(is_in_requested_regions(req_obj), \"must be\");\n+  oop req_obj = cast_to_oop(_requested_bottom + offset);\n+  assert(is_in_requested_range(req_obj), \"must be\");\n@@ -171,1 +152,1 @@\n-  return _requested_open_region_bottom + buffered_address_to_offset(buffered_addr);\n+  return _requested_bottom + buffered_address_to_offset(buffered_addr);\n@@ -175,1 +156,1 @@\n-  return requested_obj_from_buffer_offset(_heap_roots_bottom);\n+  return cast_to_oop(_requested_bottom + _heap_roots_bottom_offset);\n@@ -178,1 +159,1 @@\n-address ArchiveHeapWriter::heap_region_requested_bottom(int heap_region_idx) {\n+address ArchiveHeapWriter::requested_address() {\n@@ -180,9 +161,1 @@\n-  switch (heap_region_idx) {\n-  case MetaspaceShared::first_closed_heap_region:\n-    return _requested_closed_region_bottom;\n-  case MetaspaceShared::first_open_heap_region:\n-    return _requested_open_region_bottom;\n-  default:\n-    ShouldNotReachHere();\n-    return nullptr;\n-  }\n+  return _requested_bottom;\n@@ -194,1 +167,1 @@\n-  _open_bottom = _buffer_top = 0;\n+  _buffer_used = 0;\n@@ -206,1 +179,1 @@\n-  int length = roots != nullptr ? roots->length() : 0;\n+  int length = roots->length();\n@@ -216,2 +189,2 @@\n-  size_t new_top = _buffer_top + byte_size;\n-  ensure_buffer_space(new_top);\n+  size_t new_used = _buffer_used + byte_size;\n+  ensure_buffer_space(new_used);\n@@ -219,1 +192,1 @@\n-  HeapWord* mem = offset_to_buffered_address<HeapWord*>(_buffer_top);\n+  HeapWord* mem = offset_to_buffered_address<HeapWord*>(_buffer_used);\n@@ -241,1 +214,1 @@\n-  log_info(cds)(\"archived obj roots[%d] = \" SIZE_FORMAT \" bytes, klass = %p, obj = %p\", length, byte_size, k, mem);\n+  log_info(cds, heap)(\"archived obj roots[%d] = \" SIZE_FORMAT \" bytes, klass = %p, obj = %p\", length, byte_size, k, mem);\n@@ -243,2 +216,2 @@\n-  _heap_roots_bottom = _buffer_top;\n-  _buffer_top = new_top;\n+  _heap_roots_bottom_offset = _buffer_used;\n+  _buffer_used = new_used;\n@@ -248,14 +221,0 @@\n-  copy_source_objs_to_buffer_by_region(\/*copy_open_region=*\/true);\n-  copy_roots_to_buffer(roots);\n-  _open_top = _buffer_top;\n-\n-  \/\/ Align the closed region to the next G1 region\n-  _buffer_top = _closed_bottom = align_up(_buffer_top, HeapRegion::GrainBytes);\n-  copy_source_objs_to_buffer_by_region(\/*copy_open_region=*\/false);\n-  _closed_top = _buffer_top;\n-\n-  log_info(cds, heap)(\"Size of open region   = \" SIZE_FORMAT \" bytes\", _open_top   - _open_bottom);\n-  log_info(cds, heap)(\"Size of closed region = \" SIZE_FORMAT \" bytes\", _closed_top - _closed_bottom);\n-}\n-\n-void ArchiveHeapWriter::copy_source_objs_to_buffer_by_region(bool copy_open_region) {\n@@ -266,5 +225,2 @@\n-    if (info->in_open_region() == copy_open_region) {\n-      \/\/ For region-based collectors such as G1, we need to make sure that we don't have\n-      \/\/ an object that can possible span across two regions.\n-      size_t buffer_offset = copy_one_source_obj_to_buffer(src_obj);\n-      info->set_buffer_offset(buffer_offset);\n+    size_t buffer_offset = copy_one_source_obj_to_buffer(src_obj);\n+    info->set_buffer_offset(buffer_offset);\n@@ -272,2 +228,1 @@\n-      _buffer_offset_to_source_obj_table->put(buffer_offset, src_obj);\n-    }\n+    _buffer_offset_to_source_obj_table->put(buffer_offset, src_obj);\n@@ -275,0 +230,5 @@\n+\n+  copy_roots_to_buffer(roots);\n+\n+  log_info(cds)(\"Size of heap region = \" SIZE_FORMAT \" bytes, %d objects, %d roots\",\n+                _buffer_used, _source_objs->length() + 1, roots->length());\n@@ -301,1 +261,1 @@\n-  HeapWord* mem = offset_to_buffered_address<HeapWord*>(_buffer_top);\n+  HeapWord* mem = offset_to_buffered_address<HeapWord*>(_buffer_used);\n@@ -316,1 +276,1 @@\n-  size_t new_top = _buffer_top + required_byte_size + min_filler_byte_size;\n+  size_t new_used = _buffer_used + required_byte_size + min_filler_byte_size;\n@@ -318,2 +278,2 @@\n-  const size_t cur_min_region_bottom = align_down(_buffer_top, MIN_GC_REGION_ALIGNMENT);\n-  const size_t next_min_region_bottom = align_down(new_top, MIN_GC_REGION_ALIGNMENT);\n+  const size_t cur_min_region_bottom = align_down(_buffer_used, MIN_GC_REGION_ALIGNMENT);\n+  const size_t next_min_region_bottom = align_down(new_used, MIN_GC_REGION_ALIGNMENT);\n@@ -329,1 +289,1 @@\n-    const size_t fill_bytes = filler_end - _buffer_top;\n+    const size_t fill_bytes = filler_end - _buffer_used;\n@@ -335,1 +295,1 @@\n-                        array_length, fill_bytes, _buffer_top);\n+                        array_length, fill_bytes, _buffer_used);\n@@ -338,1 +298,1 @@\n-    _buffer_top = filler_end;\n+    _buffer_used = filler_end;\n@@ -347,0 +307,3 @@\n+  \/\/ For region-based collectors such as G1, the archive heap may be mapped into\n+  \/\/ multiple regions. We need to make sure that we don't have an object that can possible\n+  \/\/ span across two regions.\n@@ -349,2 +312,2 @@\n-  size_t new_top = _buffer_top + byte_size;\n-  assert(new_top > _buffer_top, \"no wrap around\");\n+  size_t new_used = _buffer_used + byte_size;\n+  assert(new_used > _buffer_used, \"no wrap around\");\n@@ -352,2 +315,2 @@\n-  size_t cur_min_region_bottom = align_down(_buffer_top, MIN_GC_REGION_ALIGNMENT);\n-  size_t next_min_region_bottom = align_down(new_top, MIN_GC_REGION_ALIGNMENT);\n+  size_t cur_min_region_bottom = align_down(_buffer_used, MIN_GC_REGION_ALIGNMENT);\n+  size_t next_min_region_bottom = align_down(new_used, MIN_GC_REGION_ALIGNMENT);\n@@ -356,1 +319,1 @@\n-  ensure_buffer_space(new_top);\n+  ensure_buffer_space(new_used);\n@@ -359,2 +322,2 @@\n-  address to = offset_to_buffered_address<address>(_buffer_top);\n-  assert(is_object_aligned(_buffer_top), \"sanity\");\n+  address to = offset_to_buffered_address<address>(_buffer_used);\n+  assert(is_object_aligned(_buffer_used), \"sanity\");\n@@ -364,2 +327,2 @@\n-  size_t buffered_obj_offset = _buffer_top;\n-  _buffer_top = new_top;\n+  size_t buffered_obj_offset = _buffer_used;\n+  _buffer_used = new_used;\n@@ -370,5 +333,2 @@\n-void ArchiveHeapWriter::set_requested_address_for_regions(GrowableArray<MemRegion>* closed_regions,\n-                                                          GrowableArray<MemRegion>* open_regions) {\n-  assert(closed_regions->length() == 0, \"must be\");\n-  assert(open_regions->length() == 0, \"must be\");\n-\n+void ArchiveHeapWriter::set_requested_address(ArchiveHeapInfo* info) {\n+  assert(!info->is_used(), \"only set once\");\n@@ -379,14 +339,2 @@\n-  size_t closed_region_byte_size = _closed_top - _closed_bottom;\n-  size_t open_region_byte_size = _open_top - _open_bottom;\n-  assert(closed_region_byte_size > 0, \"must archived at least one object for closed region!\");\n-  assert(open_region_byte_size > 0, \"must archived at least one object for open region!\");\n-\n-  \/\/ The following two asserts are ensured by copy_source_objs_to_buffer_by_region().\n-  assert(is_aligned(_closed_bottom, HeapRegion::GrainBytes), \"sanity\");\n-  assert(is_aligned(_open_bottom, HeapRegion::GrainBytes), \"sanity\");\n-\n-  _requested_closed_region_bottom = align_down(heap_end - closed_region_byte_size, HeapRegion::GrainBytes);\n-  _requested_open_region_bottom = _requested_closed_region_bottom - (_closed_bottom - _open_bottom);\n-\n-  assert(is_aligned(_requested_closed_region_bottom, HeapRegion::GrainBytes), \"sanity\");\n-  assert(is_aligned(_requested_open_region_bottom, HeapRegion::GrainBytes), \"sanity\");\n+  size_t heap_region_byte_size = _buffer_used;\n+  assert(heap_region_byte_size > 0, \"must archived at least one object!\");\n@@ -394,2 +342,2 @@\n-  _requested_open_region_top = _requested_open_region_bottom + (_open_top - _open_bottom);\n-  _requested_closed_region_top = _requested_closed_region_bottom + (_closed_top - _closed_bottom);\n+  _requested_bottom = align_down(heap_end - heap_region_byte_size, HeapRegion::GrainBytes);\n+  assert(is_aligned(_requested_bottom, HeapRegion::GrainBytes), \"sanity\");\n@@ -397,1 +345,1 @@\n-  assert(_requested_open_region_top <= _requested_closed_region_bottom, \"no overlap\");\n+  _requested_top = _requested_bottom + _buffer_used;\n@@ -399,4 +347,2 @@\n-  closed_regions->append(MemRegion(offset_to_buffered_address<HeapWord*>(_closed_bottom),\n-                                   offset_to_buffered_address<HeapWord*>(_closed_top)));\n-  open_regions->append(  MemRegion(offset_to_buffered_address<HeapWord*>(_open_bottom),\n-                                   offset_to_buffered_address<HeapWord*>(_open_top)));\n+  info->set_memregion(MemRegion(offset_to_buffered_address<HeapWord*>(0),\n+                                offset_to_buffered_address<HeapWord*>(_buffer_used)));\n@@ -408,1 +354,1 @@\n-  assert(is_in_requested_regions(cast_to_oop(p)), \"must be\");\n+  assert(is_in_requested_range(cast_to_oop(p)), \"must be\");\n@@ -411,2 +357,2 @@\n-  assert(addr >= _requested_open_region_bottom, \"must be\");\n-  size_t offset = addr - _requested_open_region_bottom;\n+  assert(addr >= _requested_bottom, \"must be\");\n+  size_t offset = addr - _requested_bottom;\n@@ -424,1 +370,1 @@\n-  assert(is_in_requested_regions(request_oop), \"must be\");\n+  assert(is_in_requested_range(request_oop), \"must be\");\n@@ -448,1 +394,1 @@\n-template <typename T> void ArchiveHeapWriter::relocate_field_in_buffer(T* field_addr_in_buffer) {\n+template <typename T> void ArchiveHeapWriter::relocate_field_in_buffer(T* field_addr_in_buffer, CHeapBitMap* oopmap) {\n@@ -453,1 +399,1 @@\n-    mark_oop_pointer<T>(field_addr_in_buffer);\n+    mark_oop_pointer<T>(field_addr_in_buffer, oopmap);\n@@ -457,1 +403,1 @@\n-template <typename T> void ArchiveHeapWriter::mark_oop_pointer(T* buffered_addr) {\n+template <typename T> void ArchiveHeapWriter::mark_oop_pointer(T* buffered_addr, CHeapBitMap* oopmap) {\n@@ -459,1 +405,0 @@\n-  ResourceBitMap* oopmap;\n@@ -462,10 +407,3 @@\n-  if (request_p >= (T*)_requested_closed_region_bottom) {\n-    assert(request_p < (T*)_requested_closed_region_top, \"sanity\");\n-    oopmap = _closed_oopmap;\n-    requested_region_bottom = _requested_closed_region_bottom;\n-  } else {\n-    assert(request_p >= (T*)_requested_open_region_bottom, \"sanity\");\n-    assert(request_p <  (T*)_requested_open_region_top, \"sanity\");\n-    oopmap = _open_oopmap;\n-    requested_region_bottom = _requested_open_region_bottom;\n-  }\n+  assert(request_p >= (T*)_requested_bottom, \"sanity\");\n+  assert(request_p <  (T*)_requested_top, \"sanity\");\n+  requested_region_bottom = _requested_bottom;\n@@ -504,1 +442,1 @@\n-template <typename T> void ArchiveHeapWriter::relocate_root_at(oop requested_roots, int index) {\n+template <typename T> void ArchiveHeapWriter::relocate_root_at(oop requested_roots, int index, CHeapBitMap* oopmap) {\n@@ -506,1 +444,1 @@\n-  relocate_field_in_buffer<T>((T*)(buffered_heap_roots_addr() + offset));\n+  relocate_field_in_buffer<T>((T*)(buffered_heap_roots_addr() + offset), oopmap);\n@@ -512,0 +450,1 @@\n+  CHeapBitMap* _oopmap;\n@@ -514,2 +453,2 @@\n-  EmbeddedOopRelocator(oop src_obj, address buffered_obj) :\n-    _src_obj(src_obj), _buffered_obj(buffered_obj) {}\n+  EmbeddedOopRelocator(oop src_obj, address buffered_obj, CHeapBitMap* oopmap) :\n+    _src_obj(src_obj), _buffered_obj(buffered_obj), _oopmap(oopmap) {}\n@@ -523,1 +462,1 @@\n-    ArchiveHeapWriter::relocate_field_in_buffer<T>((T*)(_buffered_obj + field_offset));\n+    ArchiveHeapWriter::relocate_field_in_buffer<T>((T*)(_buffered_obj + field_offset), _oopmap);\n@@ -529,2 +468,1 @@\n-                                               GrowableArray<ArchiveHeapBitmapInfo>* closed_bitmaps,\n-                                               GrowableArray<ArchiveHeapBitmapInfo>* open_bitmaps) {\n+                                               ArchiveHeapInfo* heap_info) {\n@@ -532,7 +470,2 @@\n-  size_t closed_region_byte_size = _closed_top - _closed_bottom;\n-  size_t open_region_byte_size   = _open_top   - _open_bottom;\n-  ResourceBitMap closed_oopmap(closed_region_byte_size \/ oopmap_unit);\n-  ResourceBitMap open_oopmap  (open_region_byte_size   \/ oopmap_unit);\n-\n-  _closed_oopmap = &closed_oopmap;\n-  _open_oopmap = &open_oopmap;\n+  size_t heap_region_byte_size = _buffer_used;\n+  heap_info->oopmap()->resize(heap_region_byte_size   \/ oopmap_unit);\n@@ -543,1 +476,0 @@\n-\n@@ -545,2 +477,1 @@\n-    EmbeddedOopRelocator relocator(src_obj, buffered_obj);\n-\n+    EmbeddedOopRelocator relocator(src_obj, buffered_obj, heap_info->oopmap());\n@@ -553,1 +484,1 @@\n-  oop requested_roots = requested_obj_from_buffer_offset(_heap_roots_bottom);\n+  oop requested_roots = requested_obj_from_buffer_offset(_heap_roots_bottom_offset);\n@@ -558,1 +489,1 @@\n-      relocate_root_at<narrowOop>(requested_roots, i);\n+      relocate_root_at<narrowOop>(requested_roots, i, heap_info->oopmap());\n@@ -560,1 +491,1 @@\n-      relocate_root_at<oop>(requested_roots, i);\n+      relocate_root_at<oop>(requested_roots, i, heap_info->oopmap());\n@@ -564,35 +495,1 @@\n-  closed_bitmaps->append(make_bitmap_info(&closed_oopmap, \/*is_open=*\/false, \/*is_oopmap=*\/true));\n-  open_bitmaps  ->append(make_bitmap_info(&open_oopmap,   \/*is_open=*\/false, \/*is_oopmap=*\/true));\n-\n-  closed_bitmaps->append(compute_ptrmap(\/*is_open=*\/false));\n-  open_bitmaps  ->append(compute_ptrmap(\/*is_open=*\/true));\n-\n-  _closed_oopmap = nullptr;\n-  _open_oopmap = nullptr;\n-}\n-\n-ArchiveHeapBitmapInfo ArchiveHeapWriter::make_bitmap_info(ResourceBitMap* bitmap, bool is_open,  bool is_oopmap) {\n-  size_t size_in_bits = bitmap->size();\n-  size_t size_in_bytes;\n-  uintptr_t* buffer;\n-\n-  if (size_in_bits > 0) {\n-    size_in_bytes = bitmap->size_in_bytes();\n-    buffer = (uintptr_t*)NEW_C_HEAP_ARRAY(char, size_in_bytes, mtInternal);\n-    bitmap->write_to(buffer, size_in_bytes);\n-  } else {\n-    size_in_bytes = 0;\n-    buffer = nullptr;\n-  }\n-\n-  log_info(cds, heap)(\"%s @ \" INTPTR_FORMAT \" (\" SIZE_FORMAT_W(6) \" bytes) for %s heap region\",\n-                      is_oopmap ? \"Oopmap\" : \"Ptrmap\",\n-                      p2i(buffer), size_in_bytes,\n-                      is_open? \"open\" : \"closed\");\n-\n-  ArchiveHeapBitmapInfo info;\n-  info._map = (address)buffer;\n-  info._size_in_bits = size_in_bits;\n-  info._size_in_bytes = size_in_bytes;\n-\n-  return info;\n+  compute_ptrmap(heap_info);\n@@ -611,1 +508,1 @@\n-ArchiveHeapBitmapInfo ArchiveHeapWriter::compute_ptrmap(bool is_open) {\n+void ArchiveHeapWriter::compute_ptrmap(ArchiveHeapInfo* heap_info) {\n@@ -613,3 +510,3 @@\n-  Metadata** bottom = (Metadata**) (is_open ? _requested_open_region_bottom: _requested_closed_region_bottom);\n-  Metadata** top = (Metadata**) (is_open ? _requested_open_region_top: _requested_closed_region_top); \/\/ exclusive\n-  ResourceBitMap ptrmap(top - bottom);\n+  Metadata** bottom = (Metadata**) _requested_bottom;\n+  Metadata** top = (Metadata**) _requested_top; \/\/ exclusive\n+  heap_info->ptrmap()->resize(top - bottom);\n@@ -617,0 +514,1 @@\n+  BitMap::idx_t max_idx = 32; \/\/ paranoid - don't make it too small\n@@ -622,22 +520,21 @@\n-    if (p->in_open_region() == is_open) {\n-      \/\/ requested_field_addr = the address of this field in the requested space\n-      oop requested_obj = requested_obj_from_buffer_offset(p->buffer_offset());\n-      Metadata** requested_field_addr = (Metadata**)(cast_from_oop<address>(requested_obj) + field_offset);\n-      assert(bottom <= requested_field_addr && requested_field_addr < top, \"range check\");\n-\n-      \/\/ Mark this field in the bitmap\n-      BitMap::idx_t idx = requested_field_addr - bottom;\n-      ptrmap.set_bit(idx);\n-      num_non_null_ptrs ++;\n-\n-      \/\/ Set the native pointer to the requested address of the metadata (at runtime, the metadata will have\n-      \/\/ this address if the RO\/RW regions are mapped at the default location).\n-\n-      Metadata** buffered_field_addr = requested_addr_to_buffered_addr(requested_field_addr);\n-      Metadata* native_ptr = *buffered_field_addr;\n-      assert(native_ptr != nullptr, \"sanity\");\n-\n-      address buffered_native_ptr = ArchiveBuilder::current()->get_buffered_addr((address)native_ptr);\n-      address requested_native_ptr = ArchiveBuilder::current()->to_requested(buffered_native_ptr);\n-      *buffered_field_addr = (Metadata*)requested_native_ptr;\n-    }\n+    \/\/ requested_field_addr = the address of this field in the requested space\n+    oop requested_obj = requested_obj_from_buffer_offset(p->buffer_offset());\n+    Metadata** requested_field_addr = (Metadata**)(cast_from_oop<address>(requested_obj) + field_offset);\n+    assert(bottom <= requested_field_addr && requested_field_addr < top, \"range check\");\n+\n+    \/\/ Mark this field in the bitmap\n+    BitMap::idx_t idx = requested_field_addr - bottom;\n+    heap_info->ptrmap()->set_bit(idx);\n+    num_non_null_ptrs ++;\n+    max_idx = MAX2(max_idx, idx);\n+\n+    \/\/ Set the native pointer to the requested address of the metadata (at runtime, the metadata will have\n+    \/\/ this address if the RO\/RW regions are mapped at the default location).\n+\n+    Metadata** buffered_field_addr = requested_addr_to_buffered_addr(requested_field_addr);\n+    Metadata* native_ptr = *buffered_field_addr;\n+    assert(native_ptr != nullptr, \"sanity\");\n+\n+    address buffered_native_ptr = ArchiveBuilder::current()->get_buffered_addr((address)native_ptr);\n+    address requested_native_ptr = ArchiveBuilder::current()->to_requested(buffered_native_ptr);\n+    *buffered_field_addr = (Metadata*)requested_native_ptr;\n@@ -646,9 +543,3 @@\n-  log_info(cds, heap)(\"compute_ptrmap: marked %d non-null native pointers for %s heap region\",\n-                      num_non_null_ptrs, is_open ? \"open\" : \"closed\");\n-\n-  if (num_non_null_ptrs == 0) {\n-    ResourceBitMap empty;\n-    return make_bitmap_info(&empty, is_open, \/*is_oopmap=*\/ false);\n-  } else {\n-    return make_bitmap_info(&ptrmap, is_open, \/*is_oopmap=*\/ false);\n-  }\n+  heap_info->ptrmap()->resize(max_idx + 1);\n+  log_info(cds, heap)(\"calculate_ptrmap: marked %d non-null native pointers for heap region (\" SIZE_FORMAT \" bits)\",\n+                      num_non_null_ptrs, size_t(heap_info->ptrmap()->size()));\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":115,"deletions":224,"binary":false,"changes":339,"status":"modified"},{"patch":"@@ -38,3 +38,0 @@\n-#if INCLUDE_CDS_JAVA_HEAP\n-\n-struct ArchiveHeapBitmapInfo;\n@@ -43,0 +40,20 @@\n+class ArchiveHeapInfo {\n+  MemRegion _memregion;\n+  CHeapBitMap _oopmap;\n+  CHeapBitMap _ptrmap;\n+\n+public:\n+  ArchiveHeapInfo() : _memregion(), _oopmap(128, mtClassShared), _ptrmap(128, mtClassShared) {}\n+  bool is_used() { return !_memregion.is_empty(); }\n+\n+  MemRegion memregion() { return _memregion; }\n+  void set_memregion(MemRegion r) { _memregion = r; }\n+\n+  char* start() { return (char*)_memregion.start(); }\n+  size_t byte_size() { return _memregion.byte_size();    }\n+\n+  CHeapBitMap* oopmap() { return &_oopmap; }\n+  CHeapBitMap* ptrmap() { return &_ptrmap; }\n+};\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n@@ -75,10 +92,2 @@\n-  \/\/ The exclusive top of the last object that has been copied into this->_buffer.\n-  static size_t _buffer_top;\n-\n-  \/\/ The bounds of the open region inside this->_buffer.\n-  static size_t _open_bottom;  \/\/ inclusive\n-  static size_t _open_top;     \/\/ exclusive\n-\n-  \/\/ The bounds of the closed region inside this->_buffer.\n-  static size_t _closed_bottom;  \/\/ inclusive\n-  static size_t _closed_top;     \/\/ exclusive\n+  \/\/ The number of bytes that have written into _buffer (may be smaller than _buffer->length()).\n+  static size_t _buffer_used;\n@@ -87,1 +96,1 @@\n-  static size_t _heap_roots_bottom;\n+  static size_t _heap_roots_bottom_offset;\n@@ -90,10 +99,3 @@\n-  static address _requested_open_region_bottom;\n-  static address _requested_open_region_top;\n-  static address _requested_closed_region_bottom;\n-  static address _requested_closed_region_top;\n-\n-  static ResourceBitMap* _closed_oopmap;\n-  static ResourceBitMap* _open_oopmap;\n-\n-  static ArchiveHeapBitmapInfo _closed_oopmap_info;\n-  static ArchiveHeapBitmapInfo _open_oopmap_info;\n+  \/\/ The address range of the requested location of the archived heap objects.\n+  static address _requested_bottom;\n+  static address _requested_top;\n@@ -130,0 +132,1 @@\n+  \/\/ The exclusive end of the last object that was copied into the buffer.\n@@ -131,1 +134,1 @@\n-    return buffer_bottom() + _buffer_top;\n+    return buffer_bottom() + _buffer_used;\n@@ -145,1 +148,0 @@\n-  static void copy_source_objs_to_buffer_by_region(bool copy_open_region);\n@@ -153,8 +155,4 @@\n-  static void set_requested_address_for_regions(GrowableArray<MemRegion>* closed_regions,\n-                                                GrowableArray<MemRegion>* open_regions);\n-  static void relocate_embedded_oops(GrowableArrayCHeap<oop, mtClassShared>* roots,\n-                                     GrowableArray<ArchiveHeapBitmapInfo>* closed_bitmaps,\n-                                     GrowableArray<ArchiveHeapBitmapInfo>* open_bitmaps);\n-  static ArchiveHeapBitmapInfo compute_ptrmap(bool is_open);\n-  static ArchiveHeapBitmapInfo make_bitmap_info(ResourceBitMap* bitmap, bool is_open,  bool is_oopmap);\n-  static bool is_in_requested_regions(oop o);\n+  static void set_requested_address(ArchiveHeapInfo* info);\n+  static void relocate_embedded_oops(GrowableArrayCHeap<oop, mtClassShared>* roots, ArchiveHeapInfo* info);\n+  static void compute_ptrmap(ArchiveHeapInfo *info);\n+  static bool is_in_requested_range(oop o);\n@@ -172,3 +170,3 @@\n-  template <typename T> static void relocate_field_in_buffer(T* field_addr_in_buffer);\n-  template <typename T> static void mark_oop_pointer(T* buffered_addr);\n-  template <typename T> static void relocate_root_at(oop requested_roots, int index);\n+  template <typename T> static void relocate_field_in_buffer(T* field_addr_in_buffer, CHeapBitMap* oopmap);\n+  template <typename T> static void mark_oop_pointer(T* buffered_addr, CHeapBitMap* oopmap);\n+  template <typename T> static void relocate_root_at(oop requested_roots, int index, CHeapBitMap* oopmap);\n@@ -183,6 +181,3 @@\n-  static void write(GrowableArrayCHeap<oop, mtClassShared>*,\n-                    GrowableArray<MemRegion>* closed_regions, GrowableArray<MemRegion>* open_regions,\n-                    GrowableArray<ArchiveHeapBitmapInfo>* closed_bitmaps,\n-                    GrowableArray<ArchiveHeapBitmapInfo>* open_bitmaps);\n-  static address heap_region_requested_bottom(int heap_region_idx);\n-  static oop heap_roots_requested_address();\n+  static void write(GrowableArrayCHeap<oop, mtClassShared>*, ArchiveHeapInfo* heap_info);\n+  static address requested_address();  \/\/ requested address of the lowest achived heap object\n+  static oop heap_roots_requested_address(); \/\/ requested address of HeapShared::roots()\n@@ -190,1 +185,1 @@\n-    return offset_to_buffered_address<address>(_heap_roots_bottom);\n+    return offset_to_buffered_address<address>(_heap_roots_bottom_offset);\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.hpp","additions":39,"deletions":44,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-  log_debug(cds)(\"%-3s space: \" SIZE_FORMAT_W(9) \" [ %4.1f%% of total] out of \" SIZE_FORMAT_W(9) \" bytes [%5.1f%% used] at \" INTPTR_FORMAT,\n+  log_debug(cds)(\"%s space: \" SIZE_FORMAT_W(9) \" [ %4.1f%% of total] out of \" SIZE_FORMAT_W(9) \" bytes [%5.1f%% used] at \" INTPTR_FORMAT,\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-  msg.debug(\"Detailed metadata info (excluding heap regions):\");\n+  msg.debug(\"Detailed metadata info (excluding heap region):\");\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/archiveHeapWriter.hpp\"\n@@ -326,1 +327,2 @@\n-  ArchiveBuilder::write_archive(dynamic_info, nullptr, nullptr, nullptr, nullptr);\n+  ArchiveHeapInfo no_heap_for_dynamic_dump;\n+  ArchiveBuilder::write_archive(dynamic_info, &no_heap_for_dynamic_dump);\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1416,1 +1416,1 @@\n-  for (int i = 0; i <= MetaspaceShared::last_valid_region; i++) {\n+  for (int i = 0; i < MetaspaceShared::n_regions; i++) {\n@@ -1518,3 +1518,4 @@\n-void FileMapRegion::init_bitmaps(ArchiveHeapBitmapInfo oopmap, ArchiveHeapBitmapInfo ptrmap) {\n-  _oopmap_offset = oopmap._bm_region_offset;\n-  _oopmap_size_in_bits = oopmap._size_in_bits;\n+void FileMapRegion::init_oopmap(size_t offset, size_t size_in_bits) {\n+  _oopmap_offset = offset;\n+  _oopmap_size_in_bits = size_in_bits;\n+}\n@@ -1522,2 +1523,3 @@\n-  _ptrmap_offset = ptrmap._bm_region_offset;\n-  _ptrmap_size_in_bits = ptrmap._size_in_bits;\n+void FileMapRegion::init_ptrmap(size_t offset, size_t size_in_bits) {\n+  _ptrmap_offset = offset;\n+  _ptrmap_size_in_bits = size_in_bits;\n@@ -1562,1 +1564,1 @@\n-    \"rw\", \"ro\", \"bm\", \"ca0\", \"ca1\", \"oa0\", \"oa1\"\n+    \"rw\", \"ro\", \"bm\", \"hp\"\n@@ -1603,1 +1605,1 @@\n-    requested_base = (char*)ArchiveHeapWriter::heap_region_requested_bottom(region);\n+    requested_base = (char*)ArchiveHeapWriter::requested_address();\n@@ -1623,1 +1625,1 @@\n-    log_info(cds)(\"Shared file region (%-3s)  %d: \" SIZE_FORMAT_W(8)\n+    log_info(cds)(\"Shared file region (%s) %d: \" SIZE_FORMAT_W(8)\n@@ -1636,6 +1638,4 @@\n-size_t FileMapInfo::set_bitmaps_offset(GrowableArray<ArchiveHeapBitmapInfo>* bitmaps, size_t curr_size) {\n-  for (int i = 0; i < bitmaps->length(); i++) {\n-    bitmaps->at(i)._bm_region_offset = curr_size;\n-    curr_size += bitmaps->at(i)._size_in_bytes;\n-  }\n-  return curr_size;\n+static size_t write_bitmap(const CHeapBitMap* map, char* output, size_t offset) {\n+  size_t size_in_bytes = map->size_in_bytes();\n+  map->write_to((BitMap::bm_word_t*)(output + offset), size_in_bytes);\n+  return offset + size_in_bytes;\n@@ -1644,11 +1644,1 @@\n-size_t FileMapInfo::write_bitmaps(GrowableArray<ArchiveHeapBitmapInfo>* bitmaps, size_t curr_offset, char* buffer) {\n-  for (int i = 0; i < bitmaps->length(); i++) {\n-    memcpy(buffer + curr_offset, bitmaps->at(i)._map, bitmaps->at(i)._size_in_bytes);\n-    curr_offset += bitmaps->at(i)._size_in_bytes;\n-  }\n-  return curr_offset;\n-}\n-\n-char* FileMapInfo::write_bitmap_region(const CHeapBitMap* ptrmap,\n-                                       GrowableArray<ArchiveHeapBitmapInfo>* closed_bitmaps,\n-                                       GrowableArray<ArchiveHeapBitmapInfo>* open_bitmaps,\n+char* FileMapInfo::write_bitmap_region(const CHeapBitMap* ptrmap, ArchiveHeapInfo* heap_info,\n@@ -1656,1 +1646,0 @@\n-  size_t size_in_bits = ptrmap->size();\n@@ -1659,3 +1648,3 @@\n-  if (closed_bitmaps != nullptr && open_bitmaps != nullptr) {\n-    size_in_bytes = set_bitmaps_offset(closed_bitmaps, size_in_bytes);\n-    size_in_bytes = set_bitmaps_offset(open_bitmaps, size_in_bytes);\n+  if (heap_info->is_used()) {\n+    size_in_bytes += heap_info->oopmap()->size_in_bytes();\n+    size_in_bytes += heap_info->ptrmap()->size_in_bytes();\n@@ -1664,0 +1653,4 @@\n+  \/\/ The bitmap region contains up to 3 parts:\n+  \/\/ ptrmap:              metaspace pointers inside the ro\/rw regions\n+  \/\/ heap_info->oopmap(): Java oop pointers in the heap region\n+  \/\/ heap_info->ptrmap(): metaspace pointers in the heap region\n@@ -1665,2 +1658,9 @@\n-  ptrmap->write_to((BitMap::bm_word_t*)buffer, ptrmap->size_in_bytes());\n-  header()->set_ptrmap_size_in_bits(size_in_bits);\n+  size_t written = 0;\n+  written = write_bitmap(ptrmap, buffer, written);\n+  header()->set_ptrmap_size_in_bits(ptrmap->size());\n+\n+  if (heap_info->is_used()) {\n+    FileMapRegion* r = region_at(MetaspaceShared::hp);\n+\n+    r->init_oopmap(written, heap_info->oopmap()->size());\n+    written = write_bitmap(heap_info->oopmap(), buffer, written);\n@@ -1668,3 +1668,2 @@\n-  if (closed_bitmaps != nullptr && open_bitmaps != nullptr) {\n-    size_t curr_offset = write_bitmaps(closed_bitmaps, ptrmap->size_in_bytes(), buffer);\n-    write_bitmaps(open_bitmaps, curr_offset, buffer);\n+    r->init_ptrmap(written, heap_info->ptrmap()->size());\n+    written = write_bitmap(heap_info->ptrmap(), buffer, written);\n@@ -1677,66 +1676,5 @@\n-\/\/ Write out the given archive heap memory regions.  GC code combines multiple\n-\/\/ consecutive archive GC regions into one MemRegion whenever possible and\n-\/\/ produces the 'regions' array.\n-\/\/\n-\/\/ If the archive heap memory size is smaller than a single dump time GC region\n-\/\/ size, there is only one MemRegion in the array.\n-\/\/\n-\/\/ If the archive heap memory size is bigger than one dump time GC region size,\n-\/\/ the 'regions' array may contain more than one consolidated MemRegions. When\n-\/\/ the first\/bottom archive GC region is a partial GC region (with the empty\n-\/\/ portion at the higher address within the region), one MemRegion is used for\n-\/\/ the bottom partial archive GC region. The rest of the consecutive archive\n-\/\/ GC regions are combined into another MemRegion.\n-\/\/\n-\/\/ Here's the mapping from (archive heap GC regions) -> (GrowableArray<MemRegion> *regions).\n-\/\/   + We have 1 or more archive heap regions: ah0, ah1, ah2 ..... ahn\n-\/\/   + We have 1 or 2 consolidated heap memory regions: r0 and r1\n-\/\/\n-\/\/ If there's a single archive GC region (ah0), then r0 == ah0, and r1 is empty.\n-\/\/ Otherwise:\n-\/\/\n-\/\/ \"X\" represented space that's occupied by heap objects.\n-\/\/ \"_\" represented unused spaced in the heap region.\n-\/\/\n-\/\/\n-\/\/    |ah0       | ah1 | ah2| ...... | ahn|\n-\/\/    |XXXXXX|__ |XXXXX|XXXX|XXXXXXXX|XXXX|\n-\/\/    |<-r0->|   |<- r1 ----------------->|\n-\/\/            ^^^\n-\/\/             |\n-\/\/             +-- gap\n-size_t FileMapInfo::write_heap_regions(GrowableArray<MemRegion>* regions,\n-                                       GrowableArray<ArchiveHeapBitmapInfo>* bitmaps,\n-                                       int first_region_id, int max_num_regions) {\n-  assert(max_num_regions <= 2, \"Only support maximum 2 memory regions\");\n-\n-  int arr_len = regions == nullptr ? 0 : regions->length();\n-  if (arr_len > max_num_regions) {\n-    log_error(cds)(\"Unable to write archive heap memory regions: \"\n-                   \"number of memory regions exceeds maximum due to fragmentation. \"\n-                   \"Please increase java heap size \"\n-                   \"(current MaxHeapSize is \" SIZE_FORMAT \", InitialHeapSize is \" SIZE_FORMAT \").\",\n-                   MaxHeapSize, InitialHeapSize);\n-    MetaspaceShared::unrecoverable_writing_error();\n-  }\n-\n-  size_t total_size = 0;\n-  for (int i = 0; i < max_num_regions; i++) {\n-    char* start = nullptr;\n-    size_t size = 0;\n-    if (i < arr_len) {\n-      start = (char*)regions->at(i).start();\n-      size = regions->at(i).byte_size();\n-      total_size += size;\n-    }\n-\n-    int region_idx = i + first_region_id;\n-    write_region(region_idx, start, size, false, false);\n-    if (size > 0) {\n-      int oopmap_idx = i * 2;\n-      int ptrmap_idx = i * 2 + 1;\n-      region_at(region_idx)->init_bitmaps(bitmaps->at(oopmap_idx),\n-                                          bitmaps->at(ptrmap_idx));\n-    }\n-  }\n-  return total_size;\n+size_t FileMapInfo::write_heap_region(ArchiveHeapInfo* heap_info) {\n+  char* start = heap_info->start();\n+  size_t size = heap_info->byte_size();\n+  write_region(MetaspaceShared::hp, start, size, false, false);\n+  return size;\n@@ -1835,2 +1773,1 @@\n-static const char* shared_region_name[] = { \"ReadWrite\", \"ReadOnly\", \"Bitmap\",\n-                                            \"String1\", \"String2\", \"OpenArchive1\", \"OpenArchive2\" };\n+static const char* shared_region_name[] = { \"ReadWrite\", \"ReadOnly\", \"Bitmap\", \"Heap\" };\n@@ -2057,5 +1994,0 @@\n-static MemRegion *closed_heap_regions = nullptr;\n-static MemRegion *open_heap_regions = nullptr;\n-static int num_closed_heap_regions = 0;\n-static int num_open_heap_regions = 0;\n-\n@@ -2063,2 +1995,4 @@\n-bool FileMapInfo::has_heap_regions() {\n-  return (region_at(MetaspaceShared::first_closed_heap_region)->used() > 0);\n+MemRegion FileMapInfo::_mapped_heap_memregion;\n+\n+bool FileMapInfo::has_heap_region() {\n+  return (region_at(MetaspaceShared::hp)->used() > 0);\n@@ -2067,1 +2001,1 @@\n-\/\/ Returns the address range of the archived heap regions computed using the\n+\/\/ Returns the address range of the archived heap region computed using the\n@@ -2071,3 +2005,4 @@\n-MemRegion FileMapInfo::get_heap_regions_requested_range() {\n-  address start = (address) max_uintx;\n-  address end   = nullptr;\n+MemRegion FileMapInfo::get_heap_region_requested_range() {\n+  FileMapRegion* r = region_at(MetaspaceShared::hp);\n+  size_t size = r->used();\n+  assert(size > 0, \"must have non-empty heap region\");\n@@ -2075,22 +2010,4 @@\n-  for (int i = MetaspaceShared::first_closed_heap_region;\n-           i <= MetaspaceShared::last_valid_region;\n-           i++) {\n-    FileMapRegion* r = region_at(i);\n-    size_t size = r->used();\n-    if (size > 0) {\n-      address s = heap_region_requested_address(r);\n-      address e = s + size;\n-      log_info(cds)(\"Heap region %s = \" INTPTR_FORMAT \" - \" INTPTR_FORMAT \" = \"  SIZE_FORMAT_W(8) \" bytes\",\n-                    region_name(i), p2i(s), p2i(e), size);\n-      if (start > s) {\n-        start = s;\n-      }\n-      if (end < e) {\n-        end = e;\n-      }\n-    }\n-  }\n-  assert(end != nullptr, \"must have at least one used heap region\");\n-\n-  start = align_down(start, HeapRegion::GrainBytes);\n-  end = align_up(end, HeapRegion::GrainBytes);\n+  address start = heap_region_requested_address();\n+  address end = start + size;\n+  log_info(cds)(\"Requested heap region [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"] = \"  SIZE_FORMAT_W(8) \" bytes\",\n+                p2i(start), p2i(end), size);\n@@ -2101,1 +2018,1 @@\n-void FileMapInfo::map_or_load_heap_regions() {\n+void FileMapInfo::map_or_load_heap_region() {\n@@ -2104,1 +2021,1 @@\n-  if (can_use_heap_regions()) {\n+  if (can_use_heap_region()) {\n@@ -2106,1 +2023,1 @@\n-      success = map_heap_regions();\n+      success = map_heap_region();\n@@ -2108,1 +2025,1 @@\n-      success = ArchiveHeapLoader::load_heap_regions(this);\n+      success = ArchiveHeapLoader::load_heap_region(this);\n@@ -2124,2 +2041,2 @@\n-bool FileMapInfo::can_use_heap_regions() {\n-  if (!has_heap_regions()) {\n+bool FileMapInfo::can_use_heap_region() {\n+  if (!has_heap_region()) {\n@@ -2171,1 +2088,2 @@\n-address FileMapInfo::heap_region_dumptime_address(FileMapRegion* r) {\n+address FileMapInfo::heap_region_dumptime_address() {\n+  FileMapRegion* r = region_at(MetaspaceShared::hp);\n@@ -2173,1 +2091,0 @@\n-  r->assert_is_heap_region();\n@@ -2178,1 +2095,1 @@\n-    return heap_region_requested_address(r);\n+    return heap_region_requested_address();\n@@ -2184,1 +2101,1 @@\n-address FileMapInfo::heap_region_requested_address(FileMapRegion* r) {\n+address FileMapInfo::heap_region_requested_address() {\n@@ -2186,1 +2103,1 @@\n-  r->assert_is_heap_region();\n+  FileMapRegion* r = region_at(MetaspaceShared::hp);\n@@ -2212,1 +2129,1 @@\n-address FileMapInfo::heap_region_mapped_address(FileMapRegion* r) {\n+address FileMapInfo::heap_region_mapped_address() {\n@@ -2214,1 +2131,0 @@\n-  r->assert_is_heap_region();\n@@ -2216,1 +2132,1 @@\n-  return heap_region_requested_address(r) + ArchiveHeapLoader::mapped_heap_delta();\n+  return heap_region_requested_address() + ArchiveHeapLoader::mapped_heap_delta();\n@@ -2219,16 +2135,38 @@\n-\/\/\n-\/\/ Map the closed and open archive heap objects to the runtime java heap.\n-\/\/\n-\/\/ The shared objects are mapped at (or close to ) the java heap top in\n-\/\/ closed archive regions. The mapped objects contain no out-going\n-\/\/ references to any other java heap regions. GC does not write into the\n-\/\/ mapped closed archive heap region.\n-\/\/\n-\/\/ The open archive heap objects are mapped below the shared objects in\n-\/\/ the runtime java heap. The mapped open archive heap data only contains\n-\/\/ references to the shared objects and open archive objects initially.\n-\/\/ During runtime execution, out-going references to any other java heap\n-\/\/ regions may be added. GC may mark and update references in the mapped\n-\/\/ open archive objects.\n-void FileMapInfo::map_heap_regions_impl() {\n-  \/\/ G1 -- always map at the very top of the heap to avoid fragmentation.\n+bool FileMapInfo::map_heap_region() {\n+  init_heap_region_relocation();\n+\n+  if (_heap_pointers_need_patching) {\n+    char* bitmap_base = map_bitmap_region();\n+    if (bitmap_base == nullptr) {\n+      log_info(cds)(\"CDS heap cannot be used because bitmap region cannot be mapped\");\n+      _heap_pointers_need_patching = false;\n+      return false;\n+    }\n+  }\n+\n+  if (map_heap_region_impl()) {\n+#ifdef ASSERT\n+    \/\/ The \"old\" regions must be parsable -- we cannot have any unused space\n+    \/\/ at the start of the lowest G1 region that contains archived objects.\n+    assert(is_aligned(_mapped_heap_memregion.start(), HeapRegion::GrainBytes), \"must be\");\n+\n+    \/\/ Make sure we map at the very top of the heap - see comments in\n+    \/\/ init_heap_region_relocation().\n+    MemRegion heap_range = G1CollectedHeap::heap()->reserved();\n+    assert(heap_range.contains(_mapped_heap_memregion), \"must be\");\n+\n+    address heap_end = (address)heap_range.end();\n+    address mapped_heap_region_end = (address)_mapped_heap_memregion.end();\n+    assert(heap_end >= mapped_heap_region_end, \"must be\");\n+    assert(heap_end - mapped_heap_region_end < (intx)(HeapRegion::GrainBytes),\n+           \"must be at the top of the heap to avoid fragmentation\");\n+#endif\n+\n+    ArchiveHeapLoader::set_mapped();\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+void FileMapInfo::init_heap_region_relocation() {\n@@ -2239,1 +2177,1 @@\n-  MemRegion archive_range = get_heap_regions_requested_range();\n+  MemRegion archive_range = get_heap_region_requested_range();\n@@ -2241,0 +2179,1 @@\n+  address requested_bottom = (address)archive_range.start();\n@@ -2242,2 +2181,0 @@\n-  address archive_end = (address)archive_range.end();\n-\n@@ -2245,1 +2182,5 @@\n-  assert(is_aligned(archive_end, HeapRegion::GrainBytes), \"must be\");\n+\n+  \/\/ We map the archive heap region at the very top of the heap to avoid fragmentation.\n+  \/\/ To do that, we make sure that the bottom of the archived region is at the same\n+  \/\/ address as the bottom of the highest possible G1 region.\n+  address mapped_bottom = heap_end - align_up(archive_range.byte_size(), HeapRegion::GrainBytes);\n@@ -2252,4 +2193,3 @@\n-  } else if (!heap_range.contains(archive_range)) {\n-    log_info(cds)(\"CDS heap data needs to be relocated because\");\n-    log_info(cds)(\"the desired range \" PTR_FORMAT \" - \"  PTR_FORMAT, p2i(archive_range.start()), p2i(archive_range.end()));\n-    log_info(cds)(\"is outside of the heap \" PTR_FORMAT \" - \"  PTR_FORMAT, p2i(heap_range.start()), p2i(heap_range.end()));\n+  } else if (requested_bottom != mapped_bottom) {\n+    log_info(cds)(\"CDS heap data needs to be relocated because it is mapped at a different address @ \" INTPTR_FORMAT,\n+                  p2i(mapped_bottom));\n@@ -2257,6 +2197,0 @@\n-  } else {\n-    assert(heap_end >= archive_end, \"must be\");\n-    if (heap_end != archive_end) {\n-      log_info(cds)(\"CDS heap data needs to be relocated to the end of the runtime heap to reduce fragmentation\");\n-      _heap_pointers_need_patching = true;\n-    }\n@@ -2267,1 +2201,1 @@\n-    delta = heap_end - archive_end;\n+    delta = mapped_bottom - requested_bottom;\n@@ -2271,17 +2205,0 @@\n-\n-  FileMapRegion* r = region_at(MetaspaceShared::first_closed_heap_region);\n-  address relocated_closed_heap_region_bottom = heap_region_requested_address(r) + delta;\n-\n-  if (!is_aligned(relocated_closed_heap_region_bottom, HeapRegion::GrainBytes)) {\n-    \/\/ Align the bottom of the closed archive heap regions at G1 region boundary.\n-    \/\/ This will avoid the situation where the highest open region and the lowest\n-    \/\/ closed region sharing the same G1 region. Otherwise we will fail to map the\n-    \/\/ open regions.\n-    size_t align = size_t(relocated_closed_heap_region_bottom) % HeapRegion::GrainBytes;\n-    delta -= align;\n-    log_info(cds)(\"CDS heap data needs to be relocated lower by a further \" SIZE_FORMAT\n-                  \" bytes to \" INTX_FORMAT \" to be aligned with HeapRegion::GrainBytes\",\n-                  align, delta);\n-    _heap_pointers_need_patching = true;\n-  }\n-\n@@ -2289,29 +2206,0 @@\n-  relocated_closed_heap_region_bottom = heap_region_mapped_address(r);\n-\n-  assert(is_aligned(relocated_closed_heap_region_bottom, HeapRegion::GrainBytes),\n-         \"must be\");\n-\n-  if (_heap_pointers_need_patching) {\n-    char* bitmap_base = map_bitmap_region();\n-    if (bitmap_base == nullptr) {\n-      log_info(cds)(\"CDS heap cannot be used because bitmap region cannot be mapped\");\n-      _heap_pointers_need_patching = false;\n-      return;\n-    }\n-  }\n-\n-  \/\/ Map the closed heap regions: GC does not write into these regions.\n-  if (map_heap_regions(MetaspaceShared::first_closed_heap_region,\n-                       MetaspaceShared::max_num_closed_heap_regions,\n-                       \/*is_open_archive=*\/ false,\n-                       &closed_heap_regions, &num_closed_heap_regions)) {\n-    ArchiveHeapLoader::set_closed_regions_mapped();\n-\n-    \/\/ Now, map the open heap regions: GC can write into these regions.\n-    if (map_heap_regions(MetaspaceShared::first_open_heap_region,\n-                         MetaspaceShared::max_num_open_heap_regions,\n-                         \/*is_open_archive=*\/ true,\n-                         &open_heap_regions, &num_open_heap_regions)) {\n-      ArchiveHeapLoader::set_open_regions_mapped();\n-    }\n-  }\n@@ -2320,2 +2208,3 @@\n-bool FileMapInfo::map_heap_regions() {\n-  map_heap_regions_impl();\n+bool FileMapInfo::map_heap_region_impl() {\n+  FileMapRegion* r = region_at(MetaspaceShared::hp);\n+  size_t size = r->used();\n@@ -2323,8 +2212,5 @@\n-  if (!ArchiveHeapLoader::closed_regions_mapped()) {\n-    assert(closed_heap_regions == nullptr &&\n-           num_closed_heap_regions == 0, \"sanity\");\n-  }\n-\n-  if (!ArchiveHeapLoader::open_regions_mapped()) {\n-    assert(open_heap_regions == nullptr && num_open_heap_regions == 0, \"sanity\");\n-    return false;\n+  if (size > 0) {\n+    HeapWord* start = (HeapWord*)heap_region_mapped_address();\n+    _mapped_heap_memregion = MemRegion(start, size \/ HeapWordSize);\n+    log_info(cds)(\"Trying to map heap data at \" INTPTR_FORMAT \", size = \" SIZE_FORMAT_W(8) \" bytes\",\n+                  p2i(start), size);\n@@ -2332,33 +2218,0 @@\n-    return true;\n-  }\n-}\n-\n-bool FileMapInfo::map_heap_regions(int first, int max,  bool is_open_archive,\n-                                   MemRegion** regions_ret, int* num_regions_ret) {\n-  MemRegion* regions = MemRegion::create_array(max, mtInternal);\n-\n-  struct Cleanup {\n-    MemRegion* _regions;\n-    uint _length;\n-    bool _aborted;\n-    Cleanup(MemRegion* regions, uint length) : _regions(regions), _length(length), _aborted(true) { }\n-    ~Cleanup() { if (_aborted) { MemRegion::destroy_array(_regions, _length); } }\n-  } cleanup(regions, max);\n-\n-  FileMapRegion* r;\n-  int num_regions = 0;\n-\n-  for (int i = first;\n-           i < first + max; i++) {\n-    r = region_at(i);\n-    size_t size = r->used();\n-    if (size > 0) {\n-      HeapWord* start = (HeapWord*)heap_region_mapped_address(r);\n-      regions[num_regions] = MemRegion(start, size \/ HeapWordSize);\n-      num_regions ++;\n-      log_info(cds)(\"Trying to map heap data: region[%d] at \" INTPTR_FORMAT \", size = \" SIZE_FORMAT_W(8) \" bytes\",\n-                    i, p2i(start), size);\n-    }\n-  }\n-\n-  if (num_regions == 0) {\n@@ -2368,2 +2221,2 @@\n-  \/\/ Check that regions are within the java heap\n-  if (!G1CollectedHeap::heap()->check_archive_addresses(regions, num_regions)) {\n+  \/\/ Check that the region is within the java heap\n+  if (!G1CollectedHeap::heap()->check_archive_addresses(_mapped_heap_memregion)) {\n@@ -2375,2 +2228,1 @@\n-  if (!G1CollectedHeap::heap()->alloc_archive_regions(\n-             regions, num_regions, is_open_archive)) {\n+  if (!G1CollectedHeap::heap()->alloc_archive_regions(_mapped_heap_memregion)) {\n@@ -2382,24 +2234,11 @@\n-  \/\/ for mapped regions as they are part of the reserved java heap, which is\n-  \/\/ already recorded.\n-  for (int i = 0; i < num_regions; i++) {\n-    r = region_at(first + i);\n-    char* addr = (char*)regions[i].start();\n-    char* base = os::map_memory(_fd, _full_path, r->file_offset(),\n-                                addr, regions[i].byte_size(), r->read_only(),\n-                                r->allow_exec());\n-    if (base == nullptr || base != addr) {\n-      \/\/ dealloc the regions from java heap\n-      dealloc_heap_regions(regions, num_regions);\n-      log_info(cds)(\"Unable to map at required address in java heap. \"\n-                    INTPTR_FORMAT \", size = \" SIZE_FORMAT \" bytes\",\n-                    p2i(addr), regions[i].byte_size());\n-      return false;\n-    }\n-\n-    r->set_mapped_base(base);\n-    if (VerifySharedSpaces && !r->check_region_crc()) {\n-      \/\/ dealloc the regions from java heap\n-      dealloc_heap_regions(regions, num_regions);\n-      log_info(cds)(\"mapped heap regions are corrupt\");\n-      return false;\n-    }\n+  \/\/ for mapped region as it is part of the reserved java heap, which is already recorded.\n+  char* addr = (char*)_mapped_heap_memregion.start();\n+  char* base = os::map_memory(_fd, _full_path, r->file_offset(),\n+                              addr, _mapped_heap_memregion.byte_size(), r->read_only(),\n+                              r->allow_exec());\n+  if (base == nullptr || base != addr) {\n+    dealloc_heap_region();\n+    log_info(cds)(\"UseSharedSpaces: Unable to map at required address in java heap. \"\n+                  INTPTR_FORMAT \", size = \" SIZE_FORMAT \" bytes\",\n+                  p2i(addr), _mapped_heap_memregion.byte_size());\n+    return false;\n@@ -2408,10 +2247,5 @@\n-  cleanup._aborted = false;\n-  \/\/ the shared heap data is mapped successfully\n-  *regions_ret = regions;\n-  *num_regions_ret = num_regions;\n-  return true;\n-}\n-\n-void FileMapInfo::patch_heap_embedded_pointers() {\n-  if (!_heap_pointers_need_patching) {\n-    return;\n+  r->set_mapped_base(base);\n+  if (VerifySharedSpaces && !r->check_region_crc()) {\n+    dealloc_heap_region();\n+    log_info(cds)(\"mapped heap region is corrupt\");\n+    return false;\n@@ -2420,7 +2254,1 @@\n-  patch_heap_embedded_pointers(closed_heap_regions,\n-                               num_closed_heap_regions,\n-                               MetaspaceShared::first_closed_heap_region);\n-\n-  patch_heap_embedded_pointers(open_heap_regions,\n-                               num_open_heap_regions,\n-                               MetaspaceShared::first_open_heap_region);\n+  return true;\n@@ -2429,1 +2257,1 @@\n-narrowOop FileMapInfo::encoded_heap_region_dumptime_address(FileMapRegion* r) {\n+narrowOop FileMapInfo::encoded_heap_region_dumptime_address() {\n@@ -2432,1 +2260,1 @@\n-  r->assert_is_heap_region();\n+  FileMapRegion* r = region_at(MetaspaceShared::hp);\n@@ -2436,2 +2264,5 @@\n-void FileMapInfo::patch_heap_embedded_pointers(MemRegion* regions, int num_regions,\n-                                               int first_region_idx) {\n+void FileMapInfo::patch_heap_embedded_pointers() {\n+  if (!ArchiveHeapLoader::is_mapped() || !_heap_pointers_need_patching) {\n+    return;\n+  }\n+\n@@ -2440,3 +2271,0 @@\n-  for (int i=0; i<num_regions; i++) {\n-    int region_idx = i + first_region_idx;\n-    FileMapRegion* r = region_at(region_idx);\n@@ -2444,2 +2272,3 @@\n-    ArchiveHeapLoader::patch_embedded_pointers(\n-      this, r, regions[i],\n+  FileMapRegion* r = region_at(MetaspaceShared::hp);\n+  ArchiveHeapLoader::patch_embedded_pointers(\n+      this, _mapped_heap_memregion,\n@@ -2448,1 +2277,0 @@\n-  }\n@@ -2451,25 +2279,5 @@\n-\/\/ This internally allocates objects using vmClasses::Object_klass(), so it\n-\/\/ must be called after the Object_klass is loaded\n-void FileMapInfo::fixup_mapped_heap_regions() {\n-  assert(vmClasses::Object_klass_loaded(), \"must be\");\n-  \/\/ If any closed regions were found, call the fill routine to make them parseable.\n-  \/\/ Note that closed_heap_regions may be non-null even if no regions were found.\n-  if (num_closed_heap_regions != 0) {\n-    assert(closed_heap_regions != nullptr,\n-           \"Null closed_heap_regions array with non-zero count\");\n-    G1CollectedHeap::heap()->fill_archive_regions(closed_heap_regions,\n-                                                  num_closed_heap_regions);\n-    \/\/ G1 marking uses the BOT for object chunking during marking in\n-    \/\/ G1CMObjArrayProcessor::process_slice(); for this reason we need to\n-    \/\/ initialize the BOT for closed archive regions too.\n-    G1CollectedHeap::heap()->populate_archive_regions_bot_part(closed_heap_regions,\n-                                                               num_closed_heap_regions);\n-  }\n-\n-  \/\/ do the same for mapped open archive heap regions\n-  if (num_open_heap_regions != 0) {\n-    assert(open_heap_regions != nullptr, \"Null open_heap_regions array with non-zero count\");\n-    G1CollectedHeap::heap()->fill_archive_regions(open_heap_regions,\n-                                                  num_open_heap_regions);\n-\n-    \/\/ Populate the open archive regions' G1BlockOffsetTableParts. That ensures\n+void FileMapInfo::fixup_mapped_heap_region() {\n+  if (ArchiveHeapLoader::is_mapped()) {\n+    assert(!_mapped_heap_memregion.is_empty(), \"sanity\");\n+\n+    \/\/ Populate the archive regions' G1BlockOffsetTableParts. That ensures\n@@ -2477,1 +2285,1 @@\n-    \/\/ within the open archive regions when trying to find start of an object\n+    \/\/ within the archive regions when trying to find start of an object\n@@ -2479,2 +2287,1 @@\n-    G1CollectedHeap::heap()->populate_archive_regions_bot_part(open_heap_regions,\n-                                                               num_open_heap_regions);\n+    G1CollectedHeap::heap()->populate_archive_regions_bot_part(_mapped_heap_memregion);\n@@ -2485,5 +2292,2 @@\n-void FileMapInfo::dealloc_heap_regions(MemRegion* regions, int num) {\n-  if (num > 0) {\n-    assert(regions != nullptr, \"Null archive regions array with non-zero count\");\n-    G1CollectedHeap::heap()->dealloc_archive_regions(regions, num);\n-  }\n+void FileMapInfo::dealloc_heap_region() {\n+  G1CollectedHeap::heap()->dealloc_archive_regions(_mapped_heap_memregion);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":162,"deletions":358,"binary":false,"changes":520,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+class ArchiveHeapInfo;\n@@ -107,7 +108,0 @@\n-struct ArchiveHeapBitmapInfo {\n-  address _map;               \/\/ bitmap for relocating embedded oops\n-  size_t  _bm_region_offset;  \/\/ this bitmap is stored at this offset from the bottom of the BM region\n-  size_t  _size_in_bits;\n-  size_t  _size_in_bytes;\n-};\n-\n@@ -176,1 +170,2 @@\n-  void init_bitmaps(ArchiveHeapBitmapInfo oopmap, ArchiveHeapBitmapInfo ptrmap);\n+  void init_oopmap(size_t offset, size_t size_in_bits);\n+  void init_ptrmap(size_t offset, size_t size_in_bits);\n@@ -454,3 +449,1 @@\n-  char* write_bitmap_region(const CHeapBitMap* ptrmap,\n-                            GrowableArray<ArchiveHeapBitmapInfo>* closed_bitmaps,\n-                            GrowableArray<ArchiveHeapBitmapInfo>* open_bitmaps,\n+  char* write_bitmap_region(const CHeapBitMap* ptrmap, ArchiveHeapInfo* heap_info,\n@@ -458,3 +451,1 @@\n-  size_t write_heap_regions(GrowableArray<MemRegion>* regions,\n-                            GrowableArray<ArchiveHeapBitmapInfo>* bitmaps,\n-                            int first_region_id, int max_num_regions);\n+  size_t write_heap_region(ArchiveHeapInfo* heap_info);\n@@ -467,2 +458,2 @@\n-  void  map_or_load_heap_regions() NOT_CDS_JAVA_HEAP_RETURN;\n-  void  fixup_mapped_heap_regions() NOT_CDS_JAVA_HEAP_RETURN;\n+  void  map_or_load_heap_region() NOT_CDS_JAVA_HEAP_RETURN;\n+  void  fixup_mapped_heap_region() NOT_CDS_JAVA_HEAP_RETURN;\n@@ -470,4 +461,2 @@\n-  void  patch_heap_embedded_pointers(MemRegion* regions, int num_regions,\n-                                     int first_region_idx) NOT_CDS_JAVA_HEAP_RETURN;\n-  bool  has_heap_regions()  NOT_CDS_JAVA_HEAP_RETURN_(false);\n-  MemRegion get_heap_regions_requested_range() NOT_CDS_JAVA_HEAP_RETURN_(MemRegion());\n+  bool  has_heap_region()  NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  MemRegion get_heap_region_requested_range() NOT_CDS_JAVA_HEAP_RETURN_(MemRegion());\n@@ -569,7 +558,6 @@\n-  bool  map_heap_regions(int first, int max, bool is_open_archive,\n-                         MemRegion** regions_ret, int* num_regions_ret) NOT_CDS_JAVA_HEAP_RETURN_(false);\n-  void  dealloc_heap_regions(MemRegion* regions, int num) NOT_CDS_JAVA_HEAP_RETURN;\n-  bool  can_use_heap_regions();\n-  bool  load_heap_regions() NOT_CDS_JAVA_HEAP_RETURN_(false);\n-  bool  map_heap_regions() NOT_CDS_JAVA_HEAP_RETURN_(false);\n-  void  map_heap_regions_impl() NOT_CDS_JAVA_HEAP_RETURN;\n+  bool  map_heap_region_impl() NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  void  dealloc_heap_region() NOT_CDS_JAVA_HEAP_RETURN;\n+  bool  can_use_heap_region();\n+  bool  load_heap_region() NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  bool  map_heap_region() NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  void  init_heap_region_relocation();\n@@ -578,2 +566,2 @@\n-  static size_t set_bitmaps_offset(GrowableArray<ArchiveHeapBitmapInfo> *bitmaps, size_t curr_size);\n-  static size_t write_bitmaps(GrowableArray<ArchiveHeapBitmapInfo> *bitmaps, size_t curr_offset, char* buffer);\n+\n+  static MemRegion _mapped_heap_memregion;\n@@ -582,4 +570,4 @@\n-  address heap_region_dumptime_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n-  address heap_region_requested_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n-  address heap_region_mapped_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n-  narrowOop encoded_heap_region_dumptime_address(FileMapRegion* r);\n+  address heap_region_dumptime_address() NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  address heap_region_requested_address() NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  address heap_region_mapped_address() NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  narrowOop encoded_heap_region_dumptime_address();\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":21,"deletions":33,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -85,1 +85,0 @@\n-bool HeapShared::_copying_open_region_objects = false;\n@@ -106,4 +105,1 @@\n-\/\/ Entry fields for shareable subgraphs archived in the closed archive heap\n-\/\/ region. Warning: Objects in the subgraphs should not have reference fields\n-\/\/ assigned at runtime.\n-static ArchivableStaticFieldInfo closed_archive_subgraph_entry_fields[] = {\n+static ArchivableStaticFieldInfo archive_subgraph_entry_fields[] = {\n@@ -117,4 +113,0 @@\n-  {nullptr, nullptr},\n-};\n-\/\/ Entry fields for subgraphs archived in the open archive heap region.\n-static ArchivableStaticFieldInfo open_archive_subgraph_entry_fields[] = {\n@@ -132,2 +124,2 @@\n-\/\/ Entry fields for subgraphs archived in the open archive heap region (full module graph).\n-static ArchivableStaticFieldInfo fmg_open_archive_subgraph_entry_fields[] = {\n+\/\/ full module graph\n+static ArchivableStaticFieldInfo fmg_archive_subgraph_entry_fields[] = {\n@@ -156,3 +148,2 @@\n-  return is_subgraph_root_class_of(closed_archive_subgraph_entry_fields, ik) ||\n-         is_subgraph_root_class_of(open_archive_subgraph_entry_fields, ik) ||\n-         is_subgraph_root_class_of(fmg_open_archive_subgraph_entry_fields, ik);\n+  return is_subgraph_root_class_of(archive_subgraph_entry_fields, ik) ||\n+         is_subgraph_root_class_of(fmg_archive_subgraph_entry_fields, ik);\n@@ -386,1 +377,1 @@\n-      bool success = archive_reachable_objects_from(1, _default_subgraph_info, m, \/*is_closed_archive=*\/ false);\n+      bool success = archive_reachable_objects_from(1, _default_subgraph_info, m);\n@@ -404,1 +395,1 @@\n-      bool success = archive_reachable_objects_from(1, _default_subgraph_info, m, \/*is_closed_archive=*\/ false);\n+      bool success = archive_reachable_objects_from(1, _default_subgraph_info, m);\n@@ -417,2 +408,1 @@\n-          bool success = HeapShared::archive_reachable_objects_from(1, _default_subgraph_info, rr,\n-                                                                    \/*is_closed_archive=*\/false);\n+          bool success = HeapShared::archive_reachable_objects_from(1, _default_subgraph_info, rr);\n@@ -430,1 +420,1 @@\n-  bool success = archive_reachable_objects_from(1, _default_subgraph_info, shared_strings_array, \/*is_closed_archive=*\/ false);\n+  bool success = archive_reachable_objects_from(1, _default_subgraph_info, shared_strings_array);\n@@ -466,2 +456,1 @@\n-                                oop orig_obj,\n-                                bool is_closed_archive) {\n+                                oop orig_obj) {\n@@ -496,1 +485,1 @@\n-        bool success = archive_reachable_objects_from(level, subgraph_info, oop_field, is_closed_archive);\n+        bool success = archive_reachable_objects_from(level, subgraph_info, oop_field);\n@@ -535,4 +524,1 @@\n-void HeapShared::archive_objects(GrowableArray<MemRegion>* closed_regions,\n-                                 GrowableArray<MemRegion>* open_regions,\n-                                 GrowableArray<ArchiveHeapBitmapInfo>* closed_bitmaps,\n-                                 GrowableArray<ArchiveHeapBitmapInfo>* open_bitmaps) {\n+void HeapShared::archive_objects(ArchiveHeapInfo *heap_info) {\n@@ -552,7 +538,1 @@\n-    log_info(cds)(\"Dumping objects to closed archive heap region ...\");\n-    copy_closed_objects();\n-\n-    _copying_open_region_objects = true;\n-\n-    log_info(cds)(\"Dumping objects to open archive heap region ...\");\n-    copy_open_objects();\n+    copy_objects();\n@@ -564,1 +544,1 @@\n-  ArchiveHeapWriter::write(_pending_roots, closed_regions, open_regions, closed_bitmaps, open_bitmaps);\n+  ArchiveHeapWriter::write(_pending_roots, heap_info);\n@@ -573,3 +553,2 @@\n-    bool success = archive_reachable_objects_from(1, _default_subgraph_info,\n-                                                  s, \/*is_closed_archive=*\/true);\n-    assert(success, \"string must be short enough to be archived\");\n+    bool success = archive_reachable_objects_from(1, _default_subgraph_info, s);\n+    assert(success, \"must be\");\n@@ -585,12 +564,1 @@\n-void HeapShared::copy_closed_objects() {\n-  assert(HeapShared::can_write(), \"must be\");\n-\n-  \/\/ Archive interned string objects\n-  copy_interned_strings();\n-\n-  archive_object_subgraphs(closed_archive_subgraph_entry_fields,\n-                           true \/* is_closed_archive *\/,\n-                           false \/* is_full_module_graph *\/);\n-}\n-\n-void HeapShared::copy_special_open_objects() {\n+void HeapShared::copy_special_objects() {\n@@ -604,1 +572,1 @@\n-void HeapShared::copy_open_objects() {\n+void HeapShared::copy_objects() {\n@@ -607,1 +575,2 @@\n-  copy_special_open_objects();\n+  copy_interned_strings();\n+  copy_special_objects();\n@@ -609,2 +578,1 @@\n-  archive_object_subgraphs(open_archive_subgraph_entry_fields,\n-                           false \/* is_closed_archive *\/,\n+  archive_object_subgraphs(archive_subgraph_entry_fields,\n@@ -612,0 +580,1 @@\n+\n@@ -613,2 +582,1 @@\n-    archive_object_subgraphs(fmg_open_archive_subgraph_entry_fields,\n-                             false \/* is_closed_archive *\/,\n+    archive_object_subgraphs(fmg_archive_subgraph_entry_fields,\n@@ -648,2 +616,1 @@\n-void KlassSubGraphInfo::add_subgraph_entry_field(\n-      int static_field_offset, oop v, bool is_closed_archive) {\n+void KlassSubGraphInfo::add_subgraph_entry_field(int static_field_offset, oop v) {\n@@ -839,1 +806,1 @@\n-\/\/   offset, value and is_closed_archive flag are recorded in the sub-graph\n+\/\/   offset, and value are recorded in the sub-graph\n@@ -939,3 +906,2 @@\n-  resolve_classes_for_subgraphs(current, closed_archive_subgraph_entry_fields);\n-  resolve_classes_for_subgraphs(current, open_archive_subgraph_entry_fields);\n-  resolve_classes_for_subgraphs(current, fmg_open_archive_subgraph_entry_fields);\n+  resolve_classes_for_subgraphs(current, archive_subgraph_entry_fields);\n+  resolve_classes_for_subgraphs(current, fmg_archive_subgraph_entry_fields);\n@@ -1118,1 +1084,0 @@\n-  bool _is_closed_archive;\n@@ -1129,1 +1094,0 @@\n-                           bool is_closed_archive,\n@@ -1133,1 +1097,1 @@\n-    _level(level), _is_closed_archive(is_closed_archive),\n+    _level(level),\n@@ -1165,1 +1129,1 @@\n-          _level + 1, _subgraph_info, obj, _is_closed_archive);\n+          _level + 1, _subgraph_info, obj);\n@@ -1181,17 +1145,1 @@\n-  return CachedOopInfo(referrer, _copying_open_region_objects);\n-}\n-\n-void HeapShared::check_closed_region_object(InstanceKlass* k) {\n-  \/\/ Check fields in the object\n-  for (JavaFieldStream fs(k); !fs.done(); fs.next()) {\n-    if (!fs.access_flags().is_static()) {\n-      BasicType ft = fs.field_descriptor().field_type();\n-      if (!fs.access_flags().is_final() && is_reference_type(ft)) {\n-        ResourceMark rm;\n-        log_warning(cds, heap)(\n-          \"Please check reference field in %s instance in closed archive heap region: %s %s\",\n-          k->external_name(), (fs.name())->as_C_string(),\n-          (fs.signature())->as_C_string());\n-      }\n-    }\n-  }\n+  return CachedOopInfo(referrer);\n@@ -1206,2 +1154,1 @@\n-                                                oop orig_obj,\n-                                                bool is_closed_archive) {\n+                                                oop orig_obj) {\n@@ -1263,2 +1210,1 @@\n-  WalkOopAndArchiveClosure walker(level, is_closed_archive, record_klasses_only,\n-                                  subgraph_info, orig_obj);\n+  WalkOopAndArchiveClosure walker(level, record_klasses_only, subgraph_info, orig_obj);\n@@ -1266,3 +1212,0 @@\n-  if (is_closed_archive && orig_k->is_instance_klass()) {\n-    check_closed_region_object(InstanceKlass::cast(orig_k));\n-  }\n@@ -1270,1 +1213,1 @@\n-  check_enum_obj(level + 1, subgraph_info, orig_obj, is_closed_archive);\n+  check_enum_obj(level + 1, subgraph_info, orig_obj);\n@@ -1311,2 +1254,1 @@\n-                                                             const char* field_name,\n-                                                             bool is_closed_archive) {\n+                                                             const char* field_name) {\n@@ -1330,2 +1272,1 @@\n-    bool success = archive_reachable_objects_from(1, subgraph_info, f, is_closed_archive);\n-\n+    bool success = archive_reachable_objects_from(1, subgraph_info, f);\n@@ -1339,1 +1280,1 @@\n-      subgraph_info->add_subgraph_entry_field(field_offset, f, is_closed_archive);\n+      subgraph_info->add_subgraph_entry_field(field_offset, f);\n@@ -1345,1 +1286,1 @@\n-    subgraph_info->add_subgraph_entry_field(field_offset, nullptr, false);\n+    subgraph_info->add_subgraph_entry_field(field_offset, nullptr);\n@@ -1575,2 +1516,1 @@\n-  init_subgraph_entry_fields(closed_archive_subgraph_entry_fields, CHECK);\n-  init_subgraph_entry_fields(open_archive_subgraph_entry_fields, CHECK);\n+  init_subgraph_entry_fields(archive_subgraph_entry_fields, CHECK);\n@@ -1578,1 +1518,1 @@\n-    init_subgraph_entry_fields(fmg_open_archive_subgraph_entry_fields, CHECK);\n+    init_subgraph_entry_fields(fmg_archive_subgraph_entry_fields, CHECK);\n@@ -1584,2 +1524,2 @@\n-  ArchivableStaticFieldInfo* p = open_archive_subgraph_entry_fields;\n-  int num_slots = sizeof(open_archive_subgraph_entry_fields) \/ sizeof(ArchivableStaticFieldInfo);\n+  ArchivableStaticFieldInfo* p = archive_subgraph_entry_fields;\n+  int num_slots = sizeof(archive_subgraph_entry_fields) \/ sizeof(ArchivableStaticFieldInfo);\n@@ -1652,1 +1592,0 @@\n-                                          bool is_closed_archive,\n@@ -1683,2 +1622,1 @@\n-                                                  f->offset, f->field_name,\n-                                                  is_closed_archive);\n+                                                  f->offset, f->field_name);\n@@ -1689,2 +1627,1 @@\n-  log_info(cds, heap)(\"Archived subgraph records in %s archive heap region = %d\",\n-                      is_closed_archive ? \"closed\" : \"open\",\n+  log_info(cds, heap)(\"Archived subgraph records = %d\",\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":43,"deletions":106,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+class ArchiveHeapInfo;\n@@ -64,2 +65,1 @@\n-  \/\/ For each entry field, it is a tuple of field_offset, field_value and\n-  \/\/ is_closed_archive flag.\n+  \/\/ For each entry field, it is a tuple of field_offset, field_value\n@@ -100,2 +100,1 @@\n-  void add_subgraph_entry_field(int static_field_offset, oop v,\n-                                bool is_closed_archive);\n+  void add_subgraph_entry_field(int static_field_offset, oop v);\n@@ -144,1 +143,1 @@\n-  \/\/ Can this VM write heap regions into the CDS archive? Currently only G1+compressed{oops,cp}\n+  \/\/ Can this VM write a heap region into the CDS archive? Currently only G1+compressed{oops,cp}\n@@ -168,1 +167,0 @@\n-  static bool _copying_open_region_objects;\n@@ -192,1 +190,0 @@\n-    bool _in_open_region;\n@@ -194,1 +191,1 @@\n-    CachedOopInfo(oop orig_referrer, bool in_open_region)\n+    CachedOopInfo(oop orig_referrer)\n@@ -196,1 +193,1 @@\n-        _buffer_offset(0), _in_open_region(in_open_region) {}\n+        _buffer_offset(0) {}\n@@ -198,1 +195,0 @@\n-    bool in_open_region()           const { return _in_open_region;  }\n@@ -204,4 +200,2 @@\n-  static void check_enum_obj(int level,\n-                             KlassSubGraphInfo* subgraph_info,\n-                             oop orig_obj,\n-                             bool is_closed_archive);\n+  static void check_enum_obj(int level, KlassSubGraphInfo* subgraph_info,\n+                             oop orig_obj);\n@@ -242,1 +236,0 @@\n-  static void check_closed_region_object(InstanceKlass* k);\n@@ -245,1 +238,0 @@\n-                                       bool is_closed_archive,\n@@ -252,2 +244,1 @@\n-    int field_offset, const char* field_name,\n-    bool is_closed_archive);\n+    int field_offset, const char* field_name);\n@@ -362,7 +353,3 @@\n-  static void archive_objects(GrowableArray<MemRegion>* closed_regions,\n-                              GrowableArray<MemRegion>* open_regions,\n-                              GrowableArray<ArchiveHeapBitmapInfo>* closed_bitmaps,\n-                              GrowableArray<ArchiveHeapBitmapInfo>* open_bitmaps);\n-  static void copy_closed_objects();\n-  static void copy_open_objects();\n-  static void copy_special_open_objects();\n+  static void archive_objects(ArchiveHeapInfo* heap_info);\n+  static void copy_objects();\n+  static void copy_special_objects();\n@@ -372,2 +359,1 @@\n-                                             oop orig_obj,\n-                                             bool is_closed_archive);\n+                                             oop orig_obj);\n@@ -383,1 +369,1 @@\n-  \/\/ archived heap regions are not prematurely collected. These roots include:\n+  \/\/ archived heap region are not prematurely collected. These roots include:\n@@ -413,2 +399,1 @@\n-    CDS_JAVA_HEAP_ONLY(return (idx >= MetaspaceShared::first_closed_heap_region &&\n-                               idx <= MetaspaceShared::last_open_heap_region);)\n+    CDS_JAVA_HEAP_ONLY(return (idx == MetaspaceShared::hp);)\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":15,"deletions":30,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -101,6 +101,1 @@\n-\/\/\n-\/\/     ca0 - closed archive heap space #0\n-\/\/     ca1 - closed archive heap space #1 (may be empty)\n-\/\/     oa0 - open archive heap space #0\n-\/\/     oa1 - open archive heap space #1 (may be empty)\n-\/\/\n+\/\/     hp  - heap region\n@@ -122,2 +117,3 @@\n-\/\/ The ca0\/ca1 and oa0\/oa1 regions are populated inside HeapShared::archive_objects.\n-\/\/ Their layout is independent of the rw\/ro regions.\n+\/\/ The heap region is populated by HeapShared::archive_objects.\n+\/\/\n+\/\/ The bitmap region is used to relocate the ro\/rw\/hp regions.\n@@ -434,5 +430,1 @@\n-  GrowableArray<MemRegion> *_closed_heap_regions;\n-  GrowableArray<MemRegion> *_open_heap_regions;\n-\n-  GrowableArray<ArchiveHeapBitmapInfo> *_closed_heap_bitmaps;\n-  GrowableArray<ArchiveHeapBitmapInfo> *_open_heap_bitmaps;\n+  ArchiveHeapInfo _heap_info;\n@@ -449,5 +441,1 @@\n-  VM_PopulateDumpSharedSpace() : VM_Operation(),\n-    _closed_heap_regions(nullptr),\n-    _open_heap_regions(nullptr),\n-    _closed_heap_bitmaps(nullptr),\n-    _open_heap_bitmaps(nullptr) {}\n+  VM_PopulateDumpSharedSpace() : VM_Operation(), _heap_info() {}\n@@ -553,5 +541,1 @@\n-  builder.write_archive(mapinfo,\n-                        _closed_heap_regions,\n-                        _open_heap_regions,\n-                        _closed_heap_bitmaps,\n-                        _open_heap_bitmaps);\n+  builder.write_archive(mapinfo, &_heap_info);\n@@ -877,8 +861,1 @@\n-  \/\/ The closed and open archive heap space has maximum two regions.\n-  \/\/ See FileMapInfo::write_heap_regions() for details.\n-  _closed_heap_regions = new GrowableArray<MemRegion>(2);\n-  _open_heap_regions = new GrowableArray<MemRegion>(2);\n-  _closed_heap_bitmaps = new GrowableArray<ArchiveHeapBitmapInfo>(2);\n-  _open_heap_bitmaps = new GrowableArray<ArchiveHeapBitmapInfo>(2);\n-  HeapShared::archive_objects(_closed_heap_regions, _open_heap_regions,\n-                              _closed_heap_bitmaps, _open_heap_bitmaps);\n+  HeapShared::archive_objects(&_heap_info);\n@@ -1180,1 +1157,1 @@\n-          \/\/ map_heap_regions() compares the current narrow oop and klass encodings\n+          \/\/ map_or_load_heap_region() compares the current narrow oop and klass encodings\n@@ -1182,1 +1159,1 @@\n-          static_mapinfo->map_or_load_heap_regions();\n+          static_mapinfo->map_or_load_heap_region();\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":10,"deletions":33,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,1 @@\n+    hp = 3,  \/\/ heap region\n@@ -64,16 +65,1 @@\n-    num_non_heap_regions = 3,  \/\/ rw and ro and bm\n-\n-    \/\/ java heap regions\n-    first_closed_heap_region = bm + 1,\n-    max_num_closed_heap_regions = 2,\n-    last_closed_heap_region = first_closed_heap_region + max_num_closed_heap_regions - 1,\n-    first_open_heap_region = last_closed_heap_region + 1,\n-    max_num_open_heap_regions = 2,\n-    last_open_heap_region = first_open_heap_region + max_num_open_heap_regions - 1,\n-    max_num_heap_regions = max_num_closed_heap_regions + max_num_open_heap_regions,\n-\n-    first_archive_heap_region = first_closed_heap_region,\n-    last_archive_heap_region = last_open_heap_region,\n-\n-    last_valid_region = last_open_heap_region,\n-    n_regions =  last_valid_region + 1 \/\/ total number of regions\n+    n_regions = 4              \/\/ total number of regions\n@@ -109,2 +95,2 @@\n-  \/\/ Return true if given address is in the shared metaspace regions (i.e., excluding any\n-  \/\/ mapped heap regions.)\n+  \/\/ Return true if given address is in the shared metaspace regions (i.e., excluding the\n+  \/\/ mapped heap region.)\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":5,"deletions":19,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1124,3 +1124,0 @@\n-  if (ArchiveHeapLoader::is_mapped()) {\n-    assert(Universe::heap()->is_archived_object(m), \"must be archived mirror object\");\n-  }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-    ArchiveHeapLoader::fixup_regions();\n+    ArchiveHeapLoader::fixup_region();\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,2 +100,0 @@\n-  assert(retained_region == NULL || !retained_region->is_archive(),\n-         \"Archive region should not be alloc region (index %u)\", retained_region->hrm_index());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -514,8 +514,18 @@\n-bool G1CollectedHeap::check_archive_addresses(MemRegion* ranges, size_t count) {\n-  assert(ranges != NULL, \"MemRegion array NULL\");\n-  assert(count != 0, \"No MemRegions provided\");\n-  MemRegion reserved = _hrm.reserved();\n-  for (size_t i = 0; i < count; i++) {\n-    if (!reserved.contains(ranges[i].start()) || !reserved.contains(ranges[i].last())) {\n-      return false;\n-    }\n+bool G1CollectedHeap::check_archive_addresses(MemRegion range) {\n+  return _hrm.reserved().contains(range);\n+}\n+\n+template <typename Func>\n+void G1CollectedHeap::iterate_regions_in_range(MemRegion range, const Func& func) {\n+  \/\/ Mark each G1 region touched by the range as old, add it to\n+  \/\/ the old set, and set top.\n+  HeapRegion* curr_region = _hrm.addr_to_region(range.start());\n+  HeapRegion* end_region = _hrm.addr_to_region(range.last());\n+\n+  while (curr_region != nullptr) {\n+    bool is_last = curr_region == end_region;\n+    HeapRegion* next_region = is_last ? nullptr : _hrm.next_region_in_heap(curr_region);\n+\n+    func(curr_region, is_last);\n+\n+    curr_region = next_region;\n@@ -523,1 +533,0 @@\n-  return true;\n@@ -526,3 +535,1 @@\n-bool G1CollectedHeap::alloc_archive_regions(MemRegion* ranges,\n-                                            size_t count,\n-                                            bool open) {\n+bool G1CollectedHeap::alloc_archive_regions(MemRegion range) {\n@@ -530,2 +537,0 @@\n-  assert(ranges != NULL, \"MemRegion array NULL\");\n-  assert(count != 0, \"No MemRegions provided\");\n@@ -535,2 +540,0 @@\n-  HeapWord* prev_last_addr = NULL;\n-  HeapRegion* prev_last_region = NULL;\n@@ -542,34 +545,6 @@\n-  \/\/ For each specified MemRegion range, allocate the corresponding G1\n-  \/\/ regions and mark them as archive regions. We expect the ranges\n-  \/\/ in ascending starting address order, without overlap.\n-  for (size_t i = 0; i < count; i++) {\n-    MemRegion curr_range = ranges[i];\n-    HeapWord* start_address = curr_range.start();\n-    size_t word_size = curr_range.word_size();\n-    HeapWord* last_address = curr_range.last();\n-    size_t commits = 0;\n-\n-    guarantee(reserved.contains(start_address) && reserved.contains(last_address),\n-              \"MemRegion outside of heap [\" PTR_FORMAT \", \" PTR_FORMAT \"]\",\n-              p2i(start_address), p2i(last_address));\n-    guarantee(start_address > prev_last_addr,\n-              \"Ranges not in ascending order: \" PTR_FORMAT \" <= \" PTR_FORMAT ,\n-              p2i(start_address), p2i(prev_last_addr));\n-    prev_last_addr = last_address;\n-\n-    \/\/ Check for ranges that start in the same G1 region in which the previous\n-    \/\/ range ended, and adjust the start address so we don't try to allocate\n-    \/\/ the same region again. If the current range is entirely within that\n-    \/\/ region, skip it, just adjusting the recorded top.\n-    HeapRegion* start_region = _hrm.addr_to_region(start_address);\n-    if ((prev_last_region != NULL) && (start_region == prev_last_region)) {\n-      start_address = start_region->end();\n-      if (start_address > last_address) {\n-        increase_used(word_size * HeapWordSize);\n-        start_region->set_top(last_address + 1);\n-        continue;\n-      }\n-      start_region->set_top(start_address);\n-      curr_range = MemRegion(start_address, last_address + 1);\n-      start_region = _hrm.addr_to_region(start_address);\n-    }\n+  \/\/ For the specified MemRegion range, allocate the corresponding G1\n+  \/\/ region(s) and mark them as old region(s).\n+  HeapWord* start_address = range.start();\n+  size_t word_size = range.word_size();\n+  HeapWord* last_address = range.last();\n+  size_t commits = 0;\n@@ -577,9 +552,3 @@\n-    \/\/ Perform the actual region allocation, exiting if it fails.\n-    \/\/ Then note how much new space we have allocated.\n-    if (!_hrm.allocate_containing_regions(curr_range, &commits, workers())) {\n-      return false;\n-    }\n-    increase_used(word_size * HeapWordSize);\n-    if (commits != 0) {\n-      log_debug(gc, ergo, heap)(\"Attempt heap expansion (allocate archive regions). Total size: \" SIZE_FORMAT \"B\",\n-                                HeapRegion::GrainWords * HeapWordSize * commits);\n+  guarantee(reserved.contains(start_address) && reserved.contains(last_address),\n+            \"MemRegion outside of heap [\" PTR_FORMAT \", \" PTR_FORMAT \"]\",\n+            p2i(start_address), p2i(last_address));\n@@ -587,1 +556,9 @@\n-    }\n+  \/\/ Perform the actual region allocation, exiting if it fails.\n+  \/\/ Then note how much new space we have allocated.\n+  if (!_hrm.allocate_containing_regions(range, &commits, workers())) {\n+    return false;\n+  }\n+  increase_used(word_size * HeapWordSize);\n+  if (commits != 0) {\n+    log_debug(gc, ergo, heap)(\"Attempt heap expansion (allocate archive regions). Total size: \" SIZE_FORMAT \"B\",\n+                              HeapRegion::GrainWords * HeapWordSize * commits);\n@@ -589,28 +566,0 @@\n-    \/\/ Mark each G1 region touched by the range as archive, add it to\n-    \/\/ the old set, and set top.\n-    HeapRegion* curr_region = _hrm.addr_to_region(start_address);\n-    HeapRegion* last_region = _hrm.addr_to_region(last_address);\n-    prev_last_region = last_region;\n-\n-    while (curr_region != NULL) {\n-      assert(curr_region->is_empty() && !curr_region->is_pinned(),\n-             \"Region already in use (index %u)\", curr_region->hrm_index());\n-      if (open) {\n-        curr_region->set_open_archive();\n-      } else {\n-        curr_region->set_closed_archive();\n-      }\n-      _hr_printer.alloc(curr_region);\n-      _archive_set.add(curr_region);\n-      HeapWord* top;\n-      HeapRegion* next_region;\n-      if (curr_region != last_region) {\n-        top = curr_region->end();\n-        next_region = _hrm.next_region_in_heap(curr_region);\n-      } else {\n-        top = last_address + 1;\n-        next_region = NULL;\n-      }\n-      curr_region->set_top(top);\n-      curr_region = next_region;\n-    }\n@@ -618,0 +567,15 @@\n+\n+  \/\/ Mark each G1 region touched by the range as old, add it to\n+  \/\/ the old set, and set top.\n+  auto set_region_to_old = [&] (HeapRegion* r, bool is_last) {\n+    assert(r->is_empty() && !r->is_pinned(), \"Region already in use (%u)\", r->hrm_index());\n+\n+    HeapWord* top = is_last ? last_address + 1 : r->end();\n+    r->set_top(top);\n+\n+    r->set_old();\n+    _hr_printer.alloc(r);\n+    _old_set.add(r);\n+  };\n+\n+  iterate_regions_in_range(range, set_region_to_old);\n@@ -621,1 +585,10 @@\n-void G1CollectedHeap::fill_archive_regions(MemRegion* ranges, size_t count) {\n+void G1CollectedHeap::populate_archive_regions_bot_part(MemRegion range) {\n+  assert(!is_init_completed(), \"Expect to be called at JVM init time\");\n+\n+  iterate_regions_in_range(range,\n+                           [&] (HeapRegion* r, bool is_last) {\n+                             r->update_bot();\n+                           });\n+}\n+\n+void G1CollectedHeap::dealloc_archive_regions(MemRegion range) {\n@@ -623,2 +596,0 @@\n-  assert(ranges != NULL, \"MemRegion array NULL\");\n-  assert(count != 0, \"No MemRegions provided\");\n@@ -626,2 +597,2 @@\n-  HeapWord *prev_last_addr = NULL;\n-  HeapRegion* prev_last_region = NULL;\n+  size_t size_used = 0;\n+  uint shrink_count = 0;\n@@ -629,4 +600,1 @@\n-  \/\/ For each MemRegion, create filler objects, if needed, in the G1 regions\n-  \/\/ that contain the address range. The address range actually within the\n-  \/\/ MemRegion will not be modified. That is assumed to have been initialized\n-  \/\/ elsewhere, probably via an mmap of archived heap data.\n+  \/\/ Free the G1 regions that are within the specified range.\n@@ -634,33 +602,19 @@\n-  for (size_t i = 0; i < count; i++) {\n-    HeapWord* start_address = ranges[i].start();\n-    HeapWord* last_address = ranges[i].last();\n-\n-    assert(reserved.contains(start_address) && reserved.contains(last_address),\n-           \"MemRegion outside of heap [\" PTR_FORMAT \", \" PTR_FORMAT \"]\",\n-           p2i(start_address), p2i(last_address));\n-    assert(start_address > prev_last_addr,\n-           \"Ranges not in ascending order: \" PTR_FORMAT \" <= \" PTR_FORMAT ,\n-           p2i(start_address), p2i(prev_last_addr));\n-\n-    HeapRegion* start_region = _hrm.addr_to_region(start_address);\n-    HeapRegion* last_region = _hrm.addr_to_region(last_address);\n-    HeapWord* bottom_address = start_region->bottom();\n-\n-    \/\/ Check for a range beginning in the same region in which the\n-    \/\/ previous one ended.\n-    if (start_region == prev_last_region) {\n-      bottom_address = prev_last_addr + 1;\n-    }\n-\n-    \/\/ Verify that the regions were all marked as archive regions by\n-    \/\/ alloc_archive_regions.\n-    HeapRegion* curr_region = start_region;\n-    while (curr_region != NULL) {\n-      guarantee(curr_region->is_archive(),\n-                \"Expected archive region at index %u\", curr_region->hrm_index());\n-      if (curr_region != last_region) {\n-        curr_region = _hrm.next_region_in_heap(curr_region);\n-      } else {\n-        curr_region = NULL;\n-      }\n-    }\n+  HeapWord* start_address = range.start();\n+  HeapWord* last_address = range.last();\n+\n+  assert(reserved.contains(start_address) && reserved.contains(last_address),\n+         \"MemRegion outside of heap [\" PTR_FORMAT \", \" PTR_FORMAT \"]\",\n+         p2i(start_address), p2i(last_address));\n+  size_used += range.byte_size();\n+\n+  \/\/ Free, empty and uncommit regions with CDS archive content.\n+  auto dealloc_archive_region = [&] (HeapRegion* r, bool is_last) {\n+    guarantee(r->is_old(), \"Expected old region at index %u\", r->hrm_index());\n+    _old_set.remove(r);\n+    r->set_free();\n+    r->set_top(r->bottom());\n+    _hrm.shrink_at(r->hrm_index(), 1);\n+    shrink_count++;\n+  };\n+\n+  iterate_regions_in_range(range, dealloc_archive_region);\n@@ -668,12 +622,5 @@\n-    prev_last_addr = last_address;\n-    prev_last_region = last_region;\n-\n-    \/\/ Fill the memory below the allocated range with dummy object(s),\n-    \/\/ if the region bottom does not match the range start, or if the previous\n-    \/\/ range ended within the same G1 region, and there is a gap.\n-    assert(start_address >= bottom_address, \"bottom address should not be greater than start address\");\n-    if (start_address > bottom_address) {\n-      size_t fill_size = pointer_delta(start_address, bottom_address);\n-      G1CollectedHeap::fill_with_objects(bottom_address, fill_size);\n-      increase_used(fill_size * HeapWordSize);\n-    }\n+  if (shrink_count != 0) {\n+    log_debug(gc, ergo, heap)(\"Attempt heap shrinking (CDS archive regions). Total size: \" SIZE_FORMAT \"B\",\n+                              HeapRegion::GrainWords * HeapWordSize * shrink_count);\n+    \/\/ Explicit uncommit.\n+    uncommit_regions(shrink_count);\n@@ -681,0 +628,1 @@\n+  decrease_used(size_used);\n@@ -708,93 +656,0 @@\n-void G1CollectedHeap::populate_archive_regions_bot_part(MemRegion* ranges, size_t count) {\n-  assert(!is_init_completed(), \"Expect to be called at JVM init time\");\n-  assert(ranges != NULL, \"MemRegion array NULL\");\n-  assert(count != 0, \"No MemRegions provided\");\n-\n-  HeapWord* st = ranges[0].start();\n-  HeapWord* last = ranges[count-1].last();\n-  HeapRegion* hr_st = _hrm.addr_to_region(st);\n-  HeapRegion* hr_last = _hrm.addr_to_region(last);\n-\n-  HeapRegion* hr_curr = hr_st;\n-  while (hr_curr != NULL) {\n-    hr_curr->update_bot();\n-    if (hr_curr != hr_last) {\n-      hr_curr = _hrm.next_region_in_heap(hr_curr);\n-    } else {\n-      hr_curr = NULL;\n-    }\n-  }\n-}\n-\n-void G1CollectedHeap::dealloc_archive_regions(MemRegion* ranges, size_t count) {\n-  assert(!is_init_completed(), \"Expect to be called at JVM init time\");\n-  assert(ranges != NULL, \"MemRegion array NULL\");\n-  assert(count != 0, \"No MemRegions provided\");\n-  MemRegion reserved = _hrm.reserved();\n-  HeapWord* prev_last_addr = NULL;\n-  HeapRegion* prev_last_region = NULL;\n-  size_t size_used = 0;\n-  uint shrink_count = 0;\n-\n-  \/\/ For each Memregion, free the G1 regions that constitute it, and\n-  \/\/ notify mark-sweep that the range is no longer to be considered 'archive.'\n-  MutexLocker x(Heap_lock);\n-  for (size_t i = 0; i < count; i++) {\n-    HeapWord* start_address = ranges[i].start();\n-    HeapWord* last_address = ranges[i].last();\n-\n-    assert(reserved.contains(start_address) && reserved.contains(last_address),\n-           \"MemRegion outside of heap [\" PTR_FORMAT \", \" PTR_FORMAT \"]\",\n-           p2i(start_address), p2i(last_address));\n-    assert(start_address > prev_last_addr,\n-           \"Ranges not in ascending order: \" PTR_FORMAT \" <= \" PTR_FORMAT ,\n-           p2i(start_address), p2i(prev_last_addr));\n-    size_used += ranges[i].byte_size();\n-    prev_last_addr = last_address;\n-\n-    HeapRegion* start_region = _hrm.addr_to_region(start_address);\n-    HeapRegion* last_region = _hrm.addr_to_region(last_address);\n-\n-    \/\/ Check for ranges that start in the same G1 region in which the previous\n-    \/\/ range ended, and adjust the start address so we don't try to free\n-    \/\/ the same region again. If the current range is entirely within that\n-    \/\/ region, skip it.\n-    if (start_region == prev_last_region) {\n-      start_address = start_region->end();\n-      if (start_address > last_address) {\n-        continue;\n-      }\n-      start_region = _hrm.addr_to_region(start_address);\n-    }\n-    prev_last_region = last_region;\n-\n-    \/\/ After verifying that each region was marked as an archive region by\n-    \/\/ alloc_archive_regions, set it free and empty and uncommit it.\n-    HeapRegion* curr_region = start_region;\n-    while (curr_region != NULL) {\n-      guarantee(curr_region->is_archive(),\n-                \"Expected archive region at index %u\", curr_region->hrm_index());\n-      uint curr_index = curr_region->hrm_index();\n-      _archive_set.remove(curr_region);\n-      curr_region->set_free();\n-      curr_region->set_top(curr_region->bottom());\n-      if (curr_region != last_region) {\n-        curr_region = _hrm.next_region_in_heap(curr_region);\n-      } else {\n-        curr_region = NULL;\n-      }\n-\n-      _hrm.shrink_at(curr_index, 1);\n-      shrink_count++;\n-    }\n-  }\n-\n-  if (shrink_count != 0) {\n-    log_debug(gc, ergo, heap)(\"Attempt heap shrinking (archive regions). Total size: \" SIZE_FORMAT \"B\",\n-                              HeapRegion::GrainWords * HeapWordSize * shrink_count);\n-    \/\/ Explicit uncommit.\n-    uncommit_regions(shrink_count);\n-  }\n-  decrease_used(size_used);\n-}\n-\n@@ -1347,10 +1202,0 @@\n-class ArchiveRegionSetChecker : public HeapRegionSetChecker {\n-public:\n-  void check_mt_safety() {\n-    guarantee(!Universe::is_fully_initialized() || SafepointSynchronize::is_at_safepoint(),\n-              \"May only change archive regions during initialization or safepoint.\");\n-  }\n-  bool is_correct_type(HeapRegion* hr) { return hr->is_archive(); }\n-  const char* get_description() { return \"Archive Regions\"; }\n-};\n-\n@@ -1391,1 +1236,0 @@\n-  _archive_set(\"Archive Region Set\", new ArchiveRegionSetChecker()),\n@@ -2296,4 +2140,0 @@\n-bool G1CollectedHeap::is_archived_object(oop object) const {\n-  return object != NULL && heap_region_containing(object)->is_archive();\n-}\n-\n@@ -2381,1 +2221,0 @@\n-               \"OA=open archive, CA=closed archive, \"\n@@ -2812,1 +2651,0 @@\n-                                               const uint archive_regions_removed,\n@@ -2814,1 +2652,1 @@\n-  if (old_regions_removed > 0 || archive_regions_removed > 0 || humongous_regions_removed > 0) {\n+  if (old_regions_removed > 0 || humongous_regions_removed > 0) {\n@@ -2817,1 +2655,0 @@\n-    _archive_set.bulk_remove(archive_regions_removed);\n@@ -2908,3 +2745,1 @@\n-   if (hr->is_archive()) {\n-    _archive_set.remove(hr);\n-  } else if (hr->is_humongous()) {\n+   if (hr->is_humongous()) {\n@@ -2946,1 +2781,0 @@\n-  HeapRegionSet* _archive_set;\n@@ -2956,1 +2790,0 @@\n-                           HeapRegionSet* archive_set,\n@@ -2959,1 +2792,1 @@\n-    _free_list_only(free_list_only), _old_set(old_set), _archive_set(archive_set),\n+    _free_list_only(free_list_only), _old_set(old_set),\n@@ -2964,1 +2797,0 @@\n-      assert(_archive_set->is_empty(), \"pre-condition\");\n@@ -2980,2 +2812,0 @@\n-      } else if (r->is_archive()) {\n-        _archive_set->add(r);\n@@ -2984,1 +2814,1 @@\n-        \/\/ We now move all (non-humongous, non-old, non-archive) regions to old gen,\n+        \/\/ We now move all (non-humongous, non-old) regions to old gen,\n@@ -3009,1 +2839,1 @@\n-                              &_old_set, &_archive_set, &_humongous_set,\n+                              &_old_set, &_humongous_set,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":95,"deletions":265,"binary":false,"changes":360,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-  \/\/ These sets keep track of old, archive and humongous regions respectively.\n+  \/\/ These sets keep track of old and humongous regions respectively.\n@@ -187,1 +187,0 @@\n-  HeapRegionSet _archive_set;\n@@ -705,15 +704,14 @@\n-  \/\/ the containing regions as 'archive'. For use at JVM init time, when the\n-  \/\/ caller may mmap archived heap data at the specified range(s).\n-  \/\/ Verify that the MemRegions specified in the argument array are within the\n-  \/\/ reserved heap.\n-  bool check_archive_addresses(MemRegion* range, size_t count);\n-\n-  \/\/ Commit the appropriate G1 regions containing the specified MemRegions\n-  \/\/ and mark them as 'archive' regions. The regions in the array must be\n-  \/\/ non-overlapping and in order of ascending address.\n-  bool alloc_archive_regions(MemRegion* range, size_t count, bool open);\n-\n-  \/\/ Insert any required filler objects in the G1 regions around the specified\n-  \/\/ ranges to make the regions parseable. This must be called after\n-  \/\/ alloc_archive_regions, and after class loading has occurred.\n-  void fill_archive_regions(MemRegion* range, size_t count);\n+  \/\/ the containing regions as 'old'. For use at JVM init time, when the\n+  \/\/ caller may mmap archived heap data at the specified range.\n+\n+  \/\/ Verify that the range is within the reserved heap.\n+  bool check_archive_addresses(MemRegion range);\n+\n+  \/\/ Execute func(HeapRegion* r, bool is_last) on every region covered by the\n+  \/\/ given range.\n+  template <typename Func>\n+  void iterate_regions_in_range(MemRegion range, const Func& func);\n+\n+  \/\/ Commit the appropriate G1 region(s) containing the specified range\n+  \/\/ and mark them as 'old' region(s).\n+  bool alloc_archive_regions(MemRegion range);\n@@ -722,2 +720,2 @@\n-  \/\/ memory ranges.\n-  void populate_archive_regions_bot_part(MemRegion* range, size_t count);\n+  \/\/ memory range.\n+  void populate_archive_regions_bot_part(MemRegion range);\n@@ -725,1 +723,1 @@\n-  \/\/ For each of the specified MemRegions, uncommit the containing G1 regions\n+  \/\/ For the specified range, uncommit the containing G1 regions\n@@ -727,3 +725,3 @@\n-  \/\/ rather than fill_archive_regions at JVM init time if the archive file\n-  \/\/ mapping failed, with the same non-overlapping and sorted MemRegion array.\n-  void dealloc_archive_regions(MemRegion* range, size_t count);\n+  \/\/ at JVM init time if the archive heap's contents cannot be used (e.g., if\n+  \/\/ CRC check fails).\n+  void dealloc_archive_regions(MemRegion range);\n@@ -1006,2 +1004,0 @@\n-  inline void archive_set_add(HeapRegion* hr);\n-\n@@ -1009,1 +1005,1 @@\n-    return (old_regions_count() + _archive_set.length() + humongous_regions_count()) * HeapRegion::GrainBytes;\n+    return (old_regions_count() + humongous_regions_count()) * HeapRegion::GrainBytes;\n@@ -1028,1 +1024,0 @@\n-                                const uint archive_regions_removed,\n@@ -1218,1 +1213,0 @@\n-  uint archive_regions_count() const { return _archive_set.length(); }\n@@ -1285,2 +1279,0 @@\n-  bool is_archived_object(oop object) const override;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":22,"deletions":30,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,4 +151,0 @@\n-inline void G1CollectedHeap::archive_set_add(HeapRegion* hr) {\n-  _archive_set.add(hr);\n-}\n-\n@@ -265,1 +261,1 @@\n-   return !is_marked(obj) && !hr->is_closed_archive();\n+   return !is_marked(obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,3 +87,2 @@\n-    \/\/ pinned after being added to the collection set candidates. Archive regions\n-    \/\/ should never have been added to the collection set though.\n-    guarantee((cur->is_pinned() && !cur->is_archive()) ||\n+    \/\/ pinned after being added to the collection set candidates.\n+    guarantee(cur->is_pinned() ||\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -195,1 +195,1 @@\n-        assert(r->is_archive() || !r->is_old() || !r->rem_set()->is_tracked(),\n+        assert(!r->is_old() || !r->rem_set()->is_tracked(),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1332,1 +1332,0 @@\n-    uint _archive_regions_removed;\n@@ -1342,1 +1341,0 @@\n-      _archive_regions_removed(0),\n@@ -1347,1 +1345,0 @@\n-    const uint archive_regions_removed() { return _archive_regions_removed; }\n@@ -1351,1 +1348,1 @@\n-      if (hr->used() > 0 && hr->live_bytes() == 0 && !hr->is_young() && !hr->is_closed_archive()) {\n+      if (hr->used() > 0 && hr->live_bytes() == 0 && !hr->is_young()) {\n@@ -1359,3 +1356,0 @@\n-        } else if (hr->is_open_archive()) {\n-          _archive_regions_removed++;\n-          _g1h->free_region(hr, _local_cleanup_list);\n@@ -1392,1 +1386,1 @@\n-    \/\/ Now update the old\/archive\/humongous region sets\n+    \/\/ Now update the old\/humongous region sets\n@@ -1394,1 +1388,0 @@\n-                                   cl.archive_regions_removed(),\n@@ -1893,1 +1886,0 @@\n-        assert(!curr_region->is_closed_archive(), \"CA regions should be skipped\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,5 +57,0 @@\n-  \/\/ All objects in closed archive regions are live.\n-  if (hr->is_closed_archive()) {\n-    return true;\n-  }\n-\n@@ -75,1 +70,1 @@\n-  return _g1h->heap_region_containing(obj)->is_old_or_humongous_or_archive();\n+  return _g1h->heap_region_containing(obj)->is_old_or_humongous();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.inline.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -260,2 +260,0 @@\n-  } else if (hr->is_closed_archive()) {\n-    _region_attr_table.set_skip_marking(hr->hrm_index());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -133,1 +133,0 @@\n-  inline bool is_skip_marking(oop obj) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,4 +43,0 @@\n-bool G1FullCollector::is_skip_marking(oop obj) const {\n-  return _region_attr_table.is_skip_marking(cast_from_oop<HeapWord*>(obj));\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,4 +71,2 @@\n-    } else if (!r->is_closed_archive() && !r->is_free()) {\n-      \/\/ Closed archive regions never change references and only contain\n-      \/\/ references into other closed regions and are always live. Free\n-      \/\/ regions do not contain objects to iterate. So skip both.\n+    } else if (!r->is_free()) {\n+      \/\/ Free regions do not contain objects to iterate. So skip them.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCAdjustTask.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-\/\/ the table specifies whether a Full GC cycle should be compacting, skip\n-\/\/ compacting, or skip marking (liveness analysis) a region.\n+\/\/ the table specifies whether a Full GC cycle should be compacting or skip\n+\/\/ compacting a region.\n@@ -39,1 +39,0 @@\n-\/\/ The only examples for skipping marking for regions are Closed Archive regions.\n@@ -43,2 +42,1 @@\n-  static const uint8_t SkipMarking = 2;      \/\/ Region contents are not even marked through, but contain live objects.\n-  static const uint8_t Free = 3;             \/\/ Regions is free.\n+  static const uint8_t Free = 2;             \/\/ Region is free.\n@@ -59,1 +57,0 @@\n-  void set_skip_marking(uint idx) { set_by_index(idx, SkipMarking); }\n@@ -63,5 +60,0 @@\n-  bool is_skip_marking(HeapWord* obj) const {\n-    assert(!is_free(obj), \"Should not have objects in free regions.\");\n-    return get_by_address(obj) == SkipMarking;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCHeapRegionAttr.hpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -48,4 +48,0 @@\n-  if (_collector->is_skip_marking(obj)) {\n-    return false;\n-  }\n-\n@@ -86,4 +82,0 @@\n-      assert(_bitmap->is_marked(obj), \"Must be marked now - map self\");\n-    } else {\n-      assert(_bitmap->is_marked(obj) || _collector->is_skip_marking(obj),\n-             \"Must be marked by other or object in skip marking region\");\n@@ -91,0 +83,1 @@\n+    assert(_bitmap->is_marked(obj), \"Must be marked\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.inline.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  return _bitmap->is_marked(p) || _collector->is_skip_marking(p);\n+  return _bitmap->is_marked(p);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,2 +51,0 @@\n-  assert(!hr->is_closed_archive(), \"must be\");\n-  assert(!hr->is_open_archive(), \"must be\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,7 +95,0 @@\n-    } else if (hr->is_open_archive()) {\n-      bool is_empty = _collector->live_words(hr->hrm_index()) == 0;\n-      if (is_empty) {\n-        free_pinned_region<false>(hr);\n-      }\n-    } else if (hr->is_closed_archive()) {\n-      \/\/ nothing to do with closed archive region\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.inline.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    assert(_collector->is_skip_compacting(region_idx) || hr->is_closed_archive(), \"must be\");\n+    assert(_collector->is_skip_compacting(region_idx), \"must be\");\n@@ -93,6 +93,0 @@\n-  } else if (hr->is_open_archive()) {\n-    bool is_empty = (_collector->live_words(hr->hrm_index()) == 0);\n-    assert(!is_empty, \"should contain at least one live obj\");\n-  } else if (hr->is_closed_archive()) {\n-    \/\/ should early-return above\n-    ShouldNotReachHere();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCResetMetadataTask.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,2 +40,0 @@\n-    OpenArchive,\n-    ClosedArchive,\n@@ -53,2 +51,0 @@\n-      case OpenArchive:        return \"OpenArchive\";\n-      case ClosedArchive:      return \"ClosedArchive\";\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionTraceType.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-  _archive_length(g1_heap->archive_regions_count()),\n@@ -70,1 +69,0 @@\n-  size_t _archive_used;\n@@ -76,1 +74,0 @@\n-  size_t _archive_region_count;\n@@ -80,1 +77,1 @@\n-    _eden_used(0), _survivor_used(0), _old_used(0), _archive_used(0), _humongous_used(0),\n+    _eden_used(0), _survivor_used(0), _old_used(0), _humongous_used(0),\n@@ -82,1 +79,1 @@\n-    _archive_region_count(0), _humongous_region_count(0) {}\n+    _humongous_region_count(0) {}\n@@ -92,3 +89,0 @@\n-    } else if (r->is_archive()) {\n-      _usage._archive_used += r->used();\n-      _usage._archive_region_count++;\n@@ -155,2 +149,0 @@\n-    assert(usage._archive_region_count == after._archive_length, \"Expected archive to be \" SIZE_FORMAT \" but was \" SIZE_FORMAT,\n-        after._archive_length, usage._archive_region_count);\n@@ -175,5 +167,0 @@\n-  log_info(gc, heap)(\"Archive regions: \" SIZE_FORMAT \"->\" SIZE_FORMAT,\n-                     _before._archive_length, after._archive_length);\n-  log_trace(gc, heap)(\" Used: \" SIZE_FORMAT \"K, Waste: \" SIZE_FORMAT \"K\",\n-      usage._archive_used \/ K, ((after._archive_length * HeapRegion::GrainBytes) - usage._archive_used) \/ K);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapTransition.cpp","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n-    size_t _archive_length;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapTransition.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -236,93 +236,0 @@\n-class VerifyArchiveOopClosure: public BasicOopIterateClosure {\n-  HeapRegion* _hr;\n-public:\n-  VerifyArchiveOopClosure(HeapRegion *hr) : _hr(hr) { }\n-  void do_oop(narrowOop *p) { do_oop_work(p); }\n-  void do_oop(      oop *p) { do_oop_work(p); }\n-\n-  template <class T> void do_oop_work(T *p) {\n-    oop obj = RawAccess<>::oop_load(p);\n-\n-    if (_hr->is_open_archive()) {\n-      guarantee(obj == NULL || G1CollectedHeap::heap()->heap_region_containing(obj)->is_archive(),\n-                \"Archive object at \" PTR_FORMAT \" references a non-archive object at \" PTR_FORMAT,\n-                p2i(p), p2i(obj));\n-    } else {\n-      assert(_hr->is_closed_archive(), \"should be closed archive region\");\n-      guarantee(obj == NULL || G1CollectedHeap::heap()->heap_region_containing(obj)->is_closed_archive(),\n-                \"Archive object at \" PTR_FORMAT \" references a non-archive object at \" PTR_FORMAT,\n-                p2i(p), p2i(obj));\n-    }\n-  }\n-};\n-\n-class VerifyObjectInArchiveRegionClosure: public ObjectClosure {\n-  HeapRegion* _hr;\n-public:\n-  VerifyObjectInArchiveRegionClosure(HeapRegion *hr, bool verbose)\n-    : _hr(hr) { }\n-  \/\/ Verify that all object pointers are to archive regions.\n-  void do_object(oop o) {\n-    VerifyArchiveOopClosure checkOop(_hr);\n-    assert(o != NULL, \"Should not be here for NULL oops\");\n-    o->oop_iterate(&checkOop);\n-  }\n-};\n-\n-\/\/ Should be only used at CDS dump time\n-class VerifyReadyForArchivingRegionClosure : public HeapRegionClosure {\n-  bool _seen_free;\n-  bool _has_holes;\n-  bool _has_unexpected_holes;\n-  bool _has_humongous;\n-public:\n-  bool has_holes() {return _has_holes;}\n-  bool has_unexpected_holes() {return _has_unexpected_holes;}\n-  bool has_humongous() {return _has_humongous;}\n-\n-  VerifyReadyForArchivingRegionClosure() : HeapRegionClosure() {\n-    _seen_free = false;\n-    _has_holes = false;\n-    _has_unexpected_holes = false;\n-    _has_humongous = false;\n-  }\n-  virtual bool do_heap_region(HeapRegion* hr) {\n-    const char* hole = \"\";\n-\n-    if (hr->is_free()) {\n-      _seen_free = true;\n-    } else {\n-      if (_seen_free) {\n-        _has_holes = true;\n-        if (hr->is_humongous()) {\n-          hole = \" hole\";\n-        } else {\n-          _has_unexpected_holes = true;\n-          hole = \" hole **** unexpected ****\";\n-        }\n-      }\n-    }\n-    if (hr->is_humongous()) {\n-      _has_humongous = true;\n-    }\n-    log_info(gc, region, cds)(\"HeapRegion \" PTR_FORMAT \" %s%s\", p2i(hr->bottom()), hr->get_type_str(), hole);\n-    return false;\n-  }\n-};\n-\n-class VerifyArchivePointerRegionClosure: public HeapRegionClosure {\n-  virtual bool do_heap_region(HeapRegion* r) {\n-   if (r->is_archive()) {\n-      VerifyObjectInArchiveRegionClosure verify_oop_pointers(r, false);\n-      r->object_iterate(&verify_oop_pointers);\n-    }\n-    return false;\n-  }\n-};\n-\n-void G1HeapVerifier::verify_archive_regions() {\n-  G1CollectedHeap*  g1h = G1CollectedHeap::heap();\n-  VerifyArchivePointerRegionClosure cl;\n-  g1h->heap_region_iterate(&cl);\n-}\n-\n@@ -349,8 +256,1 @@\n-    \/\/ For archive regions, verify there are no heap pointers to non-pinned regions.\n-    if (r->is_closed_archive()) {\n-      VerifyObjectInArchiveRegionClosure verify_oop_pointers(r, false);\n-      r->object_iterate(&verify_oop_pointers);\n-    } else if (r->is_open_archive()) {\n-      VerifyObjsInRegionClosure verify_open_archive_oop(r, _vo);\n-      r->object_iterate(&verify_open_archive_oop);\n-    } else if (r->is_continues_humongous()) {\n+    if (r->is_continues_humongous()) {\n@@ -485,1 +385,0 @@\n-  HeapRegionSet*   _archive_set;\n@@ -491,1 +390,0 @@\n-  uint _archive_count;\n@@ -496,1 +394,0 @@\n-                           HeapRegionSet* archive_set,\n@@ -499,2 +396,2 @@\n-    _old_set(old_set), _archive_set(archive_set), _humongous_set(humongous_set), _hrm(hrm),\n-    _old_count(), _archive_count(), _humongous_count(), _free_count(){ }\n+    _old_set(old_set), _humongous_set(humongous_set), _hrm(hrm),\n+    _old_count(), _humongous_count(), _free_count(){ }\n@@ -511,3 +408,0 @@\n-    } else if (hr->is_archive()) {\n-      assert(hr->containing_set() == _archive_set, \"Heap region %u is archive but not in the archive set.\", hr->hrm_index());\n-      _archive_count++;\n@@ -520,1 +414,1 @@\n-      assert(!hr->is_pinned(), \"Heap region %u is pinned but not old (archive) or humongous.\", hr->hrm_index());\n+      assert(!hr->is_pinned(), \"Heap region %u is pinned but not old or humongous.\", hr->hrm_index());\n@@ -526,1 +420,1 @@\n-  void verify_counts(HeapRegionSet* old_set, HeapRegionSet* archive_set, HeapRegionSet* humongous_set, HeapRegionManager* free_list) {\n+  void verify_counts(HeapRegionSet* old_set, HeapRegionSet* humongous_set, HeapRegionManager* free_list) {\n@@ -528,1 +422,0 @@\n-    guarantee(archive_set->length() == _archive_count, \"Archive set count mismatch. Expected %u, actual %u.\", archive_set->length(), _archive_count);\n@@ -543,1 +436,1 @@\n-  VerifyRegionListsClosure cl(&_g1h->_old_set, &_g1h->_archive_set, &_g1h->_humongous_set, &_g1h->_hrm);\n+  VerifyRegionListsClosure cl(&_g1h->_old_set, &_g1h->_humongous_set, &_g1h->_hrm);\n@@ -545,1 +438,1 @@\n-  cl.verify_counts(&_g1h->_old_set, &_g1h->_archive_set, &_g1h->_humongous_set, &_g1h->_hrm);\n+  cl.verify_counts(&_g1h->_old_set, &_g1h->_humongous_set, &_g1h->_hrm);\n@@ -696,5 +589,0 @@\n-        if (hr->is_archive()) {\n-          log_error(gc, verify)(\"## is_archive in collection set for region %u\", i);\n-          _failures = true;\n-          return true;\n-        }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":7,"deletions":119,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -83,2 +83,0 @@\n-\n-  static void verify_archive_regions();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -202,1 +202,1 @@\n-  \/\/ entries from free or archive regions.\n+  \/\/ entries from free regions.\n@@ -330,1 +330,1 @@\n-    return (hr != NULL && !hr->in_collection_set() && hr->is_old_or_humongous_or_archive());\n+    return (hr != NULL && !hr->in_collection_set() && hr->is_old_or_humongous());\n@@ -429,1 +429,1 @@\n-   assert(!hr->in_collection_set() && hr->is_old_or_humongous_or_archive(),\n+   assert(!hr->in_collection_set() && hr->is_old_or_humongous(),\n@@ -717,1 +717,1 @@\n-    assert(!r->in_collection_set() && r->is_old_or_humongous_or_archive(),\n+    assert(!r->in_collection_set() && r->is_old_or_humongous(),\n@@ -886,1 +886,1 @@\n-  } else if (r->is_old_or_humongous_or_archive()) {\n+  } else if (r->is_old_or_humongous()) {\n@@ -1479,1 +1479,1 @@\n-  if (!r->is_old_or_humongous_or_archive()) {\n+  if (!r->is_old_or_humongous()) {\n@@ -1488,3 +1488,2 @@\n-  \/\/ Non-humongous objects are either allocated in the old regions during GC,\n-  \/\/ or mapped in archive regions during startup. So if region is old or\n-  \/\/ archive then top is stable.\n+  \/\/ Non-humongous objects are either allocated in the old regions during GC.\n+  \/\/ So if region is old then top is stable.\n@@ -1521,1 +1520,1 @@\n-  \/\/ fence, because top is stable for old, archive and unfiltered humongous\n+  \/\/ fence, because top is stable for old and unfiltered humongous\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -190,1 +190,0 @@\n-  RegionTypeCounter _archive;\n@@ -214,1 +213,1 @@\n-    _free(\"Free\"), _old(\"Old\"), _archive(\"Archive\"), _all(\"All\"),\n+    _free(\"Free\"), _old(\"Old\"), _all(\"All\"),\n@@ -247,2 +246,0 @@\n-    } else if (r->is_archive()) {\n-      current = &_archive;\n@@ -261,1 +258,1 @@\n-    RegionTypeCounter* counters[] = { &_young, &_humongous, &_free, &_old, &_archive, NULL };\n+    RegionTypeCounter* counters[] = { &_young, &_humongous, &_free, &_old, NULL };\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,2 @@\n-  \/\/ All non-free, non-young, non-closed archive regions need to be scanned for references;\n-  \/\/ At every gc we gather references to other regions in young, and closed archive\n-  \/\/ regions by definition do not have references going outside the closed archive.\n+  \/\/ All non-free and non-young regions need to be scanned for references;\n+  \/\/ At every gc we gather references to other regions in young.\n@@ -38,1 +37,1 @@\n-  return !(r->is_young() || r->is_closed_archive() || r->is_free());\n+  return !(r->is_young() || r->is_free());\n@@ -48,3 +47,0 @@\n-  } else if (r->is_archive()) {\n-    \/\/ Archive regions never move ever. So never build remembered sets for them.\n-    r->rem_set()->set_state_untracked();\n@@ -82,4 +78,0 @@\n-  if (r->is_archive()) {\n-    return false;\n-  }\n-\n@@ -107,3 +99,2 @@\n-  \/\/ Only consider updating the remembered set for old gen regions - excluding archive regions\n-  \/\/ which never move (but are \"Old\" regions).\n-  if (!r->is_old() || r->is_archive()) {\n+  \/\/ Only consider updating the remembered set for old gen regions.\n+  if (!r->is_old()) {\n@@ -140,1 +131,1 @@\n-  if (r->is_old_or_humongous_or_archive()) {\n+  if (r->is_old_or_humongous()) {\n@@ -142,1 +133,0 @@\n-      assert(!r->is_archive(), \"Archive region %u with remembered set\", r->hrm_index());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetTrackingPolicy.cpp","additions":7,"deletions":17,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n-    g1h->remove_from_old_gen_sets(0, 0, _humongous_regions_reclaimed);\n+    g1h->remove_from_old_gen_sets(0, _humongous_regions_reclaimed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -182,10 +182,0 @@\n-void HeapRegion::set_open_archive() {\n-  report_region_type_change(G1HeapRegionTraceType::OpenArchive);\n-  _type.set_open_archive();\n-}\n-\n-void HeapRegion::set_closed_archive() {\n-  report_region_type_change(G1HeapRegionTraceType::ClosedArchive);\n-  _type.set_closed_archive();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -378,3 +378,2 @@\n-  \/\/ This set only includes old and open archive regions - humongous regions only\n-  \/\/ contain a single object which is either dead or live, contents of closed archive\n-  \/\/ regions never die (so is always contiguous), and young regions are never even\n+  \/\/ This set only includes old regions - humongous regions only\n+  \/\/ contain a single object which is either dead or live, and young regions are never even\n@@ -382,1 +381,1 @@\n-  bool needs_scrubbing() const { return is_old() || is_open_archive(); }\n+  bool needs_scrubbing() const { return is_old(); }\n@@ -406,2 +405,0 @@\n-  bool is_old_or_humongous_or_archive() const { return _type.is_old_or_humongous_or_archive(); }\n-\n@@ -409,1 +406,1 @@\n-  \/\/ Humongous regions and archive regions are pinned.\n+  \/\/ Humongous regions are pinned.\n@@ -412,7 +409,0 @@\n-  \/\/ An archive region is a pinned region, also tagged as old, which\n-  \/\/ should not be marked during mark\/sweep. This allows the address\n-  \/\/ space to be shared by JVM instances.\n-  bool is_archive()        const { return _type.is_archive(); }\n-  bool is_open_archive()   const { return _type.is_open_archive(); }\n-  bool is_closed_archive() const { return _type.is_closed_archive(); }\n-\n@@ -428,3 +418,0 @@\n-  void set_open_archive();\n-  void set_closed_archive();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":5,"deletions":18,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -145,5 +145,0 @@\n-  \/\/ Objects in closed archive regions are always live.\n-  if (is_closed_archive()) {\n-    return false;\n-  }\n-\n@@ -297,4 +292,1 @@\n-  assert(!is_closed_archive() || top_at_mark_start() == bottom(), \"CA region's TAMS must always be at bottom\");\n-  if (!is_closed_archive()) {\n-    set_top_at_mark_start(top());\n-  }\n+  set_top_at_mark_start(top());\n@@ -499,1 +491,1 @@\n-  assert(is_old() || is_archive(), \"Wrongly trying to iterate over region %u type %s\", _hrm_index, get_type_str());\n+  assert(is_old(), \"Wrongly trying to iterate over region %u type %s\", _hrm_index, get_type_str());\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,2 +40,1 @@\n-  assert(!hr->is_empty() || hr->is_free() || hr->is_archive(),\n-         \"Empty region %u is not free or archive for set %s\", hr->hrm_index(), name());\n+  assert(!hr->is_empty() || hr->is_free(), \"Empty region %u is not free or old for set %s\", hr->hrm_index(), name());\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionSet.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,0 @@\n-    case OpenArchiveTag:\n-    case ClosedArchiveTag:\n@@ -59,2 +57,0 @@\n-    case OpenArchiveTag:        return \"OARC\";\n-    case ClosedArchiveTag:      return \"CARC\";\n@@ -76,2 +72,0 @@\n-    case OpenArchiveTag:        return \"OA\";\n-    case ClosedArchiveTag:      return \"CA\";\n@@ -93,2 +87,0 @@\n-    case OpenArchiveTag:        return G1HeapRegionTraceType::OpenArchive;\n-    case ClosedArchiveTag:      return G1HeapRegionTraceType::ClosedArchive;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionType.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-  \/\/   major type (young, old, humongous, archive)           : top N-1 bits\n+  \/\/   major type (young, old, humongous)                    : top N-1 bits\n@@ -61,4 +61,0 @@\n-  \/\/ 10000 0 [32] Archive Mask\n-  \/\/ 10100 0 [40] Open Archive\n-  \/\/ 10100 1 [41] Closed Archive\n-  \/\/\n@@ -78,14 +74,1 @@\n-    OldTag                = OldMask,\n-\n-    \/\/ Archive regions are regions with immutable content (i.e. not reclaimed, and\n-    \/\/ not allocated into during regular operation). They differ in the kind of references\n-    \/\/ allowed for the contained objects:\n-    \/\/ - Closed archive regions form a separate self-contained (closed) object graph\n-    \/\/ within the set of all of these regions. No references outside of closed\n-    \/\/ archive regions are allowed.\n-    \/\/ - Open archive regions have no restrictions on the references of their objects.\n-    \/\/ Objects within these regions are allowed to have references to objects\n-    \/\/ contained in any other kind of regions.\n-    ArchiveMask           = 32,\n-    OpenArchiveTag        = ArchiveMask | PinnedMask,\n-    ClosedArchiveTag      = ArchiveMask | PinnedMask + 1\n+    OldTag                = OldMask\n@@ -137,4 +120,0 @@\n-  bool is_archive()        const { return (get() & ArchiveMask) != 0; }\n-  bool is_open_archive()   const { return get() == OpenArchiveTag; }\n-  bool is_closed_archive() const { return get() == ClosedArchiveTag; }\n-\n@@ -146,3 +125,0 @@\n-  bool is_old_or_humongous_or_archive() const { return (get() & (OldMask | HumongousMask | ArchiveMask)) != 0; }\n-\n-  \/\/ is_pinned regions may be archive or humongous\n@@ -183,2 +159,0 @@\n-  void set_open_archive()   { set_from(OpenArchiveTag, FreeTag); }\n-  void set_closed_archive() { set_from(ClosedArchiveTag, FreeTag); }\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionType.hpp","additions":3,"deletions":29,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,0 @@\n-  nonstatic_field(G1CollectedHeap, _archive_set,        HeapRegionSetBase)    \\\n@@ -83,1 +82,0 @@\n-  declare_constant(HeapRegionType::ArchiveMask)                               \\\n","filename":"src\/hotspot\/share\/gc\/g1\/vmStructs_g1.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -641,4 +641,0 @@\n-bool CollectedHeap::is_archived_object(oop object) const {\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -516,3 +516,0 @@\n-  \/\/ Is the given object inside a CDS archive area?\n-  virtual bool is_archived_object(oop object) const;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-#define NUM_CDS_REGIONS 7 \/\/ this must be the same as MetaspaceShared::n_regions\n+#define NUM_CDS_REGIONS 4 \/\/ this must be the same as MetaspaceShared::n_regions\n@@ -42,1 +42,1 @@\n-#define CURRENT_CDS_ARCHIVE_VERSION 17\n+#define CURRENT_CDS_ARCHIVE_VERSION 18\n","filename":"src\/hotspot\/share\/include\/cds.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,2 +59,0 @@\n-        \/\/ It's only reachable via HeapShared::roots(). All of its fields should be zero\n-        \/\/ so there's no need to scan.\n@@ -62,1 +60,0 @@\n-        return;\n","filename":"src\/hotspot\/share\/oops\/instanceMirrorKlass.inline.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -234,7 +234,0 @@\n-void oopDesc::verify_forwardee(oop forwardee) {\n-#if INCLUDE_CDS_JAVA_HEAP\n-  assert(!Universe::heap()->is_archived_object(forwardee) && !Universe::heap()->is_archived_object(this),\n-         \"forwarding archive object\");\n-#endif\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -260,2 +260,0 @@\n-  void verify_forwardee(oop forwardee) NOT_DEBUG_RETURN;\n-\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -269,1 +269,0 @@\n-  verify_forwardee(p);\n@@ -276,1 +275,0 @@\n-  verify_forwardee(p);\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2009,5 +2009,0 @@\n-WB_ENTRY(jboolean, WB_IsShared(JNIEnv* env, jobject wb, jobject obj))\n-  oop obj_oop = JNIHandles::resolve(obj);\n-  return Universe::heap()->is_archived_object(obj_oop);\n-WB_END\n-\n@@ -2027,13 +2022,1 @@\n-  return ArchiveHeapLoader::closed_regions_mapped();\n-WB_END\n-\n-WB_ENTRY(jobject, WB_GetResolvedReferences(JNIEnv* env, jobject wb, jclass clazz))\n-  Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));\n-  if (k->is_instance_klass()) {\n-    InstanceKlass *ik = InstanceKlass::cast(k);\n-    ConstantPool *cp = ik->constants();\n-    objArrayOop refs =  cp->resolved_references();\n-    return (jobject)JNIHandles::make_local(THREAD, refs);\n-  } else {\n-    return nullptr;\n-  }\n+  return ArchiveHeapLoader::is_mapped();\n@@ -2052,1 +2035,1 @@\n-  return ArchiveHeapLoader::open_regions_mapped();\n+  return ArchiveHeapLoader::is_mapped();\n@@ -2769,1 +2752,0 @@\n-  {CC\"isShared\",           CC\"(Ljava\/lang\/Object;)Z\", (void*)&WB_IsShared },\n@@ -2773,1 +2755,0 @@\n-  {CC\"getResolvedReferences\", CC\"(Ljava\/lang\/Class;)Ljava\/lang\/Object;\", (void*)&WB_GetResolvedReferences},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":2,"deletions":21,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,2 +60,0 @@\n-    \/\/ HeapRegionSet _archive_set;\n-    private static long archiveSetFieldOffset;\n@@ -80,1 +78,0 @@\n-        archiveSetFieldOffset = type.getField(\"_archive_set\").getOffset();\n@@ -111,5 +108,0 @@\n-    public HeapRegionSetBase archiveSet() {\n-        Address archiveSetAddr = addr.addOffsetTo(archiveSetFieldOffset);\n-        return VMObjectFactory.newObject(HeapRegionSetBase.class, archiveSetAddr);\n-    }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/G1CollectedHeap.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,0 @@\n-    private static int archiveMask;\n@@ -73,1 +72,0 @@\n-        archiveMask = db.lookupIntConstant(\"HeapRegionType::ArchiveMask\");\n@@ -107,4 +105,0 @@\n-    public boolean isArchive() {\n-        return (tagField.getValue(addr) & archiveMask) != 0;\n-    }\n-\n@@ -139,3 +133,0 @@\n-        if (isArchive()) {\n-            return \"Archive\";\n-        }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/HeapRegionType.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -251,1 +251,0 @@\n-      HeapRegionSetBase archiveSet = g1h.archiveSet();\n@@ -253,1 +252,1 @@\n-      long oldGenRegionNum = oldSet.length() + archiveSet.length() + humongousSet.length();\n+      long oldGenRegionNum = oldSet.length() + humongousSet.length();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/HeapSummary.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-        Pattern pattern = Pattern.compile(\"(..)  space: *([0-9]+).* out of *([0-9]+) bytes .* at 0x([0-9a0-f]+)\");\n+        Pattern pattern = Pattern.compile(\"(..) space: *([0-9]+).* out of *([0-9]+) bytes .* at 0x([0-9a0-f]+)\");\n@@ -66,6 +66,5 @@\n-        \/\/ [4.682s][debug][cds] rw  space:   4391632 [ 33.7% of total] out of   4395008 bytes [ 99.9% used] at 0x0000000800007000\n-        \/\/ [4.682s][debug][cds] ro  space:   7570632 [ 58.0% of total] out of   7573504 bytes [100.0% used] at 0x0000000800438000\n-        \/\/ [4.682s][debug][cds] bm  space:    213528 [  1.6% of total] out of    213528 bytes [100.0% used]\n-        \/\/ [4.682s][debug][cds] ca0 space:    507904 [  3.9% of total] out of    507904 bytes [100.0% used] at 0x00000000fff00000\n-        \/\/ [4.682s][debug][cds] oa0 space:    327680 [  2.5% of total] out of    327680 bytes [100.0% used] at 0x00000000ffe00000\n-        \/\/ [4.682s][debug][cds] total    :  13036288 [100.0% of total] out of  13049856 bytes [ 99.9% used]\n+        \/\/ [0.938s][debug][cds] rw space:   5253952 [ 35.2% of total] out of   5255168 bytes [100.0% used] at 0x0000000800000000\n+        \/\/ [0.938s][debug][cds] ro space:   8353976 [ 55.9% of total] out of   8355840 bytes [100.0% used] at 0x0000000800503000\n+        \/\/ [0.938s][debug][cds] bm space:    262232 [  1.8% of total] out of    262232 bytes [100.0% used]\n+        \/\/ [0.938s][debug][cds] hp space:   1057712 [  7.1% of total] out of   1057712 bytes [100.0% used] at 0x00007fa24c180090\n+        \/\/ [0.938s][debug][cds] total   :  14927872 [100.0% of total] out of  14934960 bytes [100.0% used]\n@@ -76,1 +75,1 @@\n-            if (line.contains(\" space:\") && !line.contains(\"st space:\")) {\n+            if (line.contains(\" space:\")) {\n@@ -80,0 +79,3 @@\n+                    if (!name.equals(\"rw\") && ! name.equals(\"ro\")) {\n+                        continue;\n+                    }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/SpaceUtilizationCheck.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,4 +53,1 @@\n-        \"first_closed_archive\",\n-        \"last_closed_archive\",\n-        \"first_open_archive\",\n-        \"last_open_archive\"\n+        \"hp\",          \/\/ heap\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/SharedArchiveConsistency.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- * @build jdk.test.whitebox.WhiteBox\n@@ -33,1 +32,0 @@\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar WhiteBox.jar jdk.test.whitebox.WhiteBox\n@@ -47,2 +45,0 @@\n-        String wbJar = ClassFileInstaller.getJarPath(\"WhiteBox.jar\");\n-        String use_whitebox_jar = \"-Xbootclasspath\/a:\" + wbJar;\n@@ -58,2 +54,1 @@\n-                TestCommon.list(\"CheckIntegerCacheApp\"),\n-                use_whitebox_jar);\n+                TestCommon.list(\"CheckIntegerCacheApp\"));\n@@ -65,3 +60,1 @@\n-        output = TestCommon.exec(appJar, use_whitebox_jar,\n-                \"-XX:+UnlockDiagnosticVMOptions\",\n-                \"-XX:+WhiteBoxAPI\",\n+        output = TestCommon.exec(appJar,\n@@ -69,2 +62,1 @@\n-                \"127\",\n-                \"true\");\n+                \"127\");\n@@ -77,3 +69,1 @@\n-        output = TestCommon.exec(appJar, use_whitebox_jar,\n-                \"-XX:+UnlockDiagnosticVMOptions\",\n-                \"-XX:+WhiteBoxAPI\",\n+        output = TestCommon.exec(appJar,\n@@ -82,2 +72,1 @@\n-                \"20000\",\n-                \"false\");\n+                \"20000\");\n@@ -91,2 +80,1 @@\n-                \"-XX:AutoBoxCacheMax=20000\",\n-                use_whitebox_jar);\n+                \"-XX:AutoBoxCacheMax=20000\");\n@@ -99,1 +87,1 @@\n-        output = TestCommon.exec(appJar, use_whitebox_jar,\n+        output = TestCommon.exec(appJar,\n@@ -102,2 +90,0 @@\n-                \"-XX:+UnlockDiagnosticVMOptions\",\n-                \"-XX:+WhiteBoxAPI\",\n@@ -105,2 +91,1 @@\n-                \"127\",\n-                \"true\");\n+                \"127\");\n@@ -114,1 +99,1 @@\n-        output = TestCommon.exec(appJar, use_whitebox_jar,\n+        output = TestCommon.exec(appJar,\n@@ -117,2 +102,0 @@\n-                \"-XX:+UnlockDiagnosticVMOptions\",\n-                \"-XX:+WhiteBoxAPI\",\n@@ -121,2 +104,1 @@\n-                \"20000\",\n-                \"true\");\n+                \"20000\");\n@@ -129,1 +111,1 @@\n-        output = TestCommon.exec(appJar, use_whitebox_jar,\n+        output = TestCommon.exec(appJar,\n@@ -132,2 +114,0 @@\n-                \"-XX:+UnlockDiagnosticVMOptions\",\n-                \"-XX:+WhiteBoxAPI\",\n@@ -136,2 +116,1 @@\n-                \"30000\",\n-                \"false\");\n+                \"30000\");\n@@ -149,2 +128,1 @@\n-                \"-Xlog:gc+region=trace\",\n-                use_whitebox_jar);\n+                \"-Xlog:gc+region=trace\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/ArchivedIntegerCacheTest.java","additions":13,"deletions":35,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1,189 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test archived system module sub-graph and verify objects are archived.\n- * @requires vm.cds.write.archived.java.heap\n- * @library \/test\/jdk\/lib\/testlibrary \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n- * @build jdk.test.whitebox.WhiteBox\n- * @compile CheckArchivedModuleApp.java\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar CheckArchivedModuleApp\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar WhiteBox.jar jdk.test.whitebox.WhiteBox\n- * @run driver ArchivedModuleComboTest\n- *\/\n-\n-import java.io.File;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.cds.CDSTestUtils;\n-import jdk.test.lib.helpers.ClassFileInstaller;\n-import jdk.test.whitebox.WhiteBox;\n-\n-public class ArchivedModuleComboTest {\n-    public static void main(String[] args) throws Exception {\n-        String wbJar = ClassFileInstaller.getJarPath(\"WhiteBox.jar\");\n-        String use_whitebox_jar = \"-Xbootclasspath\/a:\" + wbJar;\n-        String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n-\n-        Path userDir = Paths.get(CDSTestUtils.getOutputDir());\n-        Path moduleDir = Files.createTempDirectory(userDir, \"mods\");\n-\n-        \/\/\n-        \/\/ Dump without --module-path, without --show-module-resolution\n-        \/\/\n-        OutputAnalyzer output = TestCommon.dump(appJar,\n-                                    TestCommon.list(\"CheckArchivedModuleApp\"),\n-                                    use_whitebox_jar);\n-        TestCommon.checkDump(output);\n-\n-        \/\/ Test case 1)\n-        \/\/ - Dump without --module-path, without --show-module-resolution\n-        \/\/ - Run from -cp only and without --show-module-resolution\n-        \/\/     + archived boot layer module ModuleDescriptors should be used\n-        \/\/     + archived boot layer configuration should be used\n-        System.out.println(\"----------------------- Test case 1 ----------------------\");\n-        output = TestCommon.exec(appJar, use_whitebox_jar,\n-                                 \"-XX:+UnlockDiagnosticVMOptions\",\n-                                 \"-XX:+WhiteBoxAPI\",\n-                                 \"CheckArchivedModuleApp\",\n-                                 \"yes\",\n-                                 \"yes\");\n-        TestCommon.checkExec(output);\n-\n-        \/\/ Test case 2)\n-        \/\/ - Dump without --module-path, without --show-module-resolution\n-        \/\/ - Run from -cp only and with --show-module-resolution\n-        \/\/     + archived boot layer module ModuleDescriptors should be used with\n-        \/\/       --show-module-resolution (requires resolution)\n-        \/\/     + archived boot layer Configuration should not be disabled\n-        System.out.println(\"----------------------- Test case 2 ----------------------\");\n-        output = TestCommon.exec(appJar, use_whitebox_jar,\n-                                 \"--show-module-resolution\",\n-                                 \"-XX:+UnlockDiagnosticVMOptions\",\n-                                 \"-XX:+WhiteBoxAPI\",\n-                                 \"CheckArchivedModuleApp\",\n-                                 \"yes\",\n-                                 \"no\");\n-        TestCommon.checkExec(output, \"root java.base jrt:\/java.base\");\n-\n-        \/\/ Test case 3)\n-        \/\/ - Dump without --module-path, without --show-module-resolution\n-        \/\/ - Run with --module-path\n-        \/\/    + archived boot layer module ModuleDescriptors should be disabled\n-        \/\/    + archived boot layer Configuration should be disabled\n-        System.out.println(\"----------------------- Test case 3 ----------------------\");\n-        output = TestCommon.exec(appJar, use_whitebox_jar,\n-                                 \"--module-path\",\n-                                 moduleDir.toString(),\n-                                 \"-XX:+UnlockDiagnosticVMOptions\",\n-                                 \"-XX:+WhiteBoxAPI\",\n-                                 \"CheckArchivedModuleApp\",\n-                                 \"no\",\n-                                 \"no\");\n-        TestCommon.checkExec(output);\n-\n-        \/\/\n-        \/\/ Dump with --module-path specified (test case 4, 5). Use an\n-        \/\/ empty directory as it's simple and still triggers the case\n-        \/\/ where system module objects are not archived.\n-        \/\/\n-        output = TestCommon.dump(appJar,\n-                                 TestCommon.list(\"CheckArchivedModuleApp\"),\n-                                 \"--module-path\",\n-                                 moduleDir.toString(),\n-                                 use_whitebox_jar);\n-        TestCommon.checkDump(output);\n-\n-        \/\/ Test case 4)\n-        \/\/ - Dump with --module-path\n-        \/\/ - Run from -cp only, no archived boot layer module ModuleDescriptors\n-        \/\/   and Configuration should be found.\n-        System.out.println(\"----------------------- Test case 4 ----------------------\");\n-        output = TestCommon.exec(appJar, use_whitebox_jar,\n-                                 \"-XX:+UnlockDiagnosticVMOptions\",\n-                                 \"-XX:+WhiteBoxAPI\",\n-                                 \"CheckArchivedModuleApp\",\n-                                 \"no\",\n-                                 \"no\");\n-        TestCommon.checkExec(output);\n-\n-        \/\/ Test case 5)\n-        \/\/ - Dump with --module-path\n-        \/\/ - Run with --module-path, no archived boot layer module ModuleDescriptors\n-        \/\/   and Configuration should be found.\n-        System.out.println(\"----------------------- Test case 5 ----------------------\");\n-        output = TestCommon.exec(appJar, use_whitebox_jar,\n-                                 \"--module-path\",\n-                                 moduleDir.toString(),\n-                                 \"-XX:+UnlockDiagnosticVMOptions\",\n-                                 \"-XX:+WhiteBoxAPI\",\n-                                 \"CheckArchivedModuleApp\",\n-                                 \"no\",\n-                                 \"no\");\n-        TestCommon.checkExec(output);\n-\n-        \/\/\n-        \/\/ Dump without --module-path, with --show-module-resolution\n-        \/\/\n-        output = TestCommon.dump(appJar,\n-                                 TestCommon.list(\"CheckArchivedModuleApp\"),\n-                                 \"--show-module-resolution\",\n-                                 use_whitebox_jar);\n-        TestCommon.checkDump(output, \"root java.base jrt:\/java.base\");\n-\n-        \/\/ Test case 6)\n-        \/\/ - Dump without --module-path, with --show-module-resolution\n-        \/\/ - Run from -cp only and without --show-module-resolution\n-        \/\/     + archived boot layer module ModuleDescriptors should be used\n-        \/\/     + archived boot layer Configuration should be used\n-        System.out.println(\"----------------------- Test case 6 ----------------------\");\n-        output = TestCommon.exec(appJar, use_whitebox_jar,\n-                                 \"-XX:+UnlockDiagnosticVMOptions\",\n-                                 \"-XX:+WhiteBoxAPI\",\n-                                 \"CheckArchivedModuleApp\",\n-                                 \"yes\",\n-                                 \"yes\");\n-        TestCommon.checkExec(output);\n-\n-        \/\/ Test case 7)\n-        \/\/ - Dump without --module-path, with --show-module-resolution\n-        \/\/ - Run from -cp only and with --show-module-resolution\n-        \/\/     + archived boot layer module ModuleDescriptors should be used with\n-        \/\/       --show-module-resolution (requires resolution)\n-        \/\/     + archived boot layer Configuration should be disabled\n-        System.out.println(\"----------------------- Test case 7 ----------------------\");\n-        output = TestCommon.exec(appJar, use_whitebox_jar,\n-                                 \"--show-module-resolution\",\n-                                 \"-XX:+UnlockDiagnosticVMOptions\",\n-                                 \"-XX:+WhiteBoxAPI\",\n-                                 \"CheckArchivedModuleApp\",\n-                                 \"yes\",\n-                                 \"no\");\n-        TestCommon.checkExec(output, \"root java.base jrt:\/java.base\");\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/ArchivedModuleComboTest.java","additions":0,"deletions":189,"binary":false,"changes":189,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,4 +30,0 @@\n- * @build jdk.test.whitebox.WhiteBox\n- * @compile CheckArchivedModuleApp.java\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar CheckArchivedModuleApp\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar WhiteBox.jar jdk.test.whitebox.WhiteBox\n@@ -102,2 +98,0 @@\n-        String wbJar = ClassFileInstaller.getJarPath(\"WhiteBox.jar\");\n-        String use_whitebox_jar = \"-Xbootclasspath\/a:\" + wbJar;\n@@ -119,21 +113,0 @@\n-        \/\/ Test case 1):\n-        \/\/ test archived module graph objects are used with custome runtime image\n-        System.out.println(\"------------------- Test case 1 -------------------\");\n-        String[] runCmd = {customJava.toString(),\n-                           use_whitebox_jar,\n-                           \"-XX:SharedArchiveFile=.\/ArchivedModuleWithCustomImageTest.jsa\",\n-                           \"-cp\",\n-                           appJar,\n-                           \"-Xshare:on\",\n-                           \"-XX:+UnlockDiagnosticVMOptions\",\n-                           \"-XX:+WhiteBoxAPI\",\n-                           \"CheckArchivedModuleApp\",\n-                           \"yes\",\n-                           \"yes\"};\n-        printCommand(runCmd);\n-        ProcessBuilder pbRun = new ProcessBuilder();\n-        pbRun.command(runCmd);\n-        output = TestCommon.executeAndLog(pbRun, \"custom.runtime.image.run\");\n-        output.shouldHaveExitValue(0);\n-\n-\n@@ -150,1 +123,1 @@\n-        pbRun = new ProcessBuilder();\n+        ProcessBuilder pbRun = new ProcessBuilder();\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/ArchivedModuleWithCustomImageTest.java","additions":2,"deletions":29,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1,152 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-import java.io.File;\n-import java.lang.module.Configuration;\n-import java.lang.module.ModuleDescriptor;\n-import java.util.List;\n-import java.util.Set;\n-import jdk.test.whitebox.WhiteBox;\n-\n-\/\/\n-\/\/ Test archived system module graph when open archive heap objects are mapped:\n-\/\/\n-public class CheckArchivedModuleApp {\n-    static WhiteBox wb;\n-    public static void main(String args[]) throws Exception {\n-        wb = WhiteBox.getWhiteBox();\n-\n-        if (!wb.areOpenArchiveHeapObjectsMapped()) {\n-            System.out.println(\"Archived open_archive_heap objects are not mapped.\");\n-            System.out.println(\"This may happen during normal operation. Test Skipped.\");\n-            return;\n-        }\n-\n-        if (args.length != 2) {\n-           throw new RuntimeException(\n-               \"FAILED. Incorrect argument length: \" + args.length);\n-        }\n-\n-        boolean expectArchivedDescriptors = \"yes\".equals(args[0]);\n-        boolean expectArchivedConfiguration = \"yes\".equals(args[1]);\n-        \/\/ -XX:+EnableJVMCI adds extra system modules, in which case the system\n-        \/\/ module objects are not archived.\n-        Boolean enableJVMCI = wb.getBooleanVMFlag(\"EnableJVMCI\");\n-        if (enableJVMCI != null && enableJVMCI) {\n-            expectArchivedDescriptors = false;\n-            expectArchivedConfiguration = false;\n-        }\n-\n-        checkModuleDescriptors(expectArchivedDescriptors);\n-        checkConfiguration(expectArchivedConfiguration);\n-        checkEmptyConfiguration(expectArchivedConfiguration);\n-        checkEmptyLayer();\n-    }\n-\n-    private static void checkModuleDescriptors(boolean expectArchivedDescriptors) {\n-        Set<Module> modules = ModuleLayer.boot().modules();\n-        for (Module m : modules) {\n-            ModuleDescriptor md = m.getDescriptor();\n-            String name = md.name();\n-            if (expectArchivedDescriptors) {\n-                if (wb.isShared(md)) {\n-                    System.out.println(name + \" is archived. Expected.\");\n-                } else {\n-                    throw new RuntimeException(\n-                        \"FAILED. \" + name + \" is not archived. Expect archived.\");\n-                }\n-            } else {\n-                if (!wb.isShared(md)) {\n-                    System.out.println(name + \" is not archived. Expected.\");\n-                } else {\n-                    throw new RuntimeException(\n-                        \"FAILED. \" + name + \" is archived. Expect not archived.\");\n-                }\n-            }\n-        }\n-    }\n-\n-    private static void checkEmptyConfiguration(boolean expectArchivedConfiguration) {\n-        \/\/ Configuration.EMPTY_CONFIGURATION uses the singletons,\n-        \/\/ ListN.EMPTY_LIST, SetN.EMPTY_SET and MapN.EMPTY_MAP in\n-        \/\/ ImmutableCollections for the 'parents', 'modules' and\n-        \/\/ 'graph' fields. The ImmutableCollections singletons\n-        \/\/ can be accessed via List.of(), Set.of() and Map.of() APIs.\n-        \/\/ Configuration public APIs also allow access to the\n-        \/\/ EMPTY_CONFIGURATION's 'parents' and 'modules'. When the\n-        \/\/ archived java heap data is enabled at runtime, make sure\n-        \/\/ the EMPTY_CONFIGURATION.parents and EMPTY_CONFIGURATION.modules\n-        \/\/ are the archived ImmutableCollections singletons.\n-        Configuration emptyCf = Configuration.empty();\n-        List emptyCfParents = emptyCf.parents();\n-        Set emptyCfModules = emptyCf.modules();\n-        if (expectArchivedConfiguration) {\n-            if (emptyCfParents == List.of() &&\n-                wb.isShared(emptyCfParents)) {\n-                System.out.println(\"Empty Configuration has expected parents.\");\n-            } else {\n-                throw new RuntimeException(\n-                    \"FAILED. Unexpected parents for empty Configuration.\");\n-            }\n-            if (emptyCfModules == Set.of() &&\n-                wb.isShared(emptyCfModules)) {\n-                System.out.println(\"Empty Configuration has expected module set.\");\n-            } else {\n-                throw new RuntimeException(\n-                    \"FAILED. Unexpected module set for empty Configuration.\");\n-            }\n-        }\n-    }\n-\n-\n-\n-    private static void checkConfiguration(boolean expectArchivedConfiguration) {\n-        Configuration cf = ModuleLayer.boot().configuration();\n-\n-        if (expectArchivedConfiguration) {\n-            if (wb.isShared(cf)) {\n-                System.out.println(\"Boot layer configuration is archived. Expected.\");\n-            } else {\n-                throw new RuntimeException(\n-                    \"FAILED. Boot layer configuration is not archived.\");\n-            }\n-        } else {\n-            if (!wb.isShared(cf)) {\n-                System.out.println(\"Boot layer configuration is not archived. Expected.\");\n-            } else {\n-                throw new RuntimeException(\n-                    \"FAILED. Boot layer configuration is archived.\");\n-            }\n-        }\n-    }\n-\n-    private static void checkEmptyLayer() {\n-        \/\/ ModuleLayer.EMPTY_FIELD returned by empty() method is singleton.\n-        \/\/ Check that with CDS there is still a single instance of EMPTY_LAYER\n-        \/\/ and boot() layer parent is THE empty layer.\n-        if (ModuleLayer.empty() != ModuleLayer.boot().parents().get(0)) {\n-            throw new RuntimeException(\"FAILED. Empty module layer is not singleton\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/CheckArchivedModuleApp.java","additions":0,"deletions":152,"binary":false,"changes":152,"status":"deleted"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-import java.io.File;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n-import jdk.test.whitebox.WhiteBox;\n-\n-\/\/\n-\/\/ Test class mirror objects are cached when open archive heap objects are mapped:\n-\/\/  - Well-known shared library classes:\n-\/\/      java.lang.Object\n-\/\/      java.lang.String\n-\/\/  - Shared application class loaded by the system class loader\n-\/\/  - Shared application class loaded user defined class loader\n-\/\/\n-public class CheckCachedMirrorApp {\n-    static WhiteBox wb;\n-    public static void main(String args[]) throws Exception {\n-        String path = args[0];\n-        URL url = new File(path).toURI().toURL();\n-        URL[] urls = new URL[] {url};\n-\n-        URLClassLoader loader = new URLClassLoader(urls);\n-        Class hello = loader.loadClass(\"Hello\");\n-        System.out.println(\"Loaded \" + hello + \" from \" + url + \" using loader \" + loader);\n-\n-        wb = WhiteBox.getWhiteBox();\n-\n-        if (!wb.areOpenArchiveHeapObjectsMapped()) {\n-            System.out.println(\"Archived open_archive_heap objects are not mapped.\");\n-            System.out.println(\"This may happen during normal operation. Test Skipped.\");\n-            return;\n-        }\n-\n-        \/\/ Well-known shared library classes\n-        Class object_class = Object.class;\n-        checkMirror(object_class, true);\n-        Class string_class = String.class;\n-        checkMirror(string_class, true);\n-\n-        \/\/ Shared app class\n-        Class app_class = CheckCachedMirrorApp.class;\n-        checkMirror(app_class, true);\n-\n-        \/\/ Hello is shared class and loaded by the 'loader' defined in current app.\n-        \/\/ It should not have cached resolved_references.\n-        Class class_with_user_defined_loader = hello;\n-        checkMirror(class_with_user_defined_loader, false);\n-    }\n-\n-    static void checkMirror(Class c, boolean mirrorShouldBeArchived) {\n-        System.out.print(\"Check cached mirror for \" + c);\n-        if (wb.isSharedClass(c)) {\n-            \/\/ Check if the Class object is cached\n-            if (mirrorShouldBeArchived && wb.isShared(c)) {\n-                System.out.println(c + \" mirror is cached. Expected.\");\n-            } else if (!mirrorShouldBeArchived && !wb.isShared(c)) {\n-                System.out.println(c + \" mirror is not cached. Expected.\");\n-            } else if (mirrorShouldBeArchived && !wb.isShared(c)) {\n-                throw new RuntimeException(\n-                    \"FAILED. \" + c + \" mirror is not cached.\");\n-            } else {\n-                throw new RuntimeException(\n-                    \"FAILED. \" + c + \" mirror should not be cached.\");\n-            }\n-        } else {\n-          System.out.println(\"Class \" + c + \"is not shared, skipping the check for mirror\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/CheckCachedMirrorApp.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test archived mirror\n- * @requires vm.cds.write.archived.java.heap\n- * @requires vm.cds.custom.loaders\n- * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n- * @build jdk.test.whitebox.WhiteBox\n- * @compile CheckCachedMirrorApp.java\n- * @compile ..\/test-classes\/Hello.java\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar CheckCachedMirrorApp\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar hello.jar Hello\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar WhiteBox.jar jdk.test.whitebox.WhiteBox\n- * @run driver CheckCachedMirrorTest\n- *\/\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.helpers.ClassFileInstaller;\n-import jdk.test.whitebox.WhiteBox;\n-\n-public class CheckCachedMirrorTest {\n-    public static void main(String[] args) throws Exception {\n-        String wbJar = ClassFileInstaller.getJarPath(\"WhiteBox.jar\");\n-        String use_whitebox_jar = \"-Xbootclasspath\/a:\" + wbJar;\n-        String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n-        String helloJarPath = ClassFileInstaller.getJarPath(\"hello.jar\");\n-\n-        String classlist[] = new String[] {\n-            \"CheckCachedMirrorApp\",            \/\/ built-in app loader\n-            \"java\/lang\/Object id: 1\",          \/\/ boot loader\n-            \"Hello id: 2 super: 1 source: \" + helloJarPath \/\/ custom loader\n-        };\n-\n-        TestCommon.testDump(appJar, classlist, use_whitebox_jar);\n-        OutputAnalyzer output = TestCommon.exec(appJar, use_whitebox_jar,\n-                                                \"-XX:+UnlockDiagnosticVMOptions\",\n-                                                \"-XX:+WhiteBoxAPI\",\n-                                                \"-Xlog:cds=debug\",\n-                                                \"CheckCachedMirrorApp\",\n-                                                helloJarPath);\n-        TestCommon.checkExec(output);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/CheckCachedMirrorTest.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test resolved_references\n- * @requires vm.cds\n- * @requires vm.cds.custom.loaders\n- * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n- * @build jdk.test.whitebox.WhiteBox\n- * @compile CheckCachedResolvedReferencesApp.java\n- * @compile ..\/test-classes\/Hello.java\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar CheckCachedResolvedReferencesApp\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar hello.jar Hello\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar WhiteBox.jar jdk.test.whitebox.WhiteBox\n- * @run driver CheckCachedResolvedReferences\n- *\/\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.helpers.ClassFileInstaller;\n-import jdk.test.whitebox.WhiteBox;\n-\n-public class CheckCachedResolvedReferences {\n-    public static void main(String[] args) throws Exception {\n-        String wbJar = ClassFileInstaller.getJarPath(\"WhiteBox.jar\");\n-        String use_whitebox_jar = \"-Xbootclasspath\/a:\" + wbJar;\n-        String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n-        String helloJarPath = ClassFileInstaller.getJarPath(\"hello.jar\");\n-\n-        String classlist[] = new String[] {\n-            \"CheckCachedResolvedReferencesApp\",            \/\/ built-in app loader\n-            \"java\/lang\/Object id: 1\",                      \/\/ boot loader\n-            \"Hello id: 2 super: 1 source: \" + helloJarPath \/\/ custom loader\n-        };\n-\n-        TestCommon.testDump(appJar, classlist, use_whitebox_jar);\n-        OutputAnalyzer output = TestCommon.exec(appJar, use_whitebox_jar,\n-                                                \"-XX:+UnlockDiagnosticVMOptions\",\n-                                                \"-XX:+WhiteBoxAPI\",\n-                                                \"CheckCachedResolvedReferencesApp\",\n-                                                helloJarPath);\n-        TestCommon.checkExec(output);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/CheckCachedResolvedReferences.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-import java.io.File;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n-import jdk.test.whitebox.WhiteBox;\n-\n-public class CheckCachedResolvedReferencesApp {\n-    public static void main(String args[]) throws Exception {\n-        String path = args[0];\n-        URL url = new File(path).toURI().toURL();\n-        URL[] urls = new URL[] {url};\n-\n-        URLClassLoader loader = new URLClassLoader(urls);\n-        Class hello = loader.loadClass(\"Hello\");\n-        System.out.println(\"Loaded \" + hello + \" from \" + url + \" using loader \" + loader);\n-\n-        WhiteBox wb = WhiteBox.getWhiteBox();\n-\n-        if (!wb.areOpenArchiveHeapObjectsMapped()) {\n-            System.out.println(\"Archived open_archive_heap objects are not mapped.\");\n-            System.out.println(\"This may happen during normal operation. Test Skipped.\");\n-            return;\n-        }\n-\n-        \/\/ CheckCachedResolvedReferencesApp is shared class and loaded by the\n-        \/\/ AppClassLoader. It should have cached resolved_references.\n-        if (wb.isSharedClass(CheckCachedResolvedReferencesApp.class)) {\n-            Object refs1 = wb.getResolvedReferences(CheckCachedResolvedReferencesApp.class);\n-            if (refs1 != null && wb.isShared(refs1)) {\n-                System.out.println(\n-                    \"resolved references from CheckCachedResolvedReferencesApp is cached\");\n-            } else {\n-                throw new RuntimeException(\n-                    \"FAILED. CheckCachedResolvedReferencesApp has no cached resolved references\");\n-            }\n-        }\n-\n-        \/\/ Hello is shared class and loaded by the 'loader' defined in current app.\n-        \/\/ It should not have cached resolved_references.\n-        if (wb.isSharedClass(hello)) {\n-            Object refs2 = wb.getResolvedReferences(hello);\n-            if (refs2 != null) {\n-                if (!wb.isShared(refs2)) {\n-                    System.out.println(\"resolved references from hello is not cached\");\n-                } else {\n-                    throw new RuntimeException(\n-                        \"FAILED. Hello has unexpected cached resolved references\");\n-                }\n-            } else {\n-                throw new RuntimeException(\"FAILED. Hello has no resolved references\");\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/CheckCachedResolvedReferencesApp.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,0 @@\n-import jdk.test.whitebox.WhiteBox;\n-\n@@ -30,5 +28,1 @@\n-\/\/ Takes two arguments:\n-\/\/ 0: the expected maximum value expected to be archived\n-\/\/ 1: if the values are expected to be retrieved from the archive or not\n-\/\/    (only applies to IntegerCache; other caches should always be mapped\n-\/\/    from archive)\n+\/\/ args[0]: the expected maximum value expected to be archived\n@@ -37,2 +31,0 @@\n-    static WhiteBox wb;\n-\n@@ -40,8 +32,1 @@\n-        wb = WhiteBox.getWhiteBox();\n-\n-        if (!wb.areOpenArchiveHeapObjectsMapped()) {\n-            System.out.println(\"This may happen during normal operation. Test Skipped.\");\n-            return;\n-        }\n-\n-        if (args.length != 2) {\n+        if (args.length != 1) {\n@@ -52,2 +37,0 @@\n-        boolean archivedExpected = Boolean.parseBoolean(args[1]);\n-\n@@ -72,4 +55,0 @@\n-            checkArchivedAsExpected(archivedExpected, Integer.valueOf(i));\n-            checkArchivedAsExpected(true, Byte.valueOf((byte)i));\n-            checkArchivedAsExpected(true, Short.valueOf((short)i));\n-            checkArchivedAsExpected(true, Long.valueOf(i));\n@@ -83,1 +62,0 @@\n-                checkArchivedAsExpected(true, Character.valueOf((char)i));\n@@ -92,1 +70,0 @@\n-        checkArchivedAsExpected(archivedExpected, Integer.valueOf(high));\n@@ -98,20 +75,0 @@\n-        checkArchivedAsExpected(false, Integer.valueOf(high + 1));\n-        checkArchivedAsExpected(false, Short.valueOf((short)128));\n-        checkArchivedAsExpected(false, Long.valueOf(128));\n-        checkArchivedAsExpected(false, Character.valueOf((char)128));\n-    }\n-\n-    private static void checkArchivedAsExpected(boolean archivedExpected, Object value) {\n-        if (archivedExpected) {\n-            if (!wb.isShared(value)) {\n-                throw new RuntimeException(\n-                        \"FAILED. Value expected to be archived: \" + value +\n-                        \" of type \" + value.getClass().getName());\n-            }\n-        } else {\n-            if (wb.isShared(value)) {\n-                throw new RuntimeException(\n-                        \"FAILED. Value not expected to be archived: \" + value +\n-                        \" of type \" + value.getClass().getName());\n-            }\n-        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/CheckIntegerCacheApp.java","additions":3,"deletions":46,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-import java.io.*;\n-import java.util.*;\n-import jdk.test.lib.Utils;\n-import jdk.test.whitebox.WhiteBox;\n-\n-\/\/ All strings in archived classes are shared\n-public class GCStressApp {\n-    static WhiteBox wb = WhiteBox.getWhiteBox();\n-    static int[] arr;\n-\n-    static String get_shared_string() {\n-        String shared_str = \"GCStressApp_shared_string\";\n-        return shared_str;\n-    }\n-\n-    static String get_shared_string1() {\n-        String shared_str1 = \"GCStressApp_shared_string1\";\n-        return shared_str1;\n-    }\n-\n-    static void allocAlot() {\n-        try {\n-            Random random = Utils.getRandomInstance();\n-            for (int i = 0; i < 1024 * 1024; i++) {\n-                int len = random.nextInt(10000);\n-                arr = new int[len];\n-            }\n-        } catch (java.lang.OutOfMemoryError e) { }\n-    }\n-\n-    static void runGC() {\n-        wb.fullGC();\n-    }\n-\n-    public static void main(String args[]) throws Exception {\n-        if (!wb.isSharedClass(GCStressApp.class)) {\n-           System.out.println(\"GCStressApp is not shared. Possibly there was a mapping failure.\");\n-           return;\n-        }\n-\n-        if (!wb.areSharedStringsMapped()) {\n-          System.out.println(\"Shared strings are not mapped.\");\n-          return;\n-        }\n-\n-        Object refs = wb.getResolvedReferences(GCStressApp.class);\n-        if (wb.isShared(refs)) {\n-            String shared_str = get_shared_string();\n-            String shared_str1 = get_shared_string1();\n-\n-            if (!wb.isShared(shared_str)) {\n-                throw new RuntimeException(\"FAILED. GCStressApp_shared_string is not shared\");\n-            }\n-\n-            if (!wb.isShared(shared_str1)) {\n-                throw new RuntimeException(\"FAILED. GCStressApp_shared_string1 is not shared\");\n-            }\n-\n-            allocAlot();\n-            runGC();\n-            runGC();\n-            runGC();\n-\n-            System.out.println(\"Passed\");\n-        } else {\n-            System.out.println(\n-                \"No cached resolved references. Open archive heap data is not used.\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/GCStressApp.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @key randomness\n- * @summary\n- * @requires vm.cds.write.archived.java.heap\n- * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n- * @build jdk.test.whitebox.WhiteBox jdk.test.lib.Utils\n- * @compile GCStressApp.java\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar gcstress.jar GCStressApp jdk.test.lib.Utils\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar WhiteBox.jar jdk.test.whitebox.WhiteBox\n- * @run driver GCStressTest\n- *\/\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.helpers.ClassFileInstaller;\n-\n-public class GCStressTest {\n-    public static void main(String[] args) throws Exception {\n-        String wbJar = ClassFileInstaller.getJarPath(\"WhiteBox.jar\");\n-        String use_whitebox_jar = \"-Xbootclasspath\/a:\" + wbJar;\n-        String appJar = ClassFileInstaller.getJarPath(\"gcstress.jar\");\n-        String appClasses[] = TestCommon.list(\"GCStressApp\");\n-\n-        OutputAnalyzer output = TestCommon.dump(appJar, appClasses,\n-                                                use_whitebox_jar,\n-                                                \"-Xms20M\", \"-Xmx20M\");\n-        output = TestCommon.exec(appJar, use_whitebox_jar,\n-                                 \"-Xlog:cds=info\",\n-                                 \"-Xms20M\", \"-Xmx20M\",\n-                                 \"-XX:+UnlockDiagnosticVMOptions\",\n-                                 \"-XX:+WhiteBoxAPI\",\"GCStressApp\");\n-        TestCommon.checkExec(output);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/GCStressTest.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,11 +67,1 @@\n-            \/\/ Check if the Class object is cached\n-            if (wb.isShared(c)) {\n-                System.out.println(c + \" mirror is cached. Expected.\");\n-            } else {\n-                throw new RuntimeException(\n-                    \"FAILED. \" + c + \" mirror should be cached.\");\n-            }\n-\n-            \/\/ Check fields\n-\n-            if (wb.isShared(archived_field)) {\n+            if (wb.isSharedInternedString(archived_field)) {\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/MirrorWithReferenceFieldsApp.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,2 +48,2 @@\n-        TestCommon.checkDump(output, \"oa0 space:\");\n-        output.shouldNotContain(\"oa0 space:         0 [\");\n+        TestCommon.checkDump(output, \"hp space:\");\n+        output.shouldNotContain(\"hp space:         0 [\");\n@@ -58,1 +58,1 @@\n-        output.shouldNotContain(\"oa0 space:\");\n+        output.shouldNotContain(\"hp space:\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/OpenArchiveRegion.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,205 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-import java.lang.reflect.Field;\n-import jdk.test.whitebox.WhiteBox;\n-\n-\/\/\n-\/\/ Test primitive type class mirror objects are cached when open archive heap\n-\/\/ objects are mapped.\n-\/\/\n-public class PrimitiveTypesApp {\n-    public static void main(String[] args) {\n-        WhiteBox wb = WhiteBox.getWhiteBox();\n-        if (!wb.areOpenArchiveHeapObjectsMapped()) {\n-            System.out.println(\"Archived open_archive_heap objects are not mapped.\");\n-            System.out.println(\"This may happen during normal operation. Test Skipped.\");\n-            return;\n-        }\n-\n-        FieldsTest ft = new FieldsTest();\n-        ft.testBoolean(wb);\n-        ft.testByte(wb);\n-        ft.testChar(wb);\n-        ft.testInt(wb);\n-        ft.testShort(wb);\n-        ft.testLong(wb);\n-        ft.testFloat(wb);\n-        ft.testDouble(wb);\n-    }\n-}\n-\n-class FieldsTest {\n-    public boolean f_boolean;\n-    public byte f_byte;\n-    public char f_char;\n-    public int f_int;\n-    public short f_short;\n-    public long f_long;\n-    public float f_float;\n-    public double f_double;\n-\n-    FieldsTest() {\n-        f_byte = 1;\n-        f_boolean = false;\n-        f_char = 'a';\n-        f_int = 1;\n-        f_short = 100;\n-        f_long = 2018L;\n-        f_float = 1.0f;\n-        f_double = 2.5;\n-    }\n-\n-    void testBoolean(WhiteBox wb) {\n-        try {\n-            Field f = this.getClass().getDeclaredField(\"f_boolean\");\n-            f.setBoolean(this, true);\n-            if (!f_boolean) {\n-                throw new RuntimeException(\"FAILED. Field f_boolean has unexpected value: \" + f_boolean);\n-            }\n-            checkPrimitiveType(wb, f, Boolean.TYPE);\n-        } catch (NoSuchFieldException nsfe) {\n-            throw new RuntimeException(nsfe);\n-        } catch (IllegalAccessException iae) {\n-            throw new RuntimeException(iae);\n-        }\n-    }\n-\n-    void testByte(WhiteBox wb) {\n-        try {\n-            Field f = this.getClass().getDeclaredField(\"f_byte\");\n-            f.setByte(this, (byte)9);\n-            if (f_byte != (byte)9) {\n-                throw new RuntimeException(\"FAILED. Field f_byte has unexpected value: \" + f_byte);\n-            }\n-            checkPrimitiveType(wb, f, Byte.TYPE);\n-        } catch (NoSuchFieldException nsfe) {\n-            throw new RuntimeException(nsfe);\n-        } catch (IllegalAccessException iae) {\n-            throw new RuntimeException(iae);\n-        }\n-    }\n-\n-    void testChar(WhiteBox wb) {\n-        try {\n-            Field f = this.getClass().getDeclaredField(\"f_char\");\n-            f.setChar(this, 'b');\n-            if (f_char != 'b') {\n-                throw new RuntimeException(\"FAILED. Field f_char has unexpected value: \" + f_char);\n-            }\n-            checkPrimitiveType(wb, f, Character.TYPE);\n-        } catch (NoSuchFieldException nsfe) {\n-            throw new RuntimeException(nsfe);\n-        } catch (IllegalAccessException iae) {\n-            throw new RuntimeException(iae);\n-        }\n-    }\n-\n-    void testInt(WhiteBox wb) {\n-        try {\n-            Field f = this.getClass().getDeclaredField(\"f_int\");\n-            f.setInt(this, 9999);\n-            if (f_int != 9999) {\n-                throw new RuntimeException(\"FAILED. Field f_int has unexpected value: \" + f_int);\n-            }\n-            checkPrimitiveType(wb, f, Integer.TYPE);\n-        } catch (NoSuchFieldException nsfe) {\n-            throw new RuntimeException(nsfe);\n-        } catch (IllegalAccessException iae) {\n-            throw new RuntimeException(iae);\n-        }\n-    }\n-\n-    void testShort(WhiteBox wb) {\n-        try {\n-            Field f = this.getClass().getDeclaredField(\"f_short\");\n-            f.setShort(this, (short)99);\n-            if (f_short != 99) {\n-                throw new RuntimeException(\"FAILED. Field f_short has unexpected value: \" + f_short);\n-            }\n-            checkPrimitiveType(wb, f, Short.TYPE);\n-        } catch (NoSuchFieldException nsfe) {\n-            throw new RuntimeException(nsfe);\n-        } catch (IllegalAccessException iae) {\n-            throw new RuntimeException(iae);\n-        }\n-    }\n-\n-    void testLong(WhiteBox wb) {\n-        try {\n-            Field f = this.getClass().getDeclaredField(\"f_long\");\n-            f.setLong(this, 99L);\n-            if (f_long != 99L) {\n-                throw new RuntimeException(\"FAILED. Field f_long has unexpected value: \" + f_long);\n-            }\n-            checkPrimitiveType(wb, f, Long.TYPE);\n-        } catch (NoSuchFieldException nsfe) {\n-            throw new RuntimeException(nsfe);\n-        } catch (IllegalAccessException iae) {\n-            throw new RuntimeException(iae);\n-        }\n-    }\n-\n-    void testFloat(WhiteBox wb) {\n-        try {\n-            Field f = this.getClass().getDeclaredField(\"f_float\");\n-            f.setFloat(this, 9.9f);\n-            if (f_float != 9.9f) {\n-                throw new RuntimeException(\"FAILED. Field f_float has unexpected value: \" + f_float);\n-            }\n-            checkPrimitiveType(wb, f, Float.TYPE);\n-        } catch (NoSuchFieldException nsfe) {\n-            throw new RuntimeException(nsfe);\n-        } catch (IllegalAccessException iae) {\n-            throw new RuntimeException(iae);\n-        }\n-    }\n-\n-    void testDouble(WhiteBox wb) {\n-        try {\n-            Field f = this.getClass().getDeclaredField(\"f_double\");\n-            f.setDouble(this, 9.9);\n-            if (f_double != 9.9) {\n-                throw new RuntimeException(\"FAILED. Field f_double has unexpected value: \" + f_double);\n-            }\n-            checkPrimitiveType(wb, f, Double.TYPE);\n-        } catch (NoSuchFieldException nsfe) {\n-            throw new RuntimeException(nsfe);\n-        } catch (IllegalAccessException iae) {\n-            throw new RuntimeException(iae);\n-        }\n-    }\n-\n-    void checkPrimitiveType(WhiteBox wb, Field f, Class t) {\n-        Class c = f.getType();\n-        if (!(c.isPrimitive() && c == t)) {\n-            throw new RuntimeException(\"FAILED. \" + c + \" is not primitive type \" + t);\n-        }\n-        if (wb.isShared(c)) {\n-            System.out.println(c + \" is cached, expected\");\n-        } else {\n-            throw new RuntimeException(\"FAILED. \" + c + \" is not cached.\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/PrimitiveTypesApp.java","additions":0,"deletions":205,"binary":false,"changes":205,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test archived primitive type mirrors\n- * @requires vm.cds.write.archived.java.heap\n- * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n- * @build jdk.test.whitebox.WhiteBox\n- * @compile PrimitiveTypesApp.java\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar PrimitiveTypesApp FieldsTest\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar WhiteBox.jar jdk.test.whitebox.WhiteBox\n- * @run driver PrimitiveTypesTest\n- *\/\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.helpers.ClassFileInstaller;\n-import jdk.test.whitebox.WhiteBox;\n-\n-public class PrimitiveTypesTest {\n-    public static void main(String[] args) throws Exception {\n-        String wbJar = ClassFileInstaller.getJarPath(\"WhiteBox.jar\");\n-        String use_whitebox_jar = \"-Xbootclasspath\/a:\" + wbJar;\n-        String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n-\n-        String classlist[] = new String[] {\n-            \"PrimitiveTypesApp\",\n-            \"FieldsTest\"\n-        };\n-\n-        TestCommon.testDump(appJar, classlist, use_whitebox_jar);\n-        OutputAnalyzer output = TestCommon.exec(appJar, use_whitebox_jar,\n-                                                \"-XX:+UnlockDiagnosticVMOptions\",\n-                                                \"-XX:+WhiteBoxAPI\",\n-                                                \"-XX:+VerifyAfterGC\",\n-                                                \"PrimitiveTypesApp\");\n-        TestCommon.checkExec(output);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/PrimitiveTypesTest.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,1 @@\n-            if (!wb.isShared(klass)) {\n+            if (!wb.isSharedClass(klass)) {\n@@ -120,2 +120,2 @@\n-        if (res.equals(\"buzz\") && wb.isShared(res)) {\n-            System.out.println(\"get() returns \" + res + \", string is shared\");\n+        if (res.equals(\"buzz\")) {\n+            System.out.println(\"get() returns \" + res);\n@@ -123,5 +123,1 @@\n-            if (!res.equals(\"buzz\")) {\n-                System.out.println(\"FAILED. buzz is expected but got \" + res);\n-            } else {\n-                System.out.println(\"FAILED. \" + res + \" is not shared\");\n-            }\n+            System.out.println(\"FAILED. buzz is expected but got \" + res);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/RedefineClassApp.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,4 +78,1 @@\n-        \"first_closed_archive\",\n-        \"last_closed_archive\",\n-        \"first_open_archive\",\n-        \"last_open_archive\"\n+        \"hp\",          \/\/ heap\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSArchiveUtils.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -691,1 +691,0 @@\n-  public native boolean isShared(Object o);\n@@ -699,1 +698,0 @@\n-  public native Object  getResolvedReferences(Class<?> c);\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}