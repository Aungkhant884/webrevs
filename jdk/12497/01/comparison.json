{"files":[{"patch":"@@ -104,1 +104,1 @@\n-void G1BarrierSet::invalidate(MemRegion mr) {\n+void G1BarrierSet::invalidate(JavaThread* thread, MemRegion mr) {\n@@ -123,1 +123,0 @@\n-  Thread* thr = Thread::current();\n@@ -125,1 +124,1 @@\n-  G1DirtyCardQueue& queue = G1ThreadLocalData::dirty_card_queue(thr);\n+  G1DirtyCardQueue& queue = G1ThreadLocalData::dirty_card_queue(thread);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+  void invalidate(JavaThread* thread, MemRegion mr);\n+\n@@ -73,3 +75,2 @@\n-  \/\/ NB: if you do a whole-heap invalidation, the \"usual invariant\" defined\n-  \/\/ above no longer applies.\n-  void invalidate(MemRegion mr);\n+  inline void invalidate(MemRegion mr);\n+  inline void write_region(JavaThread* thread, MemRegion mr);\n@@ -77,2 +78,1 @@\n-  void write_region(MemRegion mr)         { invalidate(mr); }\n-  void write_ref_array_work(MemRegion mr) { invalidate(mr); }\n+  inline void write_ref_array_work(MemRegion mr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/thread.hpp\"\n@@ -70,0 +71,12 @@\n+inline void G1BarrierSet::invalidate(MemRegion mr) {\n+  invalidate(JavaThread::current(), mr);\n+}\n+\n+inline void G1BarrierSet::write_region(JavaThread* thread, MemRegion mr) {\n+  invalidate(thread, mr);\n+}\n+\n+inline void G1BarrierSet::write_ref_array_work(MemRegion mr) {\n+  invalidate(mr);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.inline.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -559,1 +559,1 @@\n-void G1DirtyCardQueueSet::concatenate_logs_and_stats() {\n+void G1DirtyCardQueueSet::update_refinement_stats(G1ConcurrentRefineStats& stats) {\n@@ -562,27 +562,1 @@\n-  \/\/ Disable mutator refinement until concurrent refinement decides otherwise.\n-  set_mutator_refinement_threshold(SIZE_MAX);\n-\n-  \/\/ Iterate over all the threads, if we find a partial log add it to\n-  \/\/ the global list of logs.\n-  struct ConcatenateThreadLogClosure : public ThreadClosure {\n-    G1DirtyCardQueueSet& _qset;\n-    G1ConcurrentRefineStats _total_stats;\n-\n-    ConcatenateThreadLogClosure(G1DirtyCardQueueSet& qset) :\n-      _qset{qset}, _total_stats{} {}\n-\n-    virtual void do_thread(Thread* t) {\n-      G1DirtyCardQueue& queue = G1ThreadLocalData::dirty_card_queue(t);\n-      \/\/ Flush the buffer if non-empty.  Flush before accumulating and\n-      \/\/ resetting stats, since flushing may modify the stats.\n-      if ((queue.buffer() != nullptr) &&\n-          (queue.index() != _qset.buffer_size())) {\n-        _qset.flush_queue(queue);\n-      }\n-      G1ConcurrentRefineStats& qstats = *queue.refinement_stats();\n-      _total_stats += qstats;\n-      qstats.reset();\n-    }\n-  } closure(*this);\n-  Threads::threads_do(&closure);\n-  _concatenated_refinement_stats = closure._total_stats;\n+  _concatenated_refinement_stats = stats;\n@@ -599,0 +573,16 @@\n+G1ConcurrentRefineStats G1DirtyCardQueueSet::concatenate_log_and_stats(Thread* thread) {\n+  assert_at_safepoint();\n+\n+  G1DirtyCardQueue& queue = G1ThreadLocalData::dirty_card_queue(thread);\n+  \/\/ Flush the buffer if non-empty.  Flush before accumulating and\n+  \/\/ resetting stats, since flushing may modify the stats.\n+  if ((queue.buffer() != nullptr) &&\n+    (queue.index() != buffer_size())) {\n+    flush_queue(queue);\n+  }\n+\n+  G1ConcurrentRefineStats result = *queue.refinement_stats();\n+  queue.refinement_stats()->reset();\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.cpp","additions":19,"deletions":29,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -277,2 +277,2 @@\n-  \/\/ Collect and reset all the per-thread refinement stats.  If any threads\n-  \/\/ have partial logs then add them to the global list.\n+  \/\/ Update global refinement statistics with the ones given and the ones from\n+  \/\/ detached threads.\n@@ -280,1 +280,5 @@\n-  void concatenate_logs_and_stats();\n+  void update_refinement_stats(G1ConcurrentRefineStats& stats);\n+  \/\/ Add the given thread's partial logs to the global list and return and reset\n+  \/\/ its refinement stats.\n+  \/\/ precondition: at safepoint.\n+  G1ConcurrentRefineStats concatenate_log_and_stats(Thread* thread);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -55,0 +55,3 @@\n+  _gc_par_phases[RetireTLABsAndFlushLogs] = new WorkerDataArray<double>(\"RetireTLABsAndFlushLogs\", \"JT Retire TLABs And Flush Logs (ms):\", max_gc_threads);\n+  _gc_par_phases[NonJavaThreadFlushLogs] = new WorkerDataArray<double>(\"NonJavaThreadFlushLogs\", \"Non-JT Flush Logs (ms):\", max_gc_threads);\n+\n@@ -177,1 +180,1 @@\n-  _cur_prepare_tlab_time_ms = 0.0;\n+  _cur_pre_evacuate_prepare_time_ms = 0.0;\n@@ -415,2 +418,1 @@\n-  const double sum_ms = _cur_prepare_tlab_time_ms +\n-                        _cur_concatenate_dirty_card_logs_time_ms +\n+  const double sum_ms = _cur_pre_evacuate_prepare_time_ms +\n@@ -425,2 +427,3 @@\n-  debug_time(\"Prepare TLABs\", _cur_prepare_tlab_time_ms);\n-  debug_time(\"Concatenate Dirty Card Logs\", _cur_concatenate_dirty_card_logs_time_ms);\n+  debug_time(\"Pre Evacuate Prepare\", _cur_pre_evacuate_prepare_time_ms);\n+  debug_phase(_gc_par_phases[RetireTLABsAndFlushLogs], 1);\n+  debug_phase(_gc_par_phases[NonJavaThreadFlushLogs], 1);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+    RetireTLABsAndFlushLogs,\n+    NonJavaThreadFlushLogs,\n@@ -182,1 +184,1 @@\n-  double _cur_prepare_tlab_time_ms;\n+  double _cur_resize_tlab_time_ms;\n@@ -184,1 +186,1 @@\n-  double _cur_concatenate_dirty_card_logs_time_ms;\n+  double _cur_pre_evacuate_prepare_time_ms;\n@@ -275,6 +277,2 @@\n-  void record_prepare_tlab_time_ms(double ms) {\n-    _cur_prepare_tlab_time_ms = ms;\n-  }\n-\n-  void record_concatenate_dirty_card_logs_time_ms(double ms) {\n-    _cur_concatenate_dirty_card_logs_time_ms = ms;\n+  void record_pre_evacuate_prepare_time_ms(double ms) {\n+    _cur_pre_evacuate_prepare_time_ms = ms;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+#include \"gc\/g1\/g1YoungGCPreEvacuateTasks.hpp\"\n@@ -470,34 +471,0 @@\n-void G1YoungCollector::retire_tlabs() {\n-  Ticks start = Ticks::now();\n-  _g1h->retire_tlabs();\n-  double retire_time = (Ticks::now() - start).seconds() * MILLIUNITS;\n-  phase_times()->record_prepare_tlab_time_ms(retire_time);\n-}\n-\n-void G1YoungCollector::concatenate_dirty_card_logs_and_stats() {\n-  Ticks start = Ticks::now();\n-  G1DirtyCardQueueSet& qset = G1BarrierSet::dirty_card_queue_set();\n-  size_t old_cards = qset.num_cards();\n-  qset.concatenate_logs_and_stats();\n-  size_t pending_cards = qset.num_cards();\n-  size_t thread_buffer_cards = pending_cards - old_cards;\n-  policy()->record_concurrent_refinement_stats(pending_cards, thread_buffer_cards);\n-  double concat_time = (Ticks::now() - start).seconds() * MILLIUNITS;\n-  phase_times()->record_concatenate_dirty_card_logs_time_ms(concat_time);\n-}\n-\n-#ifdef ASSERT\n-void G1YoungCollector::verify_empty_dirty_card_logs() const {\n-  struct Verifier : public ThreadClosure {\n-    size_t _buffer_size;\n-    Verifier() : _buffer_size(G1BarrierSet::dirty_card_queue_set().buffer_size()) {}\n-    void do_thread(Thread* t) override {\n-      G1DirtyCardQueue& queue = G1ThreadLocalData::dirty_card_queue(t);\n-      assert((queue.buffer() == nullptr) || (queue.index() == _buffer_size),\n-             \"non-empty dirty card queue for thread\");\n-    }\n-  } verifier;\n-  Threads::threads_do(&verifier);\n-}\n-#endif \/\/ ASSERT\n-\n@@ -505,6 +472,6 @@\n-  \/\/ Flush early, so later phases don't need to account for per-thread stuff.\n-  \/\/ Flushes deferred card marks, so must precede concatenating logs.\n-  retire_tlabs();\n-\n-  \/\/ Flush early, so later phases don't need to account for per-thread stuff.\n-  concatenate_dirty_card_logs_and_stats();\n+  {\n+    Ticks start = Ticks::now();\n+    G1PreEvacuateCollectionSetBatchTask cl;\n+    G1CollectedHeap::heap()->run_batch_task(&cl);\n+    phase_times()->record_pre_evacuate_prepare_time_ms((Ticks::now() - start).seconds() * 1000.0);\n+  }\n@@ -512,0 +479,1 @@\n+  \/\/ Needs log buffers flushed.\n@@ -545,1 +513,0 @@\n-  verify_empty_dirty_card_logs();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":9,"deletions":42,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,4 +101,0 @@\n-  void retire_tlabs();\n-  void concatenate_dirty_card_logs_and_stats();\n-  void verify_empty_dirty_card_logs() const NOT_DEBUG_RETURN;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n+#include \"gc\/g1\/g1ConcurrentRefineStats.hpp\"\n+#include \"gc\/g1\/g1DirtyCardQueue.hpp\"\n+#include \"gc\/g1\/g1YoungGCPreEvacuateTasks.hpp\"\n+#include \"gc\/shared\/barrierSet.inline.hpp\"\n+#include \"gc\/shared\/threadLocalAllocBuffer.inline.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/threads.hpp\"\n+\n+struct RetireTLABAndFlushLogsClosure : public ThreadClosure {\n+public:\n+  ThreadLocalAllocStats _tlab_stats;\n+  G1ConcurrentRefineStats _refinement_stats;\n+\n+  RetireTLABAndFlushLogsClosure() : _tlab_stats(), _refinement_stats() { }\n+\n+  void do_thread(Thread* thread) override {\n+    if (thread->is_Java_thread()) {\n+      \/\/ Flushes deferred card marks, so must precede concatenating logs.\n+      BarrierSet::barrier_set()->make_parsable((JavaThread*)thread);\n+      if (UseTLAB) {\n+        thread->tlab().retire(&_tlab_stats);\n+      }\n+    }\n+\n+    G1DirtyCardQueueSet& qset = G1BarrierSet::dirty_card_queue_set();\n+    _refinement_stats += qset.concatenate_log_and_stats(thread);\n+  }\n+};\n+\n+class G1PreEvacuateCollectionSetBatchTask::JavaThreadRetireTLABAndFlushLogs : public G1AbstractSubTask {\n+  G1JavaThreadsListClaimer _claimer;\n+\n+  \/\/ Per worker thread statistics.\n+  ThreadLocalAllocStats* _local_tlab_stats;\n+  G1ConcurrentRefineStats* _local_refinement_stats;\n+\n+  uint _num_workers;\n+\n+  \/\/ There is relatively little work to do per thread.\n+  static const uint ThreadsPerWorker = 250;\n+\n+public:\n+  JavaThreadRetireTLABAndFlushLogs() :\n+    G1AbstractSubTask(G1GCPhaseTimes::RetireTLABsAndFlushLogs),\n+    _claimer(ThreadsPerWorker),\n+    _local_tlab_stats(nullptr),\n+    _local_refinement_stats(nullptr),\n+    _num_workers(0) {\n+  }\n+\n+  ~JavaThreadRetireTLABAndFlushLogs() {\n+    STATIC_ASSERT(std::is_trivially_destructible<G1ConcurrentRefineStats>::value);\n+    FREE_C_HEAP_ARRAY(G1ConcurrentRefineStats, _local_refinement_stats);\n+\n+    STATIC_ASSERT(std::is_trivially_destructible<ThreadLocalAllocStats>::value);\n+    FREE_C_HEAP_ARRAY(ThreadLocalAllocStats, _local_tlab_stats);\n+  }\n+\n+  void do_work(uint worker_id) override {\n+    RetireTLABAndFlushLogsClosure tc;\n+    _claimer.apply(&tc);\n+\n+    _local_tlab_stats[worker_id] = tc._tlab_stats;\n+    _local_refinement_stats[worker_id] = tc._refinement_stats;\n+  }\n+\n+  double worker_cost() const override {\n+    return (double)_claimer.length() \/ ThreadsPerWorker;\n+  }\n+\n+  void set_max_workers(uint max_workers) override {\n+    _num_workers = max_workers;\n+    _local_tlab_stats = NEW_C_HEAP_ARRAY(ThreadLocalAllocStats, _num_workers, mtGC);\n+    _local_refinement_stats = NEW_C_HEAP_ARRAY(G1ConcurrentRefineStats, _num_workers, mtGC);\n+\n+    for (uint i = 0; i < _num_workers; i++) {\n+      ::new (&_local_tlab_stats[i]) ThreadLocalAllocStats();\n+      ::new (&_local_refinement_stats[i]) G1ConcurrentRefineStats();\n+    }\n+  }\n+\n+  ThreadLocalAllocStats tlab_stats() const {\n+    ThreadLocalAllocStats result;\n+    for (uint i = 0; i < _num_workers; i++) {\n+      result.update(_local_tlab_stats[i]);\n+    }\n+    return result;\n+  }\n+\n+  G1ConcurrentRefineStats refinement_stats() const {\n+    G1ConcurrentRefineStats result;\n+    for (uint i = 0; i < _num_workers; i++) {\n+      result += _local_refinement_stats[i];\n+    }\n+    return result;\n+  }\n+};\n+\n+class G1PreEvacuateCollectionSetBatchTask::NonJavaThreadFlushLogs : public G1AbstractSubTask {\n+  RetireTLABAndFlushLogsClosure _tc;\n+\n+public:\n+  NonJavaThreadFlushLogs() : G1AbstractSubTask(G1GCPhaseTimes::NonJavaThreadFlushLogs), _tc() { }\n+\n+  void do_work(uint worker_id) override {\n+    Threads::non_java_threads_do(&_tc);\n+  }\n+\n+  double worker_cost() const override {\n+    return 1.0;\n+  }\n+\n+  ThreadLocalAllocStats tlab_stats() const { return _tc._tlab_stats; }\n+  G1ConcurrentRefineStats refinement_stats() const { return _tc._refinement_stats; }\n+};\n+\n+G1PreEvacuateCollectionSetBatchTask::G1PreEvacuateCollectionSetBatchTask() :\n+  G1BatchedTask(\"Pre Evacuate Prepare\", G1CollectedHeap::heap()->phase_times()),\n+  _old_pending_cards(G1BarrierSet::dirty_card_queue_set().num_cards()),\n+  _java_retire_task(new JavaThreadRetireTLABAndFlushLogs()),\n+  _non_java_retire_task(new NonJavaThreadFlushLogs()) {\n+\n+  \/\/ Disable mutator refinement until concurrent refinement decides otherwise.\n+  G1BarrierSet::dirty_card_queue_set().set_mutator_refinement_threshold(SIZE_MAX);\n+\n+  add_serial_task(_non_java_retire_task);\n+  add_parallel_task(_java_retire_task);\n+}\n+\n+static void verify_empty_dirty_card_logs() {\n+#ifdef ASSERT\n+  ResourceMark rm;\n+\n+  struct Verifier : public ThreadClosure {\n+    size_t _buffer_size;\n+    Verifier() : _buffer_size(G1BarrierSet::dirty_card_queue_set().buffer_size()) {}\n+    void do_thread(Thread* t) override {\n+      G1DirtyCardQueue& queue = G1ThreadLocalData::dirty_card_queue(t);\n+      assert((queue.buffer() == nullptr) || (queue.index() == _buffer_size),\n+             \"non-empty dirty card queue for thread %s\", t->name());\n+    }\n+  } verifier;\n+  Threads::threads_do(&verifier);\n+#endif\n+}\n+\n+G1PreEvacuateCollectionSetBatchTask::~G1PreEvacuateCollectionSetBatchTask() {\n+  ThreadLocalAllocStats total_tlab_stats;\n+  total_tlab_stats.update(_java_retire_task->tlab_stats());\n+  total_tlab_stats.update(_non_java_retire_task->tlab_stats());\n+  total_tlab_stats.publish();\n+\n+  G1DirtyCardQueueSet& qset = G1BarrierSet::dirty_card_queue_set();\n+\n+  G1ConcurrentRefineStats total_refinement_stats;\n+  total_refinement_stats += _java_retire_task->refinement_stats();\n+  total_refinement_stats += _non_java_retire_task->refinement_stats();\n+  qset.update_refinement_stats(total_refinement_stats);\n+\n+  verify_empty_dirty_card_logs();\n+\n+  size_t pending_cards = qset.num_cards();\n+  size_t thread_buffer_cards = pending_cards - _old_pending_cards;\n+  G1CollectedHeap::heap()->policy()->record_concurrent_refinement_stats(pending_cards, thread_buffer_cards);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPreEvacuateTasks.cpp","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1YOUNGGCPREEVACUATETASKS_HPP\n+#define SHARE_GC_G1_G1YOUNGGCPREEVACUATETASKS_HPP\n+\n+#include \"gc\/g1\/g1BatchedTask.hpp\"\n+\n+\/\/ Set of pre evacuate collection set tasks containing (\"s\" means serial):\n+\/\/ - Retire and Flush Logs (Java threads)\n+\/\/ - Flush Logs (Non-Java threads)\n+class G1PreEvacuateCollectionSetBatchTask : public G1BatchedTask {\n+  class JavaThreadRetireTLABAndFlushLogs;\n+  class NonJavaThreadFlushLogs;\n+\n+  size_t _old_pending_cards;\n+\n+  \/\/ References to the tasks to retain access to statistics.\n+  JavaThreadRetireTLABAndFlushLogs* _java_retire_task;\n+  NonJavaThreadFlushLogs* _non_java_retire_task;\n+\n+public:\n+  G1PreEvacuateCollectionSetBatchTask();\n+  ~G1PreEvacuateCollectionSetBatchTask();\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1YOUNGGCPREEVACUATETASKS_HPP\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPreEvacuateTasks.hpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -175,1 +175,1 @@\n-    write_region(deferred);\n+    write_region(thread, deferred);\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-  void write_region(MemRegion mr) {\n+  void write_region(JavaThread* thread, MemRegion mr) {\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  \/\/ Causes all refs in \"mr\" to be assumed to be modified.\n+  \/\/ Causes all refs in \"mr\" to be assumed to be modified (by this JavaThread).\n@@ -56,1 +56,2 @@\n-  virtual void write_region(MemRegion mr) = 0;\n+  \/\/ Causes all refs in \"mr\" to be assumed to be modified by the given JavaThread.\n+  virtual void write_region(JavaThread* thread, MemRegion mr) = 0;\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSet.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/thread.hpp\"\n@@ -140,1 +141,1 @@\n-  bs->write_region(MemRegion((HeapWord*)(void*)dst, size));\n+  bs->invalidate(MemRegion((HeapWord*)(void*)dst, size));\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSet.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -111,2 +111,2 @@\n-        new LogMessageWithLevel(\"Prepare TLABs\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Concatenate Dirty Card Logs\", Level.DEBUG),\n+        new LogMessageWithLevel(\"JT Retire TLABs And Flush Logs\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Non-JT Flush Logs\", Level.DEBUG),\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,0 +90,2 @@\n+            \"RetireTLABsAndFlushLogs\",\n+            \"NonJavaThreadFlushLogs\",\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/TestG1ParallelPhases.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}