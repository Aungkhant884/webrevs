{"files":[{"patch":"@@ -131,1 +131,6 @@\n-    CFLAGS_DEBUG_SYMBOLS=\"-g\"\n+    # -gdwarf-4 and -gdwarf-aranges was introduced in clang 5.0\n+    GDWARF_FLAGS=\"-gdwarf-4 -gdwarf-aranges\"\n+    FLAGS_COMPILER_CHECK_ARGUMENTS(ARGUMENT: [${GDWARF_FLAGS}],\n+        IF_FALSE: [GDWARF_FLAGS=\"\"])\n+\n+    CFLAGS_DEBUG_SYMBOLS=\"-g ${GDWARF_FLAGS}\"\n","filename":"make\/autoconf\/flags-cflags.m4","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,0 +58,4 @@\n+#if defined(__clang_major__) && (__clang_major__ < 5)\n+  DWARF_LOG_ERROR(\"The DWARF parser only supports Clang 5.0+.\");\n+  return false;\n+#else\n@@ -93,0 +97,1 @@\n+#endif \/\/ clang\n","filename":"src\/hotspot\/share\/utilities\/decoder_elf.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -449,1 +449,1 @@\n-  char* last_slash = strrchr(_path, '\/');\n+  char* last_slash = strrchr(_path, *os::file_separator());\n@@ -1613,0 +1613,1 @@\n+      strip_path_prefix(filename, filename_len);\n@@ -1628,0 +1629,14 @@\n+\/\/ Remove everything before the last slash including the slash itself to get the actual filename. This is required, for\n+\/\/ example, for Clang debug builds which emit a relative path while GCC only emits the filename.\n+void DwarfFile::LineNumberProgram::strip_path_prefix(char* filename, const size_t filename_len) {\n+  char* last_slash = strrchr(filename, *os::file_separator());\n+  if (last_slash != nullptr) {\n+    uint16_t index_after_slash = (uint16_t)(last_slash + 1 - filename);\n+    \/\/ Copy filename to beginning of buffer.\n+    int bytes_written = jio_snprintf(filename, filename_len - index_after_slash, \"%s\", filename + index_after_slash);\n+    assert(bytes_written > 0, \"could not strip path prefix\");\n+    \/\/ Add null terminator.\n+    filename[bytes_written] = '\\0';\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/elfFile.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -864,0 +864,1 @@\n+    static void strip_path_prefix(char* filename, const size_t filename_len);\n","filename":"src\/hotspot\/share\/utilities\/elfFile.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -437,1 +437,1 @@\n-#ifndef PRODUCT\n+#if !defined(__clang_major__) || (__clang_major__ >= 5) \/\/ DWARF does not support Clang versions older than 5.0.\n@@ -458,1 +458,6 @@\n-  ASSERT_TRUE(strcmp(buf, \"jni.cp\") == 0);\n+  \/\/ Clang emits a relative file path for debug builds while in product builds it only emits the filename itself.\n+  \/\/ GCC only emits the filename.\n+  \/\/ This gives us either \"jni.cp\" or \"src\/ho\". In the latter case, we strip the path prefix to get to the actual\n+  \/\/ filename which, however, is not a real filename since we miss most of the path and the filename itself due to\n+  \/\/ the too small buffer. Stripping gives us \"ho\" as filename.\n+  ASSERT_TRUE(strcmp(buf, \"jni.cp\") == 0 || strcmp(buf, \"ho\") == 0);\n@@ -478,1 +483,1 @@\n-#endif \/\/ NOT PRODUCT\n+#endif \/\/ clang\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"}]}