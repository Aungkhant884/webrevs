{"files":[{"patch":"@@ -131,1 +131,1 @@\n-    # -gdwarf-4 and -gdwarf-aranges was introduced in clang 5.0\n+    # -gdwarf-4 and -gdwarf-aranges were introduced in clang 5.0\n","filename":"make\/autoconf\/flags-cflags.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,2 @@\n-  assert(filename != nullptr && filename_len > 0 && line != nullptr, \"Argument error\");\n+  assert(filename != nullptr && line != nullptr, \"arguments should not be null\");\n+  assert(filename_len > 1, \"buffer must be able to at least hold 1 character with a null terminator\");\n@@ -90,0 +91,3 @@\n+    \/\/ Return sane values.\n+    filename[0] = '\\0';\n+    *line = -1;\n","filename":"src\/hotspot\/share\/utilities\/decoder_elf.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1204,1 +1204,1 @@\n-  if (!_reader.read_sbyte(&_header._line_base)) {\n+  if (!_reader.read_byte(&_header._line_base)) {\n@@ -1610,2 +1610,1 @@\n-  const size_t dwarf_filename_len = 1024;\n-  char dwarf_filename[dwarf_filename_len]; \/\/ Store the filename read from DWARF which is then copied to 'filename'.\n+  size_t current_length;\n@@ -1613,5 +1612,0 @@\n-    if (!_reader.read_string(dwarf_filename, dwarf_filename_len)) {\n-      \/\/ Either an error while reading or we have reached the end of the file_names. Both should not happen.\n-      return false;\n-    }\n-\n@@ -1620,3 +1614,5 @@\n-      strip_path_prefix(dwarf_filename, dwarf_filename_len);\n-      copy_dwarf_filename_to_filename(dwarf_filename, dwarf_filename_len, filename, filename_len);\n-      return true;\n+      return read_filename(filename, filename_len);\n+    } else if (!_reader.read_string()) { \/\/ We don't care about this filename string. Read and ignore it.\n+      \/\/ Either an error while reading or we have reached the end of the file_names section before reaching the file_index.\n+      \/\/ Both should not happen.\n+      return false;\n@@ -1637,11 +1633,9 @@\n-\/\/ Remove everything before the last slash including the slash itself to get the actual filename. This is required, for\n-\/\/ example, for Clang debug builds which emit a relative path while GCC only emits the filename.\n-void DwarfFile::LineNumberProgram::strip_path_prefix(char* filename, const size_t filename_len) {\n-  char* last_slash = strrchr(filename, *os::file_separator());\n-  if (last_slash != nullptr) {\n-    uint16_t index_after_slash = (uint16_t)(last_slash + 1 - filename);\n-    \/\/ Copy filename to beginning of buffer.\n-    int bytes_written = jio_snprintf(filename, filename_len - index_after_slash, \"%s\", filename + index_after_slash);\n-    assert(bytes_written > 0, \"could not strip path prefix\");\n-    \/\/ Add null terminator.\n-    filename[bytes_written] = '\\0';\n+\/\/ Read the filename into the provided 'filename' buffer. If it does not fit, an alternative smaller tag will be emitted\n+\/\/ in order to let the DWARF parser succeed. The line number with a function name will almost always be sufficient to get\n+\/\/ to the actual source code location.\n+bool DwarfFile::LineNumberProgram::read_filename(char* filename, const size_t filename_len) {\n+  char next_char;\n+  if (!_reader.read_non_null_char(&next_char)) {\n+    \/\/ Either error while reading or read an empty string which indicates the end of the file_names section.\n+    \/\/ Both should not happen.\n+    return false;\n@@ -1649,0 +1643,29 @@\n+\n+  filename[0] = next_char;\n+  size_t index = 1;\n+  bool overflow_filename = false; \/\/ Is the currently read filename overflowing the provided 'filename' buffer?\n+  while (next_char != '\\0' && _reader.has_bytes_left()) {\n+    if (!_reader.read_byte(&next_char)) {\n+      return false;\n+    }\n+    if (next_char == *os::file_separator()) {\n+      \/\/ Skip file separator to get to the actual filename and reset the buffer and overflow flag. GCC does not emit\n+      \/\/ file separators while Clang does.\n+      index = 0;\n+      overflow_filename = false;\n+    } else if (index == filename_len) {\n+      \/\/ Just keep reading as we could read another file separator and reset the buffer again. But don't bother to store\n+      \/\/ the additionally read characters as it would not fit into the buffer anyway.\n+      overflow_filename = true;\n+    } else {\n+      assert(!overflow_filename, \"sanity check\");\n+      filename[index] = next_char;\n+      index++;\n+    }\n+  }\n+\n+  if (overflow_filename) {\n+    \/\/ 'filename' buffer overflow. Store either a generic overflow message or a minimal filename.\n+    write_filename_for_overflow(filename, filename_len);\n+  }\n+  return true;\n@@ -1651,7 +1674,15 @@\n-\/\/ Copy the read filename from the DWARF file stored in 'src' to the provided output buffer 'dst'.\n-void DwarfFile::LineNumberProgram::copy_dwarf_filename_to_filename(char* src, const size_t src_len,\n-                                                                   char* dst, const size_t dst_len) {\n-  const size_t count = MIN(src_len, dst_len);\n-  int bytes_written = jio_snprintf(dst, count, \"%s\", src);\n-  \/\/ Add null terminator.\n-  dst[count - 1] = '\\0';\n+\/\/ Try to write a generic overflow message to the provided buffer. If it does not fit, store the minimal filename \"L\"\n+\/\/ which always fits to get the source information in the form \"L:line_number\".\n+void DwarfFile::LineNumberProgram::write_filename_for_overflow(char* filename, const size_t filename_len) {\n+  DWARF_LOG_ERROR(\"DWARF filename string is too large to fit into the provided buffer of size %zu.\", filename_len);\n+  const size_t filename_overflow_message_length = strlen(overflow_filename) + 1;\n+  if (filename_overflow_message_length <= filename_len) {\n+    jio_snprintf(filename, filename_overflow_message_length, \"%s\", overflow_filename);\n+    DWARF_LOG_ERROR(\"Use overflow filename: %s\", overflow_filename);\n+  } else {\n+    \/\/ Buffer too small of generic overflow message.\n+    DWARF_LOG_ERROR(\"Too small for overflow filename, use minimal filename: %c\", minimal_overflow_filename);\n+    assert(filename_len > 1, \"sanity check\");\n+    filename[0] = minimal_overflow_filename;\n+    filename[1] = '\\0';\n+  }\n@@ -1730,6 +1761,1 @@\n-bool DwarfFile::MarkedDwarfFileReader::read_sbyte(int8_t* result) {\n-  _current_pos++;\n-  return read(result, 1);\n-}\n-\n-bool DwarfFile::MarkedDwarfFileReader::read_byte(uint8_t* result) {\n+bool DwarfFile::MarkedDwarfFileReader::read_byte(void* result) {\n@@ -1804,7 +1830,2 @@\n-  uint8_t next_byte;\n-  if (!read_byte(&next_byte)) {\n-    return false;\n-  }\n-\n-  if (next_byte == 0) {\n-    \/\/ Strings must contain at least one non-null byte.\n+  char first_char;\n+  if (!read_non_null_char(&first_char)) {\n@@ -1819,1 +1840,1 @@\n-    result[0] = (char)next_byte;\n+    result[0] = first_char;\n@@ -1822,0 +1843,1 @@\n+  uint8_t next_byte;\n@@ -1851,0 +1873,7 @@\n+bool DwarfFile::MarkedDwarfFileReader::read_non_null_char(char* result) {\n+  if (!read_byte(result)) {\n+    return false;\n+  }\n+  return *result != '\\0';\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/elfFile.cpp","additions":72,"deletions":43,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -424,2 +424,1 @@\n-    bool read_sbyte(int8_t* result);\n-    bool read_byte(uint8_t* result);\n+    bool read_byte(void* result);\n@@ -435,0 +434,1 @@\n+    bool read_non_null_char(char* result);\n@@ -721,0 +721,3 @@\n+    static constexpr const char* overflow_filename = \"<OVERFLOW>\";\n+    static constexpr const char minimal_overflow_filename = 'L';\n+\n@@ -865,1 +868,1 @@\n-    void apply_special_opcode(const uint8_t opcode);\n+    void apply_special_opcode(uint8_t opcode);\n@@ -869,2 +872,2 @@\n-    static void strip_path_prefix(char* filename, const size_t filename_len);\n-    static void copy_dwarf_filename_to_filename(char* src, size_t src_len, char* dst, size_t dst_len);\n+    bool read_filename(char* filename, size_t filename_len);\n+    static void write_filename_for_overflow(char* filename, size_t filename_len) ;\n","filename":"src\/hotspot\/share\/utilities\/elfFile.hpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"prims\/jniCheck.hpp\"\n@@ -438,1 +439,1 @@\n-\/\/ Test valid address of method JNI_CreateJavaVM in jni.cpp. We should get \"jni.cpp\" in the buffer and a valid line number.\n+\/\/ Test valid address of method ReportJNIFatalError in jniCheck.hpp. We should get \"jniCheck.hpp\" in the buffer and a valid line number.\n@@ -442,1 +443,1 @@\n-  address valid_function_pointer = (address)JNI_CreateJavaVM;\n+  address valid_function_pointer = (address)ReportJNIFatalError;\n@@ -444,18 +445,1 @@\n-  ASSERT_TRUE(strcmp(buf, \"jni.cpp\") == 0);\n-  ASSERT_TRUE(line > 0);\n-}\n-\n-\/\/ Same test as \"decoder_get_source_info_valid\" but with a too-small output buffer. Everything should work the same except\n-\/\/ that the output buffer truncates \"jni.cpp\" such that we find \"jni.cp\" instead. The line number must be found as before.\n-TEST_VM(os_linux, decoder_get_source_info_valid_truncated) {\n-  char buf[128] = \"\";\n-  int line = -1;\n-  memset(buf, 'X', sizeof(buf));\n-  address valid_function_pointer = (address)JNI_CreateJavaVM;\n-  ASSERT_TRUE(Decoder::get_source_info(valid_function_pointer, buf, 7, &line));\n-  ASSERT_TRUE(buf[7 - 1] == '\\0');\n-  ASSERT_TRUE(buf[7] == 'X');\n-  \/\/ Clang emits a relative file path for debug builds while in product builds it only emits the filename itself.\n-  \/\/ GCC only emits the filename. Either way, the DWARF parser should first read the entire filename, then strip the\n-  \/\/ prefix and finally copy the result in the output buffer. Therefore, we should always find \"jni.cp\".\n-  ASSERT_TRUE(strcmp(buf, \"jni.cp\") == 0);\n+  ASSERT_TRUE(strcmp(buf, \"jniCheck.hpp\") == 0);\n@@ -476,3 +460,2 @@\n-    \/\/ buffer should contain \"\", offset should contain -1\n-    ASSERT_TRUE(buf[0] == '\\0');\n-    ASSERT_TRUE(line == -1);\n+    ASSERT_TRUE(buf[0] == '\\0'); \/\/ Should contain \"\" on error\n+    ASSERT_TRUE(line == -1); \/\/ Should contain -1 on error\n@@ -481,0 +464,22 @@\n+\n+\/\/ Test with valid address but a too small buffer to store the entire filename. Should find generic <OVERFLOW> message\n+\/\/ and a valid line number.\n+TEST_VM(os_linux, decoder_get_source_info_valid_overflow) {\n+  char buf[11] = \"\";\n+  int line = -1;\n+  address valid_function_pointer = (address)ReportJNIFatalError;\n+  ASSERT_TRUE(Decoder::get_source_info(valid_function_pointer, buf, 11, &line));\n+  ASSERT_TRUE(strcmp(buf, \"<OVERFLOW>\") == 0);\n+  ASSERT_TRUE(line > 0);\n+}\n+\n+\/\/ Test with valid address but a too small buffer that can neither store the entire filename nor the generic <OVERFLOW>\n+\/\/ message. We should find \"L\" as filename and a valid line number.\n+TEST_VM(os_linux, decoder_get_source_info_valid_overflow_minimal) {\n+  char buf[2] = \"\";\n+  int line = -1;\n+  address valid_function_pointer = (address)ReportJNIFatalError;\n+  ASSERT_TRUE(Decoder::get_source_info(valid_function_pointer, buf, 2, &line));\n+  ASSERT_TRUE(strcmp(buf, \"L\") == 0); \/\/ Overflow message does not fit, so we fall back to \"L:line_number\"\n+  ASSERT_TRUE(line > 0); \/\/ Line should correctly be found and returned\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux.cpp","additions":28,"deletions":23,"binary":false,"changes":51,"status":"modified"}]}