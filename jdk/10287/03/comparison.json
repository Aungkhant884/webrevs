{"files":[{"patch":"@@ -131,1 +131,6 @@\n-    CFLAGS_DEBUG_SYMBOLS=\"-g\"\n+    # -gdwarf-4 and -gdwarf-aranges was introduced in clang 5.0\n+    GDWARF_FLAGS=\"-gdwarf-4 -gdwarf-aranges\"\n+    FLAGS_COMPILER_CHECK_ARGUMENTS(ARGUMENT: [${GDWARF_FLAGS}],\n+        IF_FALSE: [GDWARF_FLAGS=\"\"])\n+\n+    CFLAGS_DEBUG_SYMBOLS=\"-g ${GDWARF_FLAGS}\"\n","filename":"make\/autoconf\/flags-cflags.m4","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,0 +58,4 @@\n+#if defined(__clang_major__) && (__clang_major__ < 5)\n+  DWARF_LOG_ERROR(\"The DWARF parser only supports Clang 5.0+.\");\n+  return false;\n+#else\n@@ -93,0 +97,1 @@\n+#endif \/\/ clang\n","filename":"src\/hotspot\/share\/utilities\/decoder_elf.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -448,1 +448,1 @@\n-  char* last_slash = strrchr(_path, '\/');\n+  char* last_slash = strrchr(_path, *os::file_separator());\n@@ -1604,0 +1604,2 @@\n+  const size_t dwarf_filename_len = 1024;\n+  char dwarf_filename[dwarf_filename_len]; \/\/ Store the filename read from DWARF which is then copied to 'filename'.\n@@ -1605,1 +1607,1 @@\n-    if (!_reader.read_string(filename, filename_len)) {\n+    if (!_reader.read_string(dwarf_filename, dwarf_filename_len)) {\n@@ -1612,0 +1614,2 @@\n+      strip_path_prefix(dwarf_filename, dwarf_filename_len);\n+      copy_dwarf_filename_to_filename(dwarf_filename, dwarf_filename_len, filename, filename_len);\n@@ -1627,0 +1631,23 @@\n+\/\/ Remove everything before the last slash including the slash itself to get the actual filename. This is required, for\n+\/\/ example, for Clang debug builds which emit a relative path while GCC only emits the filename.\n+void DwarfFile::LineNumberProgram::strip_path_prefix(char* filename, const size_t filename_len) {\n+  char* last_slash = strrchr(filename, *os::file_separator());\n+  if (last_slash != nullptr) {\n+    uint16_t index_after_slash = (uint16_t)(last_slash + 1 - filename);\n+    \/\/ Copy filename to beginning of buffer.\n+    int bytes_written = jio_snprintf(filename, filename_len - index_after_slash, \"%s\", filename + index_after_slash);\n+    assert(bytes_written > 0, \"could not strip path prefix\");\n+    \/\/ Add null terminator.\n+    filename[bytes_written] = '\\0';\n+  }\n+}\n+\n+\/\/ Copy the read filename from the DWARF file stored in 'src' to the provided output buffer 'dst'.\n+void DwarfFile::LineNumberProgram::copy_dwarf_filename_to_filename(char* src, const size_t src_len,\n+                                                                   char* dst, const size_t dst_len) {\n+  const size_t count = MIN(src_len, dst_len);\n+  int bytes_written = jio_snprintf(dst, count, \"%s\", src);\n+  \/\/ Add null terminator.\n+  dst[count - 1] = '\\0';\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/elfFile.cpp","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -864,0 +864,2 @@\n+    static void strip_path_prefix(char* filename, const size_t filename_len);\n+    static void copy_dwarf_filename_to_filename(char* src, size_t src_len, char* dst, size_t dst_len);\n","filename":"src\/hotspot\/share\/utilities\/elfFile.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -437,1 +437,1 @@\n-#ifndef PRODUCT\n+#if !defined(__clang_major__) || (__clang_major__ >= 5) \/\/ DWARF does not support Clang versions older than 5.0.\n@@ -458,0 +458,3 @@\n+  \/\/ Clang emits a relative file path for debug builds while in product builds it only emits the filename itself.\n+  \/\/ GCC only emits the filename. Either way, the DWARF parser should first read the entire filename, then strip the\n+  \/\/ prefix and finally copy the result in the output buffer. Therefore, we should always find \"jni.cp\".\n@@ -478,1 +481,1 @@\n-#endif \/\/ NOT PRODUCT\n+#endif \/\/ clang\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"}]}