{"files":[{"patch":"@@ -131,1 +131,6 @@\n-    CFLAGS_DEBUG_SYMBOLS=\"-g\"\n+    # -gdwarf-4 and -gdwarf-aranges were introduced in clang 5.0\n+    GDWARF_FLAGS=\"-gdwarf-4 -gdwarf-aranges\"\n+    FLAGS_COMPILER_CHECK_ARGUMENTS(ARGUMENT: [${GDWARF_FLAGS}],\n+        IF_FALSE: [GDWARF_FLAGS=\"\"])\n+\n+    CFLAGS_DEBUG_SYMBOLS=\"-g ${GDWARF_FLAGS}\"\n","filename":"make\/autoconf\/flags-cflags.m4","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,1 +58,6 @@\n-  assert(filename != nullptr && filename_len > 0 && line != nullptr, \"Argument error\");\n+#if defined(__clang_major__) && (__clang_major__ < 5)\n+  DWARF_LOG_ERROR(\"The DWARF parser only supports Clang 5.0+.\");\n+  return false;\n+#else\n+  assert(filename != nullptr && line != nullptr, \"arguments should not be null\");\n+  assert(filename_len > 1, \"buffer must be able to at least hold 1 character with a null terminator\");\n@@ -86,0 +91,3 @@\n+    \/\/ Return sane values.\n+    filename[0] = '\\0';\n+    *line = -1;\n@@ -93,0 +101,1 @@\n+#endif \/\/ clang\n","filename":"src\/hotspot\/share\/utilities\/decoder_elf.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -448,1 +448,1 @@\n-  char* last_slash = strrchr(_path, '\/');\n+  char* last_slash = strrchr(_path, *os::file_separator());\n@@ -1204,1 +1204,1 @@\n-  if (!_reader.read_sbyte(&_header._line_base)) {\n+  if (!_reader.read_byte(&_header._line_base)) {\n@@ -1611,5 +1611,0 @@\n-    if (!_reader.read_string(filename, filename_len)) {\n-      \/\/ Either an error while reading or we have reached the end of the file_names. Both should not happen.\n-      return false;\n-    }\n-\n@@ -1618,1 +1613,5 @@\n-      return true;\n+      return read_filename(filename, filename_len);\n+    } else if (!_reader.read_string()) { \/\/ We don't care about this filename string. Read and ignore it.\n+      \/\/ Either an error while reading or we have reached the end of the file_names section before reaching the file_index.\n+      \/\/ Both should not happen.\n+      return false;\n@@ -1633,0 +1632,58 @@\n+\/\/ Read the filename into the provided 'filename' buffer. If it does not fit, an alternative smaller tag will be emitted\n+\/\/ in order to let the DWARF parser succeed. The line number with a function name will almost always be sufficient to get\n+\/\/ to the actual source code location.\n+bool DwarfFile::LineNumberProgram::read_filename(char* filename, const size_t filename_len) {\n+  char next_char;\n+  if (!_reader.read_non_null_char(&next_char)) {\n+    \/\/ Either error while reading or read an empty string which indicates the end of the file_names section.\n+    \/\/ Both should not happen.\n+    return false;\n+  }\n+\n+  filename[0] = next_char;\n+  size_t index = 1;\n+  bool overflow_filename = false; \/\/ Is the currently read filename overflowing the provided 'filename' buffer?\n+  while (next_char != '\\0' && _reader.has_bytes_left()) {\n+    if (!_reader.read_byte(&next_char)) {\n+      return false;\n+    }\n+    if (next_char == *os::file_separator()) {\n+      \/\/ Skip file separator to get to the actual filename and reset the buffer and overflow flag. GCC does not emit\n+      \/\/ file separators while Clang does.\n+      index = 0;\n+      overflow_filename = false;\n+    } else if (index == filename_len) {\n+      \/\/ Just keep reading as we could read another file separator and reset the buffer again. But don't bother to store\n+      \/\/ the additionally read characters as it would not fit into the buffer anyway.\n+      overflow_filename = true;\n+    } else {\n+      assert(!overflow_filename, \"sanity check\");\n+      filename[index] = next_char;\n+      index++;\n+    }\n+  }\n+\n+  if (overflow_filename) {\n+    \/\/ 'filename' buffer overflow. Store either a generic overflow message or a minimal filename.\n+    write_filename_for_overflow(filename, filename_len);\n+  }\n+  return true;\n+}\n+\n+\/\/ Try to write a generic overflow message to the provided buffer. If it does not fit, store the minimal filename \"L\"\n+\/\/ which always fits to get the source information in the form \"L:line_number\".\n+void DwarfFile::LineNumberProgram::write_filename_for_overflow(char* filename, const size_t filename_len) {\n+  DWARF_LOG_ERROR(\"DWARF filename string is too large to fit into the provided buffer of size %zu.\", filename_len);\n+  const size_t filename_overflow_message_length = strlen(overflow_filename) + 1;\n+  if (filename_overflow_message_length <= filename_len) {\n+    jio_snprintf(filename, filename_overflow_message_length, \"%s\", overflow_filename);\n+    DWARF_LOG_ERROR(\"Use overflow filename: %s\", overflow_filename);\n+  } else {\n+    \/\/ Buffer too small of generic overflow message.\n+    DWARF_LOG_ERROR(\"Too small for overflow filename, use minimal filename: %c\", minimal_overflow_filename);\n+    assert(filename_len > 1, \"sanity check\");\n+    filename[0] = minimal_overflow_filename;\n+    filename[1] = '\\0';\n+  }\n+}\n+\n@@ -1703,6 +1760,1 @@\n-bool DwarfFile::MarkedDwarfFileReader::read_sbyte(int8_t* result) {\n-  _current_pos++;\n-  return read(result, 1);\n-}\n-\n-bool DwarfFile::MarkedDwarfFileReader::read_byte(uint8_t* result) {\n+bool DwarfFile::MarkedDwarfFileReader::read_byte(void* result) {\n@@ -1777,7 +1829,2 @@\n-  uint8_t next_byte;\n-  if (!read_byte(&next_byte)) {\n-    return false;\n-  }\n-\n-  if (next_byte == 0) {\n-    \/\/ Strings must contain at least one non-null byte.\n+  char first_char;\n+  if (!read_non_null_char(&first_char)) {\n@@ -1792,1 +1839,1 @@\n-    result[0] = (char)next_byte;\n+    result[0] = first_char;\n@@ -1795,0 +1842,1 @@\n+  uint8_t next_byte;\n@@ -1824,0 +1872,7 @@\n+bool DwarfFile::MarkedDwarfFileReader::read_non_null_char(char* result) {\n+  if (!read_byte(result)) {\n+    return false;\n+  }\n+  return *result != '\\0';\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/elfFile.cpp","additions":77,"deletions":22,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -424,2 +424,1 @@\n-    bool read_sbyte(int8_t* result);\n-    bool read_byte(uint8_t* result);\n+    bool read_byte(void* result);\n@@ -435,0 +434,1 @@\n+    bool read_non_null_char(char* result);\n@@ -721,0 +721,3 @@\n+    static constexpr const char* overflow_filename = \"<OVERFLOW>\";\n+    static constexpr const char minimal_overflow_filename = 'L';\n+\n@@ -865,1 +868,1 @@\n-    void apply_special_opcode(const uint8_t opcode);\n+    void apply_special_opcode(uint8_t opcode);\n@@ -869,0 +872,2 @@\n+    bool read_filename(char* filename, size_t filename_len);\n+    static void write_filename_for_overflow(char* filename, size_t filename_len) ;\n","filename":"src\/hotspot\/share\/utilities\/elfFile.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"prims\/jniCheck.hpp\"\n@@ -440,2 +441,2 @@\n-#ifndef PRODUCT\n-\/\/ Test valid address of method JNI_CreateJavaVM in jni.cpp. We should get \"jni.cpp\" in the buffer and a valid line number.\n+#if !defined(__clang_major__) || (__clang_major__ >= 5) \/\/ DWARF does not support Clang versions older than 5.0.\n+\/\/ Test valid address of method ReportJNIFatalError in jniCheck.hpp. We should get \"jniCheck.hpp\" in the buffer and a valid line number.\n@@ -445,1 +446,1 @@\n-  address valid_function_pointer = (address)JNI_CreateJavaVM;\n+  address valid_function_pointer = (address)ReportJNIFatalError;\n@@ -447,15 +448,1 @@\n-  ASSERT_TRUE(strcmp(buf, \"jni.cpp\") == 0);\n-  ASSERT_TRUE(line > 0);\n-}\n-\n-\/\/ Same test as \"decoder_get_source_info_valid\" but with a too-small output buffer. Everything should work the same except\n-\/\/ that the output buffer truncates \"jni.cpp\" such that we find \"jni.cp\" instead. The line number must be found as before.\n-TEST_VM(os_linux, decoder_get_source_info_valid_truncated) {\n-  char buf[128] = \"\";\n-  int line = -1;\n-  memset(buf, 'X', sizeof(buf));\n-  address valid_function_pointer = (address)JNI_CreateJavaVM;\n-  ASSERT_TRUE(Decoder::get_source_info(valid_function_pointer, buf, 7, &line));\n-  ASSERT_TRUE(buf[7 - 1] == '\\0');\n-  ASSERT_TRUE(buf[7] == 'X');\n-  ASSERT_TRUE(strcmp(buf, \"jni.cp\") == 0);\n+  ASSERT_TRUE(strcmp(buf, \"jniCheck.hpp\") == 0);\n@@ -476,3 +463,2 @@\n-    \/\/ buffer should contain \"\", offset should contain -1\n-    ASSERT_TRUE(buf[0] == '\\0');\n-    ASSERT_TRUE(line == -1);\n+    ASSERT_TRUE(buf[0] == '\\0'); \/\/ Should contain \"\" on error\n+    ASSERT_TRUE(line == -1); \/\/ Should contain -1 on error\n@@ -481,1 +467,23 @@\n-#endif \/\/ NOT PRODUCT\n+\n+\/\/ Test with valid address but a too small buffer to store the entire filename. Should find generic <OVERFLOW> message\n+\/\/ and a valid line number.\n+TEST_VM(os_linux, decoder_get_source_info_valid_overflow) {\n+  char buf[11] = \"\";\n+  int line = -1;\n+  address valid_function_pointer = (address)ReportJNIFatalError;\n+  ASSERT_TRUE(Decoder::get_source_info(valid_function_pointer, buf, 11, &line));\n+  ASSERT_TRUE(strcmp(buf, \"<OVERFLOW>\") == 0);\n+  ASSERT_TRUE(line > 0);\n+}\n+\n+\/\/ Test with valid address but a too small buffer that can neither store the entire filename nor the generic <OVERFLOW>\n+\/\/ message. We should find \"L\" as filename and a valid line number.\n+TEST_VM(os_linux, decoder_get_source_info_valid_overflow_minimal) {\n+  char buf[2] = \"\";\n+  int line = -1;\n+  address valid_function_pointer = (address)ReportJNIFatalError;\n+  ASSERT_TRUE(Decoder::get_source_info(valid_function_pointer, buf, 2, &line));\n+  ASSERT_TRUE(strcmp(buf, \"L\") == 0); \/\/ Overflow message does not fit, so we fall back to \"L:line_number\"\n+  ASSERT_TRUE(line > 0); \/\/ Line should correctly be found and returned\n+}\n+#endif \/\/ clang\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux.cpp","additions":30,"deletions":22,"binary":false,"changes":52,"status":"modified"}]}