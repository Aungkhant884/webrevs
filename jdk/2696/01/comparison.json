{"files":[{"patch":"@@ -0,0 +1,278 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=no-options\n+ * @summary Run test with no arguments apart from the ones required by\n+ *          the test.\n+ * @requires os.family == \"linux\"\n+ * @run main\/othervm -XX:+AlwaysPreTouch -Xlog:pagesize:ps-%p.log TestTracePageSizes\n+ *\/\n+\n+\/*\n+ * @test id=explicit-large-page-size\n+ * @summary Run test explicitly with both 2m and 1g pages on x64. Excluding ZGC since\n+ *          it fail initialization if no large pages are available on the system.\n+ * @requires os.family == \"linux\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+ * @requires vm.gc != \"Z\"\n+ * @run main\/othervm -XX:+AlwaysPreTouch -Xlog:pagesize:ps-%p.log -XX:+UseLargePages -XX:LargePageSizeInBytes=2m TestTracePageSizes\n+ * @run main\/othervm -XX:+AlwaysPreTouch -Xlog:pagesize:ps-%p.log -XX:+UseLargePages -XX:LargePageSizeInBytes=1g TestTracePageSizes\n+ *\/\n+\n+\/*\n+ * @test id=compiler-options\n+ * @summary Run test without segmented code cache. Excluding ZGC since it\n+ *          fail initialization if no large pages are available on the system.\n+ * @requires os.family == \"linux\"\n+ * @requires vm.gc != \"Z\"\n+ * @run main\/othervm -XX:+AlwaysPreTouch -Xlog:pagesize:ps-%p.log -XX:-SegmentedCodeCache TestTracePageSizes\n+ * @run main\/othervm -XX:+AlwaysPreTouch -Xlog:pagesize:ps-%p.log -XX:-SegmentedCodeCache -XX:+UseLargePages TestTracePageSizes\n+ * @run main\/othervm -XX:+AlwaysPreTouch -Xlog:pagesize:ps-%p.log -XX:-SegmentedCodeCache -XX:+UseTransparentHugePages TestTracePageSizes\n+ *\/\n+\n+\/*\n+ * @test id=with-G1\n+ * @summary Run tests with G1\n+ * @requires os.family == \"linux\"\n+ * @requires vm.gc.G1\n+ * @run main\/othervm -XX:+AlwaysPreTouch -Xlog:pagesize:ps-%p.log -XX:+UseG1GC TestTracePageSizes\n+ * @run main\/othervm -XX:+AlwaysPreTouch -Xlog:pagesize:ps-%p.log -XX:+UseG1GC -XX:+UseLargePages TestTracePageSizes\n+ * @run main\/othervm -XX:+AlwaysPreTouch -Xlog:pagesize:ps-%p.log -XX:+UseG1GC -XX:+UseTransparentHugePages TestTracePageSizes\n+*\/\n+\n+\/*\n+ * @test id=with-Parallel\n+ * @summary Run tests with Parallel\n+ * @requires os.family == \"linux\"\n+ * @requires vm.gc.Parallel\n+ * @run main\/othervm -XX:+AlwaysPreTouch -Xlog:pagesize:ps-%p.log -XX:+UseParallelGC TestTracePageSizes\n+ * @run main\/othervm -XX:+AlwaysPreTouch -Xlog:pagesize:ps-%p.log -XX:+UseParallelGC -XX:+UseLargePages TestTracePageSizes\n+ * @run main\/othervm -XX:+AlwaysPreTouch -Xlog:pagesize:ps-%p.log -XX:+UseParallelGC -XX:+UseTransparentHugePages TestTracePageSizes\n+*\/\n+\n+\/*\n+ * @test id=with-Serial\n+ * @summary Run tests with Serial\n+ * @requires os.family == \"linux\"\n+ * @requires vm.gc.Serial\n+ * @run main\/othervm -XX:+AlwaysPreTouch -Xlog:pagesize:ps-%p.log -XX:+UseSerialGC TestTracePageSizes\n+ * @run main\/othervm -XX:+AlwaysPreTouch -Xlog:pagesize:ps-%p.log -XX:+UseSerialGC -XX:+UseLargePages TestTracePageSizes\n+ * @run main\/othervm -XX:+AlwaysPreTouch -Xlog:pagesize:ps-%p.log -XX:+UseSerialGC -XX:+UseTransparentHugePages TestTracePageSizes\n+*\/\n+\n+import java.io.File;\n+import java.util.LinkedList;\n+import java.util.Scanner;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/\/ Check that page sizes logged match what is recorded in \/proc\/self\/smaps.\n+\/\/ For transparent huge pages the matching is best effort since we can't\n+\/\/ know for sure what the underlying page size is.\n+public class TestTracePageSizes {\n+    \/\/ Store address ranges with known page size.\n+    private static LinkedList<RangeWithPageSize> ranges = new LinkedList<>();\n+    private static boolean debug;\n+\n+    \/\/ Parse \/proc\/self\/smaps using a regexp capturing the address\n+    \/\/ ranges, what page size they have and if they might use\n+    \/\/ transparent huge pages. The pattern is not greedy and will\n+    \/\/ match as little as possible so each \"segment\" in the file\n+    \/\/ will generate a match.\n+    private static void parseSmaps() throws Exception {\n+        String smapsPatternString = \"(\\\\w+)-(\\\\w+).*?\" +\n+                                    \"KernelPageSize:\\\\s*(\\\\d*) kB.*?\" +\n+                                    \"VmFlags: ([\\\\w ]*)\";\n+        Pattern smapsPattern = Pattern.compile(smapsPatternString, Pattern.DOTALL);\n+        Scanner smapsScanner = new Scanner(new File(\"\/proc\/self\/smaps\"));\n+        \/\/ Find all memory segments in the smaps-file.\n+        smapsScanner.findAll(smapsPattern).forEach(mr -> {\n+            String start = mr.group(1);\n+            String end = mr.group(2);\n+            String ps = mr.group(3);\n+            String vmFlags = mr.group(4);\n+\n+            \/\/ Create a range given the match and add it to the list.\n+            RangeWithPageSize range = new RangeWithPageSize(start, end, ps, vmFlags);\n+            ranges.add(range);\n+            debug(\"Added range: \" + range);\n+        });\n+        smapsScanner.close();\n+    }\n+\n+    \/\/ Search for a range including the given address.\n+    private static RangeWithPageSize getRange(String addr) {\n+        long laddr = Long.decode(addr);\n+        for (RangeWithPageSize range : ranges) {\n+            if (range.includes(laddr)) {\n+                return range;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/\/ Helper to get the page size in KB given a page size parsed\n+    \/\/ from log_info(pagesize) output.\n+    private static long pageSizeInKB(String pageSize) {\n+        String value = pageSize.substring(0, pageSize.length()-1);\n+        String unit = pageSize.substring(pageSize.length()-1);\n+        long ret = Long.parseLong(value);\n+        if (unit.equals(\"K\")) {\n+            return ret;\n+        } else if (unit.equals(\"M\")) {\n+            return ret * 1024;\n+        } else if (unit.equals(\"G\")) {\n+            return ret * 1024 * 1024;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ The test needs to be run with:\n+    \/\/  * -Xlog:pagesize:ps-%p.log - To generate the log file parsed\n+    \/\/    by the test itself.\n+    \/\/  * -XX:+AlwaysPreTouch - To make sure mapped memory is touched\n+    \/\/    so the relevant information is recorded in the smaps-file.\n+    public static void main(String args[]) throws Exception {\n+        \/\/ Check if debug printing is enabled.\n+        if (args.length > 0 && args[0].equals(\"-debug\")) {\n+            debug = true;\n+        } else {\n+            debug = false;\n+        }\n+\n+        \/\/ Parse \/proc\/self\/smaps to compare with values logged in the VM.\n+        parseSmaps();\n+\n+        \/\/ Setup patters for the JVM page size logging.\n+        String traceLinePatternString = \".*base=(0x[0-9A-Fa-f]*).*page_size=([^ ]+).*\";\n+        Pattern traceLinePattern = Pattern.compile(traceLinePatternString);\n+\n+        \/\/ The test needs to be run with page size logging printed to ps-$pid.log.\n+        Scanner fileScanner = new Scanner(new File(\".\/ps-\" + ProcessHandle.current().pid() + \".log\"));\n+        while (fileScanner.hasNextLine()) {\n+            String line = fileScanner.nextLine();\n+            if (line.matches(traceLinePatternString)){\n+                Matcher trace = traceLinePattern.matcher(line);\n+                trace.find();\n+\n+                String address = trace.group(1);\n+                String pageSize = trace.group(2);\n+\n+                RangeWithPageSize range = getRange(address);\n+                if (range == null) {\n+                    debug(\"Could not find range for: \" + line);\n+                    throw new AssertionError(\"No memory range found for address: \" + address);\n+                }\n+\n+                long pageSizeFromSmaps = range.getPageSize();\n+                long pageSizeFromTrace = pageSizeInKB(pageSize);\n+\n+                debug(\"From logfile: \" + line);\n+                debug(\"From smaps: \" + range);\n+\n+                if (pageSizeFromSmaps != pageSizeFromTrace) {\n+                    if (pageSizeFromTrace > pageSizeFromSmaps && range.isTransparentHuge()) {\n+                        \/\/ Page sizes mismatch because we can't know what underlying page size will\n+                        \/\/ be used when THP is enabled. So this is not a failure.\n+                        debug(\"Success: \" + pageSizeFromTrace + \" > \" + pageSizeFromSmaps + \" and THP enabled\");\n+                    } else {\n+                        debug(\"Failure: \" + pageSizeFromSmaps + \" != \" + pageSizeFromTrace);\n+                        throw new AssertionError(\"Page sizes mismatch: \" + pageSizeFromSmaps + \" != \" + pageSizeFromTrace);\n+                    }\n+                } else {\n+                    debug(\"Success: \" + pageSizeFromSmaps + \" == \" + pageSizeFromTrace);\n+                }\n+            }\n+            debug(\"---\");\n+        }\n+        fileScanner.close();\n+    }\n+\n+    private static void debug(String str) {\n+        if (debug) {\n+            System.out.println(str);\n+        }\n+    }\n+}\n+\n+\/\/ Class used to store information about memory ranges parsed\n+\/\/ from \/proc\/self\/smaps. The file contain a lot of information\n+\/\/ about the different mappings done by an application, but the\n+\/\/ lines we care about are:\n+\/\/ 700000000-73ea00000 rw-p 00000000 00:00 0\n+\/\/ ...\n+\/\/ KernelPageSize:        4 kB\n+\/\/ ...\n+\/\/ VmFlags: rd wr mr mw me ac sd\n+\/\/\n+\/\/ We use the VmFlags to know what kind of huge pages are used.\n+\/\/ For transparent huge pages the KernelPageSize field will not\n+\/\/ report the large page size.\n+class RangeWithPageSize {\n+    private long start;\n+    private long end;\n+    private long pageSize;\n+    private boolean vmFlagHG;\n+    private boolean vmFlagHT;\n+\n+    public RangeWithPageSize(String start, String end, String pageSize, String vmFlags) {\n+        this.start = Long.parseUnsignedLong(start, 16);\n+        this.end = Long.parseUnsignedLong(end, 16);;\n+        this.pageSize = Long.parseLong(pageSize);\n+\n+        vmFlagHG = false;\n+        vmFlagHT = false;\n+        \/\/ Check if the vmFlags line include:\n+        \/\/ * ht - Meaning the range is mapped using explicit huge pages.\n+        \/\/ * hg - Meaning the range is madvised huge.\n+        for (String flag : vmFlags.split(\" \")) {\n+            if (flag.equals(\"ht\")) {\n+                vmFlagHT = true;\n+            } else if (flag.equals(\"hg\")) {\n+                vmFlagHG = true;\n+            }\n+        }\n+    }\n+\n+    public long getPageSize() {\n+        return pageSize;\n+    }\n+\n+    public boolean isTransparentHuge() {\n+        return vmFlagHG;\n+    }\n+\n+    public boolean isExplicitHuge() {\n+        return vmFlagHT;\n+    }\n+\n+    public boolean includes(long addr) {\n+        return start <= addr && addr < end;\n+    }\n+\n+    public String toString() {\n+        return \"[\" + Long.toHexString(start) + \", \" + Long.toHexString(end) + \") \" +\n+               \"pageSize=\" + pageSize + \"KB isTHP=\" + vmFlagHG + \" isHUGETLB=\" + vmFlagHT;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTracePageSizes.java","additions":278,"deletions":0,"binary":false,"changes":278,"status":"added"}]}