{"files":[{"patch":"@@ -1918,10 +1918,0 @@\n-bool G1CollectedHeap::should_upgrade_to_full_gc(GCCause::Cause cause) {\n-  if (should_do_concurrent_full_gc(_gc_cause)) {\n-    return false;\n-  } else if (has_regions_left_for_allocation()) {\n-    return false;\n-  } else {\n-    return true;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -288,3 +288,0 @@\n-  \/\/ Return true if should upgrade to full gc after an incremental one.\n-  bool should_upgrade_to_full_gc(GCCause::Cause cause);\n-\n@@ -1092,3 +1089,4 @@\n-  \/\/ Returns whether there are any regions left in the heap for allocation.\n-  bool has_regions_left_for_allocation() const {\n-    return !is_maximal_no_gc() || num_free_regions() != 0;\n+  \/\/ Returns true if an incremental GC should be upgrade to a full gc. This\n+  \/\/ is done when there are no free regions and the heap can't be expanded.\n+  bool should_upgrade_to_full_gc() const {\n+    return is_maximal_no_gc() && num_free_regions() == 0;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-  } else if (g1h->should_upgrade_to_full_gc(_gc_cause)) {\n+  } else if (g1h->should_upgrade_to_full_gc()) {\n@@ -153,1 +153,1 @@\n-    } else if (g1h->should_upgrade_to_full_gc(_gc_cause)) {\n+    } else if (g1h->should_upgrade_to_full_gc()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}