{"files":[{"patch":"@@ -70,1 +70,1 @@\n-ciSymbol*                 ciObjectFactory::_shared_ci_symbols[vmSymbols::SID_LIMIT];\n+ciSymbol*                 ciObjectFactory::_shared_ci_symbols[vmSymbols::number_of_symbols()];\n@@ -129,5 +129,5 @@\n-    int i;\n-    for (i = vmSymbols::FIRST_SID; i < vmSymbols::SID_LIMIT; i++) {\n-      Symbol* vmsym = vmSymbols::symbol_at((vmSymbols::SID) i);\n-      assert(vmSymbols::find_sid(vmsym) == i, \"1-1 mapping\");\n-      ciSymbol* sym = new (_arena) ciSymbol(vmsym, (vmSymbols::SID) i);\n+    for (vmSymbolsIterator it = vmSymbolsRange.begin(); it != vmSymbolsRange.end(); ++it) {\n+      vmSymbolID index = *it;\n+      Symbol* vmsym = vmSymbols::symbol_at(index);\n+      assert(vmSymbols::find_sid(vmsym) == index, \"1-1 mapping\");\n+      ciSymbol* sym = new (_arena) ciSymbol(vmsym, index);\n@@ -135,1 +135,1 @@\n-      _shared_ci_symbols[i] = sym;\n+      _shared_ci_symbols[vmSymbols::as_int(index)] = sym;\n@@ -138,3 +138,4 @@\n-    for (i = vmSymbols::FIRST_SID; i < vmSymbols::SID_LIMIT; i++) {\n-      Symbol* vmsym = vmSymbols::symbol_at((vmSymbols::SID) i);\n-      ciSymbol* sym = vm_symbol_at((vmSymbols::SID) i);\n+    for (vmSymbolsIterator it = vmSymbolsRange.begin(); it != vmSymbolsRange.end(); ++it) {\n+      vmSymbolID index = *it;\n+      Symbol* vmsym = vmSymbols::symbol_at(index);\n+      ciSymbol* sym = vm_symbol_at(index);\n@@ -211,2 +212,2 @@\n-  vmSymbols::SID sid = vmSymbols::find_sid(key);\n-  if (sid != vmSymbols::NO_SID) {\n+  vmSymbolID sid = vmSymbols::find_sid(key);\n+  if (sid != vmSymbolID::NO_SID) {\n@@ -217,2 +218,2 @@\n-  assert(vmSymbols::find_sid(key) == vmSymbols::NO_SID, \"\");\n-  ciSymbol* s = new (arena()) ciSymbol(key, vmSymbols::NO_SID);\n+  assert(vmSymbols::find_sid(key) == vmSymbolID::NO_SID, \"\");\n+  ciSymbol* s = new (arena()) ciSymbol(key, vmSymbolID::NO_SID);\n@@ -681,2 +682,2 @@\n-ciSymbol* ciObjectFactory::vm_symbol_at(int index) {\n-  assert(index >= vmSymbols::FIRST_SID && index < vmSymbols::SID_LIMIT, \"oob\");\n+ciSymbol* ciObjectFactory::vm_symbol_at(vmSymbolID sid) {\n+  int index = vmSymbols::as_int(sid);\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"utilities\/vmEnums.hpp\"\n@@ -107,1 +108,1 @@\n-  static ciSymbol* vm_symbol_at(int index);\n+  static ciSymbol* vm_symbol_at(vmSymbolID index);\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-ciSymbol::ciSymbol(Symbol* s, vmSymbols::SID sid)\n+ciSymbol::ciSymbol(Symbol* s, vmSymbolID sid)\n@@ -45,1 +45,1 @@\n-  : _symbol(s), _sid(vmSymbols::NO_SID)\n+  : _symbol(s), _sid(vmSymbolID::NO_SID)\n","filename":"src\/hotspot\/share\/ci\/ciSymbol.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include \"utilities\/vmEnums.hpp\"\n@@ -51,1 +52,1 @@\n-  const vmSymbols::SID _sid;\n+  const vmSymbolID _sid;\n@@ -55,1 +56,1 @@\n-  ciSymbol(Symbol* s, vmSymbols::SID sid);   \/\/ for use with vmSymbols\n+  ciSymbol(Symbol* s, vmSymbolID sid);   \/\/ for use with vmSymbols\n@@ -71,1 +72,1 @@\n-  vmSymbols::SID sid() const { return _sid; }\n+  vmSymbolID sid() const { return _sid; }\n@@ -101,1 +102,1 @@\n-  static ciSymbol* name() { return ciObjectFactory::vm_symbol_at(vmSymbols::VM_SYMBOL_ENUM_NAME(name)); }\n+  static ciSymbol* name() { return ciObjectFactory::vm_symbol_at(VM_SYMBOL_ENUM_NAME(name)); }\n","filename":"src\/hotspot\/share\/ci\/ciSymbol.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1729,3 +1729,3 @@\n-      field->initialize(JVM_ACC_FIELD_INTERNAL,\n-                        injected[n].name_index,\n-                        injected[n].signature_index,\n+      field->initialize((u2)JVM_ACC_FIELD_INTERNAL,\n+                        (u2)(injected[n].name_index),\n+                        (u2)(injected[n].signature_index),\n@@ -2069,1 +2069,1 @@\n-  const vmSymbols::SID sid = vmSymbols::find_sid(name);\n+  const vmSymbolID sid = vmSymbols::find_sid(name);\n@@ -2075,1 +2075,1 @@\n-    case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {\n+    case VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {\n@@ -2080,1 +2080,1 @@\n-    case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ForceInline_signature): {\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ForceInline_signature): {\n@@ -2085,1 +2085,1 @@\n-    case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_DontInline_signature): {\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_DontInline_signature): {\n@@ -2090,1 +2090,1 @@\n-    case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_InjectedProfile_signature): {\n+    case VM_SYMBOL_ENUM_NAME(java_lang_invoke_InjectedProfile_signature): {\n@@ -2095,1 +2095,1 @@\n-    case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_LambdaForm_Compiled_signature): {\n+    case VM_SYMBOL_ENUM_NAME(java_lang_invoke_LambdaForm_Compiled_signature): {\n@@ -2100,1 +2100,1 @@\n-    case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Hidden_signature): {\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Hidden_signature): {\n@@ -2105,1 +2105,1 @@\n-    case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_IntrinsicCandidate_signature): {\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_IntrinsicCandidate_signature): {\n@@ -2110,1 +2110,1 @@\n-    case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Stable_signature): {\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Stable_signature): {\n@@ -2115,1 +2115,1 @@\n-    case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Contended_signature): {\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Contended_signature): {\n@@ -2124,1 +2124,1 @@\n-    case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ReservedStackAccess_signature): {\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ReservedStackAccess_signature): {\n@@ -5159,1 +5159,1 @@\n-  const vmSymbols::SID klass_id = Method::klass_id_for_intrinsics(ik);\n+  const vmSymbolID klass_id = Method::klass_id_for_intrinsics(ik);\n@@ -5161,1 +5161,1 @@\n-  if (klass_id != vmSymbols::NO_SID) {\n+  if (klass_id != vmSymbolID::NO_SID) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-  { SystemDictionary::WK_KLASS_ENUM_NAME(klass), vmSymbols::VM_SYMBOL_ENUM_NAME(name##_name), vmSymbols::VM_SYMBOL_ENUM_NAME(signature), may_be_java },\n+  { SystemDictionary::WK_KLASS_ENUM_NAME(klass), VM_SYMBOL_ENUM_NAME(name##_name), VM_SYMBOL_ENUM_NAME(signature), may_be_java },\n@@ -115,2 +115,2 @@\n-  vmSymbols::SID sid = vmSymbols::find_sid(class_name);\n-  if (sid == vmSymbols::NO_SID) {\n+  vmSymbolID sid = vmSymbols::find_sid(class_name);\n+  if (sid == vmSymbolID::NO_SID) {\n@@ -125,1 +125,1 @@\n-  if (sid == vmSymbols::VM_SYMBOL_ENUM_NAME(klass)) {              \\\n+  if (sid == VM_SYMBOL_ENUM_NAME(klass)) {                         \\\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/symbol.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"utilities\/vmEnums.hpp\"\n@@ -1683,2 +1685,2 @@\n-  const vmSymbols::SID name_index;\n-  const vmSymbols::SID signature_index;\n+  const vmSymbolID name_index;\n+  const vmSymbolID signature_index;\n@@ -1695,2 +1697,2 @@\n-  static Symbol* lookup_symbol(int symbol_index) {\n-    return vmSymbols::symbol_at((vmSymbols::SID)symbol_index);\n+  static Symbol* lookup_symbol(vmSymbolID symbol_index) {\n+    return Symbol::vm_symbol_at(symbol_index);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1985,0 +1985,2 @@\n+\/\/ TODO: we should change the base type of vmSymbolID from int to short. Then we can declare this\n+\/\/ array as vmSymbolID wk_init_info[] anf avoid all the type casts.\n@@ -1987,1 +1989,1 @@\n-    ((short)vmSymbols::VM_SYMBOL_ENUM_NAME(symbol)),\n+    ((short)VM_SYMBOL_ENUM_NAME(symbol)),\n@@ -1998,1 +2000,1 @@\n-    Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);\n+    Symbol* symbol = vmSymbols::symbol_at(vmSymbols::as_SID(sid));\n@@ -2014,1 +2016,1 @@\n-  Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);\n+  Symbol* symbol = vmSymbols::symbol_at(vmSymbols::as_SID(sid));\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -695,1 +695,1 @@\n-#define SID_ENUM(n) vmSymbols::VM_SYMBOL_ENUM_NAME(n)\n+#define SID_ENUM(n) VM_SYMBOL_ENUM_NAME(n)\n@@ -697,3 +697,3 @@\n-vmIntrinsics::ID vmIntrinsics::find_id_impl(vmSymbols::SID holder,\n-                                            vmSymbols::SID name,\n-                                            vmSymbols::SID sig,\n+vmIntrinsics::ID vmIntrinsics::find_id_impl(vmSymbolID holder,\n+                                            vmSymbolID name,\n+                                            vmSymbolID sig,\n@@ -701,1 +701,1 @@\n-  assert((int)vmSymbols::SID_LIMIT <= (1<<vmSymbols::log2_SID_LIMIT), \"must fit\");\n+  assert((int)vmSymbolID::SID_LIMIT <= (1<<vmSymbols::log2_SID_LIMIT), \"must fit\");\n@@ -764,1 +764,1 @@\n-vmSymbols::SID vmIntrinsics::class_for(vmIntrinsics::ID id) {\n+vmSymbolID vmIntrinsics::class_for(vmIntrinsics::ID id) {\n@@ -768,1 +768,1 @@\n-  return vmSymbols::SID( (info >> shift) & mask );\n+  return vmSymbols::as_SID( (info >> shift) & mask );\n@@ -771,1 +771,1 @@\n-vmSymbols::SID vmIntrinsics::name_for(vmIntrinsics::ID id) {\n+vmSymbolID vmIntrinsics::name_for(vmIntrinsics::ID id) {\n@@ -775,1 +775,1 @@\n-  return vmSymbols::SID( (info >> shift) & mask );\n+  return vmSymbols::as_SID( (info >> shift) & mask );\n@@ -778,1 +778,1 @@\n-vmSymbols::SID vmIntrinsics::signature_for(vmIntrinsics::ID id) {\n+vmSymbolID vmIntrinsics::signature_for(vmIntrinsics::ID id) {\n@@ -782,1 +782,1 @@\n-  return vmSymbols::SID( (info >> shift) & mask );\n+  return vmSymbols::as_SID( (info >> shift) & mask );\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -28,0 +28,8 @@\n+#include \"jfr\/support\/jfrIntrinsics.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/vmEnums.hpp\"\n+\n+class Method;\n+class methodHandle;\n+\n@@ -873,0 +881,138 @@\n+\/\/ VM Intrinsic ID's uniquely identify some very special methods\n+class vmIntrinsics : AllStatic {\n+  friend class vmSymbols;\n+  friend class ciObjectFactory;\n+\n+ public:\n+  \/\/ Accessing\n+  enum ID {\n+    _none = 0,                      \/\/ not an intrinsic (default answer)\n+\n+    #define VM_INTRINSIC_ENUM(id, klass, name, sig, flags)  id,\n+    #define __IGNORE_CLASS(id, name)                      \/*ignored*\/\n+    #define __IGNORE_NAME(id, name)                       \/*ignored*\/\n+    #define __IGNORE_SIGNATURE(id, name)                  \/*ignored*\/\n+    #define __IGNORE_ALIAS(id, name)                      \/*ignored*\/\n+\n+    VM_INTRINSICS_DO(VM_INTRINSIC_ENUM,\n+                     __IGNORE_CLASS, __IGNORE_NAME, __IGNORE_SIGNATURE, __IGNORE_ALIAS)\n+    #undef VM_INTRINSIC_ENUM\n+    #undef __IGNORE_CLASS\n+    #undef __IGNORE_NAME\n+    #undef __IGNORE_SIGNATURE\n+    #undef __IGNORE_ALIAS\n+\n+    ID_LIMIT,\n+    LAST_COMPILER_INLINE = _getAndSetReference,\n+    FIRST_MH_SIG_POLY    = _invokeGeneric,\n+    FIRST_MH_STATIC      = _linkToVirtual,\n+    LAST_MH_SIG_POLY     = _linkToInterface,\n+\n+    FIRST_ID = _none + 1\n+  };\n+\n+  enum Flags {\n+    \/\/ AccessFlags syndromes relevant to intrinsics.\n+    F_none = 0,\n+    F_R,                        \/\/ !static ?native !synchronized (R=\"regular\")\n+    F_S,                        \/\/  static ?native !synchronized\n+    F_Y,                        \/\/ !static ?native  synchronized\n+    F_RN,                       \/\/ !static  native !synchronized\n+    F_SN,                       \/\/  static  native !synchronized\n+    F_RNY,                      \/\/ !static  native  synchronized\n+\n+    FLAG_LIMIT\n+  };\n+  enum {\n+    log2_FLAG_LIMIT = 4         \/\/ checked by an assert at start-up\n+  };\n+\n+public:\n+  static ID ID_from(int raw_id) {\n+    assert(raw_id >= (int)_none && raw_id < (int)ID_LIMIT,\n+           \"must be a valid intrinsic ID\");\n+    return (ID)raw_id;\n+  }\n+\n+  static const char* name_at(ID id);\n+\n+private:\n+  static ID find_id_impl(vmSymbolID holder,\n+                         vmSymbolID name,\n+                         vmSymbolID sig,\n+                         jshort flags);\n+\n+  \/\/ check if the intrinsic is disabled by course-grained flags.\n+  static bool disabled_by_jvm_flags(vmIntrinsics::ID id);\n+public:\n+  static ID find_id(const char* name);\n+  \/\/ Given a method's class, name, signature, and access flags, report its ID.\n+  static ID find_id(vmSymbolID holder,\n+                    vmSymbolID name,\n+                    vmSymbolID sig,\n+                    jshort flags) {\n+    ID id = find_id_impl(holder, name, sig, flags);\n+#ifdef ASSERT\n+    \/\/ ID _none does not hold the following asserts.\n+    if (id == _none)  return id;\n+#endif\n+    assert(    class_for(id) == holder, \"correct id\");\n+    assert(     name_for(id) == name,   \"correct id\");\n+    assert(signature_for(id) == sig,    \"correct id\");\n+    return id;\n+  }\n+\n+  static void verify_method(ID actual_id, Method* m) PRODUCT_RETURN;\n+\n+  \/\/ Find out the symbols behind an intrinsic:\n+  static vmSymbolID     class_for(ID id);\n+  static vmSymbolID      name_for(ID id);\n+  static vmSymbolID signature_for(ID id);\n+  static Flags              flags_for(ID id);\n+\n+  static const char* short_name_as_C_string(ID id, char* buf, int size);\n+\n+  \/\/ Wrapper object methods:\n+  static ID for_boxing(BasicType type);\n+  static ID for_unboxing(BasicType type);\n+\n+  \/\/ Raw conversion:\n+  static ID for_raw_conversion(BasicType src, BasicType dest);\n+\n+  \/\/ The methods below provide information related to compiling intrinsics.\n+\n+  \/\/ (1) Information needed by the C1 compiler.\n+\n+  static bool preserves_state(vmIntrinsics::ID id);\n+  static bool can_trap(vmIntrinsics::ID id);\n+  static bool should_be_pinned(vmIntrinsics::ID id);\n+\n+  \/\/ (2) Information needed by the C2 compiler.\n+\n+  \/\/ Returns true if the intrinsic for method 'method' will perform a virtual dispatch.\n+  static bool does_virtual_dispatch(vmIntrinsics::ID id);\n+  \/\/ A return value larger than 0 indicates that the intrinsic for method\n+  \/\/ 'method' requires predicated logic.\n+  static int predicates_needed(vmIntrinsics::ID id);\n+\n+  \/\/ There are 2 kinds of JVM options to control intrinsics.\n+  \/\/ 1. Disable\/Control Intrinsic accepts a list of intrinsic IDs.\n+  \/\/    ControlIntrinsic is recommended. DisableIntrinic will be deprecated.\n+  \/\/    Currently, the DisableIntrinsic list prevails if an intrinsic appears on\n+  \/\/    both lists.\n+  \/\/\n+  \/\/ 2. Explicit UseXXXIntrinsics options. eg. UseAESIntrinsics, UseCRC32Intrinsics etc.\n+  \/\/    Each option can control a group of intrinsics. The user can specify them but\n+  \/\/    their final values are subject to hardware inspection (VM_Version::initialize).\n+  \/\/    Stub generators are controlled by them.\n+  \/\/\n+  \/\/ An intrinsic is enabled if and only if neither the fine-grained control(1) nor\n+  \/\/ the corresponding coarse-grained control(2) disables it.\n+  static bool is_disabled_by_flags(vmIntrinsics::ID id);\n+\n+  static bool is_disabled_by_flags(const methodHandle& method);\n+  static bool is_intrinsic_available(vmIntrinsics::ID id) {\n+    return !is_disabled_by_flags(id);\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":146,"deletions":0,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -39,2 +39,0 @@\n-Symbol* vmSymbols::_symbols[vmSymbols::SID_LIMIT];\n-\n@@ -49,1 +47,1 @@\n-static vmSymbols::SID vm_symbol_index[vmSymbols::SID_LIMIT];\n+static vmSymbolID vm_symbol_index[vmSymbols::number_of_symbols()];\n@@ -52,2 +50,2 @@\n-    const Symbol* a = vmSymbols::symbol_at(*((vmSymbols::SID*) void_a));\n-    const Symbol* b = vmSymbols::symbol_at(*((vmSymbols::SID*) void_b));\n+    const Symbol* a = Symbol::vm_symbol_at(*((vmSymbolID*) void_a));\n+    const Symbol* b = Symbol::vm_symbol_at(*((vmSymbolID*) void_b));\n@@ -63,1 +61,1 @@\n-static const char* vm_symbol_enum_name(vmSymbols::SID sid) {\n+static const char* vm_symbol_enum_name(vmSymbolID sid) {\n@@ -65,1 +63,1 @@\n-  int skip = (int)sid - (int)vmSymbols::FIRST_SID;\n+  int skip = vmSymbols::as_int(sid) - vmSymbols::as_int(vmSymbolID::FIRST_SID);\n@@ -81,2 +79,2 @@\n-  assert((int)SID_LIMIT <= (1<<log2_SID_LIMIT), \"must fit in this bitfield\");\n-  assert((int)SID_LIMIT*5 > (1<<log2_SID_LIMIT), \"make the bitfield smaller, please\");\n+  assert(SID_LIMIT <= (1<<log2_SID_LIMIT), \"must fit in this bitfield\");\n+  assert(SID_LIMIT*5 > (1<<log2_SID_LIMIT), \"make the bitfield smaller, please\");\n@@ -87,1 +85,2 @@\n-    for (int index = (int)FIRST_SID; index < (int)SID_LIMIT; index++) {\n+    for (vmSymbolsIterator it = vmSymbolsRange.begin(); it != vmSymbolsRange.end(); ++it) {\n+      vmSymbolID index = *it;\n@@ -89,1 +88,1 @@\n-      _symbols[index] = sym;\n+      Symbol::_vm_symbols[as_int(index)] = sym;\n@@ -116,4 +115,6 @@\n-  for (int i1 = (int)FIRST_SID; i1 < (int)SID_LIMIT; i1++) {\n-    Symbol* sym = symbol_at((SID)i1);\n-    for (int i2 = (int)FIRST_SID; i2 < i1; i2++) {\n-      if (symbol_at((SID)i2) == sym) {\n+  for (vmSymbolsIterator it1 = vmSymbolsRange.begin(); it1 != vmSymbolsRange.end(); ++it1) {\n+    vmSymbolID i1 = *it1;\n+    Symbol* sym = symbol_at(i1);\n+    for (vmSymbolsIterator it2 = vmSymbolsRange.begin(); it2 != it1; ++it2) {\n+      vmSymbolID i2 = *it2;\n+      if (symbol_at(i2) == sym) {\n@@ -121,2 +122,2 @@\n-                   vm_symbol_enum_name((SID)i2), i2,\n-                   vm_symbol_enum_name((SID)i1), i1);\n+                   vm_symbol_enum_name(i2), as_int(i2),\n+                   vm_symbol_enum_name(i1), as_int(i1));\n@@ -132,2 +133,3 @@\n-    for (int index = (int)FIRST_SID; index < (int)SID_LIMIT; index++) {\n-      vm_symbol_index[index] = (SID)index;\n+    for (vmSymbolsIterator it = vmSymbolsRange.begin(); it != vmSymbolsRange.end(); ++it) {\n+      vmSymbolID index = *it;\n+      vm_symbol_index[as_int(index)] = index;\n@@ -143,1 +145,1 @@\n-    assert(_symbols[NO_SID] == NULL, \"must be\");\n+    assert(Symbol::_vm_symbols[NO_SID] == NULL, \"must be\");\n@@ -148,1 +150,1 @@\n-    SID sid = VM_SYMBOL_ENUM_NAME(java_lang_Object);\n+    vmSymbolID sid = VM_SYMBOL_ENUM_NAME(java_lang_Object);\n@@ -153,2 +155,3 @@\n-    for (int index = (int)FIRST_SID; index < (int)SID_LIMIT; index++) {\n-      Symbol* sym = symbol_at((SID)index);\n+    for (vmSymbolsIterator it = vmSymbolsRange.begin(); it != vmSymbolsRange.end(); ++it) {\n+      vmSymbolID index = *it;\n+      Symbol* sym = symbol_at(index);\n@@ -156,1 +159,1 @@\n-      assert(sid == (SID)index, \"symbol index works\");\n+      assert(sid == index, \"symbol index works\");\n@@ -166,1 +169,1 @@\n-    assert(sid == NO_SID, \"symbol index works (negative test)\");\n+    assert(sid == vmSymbolID::NO_SID, \"symbol index works (negative test)\");\n@@ -173,2 +176,2 @@\n-const char* vmSymbols::name_for(vmSymbols::SID sid) {\n-  if (sid == NO_SID)\n+const char* vmSymbols::name_for(vmSymbolID sid) {\n+  if (sid == vmSymbolID::NO_SID)\n@@ -177,2 +180,3 @@\n-  for (int index = (int)FIRST_SID; index < (int)SID_LIMIT; index++) {\n-    if (index == (int)sid)\n+  for (vmSymbolsIterator it = vmSymbolsRange.begin(); it != vmSymbolsRange.end(); ++it) {\n+    vmSymbolID index = *it;\n+    if (index == sid)\n@@ -190,2 +194,3 @@\n-  for (int index = (int)FIRST_SID; index < (int)SID_LIMIT; index++) {\n-    f->do_symbol(&_symbols[index]);\n+  for (vmSymbolsIterator it = vmSymbolsRange.begin(); it != vmSymbolsRange.end(); ++it) {\n+    vmSymbolID index = *it;\n+    f->do_symbol(&Symbol::_vm_symbols[as_int(index)]);\n@@ -198,3 +203,4 @@\n-void vmSymbols::metaspace_pointers_do(MetaspaceClosure *it) {\n-  for (int index = (int)FIRST_SID; index < (int)SID_LIMIT; index++) {\n-    it->push(&_symbols[index]);\n+void vmSymbols::metaspace_pointers_do(MetaspaceClosure *closure) {\n+  for (vmSymbolsIterator it = vmSymbolsRange.begin(); it != vmSymbolsRange.end(); ++it) {\n+    vmSymbolID index = *it;\n+    closure->push(&Symbol::_vm_symbols[as_int(index)]);\n@@ -203,1 +209,1 @@\n-    it->push(&_type_signatures[i]);\n+    closure->push(&_type_signatures[i]);\n@@ -208,2 +214,2 @@\n-  soc->do_region((u_char*)&_symbols[FIRST_SID],\n-                 (SID_LIMIT - FIRST_SID) * sizeof(_symbols[0]));\n+  soc->do_region((u_char*)&Symbol::_vm_symbols[FIRST_SID],\n+                 (SID_LIMIT - FIRST_SID) * sizeof(Symbol::_vm_symbols[0]));\n@@ -213,2 +219,0 @@\n-static int mid_hint = (int)vmSymbols::FIRST_SID+1;\n-\n@@ -220,1 +224,2 @@\n-vmSymbols::SID vmSymbols::find_sid(const Symbol* symbol) {\n+vmSymbolID vmSymbols::find_sid(const Symbol* symbol) {\n+  static int mid_hint = FIRST_SID+1;\n@@ -227,2 +232,2 @@\n-  int min = (int)FIRST_SID, max = (int)SID_LIMIT - 1;\n-  SID sid = NO_SID, sid1;\n+  int min = FIRST_SID, max = SID_LIMIT - 1;\n+  vmSymbolID sid = vmSymbolID::NO_SID, sid1;\n@@ -231,1 +236,1 @@\n-  cmp1 = compare_symbol(symbol, symbol_at(sid1));\n+  cmp1 = compare_symbol(symbol, Symbol::vm_symbol_at(sid1));\n@@ -265,0 +270,4 @@\n+  if (sid == vmSymbolID::NO_SID) {\n+    return sid;\n+  }\n+\n@@ -273,3 +282,4 @@\n-    SID sid2 = NO_SID;\n-    for (int index = (int)FIRST_SID; index < (int)SID_LIMIT; index++) {\n-      Symbol* sym2 = symbol_at((SID)index);\n+    vmSymbolID sid2 = vmSymbolID::NO_SID;\n+    for (vmSymbolsIterator it = vmSymbolsRange.begin(); it != vmSymbolsRange.end(); ++it) {\n+      vmSymbolID index = *it;\n+      Symbol* sym2 = symbol_at(index);\n@@ -277,1 +287,1 @@\n-        sid2 = (SID)index;\n+        sid2 = index;\n@@ -282,1 +292,1 @@\n-    if (_symbols[sid] != _symbols[sid2]) {\n+    if (Symbol::_vm_symbols[as_int(sid)] != Symbol::_vm_symbols[as_int(sid2)]) {\n@@ -291,1 +301,1 @@\n-vmSymbols::SID vmSymbols::find_sid(const char* symbol_name) {\n+vmSymbolID vmSymbols::find_sid(const char* symbol_name) {\n@@ -293,1 +303,1 @@\n-  if (symbol == NULL)  return NO_SID;\n+  if (symbol == NULL)  return vmSymbolID::NO_SID;\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.cpp","additions":60,"deletions":50,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"jfr\/support\/jfrIntrinsics.hpp\"\n+#include \"classfile\/vmIntrinsics.hpp\"\n@@ -33,2 +33,1 @@\n-#include \"vmIntrinsics.hpp\"\n-\n+#include \"utilities\/enumIterator.hpp\"\n@@ -46,1 +45,2 @@\n-#define VM_SYMBOL_ENUM_NAME(name)    name##_enum\n+#define VM_SYMBOL_ENUM_NAME_(name)    name##_enum\n+#define VM_SYMBOL_ENUM_NAME(name)    vmSymbolID::VM_SYMBOL_ENUM_NAME_(name)\n@@ -678,0 +678,9 @@\n+\/\/ enum for figuring positions and size of Symbol::_vm_symbols[]\n+enum class vmSymbolID : int {\n+  NO_SID = -1,               \/\/ exclusive lower limit\n+\n+  #define VM_SYMBOL_ENUM(name, string) VM_SYMBOL_ENUM_NAME_(name),\n+  VM_SYMBOLS_DO(VM_SYMBOL_ENUM, VM_ALIAS_IGNORE)\n+  #undef VM_SYMBOL_ENUM\n+\n+  SID_LIMIT,                 \/\/ exclusive upper limit\n@@ -679,0 +688,3 @@\n+  #define VM_ALIAS_ENUM(name, def) VM_SYMBOL_ENUM_NAME_(name) = VM_SYMBOL_ENUM_NAME_(def),\n+  VM_SYMBOLS_DO(VM_SYMBOL_IGNORE, VM_ALIAS_ENUM)\n+  #undef VM_ALIAS_ENUM\n@@ -680,1 +692,7 @@\n-\/\/ Class vmSymbols\n+  FIRST_SID = NO_SID + 1,    \/\/ inclusive lower limit\n+  LAST_SID = SID_LIMIT - 1,  \/\/ inclusive upper limit\n+};\n+\n+ENUMERATOR_RANGE(vmSymbolID, vmSymbolID::FIRST_SID, vmSymbolID::LAST_SID)\n+constexpr EnumRange<vmSymbolID> vmSymbolsRange; \/\/ the default range of all valid vmSymbolIDs\n+using vmSymbolsIterator = EnumIterator<vmSymbolID>; \/\/ convenience\n@@ -686,0 +704,6 @@\n+\n+  static const int NO_SID    = static_cast<int>(vmSymbolID::NO_SID);    \/\/ exclusive lower limit\n+  static const int FIRST_SID = static_cast<int>(vmSymbolID::FIRST_SID); \/\/ inclusive lower limit\n+  static const int LAST_SID  = static_cast<int>(vmSymbolID::FIRST_SID); \/\/ inclusive upper limit\n+  static const int SID_LIMIT = static_cast<int>(vmSymbolID::SID_LIMIT); \/\/ exclusive upper limit\n+\n@@ -687,3 +711,6 @@\n-  \/\/ enum for figuring positions and size of array holding Symbol*s\n-  enum SID {\n-    NO_SID = 0,\n+  static constexpr bool is_valid_id(int id) {\n+    return (id >= FIRST_SID && id < SID_LIMIT);\n+  }\n+  static constexpr bool is_valid_id(vmSymbolID sid) {\n+    return is_valid_id(static_cast<int>(sid));\n+  }\n@@ -691,3 +718,4 @@\n-    #define VM_SYMBOL_ENUM(name, string) VM_SYMBOL_ENUM_NAME(name),\n-    VM_SYMBOLS_DO(VM_SYMBOL_ENUM, VM_ALIAS_IGNORE)\n-    #undef VM_SYMBOL_ENUM\n+  static constexpr vmSymbolID as_SID(int id) {\n+    assert(is_valid_id(id), \"must be\");\n+    return static_cast<vmSymbolID>(id);\n+  }\n@@ -695,1 +723,4 @@\n-    SID_LIMIT,\n+  static constexpr int as_int(vmSymbolID sid) {\n+    assert(is_valid_id(sid), \"must be\");\n+    return static_cast<int>(sid);\n+  }\n@@ -697,3 +728,4 @@\n-    #define VM_ALIAS_ENUM(name, def) VM_SYMBOL_ENUM_NAME(name) = VM_SYMBOL_ENUM_NAME(def),\n-    VM_SYMBOLS_DO(VM_SYMBOL_IGNORE, VM_ALIAS_ENUM)\n-    #undef VM_ALIAS_ENUM\n+  static constexpr int number_of_symbols() {\n+    static_assert(FIRST_SID == 0, \"must be\");\n+    return SID_LIMIT;\n+  }\n@@ -701,2 +733,0 @@\n-    FIRST_SID = NO_SID + 1\n-  };\n@@ -708,2 +738,0 @@\n-  \/\/ The symbol array\n-  static Symbol* _symbols[];\n@@ -720,1 +748,1 @@\n-      return _symbols[VM_SYMBOL_ENUM_NAME(name)];         \\\n+      return Symbol::_vm_symbols[static_cast<int>(VM_SYMBOL_ENUM_NAME(name))]; \\\n@@ -736,4 +764,2 @@\n-  static Symbol* symbol_at(SID id) {\n-    assert(id >= FIRST_SID && id < SID_LIMIT, \"oob\");\n-    assert(_symbols[id] != NULL, \"init\");\n-    return _symbols[id];\n+  static Symbol* symbol_at(vmSymbolID id) {\n+    return Symbol::vm_symbol_at(id);\n@@ -742,3 +768,3 @@\n-  \/\/ Returns symbol's SID if one is assigned, else NO_SID.\n-  static SID find_sid(const Symbol* symbol);\n-  static SID find_sid(const char* symbol_name);\n+  \/\/ Returns symbol's vmSymbolID if one is assigned, else vmSymbolID::NO_SID.\n+  static vmSymbolID find_sid(const Symbol* symbol);\n+  static vmSymbolID find_sid(const char* symbol_name);\n@@ -748,1 +774,1 @@\n-  static const char* name_for(SID sid);\n+  static const char* name_for(vmSymbolID sid);\n@@ -752,129 +778,0 @@\n-\/\/ VM Intrinsic ID's uniquely identify some very special methods\n-class vmIntrinsics: AllStatic {\n-  friend class vmSymbols;\n-  friend class ciObjectFactory;\n-\n- public:\n-  \/\/ Accessing\n-  enum ID {\n-    _none = 0,                      \/\/ not an intrinsic (default answer)\n-\n-    #define VM_INTRINSIC_ENUM(id, klass, name, sig, flags)  id,\n-    VM_INTRINSICS_DO(VM_INTRINSIC_ENUM,\n-                     VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE)\n-    #undef VM_INTRINSIC_ENUM\n-\n-    ID_LIMIT,\n-    LAST_COMPILER_INLINE = _getAndSetReference,\n-    FIRST_MH_SIG_POLY    = _invokeGeneric,\n-    FIRST_MH_STATIC      = _linkToVirtual,\n-    LAST_MH_SIG_POLY     = _linkToInterface,\n-\n-    FIRST_ID = _none + 1\n-  };\n-\n-  enum Flags {\n-    \/\/ AccessFlags syndromes relevant to intrinsics.\n-    F_none = 0,\n-    F_R,                        \/\/ !static ?native !synchronized (R=\"regular\")\n-    F_S,                        \/\/  static ?native !synchronized\n-    F_Y,                        \/\/ !static ?native  synchronized\n-    F_RN,                       \/\/ !static  native !synchronized\n-    F_SN,                       \/\/  static  native !synchronized\n-    F_RNY,                      \/\/ !static  native  synchronized\n-\n-    FLAG_LIMIT\n-  };\n-  enum {\n-    log2_FLAG_LIMIT = 4         \/\/ checked by an assert at start-up\n-  };\n-\n-public:\n-  static ID ID_from(int raw_id) {\n-    assert(raw_id >= (int)_none && raw_id < (int)ID_LIMIT,\n-           \"must be a valid intrinsic ID\");\n-    return (ID)raw_id;\n-  }\n-\n-  static const char* name_at(ID id);\n-\n-private:\n-  static ID find_id_impl(vmSymbols::SID holder,\n-                         vmSymbols::SID name,\n-                         vmSymbols::SID sig,\n-                         jshort flags);\n-\n-  \/\/ check if the intrinsic is disabled by course-grained flags.\n-  static bool disabled_by_jvm_flags(vmIntrinsics::ID id);\n-public:\n-  static ID find_id(const char* name);\n-  \/\/ Given a method's class, name, signature, and access flags, report its ID.\n-  static ID find_id(vmSymbols::SID holder,\n-                    vmSymbols::SID name,\n-                    vmSymbols::SID sig,\n-                    jshort flags) {\n-    ID id = find_id_impl(holder, name, sig, flags);\n-#ifdef ASSERT\n-    \/\/ ID _none does not hold the following asserts.\n-    if (id == _none)  return id;\n-#endif\n-    assert(    class_for(id) == holder, \"correct id\");\n-    assert(     name_for(id) == name,   \"correct id\");\n-    assert(signature_for(id) == sig,    \"correct id\");\n-    return id;\n-  }\n-\n-  static void verify_method(ID actual_id, Method* m) PRODUCT_RETURN;\n-\n-  \/\/ Find out the symbols behind an intrinsic:\n-  static vmSymbols::SID     class_for(ID id);\n-  static vmSymbols::SID      name_for(ID id);\n-  static vmSymbols::SID signature_for(ID id);\n-  static Flags              flags_for(ID id);\n-\n-  static const char* short_name_as_C_string(ID id, char* buf, int size);\n-\n-  \/\/ Wrapper object methods:\n-  static ID for_boxing(BasicType type);\n-  static ID for_unboxing(BasicType type);\n-\n-  \/\/ Raw conversion:\n-  static ID for_raw_conversion(BasicType src, BasicType dest);\n-\n-  \/\/ The methods below provide information related to compiling intrinsics.\n-\n-  \/\/ (1) Information needed by the C1 compiler.\n-\n-  static bool preserves_state(vmIntrinsics::ID id);\n-  static bool can_trap(vmIntrinsics::ID id);\n-  static bool should_be_pinned(vmIntrinsics::ID id);\n-\n-  \/\/ (2) Information needed by the C2 compiler.\n-\n-  \/\/ Returns true if the intrinsic for method 'method' will perform a virtual dispatch.\n-  static bool does_virtual_dispatch(vmIntrinsics::ID id);\n-  \/\/ A return value larger than 0 indicates that the intrinsic for method\n-  \/\/ 'method' requires predicated logic.\n-  static int predicates_needed(vmIntrinsics::ID id);\n-\n-  \/\/ There are 2 kinds of JVM options to control intrinsics.\n-  \/\/ 1. Disable\/Control Intrinsic accepts a list of intrinsic IDs.\n-  \/\/    ControlIntrinsic is recommended. DisableIntrinic will be deprecated.\n-  \/\/    Currently, the DisableIntrinsic list prevails if an intrinsic appears on\n-  \/\/    both lists.\n-  \/\/\n-  \/\/ 2. Explicit UseXXXIntrinsics options. eg. UseAESIntrinsics, UseCRC32Intrinsics etc.\n-  \/\/    Each option can control a group of intrinsics. The user can specify them but\n-  \/\/    their final values are subject to hardware inspection (VM_Version::initialize).\n-  \/\/    Stub generators are controlled by them.\n-  \/\/\n-  \/\/ An intrinsic is enabled if and only if neither the fine-grained control(1) nor\n-  \/\/ the corresponding coarse-grained control(2) disables it.\n-  static bool is_disabled_by_flags(vmIntrinsics::ID id);\n-\n-  static bool is_disabled_by_flags(const methodHandle& method);\n-  static bool is_intrinsic_available(vmIntrinsics::ID id) {\n-    return !is_disabled_by_flags(id);\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":54,"deletions":157,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-  vmSymbols::SID kls_sid = vmSymbols::NO_SID;\n+  vmSymbolID kls_sid = vmSymbolID::NO_SID;\n@@ -168,7 +168,7 @@\n-  JVMCIENV->create_string(vmSymbols::symbol_at(vmSymbols::VM_SYMBOL_ENUM_NAME(s)), JVMCI_CHECK_NULL)\n-#define VM_INTRINSIC_INFO(id, kls, name, sig, ignore_fcode) {             \\\n-    vmSymbols::SID sid = vmSymbols::VM_SYMBOL_ENUM_NAME(kls);             \\\n-    if (kls_sid != sid) {                                                 \\\n-      kls_str = VM_SYMBOL_TO_STRING(kls);                                 \\\n-      kls_sid = sid;                                                      \\\n-    }                                                                     \\\n+  JVMCIENV->create_string(vmSymbols::symbol_at(VM_SYMBOL_ENUM_NAME(s)), JVMCI_CHECK_NULL)\n+#define VM_INTRINSIC_INFO(id, kls, name, sig, ignore_fcode) {            \\\n+    vmSymbolID sid = VM_SYMBOL_ENUM_NAME(kls);                           \\\n+    if (kls_sid != sid) {                                                \\\n+      kls_str = VM_SYMBOL_TO_STRING(kls);                                \\\n+      kls_sid = sid;                                                     \\\n+    }                                                                    \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -345,1 +345,1 @@\n-  static_field(vmSymbols,                   _symbols[0],                                      Symbol*)                               \\\n+  static_field(Symbol,                      _vm_symbols[0],                                   Symbol*)                               \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"oops\/symbol.hpp\"\n@@ -30,1 +31,1 @@\n-#include \"classfile\/vmSymbols.hpp\"\n+#include \"utilities\/vmEnums.hpp\"\n@@ -253,1 +254,1 @@\n-    return vmSymbols::symbol_at((vmSymbols::SID)symbol_index);\n+    return Symbol::vm_symbol_at(static_cast<vmSymbolID>(symbol_index));\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1599,1 +1599,1 @@\n-vmSymbols::SID Method::klass_id_for_intrinsics(const Klass* holder) {\n+vmSymbolID Method::klass_id_for_intrinsics(const Klass* holder) {\n@@ -1606,1 +1606,1 @@\n-    return vmSymbols::NO_SID;   \/\/ regardless of name, no intrinsics here\n+    return vmSymbolID::NO_SID;   \/\/ regardless of name, no intrinsics here\n@@ -1621,2 +1621,2 @@\n-  vmSymbols::SID klass_id = klass_id_for_intrinsics(method_holder());\n-  assert(klass_id != vmSymbols::NO_SID, \"caller responsibility\");\n+  vmSymbolID klass_id = klass_id_for_intrinsics(method_holder());\n+  assert(klass_id != vmSymbolID::NO_SID, \"caller responsibility\");\n@@ -1625,4 +1625,4 @@\n-  vmSymbols::SID  name_id = vmSymbols::find_sid(name());\n-  if (klass_id != vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_MethodHandle)\n-      && klass_id != vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_VarHandle)\n-      && name_id == vmSymbols::NO_SID) {\n+  vmSymbolID name_id = vmSymbols::find_sid(name());\n+  if (klass_id != VM_SYMBOL_ENUM_NAME(java_lang_invoke_MethodHandle)\n+      && klass_id != VM_SYMBOL_ENUM_NAME(java_lang_invoke_VarHandle)\n+      && name_id == vmSymbolID::NO_SID) {\n@@ -1631,4 +1631,4 @@\n-  vmSymbols::SID   sig_id = vmSymbols::find_sid(signature());\n-  if (klass_id != vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_MethodHandle)\n-      && klass_id != vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_VarHandle)\n-      && sig_id == vmSymbols::NO_SID) {\n+  vmSymbolID sig_id = vmSymbols::find_sid(signature());\n+  if (klass_id != VM_SYMBOL_ENUM_NAME(java_lang_invoke_MethodHandle)\n+      && klass_id != VM_SYMBOL_ENUM_NAME(java_lang_invoke_VarHandle)\n+      && sig_id == vmSymbolID::NO_SID) {\n@@ -1651,1 +1651,1 @@\n-  case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_StrictMath):\n+  case VM_SYMBOL_ENUM_NAME(java_lang_StrictMath):\n@@ -1654,3 +1654,3 @@\n-    case vmSymbols::VM_SYMBOL_ENUM_NAME(min_name):\n-    case vmSymbols::VM_SYMBOL_ENUM_NAME(max_name):\n-    case vmSymbols::VM_SYMBOL_ENUM_NAME(sqrt_name):\n+    case VM_SYMBOL_ENUM_NAME(min_name):\n+    case VM_SYMBOL_ENUM_NAME(max_name):\n+    case VM_SYMBOL_ENUM_NAME(sqrt_name):\n@@ -1658,1 +1658,1 @@\n-      klass_id = vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_Math);\n+      klass_id = VM_SYMBOL_ENUM_NAME(java_lang_Math);\n@@ -1667,2 +1667,2 @@\n-  case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_MethodHandle):\n-  case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_VarHandle):\n+  case VM_SYMBOL_ENUM_NAME(java_lang_invoke_MethodHandle):\n+  case VM_SYMBOL_ENUM_NAME(java_lang_invoke_VarHandle):\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"utilities\/vmEnums.hpp\"\n@@ -872,1 +873,1 @@\n-  static vmSymbols::SID klass_id_for_intrinsics(const Klass* holder);\n+  static vmSymbolID klass_id_for_intrinsics(const Klass* holder);\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -43,0 +44,2 @@\n+Symbol* Symbol::_vm_symbols[vmSymbols::number_of_symbols()];\n+\n@@ -420,0 +423,6 @@\n+\n+#ifndef PRODUCT\n+bool Symbol::is_valid_id(vmSymbolID vm_symbol_id) {\n+  return vmSymbols::is_valid_id(vm_symbol_id);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/vmEnums.hpp\"\n@@ -106,0 +107,2 @@\n+  friend class vmSymbols;\n+  friend class JVMCIVMStructs;\n@@ -115,0 +118,2 @@\n+  static Symbol* _vm_symbols[];\n+\n@@ -278,0 +283,7 @@\n+  static bool is_valid_id(vmSymbolID vm_symbol_id) PRODUCT_RETURN_(return true;);\n+\n+  static Symbol* vm_symbol_at(vmSymbolID vm_symbol_id) {\n+    assert(is_valid_id(vm_symbol_id), \"must be\");\n+    return _vm_symbols[static_cast<int>(vm_symbol_id)];\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/symbol.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -462,1 +462,1 @@\n-  vmSymbols::SID name_id = vmSymbols::find_sid(name);\n+  vmSymbolID name_id = vmSymbols::find_sid(name);\n@@ -465,1 +465,1 @@\n-  case vmSymbols::VM_SYMBOL_ENUM_NAME(invoke_name):           return vmIntrinsics::_invokeGeneric;\n+  case VM_SYMBOL_ENUM_NAME(invoke_name):           return vmIntrinsics::_invokeGeneric;\n@@ -467,1 +467,1 @@\n-  case vmSymbols::VM_SYMBOL_ENUM_NAME(invokeBasic_name):      return vmIntrinsics::_invokeBasic;\n+  case VM_SYMBOL_ENUM_NAME(invokeBasic_name):      return vmIntrinsics::_invokeBasic;\n@@ -470,4 +470,4 @@\n-  case vmSymbols::VM_SYMBOL_ENUM_NAME(linkToVirtual_name):    return vmIntrinsics::_linkToVirtual;\n-  case vmSymbols::VM_SYMBOL_ENUM_NAME(linkToStatic_name):     return vmIntrinsics::_linkToStatic;\n-  case vmSymbols::VM_SYMBOL_ENUM_NAME(linkToSpecial_name):    return vmIntrinsics::_linkToSpecial;\n-  case vmSymbols::VM_SYMBOL_ENUM_NAME(linkToInterface_name):  return vmIntrinsics::_linkToInterface;\n+  case VM_SYMBOL_ENUM_NAME(linkToVirtual_name):    return vmIntrinsics::_linkToVirtual;\n+  case VM_SYMBOL_ENUM_NAME(linkToStatic_name):     return vmIntrinsics::_linkToStatic;\n+  case VM_SYMBOL_ENUM_NAME(linkToSpecial_name):    return vmIntrinsics::_linkToSpecial;\n+  case VM_SYMBOL_ENUM_NAME(linkToInterface_name):  return vmIntrinsics::_linkToInterface;\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n-\n-enum JVMFlagsEnum : int;\n+#include \"utilities\/vmEnums.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n-\n-enum JVMFlagsEnum : int;\n+#include \"utilities\/vmEnums.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagAccess.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -469,1 +469,1 @@\n-     static_field(vmSymbols,                   _symbols[0],                                   Symbol*)                               \\\n+     static_field(Symbol,                      _vm_symbols[0],                                Symbol*)                               \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,215 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_ENUMITERATOR_HPP\n+#define SHARE_UTILITIES_ENUMITERATOR_HPP\n+\n+#include <type_traits>\n+#include <limits>\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+\/\/ Iteration support for enums.\n+\/\/\n+\/\/ E is enum type, U is underlying type of E.\n+\/\/\n+\/\/ case 1:\n+\/\/ enum has sequential enumerators, with E first and E last (inclusive).\n+\/\/\n+\/\/ case 2:\n+\/\/ enum has sequential values, with U start and U end (exclusive).\n+\/\/ WeakProcessorPhases is an example because of oopstorage.\n+\/\/ This can be mapped onto case 1 by casting start\/(end-1).\n+\/\/\n+\/\/ case 3:\n+\/\/ enum has non-sequential non-duplicate enumerators\n+\/\/ Iteration could be supported via array or other sequence of enumerators.\n+\/\/ Don't bother.\n+\/\/\n+\/\/ case 4:\n+\/\/ enum has non-sequential enumerators with duplicate values\n+\/\/ Not clear what iteration should mean in this case.\n+\/\/ Don't bother trying to figure this out.\n+\/\/\n+\/\/\n+\/\/ EnumRange -- defines the range of *one specific* iteration loop.\n+\/\/ EnumIterator -- the current point in the iteration loop.\n+\n+\/\/ Example (see vmSymbols.hpp\/cpp)\n+\/\/\n+\/\/ ENUMERATOR_RANGE(vmSymbolID, vmSymbolID::FIRST_SID, vmSymbolID::LAST_SID)\n+\/\/ constexpr EnumRange<vmSymbolID> vmSymbolsRange;\n+\/\/ using vmSymbolsIterator = EnumIterator<vmSymbolID>;\n+\/\/\n+\/\/ \/* Without range-based for, allowed *\/\n+\/\/ for (vmSymbolsIterator it = vmSymbolsRange.begin(); it != vmSymbolsRange.end(); ++it) {\n+\/\/  vmSymbolID index = *it; ....\n+\/\/ }\n+\/\/\n+\/\/ \/* With range-base for, not allowed by HotSpot coding style yet *\/\n+\/\/ for (vmSymbolID index : vmSymbolsRange) {\n+\/\/    ....\n+\/\/ }\n+\n+\/\/ EnumeratorRange is a traits type supporting iteration over the enumerators of T.\n+\/\/ Specializations must provide static const data members named\n+\/\/ \"_first\" and \"_last\", whose values are the smallest \/ largest\n+\/\/ (resp.) enumerator values for T. For iteration, the enumerators of\n+\/\/ T must have sequential values in that range.\n+template<typename T> struct EnumeratorRange;\n+\n+\/\/ Specialize EnumeratorRange<T>.\n+#define ENUMERATOR_RANGE(T, First, Last)        \\\n+  template<> struct EnumeratorRange<T> {        \\\n+    static constexpr T _first = First;          \\\n+    static constexpr T _last = Last;            \\\n+  };\n+\n+\/\/ A helper class for EnumIterator, computing some additional information the\n+\/\/ iterator uses, based on T and EnumeratorRange.\n+template<typename T>\n+class EnumIterationTraits : AllStatic {\n+  using RangeType = EnumeratorRange<T>;\n+\n+public:\n+  \/\/ The underlying type for T.\n+  using Underlying = std::underlying_type_t<T>;\n+\n+  \/\/ The first enumerator of T.\n+  static constexpr T _first = RangeType::_first;\n+\n+  \/\/ The last enumerator of T.\n+  static constexpr T _last = RangeType::_last;\n+\n+  static_assert(static_cast<Underlying>(_last) <\n+                std::numeric_limits<Underlying>::max(),\n+                \"No one-past-the-end value for enum\");\n+\n+  \/\/ The value of the first enumerator of T.\n+  static constexpr Underlying _start = static_cast<Underlying>(_first);\n+\n+  \/\/ The one-past-the-end value for T.\n+  static constexpr Underlying _end = static_cast<Underlying>(_last) + 1;\n+};\n+\n+template<typename T>\n+class EnumIterator {\n+  using Traits = EnumIterationTraits<T>;\n+\n+  using Underlying = typename Traits::Underlying;\n+  Underlying _value;\n+\n+  constexpr void assert_in_bounds() const {\n+    assert(_value < Traits::_end, \"beyond the end\");\n+  }\n+\n+public:\n+  \/\/ Return a beyond-the-end iterator.\n+  constexpr EnumIterator() : _value(Traits::_end) {}\n+\n+  \/\/ Return an iterator with the indicated value.\n+  constexpr explicit EnumIterator(T value) :\n+    _value(static_cast<Underlying>(value))\n+  {\n+    assert(_value >= Traits::_start, \"out of range\");\n+    assert(_value <= Traits::_end, \"out of range\");\n+  }\n+\n+  \/\/ True if the iterators designate the same enumeration value.\n+  constexpr bool operator==(EnumIterator other) const {\n+    return _value == other._value;\n+  }\n+\n+  \/\/ True if the iterators designate different enumeration values.\n+  constexpr bool operator!=(EnumIterator other) const {\n+    return _value != other._value;\n+  }\n+\n+  \/\/ Return the current value.\n+  \/\/ precondition: this is not beyond the last enumerator.\n+  constexpr T operator*() const {\n+    assert_in_bounds();\n+    return static_cast<T>(_value);\n+  }\n+\n+  \/\/ Step this iterator to the next value.\n+  \/\/ precondition: this is not beyond the last enumerator.\n+  constexpr EnumIterator& operator++() {\n+    assert_in_bounds();\n+    ++_value;\n+    return *this;\n+  }\n+\n+  \/\/ Return a copy and step this iterator to the next value.\n+  \/\/ precondition: this is not beyond the last enumerator.\n+  constexpr EnumIterator operator++(int) {\n+    assert_in_bounds();\n+    EnumIterator result = *this;\n+    ++_value;\n+    return result;\n+  }\n+};\n+\n+template<typename T>\n+class EnumRange {\n+  using Traits = EnumIterationTraits<T>;\n+  using Underlying = typename Traits::Underlying;\n+\n+  Underlying _start;\n+  Underlying _end;\n+\n+public:\n+  using Iterator = EnumIterator<T>;\n+\n+  \/\/ Default constructor gives the full range.\n+  constexpr EnumRange() :\n+    EnumRange(Traits::_first) {}\n+\n+  \/\/ Range from start to the (exclusive) end of the enumerator range.\n+  constexpr explicit EnumRange(T start) :\n+    EnumRange(start, static_cast<T>(Traits::_end)) {}\n+\n+  \/\/ Range from start (inclusive) to end (exclusive).\n+  \/\/ precondition: start <= end.\n+  constexpr EnumRange(T start, T end) :\n+    _start(static_cast<Underlying>(start)),\n+    _end(static_cast<Underlying>(end))\n+  {\n+    assert(Traits::_start <= _start, \"out of range\");\n+    assert(_end <= Traits::_end, \"out of range\");\n+    assert(_start <= _end, \"invalid range\");\n+  }\n+\n+  \/\/ Return an iterator for the start of the range.\n+  constexpr Iterator begin() const {\n+    return Iterator(static_cast<T>(_start));\n+  }\n+\n+  \/\/ Return an iterator for the end of the range.\n+  constexpr Iterator end() const {\n+    return Iterator(static_cast<T>(_end));\n+  }\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_ENUMITERATOR_HPP\n","filename":"src\/hotspot\/share\/utilities\/enumIterator.hpp","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_VMENUMS_HPP\n+#define SHARE_UTILITIES_VMENUMS_HPP\n+\n+\/\/ Include this header file if you just need the following enum types and\n+\/\/ you don't use their members directly. This way you don't need to include the\n+\/\/ complex header files that have the full definitions of these enums.\n+\n+enum JVMFlagsEnum : int;\n+enum class vmSymbolID : int;\n+\n+#endif \/\/ SHARE_UTILITIES_VMENUMS_HPP\n","filename":"src\/hotspot\/share\/utilities\/vmEnums.hpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -53,2 +53,3 @@\n-    Type type            = db.lookupType(\"vmSymbols\");\n-    symbolsAddress       = type.getAddressField(\"_symbols[0]\").getStaticFieldAddress();\n+    \/\/ All VM symbols are now stored in: Symbol* Symbol::_vm_symbols[];\n+    Type type            = db.lookupType(\"Symbol\");\n+    symbolsAddress       = type.getAddressField(\"_vm_symbols[0]\").getStaticFieldAddress();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/vmSymbols.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -262,1 +262,1 @@\n-    final long vmSymbolsSymbols = getFieldAddress(\"vmSymbols::_symbols[0]\", \"Symbol*\");\n+    final long symbolVmSymbols = getFieldAddress(\"Symbol::_vm_symbols[0]\", \"Symbol*\");\n@@ -280,1 +280,1 @@\n-        return runtime.getCompilerToVM().getSymbol(UNSAFE.getAddress(vmSymbolsSymbols + offset));\n+        return runtime.getCompilerToVM().getSymbol(UNSAFE.getAddress(symbolVmSymbols + offset));\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}