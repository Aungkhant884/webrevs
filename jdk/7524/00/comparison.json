{"files":[{"patch":"@@ -537,0 +537,56 @@\n+\/*\n+ * Run the event through each HandlerNode's filter, and if it passes, call the HandlerNode's\n+ * HandlerFunction for the event, and then report all accumulated events to the debugger.\n+ *\/\n+static void\n+filterAndHandleEvent(JNIEnv *env, EventInfo *evinfo, EventIndex ei,\n+                     struct bag *eventBag, jbyte eventSessionID)\n+{\n+    debugMonitorEnter(handlerLock);\n+    {\n+        HandlerNode *node;\n+        char        *classname;\n+\n+        \/* We must keep track of all classes prepared to know what's unloaded *\/\n+        if (evinfo->ei == EI_CLASS_PREPARE) {\n+            classTrack_addPreparedClass(env, evinfo->clazz);\n+        }\n+\n+        node = getHandlerChain(ei)->first;\n+        classname = getClassname(evinfo->clazz);\n+\n+        \/* Filter the event over each handler node. *\/\n+        while (node != NULL) {\n+            \/* Save next so handlers can remove themselves. *\/\n+            HandlerNode *next = NEXT(node);\n+            jboolean shouldDelete;\n+\n+            if (eventFilterRestricted_passesFilter(env, classname,\n+                                                   evinfo, node,\n+                                                   &shouldDelete)) {\n+                HandlerFunction func = HANDLER_FUNCTION(node);\n+                if (func == NULL) {\n+                    EXIT_ERROR(AGENT_ERROR_INTERNAL,\"handler function NULL\");\n+                }\n+                \/* Handle the event by calling the event handler. *\/\n+                (*func)(env, evinfo, node, eventBag);\n+            }\n+            if (shouldDelete) {\n+                \/* We can safely free the node now that we are done using it. *\/\n+                (void)freeHandler(node);\n+            }\n+            node = next;\n+        }\n+        jvmtiDeallocate(classname);\n+    }\n+    debugMonitorExit(handlerLock);\n+\n+    \/*\n+     * The events destined for the debugger were accumulated in eventBag. Report all these events.\n+     *\/\n+    if (eventBag != NULL) {\n+        reportEvents(env, eventSessionID, evinfo->thread, evinfo->ei,\n+                     evinfo->clazz, evinfo->method, evinfo->location, eventBag);\n+    }\n+}\n+\n@@ -637,45 +693,1 @@\n-    debugMonitorEnter(handlerLock);\n-    {\n-        HandlerNode *node;\n-        char        *classname;\n-\n-        \/* We must keep track of all classes prepared to know what's unloaded *\/\n-        if (evinfo->ei == EI_CLASS_PREPARE) {\n-            classTrack_addPreparedClass(env, evinfo->clazz);\n-        }\n-\n-        node = getHandlerChain(evinfo->ei)->first;\n-        classname = getClassname(evinfo->clazz);\n-\n-        while (node != NULL) {\n-            \/* save next so handlers can remove themselves *\/\n-            HandlerNode *next = NEXT(node);\n-            jboolean shouldDelete;\n-\n-            if (eventFilterRestricted_passesFilter(env, classname,\n-                                                   evinfo, node,\n-                                                   &shouldDelete)) {\n-                HandlerFunction func;\n-\n-                func = HANDLER_FUNCTION(node);\n-                if ( func == NULL ) {\n-                    EXIT_ERROR(AGENT_ERROR_INTERNAL,\"handler function NULL\");\n-                }\n-                (*func)(env, evinfo, node, eventBag);\n-            }\n-            if (shouldDelete) {\n-                \/* We can safely free the node now that we are done\n-                 * using it.\n-                 *\/\n-                (void)freeHandler(node);\n-            }\n-            node = next;\n-        }\n-        jvmtiDeallocate(classname);\n-    }\n-    debugMonitorExit(handlerLock);\n-\n-    if (eventBag != NULL) {\n-        reportEvents(env, eventSessionID, thread, evinfo->ei,\n-                evinfo->clazz, evinfo->method, evinfo->location, eventBag);\n-    }\n+    filterAndHandleEvent(env, evinfo, ei, eventBag, eventSessionID);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.c","additions":57,"deletions":45,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -466,4 +466,9 @@\n-        if (    (!eventFilter_predictFiltering(step->stepHandlerNode,\n-                                               clazz, classname))\n-             && (   step->granularity != JDWP_STEP_SIZE(LINE)\n-                 || hasLineNumbers(method) ) ) {\n+        \/*\n+         * We need to figure out if we are entering a method that we want to resume\n+         * single stepping in. If the class of this method is being filtered out, then\n+         * we don't resume. Otherwise, if we are not line stepping then we resume, and\n+         * if we are line stepping we don't resume unless the method has LineNumbers.\n+         *\/\n+        jboolean filteredOut = eventFilter_predictFiltering(step->stepHandlerNode, clazz, classname);\n+        jboolean isStepLine = step->granularity == JDWP_STEP_SIZE(LINE);\n+        if (!filteredOut && (!isStepLine || hasLineNumbers(method))) {\n@@ -471,3 +476,2 @@\n-             * We've found a suitable method in which to stop. Step\n-             * until we reach the next safe location to complete the step->,\n-             * and we can get rid of the method entry handler.\n+             * We've found a suitable method in which to resume stepping.\n+             * We can also get rid of the method entry handler now.\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/stepControl.c","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-    unsigned int isStarted : 1;        \/* THREAD_START or VIRTUAL_THREAD_SCHEDULED event received. *\/\n+    unsigned int isStarted : 1;        \/* THREAD_START event received. *\/\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}