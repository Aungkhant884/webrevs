{"files":[{"patch":"@@ -243,1 +243,1 @@\n-     * @since 16\n+     * @since 17\n","filename":"src\/java.xml.crypto\/share\/classes\/javax\/xml\/crypto\/dsig\/SignatureMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n- * @since 16\n+ * @since 17\n","filename":"src\/java.xml.crypto\/share\/classes\/javax\/xml\/crypto\/dsig\/spec\/RSAPSSParameterSpec.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -143,2 +143,1 @@\n-        Element digestMethodElement = DOMUtils.createElement(rsaPssParamsElement.getOwnerDocument(), Constants._TAG_DIGESTMETHOD,\n-                                                             XMLSignature.XMLNS, prefix);\n+        DigestAlgorithm digestAlgorithm;\n@@ -146,1 +145,14 @@\n-            digestMethodElement.setAttributeNS(null, Constants._ATT_ALGORITHM, DigestAlgorithm.fromDigestAlgorithm(spec.getDigestAlgorithm()).getXmlDigestAlgorithm());\n+            digestAlgorithm = DigestAlgorithm.fromDigestAlgorithm(spec.getDigestAlgorithm());\n+            String xmlDigestAlgorithm = digestAlgorithm.getXmlDigestAlgorithm();\n+            if (!xmlDigestAlgorithm.equals(DigestMethod.SHA256)) {\n+                Element digestMethodElement = DOMUtils.createElement(rsaPssParamsElement.getOwnerDocument(), Constants._TAG_DIGESTMETHOD,\n+                        XMLSignature.XMLNS, prefix);\n+                digestMethodElement.setAttributeNS(null, Constants._ATT_ALGORITHM, xmlDigestAlgorithm);\n+                rsaPssParamsElement.appendChild(digestMethodElement);\n+            }\n+            if (spec.getSaltLength() != digestAlgorithm.getSaltLength()) {\n+                Element saltLengthElement = rsaPssParamsElement.getOwnerDocument().createElementNS(Constants.XML_DSIG_NS_MORE_07_05, \"pss\" + \":\" + Constants._TAG_SALTLENGTH);\n+                Text saltLengthText = rsaPssParamsElement.getOwnerDocument().createTextNode(String.valueOf(spec.getSaltLength()));\n+                saltLengthElement.appendChild(saltLengthText);\n+                rsaPssParamsElement.appendChild(saltLengthElement);\n+            }\n@@ -150,7 +162,0 @@\n-        rsaPssParamsElement.appendChild(digestMethodElement);\n-\n-        Element saltLengthElement = rsaPssParamsElement.getOwnerDocument().createElementNS(Constants.XML_DSIG_NS_MORE_07_05, \"pss\" + \":\" + Constants._TAG_SALTLENGTH);\n-        Text saltLengthText = rsaPssParamsElement.getOwnerDocument().createTextNode(String.valueOf(spec.getSaltLength()));\n-        saltLengthElement.appendChild(saltLengthText);\n-\n-        rsaPssParamsElement.appendChild(saltLengthElement);\n@@ -163,8 +168,0 @@\n-        Element mgfElement = rsaPssParamsElement.getOwnerDocument().createElementNS(Constants.XML_DSIG_NS_MORE_07_05, \"pss\" + \":\" + Constants._TAG_MGF);\n-        try {\n-            mgfElement.setAttributeNS(null, Constants._ATT_ALGORITHM, \"http:\/\/www.w3.org\/2007\/05\/xmldsig-more#MGF1\");\n-        } catch (DOMException e) {\n-            throw new MarshalException(\"Should not happen\");\n-        }\n-        Element mgfDigestMethodElement = DOMUtils.createElement(rsaPssParamsElement.getOwnerDocument(), Constants._TAG_DIGESTMETHOD,\n-                XMLSignature.XMLNS, prefix);\n@@ -172,1 +169,15 @@\n-            mgfDigestMethodElement.setAttributeNS(null, Constants._ATT_ALGORITHM, DigestAlgorithm.fromDigestAlgorithm(mgfSpec.getDigestAlgorithm()).getXmlDigestAlgorithm());\n+            DigestAlgorithm mgfDigestAlgorithm = DigestAlgorithm.fromDigestAlgorithm(mgfSpec.getDigestAlgorithm());\n+            if (mgfDigestAlgorithm != digestAlgorithm) {\n+                Element mgfElement = rsaPssParamsElement.getOwnerDocument().createElementNS(Constants.XML_DSIG_NS_MORE_07_05, \"pss\" + \":\" + Constants._TAG_MGF);\n+                try {\n+                    mgfElement.setAttributeNS(null, Constants._ATT_ALGORITHM, \"http:\/\/www.w3.org\/2007\/05\/xmldsig-more#MGF1\");\n+                } catch (DOMException e) {\n+                    throw new MarshalException(\"Should not happen\");\n+                }\n+                Element mgfDigestMethodElement = DOMUtils.createElement(rsaPssParamsElement.getOwnerDocument(), Constants._TAG_DIGESTMETHOD,\n+                        XMLSignature.XMLNS, prefix);\n+                String xmlDigestAlgorithm = mgfDigestAlgorithm.getXmlDigestAlgorithm();\n+                mgfDigestMethodElement.setAttributeNS(null, Constants._ATT_ALGORITHM, xmlDigestAlgorithm);\n+                mgfElement.appendChild(mgfDigestMethodElement);\n+                rsaPssParamsElement.appendChild(mgfElement);\n+            }\n@@ -176,7 +187,0 @@\n-        mgfElement.appendChild(mgfDigestMethodElement);\n-\n-        rsaPssParamsElement.appendChild(mgfElement);\n-\n-        Element trailerFieldElement = rsaPssParamsElement.getOwnerDocument().createElementNS(Constants.XML_DSIG_NS_MORE_07_05, \"pss\" + \":\" + Constants._TAG_TRAILERFIELD);\n-        Text trailerFieldText = rsaPssParamsElement.getOwnerDocument().createTextNode(String.valueOf(spec.getTrailerField()));\n-        trailerFieldElement.appendChild(trailerFieldText);\n@@ -184,1 +188,6 @@\n-        rsaPssParamsElement.appendChild(trailerFieldElement);\n+        if (spec.getTrailerField() != 1) {\n+            Element trailerFieldElement = rsaPssParamsElement.getOwnerDocument().createElementNS(Constants.XML_DSIG_NS_MORE_07_05, \"pss\" + \":\" + Constants._TAG_TRAILERFIELD);\n+            Text trailerFieldText = rsaPssParamsElement.getOwnerDocument().createTextNode(String.valueOf(spec.getTrailerField()));\n+            trailerFieldElement.appendChild(trailerFieldText);\n+            rsaPssParamsElement.appendChild(trailerFieldElement);\n+        }\n@@ -186,1 +195,3 @@\n-        parent.appendChild(rsaPssParamsElement);\n+        if (rsaPssParamsElement.hasChildNodes()) {\n+            parent.appendChild(rsaPssParamsElement);\n+        }\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMRSAPSSSignatureMethod.java","additions":39,"deletions":28,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import javax.xml.crypto.dsig.spec.RSAPSSParameterSpec;\n@@ -38,0 +39,3 @@\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.MGF1ParameterSpec;\n+import java.security.spec.PSSParameterSpec;\n@@ -40,0 +44,1 @@\n+import com.sun.org.apache.xml.internal.security.algorithms.implementations.SignatureBaseRSA;\n@@ -155,0 +160,27 @@\n+        if (secVal && signatureMethod instanceof DOMRSAPSSSignatureMethod.RSAPSS) {\n+            AlgorithmParameterSpec spec = signatureMethod.getParameterSpec();\n+            if (spec instanceof RSAPSSParameterSpec) {\n+                try {\n+                    PSSParameterSpec pspec = ((RSAPSSParameterSpec) spec).getPSSParameterSpec();\n+                    String da = SignatureBaseRSA.SignatureRSASSAPSS.DigestAlgorithm\n+                            .fromDigestAlgorithm(pspec.getDigestAlgorithm()).getXmlDigestAlgorithm();\n+                    if (Policy.restrictAlg(da)) {\n+                        throw new MarshalException(\n+                                \"It is forbidden to use algorithm \" + da + \" in PSS when secure validation is enabled\"\n+                        );\n+                    }\n+                    AlgorithmParameterSpec mspec = pspec.getMGFParameters();\n+                    if (mspec instanceof MGF1ParameterSpec) {\n+                        String da2 = SignatureBaseRSA.SignatureRSASSAPSS.DigestAlgorithm\n+                                .fromDigestAlgorithm(((MGF1ParameterSpec) mspec).getDigestAlgorithm()).getXmlDigestAlgorithm();\n+                        if (Policy.restrictAlg(da2)) {\n+                            throw new MarshalException(\n+                                    \"It is forbidden to use algorithm \" + da2 + \" in MGF1 when secure validation is enabled\"\n+                            );\n+                        }\n+                    }\n+                } catch (com.sun.org.apache.xml.internal.security.signature.XMLSignatureException e) {\n+                    \/\/ Unknown digest algorithm. Ignored.\n+                }\n+            }\n+        }\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMSignedInfo.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n@@ -232,2 +230,2 @@\n-\/\/            DigestMethod.SHA1,\n-\/\/            DigestMethod.SHA256,\n+            DigestMethod.SHA1,\n+            DigestMethod.SHA256,\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/GenerationTests.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8241306\n+ * @summary Tests for the jdk.xml.dsig.secureValidationPolicy security property\n+ *          on the RSASSA-PSS signature method\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.tools.keytool\n+ *          java.base\/sun.security.x509\n+ *\/\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.security.XMLUtils;\n+import jdk.test.lib.Utils;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import sun.security.tools.keytool.CertAndKeyGen;\n+import sun.security.x509.X500Name;\n+\n+import javax.xml.crypto.MarshalException;\n+import javax.xml.crypto.dsig.DigestMethod;\n+import javax.xml.crypto.dsig.SignatureMethod;\n+import javax.xml.crypto.dsig.spec.RSAPSSParameterSpec;\n+import javax.xml.namespace.NamespaceContext;\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathFactory;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.security.spec.MGF1ParameterSpec;\n+import java.security.spec.PSSParameterSpec;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+import static java.security.spec.PSSParameterSpec.TRAILER_FIELD_BC;\n+\n+public class SecureValidation {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        Document doc = XMLUtils.string2doc(\"<a><b>Text<\/b>Raw<\/a>\");\n+\n+        CertAndKeyGen g = new CertAndKeyGen(\"RSASSA-PSS\", \"RSASSA-PSS\");\n+        g.generate(2048);\n+        X509Certificate cert = g.getSelfCertificate(new X500Name(\"CN=Me\"), 100);\n+        PrivateKey privateKey = g.getPrivateKey();\n+        PSSParameterSpec pspec = new PSSParameterSpec(\"SHA-384\", \"MGF1\",\n+                MGF1ParameterSpec.SHA512, 48, TRAILER_FIELD_BC);\n+\n+        \/\/ Sign with PSS with SHA-384 and SHA-512\n+        Document signed = XMLUtils.signer(privateKey, cert)\n+                .use(DigestMethod.SHA384)\n+                .use(SignatureMethod.RSA_PSS, new RSAPSSParameterSpec(pspec))\n+                .sign(doc);\n+\n+        XPath xp = XPathFactory.newInstance().newXPath();\n+        xp.setNamespaceContext(new NamespaceContext() {\n+            @Override\n+            public String getNamespaceURI(String prefix) {\n+                return switch (prefix) {\n+                    case \"ds\" -> \"http:\/\/www.w3.org\/2000\/09\/xmldsig#\";\n+                    case \"pss\" -> \"http:\/\/www.w3.org\/2007\/05\/xmldsig-more#\";\n+                    default -> throw new IllegalArgumentException();\n+                };\n+            }\n+\n+            @Override\n+            public String getPrefix(String namespaceURI) {\n+                return null;\n+            }\n+\n+            @Override\n+            public Iterator<String> getPrefixes(String namespaceURI) {\n+                return null;\n+            }\n+        });\n+\n+        var validator = XMLUtils.validator();\n+        XMLUtils.addPolicy(\"disallowAlg \" + DigestMethod.SHA256);\n+\n+        \/\/ Modify the MGF1 digest algorithm in PSSParams to SHA-256\n+        \/\/ and confirm it will be rejected\n+        Element e;\n+        e = (Element) xp.evaluate(\n+                \"\/a\/ds:Signature\/ds:SignedInfo\/ds:SignatureMethod\" +\n+                        \"\/pss:RSAPSSParams\/pss:MaskGenerationFunction\/ds:DigestMethod\",\n+                signed, XPathConstants.NODE);\n+        e.setAttribute(\"Algorithm\", DigestMethod.SHA256);\n+\n+        \/\/ When secureValidation is true, validate throws an exception\n+        Utils.runAndCheckException(() -> validator.secureValidation(true).validate(signed),\n+                t -> Asserts.assertTrue(t instanceof MarshalException\n+                    && t.getMessage().contains(\"in MGF1\")\n+                    && t.getMessage().contains(DigestMethod.SHA256), Objects.toString(t)));\n+        \/\/ When secureValidation is false, verify returns false\n+        Asserts.assertFalse(validator.secureValidation(false).validate(signed));\n+\n+        \/\/ Revert the change and confirm validate returns true\n+        e.setAttribute(\"Algorithm\", DigestMethod.SHA512);\n+        Asserts.assertTrue(validator.secureValidation(true).validate(signed));\n+\n+        \/\/ Modify the digest algorithm in PSSParams to SHA-256\n+        \/\/ and confirm it will be rejected\n+        e = (Element) xp.evaluate(\"\/a\/ds:Signature\/ds:SignedInfo\" +\n+                        \"\/ds:SignatureMethod\/pss:RSAPSSParams\/ds:DigestMethod\",\n+                signed, XPathConstants.NODE);\n+        e.setAttribute(\"Algorithm\", DigestMethod.SHA256);\n+\n+        \/\/ When secureValidation is true, validate throws an exception\n+        Utils.runAndCheckException(() -> validator.secureValidation(true).validate(signed),\n+                t -> Asserts.assertTrue(t instanceof MarshalException\n+                        && t.getMessage().contains(\"in PSS\")\n+                        && t.getMessage().contains(DigestMethod.SHA256), Objects.toString(t)));\n+        \/\/ When secureValidation is false, verify returns false\n+        Asserts.assertFalse(validator.secureValidation(false).validate(signed));\n+\n+        \/\/ Revert the change and confirm validate returns true\n+        e.setAttribute(\"Algorithm\", DigestMethod.SHA384);\n+        Asserts.assertTrue(validator.secureValidation(true).validate(signed));\n+    }\n+}\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/SecureValidation.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,254 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.security;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.InputSource;\n+\n+import javax.xml.crypto.*;\n+import javax.xml.crypto.dsig.*;\n+import javax.xml.crypto.dsig.dom.DOMSignContext;\n+import javax.xml.crypto.dsig.dom.DOMValidateContext;\n+import javax.xml.crypto.dsig.keyinfo.KeyInfo;\n+import javax.xml.crypto.dsig.keyinfo.KeyInfoFactory;\n+import javax.xml.crypto.dsig.keyinfo.KeyValue;\n+import javax.xml.crypto.dsig.keyinfo.X509Data;\n+import javax.xml.crypto.dsig.spec.*;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMResult;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.lang.reflect.Modifier;\n+import java.security.*;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.RSAKey;\n+import java.security.spec.PSSParameterSpec;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class XMLUtils {\n+\n+    private static final XMLSignatureFactory FAC =\n+            XMLSignatureFactory.getInstance(\"DOM\");\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/ CONVERSION \/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    public static String doc2string(Document doc) throws Exception {\n+        TransformerFactory tf = TransformerFactory.newInstance();\n+        Transformer transformer = tf.newTransformer();\n+        transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"no\");\n+        transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n+        StringWriter writer = new StringWriter();\n+        transformer.transform(new DOMSource(doc), new StreamResult(writer));\n+        return writer.getBuffer().toString();\n+    }\n+\n+    public static Document string2doc(String input) throws Exception {\n+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n+        factory.setNamespaceAware(true);\n+        return factory.newDocumentBuilder().\n+                parse(new InputSource(new StringReader(input)));\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/ SIGN \/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    public static Signer signer(PrivateKey privateKey, X509Certificate cert)\n+            throws Exception {\n+        Signer s = new Signer(privateKey, cert).use(DigestMethod.SHA256);\n+        String alg = privateKey.getAlgorithm();\n+        if (alg.equals(\"RSASSA-PSS\")) {\n+            PSSParameterSpec pspec\n+                    = (PSSParameterSpec) ((RSAKey) privateKey).getParams();\n+            if (pspec != null) {\n+                s.use(SignatureMethod.RSA_PSS, new RSAPSSParameterSpec(pspec));\n+            } else {\n+                s.use(SignatureMethod.RSA_PSS);\n+            }\n+        } else {\n+            s.use(switch (privateKey.getAlgorithm()) {\n+                case \"RSA\" -> SignatureMethod.RSA_SHA256;\n+                case \"DSA\" -> SignatureMethod.DSA_SHA256;\n+                case \"EC\" -> SignatureMethod.ECDSA_SHA256;\n+                default -> throw new InvalidKeyException();\n+            });\n+        }\n+        return s;\n+    }\n+\n+    public static class Signer {\n+\n+        PrivateKey privateKey;\n+        X509Certificate cert;\n+        SignatureMethod sm;\n+        DigestMethod dm;\n+\n+        public Signer(PrivateKey privateKey, X509Certificate cert) {\n+            this.privateKey = privateKey;\n+            this.cert = cert;\n+        }\n+\n+        public Signer use(String method) throws Exception {\n+            try {\n+                sm = FAC.newSignatureMethod(method, null);\n+            } catch (NoSuchAlgorithmException e) {\n+                dm = FAC.newDigestMethod(method, null);\n+            }\n+            return this;\n+        }\n+\n+        public Signer use(String method, SignatureMethodParameterSpec spec)\n+                throws Exception {\n+            sm = FAC.newSignatureMethod(method, spec);\n+            return this;\n+        }\n+\n+        public Signer use(String method, DigestMethodParameterSpec spec)\n+                throws Exception {\n+            dm = FAC.newDigestMethod(method, spec);\n+            return this;\n+        }\n+\n+        public Document sign(Document document) throws Exception {\n+            DOMResult result = new DOMResult();\n+            TransformerFactory.newInstance().newTransformer()\n+                    .transform(new DOMSource(document), result);\n+            Document newDocument = (Document) result.getNode();\n+            FAC.newXMLSignature(buildSignedInfo(), buildKeyInfo()).sign(\n+                    new DOMSignContext(privateKey, newDocument.getDocumentElement()));\n+            return newDocument;\n+        }\n+\n+        private SignedInfo buildSignedInfo() throws NoSuchAlgorithmException,\n+                InvalidAlgorithmParameterException {\n+            return FAC.newSignedInfo(\n+                    FAC.newCanonicalizationMethod(\n+                            CanonicalizationMethod.EXCLUSIVE,\n+                            (C14NMethodParameterSpec) null),\n+                    sm,\n+                    List.of(FAC.newReference(\n+                            \"\",\n+                            dm,\n+                            List.of(FAC.newTransform(Transform.ENVELOPED,\n+                                    (TransformParameterSpec) null)),\n+                            null, null)));\n+        }\n+\n+        private KeyInfo buildKeyInfo() throws Exception {\n+            KeyInfoFactory keyInfoFactory = FAC.getKeyInfoFactory();\n+            X509Data x509Data = keyInfoFactory.newX509Data(List.of(cert));\n+            return keyInfoFactory.newKeyInfo(Collections.singletonList(x509Data));\n+        }\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/ VALIDATE \/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    public static Validator validator()\n+            throws Exception {\n+        return new Validator();\n+    }\n+\n+    public static class Validator {\n+\n+        private Boolean secureValidation = null;\n+\n+        public Validator secureValidation(boolean v) {\n+            this.secureValidation = v;\n+            return this;\n+        }\n+\n+        public boolean validate(Document document)\n+                throws Exception {\n+            NodeList nodeList = document.getElementsByTagName(\"Signature\");\n+            if (nodeList.getLength() == 1) {\n+                Node signatureNode = nodeList.item(0);\n+                if (signatureNode != null) {\n+                    DOMValidateContext valContext\n+                            = new DOMValidateContext(KVKS, signatureNode);\n+                    if (secureValidation != null) {\n+                        valContext.setProperty(\"org.jcp.xml.dsig.secureValidation\",\n+                                secureValidation.booleanValue());\n+                    }\n+                    return XMLSignatureFactory.getInstance(\"DOM\")\n+                            .unmarshalXMLSignature(valContext).validate(valContext);\n+                }\n+            }\n+            return false;\n+        }\n+\n+        private static KeySelector KVKS = new KeySelector() {\n+            public KeySelectorResult select(KeyInfo keyInfo,\n+                                            KeySelector.Purpose purpose,\n+                                            AlgorithmMethod method,\n+                                            XMLCryptoContext context)\n+                    throws KeySelectorException {\n+                Objects.requireNonNull(keyInfo, \"Null KeyInfo object!\");\n+\n+                for (XMLStructure xmlStructure : keyInfo.getContent()) {\n+                    PublicKey pk;\n+                    if (xmlStructure instanceof KeyValue) {\n+                        try {\n+                            pk = ((KeyValue) xmlStructure).getPublicKey();\n+                        } catch (KeyException ke) {\n+                            throw new KeySelectorException(ke);\n+                        }\n+                        return () -> pk;\n+                    } else if (xmlStructure instanceof X509Data) {\n+                        for (Object data : ((X509Data) xmlStructure).getContent()) {\n+                            if (data instanceof X509Certificate) {\n+                                pk = ((X509Certificate) data).getPublicKey();\n+                                return () -> pk;\n+                            }\n+                        }\n+                    }\n+                }\n+                throw new KeySelectorException(\"No KeyValue element found!\");\n+            }\n+        };\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/ MISC \/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    \/**\n+     * Adds a new rule to \"jdk.xml.dsig.secureValidationPolicy\"\n+     *\/\n+    public static void addPolicy(String rule) {\n+        String value = Security.getProperty(\"jdk.xml.dsig.secureValidationPolicy\");\n+        value = rule + \",\" + value;\n+        Security.setProperty(\"jdk.xml.dsig.secureValidationPolicy\", value);\n+    }\n+\n+    private XMLUtils() {\n+        assert false : \"No one instantiates me\";\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/security\/XMLUtils.java","additions":254,"deletions":0,"binary":false,"changes":254,"status":"added"}]}