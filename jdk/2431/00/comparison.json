{"files":[{"patch":"@@ -101,10 +101,0 @@\n-void Dependencies::assert_abstract_with_no_concrete_subtype(ciKlass* ctxk) {\n-  check_ctxk_abstract(ctxk);\n-  assert_common_1(abstract_with_no_concrete_subtype, ctxk);\n-}\n-\n-void Dependencies::assert_concrete_with_no_concrete_subtype(ciKlass* ctxk) {\n-  check_ctxk_concrete(ctxk);\n-  assert_common_1(concrete_with_no_concrete_subtype, ctxk);\n-}\n-\n@@ -117,10 +107,0 @@\n-void Dependencies::assert_abstract_with_exclusive_concrete_subtypes(ciKlass* ctxk, ciKlass* k1, ciKlass* k2) {\n-  check_ctxk(ctxk);\n-  assert_common_3(abstract_with_exclusive_concrete_subtypes_2, ctxk, k1, k2);\n-}\n-\n-void Dependencies::assert_exclusive_concrete_methods(ciKlass* ctxk, ciMethod* m1, ciMethod* m2) {\n-  check_ctxk(ctxk);\n-  assert_common_3(exclusive_concrete_methods_2, ctxk, m1, m2);\n-}\n-\n@@ -268,41 +248,0 @@\n-void Dependencies::assert_common_3(DepType dept,\n-                                   ciKlass* ctxk, ciBaseObject* x, ciBaseObject* x2) {\n-  assert(dep_context_arg(dept) == 0, \"sanity\");\n-  assert(dep_args(dept) == 3, \"sanity\");\n-  log_dependency(dept, ctxk, x, x2);\n-  GrowableArray<ciBaseObject*>* deps = _deps[dept];\n-\n-  \/\/ try to normalize an unordered pair:\n-  bool swap = false;\n-  switch (dept) {\n-  case abstract_with_exclusive_concrete_subtypes_2:\n-    swap = (x->ident() > x2->ident() && x->as_metadata()->as_klass() != ctxk);\n-    break;\n-  case exclusive_concrete_methods_2:\n-    swap = (x->ident() > x2->ident() && x->as_metadata()->as_method()->holder() != ctxk);\n-    break;\n-  default:\n-    break;\n-  }\n-  if (swap) { ciBaseObject* t = x; x = x2; x2 = t; }\n-\n-  \/\/ see if the same (or a similar) dep is already recorded\n-  if (note_dep_seen(dept, x) && note_dep_seen(dept, x2)) {\n-    \/\/ look in this bucket for redundant assertions\n-    const int stride = 3;\n-    for (int i = deps->length(); (i -= stride) >= 0; ) {\n-      ciBaseObject* y  = deps->at(i+1);\n-      ciBaseObject* y2 = deps->at(i+2);\n-      if (x == y && x2 == y2) {  \/\/ same subjects; check the context\n-        if (maybe_merge_ctxk(deps, i+0, ctxk)) {\n-          return;\n-        }\n-      }\n-    }\n-  }\n-  \/\/ append the assertion in the correct bucket:\n-  deps->append(ctxk);\n-  deps->append(x);\n-  deps->append(x2);\n-}\n-\n@@ -475,2 +414,0 @@\n-  case abstract_with_exclusive_concrete_subtypes_2:\n-    return x->as_metadata()->as_klass();\n@@ -478,1 +415,0 @@\n-  case exclusive_concrete_methods_2:\n@@ -488,3 +424,0 @@\n-  case abstract_with_exclusive_concrete_subtypes_2:\n-    assert(x->is_klass(), \"sanity\");\n-    return (Klass*) x;\n@@ -492,1 +425,0 @@\n-  case exclusive_concrete_methods_2:\n@@ -595,2 +527,0 @@\n-  \"abstract_with_no_concrete_subtype\",\n-  \"concrete_with_no_concrete_subtype\",\n@@ -598,2 +528,0 @@\n-  \"abstract_with_exclusive_concrete_subtypes_2\",\n-  \"exclusive_concrete_methods_2\",\n@@ -609,2 +537,0 @@\n-  1, \/\/ abstract_with_no_concrete_subtype ctxk\n-  1, \/\/ concrete_with_no_concrete_subtype ctxk\n@@ -612,2 +538,0 @@\n-  3, \/\/ unique_concrete_subtypes_2 ctxk, k1, k2\n-  3, \/\/ unique_concrete_methods_2 ctxk, m1, m2\n@@ -1349,2 +1273,2 @@\n-                                               Klass* context_type,\n-                                               bool participants_hide_witnesses) {\n+                                             Klass* context_type,\n+                                             bool participants_hide_witnesses) {\n@@ -1400,2 +1324,2 @@\n-                                                     bool participants_hide_witnesses,\n-                                                     bool top_level_call) {\n+                                                   bool participants_hide_witnesses,\n+                                                   bool top_level_call) {\n@@ -1500,2 +1424,2 @@\n-                                                 participants_hide_witnesses,\n-                                                 \/*top_level_call=*\/ false);\n+                                               participants_hide_witnesses,\n+                                               \/*top_level_call=*\/ false);\n@@ -1608,2 +1532,2 @@\n-                                                                   Klass* conck,\n-                                                                   KlassDepChange* changes) {\n+                                                                 Klass* conck,\n+                                                                 KlassDepChange* changes) {\n@@ -1614,20 +1538,0 @@\n-\/\/ If a non-concrete class has no concrete subtypes, it is not (yet)\n-\/\/ instantiatable.  This can allow the compiler to make some paths go\n-\/\/ dead, if they are gated by a test of the type.\n-Klass* Dependencies::check_abstract_with_no_concrete_subtype(Klass* ctxk,\n-                                                               KlassDepChange* changes) {\n-  \/\/ Find any concrete subtype, with no participants:\n-  ClassHierarchyWalker wf;\n-  return wf.find_witness_subtype(ctxk, changes);\n-}\n-\n-\n-\/\/ If a concrete class has no concrete subtypes, it can always be\n-\/\/ exactly typed.  This allows the use of a cheaper type test.\n-Klass* Dependencies::check_concrete_with_no_concrete_subtype(Klass* ctxk,\n-                                                               KlassDepChange* changes) {\n-  \/\/ Find any concrete subtype, with only the ctxk as participant:\n-  ClassHierarchyWalker wf(ctxk);\n-  return wf.find_witness_subtype(ctxk, changes);\n-}\n-\n@@ -1647,16 +1551,0 @@\n-#ifndef PRODUCT\n-    \/\/ Make sure the dependency mechanism will pass this discovery:\n-    if (VerifyDependencies) {\n-      \/\/ Turn off dependency tracing while actually testing deps.\n-      FlagSetting fs(TraceDependencies, false);\n-      if (!Dependencies::is_concrete_klass(ctxk)) {\n-        guarantee(NULL ==\n-                  (void *)check_abstract_with_no_concrete_subtype(ctxk),\n-                  \"verify dep.\");\n-      } else {\n-        guarantee(NULL ==\n-                  (void *)check_concrete_with_no_concrete_subtype(ctxk),\n-                  \"verify dep.\");\n-      }\n-    }\n-#endif \/\/PRODUCT\n@@ -1681,65 +1569,0 @@\n-\/\/ Test the assertion that the k[12] are the only concrete subtypes of ctxk,\n-\/\/ except possibly for further subtypes of k[12] themselves.\n-\/\/ The context type must be abstract.  The types k1 and k2 are themselves\n-\/\/ allowed to have further concrete subtypes.\n-Klass* Dependencies::check_abstract_with_exclusive_concrete_subtypes(\n-                                                Klass* ctxk,\n-                                                Klass* k1,\n-                                                Klass* k2,\n-                                                KlassDepChange* changes) {\n-  ClassHierarchyWalker wf;\n-  wf.add_participant(k1);\n-  wf.add_participant(k2);\n-  return wf.find_witness_subtype(ctxk, changes);\n-}\n-\n-\/\/ Search ctxk for concrete implementations.  If there are klen or fewer,\n-\/\/ pack them into the given array and return the number.\n-\/\/ Otherwise, return -1, meaning the given array would overflow.\n-\/\/ (Note that a return of 0 means there are exactly no concrete subtypes.)\n-\/\/ In this search, if ctxk is concrete, it will be reported alone.\n-\/\/ For any type CC reported, no proper subtypes of CC will be reported.\n-int Dependencies::find_exclusive_concrete_subtypes(Klass* ctxk,\n-                                                   int klen,\n-                                                   Klass* karray[]) {\n-  ClassHierarchyWalker wf;\n-  wf.record_witnesses(klen);\n-  Klass* wit = wf.find_witness_subtype(ctxk);\n-  if (wit != NULL)  return -1;  \/\/ Too many witnesses.\n-  int num = wf.num_participants();\n-  assert(num <= klen, \"oob\");\n-  \/\/ Pack the result array with the good news.\n-  for (int i = 0; i < num; i++)\n-    karray[i] = wf.participant(i);\n-#ifndef PRODUCT\n-  \/\/ Make sure the dependency mechanism will pass this discovery:\n-  if (VerifyDependencies) {\n-    \/\/ Turn off dependency tracing while actually testing deps.\n-    FlagSetting fs(TraceDependencies, false);\n-    switch (Dependencies::is_concrete_klass(ctxk)? -1: num) {\n-    case -1: \/\/ ctxk was itself concrete\n-      guarantee(num == 1 && karray[0] == ctxk, \"verify dep.\");\n-      break;\n-    case 0:\n-      guarantee(NULL == (void *)check_abstract_with_no_concrete_subtype(ctxk),\n-                \"verify dep.\");\n-      break;\n-    case 1:\n-      guarantee(NULL == (void *)\n-                check_abstract_with_unique_concrete_subtype(ctxk, karray[0]),\n-                \"verify dep.\");\n-      break;\n-    case 2:\n-      guarantee(NULL == (void *)\n-                check_abstract_with_exclusive_concrete_subtypes(ctxk,\n-                                                                karray[0],\n-                                                                karray[1]),\n-                \"verify dep.\");\n-      break;\n-    default:\n-      ShouldNotReachHere();  \/\/ klen > 2 yet supported\n-    }\n-  }\n-#endif \/\/PRODUCT\n-  return num;\n-}\n@@ -1749,2 +1572,3 @@\n-Klass* Dependencies::check_unique_concrete_method(Klass* ctxk, Method* uniqm,\n-                                                    KlassDepChange* changes) {\n+Klass* Dependencies::check_unique_concrete_method(Klass*  ctxk,\n+                                                  Method* uniqm,\n+                                                  KlassDepChange* changes) {\n@@ -1794,10 +1618,0 @@\n-Klass* Dependencies::check_exclusive_concrete_methods(Klass* ctxk,\n-                                                        Method* m1,\n-                                                        Method* m2,\n-                                                        KlassDepChange* changes) {\n-  ClassHierarchyWalker wf(m1);\n-  wf.add_participant(m1->method_holder());\n-  wf.add_participant(m2->method_holder());\n-  return wf.find_witness_definer(ctxk, changes);\n-}\n-\n@@ -1856,6 +1670,0 @@\n-  case abstract_with_no_concrete_subtype:\n-    witness = check_abstract_with_no_concrete_subtype(context_type(), changes);\n-    break;\n-  case concrete_with_no_concrete_subtype:\n-    witness = check_concrete_with_no_concrete_subtype(context_type(), changes);\n-    break;\n@@ -1865,6 +1673,0 @@\n-  case abstract_with_exclusive_concrete_subtypes_2:\n-    witness = check_abstract_with_exclusive_concrete_subtypes(context_type(), type_argument(1), type_argument(2), changes);\n-    break;\n-  case exclusive_concrete_methods_2:\n-    witness = check_exclusive_concrete_methods(context_type(), method_argument(1), method_argument(2), changes);\n-    break;\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":11,"deletions":209,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -118,6 +118,0 @@\n-    \/\/ The type CX is purely abstract, with no concrete subtype* at all.\n-    abstract_with_no_concrete_subtype,\n-\n-    \/\/ The concrete CX is free of concrete proper subtypes.\n-    concrete_with_no_concrete_subtype,\n-\n@@ -142,17 +136,0 @@\n-    \/\/ An \"exclusive\" assertion concerns two methods or subtypes, and\n-    \/\/ declares that there are at most two (or perhaps later N>2)\n-    \/\/ specific items that jointly satisfy the restriction.\n-    \/\/ We list all items explicitly rather than just giving their\n-    \/\/ count, for robustness in the face of complex schema changes.\n-\n-    \/\/ A context class CX (which may be either abstract or concrete)\n-    \/\/ has two exclusive concrete subtypes* C1, C2 if every concrete\n-    \/\/ subtype* of CX is either C1 or C2.  Note that if neither C1 or C2\n-    \/\/ are equal to CX, then CX itself must be abstract.  But it is\n-    \/\/ also possible (for example) that C1 is CX (a concrete class)\n-    \/\/ and C2 is a proper subtype of C1.\n-    abstract_with_exclusive_concrete_subtypes_2,\n-\n-    \/\/ This dependency asserts that MM(CX, M1) is no greater than {M1,M2}.\n-    exclusive_concrete_methods_2,\n-\n@@ -350,1 +327,0 @@\n-  void assert_common_3(DepType dept, ciKlass* ctxk, ciBaseObject* x1, ciBaseObject* x2);\n@@ -357,2 +333,0 @@\n-  void assert_abstract_with_no_concrete_subtype(ciKlass* ctxk);\n-  void assert_concrete_with_no_concrete_subtype(ciKlass* ctxk);\n@@ -360,2 +334,0 @@\n-  void assert_abstract_with_exclusive_concrete_subtypes(ciKlass* ctxk, ciKlass* k1, ciKlass* k2);\n-  void assert_exclusive_concrete_methods(ciKlass* ctxk, ciMethod* m1, ciMethod* m2);\n@@ -428,12 +400,2 @@\n-  static Klass* check_abstract_with_unique_concrete_subtype(Klass* ctxk, Klass* conck,\n-                                                              KlassDepChange* changes = NULL);\n-  static Klass* check_abstract_with_no_concrete_subtype(Klass* ctxk,\n-                                                          KlassDepChange* changes = NULL);\n-  static Klass* check_concrete_with_no_concrete_subtype(Klass* ctxk,\n-                                                          KlassDepChange* changes = NULL);\n-  static Klass* check_unique_concrete_method(Klass* ctxk, Method* uniqm,\n-                                               KlassDepChange* changes = NULL);\n-  static Klass* check_abstract_with_exclusive_concrete_subtypes(Klass* ctxk, Klass* k1, Klass* k2,\n-                                                                  KlassDepChange* changes = NULL);\n-  static Klass* check_exclusive_concrete_methods(Klass* ctxk, Method* m1, Method* m2,\n-                                                   KlassDepChange* changes = NULL);\n+  static Klass* check_abstract_with_unique_concrete_subtype(Klass* ctxk, Klass* conck, KlassDepChange* changes = NULL);\n+  static Klass* check_unique_concrete_method(Klass* ctxk, Method* uniqm, KlassDepChange* changes = NULL);\n@@ -457,3 +419,2 @@\n-  static Klass*    find_unique_concrete_subtype(Klass* ctxk);\n-  static Method*   find_unique_concrete_method(Klass* ctxk, Method* m);\n-  static int       find_exclusive_concrete_subtypes(Klass* ctxk, int klen, Klass* k[]);\n+  static Klass*  find_unique_concrete_subtype(Klass* ctxk);\n+  static Method* find_unique_concrete_method(Klass* ctxk, Method* m);\n","filename":"src\/hotspot\/share\/code\/dependencies.hpp","additions":4,"deletions":43,"binary":false,"changes":47,"status":"modified"}]}