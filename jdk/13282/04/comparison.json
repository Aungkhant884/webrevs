{"files":[{"patch":"@@ -5195,1 +5195,1 @@\n-                        ? c.flatname.subName(c.owner.enclClass().flatname.getByteLength() + 1, c.flatname.getByteLength())\n+                        ? c.flatname.subName(c.owner.enclClass().flatname.length() + 1)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-    private final Name accessDollar;\n+    private final String accessDollar;\n@@ -115,2 +115,1 @@\n-        accessDollar = names.\n-            fromString(\"access\" + target.syntheticNameChar());\n+        accessDollar = \"access\" + target.syntheticNameChar();\n@@ -344,0 +343,1 @@\n+        final String string = name.toString();\n@@ -345,2 +345,2 @@\n-            name.startsWith(accessDollar) &&\n-            (name.getByteAt(name.getByteLength() - 1) & 1) == 1;\n+            string.startsWith(accessDollar) &&\n+            (string.charAt(string.length() - 1) & 1) != 0;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import com.sun.tools.javac.util.Name.NameMapper;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ModuleNameReader.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-    \/** Append a name.\n+    \/** Append a name encoded in Modified UTF-8.\n@@ -152,1 +152,4 @@\n-        appendBytes(name.getByteArray(), name.getByteOffset(), name.getByteLength());\n+        int utf8len = name.getUtf8Length();\n+        elems = ArrayUtils.ensureCapacity(elems, length + utf8len);\n+        name.getUtf8Bytes(elems, length);\n+        length += utf8len;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/ByteBuffer.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -217,0 +217,18 @@\n+    \/** Count the number of characters encoded in a Modified UTF-8 encoding.\n+     *  This method does not check for invalid data.\n+     *  @param buf data buffer\n+     *  @param off starting offset of UTF-8 data\n+     *  @param len number of bytes of UTF-8 data\n+     *  @return the number of encoded characters\n+     *\/\n+    public static int utfNumChars(byte[] buf, int off, int len) {\n+        int numChars = 0;\n+        while (len-- > 0) {\n+            int byte1 = buf[off++];\n+            if (byte1 < 0)\n+                len -= ((byte1 & 0xe0) == 0xc0) ? 1 : 2;\n+            numChars++;\n+        }\n+        return numChars;\n+    }\n+\n@@ -349,0 +367,1 @@\n+\n@@ -354,6 +373,2 @@\n-        int start = name.lastIndexOf((byte)'.') + 1;\n-        int end = name.getByteLength();\n-        if (start == 0 && end == name.length()) {\n-            return name;\n-        }\n-        return name.subName(start, end);\n+        int start = name.lastIndexOfAscii('.') + 1;\n+        return start > 0 ? name.subName(start) : name;\n@@ -374,1 +389,2 @@\n-        return classname.subName(0, classname.lastIndexOf((byte)'.'));\n+        int end = Math.max(classname.lastIndexOfAscii('.'), 0);\n+        return classname.subName(0, end);\n@@ -385,1 +401,1 @@\n-        while ((index = name.lastIndexOf((byte)'$')) > 0) {\n+        while ((index = name.lastIndexOfAscii('$')) > 0) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Convert.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import com.sun.tools.javac.jvm.PoolReader;\n@@ -32,3 +33,4 @@\n-\/** An abstraction for internal compiler strings. They are stored in\n- *  Utf8 format. Names are stored in a Name.Table, and are unique within\n- *  that table.\n+\/** An abstraction for internal compiler strings.\n+ *\n+ *  <p>\n+ *  Names are stored in a {@link Name.Table}, and are unique within that table.\n@@ -43,0 +45,3 @@\n+    \/**\n+     * The {@link Table} that contains this instance.\n+     *\/\n@@ -45,0 +50,5 @@\n+    \/**\n+     * Constructor.\n+     *\n+     * @param table the {@link Table} that will contain this instance\n+     *\/\n@@ -49,7 +59,1 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @DefinedBy(Api.LANGUAGE_MODEL)\n-    public boolean contentEquals(CharSequence cs) {\n-        return toString().equals(cs.toString());\n-    }\n+\/\/ PoolConstant\n@@ -58,1 +62,1 @@\n-    public int poolTag() {\n+    public final int poolTag() {\n@@ -62,3 +66,3 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n+\/\/ CharSequence\n+\n+    @Override\n@@ -70,1 +74,5 @@\n-     * {@inheritDoc}\n+     *  {@inheritDoc}\n+     *\n+     *  <p>\n+     *  The implementation in {@link Name} invokes {@link Object#toString}\n+     *  on this instance and then delegates to {@link String#charAt}.\n@@ -72,0 +80,1 @@\n+    @Override\n@@ -77,1 +86,5 @@\n-     * {@inheritDoc}\n+     *  {@inheritDoc}\n+     *\n+     *  <p>\n+     *  The implementation in {@link Name} invokes {@link Object#toString}\n+     *  on this instance and then delegates to {@link String#subSequence}.\n@@ -79,0 +92,1 @@\n+    @Override\n@@ -83,1 +97,11 @@\n-    \/** Return the concatenation of this name and name `n'.\n+    @Override\n+    public abstract String toString();\n+\n+\/\/ javax.lang.model.element.Name\n+\n+    \/**\n+     *  {@inheritDoc}\n+     *\n+     *  <p>\n+     *  The implementation in {@link Name} invokes {@link Object#toString}\n+     *  on this instance and then delegates to {@link String#equals}.\n@@ -85,10 +109,4 @@\n-    public Name append(Name n) {\n-        int len = getByteLength();\n-        byte[] bs = new byte[len + n.getByteLength()];\n-        getBytes(bs, 0);\n-        n.getBytes(bs, len);\n-        try {\n-            return table.fromUtf(bs, 0, bs.length, Convert.Validation.NONE);\n-        } catch (InvalidUtfException e) {\n-            throw new AssertionError(e);\n-        }\n+    @DefinedBy(Api.LANGUAGE_MODEL)\n+    @Override\n+    public boolean contentEquals(CharSequence cs) {\n+        return toString().equals(cs.toString());\n@@ -97,14 +115,9 @@\n-    \/** Return the concatenation of this name, the given ASCII\n-     *  character, and name `n'.\n-     *\/\n-    public Name append(char c, Name n) {\n-        int len = getByteLength();\n-        byte[] bs = new byte[len + 1 + n.getByteLength()];\n-        getBytes(bs, 0);\n-        bs[len] = (byte) c;\n-        n.getBytes(bs, len+1);\n-        try {\n-            return table.fromUtf(bs, 0, bs.length, Convert.Validation.NONE);\n-        } catch (InvalidUtfException e) {\n-            throw new AssertionError(e);\n-        }\n+    @DefinedBy(Api.LANGUAGE_MODEL)\n+    @Override\n+    public final boolean equals(Object obj) {\n+        if (obj == this)\n+            return true;\n+        if (obj == null || obj.getClass() != getClass())\n+            return false;\n+        final Name that = (Name)obj;\n+        return table == that.table && nameEquals(that);\n@@ -113,0 +126,15 @@\n+    @DefinedBy(Api.LANGUAGE_MODEL)\n+    @Override\n+    public abstract int hashCode();\n+\n+    \/**\n+     * Subclass check for equality.\n+     *\n+     * <p>\n+     * This method can assume that the given instance is the same type\n+     * as this instance and is associated to the same {@link Table}.\n+     *\/\n+    protected abstract boolean nameEquals(Name that);\n+\n+\/\/ Comparable\n+\n@@ -122,26 +150,1 @@\n-        byte[] buf1 = getByteArray();\n-        byte[] buf2 = name.getByteArray();\n-        int off1 = getByteOffset();\n-        int off2 = name.getByteOffset();\n-        int len1 = getByteLength();\n-        int len2 = name.getByteLength();\n-        while (len1 > 0 && len2 > 0) {\n-            int val1 = buf1[off1++] & 0xff;\n-            int val2 = buf2[off2++] & 0xff;\n-            if (val1 == 0xc0 && (buf1[off1] & 0x3f) == 0) {\n-                val1 = 0;       \/\/ char 0x0000 encoded in two bytes\n-                off1++;\n-                len1--;\n-            }\n-            if (val2 == 0xc0 && (buf2[off2] & 0x3f) == 0) {\n-                val2 = 0;       \/\/ char 0x0000 encoded in two bytes\n-                off2++;\n-                len2--;\n-            }\n-            int diff = val1 - val2;\n-            if (diff != 0)\n-                return diff;\n-            len1--;\n-            len2--;\n-        }\n-        return len1 > 0 ? 1 : len2 > 0 ? -1 : 0;\n+        return toString().compareTo(name.toString());\n@@ -150,1 +153,20 @@\n-    \/** Return true if this is the empty name.\n+\/\/ Other methods\n+\n+    \/** Return the concatenation of this name and the given name.\n+     *  The given name must come from the same table as this one.\n+     *\/\n+    public Name append(Name name) {\n+        return table.fromString(toString() + name.toString());\n+    }\n+\n+    \/** Return the concatenation of this name, the given ASCII\n+     *  character, and the given name.\n+     *  The given name must come from the same table as this one.\n+     *\/\n+    public Name append(char c, Name name) {\n+        return table.fromString(toString() + c + name.toString());\n+    }\n+\n+    \/** Determine if this is the empty name.\n+     *  <p>\n+     *  The implementation in {@link Name} compares {@link #length()} to zero.\n@@ -153,1 +175,1 @@\n-        return getByteLength() == 0;\n+        return length() == 0;\n@@ -156,1 +178,4 @@\n-    \/** Returns last occurrence of byte b in this name, -1 if not found.\n+    \/** Returns last occurrence of the given ASCII character in this name, -1 if not found.\n+     *  <p>\n+     *  The implementation in {@link Name} converts this instance to {@link String}\n+     *  and then delegates to {@link String#lastIndexOf(int)}.\n@@ -158,6 +183,2 @@\n-    public int lastIndexOf(byte b) {\n-        byte[] bytes = getByteArray();\n-        int offset = getByteOffset();\n-        int i = getByteLength() - 1;\n-        while (i >= 0 && bytes[offset + i] != b) i--;\n-        return i;\n+    public int lastIndexOfAscii(char ch) {\n+        return toString().lastIndexOf(ch);\n@@ -166,1 +187,4 @@\n-    \/** Does this name start with prefix?\n+    \/** Determine whether this name has the given Name as a prefix.\n+     *  <p>\n+     *  The implementation in {@link Name} converts this and the given instance\n+     *  to {@link String} and then delegates to {@link String#startsWith}.\n@@ -169,15 +193,1 @@\n-        byte[] thisBytes = this.getByteArray();\n-        int thisOffset   = this.getByteOffset();\n-        int thisLength   = this.getByteLength();\n-        byte[] prefixBytes = prefix.getByteArray();\n-        int prefixOffset   = prefix.getByteOffset();\n-        int prefixLength   = prefix.getByteLength();\n-\n-        if (thisLength < prefixLength)\n-            return false;\n-\n-        int i = 0;\n-        while (i < prefixLength &&\n-               thisBytes[thisOffset + i] == prefixBytes[prefixOffset + i])\n-            i++;\n-        return i == prefixLength;\n+        return toString().startsWith(prefix.toString());\n@@ -186,2 +196,7 @@\n-    \/** Returns the sub-name starting at position start, up to and\n-     *  excluding position end.\n+    \/** Returns the sub-name extending between two character positions.\n+     *  <p>\n+     *  The implementation in {@link Name} converts this instance to {@link String},\n+     *  delegates to {@link String#substring(int, int)} and then {@link Table#fromString}.\n+     *  @param start starting character offset, inclusive\n+     *  @param end ending character offset, exclusive\n+     *  @throws IndexOutOfBoundsException if bounds are out of range or invalid\n@@ -190,6 +205,1 @@\n-        if (end < start) end = start;\n-        try {\n-            return table.fromUtf(getByteArray(), getByteOffset() + start, end - start, Convert.Validation.NONE);\n-        } catch (InvalidUtfException e) {\n-            throw new AssertionError(e);\n-        }\n+        return table.fromString(toString().substring(start, end));\n@@ -198,1 +208,6 @@\n-    \/** Return the string representation of this name.\n+    \/** Returns the suffix of this name starting at the given offset.\n+     *  <p>\n+     *  The implementation in {@link Name} converts this instance to {@link String},\n+     *  delegates to {@link String#substring(int)}, and then to {@link Table#fromString}.\n+     *  @param off starting character offset\n+     *  @throws IndexOutOfBoundsException if {@code off} is out of range or invalid\n@@ -200,7 +215,2 @@\n-    @Override\n-    public String toString() {\n-        try {\n-            return Convert.utf2string(getByteArray(), getByteOffset(), getByteLength(), Convert.Validation.NONE);\n-        } catch (InvalidUtfException e) {\n-            throw new AssertionError(e);\n-        }\n+    public Name subName(int off) {\n+        return table.fromString(toString().substring(off));\n@@ -209,1 +219,4 @@\n-    \/** Return the Utf8 representation of this name.\n+    \/** Return the Modified UTF-8 encoding of this name.\n+     *  <p>\n+     *  The implementation in {@link Name} populates a new byte array of length\n+     *  {@link #getUtf8Length} with data from {@link #getUtf8Bytes}.\n@@ -212,2 +225,2 @@\n-        byte[] bs = new byte[getByteLength()];\n-        getBytes(bs, 0);\n+        byte[] bs = new byte[getUtf8Length()];\n+        getUtf8Bytes(bs, 0);\n@@ -217,6 +230,1 @@\n-    \/* Get a \"reasonably small\" value that uniquely identifies this name\n-     * within its name table.\n-     *\/\n-    public abstract int getIndex();\n-\n-    \/** Get the length (in bytes) of this name.\n+    \/** Get the length of the Modified UTF-8 encoding of this name.\n@@ -224,1 +232,1 @@\n-    public abstract int getByteLength();\n+    public abstract int getUtf8Length();\n@@ -226,1 +234,2 @@\n-    \/** Returns i'th byte of this name.\n+    \/** Write the Modified UTF-8 encoding of this name into the given\n+     *  buffer starting at the specified offset.\n@@ -228,1 +237,1 @@\n-    public abstract byte getByteAt(int i);\n+    public abstract void getUtf8Bytes(byte buf[], int off);\n@@ -230,10 +239,1 @@\n-    \/** Copy all bytes of this name to buffer cs, starting at start.\n-     *\/\n-    public void getBytes(byte cs[], int start) {\n-        System.arraycopy(getByteArray(), getByteOffset(), cs, start, getByteLength());\n-    }\n-\n-    \/** Get the underlying byte array for this name. The contents of the\n-     * array must not be modified.\n-     *\/\n-    public abstract byte[] getByteArray();\n+\/\/ Mapping\n@@ -241,1 +241,1 @@\n-    \/** Get the start offset of this name within its byte array.\n+    \/** Maps the Modified UTF-8 encoding of a {@link Name} to something.\n@@ -243,2 +243,1 @@\n-    public abstract int getByteOffset();\n-\n+    @FunctionalInterface\n@@ -249,0 +248,2 @@\n+    \/** Decode this name's Modified UTF-8 encoding into something.\n+     *\/\n@@ -250,1 +251,2 @@\n-        return mapper.map(getByteArray(), getByteOffset(), getByteLength());\n+        byte[] buf = toUtf();\n+        return mapper.map(buf, 0, buf.length);\n@@ -253,1 +255,3 @@\n-    \/** An abstraction for the hash table used to create unique Name instances.\n+\/\/ Table\n+\n+    \/** An abstraction for the hash table used to create unique {@link Name} instances.\n@@ -256,0 +260,1 @@\n+\n@@ -260,1 +265,1 @@\n-        Table(Names names) {\n+        protected Table(Names names) {\n@@ -264,1 +269,5 @@\n-        \/** Get the name from the characters in cs[start..start+len-1].\n+        \/** Get the unique {@link Name} corresponding to the given characters.\n+         *  @param buf character buffer\n+         *  @param off starting offset\n+         *  @param len number of characters\n+         *  @return the corresponding {@link Name}\n@@ -266,1 +275,1 @@\n-        public abstract Name fromChars(char[] cs, int start, int len);\n+        public abstract Name fromChars(char[] cs, int off, int len);\n@@ -268,1 +277,5 @@\n-        \/** Get the name for the characters in string s.\n+        \/** Get the unique {@link Name} corresponding to the given string.\n+         *  <p>\n+         *  The implementation in {@link Table} delegates to {@link String#toCharArray}\n+         *  and then {@link #fromChars}.\n+         *  @param s character string\n@@ -275,2 +288,6 @@\n-        \/** Get the name for the bytes in array cs.\n-         *  Assume that bytes are in strictly valid \"Modified UTF-8\" format.\n+        \/** Get the unique {@link Name} corresponding to the given Modified UTF-8 encoding.\n+         *  <p>\n+         *  The implementation in {@link Table} delegates to {@link #fromUtf(byte[], int, int)}.\n+         *  @param buf character string\n+         *  @return the corresponding {@link Name}\n+         *  @throws IllegalArgumentException if the data is not valid Modified UTF-8\n@@ -282,2 +299,6 @@\n-        \/** get the name for the bytes in cs[start..start+len-1].\n-         *  Assume that bytes are in utf8 format.\n+        \/** Get the unique {@link Name} corresponding to the given Modified UTF-8 encoding.\n+         *  @param buf character buffer\n+         *  @param off starting offset\n+         *  @param len number of bytes\n+         *  @return the corresponding {@link Name}\n+         *  @throws IllegalArgumentException if the data is not valid Modified UTF-8\n@@ -292,23 +313,0 @@\n-\n-        \/** The hashcode of a name.\n-         *\/\n-        protected static int hashValue(byte bytes[], int offset, int length) {\n-            int h = 0;\n-            int off = offset;\n-\n-            for (int i = 0; i < length; i++) {\n-                h = (h << 5) - h + bytes[off++];\n-            }\n-            return h;\n-        }\n-\n-        \/** Compare two subarrays\n-         *\/\n-        protected static boolean equals(byte[] bytes1, int offset1,\n-                byte[] bytes2, int offset2, int length) {\n-            int i = 0;\n-            while (i < length && bytes1[offset1 + i] == bytes2[offset2 + i]) {\n-                i++;\n-            }\n-            return i == length;\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Name.java","additions":164,"deletions":166,"binary":false,"changes":330,"status":"modified"},{"patch":"@@ -431,0 +431,3 @@\n+        boolean useStringTable = options.isSet(\"useStringTable\");\n+        if (useStringTable)\n+            return newStringNameTable();\n@@ -433,3 +436,14 @@\n-            return UnsharedNameTable.create(this);\n-        else\n-            return SharedNameTable.create(this);\n+            return newUnsharedNameTable();\n+        return newSharedNameTable();\n+    }\n+\n+    public StringNameTable newStringNameTable() {\n+        return StringNameTable.create(this);\n+    }\n+\n+    public SharedNameTable newSharedNameTable() {\n+        return SharedNameTable.create(this);\n+    }\n+\n+    public UnsharedNameTable newUnsharedNameTable() {\n+        return UnsharedNameTable.create(this);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-public class SharedNameTable extends Name.Table {\n+public class SharedNameTable extends Utf8NameTable {\n@@ -82,0 +82,1 @@\n+     *  @throws IllegalArgumentException if {@code hashSize} is not a power of two\n@@ -85,0 +86,2 @@\n+        if (Integer.bitCount(hashSize) != 1)\n+            throw new IllegalArgumentException();   \/\/ hashSize is not a power of two\n@@ -88,1 +91,0 @@\n-\n@@ -95,0 +97,2 @@\n+\/\/ Name.Table\n+\n@@ -107,11 +111,2 @@\n-        if (n == null) {\n-            n = new NameImpl(this);\n-            n.index = nc;\n-            n.length = nbytes;\n-            n.next = hashes[h];\n-            hashes[h] = n;\n-            this.nc = nc + nbytes;\n-            if (nbytes == 0) {\n-                this.nc++;\n-            }\n-        }\n+        if (n == null)\n+            n = addName(nc, nbytes, h);\n@@ -133,1 +128,0 @@\n-            int nc = this.nc;\n@@ -136,9 +130,1 @@\n-            n = new NameImpl(this);\n-            n.index = nc;\n-            n.length = len;\n-            n.next = hashes[h];\n-            hashes[h] = n;\n-            this.nc = nc + len;\n-            if (len == 0) {\n-                this.nc++;\n-            }\n+            n = addName(nc, len, h);\n@@ -149,0 +135,7 @@\n+    private NameImpl addName(int index, int len, int hash) {\n+        NameImpl name = new NameImpl(this, index, len, hashes[hash]);\n+        hashes[hash] = name;\n+        this.nc = index + Math.max(len, 1);\n+        return name;\n+    }\n+\n@@ -154,1 +147,4 @@\n-    static class NameImpl extends Name {\n+\/\/ NameImpl\n+\n+    static final class NameImpl extends Utf8NameTable.NameImpl {\n+\n@@ -157,1 +153,1 @@\n-        NameImpl next;\n+        final NameImpl next;\n@@ -162,1 +158,1 @@\n-        int index;\n+        final int index;\n@@ -166,1 +162,1 @@\n-        int length;\n+        final int length;\n@@ -168,1 +164,3 @@\n-        NameImpl(SharedNameTable table) {\n+    \/\/ Constructor\n+\n+        NameImpl(SharedNameTable table, int index, int length, NameImpl next) {\n@@ -170,0 +168,3 @@\n+            this.index = index;\n+            this.length = length;\n+            this.next = next;\n@@ -172,4 +173,1 @@\n-        @Override\n-        public int getIndex() {\n-            return index;\n-        }\n+    \/\/ Utf8NameTable.NameImpl\n@@ -178,2 +176,2 @@\n-        public int getByteLength() {\n-            return length;\n+        protected byte[] getByteData() {\n+            return ((SharedNameTable)table).bytes;\n@@ -183,2 +181,2 @@\n-        public byte getByteAt(int i) {\n-            return getByteArray()[index + i];\n+        protected int getByteOffset() {\n+            return index;\n@@ -188,2 +186,2 @@\n-        public byte[] getByteArray() {\n-            return ((SharedNameTable) table).bytes;\n+        protected int getByteLength() {\n+            return length;\n@@ -193,1 +191,1 @@\n-        public int getByteOffset() {\n+        protected int getNameIndex() {\n@@ -196,17 +194,0 @@\n-\n-        \/** Return the hash value of this name.\n-         *\/\n-        @DefinedBy(Api.LANGUAGE_MODEL)\n-        public int hashCode() {\n-            return index;\n-        }\n-\n-        \/** Is this name equal to other?\n-         *\/\n-        @DefinedBy(Api.LANGUAGE_MODEL)\n-        public boolean equals(Object other) {\n-            return (other instanceof Name name)\n-                    && table == name.table\n-                    && index == name.getIndex();\n-        }\n-\n@@ -214,1 +195,0 @@\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/SharedNameTable.java","additions":37,"deletions":57,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.util;\n+\n+import java.util.HashMap;\n+\n+\/**\n+ * Straightforward implementation of {@link Name.Table} using {@link String}s.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class StringNameTable extends Name.Table {\n+\n+    private final HashMap<String, Name> nameMap;\n+\n+\/\/ Factory\n+\n+    public static StringNameTable create(Names names) {\n+        return new StringNameTable(names);\n+    }\n+\n+\/\/ Constructors\n+\n+    public StringNameTable(Names names) {\n+        this(names, 0x8000);\n+    }\n+\n+    public StringNameTable(Names names, int initialCapacity) {\n+        super(names);\n+        this.nameMap = new HashMap<>(initialCapacity);\n+    }\n+\n+\/\/ Name.Table\n+\n+    @Override\n+    public Name fromString(String string) {\n+        return this.nameMap.computeIfAbsent(string, s -> new NameImpl(this, s));\n+    }\n+\n+    @Override\n+    public Name fromChars(char[] buf, int off, int len) {\n+        return this.fromString(new String(buf, off, len));\n+    }\n+\n+    @Override\n+    public Name fromUtf(byte[] buf, int off, int len, Convert.Validation validation) throws InvalidUtfException {\n+        return this.fromString(Convert.utf2string(buf, off, len, validation));\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        this.nameMap.clear();\n+    }\n+\n+\/\/ NameImpl\n+\n+    private static final class NameImpl extends Name {\n+\n+        private final String string;\n+\n+    \/\/ Constructor\n+\n+        NameImpl(StringNameTable table, String string) {\n+            super(table);\n+            this.string = string;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return string;\n+        }\n+\n+        @Override\n+        public boolean contentEquals(CharSequence cs) {\n+            return string.contentEquals(cs);\n+        }\n+\n+        @Override\n+        protected boolean nameEquals(Name that) {\n+            return ((NameImpl)that).string.equals(string);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return string.hashCode();\n+        }\n+\n+        @Override\n+        public int getUtf8Length() {\n+            int slen = string.length();\n+            int extra = 0;\n+            for (int i = 0; i < slen; i++) {\n+                int ch = string.charAt(i);\n+                if (ch > 0x007f || ch == 0x0000) {\n+                    extra++;\n+                    if (ch > 0x07ff)\n+                        extra++;\n+                }\n+            }\n+            return slen + extra;\n+        }\n+\n+        @Override\n+        public void getUtf8Bytes(byte buf[], int off) {\n+            Convert.chars2utf(string.toCharArray(), 0, buf, off, string.length());\n+        }\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/StringNameTable.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -40,2 +40,2 @@\n-public class UnsharedNameTable extends Name.Table {\n-    public static Name.Table create(Names names) {\n+public class UnsharedNameTable extends Utf8NameTable {\n+    public static UnsharedNameTable create(Names names) {\n@@ -64,0 +64,2 @@\n+\/\/ Constructors\n+\n@@ -68,0 +70,1 @@\n+     *  @throws IllegalArgumentException if {@code hashSize} is not a power of two\n@@ -71,0 +74,2 @@\n+        if (Integer.bitCount(hashSize) != 1)\n+            throw new IllegalArgumentException();   \/\/ hashSize is not a power of two\n@@ -79,0 +84,1 @@\n+\/\/ Name.Table\n@@ -148,1 +154,9 @@\n-    static class NameImpl extends Name {\n+\/\/ NameImpl\n+\n+    static final class NameImpl extends Utf8NameTable.NameImpl {\n+\n+        final byte[] bytes;\n+        final int index;\n+\n+    \/\/ Constructor\n+\n@@ -155,7 +169,1 @@\n-        final byte[] bytes;\n-        final int index;\n-\n-        @Override\n-        public int getIndex() {\n-            return index;\n-        }\n+    \/\/ Utf8NameTable.NameImpl\n@@ -164,2 +172,2 @@\n-        public int getByteLength() {\n-            return bytes.length;\n+        protected byte[] getByteData() {\n+            return bytes;\n@@ -169,2 +177,2 @@\n-        public byte getByteAt(int i) {\n-            return bytes[i];\n+        protected int getByteOffset() {\n+            return 0;\n@@ -174,2 +182,2 @@\n-        public byte[] getByteArray() {\n-            return bytes;\n+        protected int getByteLength() {\n+            return bytes.length;\n@@ -179,2 +187,2 @@\n-        public int getByteOffset() {\n-            return 0;\n+        protected int getNameIndex() {\n+            return index;\n@@ -182,1 +190,0 @@\n-\n@@ -184,1 +191,0 @@\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/UnsharedNameTable.java","additions":26,"deletions":20,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,259 @@\n+\/*\n+ * Copyright (c) 2023 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.util;\n+\n+import java.lang.ref.SoftReference;\n+\n+import com.sun.tools.javac.util.DefinedBy.Api;\n+\n+\/**\n+ * Support superclass for {@link Name.Table} implementations that store\n+ * names as Modified UTF-8 data in {@code byte[]} arrays.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public abstract class Utf8NameTable extends Name.Table {\n+\n+    \/** Constructor.\n+     *  @param names The main name table\n+     *\/\n+    protected Utf8NameTable(Names names) {\n+        super(names);\n+    }\n+\n+\/\/ Utility methods\n+\n+    \/** Generate a hash value for a subarray.\n+     *\/\n+    protected static int hashValue(byte buf[], int off, int len) {\n+        int hash = 0;\n+        while (len-- > 0)\n+            hash = (hash << 5) - hash + buf[off++];\n+        return hash;\n+    }\n+\n+    \/** Compare two subarrays.\n+     *\/\n+    protected static boolean equals(byte[] buf1, int off1, byte[] buf2, int off2, int len) {\n+        while (len-- > 0) {\n+            if (buf1[off1++] != buf2[off2++])\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+\/\/ NameImpl\n+\n+    protected abstract static class NameImpl extends Name {\n+\n+    \/\/ Constructor\n+\n+        NameImpl(Utf8NameTable table) {\n+            super(table);\n+        }\n+\n+    \/\/ Subclass hooks\n+\n+        \/**\n+         * Get the {@code byte[]} array in which the Modified UTF-8 data is stored.\n+         *\/\n+        protected abstract byte[] getByteData();\n+\n+        \/**\n+         * Get the Modified UTF-8 data offset into the byte array.\n+         *\/\n+        protected abstract int getByteOffset();\n+\n+        \/**\n+         * Get the Modified UTF-8 data length in the byte array.\n+         *\/\n+        protected abstract int getByteLength();\n+\n+        \/**\n+         * Get a unique index corresponding to this instance.\n+         *\/\n+        protected abstract int getNameIndex();\n+\n+    \/\/ CharSequence\n+\n+        @Override\n+        public int length() {\n+            return Convert.utfNumChars(getByteData(), getByteOffset(), getByteLength());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            try {\n+                return Convert.utf2string(getByteData(), getByteOffset(), getByteLength(), Convert.Validation.NONE);\n+            } catch (InvalidUtfException e) {\n+                throw new AssertionError();\n+            }\n+        }\n+\n+    \/\/ javax.lang.model.element.Name\n+\n+        @Override\n+        protected boolean nameEquals(Name that) {\n+            return ((NameImpl)that).getNameIndex() == getNameIndex();\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return getNameIndex();\n+        }\n+\n+    \/\/ Comparable\n+\n+        @Override\n+        public int compareTo(Name name0) {\n+            NameImpl name = (NameImpl)name0;\n+            Assert.check(name.table == table);\n+            byte[] buf1 = getByteData();\n+            byte[] buf2 = name.getByteData();\n+            int off1 = getByteOffset();\n+            int off2 = name.getByteOffset();\n+            int len1 = getByteLength();\n+            int len2 = name.getByteLength();\n+            while (len1 > 0 && len2 > 0) {\n+                int val1 = buf1[off1++] & 0xff;\n+                int val2 = buf2[off2++] & 0xff;\n+                if (val1 == 0xc0 && (buf1[off1] & 0x3f) == 0) {\n+                    val1 = 0;       \/\/ char 0x0000 encoded in two bytes\n+                    off1++;\n+                    len1--;\n+                }\n+                if (val2 == 0xc0 && (buf2[off2] & 0x3f) == 0) {\n+                    val2 = 0;       \/\/ char 0x0000 encoded in two bytes\n+                    off2++;\n+                    len2--;\n+                }\n+                int diff = val1 - val2;\n+                if (diff != 0)\n+                    return diff;\n+                len1--;\n+                len2--;\n+            }\n+            return len1 > 0 ? 1 : len2 > 0 ? -1 : 0;\n+        }\n+\n+    \/\/ Name\n+\n+        @Override\n+        public Name append(Name name0) {\n+            NameImpl name = (NameImpl)name0;\n+            Assert.check(name.table == table);\n+            byte[] buf1 = getByteData();\n+            byte[] buf2 = name.getByteData();\n+            int off1 = getByteOffset();\n+            int off2 = name.getByteOffset();\n+            int len1 = getByteLength();\n+            int len2 = name.getByteLength();\n+            byte[] result = new byte[len1 + len2];\n+            System.arraycopy(buf1, off1, result, 0, len1);\n+            System.arraycopy(buf2, off2, result, len1, len2);\n+            try {\n+                return table.fromUtf(result, 0, result.length, Convert.Validation.NONE);\n+            } catch (InvalidUtfException e) {\n+                throw new AssertionError();\n+            }\n+        }\n+\n+        @Override\n+        public Name append(char ch, Name name0) {\n+            Assert.check((ch & ~0x7f) == 0);\n+            NameImpl name = (NameImpl)name0;\n+            Assert.check(name.table == table);\n+            byte[] buf1 = getByteData();\n+            byte[] buf2 = name.getByteData();\n+            int off1 = getByteOffset();\n+            int off2 = name.getByteOffset();\n+            int len1 = getByteLength();\n+            int len2 = name.getByteLength();\n+            byte[] result = new byte[len1 + 1 + len2];\n+            System.arraycopy(buf1, off1, result, 0, len1);\n+            result[len1] = (byte)ch;\n+            System.arraycopy(buf2, off2, result, len1 + 1, len2);\n+            try {\n+                return table.fromUtf(result, 0, result.length, Convert.Validation.NONE);\n+            } catch (InvalidUtfException e) {\n+                throw new AssertionError();\n+            }\n+        }\n+\n+        @Override\n+        public int lastIndexOfAscii(char ch) {\n+            Assert.check((ch & ~0x7f) == 0);\n+\n+            \/\/ Find the last *byte* index of 'ch'\n+            byte b = (byte)ch;\n+            byte[] buf = getByteData();\n+            int off = getByteOffset();\n+            int len = getByteLength();\n+            int pos = len - 1;\n+            while (pos >= 0 && buf[off + pos] != b)\n+                pos--;\n+\n+            \/\/ Not found, or index is zero?\n+            if (pos <= 0)\n+                return pos;\n+\n+            \/\/ Convert the byte index into a char index\n+            return Convert.utfNumChars(buf, off, pos);\n+        }\n+\n+        @Override\n+        public boolean startsWith(Name prefix0) {\n+            NameImpl prefix = (NameImpl)prefix0;\n+            Assert.check(prefix.table == table);\n+            int thisLen = getByteLength();\n+            int prefLen = prefix.getByteLength();\n+            if (thisLen < prefLen)\n+                return false;\n+            byte[] thisData = getByteData();\n+            byte[] prefData = prefix.getByteData();\n+            int thisOff = getByteOffset() + prefLen;\n+            int prefOff = prefix.getByteOffset() + prefLen;\n+            while (prefLen-- > 0) {\n+                if (thisData[--thisOff] != prefData[--prefOff])\n+                    return false;\n+            }\n+            return true;\n+        }\n+\n+        @Override\n+        public int getUtf8Length() {\n+            return getByteLength();\n+        }\n+\n+        @Override\n+        public void getUtf8Bytes(byte buf[], int off) {\n+            System.arraycopy(getByteData(), getByteOffset(), buf, off, getByteLength());\n+        }\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Utf8NameTable.java","additions":259,"deletions":0,"binary":false,"changes":259,"status":"added"}]}