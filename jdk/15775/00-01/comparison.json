{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Objects;\n@@ -140,5 +141,7 @@\n-     * Creates an {@code Inet4Address} based on the provided IPv4 address literal.\n-     * <p> IPv4 address literals in dotted-decimal form and\n-     * <a href=\"Inet6Address.html#format\">IPv4-compatible IPv6 address<\/a> literals\n-     * are supported. For example, the following literals are valid literals in\n-     * dotted-decimal form:\n+     * Creates an {@code Inet4Address} based on the provided textual representation of\n+     * an IPv4 address.\n+     * <p>The following IPv4 address {@linkplain Inet4Address##format\n+     * textual representations} are supported by this method:\n+     * {@snippet :\n+     *  \/\/ Dotted-decimal 'd.d.d.d' form with four part address literal\n+     *  Inet4Address.ofLiteral(\"7.08.9.010\") ==> \/7.8.9.10\n@@ -146,4 +149,4 @@\n-     *   <blockquote><ul style=\"list-style-type:none\">\n-     *   <li>{@code 1.2.3.4}<\/li>\n-     *   <li>{@code 06.07.08.09}<\/li>\n-     *   <\/ul><\/blockquote>\n+     *  \/\/ Dotted-decimal 'd.d.d' form with three part address literal,\n+     *  \/\/ the last part is placed in the right most two bytes\n+     *  \/\/ of the constructed address\n+     *  Inet4Address.ofLiteral(\"127.0.257\") ==> \/127.0.1.1\n@@ -151,3 +154,4 @@\n-     * <p> This method doesn't block, i.e. the system-wide {@linkplain\n-     * java.net.spi.InetAddressResolver resolver} is not queried to resolve\n-     * the provided literal, and no reverse lookup is performed.\n+     *  \/\/ Dotted-decimal 'd.d' form with two part address literal,\n+     *  \/\/ the last part is placed in the right most three bytes\n+     *  \/\/ of the constructed address\n+     *  Inet4Address.ofLiteral(\"127.257\") ==> \/127.0.1.1\n@@ -155,4 +159,14 @@\n-     * @param addressLiteral the IPv4 address literal.\n-     * @return an {@link Inet4Address} object with no hostname set constructed from the\n-     *         IPv4 address literal.\n-     * @throws IllegalArgumentException if literal cannot be parsed as an IPv4 address literal.\n+     *  \/\/ 'd' form with one decimal value that is stored directly in\n+     *  \/\/ the constructed address bytes without any rearrangement\n+     *  Inet4Address.ofLiteral(\"02130706689\") ==> \/127.0.1.1\n+     * }\n+     * <p>If the provided address literal cannot represent a valid IPv4 address an\n+     * {@code IllegalArgumentException} is thrown.\n+     * <p>This method doesn't block, i.e. no reverse lookup is performed.\n+     *\n+     * @param ipv4AddressLiteral the textual representation of an IPv4 address.\n+     * @return an {@link Inet4Address} object with no hostname set, and constructed\n+     *         from the IPv4 address literal.\n+     * @throws IllegalArgumentException if the {@code ipv4AddressLiteral} cannot be\n+     *         parsed as an IPv4 address literal.\n+     * @throws NullPointerException if the {@code ipv4AddressLiteral} is {@code null}.\n@@ -160,13 +174,3 @@\n-    public static Inet4Address ofLiteral(String addressLiteral) {\n-        \/\/ Try to parse IPv4-compatible IPv6 addresses first\n-        try {\n-            InetAddress inetAddress = Inet6Address.parseAddressString(addressLiteral,\n-                                                       true);\n-            if (inetAddress instanceof Inet4Address ipv4compAddress) {\n-                return ipv4compAddress;\n-            }\n-        } catch (UnknownHostException uhe) {\n-            \/\/ If address literal is not an IPv4-compatible IPv6 address - continue parsing\n-            \/\/ it as an IPv4 address literal\n-        }\n-        return parseAddressString(addressLiteral, true);\n+    public static Inet4Address ofLiteral(String ipv4AddressLiteral) {\n+        Objects.requireNonNull(ipv4AddressLiteral);\n+        return parseAddressString(ipv4AddressLiteral, true);\n","filename":"src\/java.base\/share\/classes\/java\/net\/Inet4Address.java","additions":33,"deletions":29,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.Objects;\n@@ -486,8 +487,7 @@\n-     * Creates an {@code Inet6Address} based on the provided IPv6 address literal.\n-     * <p> This method doesn't block, i.e. the system-wide {@linkplain\n-     * java.net.spi.InetAddressResolver resolver} is not queried to resolve\n-     * the provided literal, and no reverse lookup is performed.\n-     * @implNote <a href=\"Inet6Address.html#special-ipv6-address-heading\">\n-     * IPv4-mapped IPv6 address literals<\/a> are treated as invalid by this method.\n-     * <p>{@link InetAddress#ofLiteral(String)} can be used to parse IPv4-mapped IPv6\n-     * address literals.\n+     * Creates an {@code InetAddress} based on the provided textual representation of\n+     * an IPv6 address.\n+     * <p>The following IPv6 address {@linkplain Inet6Address##format\n+     * textual representations} are supported by this method:\n+     * {@snippet :\n+     *  \/\/ The full IPv6 form\n+     *  Inet6Address.ofLiteral(\"1080:0:0:0:8:800:200C:417A\") ==> \/1080:0:0:0:8:800:200c:417a\n@@ -495,4 +495,30 @@\n-     * @param addressLiteral the IPv6 address literal.\n-     * @return an {@link Inet6Address} object with no hostname set constructed from the\n-     *         IPv6 address literal.\n-     * @throws IllegalArgumentException if literal cannot be parsed as an IPv6 address literal.\n+     *  \/\/ The compressed IPv6 form with multiple groups of 16-bits of\n+     *  \/\/ zero replaced with \"::\"\n+     *  Inet6Address.ofLiteral(\"1080::8:800:200C:417A\") ==> \/1080:0:0:0:8:800:200c:417a\n+     *\n+     *  \/\/ IPv4-mapped IPv6 form\n+     *  Inet6Address.ofLiteral(\"::FFFF:129.144.52.38\") ==> \/129.144.52.38\n+     *\n+     *  \/\/ IPv4-compatible IPv6 form\n+     *  Inet6Address.ofLiteral(\"::129.144.52.38\") ==> \/0:0:0:0:0:0:8190:3426\n+     *\n+     *  \/\/ IPv6 scoped address form with scope-id as numeric identifier\n+     *  Inet6Address.ofLiteral(\"fe80::1%1\") ==> \/fe80:0:0:0:0:0:0:1%1\n+     *\n+     *  \/\/ IPv6 scoped address with scope-id as string\n+     *  Inet6Address.ofLiteral(\"fe80::1%en0\") ==> \/fe80:0:0:0:0:0:0:1%en0\n+     * }\n+     * All IPv6 address literal forms listed above are also supported when enclosed in\n+     * square brackets.\n+     * <p>If the provided address literal cannot represent a valid IP address an\n+     * {@code IllegalArgumentException} is thrown. For instance, if an IPv6 scoped\n+     *  address literal contains a scope-id that doesn't map to any network interface\n+     *  on the system, or if a scope-id is present in an IPv4-mapped IPv6 address literal.\n+     * <p>This method doesn't block, i.e. no reverse lookup is performed.\n+     *\n+     * @param ipv6AddressLiteral the textual representation of an IPv6 address.\n+     * @return an {@link Inet6Address} object with no hostname set, and constructed\n+     *         from the IPv6 address literal.\n+     * @throws IllegalArgumentException if the {@code ipv6AddressLiteral} cannot be\n+     *         parsed as an IPv6 address literal.\n+     * @throws NullPointerException if the {@code ipv6AddressLiteral} is {@code null}.\n@@ -500,1 +526,2 @@\n-    public static Inet6Address ofLiteral(String addressLiteral) {\n+    public static InetAddress ofLiteral(String ipv6AddressLiteral) {\n+        Objects.requireNonNull(ipv6AddressLiteral);\n@@ -502,4 +529,3 @@\n-            InetAddress inetAddress = parseAddressString(addressLiteral, true);\n-            \/\/ IPv4-mapped IPv6 address literals are rejected\n-            if (inetAddress instanceof Inet6Address inet6Address) {\n-                return inet6Address;\n+            InetAddress parsedAddress = parseAddressString(ipv6AddressLiteral, true);\n+            if (parsedAddress != null) {\n+                return parsedAddress;\n@@ -511,1 +537,1 @@\n-        throw IPAddressUtil.invalidIpAddressLiteral(addressLiteral);\n+        throw IPAddressUtil.invalidIpAddressLiteral(ipv6AddressLiteral);\n@@ -515,4 +541,9 @@\n-     * Method tries to parse IPv6 or IPv4-mapped IPv6 address string as a literal IP address.\n-     * If string doesn't contain valid literal - null is returned.\n-     * If there is an issue with constructing {@link InetAddress} from parsed bytes -\n-     * UnknownHostException is thrown.\n+     * Method tries to parse supplied IP address literal as IPv6, IPv4-compatible IPv6 or\n+     * IPv4-mapped IPv6 address.\n+     * If address part of the literal string doesn't contain address in valid IPv6 form\n+     * - {@code null} is returned.\n+     * {@code UnknownHostException} is thrown if {@link InetAddress} cannot be constructed\n+     * from parsed string due to:\n+     * - incorrect zone-id specified in IPv6-scoped address literal that references\n+     * non-existing interface name.\n+     * - unexpected zone-id in IPv4-mapped address literal.\n@@ -523,1 +554,1 @@\n-     * literal IP address string\n+     * literal IP address string.\n@@ -525,1 +556,1 @@\n-     * as IPv6 or IPv4-mapped IPv6 address literals.\n+     * as IPv6, IPv4-mapped IPv6 or IPv4-compatible IPv6 address literals.\n","filename":"src\/java.base\/share\/classes\/java\/net\/Inet6Address.java","additions":55,"deletions":24,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -1708,4 +1708,8 @@\n-     * Creates an {@code InetAddress} based on the provided IP address literal.\n-     * <p> This method doesn't block, i.e. the system-wide {@linkplain\n-     * java.net.spi.InetAddressResolver resolver} is not queried to resolve\n-     * the provided literal, and no reverse lookup is performed.\n+     * Creates an {@code InetAddress} based on the provided textual representation of\n+     * an IP address.\n+     * <p> The provided IP address literal is parsed as an IPv4 address literal first.\n+     * If it cannot be parsed as {@linkplain Inet4Address#ofLiteral(String) IPv4 address\n+     * literal}, then the method attempts to parse it as\n+     * {@linkplain Inet6Address#ofLiteral(String) an IPv6 address literal}.\n+     * If neither attempts succeed an {@code IllegalArgumentException} is thrown.\n+     * <p> This method doesn't block, i.e. no reverse lookup is performed.\n@@ -1713,5 +1717,8 @@\n-     * @param addressLiteral the IP address literal.\n-     * @return an {@link InetAddress} object with no hostname set constructed from the IP\n-     *         address literal.\n-     * @throws IllegalArgumentException if literal cannot be parsed as an IPv4 or IPv6\n-     *                                  address literal.\n+     * @param ipAddressLiteral the textual representation of an IP address.\n+     * @return an {@link InetAddress} object with no hostname set, and constructed\n+     *         from the IP address literal.\n+     * @throws IllegalArgumentException if the {@code ipAddressLiteral} cannot be parsed\n+     *         as an IPv4 or IPv6 address literal.\n+     * @throws NullPointerException if the {@code ipAddressLiteral} is {@code null}.\n+     * @see Inet4Address#ofLiteral(String)\n+     * @see Inet6Address#ofLiteral(String)\n@@ -1719,10 +1726,9 @@\n-    public static InetAddress ofLiteral(String addressLiteral) throws IllegalArgumentException {\n-        InetAddress inetAddress = Inet4Address.parseAddressString(addressLiteral, false);\n-        if (inetAddress == null) {\n-            try {\n-                inetAddress = Inet6Address.parseAddressString(addressLiteral, true);\n-            } catch(UnknownHostException uhe) {\n-            }\n-        }\n-        if (inetAddress == null) {\n-            throw IPAddressUtil.invalidIpAddressLiteral(addressLiteral);\n+    public static InetAddress ofLiteral(String ipAddressLiteral) {\n+        Objects.requireNonNull(ipAddressLiteral);\n+        InetAddress inetAddress;\n+        try {\n+            \/\/ First try to parse the input as an IPv4 address literal\n+            inetAddress = Inet4Address.ofLiteral(ipAddressLiteral);\n+        } catch (IllegalArgumentException iae) {\n+            \/\/ If it fails try to parse the input as an IPv6 address literal\n+            inetAddress = Inet6Address.ofLiteral(ipAddressLiteral);\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":25,"deletions":19,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -29,0 +29,9 @@\n+ * @run junit\/othervm -Djdk.net.hosts.file=nonExistingHostsFile.txt\n+ *                    -Djava.net.preferIPv4Stack=true\n+ *                     OfLiteralTest\n+ * @run junit\/othervm -Djdk.net.hosts.file=nonExistingHostsFile.txt\n+ *                    -Djava.net.preferIPv6Addresses=true\n+ *                     OfLiteralTest\n+ * @run junit\/othervm -Djdk.net.hosts.file=nonExistingHostsFile.txt\n+ *                    -Djava.net.preferIPv6Addresses=false\n+ *                     OfLiteralTest\n@@ -36,0 +45,1 @@\n+import org.junit.jupiter.params.provider.EnumSource;\n@@ -41,0 +51,4 @@\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n@@ -63,1 +77,1 @@\n-    private static Stream<Arguments> validLiteralArguments() {\n+    private static Stream<Arguments> validLiteralArguments() throws Exception {\n@@ -90,1 +104,1 @@\n-        return Stream.of(\n+        Stream<Arguments> validLiterals = Stream.of(\n@@ -95,4 +109,0 @@\n-                Arguments.of(InetAddressClass.INET6_ADDRESS,\n-                        \"[1080:0::8:800:200C:417A]\", ipv6AddressExpBytes),\n-                Arguments.of(InetAddressClass.INET_ADDRESS,\n-                        \"1080:0::8:800:200C:417A\", ipv6AddressExpBytes),\n@@ -101,1 +111,6 @@\n-\n+                \/\/ Compressed series of zeros with square brackets\n+                Arguments.of(InetAddressClass.INET6_ADDRESS,\n+                        \"[1080::8:800:200C:417A]\", ipv6AddressExpBytes),\n+                \/\/ Compressed series of zeros without square brackets\n+                Arguments.of(InetAddressClass.INET_ADDRESS,\n+                        \"1080::8:800:200C:417A\", ipv6AddressExpBytes),\n@@ -103,1 +118,1 @@\n-                \/\/ InetAddress.ofLiteral and Inet4Address.ofLiteral methods\n+                \/\/ InetAddress.ofLiteral and Inet6Address.ofLiteral methods\n@@ -108,1 +123,1 @@\n-                Arguments.of(InetAddressClass.INET4_ADDRESS,\n+                Arguments.of(InetAddressClass.INET6_ADDRESS,\n@@ -110,1 +125,1 @@\n-                Arguments.of(InetAddressClass.INET4_ADDRESS,\n+                Arguments.of(InetAddressClass.INET6_ADDRESS,\n@@ -160,0 +175,19 @@\n+\n+        \/\/ Generate addresses for loopback and wildcard address test cases\n+        var loopbackAndWildcardAddresses = List.of(\n+                \/\/ Loopback address\n+                InetAddress.getLoopbackAddress(),\n+                \/\/ IPv6 wildcard address\n+                InetAddress.getByName(\"::\"),\n+                \/\/ IPv4 wildcard address\n+                InetAddress.getByName(\"0.0.0.0\"));\n+\n+        \/\/ Get addresses for all network interfaces available,\n+        \/\/ and construct a test case for each. And then combine\n+        \/\/ them with loopback\/wildcard test cases.\n+        Stream<Arguments> hostAddressArguments = Stream.concat(\n+                        NetworkInterface.networkInterfaces()\n+                                .flatMap(NetworkInterface::inetAddresses),\n+                        loopbackAndWildcardAddresses.stream())\n+                .flatMap(OfLiteralTest::addressToValidTestCases);\n+        return Stream.concat(validLiterals, hostAddressArguments);\n@@ -166,5 +200,1 @@\n-        Executable executable = switch (inetAddressClass) {\n-            case INET_ADDRESS -> () -> InetAddress.ofLiteral(addressLiteral);\n-            case INET4_ADDRESS -> () -> Inet4Address.ofLiteral(addressLiteral);\n-            case INET6_ADDRESS -> () -> Inet6Address.ofLiteral(addressLiteral);\n-        };\n+        var executable = constructExecutable(inetAddressClass, addressLiteral);\n@@ -175,0 +205,7 @@\n+    @ParameterizedTest\n+    @EnumSource(InetAddressClass.class)\n+    public void nullLiteral(InetAddressClass inetAddressClass) {\n+        var executable = constructExecutable(inetAddressClass, null);\n+        assertThrows(NullPointerException.class, executable);\n+    }\n+\n@@ -176,1 +213,1 @@\n-        return Stream.of(\n+        Stream<Arguments> argumentsStream = Stream.of(\n@@ -186,4 +223,0 @@\n-                \/\/ IPv4-mapped IPv6 addresses not parsable by Inet6Address.ofLiteral\n-                Arguments.of(InetAddressClass.INET6_ADDRESS, \"::FFFF:129.144.52.38\"),\n-                Arguments.of(InetAddressClass.INET6_ADDRESS, \"[::ffff:1.2.3.4]\"),\n-\n@@ -205,0 +238,10 @@\n+                \/\/ IPv4-mapped IPv6 address with scope-id\n+                Arguments.of(InetAddressClass.INET6_ADDRESS,\n+                        \"::FFFF:129.144.52.38%1\"),\n+\n+                \/\/ IPv4-mapped IPv6 addresses cannot be parsed by Inet4Address.ofLiteral\n+                Arguments.of(InetAddressClass.INET4_ADDRESS,\n+                        \"::FFFF:129.144.52.38\"),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS,\n+                        \"[::ffff:1.2.3.4]\"),\n+\n@@ -213,0 +256,41 @@\n+        \/\/ Construct arguments for a test case with IPv6-scoped address with scope-id\n+        \/\/ specified as a string with non-existing network interface name\n+        String ifName = generateNonExistingIfName();\n+        Stream<Arguments> nonExistingIFinScope = ifName.isBlank() ? Stream.empty() :\n+                Stream.of(Arguments.of(InetAddressClass.INET6_ADDRESS,\n+                        \"2001:db8:a0b:12f0::1%\" + ifName));\n+        return Stream.concat(argumentsStream, nonExistingIFinScope);\n+    }\n+\n+    private static Stream<Arguments> addressToValidTestCases(InetAddress inetAddress) {\n+        String addressLiteral = inetAddress.getHostAddress();\n+        byte[] expectedAddressBytes = inetAddress.getAddress();\n+\n+        InetAddressClass addressClass = switch (inetAddress) {\n+            case Inet4Address i4 -> InetAddressClass.INET4_ADDRESS;\n+            case Inet6Address i6 -> InetAddressClass.INET6_ADDRESS;\n+            case InetAddress ia -> InetAddressClass.INET_ADDRESS;\n+        };\n+        return Stream.of(\n+                Arguments.of(InetAddressClass.INET_ADDRESS, addressLiteral, expectedAddressBytes),\n+                Arguments.of(addressClass, addressLiteral, expectedAddressBytes));\n+    }\n+\n+    private static String generateNonExistingIfName() {\n+        try {\n+            return NetworkInterface\n+                    .networkInterfaces()\n+                    .map(NetworkInterface::getName)\n+                    .collect(Collectors.joining())\n+                    .strip();\n+        } catch (SocketException e) {\n+            return \"\";\n+        }\n+    }\n+\n+    private static Executable constructExecutable(InetAddressClass inetAddressClass, String input) {\n+        return switch (inetAddressClass) {\n+            case INET_ADDRESS -> () -> InetAddress.ofLiteral(input);\n+            case INET4_ADDRESS -> () -> Inet4Address.ofLiteral(input);\n+            case INET6_ADDRESS -> () -> Inet6Address.ofLiteral(input);\n+        };\n","filename":"test\/jdk\/java\/net\/InetAddress\/OfLiteralTest.java","additions":104,"deletions":20,"binary":false,"changes":124,"status":"modified"}]}