{"files":[{"patch":"@@ -61,1 +61,1 @@\n- * format convenient for specifying Class B net- work addresses as\n+ * format convenient for specifying Class B network addresses as\n@@ -73,0 +73,23 @@\n+ * <p> These forms support parts specified in decimal format only.\n+ * For example, the following forms are supported by methods capable\n+ * of parsing textual representations of IPv4 addresses:\n+ * {@snippet :\n+ *  \/\/ Dotted-decimal 'd.d.d.d' form with four part address literal\n+ *  InetAddress.getByName(\"007.008.009.010\"); \/\/ ==> \/7.8.9.10\n+ *  InetAddress.getByName(\"127.0.1.1\");       \/\/ ==> \/127.0.1.1\n+ *\n+ *  \/\/ Dotted-decimal 'd.d.d' form with three part address literal,\n+ *  \/\/ the last part is placed in the right most two bytes\n+ *  \/\/ of the constructed address\n+ *  InetAddress.getByName(\"127.0.257\"); \/\/ ==> \/127.0.1.1\n+ *\n+ *  \/\/ Dotted-decimal 'd.d' form with two part address literal,\n+ *  \/\/ the last part is placed in the right most three bytes\n+ *  \/\/ of the constructed address\n+ *  Inet4Address.ofLiteral(\"127.257\"); \/\/ ==> \/127.0.1.1\n+ *\n+ *  \/\/ 'd' form with one decimal value that is stored directly in\n+ *  \/\/ the constructed address bytes without any rearrangement\n+ *  Inet4Address.ofLiteral(\"02130706689\"); \/\/ ==> \/127.0.1.1\n+ * }\n+ *\n@@ -141,25 +164,5 @@\n-     * Creates an {@code Inet4Address} based on the provided textual representation of\n-     * an IPv4 address.\n-     * <p>The following IPv4 address {@linkplain Inet4Address##format\n-     * textual representations} are supported by this method:\n-     * {@snippet :\n-     *  \/\/ Dotted-decimal 'd.d.d.d' form with four part address literal\n-     *  Inet4Address.ofLiteral(\"7.08.9.010\") ==> \/7.8.9.10\n-     *\n-     *  \/\/ Dotted-decimal 'd.d.d' form with three part address literal,\n-     *  \/\/ the last part is placed in the right most two bytes\n-     *  \/\/ of the constructed address\n-     *  Inet4Address.ofLiteral(\"127.0.257\") ==> \/127.0.1.1\n-     *\n-     *  \/\/ Dotted-decimal 'd.d' form with two part address literal,\n-     *  \/\/ the last part is placed in the right most three bytes\n-     *  \/\/ of the constructed address\n-     *  Inet4Address.ofLiteral(\"127.257\") ==> \/127.0.1.1\n-     *\n-     *  \/\/ 'd' form with one decimal value that is stored directly in\n-     *  \/\/ the constructed address bytes without any rearrangement\n-     *  Inet4Address.ofLiteral(\"02130706689\") ==> \/127.0.1.1\n-     * }\n-     * <p>If the provided address literal cannot represent a valid IPv4 address an\n-     * {@code IllegalArgumentException} is thrown.\n-     * <p>This method doesn't block, i.e. no reverse lookup is performed.\n+     * Creates an {@code Inet4Address} based on the provided {@linkplain\n+     * Inet4Address##format textual representations} of an IPv4 address.\n+     * <p> If the provided IPv4 address literal cannot represent a {@linkplain\n+     * Inet4Address##format valid IPv4 address} an {@code IllegalArgumentException} is thrown.\n+     * <p> This method doesn't block, i.e. no reverse lookup is performed.\n@@ -169,1 +172,1 @@\n-     *         from the IPv4 address literal.\n+     *         from the provided IPv4 address literal.\n@@ -180,5 +183,5 @@\n-     * Parses string as an IPv4 address literal.\n-     * If string contains a non-parsable literal and {@code throwIAE} is set to {@code false}\n-     * - {@code null} is returned.\n-     * If string contains a non-parsable literal and {@code throwIAE} is set to {@code true}\n-     * - {@code IllegalArgumentException} is thrown.\n+     * Parses the given string as an IPv4 address literal.\n+     * If the given {@code addressLiteral} string cannot be parsed as an IPv4 address literal\n+     * and {@code throwIAE} is {@code false}, {@code null} is returned.\n+     * If the given {@code addressLiteral} string cannot be parsed as an IPv4 address literal\n+     * and {@code throwIAE} is {@code true}, an {@code IllegalArgumentException} is thrown.\n@@ -189,2 +192,3 @@\n-     * @param throwIAE throw {@code IllegalArgumentException} if the\n-     *                 literal cannot be parsed as an IPv4 address literal.\n+     * @param throwIAE whether to throw {@code IllegalArgumentException} if the\n+     *                 given {@code addressLiteral} string cannot be parsed as\n+     *                 an IPv4 address literal.\n@@ -193,3 +197,6 @@\n-     * @throws IllegalArgumentException if ambiguous IPv4 literal is specified,\n-     * or non-parsable IPv4 literal is specified with {@code throwIAE} set to\n-     * {@code true}.\n+     * @throws IllegalArgumentException if the given {@code addressLiteral} string\n+     * cannot be parsed as an IPv4 address literal and {@code throwIAE} is {@code true}.\n+     * An {@code IllegalArgumentException} is also thrown regardless of the value of\n+     * {@code throwIAE} if the given {@code addressLiteral} string is ambiguous, that is,\n+     * it cannot be parsed as a valid IPv4 address literal using decimal notation but could be\n+     * interpreted as an IPv4 address in some other representation (octal, hexadecimal, or mixed).\n","filename":"src\/java.base\/share\/classes\/java\/net\/Inet4Address.java","additions":44,"deletions":37,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n- * <h3> Special IPv6 address <\/h3>\n+ * <h3><a id=\"special-ipv6-address\">Special IPv6 address<\/a><\/h3>\n@@ -177,0 +177,12 @@\n+ * <p> Methods of {@code InetAddress} and {@code Inet6Address} that accept a\n+ * textual representation of an IPv6 address allow for that representation\n+ * to be enclosed in square brackets. For example,\n+ * {@snippet :\n+ *  \/\/ The full IPv6 form\n+ *  InetAddress.getByName(\"1080:0:0:0:8:800:200C:417A\");   \/\/ ==> \/1080:0:0:0:8:800:200c:417a\n+ *  InetAddress.getByName(\"[1080:0:0:0:8:800:200C:417A]\"); \/\/ ==> \/1080:0:0:0:8:800:200c:417a\n+ *\n+ *  \/\/ IPv6 scoped address with scope-id as string\n+ *  Inet6Address.ofLiteral(\"fe80::1%en0\");   \/\/ ==> \/fe80:0:0:0:0:0:0:1%en0\n+ *  Inet6Address.ofLiteral(\"[fe80::1%en0]\"); \/\/ ==> \/fe80:0:0:0:0:0:0:1%en0\n+ * }\n@@ -487,25 +499,9 @@\n-     * Creates an {@code InetAddress} based on the provided textual representation of\n-     * an IPv6 address.\n-     * <p>The following IPv6 address {@linkplain Inet6Address##format\n-     * textual representations} are supported by this method:\n-     * {@snippet :\n-     *  \/\/ The full IPv6 form\n-     *  Inet6Address.ofLiteral(\"1080:0:0:0:8:800:200C:417A\") ==> \/1080:0:0:0:8:800:200c:417a\n-     *\n-     *  \/\/ The compressed IPv6 form with multiple groups of 16-bits of\n-     *  \/\/ zero replaced with \"::\"\n-     *  Inet6Address.ofLiteral(\"1080::8:800:200C:417A\") ==> \/1080:0:0:0:8:800:200c:417a\n-     *\n-     *  \/\/ IPv4-mapped IPv6 form\n-     *  Inet6Address.ofLiteral(\"::FFFF:129.144.52.38\") ==> \/129.144.52.38\n-     *\n-     *  \/\/ IPv4-compatible IPv6 form\n-     *  Inet6Address.ofLiteral(\"::129.144.52.38\") ==> \/0:0:0:0:0:0:8190:3426\n-     *\n-     *  \/\/ IPv6 scoped address form with scope-id as numeric identifier\n-     *  Inet6Address.ofLiteral(\"fe80::1%1\") ==> \/fe80:0:0:0:0:0:0:1%1\n-     *\n-     *  \/\/ IPv6 scoped address with scope-id as string\n-     *  Inet6Address.ofLiteral(\"fe80::1%en0\") ==> \/fe80:0:0:0:0:0:0:1%en0\n-     * }\n-     * All IPv6 address literal forms listed above are also supported when enclosed in\n+     * Creates an {@code InetAddress} based on the provided {@linkplain\n+     * Inet6Address##format textual representations} of an IPv6 address.\n+     * <p> If the provided address literal cannot represent {@linkplain Inet6Address##format\n+     * a valid IPv6 address} an {@code IllegalArgumentException} is thrown.\n+     * An {@code IllegalArgumentException} is also thrown if an IPv6 scoped address literal\n+     * contains a scope-id that doesn't map to any network interface on the system, or\n+     * if a scope-id is present in an IPv4-mapped IPv6 address literal.\n+     * <p> This method doesn't block, i.e. no reverse lookup is performed.\n+     * <p> Note that IPv6 address literal forms are also supported when enclosed in\n@@ -513,5 +509,3 @@\n-     * <p>If the provided address literal cannot represent a valid IP address an\n-     * {@code IllegalArgumentException} is thrown. For instance, if an IPv6 scoped\n-     *  address literal contains a scope-id that doesn't map to any network interface\n-     *  on the system, or if a scope-id is present in an IPv4-mapped IPv6 address literal.\n-     * <p>This method doesn't block, i.e. no reverse lookup is performed.\n+     * Note also that if the supplied literal represents an {@linkplain\n+     * Inet6Address##special-ipv6-address IPv4-mapped IPv6 address} an\n+     * instance of {@code Inet4Address} is returned.\n@@ -520,2 +514,2 @@\n-     * @return an {@link Inet6Address} object with no hostname set, and constructed\n-     *         from the IPv6 address literal.\n+     * @return an {@link InetAddress} object with no hostname set, and constructed\n+     *         from the provided IPv6 address literal.\n","filename":"src\/java.base\/share\/classes\/java\/net\/Inet6Address.java","additions":27,"deletions":33,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -1719,1 +1719,1 @@\n-     *         from the IP address literal.\n+     *         from the provided IP address literal.\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -281,0 +281,5 @@\n+            \/\/ At least two network interfaces are required to generate\n+            \/\/ a non-existing interface name\n+            if (NetworkInterface.networkInterfaces().count() < 2) {\n+                return \"\";\n+            }\n","filename":"test\/jdk\/java\/net\/InetAddress\/OfLiteralTest.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}