{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.net.*;\n@@ -140,1 +139,1 @@\n-                        byte[] ip = IPAddressUtil.validateNumericFormatV4(hoststr);\n+                        byte[] ip = IPAddressUtil.validateNumericFormatV4(hoststr, false);\n","filename":"src\/java.base\/share\/classes\/java\/net\/HostPortrange.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import sun.net.util.IPAddressUtil;\n+\n@@ -137,0 +139,55 @@\n+    \/**\n+     * Creates an {@code Inet4Address} based on the provided IPv4 address literal.\n+     * <p> IPv4 address literals in dotted-decimal form and\n+     * <a href=\"Inet6Address.html#format\">IPv4-compatible IPv6 address<\/a> literals\n+     * are supported. For example, the following literals are valid literals in\n+     * dotted-decimal form:\n+     *\n+     *   <blockquote><ul style=\"list-style-type:none\">\n+     *   <li>{@code 1.2.3.4}<\/li>\n+     *   <li>{@code 06.07.08.09}<\/li>\n+     *   <\/ul><\/blockquote>\n+     *\n+     * <p> This method doesn't block, i.e. the system-wide {@linkplain\n+     * java.net.spi.InetAddressResolver resolver} is not queried to resolve\n+     * the provided literal, and no reverse lookup is performed.\n+     *\n+     * @param addressLiteral the IPv4 address literal.\n+     * @return an {@link Inet4Address} object with no hostname set constructed from the\n+     *         IPv4 address literal.\n+     * @throws IllegalArgumentException if literal cannot be parsed as an IPv4 address literal.\n+     *\/\n+    public static Inet4Address ofLiteral(String addressLiteral) {\n+        \/\/ Try to parse IPv4-compatible IPv6 addresses first\n+        try {\n+            InetAddress inetAddress = Inet6Address.parseAddressString(addressLiteral,\n+                                                       true);\n+            if (inetAddress instanceof Inet4Address ipv4compAddress) {\n+                return ipv4compAddress;\n+            }\n+        } catch (UnknownHostException uhe) {\n+            \/\/ If address literal is not an IPv4-compatible IPv6 address - continue parsing\n+            \/\/ it as an IPv4 address literal\n+        }\n+        return parseAddressString(addressLiteral, true);\n+    }\n+\n+    \/**\n+     * Parses string with an IPv4 address literal.\n+     * If string doesn't contain a valid literal - null is returned.\n+     * @param addressLiteral IPv4 address literal to parse\n+     * @param throwIAE throw {@code IllegalArgumentException} if literal\n+     *                 cannot be parsed as an IPv4 address literal.\n+     * @return {@code Inet4Address} object constructed from the address literal;\n+     *         or {@@code null} if the literal cannot be parsed as an IPv4 address\n+     * @throws IllegalArgumentException if ambiguous IPv4 literal is specified,\n+     * or non-parsable IPv4 literal is specified with {@code throwIAE} set to \"true\".\n+     *\/\n+    static Inet4Address parseAddressString(String addressLiteral, boolean throwIAE) {\n+        byte [] addrBytes= IPAddressUtil.validateNumericFormatV4(addressLiteral, throwIAE);\n+        if (addrBytes == null) {\n+            return null;\n+        }\n+        return new Inet4Address(null, addrBytes);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/Inet4Address.java","additions":58,"deletions":1,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import sun.net.util.IPAddressUtil;\n+\n@@ -142,1 +144,2 @@\n- * addressing architecture is described in [draft-ietf-ipngwg-scoping-arch-04.txt].\n+ * addressing architecture is described in <a href=\"https:\/\/www.rfc-editor.org\/info\/rfc4007\">\n+ * <i>RFC&nbsp;4007: IPv6 Scoped Address Architecture<\/i><\/a>.\n@@ -175,0 +178,2 @@\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc4007\n+ *      RFC 4007: IPv6 Scoped Address Architecture\n@@ -480,0 +485,110 @@\n+    \/**\n+     * Creates an {@code Inet6Address} based on the provided IPv6 address literal.\n+     * <p> This method doesn't block, i.e. the system-wide {@linkplain\n+     * java.net.spi.InetAddressResolver resolver} is not queried to resolve\n+     * the provided literal, and no reverse lookup is performed.\n+     * @implNote <a href=\"Inet6Address.html#special-ipv6-address-heading\">\n+     * IPv4-mapped IPv6 address literals<\/a> are treated as invalid by this method.\n+     * <p>{@link InetAddress#ofLiteral(String)} can be used to parse IPv4-mapped IPv6\n+     * address literals.\n+     *\n+     * @param addressLiteral the IPv6 address literal.\n+     * @return an {@link Inet6Address} object with no hostname set constructed from the\n+     *         IPv6 address literal.\n+     * @throws IllegalArgumentException if literal cannot be parsed as an IPv6 address literal.\n+     *\/\n+    public static Inet6Address ofLiteral(String addressLiteral) {\n+        try {\n+            InetAddress inetAddress = parseAddressString(addressLiteral, true);\n+            \/\/ IPv4-mapped IPv6 address literals are rejected\n+            if (inetAddress instanceof Inet6Address inet6Address) {\n+                return inet6Address;\n+            }\n+        } catch (UnknownHostException uhe) {\n+            \/\/ Error constructing Inet6Address from address literal containing\n+            \/\/ a network interface name\n+        }\n+        throw IPAddressUtil.invalidIpAddressLiteral(addressLiteral);\n+    }\n+\n+    \/**\n+     * Method tries to parse IPv6 or IPv4-mapped IPv6 address string as a literal IP address.\n+     * If string doesn't contain valid literal - null is returned.\n+     * If there is an issue with constructing {@link InetAddress} from parsed bytes -\n+     * UnknownHostException is thrown.\n+     *\n+     * @param addressLiteral literal IP address\n+     * @param removeSqBrackets if {@code \"true\"} remove outer square brackets\n+     * @return {@link Inet6Address} or {@link Inet4Address} object constructed from\n+     * literal IP address string\n+     * @throws UnknownHostException if literal IP address string cannot be parsed\n+     * as IPv6 or IPv4-mapped IPv6 address literals.\n+     *\/\n+    static InetAddress parseAddressString(String addressLiteral, boolean removeSqBrackets)\n+            throws UnknownHostException {\n+        \/\/ Remove trailing and leading square brackets if requested\n+        if (removeSqBrackets && addressLiteral.charAt(0) == '[' &&\n+                addressLiteral.length() > 2 &&\n+                addressLiteral.charAt(addressLiteral.length() - 1) == ']') {\n+            addressLiteral = addressLiteral.substring(1, addressLiteral.length() - 1);\n+        }\n+        int pos, numericZone = -1;\n+        String ifname = null;\n+        if ((pos = addressLiteral.indexOf('%')) != -1) {\n+            numericZone = checkNumericZone(addressLiteral);\n+            if (numericZone == -1) {\n+                \/* remainder of string must be an ifname *\/\n+                ifname = addressLiteral.substring(pos + 1);\n+            }\n+        }\n+        byte[] addrBytes = IPAddressUtil.textToNumericFormatV6(addressLiteral);\n+        if (addrBytes == null) {\n+            return null;\n+        }\n+        \/\/ IPv4-mapped IPv6 address\n+        if (addrBytes.length == Inet4Address.INADDRSZ) {\n+            if (numericZone != -1 || ifname != null) {\n+                \/\/ IPv4-mapped address must not contain zone-id\n+                throw new UnknownHostException(addressLiteral + \": invalid IPv4-mapped address\");\n+            }\n+            return new Inet4Address(null, addrBytes);\n+        }\n+        if (ifname != null) {\n+            return new Inet6Address(null, addrBytes, ifname);\n+        } else {\n+            return new Inet6Address(null, addrBytes, numericZone);\n+        }\n+    }\n+\n+    \/**\n+     * Check if the literal address string has %nn appended\n+     * returns -1 if not, or the numeric value otherwise.\n+     * <p>\n+     * %nn may also be a string that represents the displayName of\n+     * a currently available NetworkInterface.\n+     *\/\n+    private static int checkNumericZone(String s) {\n+        int percent = s.indexOf('%');\n+        int slen = s.length();\n+        int digit, zone = 0;\n+        int multmax = Integer.MAX_VALUE \/ 10; \/\/ for int overflow detection\n+        if (percent == -1) {\n+            return -1;\n+        }\n+        for (int i = percent + 1; i < slen; i++) {\n+            char c = s.charAt(i);\n+            if ((digit = IPAddressUtil.parseAsciiDigit(c, 10)) < 0) {\n+                return -1;\n+            }\n+            if (zone > multmax) {\n+                return -1;\n+            }\n+            zone = (zone * 10) + digit;\n+            if (zone < 0) {\n+                return -1;\n+            }\n+\n+        }\n+        return zone;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/Inet6Address.java","additions":117,"deletions":2,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -1420,1 +1420,1 @@\n-                addrArray = IPAddressUtil.validateNumericFormatV4(addrStr);\n+                addrArray = IPAddressUtil.validateNumericFormatV4(addrStr, false);\n@@ -1647,4 +1647,1 @@\n-            byte[] addr = null;\n-            int numericZone = -1;\n-            String ifname = null;\n-\n+            InetAddress inetAddress = null;\n@@ -1654,1 +1651,2 @@\n-                    addr = IPAddressUtil.validateNumericFormatV4(host);\n+                    \/\/ Here we check the address string for ambiguity only\n+                    inetAddress = Inet4Address.parseAddressString(host, false);\n@@ -1661,11 +1659,5 @@\n-            if (addr == null) {\n-                \/\/ Try to parse host string as an IPv6 literal\n-                \/\/ Check if a numeric or string zone id is present first\n-                int pos;\n-                if ((pos = host.indexOf('%')) != -1) {\n-                    numericZone = checkNumericZone(host);\n-                    if (numericZone == -1) { \/* remainder of string must be an ifname *\/\n-                        ifname = host.substring(pos + 1);\n-                    }\n-                }\n-                if ((addr = IPAddressUtil.textToNumericFormatV6(host)) == null &&\n+            if (inetAddress == null) {\n+                \/\/ This is supposed to be an IPv6 literal\n+                \/\/ Check for presence of a numeric or string zone id\n+                \/\/ is done in Inet6Address.parseAddressString\n+                if ((inetAddress = Inet6Address.parseAddressString(host, false)) == null &&\n@@ -1676,16 +1668,2 @@\n-            if(addr != null) {\n-                InetAddress[] ret = new InetAddress[1];\n-                if (addr.length == Inet4Address.INADDRSZ) {\n-                    if (numericZone != -1 || ifname != null) {\n-                        \/\/ IPv4-mapped address must not contain zone-id\n-                        throw new UnknownHostException(host + \": invalid IPv4-mapped address\");\n-                    }\n-                    ret[0] = new Inet4Address(null, addr);\n-                } else {\n-                    if (ifname != null) {\n-                        ret[0] = new Inet6Address(null, addr, ifname);\n-                    } else {\n-                        ret[0] = new Inet6Address(null, addr, numericZone);\n-                    }\n-                }\n-                return ret;\n+            if (inetAddress != null) {\n+                return new InetAddress[]{inetAddress};\n@@ -1721,33 +1699,0 @@\n-\n-    \/**\n-     * check if the literal address string has %nn appended\n-     * returns -1 if not, or the numeric value otherwise.\n-     *\n-     * %nn may also be a string that represents the displayName of\n-     * a currently available NetworkInterface.\n-     *\/\n-    private static int checkNumericZone (String s) throws UnknownHostException {\n-        int percent = s.indexOf ('%');\n-        int slen = s.length();\n-        int digit, zone=0;\n-        int multmax = Integer.MAX_VALUE \/ 10; \/\/ for int overflow detection\n-        if (percent == -1) {\n-            return -1;\n-        }\n-        for (int i=percent+1; i<slen; i++) {\n-            char c = s.charAt(i);\n-            if ((digit = IPAddressUtil.parseAsciiDigit(c, 10)) < 0) {\n-                return -1;\n-            }\n-            if (zone > multmax) {\n-                return -1;\n-            }\n-            zone = (zone * 10) + digit;\n-            if (zone < 0) {\n-                return -1;\n-            }\n-\n-        }\n-        return zone;\n-    }\n-\n@@ -1762,0 +1707,26 @@\n+    \/**\n+     * Creates an {@code InetAddress} based on the provided IP address literal.\n+     * <p> This method doesn't block, i.e. the system-wide {@linkplain\n+     * java.net.spi.InetAddressResolver resolver} is not queried to resolve\n+     * the provided literal, and no reverse lookup is performed.\n+     *\n+     * @param addressLiteral the IP address literal.\n+     * @return an {@link InetAddress} object with no hostname set constructed from the IP\n+     *         address literal.\n+     * @throws IllegalArgumentException if literal cannot be parsed as an IPv4 or IPv6\n+     *                                  address literal.\n+     *\/\n+    public static InetAddress ofLiteral(String addressLiteral) throws IllegalArgumentException {\n+        InetAddress inetAddress = Inet4Address.parseAddressString(addressLiteral, false);\n+        if (inetAddress == null) {\n+            try {\n+                inetAddress = Inet6Address.parseAddressString(addressLiteral, true);\n+            } catch(UnknownHostException uhe) {\n+            }\n+        }\n+        if (inetAddress == null) {\n+            throw IPAddressUtil.invalidIpAddressLiteral(addressLiteral);\n+        }\n+        return inetAddress;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":37,"deletions":66,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,1 +137,1 @@\n-     * {@code IllegalArgumentException} is thrown.\n+     * either {@code IllegalArgumentException} is thrown, or {@code \"null\"} is returned.\n@@ -140,0 +140,2 @@\n+     * @param throwIAE {@code \"true\"} - throw {@code IllegalArgumentException} when cannot be parsed as IPv4 address string;\n+     *                 {@code \"false\"} - throw {@code \"IllegalArgumentException\"} only when IPv4 address string is ambiguous.\n@@ -142,1 +144,3 @@\n-     *                                  \"false\" and IPv4 address string {@code \"src\"} is ambiguous\n+     *                                  \"false\", IPv4 address string {@code \"src\"} is ambiguous,\n+     *                                  or when address string cannot be parsed as IPv4 address and\n+     *                                  {@code \"throwIAE\"} is set to {@code \"true\"}.\n@@ -144,1 +148,1 @@\n-    public static byte[] validateNumericFormatV4(String src) {\n+    public static byte[] validateNumericFormatV4(String src, boolean throwIAE) {\n@@ -148,1 +152,4 @@\n-            throw new IllegalArgumentException(\"Invalid IP address literal: \" + src);\n+            throw invalidIpAddressLiteral(src);\n+        }\n+        if (parsedBytes == null && throwIAE) {\n+            throw invalidIpAddressLiteral(src);\n@@ -153,0 +160,10 @@\n+    \/**\n+     * Creates {@code IllegalArgumentException} with invalid IP address literal message.\n+     *\n+     * @param src address literal string to include to the exception message\n+     * @return an {@code IllegalArgumentException} instance\n+     *\/\n+    public static IllegalArgumentException invalidIpAddressLiteral(String src) {\n+        return new IllegalArgumentException(\"Invalid IP address literal: \" + src);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/net\/util\/IPAddressUtil.java","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,221 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8272215\n+ * @summary Test for ofLiteral API in InetAddress classes\n+ * @run junit\/othervm -Djdk.net.hosts.file=nonExistingHostsFile.txt\n+ *                     OfLiteralTest\n+ *\/\n+\n+import org.junit.Assert;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.api.function.Executable;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+public class OfLiteralTest {\n+\n+    @ParameterizedTest\n+    @MethodSource(\"validLiteralArguments\")\n+    public void validLiteral(InetAddressClass inetAddressClass,\n+                             String addressLiteral,\n+                             byte[] expectedAddressBytes) throws Exception {\n+        InetAddress ofLiteralResult = switch (inetAddressClass) {\n+            case INET_ADDRESS -> InetAddress.ofLiteral(addressLiteral);\n+            case INET4_ADDRESS -> Inet4Address.ofLiteral(addressLiteral);\n+            case INET6_ADDRESS -> Inet6Address.ofLiteral(addressLiteral);\n+        };\n+        InetAddress getByNameResult = InetAddress.getByName(addressLiteral);\n+        Assert.assertArrayEquals(expectedAddressBytes, ofLiteralResult.getAddress());\n+        Assert.assertEquals(getByNameResult, ofLiteralResult);\n+    }\n+\n+    private static Stream<Arguments> validLiteralArguments() {\n+        \/\/ 1080:0:0:0:8:800:200C:417A address bytes\n+        byte[] ipv6AddressExpBytes = new byte[]{16, -128, 0, 0, 0, 0, 0, 0, 0,\n+                8, 8, 0, 32, 12, 65, 122};\n+\n+        \/\/ ::129.144.52.38 address bytes\n+        byte[] ipv4CompIpv6ExpBytes = new byte[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, -127, -112, 52, 38};\n+\n+        \/\/ 222.173.190.239 address bytes\n+        byte[] ipv4ExpBytes = new byte[]{(byte) 222, (byte) 173,\n+                (byte) 190, (byte) 239};\n+\n+        \/\/ 222.173.190.39 address bytes\n+        byte[] ipv4ExpBytes2 = new byte[]{(byte) 222, (byte) 173,\n+                (byte) 190, 39};\n+\n+        \/\/ 1.2.3.4 address bytes\n+        byte[] oneToFourAddressExpBytes = new byte[]{1, 2, 3, 4};\n+\n+        \/\/ 6.7.8.9 address bytes\n+        byte[] sixtoNineAddressExpBytes = new byte[]{6, 7, 8, 9};\n+\n+        \/\/ ::FFFF:129.144.52.38 address bytes\n+        byte[] ipv6Ipv4MappedAddressExpBytes = new byte[]{\n+                (byte) 129, (byte) 144, 52, 38};\n+\n+        return Stream.of(\n+                \/\/ IPv6 address literals are parsable by Inet6Address.ofLiteral\n+                \/\/ and InetAddress.ofLiteral methods\n+                Arguments.of(InetAddressClass.INET6_ADDRESS,\n+                        \"1080:0:0:0:8:800:200C:417A\", ipv6AddressExpBytes),\n+                Arguments.of(InetAddressClass.INET6_ADDRESS,\n+                        \"[1080:0::8:800:200C:417A]\", ipv6AddressExpBytes),\n+                Arguments.of(InetAddressClass.INET_ADDRESS,\n+                        \"1080:0::8:800:200C:417A\", ipv6AddressExpBytes),\n+                Arguments.of(InetAddressClass.INET_ADDRESS,\n+                        \"[1080:0:0:0:8:800:200C:417A]\", ipv6AddressExpBytes),\n+\n+                \/\/ IPv4-mapped IPv6 address literals are parsable by\n+                \/\/ InetAddress.ofLiteral and Inet4Address.ofLiteral methods\n+                Arguments.of(InetAddressClass.INET_ADDRESS,\n+                        \"::FFFF:129.144.52.38\", ipv6Ipv4MappedAddressExpBytes),\n+                Arguments.of(InetAddressClass.INET_ADDRESS,\n+                        \"[::ffff:1.2.3.4]\", oneToFourAddressExpBytes),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS,\n+                        \"::FFFF:129.144.52.38\", ipv6Ipv4MappedAddressExpBytes),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS,\n+                        \"[::ffff:1.2.3.4]\", oneToFourAddressExpBytes),\n+\n+                \/\/ IPv4-compatible IPv6 address literals are parsable by\n+                \/\/ Inet6Address.ofLiteral and InetAddress.ofLiteral methods\n+                Arguments.of(InetAddressClass.INET6_ADDRESS,\n+                        \"::129.144.52.38\", ipv4CompIpv6ExpBytes),\n+                Arguments.of(InetAddressClass.INET6_ADDRESS,\n+                        \"[::129.144.52.38]\", ipv4CompIpv6ExpBytes),\n+                Arguments.of(InetAddressClass.INET_ADDRESS,\n+                        \"::129.144.52.38\", ipv4CompIpv6ExpBytes),\n+                Arguments.of(InetAddressClass.INET_ADDRESS,\n+                        \"[::129.144.52.38]\", ipv4CompIpv6ExpBytes),\n+\n+                \/\/ Tests for IPv4 address literal forms\n+                \/\/      form:'d.d.d.d' method:Inet4Address.ofLiteral\n+                Arguments.of(InetAddressClass.INET4_ADDRESS,\n+                        \"222.173.190.239\", ipv4ExpBytes),\n+                \/\/      form:'d.d.d.d' with decimal octet with leading zero\n+                Arguments.of(InetAddressClass.INET4_ADDRESS,\n+                        \"222.173.190.039\", ipv4ExpBytes2),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS,\n+                        \"06.07.08.09\", sixtoNineAddressExpBytes),\n+                \/\/      form:'d.d.d.d' method:InetAddress.ofLiteral\n+                Arguments.of(InetAddressClass.INET_ADDRESS,\n+                        \"222.173.190.239\", ipv4ExpBytes),\n+                \/\/      form:'d.d.d' method:Inet4Address.ofLiteral\n+                Arguments.of(InetAddressClass.INET4_ADDRESS,\n+                        \"222.173.48879\", ipv4ExpBytes),\n+                \/\/      form:'d.d.d' method:InetAddress.ofLiteral\n+                Arguments.of(InetAddressClass.INET_ADDRESS,\n+                        \"222.173.48879\", ipv4ExpBytes),\n+                \/\/      form:'d.d' method:Inet4Address.ofLiteral\n+                Arguments.of(InetAddressClass.INET4_ADDRESS,\n+                        \"222.11386607\", ipv4ExpBytes),\n+                \/\/      form:'d.d' method:InetAddress.ofLiteral\n+                Arguments.of(InetAddressClass.INET_ADDRESS,\n+                        \"222.11386607\", ipv4ExpBytes),\n+                \/\/      form:'d' method:Inet4Address.ofLiteral\n+                Arguments.of(InetAddressClass.INET4_ADDRESS,\n+                        \"3735928559\", ipv4ExpBytes),\n+                \/\/      form:'d' method:InetAddress.ofLiteral\n+                Arguments.of(InetAddressClass.INET_ADDRESS,\n+                        \"3735928559\", ipv4ExpBytes),\n+                \/\/      form:'d' method:InetAddress.ofLiteral -\n+                \/\/      with leading 0 that is discarded and address\n+                \/\/      parsed as decimal\n+                Arguments.of(InetAddressClass.INET_ADDRESS,\n+                        \"03735928559\", ipv4ExpBytes)\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"invalidLiteralArguments\")\n+    public void invalidLiteral(InetAddressClass inetAddressClass,\n+                               String addressLiteral) {\n+        Executable executable = switch (inetAddressClass) {\n+            case INET_ADDRESS -> () -> InetAddress.ofLiteral(addressLiteral);\n+            case INET4_ADDRESS -> () -> Inet4Address.ofLiteral(addressLiteral);\n+            case INET6_ADDRESS -> () -> Inet6Address.ofLiteral(addressLiteral);\n+        };\n+        var exception = assertThrows(IllegalArgumentException.class, executable);\n+        System.err.println(\"Expected exception observed: \" + exception);\n+    }\n+\n+    private static Stream<Arguments> invalidLiteralArguments() {\n+        return Stream.of(\n+                \/\/ IPv4 address wrapped in square brackets\n+                Arguments.of(InetAddressClass.INET_ADDRESS, \"[1.2.3.4]\"),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS, \"[1.2.3.4]\"),\n+                Arguments.of(InetAddressClass.INET6_ADDRESS, \"[1.2.3.4]\"),\n+\n+                \/\/ IPv4 address literal with BSD-formatting\n+                Arguments.of(InetAddressClass.INET_ADDRESS, \"1.2.3.0256\"),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS, \"1.2.3.0256\"),\n+\n+                \/\/ IPv4-mapped IPv6 addresses not parsable by Inet6Address.ofLiteral\n+                Arguments.of(InetAddressClass.INET6_ADDRESS, \"::FFFF:129.144.52.38\"),\n+                Arguments.of(InetAddressClass.INET6_ADDRESS, \"[::ffff:1.2.3.4]\"),\n+\n+                \/\/ Invalid IPv4-mapped IPv6 address forms\n+                \/\/      ::FFFF:d.d.d\n+                Arguments.of(InetAddressClass.INET_ADDRESS, \"::FFFF:1.2.3\"),\n+                Arguments.of(InetAddressClass.INET6_ADDRESS, \"::FFFF:1.2.3\"),\n+\n+                \/\/      ::FFFF:d.d\n+                Arguments.of(InetAddressClass.INET_ADDRESS, \"::FFFF:1.2\"),\n+                Arguments.of(InetAddressClass.INET6_ADDRESS, \"::FFFF:1.2\"),\n+                \/\/      ::d.d.d\n+                Arguments.of(InetAddressClass.INET_ADDRESS, \"::1.2.3\"),\n+                Arguments.of(InetAddressClass.INET6_ADDRESS, \"::1.2.3\"),\n+                \/\/      ::d.d\n+                Arguments.of(InetAddressClass.INET_ADDRESS, \"::1.2\"),\n+                Arguments.of(InetAddressClass.INET6_ADDRESS, \"::1.2\"),\n+\n+                \/\/ IPv4 literals in BSD form\n+                Arguments.of(InetAddressClass.INET_ADDRESS, \"0256.1.2.3\"),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS, \"1.2.0256.3\"),\n+                Arguments.of(InetAddressClass.INET_ADDRESS, \"0x1.2.3.4\"),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS, \"1.2.0x3.4\"),\n+                Arguments.of(InetAddressClass.INET_ADDRESS, \"0xFFFFFFFF\"),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS, \"0xFFFFFFFF\")\n+        );\n+    }\n+\n+    enum InetAddressClass {\n+        INET_ADDRESS,\n+        INET4_ADDRESS,\n+        INET6_ADDRESS\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/net\/InetAddress\/OfLiteralTest.java","additions":221,"deletions":0,"binary":false,"changes":221,"status":"added"}]}