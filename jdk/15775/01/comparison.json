{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.net.*;\n@@ -140,1 +139,1 @@\n-                        byte[] ip = IPAddressUtil.validateNumericFormatV4(hoststr);\n+                        byte[] ip = IPAddressUtil.validateNumericFormatV4(hoststr, false);\n","filename":"src\/java.base\/share\/classes\/java\/net\/HostPortrange.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import sun.net.util.IPAddressUtil;\n+\n@@ -29,0 +31,1 @@\n+import java.util.Objects;\n@@ -137,0 +140,58 @@\n+    \/**\n+     * Creates an {@code Inet4Address} based on the provided textual representation of\n+     * an IPv4 address.\n+     * <p>The following IPv4 address {@linkplain Inet4Address##format\n+     * textual representations} are supported by this method:\n+     * {@snippet :\n+     *  \/\/ Dotted-decimal 'd.d.d.d' form with four part address literal\n+     *  Inet4Address.ofLiteral(\"7.08.9.010\") ==> \/7.8.9.10\n+     *\n+     *  \/\/ Dotted-decimal 'd.d.d' form with three part address literal,\n+     *  \/\/ the last part is placed in the right most two bytes\n+     *  \/\/ of the constructed address\n+     *  Inet4Address.ofLiteral(\"127.0.257\") ==> \/127.0.1.1\n+     *\n+     *  \/\/ Dotted-decimal 'd.d' form with two part address literal,\n+     *  \/\/ the last part is placed in the right most three bytes\n+     *  \/\/ of the constructed address\n+     *  Inet4Address.ofLiteral(\"127.257\") ==> \/127.0.1.1\n+     *\n+     *  \/\/ 'd' form with one decimal value that is stored directly in\n+     *  \/\/ the constructed address bytes without any rearrangement\n+     *  Inet4Address.ofLiteral(\"02130706689\") ==> \/127.0.1.1\n+     * }\n+     * <p>If the provided address literal cannot represent a valid IPv4 address an\n+     * {@code IllegalArgumentException} is thrown.\n+     * <p>This method doesn't block, i.e. no reverse lookup is performed.\n+     *\n+     * @param ipv4AddressLiteral the textual representation of an IPv4 address.\n+     * @return an {@link Inet4Address} object with no hostname set, and constructed\n+     *         from the IPv4 address literal.\n+     * @throws IllegalArgumentException if the {@code ipv4AddressLiteral} cannot be\n+     *         parsed as an IPv4 address literal.\n+     * @throws NullPointerException if the {@code ipv4AddressLiteral} is {@code null}.\n+     *\/\n+    public static Inet4Address ofLiteral(String ipv4AddressLiteral) {\n+        Objects.requireNonNull(ipv4AddressLiteral);\n+        return parseAddressString(ipv4AddressLiteral, true);\n+    }\n+\n+    \/**\n+     * Parses string with an IPv4 address literal.\n+     * If string doesn't contain a valid literal - null is returned.\n+     * @param addressLiteral IPv4 address literal to parse\n+     * @param throwIAE throw {@code IllegalArgumentException} if literal\n+     *                 cannot be parsed as an IPv4 address literal.\n+     * @return {@code Inet4Address} object constructed from the address literal;\n+     *         or {@@code null} if the literal cannot be parsed as an IPv4 address\n+     * @throws IllegalArgumentException if ambiguous IPv4 literal is specified,\n+     * or non-parsable IPv4 literal is specified with {@code throwIAE} set to \"true\".\n+     *\/\n+    static Inet4Address parseAddressString(String addressLiteral, boolean throwIAE) {\n+        byte [] addrBytes= IPAddressUtil.validateNumericFormatV4(addressLiteral, throwIAE);\n+        if (addrBytes == null) {\n+            return null;\n+        }\n+        return new Inet4Address(null, addrBytes);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/Inet4Address.java","additions":62,"deletions":1,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import sun.net.util.IPAddressUtil;\n+\n@@ -35,0 +37,1 @@\n+import java.util.Objects;\n@@ -142,1 +145,2 @@\n- * addressing architecture is described in [draft-ietf-ipngwg-scoping-arch-04.txt].\n+ * addressing architecture is described in <a href=\"https:\/\/www.rfc-editor.org\/info\/rfc4007\">\n+ * <i>RFC&nbsp;4007: IPv6 Scoped Address Architecture<\/i><\/a>.\n@@ -175,0 +179,2 @@\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc4007\n+ *      RFC 4007: IPv6 Scoped Address Architecture\n@@ -480,0 +486,140 @@\n+    \/**\n+     * Creates an {@code InetAddress} based on the provided textual representation of\n+     * an IPv6 address.\n+     * <p>The following IPv6 address {@linkplain Inet6Address##format\n+     * textual representations} are supported by this method:\n+     * {@snippet :\n+     *  \/\/ The full IPv6 form\n+     *  Inet6Address.ofLiteral(\"1080:0:0:0:8:800:200C:417A\") ==> \/1080:0:0:0:8:800:200c:417a\n+     *\n+     *  \/\/ The compressed IPv6 form with multiple groups of 16-bits of\n+     *  \/\/ zero replaced with \"::\"\n+     *  Inet6Address.ofLiteral(\"1080::8:800:200C:417A\") ==> \/1080:0:0:0:8:800:200c:417a\n+     *\n+     *  \/\/ IPv4-mapped IPv6 form\n+     *  Inet6Address.ofLiteral(\"::FFFF:129.144.52.38\") ==> \/129.144.52.38\n+     *\n+     *  \/\/ IPv4-compatible IPv6 form\n+     *  Inet6Address.ofLiteral(\"::129.144.52.38\") ==> \/0:0:0:0:0:0:8190:3426\n+     *\n+     *  \/\/ IPv6 scoped address form with scope-id as numeric identifier\n+     *  Inet6Address.ofLiteral(\"fe80::1%1\") ==> \/fe80:0:0:0:0:0:0:1%1\n+     *\n+     *  \/\/ IPv6 scoped address with scope-id as string\n+     *  Inet6Address.ofLiteral(\"fe80::1%en0\") ==> \/fe80:0:0:0:0:0:0:1%en0\n+     * }\n+     * All IPv6 address literal forms listed above are also supported when enclosed in\n+     * square brackets.\n+     * <p>If the provided address literal cannot represent a valid IP address an\n+     * {@code IllegalArgumentException} is thrown. For instance, if an IPv6 scoped\n+     *  address literal contains a scope-id that doesn't map to any network interface\n+     *  on the system, or if a scope-id is present in an IPv4-mapped IPv6 address literal.\n+     * <p>This method doesn't block, i.e. no reverse lookup is performed.\n+     *\n+     * @param ipv6AddressLiteral the textual representation of an IPv6 address.\n+     * @return an {@link Inet6Address} object with no hostname set, and constructed\n+     *         from the IPv6 address literal.\n+     * @throws IllegalArgumentException if the {@code ipv6AddressLiteral} cannot be\n+     *         parsed as an IPv6 address literal.\n+     * @throws NullPointerException if the {@code ipv6AddressLiteral} is {@code null}.\n+     *\/\n+    public static InetAddress ofLiteral(String ipv6AddressLiteral) {\n+        Objects.requireNonNull(ipv6AddressLiteral);\n+        try {\n+            InetAddress parsedAddress = parseAddressString(ipv6AddressLiteral, true);\n+            if (parsedAddress != null) {\n+                return parsedAddress;\n+            }\n+        } catch (UnknownHostException uhe) {\n+            \/\/ Error constructing Inet6Address from address literal containing\n+            \/\/ a network interface name\n+        }\n+        throw IPAddressUtil.invalidIpAddressLiteral(ipv6AddressLiteral);\n+    }\n+\n+    \/**\n+     * Method tries to parse supplied IP address literal as IPv6, IPv4-compatible IPv6 or\n+     * IPv4-mapped IPv6 address.\n+     * If address part of the literal string doesn't contain address in valid IPv6 form\n+     * - {@code null} is returned.\n+     * {@code UnknownHostException} is thrown if {@link InetAddress} cannot be constructed\n+     * from parsed string due to:\n+     * - incorrect zone-id specified in IPv6-scoped address literal that references\n+     * non-existing interface name.\n+     * - unexpected zone-id in IPv4-mapped address literal.\n+     *\n+     * @param addressLiteral literal IP address\n+     * @param removeSqBrackets if {@code \"true\"} remove outer square brackets\n+     * @return {@link Inet6Address} or {@link Inet4Address} object constructed from\n+     * literal IP address string.\n+     * @throws UnknownHostException if literal IP address string cannot be parsed\n+     * as IPv6, IPv4-mapped IPv6 or IPv4-compatible IPv6 address literals.\n+     *\/\n+    static InetAddress parseAddressString(String addressLiteral, boolean removeSqBrackets)\n+            throws UnknownHostException {\n+        \/\/ Remove trailing and leading square brackets if requested\n+        if (removeSqBrackets && addressLiteral.charAt(0) == '[' &&\n+                addressLiteral.length() > 2 &&\n+                addressLiteral.charAt(addressLiteral.length() - 1) == ']') {\n+            addressLiteral = addressLiteral.substring(1, addressLiteral.length() - 1);\n+        }\n+        int pos, numericZone = -1;\n+        String ifname = null;\n+        if ((pos = addressLiteral.indexOf('%')) != -1) {\n+            numericZone = checkNumericZone(addressLiteral);\n+            if (numericZone == -1) {\n+                \/* remainder of string must be an ifname *\/\n+                ifname = addressLiteral.substring(pos + 1);\n+            }\n+        }\n+        byte[] addrBytes = IPAddressUtil.textToNumericFormatV6(addressLiteral);\n+        if (addrBytes == null) {\n+            return null;\n+        }\n+        \/\/ IPv4-mapped IPv6 address\n+        if (addrBytes.length == Inet4Address.INADDRSZ) {\n+            if (numericZone != -1 || ifname != null) {\n+                \/\/ IPv4-mapped address must not contain zone-id\n+                throw new UnknownHostException(addressLiteral + \": invalid IPv4-mapped address\");\n+            }\n+            return new Inet4Address(null, addrBytes);\n+        }\n+        if (ifname != null) {\n+            return new Inet6Address(null, addrBytes, ifname);\n+        } else {\n+            return new Inet6Address(null, addrBytes, numericZone);\n+        }\n+    }\n+\n+    \/**\n+     * Check if the literal address string has %nn appended\n+     * returns -1 if not, or the numeric value otherwise.\n+     * <p>\n+     * %nn may also be a string that represents the displayName of\n+     * a currently available NetworkInterface.\n+     *\/\n+    private static int checkNumericZone(String s) {\n+        int percent = s.indexOf('%');\n+        int slen = s.length();\n+        int digit, zone = 0;\n+        int multmax = Integer.MAX_VALUE \/ 10; \/\/ for int overflow detection\n+        if (percent == -1) {\n+            return -1;\n+        }\n+        for (int i = percent + 1; i < slen; i++) {\n+            char c = s.charAt(i);\n+            if ((digit = IPAddressUtil.parseAsciiDigit(c, 10)) < 0) {\n+                return -1;\n+            }\n+            if (zone > multmax) {\n+                return -1;\n+            }\n+            zone = (zone * 10) + digit;\n+            if (zone < 0) {\n+                return -1;\n+            }\n+\n+        }\n+        return zone;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/Inet6Address.java","additions":148,"deletions":2,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -1420,1 +1420,1 @@\n-                addrArray = IPAddressUtil.validateNumericFormatV4(addrStr);\n+                addrArray = IPAddressUtil.validateNumericFormatV4(addrStr, false);\n@@ -1647,4 +1647,1 @@\n-            byte[] addr = null;\n-            int numericZone = -1;\n-            String ifname = null;\n-\n+            InetAddress inetAddress = null;\n@@ -1654,1 +1651,2 @@\n-                    addr = IPAddressUtil.validateNumericFormatV4(host);\n+                    \/\/ Here we check the address string for ambiguity only\n+                    inetAddress = Inet4Address.parseAddressString(host, false);\n@@ -1661,11 +1659,5 @@\n-            if (addr == null) {\n-                \/\/ Try to parse host string as an IPv6 literal\n-                \/\/ Check if a numeric or string zone id is present first\n-                int pos;\n-                if ((pos = host.indexOf('%')) != -1) {\n-                    numericZone = checkNumericZone(host);\n-                    if (numericZone == -1) { \/* remainder of string must be an ifname *\/\n-                        ifname = host.substring(pos + 1);\n-                    }\n-                }\n-                if ((addr = IPAddressUtil.textToNumericFormatV6(host)) == null &&\n+            if (inetAddress == null) {\n+                \/\/ This is supposed to be an IPv6 literal\n+                \/\/ Check for presence of a numeric or string zone id\n+                \/\/ is done in Inet6Address.parseAddressString\n+                if ((inetAddress = Inet6Address.parseAddressString(host, false)) == null &&\n@@ -1676,16 +1668,2 @@\n-            if(addr != null) {\n-                InetAddress[] ret = new InetAddress[1];\n-                if (addr.length == Inet4Address.INADDRSZ) {\n-                    if (numericZone != -1 || ifname != null) {\n-                        \/\/ IPv4-mapped address must not contain zone-id\n-                        throw new UnknownHostException(host + \": invalid IPv4-mapped address\");\n-                    }\n-                    ret[0] = new Inet4Address(null, addr);\n-                } else {\n-                    if (ifname != null) {\n-                        ret[0] = new Inet6Address(null, addr, ifname);\n-                    } else {\n-                        ret[0] = new Inet6Address(null, addr, numericZone);\n-                    }\n-                }\n-                return ret;\n+            if (inetAddress != null) {\n+                return new InetAddress[]{inetAddress};\n@@ -1721,33 +1699,0 @@\n-\n-    \/**\n-     * check if the literal address string has %nn appended\n-     * returns -1 if not, or the numeric value otherwise.\n-     *\n-     * %nn may also be a string that represents the displayName of\n-     * a currently available NetworkInterface.\n-     *\/\n-    private static int checkNumericZone (String s) throws UnknownHostException {\n-        int percent = s.indexOf ('%');\n-        int slen = s.length();\n-        int digit, zone=0;\n-        int multmax = Integer.MAX_VALUE \/ 10; \/\/ for int overflow detection\n-        if (percent == -1) {\n-            return -1;\n-        }\n-        for (int i=percent+1; i<slen; i++) {\n-            char c = s.charAt(i);\n-            if ((digit = IPAddressUtil.parseAsciiDigit(c, 10)) < 0) {\n-                return -1;\n-            }\n-            if (zone > multmax) {\n-                return -1;\n-            }\n-            zone = (zone * 10) + digit;\n-            if (zone < 0) {\n-                return -1;\n-            }\n-\n-        }\n-        return zone;\n-    }\n-\n@@ -1762,0 +1707,32 @@\n+    \/**\n+     * Creates an {@code InetAddress} based on the provided textual representation of\n+     * an IP address.\n+     * <p> The provided IP address literal is parsed as an IPv4 address literal first.\n+     * If it cannot be parsed as {@linkplain Inet4Address#ofLiteral(String) IPv4 address\n+     * literal}, then the method attempts to parse it as\n+     * {@linkplain Inet6Address#ofLiteral(String) an IPv6 address literal}.\n+     * If neither attempts succeed an {@code IllegalArgumentException} is thrown.\n+     * <p> This method doesn't block, i.e. no reverse lookup is performed.\n+     *\n+     * @param ipAddressLiteral the textual representation of an IP address.\n+     * @return an {@link InetAddress} object with no hostname set, and constructed\n+     *         from the IP address literal.\n+     * @throws IllegalArgumentException if the {@code ipAddressLiteral} cannot be parsed\n+     *         as an IPv4 or IPv6 address literal.\n+     * @throws NullPointerException if the {@code ipAddressLiteral} is {@code null}.\n+     * @see Inet4Address#ofLiteral(String)\n+     * @see Inet6Address#ofLiteral(String)\n+     *\/\n+    public static InetAddress ofLiteral(String ipAddressLiteral) {\n+        Objects.requireNonNull(ipAddressLiteral);\n+        InetAddress inetAddress;\n+        try {\n+            \/\/ First try to parse the input as an IPv4 address literal\n+            inetAddress = Inet4Address.ofLiteral(ipAddressLiteral);\n+        } catch (IllegalArgumentException iae) {\n+            \/\/ If it fails try to parse the input as an IPv6 address literal\n+            inetAddress = Inet6Address.ofLiteral(ipAddressLiteral);\n+        }\n+        return inetAddress;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":43,"deletions":66,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,1 +137,1 @@\n-     * {@code IllegalArgumentException} is thrown.\n+     * either {@code IllegalArgumentException} is thrown, or {@code \"null\"} is returned.\n@@ -140,0 +140,2 @@\n+     * @param throwIAE {@code \"true\"} - throw {@code IllegalArgumentException} when cannot be parsed as IPv4 address string;\n+     *                 {@code \"false\"} - throw {@code \"IllegalArgumentException\"} only when IPv4 address string is ambiguous.\n@@ -142,1 +144,3 @@\n-     *                                  \"false\" and IPv4 address string {@code \"src\"} is ambiguous\n+     *                                  \"false\", IPv4 address string {@code \"src\"} is ambiguous,\n+     *                                  or when address string cannot be parsed as IPv4 address and\n+     *                                  {@code \"throwIAE\"} is set to {@code \"true\"}.\n@@ -144,1 +148,1 @@\n-    public static byte[] validateNumericFormatV4(String src) {\n+    public static byte[] validateNumericFormatV4(String src, boolean throwIAE) {\n@@ -148,1 +152,4 @@\n-            throw new IllegalArgumentException(\"Invalid IP address literal: \" + src);\n+            throw invalidIpAddressLiteral(src);\n+        }\n+        if (parsedBytes == null && throwIAE) {\n+            throw invalidIpAddressLiteral(src);\n@@ -153,0 +160,10 @@\n+    \/**\n+     * Creates {@code IllegalArgumentException} with invalid IP address literal message.\n+     *\n+     * @param src address literal string to include to the exception message\n+     * @return an {@code IllegalArgumentException} instance\n+     *\/\n+    public static IllegalArgumentException invalidIpAddressLiteral(String src) {\n+        return new IllegalArgumentException(\"Invalid IP address literal: \" + src);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/net\/util\/IPAddressUtil.java","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,305 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8272215\n+ * @summary Test for ofLiteral API in InetAddress classes\n+ * @run junit\/othervm -Djdk.net.hosts.file=nonExistingHostsFile.txt\n+ *                     OfLiteralTest\n+ * @run junit\/othervm -Djdk.net.hosts.file=nonExistingHostsFile.txt\n+ *                    -Djava.net.preferIPv4Stack=true\n+ *                     OfLiteralTest\n+ * @run junit\/othervm -Djdk.net.hosts.file=nonExistingHostsFile.txt\n+ *                    -Djava.net.preferIPv6Addresses=true\n+ *                     OfLiteralTest\n+ * @run junit\/othervm -Djdk.net.hosts.file=nonExistingHostsFile.txt\n+ *                    -Djava.net.preferIPv6Addresses=false\n+ *                     OfLiteralTest\n+ *\/\n+\n+import org.junit.Assert;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.api.function.Executable;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+public class OfLiteralTest {\n+\n+    @ParameterizedTest\n+    @MethodSource(\"validLiteralArguments\")\n+    public void validLiteral(InetAddressClass inetAddressClass,\n+                             String addressLiteral,\n+                             byte[] expectedAddressBytes) throws Exception {\n+        InetAddress ofLiteralResult = switch (inetAddressClass) {\n+            case INET_ADDRESS -> InetAddress.ofLiteral(addressLiteral);\n+            case INET4_ADDRESS -> Inet4Address.ofLiteral(addressLiteral);\n+            case INET6_ADDRESS -> Inet6Address.ofLiteral(addressLiteral);\n+        };\n+        InetAddress getByNameResult = InetAddress.getByName(addressLiteral);\n+        Assert.assertArrayEquals(expectedAddressBytes, ofLiteralResult.getAddress());\n+        Assert.assertEquals(getByNameResult, ofLiteralResult);\n+    }\n+\n+    private static Stream<Arguments> validLiteralArguments() throws Exception {\n+        \/\/ 1080:0:0:0:8:800:200C:417A address bytes\n+        byte[] ipv6AddressExpBytes = new byte[]{16, -128, 0, 0, 0, 0, 0, 0, 0,\n+                8, 8, 0, 32, 12, 65, 122};\n+\n+        \/\/ ::129.144.52.38 address bytes\n+        byte[] ipv4CompIpv6ExpBytes = new byte[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, -127, -112, 52, 38};\n+\n+        \/\/ 222.173.190.239 address bytes\n+        byte[] ipv4ExpBytes = new byte[]{(byte) 222, (byte) 173,\n+                (byte) 190, (byte) 239};\n+\n+        \/\/ 222.173.190.39 address bytes\n+        byte[] ipv4ExpBytes2 = new byte[]{(byte) 222, (byte) 173,\n+                (byte) 190, 39};\n+\n+        \/\/ 1.2.3.4 address bytes\n+        byte[] oneToFourAddressExpBytes = new byte[]{1, 2, 3, 4};\n+\n+        \/\/ 6.7.8.9 address bytes\n+        byte[] sixtoNineAddressExpBytes = new byte[]{6, 7, 8, 9};\n+\n+        \/\/ ::FFFF:129.144.52.38 address bytes\n+        byte[] ipv6Ipv4MappedAddressExpBytes = new byte[]{\n+                (byte) 129, (byte) 144, 52, 38};\n+\n+        Stream<Arguments> validLiterals = Stream.of(\n+                \/\/ IPv6 address literals are parsable by Inet6Address.ofLiteral\n+                \/\/ and InetAddress.ofLiteral methods\n+                Arguments.of(InetAddressClass.INET6_ADDRESS,\n+                        \"1080:0:0:0:8:800:200C:417A\", ipv6AddressExpBytes),\n+                Arguments.of(InetAddressClass.INET_ADDRESS,\n+                        \"[1080:0:0:0:8:800:200C:417A]\", ipv6AddressExpBytes),\n+                \/\/ Compressed series of zeros with square brackets\n+                Arguments.of(InetAddressClass.INET6_ADDRESS,\n+                        \"[1080::8:800:200C:417A]\", ipv6AddressExpBytes),\n+                \/\/ Compressed series of zeros without square brackets\n+                Arguments.of(InetAddressClass.INET_ADDRESS,\n+                        \"1080::8:800:200C:417A\", ipv6AddressExpBytes),\n+                \/\/ IPv4-mapped IPv6 address literals are parsable by\n+                \/\/ InetAddress.ofLiteral and Inet6Address.ofLiteral methods\n+                Arguments.of(InetAddressClass.INET_ADDRESS,\n+                        \"::FFFF:129.144.52.38\", ipv6Ipv4MappedAddressExpBytes),\n+                Arguments.of(InetAddressClass.INET_ADDRESS,\n+                        \"[::ffff:1.2.3.4]\", oneToFourAddressExpBytes),\n+                Arguments.of(InetAddressClass.INET6_ADDRESS,\n+                        \"::FFFF:129.144.52.38\", ipv6Ipv4MappedAddressExpBytes),\n+                Arguments.of(InetAddressClass.INET6_ADDRESS,\n+                        \"[::ffff:1.2.3.4]\", oneToFourAddressExpBytes),\n+\n+                \/\/ IPv4-compatible IPv6 address literals are parsable by\n+                \/\/ Inet6Address.ofLiteral and InetAddress.ofLiteral methods\n+                Arguments.of(InetAddressClass.INET6_ADDRESS,\n+                        \"::129.144.52.38\", ipv4CompIpv6ExpBytes),\n+                Arguments.of(InetAddressClass.INET6_ADDRESS,\n+                        \"[::129.144.52.38]\", ipv4CompIpv6ExpBytes),\n+                Arguments.of(InetAddressClass.INET_ADDRESS,\n+                        \"::129.144.52.38\", ipv4CompIpv6ExpBytes),\n+                Arguments.of(InetAddressClass.INET_ADDRESS,\n+                        \"[::129.144.52.38]\", ipv4CompIpv6ExpBytes),\n+\n+                \/\/ Tests for IPv4 address literal forms\n+                \/\/      form:'d.d.d.d' method:Inet4Address.ofLiteral\n+                Arguments.of(InetAddressClass.INET4_ADDRESS,\n+                        \"222.173.190.239\", ipv4ExpBytes),\n+                \/\/      form:'d.d.d.d' with decimal octet with leading zero\n+                Arguments.of(InetAddressClass.INET4_ADDRESS,\n+                        \"222.173.190.039\", ipv4ExpBytes2),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS,\n+                        \"06.07.08.09\", sixtoNineAddressExpBytes),\n+                \/\/      form:'d.d.d.d' method:InetAddress.ofLiteral\n+                Arguments.of(InetAddressClass.INET_ADDRESS,\n+                        \"222.173.190.239\", ipv4ExpBytes),\n+                \/\/      form:'d.d.d' method:Inet4Address.ofLiteral\n+                Arguments.of(InetAddressClass.INET4_ADDRESS,\n+                        \"222.173.48879\", ipv4ExpBytes),\n+                \/\/      form:'d.d.d' method:InetAddress.ofLiteral\n+                Arguments.of(InetAddressClass.INET_ADDRESS,\n+                        \"222.173.48879\", ipv4ExpBytes),\n+                \/\/      form:'d.d' method:Inet4Address.ofLiteral\n+                Arguments.of(InetAddressClass.INET4_ADDRESS,\n+                        \"222.11386607\", ipv4ExpBytes),\n+                \/\/      form:'d.d' method:InetAddress.ofLiteral\n+                Arguments.of(InetAddressClass.INET_ADDRESS,\n+                        \"222.11386607\", ipv4ExpBytes),\n+                \/\/      form:'d' method:Inet4Address.ofLiteral\n+                Arguments.of(InetAddressClass.INET4_ADDRESS,\n+                        \"3735928559\", ipv4ExpBytes),\n+                \/\/      form:'d' method:InetAddress.ofLiteral\n+                Arguments.of(InetAddressClass.INET_ADDRESS,\n+                        \"3735928559\", ipv4ExpBytes),\n+                \/\/      form:'d' method:InetAddress.ofLiteral -\n+                \/\/      with leading 0 that is discarded and address\n+                \/\/      parsed as decimal\n+                Arguments.of(InetAddressClass.INET_ADDRESS,\n+                        \"03735928559\", ipv4ExpBytes)\n+        );\n+\n+        \/\/ Generate addresses for loopback and wildcard address test cases\n+        var loopbackAndWildcardAddresses = List.of(\n+                \/\/ Loopback address\n+                InetAddress.getLoopbackAddress(),\n+                \/\/ IPv6 wildcard address\n+                InetAddress.getByName(\"::\"),\n+                \/\/ IPv4 wildcard address\n+                InetAddress.getByName(\"0.0.0.0\"));\n+\n+        \/\/ Get addresses for all network interfaces available,\n+        \/\/ and construct a test case for each. And then combine\n+        \/\/ them with loopback\/wildcard test cases.\n+        Stream<Arguments> hostAddressArguments = Stream.concat(\n+                        NetworkInterface.networkInterfaces()\n+                                .flatMap(NetworkInterface::inetAddresses),\n+                        loopbackAndWildcardAddresses.stream())\n+                .flatMap(OfLiteralTest::addressToValidTestCases);\n+        return Stream.concat(validLiterals, hostAddressArguments);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"invalidLiteralArguments\")\n+    public void invalidLiteral(InetAddressClass inetAddressClass,\n+                               String addressLiteral) {\n+        var executable = constructExecutable(inetAddressClass, addressLiteral);\n+        var exception = assertThrows(IllegalArgumentException.class, executable);\n+        System.err.println(\"Expected exception observed: \" + exception);\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(InetAddressClass.class)\n+    public void nullLiteral(InetAddressClass inetAddressClass) {\n+        var executable = constructExecutable(inetAddressClass, null);\n+        assertThrows(NullPointerException.class, executable);\n+    }\n+\n+    private static Stream<Arguments> invalidLiteralArguments() {\n+        Stream<Arguments> argumentsStream = Stream.of(\n+                \/\/ IPv4 address wrapped in square brackets\n+                Arguments.of(InetAddressClass.INET_ADDRESS, \"[1.2.3.4]\"),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS, \"[1.2.3.4]\"),\n+                Arguments.of(InetAddressClass.INET6_ADDRESS, \"[1.2.3.4]\"),\n+\n+                \/\/ IPv4 address literal with BSD-formatting\n+                Arguments.of(InetAddressClass.INET_ADDRESS, \"1.2.3.0256\"),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS, \"1.2.3.0256\"),\n+\n+                \/\/ Invalid IPv4-mapped IPv6 address forms\n+                \/\/      ::FFFF:d.d.d\n+                Arguments.of(InetAddressClass.INET_ADDRESS, \"::FFFF:1.2.3\"),\n+                Arguments.of(InetAddressClass.INET6_ADDRESS, \"::FFFF:1.2.3\"),\n+\n+                \/\/      ::FFFF:d.d\n+                Arguments.of(InetAddressClass.INET_ADDRESS, \"::FFFF:1.2\"),\n+                Arguments.of(InetAddressClass.INET6_ADDRESS, \"::FFFF:1.2\"),\n+                \/\/      ::d.d.d\n+                Arguments.of(InetAddressClass.INET_ADDRESS, \"::1.2.3\"),\n+                Arguments.of(InetAddressClass.INET6_ADDRESS, \"::1.2.3\"),\n+                \/\/      ::d.d\n+                Arguments.of(InetAddressClass.INET_ADDRESS, \"::1.2\"),\n+                Arguments.of(InetAddressClass.INET6_ADDRESS, \"::1.2\"),\n+\n+                \/\/ IPv4-mapped IPv6 address with scope-id\n+                Arguments.of(InetAddressClass.INET6_ADDRESS,\n+                        \"::FFFF:129.144.52.38%1\"),\n+\n+                \/\/ IPv4-mapped IPv6 addresses cannot be parsed by Inet4Address.ofLiteral\n+                Arguments.of(InetAddressClass.INET4_ADDRESS,\n+                        \"::FFFF:129.144.52.38\"),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS,\n+                        \"[::ffff:1.2.3.4]\"),\n+\n+                \/\/ IPv4 literals in BSD form\n+                Arguments.of(InetAddressClass.INET_ADDRESS, \"0256.1.2.3\"),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS, \"1.2.0256.3\"),\n+                Arguments.of(InetAddressClass.INET_ADDRESS, \"0x1.2.3.4\"),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS, \"1.2.0x3.4\"),\n+                Arguments.of(InetAddressClass.INET_ADDRESS, \"0xFFFFFFFF\"),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS, \"0xFFFFFFFF\")\n+        );\n+        \/\/ Construct arguments for a test case with IPv6-scoped address with scope-id\n+        \/\/ specified as a string with non-existing network interface name\n+        String ifName = generateNonExistingIfName();\n+        Stream<Arguments> nonExistingIFinScope = ifName.isBlank() ? Stream.empty() :\n+                Stream.of(Arguments.of(InetAddressClass.INET6_ADDRESS,\n+                        \"2001:db8:a0b:12f0::1%\" + ifName));\n+        return Stream.concat(argumentsStream, nonExistingIFinScope);\n+    }\n+\n+    private static Stream<Arguments> addressToValidTestCases(InetAddress inetAddress) {\n+        String addressLiteral = inetAddress.getHostAddress();\n+        byte[] expectedAddressBytes = inetAddress.getAddress();\n+\n+        InetAddressClass addressClass = switch (inetAddress) {\n+            case Inet4Address i4 -> InetAddressClass.INET4_ADDRESS;\n+            case Inet6Address i6 -> InetAddressClass.INET6_ADDRESS;\n+            case InetAddress ia -> InetAddressClass.INET_ADDRESS;\n+        };\n+        return Stream.of(\n+                Arguments.of(InetAddressClass.INET_ADDRESS, addressLiteral, expectedAddressBytes),\n+                Arguments.of(addressClass, addressLiteral, expectedAddressBytes));\n+    }\n+\n+    private static String generateNonExistingIfName() {\n+        try {\n+            return NetworkInterface\n+                    .networkInterfaces()\n+                    .map(NetworkInterface::getName)\n+                    .collect(Collectors.joining())\n+                    .strip();\n+        } catch (SocketException e) {\n+            return \"\";\n+        }\n+    }\n+\n+    private static Executable constructExecutable(InetAddressClass inetAddressClass, String input) {\n+        return switch (inetAddressClass) {\n+            case INET_ADDRESS -> () -> InetAddress.ofLiteral(input);\n+            case INET4_ADDRESS -> () -> Inet4Address.ofLiteral(input);\n+            case INET6_ADDRESS -> () -> Inet6Address.ofLiteral(input);\n+        };\n+    }\n+\n+    enum InetAddressClass {\n+        INET_ADDRESS,\n+        INET4_ADDRESS,\n+        INET6_ADDRESS\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/net\/InetAddress\/OfLiteralTest.java","additions":305,"deletions":0,"binary":false,"changes":305,"status":"added"}]}