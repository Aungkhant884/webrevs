{"files":[{"patch":"@@ -2206,1 +2206,8 @@\n-      failure_reason = compile_state.failure_reason();\n+      if (env.init_error() != JNI_OK) {\n+        failure_reason = os::strdup(err_msg(\"Error attaching to libjvmci (err: %d)\", env.init_error()), mtJVMCI);\n+        bool reason_on_C_heap = true;\n+        \/\/ In case of JNI_ENOMEM, there's a good chance a subsequent attempt to create libjvmci or attach to it\n+        \/\/ might succeed. Other errors most likely indicate a non-recoverable error in the JVMCI runtime.\n+        bool retryable = env.init_error() == JNI_ENOMEM;\n+        compile_state.set_failure(retryable, failure_reason, reason_on_C_heap);\n+      }\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+    assert(jvmci_env->init_error() == JNI_OK, \"invalid JVMCIEnv (err: %d)\", jvmci_env->init_error());\n","filename":"src\/hotspot\/share\/jvmci\/jniAccessMark.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-  JNI_JVMCIENV(JVMCI::compilation_tick(thread), env);\n+  JVMCIENV_FROM_JNI(JVMCI::compilation_tick(thread), env);\n@@ -2439,6 +2439,3 @@\n-    bool jni_enomem_is_fatal = false;\n-    JVMCIEnv __peer_jvmci_env__(thread, false, jni_enomem_is_fatal, __FILE__, __LINE__);\n-    JVMCIEnv* peerEnv = &__peer_jvmci_env__;\n-    if (peerEnv->has_jni_enomem()) {\n-      JVMCI_THROW_MSG_0(OutOfMemoryError, \"JNI_ENOMEM creating or attaching to libjvmci\");\n-    }\n+    PEER_JVMCIENV_FROM_THREAD(THREAD, false);\n+    PEER_JVMCIENV->check_init(JVMCI_CHECK_NULL);\n+\n@@ -2447,2 +2444,2 @@\n-    if (peerEnv->has_pending_exception()) {\n-      peerEnv->describe_pending_exception(tty);\n+    if (PEER_JVMCIENV->has_pending_exception()) {\n+      PEER_JVMCIENV->describe_pending_exception(tty);\n@@ -2607,6 +2604,2 @@\n-      bool jni_enomem_is_fatal = false;\n-      JVMCIEnv __peer_jvmci_env__(thread, false, jni_enomem_is_fatal, __FILE__, __LINE__);\n-      JVMCIEnv* peerJVMCIEnv = &__peer_jvmci_env__;\n-      if (peerJVMCIEnv->has_jni_enomem()) {\n-        JVMCI_THROW_MSG_0(OutOfMemoryError, \"JNI_ENOMEM creating or attaching to libjvmci\");\n-      }\n+      PEER_JVMCIENV_FROM_THREAD(THREAD, false);\n+      PEER_JVMCIENV->check_init(JVMCI_CHECK_0);\n@@ -2615,3 +2608,3 @@\n-      JVMCIObject receiver = runtime->get_HotSpotJVMCIRuntime(peerJVMCIEnv);\n-      if (peerJVMCIEnv->has_pending_exception()) {\n-        peerJVMCIEnv->describe_pending_exception(tty);\n+      JVMCIObject receiver = runtime->get_HotSpotJVMCIRuntime(PEER_JVMCIENV);\n+      if (PEER_JVMCIENV->has_pending_exception()) {\n+        PEER_JVMCIENV->describe_pending_exception(tty);\n@@ -2707,7 +2700,2 @@\n-  bool jni_enomem_is_fatal = false;\n-  JVMCIEnv __peer_jvmci_env__(thread, !JVMCIENV->is_hotspot(), jni_enomem_is_fatal, __FILE__, __LINE__);\n-  JVMCIEnv* peerEnv = &__peer_jvmci_env__;\n-  JVMCIEnv* thisEnv = JVMCIENV;\n-  if (peerEnv->has_jni_enomem()) {\n-      JVMCI_THROW_MSG_0(OutOfMemoryError, \"JNI_ENOMEM creating or attaching to libjvmci\");\n-  }\n+  PEER_JVMCIENV_FROM_THREAD(THREAD, !JVMCIENV->is_hotspot());\n+  PEER_JVMCIENV->check_init(JVMCI_CHECK_0);\n@@ -2715,0 +2703,1 @@\n+  JVMCIEnv* thisEnv = JVMCIENV;\n@@ -2719,1 +2708,1 @@\n-    result = peerEnv->get_jvmci_method(method, JVMCI_CHECK_0);\n+    result = PEER_JVMCIENV->get_jvmci_method(method, JVMCI_CHECK_0);\n@@ -2724,1 +2713,1 @@\n-    result = peerEnv->get_jvmci_type(klass_handle, JVMCI_CHECK_0);\n+    result = PEER_JVMCIENV->get_jvmci_type(klass_handle, JVMCI_CHECK_0);\n@@ -2727,1 +2716,1 @@\n-    result = peerEnv->get_jvmci_primitive_type(type);\n+    result = PEER_JVMCIENV->get_jvmci_primitive_type(type);\n@@ -2731,1 +2720,1 @@\n-    result = peerEnv->get_object_constant(constant());\n+    result = PEER_JVMCIENV->get_object_constant(constant());\n@@ -2733,1 +2722,1 @@\n-    if (peerEnv->is_hotspot()) {\n+    if (PEER_JVMCIENV->is_hotspot()) {\n@@ -2756,1 +2745,1 @@\n-      result = peerEnv->new_HotSpotNmethod(mh, cstring, isDefault, compileIdSnapshot, JVMCI_CHECK_0);\n+      result = PEER_JVMCIENV->new_HotSpotNmethod(mh, cstring, isDefault, compileIdSnapshot, JVMCI_CHECK_0);\n@@ -2764,1 +2753,1 @@\n-        peerEnv->initialize_installed_code(result, nm, JVMCI_CHECK_0);\n+        PEER_JVMCIENV->initialize_installed_code(result, nm, JVMCI_CHECK_0);\n@@ -2766,1 +2755,1 @@\n-        if (peerEnv->is_hotspot()) {\n+        if (PEER_JVMCIENV->is_hotspot()) {\n@@ -2784,1 +2773,1 @@\n-    peerEnv->call_HotSpotJVMCIRuntime_postTranslation(result, JVMCI_CHECK_0);\n+    PEER_JVMCIENV->call_HotSpotJVMCIRuntime_postTranslation(result, JVMCI_CHECK_0);\n@@ -2787,1 +2776,1 @@\n-  if (peerEnv->transfer_pending_exception(thread, thisEnv)) {\n+  if (PEER_JVMCIENV->transfer_pending_exception(thread, thisEnv)) {\n@@ -2790,1 +2779,1 @@\n-  return (jlong) peerEnv->make_global(result).as_jobject();\n+  return (jlong) PEER_JVMCIENV->make_global(result).as_jobject();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":25,"deletions":36,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-void JVMCIEnv::init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env, bool jni_enomem_is_fatal) {\n+void JVMCIEnv::init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env) {\n@@ -150,2 +150,1 @@\n-  int create_JavaVM_err = JNI_OK;\n-  _env = _runtime->init_shared_library_javavm(&create_JavaVM_err);\n+  _env = _runtime->init_shared_library_javavm(&_init_error);\n@@ -155,7 +154,4 @@\n-  } else if (create_JavaVM_err != JNI_OK) {\n-    if (!jni_enomem_is_fatal && create_JavaVM_err == JNI_ENOMEM) {\n-      _jni_enomem = true;\n-      return;\n-    } else {\n-      fatal(\"JNI_CreateJavaVM failed with return value %d\", create_JavaVM_err);\n-    }\n+  } else if (_init_error != JNI_OK) {\n+    \/\/ Caller creating this JVMCIEnv must handle the error.\n+    JVMCI_event_1(\"[%s:%d] Error creating libjvmci (err: %d)\", _file, _line, _init_error);\n+    return;\n@@ -177,2 +173,2 @@\n-      jint attach_result = _runtime->AttachCurrentThread(thread, (void**) &_env, &attach_args);\n-      if (attach_result == JNI_OK) {\n+      _init_error = _runtime->AttachCurrentThread(thread, (void**) &_env, &attach_args);\n+      if (_init_error == JNI_OK) {\n@@ -180,1 +176,2 @@\n-      } else if (!jni_enomem_is_fatal && attach_result == JNI_ENOMEM) {\n+      } else {\n+        \/\/ Caller creating this JVMCIEnv must handle the error.\n@@ -182,1 +179,1 @@\n-        _jni_enomem = true;\n+        JVMCI_event_1(\"[%s:%d] Error attaching to libjvmci (err: %d)\", _file, _line, _init_error);\n@@ -184,2 +181,0 @@\n-      } else {\n-        fatal(\"Error attaching current thread (%s) to JVMCI shared library JNI interface\", attach_args.name);\n@@ -196,3 +191,2 @@\n-    char message[256];\n-    jio_snprintf(message, 256, \"Uncaught exception pushing local frame for JVMCIEnv scope entered at %s:%d\", _file, _line);\n-    JVMCIRuntime::fatal_exception(this, message);\n+    JVMCI_event_1(\"[%s:%d] Error pushing local JNI frame (err: %d)\", _file, _line, _init_error);\n+    return;\n@@ -204,8 +198,2 @@\n-    _throw_to_caller(false), _file(file), _line(line), _jni_enomem(false), _compile_state(compile_state) {\n-  \/\/ In case of JNI_ENOMEM, there's a good chance a subsequent attempt to create libjvmci or attach to it\n-  \/\/ might succeed. Other errors most likely indicate a non-recoverable error in the JVMCI runtime.\n-  bool jni_enomem_is_fatal = false;\n-  init_env_mode_runtime(thread, nullptr, jni_enomem_is_fatal);\n-  if (_jni_enomem) {\n-    compile_state->set_failure(true, \"Out of memory while attaching JVMCI compiler to current thread\");\n-  }\n+    _throw_to_caller(false), _file(file), _line(line), _init_error(JNI_OK), _compile_state(compile_state) {\n+  init_env_mode_runtime(thread, nullptr);\n@@ -215,1 +203,1 @@\n-    _throw_to_caller(false), _file(file), _line(line), _jni_enomem(false), _compile_state(nullptr) {\n+    _throw_to_caller(false), _file(file), _line(line), _init_error(JNI_OK), _compile_state(nullptr) {\n@@ -220,1 +208,2 @@\n-    _throw_to_caller(true), _file(file), _line(line), _jni_enomem(false), _compile_state(nullptr) {\n+    _throw_to_caller(true), _file(file), _line(line), _init_error(JNI_OK), _compile_state(nullptr) {\n+  assert(parent_env != nullptr, \"npe\");\n@@ -223,0 +212,1 @@\n+  assert(_init_error == JNI_OK, \"err: %d\", _init_error);\n@@ -225,1 +215,1 @@\n-void JVMCIEnv::init(JavaThread* thread, bool is_hotspot, bool jni_enomem_is_fatal, const char* file, int line) {\n+void JVMCIEnv::init(JavaThread* thread, bool is_hotspot, const char* file, int line) {\n@@ -230,1 +220,1 @@\n-  _jni_enomem = false;\n+  _init_error = JNI_OK;\n@@ -238,1 +228,21 @@\n-    init_env_mode_runtime(thread, nullptr, jni_enomem_is_fatal);\n+    init_env_mode_runtime(thread, nullptr);\n+  }\n+}\n+\n+void JVMCIEnv::check_init(JVMCI_TRAPS) {\n+  guarantee(JVMCIENV != this, \"must be\");\n+  if (_init_error == JNI_OK) {\n+    return;\n+  }\n+  if (_init_error == JNI_ENOMEM) {\n+    JVMCI_THROW_MSG(OutOfMemoryError, \"JNI_ENOMEM creating or attaching to libjvmci\");\n+  }\n+  JVMCI_THROW_MSG(InternalError, err_msg(\"Error creating or attaching to libjvmci (err: %d)\", _init_error));\n+}\n+\n+void JVMCIEnv::check_init(TRAPS) {\n+  if (_init_error == JNI_OK) {\n+    return;\n+  }\n+  if (_init_error == JNI_ENOMEM) {\n+    THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), \"JNI_ENOMEM creating or attaching to libjvmci\");\n@@ -240,0 +250,1 @@\n+  THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), err_msg(\"Error creating or attaching to libjvmci (err: %d)\", _init_error));\n@@ -564,1 +575,1 @@\n-  if (_jni_enomem) {\n+  if (_init_error != JNI_OK) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":44,"deletions":33,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-  void init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env, bool jni_enomem_is_fatal = true);\n+  void init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env);\n@@ -162,1 +162,1 @@\n-  void init(JavaThread* thread, bool is_hotspot, bool jni_enomem_is_fatal, const char* file, int line);\n+  void init(JavaThread* thread, bool is_hotspot, const char* file, int line);\n@@ -172,3 +172,3 @@\n-  bool             _jni_enomem;  \/\/ JNI_ENOMEM returned when creating or attaching to a libjvmci isolate.\n-                                 \/\/ If true, the JVMCIEnv is invalid and should not be used apart from\n-                                 \/\/ calling has_jni_enomem().\n+  int              _init_error;  \/\/ JNI code returned when creating or attaching to a libjvmci isolate.\n+                                 \/\/ If not JNI_OK, the JVMCIEnv is invalid and should not be used apart from\n+                                 \/\/ calling init_error().\n@@ -188,0 +188,1 @@\n+  \/\/ The `parent_env` argument must not be null.\n@@ -192,1 +193,1 @@\n-  JVMCIEnv(JavaThread* thread, JNIEnv* env, const char* file, int line);\n+  JVMCIEnv(JavaThread* thread, JNIEnv* parent_env, const char* file, int line);\n@@ -203,12 +204,0 @@\n-  \/\/ Opens a JNIEnv scope for accessing `for_object`. An exception occurring\n-  \/\/ within the scope must not be propagated back to the caller.\n-  JVMCIEnv(JavaThread* thread, JVMCIObject for_object, const char* file, int line) {\n-    \/\/ A JNI call to access an object in the shared library heap\n-    \/\/ can block or take a long time so do not allow such access\n-    \/\/ on the VM thread.\n-    assert(for_object.is_hotspot() || !Thread::current()->is_VM_thread(),\n-        \"cannot open JVMCIEnv scope when in the VM thread for accessing a shared library heap object\");\n-    bool jni_enomem_is_fatal = true;\n-    init(thread, for_object.is_hotspot(), jni_enomem_is_fatal, file, line);\n-  }\n-\n@@ -218,2 +207,2 @@\n-  JVMCIEnv(JavaThread* thread, bool is_hotspot, bool jni_enomem_is_fatal, const char* file, int line) {\n-    init(thread, is_hotspot, jni_enomem_is_fatal, file, line);\n+  JVMCIEnv(JavaThread* thread, bool is_hotspot, const char* file, int line) {\n+    init(thread, is_hotspot, file, line);\n@@ -224,4 +213,5 @@\n-  \/\/ Determines if a JNI_ENOMEM occurred while trying to create a libjvmci\n-  \/\/ isolate or attach to it within the scope of a JVMCIEnv constructor.\n-  bool has_jni_enomem() {\n-    return _jni_enomem;\n+  \/\/ Gets the JNI result code returned when creating or attaching to a libjvmci isolate.\n+  \/\/ If not JNI_OK, the JVMCIEnv is invalid and the caller must abort the operation\n+  \/\/ this JVMCIEnv context was created for.\n+  int init_error() {\n+    return _init_error;\n@@ -230,0 +220,8 @@\n+  \/\/ Checks the value of init_error() and throws an exception in `JVMCI_TRAPS`\n+  \/\/ (which must not be this) if it is not JNI_OK.\n+  void check_init(JVMCI_TRAPS);\n+\n+  \/\/ Checks the value of init_error() and throws an exception in `TRAPS`\n+  \/\/ if it is not JNI_OK.\n+  void check_init(TRAPS);\n+\n@@ -231,0 +229,1 @@\n+    guarantee(_init_error == 0, \"invalid JVMCIEnv: %d\", _init_error);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":23,"deletions":24,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#define PEER_JVMCIENV __peer_jvmci_env__\n@@ -35,1 +36,1 @@\n-#define JNI_JVMCIENV(thread, env)                                     \\\n+#define JVMCIENV_FROM_JNI(thread, env)                                     \\\n@@ -39,1 +40,1 @@\n-#define THREAD_JVMCIENV(thread)                               \\\n+#define JVMCIENV_FROM_THREAD(thread)                               \\\n@@ -43,0 +44,5 @@\n+#define PEER_JVMCIENV_FROM_THREAD(thread, is_hotspot)                  \\\n+  JVMCIEnv __peer_stack_jvmci_env__(thread, is_hotspot, __FILE__, __LINE__);   \\\n+  JVMCIEnv* PEER_JVMCIENV = &__peer_stack_jvmci_env__\n+\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciExceptions.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -747,3 +747,4 @@\n-\/\/ private static JVMCIRuntime JVMCI.initializeRuntime()\n-JVM_ENTRY_NO_ENV(jobject, JVM_GetJVMCIRuntime(JNIEnv *env, jclass c))\n-  JNI_JVMCIENV(thread, env);\n+\/\/ Implementation of JVMCI.initializeRuntime()\n+\/\/ When called from libjvmci, `libjvmciOrHotspotEnv` is a libjvmci env so use JVM_ENTRY_NO_ENV.\n+JVM_ENTRY_NO_ENV(jobject, JVM_GetJVMCIRuntime(JNIEnv *libjvmciOrHotspotEnv, jclass c))\n+  JVMCIENV_FROM_JNI(thread, libjvmciOrHotspotEnv);\n@@ -758,1 +759,2 @@\n-\/\/ private static long Services.readSystemPropertiesInfo(int[] offsets)\n+\/\/ Implementation of Services.readSystemPropertiesInfo(int[] offsets)\n+\/\/ When called from libjvmci, `env` is a libjvmci env so use JVM_ENTRY_NO_ENV.\n@@ -760,1 +762,1 @@\n-  JNI_JVMCIENV(thread, env);\n+  JVMCIENV_FROM_JNI(thread, env);\n@@ -774,1 +776,2 @@\n-  THREAD_JVMCIENV(JavaThread::current());\n+  JVMCIENV_FROM_THREAD(THREAD);\n+  JVMCIENV->check_init(CHECK);\n@@ -1528,3 +1531,4 @@\n-\/\/ private static void CompilerToVM.registerNatives()\n-JVM_ENTRY_NO_ENV(void, JVM_RegisterJVMCINatives(JNIEnv *env, jclass c2vmClass))\n-  JNI_JVMCIENV(thread, env);\n+\/\/ Implementation of CompilerToVM.registerNatives()\n+\/\/ When called from libjvmci, `libjvmciOrHotspotEnv` is a libjvmci env so use JVM_ENTRY_NO_ENV.\n+JVM_ENTRY_NO_ENV(void, JVM_RegisterJVMCINatives(JNIEnv *libjvmciOrHotspotEnv, jclass c2vmClass))\n+  JVMCIENV_FROM_JNI(thread, libjvmciOrHotspotEnv);\n@@ -1545,1 +1549,1 @@\n-\n+    JNIEnv *env = libjvmciOrHotspotEnv;\n@@ -1565,1 +1569,0 @@\n-    bool jni_enomem_is_fatal = true;\n@@ -1567,1 +1570,1 @@\n-    JVMCIEnv __stack_jvmci_env__(JavaThread::current(), _HotSpotJVMCIRuntime_instance.is_hotspot(), jni_enomem_is_fatal, __FILE__, __LINE__);\n+    JVMCIEnv __stack_jvmci_env__(JavaThread::current(), _HotSpotJVMCIRuntime_instance.is_hotspot(),__FILE__, __LINE__);\n@@ -1569,1 +1572,5 @@\n-    JVMCIENV->call_HotSpotJVMCIRuntime_shutdown(_HotSpotJVMCIRuntime_instance);\n+    if (JVMCIENV->init_error() == JNI_OK) {\n+      JVMCIENV->call_HotSpotJVMCIRuntime_shutdown(_HotSpotJVMCIRuntime_instance);\n+    } else {\n+      JVMCI_event_1(\"Error in JVMCIEnv for shutdown (err: %d)\", JVMCIENV->init_error());\n+    }\n@@ -1614,1 +1621,2 @@\n-    THREAD_JVMCIENV(JavaThread::current());\n+    JVMCIENV_FROM_THREAD(THREAD);\n+    JVMCIENV->check_init(CHECK);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"}]}