{"files":[{"patch":"@@ -5406,31 +5406,31 @@\n-            if (c.isSealed() &&\n-                    !c.isEnum() &&\n-                    !c.isPermittedExplicit &&\n-                    c.permitted.isEmpty()) {\n-                log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.SealedClassMustHaveSubclasses);\n-            }\n-\n-            if (c.isSealed()) {\n-                Set<Symbol> permittedTypes = new HashSet<>();\n-                boolean sealedInUnnamed = c.packge().modle == syms.unnamedModule || c.packge().modle == syms.noModule;\n-                for (Symbol subTypeSym : c.permitted) {\n-                    boolean isTypeVar = false;\n-                    if (subTypeSym.type.getTag() == TYPEVAR) {\n-                        isTypeVar = true; \/\/error recovery\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n-                                Errors.InvalidPermitsClause(Fragments.IsATypeVariable(subTypeSym.type)));\n-                    }\n-                    if (subTypeSym.isAnonymous() && !c.isEnum()) {\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),  Errors.LocalClassesCantExtendSealed(Fragments.Anonymous));\n-                    }\n-                    if (permittedTypes.contains(subTypeSym)) {\n-                        DiagnosticPosition pos =\n-                                env.enclClass.permitting.stream()\n-                                        .filter(permittedExpr -> TreeInfo.diagnosticPositionFor(subTypeSym, permittedExpr, true) != null)\n-                                        .limit(2).collect(List.collector()).get(1);\n-                        log.error(pos, Errors.InvalidPermitsClause(Fragments.IsDuplicated(subTypeSym.type)));\n-                    } else {\n-                        permittedTypes.add(subTypeSym);\n-                    }\n-                    if (sealedInUnnamed) {\n-                        if (subTypeSym.packge() != c.packge()) {\n+            \/\/ The info.lint field in the envs stored in typeEnvs is deliberately uninitialized,\n+            \/\/ because the annotations were not available at the time the env was created. Therefore,\n+            \/\/ we look up the environment chain for the first enclosing environment for which the\n+            \/\/ lint value is set. Typically, this is the parent env, but might be further if there\n+            \/\/ are any envs created as a result of TypeParameter nodes.\n+            Env<AttrContext> lintEnv = env;\n+            while (lintEnv.info.lint == null)\n+                lintEnv = lintEnv.next;\n+\n+            \/\/ Having found the enclosing lint value, we can initialize the lint value for this class\n+            env.info.lint = lintEnv.info.lint.augment(c);\n+\n+            Lint prevLint = chk.setLint(env.info.lint);\n+            JavaFileObject prev = log.useSource(c.sourcefile);\n+            ResultInfo prevReturnRes = env.info.returnResult;\n+\n+            try {\n+                if (c.isSealed() &&\n+                        !c.isEnum() &&\n+                        !c.isPermittedExplicit &&\n+                        c.permitted.isEmpty()) {\n+                    log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.SealedClassMustHaveSubclasses);\n+                }\n+\n+                if (c.isSealed()) {\n+                    Set<Symbol> permittedTypes = new HashSet<>();\n+                    boolean sealedInUnnamed = c.packge().modle == syms.unnamedModule || c.packge().modle == syms.noModule;\n+                    for (Symbol subTypeSym : c.permitted) {\n+                        boolean isTypeVar = false;\n+                        if (subTypeSym.type.getTag() == TYPEVAR) {\n+                            isTypeVar = true; \/\/error recovery\n@@ -5438,2 +5438,1 @@\n-                                    Errors.ClassInUnnamedModuleCantExtendSealedInDiffPackage(c)\n-                            );\n+                                    Errors.InvalidPermitsClause(Fragments.IsATypeVariable(subTypeSym.type)));\n@@ -5441,18 +5440,19 @@\n-                    } else if (subTypeSym.packge().modle != c.packge().modle) {\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n-                                Errors.ClassInModuleCantExtendSealedInDiffModule(c, c.packge().modle)\n-                        );\n-                    }\n-                    if (subTypeSym == c.type.tsym || types.isSuperType(subTypeSym.type, c.type)) {\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, ((JCClassDecl)env.tree).permitting),\n-                                Errors.InvalidPermitsClause(\n-                                        subTypeSym == c.type.tsym ?\n-                                                Fragments.MustNotBeSameClass :\n-                                                Fragments.MustNotBeSupertype(subTypeSym.type)\n-                                )\n-                        );\n-                    } else if (!isTypeVar) {\n-                        boolean thisIsASuper = types.directSupertypes(subTypeSym.type)\n-                                                    .stream()\n-                                                    .anyMatch(d -> d.tsym == c);\n-                        if (!thisIsASuper) {\n+                        if (subTypeSym.isAnonymous() && !c.isEnum()) {\n+                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),  Errors.LocalClassesCantExtendSealed(Fragments.Anonymous));\n+                        }\n+                        if (permittedTypes.contains(subTypeSym)) {\n+                            DiagnosticPosition pos =\n+                                    env.enclClass.permitting.stream()\n+                                            .filter(permittedExpr -> TreeInfo.diagnosticPositionFor(subTypeSym, permittedExpr, true) != null)\n+                                            .limit(2).collect(List.collector()).get(1);\n+                            log.error(pos, Errors.InvalidPermitsClause(Fragments.IsDuplicated(subTypeSym.type)));\n+                        } else {\n+                            permittedTypes.add(subTypeSym);\n+                        }\n+                        if (sealedInUnnamed) {\n+                            if (subTypeSym.packge() != c.packge()) {\n+                                log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n+                                        Errors.ClassInUnnamedModuleCantExtendSealedInDiffPackage(c)\n+                                );\n+                            }\n+                        } else if (subTypeSym.packge().modle != c.packge().modle) {\n@@ -5460,1 +5460,19 @@\n-                                    Errors.InvalidPermitsClause(Fragments.DoesntExtendSealed(subTypeSym.type)));\n+                                    Errors.ClassInModuleCantExtendSealedInDiffModule(c, c.packge().modle)\n+                            );\n+                        }\n+                        if (subTypeSym == c.type.tsym || types.isSuperType(subTypeSym.type, c.type)) {\n+                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, ((JCClassDecl)env.tree).permitting),\n+                                    Errors.InvalidPermitsClause(\n+                                            subTypeSym == c.type.tsym ?\n+                                                    Fragments.MustNotBeSameClass :\n+                                                    Fragments.MustNotBeSupertype(subTypeSym.type)\n+                                    )\n+                            );\n+                        } else if (!isTypeVar) {\n+                            boolean thisIsASuper = types.directSupertypes(subTypeSym.type)\n+                                                        .stream()\n+                                                        .anyMatch(d -> d.tsym == c);\n+                            if (!thisIsASuper) {\n+                                log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n+                                        Errors.InvalidPermitsClause(Fragments.DoesntExtendSealed(subTypeSym.type)));\n+                            }\n@@ -5464,1 +5482,0 @@\n-            }\n@@ -5466,5 +5483,5 @@\n-            List<ClassSymbol> sealedSupers = types.directSupertypes(c.type)\n-                                                  .stream()\n-                                                  .filter(s -> s.tsym.isSealed())\n-                                                  .map(s -> (ClassSymbol) s.tsym)\n-                                                  .collect(List.collector());\n+                List<ClassSymbol> sealedSupers = types.directSupertypes(c.type)\n+                                                      .stream()\n+                                                      .filter(s -> s.tsym.isSealed())\n+                                                      .map(s -> (ClassSymbol) s.tsym)\n+                                                      .collect(List.collector());\n@@ -5472,3 +5489,3 @@\n-            if (sealedSupers.isEmpty()) {\n-                if ((c.flags_field & Flags.NON_SEALED) != 0) {\n-                    boolean hasErrorSuper = false;\n+                if (sealedSupers.isEmpty()) {\n+                    if ((c.flags_field & Flags.NON_SEALED) != 0) {\n+                        boolean hasErrorSuper = false;\n@@ -5476,3 +5493,3 @@\n-                    hasErrorSuper |= types.directSupertypes(c.type)\n-                                          .stream()\n-                                          .anyMatch(s -> s.tsym.kind == Kind.ERR);\n+                        hasErrorSuper |= types.directSupertypes(c.type)\n+                                              .stream()\n+                                              .anyMatch(s -> s.tsym.kind == Kind.ERR);\n@@ -5480,1 +5497,1 @@\n-                    ClassType ct = (ClassType) c.type;\n+                        ClassType ct = (ClassType) c.type;\n@@ -5482,1 +5499,1 @@\n-                    hasErrorSuper |= !ct.isCompound() && ct.interfaces_field != ct.all_interfaces_field;\n+                        hasErrorSuper |= !ct.isCompound() && ct.interfaces_field != ct.all_interfaces_field;\n@@ -5484,2 +5501,7 @@\n-                    if (!hasErrorSuper) {\n-                        log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.NonSealedWithNoSealedSupertype(c));\n+                        if (!hasErrorSuper) {\n+                            log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.NonSealedWithNoSealedSupertype(c));\n+                        }\n+                    }\n+                } else {\n+                    if (c.isDirectlyOrIndirectlyLocal() && !c.isEnum()) {\n+                        log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.LocalClassesCantExtendSealed(c.isAnonymous() ? Fragments.Anonymous : Fragments.Local));\n@@ -5487,5 +5509,0 @@\n-                }\n-            } else {\n-                if (c.isDirectlyOrIndirectlyLocal() && !c.isEnum()) {\n-                    log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.LocalClassesCantExtendSealed(c.isAnonymous() ? Fragments.Anonymous : Fragments.Local));\n-                }\n@@ -5493,4 +5510,11 @@\n-                if (!c.type.isCompound()) {\n-                    for (ClassSymbol supertypeSym : sealedSupers) {\n-                        if (!supertypeSym.permitted.contains(c.type.tsym)) {\n-                            log.error(TreeInfo.diagnosticPositionFor(c.type.tsym, env.tree), Errors.CantInheritFromSealed(supertypeSym));\n+                    if (!c.type.isCompound()) {\n+                        for (ClassSymbol supertypeSym : sealedSupers) {\n+                            if (!supertypeSym.permitted.contains(c.type.tsym)) {\n+                                log.error(TreeInfo.diagnosticPositionFor(c.type.tsym, env.tree), Errors.CantInheritFromSealed(supertypeSym));\n+                            }\n+                        }\n+                        if (!c.isNonSealed() && !c.isFinal() && !c.isSealed()) {\n+                            log.error(TreeInfo.diagnosticPositionFor(c, env.tree),\n+                                    c.isInterface() ?\n+                                            Errors.NonSealedOrSealedExpected :\n+                                            Errors.NonSealedSealedOrFinalExpected);\n@@ -5498,6 +5522,0 @@\n-                    }\n-                    if (!c.isNonSealed() && !c.isFinal() && !c.isSealed()) {\n-                        log.error(TreeInfo.diagnosticPositionFor(c, env.tree),\n-                                c.isInterface() ?\n-                                        Errors.NonSealedOrSealedExpected :\n-                                        Errors.NonSealedSealedOrFinalExpected);\n@@ -5506,1 +5524,0 @@\n-            }\n@@ -5508,17 +5525,0 @@\n-            \/\/ The info.lint field in the envs stored in typeEnvs is deliberately uninitialized,\n-            \/\/ because the annotations were not available at the time the env was created. Therefore,\n-            \/\/ we look up the environment chain for the first enclosing environment for which the\n-            \/\/ lint value is set. Typically, this is the parent env, but might be further if there\n-            \/\/ are any envs created as a result of TypeParameter nodes.\n-            Env<AttrContext> lintEnv = env;\n-            while (lintEnv.info.lint == null)\n-                lintEnv = lintEnv.next;\n-\n-            \/\/ Having found the enclosing lint value, we can initialize the lint value for this class\n-            env.info.lint = lintEnv.info.lint.augment(c);\n-\n-            Lint prevLint = chk.setLint(env.info.lint);\n-            JavaFileObject prev = log.useSource(c.sourcefile);\n-            ResultInfo prevReturnRes = env.info.returnResult;\n-\n-            try {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":101,"deletions":101,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8316470\n+ * @summary Verify correct source file is set while reporting errors for sealing from Attr\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main SealedErrorPositions\n+*\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class SealedErrorPositions extends TestRunner {\n+\n+    ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new SealedErrorPositions().runTests();\n+    }\n+\n+    SealedErrorPositions() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testDoesNotExtendErrorPosition(Path base) throws IOException {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                           \"\"\"\n+                           package test;\n+                           sealed class C permits A, B { }\n+                           \"\"\",\n+                           \"\"\"\n+                           package test;\n+                           final class A extends C { }\n+                           \"\"\",\n+                           \"\"\"\n+                           package test;\n+                           final class B { }\n+                           \"\"\");\n+        Path test = src.resolve(\"test\");\n+        Path classes = current.resolve(\"classes\");\n+\n+        Files.createDirectories(classes);\n+\n+        var log =\n+                new JavacTask(tb)\n+                    .options(\"-XDrawDiagnostics\",\n+                             \"-implicit:none\",\n+                             \"-sourcepath\", src.toString())\n+                    .outdir(classes)\n+                    .files(test.resolve(\"A.java\"))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expectedErrors = List.of(\n+               \"C.java:2:27: compiler.err.invalid.permits.clause: (compiler.misc.doesnt.extend.sealed: test.B)\",\n+               \"1 error\");\n+\n+        if (!expectedErrors.equals(log)) {\n+            throw new AssertionError(\"Incorrect errors, expected: \" + expectedErrors +\n+                                      \", actual: \" + log);\n+        }\n+    }\n+\n+    @Test\n+    public void testEmptyImplicitPermitsErrorPosition(Path base) throws IOException {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                           \"\"\"\n+                           package test;\n+                           sealed class C { }\n+                           \"\"\",\n+                           \"\"\"\n+                           package test;\n+                           final class A extends C { }\n+                           \"\"\");\n+        Path test = src.resolve(\"test\");\n+        Path classes = current.resolve(\"classes\");\n+\n+        Files.createDirectories(classes);\n+\n+        var log =\n+                new JavacTask(tb)\n+                    .options(\"-XDrawDiagnostics\",\n+                             \"-implicit:none\",\n+                             \"-sourcepath\", src.toString())\n+                    .outdir(classes)\n+                    .files(test.resolve(\"A.java\"))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expectedErrors = List.of(\n+               \"C.java:2:8: compiler.err.sealed.class.must.have.subclasses\",\n+               \"A.java:2:7: compiler.err.cant.inherit.from.sealed: test.C\",\n+               \"2 errors\");\n+\n+        if (!expectedErrors.equals(log)) {\n+            throw new AssertionError(\"Incorrect errors, expected: \" + expectedErrors +\n+                                      \", actual: \" + log);\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/sealed\/SealedErrorPositions.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"}]}