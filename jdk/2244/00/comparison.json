{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,4 +40,0 @@\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.Map;\n@@ -51,0 +47,5 @@\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n@@ -53,1 +54,1 @@\n-import java.util.function.Function;\n+import java.util.Set;\n@@ -55,1 +56,0 @@\n-import static java.util.stream.Collectors.toMap;\n@@ -917,2 +917,1 @@\n-    private static class PlatformMBeanFinder\n-    {\n+    private static class PlatformMBeanFinder {\n@@ -920,0 +919,1 @@\n+\n@@ -923,6 +923,10 @@\n-                (PrivilegedAction<List<PlatformMBeanProvider>>) () -> {\n-                     List<PlatformMBeanProvider> all = new ArrayList<>();\n-                     ServiceLoader.loadInstalled(PlatformMBeanProvider.class)\n-                                  .forEach(all::add);\n-                     all.add(new DefaultPlatformMBeanProvider());\n-                     return all;\n+                new PrivilegedAction<List<PlatformMBeanProvider>>() {\n+                    @Override\n+                    public List<PlatformMBeanProvider> run() {\n+                        List<PlatformMBeanProvider> all = new ArrayList<>();\n+                        for (PlatformMBeanProvider provider : ServiceLoader.loadInstalled(PlatformMBeanProvider.class)) {\n+                            all.add(provider);\n+                        }\n+                        all.add(new DefaultPlatformMBeanProvider());\n+                        return all;\n+                    }\n@@ -930,1 +934,1 @@\n-                         new RuntimePermission(\"sun.management.spi.PlatformMBeanProvider.subclass\"));\n+                new RuntimePermission(\"sun.management.spi.PlatformMBeanProvider.subclass\"));\n@@ -933,7 +937,18 @@\n-            componentMap = providers.stream()\n-                .flatMap(p -> toPlatformComponentStream(p))\n-                \/\/ The first one wins if multiple PlatformComponents\n-                \/\/ with same ObjectName pattern,\n-                .collect(toMap(PlatformComponent::getObjectNamePattern,\n-                               Function.identity(),\n-                              (p1, p2) -> p1));\n+            var map = new HashMap<String, PlatformComponent<?>>();\n+            for (PlatformMBeanProvider provider : providers) {\n+                \/\/ For each provider, ensure that two different components are not declared\n+                \/\/ with the same object name pattern.\n+                var names = new HashSet<String>();\n+                for (PlatformComponent<?> component : provider.getPlatformComponentList()) {\n+                    String name = component.getObjectNamePattern();\n+                    if (!names.add(name)) {\n+                        throw new InternalError(name +\n+                                \" has been used as key by this provider\" +\n+                                \", it cannot be reused for \" + component);\n+                    }\n+                    \/\/ The first one wins if multiple PlatformComponents defined by\n+                    \/\/ different providers use the same ObjectName pattern\n+                    map.putIfAbsent(name, component);\n+                }\n+            }\n+            componentMap = map;\n@@ -946,20 +961,0 @@\n-        \/\/ Loads all platform components from a provider into a stream\n-        \/\/ Ensures that two different components are not declared with the same\n-        \/\/ object name pattern. Throws InternalError if the provider incorrectly\n-        \/\/ declares two platform components with the same pattern.\n-        private static Stream<PlatformComponent<?>>\n-            toPlatformComponentStream(PlatformMBeanProvider provider)\n-        {\n-            return provider.getPlatformComponentList()\n-                           .stream()\n-                           .collect(toMap(PlatformComponent::getObjectNamePattern,\n-                                          Function.identity(),\n-                                          (p1, p2) -> {\n-                                              throw new InternalError(\n-                                                 p1.getObjectNamePattern() +\n-                                                 \" has been used as key for \" + p1 +\n-                                                 \", it cannot be reused for \" + p2);\n-                                          }))\n-                           .values().stream();\n-        }\n-\n","filename":"src\/java.management\/share\/classes\/java\/lang\/management\/ManagementFactory.java","additions":38,"deletions":43,"binary":false,"changes":81,"status":"modified"}]}