{"files":[{"patch":"@@ -4450,1 +4450,1 @@\n-  if (VerifyLoopOptimizations) verify();\n+  DEBUG_ONLY( if(VerifyLoopOptimizations) { verify(); } );\n@@ -4522,1 +4522,1 @@\n-    NOT_PRODUCT( if( VerifyLoopOptimizations ) verify(); );\n+    DEBUG_ONLY( if(VerifyLoopOptimizations) { verify(); } );\n@@ -4645,0 +4645,1 @@\n+#endif\n@@ -4646,0 +4647,1 @@\n+#ifdef ASSERT\n@@ -4647,2 +4649,1 @@\n-\/\/ Build a verify-only PhaseIdealLoop, and see that it agrees with me.\n-static int fail;                \/\/ debug only, so its multi-thread dont care\n+\/\/ Build a verify-only PhaseIdealLoop, and see that it agrees with \"this\".\n@@ -4650,1 +4651,0 @@\n-  int old_progress = C->major_progress();\n@@ -4652,2 +4652,4 @@\n-  PhaseIdealLoop loop_verify(_igvn, this);\n-  VectorSet visited;\n+  int old_progress = C->major_progress();\n+  bool fail = false;\n+\n+  PhaseIdealLoop phase_verify(_igvn, this);\n@@ -4655,7 +4657,9 @@\n-  fail = 0;\n-  verify_compare(C->root(), &loop_verify, visited);\n-  assert(fail == 0, \"verify loops failed\");\n-  \/\/ Verify loop structure is the same\n-  _ltree_root->verify_tree(loop_verify._ltree_root, nullptr);\n-  \/\/ Reset major-progress.  It was cleared by creating a verify version of\n-  \/\/ PhaseIdealLoop.\n+  \/\/ Verify ctrl and idom of every node.\n+  fail |= verify_idom_and_nodes(C->root(), &phase_verify);\n+\n+  \/\/ Verify loop-tree.\n+  fail |= _ltree_root->verify_tree(phase_verify._ltree_root);\n+\n+  assert(!fail, \"verify loops failed\");\n+\n+  \/\/ Major progress was cleared by creating a verify version of PhaseIdealLoop.\n@@ -4665,8 +4669,18 @@\n-\/\/------------------------------verify_compare---------------------------------\n-\/\/ Make sure me and the given PhaseIdealLoop agree on key data structures\n-void PhaseIdealLoop::verify_compare( Node *n, const PhaseIdealLoop *loop_verify, VectorSet &visited ) const {\n-  if( !n ) return;\n-  if( visited.test_set( n->_idx ) ) return;\n-  if( !_nodes[n->_idx] ) {      \/\/ Unreachable\n-    assert( !loop_verify->_nodes[n->_idx], \"both should be unreachable\" );\n-    return;\n+\/\/------------------------------verify_idom_and_nodes-----------------------------\n+\/\/ Perform a BFS starting at n, through all inputs.\n+\/\/ Call verify_idom and verify_node on all nodes of BFS traversal.\n+bool PhaseIdealLoop::verify_idom_and_nodes(Node* root, const PhaseIdealLoop* phase_verify) const {\n+  Unique_Node_List worklist;\n+  worklist.push(root);\n+  bool fail = false;\n+  for (uint i = 0; i < worklist.size(); i++) {\n+    Node* n = worklist.at(i);\n+    \/\/ process node\n+    fail |= verify_idom(n, phase_verify);\n+    fail |= verify_nodes(n, phase_verify);\n+    \/\/ visit inputs\n+    for (uint j = 0; j < n->req(); j++) {\n+      if (n->in(j) != nullptr) {\n+        worklist.push(n->in(j));\n+      }\n+    }\n@@ -4674,0 +4688,2 @@\n+  return fail;\n+}\n@@ -4675,3 +4691,62 @@\n-  uint i;\n-  for( i = 0; i < n->req(); i++ )\n-    verify_compare( n->in(i), loop_verify, visited );\n+\/\/------------------------------verify_idom---------------------------------\n+\/\/ Verify dominator structure (IDOM).\n+bool PhaseIdealLoop::verify_idom(Node* n, const PhaseIdealLoop* phase_verify) const {\n+  \/\/ Verify IDOM for all CFG nodes (except root).\n+  if (!n->is_CFG() || n->is_Root()) {\n+    return false; \/\/ pass\n+  }\n+\n+  if (n->_idx >= _idom_size) {\n+    tty->print(\"CFG Node with no idom: \");\n+    n->dump();\n+    return true; \/\/ fail\n+  }\n+\n+  \/\/ Broken part of VerifyLoopOptimizations (C)\n+  \/\/ Reason:\n+  \/\/   Idom not always set correctly, for example BUG in\n+  \/\/   PhaseIdealLoop::create_new_if_for_predicate\n+  \/\/   at \"set_idom(rgn, nrdom, dom_depth(rgn));\"\n+  \/*\n+  Node *id = idom_no_update(n);\n+  if( id != loop_verify->idom_no_update(n) ) {\n+    tty->print(\"Unequals idoms for: \");\n+    n->dump();\n+    if( fail++ > 10 ) return;\n+    tty->print(\"We have it as: \");\n+    id->dump();\n+    tty->print(\"Verify thinks: \");\n+    loop_verify->idom_no_update(n)->dump();\n+    tty->cr();\n+  }\n+  *\/\n+  return false; \/\/ pass\n+}\n+\n+\/\/------------------------------verify_nodes---------------------------------\n+\/\/ Verify \"_nodes\": control and loop membership.\n+\/\/  (0) _nodes[i] == nullptr -> node not reachable.\n+\/\/  (1) has_ctrl -> check lowest bit. 1 -> data node. 0 -> ctrl node.\n+\/\/  (2) has_ctrl true: get_ctrl_no_update returns ctrl of data node.\n+\/\/  (3) has_ctrl false: get_loop_idx returns IdealLoopTree for ctrl node.\n+bool PhaseIdealLoop::verify_nodes(Node* n, const PhaseIdealLoop* phase_verify) const {\n+  const uint i = n->_idx;\n+  \/\/ The loop-tree was built from def to use (top-down).\n+  \/\/ The verification happens from use to def (bottom-up).\n+  \/\/ We may thus find nodes during verification that are not in the loop-tree.\n+  if (_nodes[i] == nullptr || phase_verify->_nodes[i] == nullptr) {\n+    if (_nodes[i] != nullptr || phase_verify->_nodes[i] != nullptr) {\n+      tty->print_cr(\"Was reachable in only one. this %d, verify %d.\",\n+                 _nodes[i] != nullptr, phase_verify->_nodes[i] != nullptr);\n+      n->dump();\n+      return true; \/\/ fail\n+    }\n+    \/\/ Not reachable for both.\n+    return false; \/\/ pass\n+  }\n+\n+  if (n->is_CFG() == has_ctrl(n)) {\n+    tty->print_cr(\"Exactly one should be true: %d for is_CFG, %d for has_ctrl.\", n->is_CFG(), has_ctrl(n));\n+    n->dump();\n+    return true; \/\/ fail\n+  }\n@@ -4679,3 +4754,15 @@\n-  \/\/ Check the '_nodes' block\/loop structure\n-  i = n->_idx;\n-  if( has_ctrl(n) ) {           \/\/ We have control; verify has loop or ctrl\n+  if (has_ctrl(n) != phase_verify->has_ctrl(n)) {\n+    tty->print_cr(\"Mismatch has_ctrl: %d for this, %d for verify.\", has_ctrl(n), phase_verify->has_ctrl(n));\n+    n->dump();\n+    return true; \/\/ fail\n+  } else if (has_ctrl(n)) {\n+    assert(phase_verify->has_ctrl(n), \"sanity\");\n+    \/\/ n is a data node.\n+    \/\/ Verify that its ctrl is the same.\n+\n+    \/\/ Broken part of VerifyLoopOptimizations (A)\n+    \/\/ Reason:\n+    \/\/   BUG, wrong control set for example in\n+    \/\/   PhaseIdealLoop::split_if_with_blocks\n+    \/\/   at \"set_ctrl(x, new_ctrl);\"\n+    \/*\n@@ -4698,12 +4785,13 @@\n-  } else {                    \/\/ We have a loop\n-    IdealLoopTree *us = get_loop_idx(n);\n-    if( loop_verify->has_ctrl(n) ) {\n-      tty->print(\"Mismatched loop setting for: \");\n-      n->dump();\n-      if( fail++ > 10 ) return;\n-      tty->print(\"We have it as: \");\n-      us->dump();\n-      tty->print(\"Verify thinks: \");\n-      loop_verify->get_ctrl_no_update(n)->dump();\n-      tty->cr();\n-    } else if (!C->major_progress()) {\n+    *\/\n+    return false; \/\/ pass\n+  } else {\n+    assert(!phase_verify->has_ctrl(n), \"sanity\");\n+    \/\/ n is a ctrl node.\n+    \/\/ Verify that not has_ctrl, and that get_loop_idx is the same.\n+\n+    \/\/ Broken part of VerifyLoopOptimizations (B)\n+    \/\/ Reason:\n+    \/\/   NeverBranch node for example is added to loop outside its scope.\n+    \/\/   Once we run build_loop_tree again, it is added to the correct loop.\n+    \/*\n+    if (!C->major_progress()) {\n@@ -4712,0 +4800,1 @@\n+      IdealLoopTree *us = get_loop_idx(n);\n@@ -4724,0 +4813,2 @@\n+    *\/\n+    return false; \/\/ pass\n@@ -4725,0 +4816,1 @@\n+}\n@@ -4726,21 +4818,7 @@\n-  \/\/ Check for immediate dominators being equal\n-  if( i >= _idom_size ) {\n-    if( !n->is_CFG() ) return;\n-    tty->print(\"CFG Node with no idom: \");\n-    n->dump();\n-    return;\n-  }\n-  if( !n->is_CFG() ) return;\n-  if( n == C->root() ) return; \/\/ No IDOM here\n-\n-  assert(n->_idx == i, \"sanity\");\n-  Node *id = idom_no_update(n);\n-  if( id != loop_verify->idom_no_update(n) ) {\n-    tty->print(\"Unequals idoms for: \");\n-    n->dump();\n-    if( fail++ > 10 ) return;\n-    tty->print(\"We have it as: \");\n-    id->dump();\n-    tty->print(\"Verify thinks: \");\n-    loop_verify->idom_no_update(n)->dump();\n-    tty->cr();\n+void IdealLoopTree::collect_children(GrowableArray<IdealLoopTree*> &children) const {\n+  children.clear();\n+  IdealLoopTree* child = _child;\n+  while (child != nullptr) {\n+    assert(child->_parent == this, \"all must be children of this\");\n+    children.push(child);\n+    child = child->_next;\n@@ -4748,0 +4826,1 @@\n+}\n@@ -4749,0 +4828,3 @@\n+int compare_tree(IdealLoopTree** a, IdealLoopTree** b) {\n+  assert((*a) != nullptr && (*b) != nullptr, \"must be\");\n+  return (*a)->_head->_idx - (*b)->_head->_idx;\n@@ -4752,2 +4834,2 @@\n-\/\/ Verify that tree structures match.  Because the CFG can change, siblings\n-\/\/ within the loop tree can be reordered.  We attempt to deal with that by\n+\/\/ Verify that tree structures match. Because the CFG can change, siblings\n+\/\/ within the loop tree can be reordered. We attempt to deal with that by\n@@ -4755,33 +4837,69 @@\n-void IdealLoopTree::verify_tree(IdealLoopTree *loop, const IdealLoopTree *parent) const {\n-  assert( _parent == parent, \"Badly formed loop tree\" );\n-\n-  \/\/ Siblings not in same order?  Attempt to re-order.\n-  if( _head != loop->_head ) {\n-    \/\/ Find _next pointer to update\n-    IdealLoopTree **pp = &loop->_parent->_child;\n-    while( *pp != loop )\n-      pp = &((*pp)->_next);\n-    \/\/ Find proper sibling to be next\n-    IdealLoopTree **nn = &loop->_next;\n-    while( (*nn) && (*nn)->_head != _head )\n-      nn = &((*nn)->_next);\n-\n-    \/\/ Check for no match.\n-    if( !(*nn) ) {\n-      \/\/ Annoyingly, irreducible loops can pick different headers\n-      \/\/ after a major_progress operation, so the rest of the loop\n-      \/\/ tree cannot be matched.\n-      if (_irreducible && Compile::current()->major_progress())  return;\n-      assert( 0, \"failed to match loop tree\" );\n-    }\n-\n-    \/\/ Move (*nn) to (*pp)\n-    IdealLoopTree *hit = *nn;\n-    *nn = hit->_next;\n-    hit->_next = loop;\n-    *pp = loop;\n-    loop = hit;\n-    \/\/ Now try again to verify\n-  }\n-\n-  assert( _head  == loop->_head , \"mismatched loop head\" );\n+bool IdealLoopTree::verify_tree(IdealLoopTree* loop_verify) const {\n+  assert(_head == loop_verify->_head, \"mismatched loop head\");\n+  assert(this->_parent != nullptr || this->_next == nullptr, \"is_root_loop implies has_no_sibling\");\n+\n+  \/\/ Collect the children\n+  GrowableArray<IdealLoopTree*> children;\n+  GrowableArray<IdealLoopTree*> children_verify;\n+  collect_children(children);\n+  loop_verify->collect_children(children_verify);\n+  children.sort(compare_tree);\n+  children_verify.sort(compare_tree);\n+\n+  bool fail = false;\n+\n+  \/\/ Compare the two children lists\n+  for (int i = 0, j = 0; i < children.length() || j < children_verify.length(); ) {\n+    IdealLoopTree* child        = nullptr;\n+    IdealLoopTree* child_verify = nullptr;\n+    \/\/ Read from both lists, if possible.\n+    if (i < children.length()) {\n+      child = children.at(i);\n+    }\n+    if (j < children_verify.length()) {\n+      child_verify = children_verify.at(j);\n+    }\n+    if (child != nullptr && child_verify != nullptr && child->_head != child_verify->_head) {\n+      assert(child->_head->_idx != child_verify->_head->_idx, \"is implied\");\n+      \/\/ We found two non-equal children. Select the smaller one.\n+      if (child->_head->_idx < child_verify->_head->_idx) {\n+        child_verify = nullptr;\n+      } else {\n+        child = nullptr;\n+      }\n+    }\n+    \/\/ Process the two children, or potentially log the failure if we only found one.\n+    if (child_verify == nullptr) {\n+      if (child_verify->_irreducible && Compile::current()->major_progress()) {\n+        \/\/ Irreducible loops can pick a different header (one of its entries).\n+      } else {\n+        tty->print_cr(\"We have loop that verify does not have\");\n+        child->dump();\n+        fail = true;\n+      }\n+      i++; \/\/ step for this\n+    } else if (child == nullptr) {\n+      if (child_verify->_irreducible && Compile::current()->major_progress()) {\n+        \/\/ Irreducible loops can pick a different header (one of its entries).\n+      } else if (child_verify->_head->as_Region()->is_in_infinite_subgraph()) {\n+        \/\/ Infinite loops do not get attached to the loop-tree on their first visit.\n+      } else {\n+        tty->print_cr(\"Verify has loop that we do not have\");\n+        child_verify->dump();\n+        fail = true;\n+      }\n+      j++; \/\/ step for verify\n+    } else {\n+      assert(child->_head == child_verify->_head, \"We have both and they are equal\");\n+      fail |= child->verify_tree(child_verify); \/\/ Recursion\n+      i++; \/\/ step for this\n+      j++; \/\/ step for verify\n+    }\n+  }\n+\n+  \/\/ Broken part of VerifyLoopOptimizations (D)\n+  \/\/ Reason:\n+  \/\/   split_if has to update the _tail, if it is modified. But that is done by\n+  \/\/   checking to what loop the iff belongs to. That info can be wrong, and then\n+  \/\/   we do not update the _tail correctly.\n+  \/*\n@@ -4792,0 +4910,1 @@\n+  *\/\n@@ -4793,2 +4912,1 @@\n-  \/\/ Counted loops that are guarded should be able to find their guards\n-  if( _head->is_CountedLoop() && _head->as_CountedLoop()->is_main_loop() ) {\n+  if (_head->is_CountedLoop()) {\n@@ -4796,19 +4914,0 @@\n-    Node *init = cl->init_trip();\n-    Node *ctrl = cl->in(LoopNode::EntryControl);\n-    assert( ctrl->Opcode() == Op_IfTrue || ctrl->Opcode() == Op_IfFalse, \"\" );\n-    Node *iff  = ctrl->in(0);\n-    assert( iff->Opcode() == Op_If, \"\" );\n-    Node *bol  = iff->in(1);\n-    assert( bol->Opcode() == Op_Bool, \"\" );\n-    Node *cmp  = bol->in(1);\n-    assert( cmp->Opcode() == Op_CmpI, \"\" );\n-    Node *add  = cmp->in(1);\n-    Node *opaq;\n-    if( add->Opcode() == Op_Opaque1 ) {\n-      opaq = add;\n-    } else {\n-      assert( add->Opcode() == Op_AddI || add->Opcode() == Op_ConI , \"\" );\n-      assert( add == init, \"\" );\n-      opaq = cmp->in(2);\n-    }\n-    assert( opaq->Opcode() == Op_Opaque1, \"\" );\n@@ -4816,0 +4915,5 @@\n+    Node* ctrl     = cl->init_control();\n+    Node* back     = cl->back_control();\n+    assert(ctrl != nullptr && ctrl->is_CFG(), \"sane loop in-ctrl\");\n+    assert(back != nullptr && back->is_CFG(), \"sane loop backedge\");\n+    Node* loopexit = cl->loopexit(); \/\/ assert implied\n@@ -4818,2 +4922,6 @@\n-  if (_child != nullptr)  _child->verify_tree(loop->_child, this);\n-  if (_next  != nullptr)  _next ->verify_tree(loop->_next,  parent);\n+  \/\/ Broken part of VerifyLoopOptimizations (E)\n+  \/\/ Reason:\n+  \/\/   PhaseIdealLoop::split_thru_region creates new nodes for loop that are not added\n+  \/\/   to the loop body. Or maybe they are not added to the correct loop.\n+  \/\/   at \"Node* x = n->clone();\"\n+  \/*\n@@ -4862,0 +4970,2 @@\n+  *\/\n+  return fail;\n@@ -4863,1 +4973,0 @@\n-\n@@ -6018,0 +6127,4 @@\n+  \/\/ Broken part of VerifyLoopOptimizations (F)\n+  \/\/ Reason:\n+  \/\/   _verify_me->get_ctrl_no_update(n) seems to return wrong result\n+  \/*\n@@ -6030,0 +6143,1 @@\n+  *\/\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":234,"deletions":120,"binary":false,"changes":354,"status":"modified"},{"patch":"@@ -794,1 +794,5 @@\n-  void verify_tree(IdealLoopTree *loop, const IdealLoopTree *parent) const;\n+#endif\n+\n+#ifdef ASSERT\n+  void collect_children(GrowableArray<IdealLoopTree*> &children) const;\n+  bool verify_tree(IdealLoopTree* loop_verify) const;\n@@ -1700,2 +1704,0 @@\n-  void verify() const;          \/\/ Major slow  :-)\n-  void verify_compare(Node* n, const PhaseIdealLoop* loop_verify, VectorSet &visited) const;\n@@ -1715,0 +1717,7 @@\n+#ifdef ASSERT\n+  void verify() const;\n+  bool verify_idom_and_nodes(Node* root, const PhaseIdealLoop* phase_verify) const;\n+  bool verify_idom(Node* n, const PhaseIdealLoop* phase_verify) const;\n+  bool verify_nodes(Node* n, const PhaseIdealLoop* phase_verify) const;\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -805,1 +805,1 @@\n-    if (VerifyLoopOptimizations) verify();\n+    DEBUG_ONLY( if(VerifyLoopOptimizations) { verify(); } );\n@@ -1439,3 +1439,1 @@\n-#ifndef PRODUCT\n-          if( VerifyLoopOptimizations ) verify();\n-#endif\n+          DEBUG_ONLY( if(VerifyLoopOptimizations) { verify(); } );\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -745,3 +745,1 @@\n-#ifndef PRODUCT\n-  if( VerifyLoopOptimizations ) verify();\n-#endif\n+  DEBUG_ONLY( if(VerifyLoopOptimizations) { verify(); } );\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}