{"files":[{"patch":"@@ -4660,1 +4660,1 @@\n-  _ltree_root->verify_tree(loop_verify._ltree_root, nullptr);\n+  _ltree_root->verify_tree(loop_verify._ltree_root);\n@@ -4691,1 +4691,2 @@\n-  \/\/ The loop-tree was built from def to use. The verification happens from def to use.\n+  \/\/ The loop-tree was built from def to use (top-down).\n+  \/\/ The verification happens from use to def (bottom-up).\n@@ -4715,1 +4716,1 @@\n-    \/\/ Verify that it ctrl is the same.\n+    \/\/ Verify that its ctrl is the same.\n@@ -4801,0 +4802,16 @@\n+\/\/------------------------------verify_tree------------------------------------\n+void IdealLoopTree::collect_children(GrowableArray<IdealLoopTree*> &children) const {\n+  children.clear();\n+  IdealLoopTree* child = _child;\n+  while (child != nullptr) {\n+    assert(child->_parent == this, \"all must be children of this\");\n+    children.push(child);\n+    child = child->_next;\n+  }\n+}\n+\n+int compare_tree(IdealLoopTree** a, IdealLoopTree** b) {\n+  assert((*a) != nullptr && (*b) != nullptr, \"must be\");\n+  return (*a)->_head->_idx - (*b)->_head->_idx;\n+}\n+\n@@ -4805,10 +4822,19 @@\n-void IdealLoopTree::verify_tree(IdealLoopTree* loop, const IdealLoopTree* parent) const {\n-  assert(_parent == parent, \"Badly formed loop tree\");\n-\n-  \/\/ If \"this\" and \"loop\" are not the same sibling of \"parent\", reorder the siblings.\n-  if (_head != loop->_head) {\n-    tty->print_cr(\"reorder loop tree\");\n-    \/\/ Find _next pointer to update (where \"loop\" is attached)\n-    IdealLoopTree **pp = &loop->_parent->_child;\n-    while (*pp != loop) {\n-      pp = &((*pp)->_next);\n+void IdealLoopTree::verify_tree(IdealLoopTree* loop_verify) const {\n+  assert(_head == loop_verify->_head, \"mismatched loop head\");\n+  assert(this->_parent != nullptr || this->_next == nullptr, \"is_root_loop implies has_no_sibling\");\n+\n+  \/\/ Collect the children\n+  GrowableArray<IdealLoopTree*> children;\n+  GrowableArray<IdealLoopTree*> children_verify;\n+  collect_children(children);\n+  loop_verify->collect_children(children_verify);\n+  children.sort(compare_tree);\n+  children_verify.sort(compare_tree);\n+\n+  \/\/ Compare the two children lists\n+  for (int i = 0, j = 0; i < children.length() || j < children_verify.length(); ) {\n+    IdealLoopTree* child        = nullptr;\n+    IdealLoopTree* child_verify = nullptr;\n+    \/\/ Read from both lists, if possible.\n+    if (i < children.length()) {\n+      child = children.at(i);\n@@ -4816,4 +4842,2 @@\n-    \/\/ Find proper sibling to be next (where \"loop\" will be attached)\n-    IdealLoopTree **nn = &loop->_next;\n-    while ((*nn) != nullptr && (*nn)->_head != _head) {\n-      nn = &((*nn)->_next);\n+    if (j < children_verify.length()) {\n+      child_verify = children_verify.at(j);\n@@ -4821,7 +4845,35 @@\n-\n-    \/\/ Check for no match.\n-    if ((*nn) == nullptr) {\n-      \/\/ Annoyingly, irreducible loops can pick different headers (any of the entries)\n-      \/\/ after a major_progress operation, so the rest of the loop tree cannot be matched.\n-      assert(_irreducible && Compile::current()->major_progress(), \"failed to match loop tree\");\n-      return;\n+    if (child != nullptr && child_verify != nullptr && child->_head != child_verify->_head) {\n+      assert(child->_head->_idx != child_verify->_head->_idx, \"is implied\");\n+      \/\/ We found two non-equal children. Select the smaller one.\n+      if (child->_head->_idx < child_verify->_head->_idx) {\n+        child_verify = nullptr;\n+      } else {\n+        child = nullptr;\n+      }\n+    }\n+    \/\/ Process the two children, or potentially log the failure if we only found one.\n+    if (child_verify == nullptr) {\n+      if (child_verify->_irreducible && Compile::current()->major_progress()) {\n+        \/\/ Irreducible loops can pick a different header (one of its entries).\n+      } else {\n+        tty->print_cr(\"We have loop that verify does not have\");\n+        child->dump();\n+        assert(false, \"We have loop that verify does not have\");\n+      }\n+      i++; \/\/ step for this\n+    } else if (child == nullptr) {\n+      if (child_verify->_irreducible && Compile::current()->major_progress()) {\n+        \/\/ Irreducible loops can pick a different header (one of its entries).\n+      } else if (child_verify->_head->as_Region()->is_in_infinite_subgraph()) {\n+        \/\/ Infinite loops do not get attached to the loop-tree on their first visit.\n+      } else {\n+        tty->print_cr(\"Verify has loop that we do not have\");\n+        child_verify->dump();\n+        assert(false, \"Verify has loop that we do not have\");\n+      }\n+      j++; \/\/ step for verify\n+    } else {\n+      assert(child->_head == child_verify->_head, \"We have both and they are equal\");\n+      child->verify_tree(child_verify); \/\/ Recursion\n+      i++; \/\/ step for this\n+      j++; \/\/ step for verify\n@@ -4829,7 +4881,0 @@\n-\n-    \/\/ Swap (*nn) and (*pp)\n-    IdealLoopTree* tmp = *nn;\n-    *nn = tmp->_next;\n-    tmp->_next = loop;\n-    *pp = loop;\n-    loop = tmp;\n@@ -4838,3 +4883,0 @@\n-  \/\/ After reordering, \"this\" and \"loop\" match.\n-  assert(_head == loop->_head, \"mismatched loop head\");\n-\n@@ -4912,8 +4954,0 @@\n-\n-  \/\/ Recurse to children and siblings\n-  if (_child != nullptr) {\n-    _child->verify_tree(loop->_child, this);\n-  }\n-  if (_next != nullptr) {\n-    _next->verify_tree(loop->_next, parent);\n-  }\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":76,"deletions":42,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -794,1 +794,2 @@\n-  void verify_tree(IdealLoopTree* loop, const IdealLoopTree* parent) const;\n+  void collect_children(GrowableArray<IdealLoopTree*> &children) const;\n+  void verify_tree(IdealLoopTree* loop_verify) const;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}