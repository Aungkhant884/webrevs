{"files":[{"patch":"@@ -40,0 +40,181 @@\n+\/\/ A dirty card to oop closure for contiguous spaces (ContiguousSpace and\n+\/\/ sub-classes). It knows how to filter out objects that are outside of the\n+\/\/ _boundary.\n+\/\/ (Note that because of the imprecise nature of the write barrier, this may\n+\/\/ iterate over oops beyond the region.)\n+\/\/\n+\/\/ Assumptions:\n+\/\/ 1. That the actual top of any area in a memory region\n+\/\/    contained by the space is bounded by the end of the contiguous\n+\/\/    region of the space.\n+\/\/ 2. That the space is really made up of objects and not just\n+\/\/    blocks.\n+\n+class DirtyCardToOopClosure: public MemRegionClosure {\n+protected:\n+  OopIterateClosure* _cl;\n+  Space* _sp;\n+  HeapWord* _min_done;          \/\/ Need a downwards traversal to compensate\n+                                \/\/ imprecise write barrier; this is the\n+                                \/\/ lowest location already done (or,\n+                                \/\/ alternatively, the lowest address that\n+                                \/\/ shouldn't be done again.  null means infinity.)\n+  NOT_PRODUCT(HeapWord* _last_bottom;)\n+\n+  \/\/ Get the actual top of the area on which the closure will\n+  \/\/ operate, given where the top is assumed to be (the end of the\n+  \/\/ memory region passed to do_MemRegion) and where the object\n+  \/\/ at the top is assumed to start. For example, an object may\n+  \/\/ start at the top but actually extend past the assumed top,\n+  \/\/ in which case the top becomes the end of the object.\n+  HeapWord* get_actual_top(HeapWord* top, HeapWord* top_obj);\n+\n+  \/\/ Walk the given memory region from bottom to (actual) top\n+  \/\/ looking for objects and applying the oop closure (_cl) to\n+  \/\/ them. The base implementation of this treats the area as\n+  \/\/ blocks, where a block may or may not be an object. Sub-\n+  \/\/ classes should override this to provide more accurate\n+  \/\/ or possibly more efficient walking.\n+  void walk_mem_region(MemRegion mr, HeapWord* bottom, HeapWord* top);\n+\n+  \/\/ Walk the given memory region, from bottom to top, applying\n+  \/\/ the given oop closure to (possibly) all objects found. The\n+  \/\/ given oop closure may or may not be the same as the oop\n+  \/\/ closure with which this closure was created, as it may\n+  \/\/ be a filtering closure which makes use of the _boundary.\n+  \/\/ We offer two signatures, so the FilteringClosure static type is\n+  \/\/ apparent.\n+  void walk_mem_region_with_cl(MemRegion mr,\n+                               HeapWord* bottom, HeapWord* top,\n+                               OopIterateClosure* cl);\n+public:\n+  DirtyCardToOopClosure(Space* sp, OopIterateClosure* cl) :\n+    _cl(cl), _sp(sp), _min_done(nullptr) {\n+    NOT_PRODUCT(_last_bottom = nullptr);\n+  }\n+\n+  void do_MemRegion(MemRegion mr) override;\n+};\n+\n+HeapWord* DirtyCardToOopClosure::get_actual_top(HeapWord* top,\n+                                                HeapWord* top_obj) {\n+  if (top_obj != nullptr && top_obj < (_sp->toContiguousSpace())->top()) {\n+    if (cast_to_oop(top_obj)->is_objArray() || cast_to_oop(top_obj)->is_typeArray()) {\n+      \/\/ An arrayOop is starting on the dirty card - since we do exact\n+      \/\/ store checks for objArrays we are done.\n+    } else {\n+      \/\/ Otherwise, it is possible that the object starting on the dirty\n+      \/\/ card spans the entire card, and that the store happened on a\n+      \/\/ later card.  Figure out where the object ends.\n+      assert(_sp->block_size(top_obj) == cast_to_oop(top_obj)->size(),\n+             \"Block size and object size mismatch\");\n+      top = top_obj + cast_to_oop(top_obj)->size();\n+    }\n+  } else {\n+    top = (_sp->toContiguousSpace())->top();\n+  }\n+  return top;\n+}\n+\n+void DirtyCardToOopClosure::walk_mem_region(MemRegion mr,\n+                                            HeapWord* bottom,\n+                                            HeapWord* top) {\n+  \/\/ Note that this assumption won't hold if we have a concurrent\n+  \/\/ collector in this space, which may have freed up objects after\n+  \/\/ they were dirtied and before the stop-the-world GC that is\n+  \/\/ examining cards here.\n+  assert(bottom < top, \"ought to be at least one obj on a dirty card.\");\n+\n+  walk_mem_region_with_cl(mr, bottom, top, _cl);\n+}\n+\n+\/\/ We get called with \"mr\" representing the dirty region\n+\/\/ that we want to process. Because of imprecise marking,\n+\/\/ we may need to extend the incoming \"mr\" to the right,\n+\/\/ and scan more. However, because we may already have\n+\/\/ scanned some of that extended region, we may need to\n+\/\/ trim its right-end back some so we do not scan what\n+\/\/ we (or another worker thread) may already have scanned\n+\/\/ or planning to scan.\n+void DirtyCardToOopClosure::do_MemRegion(MemRegion mr) {\n+  HeapWord* bottom = mr.start();\n+  HeapWord* last = mr.last();\n+  HeapWord* top = mr.end();\n+  HeapWord* bottom_obj;\n+  HeapWord* top_obj;\n+\n+  assert(_last_bottom == nullptr || top <= _last_bottom,\n+         \"Not decreasing\");\n+  NOT_PRODUCT(_last_bottom = mr.start());\n+\n+  bottom_obj = _sp->block_start(bottom);\n+  top_obj    = _sp->block_start(last);\n+\n+  assert(bottom_obj <= bottom, \"just checking\");\n+  assert(top_obj    <= top,    \"just checking\");\n+\n+  \/\/ Given what we think is the top of the memory region and\n+  \/\/ the start of the object at the top, get the actual\n+  \/\/ value of the top.\n+  top = get_actual_top(top, top_obj);\n+\n+  \/\/ If the previous call did some part of this region, don't redo.\n+  if (_min_done != nullptr && _min_done < top) {\n+    top = _min_done;\n+  }\n+\n+  \/\/ Top may have been reset, and in fact may be below bottom,\n+  \/\/ e.g. the dirty card region is entirely in a now free object\n+  \/\/ -- something that could happen with a concurrent sweeper.\n+  bottom = MIN2(bottom, top);\n+  MemRegion extended_mr = MemRegion(bottom, top);\n+  assert(bottom <= top &&\n+         (_min_done == nullptr || top <= _min_done),\n+         \"overlap!\");\n+\n+  \/\/ Walk the region if it is not empty; otherwise there is nothing to do.\n+  if (!extended_mr.is_empty()) {\n+    walk_mem_region(extended_mr, bottom_obj, top);\n+  }\n+\n+  _min_done = bottom;\n+}\n+\n+void DirtyCardToOopClosure::walk_mem_region_with_cl(MemRegion mr,\n+                                                    HeapWord* bottom,\n+                                                    HeapWord* top,\n+                                                    OopIterateClosure* cl) {\n+  bottom += cast_to_oop(bottom)->oop_iterate_size(cl, mr);\n+  if (bottom < top) {\n+    HeapWord* next_obj = bottom + cast_to_oop(bottom)->size();\n+    while (next_obj < top) {\n+      \/* Bottom lies entirely below top, so we can call the *\/\n+      \/* non-memRegion version of oop_iterate below. *\/\n+      cast_to_oop(bottom)->oop_iterate(cl);\n+      bottom = next_obj;\n+      next_obj = bottom + cast_to_oop(bottom)->size();\n+    }\n+    \/* Last object. *\/\n+    cast_to_oop(bottom)->oop_iterate(cl, mr);\n+  }\n+}\n+\n+class ClearNoncleanCardWrapper: public MemRegionClosure {\n+  DirtyCardToOopClosure* _dirty_card_closure;\n+  CardTableRS* _ct;\n+\n+public:\n+\n+  typedef CardTable::CardValue CardValue;\n+private:\n+  \/\/ Clears the given card, return true if the corresponding card should be\n+  \/\/ processed.\n+  inline bool clear_card(CardValue* entry);\n+  \/\/ check alignment of pointer\n+  bool is_word_aligned(CardValue* entry);\n+\n+public:\n+  ClearNoncleanCardWrapper(DirtyCardToOopClosure* dirty_card_closure, CardTableRS* ct);\n+  void do_MemRegion(MemRegion mr) override;\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.cpp","additions":181,"deletions":0,"binary":false,"changes":181,"status":"modified"},{"patch":"@@ -83,19 +83,0 @@\n-class ClearNoncleanCardWrapper: public MemRegionClosure {\n-  DirtyCardToOopClosure* _dirty_card_closure;\n-  CardTableRS* _ct;\n-\n-public:\n-\n-  typedef CardTable::CardValue CardValue;\n-private:\n-  \/\/ Clears the given card, return true if the corresponding card should be\n-  \/\/ processed.\n-  inline bool clear_card(CardValue* entry);\n-  \/\/ check alignment of pointer\n-  bool is_word_aligned(CardValue* entry);\n-\n-public:\n-  ClearNoncleanCardWrapper(DirtyCardToOopClosure* dirty_card_closure, CardTableRS* ct);\n-  void do_MemRegion(MemRegion mr) override;\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.hpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -49,103 +49,0 @@\n-HeapWord* DirtyCardToOopClosure::get_actual_top(HeapWord* top,\n-                                                HeapWord* top_obj) {\n-  if (top_obj != nullptr && top_obj < (_sp->toContiguousSpace())->top()) {\n-    if (cast_to_oop(top_obj)->is_objArray() || cast_to_oop(top_obj)->is_typeArray()) {\n-      \/\/ An arrayOop is starting on the dirty card - since we do exact\n-      \/\/ store checks for objArrays we are done.\n-    } else {\n-      \/\/ Otherwise, it is possible that the object starting on the dirty\n-      \/\/ card spans the entire card, and that the store happened on a\n-      \/\/ later card.  Figure out where the object ends.\n-      assert(_sp->block_size(top_obj) == cast_to_oop(top_obj)->size(),\n-             \"Block size and object size mismatch\");\n-      top = top_obj + cast_to_oop(top_obj)->size();\n-    }\n-  } else {\n-    top = (_sp->toContiguousSpace())->top();\n-  }\n-  return top;\n-}\n-\n-void DirtyCardToOopClosure::walk_mem_region(MemRegion mr,\n-                                            HeapWord* bottom,\n-                                            HeapWord* top) {\n-  \/\/ Note that this assumption won't hold if we have a concurrent\n-  \/\/ collector in this space, which may have freed up objects after\n-  \/\/ they were dirtied and before the stop-the-world GC that is\n-  \/\/ examining cards here.\n-  assert(bottom < top, \"ought to be at least one obj on a dirty card.\");\n-\n-  walk_mem_region_with_cl(mr, bottom, top, _cl);\n-}\n-\n-\/\/ We get called with \"mr\" representing the dirty region\n-\/\/ that we want to process. Because of imprecise marking,\n-\/\/ we may need to extend the incoming \"mr\" to the right,\n-\/\/ and scan more. However, because we may already have\n-\/\/ scanned some of that extended region, we may need to\n-\/\/ trim its right-end back some so we do not scan what\n-\/\/ we (or another worker thread) may already have scanned\n-\/\/ or planning to scan.\n-void DirtyCardToOopClosure::do_MemRegion(MemRegion mr) {\n-  HeapWord* bottom = mr.start();\n-  HeapWord* last = mr.last();\n-  HeapWord* top = mr.end();\n-  HeapWord* bottom_obj;\n-  HeapWord* top_obj;\n-\n-  assert(_last_bottom == nullptr || top <= _last_bottom,\n-         \"Not decreasing\");\n-  NOT_PRODUCT(_last_bottom = mr.start());\n-\n-  bottom_obj = _sp->block_start(bottom);\n-  top_obj    = _sp->block_start(last);\n-\n-  assert(bottom_obj <= bottom, \"just checking\");\n-  assert(top_obj    <= top,    \"just checking\");\n-\n-  \/\/ Given what we think is the top of the memory region and\n-  \/\/ the start of the object at the top, get the actual\n-  \/\/ value of the top.\n-  top = get_actual_top(top, top_obj);\n-\n-  \/\/ If the previous call did some part of this region, don't redo.\n-  if (_min_done != nullptr && _min_done < top) {\n-    top = _min_done;\n-  }\n-\n-  \/\/ Top may have been reset, and in fact may be below bottom,\n-  \/\/ e.g. the dirty card region is entirely in a now free object\n-  \/\/ -- something that could happen with a concurrent sweeper.\n-  bottom = MIN2(bottom, top);\n-  MemRegion extended_mr = MemRegion(bottom, top);\n-  assert(bottom <= top &&\n-         (_min_done == nullptr || top <= _min_done),\n-         \"overlap!\");\n-\n-  \/\/ Walk the region if it is not empty; otherwise there is nothing to do.\n-  if (!extended_mr.is_empty()) {\n-    walk_mem_region(extended_mr, bottom_obj, top);\n-  }\n-\n-  _min_done = bottom;\n-}\n-\n-void DirtyCardToOopClosure::walk_mem_region_with_cl(MemRegion mr,\n-                                                    HeapWord* bottom,\n-                                                    HeapWord* top,\n-                                                    OopIterateClosure* cl) {\n-  bottom += cast_to_oop(bottom)->oop_iterate_size(cl, mr);\n-  if (bottom < top) {\n-    HeapWord* next_obj = bottom + cast_to_oop(bottom)->size();\n-    while (next_obj < top) {\n-      \/* Bottom lies entirely below top, so we can call the *\/\n-      \/* non-memRegion version of oop_iterate below. *\/\n-      cast_to_oop(bottom)->oop_iterate(cl);\n-      bottom = next_obj;\n-      next_obj = bottom + cast_to_oop(bottom)->size();\n-    }\n-    \/* Last object. *\/\n-    cast_to_oop(bottom)->oop_iterate(cl, mr);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":0,"deletions":103,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -224,59 +224,0 @@\n-\/\/ A dirty card to oop closure for contiguous spaces (ContiguousSpace and\n-\/\/ sub-classes). It knows how to filter out objects that are outside of the\n-\/\/ _boundary.\n-\/\/ (Note that because of the imprecise nature of the write barrier, this may\n-\/\/ iterate over oops beyond the region.)\n-\/\/\n-\/\/ Assumptions:\n-\/\/ 1. That the actual top of any area in a memory region\n-\/\/    contained by the space is bounded by the end of the contiguous\n-\/\/    region of the space.\n-\/\/ 2. That the space is really made up of objects and not just\n-\/\/    blocks.\n-\n-class DirtyCardToOopClosure: public MemRegionClosure {\n-protected:\n-  OopIterateClosure* _cl;\n-  Space* _sp;\n-  HeapWord* _min_done;          \/\/ Need a downwards traversal to compensate\n-                                \/\/ imprecise write barrier; this is the\n-                                \/\/ lowest location already done (or,\n-                                \/\/ alternatively, the lowest address that\n-                                \/\/ shouldn't be done again.  null means infinity.)\n-  NOT_PRODUCT(HeapWord* _last_bottom;)\n-\n-  \/\/ Get the actual top of the area on which the closure will\n-  \/\/ operate, given where the top is assumed to be (the end of the\n-  \/\/ memory region passed to do_MemRegion) and where the object\n-  \/\/ at the top is assumed to start. For example, an object may\n-  \/\/ start at the top but actually extend past the assumed top,\n-  \/\/ in which case the top becomes the end of the object.\n-  HeapWord* get_actual_top(HeapWord* top, HeapWord* top_obj);\n-\n-  \/\/ Walk the given memory region from bottom to (actual) top\n-  \/\/ looking for objects and applying the oop closure (_cl) to\n-  \/\/ them. The base implementation of this treats the area as\n-  \/\/ blocks, where a block may or may not be an object. Sub-\n-  \/\/ classes should override this to provide more accurate\n-  \/\/ or possibly more efficient walking.\n-  void walk_mem_region(MemRegion mr, HeapWord* bottom, HeapWord* top);\n-\n-  \/\/ Walk the given memory region, from bottom to top, applying\n-  \/\/ the given oop closure to (possibly) all objects found. The\n-  \/\/ given oop closure may or may not be the same as the oop\n-  \/\/ closure with which this closure was created, as it may\n-  \/\/ be a filtering closure which makes use of the _boundary.\n-  \/\/ We offer two signatures, so the FilteringClosure static type is\n-  \/\/ apparent.\n-  void walk_mem_region_with_cl(MemRegion mr,\n-                               HeapWord* bottom, HeapWord* top,\n-                               OopIterateClosure* cl);\n-public:\n-  DirtyCardToOopClosure(Space* sp, OopIterateClosure* cl) :\n-    _cl(cl), _sp(sp), _min_done(nullptr) {\n-    NOT_PRODUCT(_last_bottom = nullptr);\n-  }\n-\n-  void do_MemRegion(MemRegion mr) override;\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":0,"deletions":59,"binary":false,"changes":59,"status":"modified"}]}