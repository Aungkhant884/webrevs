{"files":[{"patch":"@@ -672,1 +672,2 @@\n-  size_t            nmt_header_size = MemTracker::malloc_header_size(level);\n+  const size_t nmt_overhead =\n+      MemTracker::malloc_header_size(level) + MemTracker::malloc_footer_size(level);\n@@ -675,1 +676,1 @@\n-  const size_t alloc_size = size + nmt_header_size;\n+  const size_t alloc_size = size + nmt_overhead;\n@@ -677,2 +678,2 @@\n-  const size_t alloc_size = GuardedMemory::get_total_size(size + nmt_header_size);\n-  if (size + nmt_header_size > alloc_size) { \/\/ Check for rollover.\n+  const size_t alloc_size = GuardedMemory::get_total_size(size + nmt_overhead);\n+  if (size + nmt_overhead > alloc_size) { \/\/ Check for rollover.\n@@ -696,1 +697,1 @@\n-  GuardedMemory guarded(ptr, size + nmt_header_size);\n+  GuardedMemory guarded(ptr, size + nmt_overhead);\n@@ -744,2 +745,3 @@\n-  size_t  nmt_header_size = MemTracker::malloc_header_size(level);\n-  void* ptr = ::realloc(membase, size + nmt_header_size);\n+  const size_t nmt_overhead =\n+      MemTracker::malloc_header_size(level) + MemTracker::malloc_footer_size(level);\n+  void* ptr = ::realloc(membase, size + nmt_overhead);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-\n@@ -52,1 +51,0 @@\n-  assert((size_t)table_size <= MAX_MALLOCSITE_TABLE_SIZE, \"Hashtable overflow\");\n","filename":"src\/hotspot\/share\/services\/mallocSiteTable.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -117,0 +117,3 @@\n+  \/\/ The table must not be wider than the maximum value the bucket_idx field\n+  \/\/ in the malloc header can hold.\n+  STATIC_ASSERT(table_size <= MAX_MALLOCSITE_TABLE_SIZE);\n","filename":"src\/hotspot\/share\/services\/mallocSiteTable.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -30,0 +31,2 @@\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/ostream.hpp\"\n@@ -106,1 +109,7 @@\n-void MallocHeader::release() const {\n+void MallocHeader::mark_block_as_dead() {\n+  _canary = _header_canary_dead_mark;\n+  NOT_LP64(_alt_canary = _header_alt_canary_dead_mark);\n+  set_footer_byte(_footer_canary_dead_mark);\n+}\n+\n+void MallocHeader::release() {\n@@ -110,0 +119,2 @@\n+  check_block_integrity();\n+\n@@ -115,0 +126,79 @@\n+\n+  mark_block_as_dead();\n+}\n+\n+void MallocHeader::print_block_on_error(outputStream* st, address bad_address) const {\n+  st->print_cr(\"NMT Block at \" PTR_FORMAT \", corruption at: \" PTR_FORMAT \": \",\n+               p2i(this), p2i(bad_address));\n+  address from = align_down((address)this, sizeof(void*)) - 8;\n+  address to = from + 64;\n+  \/\/ Note: print_hex_dump uses SafeFetch, so it should be able to handle unmapped memory.\n+  os::print_hex_dump(st, from, to, 1);\n+  assert(bad_address >= from, \"sanity\");\n+  \/\/ if the corruption is in the block body of in the footer, print out that part too\n+  \/\/ unless it has been part of the first hexdump\n+  address from2 = align_down(bad_address, sizeof(void*)) - 8;\n+  from2 = MAX2(to, from2);\n+  address to2 = from2 + 96;\n+  if (to2 > to) {\n+    if (from2 > to) {\n+      st->print_cr(\"...\");\n+    }\n+    os::print_hex_dump(st, from2, to2, 1);\n+  }\n+}\n+\n+\/\/ Check block integrity. If block is broken, print out a report\n+\/\/ to tty (optionally with hex dump surrounding the broken block),\n+\/\/ then trigger a fatal error.\n+void MallocHeader::check_block_integrity() const {\n+\n+  \/\/ Note: if you modify the error messages here, make sure you\n+  \/\/ adapt the associated gtests too.\n+\n+  \/\/ Weed out obviously wrong block addresses of NULL or very low\n+  \/\/ values. Note that we should not call this for ::free(NULL),\n+  \/\/ which should be handled by os::free() above us.\n+  if (((size_t)p2i(this)) < K) {\n+    fatal(\"Block at \" PTR_FORMAT \": invalid block address\", p2i(this));\n+  }\n+\n+  \/\/ From here on we assume the block pointer to be valid. We could\n+  \/\/  use SafeFetch but since this is a hot path we don't. If we are\n+  \/\/  wrong, we will crash when accessing the canary, which hopefully\n+  \/\/  generates distinct crash report.\n+\n+  \/\/ Also weed out unaligned addresses. Note that the alignment requirements\n+  \/\/ we check here are the bare minimum of what we know will malloc() give us\n+  \/\/ (which is 64-bit even on 32-bit platforms).\n+  if (!is_aligned(this, sizeof(uint64_t))) {\n+    print_block_on_error(tty, (address)this);\n+    fatal(\"Block at \" PTR_FORMAT \": block address is unaligned\", p2i(this));\n+  }\n+\n+  \/\/ Check header canary\n+  if (_canary != _header_canary_life_mark) {\n+    print_block_on_error(tty, (address)this);\n+    fatal(\"Block at \" PTR_FORMAT \": header canary broken.\", p2i(this));\n+  }\n+\n+#ifndef _LP64\n+  \/\/ On 32-bit we have a second canary, check that one too.\n+  if (_alt_canary != _header_alt_canary_life_mark) {\n+    print_block_on_error(tty, (address)this);\n+    fatal(\"Block at \" PTR_FORMAT \": header alternate canary broken.\", p2i(this));\n+  }\n+#endif\n+\n+  \/\/ Does block size seems reasonable?\n+  if (_size >= max_reasonable_malloc_size) {\n+    print_block_on_error(tty, (address)this);\n+    fatal(\"Block at \" PTR_FORMAT \": header looks invalid (weirdly large block size)\", p2i(this));\n+  }\n+\n+  \/\/ Check footer canary\n+  if (get_footer_byte() != _footer_canary_life_mark) {\n+    print_block_on_error(tty, footer_address());\n+    fatal(\"Block at \" PTR_FORMAT \": footer canary broken at \" PTR_FORMAT \" (buffer overflow?)\",\n+          p2i(this), p2i(footer_address()));\n+  }\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":91,"deletions":1,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -242,2 +242,52 @@\n- * To satisfy malloc alignment requirement, NMT uses 2 machine words for tracking purpose,\n- * which ensures 8-bytes alignment on 32-bit systems and 16-bytes on 64-bit systems (Product build).\n+ *\n+ * If NMT is active (state >= minimal), we need to track allocations. A simple and cheap way to\n+ * do this is by using malloc headers.\n+ *\n+ * The user allocation is preceded by a header and followed by a single footer canary byte:\n+ *\n+ * +--------------+-------------  ....  ------------------+-----+\n+ * |    header    |               user                    | can |\n+ * |              |             allocation                | ary |\n+ * +--------------+-------------  ....  ------------------+-----+\n+ *     16 bytes              user size                      1 byte\n+ *\n+ * Alignment:\n+ *\n+ * The start of the user allocation needs to adhere to malloc alignment. We assume 2 words\n+ * (16 bytes\/8 bytes on 64-bit\/32-bit) to be enough for that (todo: it may not be enough on 32bit).\n+ *\n+ * That dictates a minimum alignment of the size of a malloc header of 2 words. However, since\n+ * 8 bytes are not enough to hold all information we need, we have to enlarge the malloc header on\n+ * 32-bit. So the malloc header is 16 bytes long on both 32-bit and 64-bit.\n+ *\n+ * Layout on 64-bit:\n+ *\n+ *     0        1        2        3        4        5        6        7\n+ * +--------+--------+--------+--------+--------+--------+--------+--------+\n+ * |                            64-bit size                                |  ...\n+ * +--------+--------+--------+--------+--------+--------+--------+--------+\n+ *\n+ *           8        9        10       11       12       13       14       15          16 ++\n+ *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n+ *  ...  |   bucket idx    |     pos idx     | flags  | unused |     canary      |  ... User payload ....\n+ *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n+ *\n+ * Layout on 32-bit:\n+ *\n+ *     0        1        2        3        4        5        6        7\n+ * +--------+--------+--------+--------+--------+--------+--------+--------+\n+ * |            alt. canary            |           32-bit size             |  ...\n+ * +--------+--------+--------+--------+--------+--------+--------+--------+\n+ *\n+ *           8        9        10       11       12       13       14       15          16 ++\n+ *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n+ *  ...  |   bucket idx    |     pos idx     | flags  | unused |     canary      |  ... User payload ....\n+ *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n+ *\n+ * Notes:\n+ * - We have a canary in the two bytes directly preceding the user payload. That allows us to\n+ *   catch negative buffer overflows.\n+ * - On 32-bit, due to the smaller size_t, we have some bits to spare. So we also have a second\n+ *   canary at the very start of the malloc header (generously sized 32 bits).\n+ * - The footer canary is just one byte since this is still enough to catch overflows, and it\n+ *   allows us to not care about aligned accesses.\n@@ -247,15 +297,32 @@\n-#ifdef _LP64\n-  size_t           _size      : 64;\n-  size_t           _flags     : 8;\n-  size_t           _pos_idx   : 16;\n-  size_t           _bucket_idx: 40;\n-#define MAX_MALLOCSITE_TABLE_SIZE right_n_bits(40)\n-#define MAX_BUCKET_LENGTH         right_n_bits(16)\n-#else\n-  size_t           _size      : 32;\n-  size_t           _flags     : 8;\n-  size_t           _pos_idx   : 8;\n-  size_t           _bucket_idx: 16;\n-#define MAX_MALLOCSITE_TABLE_SIZE  right_n_bits(16)\n-#define MAX_BUCKET_LENGTH          right_n_bits(8)\n-#endif  \/\/ _LP64\n+\n+  NOT_LP64(uint32_t _alt_canary);\n+  size_t _size;\n+  uint16_t _bucket_idx;\n+  uint16_t _pos_idx;\n+  uint8_t _flags;\n+  uint8_t _unused;\n+  uint16_t _canary;\n+\n+#define MAX_MALLOCSITE_TABLE_SIZE (USHRT_MAX - 1)\n+#define MAX_BUCKET_LENGTH         (USHRT_MAX - 1)\n+\n+  static const uint16_t _header_canary_life_mark = 0xFA1F;\n+  static const uint16_t _header_canary_dead_mark = 0xFB1F;\n+  static const uint8_t  _footer_canary_life_mark = 0xFA;\n+  static const uint8_t  _footer_canary_dead_mark = 0xFB;\n+  NOT_LP64(static const uint32_t _header_alt_canary_life_mark = 0xFAFA1F1F;)\n+  NOT_LP64(static const uint32_t _header_alt_canary_dead_mark = 0xFBFB1F1F;)\n+\n+  \/\/ We discount sizes larger than these\n+  static const size_t max_reasonable_malloc_size = LP64_ONLY(256 * G) NOT_LP64(3500 * M);\n+\n+  \/\/ Check block integrity. If block is broken, print out a report\n+  \/\/ to tty (optionally with hex dump surrounding the broken block),\n+  \/\/ then trigger a fatal error.\n+  void check_block_integrity() const;\n+  void print_block_on_error(outputStream* st, address bad_address) const;\n+  void mark_block_as_dead();\n+\n+  uint8_t* footer_address() const { return ((address)this) + sizeof(MallocHeader) + _size; }\n+  uint8_t get_footer_byte() const { return *footer_address(); }\n+  void set_footer_byte(uint8_t b) { (*footer_address()) = b; }\n@@ -264,0 +331,1 @@\n+\n@@ -265,2 +333,2 @@\n-    assert(sizeof(MallocHeader) == sizeof(void*) * 2,\n-      \"Wrong header size\");\n+\n+    assert(size < max_reasonable_malloc_size, \"Too large allocation size?\");\n@@ -280,2 +348,2 @@\n-        _bucket_idx = bucket_idx;\n-        _pos_idx = pos_idx;\n+        _bucket_idx = (uint16_t)bucket_idx;\n+        _pos_idx = (uint16_t)pos_idx;\n@@ -285,0 +353,7 @@\n+    _unused = 0;\n+    _canary = _header_canary_life_mark;\n+    \/\/ On 32-bit we have some bits more, use them for a second canary\n+    \/\/ guarding the start of the header.\n+    NOT_LP64(_alt_canary = _header_alt_canary_life_mark;)\n+    set_footer_byte(_footer_canary_life_mark); \/\/ set after initializing _size\n+\n@@ -293,2 +368,2 @@\n-  \/\/ Cleanup tracking information before the memory is released.\n-  void release() const;\n+  \/\/ Cleanup tracking information and mark block as dead before the memory is released.\n+  void release();\n@@ -304,0 +379,3 @@\n+\/\/ This needs to be true on both 64-bit and 32-bit platforms\n+STATIC_ASSERT(sizeof(MallocHeader) == (sizeof(uint64_t) * 2));\n+\n@@ -318,0 +396,5 @@\n+  \/\/ malloc tracking footer size for specific tracking level\n+  static inline size_t malloc_footer_size(NMT_TrackingLevel level) {\n+    return (level == NMT_off) ? 0 : 1;\n+  }\n+\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":106,"deletions":23,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+  static inline size_t malloc_footer_size(NMT_TrackingLevel level) { return 0; }\n@@ -160,0 +161,5 @@\n+  \/\/ malloc tracking footer size for specific tracking level\n+  static inline size_t malloc_footer_size(NMT_TrackingLevel level) {\n+    return MallocTracker::malloc_footer_size(level);\n+  }\n+\n","filename":"src\/hotspot\/share\/services\/memTracker.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -240,1 +240,0 @@\n-#ifdef ASSERT\n@@ -265,1 +264,0 @@\n-#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"services\/memTracker.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"unittest.hpp\"\n+\n+#if INCLUDE_NMT\n+\n+#define DEFINE_TEST(test_function, expected_assertion_message)                            \\\n+  TEST_VM_FATAL_ERROR_MSG(NMT, test_function, \".*\" expected_assertion_message \".*\") {     \\\n+    if (MemTracker::tracking_level() > NMT_off) {                                         \\\n+      tty->print_cr(\"NMT overwrite death test, please ignore subsequent error dump.\");    \\\n+      test_function ();                                                                   \\\n+    } else {                                                                              \\\n+      \/* overflow detection requires NMT to be on. If off, fake assert. *\/                \\\n+      guarantee(false,                                                                    \\\n+                \"fake message ignore this - \" expected_assertion_message);                \\\n+    }                                                                                     \\\n+  }\n+\n+\/\/\/\/\/\/\/\n+\n+static void test_overwrite_front() {\n+  address p = (address) os::malloc(1, mtTest);\n+  *(p - 1) = 'a';\n+  os::free(p);\n+}\n+\n+DEFINE_TEST(test_overwrite_front, \"header canary broken\")\n+\n+\/\/\/\/\/\/\/\n+\n+static void test_overwrite_back() {\n+  address p = (address) os::malloc(1, mtTest);\n+  *(p + 1) = 'a';\n+  os::free(p);\n+}\n+\n+DEFINE_TEST(test_overwrite_back, \"footer canary broken\")\n+\n+\/\/\/\/\/\/\/\n+\n+\/\/ this should generate two hex dumps, one with the front header, one with the overwritten\n+\/\/ portion.\n+static void test_overwrite_back_long() {\n+  address p = (address) os::malloc(0x2000, mtTest);\n+  *(p + 0x2000) = 'a';\n+  os::free(p);\n+}\n+\n+DEFINE_TEST(test_overwrite_back_long, \"footer canary broken\")\n+\n+\/\/\/\/\/\/\/\n+\n+static void test_double_free() {\n+  address p = (address) os::malloc(1, mtTest);\n+  os::free(p);\n+  \/\/ Now a double free. Note that this is susceptible to concurrency issues should\n+  \/\/ a concurrent thread have done a malloc and gotten the same address after the\n+  \/\/ first free. To decrease chance of this happening, we repeat the double free\n+  \/\/ several times.\n+  for (int i = 0; i < 100; i ++) {\n+    os::free(p);\n+  }\n+}\n+\n+\/\/ What assertion message we will see depends on whether the VM wipes the memory-to-be-freed\n+\/\/ on the first free(), and whether the libc uses the freed memory to store bookkeeping information.\n+\/\/ If the death marker in the header is still intact after the first free, we will recognize this as\n+\/\/ double free; if it got wiped, we should at least see a broken header canary.\n+\/\/ The message would be either\n+\/\/ - \"header canary broken\" or\n+\/\/ - \"header canary dead (double free?)\".\n+\/\/ However, since gtest regex expressions do not support unions (a|b), I search for a reasonable\n+\/\/ subset here.\n+DEFINE_TEST(test_double_free, \"header canary\")\n+\n+\/\/\/\/\/\/\/\n+\n+static void test_invalid_block_address() {\n+  \/\/ very low, like the result of an overflow or of accessing a NULL this pointer\n+  os::free((void*)0x100);\n+}\n+DEFINE_TEST(test_invalid_block_address, \"invalid block address\")\n+\n+\/\/\/\/\/\/\/\n+\n+static void test_unaliged_block_address() {\n+  address p = (address) os::malloc(1, mtTest);\n+  os::free(p + 6);\n+}\n+DEFINE_TEST(test_unaliged_block_address, \"block address is unaligned\");\n+\n+#endif \/\/ INCLUDE_NMT\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_buffer_overflow_detection.cpp","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -152,0 +152,17 @@\n+#define TEST_VM_FATAL_ERROR_MSG(category, name, msg)                \\\n+  static void test_  ## category ## _ ## name ## _();               \\\n+                                                                    \\\n+  static void child_ ## category ## _ ## name ## _() {              \\\n+    ::testing::GTEST_FLAG(throw_on_failure) = true;                 \\\n+    test_ ## category ## _ ## name ## _();                          \\\n+    exit(0);                                                        \\\n+  }                                                                 \\\n+                                                                    \\\n+  TEST(category, CONCAT(name, _vm_assert)) {                        \\\n+    ASSERT_EXIT(child_ ## category ## _ ## name ## _(),             \\\n+                ::testing::ExitedWithCode(1),                       \\\n+                msg);                            \\\n+  }                                                                 \\\n+                                                                    \\\n+  void test_ ## category ## _ ## name ## _()\n+\n","filename":"test\/hotspot\/gtest\/unittest.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"}]}