{"files":[{"patch":"@@ -131,0 +131,9 @@\n+  assert(bad_address >= (address)this, \"sanity\");\n+\n+  \/\/ This function prints block information, including hex dump, in case of a detected\n+  \/\/ corruption. The hex dump should show the both block header and the corruption site\n+  \/\/ (which may or may not be close together or identical). Plus some surrounding area.\n+  \/\/\n+  \/\/ Note that we use os::print_hex_dump(), which is able to cope with unmapped\n+  \/\/ memory (it uses SafeFetch).\n+\n@@ -133,14 +142,9 @@\n-  address from = align_down((address)this, sizeof(void*)) - 8;\n-  address to = from + 64;\n-  \/\/ Note: print_hex_dump uses SafeFetch, so it should be able to handle unmapped memory.\n-  os::print_hex_dump(st, from, to, 1);\n-  assert(bad_address >= from, \"sanity\");\n-  \/\/ if the corruption is in the block body of in the footer, print out that part too\n-  \/\/ unless it has been part of the first hexdump\n-  address from2 = align_down(bad_address, sizeof(void*)) - 8;\n-  from2 = MAX2(to, from2);\n-  address to2 = from2 + 96;\n-  if (to2 > to) {\n-    if (from2 > to) {\n-      st->print_cr(\"...\");\n-    }\n+  static const size_t min_dump_length = 256;\n+  address from1 = align_down((address)this, sizeof(void*)) - (min_dump_length \/ 2);\n+  address to1 = from1 + min_dump_length;\n+  address from2 = align_down(bad_address, sizeof(void*)) - (min_dump_length \/ 2);\n+  address to2 = from2 + min_dump_length;\n+  if (from2 > to1) {\n+    \/\/ Dump gets too large, split up in two sections.\n+    os::print_hex_dump(st, from1, to1, 1);\n+    st->print_cr(\"...\");\n@@ -148,0 +152,3 @@\n+  } else {\n+    \/\/ print one hex dump\n+    os::print_hex_dump(st, from1, to2, 1);\n@@ -167,7 +174,14 @@\n-  \/\/  use SafeFetch but since this is a hot path we don't. If we are\n-  \/\/  wrong, we will crash when accessing the canary, which hopefully\n-  \/\/  generates distinct crash report.\n-\n-  \/\/ Also weed out unaligned addresses. Note that the alignment requirements\n-  \/\/ we check here are the bare minimum of what we know will malloc() give us\n-  \/\/ (which is 64-bit even on 32-bit platforms).\n+  \/\/ use SafeFetch but since this is a hot path we don't. If we are\n+  \/\/ wrong, we will crash when accessing the canary, which hopefully\n+  \/\/ generates distinct crash report.\n+\n+  \/\/ Weed out obviously unaligned addresses. NMT blocks, being the result of\n+  \/\/ malloc calls, should adhere to malloc() alignment. Malloc alignment is\n+  \/\/ specified by the standard by this requirement:\n+  \/\/ \"malloc returns a pointer which is suitably aligned for any built-in type\"\n+  \/\/ For us it means that it is *at least* 64-bit on all of our 32-bit and\n+  \/\/ 64-bit platforms since we have native 64-bit types. It very probably is\n+  \/\/ larger than that, since there exist scalar types larger than 64bit. Here,\n+  \/\/ we test the smallest alignment we know.\n+  \/\/ Should we ever start using std::max_align_t, this would be one place to\n+  \/\/ fix up.\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":35,"deletions":21,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -69,2 +69,2 @@\n-\/\/ this should generate two hex dumps, one with the front header, one with the overwritten\n-\/\/ portion.\n+\/\/ A overwriter farther away from the NMT header; the report should show the hex dump split up\n+\/\/ in two parts, containing both header and corruption site.\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_buffer_overflow_detection.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}