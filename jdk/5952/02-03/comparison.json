{"files":[{"patch":"@@ -163,0 +163,1 @@\n+#define PREFIX \"NMT corruption: \"\n@@ -170,1 +171,1 @@\n-    fatal(\"Block at \" PTR_FORMAT \": invalid block address\", p2i(this));\n+    fatal(PREFIX \"Block at \" PTR_FORMAT \": invalid block address\", p2i(this));\n@@ -190,1 +191,1 @@\n-    fatal(\"Block at \" PTR_FORMAT \": block address is unaligned\", p2i(this));\n+    fatal(PREFIX \"Block at \" PTR_FORMAT \": block address is unaligned\", p2i(this));\n@@ -196,1 +197,1 @@\n-    fatal(\"Block at \" PTR_FORMAT \": header canary broken.\", p2i(this));\n+    fatal(PREFIX \"Block at \" PTR_FORMAT \": header canary broken.\", p2i(this));\n@@ -203,1 +204,1 @@\n-    fatal(\"Block at \" PTR_FORMAT \": header alternate canary broken.\", p2i(this));\n+    fatal(PREFIX \"Block at \" PTR_FORMAT \": header alternate canary broken.\", p2i(this));\n@@ -210,1 +211,1 @@\n-    fatal(\"Block at \" PTR_FORMAT \": header looks invalid (weirdly large block size)\", p2i(this));\n+    fatal(PREFIX \"Block at \" PTR_FORMAT \": header looks invalid (weirdly large block size)\", p2i(this));\n@@ -216,1 +217,1 @@\n-    fatal(\"Block at \" PTR_FORMAT \": footer canary broken at \" PTR_FORMAT \" (buffer overflow?)\",\n+    fatal(PREFIX \"Block at \" PTR_FORMAT \": footer canary broken at \" PTR_FORMAT \" (buffer overflow?)\",\n@@ -219,0 +220,1 @@\n+#undef PREFIX\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"testutils.hpp\"\n@@ -35,0 +36,4 @@\n+\/\/ This prefix shows up on any c heap corruption NMT detects. If unsure which assert will\n+\/\/ come, just use this one.\n+#define COMMON_NMT_HEAP_CORRUPTION_MESSAGE_PREFIX \"NMT corruption\"\n+\n@@ -71,3 +76,3 @@\n-static void test_overwrite_back_long() {\n-  address p = (address) os::malloc(0x2000, mtTest);\n-  *(p + 0x2000) = 'a';\n+static void test_overwrite_back_long(size_t distance) {\n+  address p = (address) os::malloc(distance, mtTest);\n+  *(p + distance) = 'a';\n@@ -76,2 +81,4 @@\n-\n-DEFINE_TEST(test_overwrite_back_long, \"footer canary broken\")\n+static void test_overwrite_back_long_aligned_distance()   { test_overwrite_back_long(0x2000); }\n+DEFINE_TEST(test_overwrite_back_long_aligned_distance, \"footer canary broken\")\n+static void test_overwrite_back_long_unaligned_distance() { test_overwrite_back_long(0x2001); }\n+DEFINE_TEST(test_overwrite_back_long_unaligned_distance, \"footer canary broken\")\n@@ -120,0 +127,37 @@\n+\/\/\/\/\/\/\/\n+\n+\/\/ Test that we notice block corruption on realloc too\n+static void test_corruption_on_realloc(size_t s1, size_t s2) {\n+  address p1 = (address) os::malloc(s1, mtTest);\n+  *(p1 + s1) = 'a';\n+  address p2 = (address) os::realloc(p1, s2, mtTest);\n+  ASSERT_TRUE(false); \/\/ we should not be here; we should have crashed\n+  os::free(p2);\n+}\n+static void test_corruption_on_realloc_growing()    { test_corruption_on_realloc(0x101, 0x102); }\n+DEFINE_TEST(test_corruption_on_realloc_growing, COMMON_NMT_HEAP_CORRUPTION_MESSAGE_PREFIX);\n+static void test_corruption_on_realloc_shrinking()  { test_corruption_on_realloc(0x102, 0x101); }\n+DEFINE_TEST(test_corruption_on_realloc_shrinking, COMMON_NMT_HEAP_CORRUPTION_MESSAGE_PREFIX);\n+\n+\/\/\/\/\/\/\/\n+\n+\/\/ realloc is the trickiest of the bunch. Test that realloc works and correctly takes over\n+\/\/ NMT header and footer to the resized block. We just test that nothing crashes - if the\n+\/\/ header\/footer get corrupted, NMT heap corruption checker will trigger alert on os::free()).\n+TEST_VM(NMT, test_realloc) {\n+  \/\/ We test both directions (growing and shrinking) and a small range for each to cover all\n+  \/\/ size alignment variants. Should not matter, but this should be cheap.\n+  for (size_t s1 = 0xF0; s1 < 0x110; s1 ++) {\n+    for (size_t s2 = 0x100; s2 > 0xF0; s2 --) {\n+      address p1 = (address) os::malloc(s1, mtTest);\n+      ASSERT_NOT_NULL(p1);\n+      GtestUtils::mark_range(p1, s1);       \/\/ mark payload range...\n+      address p2 = (address) os::realloc(p1, s2, mtTest);\n+      ASSERT_NOT_NULL(p2);\n+      ASSERT_RANGE_IS_MARKED(p2, MIN2(s1, s2))        \/\/ ... and check that it survived the resize\n+         << s1 << \"->\" << s2 << std::endl;\n+      os::free(p2);                         \/\/ <- if NMT headers\/footers got corrupted this asserts\n+    }\n+  }\n+}\n+\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_buffer_overflow_detection.cpp","additions":49,"deletions":5,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -60,1 +60,2 @@\n-    tty->print_cr(\"wrong pattern around \" PTR_FORMAT, p2i(first_wrong));\n+    tty->print_cr(\"check_range [\" PTR_FORMAT \"..\" PTR_FORMAT \"), 0x%X, : wrong pattern around \" PTR_FORMAT,\n+                  p2i(p), p2i(p) + s, expected, p2i(first_wrong));\n","filename":"test\/hotspot\/gtest\/testutils.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-#define ASSERT_NOT_NULL(p)  ASSERT_NE(p, (char*)NULL)\n-#define ASSERT_NULL(p)      ASSERT_EQ(p, (char*)NULL)\n+#define ASSERT_NOT_NULL(p)  ASSERT_NE(p2i(p), 0)\n+#define ASSERT_NULL(p)      ASSERT_EQ(p2i(p), 0)\n","filename":"test\/hotspot\/gtest\/testutils.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}