{"files":[{"patch":"@@ -347,76 +347,0 @@\n-\n-    public $Type$Buffer get($type$[] dst, int offset, int length) {\n-#if[rw]\n-        if (((long)length << $LG_BYTES_PER_VALUE$) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {\n-            Objects.checkFromIndexSize(offset, length, dst.length);\n-            int pos = position();\n-            int lim = limit();\n-            assert (pos <= lim);\n-            int rem = (pos <= lim ? lim - pos : 0);\n-            if (length > rem)\n-                throw new BufferUnderflowException();\n-\n-            long dstOffset = ARRAY_BASE_OFFSET + ((long)offset << $LG_BYTES_PER_VALUE$);\n-            try {\n-#if[!byte]\n-                if (order() != ByteOrder.nativeOrder())\n-                    SCOPED_MEMORY_ACCESS.copySwapMemory(scope(), null, null,\n-                                          ix(pos),\n-                                          dst,\n-                                          dstOffset,\n-                                          (long)length << $LG_BYTES_PER_VALUE$,\n-                                          (long)1 << $LG_BYTES_PER_VALUE$);\n-                else\n-#end[!byte]\n-                    SCOPED_MEMORY_ACCESS.copyMemory(scope(), null, null,\n-                                      ix(pos),\n-                                      dst,\n-                                      dstOffset,\n-                                      (long)length << $LG_BYTES_PER_VALUE$);\n-            } finally {\n-                Reference.reachabilityFence(this);\n-            }\n-            position(pos + length);\n-        } else {\n-            super.get(dst, offset, length);\n-        }\n-        return this;\n-#else[rw]\n-        throw new ReadOnlyBufferException();\n-#end[rw]\n-    }\n-\n-    public $Type$Buffer get(int index, $type$[] dst, int offset, int length) {\n-#if[rw]\n-        if (((long)length << $LG_BYTES_PER_VALUE$) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {\n-            Objects.checkFromIndexSize(index, length, limit());\n-            Objects.checkFromIndexSize(offset, length, dst.length);\n-\n-            long dstOffset = ARRAY_BASE_OFFSET + ((long)offset << $LG_BYTES_PER_VALUE$);\n-            try {\n-#if[!byte]\n-                if (order() != ByteOrder.nativeOrder())\n-                    SCOPED_MEMORY_ACCESS.copySwapMemory(scope(), null, null,\n-                                          ix(index),\n-                                          dst,\n-                                          dstOffset,\n-                                          (long)length << $LG_BYTES_PER_VALUE$,\n-                                          (long)1 << $LG_BYTES_PER_VALUE$);\n-                else\n-#end[!byte]\n-                    SCOPED_MEMORY_ACCESS.copyMemory(scope(), null, null,\n-                                      ix(index),\n-                                      dst,\n-                                      dstOffset,\n-                                      (long)length << $LG_BYTES_PER_VALUE$);\n-            } finally {\n-                Reference.reachabilityFence(this);\n-            }\n-        } else {\n-            super.get(index, dst, offset, length);\n-        }\n-        return this;\n-#else[rw]\n-        throw new ReadOnlyBufferException();\n-#end[rw]\n-    }\n@@ -451,93 +375,0 @@\n-    public $Type$Buffer put($Type$Buffer src) {\n-#if[rw]\n-        super.put(src);\n-        return this;\n-#else[rw]\n-        throw new ReadOnlyBufferException();\n-#end[rw]\n-    }\n-\n-    public $Type$Buffer put(int index, $Type$Buffer src, int offset, int length) {\n-#if[rw]\n-        super.put(index, src, offset, length);\n-        return this;\n-#else[rw]\n-        throw new ReadOnlyBufferException();\n-#end[rw]\n-    }\n-\n-    public $Type$Buffer put($type$[] src, int offset, int length) {\n-#if[rw]\n-        if (((long)length << $LG_BYTES_PER_VALUE$) > Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {\n-            Objects.checkFromIndexSize(offset, length, src.length);\n-            int pos = position();\n-            int lim = limit();\n-            assert (pos <= lim);\n-            int rem = (pos <= lim ? lim - pos : 0);\n-            if (length > rem)\n-                throw new BufferOverflowException();\n-\n-            long srcOffset = ARRAY_BASE_OFFSET + ((long)offset << $LG_BYTES_PER_VALUE$);\n-            try {\n-#if[!byte]\n-                if (order() != ByteOrder.nativeOrder())\n-                    SCOPED_MEMORY_ACCESS.copySwapMemory(null, scope(), src,\n-                                          srcOffset,\n-                                          null,\n-                                          ix(pos),\n-                                          (long)length << $LG_BYTES_PER_VALUE$,\n-                                          (long)1 << $LG_BYTES_PER_VALUE$);\n-                else\n-#end[!byte]\n-                    SCOPED_MEMORY_ACCESS.copyMemory(null, scope(), src,\n-                                      srcOffset,\n-                                      null,\n-                                      ix(pos),\n-                                      (long)length << $LG_BYTES_PER_VALUE$);\n-            } finally {\n-                Reference.reachabilityFence(this);\n-            }\n-            position(pos + length);\n-        } else {\n-            super.put(src, offset, length);\n-        }\n-        return this;\n-#else[rw]\n-        throw new ReadOnlyBufferException();\n-#end[rw]\n-    }\n-\n-    public $Type$Buffer put(int index, $type$[] src, int offset, int length) {\n-#if[rw]\n-        if (((long)length << $LG_BYTES_PER_VALUE$) > Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {\n-            Objects.checkFromIndexSize(index, length, limit());\n-            Objects.checkFromIndexSize(offset, length, src.length);\n-\n-\n-            long srcOffset = ARRAY_BASE_OFFSET + ((long)offset << $LG_BYTES_PER_VALUE$);\n-            try {\n-#if[!byte]\n-                if (order() != ByteOrder.nativeOrder())\n-                    SCOPED_MEMORY_ACCESS.copySwapMemory(null, scope(), src,\n-                                          srcOffset,\n-                                          null,\n-                                          ix(index),\n-                                          (long)length << $LG_BYTES_PER_VALUE$,\n-                                          (long)1 << $LG_BYTES_PER_VALUE$);\n-                else\n-#end[!byte]\n-                    SCOPED_MEMORY_ACCESS.copyMemory(\n-                            null, scope(), src,\n-                            srcOffset, null, ix(index), (long)length << $LG_BYTES_PER_VALUE$);\n-            } finally {\n-                Reference.reachabilityFence(this);\n-            }\n-        } else {\n-            super.put(index, src, offset, length);\n-        }\n-        return this;\n-#else[rw]\n-        throw new ReadOnlyBufferException();\n-#end[rw]\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":0,"deletions":169,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -271,0 +271,5 @@\n+    \/\/ Cached array base offset\n+    private static final long ARRAY_BASE_OFFSET = UNSAFE.arrayBaseOffset($type$[].class);\n+\n+    \/\/ Number of bytes per $type$\n+    private static final long ELEMENT_SIZE = 1L << $LG_BYTES_PER_VALUE$;\n@@ -794,1 +799,2 @@\n-        if (length > remaining())\n+        int pos = position();\n+        if (length > limit() - pos)\n@@ -797,2 +803,4 @@\n-        for (int i = offset; i < end; i++)\n-            dst[i] = get();\n+\n+        getArray(pos, dst, offset, length);\n+\n+        position(pos + length);\n@@ -872,3 +880,3 @@\n-        int end = offset + length;\n-        for (int i = offset, j = index; i < end; i++, j++)\n-            dst[i] = get(j);\n+\n+        getArray(index, dst, offset, length);\n+\n@@ -909,0 +917,38 @@\n+    private $Type$Buffer getArray(int index, $type$[] dst, int offset, int length) {\n+#if[rw]\n+        if (\n+#if[char]\n+            isAddressable() &&\n+#end[char]\n+            ((long)length << $LG_BYTES_PER_VALUE$) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {\n+            long bufAddr = address + ((long)index << $LG_BYTES_PER_VALUE$);\n+            long dstOffset =\n+                ARRAY_BASE_OFFSET + ((long)offset << $LG_BYTES_PER_VALUE$);\n+            long len = (long)length << $LG_BYTES_PER_VALUE$;\n+\n+            try {\n+#if[!byte]\n+                if (order() != ByteOrder.nativeOrder())\n+                    SCOPED_MEMORY_ACCESS.copySwapMemory(\n+                            scope(), null, base(), bufAddr,\n+                            dst, dstOffset, len, ELEMENT_SIZE);\n+                else\n+#end[!byte]\n+                    SCOPED_MEMORY_ACCESS.copyMemory(\n+                            scope(), null, base(), bufAddr,\n+                            dst, dstOffset, len);\n+            } finally {\n+                Reference.reachabilityFence(this);\n+            }\n+        } else {\n+            int end = offset + length;\n+            for (int i = offset, j = index; i < end; i++, j++) {\n+                dst[i] = get(j);\n+            }\n+        }\n+        return this;\n+#else[rw]\n+        throw new ReadOnlyBufferException();\n+#end[rw]\n+    }\n+\n@@ -1041,0 +1087,1 @@\n+#if[rw]\n@@ -1042,1 +1089,0 @@\n-\n@@ -1056,0 +1102,1 @@\n+            try {\n@@ -1057,1 +1104,5 @@\n-            if (this.order() == src.order()) {\n+                if (this.order() != src.order())\n+                    SCOPED_MEMORY_ACCESS.copySwapMemory(\n+                            src.scope(), scope(), srcBase, srcAddr,\n+                            base, addr, len, ELEMENT_SIZE);\n+                else\n@@ -1059,1 +1110,0 @@\n-                try {\n@@ -1061,16 +1111,5 @@\n-                            src.scope(), scope(), srcBase,\n-                            srcAddr, base, addr, len);\n-                } finally {\n-                    Reference.reachabilityFence(src);\n-                    Reference.reachabilityFence(this);\n-                }\n-#if[!byte]\n-            } else {\n-                try {\n-                    SCOPED_MEMORY_ACCESS.copySwapMemory(\n-                            src.scope(), scope(), srcBase,\n-                            srcAddr, base, addr, len, (long)1 << $LG_BYTES_PER_VALUE$);\n-                } finally {\n-                    Reference.reachabilityFence(src);\n-                    Reference.reachabilityFence(this);\n-                }\n+                            src.scope(), scope(), srcBase, srcAddr,\n+                            base, addr, len);\n+            } finally {\n+                Reference.reachabilityFence(src);\n+                Reference.reachabilityFence(this);\n@@ -1078,1 +1117,0 @@\n-#end[!byte]\n@@ -1087,0 +1125,3 @@\n+#else[rw]\n+        throw new ReadOnlyBufferException();\n+#end[rw]\n@@ -1141,0 +1182,2 @@\n+        if (isReadOnly())\n+            throw new ReadOnlyBufferException();\n@@ -1142,1 +1185,2 @@\n-        if (length > remaining())\n+        int pos = position();\n+        if (length > limit() - pos)\n@@ -1144,3 +1188,4 @@\n-        int end = offset + length;\n-        for (int i = offset; i < end; i++)\n-            this.put(src[i]);\n+\n+        putArray(pos, src, offset, length);\n+\n+        position(pos + length);\n@@ -1226,3 +1271,3 @@\n-        int end = offset + length;\n-        for (int i = offset, j = index; i < end; i++, j++)\n-            this.put(j, src[i]);\n+\n+        putArray(index, src, offset, length);\n+\n@@ -1265,0 +1310,37 @@\n+    private $Type$Buffer putArray(int index, $type$[] src, int offset, int length) {\n+#if[rw]\n+        if (\n+#if[char]\n+            isAddressable() &&\n+#end[char]\n+            ((long)length << $LG_BYTES_PER_VALUE$) > Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {\n+            long bufAddr = address + ((long)index << $LG_BYTES_PER_VALUE$);\n+            long srcOffset =\n+                ARRAY_BASE_OFFSET + ((long)offset << $LG_BYTES_PER_VALUE$);\n+            long len = (long)length << $LG_BYTES_PER_VALUE$;\n+\n+            try {\n+#if[!byte]\n+                if (order() != ByteOrder.nativeOrder())\n+                    SCOPED_MEMORY_ACCESS.copySwapMemory(\n+                            null, scope(), src, srcOffset,\n+                            base(), bufAddr, len, ELEMENT_SIZE);\n+                else\n+#end[!byte]\n+                    SCOPED_MEMORY_ACCESS.copyMemory(\n+                            null, scope(), src, srcOffset,\n+                            base(), bufAddr, len);\n+            } finally {\n+                Reference.reachabilityFence(this);\n+            }\n+        } else {\n+            int end = offset + length;\n+            for (int i = offset, j = index; i < end; i++, j++)\n+                this.put(j, src[i]);\n+        }\n+        return this;\n+#else[rw]\n+        throw new ReadOnlyBufferException();\n+#end[rw]\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":115,"deletions":33,"binary":false,"changes":148,"status":"modified"}]}