{"files":[{"patch":"@@ -216,36 +216,0 @@\n-HeapWord* G1BlockOffsetTablePart::forward_to_block_containing_addr_slow(HeapWord* q,\n-                                                                        HeapWord* n,\n-                                                                        const void* addr) {\n-  \/\/ We're not in the normal case.  We need to handle an important subcase\n-  \/\/ here: LAB allocation.  An allocation previously recorded in the\n-  \/\/ offset table was actually a lab allocation, and was divided into\n-  \/\/ several objects subsequently.  Fix this situation as we answer the\n-  \/\/ query, by updating entries as we cross them.\n-\n-  \/\/ If the fist object's end q is at the card boundary. Start refining\n-  \/\/ with the corresponding card (the value of the entry will be basically\n-  \/\/ set to 0). If the object crosses the boundary -- start from the next card.\n-  size_t n_index = _bot->index_for(n);\n-  size_t next_index = _bot->index_for(n) + !_bot->is_card_boundary(n);\n-  \/\/ Calculate a consistent next boundary.  If \"n\" is not at the boundary\n-  \/\/ already, step to the boundary.\n-  HeapWord* next_boundary = _bot->address_for_index(n_index) +\n-                            (n_index == next_index ? 0 : BOTConstants::N_words);\n-  assert(next_boundary <= _bot->_reserved.end(),\n-         \"next_boundary is beyond the end of the covered region \"\n-         \" next_boundary \" PTR_FORMAT \" _array->_end \" PTR_FORMAT,\n-         p2i(next_boundary), p2i(_bot->_reserved.end()));\n-  while (next_boundary < addr) {\n-    while (n <= next_boundary) {\n-      q = n;\n-      oop obj = cast_to_oop(q);\n-      if (obj->klass_or_null_acquire() == NULL) return q;\n-      n += block_size(q);\n-    }\n-    assert(q <= next_boundary && n > next_boundary, \"Consequence of loop\");\n-    \/\/ [q, n) is the block that crosses the boundary.\n-    alloc_block_work(&next_boundary, q, n);\n-  }\n-  return forward_to_block_containing_addr_const(q, n, addr);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.cpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+  \/\/ Return the address of the beginning of the block that contains \"addr\".\n@@ -145,19 +146,3 @@\n-  \/\/ next block (or the end of the space.)  Return the address of the\n-  \/\/ beginning of the block that contains \"addr\".  Does so without side\n-  \/\/ effects (see, e.g., spec of  block_start.)\n-  inline HeapWord* forward_to_block_containing_addr_const(HeapWord* q, HeapWord* n,\n-                                                          const void* addr) const;\n-\n-  \/\/ \"q\" is a block boundary that is <= \"addr\"; return the address of the\n-  \/\/ beginning of the block that contains \"addr\".  May have side effects\n-  \/\/ on \"this\", by updating imprecise entries.\n-  inline HeapWord* forward_to_block_containing_addr(HeapWord* q,\n-                                                    const void* addr);\n-\n-  \/\/ \"q\" is a block boundary that is <= \"addr\"; \"n\" is the address of the\n-  \/\/ next block (or the end of the space.)  Return the address of the\n-  \/\/ beginning of the block that contains \"addr\".  May have side effects\n-  \/\/ on \"this\", by updating imprecise entries.\n-  HeapWord* forward_to_block_containing_addr_slow(HeapWord* q,\n-                                                  HeapWord* n,\n-                                                  const void* addr);\n+  \/\/ next block (or the end of the space.)\n+  inline HeapWord* forward_to_block_containing_addr(HeapWord* q, HeapWord* n,\n+                                                    const void* addr) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":4,"deletions":19,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -49,6 +49,0 @@\n-  assert(addr >= _hr->bottom() && addr < _hr->top(), \"invalid address\");\n-  HeapWord* q = block_at_or_preceding(addr);\n-  return forward_to_block_containing_addr(q, addr);\n-}\n-\n-inline HeapWord* G1BlockOffsetTablePart::block_start_const(const void* addr) const {\n@@ -58,1 +52,1 @@\n-  return forward_to_block_containing_addr_const(q, n, addr);\n+  return forward_to_block_containing_addr(q, n, addr);\n@@ -144,2 +138,2 @@\n-inline HeapWord* G1BlockOffsetTablePart::forward_to_block_containing_addr_const(HeapWord* q, HeapWord* n,\n-                                                                                const void* addr) const {\n+inline HeapWord* G1BlockOffsetTablePart::forward_to_block_containing_addr(HeapWord* q, HeapWord* n,\n+                                                                          const void* addr) const {\n@@ -147,0 +141,7 @@\n+    \/\/ When addr is not covered by the block starting at q we need to\n+    \/\/ step forward until we find the correct block. With the BOT\n+    \/\/ being precise, we should never have to step through more than\n+    \/\/ a single card.\n+    assert(_bot->index_for(n) == _bot->index_for(addr),\n+           \"BOT not precise. Index for n: \" SIZE_FORMAT \" must be equal to the index for addr: \" SIZE_FORMAT,\n+           _bot->index_for(n), _bot->index_for(addr));\n@@ -159,17 +160,0 @@\n-inline HeapWord* G1BlockOffsetTablePart::forward_to_block_containing_addr(HeapWord* q,\n-                                                                          const void* addr) {\n-  if (cast_to_oop(q)->klass_or_null_acquire() == NULL) {\n-    return q;\n-  }\n-  HeapWord* n = q + block_size(q);\n-  \/\/ In the normal case, where the query \"addr\" is a card boundary, and the\n-  \/\/ offset table chunks are the same size as cards, the block starting at\n-  \/\/ \"q\" will contain addr, so the test below will fail, and we'll fall\n-  \/\/ through quickly.\n-  if (n <= addr) {\n-    q = forward_to_block_containing_addr_slow(q, n, addr);\n-  }\n-  assert(q <= addr, \"wrong order for current and arg\");\n-  return q;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.inline.hpp","additions":10,"deletions":26,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -86,4 +86,0 @@\n-inline HeapWord* HeapRegion::block_start_const(const void* p) const {\n-  return _bot_part.block_start_const(p);\n-}\n-\n@@ -358,2 +354,0 @@\n-  \/\/ Update BOT as needed while finding start of (possibly dead)\n-  \/\/ object containing the start of the region.\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"}]}