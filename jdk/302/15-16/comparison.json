{"files":[{"patch":"@@ -130,1 +130,1 @@\n-  bool generate_partial_inlining_block(Node** ctrl, MergeMemNode** mem, const TypePtr* adr_type,\n+  void generate_partial_inlining_block(Node** ctrl, MergeMemNode** mem, const TypePtr* adr_type,\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -194,5 +194,0 @@\n-\/\/  Constant copy length operation having size less than ArrayCopyPartialInlineSize prevents\n-\/\/  creation of additional control flow for stub_block and exit_block.\n-\/\/\n-\/\/  Return true to emit subsequent stub calling code.\n-\/\/\n@@ -200,1 +195,1 @@\n-bool PhaseMacroExpand::generate_partial_inlining_block(Node** ctrl, MergeMemNode** mem, const TypePtr* adr_type,\n+void PhaseMacroExpand::generate_partial_inlining_block(Node** ctrl, MergeMemNode** mem, const TypePtr* adr_type,\n@@ -204,4 +199,2 @@\n-\n-  Node* orig_mem = *mem;\n-  Node* is_lt64bytes_fast_path = NULL;\n-  Node* is_lt64bytes_slow_path = NULL;\n+  Node* inline_block = NULL;\n+  Node* stub_block = NULL;\n@@ -228,1 +221,1 @@\n-    return true;\n+    return;\n@@ -231,17 +224,9 @@\n-  Node* inline_block = NULL;\n-  \/\/ Emit length comparison check for non-constant length.\n-  if (const_len < 0) {\n-    Node* copy_bytes = new LShiftXNode(length, intcon(shift));\n-    transform_later(copy_bytes);\n-\n-    Node* cmp_le = new CmpULNode(copy_bytes, longcon(ArrayCopyPartialInlineSize));\n-    transform_later(cmp_le);\n-    Node* bol_le = new BoolNode(cmp_le, BoolTest::le);\n-    transform_later(bol_le);\n-    is_lt64bytes_fast_path  = generate_guard(ctrl, bol_le, NULL, PROB_FAIR);\n-    is_lt64bytes_slow_path = *ctrl;\n-\n-    inline_block = is_lt64bytes_fast_path;\n-  } else {\n-    inline_block = *ctrl;\n-  }\n+  Node* copy_bytes = new LShiftXNode(length, intcon(shift));\n+  transform_later(copy_bytes);\n+\n+  Node* cmp_le = new CmpULNode(copy_bytes, longcon(ArrayCopyPartialInlineSize));\n+  transform_later(cmp_le);\n+  Node* bol_le = new BoolNode(cmp_le, BoolTest::le);\n+  transform_later(bol_le);\n+  inline_block  = generate_guard(ctrl, bol_le, NULL, PROB_FAIR);\n+  stub_block = *ctrl;\n@@ -257,2 +242,0 @@\n-  int alias_idx = C->get_alias_index(src_adr_type);\n-  Node* mm = (*mem)->memory_at(alias_idx);\n@@ -260,0 +243,1 @@\n+  Node* mm = (*mem)->memory_at(C->get_alias_index(src_adr_type));\n@@ -269,12 +253,7 @@\n-  \/\/ Stub region is created for non-constant copy length.\n-  if (const_len < 0) {\n-    \/\/ Region containing stub calling node.\n-    Node* stub_block = is_lt64bytes_slow_path;\n-\n-    \/\/ Convergence region for inline_block and stub_block.\n-    *exit_block = new RegionNode(3);\n-    transform_later(*exit_block);\n-    (*exit_block)->init_req(1, is_lt64bytes_fast_path);\n-    *result_memory = new PhiNode(*exit_block, Type::MEMORY, adr_type);\n-    transform_later(*result_memory);\n-    (*result_memory)->init_req(1, masked_store);\n+  \/\/ Convergence region for inline_block and stub_block.\n+  *exit_block = new RegionNode(3);\n+  transform_later(*exit_block);\n+  (*exit_block)->init_req(1, inline_block);\n+  *result_memory = new PhiNode(*exit_block, Type::MEMORY, adr_type);\n+  transform_later(*result_memory);\n+  (*result_memory)->init_req(1, masked_store);\n@@ -282,15 +261,1 @@\n-    *ctrl = stub_block;\n-    return true;\n-  } else {\n-    \/\/ Prevent stub call generation for constant length less\n-    \/\/ than partial inline size.\n-    uint alias_idx = C->get_alias_index(adr_type);\n-    if (alias_idx != Compile::AliasIdxBot) {\n-      *mem = MergeMemNode::make(*mem);\n-      (*mem)->set_memory_at(alias_idx, masked_store);\n-    } else {\n-      *mem = MergeMemNode::make(masked_store);\n-    }\n-    transform_later(*mem);\n-    return false;\n-  }\n+  *ctrl = stub_block;\n@@ -1215,1 +1180,0 @@\n-  bool gen_stub_call = true;\n@@ -1218,2 +1182,2 @@\n-    gen_stub_call = generate_partial_inlining_block(ctrl, mem, adr_type, &exit_block, &result_memory,\n-                                                    copy_length, src_start, dest_start, basic_elem_type);\n+    generate_partial_inlining_block(ctrl, mem, adr_type, &exit_block, &result_memory,\n+                                    copy_length, src_start, dest_start, basic_elem_type);\n@@ -1222,4 +1186,3 @@\n-  if (gen_stub_call) {\n-    const TypeFunc* call_type = OptoRuntime::fast_arraycopy_Type();\n-    Node* call = make_leaf_call(*ctrl, *mem, call_type, copyfunc_addr, copyfunc_name, adr_type,\n-                                src_start, dest_start, copy_length XTOP);\n+  const TypeFunc* call_type = OptoRuntime::fast_arraycopy_Type();\n+  Node* call = make_leaf_call(*ctrl, *mem, call_type, copyfunc_addr, copyfunc_name, adr_type,\n+                              src_start, dest_start, copy_length XTOP);\n@@ -1227,2 +1190,1 @@\n-    finish_arraycopy_call(call, ctrl, mem, adr_type);\n-  }\n+  finish_arraycopy_call(call, ctrl, mem, adr_type);\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":28,"deletions":66,"binary":false,"changes":94,"status":"modified"}]}