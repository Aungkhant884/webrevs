{"files":[{"patch":"@@ -111,0 +111,1 @@\n+#include \"utilities\/unsigned5.hpp\"\n@@ -2512,0 +2513,9 @@\n+  \/******************\/                                                    \\\n+  \/* UNSIGNED5      *\/                                                    \\\n+  \/******************\/                                                    \\\n+                                                                          \\\n+  declare_constant(UNSIGNED5::MAX_LENGTH)                                 \\\n+  declare_constant(UNSIGNED5::H)                                          \\\n+  declare_constant(UNSIGNED5::L)                                          \\\n+  declare_constant(UNSIGNED5::X)                                          \\\n+                                                                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -672,1 +672,2 @@\n-  size_t off = 0, lim = (size_t)(limit - addr);\n+  size_t lim = !limit ? 0 : (size_t)(limit - addr);\n+  UNSIGNED5::Reader<u1*, size_t> r(arr, lim);\n@@ -677,6 +678,7 @@\n-    if (count < 0 && arr[off] == 0) {\n-      tty->print(\" null\");\n-      ++off;\n-      ++printed;\n-      continue;\n-    } else if (!UNSIGNED5::check_length(arr, off, lim)) {\n+    if (!r.has_next()) {\n+      if ((r.position() < lim || lim == 0) && arr[r.position()] == 0) {\n+        tty->print(\" null\");\n+        r.set_position(r.position()+1);  \/\/ skip null byte\n+        ++printed;\n+        if (lim != 0)  continue;  \/\/ keep going to explicit limit\n+      }\n@@ -685,1 +687,1 @@\n-    u4 value = UNSIGNED5::read_uint(arr, off, lim);\n+    u4 value = r.next_uint();\n@@ -690,2 +692,2 @@\n-                printed, (int)off);\n-  return addr + off;\n+                printed, (int)r.position());\n+  return addr + r.position();\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -84,0 +84,2 @@\n+  friend class VMStructs;  \/\/ for constants B=MAX_LENGTH,H,L,X\n+\n","filename":"src\/hotspot\/share\/utilities\/unsigned5.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.io.PrintStream;\n+\n@@ -28,0 +30,1 @@\n+import sun.jvm.hotspot.utilities.*;\n@@ -37,0 +40,9 @@\n+    if (false) {  \/\/ manually enable to get more data\n+        \/\/ Example output: -\n+        \/\/ java.lang.ref.ReferenceQueue.remove(long) @bci=36 >> CRS on\n+        \/\/ 0x0000000800b984f0+75: U5: [ 23 null null null null null\n+        \/\/ null null 135 175 102 null 7 null null null 103 132 184\n+        \/\/ null ] (values=20\/length=20)\n+        System.out.print(\">> CRS on \"+buffer+\"+\"+position+\": \");\n+        dump(20);  \/\/ dump 20 bytes of stuff at the top of each stream\n+    }\n@@ -78,3 +90,0 @@\n-  \/\/ Note: In the C++ code, the implementation of UNSIGNED5 has been\n-  \/\/ moved to its own header file, <unsigned5.hpp>.\n-\n@@ -82,25 +91,6 @@\n-    \/\/ UNSIGNED5::read_u4(_buffer, &_position, limit=0)\n-    int pos = position;\n-    int b_0 = read(pos);\n-    int sum = b_0 - X;\n-    \/\/ VM throws assert if b0<X; we just return -1 here instead\n-    if (sum < L) {  \/\/ common case\n-      setPosition(pos+1);\n-      return sum;\n-    }\n-    \/\/ must collect more bytes:  b[1]...b[4]\n-    int lg_H_i = lg_H;  \/\/ lg(H)*i == lg(H^^i)\n-    for (int i = 1; ; i++) {  \/\/ for i in [1..4]\n-      int b_i = read(pos + i);\n-      if (b_i < X) {  \/\/ avoid excluded bytes\n-        \/\/ VM throws assert here; should not happen\n-        setPosition(pos+i);  \/\/ do not consume the bad byte\n-        return sum;  \/\/ return whatever we have parsed so far\n-      }\n-      sum += (b_i - X) << lg_H_i;  \/\/ sum += (b[i]-X)*(64^^i)\n-      if (b_i < X+L || i == MAX_LENGTH-1) {\n-        setPosition(pos+i+1);\n-        return sum;\n-      }\n-      lg_H_i += lg_H;\n-    }\n+    \/\/ UNSIGNED5::read_uint(_buffer, &_position, limit=0)\n+    return (int) Unsigned5.readUint(this, position,\n+                                    \/\/ bytes are fetched here:\n+                                    CompressedReadStream::read,\n+                                    \/\/ updated position comes through here:\n+                                    CompressedReadStream::setPosition);\n@@ -119,0 +109,18 @@\n+\n+\n+  \/**\n+   * Dumps the stream, making an assumption that all items are encoded\n+   * as UNSIGNED5.  The sizeLimit argument tells the dumper when to\n+   * stop trying to read bytes; if it is zero, the dumper goes as long\n+   * as it can until it encounters a null byte.\n+   *\n+   * This class mixes UNSIGNED5 with other formats.  Stray bytes are\n+   * decoded either as \"null\" (0x00), one less than the byte value\n+   * (0x01..0xBF) or as part of a spurious multi-byte encoding.\n+   * Proceed with caution.\n+   *\/\n+  public void dump() { dumpOn(System.out, 0); }\n+  public void dump(int sizeLimit) { dumpOn(System.out, sizeLimit); }\n+  public void dumpOn(PrintStream tty, int sizeLimit) {\n+      new Unsigned5(buffer, sizeLimit).dumpOn(tty, -1);\n+  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CompressedReadStream.java","additions":36,"deletions":28,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import sun.jvm.hotspot.utilities.*;\n@@ -57,11 +58,0 @@\n-  \/\/ Note: In the C++ code, the implementation of UNSIGNED5 has been\n-  \/\/ moved to its own header file, <unsigned5.hpp>.\n-\n-  \/\/ Constants for UNSIGNED5 coding of Pack200\n-  public static final int lg_H = 6;\n-  public static final int H = 1<<lg_H;  \/\/ number of high codes (64)\n-  public static final int X = 1;        \/\/ there is one excluded byte ('\\0')\n-  public static final int MAX_b = (1<<BitsPerByte)-1;  \/\/ largest byte value\n-  public static final int L = (MAX_b+1)-X-H;  \/\/ number of low codes (191)\n-  public static final int MAX_LENGTH = 5;  \/\/ lengths are in [1..5]\n-\n@@ -76,5 +66,0 @@\n-  \/\/ Note: In the C++ code, the following little algorithms\n-  \/\/ have been moved elsewhere.\n-\n-  \/\/ 32-bit one-to-one sign encoding taken from Pack200\n-  \/\/ converts leading sign bits into leading zeros with trailing sign bit\n@@ -82,1 +67,1 @@\n-    return (value << 1) ^ (value >> 31);\n+    return Unsigned5.encodeSign(value);\n@@ -86,1 +71,1 @@\n-    return (value >>> 1) ^ -(value & 1);\n+    return Unsigned5.decodeSign(value);\n@@ -92,6 +77,1 @@\n-    \/\/ Hacker's Delight, Figure 7-1\n-    i = (i & 0x55555555) << 1 | (i >>> 1) & 0x55555555;\n-    i = (i & 0x33333333) << 3 | (i >>> 2) & 0x33333333;\n-    i = (i & 0x0f0f0f0f) << 4 | (i >>> 4) & 0x0f0f0f0f;\n-    i = (i << 24) | ((i & 0xff00) << 8) | ((i >>> 8) & 0xff00) | (i >>> 24);\n-    return i;\n+    return Integer.reverse(i);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CompressedStream.java","additions":4,"deletions":24,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,239 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.utilities;\n+\n+import java.io.PrintStream;\n+\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.types.*;\n+\n+\/**\n+ * Decompression algorithm from utilities\/unsigned5.hpp.\n+ *\/\n+public class Unsigned5 {\n+  static {\n+    VM.registerVMInitializedObserver(new Observer() {\n+        public void update(Observable o, Object data) {\n+          initialize(VM.getVM().getTypeDataBase());\n+        }\n+      });\n+  }\n+\n+  private static void initialize(TypeDataBase db) {\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(!VM.getVM().isCore(), \"Debug info not used in core build\");\n+    }\n+\n+    Integer bval = db.lookupIntConstant(\"UNSIGNED5::MAX_LENGTH\", false);\n+    int hval, lval, xval;\n+    if (bval == null) {\n+      \/\/ older vmStructs does not record this information; it's hardwired\n+      System.out.println(\"[Unsigned5: defaulting BHLX values...]\");\/\/@@\n+      bval = 5; hval = 64; lval = 192; xval = 0;\n+    } else {\n+      hval = db.lookupIntConstant(\"UNSIGNED5::H\").intValue();\n+      lval = db.lookupIntConstant(\"UNSIGNED5::L\").intValue();\n+      xval = db.lookupIntConstant(\"UNSIGNED5::X\").intValue();\n+    }\n+    \/\/ push values to mutable fields:\n+    MAX_LENGTH = bval;\n+    L = lval;\n+    X = xval;\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(hval == H, \"hardwired to 64 == (1<<(lg_H=6))\");\n+      Assert.that(hval+lval+xval == 256, \"code counts must balance to octet number\");\n+    }\n+  }\n+\n+  public static final int LogBitsPerByte = 3;\n+  public static final int BitsPerByte = 1 << 3;\n+\n+  \/\/ Constants for UNSIGNED5 coding of Pack200\n+  private static final int lg_H = 6;\n+  private static final int H = 1<<lg_H;  \/\/ number of high codes (64)\n+  private static final int MAX_b = (1<<BitsPerByte)-1;  \/\/ largest byte value\n+  \/\/ these three can vary; vmStructs gets a crack at them:\n+  public static int X = 1 \/*or 0*\/;  \/\/ there may be an excluded byte ('\\0')\n+  public static int L = (MAX_b+1)-X-H;  \/\/ number of low codes (192 or 191)\n+  public static int MAX_LENGTH = 5;  \/\/ lengths are in [1..5]\n+\n+  public interface GetByte<ARR> {\n+      short getByte(ARR array, int position);\n+  }\n+  public interface SetPosition<ARR> {\n+      void setPosition(ARR array, int position);\n+  }\n+\n+  \/\/ UNSIGNED5::read_uint(_buffer, &_position, limit=0)\n+  \/\/ In C++ this is a generic algorithm, templated with \"holes\"\n+  \/\/ for array (ARR), offset (OFF), and fetch behavior (GET).\n+  \/\/ In addition, the position is updated by reference.\n+  \/\/ Let us mimic these conditions with two lambdas, both\n+  \/\/ on the ARR parameter.  We will hardwire the position\n+  \/\/ type (OFF) to int (sorry, not long), and omit the extra\n+  \/\/ limit feature.\n+  public static\n+  <ARR> long readUint(ARR base, int position,\n+                      GetByte<ARR> getByte,\n+                      SetPosition<ARR> setPosition) {\n+    int pos = position;\n+    int b_0 = getByte.getByte(base, pos);\n+    int sum = b_0 - X;\n+    \/\/ VM throws assert if b0<X; we just return -1 here instead\n+    if (sum < L) {  \/\/ common case\n+      setPosition.setPosition(base, pos+1);\n+      return Integer.toUnsignedLong(sum);\n+    }\n+    \/\/ must collect more bytes:  b[1]...b[4]\n+    int lg_H_i = lg_H;  \/\/ lg(H)*i == lg(H^^i)\n+    for (int i = 1; ; i++) {  \/\/ for i in [1..4]\n+      int b_i = getByte.getByte(base, pos + i);\n+      if (b_i < X) {  \/\/ avoid excluded bytes\n+        \/\/ VM throws assert here; should not happen\n+        setPosition.setPosition(base, pos+i);  \/\/ do not consume the bad byte\n+        return Integer.toUnsignedLong(sum);  \/\/ return whatever we have parsed so far\n+      }\n+      sum += (b_i - X) << lg_H_i;  \/\/ sum += (b[i]-X)*(64^^i)\n+      if (b_i < X+L || i == MAX_LENGTH-1) {\n+        setPosition.setPosition(base, pos+i+1);\n+        return Integer.toUnsignedLong(sum);\n+      }\n+      lg_H_i += lg_H;\n+    }\n+  }\n+\n+  \/\/ 32-bit one-to-one sign encoding taken from Pack200\n+  \/\/ converts leading sign bits into leading zeros with trailing sign bit\n+  \/\/ uint32_t encode_sign(int32_t value)\n+  public static int encodeSign(int value) {\n+    return (value << 1) ^ (value >> 31);\n+  }\n+\n+  \/\/ int32_t decode_sign(uint32_t value)\n+  public static int decodeSign(int value) {\n+    return (value >>> 1) ^ -(value & 1);\n+  }\n+\n+  \/\/--------------------------------------------------------------------------------\n+  \/\/ constructor and instance methods for convenience\n+\n+  \/\/ You can read and print a stream directly from memory if you like.\n+  \/\/ First wrap these up, then call read or print.\n+  private final Address base;\n+  private final int limit;\n+\n+  \/\/ There is no C++ instance of UNSIGNED5 but it seems useful to\n+  \/\/ allow this class to serve as a holder for an address and optional\n+  \/\/ limit, to point at a place where U5 encodings might be stored.\n+  \/\/ Compare with Unsigned5::Reader(ARR array, OFF limit = 0).\n+  public Unsigned5(Address base) {\n+    this(base, 0);  \/\/ limit=0 means unlimited (proceed with caution)\n+  }\n+  public Unsigned5(Address base, int limit) {\n+    this.base = base;\n+    this.limit = limit;\n+  }\n+\n+  public Address base() { return base; }\n+  public short getByte(int pos) {\n+    return (short) base.getCIntegerAt(pos, 1, true);\n+  }\n+\n+  \/\/ An UNSIGNED5::Reader gadget has a settable, auto-incremented\n+  \/\/ position field and can read through a stream of encoded values.\n+  \/\/ Java can model this as an inner class: var r = myU5.new Reader()\n+  \/\/ or var r = new Unsigned5(myaddr).new Reader()\n+  public class Reader {\n+    private int position = 0;  \/\/ this is for Unsigned5::Reader behavior\n+    public int position() { return position; }\n+    public void setPosition(int pos) { position = pos; }\n+    \/\/ UNSIGNED5::Reader::next_uint\n+    public long nextUint() {\n+        if (!hasNext())  return -1;\n+        return readUint(this, position, Reader::getByte, Reader::setPosition);\n+    }\n+    \/\/ UNSIGNED5::Reader::has_next\n+    public boolean hasNext() { return Unsigned5.this.hasNext(position); }\n+    \/\/ delegate reads to outer object:\n+    private short getByte(int pos) { return Unsigned5.this.getByte(pos); }\n+  }\n+\n+  \/\/ UNSIGNED5::read_uint (no position update)\n+  public long readUint(int pos) {\n+    if (!hasNext(pos))  return -1;\n+    return readUint(this, pos, Unsigned5::getByte, (a,i)->{});\n+  }\n+  private boolean hasNext(int pos) {\n+    \/\/ 1. there must be a non-excluded byte at the read position\n+    \/\/ 2. the position must be less than any non-zero limit\n+    return ((X == 0 || getByte(pos) >= X) &&\n+            (limit == 0 || pos < limit));\n+  }\n+\n+  \/\/ debug.cpp: u5decode(intptr_t addr)\n+  public void print() {\n+    printOn(System.out);\n+  }\n+  public void printOn(PrintStream tty) {\n+    tty.print(\"U5 \" + readUint(0) + \", \");\n+  }\n+\n+  \/\/ debug.cpp: u5p(intptr_t addr, intptr_t limit, int count)\n+  \/\/ check and decode a series of u5 values\n+  \/\/ return the address after the last decoded byte\n+  \/\/ if limit is non-zero stop before limit\n+  \/\/ if count is non-negative stop when count is reached\n+  \/\/ if count is negative stop on null (works kind of like strlen)\n+  public void dumpOn(PrintStream tty, int count) {\n+    Reader r = new Reader();\n+    int printed = 0;\n+    tty.print(\"U5: [\");\n+    for (;;) {\n+      if (count >= 0 && printed >= count)  break;\n+      if (!r.hasNext()) {\n+        if ((r.position < limit || limit == 0) && getByte(r.position) == 0) {\n+          tty.print(\" null\");\n+          ++r.position;  \/\/ skip null byte\n+          ++printed;\n+          if (limit != 0)  continue;  \/\/ keep going to explicit limit\n+        }\n+        break;\n+      }\n+      int value = (int) r.nextUint();\n+      tty.print(\" \");\n+      tty.print(value);\n+      ++printed;\n+    }\n+    tty.println(\" ] (values=\" + printed + \"\/length=\" + r.position + \")\");\n+  }\n+  public void dump(int count) {\n+    dumpOn(System.out, count);\n+  }\n+  public void dump() {\n+    \/\/ dump as many as possible, up to any nonzero limit\n+    dumpOn(System.out, -1);\n+  }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/Unsigned5.java","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"}]}