{"files":[{"patch":"@@ -84,1 +84,1 @@\n-  if (nsize < min_expansion*2)\n+  if (nsize < min_expansion*2) {\n@@ -86,0 +86,1 @@\n+  }\n","filename":"src\/hotspot\/share\/code\/compressedStream.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -111,1 +111,0 @@\n-#include \"utilities\/unsigned5.hpp\"\n@@ -2513,9 +2512,0 @@\n-  \/******************\/                                                    \\\n-  \/* UNSIGNED5      *\/                                                    \\\n-  \/******************\/                                                    \\\n-                                                                          \\\n-  declare_constant(UNSIGNED5::MAX_LENGTH)                                 \\\n-  declare_constant(UNSIGNED5::H)                                          \\\n-  declare_constant(UNSIGNED5::L)                                          \\\n-  declare_constant(UNSIGNED5::X)                                          \\\n-                                                                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -663,6 +663,10 @@\n-\/\/ check and decode a series of u5 values\n-\/\/ return the address after the last decoded byte\n-\/\/ if limit is non-zero stop before limit\n-\/\/ if count is non-negative stop when count is reached\n-\/\/ if count is negative stop on null (works kind of like strlen)\n-extern \"C\" JNIEXPORT intptr_t u5p(intptr_t addr, intptr_t limit, int count) {\n+\/\/ Sets up a Reader from addr\/limit and prints count items.\n+\/\/ A limit of zero means no set limit; stop at the first null\n+\/\/ or after count items are printed.\n+\/\/ A count of zero or less is converted to -1, which means\n+\/\/ there is no limit on the count of items printed; the\n+\/\/ printing stops when an null is printed or at limit.\n+\/\/ See documentation for UNSIGNED5::Reader::print(count).\n+extern \"C\" JNIEXPORT intptr_t u5p(intptr_t addr,\n+                                  intptr_t limit,\n+                                  int count) {\n@@ -672,22 +676,4 @@\n-  size_t lim = !limit ? 0 : (size_t)(limit - addr);\n-  UNSIGNED5::Reader<u1*, size_t> r(arr, lim);\n-  int printed = 0;\n-  tty->print(\"U5: [\");\n-  for (;;) {\n-    if (count >= 0 && printed >= count)  break;\n-    if (!r.has_next()) {\n-      if ((r.position() < lim || lim == 0) && arr[r.position()] == 0) {\n-        tty->print(\" null\");\n-        r.set_position(r.position()+1);  \/\/ skip null byte\n-        ++printed;\n-        if (lim != 0)  continue;  \/\/ keep going to explicit limit\n-      }\n-      break;\n-    }\n-    u4 value = r.next_uint();\n-    tty->print(\" %d\", value);\n-    ++printed;\n-  }\n-  tty->print_cr(\" ] (values=%d\/length=%d)\",\n-                printed, (int)r.position());\n-  return addr + r.position();\n+  size_t lim = !limit ? 0 : (limit - addr);\n+  size_t endpos = UNSIGNED5::print_count(count > 0 ? count : -1,\n+                                         arr, (size_t)0, lim);\n+  return addr + endpos;\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":14,"deletions":28,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -29,1 +29,7 @@\n-\/\/ Explicit instantiation for supported types.\n+\/\/ Most of UNSIGNED5 is in the header file.\n+\/\/ Let's put a few debug functions out-of-line here.\n+\n+\/\/ For the record, UNSIGNED5 was defined around 2001 and was first\n+\/\/ published in the initial Pack200 spec.  See:\n+\/\/ https:\/\/docs.oracle.com\/en\/java\/javase\/11\/docs\/specs\/pack-spec.html\n+\/\/ in Section 6.1, \"Encoding of Small Whole Numbers\".\n@@ -31,1 +37,2 @@\n-using AGS = UNSIGNED5::ArrayGetSet<u_char*,int>;\n+PRAGMA_DIAG_PUSH\n+PRAGMA_FORMAT_NONLITERAL_IGNORED\n@@ -33,3 +40,34 @@\n-template u4 UNSIGNED5::read_uint(u_char* array, int& offset_rw, int limit, AGS);\n-template void UNSIGNED5::write_uint(uint32_t value, u_char* array, int& offset_rw, int limit, AGS);\n-template int UNSIGNED5::check_length(u_char* array, int offset, int limit, AGS);\n+\/\/ For debugging, even in product builds (see debug.cpp).\n+template<typename ARR, typename OFF, typename GET>\n+void UNSIGNED5::Reader<ARR,OFF,GET>::\n+print_on(outputStream* st, int count,\n+         const char* left,   \/\/ \"U5: [\"\n+         const char* right   \/\/ \"] (values=%d\/length=%d)\\n\"\n+         ) {\n+  if (left == NULL)   left = \"U5: [\";\n+  if (right == NULL)  right = \"] (values=%d\/length=%d)\\n\";\n+  int printed = 0;\n+  st->print(\"%s\", left);\n+  for (;;) {\n+    if (count >= 0 && printed >= count)  break;\n+    if (!has_next()) {\n+      if ((_limit == 0 || _position < _limit) && _array[_position] == 0) {\n+        st->print(\" null\");\n+        ++_position;  \/\/ skip null byte\n+        ++printed;\n+        if (_limit != 0)  continue;  \/\/ keep going to explicit limit\n+      }\n+      break;\n+    }\n+    u4 value = next_uint();\n+    if (printed == 0)\n+      st->print(\"%d\", value);\n+    else\n+      st->print(\" %d\", value);\n+    ++printed;\n+  }\n+  st->print(right,\n+            \/\/ these arguments may or may not be used in the format string:\n+            printed,\n+            (int)_position);\n+}\n@@ -37,3 +75,9 @@\n-\/\/template uint32_t UNSIGNED5::read_uint(address array, size_t& offset_rw, size_t limit, AGS);\n-\/\/template void UNSIGNED5::write_uint(uint32_t value, address array, size_t& offset_rw, size_t limit, AGS);\n-\/\/template int UNSIGNED5::check_length(address array, size_t offset, size_t limit, AGS);\n+PRAGMA_DIAG_POP\n+\n+\/\/ Explicit instantiation for supported types.\n+template void UNSIGNED5::Reader<char*,int>::\n+print_on(outputStream* st, int count, const char* left, const char* right);\n+template void UNSIGNED5::Reader<u1*,int>::\n+print_on(outputStream* st, int count, const char* left, const char* right);\n+template void UNSIGNED5::Reader<address,size_t>::\n+print_on(outputStream* st, int count, const char* left, const char* right);\n","filename":"src\/hotspot\/share\/utilities\/unsigned5.cpp","additions":52,"deletions":8,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -84,2 +85,0 @@\n-  friend class VMStructs;  \/\/ for constants B=MAX_LENGTH,H,L,X\n-\n@@ -291,0 +290,20 @@\n+\n+    \/\/ For debugging, even in product builds (see debug.cpp).\n+    \/\/ Checks and decodes a series of u5 values from the reader.\n+    \/\/ Sets position just after the last decoded byte or null byte.\n+    \/\/ If this reader has a limit, stop before that limit.\n+    \/\/ If this reader has no limit, stop after the first null byte.\n+    \/\/ In any case, if count is non-negative, print no more than\n+    \/\/ count items (uint32_t values or \"null\").\n+    \/\/ A negative count means we stop only at the limit or null,\n+    \/\/ kind of like strlen.\n+    void print(int count = -1) { print_on(tty, count); }\n+\n+    \/\/ The character strings are printed before and after the\n+    \/\/ series of values (which are separated only by spaces).\n+    \/\/ If they are null they default to something like \"U5:[ \"\n+    \/\/ and \" ] (values=%d\/length=%d)\\n\".\n+    \/\/ The %d formats are for the number of printed items and\n+    \/\/ their length in bytes, if you want to see that also.\n+    void print_on(outputStream* st, int count = -1,\n+                  const char* left = NULL, const char* right = NULL);\n@@ -305,3 +324,0 @@\n-    void limit_init() {\n-      assert(_limit_ptr == NULL || *_limit_ptr != 0, \"limit required\");\n-    }\n@@ -310,3 +326,5 @@\n-      : _array(const_cast<ARR&>(array)), _limit_ptr(NULL)\n-        \/\/ note:  if _limit_ptr is NULL, the ARR& is never reassigned\n-    { limit_init(); _position = 0; }\n+      : _array(const_cast<ARR&>(array)), _limit_ptr(NULL), _position(0) {\n+      \/\/ Note: if _limit_ptr is NULL, the ARR& is never reassigned,\n+      \/\/ because has_limit is false.  So the const_cast here is safe.\n+      assert(!has_limit(), \"this writer cannot be growable\");\n+    }\n@@ -314,2 +332,6 @@\n-      : _array(array), _limit_ptr(&limit)\n-    { limit_init(); _position = 0; }\n+      : _array(array), _limit_ptr(&limit), _position(0) {\n+      \/\/ Writable array argument can be rewritten by accept_grow.\n+      \/\/ So we need a legitimate (non-zero) limit to work with.\n+      \/\/ As a result, a writer's initial buffer must not be empty.\n+      assert(limit() != 0, \"limit required\");\n+    }\n@@ -381,0 +403,15 @@\n+\n+  template<typename ARR, typename OFF, typename GET = ArrayGetSet<ARR,OFF>>\n+  static OFF print(ARR array, OFF offset = 0, OFF limit = 0,\n+                   GET get = GET()) {\n+    print_count(-1, array, offset, limit, get);\n+  }\n+  template<typename ARR, typename OFF, typename GET = ArrayGetSet<ARR,OFF>>\n+  static OFF print_count(int count,\n+                         ARR array, OFF offset = 0, OFF limit = 0,\n+                         GET get = GET()) {\n+    Reader<ARR,OFF,GET> r(array, offset);\n+\n+    r.print_on(tty, count);\n+    return r.position();\n+  }\n","filename":"src\/hotspot\/share\/utilities\/unsigned5.hpp","additions":47,"deletions":10,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -40,9 +40,0 @@\n-    if (false) {  \/\/ manually enable to get more data\n-        \/\/ Example output: -\n-        \/\/ java.lang.ref.ReferenceQueue.remove(long) @bci=36 >> CRS on\n-        \/\/ 0x0000000800b984f0+75: U5: [ 23 null null null null null\n-        \/\/ null null 135 175 102 null 7 null null null 103 132 184\n-        \/\/ null ] (values=20\/length=20)\n-        System.out.print(\">> CRS on \"+buffer+\"+\"+position+\": \");\n-        dump(20);  \/\/ dump 20 bytes of stuff at the top of each stream\n-    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CompressedReadStream.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.types.*;\n@@ -37,34 +35,0 @@\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static void initialize(TypeDataBase db) {\n-    if (Assert.ASSERTS_ENABLED) {\n-      Assert.that(!VM.getVM().isCore(), \"Debug info not used in core build\");\n-    }\n-\n-    Integer bval = db.lookupIntConstant(\"UNSIGNED5::MAX_LENGTH\", false);\n-    int hval, lval, xval;\n-    if (bval == null) {\n-      \/\/ older vmStructs does not record this information; it's hardwired\n-      System.out.println(\"[Unsigned5: defaulting BHLX values...]\");\/\/@@\n-      bval = 5; hval = 64; lval = 192; xval = 0;\n-    } else {\n-      hval = db.lookupIntConstant(\"UNSIGNED5::H\").intValue();\n-      lval = db.lookupIntConstant(\"UNSIGNED5::L\").intValue();\n-      xval = db.lookupIntConstant(\"UNSIGNED5::X\").intValue();\n-    }\n-    \/\/ push values to mutable fields:\n-    MAX_LENGTH = bval;\n-    L = lval;\n-    X = xval;\n-    if (Assert.ASSERTS_ENABLED) {\n-      Assert.that(hval == H, \"hardwired to 64 == (1<<(lg_H=6))\");\n-      Assert.that(hval+lval+xval == 256, \"code counts must balance to octet number\");\n-    }\n-  }\n-\n@@ -75,2 +39,3 @@\n-  private static final int lg_H = 6;\n-  private static final int H = 1<<lg_H;  \/\/ number of high codes (64)\n+  private static final int lg_H = 6;     \/\/ log-base-2 of H (lg 64 == 6)\n+  private static final int H = 1<<lg_H;  \/\/ number of \"high\" bytes (64)\n+  private static final int X = 1;  \/\/ there is one excluded byte ('\\0')\n@@ -78,4 +43,11 @@\n-  \/\/ these three can vary; vmStructs gets a crack at them:\n-  public static int X = 1 \/*or 0*\/;  \/\/ there may be an excluded byte ('\\0')\n-  public static int L = (MAX_b+1)-X-H;  \/\/ number of low codes (192 or 191)\n-  public static int MAX_LENGTH = 5;  \/\/ lengths are in [1..5]\n+  private static final int L = (MAX_b+1)-X-H;  \/\/ number of \"low\" bytes (191)\n+  public static final int MAX_LENGTH = 5;  \/\/ lengths are in [1..5]\n+\n+  \/\/ Note:  Previous versions of HotSpot used X=0 (not 1) and L=192 (not 191)\n+  \/\/\n+  \/\/ Using this SA code on old versions of HotSpot, or older SA code\n+  \/\/ on newer versions of HotSpot, will decode compressed data\n+  \/\/ wrongly.  One might consider using vmStructs to communicate this\n+  \/\/ particular change between the SA and VM, but it is mostly futile.\n+  \/\/ There are a myriad of new changes in any version of HotSpot.  You\n+  \/\/ have to use the right SA and VM versions together.\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/Unsigned5.java","additions":14,"deletions":42,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -29,4 +29,0 @@\n-\/\/ T.I.L.\n-\/\/ $ sh .\/configure ... --with-gtest=<...>\/googletest ...\n-\/\/ $ make exploded-test TEST=gtest:unsigned5\n-\n@@ -128,3 +124,0 @@\n-\/\/ try out a command from debug.cpp:\n-extern \"C\" intptr_t u5p(intptr_t addr, intptr_t limit, int count);\n-\n@@ -158,1 +151,1 @@\n-      u5p((intptr_t)&buffer[0], (intptr_t)&buffer[sublimit], case_count + 1);\n+      UNSIGNED5::print_count(case_count + 1, &buffer[0], sublimit);\n@@ -252,0 +245,13 @@\n+\n+  \/\/ try printing:\n+  {\n+    char stbuf[1000];\n+    stringStream st(stbuf, sizeof(stbuf)-1);\n+    UNSIGNED5::Reader<char*,int> printer(buf);\n+    printer.print_on(&st, 4, \"(\", \")\");\n+    std::string st_s(st.base(), st.size());\n+    char buf2[sizeof(stbuf)];\n+    sprintf(buf2, \"(%d %d %d %d)\", ints[0], ints[1], ints[2], ints[3]);\n+    std::string exp_s(buf2, strlen(buf2));\n+    ASSERT_EQ(exp_s, st_s);\n+  }\n","filename":"test\/hotspot\/gtest\/utilities\/test_unsigned5.cpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"}]}