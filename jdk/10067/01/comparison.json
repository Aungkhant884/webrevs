{"files":[{"patch":"@@ -30,6 +30,0 @@\n-\/\/ 32-bit self-inverse encoding of float bits\n-\/\/ converts trailing zeroes (common in floats) to leading zeroes\n-inline juint CompressedStream::reverse_int(juint i) {\n-  return reverse_bits(i);\n-}\n-\n@@ -37,1 +31,1 @@\n-  return decode_sign(read_int());\n+  return UNSIGNED5::decode_sign(read_int());\n@@ -44,2 +38,4 @@\n-\/\/ compression.\n-\n+\/\/ compression.  Since bit reversal converts trailing zeroes to\n+\/\/ leading zeroes, effect is better compression of those common\n+\/\/ 32-bit float values, such as integers or integers divided by\n+\/\/ powers of two, that have many trailing zeroes.\n@@ -48,1 +44,1 @@\n-  int f  = reverse_int(rf);\n+  int f  = reverse_bits(rf);\n@@ -52,0 +48,6 @@\n+\/\/ The treatment of doubles is similar.  We could bit-reverse each\n+\/\/ entire 64-bit word, but it is almost as effective to bit-reverse\n+\/\/ the individual halves.  Since we are going to encode them\n+\/\/ separately as 32-bit halves anyway, it seems slightly simpler\n+\/\/ to reverse after splitting, and when reading reverse each\n+\/\/ half before joining them together.\n@@ -55,2 +57,2 @@\n-  jint h  = reverse_int(rh);\n-  jint l  = reverse_int(rl);\n+  jint h  = reverse_bits(rh);\n+  jint l  = reverse_bits(rl);\n@@ -60,0 +62,7 @@\n+\/\/ A 64-bit long is encoded into distinct 32-bit halves.  This saves\n+\/\/ us from having to define a 64-bit encoding and is almost as\n+\/\/ effective.  A modified LEB128 could encode longs into 9 bytes, and\n+\/\/ this technique maxes out at 10 bytes, so, if we didn't mind the\n+\/\/ extra complexity of another coding system, we could process 64-bit\n+\/\/ values as single units.  But, the complexity does not seem\n+\/\/ worthwhile.\n@@ -73,1 +82,5 @@\n-  u_char* _new_buffer = NEW_RESOURCE_ARRAY(u_char, _size * 2);\n+  int nsize = _size * 2;\n+  const int min_expansion = UNSIGNED5::MAX_LENGTH;\n+  if (nsize < min_expansion*2)\n+    nsize = min_expansion*2;\n+  u_char* _new_buffer = NEW_RESOURCE_ARRAY(u_char, nsize);\n@@ -76,1 +89,1 @@\n-  _size   = _size * 2;\n+  _size   = nsize;\n@@ -81,2 +94,2 @@\n-  juint rf = reverse_int(f);\n-  assert(f == reverse_int(rf), \"can re-read same bits\");\n+  juint rf = reverse_bits(f);\n+  assert(f == reverse_bits(rf), \"can re-read same bits\");\n@@ -89,4 +102,4 @@\n-  juint rh = reverse_int(h);\n-  juint rl = reverse_int(l);\n-  assert(h == reverse_int(rh), \"can re-read same bits\");\n-  assert(l == reverse_int(rl), \"can re-read same bits\");\n+  juint rh = reverse_bits(h);\n+  juint rl = reverse_bits(l);\n+  assert(h == reverse_bits(rh), \"can re-read same bits\");\n+  assert(l == reverse_bits(rl), \"can re-read same bits\");\n","filename":"src\/hotspot\/share\/code\/compressedStream.cpp","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/unsigned5.hpp\"\n@@ -39,12 +40,0 @@\n-  enum {\n-    \/\/ Constants for UNSIGNED5 coding of Pack200\n-    lg_H = 6, H = 1<<lg_H,    \/\/ number of high codes (64)\n-    L = (1<<BitsPerByte)-H,   \/\/ number of low codes (192)\n-    MAX_i = 4                 \/\/ bytes are numbered in (0..4), max 5 bytes\n-  };\n-\n-  \/\/ 32-bit one-to-one sign encoding taken from Pack200\n-  \/\/ converts leading sign bits into leading zeroes with trailing sign bit\n-  static juint encode_sign(jint  value) { return (value << 1) ^ (value >> 31); }\n-  static jint  decode_sign(juint value) { return (value >> 1) ^ -(jint)(value & 1); }\n-  static juint reverse_int(juint i);   \/\/ to trim trailing float 0's\n@@ -69,35 +58,0 @@\n-  \/\/ This encoding, called UNSIGNED5, is taken from J2SE Pack200.\n-  \/\/ It assumes that most values have lots of leading zeroes.\n-  \/\/ Very small values, in the range [0..191], code in one byte.\n-  \/\/ Any 32-bit value (including negatives) can be coded, in\n-  \/\/ up to five bytes.  The grammar is:\n-  \/\/    low_byte  = [0..191]\n-  \/\/    high_byte = [192..255]\n-  \/\/    any_byte  = low_byte | high_byte\n-  \/\/    coding = low_byte\n-  \/\/           | high_byte low_byte\n-  \/\/           | high_byte high_byte low_byte\n-  \/\/           | high_byte high_byte high_byte low_byte\n-  \/\/           | high_byte high_byte high_byte high_byte any_byte\n-  \/\/ Each high_byte contributes six bits of payload.\n-  \/\/ The encoding is one-to-one (except for integer overflow)\n-  \/\/ and easy to parse and unparse.\n-\n-  jint read_int_mb(jint b0) {\n-    int     pos = position() - 1;\n-    u_char* buf = buffer() + pos;\n-    assert(buf[0] == b0 && b0 >= L, \"correctly called\");\n-    jint    sum = b0;\n-    \/\/ must collect more bytes:  b[1]...b[4]\n-    int lg_H_i = lg_H;\n-    for (int i = 0; ; ) {\n-      jint b_i = buf[++i]; \/\/ b_i = read(); ++i;\n-      sum += b_i << lg_H_i;  \/\/ sum += b[i]*(64**i)\n-      if (b_i < L || i == MAX_i) {\n-        set_position(pos+i+1);\n-        return sum;\n-      }\n-      lg_H_i += lg_H;\n-    }\n-  }\n-\n@@ -112,4 +66,0 @@\n-  jint     read_int()                  { jint   b0 = read();\n-                                         if (b0 < L)  return b0;\n-                                         else         return read_int_mb(b0);\n-                                       }\n@@ -117,2 +67,2 @@\n-  jfloat   read_float();               \/\/ jfloat_cast(reverse_int(read_int()))\n-  jdouble  read_double();              \/\/ jdouble_cast(2*reverse_int(read_int))\n+  jfloat   read_float();               \/\/ jfloat_cast(reverse_bits(read_int()))\n+  jdouble  read_double();              \/\/ jdouble_cast(2*reverse_bits(read_int))\n@@ -120,0 +70,4 @@\n+\n+  jint     read_int() {\n+    return UNSIGNED5::read_uint(_buffer, _position, 0);\n+  }\n@@ -137,17 +91,0 @@\n-  \/\/ UNSIGNED5 coding, 1-5 byte cases\n-  void write_int_mb(jint value) {\n-    juint sum = value;\n-    for (int i = 0; ; ) {\n-      if (sum < L || i == MAX_i) {\n-        \/\/ remainder is either a \"low code\" or the 5th byte\n-        assert(sum == (u_char)sum, \"valid byte\");\n-        write((u_char)sum);\n-        break;\n-      }\n-      sum -= L;\n-      int b_i = L + (sum % H);  \/\/ this is a \"high code\"\n-      sum >>= lg_H;             \/\/ extracted 6 bits\n-      write(b_i); ++i;\n-    }\n-  }\n-\n@@ -166,6 +103,3 @@\n-  void write_int(jint value)           { if ((juint)value < L && !full())\n-                                               store((u_char)value);\n-                                         else  write_int_mb(value);  }\n-  void write_signed_int(jint value)    { write_int(encode_sign(value)); }\n-  void write_float(jfloat value);      \/\/ write_int(reverse_int(jint_cast(v)))\n-  void write_double(jdouble value);    \/\/ write_int(reverse_int(<low,high>))\n+  void write_signed_int(jint value)    { write_int(UNSIGNED5::encode_sign(value)); }\n+  void write_float(jfloat value);      \/\/ write_int(reverse_bits(jint_cast(v)))\n+  void write_double(jdouble value);    \/\/ write_int(reverse_bits(<low,high>))\n@@ -173,0 +107,5 @@\n+\n+  void write_int(juint value) {\n+    UNSIGNED5::write_uint_grow(value, _buffer, _position, _size,\n+                               [&](int){ grow(); });\n+  }\n","filename":"src\/hotspot\/share\/code\/compressedStream.hpp","additions":15,"deletions":76,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+#include \"utilities\/unsigned5.hpp\"\n@@ -651,0 +652,43 @@\n+\/\/ check and decode a single u5 value\n+extern \"C\" JNIEXPORT u4 u5decode(intptr_t addr) {\n+  Command c(\"u5decode\");\n+  u1* arr = (u1*)addr;\n+  size_t off = 0, lim = 5;\n+  if (!UNSIGNED5::check_length(arr, off, lim)) {\n+    return 0;\n+  }\n+  return UNSIGNED5::read_uint(arr, off, lim);\n+}\n+\n+\/\/ check and decode a series of u5 values\n+\/\/ return the address after the last decoded byte\n+\/\/ if limit is non-zero stop before limit\n+\/\/ if count is non-negative stop when count is reached\n+\/\/ if count is negative stop on null (works kind of like strlen)\n+extern \"C\" JNIEXPORT intptr_t u5p(intptr_t addr, intptr_t limit, int count) {\n+  Command c(\"u5p\");\n+  u1* arr = (u1*)addr;\n+  if (limit && limit < addr)  limit = addr;\n+  size_t off = 0, lim = (size_t)(limit - addr);\n+  int printed = 0;\n+  tty->print(\"U5: [\");\n+  for (;;) {\n+    if (count >= 0 && printed >= count)  break;\n+    if (count < 0 && arr[off] == 0) {\n+      tty->print(\" null\");\n+      ++off;\n+      ++printed;\n+      continue;\n+    } else if (!UNSIGNED5::check_length(arr, off, lim)) {\n+      break;\n+    }\n+    u4 value = UNSIGNED5::read_uint(arr, off, lim);\n+    tty->print(\" %d\", value);\n+    ++printed;\n+  }\n+  tty->print_cr(\" ] (values=%d\/length=%d)\",\n+                printed, (int)off);\n+  return addr + off;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/unsigned5.hpp\"\n+\n+\/\/ Explicit instantiation for supported types.\n+\n+using AGS = UNSIGNED5::ArrayGetSet<u_char*,int>;\n+\n+template u4 UNSIGNED5::read_uint(u_char* array, int& offset_rw, int limit, AGS);\n+template void UNSIGNED5::write_uint(uint32_t value, u_char* array, int& offset_rw, int limit, AGS);\n+template int UNSIGNED5::check_length(u_char* array, int offset, int limit, AGS);\n+\n+\/\/template uint32_t UNSIGNED5::read_uint(address array, size_t& offset_rw, size_t limit, AGS);\n+\/\/template void UNSIGNED5::write_uint(uint32_t value, address array, size_t& offset_rw, size_t limit, AGS);\n+\/\/template int UNSIGNED5::check_length(address array, size_t offset, size_t limit, AGS);\n","filename":"src\/hotspot\/share\/utilities\/unsigned5.cpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,380 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_UNSIGNED5_HPP\n+#define SHARE_UTILITIES_UNSIGNED5_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+\/\/ Low-level interface for [de-]coding compressed uint32_t (u4) values.\n+\n+\/\/ A uint32_t value (32-bit unsigned int) can be encoded very quickly into\n+\/\/ one to five bytes, and decoded back again, again very quickly.\n+\/\/ This is useful for storing data, like offsets or access flags, that\n+\/\/ is usually simple (fits in fewer bytes usually) but sometimes has\n+\/\/ to be complicated (uses all five bytes when necessary).\n+\n+\/\/ Notable features:\n+\/\/  - represents all 32-bit uint32_t values\n+\/\/  - never reads or writes beyond 5 bytes\n+\/\/  - values up to 0xBE (0x307E\/0xC207E\/0x308207F) code in 1 byte (2\/3\/4 bytes)\n+\/\/  - longer encodings are always of larger values (length grows monotonically)\n+\/\/  - encodings are little-endian numerals in a modifed base-64 system\n+\/\/  - \"negatives\" ((u4)-1) need 5 bytes (but see also UNSIGNED5::encode_sign)\n+\/\/  - different encodings decode to different values (excepting overflow)\n+\/\/  - zero bytes are *never* used, so it interoperates with null termination\n+\/\/  - the algorithms are templates and cooperate well with your own types\n+\/\/  - one writer algorithm can grow your resizable buffer on the fly\n+\n+\/\/ The encoding, taken from J2SE Pack200, is called UNSIGNED5.\n+\/\/ It expects the uint32_t values you give it will have many leading zeroes.\n+\/\/\n+\/\/ More details:\n+\/\/ Very small values, in the range [0..190], code in one byte.\n+\/\/ Any 32-bit value (including negatives) can be coded, in\n+\/\/ up to five bytes.  The grammar is:\n+\/\/    low_byte  = [1..191]\n+\/\/    high_byte = [192..255]\n+\/\/    any_byte  = low_byte | high_byte\n+\/\/    coding = low_byte\n+\/\/           | high_byte low_byte\n+\/\/           | high_byte high_byte low_byte\n+\/\/           | high_byte high_byte high_byte low_byte\n+\/\/           | high_byte high_byte high_byte high_byte any_byte\n+\/\/ Each high_byte contributes six bits of payload.\n+\/\/ The encoding is one-to-one (except for integer overflow)\n+\/\/ and easy to parse and unparse.  Longer sequences always\n+\/\/ decode to larger numbers.  Sequences of the same length\n+\/\/ compares as little-endian numerals decode to numbers which\n+\/\/ are ordered in the same sense as those numerals.\n+\n+\/\/ Parsing (reading) consists of doing a limit test to see if the byte\n+\/\/ is a low-byte or a high-byte, and also unconditionally adding the\n+\/\/ digit value of the byte, multiplied by its 64-bit place value, to\n+\/\/ an accumulator.  The accumulator is returned after either 5 bytes\n+\/\/ are seen, or the first low-byte is seen.  Oddly enough, this is\n+\/\/ enough to create a dense var-int format, which is why it was\n+\/\/ adopted for Pack200.  By comparison, the more common LEB128 format\n+\/\/ is less dense (for many typical workloads) and does not guarantee a\n+\/\/ length limit.\n+\n+class UNSIGNED5 : AllStatic {\n+ private:\n+  \/\/ Math constants for the modified UNSIGNED5 coding of Pack200\n+  static const int lg_H  = 6;        \/\/ log-base-2 of H (lg 64 == 6)\n+  static const int H     = 1<<lg_H;  \/\/ number of \"high\" bytes (64)\n+  static const int X     = 1  ;      \/\/ there is one excluded byte ('\\0')\n+  static const int MAX_b = (1<<BitsPerByte)-1;  \/\/ largest byte value\n+  static const int L     = (MAX_b+1)-X-H;       \/\/ number of \"low\" bytes (191)\n+\n+ public:\n+  static const int MAX_LENGTH = 5;   \/\/ lengths are in [1..5]\n+  static const uint32_t MAX_VALUE = (uint32_t)-1;  \/\/ 2^^32-1\n+\n+  \/\/ The default method for reading and writing bytes is simply\n+  \/\/ b=a[i] and a[i]=b, as defined by this helpful functor.\n+  template<typename ARR, typename OFF>\n+  struct ArrayGetSet {\n+    uint8_t operator()(ARR a, OFF i) const { return a[i]; };\n+    void operator()(ARR a, OFF i, uint8_t b) const { a[i] = b; };\n+    \/\/ So, an expression ArrayGetSet() acts like these lambdas:\n+    \/\/auto get = [&](ARR a, OFF i){ return a[i]; };\n+    \/\/auto set = [&](ARR a, OFF i, uint8_t x){ a[i] = x; };\n+  };\n+\n+  \/\/ decode a single unsigned 32-bit int from an array-like base address\n+  \/\/ returns the decoded value, updates offset_rw\n+  \/\/ that is, offset_rw is both read and written\n+  \/\/ warning:  caller must ensure there is at least one byte available\n+  \/\/ the limit is either zero meaning no limit check, or an exclusive offset\n+  \/\/ in PRODUCT builds, limit is ignored\n+  template<typename ARR, typename OFF, typename GET = ArrayGetSet<ARR,OFF>>\n+  static uint32_t read_uint(ARR array, OFF& offset_rw, OFF limit, GET get = GET()) {\n+    const OFF pos = offset_rw;\n+    STATIC_ASSERT(sizeof(get(array, pos)) == 1);  \/\/ must be a byte-getter\n+    const uint32_t b_0 = (uint8_t) get(array, pos);  \/\/b_0 = a[0]\n+    assert(b_0 >= X, \"avoid excluded bytes\");\n+    uint32_t sum = b_0 - X;\n+    if (sum < L) {  \/\/ common case\n+      offset_rw = pos + 1;\n+      return sum;\n+    }\n+    \/\/ must collect more bytes:  b[1]...b[4]\n+    int lg_H_i = lg_H;  \/\/ lg(H)*i == lg(H^^i)\n+    for (int i = 1; ; i++) {  \/\/ for i in [1..4]\n+      assert(limit == 0 || pos + i < limit, \"oob\");\n+      const uint32_t b_i = (uint8_t) get(array, pos + i);  \/\/b_i = a[i]\n+      assert(b_i >= X, \"avoid excluded bytes\");\n+      sum += (b_i - X) << lg_H_i;  \/\/ sum += (b[i]-X)*(64^^i)\n+      if (b_i < X+L || i == MAX_LENGTH-1) {\n+        offset_rw = pos + i + 1;\n+        return sum;\n+      }\n+      lg_H_i += lg_H;\n+    }\n+  }\n+\n+  \/\/ encode a single unsigned 32-bit int into an array-like span\n+  \/\/ offset_rw is both read and written\n+  \/\/ the limit is either zero meaning no limit check, or an exclusive offset\n+  \/\/ warning:  caller must ensure there is available space\n+  template<typename ARR, typename OFF, typename SET = ArrayGetSet<ARR,OFF>>\n+  static void write_uint(uint32_t value, ARR array, OFF& offset_rw, OFF limit, SET set = SET()) {\n+    const OFF pos = offset_rw;\n+    if (value < L) {\n+      const uint32_t b_0 = X + value;\n+      assert(b_0 == (uint8_t)b_0, \"valid byte\");\n+      set(array, pos, (uint8_t)b_0);  \/\/a[0] = b_0\n+      offset_rw = pos + 1;\n+      return;\n+    }\n+    uint32_t sum = value;\n+    for (int i = 0; ; i++) {  \/\/ for i in [0..4]\n+      if (sum < L || i == MAX_LENGTH-1) {\n+        \/\/ remainder is either a \"low code\" or the 5th byte\n+        uint32_t b_i = X + sum;\n+        assert(b_i == (uint8_t)b_i, \"valid byte\");\n+        set(array, pos + i, (uint8_t)b_i);  \/\/a[i] = b_i\n+        offset_rw = pos + i + 1;\n+        return;\n+      }\n+      sum -= L;\n+      uint32_t b_i = X + L + (sum % H);  \/\/ this is a \"high code\"\n+      assert(b_i == (uint8_t)b_i, \"valid byte\");\n+      set(array, pos + i, (uint8_t)b_i);  \/\/a[i] = b_i\n+      sum >>= lg_H;                 \/\/ extracted 6 bits\n+    }\n+  }\n+\n+  \/\/ returns the encoded byte length of an unsigned 32-bit int\n+  static constexpr int encoded_length(uint32_t value) {\n+    \/\/ model the reading of [0..5] high-bytes, followed possibly by a low-byte\n+    \/\/ Be careful:  the constexpr magic evaporates if undefined behavior\n+    \/\/ results from any of these expressions.  Beware of signed overflow!\n+    uint32_t sum = 0;\n+    uint32_t lg_H_i = 0;\n+    for (uint32_t i = 0; ; i++) {  \/\/ for i in [1..4]\n+      if (value <= sum + ((L-1) << lg_H_i) || i == MAX_LENGTH-1) {\n+        return i + 1;  \/\/ stopping at byte i implies length is i+1\n+      }\n+      sum += (MAX_b - X) << lg_H_i;\n+      lg_H_i += lg_H;\n+    }\n+  }\n+\n+  \/\/ reports the largest uint32_t value that can be encoded using len bytes\n+  \/\/ len must be in the range [1..5]\n+  static constexpr uint32_t max_encoded_in_length(uint32_t len) {\n+    assert(len >= 1 && len <= MAX_LENGTH, \"invalid length\");\n+    if (len >= MAX_LENGTH)  return MAX_VALUE;  \/\/ largest non-overflow value\n+    \/\/ Be careful:  the constexpr magic evaporates if undefined behavior\n+    \/\/ results from any of these expressions.  Beware of signed overflow!\n+    uint32_t all_combinations = 0;\n+    uint32_t combinations_i = L;  \/\/ L * H^i\n+    for (uint32_t i = 0; i < len; i++) {\n+      \/\/ count combinations of <H*L> that end at byte i\n+      all_combinations += combinations_i;\n+      combinations_i <<= lg_H;\n+    }\n+    return all_combinations - 1;\n+  }\n+\n+  \/\/ tells if a value, when encoded, would fit between the offset and limit\n+  template<typename OFF>\n+  static constexpr bool fits_in_limit(uint32_t value, OFF offset, OFF limit) {\n+    assert(limit != 0, \"\");\n+    return (offset + MAX_LENGTH <= limit ||\n+            offset + encoded_length(value) <= limit);\n+  }\n+\n+  \/\/ parses one encoded value for correctness and returns the size,\n+  \/\/ or else returns zero if there is a problem (bad limit or excluded byte)\n+  \/\/ the limit is either zero meaning no limit check, or an exclusive offset\n+  template<typename ARR, typename OFF, typename GET = ArrayGetSet<ARR,OFF>>\n+  static int check_length(ARR array, OFF offset, OFF limit = 0,\n+                          GET get = GET()) {\n+    const OFF pos = offset;\n+    STATIC_ASSERT(sizeof(get(array, pos)) == 1);  \/\/ must be a byte-getter\n+    const uint32_t b_0 = (uint8_t) get(array, pos);  \/\/b_0 = a[0]\n+    if (b_0 < X+L) {\n+      return (b_0 < X) ? 0 : 1;\n+    }\n+    \/\/ parse more bytes:  b[1]...b[4]\n+    for (int i = 1; ; i++) {  \/\/ for i in [1..4]\n+      if (limit != 0 && pos + i >= limit)  return 0;  \/\/ limit failure\n+      const uint32_t b_i = (uint8_t) get(array, pos + i);  \/\/b_i = a[i]\n+      if (b_i < X)  return 0;  \/\/ excluded byte found\n+      if (b_i < X+L || i == MAX_LENGTH-1) {\n+        return i + 1;\n+      }\n+    }\n+  }\n+\n+  template<typename ARR, typename OFF, typename GFN,\n+           typename SET = ArrayGetSet<ARR,OFF>>\n+  static void write_uint_grow(uint32_t value,\n+                              ARR& array, OFF& offset, OFF& limit,\n+                              GFN grow, SET set = SET()) {\n+    assert(limit != 0, \"limit required\");\n+    const OFF pos = offset;\n+    if (!fits_in_limit(value, pos, limit)) {\n+      grow(MAX_LENGTH);  \/\/ caller must ensure it somehow fixes array\/limit span\n+      assert(pos + MAX_LENGTH <= limit, \"should have grown\");\n+    }\n+    write_uint(value, array, offset, limit, set);\n+  }\n+\n+  \/\/\/ Handy state machines for that will help you with reading,\n+  \/\/\/ sizing, and writing (with optional growth).\n+\n+  \/\/ Reader example use:\n+  \/\/  struct MyReaderHelper {\n+  \/\/    char operator()(char* a, int i) const { return a[i]; }\n+  \/\/  };\n+  \/\/  using MyReader = UNSIGNED5::Reader<char*, int, MyReaderHelper>;\n+  \/\/  MyReader r(array); while (r.has_next())  print(r.next_uint());\n+  template<typename ARR, typename OFF, typename GET = ArrayGetSet<ARR,OFF>>\n+  class Reader {\n+    const ARR _array;\n+    const OFF _limit;\n+    OFF _position;\n+    int next_length() {\n+      return UNSIGNED5::check_length(_array, _position, _limit, GET());\n+    }\n+  public:\n+    Reader(ARR array, OFF limit = 0)\n+      : _array(array), _limit(limit) { _position = 0; }\n+    uint32_t next_uint() {\n+      return UNSIGNED5::read_uint(_array, _position, _limit, GET());\n+    }\n+    bool has_next() {\n+      return next_length() != 0;\n+    }\n+    \/\/ tries to skip count logical entries; returns actual number skipped\n+    int try_skip(int count) {\n+      int actual = 0;\n+      while (actual < count && has_next()) {\n+        int len = next_length();  \/\/ 0 or length in [1..5]\n+        if (len == 0)  break;\n+        _position += len;\n+      }\n+      return actual;\n+    }\n+    ARR array() { return _array; }\n+    OFF limit() { return _limit; }\n+    OFF position() { return _position; }\n+    void set_position(OFF position) { _position = position; }\n+  };\n+\n+  \/\/ Writer example use\n+  \/\/  struct MyWriterHelper {\n+  \/\/    char operator()(char* a, int i, char b) const { a[i] = b; }\n+  \/\/  };\n+  \/\/  using MyWriter = UNSIGNED5::Writer<char*, int, MyWriterHelper>;\n+  \/\/  MyWriter w(array);\n+  \/\/  for (auto i = ...)  w.accept_uint(i);\n+  template<typename ARR, typename OFF, typename SET = ArrayGetSet<ARR,OFF>>\n+  class Writer {\n+    ARR& _array;\n+    OFF* const _limit_ptr;\n+    OFF _position;\n+    void limit_init() {\n+      assert(_limit_ptr == NULL || *_limit_ptr != 0, \"limit required\");\n+    }\n+  public:\n+    Writer(const ARR& array)\n+      : _array(const_cast<ARR&>(array)), _limit_ptr(NULL)\n+        \/\/ note:  if _limit_ptr is NULL, the ARR& is never reassigned\n+    { limit_init(); _position = 0; }\n+    Writer(ARR& array, OFF& limit)\n+      : _array(array), _limit_ptr(&limit)\n+    { limit_init(); _position = 0; }\n+    void accept_uint(uint32_t value) {\n+      const OFF lim = has_limit() ? limit() : 0;\n+      UNSIGNED5::write_uint(value, _array, _position, lim, SET());\n+    }\n+    template<typename GFN>\n+    void accept_grow(uint32_t value, GFN grow) {\n+      assert(has_limit(), \"must track growing limit\");\n+      UNSIGNED5::write_uint_grow(value, _array, _position, *_limit_ptr,\n+                                 grow, SET());\n+    }\n+    \/\/ Ensure that remaining() >= r, grow if needed.  Suggested\n+    \/\/ expression for r is (n*MAX_LENGTH)+1, where n is the number of\n+    \/\/ values you are about to write.\n+    template<typename GFN>\n+    void ensure_remaining_grow(int request_remaining, GFN grow) {\n+      const OFF have = remaining();\n+      if (have < request_remaining) {\n+        grow(have - request_remaining);  \/\/ caller must fix array\/limit span\n+        assert(remaining() >= request_remaining, \"should have grown\");\n+      }\n+    }\n+    \/\/ use to add a terminating null or other data\n+    void end_byte(uint8_t extra_byte = 0) {\n+      SET()(_array, _position++, extra_byte);\n+    }\n+    ARR array() { return _array; }\n+    OFF position() { return _position; }\n+    void set_position(OFF position) { _position = position; }\n+    bool has_limit() { return _limit_ptr != NULL; }\n+    OFF limit() { assert(has_limit(), \"needs limit\"); return *_limit_ptr; }\n+    OFF remaining() { return limit() - position(); }\n+  };\n+\n+  \/\/ Sizer example use\n+  \/\/  UNSIGNED5::Sizer s;\n+  \/\/  for (auto i = ...)  s.accept_uint(i);\n+  \/\/  printf(\"%d items occupying %d bytes\", s.count(), s.position());\n+  \/\/  auto buf = new char[s.position() + 1];\n+  \/\/  UNSIGNED5::Writer<char*, int> w(buf);\n+  \/\/  for (auto i = ...)  w.accept_uint(i);\n+  \/\/  w.add_byte();\n+  \/\/  assert(w.position() == s.position(), \"s and w agree\");\n+  template<typename OFF = int>\n+  class Sizer {\n+    OFF _position;\n+    int _count;\n+  public:\n+    Sizer() { _position = 0; _count = 0; }\n+    \/\/ The accept_uint() API is the same as for Writer, which allows\n+    \/\/ templated code to work equally well on sizers and writers.\n+    \/\/ This in turn makes it easier to write code which runs a\n+    \/\/ sizing preflight pass before actually storing the data.\n+    void accept_uint(uint32_t value) {\n+      _position += encoded_length(value);\n+      _count++;\n+    }\n+    OFF position() { return _position; }\n+    int count() { return _count; }\n+  };\n+\n+  \/\/ 32-bit one-to-one sign encoding taken from Pack200\n+  \/\/ converts leading sign bits into leading zeroes with trailing sign bit\n+  \/\/ use this to better compress 32-bit values that might be negative\n+  static uint32_t encode_sign(int32_t value) { return ((uint32_t)value << 1) ^ (value >> 31); }\n+  static int32_t decode_sign(uint32_t value) { return (value >> 1) ^ -(int32_t)(value & 1); }\n+};\n+#endif \/\/ SHARE_UTILITIES_UNSIGNED5_HPP\n","filename":"src\/hotspot\/share\/utilities\/unsigned5.hpp","additions":380,"deletions":0,"binary":false,"changes":380,"status":"added"},{"patch":"@@ -59,10 +59,0 @@\n-  public int readInt() {\n-    int b0 = read();\n-    if (b0 < L) {\n-      return b0;\n-    } else {\n-      return readIntMb(b0);\n-    }\n-  }\n-\n-\n@@ -88,30 +78,24 @@\n-  \/\/ Internals only below this point\n-  \/\/\n-\n-\n-  \/\/ This encoding, called UNSIGNED5, is taken from J2SE Pack200.\n-  \/\/ It assumes that most values have lots of leading zeroes.\n-  \/\/ Very small values, in the range [0..191], code in one byte.\n-  \/\/ Any 32-bit value (including negatives) can be coded, in\n-  \/\/ up to five bytes.  The grammar is:\n-  \/\/    low_byte  = [0..191]\n-  \/\/    high_byte = [192..255]\n-  \/\/    any_byte  = low_byte | high_byte\n-  \/\/    coding = low_byte\n-  \/\/           | high_byte low_byte\n-  \/\/           | high_byte high_byte low_byte\n-  \/\/           | high_byte high_byte high_byte low_byte\n-  \/\/           | high_byte high_byte high_byte high_byte any_byte\n-  \/\/ Each high_byte contributes six bits of payload.\n-  \/\/ The encoding is one-to-one (except for integer overflow)\n-  \/\/ and easy to parse and unparse.\n-\n-  private int readIntMb(int b0) {\n-    int pos = position - 1;\n-    int sum = b0;\n-    \/\/ must collect more bytes: b[1]...b[4]\n-    int lg_H_i = lg_H;\n-    for (int i = 0; ;) {\n-      int b_i = read(pos + (++i));\n-      sum += b_i << lg_H_i; \/\/ sum += b[i]*(64**i)\n-      if (b_i < L || i == MAX_i) {\n+  \/\/ Note: In the C++ code, the implementation of UNSIGNED5 has been\n+  \/\/ moved to its own header file, <unsigned5.hpp>.\n+\n+  public int readInt() {\n+    \/\/ UNSIGNED5::read_u4(_buffer, &_position, limit=0)\n+    int pos = position;\n+    int b_0 = read(pos);\n+    int sum = b_0 - X;\n+    \/\/ VM throws assert if b0<X; we just return -1 here instead\n+    if (sum < L) {  \/\/ common case\n+      setPosition(pos+1);\n+      return sum;\n+    }\n+    \/\/ must collect more bytes:  b[1]...b[4]\n+    int lg_H_i = lg_H;  \/\/ lg(H)*i == lg(H^^i)\n+    for (int i = 1; ; i++) {  \/\/ for i in [1..4]\n+      int b_i = read(pos + i);\n+      if (b_i < X) {  \/\/ avoid excluded bytes\n+        \/\/ VM throws assert here; should not happen\n+        setPosition(pos+i);  \/\/ do not consume the bad byte\n+        return sum;  \/\/ return whatever we have parsed so far\n+      }\n+      sum += (b_i - X) << lg_H_i;  \/\/ sum += (b[i]-X)*(64^^i)\n+      if (b_i < X+L || i == MAX_LENGTH-1) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CompressedReadStream.java","additions":24,"deletions":40,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -57,0 +57,3 @@\n+  \/\/ Note: In the C++ code, the implementation of UNSIGNED5 has been\n+  \/\/ moved to its own header file, <unsigned5.hpp>.\n+\n@@ -60,2 +63,4 @@\n-  public static final int L = (1<<BitsPerByte) - H; \/\/ number of low codes (192)\n-  public static final int MAX_i = 4;      \/\/ bytes are numbered in (0..4)\n+  public static final int X = 1;        \/\/ there is one excluded byte ('\\0')\n+  public static final int MAX_b = (1<<BitsPerByte)-1;  \/\/ largest byte value\n+  public static final int L = (MAX_b+1)-X-H;  \/\/ number of low codes (191)\n+  public static final int MAX_LENGTH = 5;  \/\/ lengths are in [1..5]\n@@ -71,0 +76,3 @@\n+  \/\/ Note: In the C++ code, the following little algorithms\n+  \/\/ have been moved elsewhere.\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CompressedStream.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,297 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/unsigned5.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ T.I.L.\n+\/\/ $ sh .\/configure ... --with-gtest=<...>\/googletest ...\n+\/\/ $ make exploded-test TEST=gtest:unsigned5\n+\n+TEST_VM(unsigned5, max_encoded_in_length) {\n+  int maxlen = UNSIGNED5::MAX_LENGTH;\n+  EXPECT_EQ(maxlen, 5);\n+  for (int i = 0; i <= 190; i++) {\n+    uint32_t interesting = i;\n+    EXPECT_EQ(UNSIGNED5::encoded_length(interesting), 1);\n+    EXPECT_EQ(UNSIGNED5::encoded_length(~interesting), maxlen);\n+  }\n+  for (int len = 1; len <= maxlen; len++) {\n+    uint32_t interesting = UNSIGNED5::max_encoded_in_length(len);\n+    EXPECT_EQ(UNSIGNED5::encoded_length(interesting-1), len);\n+    EXPECT_EQ(UNSIGNED5::encoded_length(interesting), len);\n+    if (len < 5) {\n+      EXPECT_EQ(UNSIGNED5::encoded_length(interesting+1), len+1);\n+      EXPECT_EQ(UNSIGNED5::encoded_length(interesting*2), len+1);\n+    }\n+    const int offset = -123;\n+    const int good_limit = offset + len;\n+    const int bad_limit  = good_limit - 1;\n+    EXPECT_TRUE(UNSIGNED5::fits_in_limit(interesting, offset, good_limit));\n+    EXPECT_TRUE(!UNSIGNED5::fits_in_limit(interesting, offset, bad_limit));\n+  }\n+}\n+\n+\/\/ Call FN on a nice list of \"interesting\" uint32_t values to encode\/decode.\n+\/\/ For each length in [1..5], the maximum encodable value of that\n+\/\/ length is \"interesting\", as are one more and one less than that\n+\/\/ value.  For each nybble (aligned 4-bit field) of a uint32_t, each\n+\/\/ possible value (in [0..15]) stored in that nybble is \"interesting\".\n+\/\/ Also \"interesting\" are some other values created by perturbing\n+\/\/ lower bits of that nybble-bearing number, by subtracting a power\n+\/\/ of -7 (up to -7^7).  That makes just over 1000 distinct numbers.\n+\/\/\n+\/\/ Calls to this function are repeatable, so you can call it to pack\n+\/\/ an output array, and then call it again to read an input array\n+\/\/ verifying that the retrieved values match the stored ones.\n+template<typename FN>\n+inline int enumerate_cases(FN fn) {\n+  \/\/ boundary values around the maximum encoded in each byte-length\n+  for (int len = 1; len <= 5; len++) {\n+    uint32_t interesting = UNSIGNED5::max_encoded_in_length(len);\n+    int res = fn(interesting-1);\n+    if (res)  return res;\n+    res = fn(interesting);\n+    if (res)  return res;\n+    if (interesting < (uint32_t)-1) {\n+      res = fn(interesting+1);\n+      if (res)  return res;\n+    }\n+  }\n+  \/\/ for each nybble, for each value in the nybble\n+  for (uint32_t npos = 0; npos < 32; npos += 4) {\n+    for (uint32_t nval = 0; nval <= 15; nval++) {\n+      uint32_t interesting = nval << npos;\n+      int res = fn(interesting);\n+      if (res)  return res;\n+      \/\/ mix in some crazy-looking values: powers of -7 to -7^7\n+      for (int pon7 = 1; pon7 < 1000000; pon7 *= -7) {\n+        uint32_t interesting2 = interesting - pon7;\n+        res = fn(interesting2);\n+        if (res)  return res;\n+      }\n+    }\n+  }\n+  return 0;\n+}\n+\n+TEST_VM(unsigned5, transcode_single) {\n+  const int limit = UNSIGNED5::MAX_LENGTH;\n+  u_char buffer[limit + 1];\n+  auto each_case = [&](uint32_t value) -> uint32_t {\n+    \/\/printf(\"case %08X len=%d\\n\", value, UNSIGNED5::encoded_length(value));\n+    int offset = 0;\n+    UNSIGNED5::write_uint(value, buffer, offset, limit);\n+    int length = offset;\n+    EXPECT_TRUE(length <= UNSIGNED5::MAX_LENGTH);\n+    EXPECT_EQ(length, UNSIGNED5::encoded_length(value)) << \"for value=\" << value;\n+    buffer[length] = 0;\n+    offset = 0;\n+    uint32_t check = UNSIGNED5::read_uint(buffer, offset, limit);\n+    EXPECT_EQ(offset, length) << \"for value=\" << value;\n+    EXPECT_EQ(value, check);\n+    return 0;\n+  };\n+  auto z = enumerate_cases(each_case);\n+  EXPECT_TRUE(!z);\n+}\n+\n+static int count_cases() {\n+  int case_count = 0;\n+  auto inc_case_count = [&](uint32_t){ ++case_count; return 0; };\n+  enumerate_cases(inc_case_count);\n+  return case_count;\n+}\n+\n+\/\/ try out a command from debug.cpp:\n+extern \"C\" intptr_t u5p(intptr_t addr, intptr_t limit, int count);\n+\n+TEST_VM(unsigned5, transcode_multiple) {\n+  int case_count = count_cases();\n+  const int limit = 200;\n+  ASSERT_TRUE(limit < case_count*UNSIGNED5::MAX_LENGTH);\n+  u_char buffer[limit + 1];\n+  \/\/printf(\"%d cases total\\n\", case_count);  \/\/1166 cases total\n+  for (int sublimit = limit - 20; sublimit < limit; sublimit++) {\n+    int offset = 0;\n+    int count = 0;\n+    \/\/ write each number into an array\n+    auto write_case = [&](uint32_t value) -> uint32_t {\n+      if (!UNSIGNED5::fits_in_limit(value, offset, sublimit))\n+        return value|1;\n+      UNSIGNED5::write_uint(value, buffer, offset, sublimit);\n+      count++;\n+      return 0;\n+    };\n+    auto done = enumerate_cases(write_case);\n+    EXPECT_TRUE(done) << \"must have hit the sublimit\";\n+    EXPECT_TRUE(count < case_count);\n+    int length = offset;\n+    EXPECT_TRUE(length <= sublimit && length + UNSIGNED5::MAX_LENGTH > sublimit)\n+           << \"length=\" << length << \" sublimit=\" << sublimit;\n+    for (int i = length; i <= sublimit; i++) {\n+      buffer[i] = 0;\n+    }\n+    if (sublimit == limit-1) {\n+      u5p((intptr_t)&buffer[0], (intptr_t)&buffer[sublimit], case_count + 1);\n+    }\n+    \/\/printf(\"encoded %d values in %d bytes: [[%s]]\\n\", count, length, buffer);\n+    \/\/ now read it all back\n+    offset = 0;\n+    int count2 = 0;\n+    auto read_back_case = [&](uint32_t value) -> uint32_t {\n+      int clen = UNSIGNED5::check_length(buffer, offset, sublimit);\n+      if (clen == 0)  return value|1;\n+      EXPECT_EQ(clen, UNSIGNED5::encoded_length(value));\n+      int begin = offset;\n+      uint32_t check = UNSIGNED5::read_uint(buffer, offset, sublimit);\n+      EXPECT_EQ(offset, begin + clen);\n+      EXPECT_EQ(value, check);\n+      count2++;\n+      return 0;\n+    };\n+    auto done2 = enumerate_cases(read_back_case);\n+    EXPECT_EQ(done, done2);\n+    EXPECT_EQ(count, count2);\n+    EXPECT_EQ(offset, length);\n+  }\n+}\n+\n+inline void init_ints(int len, int* ints) {\n+  for (int i = 0; i < len; i++) {\n+    ints[i] = (i * ((i&2) ? i : 1001)) ^ -(i & 1);\n+  }\n+}\n+\n+struct MyReaderHelper {\n+  uint8_t operator()(char* a, int i) const { return a[i]; }\n+};\n+using MyReader = UNSIGNED5::Reader<char*, int, MyReaderHelper>;\n+\n+TEST_VM(unsigned5, reader) {\n+  const int LEN = 100;\n+  int ints[LEN];\n+  init_ints(LEN, ints);\n+  int i;\n+  UNSIGNED5::Sizer<> szr;\n+  for (i = 0; i < LEN; i++) {\n+    szr.accept_uint(ints[i]);\n+  }\n+  \/\/printf(\"count=%d, size=%d\\n\", szr.count(), szr.position());\n+  char buf[LEN * UNSIGNED5::MAX_LENGTH + 1];\n+  int buflen;\n+  {\n+    int pos = 0;\n+    for (int i = 0; i < LEN; i++) {\n+      UNSIGNED5::write_uint(ints[i], buf, pos, 0);\n+    }\n+    EXPECT_TRUE(pos+1 < (int)sizeof(buf)) << pos;\n+    buflen = pos;\n+    buf[buflen] = 0;\n+  }\n+  EXPECT_EQ(szr.position(), buflen);\n+  MyReader r1(buf);\n+  i = 0;\n+  while (r1.has_next()) {\n+    int x = r1.next_uint();\n+    int y = ints[i++];\n+    ASSERT_EQ(x, y) << i;\n+  }\n+  ASSERT_EQ(i, LEN);\n+  MyReader r2(buf, buflen \/ 2);\n+  i = 0;\n+  while (r2.has_next()) {\n+    int x = r2.next_uint();\n+    int y = ints[i++];\n+    ASSERT_EQ(x, y) << i;\n+  }\n+  ASSERT_TRUE(i < LEN);\n+  \/\/ copy from reader to writer\n+  UNSIGNED5::Reader<char*,int> r3(buf);\n+  int array_limit = 1;\n+  char* array = new char[array_limit + 1];\n+  auto array_grow = [&](int){\n+    array[array_limit] = 0;\n+    auto oal = array_limit;\n+    array_limit += 10;\n+    \/\/printf(\"growing array from %d to %d\\n\", oal, array_limit);\n+    auto na = new char[array_limit + 1];\n+    strcpy(na, array);\n+    array = na;\n+  };\n+  UNSIGNED5::Writer<char*,int> w3(array, array_limit);\n+  while (r3.has_next()) {\n+    w3.accept_grow(r3.next_uint(), array_grow);\n+  }\n+  w3.end_byte();  \/\/ we always allocated one more than the limit!\n+  std::string buf_s(buf, buflen);\n+  std::string arr_s(array, strlen(array));\n+  ASSERT_EQ(buf_s, arr_s);\n+}\n+\n+\/\/ Here is some object code to look at if we want to do a manual\n+\/\/ study.  One could find the build file named test_unsigned5.o.cmdline\n+\/\/ and hand-edit the command line to produce assembly code in\n+\/\/ test_unsigned5.s.\n+\/\/\n+\/\/ Or, given the two empty \"fence functions\", one could do a\n+\/\/ quick scan like this:\n+\/\/\n+\/\/ $ objdump -D $(find build\/*release -name test_unsigned5.o) \\\n+\/\/   | sed -n \/start_code_quality\/,\/end_code_quality\/p \\\n+\/\/   | egrep -B10 bswap  # or grep -B20 cfi_endproc\n+\n+void start_code_quality_unsigned5() { }\n+\n+uint32_t code_quality_max_encoded_in_length(int i) {\n+  return UNSIGNED5::max_encoded_in_length(i);  \/\/ should compile like 5-switch\n+}\n+\n+int code_quality_encoded_length(uint32_t x) {\n+  return UNSIGNED5::encoded_length(x);  \/\/ should compile to 4-way comparison\n+}\n+\n+int code_quality_check_length(char* a) {\n+  return UNSIGNED5::check_length(a, 0);  \/\/ should compile with fast-path\n+}\n+\n+int code_quality_read_int(char* a) {\n+  int i = 0;\n+  return UNSIGNED5::read_uint(a, i, 0);  \/\/ should compile with fast-path\n+}\n+\n+int code_quality_int_reader(char* a) {\n+  MyReader r1(a);\n+  if (!r1.has_next())  return -1;\n+  return r1.next_uint();\n+}\n+\n+int code_quality_int_sizer(int* a, int n) {\n+  UNSIGNED5::Sizer<> s;\n+  for (int i = 0; i < n; i++)  s.accept_uint(a[i]);\n+  return s.position();\n+}\n+\n+void end_code_quality_unsigned5() { }\n","filename":"test\/hotspot\/gtest\/utilities\/test_unsigned5.cpp","additions":297,"deletions":0,"binary":false,"changes":297,"status":"added"}]}