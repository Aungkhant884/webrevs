{"files":[{"patch":"@@ -30,6 +30,0 @@\n-\/\/ 32-bit self-inverse encoding of float bits\n-\/\/ converts trailing zeroes (common in floats) to leading zeroes\n-inline juint CompressedStream::reverse_int(juint i) {\n-  return reverse_bits(i);\n-}\n-\n@@ -37,1 +31,1 @@\n-  return decode_sign(read_int());\n+  return UNSIGNED5::decode_sign(read_int());\n@@ -44,2 +38,4 @@\n-\/\/ compression.\n-\n+\/\/ compression.  Since bit reversal converts trailing zeroes to\n+\/\/ leading zeroes, effect is better compression of those common\n+\/\/ 32-bit float values, such as integers or integers divided by\n+\/\/ powers of two, that have many trailing zeroes.\n@@ -48,1 +44,1 @@\n-  int f  = reverse_int(rf);\n+  int f  = reverse_bits(rf);\n@@ -52,0 +48,6 @@\n+\/\/ The treatment of doubles is similar.  We could bit-reverse each\n+\/\/ entire 64-bit word, but it is almost as effective to bit-reverse\n+\/\/ the individual halves.  Since we are going to encode them\n+\/\/ separately as 32-bit halves anyway, it seems slightly simpler\n+\/\/ to reverse after splitting, and when reading reverse each\n+\/\/ half before joining them together.\n@@ -55,2 +57,2 @@\n-  jint h  = reverse_int(rh);\n-  jint l  = reverse_int(rl);\n+  jint h  = reverse_bits(rh);\n+  jint l  = reverse_bits(rl);\n@@ -60,0 +62,7 @@\n+\/\/ A 64-bit long is encoded into distinct 32-bit halves.  This saves\n+\/\/ us from having to define a 64-bit encoding and is almost as\n+\/\/ effective.  A modified LEB128 could encode longs into 9 bytes, and\n+\/\/ this technique maxes out at 10 bytes, so, if we didn't mind the\n+\/\/ extra complexity of another coding system, we could process 64-bit\n+\/\/ values as single units.  But, the complexity does not seem\n+\/\/ worthwhile.\n@@ -73,1 +82,6 @@\n-  u_char* _new_buffer = NEW_RESOURCE_ARRAY(u_char, _size * 2);\n+  int nsize = _size * 2;\n+  const int min_expansion = UNSIGNED5::MAX_LENGTH;\n+  if (nsize < min_expansion*2) {\n+    nsize = min_expansion*2;\n+  }\n+  u_char* _new_buffer = NEW_RESOURCE_ARRAY(u_char, nsize);\n@@ -76,1 +90,1 @@\n-  _size   = _size * 2;\n+  _size   = nsize;\n@@ -81,2 +95,2 @@\n-  juint rf = reverse_int(f);\n-  assert(f == reverse_int(rf), \"can re-read same bits\");\n+  juint rf = reverse_bits(f);\n+  assert(f == reverse_bits(rf), \"can re-read same bits\");\n@@ -89,4 +103,4 @@\n-  juint rh = reverse_int(h);\n-  juint rl = reverse_int(l);\n-  assert(h == reverse_int(rh), \"can re-read same bits\");\n-  assert(l == reverse_int(rl), \"can re-read same bits\");\n+  juint rh = reverse_bits(h);\n+  juint rl = reverse_bits(l);\n+  assert(h == reverse_bits(rh), \"can re-read same bits\");\n+  assert(l == reverse_bits(rl), \"can re-read same bits\");\n","filename":"src\/hotspot\/share\/code\/compressedStream.cpp","additions":34,"deletions":20,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/unsigned5.hpp\"\n@@ -39,12 +40,0 @@\n-  enum {\n-    \/\/ Constants for UNSIGNED5 coding of Pack200\n-    lg_H = 6, H = 1<<lg_H,    \/\/ number of high codes (64)\n-    L = (1<<BitsPerByte)-H,   \/\/ number of low codes (192)\n-    MAX_i = 4                 \/\/ bytes are numbered in (0..4), max 5 bytes\n-  };\n-\n-  \/\/ 32-bit one-to-one sign encoding taken from Pack200\n-  \/\/ converts leading sign bits into leading zeroes with trailing sign bit\n-  static juint encode_sign(jint  value) { return (value << 1) ^ (value >> 31); }\n-  static jint  decode_sign(juint value) { return (value >> 1) ^ -(jint)(value & 1); }\n-  static juint reverse_int(juint i);   \/\/ to trim trailing float 0's\n@@ -69,35 +58,0 @@\n-  \/\/ This encoding, called UNSIGNED5, is taken from J2SE Pack200.\n-  \/\/ It assumes that most values have lots of leading zeroes.\n-  \/\/ Very small values, in the range [0..191], code in one byte.\n-  \/\/ Any 32-bit value (including negatives) can be coded, in\n-  \/\/ up to five bytes.  The grammar is:\n-  \/\/    low_byte  = [0..191]\n-  \/\/    high_byte = [192..255]\n-  \/\/    any_byte  = low_byte | high_byte\n-  \/\/    coding = low_byte\n-  \/\/           | high_byte low_byte\n-  \/\/           | high_byte high_byte low_byte\n-  \/\/           | high_byte high_byte high_byte low_byte\n-  \/\/           | high_byte high_byte high_byte high_byte any_byte\n-  \/\/ Each high_byte contributes six bits of payload.\n-  \/\/ The encoding is one-to-one (except for integer overflow)\n-  \/\/ and easy to parse and unparse.\n-\n-  jint read_int_mb(jint b0) {\n-    int     pos = position() - 1;\n-    u_char* buf = buffer() + pos;\n-    assert(buf[0] == b0 && b0 >= L, \"correctly called\");\n-    jint    sum = b0;\n-    \/\/ must collect more bytes:  b[1]...b[4]\n-    int lg_H_i = lg_H;\n-    for (int i = 0; ; ) {\n-      jint b_i = buf[++i]; \/\/ b_i = read(); ++i;\n-      sum += b_i << lg_H_i;  \/\/ sum += b[i]*(64**i)\n-      if (b_i < L || i == MAX_i) {\n-        set_position(pos+i+1);\n-        return sum;\n-      }\n-      lg_H_i += lg_H;\n-    }\n-  }\n-\n@@ -112,4 +66,0 @@\n-  jint     read_int()                  { jint   b0 = read();\n-                                         if (b0 < L)  return b0;\n-                                         else         return read_int_mb(b0);\n-                                       }\n@@ -117,2 +67,2 @@\n-  jfloat   read_float();               \/\/ jfloat_cast(reverse_int(read_int()))\n-  jdouble  read_double();              \/\/ jdouble_cast(2*reverse_int(read_int))\n+  jfloat   read_float();               \/\/ jfloat_cast(reverse_bits(read_int()))\n+  jdouble  read_double();              \/\/ jdouble_cast(2*reverse_bits(read_int))\n@@ -120,0 +70,4 @@\n+\n+  jint     read_int() {\n+    return UNSIGNED5::read_uint(_buffer, _position, 0);\n+  }\n@@ -137,17 +91,0 @@\n-  \/\/ UNSIGNED5 coding, 1-5 byte cases\n-  void write_int_mb(jint value) {\n-    juint sum = value;\n-    for (int i = 0; ; ) {\n-      if (sum < L || i == MAX_i) {\n-        \/\/ remainder is either a \"low code\" or the 5th byte\n-        assert(sum == (u_char)sum, \"valid byte\");\n-        write((u_char)sum);\n-        break;\n-      }\n-      sum -= L;\n-      int b_i = L + (sum % H);  \/\/ this is a \"high code\"\n-      sum >>= lg_H;             \/\/ extracted 6 bits\n-      write(b_i); ++i;\n-    }\n-  }\n-\n@@ -166,6 +103,3 @@\n-  void write_int(jint value)           { if ((juint)value < L && !full())\n-                                               store((u_char)value);\n-                                         else  write_int_mb(value);  }\n-  void write_signed_int(jint value)    { write_int(encode_sign(value)); }\n-  void write_float(jfloat value);      \/\/ write_int(reverse_int(jint_cast(v)))\n-  void write_double(jdouble value);    \/\/ write_int(reverse_int(<low,high>))\n+  void write_signed_int(jint value)    { write_int(UNSIGNED5::encode_sign(value)); }\n+  void write_float(jfloat value);      \/\/ write_int(reverse_bits(jint_cast(v)))\n+  void write_double(jdouble value);    \/\/ write_int(reverse_bits(<low,high>))\n@@ -173,0 +107,5 @@\n+\n+  void write_int(juint value) {\n+    UNSIGNED5::write_uint_grow(value, _buffer, _position, _size,\n+                               [&](int){ grow(); });\n+  }\n","filename":"src\/hotspot\/share\/code\/compressedStream.hpp","additions":15,"deletions":76,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+#include \"utilities\/unsigned5.hpp\"\n@@ -651,0 +652,31 @@\n+\/\/ check and decode a single u5 value\n+extern \"C\" JNIEXPORT u4 u5decode(intptr_t addr) {\n+  Command c(\"u5decode\");\n+  u1* arr = (u1*)addr;\n+  size_t off = 0, lim = 5;\n+  if (!UNSIGNED5::check_length(arr, off, lim)) {\n+    return 0;\n+  }\n+  return UNSIGNED5::read_uint(arr, off, lim);\n+}\n+\n+\/\/ Sets up a Reader from addr\/limit and prints count items.\n+\/\/ A limit of zero means no set limit; stop at the first null\n+\/\/ or after count items are printed.\n+\/\/ A count of zero or less is converted to -1, which means\n+\/\/ there is no limit on the count of items printed; the\n+\/\/ printing stops when an null is printed or at limit.\n+\/\/ See documentation for UNSIGNED5::Reader::print(count).\n+extern \"C\" JNIEXPORT intptr_t u5p(intptr_t addr,\n+                                  intptr_t limit,\n+                                  int count) {\n+  Command c(\"u5p\");\n+  u1* arr = (u1*)addr;\n+  if (limit && limit < addr)  limit = addr;\n+  size_t lim = !limit ? 0 : (limit - addr);\n+  size_t endpos = UNSIGNED5::print_count(count > 0 ? count : -1,\n+                                         arr, (size_t)0, lim);\n+  return addr + endpos;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/unsigned5.hpp\"\n+\n+\/\/ Most of UNSIGNED5 is in the header file.\n+\/\/ Let's put a few debug functions out-of-line here.\n+\n+\/\/ For the record, UNSIGNED5 was defined around 2001 and was first\n+\/\/ published in the initial Pack200 spec.  See:\n+\/\/ https:\/\/docs.oracle.com\/en\/java\/javase\/11\/docs\/specs\/pack-spec.html\n+\/\/ in Section 6.1, \"Encoding of Small Whole Numbers\".\n+\n+PRAGMA_DIAG_PUSH\n+PRAGMA_FORMAT_NONLITERAL_IGNORED\n+\n+\/\/ For debugging, even in product builds (see debug.cpp).\n+template<typename ARR, typename OFF, typename GET>\n+void UNSIGNED5::Reader<ARR,OFF,GET>::\n+print_on(outputStream* st, int count,\n+         const char* left,   \/\/ \"U5: [\"\n+         const char* right   \/\/ \"] (values=%d\/length=%d)\\n\"\n+         ) {\n+  if (left == NULL)   left = \"U5: [\";\n+  if (right == NULL)  right = \"] (values=%d\/length=%d)\\n\";\n+  int printed = 0;\n+  st->print(\"%s\", left);\n+  for (;;) {\n+    if (count >= 0 && printed >= count)  break;\n+    if (!has_next()) {\n+      if ((_limit == 0 || _position < _limit) && _array[_position] == 0) {\n+        st->print(\" null\");\n+        ++_position;  \/\/ skip null byte\n+        ++printed;\n+        if (_limit != 0)  continue;  \/\/ keep going to explicit limit\n+      }\n+      break;\n+    }\n+    u4 value = next_uint();\n+    if (printed == 0)\n+      st->print(\"%d\", value);\n+    else\n+      st->print(\" %d\", value);\n+    ++printed;\n+  }\n+  st->print(right,\n+            \/\/ these arguments may or may not be used in the format string:\n+            printed,\n+            (int)_position);\n+}\n+\n+PRAGMA_DIAG_POP\n+\n+\/\/ Explicit instantiation for supported types.\n+template void UNSIGNED5::Reader<char*,int>::\n+print_on(outputStream* st, int count, const char* left, const char* right);\n+template void UNSIGNED5::Reader<u1*,int>::\n+print_on(outputStream* st, int count, const char* left, const char* right);\n+template void UNSIGNED5::Reader<address,size_t>::\n+print_on(outputStream* st, int count, const char* left, const char* right);\n","filename":"src\/hotspot\/share\/utilities\/unsigned5.cpp","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,419 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_UNSIGNED5_HPP\n+#define SHARE_UTILITIES_UNSIGNED5_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+\/\/ Low-level interface for [de-]coding compressed uint32_t (u4) values.\n+\n+\/\/ A uint32_t value (32-bit unsigned int) can be encoded very quickly into\n+\/\/ one to five bytes, and decoded back again, again very quickly.\n+\/\/ This is useful for storing data, like offsets or access flags, that\n+\/\/ is usually simple (fits in fewer bytes usually) but sometimes has\n+\/\/ to be complicated (uses all five bytes when necessary).\n+\n+\/\/ Notable features:\n+\/\/  - represents all 32-bit uint32_t values\n+\/\/  - never reads or writes beyond 5 bytes\n+\/\/  - values up to 0xBE (0x307E\/0xC207E\/0x308207F) code in 1 byte (2\/3\/4 bytes)\n+\/\/  - longer encodings are always of larger values (length grows monotonically)\n+\/\/  - encodings are little-endian numerals in a modifed base-64 system\n+\/\/  - \"negatives\" ((u4)-1) need 5 bytes (but see also UNSIGNED5::encode_sign)\n+\/\/  - different encodings decode to different values (excepting overflow)\n+\/\/  - zero bytes are *never* used, so it interoperates with null termination\n+\/\/  - the algorithms are templates and cooperate well with your own types\n+\/\/  - one writer algorithm can grow your resizable buffer on the fly\n+\n+\/\/ The encoding, taken from J2SE Pack200, is called UNSIGNED5.\n+\/\/ It expects the uint32_t values you give it will have many leading zeroes.\n+\/\/\n+\/\/ More details:\n+\/\/ Very small values, in the range [0..190], code in one byte.\n+\/\/ Any 32-bit value (including negatives) can be coded, in\n+\/\/ up to five bytes.  The grammar is:\n+\/\/    low_byte  = [1..191]\n+\/\/    high_byte = [192..255]\n+\/\/    any_byte  = low_byte | high_byte\n+\/\/    coding = low_byte\n+\/\/           | high_byte low_byte\n+\/\/           | high_byte high_byte low_byte\n+\/\/           | high_byte high_byte high_byte low_byte\n+\/\/           | high_byte high_byte high_byte high_byte any_byte\n+\/\/ Each high_byte contributes six bits of payload.\n+\/\/ The encoding is one-to-one (except for integer overflow)\n+\/\/ and easy to parse and unparse.  Longer sequences always\n+\/\/ decode to larger numbers.  Sequences of the same length\n+\/\/ compares as little-endian numerals decode to numbers which\n+\/\/ are ordered in the same sense as those numerals.\n+\n+\/\/ Parsing (reading) consists of doing a limit test to see if the byte\n+\/\/ is a low-byte or a high-byte, and also unconditionally adding the\n+\/\/ digit value of the byte, multiplied by its 64-bit place value, to\n+\/\/ an accumulator.  The accumulator is returned after either 5 bytes\n+\/\/ are seen, or the first low-byte is seen.  Oddly enough, this is\n+\/\/ enough to create a dense var-int format, which is why it was\n+\/\/ adopted for Pack200.  By comparison, the more common LEB128 format\n+\/\/ is less dense (for many typical workloads) and does not guarantee a\n+\/\/ length limit.\n+\n+class UNSIGNED5 : AllStatic {\n+ private:\n+  \/\/ Math constants for the modified UNSIGNED5 coding of Pack200\n+  static const int lg_H  = 6;        \/\/ log-base-2 of H (lg 64 == 6)\n+  static const int H     = 1<<lg_H;  \/\/ number of \"high\" bytes (64)\n+  static const int X     = 1  ;      \/\/ there is one excluded byte ('\\0')\n+  static const int MAX_b = (1<<BitsPerByte)-1;  \/\/ largest byte value\n+  static const int L     = (MAX_b+1)-X-H;       \/\/ number of \"low\" bytes (191)\n+\n+ public:\n+  static const int MAX_LENGTH = 5;   \/\/ lengths are in [1..5]\n+  static const uint32_t MAX_VALUE = (uint32_t)-1;  \/\/ 2^^32-1\n+\n+  \/\/ The default method for reading and writing bytes is simply\n+  \/\/ b=a[i] and a[i]=b, as defined by this helpful functor.\n+  template<typename ARR, typename OFF>\n+  struct ArrayGetSet {\n+    uint8_t operator()(ARR a, OFF i) const { return a[i]; };\n+    void operator()(ARR a, OFF i, uint8_t b) const { a[i] = b; };\n+    \/\/ So, an expression ArrayGetSet() acts like these lambdas:\n+    \/\/auto get = [&](ARR a, OFF i){ return a[i]; };\n+    \/\/auto set = [&](ARR a, OFF i, uint8_t x){ a[i] = x; };\n+  };\n+\n+  \/\/ decode a single unsigned 32-bit int from an array-like base address\n+  \/\/ returns the decoded value, updates offset_rw\n+  \/\/ that is, offset_rw is both read and written\n+  \/\/ warning:  caller must ensure there is at least one byte available\n+  \/\/ the limit is either zero meaning no limit check, or an exclusive offset\n+  \/\/ in PRODUCT builds, limit is ignored\n+  template<typename ARR, typename OFF, typename GET = ArrayGetSet<ARR,OFF>>\n+  static uint32_t read_uint(ARR array, OFF& offset_rw, OFF limit, GET get = GET()) {\n+    const OFF pos = offset_rw;\n+    STATIC_ASSERT(sizeof(get(array, pos)) == 1);  \/\/ must be a byte-getter\n+    const uint32_t b_0 = (uint8_t) get(array, pos);  \/\/b_0 = a[0]\n+    assert(b_0 >= X, \"avoid excluded bytes\");\n+    uint32_t sum = b_0 - X;\n+    if (sum < L) {  \/\/ common case\n+      offset_rw = pos + 1;\n+      return sum;\n+    }\n+    \/\/ must collect more bytes:  b[1]...b[4]\n+    int lg_H_i = lg_H;  \/\/ lg(H)*i == lg(H^^i)\n+    for (int i = 1; ; i++) {  \/\/ for i in [1..4]\n+      assert(limit == 0 || pos + i < limit, \"oob\");\n+      const uint32_t b_i = (uint8_t) get(array, pos + i);  \/\/b_i = a[i]\n+      assert(b_i >= X, \"avoid excluded bytes\");\n+      sum += (b_i - X) << lg_H_i;  \/\/ sum += (b[i]-X)*(64^^i)\n+      if (b_i < X+L || i == MAX_LENGTH-1) {\n+        offset_rw = pos + i + 1;\n+        return sum;\n+      }\n+      lg_H_i += lg_H;\n+    }\n+  }\n+\n+  \/\/ encode a single unsigned 32-bit int into an array-like span\n+  \/\/ offset_rw is both read and written\n+  \/\/ the limit is either zero meaning no limit check, or an exclusive offset\n+  \/\/ warning:  caller must ensure there is available space\n+  template<typename ARR, typename OFF, typename SET = ArrayGetSet<ARR,OFF>>\n+  static void write_uint(uint32_t value, ARR array, OFF& offset_rw, OFF limit, SET set = SET()) {\n+    const OFF pos = offset_rw;\n+    if (value < L) {\n+      const uint32_t b_0 = X + value;\n+      assert(b_0 == (uint8_t)b_0, \"valid byte\");\n+      set(array, pos, (uint8_t)b_0);  \/\/a[0] = b_0\n+      offset_rw = pos + 1;\n+      return;\n+    }\n+    uint32_t sum = value;\n+    for (int i = 0; ; i++) {  \/\/ for i in [0..4]\n+      if (sum < L || i == MAX_LENGTH-1) {\n+        \/\/ remainder is either a \"low code\" or the 5th byte\n+        uint32_t b_i = X + sum;\n+        assert(b_i == (uint8_t)b_i, \"valid byte\");\n+        set(array, pos + i, (uint8_t)b_i);  \/\/a[i] = b_i\n+        offset_rw = pos + i + 1;\n+        return;\n+      }\n+      sum -= L;\n+      uint32_t b_i = X + L + (sum % H);  \/\/ this is a \"high code\"\n+      assert(b_i == (uint8_t)b_i, \"valid byte\");\n+      set(array, pos + i, (uint8_t)b_i);  \/\/a[i] = b_i\n+      sum >>= lg_H;                 \/\/ extracted 6 bits\n+    }\n+  }\n+\n+  \/\/ returns the encoded byte length of an unsigned 32-bit int\n+  static constexpr int encoded_length(uint32_t value) {\n+    \/\/ model the reading of [0..5] high-bytes, followed possibly by a low-byte\n+    \/\/ Be careful:  the constexpr magic evaporates if undefined behavior\n+    \/\/ results from any of these expressions.  Beware of signed overflow!\n+    uint32_t sum = 0;\n+    uint32_t lg_H_i = 0;\n+    for (uint32_t i = 0; ; i++) {  \/\/ for i in [1..4]\n+      if (value <= sum + ((L-1) << lg_H_i) || i == MAX_LENGTH-1) {\n+        return i + 1;  \/\/ stopping at byte i implies length is i+1\n+      }\n+      sum += (MAX_b - X) << lg_H_i;\n+      lg_H_i += lg_H;\n+    }\n+  }\n+\n+  \/\/ reports the largest uint32_t value that can be encoded using len bytes\n+  \/\/ len must be in the range [1..5]\n+  static constexpr uint32_t max_encoded_in_length(uint32_t len) {\n+    assert(len >= 1 && len <= MAX_LENGTH, \"invalid length\");\n+    if (len >= MAX_LENGTH)  return MAX_VALUE;  \/\/ largest non-overflow value\n+    \/\/ Be careful:  the constexpr magic evaporates if undefined behavior\n+    \/\/ results from any of these expressions.  Beware of signed overflow!\n+    uint32_t all_combinations = 0;\n+    uint32_t combinations_i = L;  \/\/ L * H^i\n+    for (uint32_t i = 0; i < len; i++) {\n+      \/\/ count combinations of <H*L> that end at byte i\n+      all_combinations += combinations_i;\n+      combinations_i <<= lg_H;\n+    }\n+    return all_combinations - 1;\n+  }\n+\n+  \/\/ tells if a value, when encoded, would fit between the offset and limit\n+  template<typename OFF>\n+  static constexpr bool fits_in_limit(uint32_t value, OFF offset, OFF limit) {\n+    assert(limit != 0, \"\");\n+    return (offset + MAX_LENGTH <= limit ||\n+            offset + encoded_length(value) <= limit);\n+  }\n+\n+  \/\/ parses one encoded value for correctness and returns the size,\n+  \/\/ or else returns zero if there is a problem (bad limit or excluded byte)\n+  \/\/ the limit is either zero meaning no limit check, or an exclusive offset\n+  template<typename ARR, typename OFF, typename GET = ArrayGetSet<ARR,OFF>>\n+  static int check_length(ARR array, OFF offset, OFF limit = 0,\n+                          GET get = GET()) {\n+    const OFF pos = offset;\n+    STATIC_ASSERT(sizeof(get(array, pos)) == 1);  \/\/ must be a byte-getter\n+    const uint32_t b_0 = (uint8_t) get(array, pos);  \/\/b_0 = a[0]\n+    if (b_0 < X+L) {\n+      return (b_0 < X) ? 0 : 1;\n+    }\n+    \/\/ parse more bytes:  b[1]...b[4]\n+    for (int i = 1; ; i++) {  \/\/ for i in [1..4]\n+      if (limit != 0 && pos + i >= limit)  return 0;  \/\/ limit failure\n+      const uint32_t b_i = (uint8_t) get(array, pos + i);  \/\/b_i = a[i]\n+      if (b_i < X)  return 0;  \/\/ excluded byte found\n+      if (b_i < X+L || i == MAX_LENGTH-1) {\n+        return i + 1;\n+      }\n+    }\n+  }\n+\n+  template<typename ARR, typename OFF, typename GFN,\n+           typename SET = ArrayGetSet<ARR,OFF>>\n+  static void write_uint_grow(uint32_t value,\n+                              ARR& array, OFF& offset, OFF& limit,\n+                              GFN grow, SET set = SET()) {\n+    assert(limit != 0, \"limit required\");\n+    const OFF pos = offset;\n+    if (!fits_in_limit(value, pos, limit)) {\n+      grow(MAX_LENGTH);  \/\/ caller must ensure it somehow fixes array\/limit span\n+      assert(pos + MAX_LENGTH <= limit, \"should have grown\");\n+    }\n+    write_uint(value, array, offset, limit, set);\n+  }\n+\n+  \/\/\/ Handy state machines for that will help you with reading,\n+  \/\/\/ sizing, and writing (with optional growth).\n+\n+  \/\/ Reader example use:\n+  \/\/  struct MyReaderHelper {\n+  \/\/    char operator()(char* a, int i) const { return a[i]; }\n+  \/\/  };\n+  \/\/  using MyReader = UNSIGNED5::Reader<char*, int, MyReaderHelper>;\n+  \/\/  MyReader r(array); while (r.has_next())  print(r.next_uint());\n+  template<typename ARR, typename OFF, typename GET = ArrayGetSet<ARR,OFF>>\n+  class Reader {\n+    const ARR _array;\n+    const OFF _limit;\n+    OFF _position;\n+    int next_length() {\n+      return UNSIGNED5::check_length(_array, _position, _limit, GET());\n+    }\n+  public:\n+    Reader(ARR array, OFF limit = 0)\n+      : _array(array), _limit(limit) { _position = 0; }\n+    uint32_t next_uint() {\n+      return UNSIGNED5::read_uint(_array, _position, _limit, GET());\n+    }\n+    bool has_next() {\n+      return next_length() != 0;\n+    }\n+    \/\/ tries to skip count logical entries; returns actual number skipped\n+    int try_skip(int count) {\n+      int actual = 0;\n+      while (actual < count && has_next()) {\n+        int len = next_length();  \/\/ 0 or length in [1..5]\n+        if (len == 0)  break;\n+        _position += len;\n+      }\n+      return actual;\n+    }\n+    ARR array() { return _array; }\n+    OFF limit() { return _limit; }\n+    OFF position() { return _position; }\n+    void set_position(OFF position) { _position = position; }\n+\n+    \/\/ For debugging, even in product builds (see debug.cpp).\n+    \/\/ Checks and decodes a series of u5 values from the reader.\n+    \/\/ Sets position just after the last decoded byte or null byte.\n+    \/\/ If this reader has a limit, stop before that limit.\n+    \/\/ If this reader has no limit, stop after the first null byte.\n+    \/\/ In any case, if count is non-negative, print no more than\n+    \/\/ count items (uint32_t values or \"null\").\n+    \/\/ A negative count means we stop only at the limit or null,\n+    \/\/ kind of like strlen.\n+    void print(int count = -1) { print_on(tty, count); }\n+\n+    \/\/ The character strings are printed before and after the\n+    \/\/ series of values (which are separated only by spaces).\n+    \/\/ If they are null they default to something like \"U5:[ \"\n+    \/\/ and \" ] (values=%d\/length=%d)\\n\".\n+    \/\/ The %d formats are for the number of printed items and\n+    \/\/ their length in bytes, if you want to see that also.\n+    void print_on(outputStream* st, int count = -1,\n+                  const char* left = NULL, const char* right = NULL);\n+  };\n+\n+  \/\/ Writer example use\n+  \/\/  struct MyWriterHelper {\n+  \/\/    char operator()(char* a, int i, char b) const { a[i] = b; }\n+  \/\/  };\n+  \/\/  using MyWriter = UNSIGNED5::Writer<char*, int, MyWriterHelper>;\n+  \/\/  MyWriter w(array);\n+  \/\/  for (auto i = ...)  w.accept_uint(i);\n+  template<typename ARR, typename OFF, typename SET = ArrayGetSet<ARR,OFF>>\n+  class Writer {\n+    ARR& _array;\n+    OFF* const _limit_ptr;\n+    OFF _position;\n+  public:\n+    Writer(const ARR& array)\n+      : _array(const_cast<ARR&>(array)), _limit_ptr(NULL), _position(0) {\n+      \/\/ Note: if _limit_ptr is NULL, the ARR& is never reassigned,\n+      \/\/ because has_limit is false.  So the const_cast here is safe.\n+      assert(!has_limit(), \"this writer cannot be growable\");\n+    }\n+    Writer(ARR& array, OFF& limit)\n+      : _array(array), _limit_ptr(&limit), _position(0) {\n+      \/\/ Writable array argument can be rewritten by accept_grow.\n+      \/\/ So we need a legitimate (non-zero) limit to work with.\n+      \/\/ As a result, a writer's initial buffer must not be empty.\n+      assert(limit() != 0, \"limit required\");\n+    }\n+    void accept_uint(uint32_t value) {\n+      const OFF lim = has_limit() ? limit() : 0;\n+      UNSIGNED5::write_uint(value, _array, _position, lim, SET());\n+    }\n+    template<typename GFN>\n+    void accept_grow(uint32_t value, GFN grow) {\n+      assert(has_limit(), \"must track growing limit\");\n+      UNSIGNED5::write_uint_grow(value, _array, _position, *_limit_ptr,\n+                                 grow, SET());\n+    }\n+    \/\/ Ensure that remaining() >= r, grow if needed.  Suggested\n+    \/\/ expression for r is (n*MAX_LENGTH)+1, where n is the number of\n+    \/\/ values you are about to write.\n+    template<typename GFN>\n+    void ensure_remaining_grow(int request_remaining, GFN grow) {\n+      const OFF have = remaining();\n+      if (have < request_remaining) {\n+        grow(have - request_remaining);  \/\/ caller must fix array\/limit span\n+        assert(remaining() >= request_remaining, \"should have grown\");\n+      }\n+    }\n+    \/\/ use to add a terminating null or other data\n+    void end_byte(uint8_t extra_byte = 0) {\n+      SET()(_array, _position++, extra_byte);\n+    }\n+    ARR array() { return _array; }\n+    OFF position() { return _position; }\n+    void set_position(OFF position) { _position = position; }\n+    bool has_limit() { return _limit_ptr != NULL; }\n+    OFF limit() { assert(has_limit(), \"needs limit\"); return *_limit_ptr; }\n+    OFF remaining() { return limit() - position(); }\n+  };\n+\n+  \/\/ Sizer example use\n+  \/\/  UNSIGNED5::Sizer s;\n+  \/\/  for (auto i = ...)  s.accept_uint(i);\n+  \/\/  printf(\"%d items occupying %d bytes\", s.count(), s.position());\n+  \/\/  auto buf = new char[s.position() + 1];\n+  \/\/  UNSIGNED5::Writer<char*, int> w(buf);\n+  \/\/  for (auto i = ...)  w.accept_uint(i);\n+  \/\/  w.add_byte();\n+  \/\/  assert(w.position() == s.position(), \"s and w agree\");\n+  template<typename OFF = int>\n+  class Sizer {\n+    OFF _position;\n+    int _count;\n+  public:\n+    Sizer() { _position = 0; _count = 0; }\n+    \/\/ The accept_uint() API is the same as for Writer, which allows\n+    \/\/ templated code to work equally well on sizers and writers.\n+    \/\/ This in turn makes it easier to write code which runs a\n+    \/\/ sizing preflight pass before actually storing the data.\n+    void accept_uint(uint32_t value) {\n+      _position += encoded_length(value);\n+      _count++;\n+    }\n+    OFF position() { return _position; }\n+    int count() { return _count; }\n+  };\n+\n+  \/\/ 32-bit one-to-one sign encoding taken from Pack200\n+  \/\/ converts leading sign bits into leading zeroes with trailing sign bit\n+  \/\/ use this to better compress 32-bit values that might be negative\n+  static uint32_t encode_sign(int32_t value) { return ((uint32_t)value << 1) ^ (value >> 31); }\n+  static int32_t decode_sign(uint32_t value) { return (value >> 1) ^ -(int32_t)(value & 1); }\n+\n+  template<typename ARR, typename OFF, typename GET = ArrayGetSet<ARR,OFF>>\n+  static OFF print(ARR array, OFF offset = 0, OFF limit = 0,\n+                   GET get = GET()) {\n+    print_count(-1, array, offset, limit, get);\n+  }\n+  template<typename ARR, typename OFF, typename GET = ArrayGetSet<ARR,OFF>>\n+  static OFF print_count(int count,\n+                         ARR array, OFF offset = 0, OFF limit = 0,\n+                         GET get = GET()) {\n+    Reader<ARR,OFF,GET> r(array, offset);\n+\n+    r.print_on(tty, count);\n+    return r.position();\n+  }\n+};\n+#endif \/\/ SHARE_UTILITIES_UNSIGNED5_HPP\n","filename":"src\/hotspot\/share\/utilities\/unsigned5.hpp","additions":419,"deletions":0,"binary":false,"changes":419,"status":"added"},{"patch":"@@ -27,0 +27,2 @@\n+import java.io.PrintStream;\n+\n@@ -28,0 +30,1 @@\n+import sun.jvm.hotspot.utilities.*;\n@@ -59,10 +62,0 @@\n-  public int readInt() {\n-    int b0 = read();\n-    if (b0 < L) {\n-      return b0;\n-    } else {\n-      return readIntMb(b0);\n-    }\n-  }\n-\n-\n@@ -88,35 +81,7 @@\n-  \/\/ Internals only below this point\n-  \/\/\n-\n-\n-  \/\/ This encoding, called UNSIGNED5, is taken from J2SE Pack200.\n-  \/\/ It assumes that most values have lots of leading zeroes.\n-  \/\/ Very small values, in the range [0..191], code in one byte.\n-  \/\/ Any 32-bit value (including negatives) can be coded, in\n-  \/\/ up to five bytes.  The grammar is:\n-  \/\/    low_byte  = [0..191]\n-  \/\/    high_byte = [192..255]\n-  \/\/    any_byte  = low_byte | high_byte\n-  \/\/    coding = low_byte\n-  \/\/           | high_byte low_byte\n-  \/\/           | high_byte high_byte low_byte\n-  \/\/           | high_byte high_byte high_byte low_byte\n-  \/\/           | high_byte high_byte high_byte high_byte any_byte\n-  \/\/ Each high_byte contributes six bits of payload.\n-  \/\/ The encoding is one-to-one (except for integer overflow)\n-  \/\/ and easy to parse and unparse.\n-\n-  private int readIntMb(int b0) {\n-    int pos = position - 1;\n-    int sum = b0;\n-    \/\/ must collect more bytes: b[1]...b[4]\n-    int lg_H_i = lg_H;\n-    for (int i = 0; ;) {\n-      int b_i = read(pos + (++i));\n-      sum += b_i << lg_H_i; \/\/ sum += b[i]*(64**i)\n-      if (b_i < L || i == MAX_i) {\n-        setPosition(pos+i+1);\n-        return sum;\n-      }\n-      lg_H_i += lg_H;\n-    }\n+  public int readInt() {\n+    \/\/ UNSIGNED5::read_uint(_buffer, &_position, limit=0)\n+    return (int) Unsigned5.readUint(this, position,\n+                                    \/\/ bytes are fetched here:\n+                                    CompressedReadStream::read,\n+                                    \/\/ updated position comes through here:\n+                                    CompressedReadStream::setPosition);\n@@ -135,0 +100,18 @@\n+\n+\n+  \/**\n+   * Dumps the stream, making an assumption that all items are encoded\n+   * as UNSIGNED5.  The sizeLimit argument tells the dumper when to\n+   * stop trying to read bytes; if it is zero, the dumper goes as long\n+   * as it can until it encounters a null byte.\n+   *\n+   * This class mixes UNSIGNED5 with other formats.  Stray bytes are\n+   * decoded either as \"null\" (0x00), one less than the byte value\n+   * (0x01..0xBF) or as part of a spurious multi-byte encoding.\n+   * Proceed with caution.\n+   *\/\n+  public void dump() { dumpOn(System.out, 0); }\n+  public void dump(int sizeLimit) { dumpOn(System.out, sizeLimit); }\n+  public void dumpOn(PrintStream tty, int sizeLimit) {\n+      new Unsigned5(buffer, sizeLimit).dumpOn(tty, -1);\n+  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CompressedReadStream.java","additions":28,"deletions":45,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import sun.jvm.hotspot.utilities.*;\n@@ -57,6 +58,0 @@\n-  \/\/ Constants for UNSIGNED5 coding of Pack200\n-  public static final int lg_H = 6;\n-  public static final int H = 1<<lg_H;  \/\/ number of high codes (64)\n-  public static final int L = (1<<BitsPerByte) - H; \/\/ number of low codes (192)\n-  public static final int MAX_i = 4;      \/\/ bytes are numbered in (0..4)\n-\n@@ -71,2 +66,0 @@\n-  \/\/ 32-bit one-to-one sign encoding taken from Pack200\n-  \/\/ converts leading sign bits into leading zeros with trailing sign bit\n@@ -74,1 +67,1 @@\n-    return (value << 1) ^ (value >> 31);\n+    return Unsigned5.encodeSign(value);\n@@ -78,1 +71,1 @@\n-    return (value >>> 1) ^ -(value & 1);\n+    return Unsigned5.decodeSign(value);\n@@ -84,6 +77,1 @@\n-    \/\/ Hacker's Delight, Figure 7-1\n-    i = (i & 0x55555555) << 1 | (i >>> 1) & 0x55555555;\n-    i = (i & 0x33333333) << 3 | (i >>> 2) & 0x33333333;\n-    i = (i & 0x0f0f0f0f) << 4 | (i >>> 4) & 0x0f0f0f0f;\n-    i = (i << 24) | ((i & 0xff00) << 8) | ((i >>> 8) & 0xff00) | (i >>> 24);\n-    return i;\n+    return Integer.reverse(i);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CompressedStream.java","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,211 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.utilities;\n+\n+import java.io.PrintStream;\n+\n+import sun.jvm.hotspot.debugger.*;\n+\n+\/**\n+ * Decompression algorithm from utilities\/unsigned5.hpp.\n+ *\/\n+public class Unsigned5 {\n+  public static final int LogBitsPerByte = 3;\n+  public static final int BitsPerByte = 1 << 3;\n+\n+  \/\/ Constants for UNSIGNED5 coding of Pack200\n+  private static final int lg_H = 6;     \/\/ log-base-2 of H (lg 64 == 6)\n+  private static final int H = 1<<lg_H;  \/\/ number of \"high\" bytes (64)\n+  private static final int X = 1;  \/\/ there is one excluded byte ('\\0')\n+  private static final int MAX_b = (1<<BitsPerByte)-1;  \/\/ largest byte value\n+  private static final int L = (MAX_b+1)-X-H;  \/\/ number of \"low\" bytes (191)\n+  public static final int MAX_LENGTH = 5;  \/\/ lengths are in [1..5]\n+\n+  \/\/ Note:  Previous versions of HotSpot used X=0 (not 1) and L=192 (not 191)\n+  \/\/\n+  \/\/ Using this SA code on old versions of HotSpot, or older SA code\n+  \/\/ on newer versions of HotSpot, will decode compressed data\n+  \/\/ wrongly.  One might consider using vmStructs to communicate this\n+  \/\/ particular change between the SA and VM, but it is mostly futile.\n+  \/\/ There are a myriad of new changes in any version of HotSpot.  You\n+  \/\/ have to use the right SA and VM versions together.\n+\n+  public interface GetByte<ARR> {\n+      short getByte(ARR array, int position);\n+  }\n+  public interface SetPosition<ARR> {\n+      void setPosition(ARR array, int position);\n+  }\n+\n+  \/\/ UNSIGNED5::read_uint(_buffer, &_position, limit=0)\n+  \/\/ In C++ this is a generic algorithm, templated with \"holes\"\n+  \/\/ for array (ARR), offset (OFF), and fetch behavior (GET).\n+  \/\/ In addition, the position is updated by reference.\n+  \/\/ Let us mimic these conditions with two lambdas, both\n+  \/\/ on the ARR parameter.  We will hardwire the position\n+  \/\/ type (OFF) to int (sorry, not long), and omit the extra\n+  \/\/ limit feature.\n+  public static\n+  <ARR> long readUint(ARR base, int position,\n+                      GetByte<ARR> getByte,\n+                      SetPosition<ARR> setPosition) {\n+    int pos = position;\n+    int b_0 = getByte.getByte(base, pos);\n+    int sum = b_0 - X;\n+    \/\/ VM throws assert if b0<X; we just return -1 here instead\n+    if (sum < L) {  \/\/ common case\n+      setPosition.setPosition(base, pos+1);\n+      return Integer.toUnsignedLong(sum);\n+    }\n+    \/\/ must collect more bytes:  b[1]...b[4]\n+    int lg_H_i = lg_H;  \/\/ lg(H)*i == lg(H^^i)\n+    for (int i = 1; ; i++) {  \/\/ for i in [1..4]\n+      int b_i = getByte.getByte(base, pos + i);\n+      if (b_i < X) {  \/\/ avoid excluded bytes\n+        \/\/ VM throws assert here; should not happen\n+        setPosition.setPosition(base, pos+i);  \/\/ do not consume the bad byte\n+        return Integer.toUnsignedLong(sum);  \/\/ return whatever we have parsed so far\n+      }\n+      sum += (b_i - X) << lg_H_i;  \/\/ sum += (b[i]-X)*(64^^i)\n+      if (b_i < X+L || i == MAX_LENGTH-1) {\n+        setPosition.setPosition(base, pos+i+1);\n+        return Integer.toUnsignedLong(sum);\n+      }\n+      lg_H_i += lg_H;\n+    }\n+  }\n+\n+  \/\/ 32-bit one-to-one sign encoding taken from Pack200\n+  \/\/ converts leading sign bits into leading zeros with trailing sign bit\n+  \/\/ uint32_t encode_sign(int32_t value)\n+  public static int encodeSign(int value) {\n+    return (value << 1) ^ (value >> 31);\n+  }\n+\n+  \/\/ int32_t decode_sign(uint32_t value)\n+  public static int decodeSign(int value) {\n+    return (value >>> 1) ^ -(value & 1);\n+  }\n+\n+  \/\/--------------------------------------------------------------------------------\n+  \/\/ constructor and instance methods for convenience\n+\n+  \/\/ You can read and print a stream directly from memory if you like.\n+  \/\/ First wrap these up, then call read or print.\n+  private final Address base;\n+  private final int limit;\n+\n+  \/\/ There is no C++ instance of UNSIGNED5 but it seems useful to\n+  \/\/ allow this class to serve as a holder for an address and optional\n+  \/\/ limit, to point at a place where U5 encodings might be stored.\n+  \/\/ Compare with Unsigned5::Reader(ARR array, OFF limit = 0).\n+  public Unsigned5(Address base) {\n+    this(base, 0);  \/\/ limit=0 means unlimited (proceed with caution)\n+  }\n+  public Unsigned5(Address base, int limit) {\n+    this.base = base;\n+    this.limit = limit;\n+  }\n+\n+  public Address base() { return base; }\n+  public short getByte(int pos) {\n+    return (short) base.getCIntegerAt(pos, 1, true);\n+  }\n+\n+  \/\/ An UNSIGNED5::Reader gadget has a settable, auto-incremented\n+  \/\/ position field and can read through a stream of encoded values.\n+  \/\/ Java can model this as an inner class: var r = myU5.new Reader()\n+  \/\/ or var r = new Unsigned5(myaddr).new Reader()\n+  public class Reader {\n+    private int position = 0;  \/\/ this is for Unsigned5::Reader behavior\n+    public int position() { return position; }\n+    public void setPosition(int pos) { position = pos; }\n+    \/\/ UNSIGNED5::Reader::next_uint\n+    public long nextUint() {\n+        if (!hasNext())  return -1;\n+        return readUint(this, position, Reader::getByte, Reader::setPosition);\n+    }\n+    \/\/ UNSIGNED5::Reader::has_next\n+    public boolean hasNext() { return Unsigned5.this.hasNext(position); }\n+    \/\/ delegate reads to outer object:\n+    private short getByte(int pos) { return Unsigned5.this.getByte(pos); }\n+  }\n+\n+  \/\/ UNSIGNED5::read_uint (no position update)\n+  public long readUint(int pos) {\n+    if (!hasNext(pos))  return -1;\n+    return readUint(this, pos, Unsigned5::getByte, (a,i)->{});\n+  }\n+  private boolean hasNext(int pos) {\n+    \/\/ 1. there must be a non-excluded byte at the read position\n+    \/\/ 2. the position must be less than any non-zero limit\n+    return ((X == 0 || getByte(pos) >= X) &&\n+            (limit == 0 || pos < limit));\n+  }\n+\n+  \/\/ debug.cpp: u5decode(intptr_t addr)\n+  public void print() {\n+    printOn(System.out);\n+  }\n+  public void printOn(PrintStream tty) {\n+    tty.print(\"U5 \" + readUint(0) + \", \");\n+  }\n+\n+  \/\/ debug.cpp: u5p(intptr_t addr, intptr_t limit, int count)\n+  \/\/ check and decode a series of u5 values\n+  \/\/ return the address after the last decoded byte\n+  \/\/ if limit is non-zero stop before limit\n+  \/\/ if count is non-negative stop when count is reached\n+  \/\/ if count is negative stop on null (works kind of like strlen)\n+  public void dumpOn(PrintStream tty, int count) {\n+    Reader r = new Reader();\n+    int printed = 0;\n+    tty.print(\"U5: [\");\n+    for (;;) {\n+      if (count >= 0 && printed >= count)  break;\n+      if (!r.hasNext()) {\n+        if ((r.position < limit || limit == 0) && getByte(r.position) == 0) {\n+          tty.print(\" null\");\n+          ++r.position;  \/\/ skip null byte\n+          ++printed;\n+          if (limit != 0)  continue;  \/\/ keep going to explicit limit\n+        }\n+        break;\n+      }\n+      int value = (int) r.nextUint();\n+      tty.print(\" \");\n+      tty.print(value);\n+      ++printed;\n+    }\n+    tty.println(\" ] (values=\" + printed + \"\/length=\" + r.position + \")\");\n+  }\n+  public void dump(int count) {\n+    dumpOn(System.out, count);\n+  }\n+  public void dump() {\n+    \/\/ dump as many as possible, up to any nonzero limit\n+    dumpOn(System.out, -1);\n+  }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/Unsigned5.java","additions":211,"deletions":0,"binary":false,"changes":211,"status":"added"},{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/unsigned5.hpp\"\n+#include \"unittest.hpp\"\n+\n+TEST_VM(unsigned5, max_encoded_in_length) {\n+  int maxlen = UNSIGNED5::MAX_LENGTH;\n+  EXPECT_EQ(maxlen, 5);\n+  for (int i = 0; i <= 190; i++) {\n+    uint32_t interesting = i;\n+    EXPECT_EQ(UNSIGNED5::encoded_length(interesting), 1);\n+    EXPECT_EQ(UNSIGNED5::encoded_length(~interesting), maxlen);\n+  }\n+  for (int len = 1; len <= maxlen; len++) {\n+    uint32_t interesting = UNSIGNED5::max_encoded_in_length(len);\n+    EXPECT_EQ(UNSIGNED5::encoded_length(interesting-1), len);\n+    EXPECT_EQ(UNSIGNED5::encoded_length(interesting), len);\n+    if (len < 5) {\n+      EXPECT_EQ(UNSIGNED5::encoded_length(interesting+1), len+1);\n+      EXPECT_EQ(UNSIGNED5::encoded_length(interesting*2), len+1);\n+    }\n+    const int offset = -123;\n+    const int good_limit = offset + len;\n+    const int bad_limit  = good_limit - 1;\n+    EXPECT_TRUE(UNSIGNED5::fits_in_limit(interesting, offset, good_limit));\n+    EXPECT_TRUE(!UNSIGNED5::fits_in_limit(interesting, offset, bad_limit));\n+  }\n+}\n+\n+\/\/ Call FN on a nice list of \"interesting\" uint32_t values to encode\/decode.\n+\/\/ For each length in [1..5], the maximum encodable value of that\n+\/\/ length is \"interesting\", as are one more and one less than that\n+\/\/ value.  For each nybble (aligned 4-bit field) of a uint32_t, each\n+\/\/ possible value (in [0..15]) stored in that nybble is \"interesting\".\n+\/\/ Also \"interesting\" are some other values created by perturbing\n+\/\/ lower bits of that nybble-bearing number, by subtracting a power\n+\/\/ of -7 (up to -7^7).  That makes just over 1000 distinct numbers.\n+\/\/\n+\/\/ Calls to this function are repeatable, so you can call it to pack\n+\/\/ an output array, and then call it again to read an input array\n+\/\/ verifying that the retrieved values match the stored ones.\n+template<typename FN>\n+inline int enumerate_cases(FN fn) {\n+  \/\/ boundary values around the maximum encoded in each byte-length\n+  for (int len = 1; len <= 5; len++) {\n+    uint32_t interesting = UNSIGNED5::max_encoded_in_length(len);\n+    int res = fn(interesting-1);\n+    if (res)  return res;\n+    res = fn(interesting);\n+    if (res)  return res;\n+    if (interesting < (uint32_t)-1) {\n+      res = fn(interesting+1);\n+      if (res)  return res;\n+    }\n+  }\n+  \/\/ for each nybble, for each value in the nybble\n+  for (uint32_t npos = 0; npos < 32; npos += 4) {\n+    for (uint32_t nval = 0; nval <= 15; nval++) {\n+      uint32_t interesting = nval << npos;\n+      int res = fn(interesting);\n+      if (res)  return res;\n+      \/\/ mix in some crazy-looking values: powers of -7 to -7^7\n+      for (int pon7 = 1; pon7 < 1000000; pon7 *= -7) {\n+        uint32_t interesting2 = interesting - pon7;\n+        res = fn(interesting2);\n+        if (res)  return res;\n+      }\n+    }\n+  }\n+  return 0;\n+}\n+\n+TEST_VM(unsigned5, transcode_single) {\n+  const int limit = UNSIGNED5::MAX_LENGTH;\n+  u_char buffer[limit + 1];\n+  auto each_case = [&](uint32_t value) -> uint32_t {\n+    \/\/printf(\"case %08X len=%d\\n\", value, UNSIGNED5::encoded_length(value));\n+    int offset = 0;\n+    UNSIGNED5::write_uint(value, buffer, offset, limit);\n+    int length = offset;\n+    EXPECT_TRUE(length <= UNSIGNED5::MAX_LENGTH);\n+    EXPECT_EQ(length, UNSIGNED5::encoded_length(value)) << \"for value=\" << value;\n+    buffer[length] = 0;\n+    offset = 0;\n+    uint32_t check = UNSIGNED5::read_uint(buffer, offset, limit);\n+    EXPECT_EQ(offset, length) << \"for value=\" << value;\n+    EXPECT_EQ(value, check);\n+    return 0;\n+  };\n+  auto z = enumerate_cases(each_case);\n+  EXPECT_TRUE(!z);\n+}\n+\n+static int count_cases() {\n+  int case_count = 0;\n+  auto inc_case_count = [&](uint32_t){ ++case_count; return 0; };\n+  enumerate_cases(inc_case_count);\n+  return case_count;\n+}\n+\n+TEST_VM(unsigned5, transcode_multiple) {\n+  int case_count = count_cases();\n+  const int limit = 200;\n+  ASSERT_TRUE(limit < case_count*UNSIGNED5::MAX_LENGTH);\n+  u_char buffer[limit + 1];\n+  \/\/printf(\"%d cases total\\n\", case_count);  \/\/1166 cases total\n+  for (int sublimit = limit - 20; sublimit < limit; sublimit++) {\n+    int offset = 0;\n+    int count = 0;\n+    \/\/ write each number into an array\n+    auto write_case = [&](uint32_t value) -> uint32_t {\n+      if (!UNSIGNED5::fits_in_limit(value, offset, sublimit))\n+        return value|1;\n+      UNSIGNED5::write_uint(value, buffer, offset, sublimit);\n+      count++;\n+      return 0;\n+    };\n+    auto done = enumerate_cases(write_case);\n+    EXPECT_TRUE(done) << \"must have hit the sublimit\";\n+    EXPECT_TRUE(count < case_count);\n+    int length = offset;\n+    EXPECT_TRUE(length <= sublimit && length + UNSIGNED5::MAX_LENGTH > sublimit)\n+           << \"length=\" << length << \" sublimit=\" << sublimit;\n+    for (int i = length; i <= sublimit; i++) {\n+      buffer[i] = 0;\n+    }\n+    if (sublimit == limit-1) {\n+      UNSIGNED5::print_count(case_count + 1, &buffer[0], sublimit);\n+    }\n+    \/\/printf(\"encoded %d values in %d bytes: [[%s]]\\n\", count, length, buffer);\n+    \/\/ now read it all back\n+    offset = 0;\n+    int count2 = 0;\n+    auto read_back_case = [&](uint32_t value) -> uint32_t {\n+      int clen = UNSIGNED5::check_length(buffer, offset, sublimit);\n+      if (clen == 0)  return value|1;\n+      EXPECT_EQ(clen, UNSIGNED5::encoded_length(value));\n+      int begin = offset;\n+      uint32_t check = UNSIGNED5::read_uint(buffer, offset, sublimit);\n+      EXPECT_EQ(offset, begin + clen);\n+      EXPECT_EQ(value, check);\n+      count2++;\n+      return 0;\n+    };\n+    auto done2 = enumerate_cases(read_back_case);\n+    EXPECT_EQ(done, done2);\n+    EXPECT_EQ(count, count2);\n+    EXPECT_EQ(offset, length);\n+  }\n+}\n+\n+inline void init_ints(int len, int* ints) {\n+  for (int i = 0; i < len; i++) {\n+    ints[i] = (i * ((i&2) ? i : 1001)) ^ -(i & 1);\n+  }\n+}\n+\n+struct MyReaderHelper {\n+  uint8_t operator()(char* a, int i) const { return a[i]; }\n+};\n+using MyReader = UNSIGNED5::Reader<char*, int, MyReaderHelper>;\n+\n+TEST_VM(unsigned5, reader) {\n+  const int LEN = 100;\n+  int ints[LEN];\n+  init_ints(LEN, ints);\n+  int i;\n+  UNSIGNED5::Sizer<> szr;\n+  for (i = 0; i < LEN; i++) {\n+    szr.accept_uint(ints[i]);\n+  }\n+  \/\/printf(\"count=%d, size=%d\\n\", szr.count(), szr.position());\n+  char buf[LEN * UNSIGNED5::MAX_LENGTH + 1];\n+  int buflen;\n+  {\n+    int pos = 0;\n+    for (int i = 0; i < LEN; i++) {\n+      UNSIGNED5::write_uint(ints[i], buf, pos, 0);\n+    }\n+    EXPECT_TRUE(pos+1 < (int)sizeof(buf)) << pos;\n+    buflen = pos;\n+    buf[buflen] = 0;\n+  }\n+  EXPECT_EQ(szr.position(), buflen);\n+  MyReader r1(buf);\n+  i = 0;\n+  while (r1.has_next()) {\n+    int x = r1.next_uint();\n+    int y = ints[i++];\n+    ASSERT_EQ(x, y) << i;\n+  }\n+  ASSERT_EQ(i, LEN);\n+  MyReader r2(buf, buflen \/ 2);\n+  i = 0;\n+  while (r2.has_next()) {\n+    int x = r2.next_uint();\n+    int y = ints[i++];\n+    ASSERT_EQ(x, y) << i;\n+  }\n+  ASSERT_TRUE(i < LEN);\n+  \/\/ copy from reader to writer\n+  UNSIGNED5::Reader<char*,int> r3(buf);\n+  int array_limit = 1;\n+  char* array = new char[array_limit + 1];\n+  auto array_grow = [&](int){\n+    array[array_limit] = 0;\n+    auto oal = array_limit;\n+    array_limit += 10;\n+    \/\/printf(\"growing array from %d to %d\\n\", oal, array_limit);\n+    auto na = new char[array_limit + 1];\n+    strcpy(na, array);\n+    array = na;\n+  };\n+  UNSIGNED5::Writer<char*,int> w3(array, array_limit);\n+  while (r3.has_next()) {\n+    w3.accept_grow(r3.next_uint(), array_grow);\n+  }\n+  w3.end_byte();  \/\/ we always allocated one more than the limit!\n+  std::string buf_s(buf, buflen);\n+  std::string arr_s(array, strlen(array));\n+  ASSERT_EQ(buf_s, arr_s);\n+\n+  \/\/ try printing:\n+  {\n+    char stbuf[1000];\n+    stringStream st(stbuf, sizeof(stbuf)-1);\n+    UNSIGNED5::Reader<char*,int> printer(buf);\n+    printer.print_on(&st, 4, \"(\", \")\");\n+    std::string st_s(st.base(), st.size());\n+    char buf2[sizeof(stbuf)];\n+    sprintf(buf2, \"(%d %d %d %d)\", ints[0], ints[1], ints[2], ints[3]);\n+    std::string exp_s(buf2, strlen(buf2));\n+    ASSERT_EQ(exp_s, st_s);\n+  }\n+}\n+\n+\/\/ Here is some object code to look at if we want to do a manual\n+\/\/ study.  One could find the build file named test_unsigned5.o.cmdline\n+\/\/ and hand-edit the command line to produce assembly code in\n+\/\/ test_unsigned5.s.\n+\/\/\n+\/\/ Or, given the two empty \"fence functions\", one could do a\n+\/\/ quick scan like this:\n+\/\/\n+\/\/ $ objdump -D $(find build\/*release -name test_unsigned5.o) \\\n+\/\/   | sed -n \/start_code_quality\/,\/end_code_quality\/p \\\n+\/\/   | egrep -B10 bswap  # or grep -B20 cfi_endproc\n+\n+void start_code_quality_unsigned5() { }\n+\n+uint32_t code_quality_max_encoded_in_length(int i) {\n+  return UNSIGNED5::max_encoded_in_length(i);  \/\/ should compile like 5-switch\n+}\n+\n+int code_quality_encoded_length(uint32_t x) {\n+  return UNSIGNED5::encoded_length(x);  \/\/ should compile to 4-way comparison\n+}\n+\n+int code_quality_check_length(char* a) {\n+  return UNSIGNED5::check_length(a, 0);  \/\/ should compile with fast-path\n+}\n+\n+int code_quality_read_int(char* a) {\n+  int i = 0;\n+  return UNSIGNED5::read_uint(a, i, 0);  \/\/ should compile with fast-path\n+}\n+\n+int code_quality_int_reader(char* a) {\n+  MyReader r1(a);\n+  if (!r1.has_next())  return -1;\n+  return r1.next_uint();\n+}\n+\n+int code_quality_int_sizer(int* a, int n) {\n+  UNSIGNED5::Sizer<> s;\n+  for (int i = 0; i < n; i++)  s.accept_uint(a[i]);\n+  return s.position();\n+}\n+\n+void end_code_quality_unsigned5() { }\n","filename":"test\/hotspot\/gtest\/utilities\/test_unsigned5.cpp","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"}]}