{"files":[{"patch":"@@ -373,0 +373,3 @@\n+     * Additionally, the provided dynamic values must conform to some bound which is derived from the layout path, that is,\n+     * {@code 0 <= x_i <= b_i}, where {@code 0 <= i <= n}, or {@link IndexOutOfBoundsException} is thrown.\n+     *\n@@ -518,0 +521,1 @@\n+         * <p>\n@@ -528,0 +532,8 @@\n+         * <p>\n+         * Additionally, if {@code C} is the sequence element count, it follows that {@code 0 <= I < B},\n+         * where {@code B} is computed as follows:\n+         *\n+         * <ul>\n+         *    <li>if {@code F > 0}, then {@code B = ceilDiv(C - S, F)}<\/li>\n+         *    <li>if {@code F < 0}, then {@code B = ceilDiv(-(S + 1), -F)}<\/li>\n+         * <\/ul>\n@@ -547,0 +559,1 @@\n+         * <p>\n@@ -548,1 +561,11 @@\n-         * the number of free dimensions of the resulting path will be {@code 1 + n}.\n+         * the number of free dimensions of the resulting path will be {@code 1 + n}. If the free dimension associated\n+         * with this path is bound by an index {@code I}, the resulting accessed offset can be obtained with the following\n+         * formula:\n+         *\n+         * <blockquote><pre>{@code\n+         * E * I\n+         * }<\/pre><\/blockquote>\n+         *\n+         * where {@code E} is the size (in bytes) of the sequence element layout.\n+         * <p>\n+         * Additionally, if {@code C} is the sequence element count, it follows that {@code 0 <= I < C}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-     * MemoryLayout arrayLayout = MemoryLayout.sequenceLayout(-1,\n+     * SequenceLayout arrayLayout = MemoryLayout.sequenceLayout(-1,\n@@ -154,0 +154,16 @@\n+     * Additionally, the values of {@code x}, {@code y} and {@code z} are constrained as follows:\n+     * <ul>\n+     *     <li>{@code 0 <= x < arrayLayout.elementCount() }<\/li>\n+     *     <li>{@code 0 <= y < 10 }<\/li>\n+     *     <li>{@code 0 <= z < 20 }<\/li>\n+     * <\/ul>\n+     * <p>\n+     * Consider the following access expressions:\n+     * {@snippet lang=java :\n+     * int value1 = arrayHandle.get(10, 2, 4); \/\/ ok, accessed offset = 8176\n+     * int value2 = arrayHandle.get(0, 0, 30); \/\/ out of bounds value for z\n+     * }\n+     * In the first case, access is well-formed, as the values for {@code x}, {@code y} and {@code z} conform to\n+     * the bounds specified above. In the second case, access fails with {@link IndexOutOfBoundsException},\n+     * as the value for {@code z} is outside its specified bounds.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.vm.annotation.ForceInline;\n+\n@@ -37,0 +39,1 @@\n+import java.util.Objects;\n@@ -56,1 +59,1 @@\n-                    MethodType.methodType(long.class, long.class, long.class, long.class));\n+                    MethodType.methodType(long.class, long.class, long.class, long.class, long.class));\n@@ -69,1 +72,3 @@\n-    private LayoutPath(MemoryLayout layout, long offset, long[] strides, LayoutPath enclosing) {\n+    private final long[] bounds;\n+\n+    private LayoutPath(MemoryLayout layout, long offset, long[] strides, long[] bounds, LayoutPath enclosing) {\n@@ -73,0 +78,1 @@\n+        this.bounds = bounds;\n@@ -82,1 +88,1 @@\n-        return LayoutPath.nestedPath(elem, offset, addStride(elem.bitSize()), this);\n+        return LayoutPath.nestedPath(elem, offset, addStride(elem.bitSize()), addBound(seq.elementCount()), this);\n@@ -91,1 +97,6 @@\n-        return LayoutPath.nestedPath(elem, offset + (start * elemSize), addStride(elemSize * step), this);\n+        long nelems = step > 0 ?\n+                seq.elementCount() - start :\n+                start + 1;\n+        long maxIndex = Math.ceilDiv(nelems, Math.abs(step));\n+        return LayoutPath.nestedPath(elem, offset + (start * elemSize),\n+                                     addStride(elemSize * step), addBound(maxIndex), this);\n@@ -98,7 +109,3 @@\n-        long elemOffset = 0;\n-        if (index > 0) {\n-            \/\/if index == 0, we do not depend on sequence element size, so skip\n-            long elemSize = seq.elementLayout().bitSize();\n-            elemOffset = elemSize * index;\n-        }\n-        return LayoutPath.nestedPath(seq.elementLayout(), offset + elemOffset, strides, this);\n+        long elemSize = seq.elementLayout().bitSize();\n+        long elemOffset = elemSize * index;\n+        return LayoutPath.nestedPath(seq.elementLayout(), offset + elemOffset, strides, bounds, this);\n@@ -125,1 +132,1 @@\n-        return LayoutPath.nestedPath(elem, this.offset + offset, strides, this);\n+        return LayoutPath.nestedPath(elem, this.offset + offset, strides, bounds, this);\n@@ -143,1 +150,2 @@\n-                    Utils.bitsToBytesOrThrow(strides[i], IllegalArgumentException::new));\n+                    Utils.bitsToBytesOrThrow(strides[i], IllegalArgumentException::new),\n+                    bounds[i]);\n@@ -153,1 +161,3 @@\n-    private static long addScaledOffset(long base, long index, long stride) {\n+    @ForceInline\n+    private static long addScaledOffset(long base, long index, long stride, long bound) {\n+        Objects.checkIndex(index, bound);\n@@ -160,1 +170,1 @@\n-            MethodHandle collector = MethodHandles.insertArguments(MH_ADD_SCALED_OFFSET, 2, strides[i]);\n+            MethodHandle collector = MethodHandles.insertArguments(MH_ADD_SCALED_OFFSET, 2, strides[i], bounds[i]);\n@@ -192,1 +202,1 @@\n-        return new LayoutPath(layout, 0L, EMPTY_STRIDES, null);\n+        return new LayoutPath(layout, 0L, EMPTY_STRIDES, EMPTY_BOUNDS, null);\n@@ -195,2 +205,2 @@\n-    private static LayoutPath nestedPath(MemoryLayout layout, long offset, long[] strides, LayoutPath encl) {\n-        return new LayoutPath(layout, offset, strides, encl);\n+    private static LayoutPath nestedPath(MemoryLayout layout, long offset, long[] strides, long[] bounds, LayoutPath encl) {\n+        return new LayoutPath(layout, offset, strides, bounds, encl);\n@@ -244,0 +254,7 @@\n+    private long[] addBound(long maxIndex) {\n+        long[] newBounds = new long[bounds.length + 1];\n+        System.arraycopy(bounds, 0, newBounds, 0, bounds.length);\n+        newBounds[bounds.length] = maxIndex;\n+        return newBounds;\n+    }\n+\n@@ -245,0 +262,1 @@\n+    private static final long[] EMPTY_BOUNDS = new long[0];\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":36,"deletions":18,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -62,0 +62,9 @@\n+    @Test(dataProvider = \"slices\")\n+    public void testSliceBadIndex(VarHandle handle, int lo, int hi, int[] values) {\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(LAYOUT, session);\n+            assertThrows(() -> handle.get(segment, lo, 0));\n+            assertThrows(() -> handle.get(segment, 0, hi));\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestSlices.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}