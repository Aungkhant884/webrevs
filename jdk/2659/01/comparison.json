{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,9 +28,2 @@\n-import java.math.*;\n-import java.security.*;\n-import java.security.interfaces.*;\n-import java.security.spec.*;\n-import java.util.Optional;\n-\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n-\n+import sun.security.ec.point.AffinePoint;\n+import sun.security.ec.point.Point;\n@@ -39,1 +32,0 @@\n-import sun.security.util.ECUtil;\n@@ -41,2 +33,22 @@\n-import sun.security.util.math.*;\n-import sun.security.ec.point.*;\n+import sun.security.util.math.ImmutableIntegerModuloP;\n+import sun.security.util.math.IntegerFieldModuloP;\n+import sun.security.util.math.MutableIntegerModuloP;\n+import sun.security.util.math.SmallValue;\n+\n+import javax.crypto.KeyAgreementSpi;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.math.BigInteger;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.SecureRandom;\n+import java.security.interfaces.ECPrivateKey;\n+import java.security.interfaces.ECPublicKey;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.ECParameterSpec;\n+import java.security.spec.EllipticCurve;\n+import java.util.Optional;\n@@ -53,0 +65,1 @@\n+    ECOperations privateKeyOps;\n@@ -66,0 +79,19 @@\n+    \/\/ Generic init\n+    private void init(Key key) throws\n+        InvalidKeyException, InvalidAlgorithmParameterException {\n+        if (!(key instanceof PrivateKey)) {\n+            throw new InvalidKeyException(\"Key must be instance of PrivateKey\");\n+        }\n+        privateKey = (ECPrivateKey)ECKeyFactory.toECKey(key);\n+        publicKey = null;\n+        Optional<ECOperations> opsOpt =\n+            ECOperations.forParameters(privateKey.getParams());\n+        if (opsOpt.isEmpty()) {\n+            NamedCurve nc = CurveDB.lookup(privateKey.getParams());\n+            throw new InvalidAlgorithmParameterException(\n+                \"Curve not supported: \" + (nc != null ? nc.toString() :\n+                    \"unknown\"));\n+        }\n+        privateKeyOps = opsOpt.get();\n+    }\n+\n@@ -70,3 +102,4 @@\n-        if (!(key instanceof PrivateKey)) {\n-            throw new InvalidKeyException\n-                        (\"Key must be instance of PrivateKey\");\n+        try {\n+            init(key);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new InvalidKeyException(e);\n@@ -74,2 +107,0 @@\n-        privateKey = (ECPrivateKey) ECKeyFactory.toECKey(key);\n-        publicKey = null;\n@@ -87,1 +118,1 @@\n-        engineInit(key, random);\n+        init(key);\n@@ -111,2 +142,2 @@\n-        ECParameterSpec params = publicKey.getParams();\n-        int keyLenBits = params.getCurve().getField().getFieldSize();\n+        int keyLenBits =\n+            publicKey.getParams().getCurve().getField().getFieldSize();\n@@ -115,0 +146,3 @@\n+        \/\/ Validate public key\n+        validate(privateKeyOps, publicKey);\n+\n@@ -118,1 +152,2 @@\n-    private static void validateCoordinate(BigInteger c, BigInteger mod) {\n+    private static void validateCoordinate(BigInteger c, BigInteger mod)\n+        throws InvalidKeyException{\n@@ -120,1 +155,1 @@\n-            throw new ProviderException(\"invalid coordinate\");\n+            throw new InvalidKeyException(\"Invalid coordinate\");\n@@ -124,1 +159,1 @@\n-            throw new ProviderException(\"invalid coordinate\");\n+            throw new InvalidKeyException(\"Invalid coordinate\");\n@@ -129,2 +164,1 @@\n-     * Check whether a public key is valid. Throw ProviderException\n-     * if it is not valid or could not be validated.\n+     * Check whether a public key is valid.\n@@ -132,1 +166,4 @@\n-    private static void validate(ECOperations ops, ECPublicKey key) {\n+    private static void validate(ECOperations ops, ECPublicKey key)\n+        throws InvalidKeyException {\n+\n+        ECParameterSpec spec = key.getParams();\n@@ -143,1 +180,1 @@\n-        EllipticCurve curve = key.getParams().getCurve();\n+        EllipticCurve curve = spec.getCurve();\n@@ -148,1 +185,1 @@\n-            throw new ProviderException(\"point is not on curve\");\n+            throw new InvalidKeyException(\"Point is not on curve\");\n@@ -155,1 +192,1 @@\n-        byte[] order = key.getParams().getOrder().toByteArray();\n+        byte[] order = spec.getOrder().toByteArray();\n@@ -159,1 +196,1 @@\n-            throw new ProviderException(\"point has incorrect order\");\n+            throw new InvalidKeyException(\"Point has incorrect order\");\n@@ -170,0 +207,1 @@\n+\n@@ -171,6 +209,4 @@\n-        Optional<byte[]> resultOpt = deriveKeyImpl(privateKey, publicKey);\n-        if (resultOpt.isEmpty()) {\n-            NamedCurve nc = CurveDB.lookup(publicKey.getParams());\n-            throw new IllegalStateException(\n-                new InvalidAlgorithmParameterException(\"Curve not supported: \" +\n-                    (nc != null ? nc.toString() : \"unknown\")));\n+        try {\n+            result = deriveKeyImpl(privateKey, privateKeyOps, publicKey);\n+        } catch (Exception e) {\n+            throw new IllegalStateException(e);\n@@ -178,1 +214,0 @@\n-        result = resultOpt.get();\n@@ -213,18 +248,2 @@\n-    Optional<byte[]> deriveKeyImpl(ECPrivateKey priv, ECPublicKey pubKey) {\n-\n-        ECParameterSpec ecSpec = priv.getParams();\n-        EllipticCurve curve = ecSpec.getCurve();\n-        Optional<ECOperations> opsOpt = ECOperations.forParameters(ecSpec);\n-        if (opsOpt.isEmpty()) {\n-            return Optional.empty();\n-        }\n-        ECOperations ops = opsOpt.get();\n-        if (! (priv instanceof ECPrivateKeyImpl)) {\n-            return Optional.empty();\n-        }\n-        ECPrivateKeyImpl privImpl = (ECPrivateKeyImpl) priv;\n-        byte[] sArr = privImpl.getArrayS();\n-\n-        \/\/ to match the native implementation, validate the public key here\n-        \/\/ and throw ProviderException if it is invalid\n-        validate(ops, pubKey);\n+    byte[] deriveKeyImpl(ECPrivateKey priv, ECOperations ops,\n+        ECPublicKey pubKey) throws InvalidKeyException {\n@@ -234,1 +253,1 @@\n-        MutableIntegerModuloP scalar = field.getElement(sArr).mutable();\n+        MutableIntegerModuloP scalar = field.getElement(priv.getS()).mutable();\n@@ -238,3 +257,2 @@\n-        int keySize = (curve.getField().getFieldSize() + 7) \/ 8;\n-        byte[] privArr = scalar.asByteArray(keySize);\n-\n+        int keySize =\n+            (priv.getParams().getCurve().getField().getFieldSize() + 7) \/ 8;\n@@ -245,2 +263,2 @@\n-        AffinePoint affPub = new AffinePoint(x, y);\n-        Point product = ops.multiply(affPub, privArr);\n+        Point product = ops.multiply(new AffinePoint(x, y),\n+            scalar.asByteArray(keySize));\n@@ -248,1 +266,1 @@\n-            throw new ProviderException(\"Product is zero\");\n+            throw new InvalidKeyException(\"Product is zero\");\n@@ -250,1 +268,0 @@\n-        AffinePoint affProduct = product.asAffine();\n@@ -252,1 +269,1 @@\n-        byte[] result = affProduct.getX().asByteArray(keySize);\n+        byte[] result = product.asAffine().getX().asByteArray(keySize);\n@@ -255,1 +272,1 @@\n-        return Optional.of(result);\n+        return result;\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECDHKeyAgreement.java","additions":83,"deletions":66,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8238911\n+ * @summary Check that ECPrivateKey's that are not ECPrivateKeyImpl can use\n+ * ECDHKeyAgreement\n+ *\/\n+\n+import javax.crypto.KeyAgreement;\n+import java.math.BigInteger;\n+import java.security.KeyPairGenerator;\n+import java.security.interfaces.ECPrivateKey;\n+import java.security.interfaces.ECPublicKey;\n+import java.security.spec.ECGenParameterSpec;\n+import java.security.spec.ECParameterSpec;\n+\n+public class ECKeyCheck {\n+\n+    public static final void main(String args[]) throws Exception {\n+        ECGenParameterSpec spec = new ECGenParameterSpec(\"secp256r1\");\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"EC\");\n+        kpg.initialize(spec);\n+\n+        ECPrivateKey privKey = (ECPrivateKey) kpg.generateKeyPair().getPrivate();\n+        ECPublicKey pubKey = (ECPublicKey) kpg.generateKeyPair().getPublic();\n+        generateECDHSecret(privKey, pubKey);\n+        generateECDHSecret(new newPrivateKeyImpl(privKey), pubKey);\n+    }\n+\n+    private static byte[] generateECDHSecret(ECPrivateKey privKey,\n+        ECPublicKey pubKey) throws Exception {\n+        KeyAgreement ka = KeyAgreement.getInstance(\"ECDH\");\n+        ka.init(privKey);\n+        ka.doPhase(pubKey, true);\n+        return ka.generateSecret();\n+    }\n+\n+    \/\/ Test ECPrivateKey class\n+    private static class newPrivateKeyImpl implements ECPrivateKey {\n+        private ECPrivateKey p;\n+\n+        newPrivateKeyImpl(ECPrivateKey p) {\n+            this.p = p;\n+        }\n+\n+        public BigInteger getS() {\n+            return p.getS();\n+        }\n+\n+        public byte[] getEncoded() {\n+            return p.getEncoded();\n+        }\n+\n+        public String getFormat() {\n+            return p.getFormat();\n+        }\n+\n+        public String getAlgorithm() {\n+            return p.getAlgorithm();\n+        }\n+\n+        public ECParameterSpec getParams() {\n+            return p.getParams();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KeyAgreement\/ECKeyCheck.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"}]}