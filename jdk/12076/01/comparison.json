{"files":[{"patch":"@@ -1,120 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.io;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-\n-\/**\n- * Utility methods for packing\/unpacking primitive values in\/out of byte arrays\n- * using big-endian byte ordering (i.e. \"Network Order\").\n- *\/\n-final class Bits {\n-    private Bits() {}\n-\n-    private static final VarHandle SHORT = create(short[].class);\n-    private static final VarHandle INT = create(int[].class);\n-    private static final VarHandle LONG = create(long[].class);\n-\n-    \/*\n-     * Methods for unpacking primitive values from byte arrays starting at\n-     * given offsets.\n-     *\/\n-\n-    static boolean getBoolean(byte[] b, int off) {\n-        return b[off] != 0;\n-    }\n-\n-    static char getChar(byte[] b, int off) {\n-        return (char) (short) SHORT.get(b, off);\n-    }\n-\n-    static short getShort(byte[] b, int off) {\n-        return (short) SHORT.get(b, off);\n-    }\n-\n-    static int getInt(byte[] b, int off) {\n-        return (int) INT.get(b, off);\n-    }\n-\n-    static float getFloat(byte[] b, int off) {\n-        \/\/ Using Float.intBitsToFloat collapses NaN values to a single\n-        \/\/ \"canonical\" NaN value\n-        return Float.intBitsToFloat((int) INT.get(b, off));\n-    }\n-\n-    static long getLong(byte[] b, int off) {\n-        return (long) LONG.get(b, off);\n-    }\n-\n-    static double getDouble(byte[] b, int off) {\n-        \/\/ Using Double.longBitsToDouble collapses NaN values to a single\n-        \/\/ \"canonical\" NaN value\n-        return Double.longBitsToDouble((long) LONG.get(b, off));\n-    }\n-\n-    \/*\n-     * Methods for packing primitive values into byte arrays starting at given\n-     * offsets.\n-     *\/\n-\n-    static void putBoolean(byte[] b, int off, boolean val) {\n-        b[off] = (byte) (val ? 1 : 0);\n-    }\n-\n-    static void putChar(byte[] b, int off, char val) {\n-        SHORT.set(b, off, (short) val);\n-    }\n-\n-    static void putShort(byte[] b, int off, short val) {\n-        SHORT.set(b, off, val);\n-    }\n-\n-    static void putInt(byte[] b, int off, int val) {\n-        INT.set(b, off, val);\n-    }\n-\n-    static void putFloat(byte[] b, int off, float val) {\n-        \/\/ Using Float.floatToIntBits collapses NaN values to a single\n-        \/\/ \"canonical\" NaN value\n-        INT.set(b, off, Float.floatToIntBits(val));\n-    }\n-\n-    static void putLong(byte[] b, int off, long val) {\n-        LONG.set(b, off, val);\n-    }\n-\n-    static void putDouble(byte[] b, int off, double val) {\n-        \/\/ Using Double.doubleToLongBits collapses NaN values to a single\n-        \/\/ \"canonical\" NaN value\n-        LONG.set(b, off, Double.doubleToLongBits(val));\n-    }\n-\n-    private static VarHandle create(Class<?> viewArrayClass) {\n-        return MethodHandles.byteArrayViewVarHandle(viewArrayClass, ByteOrder.BIG_ENDIAN);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/io\/Bits.java","additions":0,"deletions":120,"binary":false,"changes":120,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.util.access.ByteArrayAccess;\n+\n@@ -57,0 +59,2 @@\n+    private final byte[] readBuffer = new byte[8];\n+\n@@ -312,1 +316,2 @@\n-        return (short) readUnsignedShort();\n+        readFully(readBuffer, 0, 2);\n+        return ByteArrayAccess.getShort(readBuffer);\n@@ -333,6 +338,2 @@\n-        InputStream in = this.in;\n-        int ch1 = in.read();\n-        int ch2 = in.read();\n-        if ((ch1 | ch2) < 0)\n-            throw new EOFException();\n-        return (ch1 << 8) + (ch2 << 0);\n+        readFully(readBuffer, 0, 2);\n+        return ByteArrayAccess.getUnsignedShort(readBuffer);\n@@ -359,1 +360,2 @@\n-        return (char) readUnsignedShort();\n+        readFully(readBuffer, 0, 2);\n+        return ByteArrayAccess.getChar(readBuffer);\n@@ -380,8 +382,2 @@\n-        InputStream in = this.in;\n-        int ch1 = in.read();\n-        int ch2 = in.read();\n-        int ch3 = in.read();\n-        int ch4 = in.read();\n-        if ((ch1 | ch2 | ch3 | ch4) < 0)\n-            throw new EOFException();\n-        return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));\n+        readFully(readBuffer, 0, 4);\n+        return ByteArrayAccess.getInt(readBuffer);\n@@ -390,2 +386,0 @@\n-    private final byte[] readBuffer = new byte[8];\n-\n@@ -411,8 +405,1 @@\n-        return (((long)readBuffer[0] << 56) +\n-                ((long)(readBuffer[1] & 255) << 48) +\n-                ((long)(readBuffer[2] & 255) << 40) +\n-                ((long)(readBuffer[3] & 255) << 32) +\n-                ((long)(readBuffer[4] & 255) << 24) +\n-                ((readBuffer[5] & 255) << 16) +\n-                ((readBuffer[6] & 255) <<  8) +\n-                ((readBuffer[7] & 255) <<  0));\n+        return ByteArrayAccess.getLong(readBuffer);\n@@ -440,1 +427,2 @@\n-        return Float.intBitsToFloat(readInt());\n+        readFully(readBuffer, 0, 4);\n+        return ByteArrayAccess.getFloat(readBuffer);\n@@ -462,1 +450,2 @@\n-        return Double.longBitsToDouble(readLong());\n+        readFully(readBuffer, 0, 8);\n+        return ByteArrayAccess.getDouble(readBuffer);\n","filename":"src\/java.base\/share\/classes\/java\/io\/DataInputStream.java","additions":18,"deletions":29,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.util.access.ByteArrayAccess;\n+\n@@ -173,2 +175,1 @@\n-        writeBuffer[0] = (byte)(v >>> 8);\n-        writeBuffer[1] = (byte)(v >>> 0);\n+        ByteArrayAccess.setUnsignedShort(writeBuffer, v);\n@@ -189,2 +190,1 @@\n-        writeBuffer[0] = (byte)(v >>> 8);\n-        writeBuffer[1] = (byte)(v >>> 0);\n+        ByteArrayAccess.setUnsignedShort(writeBuffer, v);\n@@ -205,4 +205,1 @@\n-        writeBuffer[0] = (byte)(v >>> 24);\n-        writeBuffer[1] = (byte)(v >>> 16);\n-        writeBuffer[2] = (byte)(v >>>  8);\n-        writeBuffer[3] = (byte)(v >>>  0);\n+        ByteArrayAccess.setInt(writeBuffer, v);\n@@ -223,8 +220,1 @@\n-        writeBuffer[0] = (byte)(v >>> 56);\n-        writeBuffer[1] = (byte)(v >>> 48);\n-        writeBuffer[2] = (byte)(v >>> 40);\n-        writeBuffer[3] = (byte)(v >>> 32);\n-        writeBuffer[4] = (byte)(v >>> 24);\n-        writeBuffer[5] = (byte)(v >>> 16);\n-        writeBuffer[6] = (byte)(v >>>  8);\n-        writeBuffer[7] = (byte)(v >>>  0);\n+        ByteArrayAccess.setLong(writeBuffer, v);\n@@ -249,1 +239,3 @@\n-        writeInt(Float.floatToIntBits(v));\n+        ByteArrayAccess.setFloat(writeBuffer, v);\n+        out.write(writeBuffer, 0, 4);\n+        incCount(4);\n@@ -266,1 +258,3 @@\n-        writeLong(Double.doubleToLongBits(v));\n+        ByteArrayAccess.setDouble(writeBuffer, v);\n+        out.write(writeBuffer, 0, 8);\n+        incCount(8);\n@@ -304,2 +298,1 @@\n-            writeBuffer[0] = (byte)(v >>> 8);\n-            writeBuffer[1] = (byte)(v >>> 0);\n+            ByteArrayAccess.setUnsignedShort(writeBuffer, v);\n@@ -382,3 +375,2 @@\n-        bytearr[count++] = (byte) ((utflen >>> 8) & 0xFF);\n-        bytearr[count++] = (byte) ((utflen >>> 0) & 0xFF);\n-\n+        ByteArrayAccess.setUnsignedShort(bytearr, count, utflen);\n+        count += 2;\n","filename":"src\/java.base\/share\/classes\/java\/io\/DataOutputStream.java","additions":16,"deletions":24,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+import jdk.internal.util.access.ByteArrayAccess;\n@@ -2634,1 +2635,1 @@\n-            return (off >= 0) ? Bits.getBoolean(primValues, off) : val;\n+            return (off >= 0) ? ByteArrayAccess.getBoolean(primValues, off) : val;\n@@ -2644,1 +2645,1 @@\n-            return (off >= 0) ? Bits.getChar(primValues, off) : val;\n+            return (off >= 0) ? ByteArrayAccess.getChar(primValues, off) : val;\n@@ -2649,1 +2650,1 @@\n-            return (off >= 0) ? Bits.getShort(primValues, off) : val;\n+            return (off >= 0) ? ByteArrayAccess.getShort(primValues, off) : val;\n@@ -2654,1 +2655,1 @@\n-            return (off >= 0) ? Bits.getInt(primValues, off) : val;\n+            return (off >= 0) ? ByteArrayAccess.getInt(primValues, off) : val;\n@@ -2659,1 +2660,1 @@\n-            return (off >= 0) ? Bits.getFloat(primValues, off) : val;\n+            return (off >= 0) ? ByteArrayAccess.getFloat(primValues, off) : val;\n@@ -2664,1 +2665,1 @@\n-            return (off >= 0) ? Bits.getLong(primValues, off) : val;\n+            return (off >= 0) ? ByteArrayAccess.getLong(primValues, off) : val;\n@@ -2669,1 +2670,1 @@\n-            return (off >= 0) ? Bits.getDouble(primValues, off) : val;\n+            return (off >= 0) ? ByteArrayAccess.getDouble(primValues, off) : val;\n@@ -3117,1 +3118,1 @@\n-                            int len = Bits.getInt(hbuf, 1);\n+                            int len = ByteArrayAccess.getInt(hbuf, 1);\n@@ -3416,1 +3417,1 @@\n-            char v = Bits.getChar(buf, pos);\n+            char v = ByteArrayAccess.getChar(buf, pos);\n@@ -3428,1 +3429,1 @@\n-            short v = Bits.getShort(buf, pos);\n+            short v = ByteArrayAccess.getShort(buf, pos);\n@@ -3440,1 +3441,1 @@\n-            int v = Bits.getShort(buf, pos) & 0xFFFF;\n+            int v = ByteArrayAccess.getShort(buf, pos) & 0xFFFF;\n@@ -3452,1 +3453,1 @@\n-            int v = Bits.getInt(buf, pos);\n+            int v = ByteArrayAccess.getInt(buf, pos);\n@@ -3464,1 +3465,1 @@\n-            float v = Bits.getFloat(buf, pos);\n+            float v = ByteArrayAccess.getFloat(buf, pos);\n@@ -3476,1 +3477,1 @@\n-            long v = Bits.getLong(buf, pos);\n+            long v = ByteArrayAccess.getLong(buf, pos);\n@@ -3488,1 +3489,1 @@\n-            double v = Bits.getDouble(buf, pos);\n+            double v = ByteArrayAccess.getDouble(buf, pos);\n@@ -3526,1 +3527,1 @@\n-                    v[off++] = Bits.getBoolean(buf, pos++);\n+                    v[off++] = ByteArrayAccess.getBoolean(buf, pos++);\n@@ -3547,1 +3548,1 @@\n-                    v[off++] = Bits.getChar(buf, pos);\n+                    v[off++] = ByteArrayAccess.getChar(buf, pos);\n@@ -3569,1 +3570,1 @@\n-                    v[off++] = Bits.getShort(buf, pos);\n+                    v[off++] = ByteArrayAccess.getShort(buf, pos);\n@@ -3591,1 +3592,1 @@\n-                    v[off++] = Bits.getInt(buf, pos);\n+                    v[off++] = ByteArrayAccess.getInt(buf, pos);\n@@ -3613,1 +3614,1 @@\n-                    v[off++] = Bits.getFloat(buf, pos);\n+                    v[off++] = ByteArrayAccess.getFloat(buf, pos);\n@@ -3635,1 +3636,1 @@\n-                    v[off++] = Bits.getLong(buf, pos);\n+                    v[off++] = ByteArrayAccess.getLong(buf, pos);\n@@ -3657,1 +3658,1 @@\n-                    v[off++] = Bits.getDouble(buf, pos);\n+                    v[off++] = ByteArrayAccess.getDouble(buf, pos);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+\n+import jdk.internal.util.access.ByteArrayAccess;\n@@ -1641,1 +1643,1 @@\n-            Bits.putBoolean(primVals, getFieldOffset(name, Boolean.TYPE), val);\n+            ByteArrayAccess.setBoolean(primVals, getFieldOffset(name, Boolean.TYPE), val);\n@@ -1649,1 +1651,1 @@\n-            Bits.putChar(primVals, getFieldOffset(name, Character.TYPE), val);\n+            ByteArrayAccess.setChar(primVals, getFieldOffset(name, Character.TYPE), val);\n@@ -1653,1 +1655,1 @@\n-            Bits.putShort(primVals, getFieldOffset(name, Short.TYPE), val);\n+            ByteArrayAccess.setShort(primVals, getFieldOffset(name, Short.TYPE), val);\n@@ -1657,1 +1659,1 @@\n-            Bits.putInt(primVals, getFieldOffset(name, Integer.TYPE), val);\n+            ByteArrayAccess.setInt(primVals, getFieldOffset(name, Integer.TYPE), val);\n@@ -1661,1 +1663,1 @@\n-            Bits.putFloat(primVals, getFieldOffset(name, Float.TYPE), val);\n+            ByteArrayAccess.setFloat(primVals, getFieldOffset(name, Float.TYPE), val);\n@@ -1665,1 +1667,1 @@\n-            Bits.putLong(primVals, getFieldOffset(name, Long.TYPE), val);\n+            ByteArrayAccess.setLong(primVals, getFieldOffset(name, Long.TYPE), val);\n@@ -1669,1 +1671,1 @@\n-            Bits.putDouble(primVals, getFieldOffset(name, Double.TYPE), val);\n+            ByteArrayAccess.setDouble(primVals, getFieldOffset(name, Double.TYPE), val);\n@@ -1911,1 +1913,1 @@\n-                Bits.putInt(hbuf, 1, len);\n+                ByteArrayAccess.setInt(hbuf, 1, len);\n@@ -1928,1 +1930,1 @@\n-            Bits.putBoolean(buf, pos++, v);\n+            ByteArrayAccess.setBoolean(buf, pos++, v);\n@@ -1940,1 +1942,1 @@\n-                Bits.putChar(buf, pos, (char) v);\n+                ByteArrayAccess.setChar(buf, pos, (char) v);\n@@ -1949,1 +1951,1 @@\n-                Bits.putShort(buf, pos, (short) v);\n+                ByteArrayAccess.setShort(buf, pos, (short) v);\n@@ -1958,1 +1960,1 @@\n-                Bits.putInt(buf, pos, v);\n+                ByteArrayAccess.setInt(buf, pos, v);\n@@ -1967,1 +1969,1 @@\n-                Bits.putFloat(buf, pos, v);\n+                ByteArrayAccess.setFloat(buf, pos, v);\n@@ -1976,1 +1978,1 @@\n-                Bits.putLong(buf, pos, v);\n+                ByteArrayAccess.setLong(buf, pos, v);\n@@ -1985,1 +1987,1 @@\n-                Bits.putDouble(buf, pos, v);\n+                ByteArrayAccess.setDouble(buf, pos, v);\n@@ -2045,1 +2047,1 @@\n-                    Bits.putBoolean(buf, pos++, v[off++]);\n+                    ByteArrayAccess.setBoolean(buf, pos++, v[off++]);\n@@ -2058,1 +2060,1 @@\n-                        Bits.putChar(buf, pos, v[off++]);\n+                        ByteArrayAccess.setChar(buf, pos, v[off++]);\n@@ -2075,1 +2077,1 @@\n-                        Bits.putShort(buf, pos, v[off++]);\n+                        ByteArrayAccess.setShort(buf, pos, v[off++]);\n@@ -2092,1 +2094,1 @@\n-                        Bits.putInt(buf, pos, v[off++]);\n+                        ByteArrayAccess.setInt(buf, pos, v[off++]);\n@@ -2109,1 +2111,1 @@\n-                        Bits.putFloat(buf, pos, v[off++]);\n+                        ByteArrayAccess.setFloat(buf, pos, v[off++]);\n@@ -2126,1 +2128,1 @@\n-                        Bits.putLong(buf, pos, v[off++]);\n+                        ByteArrayAccess.setLong(buf, pos, v[off++]);\n@@ -2143,1 +2145,1 @@\n-                        Bits.putDouble(buf, pos, v[off++]);\n+                        ByteArrayAccess.setDouble(buf, pos, v[off++]);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":25,"deletions":23,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,1 @@\n+import jdk.internal.util.access.ByteArrayAccess;\n@@ -1989,1 +1990,1 @@\n-                    case 'Z' -> Bits.putBoolean(buf, off, unsafe.getBoolean(obj, key));\n+                    case 'Z' -> ByteArrayAccess.setBoolean(buf, off, unsafe.getBoolean(obj, key));\n@@ -1991,6 +1992,6 @@\n-                    case 'C' -> Bits.putChar(buf, off, unsafe.getChar(obj, key));\n-                    case 'S' -> Bits.putShort(buf, off, unsafe.getShort(obj, key));\n-                    case 'I' -> Bits.putInt(buf, off, unsafe.getInt(obj, key));\n-                    case 'F' -> Bits.putFloat(buf, off, unsafe.getFloat(obj, key));\n-                    case 'J' -> Bits.putLong(buf, off, unsafe.getLong(obj, key));\n-                    case 'D' -> Bits.putDouble(buf, off, unsafe.getDouble(obj, key));\n+                    case 'C' -> ByteArrayAccess.setChar(buf, off, unsafe.getChar(obj, key));\n+                    case 'S' -> ByteArrayAccess.setShort(buf, off, unsafe.getShort(obj, key));\n+                    case 'I' -> ByteArrayAccess.setInt(buf, off, unsafe.getInt(obj, key));\n+                    case 'F' -> ByteArrayAccess.setFloat(buf, off, unsafe.getFloat(obj, key));\n+                    case 'J' -> ByteArrayAccess.setLong(buf, off, unsafe.getLong(obj, key));\n+                    case 'D' -> ByteArrayAccess.setDouble(buf, off, unsafe.getDouble(obj, key));\n@@ -2018,1 +2019,1 @@\n-                    case 'Z' -> unsafe.putBoolean(obj, key, Bits.getBoolean(buf, off));\n+                    case 'Z' -> unsafe.putBoolean(obj, key, ByteArrayAccess.getBoolean(buf, off));\n@@ -2020,6 +2021,6 @@\n-                    case 'C' -> unsafe.putChar(obj, key, Bits.getChar(buf, off));\n-                    case 'S' -> unsafe.putShort(obj, key, Bits.getShort(buf, off));\n-                    case 'I' -> unsafe.putInt(obj, key, Bits.getInt(buf, off));\n-                    case 'F' -> unsafe.putFloat(obj, key, Bits.getFloat(buf, off));\n-                    case 'J' -> unsafe.putLong(obj, key, Bits.getLong(buf, off));\n-                    case 'D' -> unsafe.putDouble(obj, key, Bits.getDouble(buf, off));\n+                    case 'C' -> unsafe.putChar(obj, key, ByteArrayAccess.getChar(buf, off));\n+                    case 'S' -> unsafe.putShort(obj, key, ByteArrayAccess.getShort(buf, off));\n+                    case 'I' -> unsafe.putInt(obj, key, ByteArrayAccess.getInt(buf, off));\n+                    case 'F' -> unsafe.putFloat(obj, key, ByteArrayAccess.getFloat(buf, off));\n+                    case 'J' -> unsafe.putLong(obj, key, ByteArrayAccess.getLong(buf, off));\n+                    case 'D' -> unsafe.putDouble(obj, key, ByteArrayAccess.getDouble(buf, off));\n@@ -2476,7 +2477,7 @@\n-                    short.class, lkp.findStatic(Bits.class, \"getShort\", MethodType.methodType(short.class, byte[].class, int.class)),\n-                    int.class, lkp.findStatic(Bits.class, \"getInt\", MethodType.methodType(int.class, byte[].class, int.class)),\n-                    long.class, lkp.findStatic(Bits.class, \"getLong\", MethodType.methodType(long.class, byte[].class, int.class)),\n-                    float.class, lkp.findStatic(Bits.class, \"getFloat\", MethodType.methodType(float.class, byte[].class, int.class)),\n-                    double.class, lkp.findStatic(Bits.class, \"getDouble\", MethodType.methodType(double.class, byte[].class, int.class)),\n-                    char.class, lkp.findStatic(Bits.class, \"getChar\", MethodType.methodType(char.class, byte[].class, int.class)),\n-                    boolean.class, lkp.findStatic(Bits.class, \"getBoolean\", MethodType.methodType(boolean.class, byte[].class, int.class))\n+                    short.class, lkp.findStatic(ByteArrayAccess.class, \"getShort\", MethodType.methodType(short.class, byte[].class, int.class)),\n+                    int.class, lkp.findStatic(ByteArrayAccess.class, \"getInt\", MethodType.methodType(int.class, byte[].class, int.class)),\n+                    long.class, lkp.findStatic(ByteArrayAccess.class, \"getLong\", MethodType.methodType(long.class, byte[].class, int.class)),\n+                    float.class, lkp.findStatic(ByteArrayAccess.class, \"getFloat\", MethodType.methodType(float.class, byte[].class, int.class)),\n+                    double.class, lkp.findStatic(ByteArrayAccess.class, \"getDouble\", MethodType.methodType(double.class, byte[].class, int.class)),\n+                    char.class, lkp.findStatic(ByteArrayAccess.class, \"getChar\", MethodType.methodType(char.class, byte[].class, int.class)),\n+                    boolean.class, lkp.findStatic(ByteArrayAccess.class, \"getBoolean\", MethodType.methodType(boolean.class, byte[].class, int.class))\n@@ -2485,1 +2486,1 @@\n-                throw new InternalError(\"Can't lookup Bits.getXXX\", e);\n+                throw new InternalError(\"Can't lookup ByteArrayAccess.getXXX\", e);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import jdk.internal.util.access.ByteArrayAccess;\n@@ -887,1 +888,1 @@\n-        return Bits.getInt(buffer, 0);\n+        return ByteArrayAccess.getInt(buffer);\n@@ -920,1 +921,1 @@\n-        return Bits.getLong(buffer, 0);\n+        return ByteArrayAccess.getLong(buffer);\n@@ -944,1 +945,1 @@\n-        return Bits.getFloat(buffer, 0);\n+        return ByteArrayAccess.getFloat(buffer);\n@@ -968,1 +969,1 @@\n-        return Bits.getDouble(buffer, 0);\n+        return ByteArrayAccess.getDouble(buffer);\n@@ -1107,1 +1108,1 @@\n-        Bits.putInt(buffer, 0, v);\n+        ByteArrayAccess.setInt(buffer, v);\n@@ -1120,1 +1121,1 @@\n-        Bits.putLong(buffer, 0, v);\n+        ByteArrayAccess.setLong(buffer, v);\n@@ -1136,1 +1137,2 @@\n-        writeInt(Float.floatToIntBits(v));\n+        ByteArrayAccess.setFloat(buffer, v);\n+        write(buffer, 0, Float.BYTES);\n@@ -1151,1 +1153,2 @@\n-        writeLong(Double.doubleToLongBits(v));\n+        ByteArrayAccess.setDouble(buffer, v);\n+        write(buffer, 0, Double.BYTES);\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,753 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.util.access;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+\n+\/**\n+ * Utility methods for packing\/unpacking primitive values in\/out of byte arrays\n+ * using {@linkplain ByteOrder#BIG_ENDIAN big endian order} (aka. \"network order\").\n+ * <p>\n+ * All methods in this class will throw an {@linkplain NullPointerException} if {@code null} is\n+ * passed in as a method parameter for a byte array.\n+ *\/\n+public final class ByteArrayAccess {\n+\n+    private ByteArrayAccess() {\n+    }\n+\n+    private static final VarHandle SHORT = create(short[].class);\n+    private static final VarHandle CHAR = create(char[].class);\n+    private static final VarHandle INT = create(int[].class);\n+    private static final VarHandle FLOAT = create(float[].class);\n+    private static final VarHandle LONG = create(long[].class);\n+    private static final VarHandle DOUBLE = create(double[].class);\n+\n+    private static final VarHandle SHORT_AT_ZERO = createAtZeroOffset(short[].class);\n+    private static final VarHandle CHAR_AT_ZERO = createAtZeroOffset(char[].class);\n+    private static final VarHandle INT_AT_ZERO = createAtZeroOffset(int[].class);\n+    private static final VarHandle FLOAT_AT_ZERO = createAtZeroOffset(float[].class);\n+    private static final VarHandle LONG_AT_ZERO = createAtZeroOffset(long[].class);\n+    private static final VarHandle DOUBLE_AT_ZERO = createAtZeroOffset(double[].class);\n+\n+    \/*\n+     * Methods for unpacking primitive values from byte arrays starting at\n+     * a given offset.\n+     *\/\n+\n+    \/**\n+     * {@return a {@code boolean} from the provided {@code array} at the given {@code offset}}.\n+     *\n+     * @param array  to read a value from.\n+     * @param offset where extraction in the array should begin\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 1]\n+     * @see #setBoolean(byte[], boolean)\n+     *\/\n+    public static boolean getBoolean(byte[] array, int offset) {\n+        return array[offset] != 0;\n+    }\n+\n+    \/**\n+     * {@return a {@code char} from the provided {@code array} at the given {@code offset}\n+     * using big endian order}.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to get a value from.\n+     * @param offset where extraction in the array should begin\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 2]\n+     * @see #setChar(byte[], int, char)\n+     *\/\n+    public static char getChar(byte[] array, int offset) {\n+        return (char) CHAR.get(array, offset);\n+    }\n+\n+    \/**\n+     * {@return a {@code short} from the provided {@code array} at the given {@code offset}\n+     * using big endian order}.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to get a value from.\n+     * @param offset where extraction in the array should begin\n+     * @return a {@code short} from the array\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 2]\n+     * @see #setShort(byte[], int, short)\n+     *\/\n+    public static short getShort(byte[] array, int offset) {\n+        return (short) SHORT.get(array, offset);\n+    }\n+\n+    \/**\n+     * {@return an {@code unsigned short} from the provided {@code array} at the given {@code offset}\n+     * using big endian order}.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to get a value from.\n+     * @param offset where extraction in the array should begin\n+     * @return an {@code int} representing an unsigned short from the array\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 2]\n+     * @see #setUnsignedShort(byte[], int, int)\n+     *\/\n+    public static int getUnsignedShort(byte[] array, int offset) {\n+        return Short.toUnsignedInt((short) SHORT.get(array, offset));\n+    }\n+\n+    \/**\n+     * {@return an {@code int} from the provided {@code array} at the given {@code offset}\n+     * using big endian order}.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to get a value from.\n+     * @param offset where extraction in the array should begin\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 4]\n+     * @see #setInt(byte[], int, int)\n+     *\/\n+    public static int getInt(byte[] array, int offset) {\n+        return (int) INT.get(array, offset);\n+    }\n+\n+    \/**\n+     * {@return a {@code float} from the provided {@code array} at the given {@code offset}\n+     * using big endian order}.\n+     * <p>\n+     * Variants of {@linkplain Float#NaN } values are canonized to a single NaN value.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to get a value from.\n+     * @param offset where extraction in the array should begin\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 4]\n+     * @see #setFloat(byte[], int, float)\n+     *\/\n+    public static float getFloat(byte[] array, int offset) {\n+        \/\/ Using Float.intBitsToFloat collapses NaN values to a single\n+        \/\/ \"canonical\" NaN value\n+        return Float.intBitsToFloat((int) INT.get(array, offset));\n+    }\n+\n+    \/**\n+     * {@return a {@code float} from the provided {@code array} at the given {@code offset}\n+     * using big endian order}.\n+     * <p>\n+     * Variants of {@linkplain Float#NaN } values are silently read according\n+     * to their bit patterns.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to get a value from.\n+     * @param offset where extraction in the array should begin\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 4]\n+     * @see #setFloatRaw(byte[], int, float)\n+     *\/\n+    public static float getFloatRaw(byte[] array, int offset) {\n+        \/\/ Just gets the bits as they are\n+        return (float) FLOAT.get(array, offset);\n+    }\n+\n+    \/**\n+     * {@return a {@code long} from the provided {@code array} at the given {@code offset}\n+     * using big endian order}.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to get a value from.\n+     * @param offset where extraction in the array should begin\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 8]\n+     * @see #setLong(byte[], int, long)\n+     *\/\n+    public static long getLong(byte[] array, int offset) {\n+        return (long) LONG.get(array, offset);\n+    }\n+\n+    \/**\n+     * {@return a {@code double} from the provided {@code array} at the given {@code offset}\n+     * using big endian order}.\n+     * <p>\n+     * Variants of {@linkplain Double#NaN } values are canonized to a single NaN value.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to get a value from.\n+     * @param offset where extraction in the array should begin\n+     * @throws NullPointerException      if the provided {@code array} is {@code null}\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 8]\n+     * @see #setDouble(byte[], int, double)\n+     *\/\n+    public static double getDouble(byte[] array, int offset) {\n+        \/\/ Using Double.longBitsToDouble collapses NaN values to a single\n+        \/\/ \"canonical\" NaN value\n+        return Double.longBitsToDouble((long) LONG.get(array, offset));\n+    }\n+\n+    \/**\n+     * {@return a {@code double} from the provided {@code array} at the given {@code offset}\n+     * using big endian order}.\n+     * <p>\n+     * Variants of {@linkplain Double#NaN } values are silently read according to\n+     * their bit patterns.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to get a value from.\n+     * @param offset where extraction in the array should begin\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 8]\n+     * @see #setDoubleRaw(byte[], int, double)\n+     *\/\n+    public static double getDoubleRaw(byte[] array, int offset) {\n+        \/\/ Just gets the bits as they are\n+        return (double) DOUBLE.get(array, offset);\n+    }\n+\n+    \/*\n+     * Methods for unpacking primitive values from byte arrays starting at\n+     * offset zero.\n+     *\/\n+\n+    \/**\n+     * {@return a {@code boolean} from the provided {@code array} at index 0}.\n+     *\n+     * @param array  to read a value from.\n+     * @throws IndexOutOfBoundsException if {@code array.length < 1}\n+     * @see #setBoolean(byte[], boolean)\n+     *\/\n+    public static boolean getBoolean(byte[] array) {\n+        return array[0] != 0;\n+    }\n+\n+    \/**\n+     * {@return a {@code char} from the provided {@code array} at index 0}.\n+     *\n+     * @param array  to get a value from.\n+     * @throws IndexOutOfBoundsException if {@code array.length < 2}\n+     * @see #setChar(byte[], char)\n+     *\/\n+    public static char getChar(byte[] array) {\n+        return (char) CHAR_AT_ZERO.get(array);\n+    }\n+\n+    \/**\n+     * {@return a {@code short} from the provided {@code array} at index 0}.\n+     *\n+     * @param array  to get a value from.\n+     * @throws IndexOutOfBoundsException if {@code array.length < 2}\n+     * @see #setShort(byte[], short)\n+     *\/\n+    public static short getShort(byte[] array) {\n+        return (short) SHORT_AT_ZERO.get(array);\n+    }\n+\n+    \/**\n+     * {@return an {@code unsigned short} from the provided {@code array} at index 0}.\n+     *\n+     * @param array  to get a value from.\n+     * @throws IndexOutOfBoundsException if {@code array.length < 2}\n+     * @see #setUnsignedShort(byte[], int)\n+     *\/\n+    public static int getUnsignedShort(byte[] array) {\n+        return Short.toUnsignedInt((short) SHORT_AT_ZERO.get(array));\n+    }\n+\n+    \/**\n+     * {@return an {@code int} from the provided {@code array} at index 0}.\n+     *\n+     * @param array  to get a value from.\n+     * @throws IndexOutOfBoundsException if {@code array.length < 4}\n+     * @see #setInt(byte[], int)\n+     *\/\n+    public static int getInt(byte[] array) {\n+        return (int) INT_AT_ZERO.get(array);\n+    }\n+\n+    \/**\n+     * {@return a {@code float} from the provided {@code array} at index 0}.\n+     * <p>\n+     * Variants of {@linkplain Float#NaN } values are canonized to a single NaN value.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to get a value from.\n+     * @throws IndexOutOfBoundsException if {@code array.length < 4}\n+     * @see #setFloat(byte[], float)\n+     *\/\n+    public static float getFloat(byte[] array) {\n+        \/\/ Using Float.intBitsToFloat collapses NaN values to a single\n+        \/\/ \"canonical\" NaN value\n+        return Float.intBitsToFloat((int) INT_AT_ZERO.get(array));\n+    }\n+\n+    \/**\n+     * {@return a {@code float} from the provided {@code array} at index 0}.\n+     * <p>\n+     * Variants of {@linkplain Float#NaN } values are silently read according\n+     * to their bit patterns.\n+     *\n+     * @param array  to get a value from.\n+     * @throws IndexOutOfBoundsException if {@code array.length < 4}\n+     * @see #setFloatRaw(byte[], float)\n+     *\/\n+    public static float getFloatRaw(byte[] array) {\n+        \/\/ Just gets the bits as they are\n+        return (float) FLOAT_AT_ZERO.get(array);\n+    }\n+\n+    \/**\n+     * {@return a {@code long} from the provided {@code array} at index 0}.\n+     *\n+     * @param array  to get a value from.\n+     * @throws IndexOutOfBoundsException if {@code array.length < 8}\n+     * @see #setLong(byte[], long)\n+     *\/\n+    public static long getLong(byte[] array) {\n+        return (long) LONG_AT_ZERO.get(array);\n+    }\n+\n+    \/**\n+     * {@return a {@code double} from the provided {@code array} at index 0}.\n+     * <p>\n+     * Variants of {@linkplain Double#NaN } values are canonized to a single NaN value.\n+     *\n+     * @param array  to get a value from.\n+     * @throws IndexOutOfBoundsException if {@code array.length < 8}\n+     * @see #setDouble(byte[], double)\n+     *\/\n+    public static double getDouble(byte[] array) {\n+        \/\/ Using Double.longBitsToDouble collapses NaN values to a single\n+        \/\/ \"canonical\" NaN value\n+        return Double.longBitsToDouble((long) LONG_AT_ZERO.get(array));\n+    }\n+\n+    \/**\n+     * {@return a {@code double} from the provided {@code array} at the given {@code offset}\n+     * using big endian order}.\n+     * <p>\n+     * Variants of {@linkplain Double#NaN } values are silently read according to\n+     * their bit patterns.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to get a value from.\n+     * @throws IndexOutOfBoundsException if {@code array.length < 8}\n+     * @see #setDoubleRaw(byte[], double)\n+     *\/\n+    public static double getDoubleRaw(byte[] array) {\n+        \/\/ Just gets the bits as they are\n+        return (double) DOUBLE_AT_ZERO.get(array);\n+    }\n+\n+    \/*\n+     * Methods for packing primitive values into byte arrays starting at a given\n+     * offset.\n+     *\/\n+\n+    \/**\n+     * Sets (writes) the provided {@code value} into\n+     * the provided {@code array} beginning at the given {@code offset}.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param offset where setting (writing) in the array should begin\n+     * @param value  value to set in the array\n+     * @throws NullPointerException      if the provided {@code array} is {@code null}\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length]\n+     * @see #getBoolean(byte[], int)\n+     *\/\n+    public static void setBoolean(byte[] array, int offset, boolean value) {\n+        array[offset] = (byte) (value ? 1 : 0);\n+    }\n+\n+    \/**\n+     * Sets (writes) the provided {@code value} using big endian order into\n+     * the provided {@code array} beginning at the given {@code offset}.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param offset where setting (writing) in the array should begin\n+     * @param value  value to set in the array\n+     * @throws NullPointerException      if the provided {@code array} is {@code null}\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 2]\n+     * @see #getChar(byte[], int)\n+     *\/\n+    public static void setChar(byte[] array, int offset, char value) {\n+        CHAR.set(array, offset, value);\n+    }\n+\n+    \/**\n+     * Sets (writes) the provided {@code value} using big endian order into\n+     * the provided {@code array} beginning at the given {@code offset}.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param offset where setting (writing) in the array should begin\n+     * @param value  value to set in the array\n+     * @throws NullPointerException      if the provided {@code array} is {@code null}\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 2]\n+     * @see #getShort(byte[], int)\n+     *\/\n+    public static void setShort(byte[] array, int offset, short value) {\n+        SHORT.set(array, offset, value);\n+    }\n+\n+    \/**\n+     * Sets (writes) the provided {@code value} using big endian order into\n+     * the provided {@code array} beginning at the given {@code offset}.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param offset where setting (writing) in the array should begin\n+     * @param value  value to set in the array\n+     * @throws NullPointerException      if the provided {@code array} is {@code null}\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 2]\n+     * @see #getUnsignedShort(byte[], int)\n+     *\/\n+    public static void setUnsignedShort(byte[] array, int offset, int value) {\n+        SHORT.set(array, offset, (short) (char) value);\n+    }\n+\n+    \/**\n+     * Sets (writes) the provided {@code value} using big endian order into\n+     * the provided {@code array} beginning at the given {@code offset}.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param offset where setting (writing) in the array should begin\n+     * @param value  value to set in the array\n+     * @throws NullPointerException      if the provided {@code array} is {@code null}\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 4]\n+     * @see #getInt(byte[], int)\n+     *\/\n+    public static void setInt(byte[] array, int offset, int value) {\n+        INT.set(array, offset, value);\n+    }\n+\n+    \/**\n+     * Sets (writes) the provided {@code value} using big endian order into\n+     * the provided {@code array} beginning at the given {@code offset}.\n+     * <p>\n+     * Variants of {@linkplain Float#NaN } values are canonized to a single NaN value.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param offset where setting (writing) in the array should begin\n+     * @param value  value to set in the array\n+     * @throws NullPointerException      if the provided {@code array} is {@code null}\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 2]\n+     * @see #getFloat(byte[], int)\n+     *\/\n+    public static void setFloat(byte[] array, int offset, float value) {\n+        \/\/ Using Float.floatToIntBits collapses NaN values to a single\n+        \/\/ \"canonical\" NaN value\n+        INT.set(array, offset, Float.floatToIntBits(value));\n+    }\n+\n+    \/**\n+     * Sets (writes) the provided {@code value} using big endian order into\n+     * the provided {@code array} beginning at the given {@code offset}.\n+     * <p>\n+     * Variants of {@linkplain Float#NaN } values are silently written according to\n+     * their bit patterns.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param offset where setting (writing) in the array should begin\n+     * @param value  value to set in the array\n+     * @throws NullPointerException      if the provided {@code array} is {@code null}\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 2]\n+     * @see #getFloatRaw(byte[], int)\n+     *\/\n+    public static void setFloatRaw(byte[] array, int offset, float value) {\n+        \/\/ Just sets the bits as they are\n+        FLOAT.set(array, offset, value);\n+    }\n+\n+    \/**\n+     * Sets (writes) the provided {@code value} using big endian order into\n+     * the provided {@code array} beginning at the given {@code offset}.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param offset where setting (writing) in the array should begin\n+     * @param value  value to set in the array\n+     * @throws NullPointerException      if the provided {@code array} is {@code null}\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 4]\n+     * @see #getLong(byte[], int)\n+     *\/\n+    public static void setLong(byte[] array, int offset, long value) {\n+        LONG.set(array, offset, value);\n+    }\n+\n+    \/**\n+     * Sets (writes) the provided {@code value} using big endian order into\n+     * the provided {@code array} beginning at the given {@code offset}.\n+     * <p>\n+     * Variants of {@linkplain Double#NaN } values are canonized to a single NaN value.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param offset where setting (writing) in the array should begin\n+     * @param value  value to set in the array\n+     * @throws NullPointerException      if the provided {@code array} is {@code null}\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 2]\n+     * @see #getDouble(byte[], int)\n+     *\/\n+    public static void setDouble(byte[] array, int offset, double value) {\n+        \/\/ Using Double.doubleToLongBits collapses NaN values to a single\n+        \/\/ \"canonical\" NaN value\n+        LONG.set(array, offset, Double.doubleToLongBits(value));\n+    }\n+\n+    \/**\n+     * Sets (writes) the provided {@code value} using big endian order into\n+     * the provided {@code array} beginning at the given {@code offset}.\n+     * <p>\n+     * Variants of {@linkplain Double#NaN } values are silently written according to\n+     * their bit patterns.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param offset where setting (writing) in the array should begin\n+     * @param value  value to set in the array\n+     * @throws NullPointerException      if the provided {@code array} is {@code null}\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 2]\n+     * @see #getDoubleRaw(byte[], int)\n+     *\/\n+    public static void setDoubleRaw(byte[] array, int offset, double value) {\n+        \/\/ Just sets the bits as they are\n+        DOUBLE.set(array, offset, value);\n+    }\n+\n+\n+    \/*\n+     * Methods for packing primitive values into byte arrays starting at offset zero.\n+     *\/\n+\n+    \/**\n+     * Sets (writes) the provided {@code value} into\n+     * the provided {@code array} beginning at index 0.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param value  value to set in the array\n+     * @throws NullPointerException      if the provided {@code array} is {@code null}\n+     * @throws IndexOutOfBoundsException if {@code array.length < 1}\n+     * @see #getBoolean(byte[])\n+     *\/\n+    public static void setBoolean(byte[] array, boolean value) {\n+        array[0] = (byte) (value ? 1 : 0);\n+    }\n+\n+    \/**\n+     * Sets (writes) the provided {@code value} using big endian order into\n+     * the provided {@code array} beginning at index 0.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param value  value to set in the array\n+     * @throws NullPointerException      if the provided {@code array} is {@code null}\n+     * @throws IndexOutOfBoundsException if {@code array.length < 2}\n+     * @see #getChar(byte[])\n+     *\/\n+    public static void setChar(byte[] array, char value) {\n+        CHAR_AT_ZERO.set(array, value);\n+    }\n+\n+    \/**\n+     * Sets (writes) the provided {@code value} using big endian order into\n+     * the provided {@code array} beginning at index 0.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param value  value to set in the array\n+     * @throws NullPointerException      if the provided {@code array} is {@code null}\n+     * @throws IndexOutOfBoundsException if {@code array.length < 2}\n+     * @see #getShort(byte[])\n+     *\/\n+    public static void setShort(byte[] array, short value) {\n+        SHORT_AT_ZERO.set(array, value);\n+    }\n+\n+    \/**\n+     * Sets (writes) the provided {@code value} using big endian order into\n+     * the provided {@code array} beginning at index 0.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param value  value to set in the array\n+     * @throws NullPointerException      if the provided {@code array} is {@code null}\n+     * @throws IndexOutOfBoundsException if {@code array.length < 2}\n+     * @see #getUnsignedShort(byte[])\n+     *\/\n+    public static void setUnsignedShort(byte[] array, int value) {\n+        SHORT_AT_ZERO.set(array, (short) (char) value);\n+    }\n+\n+    \/**\n+     * Sets (writes) the provided {@code value} using big endian order into\n+     * the provided {@code array} beginning at index 0.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param value  value to set in the array\n+     * @throws NullPointerException      if the provided {@code array} is {@code null}\n+     * @throws IndexOutOfBoundsException if {@code array.length < 4}\n+     * @see #getInt(byte[])\n+     *\/\n+    public static void setInt(byte[] array, int value) {\n+        INT_AT_ZERO.set(array, value);\n+    }\n+\n+    \/**\n+     * Sets (writes) the provided {@code value} using big endian order into\n+     * the provided {@code array} beginning at index 0.\n+     * <p>\n+     * Variants of {@linkplain Float#NaN } values are canonized to a single NaN value.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param value  value to set in the array\n+     * @throws NullPointerException      if the provided {@code array} is {@code null}\n+     * @throws IndexOutOfBoundsException if {@code array.length < 4}\n+     * @see #getFloat(byte[])\n+     *\/\n+    public static void setFloat(byte[] array, float value) {\n+        \/\/ Using Float.floatToIntBits collapses NaN values to a single\n+        \/\/ \"canonical\" NaN value\n+        INT_AT_ZERO.set(array, Float.floatToIntBits(value));\n+    }\n+\n+    \/**\n+     * Sets (writes) the provided {@code value} using big endian order into\n+     * the provided {@code array} beginning at index 0.\n+     * <p>\n+     * Variants of {@linkplain Float#NaN } values are silently written according to\n+     * their bit patterns.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param value  value to set in the array\n+     * @throws NullPointerException      if the provided {@code array} is {@code null}\n+     * @throws IndexOutOfBoundsException if {@code array.length < 4}\n+     * @see #getFloatRaw(byte[])\n+     *\/\n+    public static void setFloatRaw(byte[] array, float value) {\n+        \/\/ Just sets the bits as they are\n+        FLOAT_AT_ZERO.set(array, value);\n+    }\n+\n+    \/**\n+     * Sets (writes) the provided {@code value} using big endian order into\n+     * the provided {@code array} beginning at index 0.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param value  value to set in the array\n+     * @throws NullPointerException      if the provided {@code array} is {@code null}\n+     * @throws IndexOutOfBoundsException if {@code array.length < 8}\n+     * @see #getLong(byte[])\n+     *\/\n+    public static void setLong(byte[] array, long value) {\n+        LONG_AT_ZERO.set(array, value);\n+    }\n+\n+    \/**\n+     * Sets (writes) the provided {@code value} using big endian order into\n+     * the provided {@code array} beginning at index 0.\n+     * <p>\n+     * Variants of {@linkplain Double#NaN } values are canonized to a single NaN value.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param value  value to set in the array\n+     * @throws NullPointerException      if the provided {@code array} is {@code null}\n+     * @throws IndexOutOfBoundsException if {@code array.length < 8}\n+     * @see #getDoubleRaw(byte[])\n+     *\/\n+    public static void setDouble(byte[] array, double value) {\n+        \/\/ Using Double.doubleToLongBits collapses NaN values to a single\n+        \/\/ \"canonical\" NaN value\n+        LONG_AT_ZERO.set(array, Double.doubleToLongBits(value));\n+    }\n+\n+    \/**\n+     * Sets (writes) the provided {@code value} using big endian order into\n+     * the provided {@code array} beginning at index 0.\n+     * <p>\n+     * Variants of {@linkplain Double#NaN } values are silently written according to\n+     * their bit patterns.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param value  value to set in the array\n+     * @throws NullPointerException      if the provided {@code array} is {@code null}\n+     * @throws IndexOutOfBoundsException if {@code array.length < 8}\n+     * @see #getDoubleRaw(byte[])\n+     *\/\n+    public static void setDoubleRaw(byte[] array, double value) {\n+        \/\/ Just sets the bits as they are\n+        DOUBLE_AT_ZERO.set(array, value);\n+    }\n+\n+    private static VarHandle createAtZeroOffset(Class<?> viewArrayClass) {\n+        var original = create(viewArrayClass);\n+        \/\/ (byte[] array, int offset, ...) -> { offset = 0 } -> (byte[], ...)\n+        return MethodHandles.insertCoordinates(original, 1, 0);\n+    }\n+\n+    private static VarHandle create(Class<?> viewArrayClass) {\n+        return MethodHandles.byteArrayViewVarHandle(viewArrayClass, ByteOrder.BIG_ENDIAN);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/access\/ByteArrayAccess.java","additions":753,"deletions":0,"binary":false,"changes":753,"status":"added"},{"patch":"@@ -1,319 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8299576\n- * @summary Verify that reads and writes of primitives are correct\n- * @compile\/module=java.base java\/io\/BitsProxy.java\n- * @run junit ReadWriteValues\n- *\/\n-\n-import java.io.BitsProxy;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.stream.DoubleStream;\n-import java.util.stream.LongStream;\n-import java.util.stream.Stream;\n-\n-import org.junit.jupiter.api.*;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-final class ReadWriteValues {\n-\n-    \/\/ Makes sure unaligned read\/write can be made.\n-    private static final int OFFSET = 1;\n-\n-    private static final byte[] BUFF = new byte[Long.BYTES + OFFSET];\n-\n-    private static final int ITERATIONS = 1 << 10;\n-\n-    @Test\n-    void testGetShort() {\n-        longs().forEach(l -> {\n-            short expected = (short) l;\n-            RefImpl.putShort(BUFF, OFFSET, expected);\n-            short actual = BitsProxy.getShort(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutShort() {\n-        longs().forEach(l -> {\n-            short expected = (short) l;\n-            BitsProxy.putShort(BUFF, OFFSET, expected);\n-            short actual = RefImpl.getShort(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testGetChar() {\n-        longs().forEach(l -> {\n-            char expected = (char) l;\n-            RefImpl.putChar(BUFF, OFFSET, expected);\n-            char actual = BitsProxy.getChar(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutChar() {\n-        longs().forEach(l -> {\n-            char expected = (char) l;\n-            BitsProxy.putChar(BUFF, OFFSET, expected);\n-            char actual = RefImpl.getChar(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testGetInt() {\n-        longs().forEach(l -> {\n-            int expected = (int) l;\n-            RefImpl.putInt(BUFF, OFFSET, expected);\n-            int actual = BitsProxy.getInt(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutInt() {\n-        longs().forEach(l -> {\n-            int expected = (int) l;\n-            BitsProxy.putInt(BUFF, OFFSET, expected);\n-            int actual = RefImpl.getInt(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testGetLong() {\n-        longs().forEach(expected -> {\n-            RefImpl.putLong(BUFF, OFFSET, expected);\n-            long actual = BitsProxy.getLong(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutLong() {\n-        longs().forEach(expected -> {\n-            BitsProxy.putLong(BUFF, OFFSET, expected);\n-            long actual = RefImpl.getLong(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testGetFloat() {\n-        floats().forEach(expected -> {\n-            RefImpl.putFloat(BUFF, OFFSET, expected);\n-            float actual = BitsProxy.getFloat(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutFloat() {\n-        floats().forEach(expected -> {\n-            BitsProxy.putFloat(BUFF, OFFSET, expected);\n-            float actual = RefImpl.getFloat(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testGetDouble() {\n-        doubles().forEach(expected -> {\n-            RefImpl.putDouble(BUFF, OFFSET, expected);\n-            double actual = BitsProxy.getDouble(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutDouble() {\n-        doubles().forEach(expected -> {\n-            BitsProxy.putDouble(BUFF, OFFSET, expected);\n-            double actual = RefImpl.getDouble(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    \/\/ Unusual cases\n-\n-    @Test\n-    void testNullArray() {\n-        assertThrowsOriginal(NullPointerException.class, () -> BitsProxy.getInt(null, OFFSET));\n-        assertThrowsOriginal(NullPointerException.class, () -> BitsProxy.putInt(null, OFFSET, 1));\n-    }\n-\n-    @Test\n-    void testNegArg() {\n-        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> BitsProxy.getInt(BUFF, -1));\n-        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> BitsProxy.putInt(BUFF, -1, 1));\n-    }\n-\n-    @Test\n-    void testOutOfBounds() {\n-        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> BitsProxy.getInt(BUFF, BUFF.length));\n-        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> BitsProxy.putInt(BUFF, BUFF.length, 1));\n-    }\n-\n-    static LongStream longs() {\n-        return ThreadLocalRandom.current().longs(ITERATIONS);\n-    }\n-\n-    static DoubleStream doubles() {\n-        return DoubleStream.concat(\n-                ThreadLocalRandom.current().doubles(ITERATIONS),\n-                DoubleStream.of(Double.NaN,\n-                        Double.NEGATIVE_INFINITY,\n-                        Double.POSITIVE_INFINITY,\n-                        Double.MAX_VALUE,\n-                        Double.MIN_VALUE,\n-                        -0.0d\n-                        +0.0d)\n-        );\n-    }\n-    static Stream<Float> floats() {\n-        return Stream.concat(\n-                ThreadLocalRandom.current().doubles(ITERATIONS).mapToObj(d -> (float)d),\n-                Stream.of(Float.NaN,\n-                        Float.NEGATIVE_INFINITY,\n-                        Float.POSITIVE_INFINITY,\n-                        Float.MAX_VALUE,\n-                        Float.MIN_VALUE,\n-                        -0.0f\n-                        +0.0f)\n-        );\n-    }\n-\n-    @FunctionalInterface\n-    interface ThrowingRunnable {\n-        void run() throws Exception;\n-    }\n-\n-    <X extends Exception> void assertThrowsOriginal(Class<X> type,\n-                                                    ThrowingRunnable runnable) {\n-        try {\n-            runnable.run();\n-        } catch (Exception e) {\n-            if (type.isInstance(e)) {\n-                return;\n-            }\n-            if (type.isInstance(e.getCause())) {\n-                return;\n-            }\n-            throw new AssertionError(e);\n-        }\n-\n-    }\n-\n-    \/**\n-    * Reference implementation from the old java.io.Bits implementation\n-    *\/\n-    private static final class RefImpl {\n-        private RefImpl() {}\n-\n-        static char getChar(byte[] b, int off) {\n-            return (char) ((b[off + 1] & 0xFF) +\n-                    (b[off] << 8));\n-        }\n-\n-        static short getShort(byte[] b, int off) {\n-            return (short) ((b[off + 1] & 0xFF) +\n-                    (b[off] << 8));\n-        }\n-\n-        static int getInt(byte[] b, int off) {\n-            return ((b[off + 3] & 0xFF)) +\n-                    ((b[off + 2] & 0xFF) << 8) +\n-                    ((b[off + 1] & 0xFF) << 16) +\n-                    ((b[off]) << 24);\n-        }\n-\n-        static float getFloat(byte[] b, int off) {\n-            return Float.intBitsToFloat(getInt(b, off));\n-        }\n-\n-        static long getLong(byte[] b, int off) {\n-            return ((b[off + 7] & 0xFFL)) +\n-                    ((b[off + 6] & 0xFFL) << 8) +\n-                    ((b[off + 5] & 0xFFL) << 16) +\n-                    ((b[off + 4] & 0xFFL) << 24) +\n-                    ((b[off + 3] & 0xFFL) << 32) +\n-                    ((b[off + 2] & 0xFFL) << 40) +\n-                    ((b[off + 1] & 0xFFL) << 48) +\n-                    (((long) b[off]) << 56);\n-        }\n-\n-        static double getDouble(byte[] b, int off) {\n-            return Double.longBitsToDouble(getLong(b, off));\n-        }\n-\n-        \/*\n-         * Methods for packing primitive values into byte arrays starting at given\n-         * offsets.\n-         *\/\n-\n-        static void putChar(byte[] b, int off, char val) {\n-            b[off + 1] = (byte) (val);\n-            b[off] = (byte) (val >>> 8);\n-        }\n-\n-        static void putShort(byte[] b, int off, short val) {\n-            b[off + 1] = (byte) (val);\n-            b[off] = (byte) (val >>> 8);\n-        }\n-\n-        static void putInt(byte[] b, int off, int val) {\n-            b[off + 3] = (byte) (val);\n-            b[off + 2] = (byte) (val >>> 8);\n-            b[off + 1] = (byte) (val >>> 16);\n-            b[off] = (byte) (val >>> 24);\n-        }\n-\n-        static void putFloat(byte[] b, int off, float val) {\n-            putInt(b, off, Float.floatToIntBits(val));\n-        }\n-\n-        static void putLong(byte[] b, int off, long val) {\n-            b[off + 7] = (byte) (val);\n-            b[off + 6] = (byte) (val >>> 8);\n-            b[off + 5] = (byte) (val >>> 16);\n-            b[off + 4] = (byte) (val >>> 24);\n-            b[off + 3] = (byte) (val >>> 32);\n-            b[off + 2] = (byte) (val >>> 40);\n-            b[off + 1] = (byte) (val >>> 48);\n-            b[off] = (byte) (val >>> 56);\n-        }\n-\n-        static void putDouble(byte[] b, int off, double val) {\n-            putLong(b, off, Double.doubleToLongBits(val));\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/io\/Bits\/ReadWriteValues.java","additions":0,"deletions":319,"binary":false,"changes":319,"status":"deleted"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.io;\n-\n-\/**\n- * Class to allow public access to package-private methods.\n- *\/\n-public final class BitsProxy {\n-\n-    public static boolean getBoolean(byte[] b, int off) {\n-        return Bits.getBoolean(b, off);\n-    }\n-\n-    public static char getChar(byte[] b, int off) {\n-        return Bits.getChar(b, off);\n-    }\n-\n-    public static short getShort(byte[] b, int off) {\n-        return Bits.getShort(b, off);\n-    }\n-\n-    public static int getInt(byte[] b, int off) {\n-        return Bits.getInt(b, off);\n-    }\n-\n-    public static float getFloat(byte[] b, int off) {\n-        return Bits.getFloat(b, off);\n-    }\n-\n-    public static long getLong(byte[] b, int off) {\n-        return Bits.getLong(b, off);\n-    }\n-\n-    public static double getDouble(byte[] b, int off) {\n-        return Bits.getDouble(b, off);\n-    }\n-\n-\n-    public static void putBoolean(byte[] b, int off, boolean val) {\n-        Bits.putBoolean(b, off, val);\n-    }\n-\n-    public static void putChar(byte[] b, int off, char val) {\n-        Bits.putChar(b, off, val);\n-    }\n-\n-    public static void putShort(byte[] b, int off, short val) {\n-        Bits.putShort(b, off, val);\n-    }\n-\n-    public static void putInt(byte[] b, int off, int val) {\n-        Bits.putInt(b, off, val);\n-    }\n-\n-    public static void putFloat(byte[] b, int off, float val) {\n-        Bits.putFloat(b, off, val);\n-    }\n-\n-    public static void putLong(byte[] b, int off, long val) {\n-        Bits.putLong(b, off, val);\n-    }\n-\n-    public static void putDouble(byte[] b, int off, double val) {\n-        Bits.putDouble(b, off, val);\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/io\/Bits\/java.base\/java\/io\/BitsProxy.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -0,0 +1,470 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8299576\n+ * @modules java.base\/jdk.internal.util\n+ * @summary Verify that reads and writes of primitives are correct\n+ * @run junit ReadWriteValues\n+ *\/\n+\n+import jdk.internal.util.access.ByteArrayAccess;\n+import org.junit.jupiter.api.*;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class ReadWriteValues {\n+\n+    \/\/ Makes sure unaligned read\/write can be made.\n+    private static final int OFFSET = 1;\n+\n+    private static final byte[] BUFF = new byte[Long.BYTES + OFFSET];\n+\n+    private static final int ITERATIONS = 1 << 10;\n+\n+    @Test\n+    void testGetShort() {\n+        longs().forEach(l -> {\n+            short expected = (short) l;\n+            RefImpl.putShort(BUFF, OFFSET, expected);\n+            short actual = ByteArrayAccess.getShort(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutShort() {\n+        longs().forEach(l -> {\n+            short expected = (short) l;\n+            ByteArrayAccess.setShort(BUFF, OFFSET, expected);\n+            short actual = RefImpl.getShort(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetChar() {\n+        longs().forEach(l -> {\n+            char expected = (char) l;\n+            RefImpl.putChar(BUFF, OFFSET, expected);\n+            char actual = ByteArrayAccess.getChar(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutChar() {\n+        longs().forEach(l -> {\n+            char expected = (char) l;\n+            ByteArrayAccess.setChar(BUFF, OFFSET, expected);\n+            char actual = RefImpl.getChar(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetInt() {\n+        longs().forEach(l -> {\n+            int expected = (int) l;\n+            RefImpl.putInt(BUFF, OFFSET, expected);\n+            int actual = ByteArrayAccess.getInt(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutInt() {\n+        longs().forEach(l -> {\n+            int expected = (int) l;\n+            ByteArrayAccess.setInt(BUFF, OFFSET, expected);\n+            int actual = RefImpl.getInt(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetLong() {\n+        longs().forEach(expected -> {\n+            RefImpl.putLong(BUFF, OFFSET, expected);\n+            long actual = ByteArrayAccess.getLong(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutLong() {\n+        longs().forEach(expected -> {\n+            ByteArrayAccess.setLong(BUFF, OFFSET, expected);\n+            long actual = RefImpl.getLong(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetFloat() {\n+        floats().forEach(expected -> {\n+            RefImpl.putFloat(BUFF, OFFSET, expected);\n+            float actual = ByteArrayAccess.getFloat(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutFloat() {\n+        floats().forEach(expected -> {\n+            ByteArrayAccess.setFloat(BUFF, OFFSET, expected);\n+            float actual = RefImpl.getFloat(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetDouble() {\n+        doubles().forEach(expected -> {\n+            RefImpl.putDouble(BUFF, OFFSET, expected);\n+            double actual = ByteArrayAccess.getDouble(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutDouble() {\n+        doubles().forEach(expected -> {\n+            ByteArrayAccess.setDouble(BUFF, OFFSET, expected);\n+            double actual = RefImpl.getDouble(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutUnsignedShort() {\n+        longs().forEach(l -> {\n+            int expected = Short.toUnsignedInt((short) l);\n+            ByteArrayAccess.setUnsignedShort(BUFF, OFFSET, expected);\n+            int actual = Short.toUnsignedInt(RefImpl.getShort(BUFF, OFFSET));\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+\n+    \/\/ Unusual cases\n+\n+    @Test\n+    void testNullArray() {\n+        assertThrowsOriginal(NullPointerException.class, () -> ByteArrayAccess.getInt(null, OFFSET));\n+        assertThrowsOriginal(NullPointerException.class, () -> ByteArrayAccess.setInt(null, OFFSET, 1));\n+    }\n+\n+    @Test\n+    void testNegArg() {\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArrayAccess.getInt(BUFF, -1));\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArrayAccess.setInt(BUFF, -1, 1));\n+    }\n+\n+    @Test\n+    void testOutOfBounds() {\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArrayAccess.getInt(BUFF, BUFF.length));\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArrayAccess.setInt(BUFF, BUFF.length, 1));\n+    }\n+\n+    \/\/ At-zero methods\n+\n+    @Test\n+    void testGetShortAtZero() {\n+        longs().forEach(l -> {\n+            short expected = (short) l;\n+            RefImpl.putShort(BUFF, 0, expected);\n+            short actual = ByteArrayAccess.getShort(BUFF);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutShortAtZero() {\n+        longs().forEach(l -> {\n+            short expected = (short) l;\n+            ByteArrayAccess.setShort(BUFF, expected);\n+            short actual = RefImpl.getShort(BUFF, 0);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetCharAtZero() {\n+        longs().forEach(l -> {\n+            char expected = (char) l;\n+            RefImpl.putChar(BUFF, 0, expected);\n+            char actual = ByteArrayAccess.getChar(BUFF);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutCharAtZero() {\n+        longs().forEach(l -> {\n+            char expected = (char) l;\n+            ByteArrayAccess.setChar(BUFF, expected);\n+            char actual = RefImpl.getChar(BUFF, 0);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetIntAtZero() {\n+        longs().forEach(l -> {\n+            int expected = (int) l;\n+            RefImpl.putInt(BUFF, 0, expected);\n+            int actual = ByteArrayAccess.getInt(BUFF);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutIntAtZero() {\n+        longs().forEach(l -> {\n+            int expected = (int) l;\n+            ByteArrayAccess.setInt(BUFF, expected);\n+            int actual = RefImpl.getInt(BUFF, 0);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetLongAtZero() {\n+        longs().forEach(expected -> {\n+            RefImpl.putLong(BUFF, 0, expected);\n+            long actual = ByteArrayAccess.getLong(BUFF);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutLongAtZero() {\n+        longs().forEach(expected -> {\n+            ByteArrayAccess.setLong(BUFF, expected);\n+            long actual = RefImpl.getLong(BUFF, 0);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetFloatAtZero() {\n+        floats().forEach(expected -> {\n+            RefImpl.putFloat(BUFF, 0, expected);\n+            float actual = ByteArrayAccess.getFloat(BUFF);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutFloatAtZero() {\n+        floats().forEach(expected -> {\n+            ByteArrayAccess.setFloat(BUFF, expected);\n+            float actual = RefImpl.getFloat(BUFF, 0);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetDoubleAtZero() {\n+        doubles().forEach(expected -> {\n+            RefImpl.putDouble(BUFF, 0, expected);\n+            double actual = ByteArrayAccess.getDouble(BUFF);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutDoubleAtZero() {\n+        doubles().forEach(expected -> {\n+            ByteArrayAccess.setDouble(BUFF, expected);\n+            double actual = RefImpl.getDouble(BUFF, 0);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutUnsignedShortAtZero() {\n+        longs().forEach(l -> {\n+            int expected = Short.toUnsignedInt((short) l);\n+            ByteArrayAccess.setUnsignedShort(BUFF, expected);\n+            int actual = Short.toUnsignedInt(RefImpl.getShort(BUFF, 0));\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    \/\/ Unusual cases\n+\n+    @Test\n+    void testNullArrayAtZero() {\n+        assertThrowsOriginal(NullPointerException.class, () -> ByteArrayAccess.getInt(null));\n+        assertThrowsOriginal(NullPointerException.class, () -> ByteArrayAccess.setInt(null, 1));\n+    }\n+\n+    @Test\n+    void testOutOfBoundsAtZero() {\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArrayAccess.getInt(new byte[1]));\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArrayAccess.setInt(new byte[1],1));\n+    }\n+\n+\n+    static LongStream longs() {\n+        return ThreadLocalRandom.current().longs(ITERATIONS);\n+    }\n+\n+    static DoubleStream doubles() {\n+        return DoubleStream.concat(\n+                ThreadLocalRandom.current().doubles(ITERATIONS),\n+                DoubleStream.of(Double.NaN,\n+                        Double.NEGATIVE_INFINITY,\n+                        Double.POSITIVE_INFINITY,\n+                        Double.MAX_VALUE,\n+                        Double.MIN_VALUE,\n+                        -0.0d\n+                        +0.0d)\n+        );\n+    }\n+    static Stream<Float> floats() {\n+        return Stream.concat(\n+                ThreadLocalRandom.current().doubles(ITERATIONS).mapToObj(d -> (float)d),\n+                Stream.of(Float.NaN,\n+                        Float.NEGATIVE_INFINITY,\n+                        Float.POSITIVE_INFINITY,\n+                        Float.MAX_VALUE,\n+                        Float.MIN_VALUE,\n+                        -0.0f\n+                        +0.0f)\n+        );\n+    }\n+\n+    @FunctionalInterface\n+    interface ThrowingRunnable {\n+        void run() throws Exception;\n+    }\n+\n+    <X extends Exception> void assertThrowsOriginal(Class<X> type,\n+                                                    ThrowingRunnable runnable) {\n+        try {\n+            runnable.run();\n+        } catch (Exception e) {\n+            if (type.isInstance(e)) {\n+                return;\n+            }\n+            if (type.isInstance(e.getCause())) {\n+                return;\n+            }\n+            throw new AssertionError(e);\n+        }\n+\n+    }\n+\n+    \/**\n+    * Reference implementation from the old java.io.Bits implementation\n+    *\/\n+    private static final class RefImpl {\n+        private RefImpl() {}\n+\n+        static char getChar(byte[] b, int off) {\n+            return (char) ((b[off + 1] & 0xFF) +\n+                    (b[off] << 8));\n+        }\n+\n+        static short getShort(byte[] b, int off) {\n+            return (short) ((b[off + 1] & 0xFF) +\n+                    (b[off] << 8));\n+        }\n+\n+        static int getInt(byte[] b, int off) {\n+            return ((b[off + 3] & 0xFF)) +\n+                    ((b[off + 2] & 0xFF) << 8) +\n+                    ((b[off + 1] & 0xFF) << 16) +\n+                    ((b[off]) << 24);\n+        }\n+\n+        static float getFloat(byte[] b, int off) {\n+            return Float.intBitsToFloat(getInt(b, off));\n+        }\n+\n+        static long getLong(byte[] b, int off) {\n+            return ((b[off + 7] & 0xFFL)) +\n+                    ((b[off + 6] & 0xFFL) << 8) +\n+                    ((b[off + 5] & 0xFFL) << 16) +\n+                    ((b[off + 4] & 0xFFL) << 24) +\n+                    ((b[off + 3] & 0xFFL) << 32) +\n+                    ((b[off + 2] & 0xFFL) << 40) +\n+                    ((b[off + 1] & 0xFFL) << 48) +\n+                    (((long) b[off]) << 56);\n+        }\n+\n+        static double getDouble(byte[] b, int off) {\n+            return Double.longBitsToDouble(getLong(b, off));\n+        }\n+\n+        \/*\n+         * Methods for packing primitive values into byte arrays starting at given\n+         * offsets.\n+         *\/\n+\n+        static void putChar(byte[] b, int off, char val) {\n+            b[off + 1] = (byte) (val);\n+            b[off] = (byte) (val >>> 8);\n+        }\n+\n+        static void putShort(byte[] b, int off, short val) {\n+            b[off + 1] = (byte) (val);\n+            b[off] = (byte) (val >>> 8);\n+        }\n+\n+        static void putInt(byte[] b, int off, int val) {\n+            b[off + 3] = (byte) (val);\n+            b[off + 2] = (byte) (val >>> 8);\n+            b[off + 1] = (byte) (val >>> 16);\n+            b[off] = (byte) (val >>> 24);\n+        }\n+\n+        static void putFloat(byte[] b, int off, float val) {\n+            putInt(b, off, Float.floatToIntBits(val));\n+        }\n+\n+        static void putLong(byte[] b, int off, long val) {\n+            b[off + 7] = (byte) (val);\n+            b[off + 6] = (byte) (val >>> 8);\n+            b[off + 5] = (byte) (val >>> 16);\n+            b[off + 4] = (byte) (val >>> 24);\n+            b[off + 3] = (byte) (val >>> 32);\n+            b[off + 2] = (byte) (val >>> 40);\n+            b[off + 1] = (byte) (val >>> 48);\n+            b[off] = (byte) (val >>> 56);\n+        }\n+\n+        static void putDouble(byte[] b, int off, double val) {\n+            putLong(b, off, Double.doubleToLongBits(val));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/util\/ByteArrayAccess\/ReadWriteValues.java","additions":470,"deletions":0,"binary":false,"changes":470,"status":"added"}]}