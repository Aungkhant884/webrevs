{"files":[{"patch":"@@ -317,1 +317,1 @@\n-        return ByteArray.getShort(readBuffer);\n+        return ByteArray.getShort(readBuffer, 0);\n@@ -339,1 +339,1 @@\n-        return ByteArray.getUnsignedShort(readBuffer);\n+        return ByteArray.getUnsignedShort(readBuffer, 0);\n@@ -361,1 +361,1 @@\n-        return ByteArray.getChar(readBuffer);\n+        return ByteArray.getChar(readBuffer, 0);\n@@ -383,1 +383,1 @@\n-        return ByteArray.getInt(readBuffer);\n+        return ByteArray.getInt(readBuffer, 0);\n@@ -405,1 +405,1 @@\n-        return ByteArray.getLong(readBuffer);\n+        return ByteArray.getLong(readBuffer, 0);\n@@ -428,1 +428,1 @@\n-        return ByteArray.getFloat(readBuffer);\n+        return ByteArray.getFloat(readBuffer, 0);\n@@ -451,1 +451,1 @@\n-        return ByteArray.getDouble(readBuffer);\n+        return ByteArray.getDouble(readBuffer, 0);\n","filename":"src\/java.base\/share\/classes\/java\/io\/DataInputStream.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-        ByteArray.setUnsignedShort(writeBuffer, v);\n+        ByteArray.setUnsignedShort(writeBuffer, 0, v);\n@@ -190,1 +190,1 @@\n-        ByteArray.setUnsignedShort(writeBuffer, v);\n+        ByteArray.setUnsignedShort(writeBuffer, 0, v);\n@@ -205,1 +205,1 @@\n-        ByteArray.setInt(writeBuffer, v);\n+        ByteArray.setInt(writeBuffer, 0, v);\n@@ -220,1 +220,1 @@\n-        ByteArray.setLong(writeBuffer, v);\n+        ByteArray.setLong(writeBuffer, 0, v);\n@@ -239,1 +239,1 @@\n-        ByteArray.setFloat(writeBuffer, v);\n+        ByteArray.setFloat(writeBuffer, 0, v);\n@@ -258,1 +258,1 @@\n-        ByteArray.setDouble(writeBuffer, v);\n+        ByteArray.setDouble(writeBuffer, 0, v);\n@@ -298,1 +298,1 @@\n-            ByteArray.setUnsignedShort(writeBuffer, v);\n+            ByteArray.setUnsignedShort(writeBuffer, 0, v);\n","filename":"src\/java.base\/share\/classes\/java\/io\/DataOutputStream.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -51,7 +51,0 @@\n-    private static final VarHandle SHORT_AT_ZERO = createAtZeroOffset(short[].class);\n-    private static final VarHandle CHAR_AT_ZERO = createAtZeroOffset(char[].class);\n-    private static final VarHandle INT_AT_ZERO = createAtZeroOffset(int[].class);\n-    private static final VarHandle FLOAT_AT_ZERO = createAtZeroOffset(float[].class);\n-    private static final VarHandle LONG_AT_ZERO = createAtZeroOffset(long[].class);\n-    private static final VarHandle DOUBLE_AT_ZERO = createAtZeroOffset(double[].class);\n-\n@@ -70,1 +63,1 @@\n-     * @see #setBoolean(byte[], boolean)\n+     * @see #setBoolean(byte[], int, boolean)\n@@ -239,136 +232,0 @@\n-    \/*\n-     * Methods for unpacking primitive values from byte arrays starting at\n-     * offset zero.\n-     *\/\n-\n-    \/**\n-     * {@return a {@code boolean} from the provided {@code array} at index 0}.\n-     *\n-     * @param array  to read a value from.\n-     * @throws IndexOutOfBoundsException if {@code array.length < 1}\n-     * @see #setBoolean(byte[], boolean)\n-     *\/\n-    public static boolean getBoolean(byte[] array) {\n-        return array[0] != 0;\n-    }\n-\n-    \/**\n-     * {@return a {@code char} from the provided {@code array} at index 0}.\n-     *\n-     * @param array  to get a value from.\n-     * @throws IndexOutOfBoundsException if {@code array.length < 2}\n-     * @see #setChar(byte[], char)\n-     *\/\n-    public static char getChar(byte[] array) {\n-        return (char) CHAR_AT_ZERO.get(array);\n-    }\n-\n-    \/**\n-     * {@return a {@code short} from the provided {@code array} at index 0}.\n-     *\n-     * @param array  to get a value from.\n-     * @throws IndexOutOfBoundsException if {@code array.length < 2}\n-     * @see #setShort(byte[], short)\n-     *\/\n-    public static short getShort(byte[] array) {\n-        return (short) SHORT_AT_ZERO.get(array);\n-    }\n-\n-    \/**\n-     * {@return an {@code unsigned short} from the provided {@code array} at index 0}.\n-     *\n-     * @param array  to get a value from.\n-     * @throws IndexOutOfBoundsException if {@code array.length < 2}\n-     * @see #setUnsignedShort(byte[], int)\n-     *\/\n-    public static int getUnsignedShort(byte[] array) {\n-        return Short.toUnsignedInt((short) SHORT_AT_ZERO.get(array));\n-    }\n-\n-    \/**\n-     * {@return an {@code int} from the provided {@code array} at index 0}.\n-     *\n-     * @param array  to get a value from.\n-     * @throws IndexOutOfBoundsException if {@code array.length < 4}\n-     * @see #setInt(byte[], int)\n-     *\/\n-    public static int getInt(byte[] array) {\n-        return (int) INT_AT_ZERO.get(array);\n-    }\n-\n-    \/**\n-     * {@return a {@code float} from the provided {@code array} at index 0}.\n-     * <p>\n-     * Variants of {@linkplain Float#NaN } values are canonized to a single NaN value.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to get a value from.\n-     * @throws IndexOutOfBoundsException if {@code array.length < 4}\n-     * @see #setFloat(byte[], float)\n-     *\/\n-    public static float getFloat(byte[] array) {\n-        \/\/ Using Float.intBitsToFloat collapses NaN values to a single\n-        \/\/ \"canonical\" NaN value\n-        return Float.intBitsToFloat((int) INT_AT_ZERO.get(array));\n-    }\n-\n-    \/**\n-     * {@return a {@code float} from the provided {@code array} at index 0}.\n-     * <p>\n-     * Variants of {@linkplain Float#NaN } values are silently read according\n-     * to their bit patterns.\n-     *\n-     * @param array  to get a value from.\n-     * @throws IndexOutOfBoundsException if {@code array.length < 4}\n-     * @see #setFloatRaw(byte[], float)\n-     *\/\n-    public static float getFloatRaw(byte[] array) {\n-        \/\/ Just gets the bits as they are\n-        return (float) FLOAT_AT_ZERO.get(array);\n-    }\n-\n-    \/**\n-     * {@return a {@code long} from the provided {@code array} at index 0}.\n-     *\n-     * @param array  to get a value from.\n-     * @throws IndexOutOfBoundsException if {@code array.length < 8}\n-     * @see #setLong(byte[], long)\n-     *\/\n-    public static long getLong(byte[] array) {\n-        return (long) LONG_AT_ZERO.get(array);\n-    }\n-\n-    \/**\n-     * {@return a {@code double} from the provided {@code array} at index 0}.\n-     * <p>\n-     * Variants of {@linkplain Double#NaN } values are canonized to a single NaN value.\n-     *\n-     * @param array  to get a value from.\n-     * @throws IndexOutOfBoundsException if {@code array.length < 8}\n-     * @see #setDouble(byte[], double)\n-     *\/\n-    public static double getDouble(byte[] array) {\n-        \/\/ Using Double.longBitsToDouble collapses NaN values to a single\n-        \/\/ \"canonical\" NaN value\n-        return Double.longBitsToDouble((long) LONG_AT_ZERO.get(array));\n-    }\n-\n-    \/**\n-     * {@return a {@code double} from the provided {@code array} at the given {@code offset}\n-     * using big endian order}.\n-     * <p>\n-     * Variants of {@linkplain Double#NaN } values are silently read according to\n-     * their bit patterns.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to get a value from.\n-     * @throws IndexOutOfBoundsException if {@code array.length < 8}\n-     * @see #setDoubleRaw(byte[], double)\n-     *\/\n-    public static double getDoubleRaw(byte[] array) {\n-        \/\/ Just gets the bits as they are\n-        return (double) DOUBLE_AT_ZERO.get(array);\n-    }\n-\n@@ -574,175 +431,0 @@\n-\n-    \/*\n-     * Methods for packing primitive values into byte arrays starting at offset zero.\n-     *\/\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} into\n-     * the provided {@code array} beginning at index 0.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param value  value to set in the array\n-     * @throws NullPointerException      if the provided {@code array} is {@code null}\n-     * @throws IndexOutOfBoundsException if {@code array.length < 1}\n-     * @see #getBoolean(byte[])\n-     *\/\n-    public static void setBoolean(byte[] array, boolean value) {\n-        array[0] = (byte) (value ? 1 : 0);\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using big endian order into\n-     * the provided {@code array} beginning at index 0.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param value  value to set in the array\n-     * @throws NullPointerException      if the provided {@code array} is {@code null}\n-     * @throws IndexOutOfBoundsException if {@code array.length < 2}\n-     * @see #getChar(byte[])\n-     *\/\n-    public static void setChar(byte[] array, char value) {\n-        CHAR_AT_ZERO.set(array, value);\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using big endian order into\n-     * the provided {@code array} beginning at index 0.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param value  value to set in the array\n-     * @throws NullPointerException      if the provided {@code array} is {@code null}\n-     * @throws IndexOutOfBoundsException if {@code array.length < 2}\n-     * @see #getShort(byte[])\n-     *\/\n-    public static void setShort(byte[] array, short value) {\n-        SHORT_AT_ZERO.set(array, value);\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using big endian order into\n-     * the provided {@code array} beginning at index 0.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param value  value to set in the array\n-     * @throws NullPointerException      if the provided {@code array} is {@code null}\n-     * @throws IndexOutOfBoundsException if {@code array.length < 2}\n-     * @see #getUnsignedShort(byte[])\n-     *\/\n-    public static void setUnsignedShort(byte[] array, int value) {\n-        SHORT_AT_ZERO.set(array, (short) (char) value);\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using big endian order into\n-     * the provided {@code array} beginning at index 0.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param value  value to set in the array\n-     * @throws NullPointerException      if the provided {@code array} is {@code null}\n-     * @throws IndexOutOfBoundsException if {@code array.length < 4}\n-     * @see #getInt(byte[])\n-     *\/\n-    public static void setInt(byte[] array, int value) {\n-        INT_AT_ZERO.set(array, value);\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using big endian order into\n-     * the provided {@code array} beginning at index 0.\n-     * <p>\n-     * Variants of {@linkplain Float#NaN } values are canonized to a single NaN value.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param value  value to set in the array\n-     * @throws NullPointerException      if the provided {@code array} is {@code null}\n-     * @throws IndexOutOfBoundsException if {@code array.length < 4}\n-     * @see #getFloat(byte[])\n-     *\/\n-    public static void setFloat(byte[] array, float value) {\n-        \/\/ Using Float.floatToIntBits collapses NaN values to a single\n-        \/\/ \"canonical\" NaN value\n-        INT_AT_ZERO.set(array, Float.floatToIntBits(value));\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using big endian order into\n-     * the provided {@code array} beginning at index 0.\n-     * <p>\n-     * Variants of {@linkplain Float#NaN } values are silently written according to\n-     * their bit patterns.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param value  value to set in the array\n-     * @throws NullPointerException      if the provided {@code array} is {@code null}\n-     * @throws IndexOutOfBoundsException if {@code array.length < 4}\n-     * @see #getFloatRaw(byte[])\n-     *\/\n-    public static void setFloatRaw(byte[] array, float value) {\n-        \/\/ Just sets the bits as they are\n-        FLOAT_AT_ZERO.set(array, value);\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using big endian order into\n-     * the provided {@code array} beginning at index 0.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param value  value to set in the array\n-     * @throws NullPointerException      if the provided {@code array} is {@code null}\n-     * @throws IndexOutOfBoundsException if {@code array.length < 8}\n-     * @see #getLong(byte[])\n-     *\/\n-    public static void setLong(byte[] array, long value) {\n-        LONG_AT_ZERO.set(array, value);\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using big endian order into\n-     * the provided {@code array} beginning at index 0.\n-     * <p>\n-     * Variants of {@linkplain Double#NaN } values are canonized to a single NaN value.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param value  value to set in the array\n-     * @throws NullPointerException      if the provided {@code array} is {@code null}\n-     * @throws IndexOutOfBoundsException if {@code array.length < 8}\n-     * @see #getDoubleRaw(byte[])\n-     *\/\n-    public static void setDouble(byte[] array, double value) {\n-        \/\/ Using Double.doubleToLongBits collapses NaN values to a single\n-        \/\/ \"canonical\" NaN value\n-        LONG_AT_ZERO.set(array, Double.doubleToLongBits(value));\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using big endian order into\n-     * the provided {@code array} beginning at index 0.\n-     * <p>\n-     * Variants of {@linkplain Double#NaN } values are silently written according to\n-     * their bit patterns.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param value  value to set in the array\n-     * @throws NullPointerException      if the provided {@code array} is {@code null}\n-     * @throws IndexOutOfBoundsException if {@code array.length < 8}\n-     * @see #getDoubleRaw(byte[])\n-     *\/\n-    public static void setDoubleRaw(byte[] array, double value) {\n-        \/\/ Just sets the bits as they are\n-        DOUBLE_AT_ZERO.set(array, value);\n-    }\n-\n-    private static VarHandle createAtZeroOffset(Class<?> viewArrayClass) {\n-        var original = create(viewArrayClass);\n-        \/\/ (byte[] array, int offset, ...) -> { offset = 0 } -> (byte[], ...)\n-        return MethodHandles.insertCoordinates(original, 1, 0);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ByteArray.java","additions":1,"deletions":319,"binary":false,"changes":320,"status":"modified"}]}