{"files":[{"patch":"@@ -28,1 +28,1 @@\n-import jdk.internal.util.access.ByteArrayAccess;\n+import jdk.internal.util.ByteArray;\n@@ -317,1 +317,1 @@\n-        return ByteArrayAccess.getShort(readBuffer);\n+        return ByteArray.getShort(readBuffer);\n@@ -339,1 +339,1 @@\n-        return ByteArrayAccess.getUnsignedShort(readBuffer);\n+        return ByteArray.getUnsignedShort(readBuffer);\n@@ -361,1 +361,1 @@\n-        return ByteArrayAccess.getChar(readBuffer);\n+        return ByteArray.getChar(readBuffer);\n@@ -383,1 +383,1 @@\n-        return ByteArrayAccess.getInt(readBuffer);\n+        return ByteArray.getInt(readBuffer);\n@@ -405,1 +405,1 @@\n-        return ByteArrayAccess.getLong(readBuffer);\n+        return ByteArray.getLong(readBuffer);\n@@ -428,1 +428,1 @@\n-        return ByteArrayAccess.getFloat(readBuffer);\n+        return ByteArray.getFloat(readBuffer);\n@@ -451,1 +451,1 @@\n-        return ByteArrayAccess.getDouble(readBuffer);\n+        return ByteArray.getDouble(readBuffer);\n","filename":"src\/java.base\/share\/classes\/java\/io\/DataInputStream.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.internal.util.access.ByteArrayAccess;\n+import jdk.internal.util.ByteArray;\n@@ -175,1 +175,1 @@\n-        ByteArrayAccess.setUnsignedShort(writeBuffer, v);\n+        ByteArray.setUnsignedShort(writeBuffer, v);\n@@ -190,1 +190,1 @@\n-        ByteArrayAccess.setUnsignedShort(writeBuffer, v);\n+        ByteArray.setUnsignedShort(writeBuffer, v);\n@@ -205,1 +205,1 @@\n-        ByteArrayAccess.setInt(writeBuffer, v);\n+        ByteArray.setInt(writeBuffer, v);\n@@ -220,1 +220,1 @@\n-        ByteArrayAccess.setLong(writeBuffer, v);\n+        ByteArray.setLong(writeBuffer, v);\n@@ -239,1 +239,1 @@\n-        ByteArrayAccess.setFloat(writeBuffer, v);\n+        ByteArray.setFloat(writeBuffer, v);\n@@ -258,1 +258,1 @@\n-        ByteArrayAccess.setDouble(writeBuffer, v);\n+        ByteArray.setDouble(writeBuffer, v);\n@@ -298,1 +298,1 @@\n-            ByteArrayAccess.setUnsignedShort(writeBuffer, v);\n+            ByteArray.setUnsignedShort(writeBuffer, v);\n@@ -375,1 +375,1 @@\n-        ByteArrayAccess.setUnsignedShort(bytearr, count, utflen);\n+        ByteArray.setUnsignedShort(bytearr, count, utflen);\n","filename":"src\/java.base\/share\/classes\/java\/io\/DataOutputStream.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-import jdk.internal.util.access.ByteArrayAccess;\n+import jdk.internal.util.ByteArray;\n@@ -2635,1 +2635,1 @@\n-            return (off >= 0) ? ByteArrayAccess.getBoolean(primValues, off) : val;\n+            return (off >= 0) ? ByteArray.getBoolean(primValues, off) : val;\n@@ -2645,1 +2645,1 @@\n-            return (off >= 0) ? ByteArrayAccess.getChar(primValues, off) : val;\n+            return (off >= 0) ? ByteArray.getChar(primValues, off) : val;\n@@ -2650,1 +2650,1 @@\n-            return (off >= 0) ? ByteArrayAccess.getShort(primValues, off) : val;\n+            return (off >= 0) ? ByteArray.getShort(primValues, off) : val;\n@@ -2655,1 +2655,1 @@\n-            return (off >= 0) ? ByteArrayAccess.getInt(primValues, off) : val;\n+            return (off >= 0) ? ByteArray.getInt(primValues, off) : val;\n@@ -2660,1 +2660,1 @@\n-            return (off >= 0) ? ByteArrayAccess.getFloat(primValues, off) : val;\n+            return (off >= 0) ? ByteArray.getFloat(primValues, off) : val;\n@@ -2665,1 +2665,1 @@\n-            return (off >= 0) ? ByteArrayAccess.getLong(primValues, off) : val;\n+            return (off >= 0) ? ByteArray.getLong(primValues, off) : val;\n@@ -2670,1 +2670,1 @@\n-            return (off >= 0) ? ByteArrayAccess.getDouble(primValues, off) : val;\n+            return (off >= 0) ? ByteArray.getDouble(primValues, off) : val;\n@@ -3118,1 +3118,1 @@\n-                            int len = ByteArrayAccess.getInt(hbuf, 1);\n+                            int len = ByteArray.getInt(hbuf, 1);\n@@ -3417,1 +3417,1 @@\n-            char v = ByteArrayAccess.getChar(buf, pos);\n+            char v = ByteArray.getChar(buf, pos);\n@@ -3429,1 +3429,1 @@\n-            short v = ByteArrayAccess.getShort(buf, pos);\n+            short v = ByteArray.getShort(buf, pos);\n@@ -3441,1 +3441,1 @@\n-            int v = ByteArrayAccess.getShort(buf, pos) & 0xFFFF;\n+            int v = ByteArray.getShort(buf, pos) & 0xFFFF;\n@@ -3453,1 +3453,1 @@\n-            int v = ByteArrayAccess.getInt(buf, pos);\n+            int v = ByteArray.getInt(buf, pos);\n@@ -3465,1 +3465,1 @@\n-            float v = ByteArrayAccess.getFloat(buf, pos);\n+            float v = ByteArray.getFloat(buf, pos);\n@@ -3477,1 +3477,1 @@\n-            long v = ByteArrayAccess.getLong(buf, pos);\n+            long v = ByteArray.getLong(buf, pos);\n@@ -3489,1 +3489,1 @@\n-            double v = ByteArrayAccess.getDouble(buf, pos);\n+            double v = ByteArray.getDouble(buf, pos);\n@@ -3527,1 +3527,1 @@\n-                    v[off++] = ByteArrayAccess.getBoolean(buf, pos++);\n+                    v[off++] = ByteArray.getBoolean(buf, pos++);\n@@ -3548,1 +3548,1 @@\n-                    v[off++] = ByteArrayAccess.getChar(buf, pos);\n+                    v[off++] = ByteArray.getChar(buf, pos);\n@@ -3570,1 +3570,1 @@\n-                    v[off++] = ByteArrayAccess.getShort(buf, pos);\n+                    v[off++] = ByteArray.getShort(buf, pos);\n@@ -3592,1 +3592,1 @@\n-                    v[off++] = ByteArrayAccess.getInt(buf, pos);\n+                    v[off++] = ByteArray.getInt(buf, pos);\n@@ -3614,1 +3614,1 @@\n-                    v[off++] = ByteArrayAccess.getFloat(buf, pos);\n+                    v[off++] = ByteArray.getFloat(buf, pos);\n@@ -3636,1 +3636,1 @@\n-                    v[off++] = ByteArrayAccess.getLong(buf, pos);\n+                    v[off++] = ByteArray.getLong(buf, pos);\n@@ -3658,1 +3658,1 @@\n-                    v[off++] = ByteArrayAccess.getDouble(buf, pos);\n+                    v[off++] = ByteArray.getDouble(buf, pos);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import jdk.internal.util.access.ByteArrayAccess;\n+import jdk.internal.util.ByteArray;\n@@ -1643,1 +1643,1 @@\n-            ByteArrayAccess.setBoolean(primVals, getFieldOffset(name, Boolean.TYPE), val);\n+            ByteArray.setBoolean(primVals, getFieldOffset(name, Boolean.TYPE), val);\n@@ -1651,1 +1651,1 @@\n-            ByteArrayAccess.setChar(primVals, getFieldOffset(name, Character.TYPE), val);\n+            ByteArray.setChar(primVals, getFieldOffset(name, Character.TYPE), val);\n@@ -1655,1 +1655,1 @@\n-            ByteArrayAccess.setShort(primVals, getFieldOffset(name, Short.TYPE), val);\n+            ByteArray.setShort(primVals, getFieldOffset(name, Short.TYPE), val);\n@@ -1659,1 +1659,1 @@\n-            ByteArrayAccess.setInt(primVals, getFieldOffset(name, Integer.TYPE), val);\n+            ByteArray.setInt(primVals, getFieldOffset(name, Integer.TYPE), val);\n@@ -1663,1 +1663,1 @@\n-            ByteArrayAccess.setFloat(primVals, getFieldOffset(name, Float.TYPE), val);\n+            ByteArray.setFloat(primVals, getFieldOffset(name, Float.TYPE), val);\n@@ -1667,1 +1667,1 @@\n-            ByteArrayAccess.setLong(primVals, getFieldOffset(name, Long.TYPE), val);\n+            ByteArray.setLong(primVals, getFieldOffset(name, Long.TYPE), val);\n@@ -1671,1 +1671,1 @@\n-            ByteArrayAccess.setDouble(primVals, getFieldOffset(name, Double.TYPE), val);\n+            ByteArray.setDouble(primVals, getFieldOffset(name, Double.TYPE), val);\n@@ -1913,1 +1913,1 @@\n-                ByteArrayAccess.setInt(hbuf, 1, len);\n+                ByteArray.setInt(hbuf, 1, len);\n@@ -1930,1 +1930,1 @@\n-            ByteArrayAccess.setBoolean(buf, pos++, v);\n+            ByteArray.setBoolean(buf, pos++, v);\n@@ -1942,1 +1942,1 @@\n-                ByteArrayAccess.setChar(buf, pos, (char) v);\n+                ByteArray.setChar(buf, pos, (char) v);\n@@ -1951,1 +1951,1 @@\n-                ByteArrayAccess.setShort(buf, pos, (short) v);\n+                ByteArray.setShort(buf, pos, (short) v);\n@@ -1960,1 +1960,1 @@\n-                ByteArrayAccess.setInt(buf, pos, v);\n+                ByteArray.setInt(buf, pos, v);\n@@ -1969,1 +1969,1 @@\n-                ByteArrayAccess.setFloat(buf, pos, v);\n+                ByteArray.setFloat(buf, pos, v);\n@@ -1978,1 +1978,1 @@\n-                ByteArrayAccess.setLong(buf, pos, v);\n+                ByteArray.setLong(buf, pos, v);\n@@ -1987,1 +1987,1 @@\n-                ByteArrayAccess.setDouble(buf, pos, v);\n+                ByteArray.setDouble(buf, pos, v);\n@@ -2047,1 +2047,1 @@\n-                    ByteArrayAccess.setBoolean(buf, pos++, v[off++]);\n+                    ByteArray.setBoolean(buf, pos++, v[off++]);\n@@ -2060,1 +2060,1 @@\n-                        ByteArrayAccess.setChar(buf, pos, v[off++]);\n+                        ByteArray.setChar(buf, pos, v[off++]);\n@@ -2077,1 +2077,1 @@\n-                        ByteArrayAccess.setShort(buf, pos, v[off++]);\n+                        ByteArray.setShort(buf, pos, v[off++]);\n@@ -2094,1 +2094,1 @@\n-                        ByteArrayAccess.setInt(buf, pos, v[off++]);\n+                        ByteArray.setInt(buf, pos, v[off++]);\n@@ -2111,1 +2111,1 @@\n-                        ByteArrayAccess.setFloat(buf, pos, v[off++]);\n+                        ByteArray.setFloat(buf, pos, v[off++]);\n@@ -2128,1 +2128,1 @@\n-                        ByteArrayAccess.setLong(buf, pos, v[off++]);\n+                        ByteArray.setLong(buf, pos, v[off++]);\n@@ -2145,1 +2145,1 @@\n-                        ByteArrayAccess.setDouble(buf, pos, v[off++]);\n+                        ByteArray.setDouble(buf, pos, v[off++]);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-import jdk.internal.util.access.ByteArrayAccess;\n+import jdk.internal.util.ByteArray;\n@@ -1990,1 +1990,1 @@\n-                    case 'Z' -> ByteArrayAccess.setBoolean(buf, off, unsafe.getBoolean(obj, key));\n+                    case 'Z' -> ByteArray.setBoolean(buf, off, unsafe.getBoolean(obj, key));\n@@ -1992,6 +1992,6 @@\n-                    case 'C' -> ByteArrayAccess.setChar(buf, off, unsafe.getChar(obj, key));\n-                    case 'S' -> ByteArrayAccess.setShort(buf, off, unsafe.getShort(obj, key));\n-                    case 'I' -> ByteArrayAccess.setInt(buf, off, unsafe.getInt(obj, key));\n-                    case 'F' -> ByteArrayAccess.setFloat(buf, off, unsafe.getFloat(obj, key));\n-                    case 'J' -> ByteArrayAccess.setLong(buf, off, unsafe.getLong(obj, key));\n-                    case 'D' -> ByteArrayAccess.setDouble(buf, off, unsafe.getDouble(obj, key));\n+                    case 'C' -> ByteArray.setChar(buf, off, unsafe.getChar(obj, key));\n+                    case 'S' -> ByteArray.setShort(buf, off, unsafe.getShort(obj, key));\n+                    case 'I' -> ByteArray.setInt(buf, off, unsafe.getInt(obj, key));\n+                    case 'F' -> ByteArray.setFloat(buf, off, unsafe.getFloat(obj, key));\n+                    case 'J' -> ByteArray.setLong(buf, off, unsafe.getLong(obj, key));\n+                    case 'D' -> ByteArray.setDouble(buf, off, unsafe.getDouble(obj, key));\n@@ -2019,1 +2019,1 @@\n-                    case 'Z' -> unsafe.putBoolean(obj, key, ByteArrayAccess.getBoolean(buf, off));\n+                    case 'Z' -> unsafe.putBoolean(obj, key, ByteArray.getBoolean(buf, off));\n@@ -2021,6 +2021,6 @@\n-                    case 'C' -> unsafe.putChar(obj, key, ByteArrayAccess.getChar(buf, off));\n-                    case 'S' -> unsafe.putShort(obj, key, ByteArrayAccess.getShort(buf, off));\n-                    case 'I' -> unsafe.putInt(obj, key, ByteArrayAccess.getInt(buf, off));\n-                    case 'F' -> unsafe.putFloat(obj, key, ByteArrayAccess.getFloat(buf, off));\n-                    case 'J' -> unsafe.putLong(obj, key, ByteArrayAccess.getLong(buf, off));\n-                    case 'D' -> unsafe.putDouble(obj, key, ByteArrayAccess.getDouble(buf, off));\n+                    case 'C' -> unsafe.putChar(obj, key, ByteArray.getChar(buf, off));\n+                    case 'S' -> unsafe.putShort(obj, key, ByteArray.getShort(buf, off));\n+                    case 'I' -> unsafe.putInt(obj, key, ByteArray.getInt(buf, off));\n+                    case 'F' -> unsafe.putFloat(obj, key, ByteArray.getFloat(buf, off));\n+                    case 'J' -> unsafe.putLong(obj, key, ByteArray.getLong(buf, off));\n+                    case 'D' -> unsafe.putDouble(obj, key, ByteArray.getDouble(buf, off));\n@@ -2477,7 +2477,7 @@\n-                    short.class, lkp.findStatic(ByteArrayAccess.class, \"getShort\", MethodType.methodType(short.class, byte[].class, int.class)),\n-                    int.class, lkp.findStatic(ByteArrayAccess.class, \"getInt\", MethodType.methodType(int.class, byte[].class, int.class)),\n-                    long.class, lkp.findStatic(ByteArrayAccess.class, \"getLong\", MethodType.methodType(long.class, byte[].class, int.class)),\n-                    float.class, lkp.findStatic(ByteArrayAccess.class, \"getFloat\", MethodType.methodType(float.class, byte[].class, int.class)),\n-                    double.class, lkp.findStatic(ByteArrayAccess.class, \"getDouble\", MethodType.methodType(double.class, byte[].class, int.class)),\n-                    char.class, lkp.findStatic(ByteArrayAccess.class, \"getChar\", MethodType.methodType(char.class, byte[].class, int.class)),\n-                    boolean.class, lkp.findStatic(ByteArrayAccess.class, \"getBoolean\", MethodType.methodType(boolean.class, byte[].class, int.class))\n+                    short.class, lkp.findStatic(ByteArray.class, \"getShort\", MethodType.methodType(short.class, byte[].class, int.class)),\n+                    int.class, lkp.findStatic(ByteArray.class, \"getInt\", MethodType.methodType(int.class, byte[].class, int.class)),\n+                    long.class, lkp.findStatic(ByteArray.class, \"getLong\", MethodType.methodType(long.class, byte[].class, int.class)),\n+                    float.class, lkp.findStatic(ByteArray.class, \"getFloat\", MethodType.methodType(float.class, byte[].class, int.class)),\n+                    double.class, lkp.findStatic(ByteArray.class, \"getDouble\", MethodType.methodType(double.class, byte[].class, int.class)),\n+                    char.class, lkp.findStatic(ByteArray.class, \"getChar\", MethodType.methodType(char.class, byte[].class, int.class)),\n+                    boolean.class, lkp.findStatic(ByteArray.class, \"getBoolean\", MethodType.methodType(boolean.class, byte[].class, int.class))\n@@ -2486,1 +2486,1 @@\n-                throw new InternalError(\"Can't lookup ByteArrayAccess.getXXX\", e);\n+                throw new InternalError(\"Can't lookup \" + ByteArray.class.getName() + \".getXXX\", e);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import jdk.internal.util.access.ByteArrayAccess;\n+import jdk.internal.util.ByteArray;\n@@ -888,1 +888,1 @@\n-        return ByteArrayAccess.getInt(buffer);\n+        return ByteArray.getInt(buffer);\n@@ -921,1 +921,1 @@\n-        return ByteArrayAccess.getLong(buffer);\n+        return ByteArray.getLong(buffer);\n@@ -945,1 +945,1 @@\n-        return ByteArrayAccess.getFloat(buffer);\n+        return ByteArray.getFloat(buffer);\n@@ -969,1 +969,1 @@\n-        return ByteArrayAccess.getDouble(buffer);\n+        return ByteArray.getDouble(buffer);\n@@ -1108,1 +1108,1 @@\n-        ByteArrayAccess.setInt(buffer, v);\n+        ByteArray.setInt(buffer, v);\n@@ -1121,1 +1121,1 @@\n-        ByteArrayAccess.setLong(buffer, v);\n+        ByteArray.setLong(buffer, v);\n@@ -1137,1 +1137,1 @@\n-        ByteArrayAccess.setFloat(buffer, v);\n+        ByteArray.setFloat(buffer, v);\n@@ -1153,1 +1153,1 @@\n-        ByteArrayAccess.setDouble(buffer, v);\n+        ByteArray.setDouble(buffer, v);\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.internal.util.access;\n+package jdk.internal.util;\n@@ -39,1 +39,1 @@\n-public final class ByteArrayAccess {\n+public final class ByteArray {\n@@ -41,1 +41,1 @@\n-    private ByteArrayAccess() {\n+    private ByteArray() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ByteArray.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/access\/ByteArrayAccess.java","status":"renamed"},{"patch":"@@ -0,0 +1,470 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8299576\n+ * @modules java.base\/jdk.internal.util\n+ * @summary Verify that reads and writes of primitives are correct\n+ * @run junit ReadWriteValues\n+ *\/\n+\n+import jdk.internal.util.ByteArray;\n+import org.junit.jupiter.api.*;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class ReadWriteValues {\n+\n+    \/\/ Makes sure unaligned read\/write can be made.\n+    private static final int OFFSET = 1;\n+\n+    private static final byte[] BUFF = new byte[Long.BYTES + OFFSET];\n+\n+    private static final int ITERATIONS = 1 << 10;\n+\n+    @Test\n+    void testGetShort() {\n+        longs().forEach(l -> {\n+            short expected = (short) l;\n+            RefImpl.putShort(BUFF, OFFSET, expected);\n+            short actual = ByteArray.getShort(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutShort() {\n+        longs().forEach(l -> {\n+            short expected = (short) l;\n+            ByteArray.setShort(BUFF, OFFSET, expected);\n+            short actual = RefImpl.getShort(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetChar() {\n+        longs().forEach(l -> {\n+            char expected = (char) l;\n+            RefImpl.putChar(BUFF, OFFSET, expected);\n+            char actual = ByteArray.getChar(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutChar() {\n+        longs().forEach(l -> {\n+            char expected = (char) l;\n+            ByteArray.setChar(BUFF, OFFSET, expected);\n+            char actual = RefImpl.getChar(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetInt() {\n+        longs().forEach(l -> {\n+            int expected = (int) l;\n+            RefImpl.putInt(BUFF, OFFSET, expected);\n+            int actual = ByteArray.getInt(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutInt() {\n+        longs().forEach(l -> {\n+            int expected = (int) l;\n+            ByteArray.setInt(BUFF, OFFSET, expected);\n+            int actual = RefImpl.getInt(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetLong() {\n+        longs().forEach(expected -> {\n+            RefImpl.putLong(BUFF, OFFSET, expected);\n+            long actual = ByteArray.getLong(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutLong() {\n+        longs().forEach(expected -> {\n+            ByteArray.setLong(BUFF, OFFSET, expected);\n+            long actual = RefImpl.getLong(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetFloat() {\n+        floats().forEach(expected -> {\n+            RefImpl.putFloat(BUFF, OFFSET, expected);\n+            float actual = ByteArray.getFloat(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutFloat() {\n+        floats().forEach(expected -> {\n+            ByteArray.setFloat(BUFF, OFFSET, expected);\n+            float actual = RefImpl.getFloat(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetDouble() {\n+        doubles().forEach(expected -> {\n+            RefImpl.putDouble(BUFF, OFFSET, expected);\n+            double actual = ByteArray.getDouble(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutDouble() {\n+        doubles().forEach(expected -> {\n+            ByteArray.setDouble(BUFF, OFFSET, expected);\n+            double actual = RefImpl.getDouble(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutUnsignedShort() {\n+        longs().forEach(l -> {\n+            int expected = Short.toUnsignedInt((short) l);\n+            ByteArray.setUnsignedShort(BUFF, OFFSET, expected);\n+            int actual = Short.toUnsignedInt(RefImpl.getShort(BUFF, OFFSET));\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+\n+    \/\/ Unusual cases\n+\n+    @Test\n+    void testNullArray() {\n+        assertThrowsOriginal(NullPointerException.class, () -> ByteArray.getInt(null, OFFSET));\n+        assertThrowsOriginal(NullPointerException.class, () -> ByteArray.setInt(null, OFFSET, 1));\n+    }\n+\n+    @Test\n+    void testNegArg() {\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArray.getInt(BUFF, -1));\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArray.setInt(BUFF, -1, 1));\n+    }\n+\n+    @Test\n+    void testOutOfBounds() {\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArray.getInt(BUFF, BUFF.length));\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArray.setInt(BUFF, BUFF.length, 1));\n+    }\n+\n+    \/\/ At-zero methods\n+\n+    @Test\n+    void testGetShortAtZero() {\n+        longs().forEach(l -> {\n+            short expected = (short) l;\n+            RefImpl.putShort(BUFF, 0, expected);\n+            short actual = ByteArray.getShort(BUFF);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutShortAtZero() {\n+        longs().forEach(l -> {\n+            short expected = (short) l;\n+            ByteArray.setShort(BUFF, expected);\n+            short actual = RefImpl.getShort(BUFF, 0);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetCharAtZero() {\n+        longs().forEach(l -> {\n+            char expected = (char) l;\n+            RefImpl.putChar(BUFF, 0, expected);\n+            char actual = ByteArray.getChar(BUFF);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutCharAtZero() {\n+        longs().forEach(l -> {\n+            char expected = (char) l;\n+            ByteArray.setChar(BUFF, expected);\n+            char actual = RefImpl.getChar(BUFF, 0);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetIntAtZero() {\n+        longs().forEach(l -> {\n+            int expected = (int) l;\n+            RefImpl.putInt(BUFF, 0, expected);\n+            int actual = ByteArray.getInt(BUFF);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutIntAtZero() {\n+        longs().forEach(l -> {\n+            int expected = (int) l;\n+            ByteArray.setInt(BUFF, expected);\n+            int actual = RefImpl.getInt(BUFF, 0);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetLongAtZero() {\n+        longs().forEach(expected -> {\n+            RefImpl.putLong(BUFF, 0, expected);\n+            long actual = ByteArray.getLong(BUFF);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutLongAtZero() {\n+        longs().forEach(expected -> {\n+            ByteArray.setLong(BUFF, expected);\n+            long actual = RefImpl.getLong(BUFF, 0);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetFloatAtZero() {\n+        floats().forEach(expected -> {\n+            RefImpl.putFloat(BUFF, 0, expected);\n+            float actual = ByteArray.getFloat(BUFF);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutFloatAtZero() {\n+        floats().forEach(expected -> {\n+            ByteArray.setFloat(BUFF, expected);\n+            float actual = RefImpl.getFloat(BUFF, 0);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetDoubleAtZero() {\n+        doubles().forEach(expected -> {\n+            RefImpl.putDouble(BUFF, 0, expected);\n+            double actual = ByteArray.getDouble(BUFF);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutDoubleAtZero() {\n+        doubles().forEach(expected -> {\n+            ByteArray.setDouble(BUFF, expected);\n+            double actual = RefImpl.getDouble(BUFF, 0);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutUnsignedShortAtZero() {\n+        longs().forEach(l -> {\n+            int expected = Short.toUnsignedInt((short) l);\n+            ByteArray.setUnsignedShort(BUFF, expected);\n+            int actual = Short.toUnsignedInt(RefImpl.getShort(BUFF, 0));\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    \/\/ Unusual cases\n+\n+    @Test\n+    void testNullArrayAtZero() {\n+        assertThrowsOriginal(NullPointerException.class, () -> ByteArray.getInt(null));\n+        assertThrowsOriginal(NullPointerException.class, () -> ByteArray.setInt(null, 1));\n+    }\n+\n+    @Test\n+    void testOutOfBoundsAtZero() {\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArray.getInt(new byte[1]));\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArray.setInt(new byte[1],1));\n+    }\n+\n+\n+    static LongStream longs() {\n+        return ThreadLocalRandom.current().longs(ITERATIONS);\n+    }\n+\n+    static DoubleStream doubles() {\n+        return DoubleStream.concat(\n+                ThreadLocalRandom.current().doubles(ITERATIONS),\n+                DoubleStream.of(Double.NaN,\n+                        Double.NEGATIVE_INFINITY,\n+                        Double.POSITIVE_INFINITY,\n+                        Double.MAX_VALUE,\n+                        Double.MIN_VALUE,\n+                        -0.0d\n+                        +0.0d)\n+        );\n+    }\n+    static Stream<Float> floats() {\n+        return Stream.concat(\n+                ThreadLocalRandom.current().doubles(ITERATIONS).mapToObj(d -> (float)d),\n+                Stream.of(Float.NaN,\n+                        Float.NEGATIVE_INFINITY,\n+                        Float.POSITIVE_INFINITY,\n+                        Float.MAX_VALUE,\n+                        Float.MIN_VALUE,\n+                        -0.0f\n+                        +0.0f)\n+        );\n+    }\n+\n+    @FunctionalInterface\n+    interface ThrowingRunnable {\n+        void run() throws Exception;\n+    }\n+\n+    <X extends Exception> void assertThrowsOriginal(Class<X> type,\n+                                                    ThrowingRunnable runnable) {\n+        try {\n+            runnable.run();\n+        } catch (Exception e) {\n+            if (type.isInstance(e)) {\n+                return;\n+            }\n+            if (type.isInstance(e.getCause())) {\n+                return;\n+            }\n+            throw new AssertionError(e);\n+        }\n+\n+    }\n+\n+    \/**\n+    * Reference implementation from the old java.io.Bits implementation\n+    *\/\n+    private static final class RefImpl {\n+        private RefImpl() {}\n+\n+        static char getChar(byte[] b, int off) {\n+            return (char) ((b[off + 1] & 0xFF) +\n+                    (b[off] << 8));\n+        }\n+\n+        static short getShort(byte[] b, int off) {\n+            return (short) ((b[off + 1] & 0xFF) +\n+                    (b[off] << 8));\n+        }\n+\n+        static int getInt(byte[] b, int off) {\n+            return ((b[off + 3] & 0xFF)) +\n+                    ((b[off + 2] & 0xFF) << 8) +\n+                    ((b[off + 1] & 0xFF) << 16) +\n+                    ((b[off]) << 24);\n+        }\n+\n+        static float getFloat(byte[] b, int off) {\n+            return Float.intBitsToFloat(getInt(b, off));\n+        }\n+\n+        static long getLong(byte[] b, int off) {\n+            return ((b[off + 7] & 0xFFL)) +\n+                    ((b[off + 6] & 0xFFL) << 8) +\n+                    ((b[off + 5] & 0xFFL) << 16) +\n+                    ((b[off + 4] & 0xFFL) << 24) +\n+                    ((b[off + 3] & 0xFFL) << 32) +\n+                    ((b[off + 2] & 0xFFL) << 40) +\n+                    ((b[off + 1] & 0xFFL) << 48) +\n+                    (((long) b[off]) << 56);\n+        }\n+\n+        static double getDouble(byte[] b, int off) {\n+            return Double.longBitsToDouble(getLong(b, off));\n+        }\n+\n+        \/*\n+         * Methods for packing primitive values into byte arrays starting at given\n+         * offsets.\n+         *\/\n+\n+        static void putChar(byte[] b, int off, char val) {\n+            b[off + 1] = (byte) (val);\n+            b[off] = (byte) (val >>> 8);\n+        }\n+\n+        static void putShort(byte[] b, int off, short val) {\n+            b[off + 1] = (byte) (val);\n+            b[off] = (byte) (val >>> 8);\n+        }\n+\n+        static void putInt(byte[] b, int off, int val) {\n+            b[off + 3] = (byte) (val);\n+            b[off + 2] = (byte) (val >>> 8);\n+            b[off + 1] = (byte) (val >>> 16);\n+            b[off] = (byte) (val >>> 24);\n+        }\n+\n+        static void putFloat(byte[] b, int off, float val) {\n+            putInt(b, off, Float.floatToIntBits(val));\n+        }\n+\n+        static void putLong(byte[] b, int off, long val) {\n+            b[off + 7] = (byte) (val);\n+            b[off + 6] = (byte) (val >>> 8);\n+            b[off + 5] = (byte) (val >>> 16);\n+            b[off + 4] = (byte) (val >>> 24);\n+            b[off + 3] = (byte) (val >>> 32);\n+            b[off + 2] = (byte) (val >>> 40);\n+            b[off + 1] = (byte) (val >>> 48);\n+            b[off] = (byte) (val >>> 56);\n+        }\n+\n+        static void putDouble(byte[] b, int off, double val) {\n+            putLong(b, off, Double.doubleToLongBits(val));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/util\/ByteArray\/ReadWriteValues.java","additions":470,"deletions":0,"binary":false,"changes":470,"status":"added"},{"patch":"@@ -1,470 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8299576\n- * @modules java.base\/jdk.internal.util\n- * @summary Verify that reads and writes of primitives are correct\n- * @run junit ReadWriteValues\n- *\/\n-\n-import jdk.internal.util.access.ByteArrayAccess;\n-import org.junit.jupiter.api.*;\n-\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.stream.DoubleStream;\n-import java.util.stream.LongStream;\n-import java.util.stream.Stream;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-final class ReadWriteValues {\n-\n-    \/\/ Makes sure unaligned read\/write can be made.\n-    private static final int OFFSET = 1;\n-\n-    private static final byte[] BUFF = new byte[Long.BYTES + OFFSET];\n-\n-    private static final int ITERATIONS = 1 << 10;\n-\n-    @Test\n-    void testGetShort() {\n-        longs().forEach(l -> {\n-            short expected = (short) l;\n-            RefImpl.putShort(BUFF, OFFSET, expected);\n-            short actual = ByteArrayAccess.getShort(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutShort() {\n-        longs().forEach(l -> {\n-            short expected = (short) l;\n-            ByteArrayAccess.setShort(BUFF, OFFSET, expected);\n-            short actual = RefImpl.getShort(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testGetChar() {\n-        longs().forEach(l -> {\n-            char expected = (char) l;\n-            RefImpl.putChar(BUFF, OFFSET, expected);\n-            char actual = ByteArrayAccess.getChar(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutChar() {\n-        longs().forEach(l -> {\n-            char expected = (char) l;\n-            ByteArrayAccess.setChar(BUFF, OFFSET, expected);\n-            char actual = RefImpl.getChar(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testGetInt() {\n-        longs().forEach(l -> {\n-            int expected = (int) l;\n-            RefImpl.putInt(BUFF, OFFSET, expected);\n-            int actual = ByteArrayAccess.getInt(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutInt() {\n-        longs().forEach(l -> {\n-            int expected = (int) l;\n-            ByteArrayAccess.setInt(BUFF, OFFSET, expected);\n-            int actual = RefImpl.getInt(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testGetLong() {\n-        longs().forEach(expected -> {\n-            RefImpl.putLong(BUFF, OFFSET, expected);\n-            long actual = ByteArrayAccess.getLong(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutLong() {\n-        longs().forEach(expected -> {\n-            ByteArrayAccess.setLong(BUFF, OFFSET, expected);\n-            long actual = RefImpl.getLong(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testGetFloat() {\n-        floats().forEach(expected -> {\n-            RefImpl.putFloat(BUFF, OFFSET, expected);\n-            float actual = ByteArrayAccess.getFloat(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutFloat() {\n-        floats().forEach(expected -> {\n-            ByteArrayAccess.setFloat(BUFF, OFFSET, expected);\n-            float actual = RefImpl.getFloat(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testGetDouble() {\n-        doubles().forEach(expected -> {\n-            RefImpl.putDouble(BUFF, OFFSET, expected);\n-            double actual = ByteArrayAccess.getDouble(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutDouble() {\n-        doubles().forEach(expected -> {\n-            ByteArrayAccess.setDouble(BUFF, OFFSET, expected);\n-            double actual = RefImpl.getDouble(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutUnsignedShort() {\n-        longs().forEach(l -> {\n-            int expected = Short.toUnsignedInt((short) l);\n-            ByteArrayAccess.setUnsignedShort(BUFF, OFFSET, expected);\n-            int actual = Short.toUnsignedInt(RefImpl.getShort(BUFF, OFFSET));\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-\n-    \/\/ Unusual cases\n-\n-    @Test\n-    void testNullArray() {\n-        assertThrowsOriginal(NullPointerException.class, () -> ByteArrayAccess.getInt(null, OFFSET));\n-        assertThrowsOriginal(NullPointerException.class, () -> ByteArrayAccess.setInt(null, OFFSET, 1));\n-    }\n-\n-    @Test\n-    void testNegArg() {\n-        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArrayAccess.getInt(BUFF, -1));\n-        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArrayAccess.setInt(BUFF, -1, 1));\n-    }\n-\n-    @Test\n-    void testOutOfBounds() {\n-        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArrayAccess.getInt(BUFF, BUFF.length));\n-        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArrayAccess.setInt(BUFF, BUFF.length, 1));\n-    }\n-\n-    \/\/ At-zero methods\n-\n-    @Test\n-    void testGetShortAtZero() {\n-        longs().forEach(l -> {\n-            short expected = (short) l;\n-            RefImpl.putShort(BUFF, 0, expected);\n-            short actual = ByteArrayAccess.getShort(BUFF);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutShortAtZero() {\n-        longs().forEach(l -> {\n-            short expected = (short) l;\n-            ByteArrayAccess.setShort(BUFF, expected);\n-            short actual = RefImpl.getShort(BUFF, 0);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testGetCharAtZero() {\n-        longs().forEach(l -> {\n-            char expected = (char) l;\n-            RefImpl.putChar(BUFF, 0, expected);\n-            char actual = ByteArrayAccess.getChar(BUFF);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutCharAtZero() {\n-        longs().forEach(l -> {\n-            char expected = (char) l;\n-            ByteArrayAccess.setChar(BUFF, expected);\n-            char actual = RefImpl.getChar(BUFF, 0);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testGetIntAtZero() {\n-        longs().forEach(l -> {\n-            int expected = (int) l;\n-            RefImpl.putInt(BUFF, 0, expected);\n-            int actual = ByteArrayAccess.getInt(BUFF);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutIntAtZero() {\n-        longs().forEach(l -> {\n-            int expected = (int) l;\n-            ByteArrayAccess.setInt(BUFF, expected);\n-            int actual = RefImpl.getInt(BUFF, 0);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testGetLongAtZero() {\n-        longs().forEach(expected -> {\n-            RefImpl.putLong(BUFF, 0, expected);\n-            long actual = ByteArrayAccess.getLong(BUFF);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutLongAtZero() {\n-        longs().forEach(expected -> {\n-            ByteArrayAccess.setLong(BUFF, expected);\n-            long actual = RefImpl.getLong(BUFF, 0);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testGetFloatAtZero() {\n-        floats().forEach(expected -> {\n-            RefImpl.putFloat(BUFF, 0, expected);\n-            float actual = ByteArrayAccess.getFloat(BUFF);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutFloatAtZero() {\n-        floats().forEach(expected -> {\n-            ByteArrayAccess.setFloat(BUFF, expected);\n-            float actual = RefImpl.getFloat(BUFF, 0);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testGetDoubleAtZero() {\n-        doubles().forEach(expected -> {\n-            RefImpl.putDouble(BUFF, 0, expected);\n-            double actual = ByteArrayAccess.getDouble(BUFF);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutDoubleAtZero() {\n-        doubles().forEach(expected -> {\n-            ByteArrayAccess.setDouble(BUFF, expected);\n-            double actual = RefImpl.getDouble(BUFF, 0);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutUnsignedShortAtZero() {\n-        longs().forEach(l -> {\n-            int expected = Short.toUnsignedInt((short) l);\n-            ByteArrayAccess.setUnsignedShort(BUFF, expected);\n-            int actual = Short.toUnsignedInt(RefImpl.getShort(BUFF, 0));\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    \/\/ Unusual cases\n-\n-    @Test\n-    void testNullArrayAtZero() {\n-        assertThrowsOriginal(NullPointerException.class, () -> ByteArrayAccess.getInt(null));\n-        assertThrowsOriginal(NullPointerException.class, () -> ByteArrayAccess.setInt(null, 1));\n-    }\n-\n-    @Test\n-    void testOutOfBoundsAtZero() {\n-        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArrayAccess.getInt(new byte[1]));\n-        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArrayAccess.setInt(new byte[1],1));\n-    }\n-\n-\n-    static LongStream longs() {\n-        return ThreadLocalRandom.current().longs(ITERATIONS);\n-    }\n-\n-    static DoubleStream doubles() {\n-        return DoubleStream.concat(\n-                ThreadLocalRandom.current().doubles(ITERATIONS),\n-                DoubleStream.of(Double.NaN,\n-                        Double.NEGATIVE_INFINITY,\n-                        Double.POSITIVE_INFINITY,\n-                        Double.MAX_VALUE,\n-                        Double.MIN_VALUE,\n-                        -0.0d\n-                        +0.0d)\n-        );\n-    }\n-    static Stream<Float> floats() {\n-        return Stream.concat(\n-                ThreadLocalRandom.current().doubles(ITERATIONS).mapToObj(d -> (float)d),\n-                Stream.of(Float.NaN,\n-                        Float.NEGATIVE_INFINITY,\n-                        Float.POSITIVE_INFINITY,\n-                        Float.MAX_VALUE,\n-                        Float.MIN_VALUE,\n-                        -0.0f\n-                        +0.0f)\n-        );\n-    }\n-\n-    @FunctionalInterface\n-    interface ThrowingRunnable {\n-        void run() throws Exception;\n-    }\n-\n-    <X extends Exception> void assertThrowsOriginal(Class<X> type,\n-                                                    ThrowingRunnable runnable) {\n-        try {\n-            runnable.run();\n-        } catch (Exception e) {\n-            if (type.isInstance(e)) {\n-                return;\n-            }\n-            if (type.isInstance(e.getCause())) {\n-                return;\n-            }\n-            throw new AssertionError(e);\n-        }\n-\n-    }\n-\n-    \/**\n-    * Reference implementation from the old java.io.Bits implementation\n-    *\/\n-    private static final class RefImpl {\n-        private RefImpl() {}\n-\n-        static char getChar(byte[] b, int off) {\n-            return (char) ((b[off + 1] & 0xFF) +\n-                    (b[off] << 8));\n-        }\n-\n-        static short getShort(byte[] b, int off) {\n-            return (short) ((b[off + 1] & 0xFF) +\n-                    (b[off] << 8));\n-        }\n-\n-        static int getInt(byte[] b, int off) {\n-            return ((b[off + 3] & 0xFF)) +\n-                    ((b[off + 2] & 0xFF) << 8) +\n-                    ((b[off + 1] & 0xFF) << 16) +\n-                    ((b[off]) << 24);\n-        }\n-\n-        static float getFloat(byte[] b, int off) {\n-            return Float.intBitsToFloat(getInt(b, off));\n-        }\n-\n-        static long getLong(byte[] b, int off) {\n-            return ((b[off + 7] & 0xFFL)) +\n-                    ((b[off + 6] & 0xFFL) << 8) +\n-                    ((b[off + 5] & 0xFFL) << 16) +\n-                    ((b[off + 4] & 0xFFL) << 24) +\n-                    ((b[off + 3] & 0xFFL) << 32) +\n-                    ((b[off + 2] & 0xFFL) << 40) +\n-                    ((b[off + 1] & 0xFFL) << 48) +\n-                    (((long) b[off]) << 56);\n-        }\n-\n-        static double getDouble(byte[] b, int off) {\n-            return Double.longBitsToDouble(getLong(b, off));\n-        }\n-\n-        \/*\n-         * Methods for packing primitive values into byte arrays starting at given\n-         * offsets.\n-         *\/\n-\n-        static void putChar(byte[] b, int off, char val) {\n-            b[off + 1] = (byte) (val);\n-            b[off] = (byte) (val >>> 8);\n-        }\n-\n-        static void putShort(byte[] b, int off, short val) {\n-            b[off + 1] = (byte) (val);\n-            b[off] = (byte) (val >>> 8);\n-        }\n-\n-        static void putInt(byte[] b, int off, int val) {\n-            b[off + 3] = (byte) (val);\n-            b[off + 2] = (byte) (val >>> 8);\n-            b[off + 1] = (byte) (val >>> 16);\n-            b[off] = (byte) (val >>> 24);\n-        }\n-\n-        static void putFloat(byte[] b, int off, float val) {\n-            putInt(b, off, Float.floatToIntBits(val));\n-        }\n-\n-        static void putLong(byte[] b, int off, long val) {\n-            b[off + 7] = (byte) (val);\n-            b[off + 6] = (byte) (val >>> 8);\n-            b[off + 5] = (byte) (val >>> 16);\n-            b[off + 4] = (byte) (val >>> 24);\n-            b[off + 3] = (byte) (val >>> 32);\n-            b[off + 2] = (byte) (val >>> 40);\n-            b[off + 1] = (byte) (val >>> 48);\n-            b[off] = (byte) (val >>> 56);\n-        }\n-\n-        static void putDouble(byte[] b, int off, double val) {\n-            putLong(b, off, Double.doubleToLongBits(val));\n-        }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/internal\/util\/ByteArrayAccess\/ReadWriteValues.java","additions":0,"deletions":470,"binary":false,"changes":470,"status":"deleted"}]}