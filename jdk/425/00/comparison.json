{"files":[{"patch":"@@ -318,2 +318,8 @@\n-bool RegionNode::is_unreachable_region(PhaseGVN *phase) const {\n-  assert(req() == 2, \"\");\n+bool RegionNode::is_unreachable_region(const PhaseGVN* phase) {\n+  Node* top = phase->C->top();\n+  assert(req() == 2 || (req() == 3 && in(1) != NULL && in(2) == top), \"sanity check arguments\");\n+  if (_is_unreachable_region) {\n+    \/\/ Return cached result from previous evaluation which should still be valid\n+    assert(is_unreachable_from_root(phase), \"walk the graph again and check if its indeed unreachable\");\n+    return true;\n+  }\n@@ -323,0 +329,11 @@\n+  if (is_possible_unsafe_loop(phase)) {\n+    \/\/ If we have a possible unsafe loop, check if the region node is actually unreachable from root.\n+    if (is_unreachable_from_root(phase)) {\n+      _is_unreachable_region = true;\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool RegionNode::is_possible_unsafe_loop(const PhaseGVN* phase) const {\n@@ -326,4 +343,5 @@\n-    Node* phi = raw_out(i);\n-    if (phi != NULL && phi->is_Phi()) {\n-      assert(phase->eqv(phi->in(0), this) && phi->req() == 2, \"\");\n-      if (phi->outcnt() == 0)\n+    Node* n = raw_out(i);\n+    if (n != NULL && n->is_Phi()) {\n+      PhiNode* phi = n->as_Phi();\n+      assert(phase->eqv(phi->in(0), this), \"sanity check phi\");\n+      if (phi->outcnt() == 0) {\n@@ -331,0 +349,1 @@\n+      }\n@@ -335,1 +354,1 @@\n-        if (u != NULL && (u->is_Phi() || u->is_CFG()))\n+        if (u != NULL && (u->is_Phi() || u->is_CFG())) {\n@@ -337,0 +356,1 @@\n+        }\n@@ -339,1 +359,1 @@\n-      if (phi->as_Phi()->simple_data_loop_check(phi->in(1)) >= PhiNode::Unsafe)\n+      if (phi->as_Phi()->simple_data_loop_check(phi->in(1)) >= PhiNode::Unsafe) {\n@@ -341,0 +361,1 @@\n+      }\n@@ -343,1 +364,1 @@\n-  if (i >= max)\n+  if (i >= max) {\n@@ -345,0 +366,3 @@\n+  }\n+  return true;\n+}\n@@ -346,1 +370,1 @@\n-  \/\/ Unsafe case - check if the Region node is reachable from root.\n+bool RegionNode::is_unreachable_from_root(const PhaseGVN* phase) const {\n@@ -348,1 +372,0 @@\n-\n@@ -370,1 +393,0 @@\n-\n@@ -1930,10 +1952,1 @@\n-      \/\/ First, take the short cut when we know it is a loop and\n-      \/\/ the EntryControl data path is dead.\n-      \/\/ Loop node may have only one input because entry path\n-      \/\/ is removed in PhaseIdealLoop::Dominators().\n-      assert(!r->is_Loop() || r->req() <= 3, \"Loop node should have 3 or less inputs\");\n-      bool is_loop = (r->is_Loop() && r->req() == 3);\n-      \/\/ Then, check if there is a data loop when phi references itself directly\n-      \/\/ or through other data nodes.\n-      if ((is_loop && !uin->eqv_uncast(in(LoopNode::EntryControl))) ||\n-          (!is_loop && is_unsafe_data_reference(uin))) {\n+      if (is_data_loop(r->as_Region(), uin, phase)) {\n@@ -2378,0 +2391,16 @@\n+bool PhiNode::is_data_loop(RegionNode* r, Node* uin, const PhaseGVN* phase) {\n+  \/\/ First, take the short cut when we know it is a loop and the EntryControl data path is dead.\n+  \/\/ The loop node may only have one input because the entry path was removed in PhaseIdealLoop::Dominators().\n+  \/\/ Then, check if there is a data loop when the phi references itself directly or through other data nodes.\n+  assert(!r->is_Loop() || r->req() <= 3, \"Loop node should have 3 or less inputs\");\n+  const bool is_loop = (r->is_Loop() && r->req() == 3);\n+  const Node* top = phase->C->top();\n+  if (is_loop) {\n+    return !uin->eqv_uncast(in(LoopNode::EntryControl));\n+  } else {\n+    \/\/ We have a data loop either with an unsafe data reference or if a region is unreachable.\n+    return is_unsafe_data_reference(uin)\n+           || (r->req() == 3 && (r->in(1) != top && r->in(2) == top && r->is_unreachable_region(phase)));\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":51,"deletions":22,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -67,0 +67,5 @@\n+private:\n+  bool _is_unreachable_region;\n+\n+  bool is_possible_unsafe_loop(const PhaseGVN* phase) const;\n+  bool is_unreachable_from_root(const PhaseGVN* phase) const;\n@@ -73,1 +78,1 @@\n-  RegionNode( uint required ) : Node(required) {\n+  RegionNode(uint required) : Node(required), _is_unreachable_region(false) {\n@@ -75,1 +80,1 @@\n-    init_req(0,this);\n+    init_req(0, this);\n@@ -87,1 +92,1 @@\n-  bool is_unreachable_region(PhaseGVN *phase) const;\n+  bool is_unreachable_region(const PhaseGVN* phase);\n@@ -89,3 +94,4 @@\n-  virtual bool pinned() const { return (const Node *)in(0) == this; }\n-  virtual bool  is_CFG   () const { return true; }\n-  virtual uint hash() const { return NO_HASH; }  \/\/ CFG nodes do not hash\n+  virtual uint size_of() const { return sizeof(*this); }\n+  virtual bool pinned() const { return (const Node*)in(0) == this; }\n+  virtual bool is_CFG() const { return true; }\n+  virtual uint hash() const { return NO_HASH; } \/\/ CFG nodes do not hash\n@@ -93,1 +99,1 @@\n-  virtual const Type *bottom_type() const { return Type::CONTROL; }\n+  virtual const Type* bottom_type() const { return Type::CONTROL; }\n@@ -96,1 +102,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -98,1 +104,1 @@\n-  bool try_clean_mem_phi(PhaseGVN *phase);\n+  bool try_clean_mem_phi(PhaseGVN* phase);\n@@ -138,0 +144,1 @@\n+  bool is_data_loop(RegionNode* r, Node* uin, const PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8251544\n+ * @summary A dead data loop in dying code is not correctly removed resulting in unremovable data nodes.\n+ * @requires vm.compiler2.enabled\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ *          java.base\/jdk.internal.access\n+ *          java.base\/jdk.internal.reflect\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-TieredCompilation -Xbatch\n+ *                   compiler.c2.TestDeadDataLoopIGVN\n+ *\/\n+\n+package compiler.c2;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.LinkedList;\n+import java.util.ArrayList;\n+import java.util.Vector;\n+import java.util.ListIterator;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.reflect.ConstantPool;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.lang.reflect.Executable;\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import sun.hotspot.WhiteBox;\n+\n+public class TestDeadDataLoopIGVN {\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+    private static final int TIERED_STOP_AT_LEVEL = WB.getIntxVMFlag(\"TieredStopAtLevel\").intValue();\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    \/\/ The original test only failed with CTW due to different inlining and virtual call decisions compared to an\n+    \/\/ execution with -Xcomp. This test adapts the behavior of CTW and compiles the methods with the Whitebox API\n+    \/\/ in order to reproduce the bug.\n+    public static void main(String[] strArr) throws Exception {\n+        \/\/ Required to get the same inlining\/virtual call decisions as for CTW\n+        callSomeMethods(new ArrayList<String>());\n+        callSomeMethods(new Vector<String>());\n+\n+        if (TIERED_STOP_AT_LEVEL != CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION) {\n+            throw new RuntimeException(\"Sanity check if C2 is available\");\n+        }\n+\n+        \/\/ To trigger the assertion, we only need to compile Test\n+        compileClass(Test.class);\n+    }\n+\n+    private static void callSomeMethods(List<String> list) {\n+        list.add(\"bla\");\n+        list.add(\"foo\");\n+        ListIterator<String> it = list.listIterator();\n+        it.hasNext();\n+        for (String s : list) {\n+            s.charAt(0);\n+        }\n+    }\n+\n+    \/\/ Adaptation from CTW to compile and deoptimize the same methods\n+    private static void compileClass(Class<?> aClass) throws Exception {\n+        aClass = Class.forName(aClass.getCanonicalName(), true, aClass.getClassLoader());\n+        ConstantPool constantPool = SharedSecrets.getJavaLangAccess().getConstantPool(aClass);\n+        preloadClasses(constantPool);\n+        UNSAFE.ensureClassInitialized(aClass);\n+        WB.enqueueInitializerForCompilation(aClass, 4); \/\/ Level 4 for C2\n+\n+        for (Executable method : aClass.getDeclaredConstructors()) {\n+            WB.deoptimizeMethod(method);\n+            WB.enqueueMethodForCompilation(method, 4);\n+            WB.deoptimizeMethod(method);\n+        }\n+\n+        for (Executable method : aClass.getDeclaredMethods()) {\n+            WB.deoptimizeMethod(method);\n+            WB.enqueueMethodForCompilation(method, 4);\n+            WB.deoptimizeMethod(method);\n+        }\n+    }\n+\n+    private static void preloadClasses(ConstantPool constantPool) throws Exception {\n+        for (int i = 0, n = constantPool.getSize(); i < n; ++i) {\n+            try {\n+                constantPool.getClassAt(i);\n+            } catch (IllegalArgumentException ignore) {\n+            }\n+        }\n+    }\n+}\n+\n+\/\/ The actual class that failed by executing it with CTW\n+class Test {\n+\n+    public static A a = new A();\n+\n+    Test() {\n+        LinkedList<A> l = new LinkedList<A>();\n+        for (int i = 0; i < 34; i++) {\n+            A instance = new A();\n+            instance.id = i;\n+            l.add(instance);\n+        }\n+        test(l, 34);\n+    }\n+\n+    public void test(LinkedList<A> list, int max) {\n+        Integer[] numbers = new Integer[max + 1];\n+        A[] numbers2 = new A[max + 1];\n+        int n = 0;\n+        ListIterator<A> it = list.listIterator();\n+        while (it.hasNext()) {\n+            A b = it.next();\n+            numbers[b.get()] = n;\n+            numbers2[n] = b;\n+            n++;\n+        }\n+\n+        Integer[] iArr = new Integer[max + 1];\n+\n+        A a = getA();\n+        Integer x = numbers[a.get()];\n+        iArr[x] = x;\n+\n+        boolean flag = true;\n+        while (flag) {\n+            flag = false;\n+            it = list.listIterator(34);\n+            while (it.hasPrevious()) {\n+                A b = it.previous();\n+                if (b == a) {\n+                    continue;\n+                }\n+            }\n+        }\n+\n+        HashMap<A, A> map = new HashMap<A, A>();\n+        for (Integer i = 0; i < max - 34; i++) {\n+            map.put(numbers2[i], numbers2[iArr[i]]);\n+        }\n+    }\n+\n+    public A getA() {\n+        return a;\n+    }\n+}\n+\n+\/\/ Helper class\n+class A {\n+    int id;\n+\n+    public int get() {\n+        return id;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestDeadDataLoopIGVN.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"}]}