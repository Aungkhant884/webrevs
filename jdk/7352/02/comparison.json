{"files":[{"patch":"@@ -2288,11 +2288,7 @@\n-  \/\/ Insert clone after (orig) tail in reverse post order\n-  clone->set_rpo_next(tail->rpo_next());\n-  tail->set_rpo_next(clone);\n-\n-  \/\/ tail->head becomes tail->clone\n-  for (SuccIter iter(tail); !iter.done(); iter.next()) {\n-    if (iter.succ() == head) {\n-      iter.set_succ(clone);\n-      \/\/ Update predecessor information\n-      head->predecessors()->remove(tail);\n-      clone->predecessors()->append(tail);\n+  \/\/ Accumulate profiled count for all backedges that share this loop's head\n+  int total_count = lp->profiled_count();\n+  for (Loop* lp1 = lp->parent(); lp1 != NULL; lp1 = lp1->parent()) {\n+    for (Loop* lp2 = lp1; lp2 != NULL; lp2 = lp2->sibling()) {\n+      if (lp2->head() == head && !lp2->tail()->is_backedge_copy()) {\n+        total_count += lp2->profiled_count();\n+      }\n@@ -2301,1 +2297,31 @@\n-  flow_block(tail, temp_vector, temp_set);\n+  \/\/ Have the most frequent ones branch to the clone instead\n+  int count = 0;\n+  int nb = 0;\n+  Block* latest_tail = tail;\n+  bool done = false;\n+  for (Loop* lp1 = lp; lp1 != NULL && !done; lp1 = lp1->parent()) {\n+    for (Loop* lp2 = lp1; lp2 != NULL && !done; lp2 = lp2->sibling()) {\n+      if (lp2->head() == head && !lp2->tail()->is_backedge_copy()) {\n+        count += lp2->profiled_count();\n+        if (lp2->tail()->post_order() < latest_tail->post_order()) {\n+          latest_tail = lp2->tail();\n+        }\n+        nb++;\n+        for (SuccIter iter(lp2->tail()); !iter.done(); iter.next()) {\n+          if (iter.succ() == head) {\n+            iter.set_succ(clone);\n+            \/\/ Update predecessor information\n+            head->predecessors()->remove(lp2->tail());\n+            clone->predecessors()->append(lp2->tail());\n+          }\n+        }\n+        flow_block(lp2->tail(), temp_vector, temp_set);\n+        if (total_count == 0 || count > (total_count * .9)) {\n+          done = true;\n+        }\n+      }\n+    }\n+  }\n+  assert(nb >= 1, \"at least one new\");\n+  clone->set_rpo_next(latest_tail->rpo_next());\n+  latest_tail->set_rpo_next(clone);\n@@ -2303,0 +2329,1 @@\n+    assert(nb == 1, \"only when the head is not shared\");\n@@ -2454,2 +2481,5 @@\n-int ciTypeFlow::profiled_count(ciTypeFlow::Loop* loop) {\n-  ciMethodData* methodData = method()->method_data();\n+int ciTypeFlow::Loop::profiled_count() {\n+  if (_profiled_count >= 0) {\n+    return _profiled_count;\n+  }\n+  ciMethodData* methodData = outer()->method()->method_data();\n@@ -2457,0 +2487,1 @@\n+    _profiled_count = 0;\n@@ -2459,1 +2490,1 @@\n-  ciTypeFlow::Block* tail = loop->tail();\n+  ciTypeFlow::Block* tail = this->tail();\n@@ -2461,0 +2492,1 @@\n+    _profiled_count = 0;\n@@ -2467,0 +2499,1 @@\n+    _profiled_count = 0;\n@@ -2470,1 +2503,1 @@\n-  ciBytecodeStream iter(method());\n+  ciBytecodeStream iter(outer()->method());\n@@ -2509,3 +2542,4 @@\n-    assert(((wide ? iter.get_far_dest() : iter.get_dest()) == loop->head()->start()) == (succs->at(ciTypeFlow::GOTO_TARGET) == loop->head()), \"branch should lead to loop head\");\n-    if (succs->at(ciTypeFlow::GOTO_TARGET) == loop->head()) {\n-      return method()->scale_count(data->as_JumpData()->taken());\n+    assert(((wide ? iter.get_far_dest() : iter.get_dest()) == head()->start()) == (succs->at(ciTypeFlow::GOTO_TARGET) == head()), \"branch should lead to loop head\");\n+    if (succs->at(ciTypeFlow::GOTO_TARGET) == head()) {\n+      _profiled_count = outer()->method()->scale_count(data->as_JumpData()->taken());\n+      return _profiled_count;\n@@ -2514,6 +2548,8 @@\n-    assert((iter.get_dest() == loop->head()->start()) == (succs->at(ciTypeFlow::IF_TAKEN) == loop->head()), \"bytecode and CFG not consistent\");\n-    assert((tail->limit() == loop->head()->start()) == (succs->at(ciTypeFlow::IF_NOT_TAKEN) == loop->head()), \"bytecode and CFG not consistent\");\n-    if (succs->at(ciTypeFlow::IF_TAKEN) == loop->head()) {\n-      return method()->scale_count(data->as_JumpData()->taken());\n-    } else if (succs->at(ciTypeFlow::IF_NOT_TAKEN) == loop->head()) {\n-      return method()->scale_count(data->as_BranchData()->not_taken());\n+    assert((iter.get_dest() == head()->start()) == (succs->at(ciTypeFlow::IF_TAKEN) == head()), \"bytecode and CFG not consistent\");\n+    assert((tail->limit() == head()->start()) == (succs->at(ciTypeFlow::IF_NOT_TAKEN) == head()), \"bytecode and CFG not consistent\");\n+    if (succs->at(ciTypeFlow::IF_TAKEN) == head()) {\n+      _profiled_count = outer()->method()->scale_count(data->as_JumpData()->taken());\n+      return _profiled_count;\n+    } else if (succs->at(ciTypeFlow::IF_NOT_TAKEN) == head()) {\n+      _profiled_count = outer()->method()->scale_count(data->as_BranchData()->not_taken());\n+      return _profiled_count;\n@@ -2523,1 +2559,2 @@\n-  return 0;\n+  _profiled_count = 0;\n+  return _profiled_count;\n@@ -2535,2 +2572,2 @@\n-    int lp_count = outer()->profiled_count(lp);\n-    int current_count = outer()->profiled_count(current);\n+    int lp_count = lp->profiled_count();\n+    int current_count = current->profiled_count();\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":65,"deletions":28,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -719,0 +719,1 @@\n+    int _profiled_count;\n@@ -727,1 +728,1 @@\n-      _irreducible(false), _def_locals() {}\n+      _irreducible(false), _def_locals(), _profiled_count(-1) {}\n@@ -763,0 +764,2 @@\n+    int profiled_count();\n+\n@@ -919,2 +922,0 @@\n-  int profiled_count(ciTypeFlow::Loop* loop);\n-\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -773,0 +773,8 @@\n+  product(bool, DuplicateBackedge, true,                                    \\\n+          \"Transform loop with a merge point into 2 loops if inner loop is\" \\\n+          \"expected to optimize better\")                                    \\\n+                                                                            \\\n+  develop(bool, StressDuplicateBackedge, false,                             \\\n+          \"Run DuplicateBackedge whenever possible ignoring benefit\"        \\\n+          \"analysis\")                                                       \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1017,53 +1017,23 @@\n-\/\/ Compute probability of reaching some CFG node from a fixed\n-\/\/ dominating CFG node\n-class PathFrequency {\n-private:\n-  Node* _dom; \/\/ frequencies are computed relative to this node\n-  Node_Stack _stack;\n-  GrowableArray<float> _freqs_stack; \/\/ keep track of intermediate result at regions\n-  GrowableArray<float> _freqs; \/\/ cache frequencies\n-  PhaseIdealLoop* _phase;\n-\n-  float check_and_truncate_frequency(float f) {\n-    assert(f >= 0, \"Incorrect frequency\");\n-    \/\/ We do not perform an exact (f <= 1) check\n-    \/\/ this would be error prone with rounding of floats.\n-    \/\/ Performing a check like (f <= 1+eps) would be of benefit,\n-    \/\/ however, it is not evident how to determine such an eps,\n-    \/\/ given that an arbitrary number of add\/mul operations\n-    \/\/ are performed on these frequencies.\n-    return (f > 1) ? 1 : f;\n-  }\n-\n-public:\n-  PathFrequency(Node* dom, PhaseIdealLoop* phase)\n-    : _dom(dom), _stack(0), _phase(phase) {\n-  }\n-\n-  float to(Node* n) {\n-    \/\/ post order walk on the CFG graph from n to _dom\n-    IdealLoopTree* loop = _phase->get_loop(_dom);\n-    Node* c = n;\n-    for (;;) {\n-      assert(_phase->get_loop(c) == loop, \"have to be in the same loop\");\n-      if (c == _dom || _freqs.at_grow(c->_idx, -1) >= 0) {\n-        float f = c == _dom ? 1 : _freqs.at(c->_idx);\n-        Node* prev = c;\n-        while (_stack.size() > 0 && prev == c) {\n-          Node* n = _stack.node();\n-          if (!n->is_Region()) {\n-            if (_phase->get_loop(n) != _phase->get_loop(n->in(0))) {\n-              \/\/ Found an inner loop: compute frequency of reaching this\n-              \/\/ exit from the loop head by looking at the number of\n-              \/\/ times each loop exit was taken\n-              IdealLoopTree* inner_loop = _phase->get_loop(n->in(0));\n-              LoopNode* inner_head = inner_loop->_head->as_Loop();\n-              assert(_phase->get_loop(n) == loop, \"only 1 inner loop\");\n-              if (inner_head->is_OuterStripMinedLoop()) {\n-                inner_head->verify_strip_mined(1);\n-                if (n->in(0) == inner_head->in(LoopNode::LoopBackControl)->in(0)) {\n-                  n = n->in(0)->in(0)->in(0);\n-                }\n-                inner_loop = inner_loop->_child;\n-                inner_head = inner_loop->_head->as_Loop();\n-                inner_head->verify_strip_mined(1);\n+float PathFrequency::to(Node* n) {\n+  \/\/ post order walk on the CFG graph from n to _dom\n+  IdealLoopTree* loop = _phase->get_loop(_dom);\n+  Node* c = n;\n+  for (;;) {\n+    assert(_phase->get_loop(c) == loop, \"have to be in the same loop\");\n+    if (c == _dom || _freqs.at_grow(c->_idx, -1) >= 0) {\n+      float f = c == _dom ? 1 : _freqs.at(c->_idx);\n+      Node* prev = c;\n+      while (_stack.size() > 0 && prev == c) {\n+        Node* n = _stack.node();\n+        if (!n->is_Region()) {\n+          if (_phase->get_loop(n) != _phase->get_loop(n->in(0))) {\n+            \/\/ Found an inner loop: compute frequency of reaching this\n+            \/\/ exit from the loop head by looking at the number of\n+            \/\/ times each loop exit was taken\n+            IdealLoopTree* inner_loop = _phase->get_loop(n->in(0));\n+            LoopNode* inner_head = inner_loop->_head->as_Loop();\n+            assert(_phase->get_loop(n) == loop, \"only 1 inner loop\");\n+            if (inner_head->is_OuterStripMinedLoop()) {\n+              inner_head->verify_strip_mined(1);\n+              if (n->in(0) == inner_head->in(LoopNode::LoopBackControl)->in(0)) {\n+                n = n->in(0)->in(0)->in(0);\n@@ -1071,5 +1041,16 @@\n-              float loop_exit_cnt = 0.0f;\n-              for (uint i = 0; i < inner_loop->_body.size(); i++) {\n-                Node *n = inner_loop->_body[i];\n-                float c = inner_loop->compute_profile_trip_cnt_helper(n);\n-                loop_exit_cnt += c;\n+              inner_loop = inner_loop->_child;\n+              inner_head = inner_loop->_head->as_Loop();\n+              inner_head->verify_strip_mined(1);\n+            }\n+            float loop_exit_cnt = 0.0f;\n+            for (uint i = 0; i < inner_loop->_body.size(); i++) {\n+              Node *n = inner_loop->_body[i];\n+              float c = inner_loop->compute_profile_trip_cnt_helper(n);\n+              loop_exit_cnt += c;\n+            }\n+            float cnt = -1;\n+            if (n->in(0)->is_If()) {\n+              IfNode* iff = n->in(0)->as_If();\n+              float p = n->in(0)->as_If()->_prob;\n+              if (n->Opcode() == Op_IfFalse) {\n+                p = 1 - p;\n@@ -1077,12 +1058,2 @@\n-              float cnt = -1;\n-              if (n->in(0)->is_If()) {\n-                IfNode* iff = n->in(0)->as_If();\n-                float p = n->in(0)->as_If()->_prob;\n-                if (n->Opcode() == Op_IfFalse) {\n-                  p = 1 - p;\n-                }\n-                if (p > PROB_MIN) {\n-                  cnt = p * iff->_fcnt;\n-                } else {\n-                  cnt = 0;\n-                }\n+              if (p > PROB_MIN) {\n+                cnt = p * iff->_fcnt;\n@@ -1090,4 +1061,1 @@\n-                assert(n->in(0)->is_Jump(), \"unsupported node kind\");\n-                JumpNode* jmp = n->in(0)->as_Jump();\n-                float p = n->in(0)->as_Jump()->_probs[n->as_JumpProj()->_con];\n-                cnt = p * jmp->_fcnt;\n+                cnt = 0;\n@@ -1095,4 +1063,0 @@\n-              float this_exit_f = cnt > 0 ? cnt \/ loop_exit_cnt : 0;\n-              this_exit_f = check_and_truncate_frequency(this_exit_f);\n-              f = f * this_exit_f;\n-              f = check_and_truncate_frequency(f);\n@@ -1100,12 +1064,4 @@\n-              float p = -1;\n-              if (n->in(0)->is_If()) {\n-                p = n->in(0)->as_If()->_prob;\n-                if (n->Opcode() == Op_IfFalse) {\n-                  p = 1 - p;\n-                }\n-              } else {\n-                assert(n->in(0)->is_Jump(), \"unsupported node kind\");\n-                p = n->in(0)->as_Jump()->_probs[n->as_JumpProj()->_con];\n-              }\n-              f = f * p;\n-              f = check_and_truncate_frequency(f);\n+              assert(n->in(0)->is_Jump(), \"unsupported node kind\");\n+              JumpNode* jmp = n->in(0)->as_Jump();\n+              float p = n->in(0)->as_Jump()->_probs[n->as_JumpProj()->_con];\n+              cnt = p * jmp->_fcnt;\n@@ -1113,6 +1069,3 @@\n-            _freqs.at_put_grow(n->_idx, (float)f, -1);\n-            _stack.pop();\n-          } else {\n-            float prev_f = _freqs_stack.pop();\n-            float new_f = f;\n-            f = new_f + prev_f;\n+            float this_exit_f = cnt > 0 ? cnt \/ loop_exit_cnt : 0;\n+            this_exit_f = check_and_truncate_frequency(this_exit_f);\n+            f = f * this_exit_f;\n@@ -1120,5 +1073,7 @@\n-            uint i = _stack.index();\n-            if (i < n->req()) {\n-              c = n->in(i);\n-              _stack.set_index(i+1);\n-              _freqs_stack.push(f);\n+          } else {\n+            float p = -1;\n+            if (n->in(0)->is_If()) {\n+              p = n->in(0)->as_If()->_prob;\n+              if (n->Opcode() == Op_IfFalse) {\n+                p = 1 - p;\n+              }\n@@ -1126,2 +1081,2 @@\n-              _freqs.at_put_grow(n->_idx, f, -1);\n-              _stack.pop();\n+              assert(n->in(0)->is_Jump(), \"unsupported node kind\");\n+              p = n->in(0)->as_Jump()->_probs[n->as_JumpProj()->_con];\n@@ -1129,0 +1084,18 @@\n+            f = f * p;\n+            f = check_and_truncate_frequency(f);\n+          }\n+          _freqs.at_put_grow(n->_idx, (float)f, -1);\n+          _stack.pop();\n+        } else {\n+          float prev_f = _freqs_stack.pop();\n+          float new_f = f;\n+          f = new_f + prev_f;\n+          f = check_and_truncate_frequency(f);\n+          uint i = _stack.index();\n+          if (i < n->req()) {\n+            c = n->in(i);\n+            _stack.set_index(i+1);\n+            _freqs_stack.push(f);\n+          } else {\n+            _freqs.at_put_grow(n->_idx, f, -1);\n+            _stack.pop();\n@@ -1131,14 +1104,19 @@\n-        if (_stack.size() == 0) {\n-          return check_and_truncate_frequency(f);\n-        }\n-      } else if (c->is_Loop()) {\n-        ShouldNotReachHere();\n-        c = c->in(LoopNode::EntryControl);\n-      } else if (c->is_Region()) {\n-        _freqs_stack.push(0);\n-        _stack.push(c, 2);\n-        c = c->in(1);\n-      } else {\n-        if (c->is_IfProj()) {\n-          IfNode* iff = c->in(0)->as_If();\n-          if (iff->_prob == PROB_UNKNOWN) {\n+      }\n+      if (_stack.size() == 0) {\n+        return check_and_truncate_frequency(f);\n+      }\n+    } else if (c->is_Loop()) {\n+      ShouldNotReachHere();\n+      c = c->in(LoopNode::EntryControl);\n+    } else if (c->is_Region()) {\n+      _freqs_stack.push(0);\n+      _stack.push(c, 2);\n+      c = c->in(1);\n+    } else {\n+      if (c->is_IfProj()) {\n+        IfNode* iff = c->in(0)->as_If();\n+        if (iff->_prob == PROB_UNKNOWN) {\n+          \/\/ assume never taken\n+          _freqs.at_put_grow(c->_idx, 0, -1);\n+        } else if (_phase->get_loop(c) != _phase->get_loop(iff)) {\n+          if (iff->_fcnt == COUNT_UNKNOWN) {\n@@ -1147,9 +1125,0 @@\n-          } else if (_phase->get_loop(c) != _phase->get_loop(iff)) {\n-            if (iff->_fcnt == COUNT_UNKNOWN) {\n-              \/\/ assume never taken\n-              _freqs.at_put_grow(c->_idx, 0, -1);\n-            } else {\n-              \/\/ skip over loop\n-              _stack.push(c, 1);\n-              c = _phase->get_loop(c->in(0))->_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl);\n-            }\n@@ -1157,0 +1126,1 @@\n+            \/\/ skip over loop\n@@ -1158,1 +1128,1 @@\n-            c = iff;\n+            c = _phase->get_loop(c->in(0))->_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl);\n@@ -1160,11 +1130,10 @@\n-        } else if (c->is_JumpProj()) {\n-          JumpNode* jmp = c->in(0)->as_Jump();\n-          if (_phase->get_loop(c) != _phase->get_loop(jmp)) {\n-            if (jmp->_fcnt == COUNT_UNKNOWN) {\n-              \/\/ assume never taken\n-              _freqs.at_put_grow(c->_idx, 0, -1);\n-            } else {\n-              \/\/ skip over loop\n-              _stack.push(c, 1);\n-              c = _phase->get_loop(c->in(0))->_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl);\n-            }\n+        } else {\n+          _stack.push(c, 1);\n+          c = iff;\n+        }\n+      } else if (c->is_JumpProj()) {\n+        JumpNode* jmp = c->in(0)->as_Jump();\n+        if (_phase->get_loop(c) != _phase->get_loop(jmp)) {\n+          if (jmp->_fcnt == COUNT_UNKNOWN) {\n+            \/\/ assume never taken\n+            _freqs.at_put_grow(c->_idx, 0, -1);\n@@ -1172,0 +1141,1 @@\n+            \/\/ skip over loop\n@@ -1173,1 +1143,1 @@\n-            c = jmp;\n+            c = _phase->get_loop(c->in(0))->_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl);\n@@ -1175,15 +1145,13 @@\n-        } else if (c->Opcode() == Op_CatchProj &&\n-                   c->in(0)->Opcode() == Op_Catch &&\n-                   c->in(0)->in(0)->is_Proj() &&\n-                   c->in(0)->in(0)->in(0)->is_Call()) {\n-          \/\/ assume exceptions are never thrown\n-          uint con = c->as_Proj()->_con;\n-          if (con == CatchProjNode::fall_through_index) {\n-            Node* call = c->in(0)->in(0)->in(0)->in(0);\n-            if (_phase->get_loop(call) != _phase->get_loop(c)) {\n-              _freqs.at_put_grow(c->_idx, 0, -1);\n-            } else {\n-              c = call;\n-            }\n-          } else {\n-            assert(con >= CatchProjNode::catch_all_index, \"what else?\");\n+        } else {\n+          _stack.push(c, 1);\n+          c = jmp;\n+        }\n+      } else if (c->Opcode() == Op_CatchProj &&\n+                 c->in(0)->Opcode() == Op_Catch &&\n+                 c->in(0)->in(0)->is_Proj() &&\n+                 c->in(0)->in(0)->in(0)->is_Call()) {\n+        \/\/ assume exceptions are never thrown\n+        uint con = c->as_Proj()->_con;\n+        if (con == CatchProjNode::fall_through_index) {\n+          Node* call = c->in(0)->in(0)->in(0)->in(0);\n+          if (_phase->get_loop(call) != _phase->get_loop(c)) {\n@@ -1191,0 +1159,2 @@\n+          } else {\n+            c = call;\n@@ -1192,2 +1162,0 @@\n-        } else if (c->unique_ctrl_out() == NULL && !c->is_If() && !c->is_Jump()) {\n-          ShouldNotReachHere();\n@@ -1195,1 +1163,2 @@\n-          c = c->in(0);\n+          assert(con >= CatchProjNode::catch_all_index, \"what else?\");\n+          _freqs.at_put_grow(c->_idx, 0, -1);\n@@ -1197,0 +1166,4 @@\n+      } else if (c->unique_ctrl_out() == NULL && !c->is_If() && !c->is_Jump()) {\n+        ShouldNotReachHere();\n+      } else {\n+        c = c->in(0);\n@@ -1199,2 +1172,0 @@\n-    ShouldNotReachHere();\n-    return -1;\n@@ -1202,1 +1173,3 @@\n-};\n+  ShouldNotReachHere();\n+  return -1;\n+}\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":133,"deletions":160,"binary":false,"changes":293,"status":"modified"},{"patch":"@@ -3472,0 +3472,2 @@\n+    } else if (phase->duplicate_loop_backedge(this, old_new)) {\n+      return false;\n@@ -3500,0 +3502,3 @@\n+    if (StressDuplicateBackedge && phase->duplicate_loop_backedge(this, old_new)) {\n+      return false;\n+    }\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1399,0 +1399,1 @@\n+  bool duplicate_loop_backedge(IdealLoopTree *loop, Node_List &old_new);\n@@ -1445,2 +1446,2 @@\n-  Node *clone_iff( PhiNode *phi, IdealLoopTree *loop );\n-  CmpNode *clone_bool( PhiNode *phi, IdealLoopTree *loop );\n+  Node* clone_iff(PhiNode* phi);\n+  CmpNode* clone_bool(PhiNode* phi);\n@@ -1661,0 +1662,14 @@\n+\n+  void clone_loop_body(const Node_List& body, Node_List &old_new, CloneMap* cm);\n+\n+  void fix_body_edges(const Node_List &body, IdealLoopTree* loop, const Node_List &old_new, int dd,\n+                      IdealLoopTree* parent, bool partial);\n+\n+  void fix_ctrl_uses(const Node_List& body, const IdealLoopTree* loop, Node_List &old_new, CloneLoopMode mode,\n+                Node* side_by_side_idom, CloneMap* cm, Node_List &worklist);\n+\n+  void fix_data_uses(Node_List& body, IdealLoopTree* loop, CloneLoopMode mode, IdealLoopTree* outer_loop,\n+                     uint new_counter, Node_List& old_new, Node_List& worklist, Node_List*& split_if_set,\n+                     Node_List*& split_bool_set, Node_List*& split_cex_set);\n+\n+  void finish_clone_loop(Node_List* split_if_set, Node_List* split_bool_set, Node_List* split_cex_set);\n@@ -1810,0 +1825,29 @@\n+\/\/ Compute probability of reaching some CFG node from a fixed\n+\/\/ dominating CFG node\n+class PathFrequency {\n+private:\n+  Node* _dom; \/\/ frequencies are computed relative to this node\n+  Node_Stack _stack;\n+  GrowableArray<float> _freqs_stack; \/\/ keep track of intermediate result at regions\n+  GrowableArray<float> _freqs; \/\/ cache frequencies\n+  PhaseIdealLoop* _phase;\n+\n+  float check_and_truncate_frequency(float f) {\n+    assert(f >= 0, \"Incorrect frequency\");\n+    \/\/ We do not perform an exact (f <= 1) check\n+    \/\/ this would be error prone with rounding of floats.\n+    \/\/ Performing a check like (f <= 1+eps) would be of benefit,\n+    \/\/ however, it is not evident how to determine such an eps,\n+    \/\/ given that an arbitrary number of add\/mul operations\n+    \/\/ are performed on these frequencies.\n+    return (f > 1) ? 1 : f;\n+  }\n+\n+public:\n+  PathFrequency(Node* dom, PhaseIdealLoop* phase)\n+    : _dom(dom), _stack(0), _phase(phase) {\n+  }\n+\n+  float to(Node* n);\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":46,"deletions":2,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1839,1 +1839,1 @@\n-Node* PhaseIdealLoop::clone_iff(PhiNode *phi, IdealLoopTree *loop) {\n+Node* PhaseIdealLoop::clone_iff(PhiNode* phi) {\n@@ -1846,1 +1846,1 @@\n-      _igvn.replace_input_of(phi, i, clone_iff(b->as_Phi(), loop));\n+      _igvn.replace_input_of(phi, i, clone_iff(b->as_Phi()));\n@@ -1926,1 +1926,1 @@\n-CmpNode *PhaseIdealLoop::clone_bool( PhiNode *phi, IdealLoopTree *loop ) {\n+CmpNode*PhaseIdealLoop::clone_bool(PhiNode* phi) {\n@@ -1932,1 +1932,1 @@\n-      _igvn.replace_input_of(phi, i, clone_bool( b->as_Phi(), loop ));\n+      _igvn.replace_input_of(phi, i, clone_bool(b->as_Phi()));\n@@ -2271,1 +2271,1 @@\n-    \/\/ Some other transformation may have pessimistically assign some\n+    \/\/ Some other transformation may have pessimistically assigned some\n@@ -2343,1 +2343,0 @@\n-  Dict* dict = cm.dict();\n@@ -2355,14 +2354,1 @@\n-  uint i;\n-  for (i = 0; i < loop->_body.size(); i++) {\n-    Node* old = loop->_body.at(i);\n-    Node* nnn = old->clone();\n-    old_new.map(old->_idx, nnn);\n-    if (old->is_reduction()) {\n-      \/\/ Reduction flag is not copied by default. Copy it here when cloning the entire loop body.\n-      nnn->add_flag(Node::Flag_is_reduction);\n-    }\n-    if (C->do_vector_loop()) {\n-      cm.verify_insert_and_clone(old, nnn, cm.clone_idx());\n-    }\n-    _igvn.register_new_node_with_optimizer(nnn);\n-  }\n+  clone_loop_body(loop->_body, old_new, &cm);\n@@ -2375,23 +2361,1 @@\n-  for( i = 0; i < loop->_body.size(); i++ ) {\n-    Node *old = loop->_body.at(i);\n-    Node *nnn = old_new[old->_idx];\n-    \/\/ Fix CFG\/Loop controlling the new node\n-    if (has_ctrl(old)) {\n-      set_ctrl(nnn, old_new[get_ctrl(old)->_idx]);\n-    } else {\n-      set_loop(nnn, outer_loop->_parent);\n-      if (old->outcnt() > 0) {\n-        set_idom( nnn, old_new[idom(old)->_idx], dd );\n-      }\n-    }\n-    \/\/ Correct edges to the new node\n-    for( uint j = 0; j < nnn->req(); j++ ) {\n-        Node *n = nnn->in(j);\n-        if( n ) {\n-          IdealLoopTree *old_in_loop = get_loop( has_ctrl(n) ? get_ctrl(n) : n );\n-          if( loop->is_member( old_in_loop ) )\n-            nnn->set_req(j, old_new[n->_idx]);\n-        }\n-    }\n-    _igvn.hash_find_insert(nnn);\n-  }\n+  fix_body_edges(loop->_body, loop, old_new, dd, outer_loop->_parent, false);\n@@ -2409,2 +2373,72 @@\n-  for( i = 0; i < loop->_body.size(); i++ ) {\n-    Node* old = loop->_body.at(i);\n+  fix_ctrl_uses(loop->_body, loop, old_new, mode, side_by_side_idom, &cm, worklist);\n+\n+  \/\/ Step 4: If loop-invariant use is not control, it must be dominated by a\n+  \/\/ loop exit IfFalse\/IfTrue.  Find \"proper\" loop exit.  Make a Region\n+  \/\/ there if needed.  Make a Phi there merging old and new used values.\n+  Node_List *split_if_set = NULL;\n+  Node_List *split_bool_set = NULL;\n+  Node_List *split_cex_set = NULL;\n+  fix_data_uses(loop->_body, loop, mode, outer_loop, new_counter, old_new, worklist, split_if_set, split_bool_set, split_cex_set);\n+\n+  for (uint i = 0; i < extra_data_nodes.size(); i++) {\n+    Node* old = extra_data_nodes.at(i);\n+    clone_loop_handle_data_uses(old, old_new, loop, outer_loop, split_if_set,\n+                                split_bool_set, split_cex_set, worklist, new_counter,\n+                                mode);\n+  }\n+\n+  \/\/ Check for IFs that need splitting\/cloning.  Happens if an IF outside of\n+  \/\/ the loop uses a condition set in the loop.  The original IF probably\n+  \/\/ takes control from one or more OLD Regions (which in turn get from NEW\n+  \/\/ Regions).  In any case, there will be a set of Phis for each merge point\n+  \/\/ from the IF up to where the original BOOL def exists the loop.\n+  finish_clone_loop(split_if_set, split_bool_set, split_cex_set);\n+\n+}\n+\n+void PhaseIdealLoop::finish_clone_loop(Node_List* split_if_set, Node_List* split_bool_set, Node_List* split_cex_set) {\n+  if (split_if_set) {\n+    while (split_if_set->size()) {\n+      Node *iff = split_if_set->pop();\n+      if (iff->in(1)->is_Phi()) {\n+        Node *b = clone_iff(iff->in(1)->as_Phi());\n+        _igvn.replace_input_of(iff, 1, b);\n+      }\n+    }\n+  }\n+  if (split_bool_set) {\n+    while (split_bool_set->size()) {\n+      Node *b = split_bool_set->pop();\n+      Node *phi = b->in(1);\n+      assert(phi->is_Phi(), \"\");\n+      CmpNode *cmp = clone_bool((PhiNode*) phi);\n+      _igvn.replace_input_of(b, 1, cmp);\n+    }\n+  }\n+  if (split_cex_set) {\n+    while (split_cex_set->size()) {\n+      Node *b = split_cex_set->pop();\n+      assert(b->in(0)->is_Region(), \"\");\n+      assert(b->in(1)->is_Phi(), \"\");\n+      assert(b->in(0)->in(0) == b->in(1)->in(0), \"\");\n+      split_up(b, b->in(0), NULL);\n+    }\n+  }\n+}\n+\n+void PhaseIdealLoop::fix_data_uses(Node_List& body, IdealLoopTree* loop, CloneLoopMode mode, IdealLoopTree* outer_loop,\n+                                   uint new_counter, Node_List &old_new, Node_List &worklist, Node_List*& split_if_set,\n+                                   Node_List*& split_bool_set, Node_List*& split_cex_set) {\n+  for(uint i = 0; i < body.size(); i++ ) {\n+    Node* old = body.at(i);\n+    clone_loop_handle_data_uses(old, old_new, loop, outer_loop, split_if_set,\n+                                split_bool_set, split_cex_set, worklist, new_counter,\n+                                mode);\n+  }\n+}\n+\n+void PhaseIdealLoop::fix_ctrl_uses(const Node_List& body, const IdealLoopTree* loop, Node_List &old_new, CloneLoopMode mode,\n+                                   Node* side_by_side_idom, CloneMap* cm, Node_List &worklist) {\n+  LoopNode* head = loop->_head->as_Loop();\n+  for(uint i = 0; i < body.size(); i++ ) {\n+    Node* old = body.at(i);\n@@ -2415,1 +2449,1 @@\n-    for (DUIterator_Fast jmax, j = old->fast_outs(jmax); j < jmax; j++)\n+    for (DUIterator_Fast jmax, j = old->fast_outs(jmax); j < jmax; j++) {\n@@ -2417,0 +2451,1 @@\n+    }\n@@ -2418,1 +2453,1 @@\n-    while( worklist.size() ) {  \/\/ Visit all uses\n+    while (worklist.size()) {  \/\/ Visit all uses\n@@ -2421,2 +2456,2 @@\n-      IdealLoopTree *use_loop = get_loop( has_ctrl(use) ? get_ctrl(use) : use );\n-      if( !loop->is_member( use_loop ) && use->is_CFG() ) {\n+      IdealLoopTree *use_loop = get_loop(has_ctrl(use) ? get_ctrl(use) : use );\n+      if (!loop->is_member(use_loop) && use->is_CFG()) {\n@@ -2424,1 +2459,1 @@\n-        assert( use->is_Proj(), \"\" );\n+        assert(use->is_Proj(), \"\" );\n@@ -2448,2 +2483,2 @@\n-        if (C->do_vector_loop()) {\n-          cm.verify_insert_and_clone(use, newuse, cm.clone_idx());\n+        if (C->do_vector_loop() && cm != NULL) {\n+          cm->verify_insert_and_clone(use, newuse, cm->clone_idx());\n@@ -2461,2 +2496,2 @@\n-        uint dd_r = MIN2(dom_depth(newuse),dom_depth(use));\n-        assert( dd_r >= dom_depth(dom_lca(newuse,use)), \"\" );\n+        uint dd_r = MIN2(dom_depth(newuse), dom_depth(use));\n+        assert(dd_r >= dom_depth(dom_lca(newuse, use)), \"\" );\n@@ -2469,1 +2504,1 @@\n-          if( useuse->in(0) == use ) {\n+          if (useuse->in(0) == use) {\n@@ -2472,1 +2507,1 @@\n-            if( useuse->is_CFG() ) {\n+            if (useuse->is_CFG()) {\n@@ -2480,1 +2515,1 @@\n-          for( uint k = 1; k < useuse->req(); k++ ) {\n+          for (uint k = 1; k < useuse->req(); k++) {\n@@ -2497,2 +2532,2 @@\n-        r->set_req( 1, newuse );\n-        r->set_req( 2,    use );\n+        r->set_req(1, newuse);\n+        r->set_req(2,    use);\n@@ -2501,1 +2536,1 @@\n-        set_idom(r, !side_by_side_idom ? newuse->in(0) : side_by_side_idom, dd_r);\n+        set_idom(r, (side_by_side_idom == NULL) ? newuse->in(0) : side_by_side_idom, dd_r);\n@@ -2505,0 +2540,1 @@\n+}\n@@ -2506,31 +2542,16 @@\n-  \/\/ Step 4: If loop-invariant use is not control, it must be dominated by a\n-  \/\/ loop exit IfFalse\/IfTrue.  Find \"proper\" loop exit.  Make a Region\n-  \/\/ there if needed.  Make a Phi there merging old and new used values.\n-  Node_List *split_if_set = NULL;\n-  Node_List *split_bool_set = NULL;\n-  Node_List *split_cex_set = NULL;\n-  for( i = 0; i < loop->_body.size(); i++ ) {\n-    Node* old = loop->_body.at(i);\n-    clone_loop_handle_data_uses(old, old_new, loop, outer_loop, split_if_set,\n-                                split_bool_set, split_cex_set, worklist, new_counter,\n-                                mode);\n-  }\n-\n-  for (i = 0; i < extra_data_nodes.size(); i++) {\n-    Node* old = extra_data_nodes.at(i);\n-    clone_loop_handle_data_uses(old, old_new, loop, outer_loop, split_if_set,\n-                                split_bool_set, split_cex_set, worklist, new_counter,\n-                                mode);\n-  }\n-\n-  \/\/ Check for IFs that need splitting\/cloning.  Happens if an IF outside of\n-  \/\/ the loop uses a condition set in the loop.  The original IF probably\n-  \/\/ takes control from one or more OLD Regions (which in turn get from NEW\n-  \/\/ Regions).  In any case, there will be a set of Phis for each merge point\n-  \/\/ from the IF up to where the original BOOL def exists the loop.\n-  if (split_if_set) {\n-    while (split_if_set->size()) {\n-      Node *iff = split_if_set->pop();\n-      if (iff->in(1)->is_Phi()) {\n-        Node *b = clone_iff(iff->in(1)->as_Phi(), loop);\n-        _igvn.replace_input_of(iff, 1, b);\n+void PhaseIdealLoop::fix_body_edges(const Node_List &body, IdealLoopTree* loop, const Node_List &old_new, int dd,\n+                                    IdealLoopTree* parent, bool partial) {\n+  for(uint i = 0; i < body.size(); i++ ) {\n+    Node *old = body.at(i);\n+    Node *nnn = old_new[old->_idx];\n+    \/\/ Fix CFG\/Loop controlling the new node\n+    if (has_ctrl(old)) {\n+      set_ctrl(nnn, old_new[get_ctrl(old)->_idx]);\n+    } else {\n+      set_loop(nnn, parent);\n+      if (old->outcnt() > 0) {\n+        Node* dom = idom(old);\n+        if (old_new[dom->_idx] != NULL) {\n+          dom = old_new[dom->_idx];\n+          set_idom(nnn, dom, dd );\n+        }\n@@ -2539,8 +2560,14 @@\n-  }\n-  if (split_bool_set) {\n-    while (split_bool_set->size()) {\n-      Node *b = split_bool_set->pop();\n-      Node *phi = b->in(1);\n-      assert(phi->is_Phi(), \"\");\n-      CmpNode *cmp = clone_bool((PhiNode*)phi, loop);\n-      _igvn.replace_input_of(b, 1, cmp);\n+    \/\/ Correct edges to the new node\n+    for (uint j = 0; j < nnn->req(); j++) {\n+        Node *n = nnn->in(j);\n+        if (n != NULL) {\n+          IdealLoopTree *old_in_loop = get_loop(has_ctrl(n) ? get_ctrl(n) : n);\n+          if (loop->is_member(old_in_loop)) {\n+            if (old_new[n->_idx] != NULL) {\n+              nnn->set_req(j, old_new[n->_idx]);\n+            } else {\n+              assert(!body.contains(n), \"\");\n+              assert(partial, \"node not cloned\");\n+            }\n+          }\n+        }\n@@ -2548,0 +2575,1 @@\n+    _igvn.hash_find_insert(nnn);\n@@ -2549,7 +2577,10 @@\n-  if (split_cex_set) {\n-    while (split_cex_set->size()) {\n-      Node *b = split_cex_set->pop();\n-      assert(b->in(0)->is_Region(), \"\");\n-      assert(b->in(1)->is_Phi(), \"\");\n-      assert(b->in(0)->in(0) == b->in(1)->in(0), \"\");\n-      split_up(b, b->in(0), NULL);\n+}\n+\n+void PhaseIdealLoop::clone_loop_body(const Node_List& body, Node_List &old_new, CloneMap* cm) {\n+  for (uint i = 0; i < body.size(); i++) {\n+    Node* old = body.at(i);\n+    Node* nnn = old->clone();\n+    old_new.map(old->_idx, nnn);\n+    if (old->is_reduction()) {\n+      \/\/ Reduction flag is not copied by default. Copy it here when cloning the entire loop body.\n+      nnn->add_flag(Node::Flag_is_reduction);\n@@ -2557,0 +2588,4 @@\n+    if (C->do_vector_loop() && cm != NULL) {\n+      cm->verify_insert_and_clone(old, nnn, cm->clone_idx());\n+    }\n+    _igvn.register_new_node_with_optimizer(nnn);\n@@ -2558,1 +2593,0 @@\n-\n@@ -3773,0 +3807,275 @@\n+\/\/ Transform:\n+\/\/\n+\/\/ loop<-----------------+\n+\/\/  |                    |\n+\/\/ stmt1 stmt2 .. stmtn  |\n+\/\/  |     |        |     |\n+\/\/  \\     |       \/      |\n+\/\/    v   v     v        |\n+\/\/       region          |\n+\/\/         |             |\n+\/\/     shared_stmt       |\n+\/\/         |             |\n+\/\/         v             |\n+\/\/         if            |\n+\/\/         \/ \\           |\n+\/\/        |   -----------+\n+\/\/        v\n+\/\/\n+\/\/ into:\n+\/\/\n+\/\/    loop<-------------------+\n+\/\/     |                      |\n+\/\/     v                      |\n+\/\/ +->loop                    |\n+\/\/ |   |                      |\n+\/\/ |  stmt1 stmt2 .. stmtn    |\n+\/\/ |   |     |        |       |\n+\/\/ |   |      \\       \/       |\n+\/\/ |   |       v     v        |\n+\/\/ |   |        region1       |\n+\/\/ |   |           |          |\n+\/\/ |  shared_stmt shared_stmt |\n+\/\/ |   |           |          |\n+\/\/ |   v           v          |\n+\/\/ |   if          if         |\n+\/\/ |   \/\\          \/ \\        |\n+\/\/ +--   |         |   -------+\n+\/\/       \\         \/\n+\/\/        v       v\n+\/\/         region2\n+\/\/\n+\/\/ (region2 is shown to merge mirrored projections of the loop exit\n+\/\/ ifs to make the diagram clearer but they really merge the same\n+\/\/ projection)\n+\/\/\n+\/\/ Conditions for this transformation to trigger:\n+\/\/ - the path through stmt1 is frequent enough\n+\/\/ - the inner loop will be turned into a counted loop after transformation\n+bool PhaseIdealLoop::duplicate_loop_backedge(IdealLoopTree *loop, Node_List &old_new) {\n+  if (!DuplicateBackedge) {\n+    return false;\n+  }\n+  assert(!loop->_head->is_CountedLoop() || StressDuplicateBackedge, \"Non-counted loop only\");\n+  if (!loop->_head->is_Loop()) {\n+    return false;\n+  }\n+\n+  uint estimate = loop->est_loop_clone_sz(1);\n+  if (exceeding_node_budget(estimate)) {\n+    return false;\n+  }\n+\n+  LoopNode *head = loop->_head->as_Loop();\n+\n+  Node* region = NULL;\n+  IfNode* exit_test = NULL;\n+  uint inner;\n+  float f;\n+  if (StressDuplicateBackedge) {\n+    if (head->is_strip_mined()) {\n+      return false;\n+    }\n+    Node* c = head->in(LoopNode::LoopBackControl);\n+\n+    while (c != head) {\n+      if (c->is_Region()) {\n+        region = c;\n+      }\n+      c = idom(c);\n+    }\n+\n+    if (region == NULL) {\n+      return false;\n+    }\n+\n+    inner = 1;\n+  } else {\n+    \/\/ Is the shape of the loop that of a counted loop...\n+    Node* back_control = loop_exit_control(head, loop);\n+    if (back_control == NULL) {\n+      return false;\n+    }\n+\n+    BoolTest::mask bt = BoolTest::illegal;\n+    float cl_prob = 0;\n+    Node* incr = NULL;\n+    Node* limit = NULL;\n+    Node* cmp = loop_exit_test(back_control, loop, incr, limit, bt, cl_prob);\n+    if (cmp == NULL || cmp->Opcode() != Op_CmpI) {\n+      return false;\n+    }\n+\n+    \/\/ With an extra phi for the candidate iv?\n+    if (!incr->is_Phi()) {\n+      return false;\n+    }\n+\n+    PathFrequency pf(head, this);\n+    region = incr->in(0);\n+\n+    \/\/ Go over all paths for the extra phi's region and see if that\n+    \/\/ path is frequent enough and would match the expected iv shape\n+    \/\/ if the extra phi is removed\n+    inner = 0;\n+    for (uint i = 1; i < incr->req(); ++i) {\n+      Node* in = incr->in(i);\n+      Node* trunc1 = NULL;\n+      Node* trunc2 = NULL;\n+      const TypeInteger* iv_trunc_t = NULL;\n+      Node* orig_in = in;\n+      if (!(in = CountedLoopNode::match_incr_with_optional_truncation(in, &trunc1, &trunc2, &iv_trunc_t, T_INT))) {\n+        continue;\n+      }\n+      assert(in->Opcode() == Op_AddI, \"wrong increment code\");\n+      Node* xphi = NULL;\n+      Node* stride = loop_iv_stride(in, loop, xphi);\n+\n+      if (stride == NULL) {\n+        continue;\n+      }\n+\n+      PhiNode* phi = loop_iv_phi(xphi, NULL, head, loop);\n+      if (phi == NULL ||\n+          (trunc1 == NULL && phi->in(LoopNode::LoopBackControl) != incr) ||\n+          (trunc1 != NULL && phi->in(LoopNode::LoopBackControl) != trunc1)) {\n+        return false;\n+      }\n+\n+      f = pf.to(region->in(i));\n+      if (f > 0.5) {\n+        inner = i;\n+        break;\n+      }\n+    }\n+\n+    if (inner == 0) {\n+      return false;\n+    }\n+\n+    exit_test = back_control->in(0)->as_If();\n+  }\n+\n+  \/\/ Collect all control nodes that need to be cloned (shared_stmt in the diagram)\n+  Unique_Node_List wq;\n+  wq.push(head->in(LoopNode::LoopBackControl));\n+  for (uint i = 0; i < wq.size(); i++) {\n+    Node* c = wq.at(i);\n+    assert(get_loop(c) == loop, \"not in the right loop?\");\n+    if (c->is_Region()) {\n+      if (c != region) {\n+        for (uint j = 1; j < c->req(); ++j) {\n+          wq.push(c->in(j));\n+        }\n+      }\n+    } else {\n+      wq.push(c->in(0));\n+    }\n+    assert(!is_dominator(c, region) || c == region, \"shouldn't go above region\");\n+  }\n+\n+  Node* region_dom = idom(region);\n+\n+  \/\/ Can't do the transformation if this would cause a membar pair to\n+  \/\/ be split\n+  for (uint i = 0; i < wq.size(); i++) {\n+    Node* c = wq.at(i);\n+    if (c->is_MemBar() && (c->as_MemBar()->trailing_store() || c->as_MemBar()->trailing_load_store())) {\n+      assert(c->as_MemBar()->leading_membar()->trailing_membar() == c, \"bad membar pair\");\n+      if (!wq.member(c->as_MemBar()->leading_membar())) {\n+        return false;\n+      }\n+    }\n+  }\n+\n+  \/\/ Collect data nodes that need to be clones as well\n+  int dd = dom_depth(head);\n+\n+  for (uint i = 0; i < loop->_body.size(); ++i) {\n+    Node* n = loop->_body.at(i);\n+    if (has_ctrl(n)) {\n+      Node* c = get_ctrl(n);\n+      if (wq.member(c)) {\n+        wq.push(n);\n+      }\n+    } else {\n+      set_idom(n, idom(n), dd);\n+    }\n+  }\n+\n+  \/\/ clone shared_stmt\n+  clone_loop_body(wq, old_new, NULL);\n+\n+  Node* region_clone = old_new[region->_idx];\n+  region_clone->set_req(inner, C->top());\n+  set_idom(region, region->in(inner), dd);\n+\n+  \/\/ Prepare the outer loop\n+  Node* outer_head = new LoopNode(head->in(LoopNode::EntryControl), old_new[head->in(LoopNode::LoopBackControl)->_idx]);\n+  register_control(outer_head, loop->_parent, outer_head->in(LoopNode::EntryControl));\n+  _igvn.replace_input_of(head, LoopNode::EntryControl, outer_head);\n+  set_idom(head, outer_head, dd);\n+\n+  fix_body_edges(wq, loop, old_new, dd, loop->_parent, true);\n+\n+  \/\/ Make one of the shared_stmt copies only reachable from stmt1, the\n+  \/\/ other only from stmt2..stmtn.\n+  Node* dom = NULL;\n+  for (uint i = 1; i < region->req(); ++i) {\n+    if (i != inner) {\n+      _igvn.replace_input_of(region, i, C->top());\n+    }\n+    Node* in = region_clone->in(i);\n+    if (in->is_top()) {\n+      continue;\n+    }\n+    if (dom == NULL) {\n+      dom = in;\n+    } else {\n+      dom = dom_lca(dom, in);\n+    }\n+  }\n+\n+  set_idom(region_clone, dom, dd);\n+\n+  \/\/ Set up the outer loop\n+  for (uint i = 0; i < head->outcnt(); i++) {\n+    Node* u = head->raw_out(i);\n+    if (u->is_Phi()) {\n+      Node* outer_phi = u->clone();\n+      outer_phi->set_req(0, outer_head);\n+      Node* backedge = old_new[u->in(LoopNode::LoopBackControl)->_idx];\n+      if (backedge == NULL) {\n+        backedge = u->in(LoopNode::LoopBackControl);\n+      }\n+      outer_phi->set_req(LoopNode::LoopBackControl, backedge);\n+      register_new_node(outer_phi, outer_head);\n+      _igvn.replace_input_of(u, LoopNode::EntryControl, outer_phi);\n+    }\n+  }\n+\n+  \/\/ create control and data nodes for out of loop uses (including region2)\n+  Node_List worklist;\n+  uint new_counter = C->unique();\n+  fix_ctrl_uses(wq, loop, old_new, ControlAroundStripMined, outer_head, NULL, worklist);\n+\n+  Node_List *split_if_set = NULL;\n+  Node_List *split_bool_set = NULL;\n+  Node_List *split_cex_set = NULL;\n+  fix_data_uses(wq, loop, ControlAroundStripMined, head->is_strip_mined() ? loop->_parent : loop, new_counter, old_new, worklist, split_if_set, split_bool_set, split_cex_set);\n+\n+  finish_clone_loop(split_if_set, split_bool_set, split_cex_set);\n+\n+  if (exit_test != NULL) {\n+    float cnt = exit_test->_fcnt;\n+    if (cnt != COUNT_UNKNOWN) {\n+      exit_test->_fcnt = cnt * f;\n+      old_new[exit_test->_idx]->as_If()->_fcnt = cnt * (1 - f);\n+    }\n+  }\n+\n+  C->set_major_progress();\n+\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":416,"deletions":107,"binary":false,"changes":523,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Objects;\n+\n+\/*\n+ * @test\n+ * @bug 8279888\n+ * @summary Local variable independently used by multiple loops can interfere with loop optimizations\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestDuplicateBackedge\n+ *\/\n+\n+public class TestDuplicateBackedge {\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:LoopMaxUnroll=1\");\n+        TestFramework.runWithFlags(\"-XX:LoopMaxUnroll=1\", \"-XX:-DuplicateBackedge\");\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"DuplicateBackedge\", \"true\" }, counts = { IRNode.LOOP, \"1\", IRNode.COUNTEDLOOP, \"1\" })\n+    @IR(applyIf = { \"DuplicateBackedge\", \"false\" }, counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"DuplicateBackedge\", \"false\" }, failOn = { IRNode.COUNTEDLOOP })\n+    public static float test() {\n+        float res = 1;\n+        for (int i = 1;;) {\n+            if (i % 10 == 0) {\n+                i = (i * 2) + 1;\n+                res \/= 42;\n+            } else {\n+                i++;\n+                res *= 42;\n+            }\n+            if (i >= 1000) {\n+                break;\n+            }\n+        }\n+        return res;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestDuplicateBackedge.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Examine issues with (potentially) uninitialized locals interfering with\n+ * loop optimizations\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3)\n+@Warmup(iterations = 5, time = 2)\n+@Measurement(iterations = 5, time = 3)\n+@State(Scope.Thread)\n+public class LoopLocals {\n+\n+    public char[] bytesStartingWithNegative = \"\"\"\n+                 \\uFF11\n+                 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam ac sem eu\n+                 urna egestas placerat. Etiam finibus ipsum nulla, non mattis dolor cursus a.\n+                 Nulla nec nisl consectetur, lacinia neque id, accumsan ante. Curabitur et\n+                 sapien in magna porta ultricies. Sed vel pellentesque nibh. Pellentesque dictum\n+                 dignissim diam eu ultricies. Class aptent taciti sociosqu ad litora torquent\n+                 per conubia nostra, per inceptos himenaeos. Suspendisse erat diam, fringilla\n+                 sed massa sed, posuere viverra orci. Suspendisse tempor libero non gravida\n+                 efficitur. Vivamus lacinia risus non orci viverra, at consectetur odio laoreet.\n+                 Suspendisse potenti.\n+\n+                 Phasellus vel nisi iaculis, accumsan quam sed, bibendum eros. Sed venenatis\n+                 nulla tortor, et eleifend urna sodales id. Nullam tempus ac metus sit amet\n+                 sollicitudin. Nam sed ex diam. Praesent vitae eros et neque condimentum\n+                 consectetur eget non tortor. Praesent bibendum vel felis nec dignissim.\n+                 Maecenas a enim diam. Suspendisse quis ligula at nisi accumsan lacinia id\n+                 hendrerit sapien. Donec aliquam mattis lectus eu ultrices. Duis eu nisl\n+                 euismod, blandit mauris vel, placerat urna. Etiam malesuada enim purus,\n+                 tristique mollis odio blandit quis. Vivamus posuere.\n+                \"\"\".toCharArray();\n+\n+    public char[] bytesEndingWithNegative = \"\"\"\n+                 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam ac sem eu\n+                 urna egestas placerat. Etiam finibus ipsum nulla, non mattis dolor cursus a.\n+                 Nulla nec nisl consectetur, lacinia neque id, accumsan ante. Curabitur et\n+                 sapien in magna porta ultricies. Sed vel pellentesque nibh. Pellentesque dictum\n+                 dignissim diam eu ultricies. Class aptent taciti sociosqu ad litora torquent\n+                 per conubia nostra, per inceptos himenaeos. Suspendisse erat diam, fringilla\n+                 sed massa sed, posuere viverra orci. Suspendisse tempor libero non gravida\n+                 efficitur. Vivamus lacinia risus non orci viverra, at consectetur odio laoreet.\n+                 Suspendisse potenti.\n+\n+                 Phasellus vel nisi iaculis, accumsan quam sed, bibendum eros. Sed venenatis\n+                 nulla tortor, et eleifend urna sodales id. Nullam tempus ac metus sit amet\n+                 sollicitudin. Nam sed ex diam. Praesent vitae eros et neque condimentum\n+                 consectetur eget non tortor. Praesent bibendum vel felis nec dignissim.\n+                 Maecenas a enim diam. Suspendisse quis ligula at nisi accumsan lacinia id\n+                 hendrerit sapien. Donec aliquam mattis lectus eu ultrices. Duis eu nisl\n+                 euismod, blandit mauris vel, placerat urna. Etiam malesuada enim purus,\n+                 tristique mollis odio blandit quis. Vivamus posuere. \\uFF11\n+                \"\"\".toCharArray();\n+\n+    @Param({\"startNonASCII\", \"endNonASCII\", \"mixed\"})\n+    private String variant;\n+    private char[] val;\n+    @Setup\n+    public void setup() {\n+        val = switch (variant) {\n+            case \"startNonASCII\" -> bytesStartingWithNegative;\n+            case \"endNonASCII\" -> bytesEndingWithNegative;\n+            case \"mixed\" -> {\n+                char[] chars = bytesEndingWithNegative.clone();\n+                var random = new Random(0L);\n+                for (int i = 0; i < chars.length; i++) {\n+                    if (random.nextInt(100) < 30) {\n+                        chars[i] = (char)(chars[i] + random.nextInt(0x2F00));\n+                    }\n+                }\n+                yield chars;\n+            }\n+            default -> throw new RuntimeException(\"Unknown variant: \" + variant);\n+        };\n+    }\n+\n+    @Benchmark\n+    public byte[] loopsWithSharedLocal() {\n+        int dp = 0;\n+        int sp = 0;\n+        int sl = val.length >> 1;\n+        byte[] dst = new byte[sl * 3];\n+        char c;\n+        while (sp < sl && (c = getChar(val, sp)) < '\\u0080') {\n+            dst[dp++] = (byte)c;\n+            sp++;\n+        }\n+        while (sp < sl) {\n+            c = getChar(val, sp++);\n+            if (c < 0x80) {\n+                dst[dp++] = (byte)c;\n+            } else if (c < 0x800) {\n+                dst[dp++] = (byte)(0xc0 | (c >> 6));\n+                dst[dp++] = (byte)(0x80 | (c & 0x3f));\n+            } else if (Character.isSurrogate(c)) {\n+                int uc = -1;\n+                char c2;\n+                if (Character.isHighSurrogate(c) && sp < sl &&\n+                        Character.isLowSurrogate(c2 = getChar(val, sp))) {\n+                    uc = Character.toCodePoint(c, c2);\n+                }\n+                if (uc < 0) {\n+                    dst[dp++] = '?';\n+                } else {\n+                    dst[dp++] = (byte)(0xf0 | ((uc >> 18)));\n+                    dst[dp++] = (byte)(0x80 | ((uc >> 12) & 0x3f));\n+                    dst[dp++] = (byte)(0x80 | ((uc >>  6) & 0x3f));\n+                    dst[dp++] = (byte)(0x80 | (uc & 0x3f));\n+                    sp++;  \/\/ 2 chars\n+                }\n+            } else {\n+                \/\/ 3 bytes, 16 bits\n+                dst[dp++] = (byte)(0xe0 | ((c >> 12)));\n+                dst[dp++] = (byte)(0x80 | ((c >>  6) & 0x3f));\n+                dst[dp++] = (byte)(0x80 | (c & 0x3f));\n+            }\n+        }\n+        if (dp == dst.length) {\n+            return dst;\n+        }\n+        return Arrays.copyOf(dst, dp);\n+    }\n+\n+    @Benchmark\n+    public byte[] loopsWithScopedLocal() {\n+        int dp = 0;\n+        int sp = 0;\n+        int sl = val.length >> 1;\n+        byte[] dst = new byte[sl * 3];\n+        while (sp < sl) {\n+            \/\/ ascii fast loop;\n+            char c = getChar(val, sp);\n+            if (c >= '\\u0080') {\n+                break;\n+            }\n+            dst[dp++] = (byte)c;\n+            sp++;\n+        }\n+        while (sp < sl) {\n+            char c = getChar(val, sp++);\n+            if (c < 0x80) {\n+                dst[dp++] = (byte)c;\n+            } else if (c < 0x800) {\n+                dst[dp++] = (byte)(0xc0 | (c >> 6));\n+                dst[dp++] = (byte)(0x80 | (c & 0x3f));\n+            } else if (Character.isSurrogate(c)) {\n+                int uc = -1;\n+                char c2;\n+                if (Character.isHighSurrogate(c) && sp < sl &&\n+                        Character.isLowSurrogate(c2 = getChar(val, sp))) {\n+                    uc = Character.toCodePoint(c, c2);\n+                }\n+                if (uc < 0) {\n+                    dst[dp++] = '?';\n+                } else {\n+                    dst[dp++] = (byte)(0xf0 | ((uc >> 18)));\n+                    dst[dp++] = (byte)(0x80 | ((uc >> 12) & 0x3f));\n+                    dst[dp++] = (byte)(0x80 | ((uc >>  6) & 0x3f));\n+                    dst[dp++] = (byte)(0x80 | (uc & 0x3f));\n+                    sp++;  \/\/ 2 chars\n+                }\n+            } else {\n+                \/\/ 3 bytes, 16 bits\n+                dst[dp++] = (byte)(0xe0 | ((c >> 12)));\n+                dst[dp++] = (byte)(0x80 | ((c >>  6) & 0x3f));\n+                dst[dp++] = (byte)(0x80 | (c & 0x3f));\n+            }\n+        }\n+        if (dp == dst.length) {\n+            return dst;\n+        }\n+        return Arrays.copyOf(dst, dp);\n+    }\n+\n+    static char getChar(char[] val, int index) {\n+        return val[index];\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/LoopLocals.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"}]}