{"files":[{"patch":"@@ -423,0 +423,1 @@\n+    bool force_gc = false;\n@@ -427,12 +428,2 @@\n-      result = _allocator->attempt_allocation_locked(word_size);\n-      if (result != NULL) {\n-        return result;\n-      }\n-\n-      \/\/ If the GCLocker is active and we are bound for a GC, try expanding young gen.\n-      \/\/ This is different to when only GCLocker::needs_gc() is set: try to avoid\n-      \/\/ waiting because the GCLocker is active to not wait too long.\n-      if (GCLocker::is_active_and_needs_gc() && policy()->can_expand_young_list()) {\n-        \/\/ No need for an ergo message here, can_expand_young_list() does this when\n-        \/\/ it returns true.\n-        result = _allocator->attempt_allocation_force(word_size);\n+      if (policy()->can_mutator_consume_free_regions(1)) {\n+        result = _allocator->attempt_allocation_locked(word_size);\n@@ -442,0 +433,14 @@\n+\n+        \/\/ If the GCLocker is active and we are bound for a GC, try expanding young gen.\n+        \/\/ This is different to when only GCLocker::needs_gc() is set: try to avoid\n+        \/\/ waiting because the GCLocker is active to not wait too long.\n+        if (GCLocker::is_active_and_needs_gc() && policy()->can_expand_young_list()) {\n+          \/\/ No need for an ergo message here, can_expand_young_list() does this when\n+          \/\/ it returns true.\n+          result = _allocator->attempt_allocation_force(word_size);\n+          if (result != NULL) {\n+            return result;\n+          }\n+        }\n+      } else {\n+        force_gc = true;\n@@ -454,1 +459,1 @@\n-                                   GCCause::_g1_inc_collection_pause);\n+                                   GCCause::_g1_inc_collection_pause, force_gc);\n@@ -847,0 +852,1 @@\n+    bool force_gc = false;\n@@ -853,9 +859,13 @@\n-      \/\/ Given that humongous objects are not allocated in young\n-      \/\/ regions, we'll first try to do the allocation without doing a\n-      \/\/ collection hoping that there's enough space in the heap.\n-      result = humongous_obj_allocate(word_size);\n-      if (result != NULL) {\n-        size_t size_in_regions = humongous_obj_size_in_regions(word_size);\n-        policy()->old_gen_alloc_tracker()->\n-          add_allocated_humongous_bytes_since_last_gc(size_in_regions * HeapRegion::GrainBytes);\n-        return result;\n+      size_t size_in_regions = humongous_obj_size_in_regions(word_size);\n+      if (policy()->can_mutator_consume_free_regions((uint)size_in_regions)) {\n+        \/\/ Given that humongous objects are not allocated in young\n+        \/\/ regions, we'll first try to do the allocation without doing a\n+        \/\/ collection hoping that there's enough space in the heap.\n+        result = humongous_obj_allocate(word_size);\n+        if (result != NULL) {\n+          policy()->old_gen_alloc_tracker()->\n+            add_allocated_humongous_bytes_since_last_gc(size_in_regions * HeapRegion::GrainBytes);\n+          return result;\n+        }\n+      } else {\n+        force_gc = true;\n@@ -875,1 +885,1 @@\n-                                   GCCause::_g1_humongous_allocation);\n+                                   GCCause::_g1_humongous_allocation, force_gc);\n@@ -2638,1 +2648,2 @@\n-                                               GCCause::Cause gc_cause) {\n+                                               GCCause::Cause gc_cause,\n+                                               bool force_gc) {\n@@ -2643,1 +2654,2 @@\n-                               policy()->max_pause_time_ms());\n+                               policy()->max_pause_time_ms(),\n+                               force_gc);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":37,"deletions":25,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -764,1 +764,2 @@\n-                                GCCause::Cause gc_cause);\n+                                GCCause::Cause gc_cause,\n+                                bool           force_gc);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -72,0 +72,2 @@\n+  _predicted_survival_bytes_from_survivor(0),\n+  _predicted_survival_bytes_from_old(0),\n@@ -454,0 +456,1 @@\n+  calculate_required_regions_for_next_collect();\n@@ -785,0 +788,3 @@\n+  \/\/ Is this the right place? Should it be in the below?\n+  calculate_required_regions_for_next_collect();\n+\n@@ -1444,0 +1450,57 @@\n+bool G1Policy::can_mutator_consume_free_regions(uint alloc_region_count) {\n+  uint eden_count = _g1h->eden_regions_count();\n+  if (eden_count < 1) {\n+    return true;\n+  }\n+  size_t const predicted_survival_bytes_from_eden = _eden_surv_rate_group->accum_surv_rate_pred(eden_count) * HeapRegion::GrainBytes;\n+  size_t const total_predicted_survival_bytes = predicted_survival_bytes_from_eden + _predicted_survival_bytes_from_survivor + _predicted_survival_bytes_from_old;\n+  \/\/ adjust the total survival bytes by the target amount of wasted space in PLABs.\n+  \/\/ should old bytes be adjusted and turned into a region count on its own?\n+  size_t const adjusted_survival_bytes_bytes = (size_t)(total_predicted_survival_bytes * (100 + TargetPLABWastePct) \/ 100.0);\n+\n+  uint required_regions = ceil((double)adjusted_survival_bytes_bytes \/ (double)HeapRegion::GrainBytes);\n+  if (required_regions <= _g1h->num_free_regions() - alloc_region_count) {\n+    return true;\n+  }\n+  log_debug(gc, ergo, cset)(\"Forcing GC, insufficient free regions for GC predicted %u current eden %u (%u) survivor %u (%u) old %u (%u) free %u alloc %u\",\n+          required_regions,\n+          eden_count,\n+          (uint)(predicted_survival_bytes_from_eden \/ HeapRegion::GrainBytes),\n+          _g1h->survivor_regions_count(),\n+          (uint)(_predicted_survival_bytes_from_survivor \/ HeapRegion::GrainBytes),\n+          _g1h->old_regions_count(),\n+          (uint)(_predicted_survival_bytes_from_old \/ HeapRegion::GrainBytes),\n+          _g1h->num_free_regions(),\n+          alloc_region_count);\n+  return false;\n+}\n+\n+void G1Policy::calculate_required_regions_for_next_collect() {\n+  \/\/ calculate the survival bytes from survivor in the next GC\n+  size_t survivor_bytes = 0;\n+  const GrowableArray<HeapRegion*>* survivor_regions = _g1h->survivor()->regions();\n+  for (GrowableArrayIterator<HeapRegion*> it = survivor_regions->begin();\n+       it != survivor_regions->end();\n+       ++it) {\n+\n+    survivor_bytes += predict_bytes_to_copy(*it);\n+  }\n+  _predicted_survival_bytes_from_survivor = survivor_bytes;\n+\n+  \/\/ calculate the survival bytes from old in the next GC\n+  _predicted_survival_bytes_from_old = 0;\n+  G1CollectionSetCandidates *candidates = _collection_set->candidates();\n+  if ((candidates != NULL) && !candidates->is_empty()) {\n+    uint predicted_old_region_count = calc_min_old_cset_length();\n+    uint num_remaining = candidates->num_remaining();\n+    uint iterate_count = num_remaining < predicted_old_region_count ? num_remaining : predicted_old_region_count;\n+    uint current_index = candidates->cur_idx();\n+    size_t old_bytes = 0;\n+    for (uint i = 0; i < iterate_count; i++) {\n+      HeapRegion *region = candidates->at(current_index + i);\n+      old_bytes += predict_bytes_to_copy(region);\n+    }\n+    _predicted_survival_bytes_from_old = old_bytes;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":63,"deletions":0,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -101,0 +101,3 @@\n+  size_t _predicted_survival_bytes_from_survivor;\n+  size_t _predicted_survival_bytes_from_old;\n+\n@@ -365,0 +368,2 @@\n+  bool can_mutator_consume_free_regions(uint region_count);\n+  void calculate_required_regions_for_next_collect();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -109,1 +109,2 @@\n-                                                     double         target_pause_time_ms) :\n+                                                     double         target_pause_time_ms,\n+                                                     bool           force_gc) :\n@@ -112,0 +113,1 @@\n+  _force_gc(force_gc),\n@@ -123,1 +125,1 @@\n-  if (_word_size > 0) {\n+  if (_word_size > 0 && !_force_gc) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+  bool _force_gc;\n@@ -77,1 +78,2 @@\n-                            double         target_pause_time_ms);\n+                            double         target_pause_time_ms,\n+                            bool           force_gc = false);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -316,1 +316,1 @@\n-        private static Object[] holder = new Object[200]; \/\/ Must be larger than G1EvacuationFailureALotCount\n+        private static Object[] holder = new Object[800]; \/\/ Must be larger than G1EvacuationFailureALotCount\n@@ -321,1 +321,1 @@\n-            \/\/ Create 16 MB of garbage. This should result in at least one GC,\n+            \/\/ Create 64 MB of garbage. This should result in at least one GC,\n@@ -323,1 +323,2 @@\n-            \/\/ which is larger than G1EvacuationFailureALotInterval.\n+            \/\/ which is larger than G1EvacuationFailureALotInterval and enough\n+            \/\/ will survive to cause the evacuation failure.\n@@ -325,1 +326,1 @@\n-                holder[i % holder.length] = new byte[1024];\n+                holder[i % holder.length] = new byte[4096];\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"}]}