{"files":[{"patch":"@@ -254,5 +254,0 @@\n-    if (next->in(0) == uncommon_proj) {\n-      \/\/ Found the last data node in the chain. Do not break, because we might have some unprocessed nodes\n-      \/\/ on some path.\n-      continue;\n-    }\n@@ -273,1 +268,2 @@\n-      \/\/ For the last data node in the chain, we only need to update the control input to the new uncommon trap projection.\n+      \/\/ All data nodes with a control input to the uncommon projection in the chain need to be rewired to the new uncommon\n+      \/\/ projection (could not only be the last data node in the chain but also, for example, a DivNode within the chain).\n@@ -276,11 +272,11 @@\n-    } else {\n-      \/\/ All other nodes require a rewiring to the cloned input nodes.\n-      for (uint k = 1; k < next->req(); k++) {\n-        Node* in = next->in(k);\n-        if (!in->is_Phi()) {\n-          assert(!in->is_CFG(), \"must be data node\");\n-          Node* in_clone = old_new->at(in->_idx);\n-          if (in_clone != NULL && in_clone->_idx >= last_idx) {\n-            _igvn.replace_input_of(clone, k, in_clone);\n-            set_ctrl(clone, if_uct);\n-          }\n+    }\n+\n+    \/\/ Rewire the inputs of the cloned nodes to the old nodes to the new clones.\n+    for (uint k = 1; k < next->req(); k++) {\n+      Node* in = next->in(k);\n+      if (!in->is_Phi()) {\n+        assert(!in->is_CFG(), \"must be data node\");\n+        Node* in_clone = old_new->at(in->_idx);\n+        if (in_clone != NULL && in_clone->_idx >= last_idx) {\n+          _igvn.replace_input_of(clone, k, in_clone);\n+          set_ctrl(clone, if_uct);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileCommand=compileonly,compiler.loopopts.TestUnswitchWithSunkNodes::*\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileCommand=compileonly,compiler.loopopts.TestUnswitchWithSunkNodes::test*\n@@ -38,1 +38,1 @@\n-    static int iFld, iFld2, iFld3 = 4, iFld4;\n+    static int iFld, iFld2, iFld3 = 1, iFld4 = 1;\n@@ -49,0 +49,1 @@\n+        \/\/ The testcases with Divisions have additional control inputs which need to be taken care of\n@@ -50,0 +51,1 @@\n+        testNoDiamondDiv();\n@@ -51,0 +53,2 @@\n+        testWithDiamondDiv1();\n+        testWithDiamondDiv2();\n@@ -53,0 +57,1 @@\n+        testWithDiamondComplexDiv();\n@@ -75,1 +80,31 @@\n-                        switch (((i))) {\n+                        switch (i) {\n+                            case 88:\n+                                i26 += (i24);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testNoDiamondDiv() {\n+        int i, i2 = 10, i21, i22, i24, i26 = 41724, iArr2[] = new int[10];\n+        double d;\n+        float f2;\n+        init(iArr2);\n+        i = 1;\n+        while (++i < 219) {\n+            for (d = 15; 305 > d; ++d) {\n+                if (bFld) {\n+                    instanceCount = i2;\n+                    i2 = (((i2 + 3) + iFld2) + iFld3) \/ iFld4;\n+                }\n+                for (f2 = 5; 87 > f2; ++f2) {\n+                    i2 = (int) instanceCount;\n+                    for (i22 = 1; 2 > i22; i22++) {\n+                        if (bFld) {\n+                            iArr2[1] += 190L;\n+                        }\n+                    }\n+                    for (i24 = 1; 2 > i24; i24++) {\n+                        switch (i) {\n@@ -106,1 +141,61 @@\n-                        switch (((i))) {\n+                        switch (i) {\n+                            case 88:\n+                                i26 += (i24);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testWithDiamondDiv1() {\n+        int i, i2 = 10, i21, i22, i24, i26 = 41724, iArr2[] = new int[10];\n+        double d;\n+        float f2;\n+        init(iArr2);\n+        i = 1;\n+        while (++i < 219) {\n+            for (d = 15; 305 > d; ++d) {\n+                if (bFld) {\n+                    i2 = (i2 \/ iFld4) - (i2 \/ iFld3);\n+                }\n+                for (f2 = 5; 87 > f2; ++f2) {\n+                    i2 = (int) instanceCount;\n+                    for (i22 = 1; 2 > i22; i22++) {\n+                        if (bFld) {\n+                            iArr2[1] += 190L;\n+                        }\n+                    }\n+                    for (i24 = 1; 2 > i24; i24++) {\n+                        switch (i) {\n+                            case 88:\n+                                i26 += (i24);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testWithDiamondDiv2() {\n+        int i, i2 = 10, i21, i22, i24, i26 = 41724, iArr2[] = new int[10];\n+        double d;\n+        float f2;\n+        init(iArr2);\n+        i = 1;\n+        while (++i < 219) {\n+            for (d = 15; 305 > d; ++d) {\n+                if (bFld) {\n+                    instanceCount = i2;\n+                    int i3 = (int)d;\n+                    i2 = (i3 \/ iFld4) - (i3 \/ iFld3);\n+                }\n+                for (f2 = 5; 87 > f2; ++f2) {\n+                    i2 = (int) instanceCount;\n+                    for (i22 = 1; 2 > i22; i22++) {\n+                        if (bFld) {\n+                            iArr2[1] += 190L;\n+                        }\n+                    }\n+                    for (i24 = 1; 2 > i24; i24++) {\n+                        switch (i) {\n@@ -137,1 +232,1 @@\n-                        switch (((i))) {\n+                        switch (i) {\n@@ -181,1 +276,35 @@\n-                        switch (((i))) {\n+                        switch (i) {\n+                            case 88:\n+                                i26 += (i24);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testWithDiamondComplexDiv() {\n+        int i, i2 = 10, i21, i22, i24, i26 = 41724, iArr2[] = new int[10];\n+        double d;\n+        float f2;\n+        init(iArr2);\n+        i = 1;\n+        while (++i < 219) {\n+            for (d = 15; 305 > d; ++d) {\n+                if (bFld) {\n+                    instanceCount = i2;\n+                    int i3 = (int)d;\n+                    i2 = (i3 \/ iFld4) - (i3 \/ iFld3);\n+                    double d1 = (double) i2;\n+                    i3 = (int)((d1 + iFld4) - (d1 + iFld));\n+                    i2 = (i3 \/ iFld4) - (i3 \/ iFld3);\n+                }\n+                for (f2 = 5; 87 > f2; ++f2) {\n+                    i2 = (int) instanceCount;\n+                    for (i22 = 1; 2 > i22; i22++) {\n+                        if (bFld) {\n+                            iArr2[1] += 190L;\n+                        }\n+                    }\n+                    for (i24 = 1; 2 > i24; i24++) {\n+                        switch (i) {\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestUnswitchWithSunkNodes.java","additions":135,"deletions":6,"binary":false,"changes":141,"status":"modified"}]}