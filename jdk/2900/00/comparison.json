{"files":[{"patch":"@@ -0,0 +1,347 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.hexdump;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataInput;\n+import java.io.DataInputStream;\n+import java.io.DataOutput;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+\/*\n+ * @test\n+ * @summary Check ObjectStreamPrinter formatting\n+ * @library \/test\/lib\n+ * @run testng\/othervm -DDEBUG=true jdk.test.lib.hexdump.ObjectStreamPrinterTest\n+ *\/\n+\n+\/**\n+ * Test of the formatter is fairly coarse, formatting several\n+ * sample classes and spot checking the result string for key strings.\n+ *\/\n+@Test\n+public class ObjectStreamPrinterTest {\n+\n+    \/\/ Override with (-DDEBUG=true) to see all the output\n+    private static boolean DEBUG = Boolean.getBoolean(\"DEBUG\");\n+\n+    @DataProvider(name = \"serializables\")\n+    Object[][] serializables() {\n+        return new Object[][]{\n+                {new Object[]{\"abc\", \"def\"}, 0, 0, 2},\n+                {new Object[]{0, 1}, 2, 2, 0},\n+                {new Object[]{TimeUnit.DAYS, TimeUnit.SECONDS}, 2, 0, 2},\n+                {new Object[]{List.of(\"one\", \"two\", \"three\")}, 1, 1, 3},\n+                {new Object[]{genList()}, 1, 1, 2},\n+                {new Object[]{genMap()}, 1, 1, 5},\n+                {new Object[]{genProxy()}, 5, 2, 9},\n+                {new Object[]{new char[]{'x', 'y', 'z'},\n+                        new byte[]{0x61, 0x62, 0x63}, new int[]{4, 5, 6},\n+                        new float[]{1.0f, 2.0f, 3.1415927f},\n+                        new boolean[]{true, false, true},\n+                        new Object[]{\"first\", 3, 3.14159f}}, 9, 2, 1},\n+                { new Object[] {new XYPair(3, 5)}, 1, 1, 0},\n+        };\n+    }\n+\n+    @DataProvider(name = \"SingleObjects\")\n+    Object[][] sources() {\n+        return new Object[][]{\n+                {\"A Simple\", new A(), 1, 1, 0},\n+                {\"BNoDefaultRO has no call to defaultReadObject\", new BNoDefaultRO(), 2, 1, 1},\n+                {\"BDefaultRO has call to defaultReadObject\", new BDefaultRO(), 2, 1, 1},\n+                {\"CNoDefaultRO extends BNoDefaultRO with no fields\", new CNoDefaultRO(), 3, 1, 3},\n+                {\"CDefaultRO extends BDefaultRO with no fields\", new CDefaultRO(), 3, 1, 3},\n+        };\n+    }\n+\n+\n+    \/**\n+     * Checks the output of serializing an object, using HexPrinter\n+     * with an ObjectStreamPrinter formatter, and spot checking the number of\n+     * class descriptors, objects, and strings.\n+     *\n+     * @param objs an array of objects\n+     * @param descriptors the expected count of class descriptors\n+     * @param objects the expected count of objects\n+     * @param strings the expected count of strings\n+     * @throws IOException if any I\/O exception occurs\n+     *\/\n+    @Test(dataProvider = \"serializables\")\n+    public void testFormat(Object[] objs, int descriptors, int objects, int strings) throws IOException {\n+        byte[] bytes = serializeObjects(objs);\n+\n+        String result = HexPrinter.simple()\n+                .formatter(ObjectStreamPrinter.formatter())\n+                .toString(bytes);\n+        if (DEBUG)\n+            System.out.println(result);\n+        expectStrings(result, \"CLASSDESC #\", descriptors);\n+        expectStrings(result, \"OBJ #\", objects);\n+        expectStrings(result, \"STRING #\", strings);\n+    }\n+\n+    \/**\n+     * Checks the output of serializing an object, using an ObjectStreamPrinter formatter,\n+     * and spot checking the number of class descriptors, objects, and strings.\n+     *\n+     * @param objs an array of objects\n+     * @param descriptors the expected count of class descriptors\n+     * @param objects the expected count of objects\n+     * @param strings the expected count of strings\n+     * @throws IOException if any I\/O exception occurs\n+     *\/\n+    @Test(dataProvider = \"serializables\", enabled=true)\n+    static void standAlonePrinter(Object[] objs, int descriptors, int objects, int strings) throws IOException{\n+        byte[] bytes = serializeObjects(objs);\n+        StringBuilder sb = new StringBuilder();\n+\n+        try (InputStream in = new ByteArrayInputStream(bytes);\n+             DataInputStream din = new DataInputStream(in)) {\n+            var p = ObjectStreamPrinter.formatter();\n+            String s;\n+            while (!(s = p.annotate(din)).isEmpty()) {\n+                sb.append(s);\n+            }\n+        } catch (EOFException eof) {\n+            \/\/ Done\n+        } catch (IOException ioe) {\n+            ioe.printStackTrace();\n+        }\n+        String result = sb.toString();\n+        if (DEBUG)\n+            System.out.println(result);\n+        expectStrings(result, \"CLASSDESC #\", descriptors);\n+        expectStrings(result, \"OBJ #\", objects);\n+        expectStrings(result, \"STRING #\", strings);\n+    }\n+\n+    \/**\n+     * Checks the output of serializing an object, using HexPrinter\n+     * with an ObjectStreamPrinter formatter, and spot checking the number of\n+     * class descriptors, objects, and strings.\n+     *\n+     * @param label a label string for the object being serialized\n+     * @param o an object\n+     * @param descriptors the expected count of class descriptors\n+     * @param objects the expected count of objects\n+     * @param strings the expected count of strings\n+     * @throws IOException if any I\/O exception occurs\n+     *\/\n+    @Test(dataProvider = \"SingleObjects\")\n+    static void singleObjects(String label, Object o, int descriptors, int objects, int strings) throws IOException {\n+        if (DEBUG)\n+            System.out.println(\"Case: \" + label);\n+        ByteArrayOutputStream boas = new ByteArrayOutputStream();\n+        try (ObjectOutputStream os = new ObjectOutputStream(boas)) {\n+            os.writeObject(o);\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        byte[] bytes = boas.toByteArray();\n+        String result = HexPrinter.simple()\n+                .formatter(ObjectStreamPrinter.formatter(), \"\/\/ \", 120)\n+                .toString(bytes);\n+        if (DEBUG)\n+            System.out.println(result);\n+        expectStrings(result, \"CLASSDESC #\", descriptors);\n+        expectStrings(result, \"OBJ #\", objects);\n+        expectStrings(result, \"STRING #\", strings);\n+    }\n+\n+    \/**\n+     * A specific test case for (TC_LONGSTRING) of a stream\n+     * containing a very long (0x10000) character string.\n+     *\n+     * @throws IOException if any I\/O exception occurs\n+     *\/\n+    @Test\n+    static void longString() throws IOException {\n+        String large = \" 123456789abcedf\".repeat(0x1000);\n+\n+        ByteArrayOutputStream boas = new ByteArrayOutputStream();\n+        try (ObjectOutputStream os = new ObjectOutputStream(boas)) {\n+            os.writeObject(large);\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        byte[] bytes = boas.toByteArray();\n+        String result = HexPrinter.simple()\n+                .formatter(ObjectStreamPrinter.formatter(), \"\/\/ \", 16 * 8 - 1)\n+                .toString(bytes);\n+        long lineCount = result.lines().count();\n+        assertEquals(4610, lineCount, \"too many\/few lines in result\");\n+        if (DEBUG || lineCount != 4610) {\n+            \/\/ Show first few lines\n+            int off = 0;\n+            for (int c = 0; c < 4; c++)\n+                off = result.indexOf('\\n', off + 1);\n+            System.out.println(result.substring(0, off));\n+            System.out.println(\"...\");\n+        }\n+    }\n+\n+    \/**\n+     * Test the main method (without launching a separate process)\n+     * passing a file name as a parameter.\n+     * Each file should be formatted to stdout with no exceptions\n+     * @throws IOException if an I\/O exception occurs\n+     *\/\n+    @Test\n+    static void testMain() throws IOException {\n+        Object[] objs = {genList()};\n+        byte[] bytes = serializeObjects(objs);   \/\/ A serialized List\n+        Path p = Path.of(\"scratch.tmp\");\n+        Files.write(p, bytes);\n+        String[] args = {p.toString()};\n+        ObjectStreamPrinter.main(args);     \/\/ invoke main with the file name\n+    }\n+\n+    \/**\n+     * Serialize multiple objects to a single stream and return a byte array.\n+     * @param obj an array of Objects to serialize\n+     * @return a byte array with the serilized objects.\n+     * @throws IOException\n+     *\/\n+    private static byte[] serializeObjects(Object[] obj) throws IOException {\n+        byte[] bytes;\n+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+             ObjectOutputStream oos = new ObjectOutputStream(baos)) {\n+            for (Object o : obj)\n+                oos.writeObject(o);\n+            oos.flush();\n+            bytes = baos.toByteArray();\n+        }\n+        return bytes;\n+    }\n+\n+    \/**\n+     * Checks if the result string contains a number of key strings.\n+     * If not, it asserts an exception.\n+     * @param result the result string of formatting\n+     * @param key a key string to count\n+     * @param expectedCount the expected count of strings\n+     *\/\n+    static void expectStrings(String result, String key, int expectedCount) {\n+        int count = 0;\n+        for (int i = result.indexOf(key); i >= 0; i = result.indexOf(key, i + 1)) {\n+            count++;\n+        }\n+        assertEquals(count, expectedCount, \"Occurrences of \" + key);\n+    }\n+\n+    public static List<String> genList() {\n+        List<String> l = new ArrayList<>();\n+        l.add(\"abc\");\n+        l.add(\"def\");\n+        return l;\n+    }\n+\n+    public static Map<String, String> genMap() {\n+        Map<String, String> map = new HashMap<>();\n+        map.put(\"1\", \"One\");\n+        map.put(\"2\", \"Two\");\n+        map.put(\"2.2\", \"Two\");\n+        return map;\n+    }\n+\n+    public static Object genProxy() {\n+        InvocationHandler h = (InvocationHandler & Serializable) (Object proxy, Method method, Object[] args) -> null;\n+        Class<?>[] intf = new Class<?>[]{Serializable.class, DataInput.class, DataOutput.class};\n+        return Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), intf, h);\n+    }\n+\n+    static class A implements Serializable {\n+        private static final long serialVersionUID = 1L;\n+        int aIntValue = 1;\n+    }\n+    static class BNoDefaultRO extends A {\n+        private static final long serialVersionUID = 2L;\n+        private void writeObject(ObjectOutputStream os) throws IOException {\n+            os.writeInt(32);\n+            os.writeObject(\"bbb\");\n+        }\n+        private void readObject(ObjectInputStream is) throws IOException, ClassNotFoundException {\n+            is.readInt();\n+            is.readObject();\n+        }\n+    }\n+\n+    static class BDefaultRO extends A {\n+        private static final long serialVersionUID = 3L;\n+        private long bLongValue = 65535L;\n+        private void writeObject(ObjectOutputStream os) throws IOException {\n+            os.defaultWriteObject();\n+            os.writeInt(32);\n+            os.writeObject(\"bbb\");\n+        }\n+        private void readObject(ObjectInputStream is) throws IOException, ClassNotFoundException {\n+            is.defaultReadObject();\n+            is.readInt();\n+            is.readObject();\n+        }\n+    }\n+    static class CNoDefaultRO extends BNoDefaultRO {\n+        private static final long serialVersionUID = 4L;\n+        int cIntValue = Integer.MIN_VALUE;\n+        String cString = \"ccc\";\n+    }\n+    static class CDefaultRO extends BDefaultRO {\n+        private static final long serialVersionUID = 5L;\n+        int cIntvalue = Integer.MIN_VALUE;\n+        String cString = \"ccc\";\n+    }\n+\n+    static class XYPair implements Serializable {\n+        private static final long serialVersionUID = 6L;\n+        private int x;\n+        private int y;\n+        XYPair(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n+\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/hexdump\/ObjectStreamPrinterTest.java","additions":347,"deletions":0,"binary":false,"changes":347,"status":"added"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.hexdump;\n+\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataInput;\n+import java.io.DataInputStream;\n+import java.io.DataOutput;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+\/*\n+ * @test\n+ * @summary Test StreamDump utility\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.hexdump.StreamDump\n+ * @run testng jdk.test.lib.hexdump.StreamDumpTest\n+ *\/\n+\n+\/**\n+ * Test of the formatter is fairly coarse, formatting several\n+ * sample classes and spot checking the result string for key strings.\n+ *\/\n+@Test\n+public class StreamDumpTest {\n+\n+    private final static Path workDir = Path.of(\".\");\n+\n+    private final static String classpath = System.getProperty(\"test.class.path\", \".\");\n+\n+    private final static String testJDK = System.getProperty(\"test.jdk\");\n+\n+    private final static String testSRC = System.getProperty(\"test.src\", \".\");\n+\n+    private final static String serializedListPath = createTmpSer();\n+\n+    \/**\n+     * Create a file containing an example serialized list.\n+     * @return the path to the file.\n+     *\/\n+    private static String createTmpSer() {\n+        try {\n+            Object[] objs = {genList()};\n+            byte[] bytes = serializeObjects(objs);   \/\/ A serialized List\n+            Path path = Files.createTempFile(workDir, \"list\", \".ser\");\n+            Files.write(path, bytes);\n+            return path.toString();\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n+        }\n+    }\n+\n+    \/**\n+     * Arguments lists to be passed when invoking StreamDump.\n+     * Arg list and the expected exit status, stdout line count, and stderr line count.\n+     * @return array of argument list arrays.\n+     *\/\n+    @DataProvider(name = \"serializables\")\n+    Object[][] serializables() {\n+        return new Object[][] {\n+                {new String[]{testSRC + \"\/openssl.p12.pem\"},\n+                        0, 126, 0},\n+                {new String[]{\"--formatter\", \"jdk.test.lib.hexdump.ASN1Formatter\", testSRC + \"\/openssl.p12.pem\"},\n+                        0, 126, 0},\n+                {new String[]{serializedListPath},\n+                        0, 19, 0},\n+                {new String[]{\"--formatter\", \"jdk.test.lib.hexdump.ObjectStreamPrinter\", serializedListPath},\n+                        0, 19, 0},\n+                {new String[]{},\n+                        1, 2, 0},    \/\/ no file arguments\n+                {new String[]{\"--formatter\"},\n+                        1, 2, 0},       \/\/ --formatter option requires a class name\n+                {new String[]{\"-formatter\", \"jdk.test.lib.hexdump.ObjectStreamPrinter\"},\n+                        1, 2, 0},       \/\/ options start with double \"--\"\n+        };\n+    }\n+\n+\n+    \/**\n+     * Test the main method (without launching a separate process)\n+     * passing a file name as a parameter.\n+     * Each file should be formatted to stdout with no exceptions\n+     * @throws IOException if an I\/O exception occurs\n+     *\/\n+    @Test(dataProvider=\"serializables\")\n+    static void testStreamDump(String[] args, int expectedStatus, int expectedStdout, int expectedStderr) throws IOException {\n+        List<String> argList = new ArrayList<>();\n+        argList.add(testJDK + \"\/bin\/\" + \"java\");\n+        argList.add(\"-classpath\");\n+        argList.add(classpath);\n+        argList.add(\"jdk.test.lib.hexdump.StreamDump\");\n+        argList.addAll(Arrays.asList(args));\n+\n+        Path stdoutPath = Files.createTempFile(workDir, \"stdout\", \".log\");\n+        Path stderrPath = Files.createTempFile(workDir, \"stderr\", \".log\");\n+\n+        ProcessBuilder pb = new ProcessBuilder(argList);\n+        pb.redirectOutput(stdoutPath.toFile());\n+        pb.redirectOutput(stdoutPath.toFile());\n+\n+        System.out.println(\"args: \" + argList);\n+        Process p = pb.start();\n+        try {\n+            int actualStatus = p.waitFor();\n+            fileCheck(stdoutPath, expectedStdout);\n+            fileCheck(stderrPath, expectedStderr);\n+            assertEquals(actualStatus, expectedStatus, \"Unexpected exit status\");\n+        } catch (InterruptedException ie) {\n+            ie.printStackTrace();\n+        }\n+    }\n+\n+    \/**\n+     * Check that the file exists and contains the expected number of lines.\n+     * @param path a file path\n+     * @param expectedLines the number of lines expected\n+     * @throws IOException if an I\/O exception occurs\n+     *\/\n+    static void fileCheck(Path path, int expectedLines) throws IOException {\n+        long actualLines = Files.newBufferedReader(path).lines().count();\n+        if (actualLines != expectedLines) {\n+            System.out.printf(\"%s: lines %d, expected: %d%n\", path, actualLines, expectedLines);\n+            System.out.println(\"---Begin---\");\n+            Files.newBufferedReader(path).lines().forEach(s -> System.out.println(s));\n+            System.out.println(\"----End----\");\n+        }\n+        assertEquals(actualLines, expectedLines, \"Unexpected line count\");\n+    }\n+\n+    \/**\n+     * Serialize multiple objects to a single stream and return a byte array.\n+     *\n+     * @param obj an array of Objects to serialize\n+     * @return a byte array with the serilized objects.\n+     * @throws IOException if an I\/O exception occurs\n+     *\/\n+    private static byte[] serializeObjects(Object[] obj) throws IOException {\n+        byte[] bytes;\n+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+             ObjectOutputStream oos = new ObjectOutputStream(baos)) {\n+            for (Object o : obj)\n+                oos.writeObject(o);\n+            oos.flush();\n+            bytes = baos.toByteArray();\n+        }\n+        return bytes;\n+    }\n+\n+    public static List<String> genList() {\n+        List<String> l = new ArrayList<>();\n+        l.add(\"abc\");\n+        l.add(\"def\");\n+        return l;\n+    }\n+\n+    public static Map<String, String> genMap() {\n+        Map<String, String> map = new HashMap<>();\n+        map.put(\"1\", \"One\");\n+        map.put(\"2\", \"Two\");\n+        map.put(\"2.2\", \"Two\");\n+        return map;\n+    }\n+\n+\n+\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/hexdump\/StreamDumpTest.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -0,0 +1,908 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.test.lib.hexdump;\n+\n+import java.io.CharArrayWriter;\n+import java.io.DataInputStream;\n+import java.io.EOFException;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.ObjectStreamConstants;\n+import java.io.PrintWriter;\n+import java.io.UTFDataFormatException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.function.BiConsumer;\n+\n+import static java.io.ObjectStreamConstants.STREAM_MAGIC;\n+import static java.io.ObjectStreamConstants.TC_BLOCKDATA;\n+import static java.io.ObjectStreamConstants.TC_BLOCKDATALONG;\n+import static java.io.ObjectStreamConstants.TC_ENDBLOCKDATA;\n+import static java.io.ObjectStreamConstants.TC_MAX;\n+import static java.io.ObjectStreamConstants.TC_NULL;\n+import static java.io.ObjectStreamConstants.baseWireHandle;\n+\n+\/**\n+ * Object Serialization stream annotation printer.\n+ * On the first call, the stream header is expected, raw bytes\n+ * are printed until the header is found.\n+ * Each call decodes a hierarchy rooted at the first typecode.\n+ * Unrecognized bytes are read and printed.\n+ *\/\n+public class ObjectStreamPrinter implements HexPrinter.Formatter {\n+\n+    private int nextHandle = 0;\n+    private List<Handle> labels = new ArrayList<>();\n+\n+    \/**\n+     * Returns an ObjectStreamPrinter.\n+     * @return an ObjectStreamPrinter\n+     *\/\n+    public static ObjectStreamPrinter formatter() {\n+        return new ObjectStreamPrinter();\n+    }\n+\n+    \/**\n+     * Create a ObjectStreamPrinter.\n+     *\/\n+    private ObjectStreamPrinter() {\n+    }\n+\n+    \/**\n+     * Read bytes from the stream and annotate the stream as a\n+     * ObjectInputStream. Each call to convert() reads an object.\n+     * Before the first object is read, the Stream header is expected and annotated.\n+     * Unrecognized bytes are printed as decimal values.\n+     *\n+     * @param in  a DataInputStream\n+     * @return a string representation of the ObjectInputStream\n+     *\/\n+    public String annotate(DataInputStream in) throws IOException {\n+        StringBuilder sb = new StringBuilder();\n+        try {\n+            this.annotate(in, sb);\n+        } catch (IOException e) {\n+            \/\/ ignore the exception so the accumulated output can be returned\n+        }\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Read bytes from the stream and annotate the stream as a\n+     * ObjectInputStream. Each call to convert() reads an object.\n+     * Before the first object is read, the Stream header is expected\n+     * and annotated.\n+     * Unrecognized bytes are printed as decimal values.\n+     *\n+     * @param in  a DataInputStream\n+     * @param out an Appendable for the output\n+     *\/\n+    @Override\n+    public void annotate(DataInputStream in, Appendable out) throws IOException {\n+        annotate(in, out, 0);\n+    }\n+\n+    \/**\n+     * Read bytes from the stream and annotate the stream as a\n+     * ObjectInputStream. Each call to convert() reads an object.\n+     * The Stream header is expected and annotated.\n+     * Unrecognized bytes are printed as decimal values.\n+     *\n+     * @param in  a DataInputStream\n+     * @param out an Appendable for the output\n+     * @param indent indentation level\n+     *\/\n+    public void annotate(DataInputStream in, Appendable out, int indent) throws IOException {\n+        \/\/ Read and format a single object, if its the header format another\n+        if (formatObject(in, out, indent).equals(HEADER_HANDLE))\n+            formatObject(in, out, indent);\n+    }\n+\n+    \/**\n+     * Read and format objects in the stream based on the type code.\n+     * Unrecognized type codes are printed in decimal.\n+     *\n+     * @param in input stream\n+     * @param infoOut output stream\n+     * @param indent indentation level\n+     * @return a label for the object just read\n+     * @throws IOException if an error occurs on the stream\n+     *\/\n+    Handle formatObject(DataInputStream in, Appendable infoOut, int indent) throws IOException {\n+        int tc;\n+        if (((tc = in.read()) < TC_NULL || tc > TC_MAX) && tc != ((STREAM_MAGIC >>> 8) & 0xff)) {\n+            if (tc < 0)\n+                throw new EOFException();\n+            infoOut.append(\"raw: [ \" + tc + \" \");\n+            while ((tc = in.read()) >= 0 && (tc < TC_NULL || tc > TC_MAX)) {\n+                infoOut.append(tc + \" \");\n+            }\n+            infoOut.append(\"] \");\n+            if (tc < 0)\n+                throw new EOFException();\n+        }\n+        switch (tc) {\n+            case TC_NULL:\n+                return formatTC_NULL(in, infoOut);\n+            case ObjectStreamConstants.TC_REFERENCE:\n+                return formatTC_REFERENCE(in, infoOut);\n+            case ObjectStreamConstants.TC_CLASSDESC:\n+                return formatTC_CLASSDESC(in, infoOut, indent);\n+            case ObjectStreamConstants.TC_OBJECT:\n+                return formatTC_OBJECT(in, infoOut, indent);\n+            case ObjectStreamConstants.TC_STRING:\n+                return formatTC_STRING(in, infoOut, indent);\n+            case ObjectStreamConstants.TC_ARRAY:\n+                return formatTC_ARRAY(in, infoOut, indent);\n+            case ObjectStreamConstants.TC_CLASS:\n+                return formatTC_CLASS(in, infoOut, indent);\n+            case ObjectStreamConstants.TC_BLOCKDATA:\n+                return formatTC_BLOCKDATA(in, infoOut);\n+            case ObjectStreamConstants.TC_ENDBLOCKDATA:\n+                return formatTC_ENDBLOCKDATA(in, infoOut);\n+            case ObjectStreamConstants.TC_RESET:\n+                return formatTC_RESET(in, infoOut);\n+            case ObjectStreamConstants.TC_BLOCKDATALONG:\n+                return formatTC_BLOCKDATALONG(in, infoOut);\n+            case ObjectStreamConstants.TC_EXCEPTION:\n+                return formatTC_EXCEPTION(in, infoOut);\n+            case ObjectStreamConstants.TC_LONGSTRING:\n+                return formatTC_LONGSTRING(in, infoOut);\n+            case ObjectStreamConstants.TC_PROXYCLASSDESC:\n+                return formatTC_PROXYCLASSDESC(in, infoOut, indent);\n+            case ObjectStreamConstants.TC_ENUM:\n+                return formatTC_ENUM(in, infoOut, indent);\n+            case (STREAM_MAGIC >>> 8) & 0xff:\n+                return formatSTREAM_MAGIC(in, infoOut, indent);\n+            default:\n+                infoOut.append(\"data: \" + tc + ' ');\n+                return EMPTY_HANDLE;\n+        }\n+    }\n+\n+    \/**\n+     * Read and print a UTF string tagged as a string.\n+     *\n+     * @param in input stream\n+     * @param infoOut output stream\n+     * @param indent indentation level\n+     * @return a label for the object just read\n+     * @throws IOException if an error occurs on the stream\n+     *\/\n+    private Handle formatTC_STRING(DataInputStream in, Appendable infoOut, int indent)\n+            throws IOException {\n+        String s = in.readUTF();\n+        Handle handle = new Handle(s);\n+        setLabel(nextHandle, handle);\n+        infoOut.append(String.format(\"STRING #%d \\\"%s\\\" \", nextHandle++, s));\n+        return handle;\n+    }\n+\n+    \/**\n+     * Read and print a long UTF string.\n+     *\n+     * @param in input stream\n+     * @param infoOut output stream\n+     * @return a label for the object just read\n+     * @throws IOException if an error occurs on the stream\n+     *\/\n+    private Handle formatTC_LONGSTRING(DataInputStream in, Appendable infoOut) throws IOException {\n+        long utflen = in.readLong();\n+        String s = \"longstring \" + nextHandle + \",len: \" + utflen;\n+        Handle handle = new Handle(s);\n+        setLabel(nextHandle, handle);\n+        infoOut.append(String.format(\"LONGSTRING #%d \\\"\", nextHandle++));\n+\n+        long count = 0;\n+        while (count < utflen) {\n+            int c = (char)(in.readUnsignedByte() & 0xff);\n+            int char2, char3;\n+            switch (c >> 4) {\n+                case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:\n+                    \/* 0xxxxxxx*\/\n+                    count++;\n+                    break;\n+                case 12: case 13:\n+                    \/* 110x xxxx   10xx xxxx*\/\n+                    count += 2;\n+                    if (count > utflen)\n+                        throw new UTFDataFormatException(\n+                                \"malformed input: partial character at end\");\n+                    char2 = in.readUnsignedByte() & 0xff;\n+                    if ((char2 & 0xC0) != 0x80)\n+                        throw new UTFDataFormatException(\n+                                \"malformed input around byte \" + count);\n+                    c = (char)(((c & 0x1F) << 6) | (char2 & 0x3F));\n+                    break;\n+                case 14:\n+                    \/* 1110 xxxx  10xx xxxx  10xx xxxx *\/\n+                    count += 3;\n+                    if (count > utflen)\n+                        throw new UTFDataFormatException(\n+                                \"malformed input: partial character at end\");\n+                    char2 = in.readUnsignedByte() & 0xff;\n+                    char3 = in.readUnsignedByte() & 0xff;\n+                    if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80))\n+                        throw new UTFDataFormatException(\n+                                \"malformed input around byte \" + (count-1));\n+                    c = (char)(((c     & 0x0F) << 12) |\n+                            ((char2 & 0x3F) << 6)  |\n+                            ((char3 & 0x3F) << 0));\n+                    break;\n+                default:\n+                    \/* 10xx xxxx,  1111 xxxx *\/\n+                    throw new UTFDataFormatException(\n+                            \"malformed input around byte \" + count);\n+            }\n+            infoOut.append((char)c);\n+        }\n+        infoOut.append(\"\\\" \");\n+        return handle;\n+    }\n+\n+    \/**\n+     * Format a null.\n+     *\n+     * @param in input stream\n+     * @param infoOut output stream\n+     * @return a label for the object just read\n+     * @throws IOException if an error occurs on the stream\n+     *\/\n+    private Handle formatTC_NULL(DataInputStream in, Appendable infoOut) throws IOException {\n+        infoOut.append(\"NULL; \");\n+        return NULL_HANDLE;\n+    }\n+\n+    \/**\n+     * Read and format a reference to a previously read object.\n+     *\n+     * @param in input stream\n+     * @param infoOut output stream\n+     * @return a label for the object just read\n+     * @throws IOException if an error occurs on the stream\n+     *\/\n+    private Handle formatTC_REFERENCE(DataInputStream in, Appendable infoOut) throws IOException {\n+        int offset = in.readInt();\n+        int h = offset - baseWireHandle;\n+        Handle handle = getHandle(h);\n+        infoOut.append(\"REF #\" + h + ' ' + getLabel(h) + ' ');\n+        return handle;\n+    }\n+\n+    \/**\n+     * Read and format a class descriptor.\n+     *\n+     * @param in input stream\n+     * @param infoOut output stream\n+     * @return a label for the object just read\n+     * @throws IOException if an error occurs on the stream\n+     *\/\n+    private Handle formatTC_CLASSDESC(DataInputStream in, Appendable infoOut, int indent) throws IOException {\n+        char[] buf = new char[1];       \/\/ buffer for 1 char type names\n+        String name = in.readUTF();\n+        ClassHandle handle = new ClassHandle(name);\n+        setLabel(nextHandle, handle);\n+        infoOut.append(String.format(\"CLASSDESC #%d %s\", nextHandle++, name));\n+        newlineIndent(infoOut, indent + 2);\n+        long svid = in.readLong();\n+        infoOut.append(String.format(\"svid: %dL\", svid));\n+        newlineIndent(infoOut, indent + 2);\n+        int flags = in.readUnsignedByte();\n+        handle.setFlags(flags);\n+        StringJoiner flagsJoiner = new StringJoiner(\", \");\n+        if (handle.hasFlag(ObjectStreamConstants.SC_WRITE_METHOD)) flagsJoiner.add(\"WRITE_OBJECT\");\n+        if (handle.hasFlag(ObjectStreamConstants.SC_SERIALIZABLE)) flagsJoiner.add(\"SERIALIZABLE\");\n+        if (handle.hasFlag(ObjectStreamConstants.SC_EXTERNALIZABLE)) flagsJoiner.add(\"EXTERNALIZABLE\");\n+        if (handle.hasFlag(ObjectStreamConstants.SC_BLOCK_DATA)) flagsJoiner.add(\"BLOCK_DATA\");\n+        if (handle.hasFlag(ObjectStreamConstants.SC_ENUM)) flagsJoiner.add(\"ENUM\");\n+        infoOut.append(String.format(\"flags: %s\", flagsJoiner.toString()));\n+\n+        newlineIndent(infoOut, indent + 2);\n+        int numFields = in.readShort();\n+        {   \/\/ Append list of fields\n+            infoOut.append(String.format(\"%d field(s) {\", numFields));\n+            CharArrayWriter caw = new CharArrayWriter();\n+            for (int i = 0; i < numFields; i++) {\n+                newlineIndent(infoOut, indent + 4);\n+                buf[0] = (char) in.readByte();\n+                String fname = in.readUTF();\n+                caw.write(buf[0]);\n+                caw.write(' ');\n+                caw.write(fname);\n+                caw.write(' ');\n+                String typeName;\n+                if ((buf[0] == 'L') || (buf[0] == '[')) {\n+                    typeName = formatObject(in, caw, 0).toString();\n+                } else {\n+                    typeName = new String(buf);\n+                    caw.write(mapClassName(typeName).toString());\n+                }\n+                caw.write(\"; \");\n+                infoOut.append(caw.toString());\n+                caw.reset();\n+                handle.addField(fname, typeName);   \/\/ Add field to handle\n+            }\n+            if (numFields > 0)\n+                newlineIndent(infoOut, indent + 2);\n+            infoOut.append(\"} \");\n+        }\n+        skipCustomData(in, infoOut, indent);\n+        newlineIndent(infoOut, indent + 2);\n+        infoOut.append(\"Super: \");\n+        Handle sup = formatObject(in, infoOut, indent);\n+        if (sup instanceof ClassHandle) {\n+            handle.superClass((ClassHandle)sup);\n+        }\n+        return handle;\n+    }\n+\n+    private Appendable newlineIndent(Appendable infoOut, int indent) throws IOException {\n+        return infoOut.append(System.lineSeparator()).append(\" \".repeat(indent));\n+    }\n+\n+    \/**\n+     * Read and format custom data until end of block data.\n+     *\n+     * @param in input stream\n+     * @param infoOut output stream\n+     * @throws IOException if an error occurs on the stream\n+     *\/\n+    private void skipCustomData(DataInputStream in, Appendable infoOut, int indent) throws IOException {\n+        while (!formatObject(in, infoOut, indent).equals(END_HANDLE)) {\n+            \/\/ ignore anything but ENDBLOCK\n+        }\n+    }\n+\n+    \/**\n+     * Read and format a proxy class descriptor.\n+     *\n+     * @param in input stream\n+     * @param infoOut output stream\n+     * @return a label for the object just read\n+     * @throws IOException if an error occurs on the stream\n+     *\/\n+    private Handle formatTC_PROXYCLASSDESC(DataInputStream in, Appendable infoOut, int indent) throws IOException {\n+        int numIfaces = in.readInt();\n+        setLabel(nextHandle, CLASS_HANDLE);\n+        infoOut.append(String.format(\"PROXYCLASSDESC #%d %d \",\n+                nextHandle++, numIfaces));\n+        if (numIfaces > 0) {\n+            CharArrayWriter caw = new CharArrayWriter();\n+            PrintWriter pw = new PrintWriter(caw);\n+            pw.append(\"{\");\n+            String delim = \"\";\n+            for (int i = 0; i < numIfaces; i++, delim = \", \") {\n+                caw.write(delim);\n+                caw.write(in.readUTF());\n+            }\n+            pw.write(\"} \");\n+            infoOut.append(caw.toString());\n+        }\n+        skipCustomData(in, infoOut, indent);\n+        newlineIndent(infoOut, indent + 2);\n+        infoOut.append(\"Super: \");\n+        formatObject(in, infoOut, indent);\n+        return CLASS_HANDLE;\n+    }\n+\n+    \/**\n+     * Read and format a class.\n+     *\n+     * @param in input stream\n+     * @param infoOut output stream\n+     * @param indent indentation level\n+     * @return a label for the object just read\n+     * @throws IOException if an error occurs on the stream\n+     *\/\n+    private Handle formatTC_CLASS(DataInputStream in, Appendable infoOut, int indent) throws IOException {\n+        Handle label = new Handle(\"class#\" + nextHandle);\n+        setLabel(nextHandle, label);\n+        infoOut.append(String.format(\"CLASS #%d; \", nextHandle++));\n+        formatObject(in, infoOut, indent);\n+        return label;\n+    }\n+\n+    \/**\n+     * Read and format an instance.\n+     *\n+     * @param in input stream\n+     * @param infoOut output stream\n+     * @param indent indentation level\n+     * @return a label for the object just read\n+     * @throws IOException if an error occurs on the stream\n+     *\/\n+    private Handle formatTC_OBJECT(DataInputStream in, Appendable infoOut, int indent) throws IOException {\n+        infoOut.append(\"READ \");\n+        Handle type = formatObject(in, infoOut, indent);\n+        setLabel(nextHandle, OBJ_HANDLE);\n+        newlineIndent(infoOut, indent);\n+        infoOut.append(String.format(\"OBJ #%d %s \", nextHandle++, type.label()));\n+\n+        if (type instanceof ClassHandle) {\n+            ClassHandle[] types =  ((ClassHandle) type).allClasses();\n+            for (ClassHandle ch : types) {\n+                ch.forEachField((n, v) -> {\n+                    try {\n+                        newlineIndent(infoOut, indent + 2).append(n).append(\":\");\n+                        var cl = mapClassName(v.substring(0, 1));\n+                        if (cl != Object.class) {\n+                            var f = HexPrinter.getFormatter(cl, \"%s \");\n+                            f.annotate(in, infoOut);\n+                        } else {\n+                            formatObject(in, infoOut, indent + 2);\n+                        }\n+                    } catch (IOException ioe) {\n+                        \/\/ ignore\n+                    }\n+                });\n+                \/\/ Check for Custom data followed by ENDBLOCK, if there was a writeObject method\n+                if (ch.hasFlag(ObjectStreamConstants.SC_WRITE_METHOD)) {\n+                    newlineIndent(infoOut, indent + 2);\n+                    infoOut.append(\"CustomData: \");\n+                    Handle skipped;\n+                    do {\n+                        newlineIndent(infoOut, indent + 4);\n+                        skipped = formatObject(in, infoOut, indent + 4);\n+                    } while (!skipped.equals(END_HANDLE));\n+                }\n+            }\n+        }\n+        return OBJ_HANDLE;\n+    }\n+\n+    \/**\n+     * Read and format an Enum.\n+     *\n+     * @param in input stream\n+     * @param infoOut output stream\n+     * @param indent indentation level\n+     * @return a label for the object just read\n+     * @throws IOException if an error occurs on the stream\n+     *\/\n+    private Handle formatTC_ENUM(DataInputStream in, Appendable infoOut, int indent) throws IOException {\n+        setLabel(nextHandle, ENUM_HANDLE);\n+        infoOut.append(String.format(\"READ \"));\n+        Handle enumType = formatObject(in, infoOut, indent);\n+        Handle h = formatObject(in, infoOut, indent + 2);\n+        setLabel(nextHandle, h);\n+        newlineIndent(infoOut, indent);\n+        infoOut.append(String.format(\"ENUM #%d %s.%s \", nextHandle++, enumType.label(), h.label()));\n+\n+        return ENUM_HANDLE;\n+    }\n+\n+    \/**\n+     * Read and format an array.\n+     *\n+     * @param in input stream\n+     * @param infoOut output stream\n+     * @param indent indentation level\n+     * @return a label for the object just read\n+     * @throws IOException if an error occurs on the stream\n+     *\/\n+    private Handle formatTC_ARRAY(DataInputStream in, Appendable infoOut, int indent) throws IOException {\n+        infoOut.append(\"READ \");\n+        Handle type = formatObject(in, infoOut, indent);\n+        newlineIndent(infoOut, indent);\n+        setLabel(nextHandle, ARRAY_HANDLE);\n+        int nelements = in.readInt();\n+        infoOut.append(String.format(\"ARRAY #%d \", nextHandle++));\n+\n+        infoOut.append(String.format(\"%d\", nelements));\n+        if (type.toString().charAt(0) == '[') {\n+            infoOut.append(\"[\");\n+            formatArray(in, infoOut, nelements, type.toString().charAt(1), indent + 2);\n+            infoOut.append(\"] \");\n+        }\n+        return ARRAY_HANDLE;\n+    }\n+\n+    \/**\n+     * Read and format block data.\n+     *\n+     * @param in input stream\n+     * @param infoOut output stream\n+     * @return a label for the object just read\n+     * @throws IOException if an error occurs on the stream\n+     *\/\n+    private Handle formatTC_BLOCKDATA(DataInputStream in, Appendable infoOut) throws IOException {\n+        int l = in.readUnsignedByte();\n+        StringBuilder sb = new StringBuilder(32 + l + 2);\n+        sb.append(\"BLOCKDATA \" + l + \"[ \");\n+        for (int i = 0; i < l; i++) {\n+            int v = in.readUnsignedByte();\n+            sb.append(toPrintable((char)v));\n+        }\n+        sb.append(\"]; \");\n+        infoOut.append(sb.toString());\n+        return BLOCK_HANDLE;\n+    }\n+\n+    \/**\n+     * Read and format long block data.\n+     *\n+     * @param in input stream\n+     * @param infoOut output stream\n+     * @return a label for the object just read\n+     * @throws IOException if an error occurs on the stream\n+     *\/\n+    private Handle formatTC_BLOCKDATALONG(DataInputStream in, Appendable infoOut) throws IOException {\n+        int l = in.readInt();\n+        StringBuilder sb = new StringBuilder(32 + l + 2);\n+        sb.append(\"BLOCKDATALONG: \" + l + \" [ \");\n+        for (int i = 0; i < l; i++) {\n+            int v = in.readUnsignedByte();\n+            sb.append(String.format(\"%02x \", v));\n+        }\n+        sb.append(\"]; \");\n+        infoOut.append(sb.toString());\n+        return BLOCKLONG_HANDLE;\n+    }\n+\n+    \/**\n+     * Read and format end-of-block-data.\n+     *\n+     * @param in input stream\n+     * @param infoOut output stream\n+     * @return a label for the object just read\n+     * @throws IOException if an error occurs on the stream\n+     *\/\n+    private Handle formatTC_ENDBLOCKDATA(DataInputStream in, Appendable infoOut) throws IOException {\n+        infoOut.append(\"ENDBLOCK; \");\n+        return END_HANDLE;\n+    }\n+\n+    \/**\n+     * Read and format a stream exception.\n+     *\n+     * @param in input stream\n+     * @param infoOut output stream\n+     * @return a label for the object just read\n+     * @throws IOException if an error occurs on the stream\n+     *\/\n+    private Handle formatTC_EXCEPTION(DataInputStream in, Appendable infoOut) throws IOException {\n+        infoOut.append(\"EXCEPTION; \");\n+        return EXCEPTION_HANDLE;\n+    }\n+\n+    \/**\n+     * Read and format a stream reset.\n+     *\n+     * @param in input stream\n+     * @param infoOut output stream\n+     * @return a label for the object just read\n+     * @throws IOException if an error occurs on the stream\n+     *\/\n+    private Handle formatTC_RESET(DataInputStream in, Appendable infoOut) throws IOException {\n+        nextHandle = 0;\n+        infoOut.append(\"RESET; \");\n+        return RESET_HANDLE;\n+    }\n+\n+    \/**\n+     * Format the stream header.\n+     * The first byte already has been read.\n+     * @param in  a DataInputStream\n+     * @param out an Appendable for the output\n+     * @param indent indentation level\n+     * @return a Handle for the Header - unused.\n+     * @throws IOException if an error occurs on the stream\n+     *\/\n+    private Handle formatSTREAM_MAGIC(DataInputStream in, Appendable out, int indent) throws IOException {\n+        \/\/ Scan for the Serialization protocol header\n+        \/\/ Format anything else as bytes\n+        int high = 0xAC, low;\n+        String prefix = \" \".repeat(indent);\n+        if ((low = in.read()) != 0xED || high != 0xAC) {\n+            out.append(prefix).append(\"data: \" + high  + \", \" + low)\n+                    .append(System.lineSeparator());\n+            if (low < 0)\n+                throw new EOFException();\n+            throw new IOException(\"malformed stream header\");\n+        }\n+\n+        int s1 = in.readUnsignedShort();\n+        out.append(\" \".repeat(indent));\n+        out.append(String.format(\"ObjectStream Version: %d\", s1));\n+        newlineIndent(out, indent); \/\/ Start a new line for the object\n+        return HEADER_HANDLE;\n+    }\n+\n+    \/**\n+     * Set the label for a handle.\n+     *\n+     * @param handle\n+     * @param label\n+     *\/\n+    private void setLabel(int handle, String label) {\n+        setLabel(handle, new Handle(label));\n+    }\n+    private void setLabel(int handle, Handle label) {\n+        while (labels.size() <= handle)\n+            labels.add(label);\n+        labels.set(handle, label);\n+    }\n+\n+    \/**\n+     * Get the label for a handle.\n+     *\n+     * @param handle\n+     * @return\n+     *\/\n+    private String getLabel(int handle) {\n+        return getHandle(handle).label();\n+    }\n+\n+    private Handle getHandle(int handle) {\n+        return (handle < 0 || handle >= labels.size()) ? INVALID_HANDLE : labels.get(handle);\n+    }\n+\n+    \/**\n+     * Map a raw class name to a Class based on the type.\n+     *\n+     * @param name\n+     * @return\n+     *\/\n+    private Class<?> mapClassName(String name) {\n+        switch (name.substring(0, 1)) {\n+            case \"I\":\n+                return int.class;\n+            case \"J\":\n+                return long.class;\n+            case \"Z\":\n+                return boolean.class;\n+            case \"S\":\n+                return short.class;\n+            case \"C\":\n+                return char.class;\n+            case \"F\":\n+                return float.class;\n+            case \"D\":\n+                return double.class;\n+            case \"B\":\n+                return byte.class;\n+            case \"L\":\n+            case \"[\":\n+                return Object.class;\n+            default:\n+                throw new RuntimeException(\"unknown class char: \" + name);\n+        }\n+    }\n+\n+    \/**\n+     * Read and format an array.\n+     *\n+     * @param in input stream\n+     * @param infoOut output stream\n+     * @param count the number of elements\n+     * @param type the type code\n+     * @param indent indentation level\n+     * @return a label for the object just read\n+     * @throws IOException if an error occurs on the stream\n+     *\/\n+    private void formatArray(DataInputStream in, Appendable infoOut, int count, char type, int indent)\n+            throws IOException {\n+        switch (type) {\n+            case 'I':\n+                while (count-- > 0) {\n+                    int v = in.readInt();\n+                    infoOut.append(Integer.toString(v));\n+                    if (count > 0) infoOut.append(' ');\n+                }\n+                break;\n+            case 'J':\n+                while (count-- > 0) {\n+                    long v = in.readLong();\n+                    infoOut.append(Long.toString(v));\n+                    if (count > 0) infoOut.append(' ');\n+                }\n+                break;\n+            case 'C':\n+                while (count-- > 0) {\n+                    int v = in.readUnsignedShort();\n+                    infoOut.append((char) v);\n+                    if (count > 0) infoOut.append(' ');\n+                }\n+                break;\n+            case 'S':\n+                while (count-- > 0) {\n+                    int v = in.readUnsignedShort();\n+                    infoOut.append(Integer.toString(v));\n+                    if (count > 0) infoOut.append(' ');\n+                }\n+                break;\n+            case 'F':\n+                while (count-- > 0) {\n+                    float v = in.readFloat();\n+                    infoOut.append(Float.toString(v));\n+                    if (count > 0) infoOut.append(' ');\n+                }\n+                break;\n+            case 'D':\n+                while (count-- > 0) {\n+                    double v = in.readDouble();\n+                    infoOut.append(Double.toString(v));\n+                    if (count > 0) infoOut.append(' ');\n+                }\n+                break;\n+            case 'Z':\n+                while (count-- > 0) {\n+                    boolean v = in.readBoolean();\n+                    infoOut.append(v ? \"true\" : \"false\");\n+                    if (count > 0) infoOut.append(' ');\n+                }\n+                break;\n+            case 'L':\n+                while (count-- > 0) {\n+                    formatObject(in, infoOut, indent + 2);\n+                    if (count > 0) newlineIndent(infoOut, indent);\n+                }\n+                break;\n+            case 'B':\n+            default:            \/\/ anything unknown as bytes\n+                while (count-- > 0) {\n+                    int v = in.readUnsignedByte();\n+                    infoOut.append(toPrintable((char) v));\n+                }\n+                break;\n+        }\n+    }\n+\n+\n+    private char toPrintable(char ch) {\n+        if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||\n+                (ch >= '0' && ch <= '9')) {\n+            return ch;\n+        } else {\n+            switch (ch) {\n+                case ' ':       \/* space *\/\n+                case '\\'':      \/* apostrophe *\/\n+                case '(':       \/* left paren *\/\n+                case ')':       \/* right paren *\/\n+                case '+':       \/* plus *\/\n+                case ',':       \/* comma *\/\n+                case '-':       \/* hyphen *\/\n+                case '.':       \/* period *\/\n+                case '\/':       \/* slash *\/\n+                case ':':       \/* colon *\/\n+                case '=':       \/* equals *\/\n+                case '?':       \/* question mark *\/\n+                    return ch;\n+                default:\n+                    return '.';\n+            }\n+        }\n+    }\n+\n+    static class Handle {\n+        private final String label;\n+\n+        Handle(String label) {\n+            this.label = label;\n+        }\n+\n+        String label() {\n+            return label;\n+        }\n+        public String toString() {\n+            return label;\n+        }\n+    }\n+\n+    static final Handle EMPTY_HANDLE = new Handle(\"\");\n+    static final Handle INVALID_HANDLE = new Handle(\"invalid handle\");\n+    static final Handle NULL_HANDLE = new Handle(\"null\");\n+    static final Handle RESET_HANDLE = new Handle(\"reset\");\n+    static final Handle EXCEPTION_HANDLE = new Handle(\"exception\");\n+    static final Handle END_HANDLE = new Handle(\"end\");\n+    static final Handle BLOCK_HANDLE = new Handle(\"block\");\n+    static final Handle BLOCKLONG_HANDLE = new Handle(\"blocklong\");\n+    static final Handle ARRAY_HANDLE = new Handle(\"array\");\n+    static final Handle ENUM_HANDLE = new Handle(\"enum\");\n+    static final Handle OBJ_HANDLE = new Handle(\"obj\");\n+    static final Handle CLASS_HANDLE = new Handle(\"class\");\n+    static final Handle HEADER_HANDLE = new Handle(\"header\");\n+\n+    static class ClassHandle extends Handle {\n+        private final Map<String, String> fields;\n+        private int flags;\n+        private ClassHandle[] allClasses;\n+\n+        ClassHandle(String label) {\n+            super(label);\n+            this.fields = new LinkedHashMap<>();\n+            allClasses = new ClassHandle[] { this };\n+        }\n+\n+        void addField(String name, String type) {\n+            fields.put(name, type);\n+        }\n+\n+        void superClass(ClassHandle superClass) {\n+            ClassHandle[] types = superClass.allClasses();\n+            types = Arrays.copyOf(types, types.length + 1);\n+            types[types.length - 1] = this;\n+            this.allClasses = types;\n+        }\n+\n+        void setFlags(int flags) {\n+            this.flags = flags;\n+        }\n+\n+        boolean hasFlag(int flagBits) {\n+            return (flags & flagBits) != 0;\n+        }\n+\n+        void forEachField(BiConsumer<String, String> doit) {\n+            fields.forEach(doit);\n+        }\n+\n+        ClassHandle[] allClasses() {\n+            return allClasses;\n+        }\n+\n+        public String toString() {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(super.toString()).append(\": \");\n+            fields.forEach( (k,v) -> sb\n+                    .append(k)\n+                    .append('=')\n+                    .append(v)\n+                    .append(\", \")\n+                    .append((allClasses == null) ? \"\" : \"; super: \" + allClasses[allClasses.length - 1].label()));\n+            return sb.toString();\n+        }\n+    }\n+    \/**\n+     * Simple utility to open and print contents of one or more files as a serialized object stream.\n+     * @param args file names\n+     *\/\n+    public static void main(String[] args) {\n+        if (args.length < 1) {\n+            System.out.println(\"Usage:  <object stream files>\");\n+            return;\n+        }\n+        ObjectStreamPrinter fmt = ObjectStreamPrinter.formatter();\n+        for (String file : args) {\n+            System.out.printf(\"%s%n\", file);\n+            try (InputStream is = Files.newInputStream(Path.of(file))) {\n+\n+                DataInputStream dis = new DataInputStream(is);\n+                HexPrinter p = HexPrinter.simple()\n+                        .dest(System.out)\n+                        .formatter(ObjectStreamPrinter.formatter(), \"; \", 100);\n+                p.format(dis);\n+            } catch (EOFException eof) {\n+                System.out.println();\n+            } catch (IOException ioe) {\n+                System.out.printf(\"%s: %s%n\", file, ioe);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/hexdump\/ObjectStreamPrinter.java","additions":908,"deletions":0,"binary":false,"changes":908,"status":"added"},{"patch":"@@ -0,0 +1,219 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.hexdump;\n+\n+import java.io.*;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Objects;\n+\n+\n+\/**\n+ * A simple command line StreamDump utility for files.\n+ * Usage: [-formatter <class name>] <files>\n+ *\n+ * The fully qualified class name of a HexPrinter.Formatter can be supplied using `--formatter`.\n+ * If none is supplied, it attempts to guess the type (a ObjectStream)\n+ * or an ASN.1 encoded certificate; otherwise the default is HexPrinter.Formatters.PRINTABLE.\n+ *\/\n+public class StreamDump {\n+    static HexPrinter.Formatter defaultFormatter = null;\n+\n+    public static void main(String[] args) {\n+        try {\n+            List<String> argList = parseOptions(args);\n+            dumpFiles(argList);\n+        } catch (IllegalArgumentException iae) {\n+            System.out.println(iae.getMessage());\n+            usage();\n+            System.exit(1);\n+        }\n+    }\n+\n+    \/**\n+     * Parse command line options and return any remaining (filename) arguments.\n+     * @param arg the array of string arguments to main\n+     * @return A\n+     * @throws IllegalArgumentException if any arguments cannot be parsed\n+     *\/\n+    private static List<String> parseOptions(String[] arg) {\n+        for (int i = 0; i < arg.length; i++) {\n+            if (!arg[i].startsWith(\"--\")) {\n+                if (arg[i].startsWith(\"-\"))\n+                    throw new IllegalArgumentException(\"options start with '--', not single '-'\");\n+                return Arrays.asList(Arrays.copyOfRange(arg, i, arg.length));\n+            }\n+            if (arg[i].equals(\"--formatter\")) {\n+                if (++i >= arg.length)\n+                    throw new IllegalArgumentException(\"Formatter class name missing\");\n+                String fmtName = arg[i];\n+                try {\n+                    defaultFormatter = findFormatter(Class.forName(fmtName));\n+                } catch (ClassNotFoundException e) {\n+                    throw new IllegalArgumentException(\"Formatter class not found: \" + fmtName);\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(\"No file arguments\");\n+    }\n+\n+    private static void usage() {\n+        System.out.println(\"Usage: [--formatter <class name>] <files>\");\n+    }\n+\n+    \/**\n+     * Dump the file preceded by the title.\n+     * If the formatter is null, the type of content is guessed to choose a formatter.\n+     *\n+     * @param args an array of file names\n+     *\/\n+    static void dumpFiles(List<String> args) {\n+        var beforeFileSpacing = \"\";\n+        for (int i = 0; i < args.size(); i++) {\n+            var file = args.get(i);\n+            try {\n+                System.out.print(beforeFileSpacing);\n+                var title = (args.size() > 1) ? String.format(\"File: %s%n\" , file) : \"\";\n+                dumpFile(Path.of(file), defaultFormatter, title);\n+                beforeFileSpacing = System.lineSeparator();\n+            } catch (FileNotFoundException | NoSuchFileException fnf) {\n+                System.out.printf(\"File: %s file not found%n\", file);\n+            } catch (IOException ioe) {\n+                System.out.printf(\"File: %s %s: %s%n\", file, ioe.getClass().getName(), ioe.getMessage());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Dump the file preceded by the title.\n+     * If the formatter is null, the type of content is guessed to choose a formatter.\n+     *\n+     * @param file a file name, not null\n+     * @param defaultFormatter a HexPrinter formatter, may be null\n+     * @param title a title, may be empty, not null\n+     * @throws IOException if an exception occurs\n+     *\/\n+    static void dumpFile(Path file, HexPrinter.Formatter defaultFormatter, String title) throws IOException {\n+        Objects.requireNonNull(file, \"filename\");\n+        Objects.requireNonNull(title, \"title\");\n+        try (InputStream fis = Files.newInputStream(file)) {\n+            System.out.print(title);\n+            dumpFile(fis, defaultFormatter);\n+        }\n+    }\n+\n+    static void dumpFile(InputStream fis, HexPrinter.Formatter formatter) throws IOException {\n+        try (BufferedInputStream is = new BufferedInputStream(fis)) {\n+            is.mark(1024);\n+\n+            InputStream decoded = decodeMaybe(is);\n+            if (!decoded.equals(is)) {\n+                if (formatter == null)\n+                    formatter = findFormatter(ASN1Formatter.class);     \/\/ Assume encoded ASN.1\n+                decoded = new BufferedInputStream(decoded);\n+                decoded.mark(1024);\n+            } else {\n+                decoded.reset();\n+            }\n+            if (formatter == null && guessSerializable(decoded)) {\n+                \/\/ Select formatter for a serializable stream\n+                formatter = findFormatter(ObjectStreamPrinter.class);\n+            }\n+            decoded.reset();\n+\n+            if (formatter == null)\n+                formatter = HexPrinter.Formatters.PRINTABLE;\n+            HexPrinter.simple()\n+                    .formatter(formatter)\n+                    .dest(System.out)\n+                    .format(decoded);\n+        }\n+    }\n+\n+    \/**\n+     * If the stream looks like Base64 Mime, return a stream to decode it.\n+     * @param is InputStream\n+     * @return an InputStream, unchanged unless it is Base64 Mime\n+     * @throws IOException if an I\/O Error occurs\n+     *\/\n+    static InputStream decodeMaybe(InputStream is) throws IOException {\n+        DataInputStream dis = new DataInputStream(is);\n+        is.mark(1024);\n+        String line1 = dis.readLine();\n+        if (line1.startsWith(\"-----\")) {\n+            return Base64.getMimeDecoder().wrap(is);\n+        }\n+        is.reset();\n+        return is;\n+    }\n+\n+    static boolean guessSerializable(InputStream is) throws IOException {\n+        byte[] bytes = new byte[4];\n+        int l = is.read(bytes, 0, bytes.length);\n+        if (l >= 4 && (bytes[0] & 0xff) == 0xAC && (bytes[1] & 0xff) == 0xED &&\n+                bytes[2] == 0x00 && bytes[3] == 0x05) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private static HexPrinter.Formatter findFormatter(Class<?> clazz) {\n+        Method[] methods = clazz.getDeclaredMethods();\n+        for (Method m : methods) {\n+            if (m.getReturnType() == clazz &&\n+                    m.getParameterCount() == 0 &&\n+                    Modifier.isStatic(m.getModifiers()) &&\n+                    Modifier.isPublic(m.getModifiers())) {\n+                try {\n+                    return (HexPrinter.Formatter)m.invoke(null);\n+                } catch (IllegalAccessException  | InvocationTargetException e) {\n+                    e.printStackTrace();\n+                    \/\/ fall through\n+                }\n+            }\n+        }\n+\n+        Constructor<?>[] cons = clazz.getDeclaredConstructors();\n+        for (Constructor<?> m : cons) {\n+            if (m.getParameterCount() == 0 &&\n+                    Modifier.isPublic(m.getModifiers())) {\n+                try {\n+                    return (HexPrinter.Formatter)m.newInstance();\n+                } catch (IllegalAccessException | InvocationTargetException | InstantiationException e) {\n+                    e.printStackTrace();\n+                    \/\/ fall through\n+                }\n+            }\n+        }\n+        throw new RuntimeException(\"No formatter for class \" + clazz.getName());\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/hexdump\/StreamDump.java","additions":219,"deletions":0,"binary":false,"changes":219,"status":"added"}]}