{"files":[{"patch":"@@ -2910,0 +2910,4 @@\n+            \/\/ Note that Section 4.5, Extensible data fields, of the PKWARE ZIP File\n+            \/\/ Format Specification does not mandate a specific order for the\n+            \/\/ data in the extra field, therefore Zip FS cannot assume the data\n+            \/\/ is written in the same order by Zip libraries as Zip FS.\n@@ -2915,0 +2919,1 @@\n+            boolean hasZip64LocOffset = false;\n@@ -2958,1 +2963,1 @@\n-                    \/\/ spec says the Extened timestamp in cen only has mtime\n+                    \/\/ spec says the Extended timestamp in cen only has mtime\n@@ -2968,38 +2973,9 @@\n-                    byte[] buf = new byte[LOCHDR];\n-                    if (zipfs.readFullyAt(buf, 0, buf.length , locoff)\n-                        != buf.length)\n-                        throw new ZipException(\"loc: reading failed\");\n-                    if (!locSigAt(buf, 0))\n-                        throw new ZipException(\"loc: wrong sig ->\"\n-                                           + Long.toString(getSig(buf, 0), 16));\n-                    int locElen = LOCEXT(buf);\n-                    if (locElen < 9)    \/\/ EXTT is at least 9 bytes\n-                        break;\n-                    int locNlen = LOCNAM(buf);\n-                    buf = new byte[locElen];\n-                    if (zipfs.readFullyAt(buf, 0, buf.length , locoff + LOCHDR + locNlen)\n-                        != buf.length)\n-                        throw new ZipException(\"loc extra: reading failed\");\n-                    int locPos = 0;\n-                    while (locPos + 4 < buf.length) {\n-                        int locTag = SH(buf, locPos);\n-                        int locSZ  = SH(buf, locPos + 2);\n-                        locPos += 4;\n-                        if (locTag  != EXTID_EXTT) {\n-                            locPos += locSZ;\n-                             continue;\n-                        }\n-                        int end = locPos + locSZ - 4;\n-                        int flag = CH(buf, locPos++);\n-                        if ((flag & 0x1) != 0 && locPos <= end) {\n-                            mtime = unixToJavaTime(LG(buf, locPos));\n-                            locPos += 4;\n-                        }\n-                        if ((flag & 0x2) != 0 && locPos <= end) {\n-                            atime = unixToJavaTime(LG(buf, locPos));\n-                            locPos += 4;\n-                        }\n-                        if ((flag & 0x4) != 0 && locPos <= end) {\n-                            ctime = unixToJavaTime(LG(buf, locPos));\n-                        }\n-                        break;\n+                    \/\/ If the LOC offset is 0xFFFFFFFF, then we need to read the\n+                    \/\/ LOC offset from the EXTID_ZIP64 extra data. Therefore\n+                    \/\/ wait until all of the CEN extra data fields have been processed\n+                    \/\/ prior to reading the LOC extra data field in order to obtain\n+                    \/\/ the Info-ZIP Extended Timestamp.\n+                    if (locoff != ZIP64_MINVAL) {\n+                        readLocEXTT(zipfs);\n+                    } else {\n+                        hasZip64LocOffset = true;\n@@ -3014,0 +2990,7 @@\n+\n+            \/\/ We need to read the LOC extra data and the LOC offset was obtained\n+            \/\/ from the EXTID_ZIP64 field.\n+            if (hasZip64LocOffset) {\n+                readLocEXTT(zipfs);\n+            }\n+\n@@ -3020,0 +3003,47 @@\n+        \/**\n+         * Read the LOC extra field to obtain the Info-ZIP Extended Timestamp fields\n+         * @param zipfs The Zip FS to use\n+         * @throws IOException If an error occurs\n+         *\/\n+        private void readLocEXTT(ZipFileSystem zipfs) throws IOException {\n+            byte[] buf = new byte[LOCHDR];\n+            if (zipfs.readFullyAt(buf, 0, buf.length , locoff)\n+                != buf.length)\n+                throw new ZipException(\"loc: reading failed\");\n+            if (!locSigAt(buf, 0))\n+                throw new ZipException(\"R\"\n+                                   + Long.toString(getSig(buf, 0), 16));\n+            int locElen = LOCEXT(buf);\n+            if (locElen < 9)    \/\/ EXTT is at least 9 bytes\n+                return;\n+            int locNlen = LOCNAM(buf);\n+            buf = new byte[locElen];\n+            if (zipfs.readFullyAt(buf, 0, buf.length , locoff + LOCHDR + locNlen)\n+                != buf.length)\n+                throw new ZipException(\"loc extra: reading failed\");\n+            int locPos = 0;\n+            while (locPos + 4 < buf.length) {\n+                int locTag = SH(buf, locPos);\n+                int locSZ  = SH(buf, locPos + 2);\n+                locPos += 4;\n+                if (locTag  != EXTID_EXTT) {\n+                    locPos += locSZ;\n+                     continue;\n+                }\n+                int end = locPos + locSZ - 4;\n+                int flag = CH(buf, locPos++);\n+                if ((flag & 0x1) != 0 && locPos <= end) {\n+                    mtime = unixToJavaTime(LG(buf, locPos));\n+                    locPos += 4;\n+                }\n+                if ((flag & 0x2) != 0 && locPos <= end) {\n+                    atime = unixToJavaTime(LG(buf, locPos));\n+                    locPos += 4;\n+                }\n+                if ((flag & 0x4) != 0 && locPos <= end) {\n+                    ctime = unixToJavaTime(LG(buf, locPos));\n+                }\n+                break;\n+            }\n+        }\n+\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java","additions":69,"deletions":39,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -0,0 +1,213 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.*;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.zip.ZipFile;\n+\n+import static java.lang.String.format;\n+\n+\/**\n+ * @test\n+ * @bug 8255380\n+ * @summary Test that Zip FS can access the LOC offset from the Zip64 extra field\n+ * @modules jdk.zipfs\n+ * @requires (os.family == \"linux\") | (os.family == \"mac\")\n+ * @run testng\/othervm TestLocOffsetFromZip64EF\n+ *\/\n+public class TestLocOffsetFromZip64EF {\n+\n+    private static final String ZIP_FILE_NAME = \"LargeZipTest.zip\";\n+    \/\/ File that will be created with a size greater than 0xFFFFFFFF\n+    private static final String LARGE_FILE_NAME = \"LargeZipEntry.txt\";\n+    \/\/ File that will be created with a size less than 0xFFFFFFFF\n+    private static final String SMALL_FILE_NAME = \"SmallZipEntry.txt\";\n+    \/\/ The size (4GB) of the large file to be created\n+    private static final long LARGE_FILE_SIZE = 4L * 1024L * 1024L * 1024L;\n+\n+    \/**\n+     * Create the files used by this test\n+     * @throws IOException if an error occurs\n+     *\/\n+    @BeforeClass\n+    public void setUp() throws IOException {\n+        System.out.println(\"In setup\");\n+        cleanup();\n+        createFiles();\n+        createZipWithZip64Ext();\n+    }\n+\n+    \/**\n+     * Delete files used by this test\n+     * @throws IOException if an error occurs\n+     *\/\n+    @AfterClass\n+    public void cleanup() throws IOException {\n+        System.out.println(\"In cleanup\");\n+        Files.deleteIfExists(Path.of(ZIP_FILE_NAME));\n+        Files.deleteIfExists(Path.of(LARGE_FILE_NAME));\n+        Files.deleteIfExists(Path.of(SMALL_FILE_NAME));\n+    }\n+\n+    \/**\n+     * Create a Zip file that will result in the an Zip64 Extra (EXT) header\n+     * being added to the CEN entry in order to find the LOC offset for\n+     * SMALL_FILE_NAME.\n+     *\/\n+    public static void createZipWithZip64Ext() {\n+        System.out.println(\"Executing zip...\");\n+        List<String> commands = List.of(\"zip\", \"-0\", ZIP_FILE_NAME,\n+                LARGE_FILE_NAME, SMALL_FILE_NAME);\n+        Result rc = run(new ProcessBuilder(commands));\n+        rc.assertSuccess();\n+    }\n+\n+    \/**\n+     * Navigate through the Zip file entries using Zip FS\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test\n+    public void walkZipFSTest() throws IOException {\n+        try (FileSystem fs =\n+                     FileSystems.newFileSystem(Paths.get(ZIP_FILE_NAME), Map.of(\"zipinfo-time\", \"False\"))) {\n+            for (Path root : fs.getRootDirectories()) {\n+                Files.walkFileTree(root, new SimpleFileVisitor<>() {\n+                    @Override\n+                    public FileVisitResult visitFile(Path file, BasicFileAttributes\n+                            attrs) throws IOException {\n+                        System.out.println(Files.readAttributes(file,\n+                                BasicFileAttributes.class).toString());\n+                        return FileVisitResult.CONTINUE;\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Navigate through the Zip file entries using ZipFile\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test\n+    public void walkZipFileTest() throws IOException {\n+        try (ZipFile zip = new ZipFile(ZIP_FILE_NAME)) {\n+            zip.stream().forEach(z -> System.out.printf(\"%s, %s, %s%n\",\n+                    z.getName(), z.getMethod(), z.getLastModifiedTime()));\n+        }\n+    }\n+\n+    \/**\n+     * Create the files that will be added to the ZIP file\n+     * @throws IOException if there is a problem  creating the files\n+     *\/\n+    private static void createFiles() throws IOException {\n+        try (RandomAccessFile file = new RandomAccessFile(LARGE_FILE_NAME, \"rw\")\n+        ) {\n+            System.out.printf(\"Creating %s%n\", LARGE_FILE_NAME);\n+            file.setLength(LARGE_FILE_SIZE);\n+            System.out.printf(\"Creating %s%n\", SMALL_FILE_NAME);\n+            Files.writeString(Path.of(SMALL_FILE_NAME), \"Hello\");\n+        }\n+    }\n+\n+    \/**\n+     * Utility method to execute a ProcessBuilder command\n+     * @param pb ProcessBuilder to execute\n+     * @return The Result(s) from the ProcessBuilder execution\n+     *\/\n+    private static Result run(ProcessBuilder pb) {\n+        Process p;\n+        System.out.printf(\"Running: %s%n\", pb.command());\n+        try {\n+            p = pb.start();\n+        } catch (IOException e) {\n+            throw new RuntimeException(\n+                    format(\"Couldn't start process '%s'\", pb.command()), e);\n+        }\n+\n+        String output;\n+        try {\n+            output = toString(p.getInputStream(), p.getErrorStream());\n+        } catch (IOException e) {\n+            throw new RuntimeException(\n+                    format(\"Couldn't read process output '%s'\", pb.command()), e);\n+        }\n+\n+        try {\n+            p.waitFor();\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(\n+                    format(\"Process hasn't finished '%s'\", pb.command()), e);\n+        }\n+        return new Result(p.exitValue(), output);\n+    }\n+\n+    \/**\n+     * Utility Method for combining the output from a ProcessBuilder invocation\n+     * @param in1 ProccessBuilder.getInputStream\n+     * @param in2 ProcessBuilder.getErrorStream\n+     * @return The ProcessBuilder output\n+     * @throws IOException if an error occurs\n+     *\/\n+    static String toString(InputStream in1, InputStream in2) throws IOException {\n+        try (ByteArrayOutputStream dst = new ByteArrayOutputStream();\n+             InputStream concatenated = new SequenceInputStream(in1, in2)) {\n+            concatenated.transferTo(dst);\n+            return new String(dst.toByteArray(), StandardCharsets.UTF_8);\n+        }\n+    }\n+\n+    \/**\n+     * Utility class used to hold the results from  a ProcessBuilder execution\n+     *\/\n+    static class Result {\n+        final int ec;\n+        final String output;\n+\n+        private Result(int ec, String output) {\n+            this.ec = ec;\n+            this.output = output;\n+        }\n+        Result assertSuccess() {\n+            assertTrue(ec == 0, \"Expected ec 0, got: \", ec, \" , output [\", output, \"]\");\n+            return this;\n+        }\n+    }\n+    static void assertTrue(boolean cond, Object ... failedArgs) {\n+        if (cond)\n+            return;\n+        StringBuilder sb = new StringBuilder();\n+        for (Object o : failedArgs)\n+            sb.append(o);\n+        Assert.fail(sb.toString());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/TestLocOffsetFromZip64EF.java","additions":213,"deletions":0,"binary":false,"changes":213,"status":"added"}]}