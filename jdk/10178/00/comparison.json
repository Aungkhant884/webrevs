{"files":[{"patch":"@@ -42,7 +42,20 @@\n-void ThreadLocalStorage::init() {\n-  assert(!_initialized, \"initializing TLS more than once!\");\n-  int rslt = pthread_key_create(&_thread_key, restore_thread_pointer);\n-  \/\/ If this assert fails we will get a recursive assertion failure\n-  \/\/ and not see the actual error message or get a hs_err file\n-  assert_status(rslt == 0, rslt, \"pthread_key_create\");\n-  _initialized = true;\n+\/\/ We initialize Library-based TLS at C++ dynamic initialization time (when\n+\/\/ the libjvm.so is loaded).\n+\/\/ Note however that we cannot rely on initialization order, and we may be\n+\/\/ used even earlier than our initialization runs when called by other\n+\/\/ initialization code (e.g. UL). Therefore we also initialize on demand\n+\/\/ in ThreadLocalStorage::thread().\n+\n+static void initialize_if_needed() {\n+  \/\/ Notes:\n+  \/\/ - we fatal out if this fails, even in release, since continuing would\n+  \/\/   mean we use pthread_key_set\/getspecific with an uninitialized key\n+  \/\/   which is UB\n+  \/\/ - pthread_key_create *returns* the error code, it does not set errno\n+  if (!_initialized) {\n+    int rslt = pthread_key_create(&_thread_key, restore_thread_pointer);\n+    if (rslt != 0) {\n+      fatal(\"TLS initialization failed (pthread_key_create error %d)\", rslt);\n+    }\n+    _initialized = true;\n+  }\n@@ -51,0 +64,3 @@\n+struct InitTLS { InitTLS() { initialize_if_needed(); }};\n+static InitTLS _the_initializer;\n+\n@@ -56,6 +72,1 @@\n-  \/\/ If this assert fails we will get a recursive assertion failure\n-  \/\/ and not see the actual error message or get a hs_err file.\n-  \/\/ Which most likely indicates we have taken an error path early in\n-  \/\/ the initialization process, which is using Thread::current without\n-  \/\/ checking TLS is initialized - see java.cpp vm_exit\n-  assert(_initialized, \"TLS not initialized yet!\");\n+  initialize_if_needed();\n@@ -66,1 +77,1 @@\n-  assert(_initialized, \"TLS not initialized yet!\");\n+  initialize_if_needed();\n@@ -68,1 +79,2 @@\n-  assert_status(rslt == 0, rslt, \"pthread_setspecific\");\n+  \/\/ pthread_setspecific *returns* error code, does not set errno\n+  assert(rslt == 0, \"pthread_setspecific error %d\", rslt);\n","filename":"src\/hotspot\/os\/posix\/threadLocalStorage_posix.cpp","additions":27,"deletions":15,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -33,0 +33,6 @@\n+\/\/ We initialize Library-based TLS at C++ dynamic initialization time (when\n+\/\/ the libjvm.so is loaded).\n+\/\/ Note however that we cannot rely on initialization order, and we may be\n+\/\/ used even earlier than our initialization runs when called by other\n+\/\/ initialization code (e.g. UL). Therefore we also initialize on demand\n+\/\/ in ThreadLocalStorage::thread().\n@@ -34,7 +40,13 @@\n-void ThreadLocalStorage::init() {\n-  assert(!_initialized, \"initializing TLS more than once!\");\n-  _thread_key = TlsAlloc();\n-  \/\/ If this assert fails we will get a recursive assertion failure\n-  \/\/ and not see the actual error message or get a hs_err file\n-  assert(_thread_key != TLS_OUT_OF_INDEXES, \"TlsAlloc failed: out of indices\");\n-  _initialized = true;\n+static void initialize_if_needed() {\n+  \/\/ Notes:\n+  \/\/ - we fatal out if this fails, even in release, since continuing would\n+  \/\/   mean we use TlsGet\/SetValue with an uninitialized key\n+  \/\/   which is UB\n+  \/\/ - pthread_key_create *returns* the error code, it does not set errno\n+  if (!_initialized) {\n+    _thread_key = TlsAlloc();\n+    if (_thread_key == TLS_OUT_OF_INDEXES) {\n+      fatal(\"TlsAlloc failed: out of indices\");\n+    }\n+    _initialized = true;\n+  }\n@@ -43,0 +55,3 @@\n+struct InitTLS { InitTLS() { initialize_if_needed(); }};\n+static InitTLS _the_initializer;\n+\n@@ -48,0 +63,1 @@\n+  initialize_if_needed();\n@@ -53,1 +69,0 @@\n-  assert(_initialized, \"TLS not initialized yet!\");\n@@ -61,1 +76,1 @@\n-  assert(_initialized, \"TLS not initialized yet!\");\n+  initialize_if_needed();\n","filename":"src\/hotspot\/os\/windows\/threadLocalStorage_windows.cpp","additions":24,"deletions":9,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+#include \"runtime\/thread.inline.hpp\"\n@@ -639,0 +640,2 @@\n+  DEBUG_ONLY(NoThreadCurrentMark ntcm);\n+\n@@ -684,0 +687,2 @@\n+  DEBUG_ONLY(NoThreadCurrentMark ntcm);\n+\n@@ -725,0 +730,2 @@\n+  DEBUG_ONLY(NoThreadCurrentMark ntcm);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -156,0 +156,7 @@\n+void Thread::set_thread_current(Thread* t) {\n+#ifndef USE_LIBRARY_BASED_TLS_ONLY\n+  _thr_current = t;\n+#endif\n+  ThreadLocalStorage::set_thread(t);\n+}\n+\n@@ -159,1 +166,0 @@\n-  _thr_current = this;\n@@ -162,1 +168,1 @@\n-  ThreadLocalStorage::set_thread(this);\n+  set_thread_current(this);\n@@ -168,3 +174,1 @@\n-#ifndef USE_LIBRARY_BASED_TLS_ONLY\n-  _thr_current = NULL;\n-#endif\n+  set_thread_current(NULL);\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -290,0 +290,3 @@\n+\n+  static void set_thread_current(Thread* t);\n+\n@@ -299,0 +302,5 @@\n+#ifdef ASSERT\n+  \/\/ Support for temporarily disabling thread_current (see NoThreadCurrentMark)\n+  static void swap_thread_current(Thread* swap_in, Thread** old);\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -94,0 +94,24 @@\n+\n+#ifdef ASSERT\n+inline void Thread::swap_thread_current(Thread* swap_in, Thread** old) {\n+  *old = current_or_null_safe();\n+  Thread::set_thread_current(swap_in);\n+}\n+\n+\/\/ Mark disables Thread::current by setting it to NULL for the extend. Can be\n+\/\/ used to simulate running code in non-attached threads, or to guard code\n+\/\/ against accidental usage of features that depend on Thread::current() (e.g.\n+\/\/ ResourceAreas)\n+class NoThreadCurrentMark {\n+  Thread* _t;\n+public:\n+  NoThreadCurrentMark() {\n+    Thread::swap_thread_current((Thread*)nullptr, &_t);\n+  }\n+  ~NoThreadCurrentMark() {\n+    Thread* dummy;\n+    Thread::swap_thread_current(_t, &dummy);\n+  }\n+};\n+#endif \/\/ ASSERT\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-  static void    init();\n","filename":"src\/hotspot\/share\/runtime\/threadLocalStorage.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -421,3 +421,0 @@\n-  \/\/ Initialize library-based TLS\n-  ThreadLocalStorage::init();\n-\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/thread.inline.hpp\"\n@@ -40,0 +41,3 @@\n+\n+  DEBUG_ONLY(NoThreadCurrentMark ntcm;)\n+\n@@ -58,0 +62,3 @@\n+\n+  DEBUG_ONLY(NoThreadCurrentMark ntcm;)\n+\n","filename":"src\/hotspot\/share\/utilities\/decoder_elf.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#ifdef ASSERT\n+\n+#include \"runtime\/thread.inline.hpp\"\n+#include \"testutils.hpp\"\n+#include \"unittest.hpp\"\n+\n+TEST_VM(Thread, NoThreadCurrentMark) {\n+\n+  ASSERT_NOT_NULL(Thread::current_or_null_safe());\n+\n+  {\n+    NoThreadCurrentMark ntcm1;\n+    ASSERT_NULL(Thread::current_or_null_safe());\n+    {\n+      NoThreadCurrentMark ntcm2;\n+      ASSERT_NULL(Thread::current_or_null_safe());\n+      {\n+        NoThreadCurrentMark ntcm3;\n+        ASSERT_NULL(Thread::current_or_null_safe());\n+      }\n+      ASSERT_NULL(Thread::current_or_null_safe());\n+    }\n+    ASSERT_NULL(Thread::current_or_null_safe());\n+  }\n+\n+  ASSERT_NOT_NULL(Thread::current_or_null_safe());\n+\n+}\n+\n+#endif \/\/ ASSERT\n","filename":"test\/hotspot\/gtest\/runtime\/test_nothreadcurrentmark.cpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/thread.inline.hpp\"\n@@ -111,12 +112,1 @@\n-class ThreadCurrentNullMark : public StackObj {\n-  Thread* _saved;\n-public:\n-  ThreadCurrentNullMark() {\n-    _saved = Thread::current();\n-    Thread::clear_thread_current();\n-  }\n-  ~ThreadCurrentNullMark() {\n-    _saved->initialize_thread_current();\n-  }\n-};\n-\n+#ifdef ASSERT \/\/ NoThreadCurrentMark requires debug build\n@@ -124,1 +114,1 @@\n-  ThreadCurrentNullMark tcnmark;\n+  NoThreadCurrentMark ntcm;\n@@ -129,1 +119,1 @@\n-  ThreadCurrentNullMark tcnmark;\n+  NoThreadCurrentMark ntcm;\n@@ -134,1 +124,1 @@\n-  ThreadCurrentNullMark tcnmark;\n+  NoThreadCurrentMark ntcm;\n@@ -139,1 +129,1 @@\n-  ThreadCurrentNullMark tcnmark;\n+  NoThreadCurrentMark ntcm;\n@@ -142,0 +132,1 @@\n+#endif \/\/ ASSERT\n","filename":"test\/hotspot\/gtest\/runtime\/test_safefetch.cpp","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"}]}