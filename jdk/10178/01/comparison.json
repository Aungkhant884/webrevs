{"files":[{"patch":"@@ -60,0 +60,1 @@\n+#include \"runtime\/thread.inline.hpp\"\n@@ -639,0 +640,2 @@\n+  DEBUG_ONLY(NoThreadCurrentMark ntcm);\n+\n@@ -684,0 +687,2 @@\n+  DEBUG_ONLY(NoThreadCurrentMark ntcm);\n+\n@@ -725,0 +730,2 @@\n+  DEBUG_ONLY(NoThreadCurrentMark ntcm);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+  DEBUG_ONLY(_thread_current_disabled = false;)\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -290,0 +290,1 @@\n+\n@@ -299,0 +300,7 @@\n+#ifdef ASSERT\n+  \/\/ Support for temporarily disabling thread_current (see NoThreadCurrentMark)\n+  bool _thread_current_disabled;\n+  void disable_thread_current() { _thread_current_disabled = true; }\n+  void enable_thread_current()  { _thread_current_disabled = false; }\n+#endif \/\/ ASSERT\n+\n@@ -650,0 +658,1 @@\n+  Thread* t = nullptr;\n@@ -651,1 +660,1 @@\n-  return _thr_current;\n+  t = _thr_current;\n@@ -654,1 +663,1 @@\n-    return ThreadLocalStorage::thread();\n+    t = ThreadLocalStorage::thread();\n@@ -656,1 +665,0 @@\n-  return NULL;\n@@ -658,0 +666,4 @@\n+  if (t != nullptr && t->_thread_current_disabled) {\n+    t = nullptr;\n+  }\n+  return t;\n@@ -661,0 +673,1 @@\n+  Thread* t = nullptr;\n@@ -662,1 +675,4 @@\n-    return ThreadLocalStorage::thread();\n+    t = ThreadLocalStorage::thread();\n+  }\n+  if (t != nullptr && t->_thread_current_disabled) {\n+    t = nullptr;\n@@ -664,1 +680,1 @@\n-  return NULL;\n+  return t;\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -94,0 +94,23 @@\n+\n+#ifdef ASSERT\n+\/\/ Mark disables Thread::current by setting it to NULL for the extend. Can be\n+\/\/ used to simulate running code in non-attached threads, or to guard code\n+\/\/ against accidental usage of features that depend on Thread::current() (e.g.\n+\/\/ ResourceAreas)\n+class NoThreadCurrentMark {\n+  Thread* _t;\n+public:\n+  NoThreadCurrentMark() {\n+    _t = Thread::current_or_null_safe();\n+    if (_t != nullptr) {\n+      _t->disable_thread_current();\n+    }\n+  }\n+  ~NoThreadCurrentMark() {\n+    if (_t != nullptr) {\n+      _t->enable_thread_current();\n+    }\n+  }\n+};\n+#endif \/\/ ASSERT\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/thread.inline.hpp\"\n@@ -40,0 +41,3 @@\n+\n+  DEBUG_ONLY(NoThreadCurrentMark ntcm;)\n+\n@@ -58,0 +62,3 @@\n+\n+  DEBUG_ONLY(NoThreadCurrentMark ntcm;)\n+\n","filename":"src\/hotspot\/share\/utilities\/decoder_elf.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#ifdef ASSERT\n+\n+#include \"runtime\/thread.inline.hpp\"\n+#include \"testutils.hpp\"\n+#include \"unittest.hpp\"\n+\n+TEST_VM(Thread, NoThreadCurrentMark) {\n+\n+  ASSERT_NOT_NULL(Thread::current_or_null_safe());\n+\n+  {\n+    NoThreadCurrentMark ntcm1;\n+    ASSERT_NULL(Thread::current_or_null_safe());\n+    {\n+      NoThreadCurrentMark ntcm2;\n+      ASSERT_NULL(Thread::current_or_null_safe());\n+      {\n+        NoThreadCurrentMark ntcm3;\n+        ASSERT_NULL(Thread::current_or_null_safe());\n+      }\n+      ASSERT_NULL(Thread::current_or_null_safe());\n+    }\n+    ASSERT_NULL(Thread::current_or_null_safe());\n+  }\n+\n+  ASSERT_NOT_NULL(Thread::current_or_null_safe());\n+\n+}\n+\n+#endif \/\/ ASSERT\n","filename":"test\/hotspot\/gtest\/runtime\/test_nothreadcurrentmark.cpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/thread.inline.hpp\"\n@@ -111,12 +112,1 @@\n-class ThreadCurrentNullMark : public StackObj {\n-  Thread* _saved;\n-public:\n-  ThreadCurrentNullMark() {\n-    _saved = Thread::current();\n-    Thread::clear_thread_current();\n-  }\n-  ~ThreadCurrentNullMark() {\n-    _saved->initialize_thread_current();\n-  }\n-};\n-\n+#ifdef ASSERT \/\/ NoThreadCurrentMark requires debug build\n@@ -124,1 +114,1 @@\n-  ThreadCurrentNullMark tcnmark;\n+  NoThreadCurrentMark ntcm;\n@@ -129,1 +119,1 @@\n-  ThreadCurrentNullMark tcnmark;\n+  NoThreadCurrentMark ntcm;\n@@ -134,1 +124,1 @@\n-  ThreadCurrentNullMark tcnmark;\n+  NoThreadCurrentMark ntcm;\n@@ -139,1 +129,1 @@\n-  ThreadCurrentNullMark tcnmark;\n+  NoThreadCurrentMark ntcm;\n@@ -142,0 +132,1 @@\n+#endif \/\/ ASSERT\n","filename":"test\/hotspot\/gtest\/runtime\/test_safefetch.cpp","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"}]}