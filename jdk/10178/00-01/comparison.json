{"files":[{"patch":"@@ -42,20 +42,7 @@\n-\/\/ We initialize Library-based TLS at C++ dynamic initialization time (when\n-\/\/ the libjvm.so is loaded).\n-\/\/ Note however that we cannot rely on initialization order, and we may be\n-\/\/ used even earlier than our initialization runs when called by other\n-\/\/ initialization code (e.g. UL). Therefore we also initialize on demand\n-\/\/ in ThreadLocalStorage::thread().\n-\n-static void initialize_if_needed() {\n-  \/\/ Notes:\n-  \/\/ - we fatal out if this fails, even in release, since continuing would\n-  \/\/   mean we use pthread_key_set\/getspecific with an uninitialized key\n-  \/\/   which is UB\n-  \/\/ - pthread_key_create *returns* the error code, it does not set errno\n-  if (!_initialized) {\n-    int rslt = pthread_key_create(&_thread_key, restore_thread_pointer);\n-    if (rslt != 0) {\n-      fatal(\"TLS initialization failed (pthread_key_create error %d)\", rslt);\n-    }\n-    _initialized = true;\n-  }\n+void ThreadLocalStorage::init() {\n+  assert(!_initialized, \"initializing TLS more than once!\");\n+  int rslt = pthread_key_create(&_thread_key, restore_thread_pointer);\n+  \/\/ If this assert fails we will get a recursive assertion failure\n+  \/\/ and not see the actual error message or get a hs_err file\n+  assert_status(rslt == 0, rslt, \"pthread_key_create\");\n+  _initialized = true;\n@@ -64,3 +51,0 @@\n-struct InitTLS { InitTLS() { initialize_if_needed(); }};\n-static InitTLS _the_initializer;\n-\n@@ -72,1 +56,6 @@\n-  initialize_if_needed();\n+  \/\/ If this assert fails we will get a recursive assertion failure\n+  \/\/ and not see the actual error message or get a hs_err file.\n+  \/\/ Which most likely indicates we have taken an error path early in\n+  \/\/ the initialization process, which is using Thread::current without\n+  \/\/ checking TLS is initialized - see java.cpp vm_exit\n+  assert(_initialized, \"TLS not initialized yet!\");\n@@ -77,1 +66,1 @@\n-  initialize_if_needed();\n+  assert(_initialized, \"TLS not initialized yet!\");\n@@ -79,2 +68,1 @@\n-  \/\/ pthread_setspecific *returns* error code, does not set errno\n-  assert(rslt == 0, \"pthread_setspecific error %d\", rslt);\n+  assert_status(rslt == 0, rslt, \"pthread_setspecific\");\n","filename":"src\/hotspot\/os\/posix\/threadLocalStorage_posix.cpp","additions":15,"deletions":27,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -33,6 +33,0 @@\n-\/\/ We initialize Library-based TLS at C++ dynamic initialization time (when\n-\/\/ the libjvm.so is loaded).\n-\/\/ Note however that we cannot rely on initialization order, and we may be\n-\/\/ used even earlier than our initialization runs when called by other\n-\/\/ initialization code (e.g. UL). Therefore we also initialize on demand\n-\/\/ in ThreadLocalStorage::thread().\n@@ -40,13 +34,7 @@\n-static void initialize_if_needed() {\n-  \/\/ Notes:\n-  \/\/ - we fatal out if this fails, even in release, since continuing would\n-  \/\/   mean we use TlsGet\/SetValue with an uninitialized key\n-  \/\/   which is UB\n-  \/\/ - pthread_key_create *returns* the error code, it does not set errno\n-  if (!_initialized) {\n-    _thread_key = TlsAlloc();\n-    if (_thread_key == TLS_OUT_OF_INDEXES) {\n-      fatal(\"TlsAlloc failed: out of indices\");\n-    }\n-    _initialized = true;\n-  }\n+void ThreadLocalStorage::init() {\n+  assert(!_initialized, \"initializing TLS more than once!\");\n+  _thread_key = TlsAlloc();\n+  \/\/ If this assert fails we will get a recursive assertion failure\n+  \/\/ and not see the actual error message or get a hs_err file\n+  assert(_thread_key != TLS_OUT_OF_INDEXES, \"TlsAlloc failed: out of indices\");\n+  _initialized = true;\n@@ -55,3 +43,0 @@\n-struct InitTLS { InitTLS() { initialize_if_needed(); }};\n-static InitTLS _the_initializer;\n-\n@@ -63,1 +48,0 @@\n-  initialize_if_needed();\n@@ -69,0 +53,1 @@\n+  assert(_initialized, \"TLS not initialized yet!\");\n@@ -76,1 +61,1 @@\n-  initialize_if_needed();\n+  assert(_initialized, \"TLS not initialized yet!\");\n","filename":"src\/hotspot\/os\/windows\/threadLocalStorage_windows.cpp","additions":9,"deletions":24,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+  DEBUG_ONLY(_thread_current_disabled = false;)\n@@ -156,7 +157,0 @@\n-void Thread::set_thread_current(Thread* t) {\n-#ifndef USE_LIBRARY_BASED_TLS_ONLY\n-  _thr_current = t;\n-#endif\n-  ThreadLocalStorage::set_thread(t);\n-}\n-\n@@ -166,0 +160,1 @@\n+  _thr_current = this;\n@@ -168,1 +163,1 @@\n-  set_thread_current(this);\n+  ThreadLocalStorage::set_thread(this);\n@@ -174,1 +169,3 @@\n-  set_thread_current(NULL);\n+#ifndef USE_LIBRARY_BASED_TLS_ONLY\n+  _thr_current = NULL;\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -291,2 +291,0 @@\n-  static void set_thread_current(Thread* t);\n-\n@@ -304,2 +302,4 @@\n-  static void swap_thread_current(Thread* swap_in, Thread** old);\n-#endif\n+  bool _thread_current_disabled;\n+  void disable_thread_current() { _thread_current_disabled = true; }\n+  void enable_thread_current()  { _thread_current_disabled = false; }\n+#endif \/\/ ASSERT\n@@ -658,0 +658,1 @@\n+  Thread* t = nullptr;\n@@ -659,1 +660,1 @@\n-  return _thr_current;\n+  t = _thr_current;\n@@ -662,1 +663,1 @@\n-    return ThreadLocalStorage::thread();\n+    t = ThreadLocalStorage::thread();\n@@ -664,1 +665,0 @@\n-  return NULL;\n@@ -666,0 +666,4 @@\n+  if (t != nullptr && t->_thread_current_disabled) {\n+    t = nullptr;\n+  }\n+  return t;\n@@ -669,0 +673,1 @@\n+  Thread* t = nullptr;\n@@ -670,1 +675,4 @@\n-    return ThreadLocalStorage::thread();\n+    t = ThreadLocalStorage::thread();\n+  }\n+  if (t != nullptr && t->_thread_current_disabled) {\n+    t = nullptr;\n@@ -672,1 +680,1 @@\n-  return NULL;\n+  return t;\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -96,5 +96,0 @@\n-inline void Thread::swap_thread_current(Thread* swap_in, Thread** old) {\n-  *old = current_or_null_safe();\n-  Thread::set_thread_current(swap_in);\n-}\n-\n@@ -109,1 +104,4 @@\n-    Thread::swap_thread_current((Thread*)nullptr, &_t);\n+    _t = Thread::current_or_null_safe();\n+    if (_t != nullptr) {\n+      _t->disable_thread_current();\n+    }\n@@ -112,2 +110,3 @@\n-    Thread* dummy;\n-    Thread::swap_thread_current(_t, &dummy);\n+    if (_t != nullptr) {\n+      _t->enable_thread_current();\n+    }\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+  static void    init();\n","filename":"src\/hotspot\/share\/runtime\/threadLocalStorage.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -421,0 +421,3 @@\n+  \/\/ Initialize library-based TLS\n+  ThreadLocalStorage::init();\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}