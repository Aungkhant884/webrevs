{"files":[{"patch":"@@ -2140,8 +2140,2 @@\n-void os::Linux::print_process_memory_info(outputStream* st) {\n-\n-  st->print_cr(\"Process Memory:\");\n-\n-  \/\/ Print virtual and resident set size; peak values; swap; and for\n-  \/\/  rss its components if the kernel is recent enough.\n-  ssize_t vmsize = -1, vmpeak = -1, vmswap = -1,\n-      vmrss = -1, vmhwm = -1, rssanon = -1, rssfile = -1, rssshmem = -1;\n+bool os::Linux::query_memory_info(os::Linux::meminfo_t* info) {\n+  FILE* f = ::fopen(\"\/proc\/self\/status\", \"r\");\n@@ -2150,1 +2144,0 @@\n-  FILE* f = ::fopen(\"\/proc\/self\/status\", \"r\");\n@@ -2152,0 +2145,2 @@\n+  info->vmsize = info->vmpeak = info->vmrss = info->vmhwm = info->vmswap =\n+      info->rssanon = info->rssfile = info->rssshmem = -1;\n@@ -2154,8 +2149,8 @@\n-      if ( (vmsize == -1    && sscanf(buf, \"VmSize: \" SSIZE_FORMAT \" kB\", &vmsize) == 1) ||\n-           (vmpeak == -1    && sscanf(buf, \"VmPeak: \" SSIZE_FORMAT \" kB\", &vmpeak) == 1) ||\n-           (vmswap == -1    && sscanf(buf, \"VmSwap: \" SSIZE_FORMAT \" kB\", &vmswap) == 1) ||\n-           (vmhwm == -1     && sscanf(buf, \"VmHWM: \" SSIZE_FORMAT \" kB\", &vmhwm) == 1) ||\n-           (vmrss == -1     && sscanf(buf, \"VmRSS: \" SSIZE_FORMAT \" kB\", &vmrss) == 1) ||\n-           (rssanon == -1   && sscanf(buf, \"RssAnon: \" SSIZE_FORMAT \" kB\", &rssanon) == 1) ||\n-           (rssfile == -1   && sscanf(buf, \"RssFile: \" SSIZE_FORMAT \" kB\", &rssfile) == 1) ||\n-           (rssshmem == -1  && sscanf(buf, \"RssShmem: \" SSIZE_FORMAT \" kB\", &rssshmem) == 1)\n+      if ( (info->vmsize == -1    && sscanf(buf, \"VmSize: \" SSIZE_FORMAT \" kB\", &info->vmsize) == 1) ||\n+           (info->vmpeak == -1    && sscanf(buf, \"VmPeak: \" SSIZE_FORMAT \" kB\", &info->vmpeak) == 1) ||\n+           (info->vmswap == -1    && sscanf(buf, \"VmSwap: \" SSIZE_FORMAT \" kB\", &info->vmswap) == 1) ||\n+           (info->vmhwm == -1     && sscanf(buf, \"VmHWM: \" SSIZE_FORMAT \" kB\", &info->vmhwm) == 1) ||\n+           (info->vmrss == -1     && sscanf(buf, \"VmRSS: \" SSIZE_FORMAT \" kB\", &info->vmrss) == 1) ||\n+           (info->rssanon == -1   && sscanf(buf, \"RssAnon: \" SSIZE_FORMAT \" kB\", &info->rssanon) == 1) ||\n+           (info->rssfile == -1   && sscanf(buf, \"RssFile: \" SSIZE_FORMAT \" kB\", &info->rssfile) == 1) ||\n+           (info->rssshmem == -1  && sscanf(buf, \"RssShmem: \" SSIZE_FORMAT \" kB\", &info->rssshmem) == 1)\n@@ -2168,0 +2163,6 @@\n+    return true;\n+  }\n+  return false;\n+}\n+\n+void os::Linux::print_process_memory_info(outputStream* st) {\n@@ -2169,3 +2170,9 @@\n-    st->print_cr(\"Virtual Size: \" SSIZE_FORMAT \"K (peak: \" SSIZE_FORMAT \"K)\", vmsize, vmpeak);\n-    st->print(\"Resident Set Size: \" SSIZE_FORMAT \"K (peak: \" SSIZE_FORMAT \"K)\", vmrss, vmhwm);\n-    if (rssanon != -1) { \/\/ requires kernel >= 4.5\n+  st->print_cr(\"Process Memory:\");\n+\n+  \/\/ Print virtual and resident set size; peak values; swap; and for\n+  \/\/  rss its components if the kernel is recent enough.\n+  meminfo_t info;\n+  if (query_memory_info(&info)) {\n+    st->print_cr(\"Virtual Size: \" SSIZE_FORMAT \"K (peak: \" SSIZE_FORMAT \"K)\", info.vmsize, info.vmpeak);\n+    st->print(\"Resident Set Size: \" SSIZE_FORMAT \"K (peak: \" SSIZE_FORMAT \"K)\", info.vmrss, info.vmhwm);\n+    if (info.rssanon != -1) { \/\/ requires kernel >= 4.5\n@@ -2173,1 +2180,1 @@\n-                  rssanon, rssfile, rssshmem);\n+                info.rssanon, info.rssfile, info.rssshmem);\n@@ -2176,2 +2183,2 @@\n-    if (vmswap != -1) { \/\/ requires kernel >= 2.6.34\n-      st->print_cr(\"Swapped out: \" SSIZE_FORMAT \"K\", vmswap);\n+    if (info.vmswap != -1) { \/\/ requires kernel >= 2.6.34\n+      st->print_cr(\"Swapped out: \" SSIZE_FORMAT \"K\", info.vmswap);\n@@ -2198,1 +2205,1 @@\n-    might_have_wrapped = (vmrss * K) > UINT_MAX && (vmrss * K) > (total_allocated + UINT_MAX);\n+    might_have_wrapped = (info.vmrss * K) > UINT_MAX && (info.vmrss * K) > (total_allocated + UINT_MAX);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":31,"deletions":24,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -177,0 +177,17 @@\n+  \/\/ Output structure for query_memory_info()\n+  struct meminfo_t {\n+    ssize_t vmsize;     \/\/ current virtual size\n+    ssize_t vmpeak;     \/\/ peak virtual size\n+    ssize_t vmrss;      \/\/ current resident set size\n+    ssize_t vmhwm;      \/\/ peak resident set size\n+    ssize_t vmswap;     \/\/ swapped out\n+    ssize_t rssanon;    \/\/ resident set size\n+    ssize_t rssfile;    \/\/ resident set size\n+    ssize_t rssshmem;   \/\/ resident set size\n+  };\n+\n+  \/\/ Attempts to query memory information about the current process and return it in the output structure.\n+  \/\/ May fail (returns false) or succeed (returns true) but not all output fields are available; unavailable\n+  \/\/ fields will contain -1.\n+  static bool query_memory_info(meminfo_t* info);\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"trimCHeapDCmd.hpp\"\n+\n+#include <malloc.h>\n+\n+void TrimCLibcHeapDCmd::execute(DCmdSource source, TRAPS) {\n+#ifdef __GLIBC__\n+  stringStream ss_report(1024); \/\/ Note: before calling trim\n+\n+  \/\/ Query memory before...\n+  os::Linux::meminfo_t info1;\n+  os::Linux::meminfo_t info2;\n+  bool have_info1 = os::Linux::query_memory_info(&info1);\n+\n+  _output->print_cr(\"Attempting trim...\");\n+  ::malloc_trim(0);\n+  _output->print_cr(\"Done.\");\n+\n+  \/\/ ...and after trim.\n+  bool have_info2 = os::Linux::query_memory_info(&info2);\n+\n+  \/\/ Print report both to output stream as well to UL\n+  if (have_info1 && have_info2) {\n+    if (info1.vmsize != -1 && info2.vmsize != -1) {\n+      ss_report.print_cr(\"Virtual size before: \" SSIZE_FORMAT \"k, after: \" SSIZE_FORMAT \"k, (\" SSIZE_FORMAT \"k)\",\n+                         info1.vmsize, info2.vmsize, (info2.vmsize - info1.vmsize));\n+    }\n+    if (info1.vmrss != -1 && info2.vmrss != -1) {\n+      ss_report.print_cr(\"RSS before: \" SSIZE_FORMAT \"k, after: \" SSIZE_FORMAT \"k, (\" SSIZE_FORMAT \"k)\",\n+                         info1.vmrss, info2.vmrss, (info2.vmrss - info1.vmrss));\n+    }\n+    if (info1.vmswap != -1 && info2.vmswap != -1) {\n+      ss_report.print_cr(\"Swap before: \" SSIZE_FORMAT \"k, after: \" SSIZE_FORMAT \"k, (\" SSIZE_FORMAT \"k)\",\n+                         info1.vmswap, info2.vmswap, (info2.vmswap - info1.vmswap));\n+    }\n+  } else {\n+    ss_report.print_raw(\"No details available.\");\n+  }\n+  _output->print_raw(ss_report.base());\n+  log_info(os)(\"malloc_trim: \");\n+  log_info(os)(\"%s\", ss_report.base());\n+#else\n+  _output->print_cr(\"Not available.\");\n+#endif\n+}\n","filename":"src\/hotspot\/os\/linux\/trimCHeapDCmd.cpp","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_LINUX_TRIMCHEAPDCMD_HPP\n+#define OS_LINUX_TRIMCHEAPDCMD_HPP\n+\n+#include \"services\/diagnosticCommand.hpp\"\n+\n+class outputStream;\n+\n+class TrimCLibcHeapDCmd : public DCmd {\n+public:\n+  TrimCLibcHeapDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n+  static const char* name() {\n+    return \"VM.trim_libc_heap\";\n+  }\n+  static const char* description() {\n+    return \"Attempts to free up memory by trimming the glibc heap.\";\n+  }\n+  static const char* impact() {\n+    return \"Low\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = { \"java.lang.management.ManagementPermission\", \"control\", NULL };\n+    return p;\n+  }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n+#endif \/\/ OS_LINUX_TRIMCHEAPDCMD_HPP\n","filename":"src\/hotspot\/os\/linux\/trimCHeapDCmd.hpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -61,1 +61,3 @@\n-\n+#ifdef LINUX\n+#include \"trimCHeapDCmd.hpp\"\n+#endif\n@@ -97,0 +99,1 @@\n+  LINUX_ONLY(DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<TrimCLibcHeapDCmd>(full_export, true, false));)\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import jdk.test.lib.dcmd.CommandExecutor;\n+import jdk.test.lib.dcmd.JMXExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/*\n+ * @test\n+ * @summary Test of diagnostic command VM.trim_libc_heap\n+ * @library \/test\/lib\n+ * @requires os.family == \"linux\"\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.compiler\n+ *          java.management\n+ *          jdk.internal.jvmstat\/sun.jvmstat.monitor\n+ * @run testng TrimLibcHeapTest\n+ *\/\n+public class TrimLibcHeapTest {\n+    public void run(CommandExecutor executor) {\n+        OutputAnalyzer output = executor.execute(\"VM.trim_libc_heap\");\n+        output.reportDiagnosticSummary();\n+        output.shouldMatch(\"(Done|Not available)\");\n+    }\n+\n+    @Test\n+    public void jmx() {\n+        run(new JMXExecutor());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/TrimLibcHeapTest.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"}]}