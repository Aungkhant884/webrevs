{"files":[{"patch":"@@ -81,0 +81,8 @@\n+#if INCLUDE_JVMCI\n+  \/\/ JVMCI compiler is doing linktime resolution\n+  if (sender->method_holder()->name() == vmSymbols::jdk_vm_ci_hotspot_CompilerToVM()) {\n+    if (sender->name()->equals(\"lookupMethodInPool\")) {\n+      return;\n+    }\n+  }\n+#endif\n@@ -84,3 +92,1 @@\n-static inline bool is_compiler_linking_event_writer(const ciKlass * holder, const ciMethod * target) {\n-  assert(holder != nullptr, \"invariant\");\n-  assert(target != nullptr, \"invariant\");\n+static inline bool is_compiler_linking_event_writer(const Symbol* holder, const Symbol* name) {\n@@ -89,1 +95,1 @@\n-  if (holder->name()->get_symbol() != event_writer_factory_klass_name) {\n+  if (holder != event_writer_factory_klass_name) {\n@@ -94,1 +100,7 @@\n-  return target->name()->get_symbol() == event_writer_method_name;\n+  return name == event_writer_method_name;\n+}\n+\n+static inline bool is_compiler_linking_event_writer(const ciKlass * holder, const ciMethod * target) {\n+  assert(holder != nullptr, \"invariant\");\n+  assert(target != nullptr, \"invariant\");\n+  return is_compiler_linking_event_writer(holder->name()->get_symbol(), target->name()->get_symbol());\n@@ -114,0 +126,9 @@\n+\n+#if INCLUDE_JVMCI\n+\/\/ JVMCI\n+void JfrResolution::on_jvmci_resolution(const Method* caller, const Method* target, TRAPS) {\n+  if (is_compiler_linking_event_writer(target->method_holder()->name(), target->name()) && !IS_METHOD_BLESSED(caller)) {\n+    THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), link_error_msg);\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrResolution.cpp","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+  static void on_jvmci_resolution(const Method* caller, const Method* target, TRAPS);\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrResolution.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -119,0 +119,6 @@\n+#if INCLUDE_JVMCI\n+void Jfr::on_resolution(const Method* caller, const Method* target, TRAPS) {\n+  JfrResolution::on_jvmci_resolution(caller, target, CHECK);\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/jfr\/jfr.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+  static void on_resolution(const Method* caller, const Method* target, TRAPS);\n","filename":"src\/hotspot\/share\/jfr\/jfr.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,0 +66,3 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.hpp\"\n+#endif\n@@ -757,1 +760,1 @@\n-C2V_VMENTRY_NULL(jobject, lookupMethodInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index, jbyte opcode))\n+C2V_VMENTRY_NULL(jobject, lookupMethodInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index, jbyte opcode, ARGUMENT_PAIR(caller)))\n@@ -759,0 +762,1 @@\n+  methodHandle caller(THREAD, UNPACK_PAIR(Method, caller));\n@@ -762,0 +766,1 @@\n+  JFR_ONLY(if (method.not_null()) Jfr::on_resolution(caller(), method(), CHECK_NULL);)\n@@ -2837,1 +2842,1 @@\n-  {CC \"lookupMethodInPool\",                           CC \"(\" HS_CONSTANT_POOL2 \"IB)\" HS_METHOD,                                             FN_PTR(lookupMethodInPool)},\n+  {CC \"lookupMethodInPool\",                           CC \"(\" HS_CONSTANT_POOL2 \"IB\" HS_METHOD2 \")\" HS_METHOD,                               FN_PTR(lookupMethodInPool)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.vm.ci.meta.Value;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.code\/src\/jdk\/vm\/ci\/code\/StackLockValue.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -347,0 +347,2 @@\n+     * @param caller if non-null, do access checks in the context of {@code caller} calling the\n+     *            looked up method\n@@ -349,2 +351,3 @@\n-    HotSpotResolvedJavaMethodImpl lookupMethodInPool(HotSpotConstantPool constantPool, int cpi, byte opcode) {\n-        return lookupMethodInPool(constantPool, constantPool.getConstantPoolPointer(), cpi, opcode);\n+    HotSpotResolvedJavaMethodImpl lookupMethodInPool(HotSpotConstantPool constantPool, int cpi, byte opcode, HotSpotResolvedJavaMethodImpl caller) {\n+        long callerMethodPointer = caller == null ? 0L : caller.getMethodPointer();\n+        return lookupMethodInPool(constantPool, constantPool.getConstantPoolPointer(), cpi, opcode, caller, callerMethodPointer);\n@@ -353,1 +356,6 @@\n-    private native HotSpotResolvedJavaMethodImpl lookupMethodInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi, byte opcode);\n+    private native HotSpotResolvedJavaMethodImpl lookupMethodInPool(HotSpotConstantPool constantPool,\n+                    long constantPoolPointer,\n+                    int cpi,\n+                    byte opcode,\n+                    HotSpotResolvedJavaMethodImpl caller,\n+                    long callerMethodPointer);\n@@ -516,1 +524,1 @@\n-     }\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -692,1 +692,1 @@\n-    public JavaMethod lookupMethod(int cpi, int opcode) {\n+    public JavaMethod lookupMethod(int cpi, int opcode, ResolvedJavaMethod caller) {\n@@ -694,1 +694,1 @@\n-        final HotSpotResolvedJavaMethod method = compilerToVM().lookupMethodInPool(this, index, (byte) opcode);\n+        final HotSpotResolvedJavaMethod method = compilerToVM().lookupMethodInPool(this, index, (byte) opcode, (HotSpotResolvedJavaMethodImpl) caller);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;\n+\n@@ -29,1 +31,0 @@\n-import jdk.vm.ci.common.JVMCIError;\n@@ -39,2 +40,0 @@\n-import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCICompilerConfig.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -88,1 +88,20 @@\n-    JavaMethod lookupMethod(int cpi, int opcode);\n+    default JavaMethod lookupMethod(int cpi, int opcode) {\n+        return lookupMethod(cpi, opcode, null);\n+    }\n+\n+    \/**\n+     * Looks up a reference to a method. If {@code opcode} is non-negative, then resolution checks\n+     * specific to the bytecode it denotes are performed if the method is already resolved. Should\n+     * any of these checks fail, an unresolved method reference is returned.\n+     *\n+     * @param cpi the constant pool index\n+     * @param opcode the opcode of the instruction for which the lookup is being performed or\n+     *            {@code -1}\n+     * @param caller if non-null, do access checks in the context of {@code caller} calling the\n+     *            looked up method\n+     * @return a reference to the method at {@code cpi} in this pool\n+     * @throws ClassFormatError if the entry at {@code cpi} is not a method\n+     * @throws IllegalAccessError if {@code caller} is non-null and it cannot link against the\n+     *             looked up method\n+     *\/\n+    JavaMethod lookupMethod(int cpi, int opcode, ResolvedJavaMethod caller);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/ConstantPool.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -131,1 +131,2 @@\n-        return CTVM.lookupMethodInPool((HotSpotConstantPool) constantPool, cpi, opcode);\n+        HotSpotResolvedJavaMethodImpl caller = null;\n+        return CTVM.lookupMethodInPool((HotSpotConstantPool) constantPool, cpi, opcode, null);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/patches\/jdk.internal.vm.ci\/jdk\/vm\/ci\/hotspot\/CompilerToVMHelper.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,4 @@\n+import jdk.vm.ci.meta.MetaAccessProvider;\n+import jdk.vm.ci.meta.ResolvedJavaMethod;\n+import jdk.vm.ci.meta.ConstantPool;\n+import jdk.vm.ci.runtime.JVMCI;\n@@ -41,0 +45,2 @@\n+ * @modules jdk.internal.vm.ci\/jdk.vm.ci.meta\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.runtime\n@@ -54,0 +60,3 @@\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -Dtest.jvmci=true --add-exports=jdk.jfr\/jdk.jfr.internal.event=ALL-UNNAMED\n+ *      jdk.jfr.jvm.TestGetEventWriter\n+ *\n@@ -104,0 +113,1 @@\n+            maybeCheckJVMCI(e.getClass());\n@@ -118,0 +128,1 @@\n+            maybeCheckJVMCI(e.getClass());\n@@ -137,0 +148,1 @@\n+            maybeCheckJVMCI(e.getClass());\n@@ -157,0 +169,1 @@\n+            maybeCheckJVMCI(e.getClass());\n@@ -173,0 +186,1 @@\n+            maybeCheckJVMCI(e.getClass());\n@@ -190,0 +204,1 @@\n+            maybeCheckJVMCI(e.getClass());\n@@ -320,0 +335,46 @@\n+\n+    private static ResolvedJavaMethod findCommitMethod(MetaAccessProvider metaAccess, Class<?> eventClass) {\n+        for (Method m : eventClass.getMethods()) {\n+            if (m.getName().toLowerCase().contains(\"commit\")) {\n+                return metaAccess.lookupJavaMethod(m);\n+            }\n+        }\n+        throw new AssertionError(\"could not find commit method in \" + eventClass);\n+    }\n+\n+    \/\/ Factor out test.jvmci system property check to reduce unecessary work in -Xcomp.\n+    private static void maybeCheckJVMCI(Class<?> eventClass) throws Throwable {\n+        if (!Boolean.getBoolean(\"test.jvmci\")) {\n+            return;\n+        }\n+        checkJVMCI(eventClass);\n+    }\n+\n+    \/**\n+     * Checks that JVMCI prevents unblessed access to {@code EventWriterFactory.getEventWriter(long)}.\n+     *\/\n+    private static void checkJVMCI(Class<?> eventClass) throws Throwable {\n+        MetaAccessProvider metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();\n+        ResolvedJavaMethod commit = findCommitMethod(metaAccess, eventClass);\n+        ConstantPool cp = commit.getConstantPool();\n+\n+        \/\/ Search for first INVOKESTATIC instruction in commit method which is expected\n+        \/\/ to be the call to jdk.jfr.internal.event.EventWriterFactory.getEventWriter(long).\n+        final int INVOKESTATIC = 184;\n+        byte[] code = commit.getCode();\n+        for (int bci = 0; bci < code.length; bci++) {\n+            int b = code[bci] & 0xff;\n+            if (b == INVOKESTATIC) {\n+                int cpi = ((code[bci + 1] & 0xff) << 8) | (code[bci + 2] & 0xff);\n+                try {\n+                    cp.lookupMethod(cpi, 184, commit);\n+                    throw new AssertionError(\"Expected IllegalAccessError\");\n+                } catch (IllegalAccessError e) {\n+                }\n+\n+                \/\/ Ignore all subsequent instructions\n+                return;\n+            }\n+        }\n+        throw new AssertionError(\"did not find INVOKESTATIC in \" + commit.format(\"%H.%n(%p)\"));\n+    }\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestGetEventWriter.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"modified"}]}