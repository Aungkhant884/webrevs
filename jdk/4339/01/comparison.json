{"files":[{"patch":"@@ -41,0 +41,3 @@\n+\/* The winsock provider ID of the Microsoft AF_UNIX implementation *\/\n+static GUID MS_PROVIDER_ID  = {0xA00943D9,0x9C2E,0x4633,{0x9B,0x59,0,0x57,0xA3,0x16,0x09,0x94}};\n+\n@@ -87,0 +90,16 @@\n+static int cmpGuid(GUID *g1, GUID *g2) {\n+    if (g1->Data1 != g2->Data1)\n+        return JNI_FALSE;\n+    if (g1->Data2 != g2->Data2)\n+        return JNI_FALSE;\n+    if (g1->Data3 != g2->Data3)\n+        return JNI_FALSE;\n+    for (int i=0; i<8; i++) {\n+        if (g1->Data4[i] != g2->Data4[i])\n+            return JNI_FALSE;\n+    }\n+    return JNI_TRUE;\n+}\n+\n+static WSAPROTOCOL_INFOW provider;\n+\n@@ -90,3 +109,20 @@\n-    SOCKET s = socket(PF_UNIX, SOCK_STREAM, 0);\n-    if (s == INVALID_SOCKET) {\n-        return JNI_FALSE;\n+    WSAPROTOCOL_INFOW info[5]; \/\/ if not large enough, a buffer is malloc'd\n+    LPWSAPROTOCOL_INFOW infoPtr = &info[0];\n+    DWORD len = sizeof(info);\n+    jboolean found = JNI_FALSE;\n+\n+    \/*\n+     * First locate the Microsoft AF_UNIX Winsock provider\n+     *\/\n+    int result = WSAEnumProtocolsW(0, infoPtr, &len);\n+    if (result == SOCKET_ERROR) {\n+        if (GetLastError() == WSAENOBUFS) {\n+            infoPtr = (LPWSAPROTOCOL_INFOW)malloc(len);\n+            result = WSAEnumProtocolsW(0, infoPtr, &len);\n+            if (result == SOCKET_ERROR) {\n+                free(infoPtr);\n+                return JNI_FALSE;\n+            }\n+        } else {\n+            return JNI_FALSE;\n+        }\n@@ -94,2 +130,24 @@\n-    closesocket(s);\n-    return JNI_TRUE;\n+    for (int i=0; i<result;  i++) {\n+        if (infoPtr[i].iAddressFamily == AF_UNIX) {\n+            GUID g = infoPtr[i].ProviderId;\n+            if (cmpGuid(&g, &MS_PROVIDER_ID)) {\n+                found = JNI_TRUE;\n+                provider = infoPtr[i];\n+                break;\n+            }\n+        }\n+    }\n+    if (infoPtr != &info[0]) {\n+        free(infoPtr);\n+    }\n+    \/*\n+     * check we can create a socket\n+     *\/\n+    if (found) {\n+        SOCKET s = WSASocketW(PF_UNIX, SOCK_STREAM, 0, &provider, 0, WSA_FLAG_OVERLAPPED);\n+        if (s == INVALID_SOCKET) {\n+            return JNI_FALSE;\n+        }\n+        closesocket(s);\n+    }\n+    return found;\n@@ -101,1 +159,1 @@\n-    SOCKET s = socket(PF_UNIX, SOCK_STREAM, 0);\n+    SOCKET s = WSASocketW(PF_UNIX, SOCK_STREAM, 0, &provider, 0, WSA_FLAG_OVERLAPPED);\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/UnixDomainSockets.c","additions":64,"deletions":6,"binary":false,"changes":70,"status":"modified"}]}