{"files":[{"patch":"@@ -163,1 +163,1 @@\n-    private static native boolean socketSupported();\n+    private static native boolean init();\n@@ -179,1 +179,1 @@\n-        supported = socketSupported();\n+        supported = init();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/UnixDomainSockets.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-Java_sun_nio_ch_UnixDomainSockets_socketSupported(JNIEnv *env, jclass cl)\n+Java_sun_nio_ch_UnixDomainSockets_init(JNIEnv *env, jclass cl)\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/UnixDomainSockets.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,3 @@\n+\/* The winsock provider ID of the Microsoft AF_UNIX implementation *\/\n+static GUID MS_PROVIDER_ID  = {0xA00943D9,0x9C2E,0x4633,{0x9B,0x59,0,0x57,0xA3,0x16,0x09,0x94}};\n+\n@@ -87,5 +90,6 @@\n-JNIEXPORT jboolean JNICALL\n-Java_sun_nio_ch_UnixDomainSockets_socketSupported(JNIEnv *env, jclass cl)\n-{\n-    SOCKET s = socket(PF_UNIX, SOCK_STREAM, 0);\n-    if (s == INVALID_SOCKET) {\n+static int cmpGuid(GUID *g1, GUID *g2) {\n+    if (g1->Data1 != g2->Data1)\n+        return JNI_FALSE;\n+    if (g1->Data2 != g2->Data2)\n+        return JNI_FALSE;\n+    if (g1->Data3 != g2->Data3)\n@@ -93,0 +97,3 @@\n+    for (int i=0; i<8; i++) {\n+        if (g1->Data4[i] != g2->Data4[i])\n+            return JNI_FALSE;\n@@ -94,1 +101,0 @@\n-    closesocket(s);\n@@ -98,0 +104,52 @@\n+static WSAPROTOCOL_INFOW provider;\n+\n+JNIEXPORT jboolean JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_init(JNIEnv *env, jclass cl)\n+{\n+    WSAPROTOCOL_INFOW info[5]; \/\/ if not large enough, a buffer is malloc'd\n+    LPWSAPROTOCOL_INFOW infoPtr = &info[0];\n+    DWORD len = sizeof(info);\n+    jboolean found = JNI_FALSE;\n+\n+    \/*\n+     * First locate the Microsoft AF_UNIX Winsock provider\n+     *\/\n+    int result = WSAEnumProtocolsW(0, infoPtr, &len);\n+    if (result == SOCKET_ERROR) {\n+        if (GetLastError() == WSAENOBUFS) {\n+            infoPtr = (LPWSAPROTOCOL_INFOW)malloc(len);\n+            result = WSAEnumProtocolsW(0, infoPtr, &len);\n+            if (result == SOCKET_ERROR) {\n+                free(infoPtr);\n+                return JNI_FALSE;\n+            }\n+        } else {\n+            return JNI_FALSE;\n+        }\n+    }\n+    for (int i=0; i<result;  i++) {\n+        if (infoPtr[i].iAddressFamily == AF_UNIX) {\n+            GUID g = infoPtr[i].ProviderId;\n+            if (cmpGuid(&g, &MS_PROVIDER_ID)) {\n+                found = JNI_TRUE;\n+                provider = infoPtr[i];\n+                break;\n+            }\n+        }\n+    }\n+    if (infoPtr != &info[0]) {\n+        free(infoPtr);\n+    }\n+    \/*\n+     * check we can create a socket\n+     *\/\n+    if (found) {\n+        SOCKET s = WSASocketW(PF_UNIX, SOCK_STREAM, 0, &provider, 0, WSA_FLAG_OVERLAPPED);\n+        if (s == INVALID_SOCKET) {\n+            return JNI_FALSE;\n+        }\n+        closesocket(s);\n+    }\n+    return found;\n+}\n+\n@@ -101,1 +159,1 @@\n-    SOCKET s = socket(PF_UNIX, SOCK_STREAM, 0);\n+    SOCKET s = WSASocketW(PF_UNIX, SOCK_STREAM, 0, &provider, 0, WSA_FLAG_OVERLAPPED);\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/UnixDomainSockets.c","additions":65,"deletions":7,"binary":false,"changes":72,"status":"modified"}]}