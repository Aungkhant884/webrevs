{"files":[{"patch":"@@ -31,3 +31,0 @@\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-import java.util.stream.Stream;\n@@ -113,57 +110,0 @@\n-    \/**\n-     * Walk the call stack and find the first method that has called\n-     * MethodHandleNatives.linkCallSite(). This is the method which has the invokedynamic\n-     * bytecode that is being resolved to the current CallSite. CallerFinder must\n-     * used only inside the constructor of CallSite.\n-     * <p>\n-     * Note the use of inner classes (instead of stream\/lambda) to avoid triggering\n-     * further invokedynamic resolution, which would cause infinite recursion in the\n-     * TRACE_CALLSITE code.\n-     * <p>\n-     * It's OK to use + for string concat, because java.base is compiled without\n-     * the use of indy string concat.\n-     *\/\n-    private static class CallerFinder implements Function<Stream<StackWalker.StackFrame>, Object> {\n-        private String caller = null;\n-        private boolean foundLinkCallSite = false;\n-        private String bsm = \"Unknown\";\n-        private StackWalker.StackFrame lastFrame;\n-\n-        @Override\n-        public Object apply(Stream<StackWalker.StackFrame> s) {\n-            s.forEach(new Consumer<StackWalker.StackFrame>() {\n-                @Override\n-                public void accept(StackWalker.StackFrame f) {\n-                    String className = f.getClassName();\n-                    if (className.equals(\"java.lang.invoke.MethodHandleNatives\") && f.getMethodName().equals(\"linkCallSite\")) {\n-                        foundLinkCallSite = true;\n-                    } else if (caller == null && foundLinkCallSite) {\n-                        \/\/ Find the caller of MethodHandleNatives.linkCallSite(), which\n-                        \/\/ contains the invokedynamic bytecode that has triggered the BSM.\n-                        caller = f.toStackTraceElement().toString();\n-                    } else if (className.equals(\"java.lang.invoke.BootstrapMethodInvoker\") && f.getMethodName().equals(\"invoke\")) {\n-                        if (lastFrame != null) {\n-                            bsm = lastFrame.toStackTraceElement().toString();\n-                        }\n-                    }\n-                    lastFrame = f;\n-                }\n-            });\n-            return null;\n-        }\n-\n-        \/\/ When the caller is found, return a human readable string like\n-        \/\/ \"java.base\/java.util.stream.FindOps$FindSink$OfRef.<clinit>(FindOps.java:202)\"\n-        public String getCaller() {\n-            if (caller == null) {\n-                return \"Unknown\";\n-            } else {\n-                return caller;\n-            }\n-        }\n-\n-        public String getBSM() {\n-            return bsm;\n-        }\n-    }\n-\n@@ -179,10 +119,0 @@\n-        if (MethodHandleStatics.TRACE_CALLSITE) {\n-            synchronized (CallSite.class) { \/\/ Avoid interleaving from concurrent threads\n-                CallerFinder finder = new CallerFinder();\n-                StackWalker.getInstance().walk(finder);\n-                System.out.println(\"======== CallSite: \" + finder.getCaller());\n-                System.out.println(\"BSM = \" + finder.getBSM());\n-                System.out.println(\"target class = \" + target.getClass().getName());\n-                System.out.println(\"target = \" + target.debugString(0));\n-            }\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/CallSite.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -1814,1 +1814,1 @@\n-        return new String(new char[indentLevel*4]).replace('\\0', ' ');\n+        return \"    \".repeat(indentLevel);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n@@ -284,0 +287,6 @@\n+        if (TRACE_METHOD_LINKAGE) {\n+            MethodHandle target = callSite.getTarget();\n+            System.out.println(\"linkCallSite target class => \" + target.getClass().getName());\n+            System.out.println(\"linkCallSite target => \" + target.debugString(0));\n+        }\n+\n@@ -301,1 +310,21 @@\n-        System.out.println(\"linkCallSite \"+caller.getName()+\" \"+\n+        String callerName = caller.getName();\n+        String[] callerInfo = new String[] {callerName};\n+        StackWalker.getInstance().walk(new Function<Stream<StackWalker.StackFrame>, Object>() {\n+            \/\/ We use inner classes (instead of stream\/lambda) to avoid triggering\n+            \/\/ further invokedynamic resolution, which would cause infinite recursion.\n+            \/\/ It's OK to use + for string concat, because java.base is compiled without\n+            \/\/ the use of indy string concat.\n+            @Override\n+            public Object apply(Stream<StackWalker.StackFrame> s) {\n+                s.forEach(new Consumer<StackWalker.StackFrame>() {\n+                    @Override\n+                    public void accept(StackWalker.StackFrame f) {\n+                        if (!\"java.lang.invoke.MethodHandleNatives\".equals(f.getClassName()) && callerInfo[0] == callerName) {\n+                            callerInfo[0] = f.toStackTraceElement().toString();\n+                        }\n+                    }\n+                });\n+                return null;\n+            }\n+        });\n+        System.out.println(\"linkCallSite \"+callerInfo[0]+\" \"+\n@@ -307,1 +336,1 @@\n-            System.out.println(\"linkCallSite => \"+res+\" + \"+appendixResult[0]);\n+            System.out.println(\"linkCallSite linkage => \"+res+\" + \"+appendixResult[0]);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":31,"deletions":2,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,0 @@\n-    static final boolean TRACE_CALLSITE;\n@@ -80,2 +79,0 @@\n-        TRACE_CALLSITE = Boolean.parseBoolean(\n-                props.getProperty(\"java.lang.invoke.MethodHandle.TRACE_CALLSITE\"));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleStatics.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"}]}