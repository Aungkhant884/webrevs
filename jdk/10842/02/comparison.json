{"files":[{"patch":"@@ -161,2 +161,2 @@\n-    Object internalProperties() {\n-        return \"\\n& BMH=\"+internalValues();\n+    Object internalProperties(int indentLevel) {\n+        return \"\\n\" + debugPrefix(indentLevel) + \"& BMH=\" + internalValues(indentLevel);\n@@ -166,1 +166,2 @@\n-    final String internalValues() {\n+    final String internalValues(int indentLevel) {\n+        String prefix = debugPrefix(indentLevel);\n@@ -168,1 +169,1 @@\n-        if (count == 1) {\n+        if (count == 1 && indentLevel < 0) {\n@@ -173,1 +174,8 @@\n-            sb.append(\"\\n  \").append(i).append(\": ( \").append(arg(i)).append(\" )\");\n+            Object theArg = arg(i);\n+            sb.append(\"\\n  \").append(prefix).append(i);\n+            if (indentLevel >= 0 && theArg instanceof MethodHandle) {\n+                sb.append(\": MethodHandle = {\").append(((MethodHandle)theArg).debugString(indentLevel+1));\n+                sb.append(\"\\n  \").append(prefix).append(\"}\");\n+            } else {\n+                sb.append(\": ( \").append(theArg).append(\" )\");\n+            }\n@@ -175,1 +183,1 @@\n-        return sb.append(\"\\n]\").toString();\n+        return sb.append(\"\\n\").append(prefix).append(\"]\").toString();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BoundMethodHandle.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -173,2 +173,2 @@\n-    String internalProperties() {\n-        return \"\\n& DMH.MN=\"+internalMemberName();\n+    String internalProperties(int indentLevel) {\n+        return \"\\n\" + debugPrefix(indentLevel) + \"& DMH.MN=\" + internalMemberName();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1032,0 +1032,5 @@\n+        return debugString(-1);\n+    }\n+\n+    String debugString(int indentLevel) {\n+        String prefix = MethodHandle.debugPrefix(indentLevel);\n@@ -1033,1 +1038,2 @@\n-        StringBuilder buf = new StringBuilder(lambdaName + \"=Lambda(\");\n+        StringBuilder buf = new StringBuilder(lambdaName);\n+        buf.append(\"=Lambda(\");\n@@ -1037,1 +1043,1 @@\n-            if (i >= arity)  buf.append(\"\\n    \");\n+            if (i >= arity)  buf.append(\"\\n    \").append(prefix);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1691,0 +1691,6 @@\n+     * @param indentLevel If negative, return only information about this MethodHandle.\n+     *  Otherwise, return information about this MethodHandle and (recursively) all other\n+     *  MethodHandles, if any, that are invoked directly or indirectly by this MethodHandle.\n+     *  During the recursion, `indentLevel` is incremented (see\n+     *  BoundMethodHandle.internalValues()) to improve readability of\n+     *  the nested structure.\n@@ -1692,0 +1698,4 @@\n+    String debugString(int indentLevel) {\n+        return type + \" : \" + internalForm().debugString(indentLevel) +\n+               internalProperties(indentLevel);\n+    }\n@@ -1693,1 +1703,1 @@\n-        return type+\" : \"+internalForm()+internalProperties();\n+        return debugString(-1);\n@@ -1790,1 +1800,1 @@\n-    Object internalValues() {\n+    Object internalValues(int indentLevel) {\n@@ -1794,0 +1804,13 @@\n+    \/**\n+     * Various debugging methods in MethodHandle (and subclasses thereof) and LambdaForm\n+     * take an `indentLevel` argument, so that {@link java.lang.invoke.MethodHandle.debugString(int)}\n+     * can return nested structures in a readable fashion. This method returns a string to be\n+     * prepended to each line at the specified level.\n+     *\/\n+    static String debugPrefix(int indentLevel) {\n+        if (indentLevel <= 0) {\n+            return \"\";\n+        }\n+        return \"    \".repeat(indentLevel);\n+    }\n+\n@@ -1796,0 +1819,4 @@\n+        return internalProperties(-1);\n+    }\n+\n+    Object internalProperties(int indentLevel) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandle.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -284,0 +284,6 @@\n+        if (TRACE_METHOD_LINKAGE) {\n+            MethodHandle target = callSite.getTarget();\n+            System.out.println(\"linkCallSite target class => \" + target.getClass().getName());\n+            System.out.println(\"linkCallSite target => \" + target.debugString(0));\n+        }\n+\n@@ -301,1 +307,1 @@\n-        System.out.println(\"linkCallSite \"+caller.getName()+\" \"+\n+        System.out.println(\"linkCallSite \"+getCallerInfo(caller)+\" \"+\n@@ -307,1 +313,1 @@\n-            System.out.println(\"linkCallSite => \"+res+\" + \"+appendixResult[0]);\n+            System.out.println(\"linkCallSite linkage => \"+res+\" + \"+appendixResult[0]);\n@@ -316,0 +322,14 @@\n+    \/**\n+     * Return a human-readable description of the caller. Something like\n+     * \"java.base\/java.security.Security.<clinit>(Security.java:82)\"\n+     *\/\n+    private static String getCallerInfo(Class<?> caller) {\n+        for (StackTraceElement e : Thread.currentThread().getStackTrace()) {\n+            if (e.getClassName().equals(caller.getName())) {\n+                return e.toString();\n+            }\n+        }\n+        \/\/ fallback if the caller is somehow missing from the stack.\n+        return caller.getName();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"}]}