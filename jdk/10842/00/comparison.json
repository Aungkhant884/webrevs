{"files":[{"patch":"@@ -161,2 +161,2 @@\n-    Object internalProperties() {\n-        return \"\\n& BMH=\"+internalValues();\n+    Object internalProperties(int indentLevel) {\n+        return \"\\n\" + debugPrefix(indentLevel) + \"& BMH=\" + internalValues(indentLevel);\n@@ -166,1 +166,2 @@\n-    final String internalValues() {\n+    final String internalValues(int indentLevel) {\n+        String prefix = debugPrefix(indentLevel);\n@@ -168,1 +169,1 @@\n-        if (count == 1) {\n+        if (count == 1 && indentLevel < 0) {\n@@ -173,1 +174,8 @@\n-            sb.append(\"\\n  \").append(i).append(\": ( \").append(arg(i)).append(\" )\");\n+            Object theArg = arg(i);\n+            sb.append(\"\\n  \").append(prefix).append(i);\n+            if (indentLevel >= 0 && theArg instanceof MethodHandle) {\n+                sb.append(\": MethodHandle = {\").append(((MethodHandle)theArg).debugString(indentLevel+1));\n+                sb.append(\"\\n  \").append(prefix).append(\"}\");\n+            } else {\n+                sb.append(\": ( \").append(theArg).append(\" )\");\n+            }\n@@ -175,1 +183,1 @@\n-        return sb.append(\"\\n]\").toString();\n+        return sb.append(\"\\n\").append(prefix).append(\"]\").toString();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BoundMethodHandle.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n@@ -110,0 +113,57 @@\n+    \/**\n+     * Walk the call stack and find the first method that has called\n+     * MethodHandleNatives.linkCallSite(). This is the method which has the invokedynamic\n+     * bytecode that is being resolved to the current CallSite. CallerFinder must\n+     * used only inside the constructor of CallSite.\n+     * <p>\n+     * Note the use of inner classes (instead of stream\/lambda) to avoid triggering\n+     * further invokedynamic resolution, which would cause infinite recursion in the\n+     * TRACE_CALLSITE code.\n+     * <p>\n+     * It's OK to use + for string concat, because java.base is compiled without\n+     * the use of indy string concat.\n+     *\/\n+    private static class CallerFinder implements Function<Stream<StackWalker.StackFrame>, Object> {\n+        private String caller = null;\n+        private boolean foundLinkCallSite = false;\n+        private String bsm = \"Unknown\";\n+        private StackWalker.StackFrame lastFrame;\n+\n+        @Override\n+        public Object apply(Stream<StackWalker.StackFrame> s) {\n+            s.forEach(new Consumer<StackWalker.StackFrame>() {\n+                @Override\n+                public void accept(StackWalker.StackFrame f) {\n+                    String className = f.getClassName();\n+                    if (className.equals(\"java.lang.invoke.MethodHandleNatives\") && f.getMethodName().equals(\"linkCallSite\")) {\n+                        foundLinkCallSite = true;\n+                    } else if (caller == null && foundLinkCallSite) {\n+                        \/\/ Find the caller of MethodHandleNatives.linkCallSite(), which\n+                        \/\/ contains the invokedynamic bytecode that has triggered the BSM.\n+                        caller = f.toStackTraceElement().toString();\n+                    } else if (className.equals(\"java.lang.invoke.BootstrapMethodInvoker\") && f.getMethodName().equals(\"invoke\")) {\n+                        if (lastFrame != null) {\n+                            bsm = lastFrame.toStackTraceElement().toString();\n+                        }\n+                    }\n+                    lastFrame = f;\n+                }\n+            });\n+            return null;\n+        }\n+\n+        \/\/ When the caller is found, return a human readable string like\n+        \/\/ \"java.base\/java.util.stream.FindOps$FindSink$OfRef.<clinit>(FindOps.java:202)\"\n+        public String getCaller() {\n+            if (caller == null) {\n+                return \"Unknown\";\n+            } else {\n+                return caller;\n+            }\n+        }\n+\n+        public String getBSM() {\n+            return bsm;\n+        }\n+    }\n+\n@@ -119,0 +179,10 @@\n+        if (MethodHandleStatics.TRACE_CALLSITE) {\n+            synchronized (CallSite.class) { \/\/ Avoid interleaving from concurrent threads\n+                CallerFinder finder = new CallerFinder();\n+                StackWalker.getInstance().walk(finder);\n+                System.out.println(\"======== CallSite: \" + finder.getCaller());\n+                System.out.println(\"BSM = \" + finder.getBSM());\n+                System.out.println(\"target class = \" + target.getClass().getName());\n+                System.out.println(\"target = \" + target.debugString(0));\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/CallSite.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -173,2 +173,2 @@\n-    String internalProperties() {\n-        return \"\\n& DMH.MN=\"+internalMemberName();\n+    String internalProperties(int indentLevel) {\n+        return \"\\n\" + debugPrefix(indentLevel) + \"& DMH.MN=\" + internalMemberName();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1032,0 +1032,5 @@\n+        return debugString(-1);\n+    }\n+\n+    String debugString(int indentLevel) {\n+        String prefix = MethodHandle.debugPrefix(indentLevel);\n@@ -1033,1 +1038,2 @@\n-        StringBuilder buf = new StringBuilder(lambdaName + \"=Lambda(\");\n+        StringBuilder buf = new StringBuilder(lambdaName);\n+        buf.append(\"=Lambda(\");\n@@ -1037,1 +1043,1 @@\n-            if (i >= arity)  buf.append(\"\\n    \");\n+            if (i >= arity)  buf.append(\"\\n    \").append(prefix);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1691,0 +1691,6 @@\n+     * @param indentLevel If negative, return only information about this MethodHandle.\n+     *  Otherwise, return information about this MethodHandle and (recursively) all other\n+     *  MethodHandles, if any, that are invoked directly or indirectly by this MethodHandle.\n+     *  During the recursion, `indentLevel` is incremented (see\n+     *  BoundMethodHandle.internalValues()) to improve readability of\n+     *  the nested structure.\n@@ -1692,0 +1698,4 @@\n+    String debugString(int indentLevel) {\n+        return type + \" : \" + internalForm().debugString(indentLevel) +\n+               internalProperties(indentLevel);\n+    }\n@@ -1693,1 +1703,1 @@\n-        return type+\" : \"+internalForm()+internalProperties();\n+        return debugString(-1);\n@@ -1790,1 +1800,1 @@\n-    Object internalValues() {\n+    Object internalValues(int indentLevel) {\n@@ -1794,0 +1804,13 @@\n+    \/**\n+     * Various debugging methods in MethodHandle (and subclasses thereof) and LambdaForm\n+     * take an `indentLevel` argument, so that {@link java.lang.invoke.MethodHandle.debugString(int)}\n+     * can return nested structures in a readable fashion. This method returns a string to be\n+     * prepended to each line at the specified level.\n+     *\/\n+    static String debugPrefix(int indentLevel) {\n+        if (indentLevel <= 0) {\n+            return \"\";\n+        }\n+        return new String(new char[indentLevel*4]).replace('\\0', ' ');\n+    }\n+\n@@ -1796,0 +1819,4 @@\n+        return internalProperties(-1);\n+    }\n+\n+    Object internalProperties(int indentLevel) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandle.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,1 @@\n+    static final boolean TRACE_CALLSITE;\n@@ -79,0 +80,2 @@\n+        TRACE_CALLSITE = Boolean.parseBoolean(\n+                props.getProperty(\"java.lang.invoke.MethodHandle.TRACE_CALLSITE\"));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleStatics.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}