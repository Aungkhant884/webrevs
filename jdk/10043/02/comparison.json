{"files":[{"patch":"@@ -169,1 +169,1 @@\n-    ProtectionDomainCacheEntry* entry = SystemDictionary::pd_cache_table()->get(protection_domain);\n+    WeakHandle obj = ProtectionDomainCacheTable::add_if_absent(protection_domain);\n@@ -171,1 +171,1 @@\n-    ProtectionDomainEntry* new_head = new ProtectionDomainEntry(entry, _pd_set);\n+    ProtectionDomainEntry* new_head = new ProtectionDomainEntry(obj, _pd_set);\n","filename":"src\/hotspot\/share\/classfile\/dictionary.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -39,1 +40,1 @@\n-#include \"utilities\/hashtable.inline.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n@@ -41,3 +42,2 @@\n-unsigned int ProtectionDomainCacheTable::compute_hash(Handle protection_domain) {\n-  \/\/ Identity hash can safepoint, so keep protection domain in a Handle.\n-  return (unsigned int)(protection_domain->identity_hash());\n+unsigned int ProtectionDomainCacheTable::compute_hash(const WeakHandle& protection_domain) {\n+  return (unsigned int)(protection_domain.resolve()->identity_hash());\n@@ -46,2 +46,2 @@\n-int ProtectionDomainCacheTable::index_for(Handle protection_domain) {\n-  return hash_to_index(compute_hash(protection_domain));\n+bool ProtectionDomainCacheTable::equals(const WeakHandle& protection_domain1, const WeakHandle& protection_domain2) {\n+  return protection_domain1.peek() == protection_domain2.peek();\n@@ -50,5 +50,6 @@\n-ProtectionDomainCacheTable::ProtectionDomainCacheTable(int table_size)\n-  : Hashtable<WeakHandle, mtClass>(table_size, sizeof(ProtectionDomainCacheEntry))\n-{   _dead_entries = false;\n-    _total_oops_removed = 0;\n-}\n+ResourceHashtable<WeakHandle, WeakHandle, 1009, ResourceObj::C_HEAP, mtClass,\n+                  ProtectionDomainCacheTable::compute_hash,\n+                  ProtectionDomainCacheTable::equals> _pd_cache_table;\n+\n+bool ProtectionDomainCacheTable::_dead_entries = false;\n+int  ProtectionDomainCacheTable::_total_oops_removed = 0;\n@@ -108,0 +109,30 @@\n+static int purge_entries_from_table() {\n+  MutexLocker ml(SystemDictionary_lock);\n+\n+  struct Deleter {\n+    int _oops_removed;\n+    Deleter() : _oops_removed(0) {}\n+\n+    bool do_entry(WeakHandle& key, WeakHandle& value) {\n+      oop pd = value.peek();\n+      if (value.peek() == nullptr) {\n+        _oops_removed++;\n+        LogTarget(Debug, protectiondomain, table) lt;\n+        if (lt.is_enabled()) {\n+          LogStream ls(lt);\n+          ls.print_cr(\"protection domain unlinked %d\", _oops_removed);\n+        }\n+        value.release(Universe::vm_weak());\n+        return true;\n+      } else {\n+        return false;\n+      }\n+    }\n+  };\n+\n+  Deleter deleter;\n+  _pd_cache_table.unlink(&deleter);\n+  return deleter._oops_removed;\n+}\n+\n+\n@@ -131,0 +162,1 @@\n+  int oops_removed = purge_entries_from_table();\n@@ -132,23 +164,0 @@\n-  MutexLocker ml(SystemDictionary_lock);\n-  int oops_removed = 0;\n-  for (int i = 0; i < table_size(); ++i) {\n-    ProtectionDomainCacheEntry** p = bucket_addr(i);\n-    ProtectionDomainCacheEntry* entry = bucket(i);\n-    while (entry != NULL) {\n-      oop pd = entry->object_no_keepalive();\n-      if (pd != NULL) {\n-        p = entry->next_addr();\n-      } else {\n-        oops_removed++;\n-        LogTarget(Debug, protectiondomain, table) lt;\n-        if (lt.is_enabled()) {\n-          LogStream ls(lt);\n-          ls.print_cr(\"protection domain unlinked at %d\", i);\n-        }\n-        entry->literal().release(Universe::vm_weak());\n-        *p = entry->next();\n-        free_entry(entry);\n-      }\n-      entry = *p;\n-    }\n-  }\n@@ -159,1 +168,1 @@\n-void ProtectionDomainCacheTable::print_on(outputStream* st) const {\n+void ProtectionDomainCacheTable::print_on(outputStream* st) {\n@@ -161,9 +170,6 @@\n-  st->print_cr(\"Protection domain cache table (table_size=%d, classes=%d)\",\n-               table_size(), number_of_entries());\n-  for (int index = 0; index < table_size(); index++) {\n-    for (ProtectionDomainCacheEntry* probe = bucket(index);\n-                                     probe != NULL;\n-                                     probe = probe->next()) {\n-      st->print_cr(\"%4d: protection_domain: \" PTR_FORMAT, index, p2i(probe->object_no_keepalive()));\n-    }\n-  }\n+  auto printer = [&] (WeakHandle& key, WeakHandle& value) {\n+      st->print_cr(\"  protection_domain: \" PTR_FORMAT, p2i(value.peek()));\n+  };\n+  st->print_cr(\"Protection domain cache table (table_size=%d, protection domains=%d)\",\n+                _pd_cache_table.table_size(), _pd_cache_table.number_of_entries());\n+  _pd_cache_table.iterate_all(printer);\n@@ -173,5 +179,4 @@\n-  verify_table<ProtectionDomainCacheEntry>(\"Protection Domain Table\");\n-}\n-\n-oop ProtectionDomainCacheEntry::object() {\n-  return literal().resolve();\n+  auto verifier = [&] (WeakHandle& key, WeakHandle& value) {\n+    guarantee(value.peek() == nullptr || oopDesc::is_oop(value.peek()), \"must be an oop\");\n+  };\n+  _pd_cache_table.iterate_all(verifier);\n@@ -183,4 +188,0 @@\n-oop ProtectionDomainCacheEntry::object_no_keepalive() {\n-  return literal().peek();\n-}\n-\n@@ -188,1 +189,1 @@\n-  return _pd_cache->object_no_keepalive();\n+  return _object.peek();\n@@ -191,18 +192,1 @@\n-void ProtectionDomainCacheEntry::verify() {\n-  guarantee(object_no_keepalive() == NULL || oopDesc::is_oop(object_no_keepalive()), \"must be an oop\");\n-}\n-\n-ProtectionDomainCacheEntry* ProtectionDomainCacheTable::get(Handle protection_domain) {\n-  unsigned int hash = compute_hash(protection_domain);\n-  int index = hash_to_index(hash);\n-\n-  ProtectionDomainCacheEntry* entry = find_entry(index, protection_domain);\n-  if (entry == NULL) {\n-    entry = add_entry(index, hash, protection_domain);\n-  }\n-  \/\/ keep entry alive\n-  (void)entry->object();\n-  return entry;\n-}\n-\n-ProtectionDomainCacheEntry* ProtectionDomainCacheTable::find_entry(int index, Handle protection_domain) {\n+WeakHandle ProtectionDomainCacheTable::add_if_absent(Handle protection_domain) {\n@@ -210,3 +194,16 @@\n-  for (ProtectionDomainCacheEntry* e = bucket(index); e != NULL; e = e->next()) {\n-    if (e->object_no_keepalive() == protection_domain()) {\n-      return e;\n+  WeakHandle w(Universe::vm_weak(), protection_domain);\n+  bool created;\n+  WeakHandle* wk = _pd_cache_table.put_if_absent(w, w, &created);\n+  if (!created) {\n+    \/\/ delete the one created since we already had it in the table\n+    w.release(Universe::vm_weak());\n+    \/\/ Keep entry alive\n+    (void)wk->resolve();\n+    return *wk;\n+  } else {\n+    LogTarget(Debug, protectiondomain, table) lt;\n+    if (lt.is_enabled()) {\n+      LogStream ls(lt);\n+      ls.print(\"protection domain added \");\n+      protection_domain->print_value_on(&ls);\n+      ls.cr();\n@@ -214,0 +211,2 @@\n+    (void)w.resolve();\n+    return w;\n@@ -215,0 +214,1 @@\n+}\n@@ -216,1 +216,7 @@\n-  return NULL;\n+void ProtectionDomainCacheTable::print_table_statistics(outputStream* st) {\n+  auto size = [&] (WeakHandle& key, WeakHandle& value) {\n+    \/\/ The only storage is in OopStorage for an oop\n+    return sizeof(oop);\n+  };\n+  TableStatistics ts = _pd_cache_table.statistics_calculate(size);\n+  ts.print(st, \"ProtectionDomainCacheTable\");\n@@ -219,16 +225,2 @@\n-ProtectionDomainCacheEntry* ProtectionDomainCacheTable::add_entry(int index, unsigned int hash, Handle protection_domain) {\n-  assert_locked_or_safepoint(SystemDictionary_lock);\n-  assert(index == index_for(protection_domain), \"incorrect index?\");\n-  assert(find_entry(index, protection_domain) == NULL, \"no double entry\");\n-\n-  LogTarget(Debug, protectiondomain, table) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    ls.print(\"protection domain added \");\n-    protection_domain->print_value_on(&ls);\n-    ls.cr();\n-  }\n-  WeakHandle w(Universe::vm_weak(), protection_domain);\n-  ProtectionDomainCacheEntry* p = new_entry(hash, w);\n-  Hashtable<WeakHandle, mtClass>::add_entry(index, p);\n-  return p;\n+int ProtectionDomainCacheTable::number_of_entries() {\n+  return _pd_cache_table.number_of_entries();\n","filename":"src\/hotspot\/share\/classfile\/protectionDomainCache.cpp","additions":85,"deletions":93,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-#include \"utilities\/hashtable.hpp\"\n@@ -33,29 +32,1 @@\n-\/\/ This class caches the approved protection domains that can access loaded classes.\n-\/\/ Dictionary entry pd_set point to entries in this hashtable.   Please refer\n-\/\/ to dictionary.hpp pd_set for more information about how protection domain entries\n-\/\/ are used.\n-\/\/ This table is walked during GC, rather than the class loader data graph dictionaries.\n-class ProtectionDomainCacheEntry : public HashtableEntry<WeakHandle, mtClass> {\n-  friend class VMStructs;\n- public:\n-  oop object();\n-  oop object_no_keepalive();\n-\n-  ProtectionDomainCacheEntry* next() {\n-    return (ProtectionDomainCacheEntry*)HashtableEntry<WeakHandle, mtClass>::next();\n-  }\n-\n-  ProtectionDomainCacheEntry** next_addr() {\n-    return (ProtectionDomainCacheEntry**)HashtableEntry<WeakHandle, mtClass>::next_addr();\n-  }\n-\n-  void verify();\n-};\n-\n-\/\/ The ProtectionDomainCacheTable contains all protection domain oops. The\n-\/\/ dictionary entries reference its entries instead of having references to oops\n-\/\/ directly.\n-\/\/ This is used to speed up system dictionary iteration: the oops in the\n-\/\/ protection domain are the only ones referring the Java heap. So when there is\n-\/\/ need to update these, instead of going over every entry of the system dictionary,\n-\/\/ we only need to iterate over this set.\n+\/\/ The ProtectionDomainCacheTable contains all protection domain oops as WeakHandles.\n@@ -64,21 +35,1 @@\n-class ProtectionDomainCacheTable : public Hashtable<WeakHandle, mtClass> {\n-  ProtectionDomainCacheEntry* bucket(int i) const {\n-    return (ProtectionDomainCacheEntry*) Hashtable<WeakHandle, mtClass>::bucket(i);\n-  }\n-\n-  \/\/ The following method is not MT-safe and must be done under lock.\n-  ProtectionDomainCacheEntry** bucket_addr(int i) {\n-    return (ProtectionDomainCacheEntry**) Hashtable<WeakHandle, mtClass>::bucket_addr(i);\n-  }\n-\n-  ProtectionDomainCacheEntry* new_entry(unsigned int hash, WeakHandle protection_domain) {\n-    ProtectionDomainCacheEntry* entry = (ProtectionDomainCacheEntry*)\n-      Hashtable<WeakHandle, mtClass>::new_entry(hash, protection_domain);\n-    return entry;\n-  }\n-\n-  static unsigned int compute_hash(Handle protection_domain);\n-\n-  int index_for(Handle protection_domain);\n-  ProtectionDomainCacheEntry* add_entry(int index, unsigned int hash, Handle protection_domain);\n-  ProtectionDomainCacheEntry* find_entry(int index, Handle protection_domain);\n+class ProtectionDomainCacheTable : public AllStatic {\n@@ -86,2 +37,2 @@\n-  bool _dead_entries;\n-  int _total_oops_removed;\n+  static bool _dead_entries;\n+  static int _total_oops_removed;\n@@ -90,2 +41,2 @@\n-  ProtectionDomainCacheTable(int table_size);\n-  ProtectionDomainCacheEntry* get(Handle protection_domain);\n+  static unsigned int compute_hash(const WeakHandle& protection_domain);\n+  static bool equals(const WeakHandle& protection_domain1, const WeakHandle& protection_domain2);\n@@ -93,1 +44,2 @@\n-  void unlink();\n+  static WeakHandle add_if_absent(Handle protection_domain);\n+  static void unlink();\n@@ -95,2 +47,2 @@\n-  void print_on(outputStream* st) const;\n-  void verify();\n+  static void print_on(outputStream* st);\n+  static void verify();\n@@ -98,2 +50,2 @@\n-  bool has_work() { return _dead_entries; }\n-  void trigger_cleanup();\n+  static bool has_work() { return _dead_entries; }\n+  static void trigger_cleanup();\n@@ -101,1 +53,3 @@\n-  int removed_entries_count() { return _total_oops_removed; };\n+  static int removed_entries_count() { return _total_oops_removed; };\n+  static int number_of_entries();\n+  static void print_table_statistics(outputStream* st);\n@@ -107,1 +61,1 @@\n-  ProtectionDomainCacheEntry* _pd_cache;\n+  WeakHandle _object;\n@@ -111,2 +65,2 @@\n-  ProtectionDomainEntry(ProtectionDomainCacheEntry* pd_cache,\n-                        ProtectionDomainEntry* head) : _pd_cache(pd_cache), _next(head) {}\n+  ProtectionDomainEntry(WeakHandle obj,\n+                        ProtectionDomainEntry* head) : _object(obj), _next(head) {}\n","filename":"src\/hotspot\/share\/classfile\/protectionDomainCache.hpp","additions":19,"deletions":65,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -119,1 +119,0 @@\n-ProtectionDomainCacheTable*   SystemDictionary::_pd_cache_table = NULL;\n@@ -124,6 +123,0 @@\n-\/\/ Default ProtectionDomainCacheSize value\n-const int defaultProtectionDomainCacheSize = 1009;\n-\n-const int _resolution_error_size  = 107;                     \/\/ number of entries in resolution error table\n-const int _invoke_method_size     = 139;                     \/\/ number of entries in invoke method table\n-\n@@ -1668,1 +1661,1 @@\n-      _pd_cache_table->trigger_cleanup();\n+      ProtectionDomainCacheTable::trigger_cleanup();\n@@ -1670,1 +1663,1 @@\n-      assert(_pd_cache_table->number_of_entries() == 0, \"should be empty\");\n+      assert(ProtectionDomainCacheTable::number_of_entries() == 0, \"should be empty\");\n@@ -1703,3 +1696,0 @@\n-  \/\/ Allocate arrays\n-  _pd_cache_table = new ProtectionDomainCacheTable(defaultProtectionDomainCacheSize);\n-\n@@ -2471,1 +2461,1 @@\n-  _pd_cache_table->print_on(st);\n+  ProtectionDomainCacheTable::print_on(st);\n@@ -2487,1 +2477,2 @@\n-  _pd_cache_table->verify();\n+  \/\/ Verify protection domain table\n+  ProtectionDomainCacheTable::verify();\n@@ -2498,1 +2489,1 @@\n-    pd_cache_table()->print_table_statistics(st, \"ProtectionDomainCache Table\");\n+    ProtectionDomainCacheTable::print_table_statistics(st);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":6,"deletions":15,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -73,2 +73,0 @@\n-template <MEMFLAGS F> class HashtableBucket;\n-class SymbolPropertyTable;\n@@ -76,2 +74,0 @@\n-class ProtectionDomainCacheTable;\n-class ProtectionDomainCacheEntry;\n@@ -193,3 +189,0 @@\n-  \/\/ Protection Domain Table\n-  static ProtectionDomainCacheTable* pd_cache_table() { return _pd_cache_table; }\n-\n@@ -298,9 +291,0 @@\n- private:\n-  \/\/ Static tables owned by the SystemDictionary\n-\n-  \/\/ Invoke methods (JSR 292)\n-  static SymbolPropertyTable*    _invoke_method_table;\n-\n-  \/\/ ProtectionDomain cache\n-  static ProtectionDomainCacheTable*   _pd_cache_table;\n-\n@@ -317,2 +301,0 @@\n-  static SymbolPropertyTable* invoke_method_table() { return _invoke_method_table; }\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2390,1 +2390,1 @@\n-  return (jint) SystemDictionary::pd_cache_table()->removed_entries_count();\n+  return (jint) ProtectionDomainCacheTable::removed_entries_count();\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -153,1 +153,1 @@\n-              (protection_domain_table_work = SystemDictionary::pd_cache_table()->has_work()) |\n+              (protection_domain_table_work = ProtectionDomainCacheTable::has_work()) |\n@@ -210,1 +210,1 @@\n-      SystemDictionary::pd_cache_table()->unlink();\n+      ProtectionDomainCacheTable::unlink();\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,4 +28,0 @@\n-#include \"classfile\/moduleEntry.hpp\"\n-#include \"classfile\/packageEntry.hpp\"\n-#include \"classfile\/placeholders.hpp\"\n-#include \"classfile\/protectionDomainCache.hpp\"\n@@ -258,1 +254,0 @@\n-template class BasicHashtable<mtClass>;\n@@ -262,2 +257,0 @@\n-template class Hashtable<InstanceKlass*, mtClass>;\n-template class Hashtable<WeakHandle, mtClass>;\n@@ -265,2 +258,0 @@\n-\n-template void BasicHashtable<mtClass>::verify_table<ProtectionDomainCacheEntry>(char const*);\n","filename":"src\/hotspot\/share\/utilities\/hashtable.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -61,0 +61,18 @@\n+    \/\/ LoaderConstraintTable statistics:\n+    \/\/ Number of buckets       :       107 =       856 bytes, each 8\n+    \/\/ Number of entries       :        31 =      1736 bytes, each 56\n+    \/\/ Number of literals      :        31 =      1120 bytes, avg  36.000\n+    \/\/ Total footprint         :           =      3712 bytes\n+    \/\/ Average bucket size     :     0.290\n+    \/\/ Variance of bucket size :     0.281\n+    \/\/ Std. dev. of bucket size:     0.530\n+    \/\/ Maximum bucket size     :         2\n+    \/\/ ProtectionDomainCacheTable statistics:\n+    \/\/ Number of buckets       :      1009 =      8072 bytes, each 8\n+    \/\/ Number of entries       :         0 =         0 bytes, each 0\n+    \/\/ Total footprint         :           =      8072 bytes\n+    \/\/ Average bucket size     :     0.000\n+    \/\/ Variance of bucket size :     0.000\n+    \/\/ Std. dev. of bucket size:     0.000\n+    \/\/ Maximum bucket size     :         0\n+\n@@ -83,0 +101,5 @@\n+        output.shouldMatch(\"LoaderConstraintTable statistics:\");\n+        \/\/ Would be nice to run this with \"-Djava.security.manager=allow\"\n+        \/\/ so the numbers aren't 0 (running make with VM_OPTIONS allowing\n+        \/\/ security manager does get 12 entries in this table.)\n+        output.shouldMatch(\"ProtectionDomainCacheTable statistics:\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/DictionaryStatsTest.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"}]}