{"files":[{"patch":"@@ -111,1 +111,25 @@\n-static int purge_entries_from_table() {\n+void ProtectionDomainCacheTable::unlink() {\n+  \/\/ The dictionary entries _pd_set field should be null also, so nothing to do.\n+  assert(java_lang_System::allow_security_manager(), \"should not be called otherwise\");\n+\n+  \/\/ Create a list for holding deleted entries\n+  if (_delete_list == NULL) {\n+    _delete_list = new (ResourceObj::C_HEAP, mtClass)\n+                       GrowableArray<ProtectionDomainEntry*>(20, mtClass);\n+  }\n+\n+  {\n+    \/\/ First clean cached pd lists in loaded CLDs\n+    \/\/ It's unlikely, but some loaded classes in a dictionary might\n+    \/\/ point to a protection_domain that has been unloaded.\n+    \/\/ The dictionary pd_set points at entries in the ProtectionDomainCacheTable.\n+    MutexLocker ml(ClassLoaderDataGraph_lock);\n+    MutexLocker mldict(SystemDictionary_lock);  \/\/ need both.\n+    CleanProtectionDomainEntries clean(_delete_list);\n+    ClassLoaderDataGraph::loaded_cld_do(&clean);\n+  }\n+\n+  \/\/ Purge any deleted entries outside of the SystemDictionary_lock.\n+  purge_deleted_entries();\n+\n+  \/\/ Reacquire the lock to remove entries from the hashtable.\n@@ -137,28 +161,0 @@\n-  return deleter._oops_removed;\n-}\n-\n-\n-void ProtectionDomainCacheTable::unlink() {\n-  \/\/ The dictionary entries _pd_set field should be null also, so nothing to do.\n-  assert(java_lang_System::allow_security_manager(), \"should not be called otherwise\");\n-\n-  \/\/ Create a list for holding deleted entries\n-  if (_delete_list == NULL) {\n-    _delete_list = new (ResourceObj::C_HEAP, mtClass)\n-                       GrowableArray<ProtectionDomainEntry*>(20, mtClass);\n-  }\n-\n-  {\n-    \/\/ First clean cached pd lists in loaded CLDs\n-    \/\/ It's unlikely, but some loaded classes in a dictionary might\n-    \/\/ point to a protection_domain that has been unloaded.\n-    \/\/ The dictionary pd_set points at entries in the ProtectionDomainCacheTable.\n-    MutexLocker ml(ClassLoaderDataGraph_lock);\n-    MutexLocker mldict(SystemDictionary_lock);  \/\/ need both.\n-    CleanProtectionDomainEntries clean(_delete_list);\n-    ClassLoaderDataGraph::loaded_cld_do(&clean);\n-  }\n-\n-  \/\/ Purge any deleted entries outside of the SystemDictionary_lock.\n-  purge_deleted_entries();\n-  int oops_removed = purge_entries_from_table(); \/\/ reacquires SD lock\n@@ -166,1 +162,1 @@\n-  _total_oops_removed += oops_removed;\n+  _total_oops_removed += deleter._oops_removed;\n","filename":"src\/hotspot\/share\/classfile\/protectionDomainCache.cpp","additions":26,"deletions":30,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -32,1 +32,2 @@\n-\/\/ The ProtectionDomainCacheTable contains all protection domain oops as WeakHandles.\n+\/\/ The ProtectionDomainCacheTable maps all java.security.ProtectionDomain objects that are\n+\/\/ registered by DictionaryEntry::add_protection_domain() to a unique WeakHandle.\n","filename":"src\/hotspot\/share\/classfile\/protectionDomainCache.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}