{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess.Scope;\n@@ -267,0 +268,11 @@\n+        Scope scope = scope();\n+        if (scope != null) {\n+            if (scope.ownerThread() == null) {\n+                throw new UnsupportedOperationException(\"ByteBuffer derived from shared segments not supported\");\n+            }\n+            try {\n+                scope.checkValidState();\n+            } catch (Scope.ScopedAccessError e) {\n+                throw new IllegalStateException(\"This segment is already closed\");\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -102,0 +102,2 @@\n+        Thread ownerThread();\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -554,0 +554,5 @@\n+     * The returned buffer's position (see {@link ByteBuffer#position()} is initially set to zero, while\n+     * the returned buffer's capacity and limit (see {@link ByteBuffer#capacity()} and {@link ByteBuffer#limit()}, respectively)\n+     * are set to this segment' size (see {@link MemorySegment#byteSize()}). For this reason, a byte buffer cannot be\n+     * returned if this segment' size is greater than {@link Integer#MAX_VALUE}.\n+     * <p>\n@@ -558,1 +563,6 @@\n-     * The resulting buffer's byte order is {@link java.nio.ByteOrder#BIG_ENDIAN}; this can be changed using\n+     * If this segment is <em>shared<\/em>, calling certain I\/O operations on the resulting buffer might result in\n+     * an unspecified exception being thrown. Examples of such problematic operations are {@link FileChannel#read(ByteBuffer)},\n+     * {@link FileChannel#write(ByteBuffer)}, {@link java.nio.channels.SocketChannel#read(ByteBuffer)} and\n+     * {@link java.nio.channels.SocketChannel#write(ByteBuffer)}.\n+     * <p>\n+     * Finally, the resulting buffer's byte order is {@link java.nio.ByteOrder#BIG_ENDIAN}; this can be changed using\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-    abstract Thread ownerThread();\n+    public abstract Thread ownerThread();\n@@ -224,1 +224,1 @@\n-        Thread ownerThread() {\n+        public Thread ownerThread() {\n@@ -264,1 +264,1 @@\n-        Thread ownerThread() {\n+        public Thread ownerThread() {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryScope.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -532,0 +532,10 @@\n+    @Test(dataProvider=\"bufferSources\")\n+    public void bufferProperties(ByteBuffer bb, Predicate<MemorySegment> _unused) {\n+        try (MemorySegment segment = MemorySegment.ofByteBuffer(bb)) {\n+            ByteBuffer buffer = segment.asByteBuffer();\n+            assertEquals(buffer.position(), 0);\n+            assertEquals(buffer.capacity(), segment.byteSize());\n+            assertEquals(buffer.limit(), segment.byteSize());\n+        }\n+    }\n+\n@@ -551,0 +561,43 @@\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    public void testIOOnSharedSegmentBuffer() throws IOException {\n+        File tmp = File.createTempFile(\"tmp\", \"txt\");\n+        tmp.deleteOnExit();\n+        try (FileChannel channel = FileChannel.open(tmp.toPath(), StandardOpenOption.WRITE)) {\n+            MemorySegment segment = MemorySegment.allocateNative(10).share();\n+            for (int i = 0; i < 10; i++) {\n+                MemoryAccess.setByteAtIndex(segment, i, (byte) i);\n+            }\n+            ByteBuffer bb = segment.asByteBuffer();\n+            segment.close();\n+            channel.write(bb);\n+        }\n+    }\n+\n+    @Test(expectedExceptions = IllegalStateException.class)\n+    public void testIOOnClosedConfinedSegmentBuffer() throws IOException {\n+        File tmp = File.createTempFile(\"tmp\", \"txt\");\n+        tmp.deleteOnExit();\n+        try (FileChannel channel = FileChannel.open(tmp.toPath(), StandardOpenOption.WRITE)) {\n+            MemorySegment segment = MemorySegment.allocateNative(10);\n+            for (int i = 0; i < 10; i++) {\n+                MemoryAccess.setByteAtIndex(segment, i, (byte) i);\n+            }\n+            ByteBuffer bb = segment.asByteBuffer();\n+            segment.close();\n+            channel.write(bb);\n+        }\n+    }\n+\n+    public void testIOOnClosedConfinedSegment() throws IOException {\n+        File tmp = File.createTempFile(\"tmp\", \"txt\");\n+        tmp.deleteOnExit();\n+        try (FileChannel channel = FileChannel.open(tmp.toPath(), StandardOpenOption.WRITE)) {\n+            MemorySegment segment = MemorySegment.allocateNative(10);\n+            for (int i = 0; i < 10; i++) {\n+                MemoryAccess.setByteAtIndex(segment, i, (byte) i);\n+            }\n+            ByteBuffer bb = segment.asByteBuffer();\n+            channel.write(bb);\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"}]}