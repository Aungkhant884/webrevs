{"files":[{"patch":"@@ -484,5 +484,3 @@\n-                    SCOPED_MEMORY_ACCESS.copyMemory(scope(), null, src,\n-                                      srcOffset,\n-                                      null,\n-                                      ix(index),\n-                                      (long)length << $LG_BYTES_PER_VALUE$);\n+                    SCOPED_MEMORY_ACCESS.copyMemory(\n+                            scope(), null, src,\n+                            srcOffset, null, ix(index), (long)length << $LG_BYTES_PER_VALUE$);\n@@ -508,1 +506,2 @@\n-            SCOPED_MEMORY_ACCESS.copyMemory(scope(), null, null, ix(pos), null, ix(0), (long)rem << $LG_BYTES_PER_VALUE$);\n+            SCOPED_MEMORY_ACCESS.copyMemory(scope(), null, null,\n+                    ix(pos), null, ix(0), (long)rem << $LG_BYTES_PER_VALUE$);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -978,5 +978,3 @@\n-                    SCOPED_MEMORY_ACCESS.copyMemory(scope(), src.scope(), srcBase,\n-                                      srcAddr,\n-                                      base,\n-                                      addr,\n-                                      len);\n+                    SCOPED_MEMORY_ACCESS.copyMemory(\n+                            scope(), src.scope(), srcBase,\n+                            srcAddr, base, addr, len);\n@@ -990,6 +988,3 @@\n-                    SCOPED_MEMORY_ACCESS.copySwapMemory(scope(), src.scope(), srcBase,\n-                                          srcAddr,\n-                                          base,\n-                                          addr,\n-                                          len,\n-                                          (long)1 << $LG_BYTES_PER_VALUE$);\n+                    SCOPED_MEMORY_ACCESS.copySwapMemory(\n+                            scope(), src.scope(), srcBase,\n+                            srcAddr, base, addr, len, (long)1 << $LG_BYTES_PER_VALUE$);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-     * {@code segment.fileDescriptor().isEmpty()}.\n+     * {@code segment.isMapped() == false}.\n@@ -95,1 +95,1 @@\n-     * {@code segment.fileDescriptor().isEmpty()}.\n+     * {@code segment.isMapped() == false}.\n@@ -114,1 +114,1 @@\n-     * {@code segment.fileDescriptor().isEmpty()}.\n+     * {@code segment.isMapped() == false}.\n@@ -122,1 +122,1 @@\n-     * storage device described by the segment's file descriptor (see {@link MemorySegment#fileDescriptor()}).\n+     * storage device described by the mapped segment's file descriptor.\n@@ -146,1 +146,1 @@\n-     * {@code segment.fileDescriptor().isEmpty()}.\n+     * {@code segment.isMapped() == false}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MappedMemorySegments.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -89,6 +89,1 @@\n-     * Reads a byte from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    getByteAtOffset(segment, offset, ByteOrder.nativeOrder());\n-     * }<\/pre><\/blockquote>\n+     * Reads a byte from given segment and offset.\n@@ -105,6 +100,2 @@\n-     * Writes a byte at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setByteAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-     * }<\/pre><\/blockquote>\n+     * Writes a byte at given segment and offset.\n+     *\n@@ -1007,1 +998,1 @@\n-     * Reads a byte from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Reads a byte from given segment and element index.\n@@ -1023,1 +1014,1 @@\n-     * Writes a byte at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Writes a byte at given segment and element index.\n@@ -1247,33 +1238,0 @@\n-    \/**\n-     * Reads a byte from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    byte value = getByteAtOffset(segment, index, order);\n-     * }<\/pre><\/blockquote>\n-     *\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index)}.\n-     * @param order the specified byte order.\n-     * @return a byte value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    public static byte getByteAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getByteAtOffset(segment, index, order);\n-    }\n-\n-    \/**\n-     * Writes a byte at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setByteAtOffset(segment, index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index)}.\n-     * @param order the specified byte order.\n-     * @param value the byte value to be written.\n-     *\/\n-    public static void setByteAtIndex(MemorySegment segment, long index, ByteOrder order, byte value) {\n-        setByteAtOffset(segment, index, order, value);\n-    }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAccess.java","additions":5,"deletions":47,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -79,3 +79,2 @@\n- * {@link MemorySegment#mapFromPath(Path, long, long, FileChannel.MapMode)}. Such memory segments are called <em>mapped memory segments<\/em>;\n- * mapped memory segments are associated with a {@link FileDescriptor} instance which can be obtained calling the\n- * {@link #fileDescriptor()} method. For more operations on mapped memory segments, please refer to the\n+ * {@link MemorySegment#mapFile(Path, long, long, FileChannel.MapMode)}. Such memory segments are called <em>mapped memory segments<\/em>;\n+ * mapped memory segments are associated with an underlying file descriptor. For more operations on mapped memory segments, please refer to the\n@@ -380,2 +379,2 @@\n-     * Obtain the file descriptor with this memory segment, assuming this segment is a mapped memory segment,\n-     * created using the {@link #mapFromPath(Path, long, long, FileChannel.MapMode)} factory, or a buffer segment\n+     * Is this a mapped segment? Returns true if this segment is a mapped memory segment,\n+     * created using the {@link #mapFile(Path, long, long, FileChannel.MapMode)} factory, or a buffer segment\n@@ -383,1 +382,1 @@\n-     * @return the file descriptor associated with this memory segment (if any).\n+     * @return {@code true} if this segment is a mapped segment.\n@@ -385,1 +384,1 @@\n-    Optional<FileDescriptor> fileDescriptor();\n+    boolean isMapped();\n@@ -395,2 +394,4 @@\n-     * Closes this memory segment. This is a <em>terminal operation<\/em>; as a side-effect, this segment will be marked\n-     * as <em>not alive<\/em>, and subsequent operations on this segment will fail with {@link IllegalStateException}.\n+     * Closes this memory segment. This is a <em>terminal operation<\/em>; as a side-effect, if this operation completes\n+     * without exceptions, this segment will be marked as <em>not alive<\/em>, and subsequent operations on this segment\n+     * will fail with {@link IllegalStateException}.\n+     * <p>\n@@ -399,0 +400,8 @@\n+     *\n+     * @apiNote This operation is not idempotent; that is, closing an already closed segment <em>always<\/em> results in an\n+     * exception being thrown. This reflects a deliberate design choice: segment state transitions should be\n+     * manifest in the client code; a failure in any of these transitions reveals a bug in the underlying application\n+     * logic. This is especially useful when reasoning about the lifecycle of dependent segment views (see {@link #asSlice(MemoryAddress)},\n+     * where closing one segment might side-effect multiple segments. In such cases it might in fact not be obvious, looking\n+     * at the code, as to whether a given segment is alive or not.\n+     *\n@@ -411,2 +420,3 @@\n-     * This is a <em>terminal operation<\/em>; as a side-effect, this segment will be\n-     * marked as <em>not alive<\/em>, and subsequent operations on this segment will fail with {@link IllegalStateException}.\n+     * This is a <em>terminal operation<\/em>; as a side-effect, if this operation completes\n+     * without exceptions, this segment will be marked as <em>not alive<\/em>, and subsequent operations on this segment\n+     * will fail with {@link IllegalStateException}.\n@@ -434,2 +444,3 @@\n-     * This is a <em>terminal operation<\/em>; as a side-effect, this segment will be\n-     * marked as <em>not alive<\/em>, and subsequent operations on this segment will fail with {@link IllegalStateException}.\n+     * This is a <em>terminal operation<\/em>; as a side-effect, if this operation completes\n+     * without exceptions, this segment will be marked as <em>not alive<\/em>, and subsequent operations on this segment\n+     * will fail with {@link IllegalStateException}.\n@@ -444,1 +455,0 @@\n-     * @throws NullPointerException if {@code thread == null}\n@@ -455,2 +465,3 @@\n-     * This is a <em>terminal operation<\/em>; as a side-effect, this segment will be\n-     * marked as <em>not alive<\/em>, and subsequent operations on this segment will fail with {@link IllegalStateException}.\n+     * This is a <em>terminal operation<\/em>; as a side-effect, if this operation completes\n+     * without exceptions, this segment will be marked as <em>not alive<\/em>, and subsequent operations on this segment\n+     * will fail with {@link IllegalStateException}.\n@@ -467,1 +478,0 @@\n-     * @throws NullPointerException if {@code thread == null}\n@@ -509,1 +519,1 @@\n-     * For example, this may occur if the same file is {@link MemorySegment#mapFromPath mapped} to two segments.\n+     * For example, this may occur if the same file is {@link MemorySegment#mapFile mapped} to two segments.\n@@ -851,1 +861,1 @@\n-    static MemorySegment mapFromPath(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {\n+    static MemorySegment mapFile(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":29,"deletions":19,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -316,2 +316,2 @@\n-    public Optional<FileDescriptor> fileDescriptor() {\n-        return Optional.empty();\n+    public boolean isMapped() {\n+        return false;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,2 +83,2 @@\n-    public Optional<FileDescriptor> fileDescriptor() {\n-        return Optional.of(unmapper.fileDescriptor());\n+    public boolean isMapped() {\n+        return true;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-        try (MemorySegment segment = MemorySegment.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_WRITE)) {\n+        try (MemorySegment segment = MemorySegment.mapFile(tempPath, 0L, 8, FileChannel.MapMode.READ_WRITE)) {\n@@ -236,1 +236,1 @@\n-        try (MemorySegment segment = MemorySegment.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_ONLY)) {\n+        try (MemorySegment segment = MemorySegment.mapFile(tempPath, 0L, 8, FileChannel.MapMode.READ_ONLY)) {\n@@ -249,1 +249,1 @@\n-        try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {\n+        try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {\n@@ -255,1 +255,1 @@\n-        try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {\n+        try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {\n@@ -266,2 +266,2 @@\n-        MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, 8, FileChannel.MapMode.READ_WRITE);\n-        assertTrue(segment.fileDescriptor().isPresent());\n+        MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 8, FileChannel.MapMode.READ_WRITE);\n+        assertTrue(segment.isMapped());\n@@ -283,1 +283,1 @@\n-            try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {\n+            try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {\n@@ -292,1 +292,1 @@\n-            try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {\n+            try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {\n@@ -456,1 +456,1 @@\n-        MemorySegment.mapFromPath(f.toPath(), 0L, -1, FileChannel.MapMode.READ_WRITE);\n+        MemorySegment.mapFile(f.toPath(), 0L, -1, FileChannel.MapMode.READ_WRITE);\n@@ -464,1 +464,1 @@\n-        MemorySegment.mapFromPath(f.toPath(), -1, 1, FileChannel.MapMode.READ_WRITE);\n+        MemorySegment.mapFile(f.toPath(), -1, 1, FileChannel.MapMode.READ_WRITE);\n@@ -471,1 +471,1 @@\n-        try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, 0L, FileChannel.MapMode.READ_WRITE)) {\n+        try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 0L, FileChannel.MapMode.READ_WRITE)) {\n@@ -662,1 +662,1 @@\n-                (base) -> initBytes(base, bytes, (addr, pos) -> MemoryAccess.setByteAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (byte)(long)pos));\n+                (base) -> initBytes(base, bytes, (addr, pos) -> MemoryAccess.setByteAtIndex(addr, pos, (byte)(long)pos));\n@@ -677,1 +677,1 @@\n-                (base) -> checkBytes(base, bytes, Function.identity(), (addr, pos) -> MemoryAccess.getByteAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), ByteBuffer::get);\n+                (base) -> checkBytes(base, bytes, Function.identity(), (addr, pos) -> MemoryAccess.getByteAtIndex(addr, pos), ByteBuffer::get);\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -99,1 +98,1 @@\n-        segment = MemorySegment.mapFromPath(tempPath, 0L, ALLOC_SIZE, FileChannel.MapMode.READ_WRITE);\n+        segment = MemorySegment.mapFile(tempPath, 0L, ALLOC_SIZE, FileChannel.MapMode.READ_WRITE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantMapped.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}