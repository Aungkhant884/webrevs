{"files":[{"patch":"@@ -34,1 +34,3 @@\n- * using the combinator methods defined in the {@link jdk.incubator.foreign.MemoryHandles} class. Finally, the {@link jdk.incubator.foreign.MemoryLayout} class\n+ * using the combinator methods defined in the {@link jdk.incubator.foreign.MemoryHandles} class; a set of\n+ * common dereference operations is provided also by the {@link jdk.incubator.foreign.MemoryAccess} class, which can\n+ * be useful for simple, non-structured access. Finally, the {@link jdk.incubator.foreign.MemoryLayout} class\n@@ -43,2 +45,0 @@\n-static final VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());\n-\n@@ -46,2 +46,2 @@\n-    for (long i = 0 ; i < 10 ; i++) {\n-       intHandle.set(base.asSlice(i * 4), (int)i);\n+    for (int i = 0 ; i < 10 ; i++) {\n+       MemoryAccess.setIntAtIndex(segment, i);\n@@ -52,4 +52,1 @@\n- * Here we create a var handle, namely {@code intHandle}, to manipulate values of the primitive type {@code int}, at\n- * a given memory location. Also, {@code intHandle} is stored in a {@code static} and {@code final} field, to achieve\n- * better performance and allow for inlining of the memory access operation through the {@link java.lang.invoke.VarHandle}\n- * instance. We then create a <em>native<\/em> memory segment, that is, a memory segment backed by\n+ * Here create a <em>native<\/em> memory segment, that is, a memory segment backed by\n@@ -60,1 +57,3 @@\n- * the contents of the memory segment; more specifically, if we view the memory segment as a set of 10 adjacent slots,\n+ * the contents of the memory segment using the\n+ * {@link jdk.incubator.foreign.MemoryAccess#setIntAtIndex(jdk.incubator.foreign.MemorySegment, long, int)} helper method;\n+ * more specifically, if we view the memory segment as a set of 10 adjacent slots,\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"}]}