{"files":[{"patch":"@@ -32,2 +32,2 @@\n-SCOPED_MEMORY_ACCESS_TEMPLATE := $(TOPDIR)\/src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template\n-SCOPED_MEMORY_ACCESS_BIN_TEMPLATE := $(TOPDIR)\/src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess-bin.java.template\n+SCOPED_MEMORY_ACCESS_TEMPLATE := $(SCOPED_MEMORY_ACCESS_SRC_DIR)\/X-ScopedMemoryAccess.java.template\n+SCOPED_MEMORY_ACCESS_BIN_TEMPLATE := $(SCOPED_MEMORY_ACCESS_SRC_DIR)\/X-ScopedMemoryAccess-bin.java.template\n@@ -145,1 +145,1 @@\n-  $(eval $(call GenerateScopedOp,BIN_$t,$t)))\n+\t  $(eval $(call GenerateScopedOp,BIN_$t,$t)))\n@@ -155,1 +155,1 @@\n-TARGETS += $(DEST)\n\\ No newline at end of file\n+TARGETS += $(DEST)\n","filename":"make\/modules\/java.base\/gensrc\/GensrcScopedMemoryAccess.gmk","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,23 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n@@ -81,9 +104,7 @@\n-      \/\/FIXME: this doesn't work if reachability fences are violated by C2\n-      \/\/ last_frame.oops_do(&cl, NULL, &register_map);\n-\n-      \/\/ if (cl.found()) {\n-      \/\/   \/\/ Found the deopt oop in a compiled method; deoptimize.\n-      \/\/   Deoptimization::deoptimize(jt, last_frame);\n-      \/\/ }\n-\n-      \/\/ so... we unconditionally deoptimize, for now\n+      \/* FIXME: this doesn't work if reachability fences are violated by C2\n+      last_frame.oops_do(&cl, NULL, &register_map);\n+      if (cl.found()) {\n+           \/\/Found the deopt oop in a compiled method; deoptimize.\n+           Deoptimization::deoptimize(jt, last_frame);\n+      }\n+      so... we unconditionally deoptimize, for now: *\/\n@@ -95,2 +116,1 @@\n-    vframeStream stream(jt);\n-    for (; !stream.at_end(); stream.next()) {\n+    for (vframeStream stream(jt); !stream.at_end(); stream.next()) {\n@@ -130,1 +150,1 @@\n-JVM_ENTRY(jboolean, ScopedMemoryAccess_closeScope(JNIEnv *env, jobject receiver, jobject deopt, jobject exception)) {\n+JVM_ENTRY(jboolean, ScopedMemoryAccess_closeScope(JNIEnv *env, jobject receiver, jobject deopt, jobject exception))\n@@ -134,1 +154,1 @@\n-} JVM_END\n+JVM_END\n@@ -138,1 +158,1 @@\n-#define LANG \"Ljdk\/internal\/misc\/\"\n+#define PKG \"Ljdk\/internal\/misc\/\"\n@@ -141,2 +161,2 @@\n-#define SCOPE LANG MEMACCESS \"$Scope;\"\n-#define SCOPED_ERR LANG MEMACCESS \"$Scope$ScopedAccessError;\"\n+#define SCOPE PKG MEMACCESS \"$Scope;\"\n+#define SCOPED_ERR PKG MEMACCESS \"$Scope$ScopedAccessError;\"\n@@ -154,1 +174,1 @@\n-#undef LANG\n+#undef PKG\n@@ -161,1 +181,1 @@\n-JVM_ENTRY(void, JVM_RegisterJDKInternalMiscScopedMemoryAccessMethods(JNIEnv *env, jclass scopedMemoryAccessClass)) {\n+JVM_ENTRY(void, JVM_RegisterJDKInternalMiscScopedMemoryAccessMethods(JNIEnv *env, jclass scopedMemoryAccessClass))\n@@ -166,1 +186,1 @@\n-} JVM_END\n+JVM_END\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp","additions":39,"deletions":19,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    MemoryAccessVarHandleBase(VarForm form, boolean skipOffetCheck, boolean be, long length, long alignmentMask) {\n+    MemoryAccessVarHandleBase(VarForm form, boolean skipAlignmentMaskCheck, boolean be, long length, long alignmentMask) {\n@@ -47,1 +47,1 @@\n-        this.skipAlignmentMaskCheck = skipOffetCheck;\n+        this.skipAlignmentMaskCheck = skipAlignmentMaskCheck;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemoryAccessVarHandleBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @run testng\/othervm -XX:MaxDirectMemorySize=5000000000 TestMismatch\n+ * @run testng TestMismatch\n@@ -113,5 +113,7 @@\n-        try (var s1 = MemorySegment.allocateNative((long)Integer.MAX_VALUE + 10L);\n-             var s2 = MemorySegment.allocateNative((long)Integer.MAX_VALUE + 10L)) {\n-            assertEquals(s1.mismatch(s1), -1);\n-            assertEquals(s1.mismatch(s2), -1);\n-            assertEquals(s2.mismatch(s1), -1);\n+        \/\/ skip if not on 64 bits\n+        if (MemoryLayouts.ADDRESS.byteSize() > 32) {\n+            try (var s1 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L);\n+                 var s2 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L)) {\n+                assertEquals(s1.mismatch(s1), -1);\n+                assertEquals(s1.mismatch(s2), -1);\n+                assertEquals(s2.mismatch(s1), -1);\n@@ -119,1 +121,1 @@\n-            testLargeAcrossMaxBoundary(s1, s2);\n+                testLargeAcrossMaxBoundary(s1, s2);\n@@ -121,1 +123,2 @@\n-            testLargeMismatchAcrossMaxBoundary(s1, s2);\n+                testLargeMismatchAcrossMaxBoundary(s1, s2);\n+            }\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @run testng TestSegments\n+ * @run testng\/othervm -XX:MaxDirectMemorySize=1M TestSegments\n@@ -103,0 +103,7 @@\n+    @Test(expectedExceptions = OutOfMemoryError.class)\n+    public void testNativeAllocationTooBig() {\n+        try (MemorySegment segment = MemorySegment.allocateNative(1024 * 1024 * 8 * 2)) { \/\/ 2M\n+            \/\/ do nothing\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}