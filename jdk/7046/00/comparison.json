{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,13 +168,1 @@\n-        Set<String> alreadyDocumented = new HashSet<>();\n-        if (!paramTags.isEmpty()) {\n-            result.add(\n-                processParamTags(holder, kind, paramTags,\n-                getRankMap(writer.configuration().utils, formalParameters), writer, alreadyDocumented)\n-            );\n-        }\n-        if (alreadyDocumented.size() != formalParameters.size()) {\n-            \/\/Some parameters are missing corresponding @param tags.\n-            \/\/Try to inherit them.\n-            result.add(getInheritedTagletOutput(kind, holder,\n-                writer, formalParameters, alreadyDocumented));\n-        }\n+        result.add(processParamTags(holder, kind, paramTags, formalParameters, writer));\n@@ -185,2 +173,1 @@\n-     * Loop through each individual parameter, despite not having a\n-     * corresponding param tag, try to inherit it.\n+     * Try to get the inherited taglet documentation for a specific parameter.\n@@ -189,2 +176,2 @@\n-            TagletWriter writer, List<? extends Element> formalParameters,\n-            Set<String> alreadyDocumented) {\n+                                             TagletWriter writer, Element param, int rank,\n+                                             boolean isFirst) {\n@@ -193,23 +180,11 @@\n-        if ((!alreadyDocumented.contains(null)) && utils.isExecutableElement(holder)) {\n-            for (int i = 0; i < formalParameters.size(); i++) {\n-                if (alreadyDocumented.contains(String.valueOf(i))) {\n-                    continue;\n-                }\n-                \/\/ This parameter does not have any @param documentation.\n-                \/\/ Try to inherit it.\n-                Input input = new DocFinder.Input(writer.configuration().utils, holder, this,\n-                        Integer.toString(i), kind == ParamKind.TYPE_PARAMETER);\n-                DocFinder.Output inheritedDoc = DocFinder.search(writer.configuration(), input);\n-                if (inheritedDoc.inlineTags != null && !inheritedDoc.inlineTags.isEmpty()) {\n-                    Element e = formalParameters.get(i);\n-                    String lname = kind != ParamKind.TYPE_PARAMETER\n-                            ? utils.getSimpleName(e)\n-                            : utils.getTypeName(e.asType(), false);\n-                    Content content = processParamTag(inheritedDoc.holder, kind, writer,\n-                            (ParamTree) inheritedDoc.holderTag,\n-                            lname,\n-                            alreadyDocumented.isEmpty());\n-                    result.add(content);\n-                }\n-                alreadyDocumented.add(String.valueOf(i));\n-            }\n+        Input input = new DocFinder.Input(writer.configuration().utils, holder, this,\n+                Integer.toString(rank), kind == ParamKind.TYPE_PARAMETER);\n+        DocFinder.Output inheritedDoc = DocFinder.search(writer.configuration(), input);\n+        if (inheritedDoc.inlineTags != null && !inheritedDoc.inlineTags.isEmpty()) {\n+            String lname = kind != ParamKind.TYPE_PARAMETER\n+                    ? utils.getSimpleName(param)\n+                    : utils.getTypeName(param.asType(), false);\n+            Content content = processParamTag(inheritedDoc.holder, kind, writer,\n+                    (ParamTree) inheritedDoc.holderTag,\n+                    lname, isFirst);\n+            result.add(content);\n@@ -228,8 +203,0 @@\n-     * @param alreadyDocumented the set of exceptions that have already\n-     *        been documented.\n-     * @param rankMap a {@link java.util.Map} which holds ordering\n-     *                    information about the parameters.\n-     * @param rankMap a {@link java.util.Map} which holds a mapping\n-                of a rank of a parameter to its name.  This is\n-                used to ensure that the right name is used\n-                when parameter documentation is inherited.\n@@ -238,3 +205,3 @@\n-    private Content processParamTags(Element e, ParamKind kind,\n-            List<? extends ParamTree> paramTags, Map<String, String> rankMap, TagletWriter writer,\n-            Set<String> alreadyDocumented) {\n+    private Content processParamTags(Element e, ParamKind kind, List<? extends ParamTree> paramTags,\n+                                     List<? extends Element> formalParameters, TagletWriter writer) {\n+        Map<String, ParamTree> documented = new HashMap<>();\n@@ -242,1 +209,1 @@\n-        Content result = writer.getOutputInstance();\n+        CommentHelper ch = writer.configuration().utils.getCommentHelper(e);\n@@ -244,1 +211,1 @@\n-            CommentHelper ch = writer.configuration().utils.getCommentHelper(e);\n+            Map<String,String> rankMap = getRankMap(writer.configuration().utils, formalParameters);\n@@ -253,1 +220,0 @@\n-                        default -> throw new IllegalArgumentException(kind.toString());\n@@ -258,8 +224,11 @@\n-                if (rank != null && alreadyDocumented.contains(rank)) {\n-                    String key = switch (kind) {\n-                        case PARAMETER        -> \"doclet.Parameters_dup_warn\";\n-                        case TYPE_PARAMETER   -> \"doclet.TypeParameters_dup_warn\";\n-                        case RECORD_COMPONENT -> \"doclet.RecordComponents_dup_warn\";\n-                        default -> throw new IllegalArgumentException(kind.toString());\n-                    };\n-                    messages.warning(ch.getDocTreePath(dt), key, paramName);\n+                if (rank != null) {\n+                    if (documented.containsKey(rank)) {\n+                        String key = switch (kind) {\n+                            case PARAMETER -> \"doclet.Parameters_dup_warn\";\n+                            case TYPE_PARAMETER -> \"doclet.TypeParameters_dup_warn\";\n+                            case RECORD_COMPONENT -> \"doclet.RecordComponents_dup_warn\";\n+                        };\n+                        messages.warning(ch.getDocTreePath(dt), key, paramName);\n+                    } else {\n+                        documented.put(rank, dt);\n+                    }\n@@ -267,0 +236,8 @@\n+            }\n+        }\n+        \/\/ Document declared parameters for which taglet documentation is available\n+        \/\/ (either directly or inherited) in order of their declaration.\n+        Content result = writer.getOutputInstance();\n+        for (int i = 0; i < formalParameters.size(); i++) {\n+            ParamTree dt = documented.get(String.valueOf(i));\n+            if (dt != null) {\n@@ -268,2 +245,14 @@\n-                        name, alreadyDocumented.isEmpty()));\n-                alreadyDocumented.add(rank);\n+                        ch.getParameterName(dt), result.isEmpty()));\n+            } else if (writer.configuration().utils.isExecutableElement(e)) {\n+                result.add(getInheritedTagletOutput(kind, e, writer,\n+                        formalParameters.get(i), i, result.isEmpty()));\n+            }\n+        }\n+        if (paramTags.size() > documented.size()) {\n+            \/\/ Generate documentation for remaining taglets that do not match a declared parameter.\n+            \/\/ These are erroneous but we generate them anyway.\n+            for (ParamTree dt : paramTags) {\n+                if (!documented.containsValue(dt)) {\n+                    result.add(processParamTag(e, kind, writer, dt,\n+                            ch.getParameterName(dt), result.isEmpty()));\n+                }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ParamTaglet.java","additions":54,"deletions":65,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug      4802275 4967243 8026567 8239804\n+ * @bug      4802275 4967243 8026567 8239804 8234682\n@@ -51,1 +51,4 @@\n-\n+        checkOutput(Output.OUT, true,\n+                \"warning: no @param for param1\",\n+                \"error: @param name not found\",\n+                \"warning: @param \\\"b\\\" has already been specified\");\n@@ -53,1 +56,1 @@\n-                \/\/Regular param tags.\n+                \/\/ Regular param tags.\n@@ -57,2 +60,5 @@\n-                    <dd><code>param2<\/code> - testing 1 2 3.\"\"\",\n-                \/\/Param tags that don't match with any real parameters.\n+                    <dd><code>param2<\/code> - testing 1 2 3.<\/dd>\n+                    <\/dl>\"\"\",\n+                \/\/ Param tags that don't match with any real parameters.\n+                \/\/ {@inherit} doc misuse does not cause doclet to throw exception.\n+                \/\/ Param is printed with nothing inherited.\n@@ -62,6 +68,29 @@\n-                    <dd><code>p2<\/code> - testing 1 2 3.\"\"\",\n-                \/\/{@inherit} doc misuse does not cause doclet to throw exception.\n-                \/\/ Param is printed with nothing inherited.\n-                \/\/XXX: in the future when Configuration is available during doc inheritence,\n-                \/\/print a warning for this mistake.\n-                \"<code>inheritBug<\/code> -\");\n+                    <dd><code>p2<\/code> - testing 1 2 3.<\/dd>\n+                    <dd><code>inheritBug<\/code> - <\/dd>\n+                    <\/dl>\"\"\",\n+                \"\"\"\n+                    <dt>Parameters:<\/dt>\n+                    <dd><code>i<\/code> - an int<\/dd>\n+                    <dd><code>d<\/code> - a double<\/dd>\n+                    <dd><code>b<\/code> - a boolean<\/dd>\n+                    <dd><code>x<\/code> - does not exist<\/dd>\n+                    <dd><code>x<\/code> - duplicate<\/dd>\n+                    <dd><code>b<\/code> - another duplicate<\/dd>\n+                    <\/dl>\"\"\",\n+                \"\"\"\n+                    <dt>Type Parameters:<\/dt>\n+                    <dd><code>T2<\/code> - type 2<\/dd>\n+                    <dt>Parameters:<\/dt>\n+                    <dd><code>t1<\/code> - param 1<\/dd>\n+                    <dd><code>t3<\/code> - param 3<\/dd>\n+                    <\/dl>\"\"\");\n+        checkOutput(\"pkg\/C.Point.html\", true,\n+                \"\"\"\n+                    <dt>Record Components:<\/dt>\n+                    <dd><code><span id=\"param-y\">y<\/span><\/code> - the y coordinate<\/dd>\n+                    <\/dl>\"\"\");\n+        checkOutput(\"pkg\/C.Nested.html\", true,\n+                \"\"\"\n+                    <dt>Type Parameters:<\/dt>\n+                    <dd><code>T1<\/code> - type 1<\/dd>\n+                    <\/dl>\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testParamTaglet\/TestParamTaglet.java","additions":41,"deletions":12,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,35 @@\n+    \/**\n+     * Overriding method with missing\/additional\/duplicate param tags in non-declaration order.\n+     *\n+     * @param x does not exist\n+     * @param b a boolean\n+     * @param i an int\n+     * @param x duplicate\n+     * @param b another duplicate\n+     *\/\n+    public void unorderedParams(int i, double d, boolean b) {}\n+\n+    \/**\n+     * Generic method with mixed\/missing param tags.\n+     *\n+     * @param t1 param 1\n+     * @param <T2> type 2\n+     * @param t3 param 3\n+     *\/\n+    public static <T1, T2, T3> void genericMethod(T1 t1, T2 t2, T3 t3) {\n+    }\n+\n+    \/**\n+     * A partially documented point.\n+     *\n+     * @param y the y coordinate\n+     *\/\n+    public static record Point(int x, int y) {}\n+\n+    \/**\n+     * Generic class with missing param tags.\n+     *\n+     * @param <T1> type 1\n+     *\/\n+    public static class Nested<T1, T2> {}\n+\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testParamTaglet\/pkg\/C.java","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,7 @@\n+\n+    \/**\n+     * Base method with partially documented params.\n+     *\n+     * @param d a double\n+     *\/\n+    public void unorderedParams(int i, double d, boolean b) {}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testParamTaglet\/pkg\/Parent.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}