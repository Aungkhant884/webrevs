{"files":[{"patch":"@@ -1624,10 +1624,0 @@\n-  if (x->in(LoopNode::LoopBackControl)->Opcode() == Op_SafePoint &&\n-          ((iv_bt == T_INT && LoopStripMiningIter != 0) ||\n-           iv_bt == T_LONG)) {\n-    \/\/ Leaving the safepoint on the backedge and creating a\n-    \/\/ CountedLoop will confuse optimizations. We can't move the\n-    \/\/ safepoint around because its jvm state wouldn't match a new\n-    \/\/ location. Give up on that loop.\n-    return false;\n-  }\n-\n@@ -1862,0 +1852,32 @@\n+  Node *sfpt2 = NULL;\n+  if (loop->_child == NULL) {\n+    sfpt2 = find_safepoint(back_control, x, loop);\n+  } else {\n+    sfpt2 = iff->in(0);\n+    if (sfpt2->Opcode() != Op_SafePoint) {\n+      sfpt2 = NULL;\n+    }\n+  }\n+\n+  if (x->in(LoopNode::LoopBackControl)->Opcode() == Op_SafePoint) {\n+    Node *sfpt = x->in(LoopNode::LoopBackControl);\n+    bool deleteable = is_deleteable_safept(sfpt);\n+    if (((iv_bt == T_INT && LoopStripMiningIter != 0) ||\n+         iv_bt == T_LONG) &&\n+        sfpt2 == NULL) {\n+      \/\/ Leaving the safepoint on the backedge and creating a\n+      \/\/ CountedLoop will confuse optimizations. We can't move the\n+      \/\/ safepoint around because its jvm state wouldn't match a new\n+      \/\/ location. Give up on that loop.\n+      return false;\n+    }\n+    if (deleteable) {\n+      lazy_replace(sfpt, iftrue);\n+      if (loop->_safepts != NULL) {\n+        loop->_safepts->yank(sfpt);\n+      }\n+      loop->_tail = iftrue;\n+    }\n+  }\n+\n+\n@@ -1900,12 +1922,0 @@\n-  if (iv_bt == T_INT && LoopStripMiningIter == 0) {\n-    \/\/ Check for SafePoint on backedge and remove\n-    Node *sfpt = x->in(LoopNode::LoopBackControl);\n-    if (sfpt->Opcode() == Op_SafePoint && is_deleteable_safept(sfpt)) {\n-      lazy_replace( sfpt, iftrue );\n-      if (loop->_safepts != NULL) {\n-        loop->_safepts->yank(sfpt);\n-      }\n-      loop->_tail = iftrue;\n-    }\n-  }\n-\n@@ -1983,2 +1993,0 @@\n-  Node *sfpt2 = le->in(0);\n-\n@@ -1989,1 +1997,1 @@\n-                         sfpt2->Opcode() == Op_SafePoint &&\n+                         sfpt2 != NULL &&\n@@ -2015,1 +2023,1 @@\n-    if (sfpt2->Opcode() == Op_SafePoint && (LoopStripMiningIter != 0 || is_deleteable_safept(sfpt2))) {\n+    if (sfpt2 != NULL && (LoopStripMiningIter != 0 || is_deleteable_safept(sfpt2))) {\n@@ -3666,1 +3674,1 @@\n-    if (LoopStripMiningIter == 0 || (LoopStripMiningIter > 1 && _child == NULL)) {\n+    if (LoopStripMiningIter == 0 || _head->as_CountedLoop()->is_strip_mined()) {\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":35,"deletions":27,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8282045\n+ * @summary When loop strip mining fails, safepoints are removed from loop anyway\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestStripMiningDropsSafepoint\n+ *\/\n+\n+public class TestStripMiningDropsSafepoint {\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1000\", \"-XX:LoopMaxUnroll=1\", \"-XX:-RangeCheckElimination\");\n+        TestFramework.runWithFlags(\"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1000\", \"-XX:LoopMaxUnroll=1\", \"-XX:-RangeCheckElimination\", \"-XX:-PartialPeelLoop\");\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"PartialPeelLoop\", \"true\" }, counts = { IRNode.COUNTEDLOOP, \"1\",  IRNode.OUTERSTRIPMINEDLOOP, \"1\", IRNode.SAFEPOINT, \"1\" })\n+    private static void test1(int[] dst, int[] src) {\n+        \/\/ Partial peel is applied. No side effect between exit and\n+        \/\/ safepoint.\n+        for (int i = 0; ; ) {\n+            \/\/ prevent ciTypeFlow from cloning head\n+            synchronized (new Object()) {}\n+            i++;\n+            if (i >= src.length) {\n+                break;\n+            }\n+            dst[i] = src[i];\n+            if (i \/ 2 >= 2000) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test1\")\n+    private static void test1_runner() {\n+        int[] array1 = new int[1000];\n+        int[] array2 = new int[10000];\n+        test1(array1, array1);\n+        test1(array2, array2);\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"PartialPeelLoop\", \"true\" }, counts = { IRNode.COUNTEDLOOP, \"1\", IRNode.SAFEPOINT, \"1\" })\n+    @IR(applyIf = { \"PartialPeelLoop\", \"true\" }, failOn = { IRNode.OUTERSTRIPMINEDLOOP })\n+    private static void test2(int[] dst, int[] src) {\n+        \/\/ Partial peel is applied. Some side effect between exit and\n+        \/\/ safepoint.\n+        int v = src[0];\n+        for (int i = 0; ; ) {\n+            synchronized (new Object()) {}\n+            dst[i] = v;\n+            i++;\n+            if (i >= src.length) {\n+                break;\n+            }\n+            v = src[i];\n+            if (i \/ 2 >= 2000) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test2\")\n+    private static void test2_runner() {\n+        int[] array1 = new int[1000];\n+        int[] array2 = new int[10000];\n+        test2(array1, array1);\n+        test2(array2, array2);\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"PartialPeelLoop\", \"false\" }, counts = { IRNode.COUNTEDLOOP, \"1\",  IRNode.OUTERSTRIPMINEDLOOP, \"1\", IRNode.SAFEPOINT, \"1\" })\n+    private static void test3(int[] dst, int[] src) {\n+        int v = src[0];\n+        for (int i = 0; ; ) {\n+            synchronized (new Object()) {}\n+            dst[i] = v;\n+            int inc = test3_helper(2);\n+            v = src[i];\n+            i += (inc \/ 2);\n+            if (i >= src.length) {\n+                break;\n+            }\n+            for (int j = 0; j < 10; j++) {\n+            }\n+            \/\/ safepoint on backedge\n+        }\n+    }\n+\n+    private static int test3_helper(int stop) {\n+        int i = 1;\n+        do {\n+            synchronized (new Object()) {}\n+            i *= 2;\n+        } while (i < stop);\n+        return i;\n+    }\n+\n+    @Run(test = \"test3\")\n+    private static void test3_runner() {\n+        int[] array1 = new int[1000];\n+        test3(array1, array1);\n+        test3_helper(10);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestStripMiningDropsSafepoint.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -118,0 +118,1 @@\n+    public static final String OUTERSTRIPMINEDLOOP = START + \"OuterStripMinedLoop\\\\b\" + MID + END;\n@@ -138,0 +139,1 @@\n+    public static final String SAFEPOINT = START + \"SafePoint\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}