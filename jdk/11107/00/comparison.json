{"files":[{"patch":"@@ -69,1 +69,0 @@\n-import jdk.test.lib.Platform;\n@@ -110,1 +109,1 @@\n-                \/\/ delayed write to sc1\n+                \/\/ write to sc1 when current thread blocks in sc2.read\n@@ -133,1 +132,1 @@\n-                \/\/ delayed read from sc2 to EOF\n+                \/\/ read from sc2 to EOF when current thread blocks in sc1.write\n@@ -177,1 +176,1 @@\n-                \/\/ delayed interrupt of current thread\n+                \/\/ interrupt current thread when it blocks in read\n@@ -197,9 +196,19 @@\n-            try (var connection = new Connection()) {\n-                SocketChannel sc = connection.channel1();\n-                runAfterParkedAsync(sc::close);\n-                try {\n-                    ByteBuffer bb = ByteBuffer.allocate(100*1024);\n-                    for (;;) {\n-                        int n = sc.write(bb);\n-                        assertTrue(n > 0);\n-                        bb.clear();\n+            boolean retry = true;\n+            while (retry) {\n+                try (var connection = new Connection()) {\n+                    SocketChannel sc = connection.channel1();\n+\n+                    \/\/ close sc when current thread blocks in write\n+                    runAfterParkedAsync(sc::close);\n+                    try {\n+                        ByteBuffer bb = ByteBuffer.allocate(100*1024);\n+                        for (;;) {\n+                            int n = sc.write(bb);\n+                            assertTrue(n > 0);\n+                            bb.clear();\n+                        }\n+                    } catch (AsynchronousCloseException expected) {\n+                        \/\/ closed when blocked in write\n+                        retry = false;\n+                    } catch (ClosedChannelException e) {\n+                        \/\/ closed when not blocked in write, need to retry test\n@@ -207,5 +216,0 @@\n-                } catch (AsynchronousCloseException e) {\n-                    \/\/ expected\n-                } catch (ClosedChannelException e) {\n-                    \/\/ on macOS the write loop may block more than once\n-                    if (!Platform.isOSX()) throw e;\n@@ -223,13 +227,22 @@\n-            try (var connection = new Connection()) {\n-                SocketChannel sc = connection.channel1();\n-\n-                \/\/ delayed interrupt of current thread\n-                Thread thisThread = Thread.currentThread();\n-                runAfterParkedAsync(thisThread::interrupt);\n-\n-                try {\n-                    ByteBuffer bb = ByteBuffer.allocate(100*1024);\n-                    for (;;) {\n-                        int n = sc.write(bb);\n-                        assertTrue(n > 0);\n-                        bb.clear();\n+            boolean retry = true;\n+            while (retry) {\n+                try (var connection = new Connection()) {\n+                    SocketChannel sc = connection.channel1();\n+\n+                    \/\/ interrupt current thread when it blocks in write\n+                    Thread thisThread = Thread.currentThread();\n+                    runAfterParkedAsync(thisThread::interrupt);\n+\n+                    try {\n+                        ByteBuffer bb = ByteBuffer.allocate(100*1024);\n+                        for (;;) {\n+                            int n = sc.write(bb);\n+                            assertTrue(n > 0);\n+                            bb.clear();\n+                        }\n+                    } catch (ClosedByInterruptException e) {\n+                        \/\/ closed when blocked in write\n+                        assertTrue(Thread.interrupted());\n+                        retry = false;\n+                    } catch (ClosedChannelException e) {\n+                        \/\/ closed when not blocked in write, need to retry test\n@@ -237,5 +250,0 @@\n-                } catch (ClosedByInterruptException e) {\n-                    assertTrue(Thread.interrupted());\n-                } catch (ClosedChannelException e) {\n-                    \/\/ on macOS the write loop may block more than once\n-                    if (!Platform.isOSX()) throw e;\n@@ -269,1 +277,1 @@\n-                \/\/ delayed write to sc1\n+                \/\/ write to sc1 when currnet thread blocks reading from sc2\n@@ -311,1 +319,1 @@\n-                \/\/ delayed connect\n+                \/\/ connect when current thread when it blocks in accept\n@@ -351,1 +359,1 @@\n-                \/\/ delayed interrupt of current thread\n+                \/\/ interrupt current thread when it blocks in accept\n@@ -388,1 +396,1 @@\n-                \/\/ delayed connect\n+                \/\/ interrupt current thread when it blocks in accept\n@@ -438,1 +446,1 @@\n-                \/\/ delayed send from sc1\n+                \/\/ send from dc1 when current thread blocked in dc2.receive\n@@ -478,1 +486,1 @@\n-                \/\/ delayed interrupt of current thread\n+                \/\/ interrupt current thread when it blocks in receive\n@@ -516,1 +524,1 @@\n-                \/\/ delayed send from dc2\n+                \/\/ send from dc1 when current thread blocks in dc2 receive\n@@ -559,1 +567,1 @@\n-                \/\/ delayed close of channel\/socket\n+                \/\/ close channel\/socket when current thread blocks in receive\n@@ -595,1 +603,1 @@\n-                \/\/ delayed interrupt of current thread\n+                \/\/ interrupt current thread when it blocks in receive\n@@ -643,1 +651,1 @@\n-                \/\/ delayed write from sink\n+                \/\/ write from sink when current thread blocks reading from source\n@@ -666,1 +674,1 @@\n-                \/\/ delayed read from source to EOF\n+                \/\/ read from source to EOF when current thread blocking in write\n@@ -691,1 +699,2 @@\n-            try (Pipe.SourceChannel source = p.source()) {\n+            try (Pipe.SinkChannel sink = p.sink();\n+                 Pipe.SourceChannel source = p.source()) {\n@@ -708,1 +717,2 @@\n-            try (Pipe.SourceChannel source = p.source()) {\n+            try (Pipe.SinkChannel sink = p.sink();\n+                 Pipe.SourceChannel source = p.source()) {\n@@ -710,1 +720,1 @@\n-                \/\/ delayed interrupt of current thread\n+                \/\/ interrupt current thread when it blocks reading from source\n@@ -730,9 +740,20 @@\n-            Pipe p = Pipe.open();\n-            try (Pipe.SinkChannel sink = p.sink()) {\n-                runAfterParkedAsync(sink::close);\n-                try {\n-                    ByteBuffer bb = ByteBuffer.allocate(100*1024);\n-                    for (;;) {\n-                        int n = sink.write(bb);\n-                        assertTrue(n > 0);\n-                        bb.clear();\n+            boolean retry = true;\n+            while (retry) {\n+                Pipe p = Pipe.open();\n+                try (Pipe.SinkChannel sink = p.sink();\n+                     Pipe.SourceChannel source = p.source()) {\n+\n+                    \/\/ close sink when current thread blocks in write\n+                    runAfterParkedAsync(sink::close);\n+                    try {\n+                        ByteBuffer bb = ByteBuffer.allocate(100*1024);\n+                        for (;;) {\n+                            int n = sink.write(bb);\n+                            assertTrue(n > 0);\n+                            bb.clear();\n+                        }\n+                    } catch (AsynchronousCloseException e) {\n+                        \/\/ closed when blocked in write\n+                        retry = false;\n+                    } catch (ClosedChannelException e) {\n+                        \/\/ closed when not blocked in write, need to retry test\n@@ -740,1 +761,1 @@\n-                } catch (AsynchronousCloseException expected) { }\n+                }\n@@ -751,13 +772,23 @@\n-            Pipe p = Pipe.open();\n-            try (Pipe.SinkChannel sink = p.sink()) {\n-\n-                \/\/ delayed interrupt of current thread\n-                Thread thisThread = Thread.currentThread();\n-                runAfterParkedAsync(thisThread::interrupt);\n-\n-                try {\n-                    ByteBuffer bb = ByteBuffer.allocate(100*1024);\n-                    for (;;) {\n-                        int n = sink.write(bb);\n-                        assertTrue(n > 0);\n-                        bb.clear();\n+            boolean retry = true;\n+            while (retry) {\n+                Pipe p = Pipe.open();\n+                try (Pipe.SinkChannel sink = p.sink();\n+                     Pipe.SourceChannel source = p.source()) {\n+\n+                    \/\/ interrupt current thread when it blocks in write\n+                    Thread thisThread = Thread.currentThread();\n+                    runAfterParkedAsync(thisThread::interrupt);\n+\n+                    try {\n+                        ByteBuffer bb = ByteBuffer.allocate(100*1024);\n+                        for (;;) {\n+                            int n = sink.write(bb);\n+                            assertTrue(n > 0);\n+                            bb.clear();\n+                        }\n+                    } catch (ClosedByInterruptException expected) {\n+                        \/\/ closed when blocked in write\n+                        assertTrue(Thread.interrupted());\n+                        retry = false;\n+                    } catch (ClosedChannelException e) {\n+                        \/\/ closed when not blocked in write, need to retry test\n@@ -765,2 +796,0 @@\n-                } catch (ClosedByInterruptException expected) {\n-                    assertTrue(Thread.interrupted());\n","filename":"test\/jdk\/java\/nio\/channels\/vthread\/BlockingChannelOps.java","additions":104,"deletions":75,"binary":false,"changes":179,"status":"modified"}]}