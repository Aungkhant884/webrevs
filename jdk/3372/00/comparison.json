{"files":[{"patch":"@@ -2058,1 +2058,1 @@\n-      _subtasks(),\n+      _subtasks(ParallelRootType::sentinel),\n@@ -2061,2 +2061,0 @@\n-    _subtasks.set_n_threads(active_workers);\n-    _subtasks.set_n_tasks(ParallelRootType::sentinel);\n@@ -2069,1 +2067,0 @@\n-    _subtasks.all_tasks_completed();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -306,1 +306,1 @@\n-      _subtasks(),\n+      _subtasks(ParallelRootType::sentinel),\n@@ -312,2 +312,0 @@\n-    _subtasks.set_n_threads(active_workers);\n-    _subtasks.set_n_tasks(ParallelRootType::sentinel);\n@@ -348,1 +346,0 @@\n-    _subtasks.all_tasks_completed();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -107,1 +107,0 @@\n-    _sub_tasks.all_tasks_completed();\n@@ -110,2 +109,1 @@\n-  ParRestoreTask(uint worker_num,\n-                 PreservedMarksSet* preserved_marks_set,\n+  ParRestoreTask(PreservedMarksSet* preserved_marks_set,\n@@ -115,0 +113,1 @@\n+        _sub_tasks(preserved_marks_set->num()),\n@@ -116,3 +115,1 @@\n-    _sub_tasks.set_n_threads(worker_num);\n-    _sub_tasks.set_n_tasks(preserved_marks_set->num());\n-  }\n+    }\n@@ -130,1 +127,1 @@\n-#endif \/\/ def ASSERT\n+#endif \/\/ ASSERT\n@@ -138,1 +135,1 @@\n-    ParRestoreTask task(workers->active_workers(), this, &total_size);\n+    ParRestoreTask task(this, &total_size);\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -402,9 +402,0 @@\n-void SequentialSubTasksDone::clear() {\n-  _n_tasks   = _n_claimed   = 0;\n-  _n_threads = _n_completed = 0;\n-}\n-\n-bool SequentialSubTasksDone::valid() {\n-  return _n_threads > 0;\n-}\n-\n@@ -412,3 +403,3 @@\n-  t = _n_claimed;\n-  while (t < _n_tasks) {\n-    uint res = Atomic::cmpxchg(&_n_claimed, t, t+1);\n+  t = _num_claimed;\n+  while (t < _num_tasks) {\n+    uint res = Atomic::cmpxchg(&_num_claimed, t, t+1);\n@@ -422,16 +413,0 @@\n-\n-bool SequentialSubTasksDone::all_tasks_completed() {\n-  uint complete = _n_completed;\n-  while (true) {\n-    uint res = Atomic::cmpxchg(&_n_completed, complete, complete+1);\n-    if (res == complete) {\n-      break;\n-    }\n-    complete = res;\n-  }\n-  if (complete+1 == _n_threads) {\n-    clear();\n-    return true;\n-  }\n-  return false;\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/workgroup.cpp","additions":3,"deletions":28,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -349,2 +349,1 @@\n-\/\/ set scanning). Note that unlike the above class this is\n-\/\/ a stack object - is there any reason for it not to be?\n+\/\/ set scanning).\n@@ -352,8 +351,4 @@\n-class SequentialSubTasksDone : public StackObj {\n-protected:\n-  uint _n_tasks;     \/\/ Total number of tasks available.\n-  volatile uint _n_claimed;   \/\/ Number of tasks claimed.\n-  \/\/ _n_threads is used to determine when a sub task is done.\n-  \/\/ See comments on SubTasksDone::_n_threads\n-  uint _n_threads;   \/\/ Total number of parallel threads.\n-  volatile uint _n_completed; \/\/ Number of completed threads.\n+class SequentialSubTasksDone : public CHeapObj<mtInternal> {\n+\n+  uint _num_tasks;     \/\/ Total number of tasks available.\n+  volatile uint _num_claimed;   \/\/ Number of tasks claimed.\n@@ -361,1 +356,1 @@\n-  void clear();\n+  NONCOPYABLE(SequentialSubTasksDone);\n@@ -364,2 +359,3 @@\n-  SequentialSubTasksDone() {\n-    clear();\n+  SequentialSubTasksDone(uint num_tasks) : _num_tasks(num_tasks), _num_claimed(0) { }\n+  ~SequentialSubTasksDone() {\n+    assert(_num_claimed == _num_tasks, \"Claimed %u tasks of %u\", _num_claimed, _num_tasks);\n@@ -367,20 +363,0 @@\n-  ~SequentialSubTasksDone() {}\n-\n-  \/\/ True iff the object is in a valid state.\n-  bool valid();\n-\n-  \/\/ number of tasks\n-  uint n_tasks() const { return _n_tasks; }\n-\n-  \/\/ Get\/set the number of parallel threads doing the tasks to t.\n-  \/\/ Should be called before the task starts but it is safe\n-  \/\/ to call this once a task is running provided that all\n-  \/\/ threads agree on the number of threads.\n-  uint n_threads() { return _n_threads; }\n-  void set_n_threads(uint t) { _n_threads = t; }\n-\n-  \/\/ Set the number of tasks to be claimed to t. As above,\n-  \/\/ should be called before the tasks start but it is safe\n-  \/\/ to call this once a task is running provided all threads\n-  \/\/ agree on the number of tasks.\n-  void set_n_tasks(uint t) { _n_tasks = t; }\n@@ -393,7 +369,0 @@\n-\n-  \/\/ The calling thread asserts that it has attempted to claim\n-  \/\/ all the tasks it possibly can in the sequence. Every thread\n-  \/\/ claiming tasks must promise call this. Returns true if this\n-  \/\/ is the last thread to complete so that the thread can perform\n-  \/\/ cleanup if necessary.\n-  bool all_tasks_completed();\n","filename":"src\/hotspot\/share\/gc\/shared\/workgroup.hpp","additions":9,"deletions":40,"binary":false,"changes":49,"status":"modified"}]}