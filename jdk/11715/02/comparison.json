{"files":[{"patch":"@@ -33,1 +33,0 @@\n-#include \"classfile\/classLoaderDataShared.hpp\"\n@@ -35,1 +34,1 @@\n-#include \"classfile\/moduleEntry.hpp\"\n+#include \"classfile\/modules.hpp\"\n@@ -557,1 +556,1 @@\n-    ClassLoaderDataShared::init_archived_oops();\n+    Modules::verify_archived_modules();\n@@ -1192,19 +1191,0 @@\n-void HeapShared::check_module_oop(oop orig_module_obj) {\n-  assert(DumpSharedSpaces, \"must be\");\n-  assert(java_lang_Module::is_instance(orig_module_obj), \"must be\");\n-  ModuleEntry* orig_module_ent = java_lang_Module::module_entry_raw(orig_module_obj);\n-  if (orig_module_ent == NULL) {\n-    \/\/ These special Module objects are created in Java code. They are not\n-    \/\/ defined via Modules::define_module(), so they don't have a ModuleEntry:\n-    \/\/     java.lang.Module::ALL_UNNAMED_MODULE\n-    \/\/     java.lang.Module::EVERYONE_MODULE\n-    \/\/     jdk.internal.loader.ClassLoaders$BootClassLoader::unnamedModule\n-    assert(java_lang_Module::name(orig_module_obj) == NULL, \"must be unnamed\");\n-    log_info(cds, heap)(\"Module oop with No ModuleEntry* @[\" PTR_FORMAT \"]\", p2i(orig_module_obj));\n-  } else {\n-    ClassLoaderData* loader_data = orig_module_ent->loader_data();\n-    assert(loader_data->is_builtin_class_loader_data(), \"must be\");\n-  }\n-}\n-\n-\n@@ -1279,1 +1259,3 @@\n-      check_module_oop(orig_obj);\n+      if (Modules::check_module_oop(orig_obj)) {\n+        Modules::update_oops_in_archived_module(orig_obj, append_root(archived_obj));\n+      }\n@@ -1281,1 +1263,0 @@\n-      java_lang_Module::set_loader(archived_obj, NULL);\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":5,"deletions":24,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -304,1 +304,0 @@\n-  static void check_module_oop(oop orig_module_obj);\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,0 @@\n-  void init_archived_oops(ClassLoaderData* loader_data);\n@@ -104,8 +103,0 @@\n-void ArchivedClassLoaderData::init_archived_oops(ClassLoaderData* loader_data) {\n-  assert(DumpSharedSpaces, \"must be\");\n-  assert_valid(loader_data);\n-  if (loader_data != NULL) {\n-    loader_data->modules()->init_archived_oops(_modules);\n-  }\n-}\n-\n@@ -177,7 +168,0 @@\n-void ClassLoaderDataShared::init_archived_oops() {\n-  assert(DumpSharedSpaces && MetaspaceShared::use_full_module_graph(), \"must be\");\n-  _archived_boot_loader_data.init_archived_oops    (null_class_loader_data());\n-  _archived_platform_loader_data.init_archived_oops(java_platform_loader_data_or_null());\n-  _archived_system_loader_data.init_archived_oops  (java_system_loader_data_or_null());\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataShared.cpp","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-  static void init_archived_oops();\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataShared.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -36,0 +37,1 @@\n+#include \"logging\/logStream.hpp\"\n@@ -389,0 +391,5 @@\n+#ifndef PRODUCT\n+static int _num_archived_module_entries = 0;\n+static int _num_inited_module_entries = 0;\n+#endif\n+\n@@ -393,0 +400,1 @@\n+  archived_entry->_archived_module_index = -1;\n@@ -399,0 +407,1 @@\n+  DEBUG_ONLY(_num_archived_module_entries++);\n@@ -400,0 +409,6 @@\n+  if (log_is_enabled(Info, cds, module)) {\n+    ResourceMark rm;\n+    LogStream ls(Log(cds, module)::info());\n+    ls.print(\"Stored in archive: \");\n+    archived_entry->print(&ls);\n+  }\n@@ -403,0 +418,5 @@\n+bool ModuleEntry::has_been_archived() {\n+  assert(!ArchiveBuilder::current()->is_in_buffer_space(this), \"must be called on original ModuleEntry\");\n+  return _archive_modules_entries->contains(this);\n+}\n+\n@@ -470,1 +490,1 @@\n-void ModuleEntry::init_archived_oops() {\n+void ModuleEntry::update_oops_in_archived_module(int root_oop_index) {\n@@ -472,6 +492,5 @@\n-  oop module_obj = module();\n-  if (module_obj != NULL) {\n-    oop m = HeapShared::find_archived_heap_object(module_obj);\n-    assert(m != NULL, \"sanity\");\n-    _archived_module_index = HeapShared::append_root(m);\n-  }\n+  assert(_archived_module_index == -1, \"must be set exactly once\");\n+  assert(root_oop_index >= 0, \"sanity\");\n+\n+  _archived_module_index = root_oop_index;\n+\n@@ -482,0 +501,10 @@\n+\n+  \/\/ For verify_archived_module_entries()\n+  DEBUG_ONLY(_num_inited_module_entries++);\n+}\n+\n+#ifndef PRODUCT\n+void ModuleEntry::verify_archived_module_entries() {\n+  assert(_num_archived_module_entries == _num_inited_module_entries,\n+         \"%d ModuleEntries have been archived but %d of them have been properly initialized with archived java.lang.Module objects\",\n+         _num_archived_module_entries, _num_inited_module_entries);\n@@ -483,0 +512,1 @@\n+#endif \/\/ PRODUCT\n@@ -485,0 +515,1 @@\n+  assert(UseSharedSpaces, \"runtime only\");\n@@ -491,0 +522,1 @@\n+  assert(UseSharedSpaces, \"runtime only\");\n@@ -499,2 +531,8 @@\n-  if (loader_data->class_loader() != NULL) {\n-    java_lang_Module::set_loader(module_handle(), loader_data->class_loader());\n+  assert(java_lang_Module::loader(module_handle()) == loader_data->class_loader(),\n+         \"must be set in dump time\");\n+\n+  if (log_is_enabled(Info, cds, module)) {\n+    ResourceMark rm;\n+    LogStream ls(Log(cds, module)::info());\n+    ls.print(\"Restored from archive: \");\n+    print(&ls);\n@@ -505,0 +543,1 @@\n+  assert(UseSharedSpaces, \"runtime only\");\n@@ -547,8 +586,0 @@\n-void ModuleEntryTable::init_archived_oops(Array<ModuleEntry*>* archived_modules) {\n-  assert(DumpSharedSpaces, \"dump time only\");\n-  for (int i = 0; i < archived_modules->length(); i++) {\n-    ModuleEntry* archived_entry = archived_modules->at(i);\n-    archived_entry->init_archived_oops();\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":48,"deletions":17,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -178,1 +178,0 @@\n-  void init_archived_oops();\n@@ -180,0 +179,1 @@\n+  bool has_been_archived();\n@@ -185,0 +185,2 @@\n+  void update_oops_in_archived_module(int root_oop_index);\n+  static void verify_archived_module_entries() PRODUCT_RETURN;\n@@ -253,1 +255,0 @@\n-  void init_archived_oops(Array<ModuleEntry*>* archived_modules);\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -480,0 +480,82 @@\n+static bool _seen_platform_unnamed_module = false;\n+static bool _seen_system_unnamed_module = false;\n+\n+\/\/ Validate the states of an java.lang.Module oop to be archived.\n+\/\/\n+\/\/ Returns true iff the oop has an archived ModuleEntry.\n+bool Modules::check_module_oop(oop orig_module_obj) {\n+  assert(DumpSharedSpaces, \"must be\");\n+  assert(MetaspaceShared::use_full_module_graph(), \"must be\");\n+  assert(java_lang_Module::is_instance(orig_module_obj), \"must be\");\n+\n+  ModuleEntry* orig_module_ent = java_lang_Module::module_entry_raw(orig_module_obj);\n+  if (orig_module_ent == nullptr) {\n+    \/\/ These special java.lang.Module oops are created in Java code. They are not\n+    \/\/ defined via Modules::define_module(), so they don't have a ModuleEntry:\n+    \/\/     java.lang.Module::ALL_UNNAMED_MODULE\n+    \/\/     java.lang.Module::EVERYONE_MODULE\n+    \/\/     jdk.internal.loader.ClassLoaders$BootClassLoader::unnamedModule\n+    log_info(cds, module)(\"Archived java.lang.Module oop \" PTR_FORMAT \" with no ModuleEntry*\", p2i(orig_module_obj));\n+    assert(java_lang_Module::name(orig_module_obj) == nullptr, \"must be unnamed\");\n+    return false;\n+  } else {\n+    \/\/ This java.lang.Module oop has an ModuleEntry*. Check if the latter is archived.\n+    if (log_is_enabled(Info, cds, module)) {\n+      ResourceMark rm;\n+      LogStream ls(Log(cds, module)::info());\n+      ls.print(\"Archived java.lang.Module oop \" PTR_FORMAT \" for \", p2i(orig_module_obj));\n+      orig_module_ent->print(&ls);\n+    }\n+\n+    \/\/ We only archive the default module graph, which should contain only java.lang.Module oops\n+    \/\/ for the 3 built-in loaders (boot\/platform\/system)\n+    ClassLoaderData* loader_data = orig_module_ent->loader_data();\n+    assert(loader_data->is_builtin_class_loader_data(), \"must be\");\n+\n+    if (orig_module_ent->name() != nullptr) {\n+      \/\/ For each named module, we archive both the java.lang.Module oop and the ModuleEntry.\n+      assert(orig_module_ent->has_been_archived(), \"sanity\");\n+      return true;\n+    } else {\n+      \/\/ We only archive two unnamed module oops (for platform and system loaders). These do NOT have an archived\n+      \/\/ ModuleEntry.\n+      \/\/\n+      \/\/ At runtime, these oops are fetched from java_lang_ClassLoader::unnamedModule(loader) and\n+      \/\/ are initialized in ClassLoaderData::ClassLoaderData() => ModuleEntry::create_unnamed_module(), where\n+      \/\/ a new ModuleEntry is allocated.\n+      assert(!loader_data->is_boot_class_loader_data(), \"unnamed module for boot loader should be not archived\");\n+      assert(!orig_module_ent->has_been_archived(), \"sanity\");\n+\n+      if (SystemDictionary::is_platform_class_loader(loader_data->class_loader())) {\n+        assert(!_seen_platform_unnamed_module, \"only once\");\n+        _seen_platform_unnamed_module = true;\n+      } else if (SystemDictionary::is_system_class_loader(loader_data->class_loader())) {\n+        assert(!_seen_system_unnamed_module, \"only once\");\n+        _seen_system_unnamed_module = true;\n+      } else {\n+        \/\/ The java.lang.Module oop and ModuleEntry of the unnamed module of the boot loader are\n+        \/\/ not in the archived module graph. These are always allocated at runtime.\n+        ShouldNotReachHere();\n+      }\n+      return false;\n+    }\n+  }\n+}\n+\n+void Modules::update_oops_in_archived_module(oop orig_module_obj, int archived_module_root_index) {\n+  \/\/ This java.lang.Module oop must have an archived ModuleEntry\n+  assert(check_module_oop(orig_module_obj) == true, \"sanity\");\n+\n+  \/\/ We remember the oop inside the ModuleEntry::_archived_module_index. At runtime, we use\n+  \/\/ this index to reinitialize the ModuleEntry inside ModuleEntry::restore_archived_oops().\n+  \/\/\n+  \/\/ ModuleEntry::verify_archived_module_entries(), called below, ensures that every archived\n+  \/\/ ModuleEntry has been assigned an _archived_module_index.\n+  ModuleEntry* orig_module_ent = java_lang_Module::module_entry_raw(orig_module_obj);\n+  ModuleEntry::get_archived_entry(orig_module_ent)->update_oops_in_archived_module(archived_module_root_index);\n+}\n+\n+void Modules::verify_archived_modules() {\n+  ModuleEntry::verify_archived_module_entries();\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":82,"deletions":0,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -56,0 +56,3 @@\n+  static bool check_module_oop(oop orig_module_obj) NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static void update_oops_in_archived_module(oop orig_module_obj, int archived_module_root_index)\n+                                             NOT_CDS_JAVA_HEAP_RETURN;\n@@ -58,0 +61,1 @@\n+  static void verify_archived_modules() NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/modules.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}