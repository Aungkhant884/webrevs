{"files":[{"patch":"@@ -33,1 +33,0 @@\n-#include \"classfile\/classLoaderDataShared.hpp\"\n@@ -35,1 +34,1 @@\n-#include \"classfile\/moduleEntry.hpp\"\n+#include \"classfile\/modules.hpp\"\n@@ -557,1 +556,1 @@\n-    ClassLoaderDataShared::init_archived_oops();\n+    Modules::verify_archived_modules();\n@@ -1192,19 +1191,0 @@\n-void HeapShared::check_module_oop(oop orig_module_obj) {\n-  assert(DumpSharedSpaces, \"must be\");\n-  assert(java_lang_Module::is_instance(orig_module_obj), \"must be\");\n-  ModuleEntry* orig_module_ent = java_lang_Module::module_entry_raw(orig_module_obj);\n-  if (orig_module_ent == NULL) {\n-    \/\/ These special Module objects are created in Java code. They are not\n-    \/\/ defined via Modules::define_module(), so they don't have a ModuleEntry:\n-    \/\/     java.lang.Module::ALL_UNNAMED_MODULE\n-    \/\/     java.lang.Module::EVERYONE_MODULE\n-    \/\/     jdk.internal.loader.ClassLoaders$BootClassLoader::unnamedModule\n-    assert(java_lang_Module::name(orig_module_obj) == NULL, \"must be unnamed\");\n-    log_info(cds, heap)(\"Module oop with No ModuleEntry* @[\" PTR_FORMAT \"]\", p2i(orig_module_obj));\n-  } else {\n-    ClassLoaderData* loader_data = orig_module_ent->loader_data();\n-    assert(loader_data->is_builtin_class_loader_data(), \"must be\");\n-  }\n-}\n-\n-\n@@ -1279,1 +1259,3 @@\n-      check_module_oop(orig_obj);\n+      if (Modules::check_module_oop(orig_obj)) {\n+        Modules::update_oops_in_archived_module(orig_obj, append_root(archived_obj));\n+      }\n@@ -1281,1 +1263,0 @@\n-      java_lang_Module::set_loader(archived_obj, NULL);\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":5,"deletions":24,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -304,1 +304,0 @@\n-  static void check_module_oop(oop orig_module_obj);\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,0 @@\n-  void init_archived_oops(ClassLoaderData* loader_data);\n@@ -104,8 +103,0 @@\n-void ArchivedClassLoaderData::init_archived_oops(ClassLoaderData* loader_data) {\n-  assert(DumpSharedSpaces, \"must be\");\n-  assert_valid(loader_data);\n-  if (loader_data != NULL) {\n-    loader_data->modules()->init_archived_oops(_modules);\n-  }\n-}\n-\n@@ -177,7 +168,0 @@\n-void ClassLoaderDataShared::init_archived_oops() {\n-  assert(DumpSharedSpaces && MetaspaceShared::use_full_module_graph(), \"must be\");\n-  _archived_boot_loader_data.init_archived_oops    (null_class_loader_data());\n-  _archived_platform_loader_data.init_archived_oops(java_platform_loader_data_or_null());\n-  _archived_system_loader_data.init_archived_oops  (java_system_loader_data_or_null());\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataShared.cpp","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-  static void init_archived_oops();\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataShared.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -389,0 +390,5 @@\n+#ifndef PRODUCT\n+static int _num_archived_module_entries = 0;\n+static int _num_inited_module_entries = 0;\n+#endif\n+\n@@ -393,0 +399,1 @@\n+  archived_entry->_archived_module_index = -2;\n@@ -399,0 +406,1 @@\n+  DEBUG_ONLY(_num_archived_module_entries++);\n@@ -400,0 +408,4 @@\n+  if (log_is_enabled(Info, cds, module)) {\n+    ResourceMark rm;\n+    log_info(cds, module)(\"Archived ModuleEntry* = \" PTR_FORMAT \" for %s\", p2i(archived_entry), debug_info());\n+  }\n@@ -403,0 +415,5 @@\n+bool ModuleEntry::has_been_archived() {\n+  assert(!ArchiveBuilder::current()->is_in_buffer_space(this), \"must be called on original ModuleEntry\");\n+  return _archive_modules_entries->contains(this);\n+}\n+\n@@ -470,1 +487,1 @@\n-void ModuleEntry::init_archived_oops() {\n+void ModuleEntry::update_oops_in_archived_module(int root_oop_index) {\n@@ -472,6 +489,5 @@\n-  oop module_obj = module();\n-  if (module_obj != NULL) {\n-    oop m = HeapShared::find_archived_heap_object(module_obj);\n-    assert(m != NULL, \"sanity\");\n-    _archived_module_index = HeapShared::append_root(m);\n-  }\n+  assert(_archived_module_index == -2, \"must be set exactly once\");\n+  assert(root_oop_index >= 0, \"sanity\");\n+\n+  _archived_module_index = root_oop_index;\n+\n@@ -482,0 +498,3 @@\n+\n+  \/\/ For validate_archived_module_entries()\n+  DEBUG_ONLY(_num_inited_module_entries++);\n@@ -484,0 +503,27 @@\n+char* ModuleEntry::debug_info() const {\n+  stringStream info;\n+\n+  info.print(\"ModuleEntry* \" PTR_FORMAT \" (loader = \", p2i(this));\n+\n+  assert(loader_data()->is_builtin_class_loader_data(), \"must be\");\n+\n+  if (loader_data()->is_boot_class_loader_data()) {\n+    info.print(\"boot\");\n+  } else if (SystemDictionary::is_platform_class_loader(loader_data()->class_loader())) {\n+    info.print(\"platform\");\n+  } else if (SystemDictionary::is_system_class_loader(loader_data()->class_loader())) {\n+    info.print(\"system\");\n+  }\n+\n+  info.print(\", name = %s)\", (name() == nullptr) ? \"unnamed\" : name()->as_quoted_ascii());\n+  return info.as_string();\n+}\n+\n+#ifndef PRODUCT\n+void ModuleEntry::validate_archived_module_entries() {\n+  assert(_num_archived_module_entries == _num_inited_module_entries,\n+         \"%d ModuleEntries have been archived but %d of them have been properly initialized with archived java.lang.Module objects\",\n+         _num_archived_module_entries, _num_inited_module_entries);\n+}\n+#endif \/\/ PRODUCT\n+\n@@ -485,0 +531,1 @@\n+  assert(UseSharedSpaces, \"runtime only\");\n@@ -491,0 +538,1 @@\n+  assert(UseSharedSpaces, \"runtime only\");\n@@ -499,2 +547,6 @@\n-  if (loader_data->class_loader() != NULL) {\n-    java_lang_Module::set_loader(module_handle(), loader_data->class_loader());\n+  assert(java_lang_Module::loader(module_handle()) == loader_data->class_loader(),\n+         \"must be set in dump time\");\n+\n+  if (log_is_enabled(Info, cds, module)) {\n+    ResourceMark rm;\n+    log_info(cds, module)(\"Restored archived %s\", debug_info());\n@@ -505,0 +557,1 @@\n+  assert(UseSharedSpaces, \"runtime only\");\n@@ -547,8 +600,0 @@\n-void ModuleEntryTable::init_archived_oops(Array<ModuleEntry*>* archived_modules) {\n-  assert(DumpSharedSpaces, \"dump time only\");\n-  for (int i = 0; i < archived_modules->length(); i++) {\n-    ModuleEntry* archived_entry = archived_modules->at(i);\n-    archived_entry->init_archived_oops();\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":62,"deletions":17,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -178,1 +178,0 @@\n-  void init_archived_oops();\n@@ -180,0 +179,1 @@\n+  bool has_been_archived();\n@@ -185,0 +185,3 @@\n+  void update_oops_in_archived_module(int root_oop_index);\n+  static void validate_archived_module_entries() PRODUCT_RETURN;\n+  char* debug_info() const;\n@@ -253,1 +256,0 @@\n-  void init_archived_oops(Array<ModuleEntry*>* archived_modules);\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -480,0 +480,81 @@\n+static bool _seen_platform_unnamed_module = false;\n+static bool _seen_system_unnamed_module = false;\n+\n+\/\/ Validate the states of an java.lang.Module oop to be archived.\n+\/\/\n+\/\/ Returns true iff the oop has an archived ModuleEntry.\n+bool Modules::check_module_oop(oop orig_module_obj) {\n+  assert(DumpSharedSpaces, \"must be\");\n+  assert(MetaspaceShared::use_full_module_graph(), \"must be\");\n+  assert(java_lang_Module::is_instance(orig_module_obj), \"must be\");\n+\n+  ModuleEntry* orig_module_ent = java_lang_Module::module_entry_raw(orig_module_obj);\n+  if (orig_module_ent == NULL) {\n+    \/\/ These special java.lang.Module oops are created in Java code. They are not\n+    \/\/ defined via Modules::define_module(), so they don't have a ModuleEntry:\n+    \/\/     java.lang.Module::ALL_UNNAMED_MODULE\n+    \/\/     java.lang.Module::EVERYONE_MODULE\n+    \/\/     jdk.internal.loader.ClassLoaders$BootClassLoader::unnamedModule\n+    log_info(cds, module)(\"Archived java.lang.Module oop with no ModuleEntry* @[\" PTR_FORMAT \"]\", p2i(orig_module_obj));\n+    assert(java_lang_Module::name(orig_module_obj) == NULL, \"must be unnamed\");\n+    return false;\n+  } else {\n+    \/\/ This java.lang.Module oop has an ModuleEntry*. Check if the latter is archived.\n+    if (log_is_enabled(Info, cds, module)) {\n+      ResourceMark rm;\n+      log_info(cds, module)(\"Archived java.lang.Module oop \" PTR_FORMAT \" for %s\", p2i(orig_module_obj),\n+                            orig_module_ent->debug_info());\n+    }\n+\n+    \/\/ We only archive the default module graph, which should contain only java.lang.Module oops\n+    \/\/ for the 3 built-in loaders (boot\/platform\/system)\n+    ClassLoaderData* loader_data = orig_module_ent->loader_data();\n+    assert(loader_data->is_builtin_class_loader_data(), \"must be\");\n+\n+    if (orig_module_ent->name() != nullptr) {\n+      \/\/ For each named module, we archive both the java.lang.Module oop and the ModuleEntry.\n+      assert(orig_module_ent->has_been_archived(), \"sanity\");\n+      return true;\n+    } else {\n+      \/\/ We only archive two unnamed module oops (for platform and system loaders). These do NOT have an archived\n+      \/\/ ModuleEntry.\n+      \/\/\n+      \/\/ At runtime, these oops are fetched from java_lang_ClassLoader::unnamedModule(loader) and\n+      \/\/ are initialized in ClassLoaderData::ClassLoaderData() => ModuleEntry::create_unnamed_module(), where\n+      \/\/ a new ModuleEntry is allocated.\n+      assert(!loader_data->is_boot_class_loader_data(), \"unnamed module for boot loader should be not archived\");\n+      assert(!orig_module_ent->has_been_archived(), \"sanity\");\n+\n+      if (SystemDictionary::is_platform_class_loader(loader_data->class_loader())) {\n+        assert(!_seen_platform_unnamed_module, \"only once\");\n+        _seen_platform_unnamed_module = true;\n+      } else if (SystemDictionary::is_system_class_loader(loader_data->class_loader())) {\n+        assert(!_seen_system_unnamed_module, \"only once\");\n+        _seen_system_unnamed_module = true;\n+      } else {\n+        \/\/ The java.lang.Module oop and ModuleEntry of the unnamed module of the boot loader are\n+        \/\/ not in the archived module graph. These are always allocated at runtime.\n+        ShouldNotReachHere();\n+      }\n+      return false;\n+    }\n+  }\n+}\n+\n+void Modules::update_oops_in_archived_module(oop orig_module_obj, int archived_module_root_index) {\n+  \/\/ This java.lang.Module oop must have an archived ModuleEntry\n+  assert(check_module_oop(orig_module_obj) == true, \"sanity\");\n+\n+  \/\/ We remember the oop inside the ModuleEntry::_archived_module_index. At runtime, we use\n+  \/\/ this index to reinitialize the ModuleEntry inside ModuleEntry::restore_archived_oops().\n+  \/\/\n+  \/\/ ModuleEntry::validate_archived_module_entries(), called below, ensures that every archived\n+  \/\/ ModuleEntry has been assigned an _archived_module_index.\n+  ModuleEntry* orig_module_ent = java_lang_Module::module_entry_raw(orig_module_obj);\n+  ModuleEntry::get_archived_entry(orig_module_ent)->update_oops_in_archived_module(archived_module_root_index);\n+}\n+\n+void Modules::verify_archived_modules() {\n+  ModuleEntry::validate_archived_module_entries();\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":81,"deletions":0,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -56,0 +56,3 @@\n+  static bool check_module_oop(oop orig_module_obj);\n+  static void update_oops_in_archived_module(oop orig_module_obj, int archived_module_root_index)\n+                                             NOT_CDS_JAVA_HEAP_RETURN;\n@@ -58,0 +61,1 @@\n+  static void verify_archived_modules() NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/modules.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}