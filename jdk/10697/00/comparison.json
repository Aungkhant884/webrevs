{"files":[{"patch":"@@ -43,261 +43,0 @@\n-void Assembler::add(Register Rd, Register Rn, int64_t increment, Register temp) {\n-  if (is_imm_in_range(increment, 12, 0)) {\n-    addi(Rd, Rn, increment);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, increment);\n-    add(Rd, Rn, temp);\n-  }\n-}\n-\n-void Assembler::addw(Register Rd, Register Rn, int32_t increment, Register temp) {\n-  if (is_imm_in_range(increment, 12, 0)) {\n-    addiw(Rd, Rn, increment);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, increment);\n-    addw(Rd, Rn, temp);\n-  }\n-}\n-\n-void Assembler::sub(Register Rd, Register Rn, int64_t decrement, Register temp) {\n-  if (is_imm_in_range(-decrement, 12, 0)) {\n-    addi(Rd, Rn, -decrement);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, decrement);\n-    sub(Rd, Rn, temp);\n-  }\n-}\n-\n-void Assembler::subw(Register Rd, Register Rn, int32_t decrement, Register temp) {\n-  if (is_imm_in_range(-decrement, 12, 0)) {\n-    addiw(Rd, Rn, -decrement);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, decrement);\n-    subw(Rd, Rn, temp);\n-  }\n-}\n-\n-void Assembler::zext_w(Register Rd, Register Rs) {\n-  add_uw(Rd, Rs, zr);\n-}\n-\n-void Assembler::_li(Register Rd, int64_t imm) {\n-  \/\/ int64_t is in range 0x8000 0000 0000 0000 ~ 0x7fff ffff ffff ffff\n-  int shift = 12;\n-  int64_t upper = imm, lower = imm;\n-  \/\/ Split imm to a lower 12-bit sign-extended part and the remainder,\n-  \/\/ because addi will sign-extend the lower imm.\n-  lower = ((int32_t)imm << 20) >> 20;\n-  upper -= lower;\n-\n-  \/\/ Test whether imm is a 32-bit integer.\n-  if (!(((imm) & ~(int64_t)0x7fffffff) == 0 ||\n-        (((imm) & ~(int64_t)0x7fffffff) == ~(int64_t)0x7fffffff))) {\n-    while (((upper >> shift) & 1) == 0) { shift++; }\n-    upper >>= shift;\n-    li(Rd, upper);\n-    slli(Rd, Rd, shift);\n-    if (lower != 0) {\n-      addi(Rd, Rd, lower);\n-    }\n-  } else {\n-    \/\/ 32-bit integer\n-    Register hi_Rd = zr;\n-    if (upper != 0) {\n-      lui(Rd, (int32_t)upper);\n-      hi_Rd = Rd;\n-    }\n-    if (lower != 0 || hi_Rd == zr) {\n-      addiw(Rd, hi_Rd, lower);\n-    }\n-  }\n-}\n-\n-void Assembler::li64(Register Rd, int64_t imm) {\n-  \/\/ Load upper 32 bits. upper = imm[63:32], but if imm[31] == 1 or\n-  \/\/ (imm[31:20] == 0x7ff && imm[19] == 1), upper = imm[63:32] + 1.\n-  int64_t lower = imm & 0xffffffff;\n-  lower -= ((lower << 44) >> 44);\n-  int64_t tmp_imm = ((uint64_t)(imm & 0xffffffff00000000)) + (uint64_t)lower;\n-  int32_t upper = (tmp_imm - (int32_t)lower) >> 32;\n-\n-  \/\/ Load upper 32 bits\n-  int64_t up = upper, lo = upper;\n-  lo = (lo << 52) >> 52;\n-  up -= lo;\n-  up = (int32_t)up;\n-  lui(Rd, up);\n-  addi(Rd, Rd, lo);\n-\n-  \/\/ Load the rest 32 bits.\n-  slli(Rd, Rd, 12);\n-  addi(Rd, Rd, (int32_t)lower >> 20);\n-  slli(Rd, Rd, 12);\n-  lower = ((int32_t)imm << 12) >> 20;\n-  addi(Rd, Rd, lower);\n-  slli(Rd, Rd, 8);\n-  lower = imm & 0xff;\n-  addi(Rd, Rd, lower);\n-}\n-\n-void Assembler::li32(Register Rd, int32_t imm) {\n-  \/\/ int32_t is in range 0x8000 0000 ~ 0x7fff ffff, and imm[31] is the sign bit\n-  int64_t upper = imm, lower = imm;\n-  lower = (imm << 20) >> 20;\n-  upper -= lower;\n-  upper = (int32_t)upper;\n-  \/\/ lui Rd, imm[31:12] + imm[11]\n-  lui(Rd, upper);\n-  \/\/ use addiw to distinguish li32 to li64\n-  addiw(Rd, Rd, lower);\n-}\n-\n-#define INSN(NAME, REGISTER)                                       \\\n-  void Assembler::NAME(const address &dest, Register temp) {       \\\n-    assert_cond(dest != NULL);                                     \\\n-    int64_t distance = dest - pc();                                \\\n-    if (is_imm_in_range(distance, 20, 1)) {                        \\\n-      jal(REGISTER, distance);                                     \\\n-    } else {                                                       \\\n-      assert(temp != noreg, \"temp must not be empty register!\");   \\\n-      int32_t offset = 0;                                          \\\n-      movptr(temp, dest, offset);                                  \\\n-      jalr(REGISTER, temp, offset);                                \\\n-    }                                                              \\\n-  }                                                                \\\n-  void Assembler::NAME(Label &l, Register temp) {                  \\\n-    jal(REGISTER, l, temp);                                        \\\n-  }                                                                \\\n-\n-  INSN(j,   x0);\n-  INSN(jal, x1);\n-\n-#undef INSN\n-\n-#define INSN(NAME, REGISTER)                                       \\\n-  void Assembler::NAME(Register Rs) {                              \\\n-    jalr(REGISTER, Rs, 0);                                         \\\n-  }\n-\n-  INSN(jr,   x0);\n-  INSN(jalr, x1);\n-\n-#undef INSN\n-\n-#define INSN(NAME, REGISTER)                                   \\\n-  void Assembler::NAME(const Address &adr, Register temp) {    \\\n-    switch (adr.getMode()) {                                   \\\n-      case Address::literal: {                                 \\\n-        relocate(adr.rspec());                                 \\\n-        NAME(adr.target(), temp);                              \\\n-        break;                                                 \\\n-      }                                                        \\\n-      case Address::base_plus_offset: {                        \\\n-        int32_t offset = 0;                                    \\\n-        baseOffset(temp, adr, offset);                         \\\n-        jalr(REGISTER, temp, offset);                          \\\n-        break;                                                 \\\n-      }                                                        \\\n-      default:                                                 \\\n-        ShouldNotReachHere();                                  \\\n-    }                                                          \\\n-  }\n-\n-  INSN(j,    x0);\n-  INSN(jal,  x1);\n-\n-#undef INSN\n-\n-void Assembler::wrap_label(Register r1, Register r2, Label &L, compare_and_branch_insn insn,\n-                           compare_and_branch_label_insn neg_insn, bool is_far) {\n-  if (is_far) {\n-    Label done;\n-    (this->*neg_insn)(r1, r2, done, \/* is_far *\/ false);\n-    j(L);\n-    bind(done);\n-  } else {\n-    if (L.is_bound()) {\n-      (this->*insn)(r1, r2, target(L));\n-    } else {\n-      L.add_patch_at(code(), locator());\n-      (this->*insn)(r1, r2, pc());\n-    }\n-  }\n-}\n-\n-void Assembler::wrap_label(Register Rt, Label &L, Register tmp, load_insn_by_temp insn) {\n-  if (L.is_bound()) {\n-    (this->*insn)(Rt, target(L), tmp);\n-  } else {\n-    L.add_patch_at(code(), locator());\n-    (this->*insn)(Rt, pc(), tmp);\n-  }\n-}\n-\n-void Assembler::wrap_label(Register Rt, Label &L, jal_jalr_insn insn) {\n-  if (L.is_bound()) {\n-    (this->*insn)(Rt, target(L));\n-  } else {\n-    L.add_patch_at(code(), locator());\n-    (this->*insn)(Rt, pc());\n-  }\n-}\n-\n-void Assembler::movptr(Register Rd, address addr, int32_t &offset) {\n-  int64_t imm64 = (int64_t)addr;\n-#ifndef PRODUCT\n-  {\n-    char buffer[64];\n-    snprintf(buffer, sizeof(buffer), \"0x%\" PRIx64, imm64);\n-    block_comment(buffer);\n-  }\n-#endif\n-  assert(is_unsigned_imm_in_range(imm64, 47, 0) || (imm64 == (int64_t)-1),\n-         \"bit 47 overflows in address constant\");\n-  \/\/ Load upper 31 bits\n-  int64_t imm = imm64 >> 17;\n-  int64_t upper = imm, lower = imm;\n-  lower = (lower << 52) >> 52;\n-  upper -= lower;\n-  upper = (int32_t)upper;\n-  lui(Rd, upper);\n-  addi(Rd, Rd, lower);\n-\n-  \/\/ Load the rest 17 bits.\n-  slli(Rd, Rd, 11);\n-  addi(Rd, Rd, (imm64 >> 6) & 0x7ff);\n-  slli(Rd, Rd, 6);\n-\n-  \/\/ This offset will be used by following jalr\/ld.\n-  offset = imm64 & 0x3f;\n-}\n-\n-void Assembler::movptr(Register Rd, uintptr_t imm64) {\n-  movptr(Rd, (address)imm64);\n-}\n-\n-void Assembler::movptr(Register Rd, address addr) {\n-  int offset = 0;\n-  movptr(Rd, addr, offset);\n-  addi(Rd, Rd, offset);\n-}\n-\n-#define INSN(NAME, NEG_INSN)                                                         \\\n-  void Assembler::NAME(Register Rs, Register Rt, const address &dest) {              \\\n-    NEG_INSN(Rt, Rs, dest);                                                          \\\n-  }                                                                                  \\\n-  void Assembler::NAME(Register Rs, Register Rt, Label &l, bool is_far) {            \\\n-    NEG_INSN(Rt, Rs, l, is_far);                                                     \\\n-  }\n-\n-  INSN(bgt,  blt);\n-  INSN(ble,  bge);\n-  INSN(bgtu, bltu);\n-  INSN(bleu, bgeu);\n-#undef INSN\n-\n-#undef __\n-\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.cpp","additions":0,"deletions":261,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -294,42 +294,0 @@\n-  void baseOffset32(Register Rd, const Address &adr, int32_t &offset) {\n-    assert(Rd != noreg, \"Rd must not be empty register!\");\n-    guarantee(Rd != adr.base(), \"should use different registers!\");\n-    if (is_offset_in_range(adr.offset(), 32)) {\n-      int32_t imm = adr.offset();\n-      int32_t upper = imm, lower = imm;\n-      lower = (imm << 20) >> 20;\n-      upper -= lower;\n-      lui(Rd, upper);\n-      offset = lower;\n-    } else {\n-      offset = ((int32_t)adr.offset() << 20) >> 20;\n-      li(Rd, adr.offset() - offset);\n-    }\n-    add(Rd, Rd, adr.base());\n-  }\n-\n-  void baseOffset(Register Rd, const Address &adr, int32_t &offset) {\n-    if (is_offset_in_range(adr.offset(), 12)) {\n-      assert(Rd != noreg, \"Rd must not be empty register!\");\n-      addi(Rd, adr.base(), adr.offset());\n-      offset = 0;\n-    } else {\n-      baseOffset32(Rd, adr, offset);\n-    }\n-  }\n-\n-  void _li(Register Rd, int64_t imm);  \/\/ optimized load immediate\n-  void li32(Register Rd, int32_t imm);\n-  void li64(Register Rd, int64_t imm);\n-  void movptr(Register Rd, address addr);\n-  void movptr(Register Rd, address addr, int32_t &offset);\n-  void movptr(Register Rd, uintptr_t imm64);\n-  void j(const address &dest, Register temp = t0);\n-  void j(const Address &adr, Register temp = t0);\n-  void j(Label &l, Register temp = t0);\n-  void jal(Label &l, Register temp = t0);\n-  void jal(const address &dest, Register temp = t0);\n-  void jal(const Address &adr, Register temp = t0);\n-  void jr(Register Rs);\n-  void jalr(Register Rs);\n-\n@@ -477,7 +435,1 @@\n-#define INSN_ENTRY_RELOC(result_type, header)                               \\\n-  result_type header {                                                      \\\n-    guarantee(rtype == relocInfo::internal_word_type,                       \\\n-              \"only internal_word_type relocs make sense here\");            \\\n-    relocate(InternalAddress(dest).rspec());\n-\n-  \/\/ Load\/store register (all modes)\n+\/\/ Load\/store register (all modes)\n@@ -507,56 +459,0 @@\n-#define INSN(NAME)                                                                                 \\\n-  void NAME(Register Rd, address dest) {                                                           \\\n-    assert_cond(dest != NULL);                                                                     \\\n-    int64_t distance = (dest - pc());                                                              \\\n-    if (is_offset_in_range(distance, 32)) {                                                        \\\n-      auipc(Rd, (int32_t)distance + 0x800);                                                        \\\n-      NAME(Rd, Rd, ((int32_t)distance << 20) >> 20);                                               \\\n-    } else {                                                                                       \\\n-      int32_t offset = 0;                                                                          \\\n-      movptr(Rd, dest, offset);                                                                    \\\n-      NAME(Rd, Rd, offset);                                                                        \\\n-    }                                                                                              \\\n-  }                                                                                                \\\n-  INSN_ENTRY_RELOC(void, NAME(Register Rd, address dest, relocInfo::relocType rtype))              \\\n-    NAME(Rd, dest);                                                                                \\\n-  }                                                                                                \\\n-  void NAME(Register Rd, const Address &adr, Register temp = t0) {                                 \\\n-    switch (adr.getMode()) {                                                                       \\\n-      case Address::literal: {                                                                     \\\n-        relocate(adr.rspec());                                                                     \\\n-        NAME(Rd, adr.target());                                                                    \\\n-        break;                                                                                     \\\n-      }                                                                                            \\\n-      case Address::base_plus_offset: {                                                            \\\n-        if (is_offset_in_range(adr.offset(), 12)) {                                                \\\n-          NAME(Rd, adr.base(), adr.offset());                                                      \\\n-        } else {                                                                                   \\\n-          int32_t offset = 0;                                                                      \\\n-          if (Rd == adr.base()) {                                                                  \\\n-            baseOffset32(temp, adr, offset);                                                       \\\n-            NAME(Rd, temp, offset);                                                                \\\n-          } else {                                                                                 \\\n-            baseOffset32(Rd, adr, offset);                                                         \\\n-            NAME(Rd, Rd, offset);                                                                  \\\n-          }                                                                                        \\\n-        }                                                                                          \\\n-        break;                                                                                     \\\n-      }                                                                                            \\\n-      default:                                                                                     \\\n-        ShouldNotReachHere();                                                                      \\\n-    }                                                                                              \\\n-  }                                                                                                \\\n-  void NAME(Register Rd, Label &L) {                                                               \\\n-    wrap_label(Rd, L, &Assembler::NAME);                                                           \\\n-  }\n-\n-  INSN(lb);\n-  INSN(lbu);\n-  INSN(lh);\n-  INSN(lhu);\n-  INSN(lw);\n-  INSN(lwu);\n-  INSN(ld);\n-\n-#undef INSN\n-\n@@ -581,42 +477,0 @@\n-#define INSN(NAME)                                                                                 \\\n-  void NAME(FloatRegister Rd, address dest, Register temp = t0) {                                  \\\n-    assert_cond(dest != NULL);                                                                     \\\n-    int64_t distance = (dest - pc());                                                              \\\n-    if (is_offset_in_range(distance, 32)) {                                                        \\\n-      auipc(temp, (int32_t)distance + 0x800);                                                      \\\n-      NAME(Rd, temp, ((int32_t)distance << 20) >> 20);                                             \\\n-    } else {                                                                                       \\\n-      int32_t offset = 0;                                                                          \\\n-      movptr(temp, dest, offset);                                                                  \\\n-      NAME(Rd, temp, offset);                                                                      \\\n-    }                                                                                              \\\n-  }                                                                                                \\\n-  INSN_ENTRY_RELOC(void, NAME(FloatRegister Rd, address dest, relocInfo::relocType rtype, Register temp = t0)) \\\n-    NAME(Rd, dest, temp);                                                                          \\\n-  }                                                                                                \\\n-  void NAME(FloatRegister Rd, const Address &adr, Register temp = t0) {                            \\\n-    switch (adr.getMode()) {                                                                       \\\n-      case Address::literal: {                                                                     \\\n-        relocate(adr.rspec());                                                                     \\\n-        NAME(Rd, adr.target(), temp);                                                              \\\n-        break;                                                                                     \\\n-      }                                                                                            \\\n-      case Address::base_plus_offset: {                                                            \\\n-        if (is_offset_in_range(adr.offset(), 12)) {                                                \\\n-          NAME(Rd, adr.base(), adr.offset());                                                      \\\n-        } else {                                                                                   \\\n-          int32_t offset = 0;                                                                      \\\n-          baseOffset32(temp, adr, offset);                                                         \\\n-          NAME(Rd, temp, offset);                                                                  \\\n-        }                                                                                          \\\n-        break;                                                                                     \\\n-      }                                                                                            \\\n-      default:                                                                                     \\\n-        ShouldNotReachHere();                                                                      \\\n-    }                                                                                              \\\n-  }\n-\n-  INSN(flw);\n-  INSN(fld);\n-#undef INSN\n-\n@@ -643,2 +497,2 @@\n-  INSN(beq, 0b1100011, 0b000);\n-  INSN(bne, 0b1100011, 0b001);\n+  INSN(beq,  0b1100011, 0b000);\n+  INSN(bne,  0b1100011, 0b001);\n@@ -652,34 +506,0 @@\n-#define INSN(NAME)                                                                                       \\\n-  void NAME(Register Rs1, Register Rs2, const address dest) {                                            \\\n-    assert_cond(dest != NULL);                                                                           \\\n-    int64_t offset = (dest - pc());                                                                      \\\n-    guarantee(is_imm_in_range(offset, 12, 1), \"offset is invalid.\");                                     \\\n-    NAME(Rs1, Rs2, offset);                                                                              \\\n-  }                                                                                                      \\\n-  INSN_ENTRY_RELOC(void, NAME(Register Rs1, Register Rs2, address dest, relocInfo::relocType rtype))     \\\n-    NAME(Rs1, Rs2, dest);                                                                                \\\n-  }\n-\n-  INSN(beq);\n-  INSN(bne);\n-  INSN(bge);\n-  INSN(bgeu);\n-  INSN(blt);\n-  INSN(bltu);\n-\n-#undef INSN\n-\n-#define INSN(NAME, NEG_INSN)                                                                \\\n-  void NAME(Register Rs1, Register Rs2, Label &L, bool is_far = false) {                    \\\n-    wrap_label(Rs1, Rs2, L, &Assembler::NAME, &Assembler::NEG_INSN, is_far);                \\\n-  }\n-\n-  INSN(beq,  bne);\n-  INSN(bne,  beq);\n-  INSN(blt,  bge);\n-  INSN(bge,  blt);\n-  INSN(bltu, bgeu);\n-  INSN(bgeu, bltu);\n-\n-#undef INSN\n-\n@@ -711,99 +531,0 @@\n-#define INSN(NAME, REGISTER)                                                                                \\\n-  INSN_ENTRY_RELOC(void, NAME(REGISTER Rs, address dest, relocInfo::relocType rtype, Register temp = t0))   \\\n-    NAME(Rs, dest, temp);                                                                                   \\\n-  }\n-\n-  INSN(sb,  Register);\n-  INSN(sh,  Register);\n-  INSN(sw,  Register);\n-  INSN(sd,  Register);\n-  INSN(fsw, FloatRegister);\n-  INSN(fsd, FloatRegister);\n-\n-#undef INSN\n-\n-#define INSN(NAME)                                                                                 \\\n-  void NAME(Register Rs, address dest, Register temp = t0) {                                       \\\n-    assert_cond(dest != NULL);                                                                     \\\n-    assert_different_registers(Rs, temp);                                                          \\\n-    int64_t distance = (dest - pc());                                                              \\\n-    if (is_offset_in_range(distance, 32)) {                                                        \\\n-      auipc(temp, (int32_t)distance + 0x800);                                                      \\\n-      NAME(Rs, temp, ((int32_t)distance << 20) >> 20);                                             \\\n-    } else {                                                                                       \\\n-      int32_t offset = 0;                                                                          \\\n-      movptr(temp, dest, offset);                                                                  \\\n-      NAME(Rs, temp, offset);                                                                      \\\n-    }                                                                                              \\\n-  }                                                                                                \\\n-  void NAME(Register Rs, const Address &adr, Register temp = t0) {                                 \\\n-    switch (adr.getMode()) {                                                                       \\\n-      case Address::literal: {                                                                     \\\n-        assert_different_registers(Rs, temp);                                                      \\\n-        relocate(adr.rspec());                                                                     \\\n-        NAME(Rs, adr.target(), temp);                                                              \\\n-        break;                                                                                     \\\n-      }                                                                                            \\\n-      case Address::base_plus_offset: {                                                            \\\n-        if (is_offset_in_range(adr.offset(), 12)) {                                                \\\n-          NAME(Rs, adr.base(), adr.offset());                                                      \\\n-        } else {                                                                                   \\\n-          int32_t offset= 0;                                                                       \\\n-          assert_different_registers(Rs, temp);                                                    \\\n-          baseOffset32(temp, adr, offset);                                                         \\\n-          NAME(Rs, temp, offset);                                                                  \\\n-        }                                                                                          \\\n-        break;                                                                                     \\\n-      }                                                                                            \\\n-      default:                                                                                     \\\n-        ShouldNotReachHere();                                                                      \\\n-    }                                                                                              \\\n-  }\n-\n-  INSN(sb);\n-  INSN(sh);\n-  INSN(sw);\n-  INSN(sd);\n-\n-#undef INSN\n-\n-#define INSN(NAME)                                                                                 \\\n-  void NAME(FloatRegister Rs, address dest, Register temp = t0) {                                  \\\n-    assert_cond(dest != NULL);                                                                     \\\n-    int64_t distance = (dest - pc());                                                              \\\n-    if (is_offset_in_range(distance, 32)) {                                                        \\\n-      auipc(temp, (int32_t)distance + 0x800);                                                      \\\n-      NAME(Rs, temp, ((int32_t)distance << 20) >> 20);                                             \\\n-    } else {                                                                                       \\\n-      int32_t offset = 0;                                                                          \\\n-      movptr(temp, dest, offset);                                                                  \\\n-      NAME(Rs, temp, offset);                                                                      \\\n-    }                                                                                              \\\n-  }                                                                                                \\\n-  void NAME(FloatRegister Rs, const Address &adr, Register temp = t0) {                            \\\n-    switch (adr.getMode()) {                                                                       \\\n-      case Address::literal: {                                                                     \\\n-        relocate(adr.rspec());                                                                     \\\n-        NAME(Rs, adr.target(), temp);                                                              \\\n-        break;                                                                                     \\\n-      }                                                                                            \\\n-      case Address::base_plus_offset: {                                                            \\\n-        if (is_offset_in_range(adr.offset(), 12)) {                                                \\\n-          NAME(Rs, adr.base(), adr.offset());                                                      \\\n-        } else {                                                                                   \\\n-          int32_t offset = 0;                                                                      \\\n-          baseOffset32(temp, adr, offset);                                                         \\\n-          NAME(Rs, temp, offset);                                                                  \\\n-        }                                                                                          \\\n-        break;                                                                                     \\\n-      }                                                                                            \\\n-      default:                                                                                     \\\n-        ShouldNotReachHere();                                                                      \\\n-    }                                                                                              \\\n-  }\n-\n-  INSN(fsw);\n-  INSN(fsd);\n-\n-#undef INSN\n-\n@@ -848,11 +569,11 @@\n-#define INSN(NAME, op)                                                                        \\\n-  void NAME(Register Rd, const int32_t offset) {                                              \\\n-    guarantee(is_imm_in_range(offset, 20, 1), \"offset is invalid.\");                          \\\n-    unsigned insn = 0;                                                                        \\\n-    patch((address)&insn, 6, 0, op);                                                          \\\n-    patch_reg((address)&insn, 7, Rd);                                                         \\\n-    patch((address)&insn, 19, 12, (uint32_t)((offset >> 12) & 0xff));                         \\\n-    patch((address)&insn, 20, (uint32_t)((offset >> 11) & 0x1));                              \\\n-    patch((address)&insn, 30, 21, (uint32_t)((offset >> 1) & 0x3ff));                         \\\n-    patch((address)&insn, 31, (uint32_t)((offset >> 20) & 0x1));                              \\\n-    emit(insn);                                                                               \\\n+#define INSN(NAME, op)                                                                \\\n+  void NAME(Register Rd, const int32_t offset) {                                      \\\n+    guarantee(is_imm_in_range(offset, 20, 1), \"offset is invalid.\");                  \\\n+    unsigned insn = 0;                                                                \\\n+    patch((address)&insn, 6, 0, op);                                                  \\\n+    patch_reg((address)&insn, 7, Rd);                                                 \\\n+    patch((address)&insn, 19, 12, (uint32_t)((offset >> 12) & 0xff));                 \\\n+    patch((address)&insn, 20, (uint32_t)((offset >> 11) & 0x1));                      \\\n+    patch((address)&insn, 30, 21, (uint32_t)((offset >> 1) & 0x3ff));                 \\\n+    patch((address)&insn, 31, (uint32_t)((offset >> 20) & 0x1));                      \\\n+    emit(insn);                                                                       \\\n@@ -865,35 +586,11 @@\n-#define INSN(NAME)                                                                            \\\n-  void NAME(Register Rd, const address dest, Register temp = t0) {                            \\\n-    assert_cond(dest != NULL);                                                                \\\n-    int64_t offset = dest - pc();                                                             \\\n-    if (is_imm_in_range(offset, 20, 1)) {                                                     \\\n-      NAME(Rd, offset);                                                                       \\\n-    } else {                                                                                  \\\n-      assert_different_registers(Rd, temp);                                                   \\\n-      int32_t off = 0;                                                                        \\\n-      movptr(temp, dest, off);                                                                \\\n-      jalr(Rd, temp, off);                                                                    \\\n-    }                                                                                         \\\n-  }                                                                                           \\\n-  void NAME(Register Rd, Label &L, Register temp = t0) {                                      \\\n-    assert_different_registers(Rd, temp);                                                     \\\n-    wrap_label(Rd, L, temp, &Assembler::NAME);                                                \\\n-  }\n-\n-  INSN(jal);\n-\n-#undef INSN\n-\n-#undef INSN_ENTRY_RELOC\n-\n-#define INSN(NAME, op, funct)                                                              \\\n-  void NAME(Register Rd, Register Rs, const int32_t offset) {                              \\\n-    guarantee(is_offset_in_range(offset, 12), \"offset is invalid.\");                       \\\n-    unsigned insn = 0;                                                                     \\\n-    patch((address)&insn, 6, 0, op);                                                       \\\n-    patch_reg((address)&insn, 7, Rd);                                                      \\\n-    patch((address)&insn, 14, 12, funct);                                                  \\\n-    patch_reg((address)&insn, 15, Rs);                                                     \\\n-    int32_t val = offset & 0xfff;                                                          \\\n-    patch((address)&insn, 31, 20, val);                                                    \\\n-    emit(insn);                                                                            \\\n+#define INSN(NAME, op, funct)                                                         \\\n+  void NAME(Register Rd, Register Rs, const int32_t offset) {                         \\\n+    guarantee(is_offset_in_range(offset, 12), \"offset is invalid.\");                  \\\n+    unsigned insn = 0;                                                                \\\n+    patch((address)&insn, 6, 0, op);                                                  \\\n+    patch_reg((address)&insn, 7, Rd);                                                 \\\n+    patch((address)&insn, 14, 12, funct);                                             \\\n+    patch_reg((address)&insn, 15, Rs);                                                \\\n+    int32_t val = offset & 0xfff;                                                     \\\n+    patch((address)&insn, 31, 20, val);                                               \\\n+    emit(insn);                                                                       \\\n@@ -1027,4 +724,4 @@\n-  INSN(fsqrt_s,   0b1010011, 0b00000, 0b0101100);\n-  INSN(fsqrt_d,   0b1010011, 0b00000, 0b0101101);\n-  INSN(fcvt_s_d,  0b1010011, 0b00001, 0b0100000);\n-  INSN(fcvt_d_s,  0b1010011, 0b00000, 0b0100001);\n+  INSN(fsqrt_s,  0b1010011, 0b00000, 0b0101100);\n+  INSN(fsqrt_d,  0b1010011, 0b00000, 0b0101101);\n+  INSN(fcvt_s_d, 0b1010011, 0b00001, 0b0100000);\n+  INSN(fcvt_d_s, 0b1010011, 0b00000, 0b0100001);\n@@ -2679,4 +2376,0 @@\n-  bool do_compress() const {\n-    return UseRVC && in_compressible_region();\n-  }\n-\n@@ -2722,0 +2415,4 @@\n+bool do_compress() const {\n+  return UseRVC && in_compressible_region();\n+}\n+\n@@ -2885,15 +2582,0 @@\n-\/\/ --------------------------\n-#define INSN(NAME)                                                                           \\\n-  void NAME(Register Rd, int64_t imm) {                                                      \\\n-    \/* li -> c.li *\/                                                                         \\\n-    if (do_compress() && (is_imm_in_range(imm, 6, 0) && Rd != x0)) {                         \\\n-      c_li(Rd, imm);                                                                         \\\n-      return;                                                                                \\\n-    }                                                                                        \\\n-    _li(Rd, imm);                                                                            \\\n-  }\n-\n-  INSN(li);\n-\n-#undef INSN\n-\n@@ -3011,18 +2693,4 @@\n-  void bgt(Register Rs, Register Rt, const address &dest);\n-  void ble(Register Rs, Register Rt, const address &dest);\n-  void bgtu(Register Rs, Register Rt, const address &dest);\n-  void bleu(Register Rs, Register Rt, const address &dest);\n-  void bgt(Register Rs, Register Rt, Label &l, bool is_far = false);\n-  void ble(Register Rs, Register Rt, Label &l, bool is_far = false);\n-  void bgtu(Register Rs, Register Rt, Label &l, bool is_far = false);\n-  void bleu(Register Rs, Register Rt, Label &l, bool is_far = false);\n-\n-  typedef void (Assembler::* jal_jalr_insn)(Register Rt, address dest);\n-  typedef void (Assembler::* load_insn_by_temp)(Register Rt, address dest, Register temp);\n-  typedef void (Assembler::* compare_and_branch_insn)(Register Rs1, Register Rs2, const address dest);\n-  typedef void (Assembler::* compare_and_branch_label_insn)(Register Rs1, Register Rs2, Label &L, bool is_far);\n-\n-  void wrap_label(Register r1, Register r2, Label &L, compare_and_branch_insn insn,\n-                  compare_and_branch_label_insn neg_insn, bool is_far);\n-  void wrap_label(Register r, Label &L, Register t, load_insn_by_temp insn);\n-  void wrap_label(Register r, Label &L, jal_jalr_insn insn);\n+#define INSN(NAME, REGISTER)                       \\\n+  void NAME(Register Rs) {                         \\\n+    jalr(REGISTER, Rs, 0);                         \\\n+  }\n@@ -3030,3 +2698,2 @@\n-  \/\/ Computational pseudo instructions\n-  void add(Register Rd, Register Rn, int64_t increment, Register temp = t0);\n-  void addw(Register Rd, Register Rn, int32_t increment, Register temp = t0);\n+  INSN(jr,   x0);\n+  INSN(jalr, x1);\n@@ -3034,2 +2701,1 @@\n-  void sub(Register Rd, Register Rn, int64_t decrement, Register temp = t0);\n-  void subw(Register Rd, Register Rn, int32_t decrement, Register temp = t0);\n+#undef INSN\n@@ -3039,3 +2705,2 @@\n-  void zext_w(Register Rd, Register Rs);\n-\n-  Assembler(CodeBuffer* code) : AbstractAssembler(code), _in_compressible_region(false) {\n+  void zext_w(Register Rd, Register Rs) {\n+    add_uw(Rd, Rs, zr);\n@@ -3058,0 +2723,3 @@\n+  Assembler(CodeBuffer* code) : AbstractAssembler(code), _in_compressible_region(false) {\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":45,"deletions":377,"binary":false,"changes":422,"status":"modified"},{"patch":"@@ -546,1 +546,1 @@\n-  void (Assembler::* insn)(Register Rt, const Address &adr, Register temp);\n+  void (MacroAssembler::* insn)(Register Rt, const Address &adr, Register temp);\n@@ -550,1 +550,1 @@\n-      insn = &Assembler::sd; break;\n+      insn = &MacroAssembler::sd; break;\n@@ -553,1 +553,1 @@\n-      insn = &Assembler::sd; break;\n+      insn = &MacroAssembler::sd; break;\n@@ -556,1 +556,1 @@\n-      insn = &Assembler::sd; break;\n+      insn = &MacroAssembler::sd; break;\n@@ -559,1 +559,1 @@\n-      insn = &Assembler::sw; break;\n+      insn = &MacroAssembler::sw; break;\n@@ -562,1 +562,1 @@\n-      insn = &Assembler::sw; break;\n+      insn = &MacroAssembler::sw; break;\n@@ -567,1 +567,1 @@\n-        insn = &Assembler::sw;\n+        insn = &MacroAssembler::sw;\n@@ -569,1 +569,1 @@\n-        insn = &Assembler::sd;\n+        insn = &MacroAssembler::sd;\n@@ -575,1 +575,1 @@\n-      insn = &Assembler::sh;\n+      insn = &MacroAssembler::sh;\n@@ -580,1 +580,1 @@\n-      insn = &Assembler::sb; break;\n+      insn = &MacroAssembler::sb; break;\n@@ -583,1 +583,1 @@\n-      insn = &Assembler::sd;  \/\/ unreachable\n+      insn = &MacroAssembler::sd;  \/\/ unreachable\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -44,2 +44,1 @@\n-                                  Register result)\n-{\n+                                  Register result) {\n@@ -378,8 +377,8 @@\n-  (c1_cond_branch_insn)&Assembler::beq,\n-  (c1_cond_branch_insn)&Assembler::bne,\n-  (c1_cond_branch_insn)&Assembler::blt,\n-  (c1_cond_branch_insn)&Assembler::ble,\n-  (c1_cond_branch_insn)&Assembler::bge,\n-  (c1_cond_branch_insn)&Assembler::bgt,\n-  (c1_cond_branch_insn)&Assembler::bleu, \/\/ lir_cond_belowEqual\n-  (c1_cond_branch_insn)&Assembler::bgeu  \/\/ lir_cond_aboveEqual\n+  (c1_cond_branch_insn)&MacroAssembler::beq,\n+  (c1_cond_branch_insn)&MacroAssembler::bne,\n+  (c1_cond_branch_insn)&MacroAssembler::blt,\n+  (c1_cond_branch_insn)&MacroAssembler::ble,\n+  (c1_cond_branch_insn)&MacroAssembler::bge,\n+  (c1_cond_branch_insn)&MacroAssembler::bgt,\n+  (c1_cond_branch_insn)&MacroAssembler::bleu, \/\/ lir_cond_belowEqual\n+  (c1_cond_branch_insn)&MacroAssembler::bgeu  \/\/ lir_cond_aboveEqual\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1210,2 +1210,2 @@\n-      lbu(tmp1, a1, 0);\n-      lbu(tmp2, a2, 0);\n+      lbu(tmp1, Address(a1, 0));\n+      lbu(tmp2, Address(a2, 0));\n@@ -1232,2 +1232,2 @@\n-  (conditional_branch_insn)&Assembler::beq,\n-  (conditional_branch_insn)&Assembler::bgt,\n+  (conditional_branch_insn)&MacroAssembler::beq,\n+  (conditional_branch_insn)&MacroAssembler::bgt,\n@@ -1235,3 +1235,3 @@\n-  (conditional_branch_insn)&Assembler::blt,\n-  (conditional_branch_insn)&Assembler::bne,\n-  (conditional_branch_insn)&Assembler::ble,\n+  (conditional_branch_insn)&MacroAssembler::blt,\n+  (conditional_branch_insn)&MacroAssembler::bne,\n+  (conditional_branch_insn)&MacroAssembler::ble,\n@@ -1239,1 +1239,1 @@\n-  (conditional_branch_insn)&Assembler::bge,\n+  (conditional_branch_insn)&MacroAssembler::bge,\n@@ -1242,2 +1242,2 @@\n-  (conditional_branch_insn)&Assembler::beq,\n-  (conditional_branch_insn)&Assembler::bgtu,\n+  (conditional_branch_insn)&MacroAssembler::beq,\n+  (conditional_branch_insn)&MacroAssembler::bgtu,\n@@ -1245,3 +1245,3 @@\n-  (conditional_branch_insn)&Assembler::bltu,\n-  (conditional_branch_insn)&Assembler::bne,\n-  (conditional_branch_insn)&Assembler::bleu,\n+  (conditional_branch_insn)&MacroAssembler::bltu,\n+  (conditional_branch_insn)&MacroAssembler::bne,\n+  (conditional_branch_insn)&MacroAssembler::bleu,\n@@ -1249,1 +1249,1 @@\n-  (conditional_branch_insn)&Assembler::bgeu\n+  (conditional_branch_insn)&MacroAssembler::bgeu\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -371,1 +371,1 @@\n-  flw(r, esp, 0);\n+  flw(r, Address(esp, 0));\n@@ -376,1 +376,1 @@\n-  fld(r, esp, 0);\n+  fld(r, Address(esp, 0));\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -722,1 +722,28 @@\n-void MacroAssembler::la(Register Rd, const address &dest) {\n+void MacroAssembler::baseOffset32(Register Rd, const Address &adr, int32_t &offset) {\n+  assert(Rd != noreg, \"Rd must not be empty register!\");\n+  guarantee(Rd != adr.base(), \"should use different registers!\");\n+  if (is_offset_in_range(adr.offset(), 32)) {\n+    int32_t imm = adr.offset();\n+    int32_t upper = imm, lower = imm;\n+    lower = (imm << 20) >> 20;\n+    upper -= lower;\n+    lui(Rd, upper);\n+    offset = lower;\n+  } else {\n+    offset = ((int32_t)adr.offset() << 20) >> 20;\n+    li(Rd, adr.offset() - offset);\n+  }\n+  add(Rd, Rd, adr.base());\n+}\n+\n+void MacroAssembler::baseOffset(Register Rd, const Address &adr, int32_t &offset) {\n+  if (is_offset_in_range(adr.offset(), 12)) {\n+    assert(Rd != noreg, \"Rd must not be empty register!\");\n+    addi(Rd, adr.base(), adr.offset());\n+    offset = 0;\n+  } else {\n+    baseOffset32(Rd, adr, offset);\n+  }\n+}\n+\n+void MacroAssembler::la(Register Rd, const address dest) {\n@@ -760,0 +787,202 @@\n+void MacroAssembler::li32(Register Rd, int32_t imm) {\n+  \/\/ int32_t is in range 0x8000 0000 ~ 0x7fff ffff, and imm[31] is the sign bit\n+  int64_t upper = imm, lower = imm;\n+  lower = (imm << 20) >> 20;\n+  upper -= lower;\n+  upper = (int32_t)upper;\n+  \/\/ lui Rd, imm[31:12] + imm[11]\n+  lui(Rd, upper);\n+  \/\/ use addiw to distinguish li32 to li64\n+  addiw(Rd, Rd, lower);\n+}\n+\n+void MacroAssembler::li64(Register Rd, int64_t imm) {\n+  \/\/ Load upper 32 bits. upper = imm[63:32], but if imm[31] == 1 or\n+  \/\/ (imm[31:20] == 0x7ff && imm[19] == 1), upper = imm[63:32] + 1.\n+  int64_t lower = imm & 0xffffffff;\n+  lower -= ((lower << 44) >> 44);\n+  int64_t tmp_imm = ((uint64_t)(imm & 0xffffffff00000000)) + (uint64_t)lower;\n+  int32_t upper = (tmp_imm - (int32_t)lower) >> 32;\n+\n+  \/\/ Load upper 32 bits\n+  int64_t up = upper, lo = upper;\n+  lo = (lo << 52) >> 52;\n+  up -= lo;\n+  up = (int32_t)up;\n+  lui(Rd, up);\n+  addi(Rd, Rd, lo);\n+\n+  \/\/ Load the rest 32 bits.\n+  slli(Rd, Rd, 12);\n+  addi(Rd, Rd, (int32_t)lower >> 20);\n+  slli(Rd, Rd, 12);\n+  lower = ((int32_t)imm << 12) >> 20;\n+  addi(Rd, Rd, lower);\n+  slli(Rd, Rd, 8);\n+  lower = imm & 0xff;\n+  addi(Rd, Rd, lower);\n+}\n+\n+void MacroAssembler::li(Register Rd, int64_t imm) {\n+  \/\/ int64_t is in range 0x8000 0000 0000 0000 ~ 0x7fff ffff ffff ffff\n+  \/\/ li -> c.li\n+  if (do_compress() && (is_imm_in_range(imm, 6, 0) && Rd != x0)) {\n+    c_li(Rd, imm);\n+    return;\n+  }\n+\n+  int shift = 12;\n+  int64_t upper = imm, lower = imm;\n+  \/\/ Split imm to a lower 12-bit sign-extended part and the remainder,\n+  \/\/ because addi will sign-extend the lower imm.\n+  lower = ((int32_t)imm << 20) >> 20;\n+  upper -= lower;\n+\n+  \/\/ Test whether imm is a 32-bit integer.\n+  if (!(((imm) & ~(int64_t)0x7fffffff) == 0 ||\n+        (((imm) & ~(int64_t)0x7fffffff) == ~(int64_t)0x7fffffff))) {\n+    while (((upper >> shift) & 1) == 0) { shift++; }\n+    upper >>= shift;\n+    li(Rd, upper);\n+    slli(Rd, Rd, shift);\n+    if (lower != 0) {\n+      addi(Rd, Rd, lower);\n+    }\n+  } else {\n+    \/\/ 32-bit integer\n+    Register hi_Rd = zr;\n+    if (upper != 0) {\n+      lui(Rd, (int32_t)upper);\n+      hi_Rd = Rd;\n+    }\n+    if (lower != 0 || hi_Rd == zr) {\n+      addiw(Rd, hi_Rd, lower);\n+    }\n+  }\n+}\n+\n+#define INSN(NAME, REGISTER)                                       \\\n+  void MacroAssembler::NAME(const address dest, Register temp) {   \\\n+    assert_cond(dest != NULL);                                     \\\n+    int64_t offset = dest - pc();                                  \\\n+    if (is_imm_in_range(offset, 20, 1)) {                          \\\n+      Assembler::jal(REGISTER, offset);                            \\\n+    } else {                                                       \\\n+      assert(temp != noreg, \"temp must not be empty register!\");   \\\n+      int32_t offset = 0;                                          \\\n+      movptr(temp, dest, offset);                                  \\\n+      Assembler::jalr(REGISTER, temp, offset);                     \\\n+    }                                                              \\\n+  }                                                                \\\n+\n+  INSN(j,   x0);\n+  INSN(jal, x1);\n+\n+#undef INSN\n+\n+#define INSN(NAME, REGISTER)                                       \\\n+  void MacroAssembler::NAME(const Address &adr, Register temp) {   \\\n+    switch (adr.getMode()) {                                       \\\n+      case Address::literal: {                                     \\\n+        relocate(adr.rspec());                                     \\\n+        NAME(adr.target(), temp);                                  \\\n+        break;                                                     \\\n+      }                                                            \\\n+      case Address::base_plus_offset: {                            \\\n+        int32_t offset = 0;                                        \\\n+        baseOffset(temp, adr, offset);                             \\\n+        Assembler::jalr(REGISTER, temp, offset);                   \\\n+        break;                                                     \\\n+      }                                                            \\\n+      default:                                                     \\\n+        ShouldNotReachHere();                                      \\\n+    }                                                              \\\n+  }\n+\n+  INSN(j,   x0);\n+  INSN(jal, x1);\n+\n+#undef INSN\n+\n+#define INSN(NAME)                                                                    \\\n+  void MacroAssembler::NAME(Register Rd, const address dest, Register temp) {         \\\n+    assert_cond(dest != NULL);                                                        \\\n+    int64_t offset = dest - pc();                                                     \\\n+    if (is_imm_in_range(offset, 20, 1)) {                                             \\\n+      Assembler::NAME(Rd, offset);                                                    \\\n+    } else {                                                                          \\\n+      assert_different_registers(Rd, temp);                                           \\\n+      int32_t off = 0;                                                                \\\n+      movptr(temp, dest, off);                                                        \\\n+      jalr(Rd, temp, off);                                                            \\\n+    }                                                                                 \\\n+  }                                                                                   \\\n+  void MacroAssembler::NAME(Register Rd, Label &L, Register temp) {                   \\\n+    assert_different_registers(Rd, temp);                                             \\\n+    wrap_label(Rd, L, temp, &MacroAssembler::NAME);                                   \\\n+  }\n+\n+  INSN(jal);\n+\n+#undef INSN\n+\n+#define INSN(NAME, REGISTER)                                       \\\n+  void MacroAssembler::NAME(Label &l, Register temp) {             \\\n+    jal(REGISTER, l, temp);                                        \\\n+  }                                                                \\\n+\n+  INSN(j,   x0);\n+  INSN(jal, x1);\n+\n+#undef INSN\n+\n+void MacroAssembler::wrap_label(Register Rt, Label &L, Register tmp, load_insn_by_temp insn) {\n+  if (L.is_bound()) {\n+    (this->*insn)(Rt, target(L), tmp);\n+  } else {\n+    L.add_patch_at(code(), locator());\n+    (this->*insn)(Rt, pc(), tmp);\n+  }\n+}\n+\n+void MacroAssembler::wrap_label(Register Rt, Label &L, jal_jalr_insn insn) {\n+  if (L.is_bound()) {\n+    (this->*insn)(Rt, target(L));\n+  } else {\n+    L.add_patch_at(code(), locator());\n+    (this->*insn)(Rt, pc());\n+  }\n+}\n+\n+void MacroAssembler::wrap_label(Register r1, Register r2, Label &L,\n+                                compare_and_branch_insn insn,\n+                                compare_and_branch_label_insn neg_insn, bool is_far) {\n+  if (is_far) {\n+    Label done;\n+    (this->*neg_insn)(r1, r2, done, \/* is_far *\/ false);\n+    j(L);\n+    bind(done);\n+  } else {\n+    if (L.is_bound()) {\n+      (this->*insn)(r1, r2, target(L));\n+    } else {\n+      L.add_patch_at(code(), locator());\n+      (this->*insn)(r1, r2, pc());\n+    }\n+  }\n+}\n+\n+#define INSN(NAME, NEG_INSN)                                                              \\\n+  void MacroAssembler::NAME(Register Rs1, Register Rs2, Label &L, bool is_far) {          \\\n+    wrap_label(Rs1, Rs2, L, &MacroAssembler::NAME, &MacroAssembler::NEG_INSN, is_far);    \\\n+  }\n+\n+  INSN(beq,  bne);\n+  INSN(bne,  beq);\n+  INSN(blt,  bge);\n+  INSN(bge,  blt);\n+  INSN(bltu, bgeu);\n+  INSN(bgeu, bltu);\n+\n+#undef INSN\n+\n@@ -761,1 +990,1 @@\n-  void MacroAssembler::NAME##z(Register Rs, const address &dest) {                \\\n+  void MacroAssembler::NAME##z(Register Rs, const address dest) {                 \\\n@@ -777,0 +1006,15 @@\n+#define INSN(NAME, NEG_INSN)                                                      \\\n+  void MacroAssembler::NAME(Register Rs, Register Rt, const address dest) {       \\\n+    NEG_INSN(Rt, Rs, dest);                                                       \\\n+  }                                                                               \\\n+  void MacroAssembler::NAME(Register Rs, Register Rt, Label &l, bool is_far) {    \\\n+    NEG_INSN(Rt, Rs, l, is_far);                                                  \\\n+  }\n+\n+  INSN(bgt,  blt);\n+  INSN(ble,  bge);\n+  INSN(bgtu, bltu);\n+  INSN(bleu, bgeu);\n+\n+#undef INSN\n+\n@@ -779,8 +1023,8 @@\n-#define INSN(NAME, FLOATCMP, BRANCH)                                                                                   \\\n-  void MacroAssembler::float_##NAME(FloatRegister Rs1, FloatRegister Rs2, Label &l, bool is_far, bool is_unordered) {  \\\n-    FLOATCMP##_s(t0, Rs1, Rs2);                                                                                        \\\n-    BRANCH(t0, l, is_far);                                                                                             \\\n-  }                                                                                                                    \\\n-  void MacroAssembler::double_##NAME(FloatRegister Rs1, FloatRegister Rs2, Label &l, bool is_far, bool is_unordered) { \\\n-    FLOATCMP##_d(t0, Rs1, Rs2);                                                                                        \\\n-    BRANCH(t0, l, is_far);                                                                                             \\\n+#define INSN(NAME, FLOATCMP, BRANCH)                                                                                    \\\n+  void MacroAssembler::float_##NAME(FloatRegister Rs1, FloatRegister Rs2, Label &l, bool is_far, bool is_unordered) {   \\\n+    FLOATCMP##_s(t0, Rs1, Rs2);                                                                                         \\\n+    BRANCH(t0, l, is_far);                                                                                              \\\n+  }                                                                                                                     \\\n+  void MacroAssembler::double_##NAME(FloatRegister Rs1, FloatRegister Rs2, Label &l, bool is_far, bool is_unordered) {  \\\n+    FLOATCMP##_d(t0, Rs1, Rs2);                                                                                         \\\n+    BRANCH(t0, l, is_far);                                                                                              \\\n@@ -931,1 +1175,1 @@\n-  ld(Rd, esp, 0);\n+  ld(Rd, Address(esp, 0));\n@@ -1364,0 +1608,79 @@\n+void MacroAssembler::movptr(Register Rd, address addr, int32_t &offset) {\n+  int64_t imm64 = (int64_t)addr;\n+#ifndef PRODUCT\n+  {\n+    char buffer[64];\n+    snprintf(buffer, sizeof(buffer), \"0x%\" PRIx64, imm64);\n+    block_comment(buffer);\n+  }\n+#endif\n+  assert(is_unsigned_imm_in_range(imm64, 47, 0) || (imm64 == (int64_t)-1),\n+         \"bit 47 overflows in address constant\");\n+  \/\/ Load upper 31 bits\n+  int64_t imm = imm64 >> 17;\n+  int64_t upper = imm, lower = imm;\n+  lower = (lower << 52) >> 52;\n+  upper -= lower;\n+  upper = (int32_t)upper;\n+  lui(Rd, upper);\n+  addi(Rd, Rd, lower);\n+\n+  \/\/ Load the rest 17 bits.\n+  slli(Rd, Rd, 11);\n+  addi(Rd, Rd, (imm64 >> 6) & 0x7ff);\n+  slli(Rd, Rd, 6);\n+\n+  \/\/ This offset will be used by following jalr\/ld.\n+  offset = imm64 & 0x3f;\n+}\n+\n+void MacroAssembler::movptr(Register Rd, uintptr_t imm64) {\n+  movptr(Rd, (address)imm64);\n+}\n+\n+void MacroAssembler::movptr(Register Rd, address addr) {\n+  int offset = 0;\n+  movptr(Rd, addr, offset);\n+  addi(Rd, Rd, offset);\n+}\n+\n+void MacroAssembler::add(Register Rd, Register Rn, int64_t increment, Register temp) {\n+  if (is_imm_in_range(increment, 12, 0)) {\n+    addi(Rd, Rn, increment);\n+  } else {\n+    assert_different_registers(Rn, temp);\n+    li(temp, increment);\n+    add(Rd, Rn, temp);\n+  }\n+}\n+\n+void MacroAssembler::addw(Register Rd, Register Rn, int32_t increment, Register temp) {\n+  if (is_imm_in_range(increment, 12, 0)) {\n+    addiw(Rd, Rn, increment);\n+  } else {\n+    assert_different_registers(Rn, temp);\n+    li(temp, increment);\n+    addw(Rd, Rn, temp);\n+  }\n+}\n+\n+void MacroAssembler::sub(Register Rd, Register Rn, int64_t decrement, Register temp) {\n+  if (is_imm_in_range(-decrement, 12, 0)) {\n+    addi(Rd, Rn, -decrement);\n+  } else {\n+    assert_different_registers(Rn, temp);\n+    li(temp, decrement);\n+    sub(Rd, Rn, temp);\n+  }\n+}\n+\n+void MacroAssembler::subw(Register Rd, Register Rn, int32_t decrement, Register temp) {\n+  if (is_imm_in_range(-decrement, 12, 0)) {\n+    addiw(Rd, Rn, -decrement);\n+  } else {\n+    assert_different_registers(Rn, temp);\n+    li(temp, decrement);\n+    subw(Rd, Rn, temp);\n+  }\n+}\n+\n@@ -3861,1 +4184,1 @@\n-    Assembler::sd(zr, Address(tmp, i * wordSize));\n+    sd(zr, Address(tmp, i * wordSize));\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":335,"deletions":12,"binary":false,"changes":347,"status":"modified"},{"patch":"@@ -404,1 +404,1 @@\n-  \/\/ Standard pseudoinstruction\n+  \/\/ Standard pseudo instructions\n@@ -417,1 +417,1 @@\n-  \/\/ Float pseudoinstruction\n+  \/\/ Float pseudo instructions\n@@ -422,1 +422,1 @@\n-  \/\/ Double pseudoinstruction\n+  \/\/ Double pseudo instructions\n@@ -427,1 +427,1 @@\n-  \/\/ Pseudoinstruction for control and status register\n+  \/\/ Control pseudo instructions\n@@ -452,9 +452,16 @@\n-  void beqz(Register Rs, const address &dest);\n-  void bnez(Register Rs, const address &dest);\n-  void blez(Register Rs, const address &dest);\n-  void bgez(Register Rs, const address &dest);\n-  void bltz(Register Rs, const address &dest);\n-  void bgtz(Register Rs, const address &dest);\n-  void la(Register Rd, Label &label);\n-  void la(Register Rd, const address &dest);\n-  void la(Register Rd, const Address &adr);\n+  void beqz(Register Rs, const address dest);\n+  void bnez(Register Rs, const address dest);\n+  void blez(Register Rs, const address dest);\n+  void bgez(Register Rs, const address dest);\n+  void bltz(Register Rs, const address dest);\n+  void bgtz(Register Rs, const address dest);\n+\n+  void j(Label &l, Register temp = t0);\n+  void j(const address dest, Register temp = t0);\n+  void j(const Address &adr, Register temp = t0);\n+  void jal(Label &l, Register temp = t0);\n+  void jal(const address dest, Register temp = t0);\n+  void jal(const Address &adr, Register temp = t0);\n+  void jal(Register Rd, Label &L, Register temp = t0);\n+  void jal(Register Rd, const address dest, Register temp = t0);\n+\n@@ -468,0 +475,46 @@\n+\n+  void beq(Register Rs1, Register Rs2, Label &L, bool is_far = false);\n+  void bne(Register Rs1, Register Rs2, Label &L, bool is_far = false);\n+  void blt(Register Rs1, Register Rs2, Label &L, bool is_far = false);\n+  void bge(Register Rs1, Register Rs2, Label &L, bool is_far = false);\n+  void bltu(Register Rs1, Register Rs2, Label &L, bool is_far = false);\n+  void bgeu(Register Rs1, Register Rs2, Label &L, bool is_far = false);\n+\n+  void bgt(Register Rs, Register Rt, const address dest);\n+  void ble(Register Rs, Register Rt, const address dest);\n+  void bgtu(Register Rs, Register Rt, const address dest);\n+  void bleu(Register Rs, Register Rt, const address dest);\n+\n+  void bgt(Register Rs, Register Rt, Label &l, bool is_far = false);\n+  void ble(Register Rs, Register Rt, Label &l, bool is_far = false);\n+  void bgtu(Register Rs, Register Rt, Label &l, bool is_far = false);\n+  void bleu(Register Rs, Register Rt, Label &l, bool is_far = false);\n+\n+#define INSN_ENTRY_RELOC(result_type, header)                               \\\n+  result_type header {                                                      \\\n+    guarantee(rtype == relocInfo::internal_word_type,                       \\\n+              \"only internal_word_type relocs make sense here\");            \\\n+    relocate(InternalAddress(dest).rspec());\n+\n+#define INSN(NAME)                                                                                       \\\n+  void NAME(Register Rs1, Register Rs2, const address dest) {                                            \\\n+    assert_cond(dest != NULL);                                                                           \\\n+    int64_t offset = dest - pc();                                                                        \\\n+    guarantee(is_imm_in_range(offset, 12, 1), \"offset is invalid.\");                                     \\\n+    Assembler::NAME(Rs1, Rs2, offset);                                                                   \\\n+  }                                                                                                      \\\n+  INSN_ENTRY_RELOC(void, NAME(Register Rs1, Register Rs2, address dest, relocInfo::relocType rtype))     \\\n+    NAME(Rs1, Rs2, dest);                                                                                \\\n+  }\n+\n+  INSN(beq);\n+  INSN(bne);\n+  INSN(bge);\n+  INSN(bgeu);\n+  INSN(blt);\n+  INSN(bltu);\n+\n+#undef INSN\n+\n+#undef INSN_ENTRY_RELOC\n+\n@@ -474,0 +527,1 @@\n+\n@@ -529,0 +583,22 @@\n+  typedef void (MacroAssembler::* compare_and_branch_insn)(Register Rs1, Register Rs2, const address dest);\n+  typedef void (MacroAssembler::* compare_and_branch_label_insn)(Register Rs1, Register Rs2, Label &L, bool is_far);\n+  typedef void (MacroAssembler::* jal_jalr_insn)(Register Rt, address dest);\n+  typedef void (MacroAssembler::* load_insn_by_temp)(Register Rt, address dest, Register temp);\n+\n+  void wrap_label(Register r, Label &L, Register t, load_insn_by_temp insn);\n+  void wrap_label(Register r, Label &L, jal_jalr_insn insn);\n+  void wrap_label(Register r1, Register r2, Label &L,\n+                  compare_and_branch_insn insn,\n+                  compare_and_branch_label_insn neg_insn, bool is_far = false);\n+\n+  void baseOffset(Register Rd, const Address &adr, int32_t &offset);\n+  void baseOffset32(Register Rd, const Address &adr, int32_t &offset);\n+\n+  void la(Register Rd, Label &label);\n+  void la(Register Rd, const address dest);\n+  void la(Register Rd, const Address &adr);\n+\n+  void li32(Register Rd, int32_t imm);\n+  void li64(Register Rd, int64_t imm);\n+  void li(Register Rd, int64_t imm);  \/\/ optimized load immediate\n+\n@@ -546,0 +622,22 @@\n+  void movptr(Register Rd, address addr);\n+  void movptr(Register Rd, address addr, int32_t &offset);\n+  void movptr(Register Rd, uintptr_t imm64);\n+\n+  \/\/ arith\n+  void add (Register Rd, Register Rn, int64_t increment, Register temp = t0);\n+  void addw(Register Rd, Register Rn, int32_t increment, Register temp = t0);\n+  void sub (Register Rd, Register Rn, int64_t decrement, Register temp = t0);\n+  void subw(Register Rd, Register Rn, int32_t decrement, Register temp = t0);\n+\n+#define INSN(NAME)                                               \\\n+  inline void NAME(Register Rd, Register Rs1, Register Rs2) {    \\\n+    Assembler::NAME(Rd, Rs1, Rs2);                               \\\n+  }\n+\n+  INSN(add);\n+  INSN(addw);\n+  INSN(sub);\n+  INSN(subw);\n+\n+#undef INSN\n+\n@@ -565,0 +663,209 @@\n+\/\/ Load and Store Instructions\n+#define INSN_ENTRY_RELOC(result_type, header)                               \\\n+  result_type header {                                                      \\\n+    guarantee(rtype == relocInfo::internal_word_type,                       \\\n+              \"only internal_word_type relocs make sense here\");            \\\n+    relocate(InternalAddress(dest).rspec());\n+\n+#define INSN(NAME)                                                                                 \\\n+  void NAME(Register Rd, address dest) {                                                           \\\n+    assert_cond(dest != NULL);                                                                     \\\n+    int64_t offset = dest - pc();                                                                  \\\n+    if (is_offset_in_range(offset, 32)) {                                                          \\\n+      auipc(Rd, (int32_t)offset + 0x800);                                                          \\\n+      Assembler::NAME(Rd, Rd, ((int32_t)offset << 20) >> 20);                                      \\\n+    } else {                                                                                       \\\n+      int32_t offset = 0;                                                                          \\\n+      movptr(Rd, dest, offset);                                                                    \\\n+      Assembler::NAME(Rd, Rd, offset);                                                             \\\n+    }                                                                                              \\\n+  }                                                                                                \\\n+  INSN_ENTRY_RELOC(void, NAME(Register Rd, address dest, relocInfo::relocType rtype))              \\\n+    NAME(Rd, dest);                                                                                \\\n+  }                                                                                                \\\n+  void NAME(Register Rd, const Address &adr, Register temp = t0) {                                 \\\n+    switch (adr.getMode()) {                                                                       \\\n+      case Address::literal: {                                                                     \\\n+        relocate(adr.rspec());                                                                     \\\n+        NAME(Rd, adr.target());                                                                    \\\n+        break;                                                                                     \\\n+      }                                                                                            \\\n+      case Address::base_plus_offset: {                                                            \\\n+        if (is_offset_in_range(adr.offset(), 12)) {                                                \\\n+          Assembler::NAME(Rd, adr.base(), adr.offset());                                           \\\n+        } else {                                                                                   \\\n+          int32_t offset = 0;                                                                      \\\n+          if (Rd == adr.base()) {                                                                  \\\n+            baseOffset32(temp, adr, offset);                                                       \\\n+            Assembler::NAME(Rd, temp, offset);                                                     \\\n+          } else {                                                                                 \\\n+            baseOffset32(Rd, adr, offset);                                                         \\\n+            Assembler::NAME(Rd, Rd, offset);                                                       \\\n+          }                                                                                        \\\n+        }                                                                                          \\\n+        break;                                                                                     \\\n+      }                                                                                            \\\n+      default:                                                                                     \\\n+        ShouldNotReachHere();                                                                      \\\n+    }                                                                                              \\\n+  }                                                                                                \\\n+  void NAME(Register Rd, Label &L) {                                                               \\\n+    wrap_label(Rd, L, &MacroAssembler::NAME);                                                      \\\n+  }\n+\n+  INSN(lb);\n+  INSN(lbu);\n+  INSN(lh);\n+  INSN(lhu);\n+  INSN(lw);\n+  INSN(lwu);\n+  INSN(ld);\n+\n+#undef INSN\n+\n+#define INSN(NAME)                                                                                 \\\n+  void NAME(FloatRegister Rd, address dest, Register temp = t0) {                                  \\\n+    assert_cond(dest != NULL);                                                                     \\\n+    int64_t offset = dest - pc();                                                                  \\\n+    if (is_offset_in_range(offset, 32)) {                                                          \\\n+      auipc(temp, (int32_t)offset + 0x800);                                                        \\\n+      Assembler::NAME(Rd, temp, ((int32_t)offset << 20) >> 20);                                    \\\n+    } else {                                                                                       \\\n+      int32_t offset = 0;                                                                          \\\n+      movptr(temp, dest, offset);                                                                  \\\n+      Assembler::NAME(Rd, temp, offset);                                                           \\\n+    }                                                                                              \\\n+  }                                                                                                \\\n+  INSN_ENTRY_RELOC(void, NAME(FloatRegister Rd, address dest,                                      \\\n+                              relocInfo::relocType rtype, Register temp = t0))                     \\\n+    NAME(Rd, dest, temp);                                                                          \\\n+  }                                                                                                \\\n+  void NAME(FloatRegister Rd, const Address &adr, Register temp = t0) {                            \\\n+    switch (adr.getMode()) {                                                                       \\\n+      case Address::literal: {                                                                     \\\n+        relocate(adr.rspec());                                                                     \\\n+        NAME(Rd, adr.target(), temp);                                                              \\\n+        break;                                                                                     \\\n+      }                                                                                            \\\n+      case Address::base_plus_offset: {                                                            \\\n+        if (is_offset_in_range(adr.offset(), 12)) {                                                \\\n+          Assembler::NAME(Rd, adr.base(), adr.offset());                                           \\\n+        } else {                                                                                   \\\n+          int32_t offset = 0;                                                                      \\\n+          baseOffset32(temp, adr, offset);                                                         \\\n+          Assembler::NAME(Rd, temp, offset);                                                       \\\n+        }                                                                                          \\\n+        break;                                                                                     \\\n+      }                                                                                            \\\n+      default:                                                                                     \\\n+        ShouldNotReachHere();                                                                      \\\n+    }                                                                                              \\\n+  }\n+\n+  INSN(flw);\n+  INSN(fld);\n+\n+#undef INSN\n+\n+#define INSN(NAME, REGISTER)                                                                       \\\n+  INSN_ENTRY_RELOC(void, NAME(REGISTER Rs, address dest,                                           \\\n+                              relocInfo::relocType rtype, Register temp = t0))                     \\\n+    NAME(Rs, dest, temp);                                                                          \\\n+  }\n+\n+  INSN(sb,  Register);\n+  INSN(sh,  Register);\n+  INSN(sw,  Register);\n+  INSN(sd,  Register);\n+  INSN(fsw, FloatRegister);\n+  INSN(fsd, FloatRegister);\n+\n+#undef INSN\n+\n+#define INSN(NAME)                                                                                 \\\n+  void NAME(Register Rs, address dest, Register temp = t0) {                                       \\\n+    assert_cond(dest != NULL);                                                                     \\\n+    assert_different_registers(Rs, temp);                                                          \\\n+    int64_t offset = dest - pc();                                                                  \\\n+    if (is_offset_in_range(offset, 32)) {                                                          \\\n+      auipc(temp, (int32_t)offset + 0x800);                                                        \\\n+      Assembler::NAME(Rs, temp, ((int32_t)offset << 20) >> 20);                                    \\\n+    } else {                                                                                       \\\n+      int32_t offset = 0;                                                                          \\\n+      movptr(temp, dest, offset);                                                                  \\\n+      Assembler::NAME(Rs, temp, offset);                                                           \\\n+    }                                                                                              \\\n+  }                                                                                                \\\n+  void NAME(Register Rs, const Address &adr, Register temp = t0) {                                 \\\n+    switch (adr.getMode()) {                                                                       \\\n+      case Address::literal: {                                                                     \\\n+        assert_different_registers(Rs, temp);                                                      \\\n+        relocate(adr.rspec());                                                                     \\\n+        NAME(Rs, adr.target(), temp);                                                              \\\n+        break;                                                                                     \\\n+      }                                                                                            \\\n+      case Address::base_plus_offset: {                                                            \\\n+        if (is_offset_in_range(adr.offset(), 12)) {                                                \\\n+          Assembler::NAME(Rs, adr.base(), adr.offset());                                           \\\n+        } else {                                                                                   \\\n+          int32_t offset= 0;                                                                       \\\n+          assert_different_registers(Rs, temp);                                                    \\\n+          baseOffset32(temp, adr, offset);                                                         \\\n+          Assembler::NAME(Rs, temp, offset);                                                       \\\n+        }                                                                                          \\\n+        break;                                                                                     \\\n+      }                                                                                            \\\n+      default:                                                                                     \\\n+        ShouldNotReachHere();                                                                      \\\n+    }                                                                                              \\\n+  }\n+\n+  INSN(sb);\n+  INSN(sh);\n+  INSN(sw);\n+  INSN(sd);\n+\n+#undef INSN\n+\n+#define INSN(NAME)                                                                                 \\\n+  void NAME(FloatRegister Rs, address dest, Register temp = t0) {                                  \\\n+    assert_cond(dest != NULL);                                                                     \\\n+    int64_t offset = dest - pc();                                                                  \\\n+    if (is_offset_in_range(offset, 32)) {                                                          \\\n+      auipc(temp, (int32_t)offset + 0x800);                                                        \\\n+      Assembler::NAME(Rs, temp, ((int32_t)offset << 20) >> 20);                                    \\\n+    } else {                                                                                       \\\n+      int32_t offset = 0;                                                                          \\\n+      movptr(temp, dest, offset);                                                                  \\\n+      Assembler::NAME(Rs, temp, offset);                                                           \\\n+    }                                                                                              \\\n+  }                                                                                                \\\n+  void NAME(FloatRegister Rs, const Address &adr, Register temp = t0) {                            \\\n+    switch (adr.getMode()) {                                                                       \\\n+      case Address::literal: {                                                                     \\\n+        relocate(adr.rspec());                                                                     \\\n+        NAME(Rs, adr.target(), temp);                                                              \\\n+        break;                                                                                     \\\n+      }                                                                                            \\\n+      case Address::base_plus_offset: {                                                            \\\n+        if (is_offset_in_range(adr.offset(), 12)) {                                                \\\n+          Assembler::NAME(Rs, adr.base(), adr.offset());                                           \\\n+        } else {                                                                                   \\\n+          int32_t offset = 0;                                                                      \\\n+          baseOffset32(temp, adr, offset);                                                         \\\n+          Assembler::NAME(Rs, temp, offset);                                                       \\\n+        }                                                                                          \\\n+        break;                                                                                     \\\n+      }                                                                                            \\\n+      default:                                                                                     \\\n+        ShouldNotReachHere();                                                                      \\\n+    }                                                                                              \\\n+  }\n+\n+  INSN(fsw);\n+  INSN(fsd);\n+\n+#undef INSN\n+\n+#undef INSN_ENTRY_RELOC\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":320,"deletions":13,"binary":false,"changes":333,"status":"modified"},{"patch":"@@ -2176,2 +2176,2 @@\n-  __ ld(fp, sp, 0);\n-  __ ld(ra, sp, wordSize);\n+  __ ld(fp, Address(sp, 0));\n+  __ ld(ra, Address(sp, wordSize));\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-    __ ld(t0, c_rarg5, 0);\n+    __ ld(t0, Address(c_rarg5, 0));\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -247,1 +247,1 @@\n-      __ flw(f10, t0, 0);\n+      __ flw(f10, Address(t0, 0));\n@@ -250,1 +250,1 @@\n-      __ flw(f10, t0, sizeof(float));\n+      __ flw(f10, Address(t0, sizeof(float)));\n@@ -266,1 +266,1 @@\n-      __ fld(f10, t0, 0);\n+      __ fld(f10, Address(t0, 0));\n@@ -269,1 +269,1 @@\n-      __ fld(f10, t0, sizeof(double));\n+      __ fld(f10, Address(t0, sizeof(double)));\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}