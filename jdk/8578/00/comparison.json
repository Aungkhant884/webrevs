{"files":[{"patch":"@@ -51,0 +51,1 @@\n+import javax.accessibility.AccessibleList;\n@@ -568,2 +569,3 @@\n-                if (parent instanceof JList) {\n-                    ((JList) parent).setSelectedIndex(i);\n+                AccessibleTable pat = pac.getAccessibleTable();\n+                if (pat instanceof AccessibleList) {\n+                    ((AccessibleList) pat).setSelectionInterval(i, i);\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CAccessibility.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, JetBrains s.r.o.. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *\/\n+\n+package javax.accessibility;\n+\n+\/**\n+ *  This interface provides list specific data.\n+ *\n+ * @author Artem Semenov\n+ *\/\n+public interface AccessibleList {\n+\n+    \/**\n+     * A value for the selectionMode property: select one list index\n+     * at a time.\n+     *\/\n+    int SINGLE_SELECTION = 0;\n+\n+    \/**\n+     * A value for the selectionMode property: select one contiguous\n+     * range of indices at a time.\n+     *\/\n+    int SINGLE_INTERVAL_SELECTION = 1;\n+\n+    \/**\n+     * A value for the selectionMode property: select one or more\n+     * contiguous ranges of indices at a time.\n+     *\/\n+    int MULTIPLE_INTERVAL_SELECTION = 2;\n+\n+    \/**\n+     * Returns the length of the list.\n+     * @return the length of the list\n+     *\/\n+    int getSize();\n+\n+    \/**\n+     * Changes the selection to be between {@code index0} and {@code index1}\n+     *\n+     * @param index0 one end of the interval.\n+     * @param index1 other end of the interval\n+     *\/\n+    void setSelectionInterval(int index0, int index1);\n+\n+    \/**\n+     * Changes the selection to be the set union of the current selection\n+     * and the indices between {@code index0} and {@code index1} inclusive.\n+     *\n+     * @param index0 one end of the interval.\n+     * @param index1 other end of the interval\n+     *\/\n+    void addSelectionInterval(int index0, int index1);\n+\n+    \/**\n+     * Changes the selection to be the set difference of the current selection\n+     * and the indices between {@code index0} and {@code index1} inclusive.\n+     *\n+     * @param index0 one end of the interval.\n+     * @param index1 other end of the interval\n+     *\/\n+    void removeSelectionInterval(int index0, int index1);\n+\n+    \/**\n+     * Returns the first selected index or -1 if the selection is empty.\n+     *\n+     * @return the first selected index or -1 if the selection is empty.\n+     *\/\n+    int getMinSelectionIndex();\n+\n+    \/**\n+     * Returns the last selected index or -1 if the selection is empty.\n+     *\n+     * @return the last selected index or -1 if the selection is empty.\n+     *\/\n+    int getMaxSelectionIndex();\n+\n+\n+    \/**\n+     * Returns true if the specified index is selected.\n+     *\n+     * @param index an index\n+     * @return {@code true} if the specified index is selected\n+     *\/\n+    boolean isSelectedIndex(int index);\n+\n+    \/**\n+     * Returns true if no indices are selected.\n+     *\n+     * @return {@code true} if no indices are selected.\n+     *\/\n+    boolean isSelectionEmpty();\n+\n+    \/**\n+     * Insert {@code length} indices beginning before\/after {@code index}. This is typically\n+     * called to sync the selection model with a corresponding change\n+     * in the data model.\n+     *\n+     * @param index the beginning of the interval\n+     * @param length the length of the interval\n+     * @param before if {@code true}, interval inserts before the {@code index},\n+     *               otherwise, interval inserts after the {@code index}\n+     *\/\n+    void insertIndexInterval(int index, int length, boolean before);\n+\n+    \/**\n+     * Remove the indices in the interval {@code index0,index1} (inclusive) from\n+     * the selection model. This is typically called to sync the selection\n+     * model width a corresponding change in the data model.\n+     *\n+     * @param index0 the beginning of the interval\n+     * @param index1 the end of the interval\n+     *\/\n+    void removeIndexInterval(int index0, int index1);\n+\n+    \/**\n+     * Sets the selection mode. The following list describes the accepted\n+     * selection modes:\n+     * <ul>\n+     * <li>{@code AccessibleList.SINGLE_SELECTION} -\n+     *   Only one list index can be selected at a time. In this mode,\n+     *   {@code setSelectionInterval} and {@code addSelectionInterval} are\n+     *   equivalent, both replacing the current selection with the index\n+     *   represented by the second argument (the \"lead\").\n+     * <li>{@code AccessibleList.SINGLE_INTERVAL_SELECTION} -\n+     *   Only one contiguous interval can be selected at a time.\n+     *   In this mode, {@code addSelectionInterval} behaves like\n+     *   {@code setSelectionInterval} (replacing the current selection),\n+     *   unless the given interval is immediately adjacent to or overlaps\n+     *   the existing selection, and can therefore be used to grow it.\n+     * <li>{@code AccessibleList.MULTIPLE_INTERVAL_SELECTION} -\n+     *   In this mode, there's no restriction on what can be selected.\n+     * <\/ul>\n+     *\n+     * @param selectionMode the selection mode\n+     *\/\n+    void setSelectionMode(int selectionMode);\n+\n+    \/**\n+     * Returns the current selection mode.\n+     *\n+     * @return the current selection mode\n+     * @see #setSelectionMode\n+     *\/\n+    int getSelectionMode();\n+\n+    \/**\n+     * Returns an array of all of the selected indices in the selection model,\n+     * in increasing order.\n+     *\n+     * @return all of the selected indices, in increasing order,\n+     *         or an empty array if nothing is selected\n+     *\/\n+    int[] getSelectedIndices();\n+\n+    \/**\n+     * Returns the number of selected items.\n+     *\n+     * @return the number of selected items, 0 if no items are selected\n+     *\/\n+    int getSelectedItemsCount();\n+}\n","filename":"src\/java.desktop\/share\/classes\/javax\/accessibility\/AccessibleList.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -52,17 +52,3 @@\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Vector;\n-\n-import javax.accessibility.Accessible;\n-import javax.accessibility.AccessibleAction;\n-import javax.accessibility.AccessibleComponent;\n-import javax.accessibility.AccessibleContext;\n-import javax.accessibility.AccessibleIcon;\n-import javax.accessibility.AccessibleRole;\n-import javax.accessibility.AccessibleSelection;\n-import javax.accessibility.AccessibleState;\n-import javax.accessibility.AccessibleStateSet;\n-import javax.accessibility.AccessibleText;\n-import javax.accessibility.AccessibleValue;\n+import java.util.*;\n+\n+import javax.accessibility.*;\n@@ -3053,1 +3039,240 @@\n-    \/\/ AccessibleContext methods\n+        private class AccessibleListImpl implements AccessibleList, AccessibleTable {\n+            private final Map<Integer, Integer> listSelectionModeMap = Map.of(\n+                    AccessibleList.SINGLE_SELECTION, ListSelectionModel.SINGLE_SELECTION,\n+                    AccessibleList.SINGLE_INTERVAL_SELECTION, ListSelectionModel.SINGLE_INTERVAL_SELECTION,\n+                    AccessibleList.MULTIPLE_INTERVAL_SELECTION, ListSelectionModel.MULTIPLE_INTERVAL_SELECTION\n+            );\n+            private final Map<Integer, Integer> accessibleListModeMap = Map.of(\n+                    ListSelectionModel.SINGLE_SELECTION, AccessibleList.SINGLE_SELECTION,\n+                    ListSelectionModel.SINGLE_INTERVAL_SELECTION, AccessibleList.SINGLE_INTERVAL_SELECTION,\n+                    ListSelectionModel.MULTIPLE_INTERVAL_SELECTION, AccessibleList.MULTIPLE_INTERVAL_SELECTION\n+            );\n+\n+            @Override\n+            public Accessible getAccessibleCaption() {\n+                return null;\n+            }\n+\n+            @Override\n+            public void setAccessibleCaption(Accessible a) {\n+\n+            }\n+\n+            @Override\n+            public Accessible getAccessibleSummary() {\n+                return null;\n+            }\n+\n+            @Override\n+            public void setAccessibleSummary(Accessible a) {\n+\n+            }\n+\n+            @Override\n+            public int getAccessibleRowCount() {\n+                return AccessibleListImpl.this.getSize();\n+            }\n+\n+            \/**\n+             *  list has one column only\n+             *\n+             * @return 1\n+             *\/\n+            @Override\n+            public int getAccessibleColumnCount() {\n+                return 1;\n+            }\n+\n+            @Override\n+            public int getAccessibleRowExtentAt(int r, int c) {\n+                return 0;\n+            }\n+\n+            @Override\n+            public int getAccessibleColumnExtentAt(int r, int c) {\n+                return 0;\n+            }\n+\n+            @Override\n+            public AccessibleTable getAccessibleRowHeader() {\n+                return null;\n+            }\n+\n+            @Override\n+            public void setAccessibleRowHeader(AccessibleTable table) {\n+\n+            }\n+\n+            @Override\n+            public AccessibleTable getAccessibleColumnHeader() {\n+                return null;\n+            }\n+\n+            @Override\n+            public void setAccessibleColumnHeader(AccessibleTable table) {\n+\n+            }\n+\n+            @Override\n+            public Accessible getAccessibleRowDescription(int r) {\n+                return null;\n+            }\n+\n+            @Override\n+            public void setAccessibleRowDescription(int r, Accessible a) {\n+\n+            }\n+\n+            @Override\n+            public Accessible getAccessibleColumnDescription(int c) {\n+                return null;\n+            }\n+\n+            @Override\n+            public void setAccessibleColumnDescription(int c, Accessible a) {\n+\n+            }\n+\n+            \/**\n+             *  table has one column, so we only check the row\n+             *\n+             * @param r zero-based row of the table\n+             * @param c zero-based column of the table\n+             * @return row is selected\n+             *\/\n+            @Override\n+            public boolean isAccessibleSelected(int r, int c) {\n+                return AccessibleListImpl.this.isAccessibleRowSelected(r);\n+            }\n+\n+            @Override\n+            public boolean isAccessibleRowSelected(int r) {\n+                return AccessibleListImpl.this.isSelectedIndex(r);\n+            }\n+\n+            \/**\n+             *  list has selected only one column\n+             *\n+             * @param c zero-based column of the table\n+             * @return c is first column\n+             *\/\n+            @Override\n+            public boolean isAccessibleColumnSelected(int c) {\n+                return c == 0;\n+            }\n+\n+            @Override\n+            public int[] getSelectedAccessibleRows() {\n+                return AccessibleListImpl.this.getSelectedIndices();\n+            }\n+\n+            @Override\n+            public int[] getSelectedAccessibleColumns() {\n+                return new int[] {0};\n+            }\n+\n+            @Override\n+            public int getSize() {\n+                return JList.this.getModel().getSize();\n+            }\n+\n+            @Override\n+            public void setSelectionInterval(int index0, int index1) {\n+                JList.this.getSelectionModel().setSelectionInterval(index0, index1);\n+            }\n+\n+            @Override\n+            public void addSelectionInterval(int index0, int index1) {\n+                JList.this.getSelectionModel().addSelectionInterval(index0, index1);\n+            }\n+\n+            @Override\n+            public void removeSelectionInterval(int index0, int index1) {\n+                JList.this.getSelectionModel().removeSelectionInterval(index0, index1);\n+            }\n+\n+            @Override\n+            public int getMinSelectionIndex() {\n+                return JList.this.getSelectionModel().getMinSelectionIndex();\n+            }\n+\n+            @Override\n+            public int getMaxSelectionIndex() {\n+                return JList.this.getSelectionModel().getMaxSelectionIndex();\n+            }\n+\n+            @Override\n+            public boolean isSelectedIndex(int index) {\n+                return JList.this.getSelectionModel().isSelectedIndex(index);\n+            }\n+\n+            @Override\n+            public boolean isSelectionEmpty() {\n+                return JList.this.getSelectionModel().isSelectionEmpty();\n+            }\n+\n+            @Override\n+            public void insertIndexInterval(int index, int length, boolean before) {\n+                JList.this.getSelectionModel().insertIndexInterval(index, length, before);\n+            }\n+\n+            @Override\n+            public void removeIndexInterval(int index0, int index1) {\n+                JList.this.getSelectionModel().removeIndexInterval(index0, index1);\n+            }\n+\n+            \/**\n+             * This method sets the ListSelectionMode to match the AccessibleListMode.\n+             * If no match is found, the value will not be set.\n+             *\n+             * @param selectionMode the AccessibleListMode\n+             *\/\n+            @Override\n+            public void setSelectionMode(int selectionMode) {\n+                Integer sm = listSelectionModeMap.get(selectionMode);\n+                if (sm != null) {\n+                    JList.this.getSelectionModel().setSelectionMode(sm);\n+                }\n+            }\n+\n+            \/**\n+             * This method returns an AccessibleListMode corresponding to the ListSelectionMode\n+             *\n+             * @return AccessibleListMode\n+             *\/\n+            @Override\n+            public int getSelectionMode() {\n+                return accessibleListModeMap.get(JList.this.getSelectionModel().getSelectionMode());\n+            }\n+\n+            @Override\n+            public int[] getSelectedIndices() {\n+                return JList.this.getSelectionModel().getSelectedIndices();\n+            }\n+\n+            @Override\n+            public int getSelectedItemsCount() {\n+                return JList.this.getSelectionModel().getSelectedItemsCount();\n+            }\n+\n+            public Accessible getAccessibleAt(int r, int c) {\n+                if ((r >= 0) && (r < getAccessibleRowCount())) {\n+                    E o =  JList.this.getModel().getElementAt(r);\n+                    if (o != null) {\n+                        Component component = JList.this.getCellRenderer().getListCellRendererComponent(JList.this, o, r,\n+                                JList.this.isSelectedIndex(r), false);\n+                        if (component instanceof Accessible) {\n+                            return (Accessible) component;\n+                        }\n+                    }\n+                }\n+                return null;\n+            }\n+        }\n+\n+        \/\/ AccessibleContext methods\n+\n+        @Override\n+        public AccessibleTable getAccessibleTable() {\n+                 return new AccessibleListImpl();\n+         }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JList.java","additions":243,"deletions":18,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, JetBrains s.r.o.. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8271846\n+ * @summary Test implementation of AccessibleList interface\n+ * @author Artem.Semenov@jetbrains.com\n+ * @run main AccessibleListTest\n+ * @requires (os.family == \"windows\" | os.family == \"mac\")\n+ *\/\n+\n+import javax.swing.JList;\n+import  javax.swing.ListSelectionModel;\n+\n+import javax.accessibility.AccessibleContext;\n+import javax.accessibility.AccessibleList;\n+import javax.accessibility.AccessibleTable;\n+import java.util.Map;\n+\n+public class AccessibleListTest {\n+    private static boolean testResult = false;\n+    private static String exceptionString = null;\n+    private static final String[] NAMES = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\"};\n+    private static final boolean OK = true;\n+    private static final boolean FAIL = false;\n+    private static int failCount = 0;\n+    private static final Map<Integer, Integer> listSelectionModeMap = Map.of(\n+            AccessibleList.SINGLE_SELECTION, ListSelectionModel.SINGLE_SELECTION,\n+            AccessibleList.SINGLE_INTERVAL_SELECTION, ListSelectionModel.SINGLE_INTERVAL_SELECTION,\n+            AccessibleList.MULTIPLE_INTERVAL_SELECTION, ListSelectionModel.MULTIPLE_INTERVAL_SELECTION\n+    );\n+    private static final Map<Integer, Integer> accessibleListModeMap = Map.of(\n+            ListSelectionModel.SINGLE_SELECTION, AccessibleList.SINGLE_SELECTION,\n+            ListSelectionModel.SINGLE_INTERVAL_SELECTION, AccessibleList.SINGLE_INTERVAL_SELECTION,\n+            ListSelectionModel.MULTIPLE_INTERVAL_SELECTION, AccessibleList.MULTIPLE_INTERVAL_SELECTION\n+    );\n+\n+    public static void main(String[] args) throws Exception {\n+        AccessibleListTest.runTest();\n+\n+        if (!testResult) {\n+            throw new RuntimeException(AccessibleListTest.exceptionString);\n+        }\n+    }\n+\n+    private static void countersControl(final boolean isOk, final String methodName) {\n+        if (isOk) {\n+            System.out.println(methodName + \": ok\");\n+        } else {\n+            failCount += 1;\n+            System.out.println(methodName + \": fail\");\n+        }\n+    }\n+\n+    public static void runTest() {\n+        JList<String> list = new JList<>(NAMES);\n+\n+        AccessibleContext ac = list.getAccessibleContext();\n+        if (ac == null) {\n+            countersControl(FAIL, \"accessibleConntext\");\n+            return;\n+        }\n+        countersControl(OK, \"acccessibleContext\");\n+\n+        AccessibleTable at = ac.getAccessibleTable();\n+        if ((at == null) && !(at instanceof AccessibleList)) {\n+            countersControl(FAIL, \"AccessibleList\");\n+            return;\n+        }\n+        countersControl(OK, \"AccessibleList\");\n+\n+        AccessibleList al = ((AccessibleList) at);\n+\n+        int size = al.getSize();\n+        if (size == 5) {\n+            countersControl(OK, \"getSize()\");\n+        } else {\n+            countersControl(FAIL, \"getSize()\");\n+        }\n+\n+        int listSelectionMode = list.getSelectionMode();\n+        int accessibleListMode = listSelectionModeMap.get(al.getSelectionMode());\n+        if (listSelectionMode == accessibleListMode) {\n+            countersControl(OK, \"getSelectionMode()\");\n+        } else {\n+            countersControl(FAIL, \"getSelectionMode()\");\n+        }\n+\n+        al.setSelectionMode(AccessibleList.MULTIPLE_INTERVAL_SELECTION);\n+\n+        listSelectionMode = list.getSelectionMode();\n+        accessibleListMode = listSelectionModeMap.get(al.getSelectionMode());\n+        if (listSelectionMode == accessibleListMode) {\n+            countersControl(OK, \"setSelectionMode()\");\n+        } else {\n+            countersControl(FAIL, \"setSelectionMode()\");\n+        }\n+\n+        al.setSelectionInterval(0, 2);\n+\n+        if (list.getSelectionModel().isSelectedIndex(0) &&\n+                list.getSelectionModel().isSelectedIndex(1) &&\n+                list.getSelectionModel().isSelectedIndex(2)) {\n+            countersControl(OK, \"setSelectionInterval()\");\n+        } else {\n+            countersControl(FAIL, \"setSelectionInterval()\");\n+        }\n+\n+        if (al.isSelectedIndex(1)) {\n+            countersControl(OK, \"isSelectedIndex()\");\n+        } else {\n+            countersControl(FAIL, \"isSelectedIndex()\");\n+        }\n+\n+        if (al.getSelectedItemsCount() == list.getSelectionModel().getSelectedItemsCount()) {\n+            countersControl(OK, \"getSelectedItemsCount()\");\n+        } else {\n+            countersControl(FAIL, \"getSelectedItemsCount()\");\n+        }\n+\n+        if (!al.isSelectionEmpty()) {\n+            countersControl(OK, \"isSelectionEmpty()\");\n+        } else {\n+            countersControl(FAIL, \"isSelectionEmpty()\");\n+        }\n+\n+        if (al.getMaxSelectionIndex() == 2) {\n+            countersControl(OK, \"getMaxSelectionIndex()\");\n+        } else {\n+            countersControl(FAIL, \"getMaxSelectionIndex()\");\n+        }\n+\n+        if (al.getMinSelectionIndex() == 0) {\n+            countersControl(OK, \"getMinSelectionIndex()\");\n+        } else {\n+            countersControl(FAIL, \"getMinSelectionIndex()\");\n+        }\n+\n+        int[] listSelectedIndices = list.getSelectionModel().getSelectedIndices();\n+        int[] accessibleListSelectedIndices = al.getSelectedIndices();\n+\n+        if (listSelectedIndices.length != accessibleListSelectedIndices.length) {\n+            countersControl(FAIL, \"getSelectedIndices()\");\n+        } else {\n+            int length = listSelectedIndices.length, i = 0;\n+            boolean ok = true;\n+            while (ok && (i < length)) {\n+                if (listSelectedIndices[i] != accessibleListSelectedIndices[i]) {\n+                    ok = false;\n+                } else {\n+                    i += 1;\n+                }\n+            }\n+            if (ok) {\n+                countersControl(OK, \"getSelectedIndices()\");\n+            } else {\n+                countersControl(FAIL, \"getSelectedIndices()\");\n+            }\n+        }\n+\n+        al.addSelectionInterval(3, 4);\n+        if (al.getSelectedItemsCount() == 5) {\n+            countersControl(OK, \"addSelectionInterval()\");\n+        } else {\n+            countersControl(FAIL, \"addSelectionInterval()\");\n+        }\n+\n+        al.removeSelectionInterval(2, 3);\n+        if (al.getSelectedItemsCount() == 3) {\n+            countersControl(OK, \"removeSelectionInterval()\");\n+        } else {\n+            countersControl(FAIL, \"removeSelectionInterval()\");\n+        }\n+\n+        al.setSelectionInterval(0, 4);\n+        al.removeIndexInterval(2, 3);\n+        if (al.getSelectedItemsCount() == 3) {\n+            countersControl(OK, \"removeIndexInterval()\");\n+        } else {\n+            countersControl(FAIL, \"removeIndexInterval()\");\n+        }\n+\n+        al.removeSelectionInterval(0, 4);\n+        al.setSelectionInterval(0, 0);\n+        al.addSelectionInterval(4, 4);\n+        al.insertIndexInterval(0, 2, true);\n+        al.insertIndexInterval(4, 2, false);\n+        if (al.getSelectedItemsCount() == 4) {\n+            countersControl(OK, \"insertIndexInterval()\");\n+        } else {\n+            countersControl(FAIL, \"insertIndexInterval()\");\n+        }\n+\n+        if (failCount == 0) {\n+            AccessibleListTest.testResult = true;\n+            System.out.println(\"All methods: Ok\");\n+        } else {\n+            AccessibleListTest.exceptionString = \"Test failed. \" + String.valueOf(failCount) + \" methods is no ok\";\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/a11y\/AccessibleListTest.java","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"}]}