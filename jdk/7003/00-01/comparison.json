{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -597,0 +597,4 @@\n+  if (!signal_was_handled && sig == BREAK_SIGNAL) {\n+    signal_was_handled = true;\n+  }\n+\n@@ -1283,0 +1287,5 @@\n+  \/\/ This is just for initialization phase. os::initialize_jdk_signal_support() will overwrite\n+  \/\/ the signal handler of BREAK_SIGNAL later. Intercepting the signal here reduces the risk\n+  \/\/ that an attach client accidentally forces HotSpot to quit prematurely.\n+  set_signal_handler(BREAK_SIGNAL);\n+\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,40 +114,0 @@\n-\/**\n- * Check \/proc\/$pid\/stat to determine SIGQUIT is caught by pid.\n- * Return 1 if the SIGQUIT is set in SigCgt; 0 if it is not.\n- * Return -1 when it runs into any error.\n- *\/\n-static int check_sigquit_caught(jint pid) {\n-    char buf[2048];\n-    int statlen;\n-\n-    sprintf(buf, \"\/proc\/%d\/stat\", pid);\n-    FILE *fp = fopen(buf, \"r\");\n-    if (fp != NULL) {\n-        statlen = fread(buf, 1, 2047, fp);\n-        buf[statlen] = '\\0';\n-        fclose(fp);\n-\n-        \/\/ Code is inspired by email from Hans Boehm. \/proc\/self\/stat begins with current\n-        \/\/ pid, followed by command name surrounded by parentheses, state, etc\n-        char *s = strrchr(buf, ')');\n-        \/\/ https:\/\/www.kernel.org\/doc\/html\/latest\/filesystems\/proc.html#id10\n-        \/\/ pid tcomm) stat ppid ... sigign sigcatch\n-        \/\/ 0   1      2    3    ... 32     33\n-        for (int i = 1; s != NULL && i < 33; ++i) {\n-            s = strchr(s + 1, ' ');\n-        }\n-\n-        if (s != NULL) {\n-            unsigned long bitmask;\n-            if (1 == sscanf(s + 1, \"%lu\", &bitmask)) {\n-                if (bitmask & (1 << (SIGQUIT - 1))) {\n-                    return 1;\n-                } else {\n-                    return 0;\n-                }\n-            }\n-        }\n-    }\n-\n-    return -1;\n-}\n@@ -163,2 +123,0 @@\n-    \/\/ Only give up sending SIGQUIT if we see that SigCgt is not set.\n-    if (check_sigquit_caught(pid) == 0) return;\n","filename":"src\/jdk.attach\/linux\/native\/libattach\/VirtualMachineImpl.c","additions":1,"deletions":43,"binary":false,"changes":44,"status":"modified"}]}