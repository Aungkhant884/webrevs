{"files":[{"patch":"@@ -1802,0 +1802,3 @@\n+\/\/ Only initialize if Parse Predicate projection itself or any of the Parse Predicate projections coming further up\n+\/\/ in the graph are not already initialized (this would be a sign of repeated Parse Predicates which are not cleaned up,\n+\/\/ yet).\n@@ -1814,1 +1817,2 @@\n-      if (_profiled_loop_predicate_proj != nullptr) {\n+      if (_profiled_loop_predicate_proj != nullptr ||\n+          _loop_predicate_proj != nullptr) {\n@@ -1820,1 +1824,3 @@\n-      if (_loop_limit_check_predicate_proj != nullptr) {\n+      if (_loop_limit_check_predicate_proj != nullptr ||\n+          _loop_predicate_proj != nullptr ||\n+          _profiled_loop_predicate_proj != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8308892\n+ * @summary Test that Parse Predicates immediately following other Parse Predicates\n+            are cleaned up properly.\n+ * @run main\/othervm -Xbatch compiler.predicates.TestWrongPredicateOrder\n+ *\/\n+\n+package compiler.predicates;\n+\n+public class TestWrongPredicateOrder {\n+    static boolean flag;\n+    static int iFld = 0;\n+    static int iFld2 = 34;\n+    static int iArr[] = new int[1005];\n+    static int iArr2[] = new int[2];\n+\n+\n+    public static void main(String[] strArr) {\n+        \/\/ We will keep hitting the Profiled Loop Predicate for RC1 (Integer.MAX_VALUE - 1 - 3 > 1005) such that we will\n+        \/\/ not emit the Profile Loop Parse Predicate anymore. After that, we will also keep hitting the Loop Limit Check\n+        \/\/ Predicate (Interger.MAX_VALUE - 1 > Integer.MAX_VALUE - 2) such that we will also not emit the Loop Limit Check\n+        \/\/ Parse Predicate anymore. As a result, we'll only emit the Loop Parse Predicate in the next re-compilation.\n+        \/\/ In the next re-compilation, we'll hoist IC1 as Loop Predicate and IC2 as Profiled Loop Predicate.\n+        \/\/ They have a data dependency between them but this is normally okay because Profiled Loop Predicates are below\n+        \/\/ Loop Predicates in the graph. But due to the flipped order of Parse Predicates in this bug, we create the\n+        \/\/ Hoisted Predicates in the wrong order and we end up with a bad graph and assert.\n+        for (int i = 0; i < 10000; i++) {\n+            flag = !flag;\n+            test();\n+        }\n+    }\n+\n+    public static void test() {\n+        \/\/ Ensure to emit Loop Limit Check Predicate which is hit too often\n+        \/\/ -> no Loop Limit Check Parse Predicate is added in re-compilation anymore\n+        int limit = flag ? Integer.MAX_VALUE - 1 : 1000;\n+\n+        int i = 0;\n+        \/\/ Loop Limit Check Predicate: limit <= Integer.MAX_VALUE - stride + 1 = Integer.MAX_VALUE - 2\n+        while (i < limit) {\n+            i += 3;\n+            \/\/ Invariant check hoisted as Loop Predicate\n+            iArr2[iFld] = 1; \/\/ (IC1)\n+\n+            if (flag) {\n+                \/\/ Early exit -> enables Profiled Loop Predicate creation below\n+                return;\n+            }\n+\n+            \/\/ Invariant check hoisted as Profiled Loop Predicate\n+            \/\/ Data dependency on Loop Predicate for \"iArr2[0] = 1\"\n+            iArr2[1] = 5; \/\/ (IC2)\n+\n+            \/\/ Profiled Loop Predicate for range check hit too much -> no Profiled Loop Parse Predicate is added in\n+            \/\/ re-compilation anymore\n+            iArr[i] = 34; \/\/ (RC1)\n+\n+            if (iFld2 == 5555) {\n+                i++; \/\/ UCT -> ensures to emit Parse Predicates twice with an If in between that is folded after parsing\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/TestWrongPredicateOrder.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"}]}