{"files":[{"patch":"@@ -40,1 +40,1 @@\n-    static int iArr2[] = new int[100000];\n+    static int iArr2[] = new int[2];\n@@ -44,1 +44,8 @@\n-        \/\/ Warmup without hitting Profiled Loop Predicate for range check\n+        \/\/ We will keep hitting the Profiled Loop Predicate for RC1 (Integer.MAX_VALUE - 1 - 3 > 1005) such that we will\n+        \/\/ not emit the Profile Loop Parse Predicate anymore. After that, we will also keep hitting the Loop Limit Check\n+        \/\/ Predicate (Interger.MAX_VALUE - 1 > Integer.MAX_VALUE - 2) such that we will also not emit the Loop Limit Check\n+        \/\/ Parse Predicate anymore. As a result, we'll only emit the Loop Parse Predicate in the next re-compilation.\n+        \/\/ In the next re-compilation, we'll hoist IC1 as Loop Predicate and IC2 as Profiled Loop Predicate.\n+        \/\/ They have a data dependency between them but this is normally okay because Profiled Loop Predicates are below\n+        \/\/ Loop Predicates in the graph. But due to the flipped order of Parse Predicates in this bug, we create the\n+        \/\/ Hoisted Predicates in the wrong order and we end up with a bad graph and assert.\n@@ -47,1 +54,0 @@\n-            iFld = 0;\n@@ -50,11 +56,0 @@\n-\n-        \/\/ Constantly hitting Profiled Loop Predicate for range check -> re-compilation without\n-        for (int i = 0; i < 10000; i++) {\n-            try {\n-                iFld = 1000; \/\/ Ensures out of bounds access to hit Profiled Loop Predicate\n-                flag = !flag;\n-                test();\n-            } catch (Exception e) {\n-                \/\/ Expected\n-            }\n-        }\n@@ -64,1 +59,2 @@\n-        \/\/ Ensure to emit Loop Limit Check Predicate which is hit too often -> no Loop Limit Check Parse Predicate is added in re-compilation anymore\n+        \/\/ Ensure to emit Loop Limit Check Predicate which is hit too often\n+        \/\/ -> no Loop Limit Check Parse Predicate is added in re-compilation anymore\n@@ -68,0 +64,1 @@\n+        \/\/ Loop Limit Check Predicate: limit <= Integer.MAX_VALUE - stride + 1 = Integer.MAX_VALUE - 2\n@@ -70,1 +67,2 @@\n-            iArr2[0] = 1; \/\/ Invariant check hoisted as Loop Predicate\n+            \/\/ Invariant check hoisted as Loop Predicate\n+            iArr2[iFld] = 1; \/\/ (IC1)\n@@ -77,2 +75,3 @@\n-            \/\/ Data dependency on Loop Predicate for \"iArr2[0] = 1\", we need to hoist this (invariant) check with a Profiled Loop Predicate\n-            iArr2[1] = 5;\n+            \/\/ Invariant check hoisted as Profiled Loop Predicate\n+            \/\/ Data dependency on Loop Predicate for \"iArr2[0] = 1\"\n+            iArr2[1] = 5; \/\/ (IC2)\n@@ -80,2 +79,3 @@\n-            \/\/ Profiled Loop Predicate for range check hit too much -> no Profiled Parse Predicate is added in re-compilation anymore\n-            iArr[i + iFld] = 34;\n+            \/\/ Profiled Loop Predicate for range check hit too much -> no Profiled Loop Parse Predicate is added in\n+            \/\/ re-compilation anymore\n+            iArr[i] = 34; \/\/ (RC1)\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/TestWrongPredicateOrder.java","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"}]}