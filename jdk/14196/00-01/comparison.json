{"files":[{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8308892\n+ * @summary Test that Parse Predicates immediately following other Parse Predicates\n+            are cleaned up properly.\n+ * @run main\/othervm -Xbatch compiler.predicates.TestWrongPredicateOrder\n+ *\/\n+\n+package compiler.predicates;\n+\n+public class TestWrongPredicateOrder {\n+    static boolean flag;\n+    static int iFld = 0;\n+    static int iFld2 = 34;\n+    static int iArr[] = new int[1005];\n+    static int iArr2[] = new int[100000];\n+\n+\n+    public static void main(String[] strArr) {\n+        \/\/ Warmup without hitting Profiled Loop Predicate for range check\n+        for (int i = 0; i < 10000; i++) {\n+            flag = !flag;\n+            iFld = 0;\n+            test();\n+        }\n+\n+        \/\/ Constantly hitting Profiled Loop Predicate for range check -> re-compilation without\n+        for (int i = 0; i < 10000; i++) {\n+            try {\n+                iFld = 1000; \/\/ Ensures out of bounds access to hit Profiled Loop Predicate\n+                flag = !flag;\n+                test();\n+            } catch (Exception e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    public static void test() {\n+        \/\/ Ensure to emit Loop Limit Check Predicate which is hit too often -> no Loop Limit Check Parse Predicate is added in re-compilation anymore\n+        int limit = flag ? Integer.MAX_VALUE - 1 : 1000;\n+\n+        int i = 0;\n+        while (i < limit) {\n+            i += 3;\n+            iArr2[0] = 1; \/\/ Invariant check hoisted as Loop Predicate\n+\n+\n+            if (flag) {\n+                \/\/ Early exit -> enables Profiled Loop Predicate creation below\n+                return;\n+            }\n+\n+            \/\/ Data dependency on Loop Predicate for \"iArr2[0] = 1\", we need to hoist this (invariant) check with a Profiled Loop Predicate\n+            iArr2[1] = 5;\n+\n+            \/\/ Profiled Loop Predicate for range check hit too much -> no Profiled Parse Predicate is added in re-compilation anymore\n+            iArr[i + iFld] = 34;\n+\n+\n+            if (iFld2 == 5555) {\n+                i++; \/\/ UCT -> ensures to emit Parse Predicates twice with an If in between that is folded after parsing\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/TestWrongPredicateOrder.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"}]}