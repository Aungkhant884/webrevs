{"files":[{"patch":"@@ -709,1 +709,1 @@\n-    static String newStringUTF8FailFast(byte[] bytes, int offset, int length, boolean noShare) {\n+    static String newStringUTF8ReportError(byte[] bytes, int offset, int length, boolean noShare) {\n@@ -772,1 +772,1 @@\n-    static String newStringNoRepl(byte[] src, Charset cs) throws CharacterCodingException {\n+    static String newStringReportError(byte[] src, Charset cs) throws CharacterCodingException {\n@@ -774,1 +774,1 @@\n-            return newStringNoRepl1(src, cs);\n+            return newStringReportErrorUnchecked(src, cs);\n@@ -776,6 +776,2 @@\n-            \/\/newStringNoRepl1 throws IAE with MalformedInputException or CCE as the cause\n-            Throwable cause = e.getCause();\n-            if (cause instanceof MalformedInputException mie) {\n-                throw mie;\n-            }\n-            throw (CharacterCodingException)cause;\n+            \/\/newStringReportErrorUnchecked throws IAE with MalformedInputException or CCE as the cause\n+            throw (CharacterCodingException) e.getCause();\n@@ -786,1 +782,1 @@\n-    private static String newStringNoRepl1(byte[] src, Charset cs) {\n+    private static String newStringReportErrorUnchecked(byte[] src, Charset cs) {\n@@ -792,1 +788,1 @@\n-            return newStringUTF8FailFast(src, 0, src.length, false);\n+            return newStringUTF8ReportError(src, 0, src.length, false);\n@@ -936,1 +932,1 @@\n-    static byte[] getBytesUTF8FailFast(String s) {\n+    static byte[] getBytesUTF8ReportError(String s) {\n@@ -947,1 +943,1 @@\n-    static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n+    static byte[] getBytesReportError(String s, Charset cs) throws CharacterCodingException {\n@@ -949,1 +945,1 @@\n-            return getBytesNoRepl1(s, cs);\n+            return getBytesReportErrorUnchecked(s, cs);\n@@ -951,6 +947,2 @@\n-            \/\/getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause\n-            Throwable cause = e.getCause();\n-            if (cause instanceof UnmappableCharacterException) {\n-                throw (UnmappableCharacterException)cause;\n-            }\n-            throw (CharacterCodingException)cause;\n+            \/\/getBytesReportErrorUnchecked throws IAE with UnmappableCharacterException or CCE as the cause\n+            throw (CharacterCodingException) e.getCause();\n@@ -960,1 +952,1 @@\n-    private static byte[] getBytesNoRepl1(String s, Charset cs) {\n+    private static byte[] getBytesReportErrorUnchecked(String s, Charset cs) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":13,"deletions":21,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2476,2 +2476,2 @@\n-            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n-                return String.newStringNoRepl(bytes, cs);\n+            public String newStringReportError(byte[] bytes, Charset cs) throws CharacterCodingException  {\n+                return String.newStringReportError(bytes, cs);\n@@ -2482,2 +2482,2 @@\n-            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n-                return String.getBytesNoRepl(s, cs);\n+            public byte[] getBytesReportError(String s, Charset cs) throws CharacterCodingException {\n+                return String.getBytesReportError(s, cs);\n@@ -2486,2 +2486,2 @@\n-            public String newStringUTF8FailFast(byte[] bytes, int off, int len) {\n-                return String.newStringUTF8FailFast(bytes, off, len, true);\n+            public String newStringUTF8ReportError(byte[] bytes, int off, int len) {\n+                return String.newStringUTF8ReportError(bytes, off, len, true);\n@@ -2490,2 +2490,2 @@\n-            public byte[] getBytesUTF8FailFast(String s) {\n-                return String.getBytesUTF8FailFast(s);\n+            public byte[] getBytesUTF8ReportError(String s) {\n+                return String.getBytesUTF8ReportError(s);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3354,1 +3354,1 @@\n-        return JLA.newStringNoRepl(ba, cs);\n+        return JLA.newStringReportError(ba, cs);\n@@ -3716,1 +3716,1 @@\n-        byte[] bytes = JLA.getBytesNoRepl(String.valueOf(csq), cs);\n+        byte[] bytes = JLA.getBytesReportError(String.valueOf(csq), cs);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Files.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -470,1 +470,1 @@\n-            return jla.newStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n+            return jla.newStringReportError(rep, StandardCharsets.ISO_8859_1);\n@@ -704,1 +704,1 @@\n-            return jla.newStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n+            return jla.newStringReportError(rep, StandardCharsets.ISO_8859_1);\n@@ -740,1 +740,1 @@\n-            return jla.newStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n+            return jla.newStringReportError(rep, StandardCharsets.ISO_8859_1);\n@@ -768,1 +768,1 @@\n-            return jla.newStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n+            return jla.newStringReportError(rep, StandardCharsets.ISO_8859_1);\n@@ -804,1 +804,1 @@\n-            return jla.newStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n+            return jla.newStringReportError(rep, StandardCharsets.ISO_8859_1);\n@@ -832,1 +832,1 @@\n-            return jla.newStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n+            return jla.newStringReportError(rep, StandardCharsets.ISO_8859_1);\n","filename":"src\/java.base\/share\/classes\/java\/util\/HexFormat.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -503,1 +503,1 @@\n-            return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+            return jla.newStringReportError(buf, StandardCharsets.ISO_8859_1);\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -270,1 +270,1 @@\n-            return JLA.newStringUTF8FailFast(ba, off, length);\n+            return JLA.newStringUTF8ReportError(ba, off, length);\n@@ -275,1 +275,1 @@\n-            return JLA.getBytesUTF8FailFast(s);\n+            return JLA.getBytesUTF8ReportError(s);\n@@ -289,1 +289,1 @@\n-                \/\/ We use the JLA.newStringUTF8FailFast variant to throw\n+                \/\/ We use the JLA.newStringUTF8ReportError variant to throw\n@@ -291,1 +291,1 @@\n-                return hash(JLA.newStringUTF8FailFast(a, off, len));\n+                return hash(JLA.newStringUTF8ReportError(a, off, len));\n@@ -309,1 +309,1 @@\n-                byte[] encoded = JLA.getBytesNoRepl(str, UTF_8.INSTANCE);\n+                byte[] encoded = JLA.getBytesReportError(str, UTF_8.INSTANCE);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipCoder.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -308,5 +308,7 @@\n-     * Constructs a new {@code String} by decoding the specified subarray of\n-     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n-     *\n-     * The caller of this method shall relinquish and transfer the ownership of\n-     * the byte array to the callee since the later will not make a copy.\n+     * Constructs a new String by decoding the specified sequence of\n+     * bytes using the specified Charset.\n+     * <p>\n+     * This method throws CharacterCodingException instead of replacing when\n+     * any malformed input or unmappable character is encountered.\n+     * <p>\n+     * The input byte array must not be accessible to user code or modified.\n@@ -319,1 +321,1 @@\n-    String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException;\n+    String newStringReportError(byte[] bytes, Charset cs) throws CharacterCodingException;\n@@ -323,4 +325,1 @@\n-     *\n-     * This method avoids copying the String's internal representation if the input\n-     * is ASCII.\n-     *\n+     * <p>\n@@ -328,1 +327,3 @@\n-     * malformed input or unmappable characters are encountered.\n+     * any malformed input or unmappable character is encountered.\n+     * <p>\n+     * The returned byte array must not be accessible to user code or modified.\n@@ -335,1 +336,1 @@\n-    byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException;\n+    byte[] getBytesReportError(String s, Charset cs) throws CharacterCodingException;\n@@ -338,1 +339,4 @@\n-     * Returns a new string by decoding from the given utf8 bytes array.\n+     * Returns a new string by decoding from the given utf8 range in the bytes array.\n+     * <p>\n+     * This method throws CharacterCodingException instead of replacing when\n+     * any malformed input or unmappable character is encountered.\n@@ -345,1 +349,1 @@\n-    String newStringUTF8FailFast(byte[] bytes, int off, int len);\n+    String newStringUTF8ReportError(byte[] bytes, int off, int len);\n@@ -358,1 +362,4 @@\n-     * Encode the given string into a sequence of bytes using utf8.\n+     * Encode the given string into a sequence of bytes in utf8.\n+     * <p>\n+     * This method throws CharacterCodingException instead of replacing when\n+     * any malformed input or unmappable character is encountered.\n@@ -364,1 +371,1 @@\n-    byte[] getBytesUTF8FailFast(String s);\n+    byte[] getBytesUTF8ReportError(String s);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":23,"deletions":16,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-            return JLA.getBytesNoRepl(input, Util.jnuEncoding());\n+            return JLA.getBytesReportError(input, Util.jnuEncoding());\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8286287 8288589\n- * @summary Tests for *NoRepl() shared secret methods.\n- * @run testng NoReplTest\n- * @modules jdk.charsets\n- *\/\n-\n-import java.io.IOException;\n-import java.nio.charset.CharacterCodingException;\n-import java.nio.charset.Charset;\n-import java.nio.file.Files;\n-import java.util.HexFormat;\n-import static java.nio.charset.StandardCharsets.UTF_16;\n-\n-import org.testng.annotations.Test;\n-\n-@Test\n-public class NoReplTest {\n-    private final static byte[] MALFORMED_UTF16 = {(byte)0x00, (byte)0x20, (byte)0x00};\n-    private final static String MALFORMED_WINDOWS_1252 = \"\\u0080\\u041e\";\n-    private final static Charset WINDOWS_1252 = Charset.forName(\"windows-1252\");\n-\n-    \/**\n-     * Verifies newStringNoRepl() throws a CharacterCodingException.\n-     * The method is invoked by `Files.readString()` method.\n-     *\/\n-    @Test\n-    public void newStringNoReplTest() throws IOException {\n-        var f = Files.createTempFile(null, null);\n-        try (var fos = Files.newOutputStream(f)) {\n-            fos.write(MALFORMED_UTF16);\n-            var read = Files.readString(f, UTF_16);\n-            throw new RuntimeException(\"Exception should be thrown for a malformed input. Bytes read: \" +\n-                    HexFormat.of()\n-                            .withPrefix(\"x\")\n-                            .withUpperCase()\n-                            .formatHex(read.getBytes(UTF_16)));\n-        } catch (CharacterCodingException cce) {\n-            \/\/ success\n-        } finally {\n-            Files.delete(f);\n-        }\n-    }\n-\n-    \/**\n-     * Verifies getBytesNoRepl() throws a CharacterCodingException.\n-     * The method is invoked by `Files.writeString()` method.\n-     *\/\n-    @Test\n-    public void getBytesNoReplTest() throws IOException {\n-        var f = Files.createTempFile(null, null);\n-        try {\n-            Files.writeString(f, MALFORMED_WINDOWS_1252, WINDOWS_1252);\n-            throw new RuntimeException(\"Exception should be thrown\");\n-        } catch (CharacterCodingException cce) {\n-            \/\/ success\n-        } finally {\n-            Files.delete(f);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/String\/NoReplTest.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8286287 8288589 8318486\n+ * @summary Tests for *ReportError() shared secret methods.\n+ * @run testng ReportErrorTest\n+ * @modules jdk.charsets\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.util.HexFormat;\n+import static java.nio.charset.StandardCharsets.UTF_16;\n+\n+import org.testng.annotations.Test;\n+\n+@Test\n+public class ReportErrorTest {\n+    private final static byte[] MALFORMED_UTF16 = {(byte)0x00, (byte)0x20, (byte)0x00};\n+    private final static String MALFORMED_WINDOWS_1252 = \"\\u0080\\u041e\";\n+    private final static Charset WINDOWS_1252 = Charset.forName(\"windows-1252\");\n+\n+    \/**\n+     * Verifies newStringReportError() throws a CharacterCodingException.\n+     * The method is invoked by `Files.readString()` method.\n+     *\/\n+    @Test\n+    public void newStringReportErrorTest() throws IOException {\n+        var f = Files.createTempFile(null, null);\n+        try (var fos = Files.newOutputStream(f)) {\n+            fos.write(MALFORMED_UTF16);\n+            var read = Files.readString(f, UTF_16);\n+            throw new RuntimeException(\"Exception should be thrown for a malformed input. Bytes read: \" +\n+                    HexFormat.of()\n+                            .withPrefix(\"x\")\n+                            .withUpperCase()\n+                            .formatHex(read.getBytes(UTF_16)));\n+        } catch (CharacterCodingException cce) {\n+            \/\/ success\n+        } finally {\n+            Files.delete(f);\n+        }\n+    }\n+\n+    \/**\n+     * Verifies getBytesReportError() throws a CharacterCodingException.\n+     * The method is invoked by `Files.writeString()` method.\n+     *\/\n+    @Test\n+    public void getBytesReportErrorTest() throws IOException {\n+        var f = Files.createTempFile(null, null);\n+        try {\n+            Files.writeString(f, MALFORMED_WINDOWS_1252, WINDOWS_1252);\n+            throw new RuntimeException(\"Exception should be thrown\");\n+        } catch (CharacterCodingException cce) {\n+            \/\/ success\n+        } finally {\n+            Files.delete(f);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/String\/ReportErrorTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"}]}