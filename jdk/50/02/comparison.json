{"files":[{"patch":"@@ -223,1 +223,5 @@\n-    \/\/ Flag bit (1L << 40) is available.\n+    \/**\n+     * Flags an erroneous TypeSymbol as viable for recovery.\n+     * TypeSymbols only.\n+     *\/\n+    public static final long RECOVERABLE = 1L<<40;\n@@ -511,0 +515,1 @@\n+        RECOVERABLE(Flags.RECOVERABLE),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -123,0 +123,1 @@\n+    final AttrRecover attrRecover;\n@@ -160,0 +161,1 @@\n+        attrRecover = AttrRecover.instance(context);\n@@ -422,1 +424,1 @@\n-                    null, DeferredAttr.AttributionMode.ANALYZER,\n+                    null, DeferredAttr.AttributionMode.ATTRIB_TO_TREE,\n@@ -424,0 +426,1 @@\n+            attrRecover.doRecovery();\n@@ -741,0 +744,1 @@\n+        attrRecover.doRecovery();\n@@ -2095,0 +2099,1 @@\n+            attrRecover.doRecovery();\n@@ -3117,0 +3122,1 @@\n+            attrRecover.doRecovery();\n@@ -4310,4 +4316,1 @@\n-                Type pt = resultInfo.pt.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.SPECULATIVE, sym, env.info.pendingResolutionPhase));\n-                Type owntype = checkIdInternal(tree, site, sym, pt, env, resultInfo);\n-                resultInfo.pt.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.CHECK, sym, env.info.pendingResolutionPhase));\n-                return owntype;\n+                return attrRecover.recoverMethodInvocation(tree, site, sym, env, resultInfo);\n@@ -4919,1 +4922,3 @@\n-        if (tree.errs != null)\n+        if (tree.errs != null) {\n+            Env<AttrContext> errEnv = env.dup(env.tree);\n+            errEnv.info.returnResult = unknownExprInfo;\n@@ -4921,1 +4926,2 @@\n-                attribTree(err, env, new ResultInfo(KindSelector.ERR, pt()));\n+                attribTree(err, errEnv, new ResultInfo(KindSelector.ERR, pt()));\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,282 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.javac.comp;\n+\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Symbol.TypeSymbol;\n+import com.sun.tools.javac.code.Symtab;\n+import com.sun.tools.javac.code.Type;\n+import com.sun.tools.javac.code.Type.ArrayType;\n+import com.sun.tools.javac.code.Type.ErrorType;\n+import com.sun.tools.javac.code.TypeTag;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.comp.Attr.ResultInfo;\n+import com.sun.tools.javac.comp.DeferredAttr.AttrMode;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.JCBlock;\n+import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n+import com.sun.tools.javac.tree.JCTree.JCErroneous;\n+import com.sun.tools.javac.tree.JCTree.JCExpression;\n+import com.sun.tools.javac.tree.JCTree.JCLambda;\n+import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;\n+import com.sun.tools.javac.tree.JCTree.JCReturn;\n+import com.sun.tools.javac.tree.JCTree.JCVariableDecl;\n+import com.sun.tools.javac.tree.JCTree.Tag;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.tree.TreeMaker;\n+import com.sun.tools.javac.tree.TreeTranslator;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.JCDiagnostic;\n+import com.sun.tools.javac.util.List;\n+import com.sun.tools.javac.util.ListBuffer;\n+import com.sun.tools.javac.util.Names;\n+\n+\/** This is an error recovery addon for Attr. Currently, it recovers\n+ *  method invocations with lambdas, that require type inference.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class AttrRecover {\n+    protected static final Context.Key<AttrRecover> attrRepairKey = new Context.Key<>();\n+\n+    final Attr attr;\n+    final DeferredAttr deferredAttr;\n+    final Names names;\n+    final TreeMaker make;\n+    final Symtab syms;\n+    final Types types;\n+\n+    public static AttrRecover instance(Context context) {\n+        AttrRecover instance = context.get(attrRepairKey);\n+        if (instance == null)\n+            instance = new AttrRecover(context);\n+        return instance;\n+    }\n+\n+    protected AttrRecover(Context context) {\n+        context.put(attrRepairKey, this);\n+\n+        attr = Attr.instance(context);\n+        deferredAttr = DeferredAttr.instance(context);\n+        names = Names.instance(context);\n+        make = TreeMaker.instance(context);\n+        syms = Symtab.instance(context);\n+        types = Types.instance(context);\n+    }\n+\n+    private final ListBuffer<RecoverTodo> recoveryTodo = new ListBuffer<>();\n+\n+    public void doRecovery() {\n+        while (recoveryTodo.nonEmpty()) {\n+            RecoverTodo todo = recoveryTodo.remove();\n+            ListBuffer<Runnable> rollback = new ListBuffer<>();\n+            boolean repaired = false;\n+            RECOVER: if (todo.env.tree.hasTag(Tag.APPLY)) {\n+                JCMethodInvocation mit = (JCMethodInvocation) todo.env.tree;\n+                boolean vararg = (todo.candSym.flags() & Flags.VARARGS) !=  0;\n+                if (!vararg &&\n+                    mit.args.length() > todo.candSym.type.getParameterTypes().length()) {\n+                    break RECOVER; \/\/too many actual parameters, skip\n+                }\n+                List<JCExpression> args = mit.args;\n+                List<Type> formals = todo.candSym.type.getParameterTypes();\n+                while (args.nonEmpty() && formals.nonEmpty()) {\n+                    JCExpression arg = args.head;\n+                    Type formal = formals.tail.nonEmpty() || !vararg\n+                            ? formals.head : ((ArrayType) formals.head).elemtype;\n+                    if (arg.hasTag(JCTree.Tag.LAMBDA)) {\n+                        final JCTree.JCLambda lambda = (JCLambda) arg;\n+                        if (lambda.paramKind == JCLambda.ParameterKind.IMPLICIT) {\n+                            for (JCVariableDecl var : lambda.params) {\n+                                var.vartype = null; \/\/reset type\n+                            }\n+                        }\n+                        if (types.isFunctionalInterface(formal)) {\n+                            Type functionalType = types.findDescriptorType(formal);\n+                            boolean voidCompatible = functionalType.getReturnType().hasTag(TypeTag.VOID);\n+                            lambda.body = new TreeTranslator() {\n+                                @Override\n+                                public void visitReturn(JCReturn tree) {\n+                                    result = tree;\n+                                    if (voidCompatible) {\n+                                        if (tree.expr != null) {\n+                                            JCErroneous err = make.Erroneous(List.of(tree));\n+                                            result = err;\n+                                            rollback.append(() -> {\n+                                                lambda.body = new TreeTranslator() {\n+                                                    @SuppressWarnings(\"unchecked\")\n+                                                    public <T extends JCTree> T translate(T t) {\n+                                                        if (t == err) return (T) tree;\n+                                                        else return super.translate(t);\n+                                                    }\n+                                                }.translate(lambda.body);\n+                                            });\n+                                        }\n+                                    } else {\n+                                        if (tree.expr == null) {\n+                                            tree.expr = make.Erroneous().setType(syms.errType);\n+                                            rollback.append(() -> {\n+                                                tree.expr = null;\n+                                            });\n+                                        }\n+                                    }\n+                                }\n+                                @Override\n+                                public void visitLambda(JCLambda tree) {\n+                                    \/\/do not touch nested lambdas\n+                                }\n+                                @Override\n+                                public void visitClassDef(JCClassDecl tree) {\n+                                    \/\/do not touch nested classes\n+                                }\n+                            }.translate(lambda.body);\n+                            if (!voidCompatible) {\n+                                JCReturn ret = make.Return(make.Erroneous().setType(syms.errType));\n+                                ((JCBlock) lambda.body).stats = ((JCBlock) lambda.body).stats.append(ret);\n+                                rollback.append(() -> {\n+                                    ((JCBlock) lambda.body).stats = List.filter(((JCBlock) lambda.body).stats, ret);\n+                                });\n+                            }\n+                        }\n+                        repaired = true;\n+                    }\n+                    args = args.tail;\n+                    if (formals.tail.nonEmpty() || !vararg) {\n+                        formals = formals.tail;\n+                    }\n+                }\n+                List<JCExpression> prevArgs = mit.args;\n+                while (formals.nonEmpty()) {\n+                    mit.args = mit.args.append(make.Erroneous().setType(syms.errType));\n+                    formals = formals.tail;\n+                    repaired = true;\n+                }\n+                rollback.append(() -> {\n+                    mit.args = prevArgs;\n+                });\n+            }\n+\n+            Type owntype;\n+            if (repaired) {\n+                List<JCExpression> args = TreeInfo.args(todo.env.tree);\n+                List<Type> pats = todo.resultInfo.pt.getParameterTypes();\n+                while (pats.length() < args.length()) {\n+                    pats = pats.append(syms.errType);\n+                }\n+                owntype = attr.checkMethod(todo.site, todo.candSym,\n+                                 attr.new ResultInfo(todo.resultInfo.pkind, todo.resultInfo.pt.getReturnType(), todo.resultInfo.checkContext, todo.resultInfo.checkMode),\n+                                 todo.env, args, pats,\n+                                 todo.resultInfo.pt.getTypeArguments());\n+                rollback.stream().forEach(Runnable::run);\n+            } else {\n+                owntype = basicMethodInvocationRecovery(todo.tree, todo.site, todo.errSym, todo.env, todo.resultInfo);\n+            }\n+            todo.tree.type = owntype;\n+        }\n+    }\n+\n+    Type recoverMethodInvocation(JCTree tree,\n+                                 Type site,\n+                                 Symbol sym,\n+                                 Env<AttrContext> env,\n+                                 ResultInfo resultInfo) {\n+        if ((sym.flags_field & Flags.RECOVERABLE) != 0 && env.info.attributionMode.recover()) {\n+            recoveryTodo.append(new RecoverTodo(tree, site, sym, ((RecoveryErrorType) sym.type).candidateSymbol, attr.copyEnv(env), resultInfo));\n+            return syms.errType;\n+        } else {\n+            return basicMethodInvocationRecovery(tree, site, sym, env, resultInfo);\n+        }\n+    }\n+\n+    private Type basicMethodInvocationRecovery(JCTree tree,\n+                                               Type site,\n+                                               Symbol sym,\n+                                               Env<AttrContext> env,\n+                                               ResultInfo resultInfo) {\n+        Type pt = resultInfo.pt.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.SPECULATIVE, sym, env.info.pendingResolutionPhase));\n+        Type owntype = attr.checkIdInternal(tree, site, sym, pt, env, resultInfo);\n+        resultInfo.pt.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.CHECK, sym, env.info.pendingResolutionPhase));\n+        return owntype;\n+    }\n+\n+    void wrongMethodSymbolCandidate(TypeSymbol errSymbol, Symbol candSym, JCDiagnostic diag) {\n+        List<JCDiagnostic> diags = List.of(diag);\n+        boolean recoverable = false;\n+        while (!recoverable && diags.nonEmpty()) {\n+            JCDiagnostic d = diags.head;\n+            diags = diags.tail;\n+            switch (d.getCode()) {\n+                case \"compiler.misc.missing.ret.val\":\n+                case \"compiler.misc.unexpected.ret.val\":\n+                case \"compiler.misc.infer.arg.length.mismatch\":\n+                case \"compiler.misc.arg.length.mismatch\":\n+                    errSymbol.type = new RecoveryErrorType((Type.ErrorType) errSymbol.type, candSym);\n+                    errSymbol.flags_field |= Flags.RECOVERABLE;\n+                    return ;\n+                default:\n+                    break;\n+            }\n+            for (Object a : d.getArgs()) {\n+                if (a instanceof JCDiagnostic) {\n+                    diags = diags.prepend((JCDiagnostic) a);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static class RecoveryErrorType extends ErrorType {\n+        public final Symbol candidateSymbol;\n+\n+        public RecoveryErrorType(ErrorType original, Symbol candidateSymbol) {\n+            super(original.getOriginalType(), original.tsym);\n+            this.candidateSymbol = candidateSymbol;\n+        }\n+\n+    }\n+\n+    private static class RecoverTodo {\n+        public final JCTree tree;\n+        public final Type site;\n+        public final Symbol errSym;\n+        public final Symbol candSym;\n+        public final Env<AttrContext> env;\n+        public final ResultInfo resultInfo;\n+\n+        public RecoverTodo(JCTree tree, Type site, Symbol errSym, Symbol candSym,\n+                           Env<AttrContext> env, Attr.ResultInfo resultInfo) {\n+            this.tree = tree;\n+            this.site = site;\n+            this.errSym = errSym;\n+            this.candSym = candSym;\n+            this.env = env;\n+            this.resultInfo = resultInfo;\n+        }\n+\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/AttrRecover.java","additions":282,"deletions":0,"binary":false,"changes":282,"status":"added"},{"patch":"@@ -1332,1 +1332,1 @@\n-        FULL(false),\n+        FULL(false, true),\n@@ -1334,1 +1334,3 @@\n-        ANALYZER(true),\n+        ATTRIB_TO_TREE(true, true),\n+        \/**Speculative attribution on behalf of an Analyzer.*\/\n+        ANALYZER(true, false),\n@@ -1336,1 +1338,1 @@\n-        SPECULATIVE(true);\n+        SPECULATIVE(true, false);\n@@ -1338,1 +1340,1 @@\n-        AttributionMode(boolean isSpeculative) {\n+        AttributionMode(boolean isSpeculative, boolean recover) {\n@@ -1340,0 +1342,1 @@\n+            this.recover = recover;\n@@ -1346,0 +1349,4 @@\n+        boolean recover() {\n+            return recover;\n+        }\n+\n@@ -1347,0 +1354,1 @@\n+        final boolean recover;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/DeferredAttr.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+    AttrRecover attrRecover;\n@@ -129,0 +130,1 @@\n+        attrRecover = AttrRecover.instance(context);\n@@ -4046,6 +4048,6 @@\n-            Symbol sym = bestCandidate();\n-            return types.createErrorType(name, location, sym != null ? sym.type : syms.errSymbol.type).tsym;\n-        }\n-\n-        protected Symbol bestCandidate() {\n-            return errCandidate().fst;\n+            Pair<Symbol, JCDiagnostic> cand = errCandidate();\n+            TypeSymbol errSymbol = types.createErrorType(name, location, cand != null ? cand.fst.type : syms.errSymbol.type).tsym;\n+            if (cand != null) {\n+                attrRecover.wrongMethodSymbolCandidate(errSymbol, cand.fst, cand.snd);\n+            }\n+            return errSymbol;\n@@ -4184,1 +4186,1 @@\n-        protected Symbol bestCandidate() {\n+        protected Pair<Symbol, JCDiagnostic> errCandidate() {\n@@ -4188,1 +4190,2 @@\n-                return filteredCandidates.keySet().iterator().next();\n+                return Pair.of(filteredCandidates.keySet().iterator().next(),\n+                               filteredCandidates.values().iterator().next());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8131025 8141092 8153761 8145263 8131019 8175886 8176184 8176241 8176110 8177466 8197439 8221759 8234896\n+ * @bug 8131025 8141092 8153761 8145263 8131019 8175886 8176184 8176241 8176110 8177466 8197439 8221759 8234896 8240658\n@@ -701,0 +701,21 @@\n+    public void testBrokenLambdaCompletion() {\n+        assertEval(\"interface Consumer<T> { public void consume(T t); }\");\n+        assertEval(\"interface Function<T, R> { public R convert(T t); }\");\n+        assertEval(\"<T> void m1(T t, Consumer<T> f) { }\");\n+        assertCompletion(\"m1(\\\"\\\", x -> {x.tri|\", \"trim()\");\n+        assertEval(\"<T> void m2(T t, Function<T, String> f) { }\");\n+        assertCompletion(\"m2(\\\"\\\", x -> {x.tri|\", \"trim()\");\n+        assertEval(\"<T> void m3(T t, Consumer<T> f, int i) { }\");\n+        assertCompletion(\"m3(\\\"\\\", x -> {x.tri|\", \"trim()\");\n+        assertEval(\"<T> void m4(T t, Function<T, String> f, int i) { }\");\n+        assertCompletion(\"m4(\\\"\\\", x -> {x.tri|\", \"trim()\");\n+        assertEval(\"<T> T m5(Consumer<T> f) { return null; }\");\n+        assertCompletion(\"String s = m5(x -> {x.tri|\", \"trim()\");\n+        assertEval(\"<T> T m6(Function<T, String> f) { return null; }\");\n+        assertCompletion(\"String s = m6(x -> {x.tri|\", \"trim()\");\n+        assertEval(\"<T> T m7(Consumer<T> f, int i) { return null; }\");\n+        assertCompletion(\"String s = m7(x -> {x.tri|\", \"trim()\");\n+        assertEval(\"<T> T m8(Function<T, String> f, int i) { return null; }\");\n+        assertCompletion(\"String s = m8(x -> {x.tri|\", \"trim()\");\n+    }\n+\n","filename":"test\/langtools\/jdk\/jshell\/CompletionSuggestionTest.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8205418 8207229 8207230 8230847 8245786 8247334 8248641\n+ * @bug 8205418 8207229 8207230 8230847 8245786 8247334 8248641 8240658\n@@ -32,0 +32,1 @@\n+ * @compile TestGetScopeResult.java\n@@ -65,0 +66,1 @@\n+import com.sun.tools.javac.api.JavacTaskImpl;\n@@ -195,0 +197,13 @@\n+\n+        String[] infer = {\n+            \"c:java.lang.String\",\n+            \"super:java.lang.Object\",\n+            \"this:Test\"\n+        };\n+\n+        doTest(\"class Test { void test() { cand(\\\"\\\", c -> { }); } <T>void cand(T t, I<T> i) { } interface I<T> { public String test(T s); }  }\",\n+               infer);\n+        doTest(\"class Test { void test() { cand(\\\"\\\", c -> { }); } <T>void cand(T t, I<T> i, int j) { } interface I<T> { public void test(T s); }  }\",\n+               infer);\n+        doTest(\"class Test { void test() { cand(\\\"\\\", c -> { }); } <T>void cand(T t, I<T> i, int j) { } interface I<T> { public String test(T s); }  }\",\n+               infer);\n@@ -211,1 +226,0 @@\n-            t.analyze();\n@@ -213,1 +227,1 @@\n-            List<String> actual = new ArrayList<>();\n+            ((JavacTaskImpl)t).enter();\n@@ -215,8 +229,11 @@\n-            new TreePathScanner<Void, Void>() {\n-                @Override\n-                public Void visitLambdaExpression(LambdaExpressionTree node, Void p) {\n-                    Scope scope = Trees.instance(t).getScope(new TreePath(getCurrentPath(), node.getBody()));\n-                    actual.addAll(dumpScope(scope));\n-                    return super.visitLambdaExpression(node, p);\n-                }\n-            }.scan(cut, null);\n+            for (int r = 0; r < 2; r++) {\n+                List<String> actual = new ArrayList<>();\n+\n+                new TreePathScanner<Void, Void>() {\n+                    @Override\n+                    public Void visitLambdaExpression(LambdaExpressionTree node, Void p) {\n+                        Scope scope = Trees.instance(t).getScope(new TreePath(getCurrentPath(), node.getBody()));\n+                        actual.addAll(dumpScope(scope));\n+                        return super.visitLambdaExpression(node, p);\n+                    }\n+                }.scan(cut, null);\n@@ -224,1 +241,6 @@\n-            List<String> expectedList = List.of(expected);\n+                List<String> expectedList = List.of(expected);\n+\n+                if (!expectedList.equals(actual)) {\n+                    throw new IllegalStateException(\"Unexpected scope content: \" + actual + \"\\n\" +\n+                                                     \"expected: \" + expectedList);\n+                }\n@@ -226,3 +248,1 @@\n-            if (!expectedList.equals(actual)) {\n-                throw new IllegalStateException(\"Unexpected scope content: \" + actual + \"\\n\" +\n-                                                 \"expected: \" + expectedList);\n+                t.analyze();\n","filename":"test\/langtools\/tools\/javac\/api\/TestGetScopeResult.java","additions":35,"deletions":15,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,248 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8240658\n+ * @summary Verify that broken method invocations with lambdas get type inference done\n+ * @modules jdk.compiler\n+ * @compile --enable-preview -source ${jdk.version} TestGetTypeMirrorReference.java\n+ * @run main\/othervm --enable-preview TestGetTypeMirrorReference\n+ *\/\n+\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.util.*;\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import javax.lang.model.type.TypeMirror;\n+import javax.tools.DiagnosticCollector;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.StandardJavaFileManager;\n+import javax.tools.ToolProvider;\n+\n+\/*\n+ * This test verifies proper error recovery for method invocations which need\n+ * type inference, and have lambdas as arguments.\n+ *\n+ * The test will read the adjacent TestGetTypeMirrorReferenceData.java, parse and\n+ * attribute it, and call Trees.getTypeMirror on each place marked, in a block\n+ * comment, with:\n+ * getTypeMirror:<expected-typemirror-kind>:<expected-typemirror-toString>\n+ * The actual retrieved TypeMirror will be checked against the provided description,\n+ * verifying the return value of TypeMirror.getKind and TypeMirror.toString().\n+ *\n+ * The AST for TestGetTypeMirrorReferenceData.java will also be printed using\n+ * Tree.toString(), and compared to the expected AST form.\n+ *\/\n+public class TestGetTypeMirrorReference {\n+\n+    private static final String JDK_VERSION =\n+            Integer.toString(Runtime.version().feature());\n+\n+    public static void main(String... args) throws IOException {\n+        analyze(\"TestGetTypeMirrorReferenceData.java\",\n+                \"\"\"\n+                package test;\n+\n+                public class TestGetTypeMirrorReferenceData {\n+\n+                    public TestGetTypeMirrorReferenceData() {\n+                        super();\n+                    }\n+\n+                    private static void test() {\n+                        Test.of(1).convert((c1)->{\n+                            Object o = c1;\n+                        });\n+                        Test.of(1).consume((c2)->{\n+                            Object o = c2;\n+                            return null;\n+                        });\n+                        Test.of(1).consumeWithParam((c3)->{\n+                            Object o = c3;\n+                        });\n+                        convert(0, (c4)->{\n+                            Object o = c4;\n+                        });\n+                        consume(0, (c5)->{\n+                            Object o = c5;\n+                        });\n+                        convertVarArgs(0, (c6)->{\n+                            Object o = c6;\n+                        }, 1, 2, 3, 4);\n+                        consumeVarArgs(0, (c7)->{\n+                            Object o = c7;\n+                        }, 1, 2, 3, 4);\n+                        convertVarArgs2(0, (c8)->{\n+                            Object o = c8;\n+                        }, (c8)->{\n+                            Object o = c8;\n+                        });\n+                        consumeVarArgs2(0, (c9)->{\n+                            Object o = c9;\n+                        }, (c9)->{\n+                            Object o = c9;\n+                        });\n+                    }\n+\n+                    public <T, R>R convert(T t, Function<T, R> f, int i) {\n+                        return null;\n+                    }\n+\n+                    public <T>void consume(T t, Consumer<T> c, int i) {\n+                    }\n+\n+                    public <T, R>R convertVarArgs(T t, Function<T, R> c, int... i) {\n+                        return null;\n+                    }\n+\n+                    public <T>void consumeVarArgs(T t, Consumer<T> c, int... i) {\n+                    }\n+\n+                    public <T, R>R convertVarArgs2(T t, Function<T, R>... c) {\n+                        return null;\n+                    }\n+\n+                    public <T>void consumeVarArgs2(T t, Consumer<T>... c) {\n+                    }\n+\n+                    public static class Test<T> {\n+\n+                        public Test() {\n+                            super();\n+                        }\n+\n+                        public static <T>Test<T> of(T t) {\n+                            return new Test<>();\n+                        }\n+\n+                        public <R>Test<R> convert(Function<T, R> c) {\n+                            return null;\n+                        }\n+\n+                        public void consume(Consumer<T> c) {\n+                        }\n+\n+                        public void consumeWithParam(Consumer<T> c, int i) {\n+                        }\n+                    }\n+\n+                    public interface Function<T, R> {\n+\n+                        public R map(T t);\n+                    }\n+\n+                    public interface Consumer<T> {\n+\n+                        public void run(T t);\n+                    }\n+                }\"\"\");\n+    }\n+\n+    private static void analyze(String fileName, String expectedAST) throws IOException {\n+        try (StandardJavaFileManager fm = ToolProvider.getSystemJavaCompiler().getStandardFileManager(null, null, null)) {\n+            List<JavaFileObject> files = new ArrayList<>();\n+            File source = new File(System.getProperty(\"test.src\", \".\"), fileName.replace('\/', File.separatorChar)).getAbsoluteFile();\n+            for (JavaFileObject f : fm.getJavaFileObjects(source)) {\n+                files.add(f);\n+            }\n+            DiagnosticCollector<JavaFileObject> diagnostics = new DiagnosticCollector<>();\n+            List<String> options = List.of(\"-source\", JDK_VERSION,\n+                                           \"-XDshould-stop.at=FLOW\");\n+            JavacTask ct = (JavacTask) ToolProvider.getSystemJavaCompiler().getTask(null, null, diagnostics, options, null, files);\n+            Trees trees = Trees.instance(ct);\n+            CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+            ct.analyze();\n+\n+            String actualAST = Arrays.stream(cut.toString().split(\"\\n\"))\n+                                     .map(l -> l.stripTrailing())\n+                                     .collect(Collectors.joining(\"\\n\"));\n+\n+            if (!expectedAST.equals(actualAST)) {\n+                throw new AssertionError(\"Unexpected AST shape!\\n\" + actualAST);\n+            }\n+\n+            Pattern p = Pattern.compile(\"\/\\\\*getTypeMirror:(.*?)\\\\*\/\");\n+            Matcher m = p.matcher(cut.getSourceFile().getCharContent(false));\n+\n+            while (m.find()) {\n+                TreePath tp = pathFor(trees, cut, m.start() - 1);\n+                String expected = m.group(1);\n+                if (expected.startsWith(\"getParentPath:\")) {\n+                    tp = tp.getParentPath();\n+                    expected = expected.substring(\"getParentPath:\".length());\n+                }\n+                TypeMirror found = trees.getTypeMirror(tp);\n+                String actual = found != null ? found.getKind() + \":\" + typeToString(found) : \"<null>\";\n+\n+                if (!expected.equals(actual)) {\n+                    throw new IllegalStateException(\"expected=\" + expected + \"; actual=\" + actual + \"; tree: \" + tp.getLeaf());\n+                }\n+            }\n+        }\n+    }\n+\n+    private static TreePath pathFor(final Trees trees, final CompilationUnitTree cut, final int pos) {\n+        final TreePath[] result = new TreePath[1];\n+\n+        new TreePathScanner<Void, Void>() {\n+            @Override public Void scan(Tree node, Void p) {\n+                if (   node != null\n+                    && trees.getSourcePositions().getStartPosition(cut, node) <= pos\n+                    && pos <= trees.getSourcePositions().getEndPosition(cut, node)) {\n+                    result[0] = new TreePath(getCurrentPath(), node);\n+                    return super.scan(node, p);\n+                }\n+                return null;\n+            }\n+        }.scan(cut, null);\n+\n+        return result[0];\n+    }\n+\n+    private static String typeToString(TypeMirror type) {\n+        return type.toString();\n+    }\n+\n+    static class TestFileObject extends SimpleJavaFileObject {\n+        private final String text;\n+        public TestFileObject(String text) {\n+            super(URI.create(\"myfo:\/Test.java\"), JavaFileObject.Kind.SOURCE);\n+            this.text = text;\n+        }\n+        @Override public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+            return text;\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/api\/lambdaErrorRecovery\/TestGetTypeMirrorReference.java","additions":248,"deletions":0,"binary":false,"changes":248,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test;\n+\n+public class TestGetTypeMirrorReferenceData {\n+\n+    private static void test() {\n+        Test.of(1).convert(c1 -> {Object o = c1\/*getTypeMirror:DECLARED:java.lang.Integer*\/;});\n+        Test.of(1).consume(c2 -> {Object o = c2\/*getTypeMirror:DECLARED:java.lang.Integer*\/; return null;});\n+        Test.of(1).consumeWithParam(c3 -> {Object o = c3\/*getTypeMirror:DECLARED:java.lang.Integer*\/;});\n+        convert(0, c4 -> {Object o = c4\/*getTypeMirror:DECLARED:java.lang.Integer*\/;});\n+        consume(0, c5 -> {Object o = c5\/*getTypeMirror:DECLARED:java.lang.Integer*\/;});\n+        convertVarArgs(0, c6 -> {Object o = c6\/*getTypeMirror:DECLARED:java.lang.Integer*\/;}, 1, 2, 3, 4);\n+        consumeVarArgs(0, c7 -> {Object o = c7\/*getTypeMirror:DECLARED:java.lang.Integer*\/;}, 1, 2, 3, 4);\n+        convertVarArgs2(0, c8 -> {Object o = c8\/*getTypeMirror:DECLARED:java.lang.Integer*\/;}, c8 -> {Object o = c8\/*getTypeMirror:DECLARED:java.lang.Integer*\/;});\n+        consumeVarArgs2(0, c9 -> {Object o = c9\/*getTypeMirror:DECLARED:java.lang.Integer*\/;}, c9 -> {Object o = c9\/*getTypeMirror:DECLARED:java.lang.Integer*\/;});\n+    }\n+    public <T, R> R convert(T t, Function<T, R> f, int i) {\n+        return null;\n+    }\n+    public <T> void consume(T t, Consumer<T> c, int i) {\n+    }\n+    public <T, R> R convertVarArgs(T t, Function<T, R> c, int... i) {\n+        return null;\n+    }\n+    public <T> void consumeVarArgs(T t, Consumer<T> c, int... i) {\n+    }\n+    public <T, R> R convertVarArgs2(T t, Function<T, R>... c) {\n+        return null;\n+    }\n+    public <T> void consumeVarArgs2(T t, Consumer<T>... c) {\n+    }\n+    public static class Test<T> {\n+        public static <T> Test<T> of(T t) {\n+            return new Test<>();\n+        }\n+        public <R> Test<R> convert(Function<T, R> c) {\n+            return null;\n+        }\n+        public void consume(Consumer<T> c) {}\n+        public void consumeWithParam(Consumer<T> c, int i) {}\n+    }\n+    public interface Function<T, R> {\n+        public R map(T t);\n+    }\n+    public interface Consumer<T> {\n+        public void run(T t);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/api\/lambdaErrorRecovery\/TestGetTypeMirrorReferenceData.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"}]}