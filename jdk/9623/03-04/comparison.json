{"files":[{"patch":"@@ -40,1 +40,1 @@\n- * @summary Test various reverse bytes ideal transforms.\n+ * @summary Test various reverse bytes ideal transforms on X86(AVX2, AVX512) and AARCH64(NEON)\n@@ -80,1 +80,1 @@\n-    @IR(applyIfCPUFeature={\"sve\", \"true\"}, failOn = {IRNode.REVERSE_BYTES_V})\n+    @IR(applyIfCPUFeatureOr = {\"simd\", \"true\", \"avx2\", \"true\"}, counts = {IRNode.REVERSE_BYTES_V , \" > 0 \"})\n@@ -85,1 +85,1 @@\n-                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n@@ -99,1 +99,1 @@\n-    @IR(applyIfCPUFeatureOr={\"simd\", \"true\", \"avx2\", \"true\"}, counts = {IRNode.REVERSE_BYTES_V , \" > 0 \"})\n+    @IR(applyIfCPUFeatureOr = {\"simd\", \"true\", \"avx2\", \"true\"}, counts = {IRNode.REVERSE_BYTES_V , \" > 0 \"})\n@@ -101,1 +101,2 @@\n-        VectorMask<Long> mask = VectorMask.fromLong(LSPECIES, 3);\n+        VectorMask<Long> mask1 = VectorMask.fromLong(LSPECIES, 3);\n+        VectorMask<Long> mask2 = VectorMask.fromLong(LSPECIES, 3);\n@@ -104,2 +105,2 @@\n-                     .lanewise(VectorOperators.REVERSE_BYTES)\n-                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask1)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask2)\n@@ -118,1 +119,1 @@\n-    @IR(applyIfCPUFeatureOr={\"simd\", \"true\", \"avx2\", \"true\"}, counts = {IRNode.REVERSE_BYTES_V , \" > 0 \"})\n+    @IR(applyIfCPUFeatureOr = {\"simd\", \"true\", \"avx2\", \"true\"}, failOn = {IRNode.REVERSE_BYTES_V})\n@@ -120,2 +121,0 @@\n-        VectorMask<Long> mask1 = VectorMask.fromLong(LSPECIES, 3);\n-        VectorMask<Long> mask2 = VectorMask.fromLong(LSPECIES, 3);\n@@ -124,2 +123,2 @@\n-                     .lanewise(VectorOperators.REVERSE_BYTES, mask1)\n-                     .lanewise(VectorOperators.REVERSE_BYTES, mask2)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n@@ -138,19 +137,1 @@\n-    @IR(applyIfCPUFeatureOr={\"simd\", \"true\", \"avx2\", \"true\"}, failOn = {IRNode.REVERSE_BYTES_V})\n-    public void test_reversebytes_long_transform4(long[] lout, long[] linp) {\n-        for (int i = 0; i < LSPECIES.loopBound(linp.length); i+=LSPECIES.length()) {\n-            LongVector.fromArray(LSPECIES, linp, i)\n-                     .lanewise(VectorOperators.REVERSE_BYTES)\n-                     .lanewise(VectorOperators.REVERSE_BYTES)\n-                     .intoArray(lout, i);\n-        }\n-    }\n-\n-    @Run(test = {\"test_reversebytes_long_transform4\"}, mode = RunMode.STANDALONE)\n-    public void kernel_test_reversebytes_long_transform4() {\n-        for (int i = 0; i < ITERS; i++) {\n-            test_reversebytes_long_transform4(lout, linp);\n-        }\n-    }\n-\n-    @Test\n-    @IR(applyIfCPUFeature={\"sve\", \"true\"}, failOn = {IRNode.REVERSE_BYTES_V})\n+    @IR(applyIfCPUFeatureOr = {\"simd\", \"true\", \"avx2\", \"true\"}, counts = {IRNode.REVERSE_BYTES_V , \" > 0 \"})\n@@ -161,1 +142,1 @@\n-                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n@@ -175,1 +156,1 @@\n-    @IR(applyIfCPUFeatureOr={\"simd\", \"true\", \"avx2\", \"true\"}, counts = {IRNode.REVERSE_BYTES_V , \" > 0 \"})\n+    @IR(applyIfCPUFeatureOr = {\"simd\", \"true\", \"avx2\", \"true\"}, counts = {IRNode.REVERSE_BYTES_V , \" > 0 \"})\n@@ -177,1 +158,2 @@\n-        VectorMask<Integer> mask = VectorMask.fromLong(ISPECIES, 3);\n+        VectorMask<Integer> mask1 = VectorMask.fromLong(ISPECIES, 3);\n+        VectorMask<Integer> mask2 = VectorMask.fromLong(ISPECIES, 3);\n@@ -180,2 +162,2 @@\n-                     .lanewise(VectorOperators.REVERSE_BYTES)\n-                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask1)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask2)\n@@ -194,1 +176,1 @@\n-    @IR(applyIfCPUFeatureOr={\"simd\", \"true\", \"avx2\", \"true\"}, counts = {IRNode.REVERSE_BYTES_V , \" > 0 \"})\n+    @IR(applyIfCPUFeatureOr = {\"simd\", \"true\", \"avx2\", \"true\"}, failOn = {IRNode.REVERSE_BYTES_V})\n@@ -196,2 +178,0 @@\n-        VectorMask<Integer> mask1 = VectorMask.fromLong(ISPECIES, 3);\n-        VectorMask<Integer> mask2 = VectorMask.fromLong(ISPECIES, 3);\n@@ -200,2 +180,2 @@\n-                     .lanewise(VectorOperators.REVERSE_BYTES, mask1)\n-                     .lanewise(VectorOperators.REVERSE_BYTES, mask2)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n@@ -214,19 +194,1 @@\n-    @IR(applyIfCPUFeatureOr={\"simd\", \"true\", \"avx2\", \"true\"}, failOn = {IRNode.REVERSE_BYTES_V})\n-    public void test_reversebytes_int_transform4(int[] iout, int[] iinp) {\n-        for (int i = 0; i < ISPECIES.loopBound(iinp.length); i+=ISPECIES.length()) {\n-            IntVector.fromArray(ISPECIES, iinp, i)\n-                     .lanewise(VectorOperators.REVERSE_BYTES)\n-                     .lanewise(VectorOperators.REVERSE_BYTES)\n-                     .intoArray(iout, i);\n-        }\n-    }\n-\n-    @Run(test = {\"test_reversebytes_int_transform4\"}, mode = RunMode.STANDALONE)\n-    public void kernel_test_reversebytes_int_transform4() {\n-        for (int i = 0; i < ITERS; i++) {\n-            test_reversebytes_int_transform4(iout, iinp);\n-        }\n-    }\n-\n-    @Test\n-    @IR(applyIfCPUFeature={\"sve\", \"true\"}, failOn = {IRNode.REVERSE_BYTES_V})\n+    @IR(applyIfCPUFeatureOr = {\"simd\", \"true\", \"avx2\", \"true\"}, counts = {IRNode.REVERSE_BYTES_V , \" > 0 \"})\n@@ -237,1 +199,1 @@\n-                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n@@ -251,1 +213,1 @@\n-    @IR(applyIfCPUFeatureOr={\"simd\", \"true\", \"avx2\", \"true\"}, counts = {IRNode.REVERSE_BYTES_V , \" > 0 \"})\n+    @IR(applyIfCPUFeatureOr = {\"simd\", \"true\", \"avx2\", \"true\"}, counts = {IRNode.REVERSE_BYTES_V , \" > 0 \"})\n@@ -253,1 +215,2 @@\n-        VectorMask<Short> mask = VectorMask.fromLong(SSPECIES, 3);\n+        VectorMask<Short> mask1 = VectorMask.fromLong(SSPECIES, 3);\n+        VectorMask<Short> mask2 = VectorMask.fromLong(SSPECIES, 3);\n@@ -256,2 +219,2 @@\n-                     .lanewise(VectorOperators.REVERSE_BYTES)\n-                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask1)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask2)\n@@ -270,1 +233,1 @@\n-    @IR(applyIfCPUFeatureOr={\"simd\", \"true\", \"avx2\", \"true\"}, counts = {IRNode.REVERSE_BYTES_V , \" > 0 \"})\n+    @IR(applyIfCPUFeatureOr = {\"simd\", \"true\", \"avx2\", \"true\"}, failOn = {IRNode.REVERSE_BYTES_V})\n@@ -272,2 +235,0 @@\n-        VectorMask<Short> mask1 = VectorMask.fromLong(SSPECIES, 3);\n-        VectorMask<Short> mask2 = VectorMask.fromLong(SSPECIES, 3);\n@@ -276,2 +237,2 @@\n-                     .lanewise(VectorOperators.REVERSE_BYTES, mask1)\n-                     .lanewise(VectorOperators.REVERSE_BYTES, mask2)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n@@ -288,18 +249,0 @@\n-\n-    @Test\n-    @IR(applyIfCPUFeatureOr={\"simd\", \"true\", \"avx2\", \"true\"}, failOn = {IRNode.REVERSE_BYTES_V})\n-    public void test_reversebytes_short_transform4(short[] sout, short[] sinp) {\n-        for (int i = 0; i < SSPECIES.loopBound(sinp.length); i+=SSPECIES.length()) {\n-            ShortVector.fromArray(SSPECIES, sinp, i)\n-                     .lanewise(VectorOperators.REVERSE_BYTES)\n-                     .lanewise(VectorOperators.REVERSE_BYTES)\n-                     .intoArray(sout, i);\n-        }\n-    }\n-\n-    @Run(test = {\"test_reversebytes_short_transform4\"}, mode = RunMode.STANDALONE)\n-    public void kernel_test_reversebytes_short_transform4() {\n-        for (int i = 0; i < ITERS; i++) {\n-            test_reversebytes_short_transform4(sout, sinp);\n-        }\n-    }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestReverseByteTransforms.java","additions":31,"deletions":88,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import java.util.Random;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.LongVector;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8287794\n+ * @summary Test various reverse bytes ideal transforms on AARCH64 SVE.\n+ * @requires vm.compiler2.enabled\n+ * @modules jdk.incubator.vector\n+ * @requires vm.cpu.features ~= \".*sve.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorapi.TestReverseByteTransformsSVE\n+ *\/\n+\n+public class TestReverseByteTransformsSVE {\n+    static final VectorSpecies<Long> LSPECIES = LongVector.SPECIES_MAX;\n+    static final VectorSpecies<Integer> ISPECIES = IntVector.SPECIES_MAX;\n+    static final VectorSpecies<Short> SSPECIES = ShortVector.SPECIES_MAX;\n+\n+    static final int SIZE = 1024;\n+    static final int ITERS = 50000;\n+\n+    static long [] lout = new long[SIZE];\n+    static long [] linp = new long[SIZE];\n+\n+    static int [] iout = new int[SIZE];\n+    static int [] iinp = new int[SIZE];\n+\n+    static short [] sout = new short[SIZE];\n+    static short [] sinp = new short[SIZE];\n+\n+    static void init() {\n+        Random r = new Random(1024);\n+        for(int i = 0; i < SIZE; i++) {\n+            linp[i] = r.nextLong();\n+            iinp[i] = r.nextInt();\n+            sinp[i] = (short)r.nextInt();\n+        }\n+    }\n+\n+    public static void main(String args[]) {\n+        init();\n+        TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"--add-modules=jdk.incubator.vector\");\n+        System.out.println(\"PASSED\");\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseSVE\", \" > 0\"}, failOn = {IRNode.REVERSE_BYTES_V})\n+    public void test_reversebytes_long_transform(long[] lout, long[] linp) {\n+        VectorMask<Long> mask = VectorMask.fromLong(LSPECIES, 3);\n+        for (int i = 0; i < LSPECIES.loopBound(linp.length); i+=LSPECIES.length()) {\n+            LongVector.fromArray(LSPECIES, linp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .intoArray(lout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_long_transform\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_long_transform() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_long_transform(lout, linp);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseSVE\", \" > 0\"}, failOn = {IRNode.REVERSE_BYTES_V})\n+    public void test_reversebytes_int_transform(int[] iout, int[] iinp) {\n+        VectorMask<Integer> mask = VectorMask.fromLong(ISPECIES, 3);\n+        for (int i = 0; i < ISPECIES.loopBound(iinp.length); i+=ISPECIES.length()) {\n+            IntVector.fromArray(ISPECIES, iinp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .intoArray(iout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_int_transform\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_int_transform() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_int_transform(iout, iinp);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseSVE\", \" > 0\"}, failOn = {IRNode.REVERSE_BYTES_V})\n+    public void test_reversebytes_short_transform(short[] sout, short[] sinp) {\n+        VectorMask<Short> mask = VectorMask.fromLong(SSPECIES, 3);\n+        for (int i = 0; i < SSPECIES.loopBound(sinp.length); i+=SSPECIES.length()) {\n+            ShortVector.fromArray(SSPECIES, sinp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .intoArray(sout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_short_transform\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_short_transform() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_short_transform(sout, sinp);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestReverseByteTransformsSVE.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"}]}