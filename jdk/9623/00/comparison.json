{"files":[{"patch":"@@ -1854,11 +1854,11 @@\n-Node* ReverseBytesVNode::Identity(PhaseGVN* phase) {\n-  if (is_predicated_using_blend()) {\n-    return this;\n-  }\n-  \/\/ ReverseBytesV (ReverseBytesV X , MASK) , MASK =>  X\n-  if (in(1)->Opcode() == Op_ReverseBytesV) {\n-    if (is_predicated_vector() && in(1)->is_predicated_vector() && in(2) == in(1)->in(2)) {\n-      return in(1)->in(1);\n-    } else {\n-      \/\/ ReverseBytesV (ReverseBytesV X) =>  X\n-      return in(1)->in(1);\n+static Node* reverse_operations_identity(Node* n, Node* in1) {\n+  if (n->is_predicated_using_blend()) {\n+    return n;\n+  }\n+  if (n->Opcode() == in1->Opcode()) {\n+    \/\/ OperationV (OperationV X , MASK) , MASK =>  X\n+    if (n->is_predicated_vector() && in1->is_predicated_vector() && n->in(2) == in1->in(2)) {\n+      return in1->in(1);\n+    \/\/ OperationV (OperationV X) =>  X\n+    } else if (!n->is_predicated_vector() && !in1->is_predicated_vector())  {\n+      return in1->in(1);\n@@ -1867,1 +1867,5 @@\n-  return this;\n+  return n;\n+}\n+\n+Node* ReverseBytesVNode::Identity(PhaseGVN* phase) {\n+  return reverse_operations_identity(this, in(1));\n@@ -1871,13 +1875,1 @@\n-  if (is_predicated_using_blend()) {\n-    return this;\n-  }\n-  \/\/ ReverseV (ReverseV X , MASK) , MASK =>  X\n-  if (in(1)->Opcode() == Op_ReverseV) {\n-    if (is_predicated_vector() && in(1)->is_predicated_vector() && in(2) == in(1)->in(2)) {\n-      return in(1)->in(1);\n-    } else {\n-      \/\/ ReverseV (ReverseV X) =>  X\n-      return in(1)->in(1);\n-    }\n-  }\n-  return this;\n+  return reverse_operations_identity(this, in(1));\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":17,"deletions":25,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,306 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import java.util.Random;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.LongVector;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8287794\n+ * @summary Test various reverse bytes ideal transforms.\n+ * @requires vm.compiler2.enabled\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorapi.TestReverseByteTransforms\n+ *\/\n+\n+public class TestReverseByteTransforms {\n+    static final VectorSpecies<Long> LSPECIES = LongVector.SPECIES_MAX;\n+    static final VectorSpecies<Integer> ISPECIES = IntVector.SPECIES_MAX;\n+    static final VectorSpecies<Short> SSPECIES = ShortVector.SPECIES_MAX;\n+\n+    static final int SIZE = 1024;\n+    static final int ITERS = 50000;\n+\n+    static long [] lout = new long[SIZE];\n+    static long [] linp = new long[SIZE];\n+\n+    static int [] iout = new int[SIZE];\n+    static int [] iinp = new int[SIZE];\n+\n+    static short [] sout = new short[SIZE];\n+    static short [] sinp = new short[SIZE];\n+\n+    static void init() {\n+        Random r = new Random(1024);\n+        for(int i = 0; i < SIZE; i++) {\n+            linp[i] = r.nextLong();\n+            iinp[i] = r.nextInt();\n+            sinp[i] = (short)r.nextInt();\n+        }\n+    }\n+\n+    public static void main(String args[]) {\n+        init();\n+        TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"--add-modules=jdk.incubator.vector\");\n+        System.out.println(\"PASSED\");\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature={\"sve\", \"true\"}, failOn = {\"ReverseBytesV\" , \" > 0 \"})\n+    public void test_reversebytes_long_transform1(long[] lout, long[] linp) {\n+        VectorMask<Long> mask = VectorMask.fromLong(LSPECIES, 3);\n+        for (int i = 0; i < LSPECIES.loopBound(linp.length); i+=LSPECIES.length()) {\n+            LongVector.fromArray(LSPECIES, linp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .intoArray(lout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_long_transform1\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_long_transform1() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_long_transform1(lout, linp);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr={\"sve\", \"true\", \"simd\", \"true\", \"avx2\", \"true\"}, counts = {\"ReverseBytesV\" , \" > 0 \"})\n+    public void test_reversebytes_long_transform2(long[] lout, long[] linp) {\n+        VectorMask<Long> mask = VectorMask.fromLong(LSPECIES, 3);\n+        for (int i = 0; i < LSPECIES.loopBound(linp.length); i+=LSPECIES.length()) {\n+            LongVector.fromArray(LSPECIES, linp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .intoArray(lout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_long_transform2\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_long_transform2() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_long_transform2(lout, linp);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr={\"sve\", \"true\", \"simd\", \"true\", \"avx2\", \"true\"}, counts = {\"ReverseBytesV\" , \" > 0 \"})\n+    public void test_reversebytes_long_transform3(long[] lout, long[] linp) {\n+        VectorMask<Long> mask1 = VectorMask.fromLong(LSPECIES, 3);\n+        VectorMask<Long> mask2 = VectorMask.fromLong(LSPECIES, 3);\n+        for (int i = 0; i < LSPECIES.loopBound(linp.length); i+=LSPECIES.length()) {\n+            LongVector.fromArray(LSPECIES, linp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask1)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask2)\n+                     .intoArray(lout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_long_transform3\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_long_transform3() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_long_transform3(lout, linp);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr={\"sve\", \"true\", \"simd\", \"true\", \"avx2\", \"true\"}, failOn = {\"ReverseBytesV\" , \" > 0 \"})\n+    public void test_reversebytes_long_transform4(long[] lout, long[] linp) {\n+        for (int i = 0; i < LSPECIES.loopBound(linp.length); i+=LSPECIES.length()) {\n+            LongVector.fromArray(LSPECIES, linp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n+                     .intoArray(lout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_long_transform4\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_long_transform4() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_long_transform4(lout, linp);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature={\"sve\", \"true\"}, failOn = {\"ReverseBytesV\" , \" > 0 \"})\n+    public void test_reversebytes_int_transform1(int[] iout, int[] iinp) {\n+        VectorMask<Integer> mask = VectorMask.fromLong(ISPECIES, 3);\n+        for (int i = 0; i < ISPECIES.loopBound(iinp.length); i+=ISPECIES.length()) {\n+            IntVector.fromArray(ISPECIES, iinp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .intoArray(iout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_int_transform1\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_int_transform1() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_int_transform1(iout, iinp);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr={\"sve\", \"true\", \"simd\", \"true\", \"avx2\", \"true\"}, counts = {\"ReverseBytesV\" , \" > 0 \"})\n+    public void test_reversebytes_int_transform2(int[] iout, int[] iinp) {\n+        VectorMask<Integer> mask = VectorMask.fromLong(ISPECIES, 3);\n+        for (int i = 0; i < ISPECIES.loopBound(iinp.length); i+=ISPECIES.length()) {\n+            IntVector.fromArray(ISPECIES, iinp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .intoArray(iout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_int_transform2\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_int_transform2() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_int_transform2(iout, iinp);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr={\"sve\", \"true\", \"simd\", \"true\", \"avx2\", \"true\"}, counts = {\"ReverseBytesV\" , \" > 0 \"})\n+    public void test_reversebytes_int_transform3(int[] iout, int[] iinp) {\n+        VectorMask<Integer> mask1 = VectorMask.fromLong(ISPECIES, 3);\n+        VectorMask<Integer> mask2 = VectorMask.fromLong(ISPECIES, 3);\n+        for (int i = 0; i < ISPECIES.loopBound(iinp.length); i+=ISPECIES.length()) {\n+            IntVector.fromArray(ISPECIES, iinp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask1)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask2)\n+                     .intoArray(iout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_int_transform3\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_int_transform3() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_int_transform3(iout, iinp);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr={\"sve\", \"true\", \"simd\", \"true\", \"avx2\", \"true\"}, failOn = {\"ReverseBytesV\" , \" > 0 \"})\n+    public void test_reversebytes_int_transform4(int[] iout, int[] iinp) {\n+        for (int i = 0; i < ISPECIES.loopBound(iinp.length); i+=ISPECIES.length()) {\n+            IntVector.fromArray(ISPECIES, iinp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n+                     .intoArray(iout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_int_transform4\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_int_transform4() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_int_transform4(iout, iinp);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature={\"sve\", \"true\"}, failOn = {\"ReverseBytesV\" , \" > 0 \"})\n+    public void test_reversebytes_short_transform1(short[] sout, short[] sinp) {\n+        VectorMask<Short> mask = VectorMask.fromLong(SSPECIES, 3);\n+        for (int i = 0; i < SSPECIES.loopBound(sinp.length); i+=SSPECIES.length()) {\n+            ShortVector.fromArray(SSPECIES, sinp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .intoArray(sout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_short_transform1\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_short_transform1() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_short_transform1(sout, sinp);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr={\"sve\", \"true\", \"simd\", \"true\", \"avx2\", \"true\"}, counts = {\"ReverseBytesV\" , \" > 0 \"})\n+    public void test_reversebytes_short_transform2(short[] sout, short[] sinp) {\n+        VectorMask<Short> mask = VectorMask.fromLong(SSPECIES, 3);\n+        for (int i = 0; i < SSPECIES.loopBound(sinp.length); i+=SSPECIES.length()) {\n+            ShortVector.fromArray(SSPECIES, sinp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .intoArray(sout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_short_transform2\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_short_transform2() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_short_transform2(sout, sinp);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr={\"sve\", \"true\", \"simd\", \"true\", \"avx2\", \"true\"}, counts = {\"ReverseBytesV\" , \" > 0 \"})\n+    public void test_reversebytes_short_transform3(short[] sout, short[] sinp) {\n+        VectorMask<Short> mask1 = VectorMask.fromLong(SSPECIES, 3);\n+        VectorMask<Short> mask2 = VectorMask.fromLong(SSPECIES, 3);\n+        for (int i = 0; i < SSPECIES.loopBound(sinp.length); i+=SSPECIES.length()) {\n+            ShortVector.fromArray(SSPECIES, sinp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask1)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask2)\n+                     .intoArray(sout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_short_transform3\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_short_transform3() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_short_transform3(sout, sinp);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr={\"sve\", \"true\", \"simd\", \"true\", \"avx2\", \"true\"}, failOn = {\"ReverseBytesV\" , \" > 0 \"})\n+    public void test_reversebytes_short_transform4(short[] sout, short[] sinp) {\n+        for (int i = 0; i < SSPECIES.loopBound(sinp.length); i+=SSPECIES.length()) {\n+            ShortVector.fromArray(SSPECIES, sinp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n+                     .intoArray(sout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_short_transform4\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_short_transform4() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_short_transform4(sout, sinp);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestReverseByteTransforms.java","additions":306,"deletions":0,"binary":false,"changes":306,"status":"added"}]}