{"files":[{"patch":"@@ -571,0 +571,4 @@\n+            if (prev == DRAWING_OP_TO) {\n+                \/\/ skip repeated end-point\n+                return;\n+            }\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Stroker.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,335 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Pass if app exits without error code\n+ * @bug 8264999\n+ *\/\n+\n+import java.awt.*;\n+import java.io.*;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.awt.geom.*;\n+import javax.imageio.*;\n+import java.awt.image.*;\n+\n+\/**\n+ * This tests redundant line segments. That is: if you draw a line from A to B, and then a line from\n+ * B to B, then the expected behavior is for the last redundant segment to NOT affect the miter stroke.\n+ *\/\n+public class JoinMiterRedundantLineSegmentsTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        System.out.println(\"This test defines a series of shapes with optional shape data. The optional data (which is enclosed in brackets) should not make a difference in how the shape is rendered. This test renders the shape data with and without the bracketed segments and tests to see if those renderings are identical.\");\n+\n+        List<Test> tests = createTests();\n+        int sampleCtr = 1;\n+        boolean[] booleans = new boolean[] {false, true};\n+        boolean failed = false;\n+        String header = null;\n+        for (Test test : tests) {\n+            header = null;\n+\n+            for (Object strokeHint : new Object[] { RenderingHints.VALUE_STROKE_PURE, RenderingHints.VALUE_STROKE_NORMALIZE } ) {\n+                for (boolean createStrokedShape : booleans) {\n+                    for (boolean closePath : booleans) {\n+                        try {\n+                            test.run(strokeHint, createStrokedShape, closePath);\n+                        } catch(TestException e) {\n+                            failed = true;\n+\n+                            if (header == null) {\n+                                System.out.println();\n+\n+                                header = \"#############################\\n\";\n+                                header += \"## \" + test.name + \"\\n\";\n+                                header += \"## \" + test.description + \"\\n\";\n+                                header += \"## \" + test.shapeString + \"\\n\";\n+                                header += \"#############################\";\n+                                System.out.println(header);\n+                            }\n+\n+                            System.out.println();\n+                            System.out.println(\"# sample index = \" + (sampleCtr));\n+                            System.out.println(\"strokeHint = \" + strokeHint);\n+                            System.out.println(\"createStrokedShape = \" + createStrokedShape);\n+                            System.out.println(\"closePath = \" + closePath);\n+                            System.out.println(\"FAILED\");\n+                            e.printStackTrace(System.out);\n+                            BufferedImage bi = e.getImage();\n+                            File file = new File(\"failure-\"+sampleCtr+\".png\");\n+                            ImageIO.write(bi, \"png\", file);\n+                        }\n+\n+                        sampleCtr++;\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (failed)\n+            System.exit(1);\n+    }\n+\n+    private static List<Test> createTests() {\n+        List<Test> tests = new ArrayList<>();\n+\n+        tests.add(new Test(\"Redundant diagonal line endpoint\",\n+                \"m 0 0 l 10 10 [l 10 10]\",\n+                \"This creates a diagonal line with a redundant endpoint; this is the core problem demonstrated in JDK-8264999.\"));\n+\n+        tests.add(new Test(\"jdk-8264999\",\n+                \"m 24.954517 159 l 21.097446 157.5 [l 21.097446 157.5] l 17.61364 162 [l 17.61364 162] l 13.756569 163.5 [l 13.756569 163.5] l 11.890244 160.5\",\n+                \"This is the original shape reported in https:\/\/bugs.openjdk.org\/browse\/JDK-8264999\"));\n+\n+        tests.add(new Test(\"2x and 3x redundant lines\",\n+                \"m 24.954517 159 l 21.097446 157.5 [l 21.097446 157.5 l 21.097446 157.5] l 17.61364 162 [l 17.61364 162 l 17.61364 162 l 17.61364 162] l 13.756569 163.5 [l 13.756569 163.5 l 13.756569 163.5 l 13.756569 163.5] l 11.890244 160.5\",\n+                \"This is a derivative of JDK-8264999 that includes two or three redundant lines (instead of just one).\"));\n+\n+        tests.add(new Test(\"cubic curve with redundant line\",\n+                \"m 17 100 c 7 130 27 130 17 100 [l 17 100]\",\n+                \"This creates a simple cubic curve (a teardrop shape) with one redundant line at the end.\"));\n+\n+        tests.add(new Test(\"degenerate cubic curve\",\n+                \"m 19 180 l 20 181 [c 20 181 20 181 20 181]\",\n+                \"This creates a degenerate cubic curve after the last end point.\"));\n+\n+        tests.add(new Test(\"degenerate quadratic curve\",\n+                \"m 19 180 l 20 181 [q 20 181 20 181]\",\n+                \"This creates a degenerate quadratic curve after the last end point.\"));\n+\n+        \/\/ The following 3 tests are not essential for the resolution of JDK-8264999, but IMO they raise some\n+        \/\/ interesting questions about what the expected behavior is. (My apologies if the expected behavior\n+        \/\/ is specified somewhere: I'm not sure where that is?)\n+\n+\/\/        tests.add(new Test(\"lineTo after close\",\n+\/\/                \"m 19 180 z [l 19 180]\",\n+\/\/                \"This tests a lineTo after a close (but without a second moveTo)\"));\n+\/\/\n+\/\/        tests.add(new Test(\"Diagonal line, optional lineTo back\",\n+\/\/                \"m 0 0 l 20 20 [l 0 0]\",\n+\/\/                \"This creates a diagonal line and optionally returns to the starting point.\"));\n+\/\/\n+\/\/        tests.add(new Test(\"Diagonal line, optional close\",\n+\/\/                \"m 0 0 l 20 20 l 0 0 [z]\",\n+\/\/                \"This creates a diagonal line, returns to the starting point, and optionally closes the path.\"));\n+\n+\n+        \/\/ We've decided the following commented-out tests are invalid. The current interpretation is:\n+        \/\/ \"a moveTo statement without any additional information should NOT result in rendering anything\"\n+\n+\/\/        tests.add(new Test(\"empty line\",\n+\/\/                \"m 19 180 [l 19 180]\",\n+\/\/                \"This creates an empty shape with a lineTo the starting point.\"));\n+\n+\/\/        tests.add(new Test(\"empty degenerate cubic curve\",\n+\/\/                \"m 19 180 [c 19 180 19 180 19 180]\",\n+\/\/                \"This creates an empty degenerate cubic curve that is effectively a line to the starting point.\"));\n+\n+\/\/        tests.add(new Test(\"empty degenerate quadratic curve\",\n+\/\/                \"m 19 180 [q 19 180 19 180]\",\n+\/\/                \"This creates an empty degenerate quadratic curve that is effectively a line to the starting point.\"));\n+\n+\/\/        tests.add(new Test(\"moveTo then close\",\n+\/\/                \"m 19 180 [z]\",\n+\/\/                \"This moves to a starting position and then optionally closes the path.\"));\n+\n+        return tests;\n+    }\n+}\n+\n+class TestException extends Exception {\n+    BufferedImage bi;\n+\n+    public TestException(Throwable t, BufferedImage bi) {\n+        super(t);\n+        this.bi = bi;\n+    }\n+\n+    public BufferedImage getImage() {\n+        return bi;\n+    }\n+}\n+\n+class Test {\n+    Path2D path_expected, path_actual;\n+    String name, description, shapeString;\n+\n+    \/**\n+     * @param name a short name of this test\n+     * @param shape shape data, including optional phrases in brackets. The shape should render the same\n+     *              whether the data in brackets is included or not.\n+     * @param description a sentence describing this test\n+     *\/\n+    public Test(String name, String shape, String description) {\n+        \/\/ make sure the test contains optional path data. Because if it doesn't: this test\n+        \/\/ is meaningless because nothing will change.\n+        if (!shape.contains(\"[\"))\n+            throw new IllegalArgumentException(\"The shape must contain optional path data.\");\n+\n+        this.shapeString = shape;\n+        this.name = name;\n+        this.description = description;\n+        path_expected = parse(shape, false);\n+        path_actual = parse(shape, true);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    private String stripBracketPhrases(String str) {\n+        StringBuffer sb = new StringBuffer();\n+        int ctr = 0;\n+        for (int a = 0; a < str.length(); a++) {\n+            char ch = str.charAt(a);\n+            if (ch == '[') {\n+                ctr++;\n+            } else if (ch == ']') {\n+                ctr--;\n+            } else if (ctr == 0) {\n+                sb.append(ch);\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    private Path2D.Double parse(String str, boolean includeBrackets) {\n+        if (includeBrackets) {\n+            str = str.replace('[', ' ');\n+            str = str.replace(']', ' ');\n+        } else {\n+            str = stripBracketPhrases(str);\n+        }\n+        Path2D.Double path = new Path2D.Double();\n+        String[] terms = str.split(\" \");\n+        int a = 0;\n+        while (a < terms.length) {\n+            if (\"m\".equals(terms[a])) {\n+                path.moveTo(Double.parseDouble(terms[a + 1]), Double.parseDouble(terms[a + 2]));\n+                a += 3;\n+            } else if (\"l\".equals(terms[a])) {\n+                path.lineTo( Double.parseDouble(terms[a+1]), Double.parseDouble(terms[a+2]) );\n+                a += 3;\n+            } else if (\"q\".equals(terms[a])) {\n+                path.quadTo( Double.parseDouble(terms[a+1]), Double.parseDouble(terms[a+2]),\n+                        Double.parseDouble(terms[a+3]), Double.parseDouble(terms[a+4]) );\n+                a += 5;\n+            } else if (\"c\".equals(terms[a])) {\n+                path.curveTo( Double.parseDouble(terms[a+1]), Double.parseDouble(terms[a+2]),\n+                        Double.parseDouble(terms[a+3]), Double.parseDouble(terms[a+4]),\n+                        Double.parseDouble(terms[a+5]), Double.parseDouble(terms[a+6]) );\n+                a += 7;\n+            } else if (\"z\".equals(terms[a])) {\n+                path.closePath();\n+                a += 1;\n+            } else if(terms[a].trim().isEmpty()) {\n+                a += 1;\n+            } else {\n+                throw new RuntimeException(\"\\\"\"+terms[a]+\"\\\" in \\\"\"+str+\"\\\"\");\n+            }\n+        }\n+        return path;\n+    }\n+\n+    public void run(Object strokeRenderingHint, boolean createStrokedShape, boolean closePath) throws Exception {\n+        BufferedImage bi_expected = new BufferedImage(400, 400, BufferedImage.TYPE_INT_ARGB);\n+        BufferedImage bi_actual = new BufferedImage(400, 400, BufferedImage.TYPE_INT_ARGB);\n+\n+        paint(path_expected, bi_expected, Color.black, strokeRenderingHint, createStrokedShape, closePath);\n+        paint(path_actual, bi_actual, Color.black, strokeRenderingHint, createStrokedShape, closePath);\n+\n+        try {\n+            assertEquals(bi_expected, bi_actual);\n+        } catch(Exception e) {\n+            BufferedImage composite = new BufferedImage(400, 400, BufferedImage.TYPE_INT_ARGB);\n+            paint(path_expected, composite, Color.blue, strokeRenderingHint, createStrokedShape, closePath);\n+            paint(path_actual, composite, new Color(255,0,0,100), strokeRenderingHint, createStrokedShape, closePath);\n+            throw new TestException(e, composite);\n+        }\n+    }\n+\n+    \/**\n+     * Throw an exception if two images are not equal.\n+     *\/\n+    private static void assertEquals(BufferedImage bi1, BufferedImage bi2) {\n+        int w = bi1.getWidth();\n+        int h = bi1.getHeight();\n+        int[] row1 = new int[w];\n+        int[] row2 = new int[w];\n+        for (int y = 0; y < h; y++) {\n+            bi1.getRaster().getDataElements(0,y,w,1,row1);\n+            bi2.getRaster().getDataElements(0,y,w,1,row2);\n+            for (int x = 0; x < w; x++) {\n+                if (row1[x] != row2[x])\n+                    throw new RuntimeException(\"failure at (\"+x+\", \"+y+\"): 0x\"+Integer.toHexString(row1[x])+\" != 0x\"+Integer.toHexString(row2[x]));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Create a transform that maps from one rectangle to another.\n+     *\/\n+    private AffineTransform createTransform(Rectangle2D oldRect,Rectangle2D newRect) {\n+        double scaleX = newRect.getWidth() \/ oldRect.getWidth();\n+        double scaleY = newRect.getHeight() \/ oldRect.getHeight();\n+\n+        double translateX = -oldRect.getX() * scaleX + newRect.getX();\n+        double translateY = -oldRect.getY() * scaleY + newRect.getY();\n+        return new AffineTransform(scaleX, 0, 0, scaleY, translateX, translateY);\n+    }\n+\n+    \/**\n+     * Paint a path to an image.\n+     *\/\n+    private void paint(Path2D path, BufferedImage dst, Color color, Object strokeRenderingHint,\n+                       boolean createStrokedShape, boolean closePath) {\n+        Rectangle2D pathBounds = path.getBounds2D();\n+        pathBounds.setFrame(pathBounds.getX() - 10,\n+                pathBounds.getY() - 10,\n+                pathBounds.getWidth() + 20,\n+                pathBounds.getHeight() + 20);\n+        Rectangle imageBounds = new Rectangle(0, 0, dst.getWidth(), dst.getHeight());\n+\n+        Path2D p = new Path2D.Double();\n+        p.append(path, false);\n+        if (closePath)\n+            p.closePath();\n+\n+        Graphics2D g = dst.createGraphics();\n+        g.transform(createTransform(pathBounds, imageBounds));\n+        g.setColor(color);\n+        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n+        g.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, strokeRenderingHint);\n+        Stroke stroke = new BasicStroke(3);\n+        if (createStrokedShape) {\n+            g.fill( stroke.createStrokedShape(p) );\n+        } else {\n+            g.setStroke(stroke);\n+            g.draw(p);\n+        }\n+        g.dispose();\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/marlin\/JoinMiterRedundantLineSegmentsTest.java","additions":335,"deletions":0,"binary":false,"changes":335,"status":"added"}]}