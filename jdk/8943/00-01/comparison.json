{"files":[{"patch":"@@ -570,1 +570,1 @@\n-        if (dx == 0.0d && dy == 0.0d) {\n+        if (dx == 0.0d && dy == 0.0d && prev == DRAWING_OP_TO) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Stroker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.util.List;\n+import java.util.ArrayList;\n@@ -42,0 +44,1 @@\n+        System.out.println(\"This test defines a series of shapes with optional shape data. The optional data (which is enclosed in brackets) should not make a difference in how the shape is rendered. This test renders the shape data with and without the bracketed segments and tests to see if those renderings are identical.\");\n@@ -43,4 +46,2 @@\n-        boolean failed = false;\n-\n-        \/\/ we'll run several scenarios just to be safe:\n-\n+        List<Test> tests = createTests();\n+        int sampleCtr = 1;\n@@ -48,21 +49,34 @@\n-        for (boolean strokeHint_pure : booleans) {\n-            for (boolean createStrokedShape : booleans) {\n-                for (boolean closePath : booleans) {\n-\n-                    BufferedImage expected = null;\n-                    BufferedImage actual = null;\n-                    try {\n-                        expected = createImage(false, strokeHint_pure, createStrokedShape, closePath);\n-                        actual = createImage(true, strokeHint_pure, createStrokedShape, closePath);\n-                        assertEquals(expected, actual);\n-                    } catch (RuntimeException e) {\n-                        String id = strokeHint_pure+\"-\"+createStrokedShape+\"-\"+closePath;\n-                        if (expected != null) {\n-                            File file = new File(\"JoinMiterTest2-\" + id + \"-expected.png\");\n-                            System.err.println(\"Failure: \"+file.getAbsolutePath());\n-                            ImageIO.write(expected, \"png\", file);\n-                        }\n-                        if (actual != null) {\n-                            File file = new File(\"JoinMiterTest2-\" + id + \"-actual.png\");\n-                            System.err.println(\"Failure: \"+file.getAbsolutePath());\n-                            ImageIO.write(actual, \"png\", file);\n+        boolean failed = false;\n+        String header = null;\n+        for (Test test : tests) {\n+            header = null;\n+\n+            for (Object strokeHint : new Object[] { RenderingHints.VALUE_STROKE_PURE, RenderingHints.VALUE_STROKE_NORMALIZE } ) {\n+                for (boolean createStrokedShape : booleans) {\n+                    for (boolean closePath : booleans) {\n+                        try {\n+                            test.run(strokeHint, createStrokedShape, closePath);\n+                        } catch(TestException e) {\n+                            failed = true;\n+\n+                            if (header == null) {\n+                                System.out.println();\n+\n+                                header = \"#############################\\n\";\n+                                header += \"## \" + test.name + \"\\n\";\n+                                header += \"## \" + test.description + \"\\n\";\n+                                header += \"## \" + test.shapeString + \"\\n\";\n+                                header += \"#############################\";\n+                                System.out.println(header);\n+                            }\n+\n+                            System.out.println();\n+                            System.out.println(\"# sample index = \" + (sampleCtr));\n+                            System.out.println(\"strokeHint = \" + strokeHint);\n+                            System.out.println(\"createStrokedShape = \" + createStrokedShape);\n+                            System.out.println(\"closePath = \" + closePath);\n+                            System.out.println(\"FAILED\");\n+                            e.printStackTrace(System.out);\n+                            BufferedImage bi = e.getImage();\n+                            File file = new File(\"failure-\"+sampleCtr+\".png\");\n+                            ImageIO.write(bi, \"png\", file);\n@@ -70,2 +84,2 @@\n-                        e.printStackTrace();\n-                        failed = true;\n+\n+                        sampleCtr++;\n@@ -81,18 +95,2 @@\n-    \/**\n-     * @param addRedundantPoints add PathIterator segments that result in redundant SEG_LINETO instructions. When true\n-     *                           this may also include quadratic and cubic segments that should degenerate into lines.\n-     * @param useHintPure if true we render the stroke using RenderingHints.VALUE_STROKE_PURE\n-     * @param createStrokedShape if true we use graphics.fill(BasicStroke#createStrokedShape(path)). If false\n-     *                           we use graphics.draw(path)\n-     * @param closePath if true we close subpaths (once we make sure they return to their starting location)\n-     * @return an image we compare against to determine if this test passes or fails.\n-     * @throws Exception\n-     *\/\n-    private static BufferedImage createImage(boolean addRedundantPoints, boolean useHintPure, boolean createStrokedShape, boolean closePath) throws Exception {\n-        BufferedImage bi = new BufferedImage(500, 500, BufferedImage.TYPE_INT_RGB);\n-        Graphics2D g = (Graphics2D) bi.getGraphics();\n-        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n-        g.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, useHintPure ? RenderingHints.VALUE_STROKE_PURE : RenderingHints.VALUE_STROKE_NORMALIZE);\n-\n-        g.setBackground(Color.white);\n-        g.clearRect(0, 0, bi.getWidth(), bi.getHeight());\n+    private static List<Test> createTests() {\n+        List<Test> tests = new ArrayList<>();\n@@ -100,1 +98,3 @@\n-        AffineTransform at = g.getTransform();\n+        tests.add(new Test(\"jdk-8264999\",\n+                \"m 24.954517 159 l 21.097446 157.5 [l 21.097446 157.5] l 17.61364 162 [l 17.61364 162] l 13.756569 163.5 [l 13.756569 163.5] l 11.890244 160.5\",\n+                \"This is the original shape reported in https:\/\/bugs.openjdk.org\/browse\/JDK-8264999\"));\n@@ -102,2 +102,3 @@\n-        g.transform(AffineTransform.getTranslateInstance(0, -1400));\n-        g.transform(AffineTransform.getScaleInstance(10, 10));\n+        tests.add(new Test(\"2x and 3x redundant lines\",\n+                \"m 24.954517 159 l 21.097446 157.5 [l 21.097446 157.5 l 21.097446 157.5] l 17.61364 162 [l 17.61364 162 l 17.61364 162 l 17.61364 162] l 13.756569 163.5 [l 13.756569 163.5 l 13.756569 163.5 l 13.756569 163.5] l 11.890244 160.5\",\n+                \"This is a derivative of JDK-8264999 that includes two or three redundant lines (instead of just one).\"));\n@@ -105,2 +106,3 @@\n-        GeneralPath path1 = new GeneralPath();\n-        path1.moveTo(24.954517, 159);\n+        tests.add(new Test(\"cubic curve with redundant line\",\n+                \"m 17 100 c 7 130 27 130 17 100 [l 17 100]\",\n+                \"This creates a simple cubic curve (a teardrop shape) with one redundant line at the end.\"));\n@@ -108,3 +110,3 @@\n-        path1.lineTo(21.097446, 157.5);\n-        if (addRedundantPoints)\n-            path1.lineTo(21.097446, 157.5);\n+\/\/        tests.add(new Test(\"empty line\",\n+\/\/                \"m 19 180 [l 19 180]\",\n+\/\/                \"This creates an empty shape with a lineTo the starting point.\"));\n@@ -112,5 +114,3 @@\n-        path1.lineTo(17.61364, 162);\n-        if (addRedundantPoints) {\n-            path1.lineTo(17.61364, 162);\n-            path1.lineTo(17.61364, 162);\n-        }\n+        tests.add(new Test(\"degenerate cubic curve\",\n+                \"m 19 180 l 20 181 [c 20 181 20 181 20 181]\",\n+                \"This creates a degenerate cubic curve after the last end point.\"));\n@@ -118,6 +118,3 @@\n-        path1.lineTo(13.756569, 163.5);\n-        if (addRedundantPoints) {\n-            path1.lineTo(13.756569, 163.5);\n-            path1.lineTo(13.756569, 163.5);\n-            path1.lineTo(13.756569, 163.5);\n-        }\n+        tests.add(new Test(\"degenerate quadratic curve\",\n+                \"m 19 180 l 20 181 [q 20 181 20 181]\",\n+                \"This creates a degenerate quadratic curve after the last end point.\"));\n@@ -125,3 +122,3 @@\n-        path1.lineTo(11.890244, 160.5);\n-        if (addRedundantPoints)\n-            path1.lineTo(11.890244, 160.5);\n+\/\/        tests.add(new Test(\"empty degenerate cubic curve\",\n+\/\/                \"m 19 180 [c 19 180 19 180 19 180]\",\n+\/\/                \"This creates an empty degenerate cubic curve that is effectively a line to the starting point.\"));\n@@ -129,4 +126,3 @@\n-        if (closePath) {\n-            path1.lineTo(24.954517, 159);\n-            path1.closePath();\n-        }\n+\/\/        tests.add(new Test(\"empty degenerate quadratic curve\",\n+\/\/                \"m 19 180 [q 19 180 19 180]\",\n+\/\/                \"This creates an empty degenerate quadratic curve that is effectively a line to the starting point.\"));\n@@ -134,1 +130,3 @@\n-        draw(g, Color.red, path1, createStrokedShape);\n+\/\/        tests.add(new Test(\"moveTo then close\",\n+\/\/                \"m 19 180 [z]\",\n+\/\/                \"This moves to a starting position and then optionally closes the path.\"));\n@@ -136,1 +134,3 @@\n-        \/\/ normal cubics don't suffer the same problem; I just wanted visual confirmation so I threw this in:\n+        tests.add(new Test(\"lineTo after close\",\n+                \"m 19 180 z [l 19 180]\",\n+                \"This tests a lineTo after a close (without a moveTo)\"));\n@@ -138,3 +138,3 @@\n-        Path2D path2 = new Path2D.Double();\n-        path2.moveTo(17, 150);\n-        path2.curveTo(17-10, 150-20, 17+10, 150-20, 17, 150);\n+        return tests;\n+    }\n+}\n@@ -142,2 +142,2 @@\n-        if (closePath)\n-            path2.closePath();\n+class TestException extends Exception {\n+    BufferedImage bi;\n@@ -145,1 +145,4 @@\n-        draw(g, Color.green, path2, createStrokedShape);\n+    public TestException(Throwable t, BufferedImage bi) {\n+        super(t);\n+        this.bi = bi;\n+    }\n@@ -147,1 +150,4 @@\n-        path2.transform(AffineTransform.getRotateInstance(1, 20, 140));\n+    public BufferedImage getImage() {\n+        return bi;\n+    }\n+}\n@@ -149,1 +155,3 @@\n-        draw(g, Color.cyan, path2, createStrokedShape);\n+class Test {\n+    Path2D path_expected, path_actual;\n+    String name, description, shapeString;\n@@ -151,1 +159,18 @@\n-        \/\/ test degenerate cubics\n+    \/**\n+     * @param name a short name of this test\n+     * @param shape shape data, including optional phrases in brackets. The shape should render the same\n+     *              whether the data in brackets is included or not.\n+     * @param description a sentence describing this test\n+     *\/\n+    public Test(String name, String shape, String description) {\n+        \/\/ make sure the test contains optional path data. Because if it doesn't: this test\n+        \/\/ is meaningless because nothing will change.\n+        if (!shape.contains(\"[\"))\n+            throw new IllegalArgumentException(\"The shape must contain optional path data.\");\n+\n+        this.shapeString = shape;\n+        this.name = name;\n+        this.description = description;\n+        path_expected = parse(shape, false);\n+        path_actual = parse(shape, true);\n+    }\n@@ -153,4 +178,4 @@\n-        Path2D path3 = new Path2D.Double();\n-        path3.moveTo(19, 180);\n-        if (addRedundantPoints)\n-            path3.curveTo(19, 180, 19, 180, 19, 180);\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n@@ -158,14 +183,12 @@\n-        if (closePath)\n-            path3.closePath();\n-\n-        draw(g, Color.pink, path3, createStrokedShape);\n-\n-        \/\/ add a cubic that ends by pointing northeast, then see if any redundant\n-        \/\/ segments (lines or higher degenerating segments) change the miter:\n-        Path2D path4 = new Path2D.Double();\n-        path4.moveTo(22, 175);\n-        path4.curveTo(15,175,25,155,30,150);\n-        if (addRedundantPoints) {\n-            path4.lineTo(30, 150);\n-            path4.quadTo(30, 150,30, 150);\n-            path4.curveTo(30, 150,30, 150,30, 150);\n+    private String stripBracketPhrases(String str) {\n+        StringBuffer sb = new StringBuffer();\n+        int ctr = 0;\n+        for (int a = 0; a < str.length(); a++) {\n+            char ch = str.charAt(a);\n+            if (ch == '[') {\n+                ctr++;\n+            } else if (ch == ']') {\n+                ctr--;\n+            } else if (ctr == 0) {\n+                sb.append(ch);\n+            }\n@@ -173,0 +196,2 @@\n+        return sb.toString();\n+    }\n@@ -174,14 +199,37 @@\n-        if (closePath)\n-            path4.closePath();\n-\n-        draw(g, Color.blue, path4, createStrokedShape);\n-\n-        \/\/ and test degenerate quadratics\n-\n-        Path2D path5 = new Path2D.Double();\n-        path5.moveTo(22, 170);\n-        if (addRedundantPoints)\n-            path5.quadTo(22, 170, 22, 170);\n-\n-        if (closePath)\n-            path5.closePath();\n+    private Path2D.Double parse(String str, boolean includeBrackets) {\n+        if (includeBrackets) {\n+            str = str.replace('[', ' ');\n+            str = str.replace(']', ' ');\n+        } else {\n+            str = stripBracketPhrases(str);\n+        }\n+        Path2D.Double path = new Path2D.Double();\n+        String[] terms = str.split(\" \");\n+        int a = 0;\n+        while (a < terms.length) {\n+            if (\"m\".equals(terms[a])) {\n+                path.moveTo(Double.parseDouble(terms[a + 1]), Double.parseDouble(terms[a + 2]));\n+                a += 3;\n+            } else if (\"l\".equals(terms[a])) {\n+                path.lineTo( Double.parseDouble(terms[a+1]), Double.parseDouble(terms[a+2]) );\n+                a += 3;\n+            } else if (\"q\".equals(terms[a])) {\n+                path.quadTo( Double.parseDouble(terms[a+1]), Double.parseDouble(terms[a+2]),\n+                        Double.parseDouble(terms[a+3]), Double.parseDouble(terms[a+4]) );\n+                a += 5;\n+            } else if (\"c\".equals(terms[a])) {\n+                path.curveTo( Double.parseDouble(terms[a+1]), Double.parseDouble(terms[a+2]),\n+                        Double.parseDouble(terms[a+3]), Double.parseDouble(terms[a+4]),\n+                        Double.parseDouble(terms[a+5]), Double.parseDouble(terms[a+6]) );\n+                a += 7;\n+            } else if (\"z\".equals(terms[a])) {\n+                path.closePath();\n+                a += 1;\n+            } else if(terms[a].trim().isEmpty()) {\n+                a += 1;\n+            } else {\n+                throw new RuntimeException(\"\\\"\"+terms[a]+\"\\\" in \\\"\"+str+\"\\\"\");\n+            }\n+        }\n+        return path;\n+    }\n@@ -189,1 +237,3 @@\n-        draw(g, Color.green, path5, createStrokedShape);\n+    public void run(Object strokeRenderingHint, boolean createStrokedShape, boolean closePath) throws Exception {\n+        BufferedImage bi_expected = new BufferedImage(400, 400, BufferedImage.TYPE_INT_ARGB);\n+        BufferedImage bi_actual = new BufferedImage(400, 400, BufferedImage.TYPE_INT_ARGB);\n@@ -191,2 +241,2 @@\n-        return bi;\n-    }\n+        paint(path_expected, bi_expected, Color.black, strokeRenderingHint, createStrokedShape, closePath);\n+        paint(path_actual, bi_actual, Color.black, strokeRenderingHint, createStrokedShape, closePath);\n@@ -194,6 +244,7 @@\n-    private static void draw(Graphics2D g, Color color, Shape shape, boolean createStrokedShape) {\n-        g.setColor(color);\n-        if (createStrokedShape) {\n-            g.fill(g.getStroke().createStrokedShape(shape));\n-        } else {\n-            g.draw(shape);\n+        try {\n+            assertEquals(bi_expected, bi_actual);\n+        } catch(Exception e) {\n+            BufferedImage composite = new BufferedImage(400, 400, BufferedImage.TYPE_INT_ARGB);\n+            paint(path_expected, composite, Color.blue, strokeRenderingHint, createStrokedShape, closePath);\n+            paint(path_actual, composite, new Color(255,0,0,100), strokeRenderingHint, createStrokedShape, closePath);\n+            throw new TestException(e, composite);\n@@ -203,0 +254,3 @@\n+    \/**\n+     * Throw an exception if two images are not equal.\n+     *\/\n@@ -217,0 +271,44 @@\n+\n+    \/**\n+     * Create a transform that maps from one rectangle to another.\n+     *\/\n+    private AffineTransform createTransform(Rectangle2D oldRect,Rectangle2D newRect) {\n+        double scaleX = newRect.getWidth() \/ oldRect.getWidth();\n+        double scaleY = newRect.getHeight() \/ oldRect.getHeight();\n+\n+        double translateX = -oldRect.getX() * scaleX + newRect.getX();\n+        double translateY = -oldRect.getY() * scaleY + newRect.getY();\n+        return new AffineTransform(scaleX, 0, 0, scaleY, translateX, translateY);\n+    }\n+\n+    \/**\n+     * Paint a path to an image.\n+     *\/\n+    private void paint(Path2D path, BufferedImage dst, Color color, Object strokeRenderingHint,\n+                       boolean createStrokedShape, boolean closePath) {\n+        Rectangle2D pathBounds = path.getBounds2D();\n+        pathBounds.setFrame(pathBounds.getX() - 10,\n+                pathBounds.getY() - 10,\n+                pathBounds.getWidth() + 20,\n+                pathBounds.getHeight() + 20);\n+        Rectangle imageBounds = new Rectangle(0, 0, dst.getWidth(), dst.getHeight());\n+\n+        Path2D p = new Path2D.Double();\n+        p.append(path, false);\n+        if (closePath)\n+            p.closePath();\n+\n+        Graphics2D g = dst.createGraphics();\n+        g.transform(createTransform(pathBounds, imageBounds));\n+        g.setColor(color);\n+        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n+        g.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, strokeRenderingHint);\n+        Stroke stroke = new BasicStroke(3);\n+        if (createStrokedShape) {\n+            g.fill( stroke.createStrokedShape(p) );\n+        } else {\n+            g.setStroke(stroke);\n+            g.draw(p);\n+        }\n+        g.dispose();\n+    }\n","filename":"test\/jdk\/sun\/java2d\/marlin\/JoinMiterRedundantLineSegmentsTest.java","additions":221,"deletions":123,"binary":false,"changes":344,"status":"modified"}]}