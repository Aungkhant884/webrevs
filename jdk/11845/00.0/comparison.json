{"files":[{"patch":"@@ -504,1 +504,1 @@\n-WB_ENTRY(jboolean, WB_G1StartMarkCycle(JNIEnv* env, jobject o))\n+WB_ENTRY(jint, WB_G1CompletedConcurrentMarkCycles(JNIEnv* env, jobject o))\n@@ -507,5 +507,2 @@\n-    if (!g1h->concurrent_mark()->cm_thread()->in_progress()) {\n-      g1h->collect(GCCause::_wb_conc_mark);\n-      return true;\n-    }\n-    return false;\n+    G1ConcurrentMark* cm = g1h->concurrent_mark();\n+    return cm->completed_mark_cycles();\n@@ -513,1 +510,1 @@\n-  THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), \"WB_G1StartMarkCycle: G1 GC is not enabled\");\n+  THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), \"WB_G1CompletedConcurrentMarkCycles: G1 GC is not enabled\");\n@@ -2540,0 +2537,1 @@\n+  {CC\"g1CompletedConcurrentMarkCycles\", CC\"()I\",      (void*)&WB_G1CompletedConcurrentMarkCycles},\n@@ -2546,1 +2544,0 @@\n-  {CC\"g1StartConcMarkCycle\",       CC\"()Z\",           (void*)&WB_G1StartMarkCycle  },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -486,2 +486,5 @@\n-  static const int doYield_stub_frame_size = NOT_PPC64(frame::metadata_words)\n-                                             PPC64_ONLY(frame::abi_reg_args_size >> LogBytesPerWord);\n+#if !defined(PPC64) || defined(ZERO)\n+  static const int doYield_stub_frame_size = frame::metadata_words;\n+#else\n+  static const int doYield_stub_frame_size = frame::abi_reg_args_size >> LogBytesPerWord;\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -369,1 +369,1 @@\n-            WB.g1StartConcMarkCycle();\n+            WB.g1StartConcurrentGC();\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -275,6 +275,4 @@\n-            wb.g1StartConcMarkCycle(); \/\/ concurrent-start, remark and cleanup\n-            partialFree(used);\n-            \/\/ Sleep to make sure concurrent cycle is done\n-            while (wb.g1InConcurrentMark()) {\n-                Thread.sleep(1000);\n-            }\n+            wb.concurrentGCAcquireControl();\n+            try {\n+                wb.concurrentGCRunTo(wb.AFTER_MARKING_STARTED);\n+                partialFree(used);\n@@ -283,4 +281,1 @@\n-            \/\/ Trigger two young GCs, first will be young-prepare-mixed, second will be mixed.\n-            used = alloc1M();\n-            wb.youngGC(); \/\/ young-prepare-mixed\n-            partialFree(used);\n+                wb.concurrentGCRunToIdle();\n@@ -288,3 +283,12 @@\n-            used = alloc1M();\n-            wb.youngGC(); \/\/ mixed\n-            partialFree(used);\n+                \/\/ Trigger two young GCs while preventing a new concurrent GC.\n+                \/\/ First will be young-prepare-mixed, second will be mixed.\n+                used = alloc1M();\n+                wb.youngGC(); \/\/ young-prepare-mixed\n+                partialFree(used);\n+\n+                used = alloc1M();\n+                wb.youngGC(); \/\/ mixed\n+                partialFree(used);\n+            } finally {\n+                wb.concurrentGCReleaseControl();\n+            }\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestVerifyGCType.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"}]}