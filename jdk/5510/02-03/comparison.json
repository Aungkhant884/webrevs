{"files":[{"patch":"@@ -177,1 +177,2 @@\n-            case AUTHOR, DEPRECATED, HIDDEN, PARAM, RETURN, SEE, SERIAL, SERIAL_DATA, SERIAL_FIELD, SINCE, THROWS, UNKNOWN_BLOCK_TAG, VERSION -> {\n+            case AUTHOR, DEPRECATED, HIDDEN, PARAM, PROVIDES, RETURN, SEE, SERIAL, SERIAL_DATA, SERIAL_FIELD, SINCE,\n+                    THROWS, UNKNOWN_BLOCK_TAG, USES, VERSION -> {\n@@ -185,1 +186,0 @@\n-                int pos = this.pos;\n@@ -187,1 +187,1 @@\n-                return pos + name.length() + 1;\n+                return this.pos + name.length() + 1;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DCTree.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8273244\n+ * @summary check coverage of tools\/javac\/doctree tests\n+ * @modules jdk.compiler\n+ * @run main CoverageTest\n+ *\/\n+\n+import com.sun.source.doctree.DocCommentTree;\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.DocTreeScanner;\n+import com.sun.source.util.DocTrees;\n+import com.sun.source.util.JavacTask;\n+import com.sun.source.util.TaskEvent;\n+import com.sun.source.util.TaskListener;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.TreePathScanner;\n+\n+import javax.lang.model.element.Name;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileObject;\n+import javax.tools.StandardJavaFileManager;\n+import javax.tools.ToolProvider;\n+import java.io.IOException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Scans for tests in the same source directory that use the DocCommentTester framework,\n+ * and for those tests, scans for doc comments, counting the number of occurrences\n+ * of different kinds of DocTree nodes.  The number are mostly just informational,\n+ * except for the (implicit) zeroes, indicating that no instances of a kind of tree\n+ * have been detected ... which is a hole in the coverage.\n+ *\n+ * If desired, we could enhance the DocTreeScanner to track different variants of\n+ * specific kinds of tree nodes.\n+ *\/\n+public class CoverageTest {\n+    public static void main(String... args) throws Exception {\n+        new CoverageTest().run(args);\n+    }\n+\n+    void run(String... args) throws Exception {\n+        Path src = Path.of(System.getProperty(\"test.src\"));\n+\n+        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+        StandardJavaFileManager fm = compiler.getStandardFileManager(null, null, null);\n+\n+        List<JavaFileObject> files = new ArrayList<>();\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(src, this::isDocCommentTesterTest)) {\n+            for (Path p : ds) {\n+                files.add(fm.getJavaFileObjects(p).iterator().next());\n+            }\n+        }\n+\n+        JavacTask task = (JavacTask) compiler.getTask(null, null, null, null, null, files);\n+\n+        DocTrees trees = DocTrees.instance(task);\n+        Map<DocTree.Kind, Integer> counts = new TreeMap<>();\n+        DocTreeScanner dtScanner = new DocTreeScanner() {\n+            @Override\n+            public Object scan(DocTree node, Object o) {\n+                if (node != null) {\n+                    DocTree.Kind k = node.getKind();\n+                    counts.put(k, counts.computeIfAbsent(k, k_ -> 0) + 1);\n+                }\n+                return super.scan(node, o);\n+            }\n+        };\n+\n+        TreePathScanner declScanner = new DeclScanner() {\n+            @Override\n+            void visitDecl(Tree tree, Name name) {\n+                TreePath path = getCurrentPath();\n+                DocCommentTree dc = trees.getDocCommentTree(path);\n+                dtScanner.scan(dc, null);\n+            }\n+        };\n+\n+\n+        task.addTaskListener(new TaskListener() {\n+            @Override\n+            public void finished(TaskEvent e) {\n+                if (e.getKind() == TaskEvent.Kind.PARSE) {\n+                    declScanner.scan(e.getCompilationUnit(), null);\n+                }\n+            }\n+        });\n+\n+        task.parse();\n+\n+        counts.forEach((k, v) -> System.err.printf(\"%20s: %5d%n\", k, v));\n+\n+        List<DocTree.Kind> notFound = Stream.of(DocTree.Kind.values())\n+                .filter(k -> switch (k) { case DOC_TYPE, OTHER -> false; default -> true; })\n+                .filter(k -> !counts.containsKey(k))\n+                .toList();\n+\n+        if (!notFound.isEmpty()) {\n+            System.err.println();\n+            System.err.println(\"ERROR: The following kinds were not found: \" + notFound.stream()\n+                    .map(DocTree.Kind::name)\n+                    .collect(Collectors.joining(\", \")));\n+            System.err.println();\n+            throw new Exception(\"Not Found: \" + notFound);\n+        }\n+    }\n+\n+    boolean isDocCommentTesterTest(Path p) throws IOException {\n+        if (!p.getFileName().toString().endsWith(\".java\")) {\n+            return false;\n+        }\n+\n+        String marker = \" * @run main DocCommentTester \" + p.getFileName();\n+        for (String line : Files.readAllLines(p)) {\n+            if (line.equals(marker)) {\n+                return true;\n+            } else if (line.contains(\"{\")) {\n+                return false;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    static abstract class DeclScanner extends TreePathScanner<Void, Void> {\n+        abstract void visitDecl(Tree tree, Name name);\n+\n+        @Override\n+        public Void visitClass(ClassTree tree, Void ignore) {\n+            super.visitClass(tree, ignore);\n+            visitDecl(tree, tree.getSimpleName());\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitMethod(MethodTree tree, Void ignore) {\n+            super.visitMethod(tree, ignore);\n+            visitDecl(tree, tree.getName());\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitVariable(VariableTree tree, Void ignore) {\n+            super.visitVariable(tree, ignore);\n+            visitDecl(tree, tree.getName());\n+            return null;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/doctree\/CoverageTest.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -40,0 +40,1 @@\n+import javax.tools.Diagnostic;\n@@ -111,1 +112,2 @@\n-            new RangeChecker(this, trees)\n+            new RangeChecker(this, trees),\n+            new StartEndPosChecker(this, trees)\n@@ -1000,0 +1002,73 @@\n+\n+    static class StartEndPosChecker extends Checker {\n+\n+        StartEndPosChecker(DocCommentTester test, DocTrees docTrees) {\n+            test.super(docTrees);\n+        }\n+\n+        @Override\n+        void check(TreePath path, Name name) throws Exception {\n+            final DCDocComment dc = (DCDocComment) trees.getDocCommentTree(path);\n+            JavaFileObject jfo = path.getCompilationUnit().getSourceFile();\n+            CharSequence content = jfo.getCharContent(true);\n+\n+            DocTreeScanner<Void, Void> scanner = new DocTreeScanner<>() {\n+                @Override\n+                public Void scan(DocTree node, Void ignore) {\n+                    if (node instanceof DCTree dcTree) {\n+                        int start = dc.getSourcePosition(dc.getStartPosition());\n+                        int end = dc.getSourcePosition(dcTree.getEndPosition());\n+\n+                        try {\n+                            StringWriter out = new StringWriter();\n+                            DocPretty dp = new DocPretty(out);\n+                            dp.print(trees.getDocCommentTree(path));\n+                            String pretty = out.toString();\n+\n+                            if (pretty.isEmpty()) {\n+                                if (start != end) {\n+                                    error(\"Error: expected content is empty, but actual content is not: \"\n+                                            + dcTree.getKind() + \" [\" + start + \",\" + end + \")\"\n+                                            + \": \\\"\" + content.subSequence(start, end) + \"\\\"\" );\n+                                }\n+                            } else {\n+                                check(dcTree, \"start\", content, start, pretty, 0);\n+                                check(dcTree, \"end\", content, end - 1, pretty, pretty.length() - 1);\n+                            }\n+\n+                        } catch (IOException e) {\n+                            error(\"Error generating Pretty for tree at position \" + start + \"; \" + e);\n+                        }\n+                    }\n+                    return null;\n+                }\n+            };\n+\n+            scanner.scan(dc, null);\n+        }\n+\n+        void check(DCTree tree, String label, CharSequence content, int contentIndex, String pretty, int prettyIndex) {\n+            if (contentIndex == Diagnostic.NOPOS) {\n+                error(\"NOPOS for content \" + label + \": \" + tree.getKind() + \" >>\" + abbrev(pretty, MAX) + \"<<\");\n+            }\n+\n+            char contentChar = content.charAt(contentIndex);\n+            char prettyChar = pretty.charAt(prettyIndex);\n+            if (contentChar != prettyChar) {\n+                error (\"Mismatch for content \" + label + \": \"\n+                        + \"expect: '\" + prettyChar + \"', found: '\" + contentChar + \"' at position \" + contentIndex + \": \"\n+                        + tree.getKind() + \" >>\" + abbrev(pretty, MAX) + \"<<\");\n+            }\n+        }\n+\n+        static final int MAX = 64;\n+\n+        static String abbrev(String s, int max) {\n+            s = s.replaceAll(\"\\\\s+\", \" \");\n+            if (s.length() > max) {\n+                s = s.substring(0, max \/ 2 - 2) + \" ... \" + s.substring(max \/ 2 + 2);\n+            }\n+            return s;\n+        }\n+\n+    }\n","filename":"test\/langtools\/tools\/javac\/doctree\/DocCommentTester.java","additions":76,"deletions":1,"binary":false,"changes":77,"status":"modified"}]}