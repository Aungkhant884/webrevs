{"files":[{"patch":"@@ -259,1 +259,3 @@\n-                    return ((DCTree) tree).getSourcePosition((DCDocComment) comment);\n+                    DCDocComment dcComment = (DCDocComment) comment;\n+                    DCTree dcTree = (DCTree) tree;\n+                    return dcComment.getSourcePosition(dcTree.getStartPosition());\n@@ -261,1 +263,2 @@\n-                @Override  @DefinedBy(Api.COMPILER_TREE) @SuppressWarnings(\"fallthrough\")\n+\n+                @Override  @DefinedBy(Api.COMPILER_TREE)\n@@ -264,68 +267,2 @@\n-                    if (tree instanceof DCEndPosTree<?> dcEndPosTree) {\n-                        int endPos = dcEndPosTree.getEndPos(dcComment);\n-\n-                        if (endPos != Position.NOPOS) {\n-                            return endPos;\n-                        }\n-                    }\n-                    int correction = 0;\n-                    switch (tree.getKind()) {\n-                        case TEXT:\n-                            DCText text = (DCText) tree;\n-\n-                            return dcComment.comment.getSourcePos(text.pos + text.text.length());\n-                        case ERRONEOUS:\n-                            DCErroneous err = (DCErroneous) tree;\n-\n-                            return dcComment.comment.getSourcePos(err.pos + err.body.length());\n-                        case IDENTIFIER:\n-                            DCIdentifier ident = (DCIdentifier) tree;\n-\n-                            return dcComment.comment.getSourcePos(ident.pos + (ident.name != names.error ? ident.name.length() : 0));\n-                        case PARAM:\n-                            DCParam param = (DCParam) tree;\n-\n-                            if (param.isTypeParameter && param.getDescription().isEmpty()) {\n-                                correction = 1;\n-                            }\n-                        case AUTHOR: case DEPRECATED: case RETURN: case SEE:\n-                        case SERIAL: case SERIAL_DATA: case SERIAL_FIELD: case SINCE:\n-                        case THROWS: case UNKNOWN_BLOCK_TAG: case VERSION: {\n-                            DocTree last = getLastChild(tree);\n-\n-                            if (last != null) {\n-                                return getEndPosition(file, comment, last) + correction;\n-                            }\n-\n-                            int pos;\n-                            String name;\n-                            if (tree.getKind() == DocTree.Kind.RETURN) {\n-                                DCTree.DCReturn dcReturn = (DCTree.DCReturn) tree;\n-                                pos = dcReturn.pos;\n-                                name = dcReturn.getTagName();\n-                            } else {\n-                                DCBlockTag block = (DCBlockTag) tree;\n-                                pos = block.pos;\n-                                name = block.getTagName();\n-                            }\n-\n-                            return dcComment.comment.getSourcePos(pos + name.length() + 1);\n-                        }\n-                        case ENTITY: {\n-                            DCEntity endEl = (DCEntity) tree;\n-                            return dcComment.comment.getSourcePos(endEl.pos + (endEl.name != names.error ? endEl.name.length() : 0) + 2);\n-                        }\n-                        case COMMENT: {\n-                            DCComment endEl = (DCComment) tree;\n-                            return dcComment.comment.getSourcePos(endEl.pos + endEl.body.length());\n-                        }\n-                        default:\n-                            DocTree last = getLastChild(tree);\n-\n-                            if (last != null) {\n-                                return getEndPosition(file, comment, last);\n-                            }\n-                            break;\n-                    }\n-\n-                    return Position.NOPOS;\n+                    DCTree dcTree = (DCTree) tree;\n+                    return dcComment.getSourcePosition(dcTree.getEndPosition());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":7,"deletions":70,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic;\n@@ -65,0 +66,2 @@\n+        final int pos;\n+\n@@ -66,0 +69,3 @@\n+            this(Position.NOPOS, key);\n+        }\n+        ParseException(int pos, String key) {\n@@ -67,0 +73,1 @@\n+            this.pos = pos;\n@@ -70,1 +77,1 @@\n-    private enum Phase {PREAMBLE, BODY, POSTAMBLE}\n+    private enum Phase { PREAMBLE, BODY, POSTAMBLE }\n@@ -73,0 +80,1 @@\n+    private final JCDiagnostic.Factory diags;\n@@ -99,0 +107,1 @@\n+        this.diags = fac.log.diags;\n@@ -129,12 +138,7 @@\n-        int pos = Position.NOPOS;\n-        if (!preamble.isEmpty())\n-            pos = preamble.head.pos;\n-        else if (!body.isEmpty())\n-            pos = body.head.pos;\n-        else if (!tags.isEmpty())\n-            pos = tags.head.pos;\n-        else if (!postamble.isEmpty())\n-            pos = postamble.head.pos;\n-\n-        DCDocComment dc = m.at(pos).newDocCommentTree(comment, body, tags, preamble, postamble);\n-        return dc;\n+        int pos = !preamble.isEmpty() ? preamble.head.pos\n+                : !body.isEmpty() ? body.head.pos\n+                : !tags.isEmpty() ? tags.head.pos\n+                : !postamble.isEmpty() ? postamble.head.pos\n+                : 0;\n+\n+        return m.at(pos).newDocCommentTree(comment, body, tags, preamble, postamble);\n@@ -284,1 +288,1 @@\n-            return erroneous(e.getMessage(), p);\n+            return erroneous(e.getMessage(), p, e.pos);\n@@ -337,1 +341,1 @@\n-            return erroneous(e.getMessage(), p);\n+            return erroneous(e.getMessage(), p, e.pos);\n@@ -474,2 +478,2 @@\n-        } catch (ReferenceParser.ParseException parseException) {\n-            throw new ParseException(parseException.getMessage());\n+        } catch (ReferenceParser.ParseException pe) {\n+            throw new ParseException(pos + pe.pos, pe.getMessage());\n@@ -481,3 +485,1 @@\n-     * Read Java identifier\n-     * Matching pairs of { } are skipped; the text is terminated by the first\n-     * unmatched }. It is an error if the beginning of the next tag is detected.\n+     * Reads a Java identifier.\n@@ -485,1 +487,0 @@\n-    @SuppressWarnings(\"fallthrough\")\n@@ -499,1 +500,1 @@\n-     * Read a quoted string.\n+     * Reads a quoted string.\n@@ -502,1 +503,0 @@\n-    @SuppressWarnings(\"fallthrough\")\n@@ -533,1 +533,1 @@\n-     * Read a term (that is, one word).\n+     * Reads a term (that is, one word).\n@@ -570,1 +570,1 @@\n-     * Read general text content of an inline tag, including HTML entities and elements.\n+     * Reads general text content of an inline tag, including HTML entities and elements.\n@@ -659,1 +659,1 @@\n-     * Read an HTML entity.\n+     * Reads an HTML entity.\n@@ -969,0 +969,10 @@\n+    \/**\n+     * Creates an {@code ErroneousTree} node, for a range of text starting at a given position,\n+     * ending at the last non-whitespace character before the current position,\n+     * and with the preferred position set to the last character within that range.\n+     *\n+     * @param code the resource key for the error message\n+     * @param pos  the starting position\n+     *\n+     * @return the {@code ErroneousTree} node\n+     *\/\n@@ -970,0 +980,16 @@\n+        return erroneous(code, pos, Position.NOPOS);\n+    }\n+\n+    \/**\n+     * Creates an {@code ErroneousTree} node, for a range of text starting at a given position,\n+     * ending at the last non-whitespace character before the current position,\n+     * and with a given preferred position.\n+     *\n+     * @param code the resource key for the error message\n+     * @param pos  the starting position\n+     * @param pref the preferred position for the node, or {@code NOPOS} to use the default value\n+     *             as the last character of the range\n+     *\n+     * @return the {@code ErroneousTree} node\n+     *\/\n+    protected DCErroneous erroneous(String code, int pos, int pref) {\n@@ -984,0 +1010,4 @@\n+        if (pref == Position.NOPOS) {\n+            pref = i;\n+        }\n+        int end = i + 1;\n@@ -985,1 +1015,3 @@\n-        return m.at(pos).newErroneousTree(newString(pos, i + 1), diagSource, code);\n+        JCDiagnostic.DiagnosticPosition dp = DCTree.createDiagnosticPosition(comment, pos, pref, end);\n+        JCDiagnostic diag = diags.error(null, diagSource, dp, code);\n+        return m.at(pos).newErroneousTree(newString(pos, end), diag).setPrefPos(pref);\n@@ -1165,1 +1197,1 @@\n-                    throw new ParseException(\"dc.unexpected.content\");\n+                    throw new ParseException(pos, \"dc.unexpected.content\");\n@@ -1222,1 +1254,1 @@\n-                    throw new ParseException(\"dc.unexpected.content\");\n+                    throw new ParseException(pos, \"dc.unexpected.content\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/DocCommentParser.java","additions":62,"deletions":30,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import com.sun.tools.javac.util.DiagnosticSource;\n+import com.sun.tools.javac.util.JCDiagnostic;\n@@ -38,0 +40,4 @@\n+import javax.tools.JavaFileObject;\n+import java.util.Locale;\n+import java.util.Queue;\n+\n@@ -74,1 +80,3 @@\n-        ParseException(String message) {\n+        final int pos;\n+\n+        ParseException(int pos, String message) {\n@@ -76,0 +84,1 @@\n+            this.pos = pos;\n@@ -103,2 +112,1 @@\n-        Log.DeferredDiagnosticHandler deferredDiagnosticHandler\n-                = new Log.DeferredDiagnosticHandler(fac.log);\n+        Log.DeferredDiagnosticHandler dh = new Log.DeferredDiagnosticHandler(fac.log);\n@@ -108,1 +116,3 @@\n-            int hash = sig.indexOf(\"#\", slash + 1);\n+            int afterSlash = slash + 1;\n+            int hash = sig.indexOf(\"#\", afterSlash);\n+            int afterHash = hash + 1;\n@@ -110,6 +120,9 @@\n-            if (slash > -1) {\n-                moduleName = parseModule(sig.substring(0, slash));\n-            } else {\n-                moduleName = null;\n-            }\n-            if (slash > 0 && sig.length() == slash + 1) {\n+            int afterLparen = lparen + 1;\n+\n+            moduleName = switch (slash) {\n+                case -1 -> null;\n+                case 0 -> throw new ParseException(0, \"dc.ref.syntax.error\");\n+                default -> parseModule(sig, 0, slash, dh);\n+            };\n+\n+            if (slash > 0 && sig.length() == afterSlash) {\n@@ -120,1 +133,1 @@\n-                    qualExpr = parseType(sig.substring(slash + 1));\n+                    qualExpr = parseType(sig, afterSlash, sig.length(), dh);\n@@ -124,1 +137,1 @@\n-                    member = parseMember(sig.substring(slash + 1, lparen));\n+                    member = parseMember(sig, afterSlash, lparen, dh);\n@@ -127,5 +140,6 @@\n-                qualExpr = (hash == slash + 1) ? null : parseType(sig.substring(slash + 1, hash));\n-                if (lparen == -1)\n-                    member = parseMember(sig.substring(hash + 1));\n-                else\n-                    member = parseMember(sig.substring(hash + 1, lparen));\n+                qualExpr = (hash == afterSlash) ? null : parseType(sig, afterSlash, hash, dh);\n+                if (lparen == -1) {\n+                    member = parseMember(sig, afterHash, sig.length(), dh);\n+                } else {\n+                    member = parseMember(sig, afterHash, lparen, dh);\n+                }\n@@ -134,1 +148,1 @@\n-            if (lparen < 0) {\n+            if (lparen == -1) {\n@@ -138,3 +152,4 @@\n-                if (rparen != sig.length() - 1)\n-                    throw new ParseException(\"dc.ref.bad.parens\");\n-                paramTypes = parseParams(sig.substring(lparen + 1, rparen));\n+                if (rparen != sig.length() - 1) {\n+                    throw new ParseException(rparen, \"dc.ref.bad.parens\");\n+                }\n+                paramTypes = parseParams(sig, afterLparen, rparen, dh);\n@@ -143,2 +158,1 @@\n-            if (!deferredDiagnosticHandler.getDiagnostics().isEmpty())\n-                throw new ParseException(\"dc.ref.syntax.error\");\n+            assert dh.getDiagnostics().isEmpty();\n@@ -147,1 +161,1 @@\n-            fac.log.popDiagnosticHandler(deferredDiagnosticHandler);\n+            fac.log.popDiagnosticHandler(dh);\n@@ -153,6 +167,14 @@\n-    private JCTree.JCExpression parseModule(String s) throws ParseException {\n-        JavacParser p = fac.newParser(s, false, false, false);\n-        JCTree.JCExpression expr = p.qualident(false);\n-        if (p.token().kind != TokenKind.EOF)\n-            throw new ParseException(\"dc.ref.unexpected.input\");\n-        return expr;\n+    private JCTree.JCExpression parseModule(String sig, int beginIndex, int endIndex, Log.DeferredDiagnosticHandler dh) throws ParseException {\n+        String s = sig.substring(beginIndex, endIndex);\n+        JavaFileObject prev = fac.log.useSource(null);\n+        try {\n+            JavacParser p = fac.newParser(s, false, false, false);\n+            JCTree.JCExpression expr = p.qualident(false);\n+            if (p.token().kind != TokenKind.EOF) {\n+                throw new ParseException(beginIndex + p.token().pos, \"dc.ref.unexpected.input\");\n+            }\n+            checkDiags(dh, beginIndex);\n+            return expr;\n+        } finally {\n+            fac.log.useSource(prev);\n+        }\n@@ -161,6 +183,14 @@\n-    private JCTree parseType(String s) throws ParseException {\n-        JavacParser p = fac.newParser(s, false, false, false);\n-        JCTree tree = p.parseType();\n-        if (p.token().kind != TokenKind.EOF)\n-            throw new ParseException(\"dc.ref.unexpected.input\");\n-        return tree;\n+    private JCTree parseType(String sig, int beginIndex, int endIndex, Log.DeferredDiagnosticHandler dh) throws ParseException {\n+        String s = sig.substring(beginIndex, endIndex);\n+        JavaFileObject prev = fac.log.useSource(null);\n+        try {\n+            JavacParser p = fac.newParser(s, false, false, false);\n+            JCTree tree = p.parseType();\n+            if (p.token().kind != TokenKind.EOF) {\n+                throw new ParseException(beginIndex + p.token().pos, \"dc.ref.unexpected.input\");\n+            }\n+            checkDiags(dh, beginIndex);\n+            return tree;\n+        } finally {\n+            fac.log.useSource(prev);\n+        }\n@@ -169,6 +199,14 @@\n-    private Name parseMember(String s) throws ParseException {\n-        JavacParser p = fac.newParser(s, false, false, false);\n-        Name name = p.ident();\n-        if (p.token().kind != TokenKind.EOF)\n-            throw new ParseException(\"dc.ref.unexpected.input\");\n-        return name;\n+    private Name parseMember(String sig, int beginIndex, int endIndex, Log.DeferredDiagnosticHandler dh) throws ParseException {\n+        String s = sig.substring(beginIndex, endIndex);\n+        JavaFileObject prev = fac.log.useSource(null);\n+        try {\n+            JavacParser p = fac.newParser(s, false, false, false);\n+            Name name = p.ident();\n+            if (p.token().kind != TokenKind.EOF) {\n+                throw new ParseException(beginIndex + p.token().pos, \"dc.ref.unexpected.input\");\n+            }\n+            checkDiags(dh, beginIndex);\n+            return name;\n+        } finally {\n+            fac.log.useSource(prev);\n+        }\n@@ -177,2 +215,3 @@\n-    private List<JCTree> parseParams(String s) throws ParseException {\n-        if (s.trim().isEmpty())\n+    private List<JCTree> parseParams(String sig, int beginIndex, int endIndex, Log.DeferredDiagnosticHandler dh) throws ParseException {\n+        String s = sig.substring(beginIndex, endIndex);\n+        if (s.isBlank()) {\n@@ -180,0 +219,1 @@\n+        }\n@@ -181,9 +221,4 @@\n-        JavacParser p = fac.newParser(s.replace(\"...\", \"[]\"), false, false, false);\n-        ListBuffer<JCTree> paramTypes = new ListBuffer<>();\n-        paramTypes.add(p.parseType());\n-\n-        if (p.token().kind == TokenKind.IDENTIFIER)\n-            p.nextToken();\n-\n-        while (p.token().kind == TokenKind.COMMA) {\n-            p.nextToken();\n+        JavaFileObject prev = fac.log.useSource(null);\n+        try {\n+            JavacParser p = fac.newParser(s.replace(\"...\", \"[]\"), false, false, false);\n+            ListBuffer<JCTree> paramTypes = new ListBuffer<>();\n@@ -192,1 +227,1 @@\n-            if (p.token().kind == TokenKind.IDENTIFIER)\n+            if (p.token().kind == TokenKind.IDENTIFIER) {\n@@ -194,1 +229,20 @@\n-        }\n+            }\n+\n+            while (p.token().kind == TokenKind.COMMA) {\n+                p.nextToken();\n+                paramTypes.add(p.parseType());\n+\n+                if (p.token().kind == TokenKind.IDENTIFIER) {\n+                    p.nextToken();\n+                }\n+            }\n+\n+            if (p.token().kind != TokenKind.EOF) {\n+                throw new ParseException(p.token().pos, \"dc.ref.unexpected.input\");\n+            }\n+\n+            Tree typeAnno = new TypeAnnotationFinder().scan(paramTypes, null);\n+            if (typeAnno != null) {\n+                int annoPos = ((JCTree) typeAnno).getStartPosition();\n+                throw new ParseException(beginIndex + annoPos, \"dc.ref.annotations.not.allowed\");\n+            }\n@@ -196,2 +250,1 @@\n-        if (p.token().kind != TokenKind.EOF)\n-            throw new ParseException(\"dc.ref.unexpected.input\");\n+            checkDiags(dh, beginIndex);\n@@ -199,2 +252,5 @@\n-        if (new TypeAnnotationFinder().scan(paramTypes, null) != null)\n-            throw new ParseException(\"dc.ref.annotations.not.allowed\");\n+            return paramTypes.toList();\n+        } finally {\n+            fac.log.useSource(prev);\n+        }\n+    }\n@@ -202,1 +258,5 @@\n-        return paramTypes.toList();\n+    private void checkDiags(Log.DeferredDiagnosticHandler h, int offset) throws ParseException {\n+        JCDiagnostic d = h.getDiagnostics().peek();\n+        if (d != null) {\n+            throw new ParseException(offset + ((int) d.getPosition()), \"dc.ref.syntax.error\");\n+        }\n@@ -216,1 +276,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/ReferenceParser.java","additions":122,"deletions":62,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -28,0 +28,6 @@\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.util.List;\n+\n+import javax.lang.model.element.Name;\n+import javax.lang.model.util.Elements;\n@@ -29,0 +35,1 @@\n+import javax.tools.JavaFileObject;\n@@ -31,0 +38,2 @@\n+import com.sun.source.util.DocTreeScanner;\n+\n@@ -35,1 +44,0 @@\n-import com.sun.tools.javac.util.DiagnosticSource;\n@@ -37,1 +45,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.SimpleDiagnosticPosition;\n@@ -40,6 +47,1 @@\n-import java.io.IOException;\n-import java.io.StringWriter;\n-import java.util.List;\n-\n-import javax.lang.model.element.Name;\n-import javax.tools.JavaFileObject;\n+import static com.sun.tools.javac.util.Position.NOPOS;\n@@ -48,0 +50,29 @@\n+ *\n+ * Root class for abstract syntax documentation tree nodes. It provides definitions\n+ * for specific tree nodes as subclasses nested inside.\n+ *\n+ * Apart from the top-level {@link DCDocComment} node, generally nodes fall into\n+ * three groups:\n+ * <ul>\n+ * <li>Leaf nodes, such as {@link DCIdentifier}, {@link DCText}\n+ * <li>Inline tag nodes, such as {@link DCLink}, {@link DCLiteral}\n+ * <li>Block tag nodes, such as {@link DCParam}, {@link DCThrows}\n+ * <\/ul>\n+ *\n+ * Trees are typically wide and shallow, without a significant amount of nesting.\n+ *\n+ * Nodes have various associated positions:\n+ * <ul>\n+ * <li>the {@link #pos position} of the first character that is unique to this node,\n+ *      and not part of any child node\n+ * <li>the {@link #getStartPosition start} of the range of characters for this node\n+ * <li>the \"{@link #getPreferredPosition() preferred}\" position in the range of characters\n+ *      for this node\n+ * <li>the {@link #getEndPosition() end} of the range of characters for this node\n+ * <\/ul>\n+ *\n+ * All values are relative to the beginning of the\n+ * {@link Elements#getDocComment comment text} in which they appear.\n+ * To convert a value to the position in the enclosing source text,\n+ * use {@link DCDocComment#getSourcePosition(int)}.\n+ *\n@@ -56,2 +87,5 @@\n-     * The position in the comment string.\n-     * Use {@link #getSourcePosition getSourcePosition} to convert\n+     * The position of the first character that is unique to this node.\n+     * It is normally set by the methods in {@link DocTreeMaker}.\n+     *\n+     * The value is relative to the beginning of the comment text.\n+     * Use {@link DCDocComment#getSourcePosition(int)} to convert\n@@ -60,3 +94,3 @@\n-     * TODO: why not simply translate all these values into\n-     * source file positions? Is it useful to have string-offset\n-     * positions as well?\n+     * @see #getStartPosition()\n+     * @see #getPreferredPosition()\n+     * @see #getEndPosition()\n@@ -67,1 +101,2 @@\n-     * {@return the source position for this tree node}\n+     * {@return a {@code DiagnosticPosition} for this node}\n+     * The method may be used when reporting diagnostics for this node.\n@@ -69,1 +104,2 @@\n-     * @param dc the enclosing doc comment\n+     * @param dc the enclosing comment, used to convert comment-based positions\n+     *           to file-based positions\n@@ -71,2 +107,2 @@\n-    public long getSourcePosition(DCDocComment dc) {\n-        return dc.comment.getSourcePos(pos);\n+    public JCDiagnostic.DiagnosticPosition pos(DCDocComment dc) {\n+        return createDiagnosticPosition(dc.comment, getStartPosition(), getPreferredPosition(), getEndPosition());\n@@ -76,2 +112,3 @@\n-     * {@return the source position for position relative to this tree node}\n-     * This is primarily useful for nodes that wrap a single string child.\n+     * {@return the start position of this tree node}\n+     *\n+     * For most nodes, this is the position of the first character that is unique to this node.\n@@ -79,2 +116,3 @@\n-     * @param dc     the enclosing doc comment\n-     * @param offset the offset\n+     * The value is relative to the beginning of the comment text.\n+     * Use {@link DCDocComment#getSourcePosition(int)} to convert\n+     * it to a position in the source file.\n@@ -82,2 +120,2 @@\n-    public long getSourcePosition(DCDocComment dc, int offset) {\n-        return dc.comment.getSourcePos(pos + offset);\n+    public int getStartPosition() {\n+        return pos;\n@@ -86,2 +124,12 @@\n-    public JCDiagnostic.DiagnosticPosition pos(DCDocComment dc) {\n-        return new SimpleDiagnosticPosition(dc.comment.getSourcePos(pos));\n+    \/**\n+     * {@return the \"preferred\" position of this tree node}\n+     *\n+     * It is typically the position of the first character that is unique to this node.\n+     * It is the position that is used for the caret in \"line and caret\" diagnostic messages.\n+     *\n+     * The value is relative to the beginning of the comment text.\n+     * Use {@link DCDocComment#getSourcePosition(int)} to convert\n+     * it to a position in the source file.\n+     *\/\n+    public int getPreferredPosition() {\n+        return pos;\n@@ -90,1 +138,93 @@\n-    \/** Convert a tree to a pretty-printed string. *\/\n+    \/**\n+     * {@return the end position of the tree node}\n+     *\n+     * The value is typically derived in one of three ways:\n+     * <ul>\n+     * <li>computed from the start and length of \"leaf\" nodes, such as {@link TextTree},\n+     * <li>computed recursively from the end of the last child node, such as for most {@link DCBlockTag block tags}, or\n+     * <li>provided explicitly, such as for subtypes of {@link DCEndPosTree}\n+     * <\/ul>\n+     *\n+     * The value is relative to the beginning of the comment text.\n+     * Use {@link DCDocComment#getSourcePosition(int)} to convert\n+     * it to a position in the source file.\n+     *\/\n+    public int getEndPosition() {\n+        if (this instanceof DCEndPosTree<?> dcEndPosTree) {\n+            int endPos = dcEndPosTree.getEndPos();\n+\n+            if (endPos != NOPOS) {\n+                return endPos;\n+            }\n+        }\n+\n+        switch (getKind()) {\n+            case TEXT -> {\n+                DCText text = (DCText) this;\n+                return text.pos + text.text.length();\n+            }\n+\n+            case ERRONEOUS -> {\n+                DCErroneous err = (DCErroneous) this;\n+                return err.pos + err.body.length();\n+            }\n+\n+            case IDENTIFIER -> {\n+                DCIdentifier ident = (DCIdentifier) this;\n+                return ident.pos + ident.name.length();\n+            }\n+\n+            case AUTHOR, DEPRECATED, HIDDEN, PARAM, PROVIDES, RETURN, SEE, SERIAL, SERIAL_DATA, SERIAL_FIELD, SINCE,\n+                    THROWS, UNKNOWN_BLOCK_TAG, USES, VERSION -> {\n+                DCTree last = getLastChild();\n+\n+                if (last != null) {\n+                    int correction = (this instanceof DCParam p && p.isTypeParameter && p.getDescription().isEmpty()) ? 1 : 0;\n+                    return last.getEndPosition() + correction;\n+                }\n+\n+                String name = ((BlockTagTree) this).getTagName();\n+                return this.pos + name.length() + 1;\n+            }\n+\n+            case ENTITY -> {\n+                DCEntity endEl = (DCEntity) this;\n+                return endEl.pos + endEl.name.length() + 2;\n+            }\n+\n+            case COMMENT -> {\n+                DCComment endEl = (DCComment) this;\n+                return endEl.pos + endEl.body.length();\n+            }\n+\n+            case ATTRIBUTE -> {\n+                DCAttribute attr = (DCAttribute) this;\n+                if (attr.vkind == AttributeTree.ValueKind.EMPTY) {\n+                    return attr.pos + attr.name.length();\n+                }\n+                DCTree last = getLastChild();\n+                if (last != null) {\n+                    return last.getEndPosition() + (attr.vkind == AttributeTree.ValueKind.UNQUOTED ? 0 : 1);\n+                }\n+            }\n+\n+            case DOC_COMMENT ->  {\n+                DCDocComment dc = (DCDocComment) this;\n+                DCTree last = getLastChild();\n+                return last == null ? dc.pos : last.getEndPosition();\n+            }\n+\n+            default -> {\n+                DCTree last = getLastChild();\n+                if (last != null) {\n+                    return last.getEndPosition();\n+                }\n+            }\n+        }\n+\n+        return Position.NOPOS;\n+    }\n+\n+    \/**\n+     * Convert a tree to a pretty-printed string.\n+     *\/\n@@ -105,0 +245,52 @@\n+    \/**\n+     * {@return the last (right-most) child of this node}\n+     *\/\n+    private DCTree getLastChild() {\n+        final DCTree[] last = new DCTree[] {null};\n+\n+        accept(new DocTreeScanner<Void, Void>() {\n+            @Override @DefinedBy(Api.COMPILER_TREE)\n+            public Void scan(DocTree node, Void p) {\n+                if (node instanceof DCTree dcTree) last[0] = dcTree;\n+                return null;\n+            }\n+        }, null);\n+\n+        return last[0];\n+    }\n+\n+    \/**\n+     * {@return a diagnostic position based on the positions in a comment}\n+     *\n+     * The positions are lazily converted to file-based positions, as needed.\n+     *\n+     * @param comment the enclosing comment\n+     * @param start the start position in the comment\n+     * @param pref the preferred position in the comment\n+     * @param end the end position in the comment\n+     *\/\n+    public static JCDiagnostic.DiagnosticPosition createDiagnosticPosition(Comment comment, int start, int pref, int end) {\n+        return new JCDiagnostic.DiagnosticPosition() {\n+\n+            @Override\n+            public JCTree getTree() {\n+                return null;\n+            }\n+\n+            @Override\n+            public int getStartPosition() {\n+                return comment.getSourcePos(start);\n+            }\n+\n+            @Override\n+            public int getPreferredPosition() {\n+                return comment.getSourcePos(pref);\n+            }\n+\n+            @Override\n+            public int getEndPosition(EndPosTable endPosTable) {\n+                return comment.getSourcePos(end);\n+            }\n+        };\n+    }\n+\n@@ -107,1 +299,1 @@\n-        private int endPos = Position.NOPOS;\n+        private int endPos = NOPOS;\n@@ -109,2 +301,2 @@\n-        public int getEndPos(DCDocComment dc) {\n-            return dc.comment.getSourcePos(endPos);\n+        public int getEndPos() {\n+            return endPos;\n@@ -186,0 +378,4 @@\n+\n+        public int getSourcePosition(int index) {\n+            return comment.getSourcePos(index);\n+        }\n@@ -391,1 +587,1 @@\n-    public static class DCErroneous extends DCTree implements ErroneousTree, JCDiagnostic.DiagnosticPosition {\n+    public static class DCErroneous extends DCTree implements ErroneousTree {\n@@ -395,4 +591,1 @@\n-        DCErroneous(String body, JCDiagnostic.Factory diags, DiagnosticSource diagSource, String code, Object... args) {\n-            this.body = body;\n-            this.diag = diags.error(null, diagSource, this, code, args);\n-        }\n+        private int prefPos = NOPOS;\n@@ -425,5 +618,0 @@\n-        @Override\n-        public JCTree getTree() {\n-            return null;\n-        }\n-\n@@ -437,1 +625,1 @@\n-            return pos + body.length() - 1;\n+            return prefPos == NOPOS ? pos + body.length() - 1 : prefPos;\n@@ -441,1 +629,1 @@\n-        public int getEndPosition(EndPosTable endPosTable) {\n+        public int getEndPosition() {\n@@ -445,0 +633,5 @@\n+        public DCErroneous setPrefPos(int prefPos) {\n+            this.prefPos = prefPos;\n+            return this;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DCTree.java","additions":234,"deletions":41,"binary":false,"changes":275,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,3 +129,0 @@\n-    \/** Access to diag factory for ErroneousTrees. *\/\n-    private final JCDiagnostic.Factory diags;\n-\n@@ -141,1 +138,0 @@\n-        diags = JCDiagnostic.Factory.instance(context);\n@@ -156,7 +152,0 @@\n-    \/** Reassign current position.\n-     *\/\n-    public DocTreeMaker at(DiagnosticPosition pos) {\n-        this.pos = (pos == null ? Position.NOPOS : pos.getStartPosition());\n-        return this;\n-    }\n-\n@@ -292,6 +281,0 @@\n-    public DCErroneous newErroneousTree(String text, DiagnosticSource diagSource, String code, Object... args) {\n-        DCErroneous tree = new DCErroneous(text, diags, diagSource, code, args);\n-        tree.pos = pos;\n-        return tree;\n-    }\n-\n@@ -716,1 +699,1 @@\n-     * Returns the position of the the first non-white space\n+     * Returns the position of the first non-whitespace character.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DocTreeMaker.java","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-    protected JCDiagnostic.Factory diags;\n+    public final JCDiagnostic.Factory diags;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/AbstractLog.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -498,1 +498,1 @@\n-                            if (endPos >= 0) {\n+                            if (endPos >= offset) {\n","filename":"src\/jdk.compiler\/share\/classes\/jdk\/internal\/shellsupport\/doc\/JavadocHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -290,1 +290,0 @@\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/DocLint.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,0 +48,2 @@\n+import jdk.javadoc.doclet.Reporter;\n+\n@@ -53,0 +55,1 @@\n+import com.sun.tools.javac.tree.DCTree.DCDocComment;\n@@ -54,1 +57,0 @@\n-import jdk.javadoc.doclet.Reporter;\n@@ -281,1 +283,1 @@\n-        DCTree tree = (DCTree) path.getLeaf();\n+        DCTree docTree = (DCTree) path.getLeaf();\n@@ -284,3 +286,4 @@\n-        int sStart = (int) tree.getSourcePosition(docComment, start);\n-        int sPos = (int) tree.getSourcePosition(docComment, pos);\n-        int sEnd = (int) tree.getSourcePosition(docComment, end);\n+        int dtStart = docTree.getStartPosition();\n+        int sStart = docComment.getSourcePosition(dtStart + start);\n+        int sPos = docComment.getSourcePosition(dtStart + pos);\n+        int sEnd = docComment.getSourcePosition(dtStart + end);\n@@ -295,1 +298,1 @@\n-        return (int) tree.getSourcePosition(docComment, offset);\n+        return docComment.getSourcePosition(tree.getStartPosition() + offset);\n@@ -569,5 +572,3 @@\n-        DocSourcePositions posns = getSourcePositions();\n-        CompilationUnitTree compUnit = path.getTreePath().getCompilationUnit();\n-        int start = (int) posns.getStartPosition(compUnit, path.getDocComment(), path.getLeaf());\n-        int end = (int) posns.getEndPosition(compUnit, path.getDocComment(), path.getLeaf());\n-        return createDiagnosticPosition(null, start, start, end);\n+        DCDocComment dc = (DCDocComment) path.getDocComment();\n+        DCTree dcTree = (DCTree) path.getLeaf();\n+        return dcTree.pos(dc);\n@@ -660,1 +661,1 @@\n-     * Returns the diagnostic source for an documentation tree node.\n+     * Returns the diagnostic source for a documentation tree node.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/JavadocLog.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,6 +1,6 @@\n-CrashInAnnotateTest.java:10:5: compiler.err.proc.messager: annotations not allowed\n-CrashInAnnotateTest.java:11:5: compiler.err.proc.messager: syntax error in reference\n-CrashInAnnotateTest.java:16:5: compiler.err.proc.messager: annotations not allowed\n-CrashInAnnotateTest.java:21:5: compiler.err.proc.messager: syntax error in reference\n-CrashInAnnotateTest.java:24:5: compiler.err.proc.messager: syntax error in reference\n-CrashInAnnotateTest.java:25:5: compiler.err.proc.messager: syntax error in reference\n+CrashInAnnotateTest.java:10:20: compiler.err.proc.messager: annotations not allowed\n+CrashInAnnotateTest.java:11:37: compiler.err.proc.messager: syntax error in reference\n+CrashInAnnotateTest.java:16:39: compiler.err.proc.messager: annotations not allowed\n+CrashInAnnotateTest.java:21:23: compiler.err.proc.messager: syntax error in reference\n+CrashInAnnotateTest.java:24:54: compiler.err.proc.messager: syntax error in reference\n+CrashInAnnotateTest.java:25:37: compiler.err.proc.messager: syntax error in reference\n","filename":"test\/langtools\/tools\/doclint\/CrashInAnnotateTest.out","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-       ^\n+             ^\n@@ -9,1 +9,1 @@\n-       ^\n+          ^\n","filename":"test\/langtools\/tools\/doclint\/EndWithIdentifierTest.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,3 +1,3 @@\n-UnfinishedInlineTagTest.java:15: error: unterminated inline tag\n- *\/\n-^\n+UnfinishedInlineTagTest.java:14: error: unterminated inline tag\n+\/**{@link List\n+              ^\n","filename":"test\/langtools\/tools\/doclint\/UnfinishedInlineTagTest.out","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-directroy.\n+directory.\n@@ -10,2 +10,2 @@\n-tidystats.Main is a Java program that can analyze the \n-files produced by the tidy.sh script to generate a \n+tidystats.Main is a Java program that can analyze the\n+files produced by the tidy.sh script to generate a\n@@ -18,1 +18,1 @@\n-generated by javadoc. \n+generated by javadoc.\n@@ -21,1 +21,1 @@\n-Library Project page at http:\/\/tidy.sourceforge.net\/.\n+page at https:\/\/www.html-tidy.org.\n","filename":"test\/langtools\/tools\/doclint\/tidy\/README.txt","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-    ^\n+     ^\n@@ -6,1 +6,1 @@\n-       ^\n+           ^\n@@ -10,2 +10,1 @@\n-3 errors\n-\n+3 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/doclint\/tidy\/UnescapedOrUnknownEntity.out","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614 8076026\n+ * @bug 7021614 8076026 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/AttrTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614\n+ * @bug 7021614 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/AuthorTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614\n+ * @bug 7021614 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/BadTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614 8241780\n+ * @bug 7021614 8241780 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/CodeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8273244\n+ * @summary check coverage of tools\/javac\/doctree tests\n+ * @modules jdk.compiler\n+ * @run main CoverageTest\n+ *\/\n+\n+import com.sun.source.doctree.DocCommentTree;\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.DocTreeScanner;\n+import com.sun.source.util.DocTrees;\n+import com.sun.source.util.JavacTask;\n+import com.sun.source.util.TaskEvent;\n+import com.sun.source.util.TaskListener;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.TreePathScanner;\n+\n+import javax.lang.model.element.Name;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileObject;\n+import javax.tools.StandardJavaFileManager;\n+import javax.tools.ToolProvider;\n+import java.io.IOException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Scans for tests in the same source directory that use the DocCommentTester framework,\n+ * and for those tests, scans for doc comments, counting the number of occurrences\n+ * of different kinds of DocTree nodes.  The number are mostly just informational,\n+ * except for the (implicit) zeroes, indicating that no instances of a kind of tree\n+ * have been detected ... which is a hole in the coverage.\n+ *\n+ * If desired, we could enhance the DocTreeScanner to track different variants of\n+ * specific kinds of tree nodes.\n+ *\/\n+public class CoverageTest {\n+    public static void main(String... args) throws Exception {\n+        new CoverageTest().run(args);\n+    }\n+\n+    void run(String... args) throws Exception {\n+        Path src = Path.of(System.getProperty(\"test.src\"));\n+\n+        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+        StandardJavaFileManager fm = compiler.getStandardFileManager(null, null, null);\n+\n+        List<JavaFileObject> files = new ArrayList<>();\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(src, this::isDocCommentTesterTest)) {\n+            for (Path p : ds) {\n+                files.add(fm.getJavaFileObjects(p).iterator().next());\n+            }\n+        }\n+\n+        JavacTask task = (JavacTask) compiler.getTask(null, null, null, null, null, files);\n+\n+        DocTrees trees = DocTrees.instance(task);\n+        Map<DocTree.Kind, Integer> counts = new TreeMap<>();\n+        DocTreeScanner dtScanner = new DocTreeScanner() {\n+            @Override\n+            public Object scan(DocTree node, Object o) {\n+                if (node != null) {\n+                    DocTree.Kind k = node.getKind();\n+                    counts.put(k, counts.computeIfAbsent(k, k_ -> 0) + 1);\n+                }\n+                return super.scan(node, o);\n+            }\n+        };\n+\n+        TreePathScanner declScanner = new DeclScanner() {\n+            @Override\n+            void visitDecl(Tree tree, Name name) {\n+                TreePath path = getCurrentPath();\n+                DocCommentTree dc = trees.getDocCommentTree(path);\n+                dtScanner.scan(dc, null);\n+            }\n+        };\n+\n+\n+        task.addTaskListener(new TaskListener() {\n+            @Override\n+            public void finished(TaskEvent e) {\n+                if (e.getKind() == TaskEvent.Kind.PARSE) {\n+                    declScanner.scan(e.getCompilationUnit(), null);\n+                }\n+            }\n+        });\n+\n+        task.parse();\n+\n+        counts.forEach((k, v) -> System.err.printf(\"%20s: %5d%n\", k, v));\n+\n+        \/\/ Note: DOC_TYPE cannot appear in any doc comment in a *.java file,\n+        \/\/ and OTHER is a special value that never appears in any standard DocTree node.\n+        List<DocTree.Kind> notFound = Stream.of(DocTree.Kind.values())\n+                .filter(k -> switch (k) { case DOC_TYPE, OTHER -> false; default -> true; })\n+                .filter(k -> !counts.containsKey(k))\n+                .toList();\n+\n+        if (!notFound.isEmpty()) {\n+            System.err.println();\n+            System.err.println(\"ERROR: The following kinds were not found: \" + notFound.stream()\n+                    .map(DocTree.Kind::name)\n+                    .collect(Collectors.joining(\", \")));\n+            System.err.println();\n+            throw new Exception(\"Not Found: \" + notFound);\n+        }\n+    }\n+\n+    boolean isDocCommentTesterTest(Path p) throws IOException {\n+        if (!p.getFileName().toString().endsWith(\".java\")) {\n+            return false;\n+        }\n+\n+        String marker = \" * @run main DocCommentTester \" + p.getFileName();\n+        for (String line : Files.readAllLines(p)) {\n+            if (line.equals(marker)) {\n+                return true;\n+            } else if (line.contains(\"{\")) {\n+                return false;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    static abstract class DeclScanner extends TreePathScanner<Void, Void> {\n+        abstract void visitDecl(Tree tree, Name name);\n+\n+        @Override\n+        public Void visitClass(ClassTree tree, Void ignore) {\n+            super.visitClass(tree, ignore);\n+            visitDecl(tree, tree.getSimpleName());\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitMethod(MethodTree tree, Void ignore) {\n+            super.visitMethod(tree, ignore);\n+            visitDecl(tree, tree.getName());\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitVariable(VariableTree tree, Void ignore) {\n+            super.visitVariable(tree, ignore);\n+            visitDecl(tree, tree.getName());\n+            return null;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/doctree\/CoverageTest.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614\n+ * @bug 7021614 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/DeprecatedTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import javax.tools.Diagnostic;\n@@ -60,0 +61,8 @@\n+\/**\n+ * A class to test doc comment trees.\n+ * It is normally executed by calling {@code main}, providing a source file to be analyzed.\n+ * The file is scanned for top-level declarations, and the comment for any such declarations\n+ * is analyzed with a series of \"checkers\".\n+ *\n+ * @see DocCommentTester.ASTChecker#main(String... args)\n+ *\/\n@@ -62,6 +71,0 @@\n-    public static final String BI_MARKER = \"BREAK_ITERATOR\";\n-    public final boolean useBreakIterator;\n-\n-    public DocCommentTester(boolean useBreakIterator) {\n-        this.useBreakIterator = useBreakIterator;\n-    }\n@@ -78,0 +81,7 @@\n+    public static final String BI_MARKER = \"BREAK_ITERATOR\";\n+    public final boolean useBreakIterator;\n+\n+    public DocCommentTester(boolean useBreakIterator) {\n+        this.useBreakIterator = useBreakIterator;\n+    }\n+\n@@ -101,1 +111,3 @@\n-            new PrettyChecker(this, trees)\n+            new PrettyChecker(this, trees),\n+            new RangeChecker(this, trees),\n+            new StartEndPosChecker(this, trees)\n@@ -197,1 +209,1 @@\n-     * Verify the structure of the DocTree AST by comparing it against golden text.\n+     * Verifies the structure of the DocTree AST by comparing it against golden text.\n@@ -283,1 +295,1 @@\n-                Printer p = new Printer();\n+                final Printer p = new Printer();\n@@ -787,1 +799,1 @@\n-     * Verify the reported tree positions by comparing the characters found\n+     * Verifies the reported tree positions by comparing the characters found\n@@ -802,1 +814,0 @@\n-            DCTree t = (DCTree) trees.getDocCommentTree(path);\n@@ -809,0 +820,1 @@\n+                            DCTree dcTree = (DCTree) node;\n@@ -810,2 +822,2 @@\n-                            long pos = ((DCTree) node).getSourcePosition(dc);\n-                            String found = getFoundText(cs, (int) pos, expect.length());\n+                            long startPos = dc.getSourcePosition(dcTree.getStartPosition());\n+                            String found = getFoundText(cs, (int) startPos, expect.length());\n@@ -819,1 +831,1 @@\n-                            error(node.getClass() + \": \" + e.toString());\n+                            error(node.getClass() + \": \" + e);\n@@ -827,1 +839,1 @@\n-            scanner.scan(t, null);\n+            scanner.scan(dc, null);\n@@ -848,1 +860,1 @@\n-     * Verify the pretty printed text against a normalized form of the\n+     * Verifies the pretty printed text against a normalized form of the\n@@ -896,3 +908,3 @@\n-            return s.replaceAll(\"\\\\{@docRoot\\\\s+\\\\}\", \"{@docRoot}\")\n-                    .replaceAll(\"\\\\{@inheritDoc\\\\s+\\\\}\", \"{@inheritDoc}\")\n-                    .replaceAll(\"(\\\\{@value\\\\s+[^}]+)\\\\s+(\\\\})\", \"$1$2\")\n+            return s.replaceAll(\"\\\\{@docRoot\\\\s+}\", \"{@docRoot}\")\n+                    .replaceAll(\"\\\\{@inheritDoc\\\\s+}\", \"{@inheritDoc}\")\n+                    .replaceAll(\"(\\\\{@value\\\\s+[^}]+)\\\\s+(})\", \"$1$2\")\n@@ -910,1 +922,1 @@\n-                    case '{':\n+                    case '{' ->\n@@ -912,2 +924,2 @@\n-                        break;\n-                    case '}':\n+\n+                    case '}' -> {\n@@ -919,1 +931,1 @@\n-                        break;\n+                    }\n@@ -926,0 +938,145 @@\n+\n+\n+    \/**\n+     * Verifies the general \"left to right\" constraints for the positions of\n+     * nodes in the DocTree AST.\n+     *\/\n+    static class RangeChecker extends Checker {\n+        int cursor = 0;\n+\n+        RangeChecker(DocCommentTester test, DocTrees docTrees) {\n+            test.super(docTrees);\n+        }\n+\n+        @Override\n+        void check(TreePath path, Name name) throws Exception {\n+            final DCDocComment dc = (DCDocComment) trees.getDocCommentTree(path);\n+\n+            DocTreeScanner<Void, Void> scanner = new DocTreeScanner<>() {\n+                @Override\n+                public Void scan(DocTree node, Void ignore) {\n+                    if (node instanceof DCTree dcTree) {\n+                        int start = dcTree.getStartPosition();\n+                        int pref = dcTree.getPreferredPosition();\n+                        int end = dcTree.getEndPosition();\n+\n+                        \/\/ check within the node, start <= pref <= end\n+                        check(\"start:pref\", dcTree, start, pref);\n+                        check(\"pref:end\", dcTree, pref, end);\n+\n+                        \/\/ check cursor <= start\n+                        check(\"cursor:start\", dcTree, cursor, start);\n+                        cursor = start;\n+\n+                        \/\/ recursively scan any children, updating the cursor\n+                        super.scan(node, ignore);\n+\n+                        \/\/ check cursor <= end\n+                        check(\"cursor:end\", dcTree, cursor, end);\n+                        cursor = end;\n+                    }\n+                    return null;\n+                }\n+            };\n+\n+            cursor = 0;\n+            scanner.scan(dc, null);\n+\n+        }\n+\n+        void check(String name, DCTree tree, int first, int second) {\n+            if (!(first <= second)) {\n+                error(name, tree, first, second);\n+            }\n+        }\n+\n+        private void error(String name, DCTree tree, int first, int second) {\n+            String t = tree.toString().replaceAll(\"\\\\s+\", \" \");\n+            if (t.length() > 32) {\n+                t = t.substring(0, 15) + \"...\" + t.substring(t.length() - 15);\n+            }\n+            error(\"Checking \" + name + \" for \" + tree.getKind() + \" `\" + t + \"`;  first:\" + first + \", second:\" + second);\n+\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that the start and end positions of all nodes in a DocCommentTree point to the\n+     * expected characters in the source code.\n+     *\n+     * The expected characters are derived from the beginning and end of the DocPretty output\n+     * for each node. Note that while the whitespace within the DocPretty output may not exactly\n+     * match the original source code, the first and last characters should match.\n+     *\/\n+    static class StartEndPosChecker extends Checker {\n+\n+        StartEndPosChecker(DocCommentTester test, DocTrees docTrees) {\n+            test.super(docTrees);\n+        }\n+\n+        @Override\n+        void check(TreePath path, Name name) throws Exception {\n+            final DCDocComment dc = (DCDocComment) trees.getDocCommentTree(path);\n+            JavaFileObject jfo = path.getCompilationUnit().getSourceFile();\n+            CharSequence content = jfo.getCharContent(true);\n+\n+            DocTreeScanner<Void, Void> scanner = new DocTreeScanner<>() {\n+                @Override\n+                public Void scan(DocTree node, Void ignore) {\n+                    if (node instanceof DCTree dcTree) {\n+                        int start = dc.getSourcePosition(dc.getStartPosition());\n+                        int end = dc.getSourcePosition(dcTree.getEndPosition());\n+\n+                        try {\n+                            StringWriter out = new StringWriter();\n+                            DocPretty dp = new DocPretty(out);\n+                            dp.print(trees.getDocCommentTree(path));\n+                            String pretty = out.toString();\n+\n+                            if (pretty.isEmpty()) {\n+                                if (start != end) {\n+                                    error(\"Error: expected content is empty, but actual content is not: \"\n+                                            + dcTree.getKind() + \" [\" + start + \",\" + end + \")\"\n+                                            + \": \\\"\" + content.subSequence(start, end) + \"\\\"\" );\n+                                }\n+                            } else {\n+                                check(dcTree, \"start\", content, start, pretty, 0);\n+                                check(dcTree, \"end\", content, end - 1, pretty, pretty.length() - 1);\n+                            }\n+\n+                        } catch (IOException e) {\n+                            error(\"Error generating DocPretty for tree at position \" + start + \"; \" + e);\n+                        }\n+                    }\n+                    return null;\n+                }\n+            };\n+\n+            scanner.scan(dc, null);\n+        }\n+\n+        void check(DCTree tree, String label, CharSequence content, int contentIndex, String pretty, int prettyIndex) {\n+            if (contentIndex == Diagnostic.NOPOS) {\n+                error(\"NOPOS for content \" + label + \": \" + tree.getKind() + \" >>\" + abbrev(pretty, MAX) + \"<<\");\n+            }\n+\n+            char contentChar = content.charAt(contentIndex);\n+            char prettyChar = pretty.charAt(prettyIndex);\n+            if (contentChar != prettyChar) {\n+                error (\"Mismatch for content \" + label + \": \"\n+                        + \"expect: '\" + prettyChar + \"', found: '\" + contentChar + \"' at position \" + contentIndex + \": \"\n+                        + tree.getKind() + \" >>\" + abbrev(pretty, MAX) + \"<<\");\n+            }\n+        }\n+\n+        static final int MAX = 64;\n+\n+        static String abbrev(String s, int max) {\n+            s = s.replaceAll(\"\\\\s+\", \" \");\n+            if (s.length() > max) {\n+                s = s.substring(0, max \/ 2 - 2) + \" ... \" + s.substring(max \/ 2 + 2);\n+            }\n+            return s;\n+        }\n+\n+    }\n","filename":"test\/langtools\/tools\/javac\/doctree\/DocCommentTester.java","additions":181,"deletions":24,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614\n+ * @bug 7021614 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/DocRootTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614 8078320 8247788\n+ * @bug 7021614 8078320 8247788 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/ElementTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614\n+ * @bug 7021614 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/EntityTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614\n+ * @bug 7021614 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/ExceptionTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614 8078320 8132096\n+ * @bug 7021614 8078320 8132096 8273244\n@@ -41,1 +41,1 @@\n-DocComment[DOC_COMMENT, pos:-1\n+DocComment[DOC_COMMENT, pos:0\n@@ -49,1 +49,1 @@\n-DocComment[DOC_COMMENT, pos:-1\n+DocComment[DOC_COMMENT, pos:0\n","filename":"test\/langtools\/tools\/javac\/doctree\/FirstSentenceTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8073100\n+ * @bug 8073100 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/HiddenTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8078320\n+ * @bug 8078320 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/InPreTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8144287\n+ * @bug 8144287 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/IndexTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614\n+ * @bug 7021614 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/InheritDocTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614\n+ * @bug 7021614 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/LinkPlainTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614\n+ * @bug 7021614 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/LinkTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614  8241780\n+ * @bug 7021614  8241780 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/LiteralTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614\n+ * @bug 7021614 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/ParamTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8160196\n+ * @bug 8160196 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/ProvidesTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614\n+ * @bug 7021614 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/ReturnTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614 8031212\n+ * @bug 7021614 8031212 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/SeeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614\n+ * @bug 7021614 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/SerialDataTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614\n+ * @bug 7021614 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/SerialFieldTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614\n+ * @bug 7021614 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/SerialTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614\n+ * @bug 7021614 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/SinceTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8173425\n+ * @bug 8173425 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/SummaryTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 5076751\n+ * @bug 5076751 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/SystemPropertyTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614 8078320\n+ * @bug 7021614 8078320 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/TagTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614\n+ * @bug 7021614 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/ThrowableTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8160196\n+ * @bug 8160196 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/UsesTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614\n+ * @bug 7021614 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/ValueTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614\n+ * @bug 7021614 8273244\n","filename":"test\/langtools\/tools\/javac\/doctree\/VersionTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-                                DocSourcePositions sp = (DocSourcePositions) trees.getSourcePositions(); \/\/XXX: the cast???\n+                                DocSourcePositions sp = trees.getSourcePositions();\n","filename":"test\/langtools\/tools\/javac\/doctree\/positions\/TestPosition.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,4 +203,5 @@\n-     *  Report an error for a specific tree node.\n-     *  @param file the source file for the tree\n-     *  @param t    the tree node\n-     *  @param label an indication of the error\n+     * Report an error for a specific tree node.\n+     *\n+     * @param file the source file for the tree\n+     * @param tree the tree node\n+     * @param msg  an indication of the error\n@@ -214,4 +215,6 @@\n-     *  Report an error for a specific tree node.\n-     *  @param file the source file for the tree\n-     *  @param t    the tree node\n-     *  @param label an indication of the error\n+     * Report an error for a specific tree node.\n+     *\n+     * @param file    the source file for the tree\n+     * @param comment the top level doc tree node\n+     * @param tree    the tree node\n+     * @param msg     an indication of the error\n@@ -222,1 +225,1 @@\n-        error(file.getName() + \":\" + getLine(file, t.getSourcePosition(dc)) + \": \" + msg + \" \" + trim(t, 64));\n+        error(file.getName() + \":\" + getLine(file, dc.getSourcePosition(t.pos)) + \": \" + msg + \" \" + trim(t, 64));\n","filename":"test\/langtools\/tools\/javac\/tree\/AbstractTreeScannerTest.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"}]}