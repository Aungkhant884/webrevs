[{"commit":{"message":"Fix match rules for mla\/mls and add a vector API regression testcase"},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad"},{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorMulAddSub.java"}],"sha":"fad1cc2fd116920f1d4d480043f2b115cc0a40d3"},{"commit":{"message":"Merge branch 'master' into fg8275275"},"files":[],"sha":"5b4021ce00f4886f1f821ca9feadde9f324e01f2"},{"commit":{"message":"8275275: AArch64: Fix performance regression after auto-vectorization on NEON\n\nFor some vector opcodes, there are no corresponding AArch64 NEON\ninstructions but supporting them benefits vector API. Some of\nthis kind of opcodes are also used by superword for auto-\nvectorization and here is the list:\n```\nVectorCastD2I, VectorCastL2F\nMulVL\nAddReductionVI\/L\/F\/D\nMulReductionVI\/L\/F\/D\nAndReductionV, OrReductionV, XorReductionV\n```\n\nWe did some micro-benchmark performance tests on NEON and found\nthat some of listed opcodes hurt the performance of loops after\nauto-vectorization, but others don't.\n\nThis patch disables those opcodes for superword, which have\nobvious performance regressions after auto-vectorization on\nNEON. Besides, one jtreg test case, where IR nodes are checked,\nis added in the patch to protect the code against change by\nmistake in the future.\n\nHere is the performance data before and after the patch on NEON.\n\nBenchmark       length  Mode  Cnt   Before    After     Units\nAddReductionVD   1024   thrpt  15   450.830   548.001   ops\/ms\nAddReductionVF   1024   thrpt  15   514.468   548.013   ops\/ms\nMulReductionVD   1024   thrpt  15   405.613   499.531   ops\/ms\nMulReductionVF   1024   thrpt  15   451.292   495.061   ops\/ms\n\nNote:\nBecause superword doesn't vectorize reductions unconnected with\nother vector packs, the benchmark function for Add\/Mul\nreduction is like:\n```\n\/\/  private double[] da, db;\n\/\/  private double dresult;\n  public void AddReductionVD() {\n    double result = 1;\n    for (int i = startIndex; i < length; i++) {\n      result += (da[i] + db[i]);\n    }\n    dresult += result;\n  }\n```\n\nSpecially, vector multiply long has been implemented but disabled\nfor both vector API and superword. Out of the same reason, the\npatch re-enables MulVL on NEON for Vector API but still disables\nit for superword. The performance uplift on vector API is ~12.8x\non my local.\n\nBenchmark          length  Mode  Cnt  Before   After    Units\nLong128Vector.MUL   1024   thrpt  10  55.015   760.593  ops\/ms\nMulVL(superword)    1024   thrpt  10  907.788  907.805  ops\/ms\n\nNote:\nThe superword benchmark function is:\n```\n\/\/  private long[] in1, in2, res;\n  public void MulVL() {\n    for (int i = 0; i < length; i++) {\n      res[i] = in1[i] * in2[i];\n    }\n  }\n\nThe Vector API benchmark case is from:\nhttps:\/\/github.com\/openjdk\/panama-vector\/blob\/vectorIntrinsics\/test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long128Vector.java#L190\n\n```\n\nChange-Id: Ie9133e4010f98b26f97969c02fbf992b11e7edbb"},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad"},{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4"},{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestDisableAutoVectOpcodes.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java"}],"sha":"d02cd800deadf10af2ccebe00a2d78749b685b4c"}]