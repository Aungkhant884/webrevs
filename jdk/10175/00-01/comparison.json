{"files":[{"patch":"@@ -2027,2 +2027,1 @@\n-  match(Set dst_src1 (AddVL dst_src1 (MulVL src2 src3)));\n-  format %{ \"vmla $dst_src1, src2, src3\" %}\n+  format %{ \"vmla $dst_src1, $src2, $src3\" %}\n@@ -2032,2 +2031,1 @@\n-    if (VM_Version::use_neon_for_vector(length_in_bytes) && bt != T_LONG) {\n-      \/\/ NEON mlav does not accept T2D arrangement.\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n@@ -2045,0 +2043,12 @@\n+instruct vmlaL(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddVL dst_src1 (MulVL src2 src3)));\n+  format %{ \"vmlaL $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_mla($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2051,1 +2061,1 @@\n-  format %{ \"vmla_masked $dst_src1, $pg, src2, src3\" %}\n+  format %{ \"vmla_masked $dst_src1, $pg, $src2, $src3\" %}\n@@ -2106,2 +2116,1 @@\n-  match(Set dst_src1 (SubVL dst_src1 (MulVL src2 src3)));\n-  format %{ \"vmls $dst_src1, src2, src3\" %}\n+  format %{ \"vmls $dst_src1, $src2, $src3\" %}\n@@ -2111,2 +2120,1 @@\n-    if (VM_Version::use_neon_for_vector(length_in_bytes) && bt != T_LONG) {\n-      \/\/ NEON mlsv does not accept T2D arrangement.\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n@@ -2124,0 +2132,12 @@\n+instruct vmlsL(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVL dst_src1 (MulVL src2 src3)));\n+  format %{ \"vmlsL $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_mls($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2130,1 +2150,1 @@\n-  format %{ \"vmls_masked $dst_src1, $pg, src2, src3\" %}\n+  format %{ \"vmls_masked $dst_src1, $pg, $src2, $src3\" %}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":30,"deletions":10,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1059,2 +1059,1 @@\n-  match(Set dst_src1 (AddVL dst_src1 (MulVL src2 src3)));\n-  format %{ \"vmla $dst_src1, src2, src3\" %}\n+  format %{ \"vmla $dst_src1, $src2, $src3\" %}\n@@ -1064,2 +1063,1 @@\n-    if (VM_Version::use_neon_for_vector(length_in_bytes) && bt != T_LONG) {\n-      \/\/ NEON mlav does not accept T2D arrangement.\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n@@ -1077,0 +1075,12 @@\n+instruct vmlaL(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddVL dst_src1 (MulVL src2 src3)));\n+  format %{ \"vmlaL $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_mla($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1083,1 +1093,1 @@\n-  format %{ \"vmla_masked $dst_src1, $pg, src2, src3\" %}\n+  format %{ \"vmla_masked $dst_src1, $pg, $src2, $src3\" %}\n@@ -1138,2 +1148,1 @@\n-  match(Set dst_src1 (SubVL dst_src1 (MulVL src2 src3)));\n-  format %{ \"vmls $dst_src1, src2, src3\" %}\n+  format %{ \"vmls $dst_src1, $src2, $src3\" %}\n@@ -1143,2 +1152,1 @@\n-    if (VM_Version::use_neon_for_vector(length_in_bytes) && bt != T_LONG) {\n-      \/\/ NEON mlsv does not accept T2D arrangement.\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n@@ -1156,0 +1164,12 @@\n+instruct vmlsL(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVL dst_src1 (MulVL src2 src3)));\n+  format %{ \"vmlsL $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_mls($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1162,1 +1182,1 @@\n-  format %{ \"vmls_masked $dst_src1, $pg, src2, src3\" %}\n+  format %{ \"vmls_masked $dst_src1, $pg, $src2, $src3\" %}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":30,"deletions":10,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,267 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+\n+import java.util.Random;\n+\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.LongVector;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/**\n+ * @test\n+ * @bug 8275275\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @requires os.arch==\"aarch64\"\n+ * @summary AArch64: Fix performance regression after auto-vectorization on NEON\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.vectorapi.TestVectorMulAddSub\n+ *\/\n+\n+public class TestVectorMulAddSub {\n+\n+    private static final VectorSpecies<Byte> B_SPECIES = ByteVector.SPECIES_MAX;\n+    private static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_MAX;\n+    private static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_MAX;\n+    private static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_MAX;\n+\n+    private static int LENGTH = 1024;\n+    private static final Random RD = Utils.getRandomInstance();\n+\n+    private static byte[] ba;\n+    private static byte[] bb;\n+    private static byte[] bc;\n+    private static byte[] br;\n+    private static short[] sa;\n+    private static short[] sb;\n+    private static short[] sc;\n+    private static short[] sr;\n+    private static int[] ia;\n+    private static int[] ib;\n+    private static int[] ic;\n+    private static int[] ir;\n+    private static long[] la;\n+    private static long[] lb;\n+    private static long[] lc;\n+    private static long[] lr;\n+\n+    static {\n+        ba = new byte[LENGTH];\n+        bb = new byte[LENGTH];\n+        bc = new byte[LENGTH];\n+        br = new byte[LENGTH];\n+        sa = new short[LENGTH];\n+        sb = new short[LENGTH];\n+        sc = new short[LENGTH];\n+        sr = new short[LENGTH];\n+        ia = new int[LENGTH];\n+        ib = new int[LENGTH];\n+        ic = new int[LENGTH];\n+        ir = new int[LENGTH];\n+        la = new long[LENGTH];\n+        lb = new long[LENGTH];\n+        lc = new long[LENGTH];\n+        lr = new long[LENGTH];\n+\n+        for (int i = 0; i < LENGTH; i++) {\n+            ba[i] = (byte) RD.nextInt();\n+            bb[i] = (byte) RD.nextInt();\n+            bc[i] = (byte) RD.nextInt();\n+            sa[i] = (short) RD.nextInt();\n+            sb[i] = (short) RD.nextInt();\n+            sc[i] = (short) RD.nextInt();\n+            ia[i] = RD.nextInt();\n+            ib[i] = RD.nextInt();\n+            ic[i] = RD.nextInt();\n+            la[i] = RD.nextLong();\n+            lb[i] = RD.nextLong();\n+            lc[i] = RD.nextLong();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"vmla\", \"> 0\"})\n+    public static void testByteMulAdd() {\n+        for (int i = 0; i < LENGTH; i += B_SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(B_SPECIES, ba, i);\n+            ByteVector bv = ByteVector.fromArray(B_SPECIES, bb, i);\n+            ByteVector cv = ByteVector.fromArray(B_SPECIES, bc, i);\n+            av.add(bv.mul(cv)).intoArray(br, i);\n+        }\n+    }\n+\n+    @Run(test = \"testByteMulAdd\")\n+    public static void testByteMulAdd_runner() {\n+        testByteMulAdd();\n+        for (int i = 0; i < LENGTH; i++) {\n+            Asserts.assertEquals((byte) (ba[i] + bb[i] * bc[i]), br[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"vmla\", \"> 0\"})\n+    public static void testShortMulAdd() {\n+        for (int i = 0; i < LENGTH; i += S_SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(S_SPECIES, sa, i);\n+            ShortVector bv = ShortVector.fromArray(S_SPECIES, sb, i);\n+            ShortVector cv = ShortVector.fromArray(S_SPECIES, sc, i);\n+            av.add(bv.mul(cv)).intoArray(sr, i);\n+        }\n+    }\n+\n+    @Run(test = \"testShortMulAdd\")\n+    public static void testShortMulAdd_runner() {\n+        testShortMulAdd();\n+        for (int i = 0; i < LENGTH; i++) {\n+            Asserts.assertEquals((short) (sa[i] + sb[i] * sc[i]), sr[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"vmla\", \"> 0\"})\n+    public static void testIntMulAdd() {\n+        for (int i = 0; i < LENGTH; i += I_SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(I_SPECIES, ia, i);\n+            IntVector bv = IntVector.fromArray(I_SPECIES, ib, i);\n+            IntVector cv = IntVector.fromArray(I_SPECIES, ic, i);\n+            av.add(bv.mul(cv)).intoArray(ir, i);\n+        }\n+    }\n+\n+    @Run(test = \"testIntMulAdd\")\n+    public static void testIntMulAdd_runner() {\n+        testIntMulAdd();\n+        for (int i = 0; i < LENGTH; i++) {\n+            Asserts.assertEquals((ia[i] + ib[i] * ic[i]), ir[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseSVE\", \" > 0\"}, counts = {\"vmla\", \"> 0\"})\n+    public static void testLongMulAdd() {\n+        for (int i = 0; i < LENGTH; i += L_SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(L_SPECIES, la, i);\n+            LongVector bv = LongVector.fromArray(L_SPECIES, lb, i);\n+            LongVector cv = LongVector.fromArray(L_SPECIES, lc, i);\n+            av.add(bv.mul(cv)).intoArray(lr, i);\n+        }\n+    }\n+\n+    @Run(test = \"testLongMulAdd\")\n+    public static void testLongMulAdd_runner() {\n+        testLongMulAdd();\n+        for (int i = 0; i < LENGTH; i++) {\n+            Asserts.assertEquals((la[i] + lb[i] * lc[i]), lr[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"vmls\", \"> 0\"})\n+    public static void testByteMulSub() {\n+        for (int i = 0; i < LENGTH; i += B_SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(B_SPECIES, ba, i);\n+            ByteVector bv = ByteVector.fromArray(B_SPECIES, bb, i);\n+            ByteVector cv = ByteVector.fromArray(B_SPECIES, bc, i);\n+            av.sub(bv.mul(cv)).intoArray(br, i);\n+        }\n+    }\n+\n+    @Run(test = \"testByteMulSub\")\n+    public static void testByteMulSub_runner() {\n+        testByteMulSub();\n+        for (int i = 0; i < LENGTH; i++) {\n+            Asserts.assertEquals((byte) (ba[i] - bb[i] * bc[i]), br[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"vmls\", \"> 0\"})\n+    public static void testShortMulSub() {\n+        for (int i = 0; i < LENGTH; i += S_SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(S_SPECIES, sa, i);\n+            ShortVector bv = ShortVector.fromArray(S_SPECIES, sb, i);\n+            ShortVector cv = ShortVector.fromArray(S_SPECIES, sc, i);\n+            av.sub(bv.mul(cv)).intoArray(sr, i);\n+        }\n+    }\n+\n+    @Run(test = \"testShortMulSub\")\n+    public static void testShortMulSub_runner() {\n+        testShortMulSub();\n+        for (int i = 0; i < LENGTH; i++) {\n+            Asserts.assertEquals((short) (sa[i] - sb[i] * sc[i]), sr[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"vmls\", \"> 0\"})\n+    public static void testIntMulSub() {\n+        for (int i = 0; i < LENGTH; i += I_SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(I_SPECIES, ia, i);\n+            IntVector bv = IntVector.fromArray(I_SPECIES, ib, i);\n+            IntVector cv = IntVector.fromArray(I_SPECIES, ic, i);\n+            av.sub(bv.mul(cv)).intoArray(ir, i);\n+        }\n+    }\n+\n+    @Run(test = \"testIntMulSub\")\n+    public static void testIntMulSub_runner() {\n+        testIntMulSub();\n+        for (int i = 0; i < LENGTH; i++) {\n+            Asserts.assertEquals((ia[i] - ib[i] * ic[i]), ir[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseSVE\", \" > 0\"}, counts = {\"vmls\", \"> 0\"})\n+    public static void testLongMulSub() {\n+        for (int i = 0; i < LENGTH; i += L_SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(L_SPECIES, la, i);\n+            LongVector bv = LongVector.fromArray(L_SPECIES, lb, i);\n+            LongVector cv = LongVector.fromArray(L_SPECIES, lc, i);\n+            av.sub(bv.mul(cv)).intoArray(lr, i);\n+        }\n+    }\n+\n+    @Run(test = \"testLongMulSub\")\n+    public static void testLongMulSub_runner() {\n+        testLongMulSub();\n+        for (int i = 0; i < LENGTH; i++) {\n+            Asserts.assertEquals((la[i] - lb[i] * lc[i]), lr[i]);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorMulAddSub.java","additions":267,"deletions":0,"binary":false,"changes":267,"status":"added"}]}