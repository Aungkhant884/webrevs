{"files":[{"patch":"@@ -71,1 +71,2 @@\n-                (int)timeout, readTimeout, trace, pcb);\n+                timeout > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) timeout,\n+                readTimeout, trace, pcb);\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapClientFactory.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-            throw new NamingException(\"Timed out waiting for lock\");\n+            throw new CommunicationException(\"Timed out waiting for lock\");\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/pool\/Pool.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ *          lib\/\n+ * @run testng\/othervm LdapPoolTimeoutTest\n+ * @bug JDK-8277795\n+ * @summary Multi-threaded client timeout tests for ldap pool\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import javax.naming.Context;\n+import javax.naming.NamingException;\n+import javax.naming.directory.InitialDirContext;\n+import java.util.ArrayList;\n+import java.util.Hashtable;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.TimeUnit;\n+\n+import static jdk.test.lib.Utils.adjustTimeout;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.expectThrows;\n+\n+public class LdapPoolTimeoutTest {\n+    \/*\n+     * Practical representation of an infinite timeout.\n+     *\/\n+    private static final long INFINITY_MILLIS = adjustTimeout(20_000);\n+    \/*\n+     * The acceptable variation in timeout measurements.\n+     *\/\n+    private static final long TOLERANCE       = adjustTimeout( 3_500);\n+\n+    private static final long CONNECT_MILLIS  = adjustTimeout( 3_000);\n+    private static final long READ_MILLIS     = adjustTimeout(10_000);\n+\n+    static {\n+        \/\/ a series of checks to make sure this timeouts configuration is\n+        \/\/ consistent and the timeouts do not overlap\n+\n+        assert (TOLERANCE >= 0);\n+        \/\/ context creation\n+        assert (2 * CONNECT_MILLIS + TOLERANCE < READ_MILLIS);\n+        \/\/ context creation immediately followed by search\n+        assert (2 * CONNECT_MILLIS + READ_MILLIS + TOLERANCE < INFINITY_MILLIS);\n+    }\n+\n+    @Test\n+    public void test() throws Exception {\n+        List<Future<?>> futures = new ArrayList<>();\n+        ExecutorService executorService = Executors.newCachedThreadPool();\n+\n+        Hashtable<Object, Object> env = new Hashtable<>();\n+        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n+        env.put(\"com.sun.jndi.ldap.read.timeout\", String.valueOf(READ_MILLIS));\n+        env.put(\"com.sun.jndi.ldap.connect.timeout\", String.valueOf(CONNECT_MILLIS));\n+        env.put(\"com.sun.jndi.ldap.connect.pool\", \"true\");\n+\n+        env.put(Context.PROVIDER_URL, \"ldap:\/\/10.0.0.0\");\n+\n+        try {\n+            futures.add(executorService.submit(() -> { attemptConnect(env); return null; }));\n+            futures.add(executorService.submit(() -> { attemptConnect(env); return null; }));\n+            futures.add(executorService.submit(() -> { attemptConnect(env); return null; }));\n+            futures.add(executorService.submit(() -> { attemptConnect(env); return null; }));\n+            futures.add(executorService.submit(() -> { attemptConnect(env); return null; }));\n+            futures.add(executorService.submit(() -> { attemptConnect(env); return null; }));\n+            futures.add(executorService.submit(() -> { attemptConnect(env); return null; }));\n+            futures.add(executorService.submit(() -> { attemptConnect(env); return null; }));\n+        } finally {\n+            executorService.shutdown();\n+        }\n+        int failedCount = 0;\n+        for (var f : futures) {\n+            try {\n+                f.get();\n+            } catch (ExecutionException e) {\n+                failedCount++;\n+                e.getCause().printStackTrace(System.out);\n+            }\n+        }\n+        if (failedCount > 0)\n+            throw new RuntimeException(failedCount + \" (sub)tests failed\");\n+    }\n+\n+    private static void attemptConnect(Hashtable<Object, Object> env) throws Exception {\n+        Assert.ThrowingRunnable completion =\n+                () -> LdapTimeoutTest.assertCompletion(CONNECT_MILLIS - 1000,\n+                                       2 * CONNECT_MILLIS + TOLERANCE,\n+                                       () -> new InitialDirContext(env));\n+        NamingException e = expectThrows(NamingException.class, completion);\n+        String msg = e.getCause() == null ? e.getMessage() : e.getCause().getMessage();\n+        assertTrue(msg != null &&\n+                (msg.contains(\"Timed out\")\n+                    || msg.contains(\"timed out\")\n+                    || msg.contains(\"Timeout\")));\n+    }\n+\n+}\n+\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/LdapPoolTimeoutTest.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"}]}