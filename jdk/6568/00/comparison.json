{"files":[{"patch":"@@ -68,0 +68,6 @@\n+    public PooledConnection createPooledConnection(PoolCallback pcb, long timeout)\n+        throws NamingException {\n+        return new LdapClient(host, port, socketFactory,\n+                (int)timeout, readTimeout, trace, pcb);\n+    }\n+\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapClientFactory.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -71,0 +74,1 @@\n+    final private int initSize;\n@@ -74,0 +78,1 @@\n+    final private PooledConnectionFactory factory;\n@@ -78,0 +83,4 @@\n+    private boolean initialized = false;\n+    private final ReentrantLock lock;\n+    private final Condition connectionsAvailable;\n+\n@@ -90,3 +99,2 @@\n-    Connections(Object id, int initSize, int prefSize, int maxSize,\n-        PooledConnectionFactory factory) throws NamingException {\n-\n+    Connections(Object id, int initSize, int prefSize, int maxSize, PooledConnectionFactory factory,\n+            ReentrantLock lock) throws NamingException {\n@@ -94,0 +102,4 @@\n+        this.lock = lock;\n+        this.connectionsAvailable = lock.newCondition();\n+        this.factory = factory;\n+\n@@ -97,1 +109,1 @@\n-            initSize = Math.min(initSize, maxSize);\n+            this.initSize = Math.min(initSize, maxSize);\n@@ -100,0 +112,1 @@\n+            this.initSize = initSize;\n@@ -101,1 +114,2 @@\n-        conns = new ArrayList<>(maxSize > 0 ? maxSize : DEFAULT_SIZE);\n+        this.conns = new ArrayList<>(maxSize > 0 ? maxSize : DEFAULT_SIZE);\n+        this.initialized = initSize <= 0;\n@@ -105,1 +119,1 @@\n-        ref = new SoftReference<>(id);\n+        this.ref = new SoftReference<>(id);\n@@ -110,0 +124,1 @@\n+    }\n@@ -111,6 +126,7 @@\n-        \/\/ Create initial connections\n-        PooledConnection conn;\n-        for (int i = 0; i < initSize; i++) {\n-            conn = factory.createPooledConnection(this);\n-            td(\"Create \", conn ,factory);\n-            conns.add(new ConnectionDesc(conn)); \/\/ Add new idle conn to pool\n+    void waitForAvailableConnection() throws InterruptedNamingException {\n+        try {\n+            d(\"get(): waiting\");\n+            connectionsAvailable.await();\n+        } catch (InterruptedException e) {\n+            throw new InterruptedNamingException(\n+                    \"Interrupted while waiting for a connection\");\n@@ -120,38 +136,6 @@\n-    \/**\n-     * Retrieves a PooledConnection from this list of connections.\n-     * Use an existing one if one is idle, or create one if the list's\n-     * max size hasn't been reached. If max size has been reached, wait\n-     * for a PooledConnection to be returned, or one to be removed (thus\n-     * not reaching the max size any longer).\n-     *\n-     * @param timeout if > 0, msec to wait until connection is available\n-     * @param factory creates the PooledConnection if one needs to be created\n-     *\n-     * @return A non-null PooledConnection\n-     * @throws NamingException PooledConnection cannot be created, because this\n-     * thread was interrupted while it waited for an available connection,\n-     * or if it timed out while waiting, or the creation of a connection\n-     * resulted in an error.\n-     *\/\n-    synchronized PooledConnection get(long timeout,\n-        PooledConnectionFactory factory) throws NamingException {\n-        PooledConnection conn;\n-        long start = (timeout > 0 ? System.currentTimeMillis() : 0);\n-        long waittime = timeout;\n-\n-        d(\"get(): before\");\n-        while ((conn = getOrCreateConnection(factory)) == null) {\n-            if (timeout > 0 && waittime <= 0) {\n-                throw new CommunicationException(\n-                    \"Timeout exceeded while waiting for a connection: \" +\n-                    timeout + \"ms\");\n-            }\n-            try {\n-                d(\"get(): waiting\");\n-                if (waittime > 0) {\n-                    wait(waittime);  \/\/ Wait until one is released or removed\n-                } else {\n-                    wait();\n-                }\n-            } catch (InterruptedException e) {\n-                throw new InterruptedNamingException(\n+    void waitForAvailableConnection(long waitTime) throws InterruptedNamingException {\n+        try {\n+            d(\"get(): waiting\");\n+            connectionsAvailable.await(waitTime, TimeUnit.MILLISECONDS);\n+        } catch (InterruptedException e) {\n+            throw new InterruptedNamingException(\n@@ -159,6 +143,0 @@\n-            }\n-            \/\/ Check whether we timed out\n-            if (timeout > 0) {\n-                long now = System.currentTimeMillis();\n-                waittime = timeout - (now - start);\n-            }\n@@ -166,3 +144,0 @@\n-\n-        d(\"get(): after\");\n-        return conn;\n@@ -173,3 +148,0 @@\n-     * If none is available, create a new one if maxSize hasn't been reached.\n-     * If maxSize has been reached, return null.\n-     * Always called from a synchronized method.\n@@ -177,3 +149,8 @@\n-    private PooledConnection getOrCreateConnection(\n-        PooledConnectionFactory factory) throws NamingException {\n-\n+    PooledConnection getAvailableConnection(long timeout) throws NamingException {\n+        if (!initialized) {\n+            PooledConnection conn = createConnection(factory, timeout);\n+            if (conns.size() >= initSize) {\n+                this.initialized = true;\n+            }\n+            return conn;\n+        }\n@@ -181,1 +158,0 @@\n-        PooledConnection conn = null;\n@@ -187,2 +163,3 @@\n-            for (int i = 0; i < size; i++) {\n-                entry = conns.get(i);\n+            for (ConnectionDesc connectionDesc : conns) {\n+                PooledConnection conn;\n+                entry = connectionDesc;\n@@ -196,0 +173,2 @@\n+        return null;\n+    }\n@@ -197,3 +176,13 @@\n-        \/\/ Check if list size already at maxSize specified\n-        if (maxSize > 0 && size >= maxSize) {\n-            return null;   \/\/ List size is at limit; cannot create any more\n+    \/*\n+     * Creates a new Connection if maxSize hasn't been reached.\n+     * If maxSize has been reached, return null.\n+     * Caller must hold the ReentrantLock.\n+     *\/\n+    PooledConnection createConnection(PooledConnectionFactory factory, long timeout)\n+            throws NamingException {\n+        int size = conns.size(); \/\/ Current number of idle\/non-idle connections\n+        if (maxSize == 0 || size < maxSize) {\n+            PooledConnection conn = factory.createPooledConnection(this, timeout);\n+            td(\"Create and use \", conn, factory);\n+            conns.add(new ConnectionDesc(conn, true)); \/\/ Add new conn to pool\n+            return conn;\n@@ -202,5 +191,1 @@\n-        conn = factory.createPooledConnection(this);\n-        td(\"Create and use \", conn, factory);\n-        conns.add(new ConnectionDesc(conn, true)); \/\/ Add new conn to pool\n-\n-        return conn;\n+        return null;\n@@ -214,1 +199,1 @@\n-     *\n+     * <p>\n@@ -217,8 +202,5 @@\n-    public synchronized boolean releasePooledConnection(PooledConnection conn) {\n-        ConnectionDesc entry;\n-        int loc = conns.indexOf(entry=new ConnectionDesc(conn));\n-\n-        d(\"release(): \", conn);\n-\n-        if (loc >= 0) {\n-            \/\/ Found entry\n+    public boolean releasePooledConnection(PooledConnection conn) {\n+        lock.lock();\n+        try {\n+            ConnectionDesc entry;\n+            int loc = conns.indexOf(entry = new ConnectionDesc(conn));\n@@ -226,2 +208,1 @@\n-            if (closed || (prefSize > 0 && conns.size() > prefSize)) {\n-                \/\/ If list size exceeds prefSize, close connection\n+            d(\"release(): \", conn);\n@@ -229,2 +210,2 @@\n-                d(\"release(): closing \", conn);\n-                td(\"Close \", conn);\n+            if (loc >= 0) {\n+                \/\/ Found entry\n@@ -232,3 +213,2 @@\n-                \/\/ size must be >= 2 so don't worry about empty list\n-                conns.remove(entry);\n-                conn.closeConnection();\n+                if (closed || (prefSize > 0 && conns.size() > prefSize)) {\n+                    \/\/ If list size exceeds prefSize, close connection\n@@ -236,3 +216,2 @@\n-            } else {\n-                d(\"release(): release \", conn);\n-                td(\"Release \", conn);\n+                    d(\"release(): closing \", conn);\n+                    td(\"Close \", conn);\n@@ -240,4 +219,14 @@\n-                \/\/ Get ConnectionDesc from list to get correct state info\n-                entry = conns.get(loc);\n-                \/\/ Return connection to list, ready for reuse\n-                entry.release();\n+                    \/\/ size must be >= 2 so don't worry about empty list\n+                    conns.remove(entry);\n+                    conn.closeConnection();\n+                } else {\n+                    d(\"release(): release \", conn);\n+                    td(\"Release \", conn);\n+                    \/\/ Get ConnectionDesc from list to get correct state info\n+                    entry = conns.get(loc);\n+                    \/\/ Return connection to list, ready for reuse\n+                    entry.release();\n+                }\n+                connectionsAvailable.signalAll();\n+                d(\"release(): notify\");\n+                return true;\n@@ -245,5 +234,2 @@\n-            notifyAll();\n-            d(\"release(): notify\");\n-            return true;\n-        } else {\n-            return false;\n+        } finally {\n+            lock.unlock();\n@@ -251,0 +237,1 @@\n+        return false;\n@@ -260,1 +247,1 @@\n-     *\n+     * <p>\n@@ -263,3 +250,5 @@\n-    public synchronized boolean removePooledConnection(PooledConnection conn) {\n-        if (conns.remove(new ConnectionDesc(conn))) {\n-            d(\"remove(): \", conn);\n+    public boolean removePooledConnection(PooledConnection conn) {\n+        lock.lock();\n+        try {\n+            if (conns.remove(new ConnectionDesc(conn))) {\n+                d(\"remove(): \", conn);\n@@ -267,1 +256,1 @@\n-            notifyAll();\n+                connectionsAvailable.signalAll();\n@@ -269,2 +258,2 @@\n-            d(\"remove(): notify\");\n-            td(\"Remove \", conn);\n+                d(\"remove(): notify\");\n+                td(\"Remove \", conn);\n@@ -272,5 +261,5 @@\n-            if (conns.isEmpty()) {\n-                \/\/ Remove softref to make pool entry eligible for GC.\n-                \/\/ Once ref has been removed, it cannot be reinstated.\n-                ref = null;\n-            }\n+                if (conns.isEmpty()) {\n+                    \/\/ Remove softref to make pool entry eligible for GC.\n+                    \/\/ Once ref has been removed, it cannot be reinstated.\n+                    ref = null;\n+                }\n@@ -278,4 +267,6 @@\n-            return true;\n-        } else {\n-            d(\"remove(): not found \", conn);\n-            return false;\n+                return true;\n+            } else {\n+                d(\"remove(): not found \", conn);\n+            }\n+        } finally {\n+            lock.unlock();\n@@ -283,0 +274,1 @@\n+        return false;\n@@ -294,1 +286,2 @@\n-        synchronized(this) {\n+        lock.lock();\n+        try {\n@@ -296,0 +289,2 @@\n+        } finally {\n+            lock.unlock();\n@@ -307,1 +302,2 @@\n-        synchronized (this) {\n+        lock.lock();\n+        try {\n@@ -313,0 +309,2 @@\n+        } finally {\n+            lock.unlock();\n@@ -358,0 +356,23 @@\n+    boolean grabLock(long timeout) throws InterruptedNamingException {\n+        final long start = System.nanoTime();\n+        long current = start;\n+        long remaining = timeout;\n+        boolean locked = false;\n+        while (!locked && remaining > 0) {\n+            try {\n+                locked = lock.tryLock(remaining, TimeUnit.MILLISECONDS);\n+                remaining -= TimeUnit.NANOSECONDS.toMillis(current - start);\n+            } catch (InterruptedException ignore) {\n+                throw new InterruptedNamingException(\n+                        \"Interrupted while waiting for the connection pool lock\");\n+            }\n+            current = System.nanoTime();\n+            remaining -= TimeUnit.NANOSECONDS.toMillis(current - start);\n+        }\n+        return locked;\n+    }\n+\n+    void unlock() {\n+        lock.unlock();\n+    }\n+\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/pool\/Connections.java","additions":143,"deletions":122,"binary":false,"changes":265,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -38,0 +40,1 @@\n+import javax.naming.CommunicationException;\n@@ -120,0 +123,3 @@\n+        final long start = System.nanoTime();\n+        long remaining = timeout;\n+\n@@ -125,0 +131,1 @@\n+            remaining = checkRemaining(start, remaining);\n@@ -129,0 +136,25 @@\n+        Connections conns = getOrCreateConnections(factory, id);\n+        d(\"get(): size after: \", map.size());\n+        remaining = checkRemaining(start, remaining);\n+\n+        if (!conns.grabLock(remaining)) {\n+            throw new NamingException(\"Timed out waiting for lock\");\n+        }\n+\n+        try {\n+            remaining = checkRemaining(start, remaining);\n+            PooledConnection conn = null;\n+            while (remaining > 0 && conn == null) {\n+                conn = getOrCreatePooledConnection(factory, conns, start, remaining);\n+                \/\/ don't loop if the timeout has expired\n+                remaining = checkRemaining(start, timeout);\n+            }\n+            return conn;\n+        } finally {\n+            conns.unlock();\n+        }\n+    }\n+\n+    private Connections getOrCreateConnections(PooledConnectionFactory factory, Object id)\n+            throws NamingException {\n+\n@@ -131,16 +163,3 @@\n-            conns = getConnections(id);\n-            if (conns == null) {\n-                d(\"get(): creating new connections list for \", id);\n-\n-                \/\/ No connections for this id so create a new list\n-                conns = new Connections(id, initSize, prefSize, maxSize,\n-                    factory);\n-                ConnectionsRef connsRef = new ConnectionsRef(conns);\n-                map.put(id, connsRef);\n-\n-                \/\/ Create a weak reference to ConnectionsRef\n-                Reference<ConnectionsRef> weakRef =\n-                        new ConnectionsWeakRef(connsRef, queue);\n-\n-                \/\/ Keep the weak reference through the element of a linked list\n-                weakRefs.add(weakRef);\n+            ConnectionsRef ref = map.get(id);\n+            if (ref != null) {\n+                return ref.getConnections();\n@@ -148,1 +167,15 @@\n-            d(\"get(): size after: \", map.size());\n+\n+            d(\"get(): creating new connections list for \", id);\n+\n+            \/\/ No connections for this id so create a new list\n+            conns = new Connections(id, initSize, prefSize, maxSize,\n+                    factory, new ReentrantLock());\n+\n+            ConnectionsRef connsRef = new ConnectionsRef(conns);\n+            map.put(id, connsRef);\n+\n+            \/\/ Create a weak reference to ConnectionsRef\n+            Reference<ConnectionsRef> weakRef = new ConnectionsWeakRef(connsRef, queue);\n+\n+            \/\/ Keep the weak reference through the element of a linked list\n+            weakRefs.add(weakRef);\n@@ -150,0 +183,2 @@\n+        return conns;\n+    }\n@@ -151,1 +186,22 @@\n-        return conns.get(timeout, factory); \/\/ get one connection from list\n+    private PooledConnection getOrCreatePooledConnection(\n+            PooledConnectionFactory factory, Connections conns, long start, long timeout)\n+            throws NamingException {\n+        PooledConnection conn = conns.getAvailableConnection(timeout);\n+        if (conn != null) {\n+            return conn;\n+        }\n+        \/\/ no available cached connection\n+        \/\/ check if list size already at maxSize before creating a new one\n+        conn = conns.createConnection(factory, timeout);\n+        if (conn != null) {\n+            return conn;\n+        }\n+        \/\/ max number of connections already created,\n+        \/\/ try waiting around for one to become available\n+        if (timeout <= 0) {\n+            conns.waitForAvailableConnection();\n+        } else {\n+            long remaining = checkRemaining(start, timeout);\n+            conns.waitForAvailableConnection(remaining);\n+        }\n+        return null;\n@@ -154,3 +210,13 @@\n-    private Connections getConnections(Object id) {\n-        ConnectionsRef ref = map.get(id);\n-        return (ref != null) ? ref.getConnections() : null;\n+    \/\/ Check whether we timed out\n+    private long checkRemaining(long start, long timeout) throws CommunicationException {\n+        if (timeout > 0) {\n+            long current = System.nanoTime();\n+            long remaining = timeout - TimeUnit.NANOSECONDS.toMillis(current - start);\n+            if (remaining <= 0) {\n+                throw new CommunicationException(\n+                        \"Timeout exceeded while waiting for a connection: \" +\n+                                timeout + \"ms\");\n+            }\n+            return remaining;\n+        }\n+        return Long.MAX_VALUE;\n@@ -159,0 +225,1 @@\n+\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/pool\/Pool.java","additions":88,"deletions":21,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -47,0 +47,9 @@\n+\n+    \/**\n+     * Creates a pooled connection.\n+     * @param pcb callback responsible for removing and releasing the pooled\n+     * connection from the pool.\n+     * @param timeout the connection timeout\n+     *\/\n+    public abstract PooledConnection createPooledConnection(PoolCallback pcb, long timeout)\n+        throws NamingException;\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/pool\/PooledConnectionFactory.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}