{"files":[{"patch":"@@ -10258,0 +10258,20 @@\n+void Assembler::vfpclassss(KRegister kdst, XMMRegister src, uint8_t imm8) {\n+  \/\/ Encoding: EVEX.LIG.66.0F3A.W0 67 \/r ib\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(VM_Version::supports_avx512dq(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(kdst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24((unsigned char)0x67, (unsigned char)(0xC0 | encode), imm8);\n+}\n+\n+void Assembler::vfpclasssd(KRegister kdst, XMMRegister src, uint8_t imm8) {\n+  \/\/ Encoding: EVEX.LIG.66.0F3A.W1 67 \/r ib\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(VM_Version::supports_avx512dq(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(kdst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24((unsigned char)0x67, (unsigned char)(0xC0 | encode), imm8);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2725,0 +2725,4 @@\n+  \/\/ floating point class tests\n+  void vfpclassss(KRegister kdst, XMMRegister src, uint8_t imm8);\n+  void vfpclasssd(KRegister kdst, XMMRegister src, uint8_t imm8);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4743,0 +4743,98 @@\n+void C2_MacroAssembler::float_class_check(int opcode, Register dst, XMMRegister src, Register temp) {\n+\n+  int32_t POS_INF = 0x7f800000;\n+  int32_t KILL_SIGN_MASK = 0x7fffffff;\n+\n+  movdl(temp, src);\n+  andl(temp, KILL_SIGN_MASK);\n+  cmpl(temp, POS_INF);\n+  switch (opcode) {\n+    case Op_IsFiniteF:\n+      setb(Assembler::below, dst);\n+      break;\n+    case Op_IsInfiniteF: {\n+      setb(Assembler::equal, dst);\n+      break;\n+    }\n+    case Op_IsNaNF:\n+       setb(Assembler::above, dst);\n+       break;\n+    default:\n+      assert(false, \"%s\", NodeClassNames[opcode]);\n+  }\n+}\n+\n+void C2_MacroAssembler::float_class_check_vfp(int opcode, Register dst, XMMRegister src, KRegister tmp) {\n+  uint8_t imm8;\n+  switch (opcode) {\n+    case Op_IsFiniteF:\n+      imm8 = 0x99;\n+      break;\n+    case Op_IsInfiniteF:\n+      imm8 = 0x18;\n+      break;\n+    case Op_IsNaNF:\n+       imm8 = 0x81;\n+       break;\n+    default:\n+      assert(false, \"%s\", NodeClassNames[opcode]);\n+  }\n+  vfpclassss(tmp, src, imm8);\n+  kmovbl(dst, tmp);\n+  if (opcode == Op_IsFiniteF) {\n+    xorl(dst, 0x00000001);\n+  }\n+}\n+\n+\n+\n+#ifdef _LP64\n+void C2_MacroAssembler::double_class_check(int opcode, XMMRegister src, Register dst, Register temp,\n+                                            Register temp1, Register temp2) {\n+  int64_t POS_INF = 0x7ff0000000000000L;\n+  int64_t KILL_SIGN_MASK = 0x7fffffffffffffffL;\n+\n+  movq(temp, src);\n+  mov64(temp1, KILL_SIGN_MASK);\n+  andq(temp, temp1);\n+  mov64(temp2, POS_INF);\n+  cmpq(temp, temp2);\n+\n+  switch (opcode) {\n+    case Op_IsFiniteD:\n+      setb(Assembler::below, dst);\n+      break;\n+    case Op_IsInfiniteD:\n+      setb(Assembler::equal, dst);\n+      break;\n+    case Op_IsNaND:\n+      setb(Assembler::above, dst);\n+      break;\n+    default:\n+      assert(false, \"%s\", NodeClassNames[opcode]);\n+  }\n+}\n+\n+\n+void C2_MacroAssembler::double_class_check_vfp(int opcode, Register dst, XMMRegister src, KRegister tmp) {\n+  uint8_t imm8;\n+  switch (opcode) {\n+    case Op_IsFiniteD:\n+      imm8 = 0x99;\n+      break;\n+    case Op_IsInfiniteD:\n+      imm8 = 0x18;\n+      break;\n+    case Op_IsNaND:\n+       imm8 = 0x81;\n+       break;\n+    default:\n+      assert(false, \"%s\", NodeClassNames[opcode]);\n+  }\n+  vfpclasssd(tmp, src, imm8);\n+  kmovbl(dst, tmp);\n+  if (opcode == Op_IsFiniteD) {\n+    xorl(dst, 0x00000001);\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":98,"deletions":0,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -352,0 +352,2 @@\n+  void float_class_check(int opcode, Register dst, XMMRegister src, Register temp);\n+  void float_class_check_vfp(int opcode, Register dst, XMMRegister src, KRegister tmp);\n@@ -353,1 +355,2 @@\n-  #ifdef _LP64\n+\n+#ifdef _LP64\n@@ -357,1 +360,3 @@\n-  #endif\n+  void double_class_check(int opcode, XMMRegister src, Register dst, Register temp, Register temp1, Register temp2);\n+  void double_class_check_vfp(int opcode, Register dst, XMMRegister src, KRegister tmp);\n+#endif\n@@ -367,0 +372,2 @@\n+\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -11123,0 +11123,39 @@\n+instruct FloatClassCheck_reg_reg(rRegI dst, regF src, rRegI tmp, kReg ktmp, rFlagsReg cr)\n+%{\n+  match(Set dst (IsInfiniteF src));\n+  match(Set dst (IsNaNF src));\n+  match(Set dst (IsFiniteF src));\n+  effect(TEMP tmp, TEMP ktmp, KILL cr);\n+  format %{ \"float_class_check $dst, $src\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    if (VM_Version::supports_avx512dq()) {\n+      __ float_class_check_vfp(opcode, $dst$$Register, $src$$XMMRegister, $ktmp$$KRegister);\n+    }\n+    else {\n+      __ float_class_check(opcode, $dst$$Register, $src$$XMMRegister, $tmp$$Register);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct DoubleClassCheck_reg_reg(rRegI dst, regD src, rRegL tmp, rRegL tmp1, rRegL tmp2, kReg ktmp, rFlagsReg cr)\n+%{\n+  match(Set dst (IsInfiniteD src));\n+  match(Set dst (IsNaND src));\n+  match(Set dst (IsFiniteD src));\n+  effect(TEMP tmp, TEMP tmp1, TEMP tmp2, TEMP ktmp, KILL cr);\n+  format %{ \"double_class_check $dst, $src\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    if (VM_Version::supports_avx512dq()) {\n+      __ double_class_check_vfp(opcode, $dst$$Register, $src$$XMMRegister, $ktmp$$KRegister);\n+    }\n+    else {\n+      __ double_class_check(opcode, $src$$XMMRegister, $dst$$Register, $tmp$$Register,\n+                $tmp1$$Register,  $tmp2$$Register);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -206,0 +206,10 @@\n+  do_intrinsic(_floatIsInfinite,          java_lang_Float,        isInfinite_name,    float_bool_signature,      F_S)   \\\n+   do_name(     isInfinite_name,                                  \"isInfinite\")                                         \\\n+  do_intrinsic(_floatIsFinite,            java_lang_Float,        isFinite_name,      float_bool_signature,      F_S)   \\\n+   do_name(     isFinite_name,                                    \"isFinite\")                                           \\\n+  do_intrinsic(_floatIsNaN,               java_lang_Float,        isNaN_name,         float_bool_signature,      F_S)   \\\n+   do_name(     isNaN_name,                                       \"isNaN\")                                              \\\n+  do_intrinsic(_doubleIsInfinite,         java_lang_Double,       isInfinite_name,    double_bool_signature,     F_S)   \\\n+  do_intrinsic(_doubleIsFinite,           java_lang_Double,       isFinite_name,      double_bool_signature,     F_S)   \\\n+  do_intrinsic(_doubleIsNaN,              java_lang_Double,       isNaN_name,         double_bool_signature,     F_S)   \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -552,0 +552,2 @@\n+  template(float_bool_signature,                      \"(F)Z\")                                     \\\n+  template(double_bool_signature,                     \"(D)Z\")                                     \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -521,0 +521,18 @@\n+  case vmIntrinsics::_floatIsInfinite:\n+    if (!Matcher::match_rule_supported(Op_IsInfiniteF)) return false;\n+    break;\n+  case vmIntrinsics::_floatIsFinite:\n+    if (!Matcher::match_rule_supported(Op_IsFiniteF)) return false;\n+    break;\n+  case vmIntrinsics::_floatIsNaN:\n+    if (!Matcher::match_rule_supported(Op_IsNaNF)) return false;\n+    break;\n+  case vmIntrinsics::_doubleIsInfinite:\n+    if (!Matcher::match_rule_supported(Op_IsInfiniteD)) return false;\n+    break;\n+  case vmIntrinsics::_doubleIsFinite:\n+    if (!Matcher::match_rule_supported(Op_IsFiniteD)) return false;\n+    break;\n+  case vmIntrinsics::_doubleIsNaN:\n+    if (!Matcher::match_rule_supported(Op_IsNaND)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include \"opto\/fpclassnode.hpp\"\n","filename":"src\/hotspot\/share\/opto\/classes.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -250,0 +250,6 @@\n+macro(IsInfiniteF)\n+macro(IsFiniteF)\n+macro(IsNaNF)\n+macro(IsInfiniteD)\n+macro(IsFiniteD)\n+macro(IsNaND)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OPTO_FPCLASSNODE_HPP\n+#define SHARE_OPTO_FPCLASSNODE_HPP\n+\n+#include \"opto\/node.hpp\"\n+#include \"opto\/opcodes.hpp\"\n+\n+\n+\/\/---------- IsInfiniteFNode -----------------------------------------------------\n+class IsInfiniteFNode : public Node {\n+  public:\n+  IsInfiniteFNode(Node* in1) : Node(0, in1) {}\n+  virtual int   Opcode() const;\n+  const Type* bottom_type() const { return TypeInt::BOOL; }\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+};\n+\n+\/\/---------- IsFiniteFNode -----------------------------------------------------\n+class IsFiniteFNode : public Node {\n+  public:\n+  IsFiniteFNode(Node* in1) : Node(0, in1) {}\n+  virtual int   Opcode() const;\n+  const Type* bottom_type() const { return TypeInt::BOOL; }\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+};\n+\n+\/\/---------- IsNaNFNode -----------------------------------------------------\n+class IsNaNFNode : public Node {\n+  public:\n+  IsNaNFNode(Node* in1) : Node(0, in1) {}\n+  virtual int   Opcode() const;\n+  const Type* bottom_type() const { return TypeInt::BOOL; }\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+};\n+\n+\/\/---------- IsInfiniteDNode -----------------------------------------------------\n+class IsInfiniteDNode : public Node {\n+  public:\n+  IsInfiniteDNode(Node* in1) : Node(0, in1) {}\n+  virtual int   Opcode() const;\n+  const Type* bottom_type() const { return TypeInt::BOOL; }\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+};\n+\n+\/\/---------- IsFiniteDNode -----------------------------------------------------\n+class IsFiniteDNode : public Node {\n+  public:\n+  IsFiniteDNode(Node* in1) : Node(0, in1) {}\n+  virtual int   Opcode() const;\n+  const Type* bottom_type() const { return TypeInt::BOOL; }\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+};\n+\n+\/\/---------- IsNaNDNode -----------------------------------------------------\n+class IsNaNDNode : public Node {\n+  public:\n+  IsNaNDNode(Node* in1) : Node(0, in1) {}\n+  virtual int   Opcode() const;\n+  const Type* bottom_type() const { return TypeInt::BOOL; }\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+};\n+\n+#endif \/\/ SHARE_OPTO_FPCLASSNODE_HPP\n","filename":"src\/hotspot\/share\/opto\/fpclassnode.hpp","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"opto\/fpclassnode.hpp\"\n@@ -519,0 +520,7 @@\n+  case vmIntrinsics::_floatIsNaN:\n+  case vmIntrinsics::_floatIsFinite:\n+  case vmIntrinsics::_floatIsInfinite:\n+  case vmIntrinsics::_doubleIsNaN:\n+  case vmIntrinsics::_doubleIsFinite:\n+  case vmIntrinsics::_doubleIsInfinite:         return inline_fp_range_check(intrinsic_id());\n+\n@@ -4643,0 +4651,31 @@\n+bool LibraryCallKit::inline_fp_range_check(vmIntrinsics::ID id) {\n+  Node* arg = argument(0);\n+  Node* result = NULL;\n+\n+  switch (id) {\n+  case vmIntrinsics::_floatIsInfinite:\n+    result = new IsInfiniteFNode(arg);\n+    break;\n+  case vmIntrinsics::_floatIsFinite:\n+    result = new IsFiniteFNode(arg);\n+    break;\n+  case vmIntrinsics::_floatIsNaN:\n+    result = new IsNaNFNode(arg);\n+    break;\n+  case vmIntrinsics::_doubleIsInfinite:\n+    result = new IsInfiniteDNode(arg);\n+    break;\n+  case vmIntrinsics::_doubleIsFinite:\n+    result = new IsFiniteDNode(arg);\n+    break;\n+  case vmIntrinsics::_doubleIsNaN:\n+    result = new IsNaNDNode(arg);\n+    break;\n+  default:\n+    fatal_unexpected_iid(id);\n+    break;\n+  }\n+  set_result(_gvn.transform(result));\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -277,0 +277,1 @@\n+  bool inline_fp_range_check(vmIntrinsics::ID id);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+#include \"opto\/fpclassnode.hpp\"\n@@ -1855,0 +1856,1 @@\n+  declare_c2_type(IsInfiniteFNode, Node)                                  \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -674,0 +674,1 @@\n+    @IntrinsicCandidate\n@@ -686,0 +687,1 @@\n+    @IntrinsicCandidate\n@@ -700,0 +702,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -499,0 +499,1 @@\n+    @IntrinsicCandidate\n@@ -511,0 +512,1 @@\n+    @IntrinsicCandidate\n@@ -526,0 +528,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @summary Test x86_64 intrinsics for Double methods isNaN, isFinite, isInfinite.\n+* @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+* @library \/test\/lib \/\n+* @run driver compiler.intrinsics.TestDoubleClassCheck\n+*\/\n+\n+package compiler.intrinsics;\n+import compiler.lib.ir_framework.*;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGeneratorFactory;\n+\n+public class TestDoubleClassCheck {\n+    RandomGenerator rng;\n+    int BUFFER_SIZE = 1024;\n+    double[] inputs;\n+    boolean[] outputs;\n+\n+    public static void main(String args[]) {\n+        TestFramework.run(TestDoubleClassCheck.class);\n+    }\n+\n+    public TestDoubleClassCheck() {\n+        outputs = new boolean[BUFFER_SIZE];\n+        inputs = new double[BUFFER_SIZE];\n+        RandomGenerator rng = RandomGeneratorFactory.getDefault().create(0);\n+        double input;\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            if (i % 5 == 0) {\n+                input = (i%2 == 0) ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n+            }\n+            else if (i % 3 == 0) input = Double.NaN;\n+            else input = rng.nextDouble();\n+            inputs[i] = input;\n+        }\n+    }\n+\n+    @Test \/\/ needs to be run in (fast) debug mode\n+    @Warmup(10000)\n+    @IR(counts = {\"IsFiniteD\", \">= 1\"}) \/\/ Atleast one IsFiniteD node is generated if intrinsic is used\n+    public void testIsFinite() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            outputs[i] = Double.isFinite(inputs[i]);\n+        }\n+        checkResult(\"isFinite\");\n+    }\n+\n+    @Test \/\/ needs to be run in (fast) debug mode\n+    @Warmup(10000)\n+    @IR(counts = {\"IsInfiniteD\", \">= 1\"}) \/\/ Atleast one IsInfiniteD node is generated if intrinsic is used\n+    public void testIsInfinite() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            outputs[i] = Double.isInfinite(inputs[i]);\n+        }\n+        checkResult(\"isInfinite\");\n+    }\n+\n+    @Test \/\/ needs to be run in (fast) debug mode\n+    @Warmup(10000)\n+    @IR(counts = {\"IsNaND\", \">= 1\"}) \/\/ Atleast one IsNaND node is generated if intrinsic is used\n+    public void testIsNaN() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            outputs[i] = Double.isNaN(inputs[i]);\n+        }\n+        checkResult(\"isNaN\");\n+    }\n+\n+    public void checkResult(String method) {\n+        for (int i=0; i < BUFFER_SIZE; i++) {\n+            boolean expected = doubleClassCheck(inputs[i], method);\n+            if (expected != outputs[i]) {\n+                String errorMsg = \"Correctness check failed for Double.\" + method +\n+                \"() for input = \" + inputs[i];\n+                throw new RuntimeException(errorMsg);\n+            }\n+        }\n+    }\n+\n+    public boolean doubleClassCheck(double f, String method) {\n+        long infBits = Double.doubleToRawLongBits(Double.POSITIVE_INFINITY);\n+        long bits =  Double.doubleToRawLongBits(f);\n+        bits = bits & Long.MAX_VALUE;\n+        switch (method) {\n+            case \"isFinite\": return (bits < infBits);\n+            case \"isInfinite\": return (bits == infBits);\n+            case \"isNaN\": return (bits > infBits);\n+            default: throw new IllegalArgumentException(\"incorrect method for Double\");\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestDoubleClassCheck.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @summary Test x86_64 intrinsics for Float methods isNaN, isFinite, isInfinite.\n+* @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+* @library \/test\/lib \/\n+* @run driver compiler.intrinsics.TestFloatClassCheck\n+*\/\n+\n+package compiler.intrinsics;\n+import compiler.lib.ir_framework.*;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGeneratorFactory;\n+\n+public class TestFloatClassCheck {\n+    RandomGenerator rng;\n+    int BUFFER_SIZE = 1024;\n+    float[] inputs;\n+    boolean[] outputs;\n+\n+    public static void main(String args[]) {\n+        TestFramework.run(TestFloatClassCheck.class);\n+    }\n+\n+    public TestFloatClassCheck() {\n+        outputs = new boolean[BUFFER_SIZE];\n+        inputs = new float[BUFFER_SIZE];\n+        RandomGenerator rng = RandomGeneratorFactory.getDefault().create(0);\n+        float input;\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            if (i % 5 == 0) {\n+                input = (i%2 == 0) ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n+            }\n+            else if (i % 3 == 0) input = Float.NaN;\n+            else input = rng.nextFloat();\n+            inputs[i] = input;\n+        }\n+    }\n+\n+    @Test \/\/ needs to be run in (fast) debug mode\n+    @Warmup(10000)\n+    @IR(counts = {\"IsFiniteF\", \">= 1\"}) \/\/ Atleast one IsFiniteF node is generated if intrinsic is used\n+    public void testIsFinite() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            outputs[i] = Float.isFinite(inputs[i]);\n+        }\n+        checkResult(\"isFinite\");\n+    }\n+\n+    @Test \/\/ needs to be run in (fast) debug mode\n+    @Warmup(10000)\n+    @IR(counts = {\"IsInfiniteF\", \">= 1\"}) \/\/ Atleast one IsInfiniteF node is generated if intrinsic is used\n+    public void testIsInfinite() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            outputs[i] = Float.isInfinite(inputs[i]);\n+        }\n+        checkResult(\"isInfinite\");\n+    }\n+\n+    @Test \/\/ needs to be run in (fast) debug mode\n+    @Warmup(10000)\n+    @IR(counts = {\"IsNaNF\", \">= 1\"}) \/\/ Atleast one IsNaNF node is generated if intrinsic is used\n+    public void testIsNaN() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            outputs[i] = Float.isNaN(inputs[i]);\n+        }\n+        checkResult(\"isNaN\");\n+    }\n+\n+    public void checkResult(String method) {\n+        for (int i=0; i < BUFFER_SIZE; i++) {\n+            boolean expected = floatClassCheck(inputs[i], method);\n+            if (expected != outputs[i]) {\n+                String errorMsg = \"Correctness check failed for Float.\" + method +\n+                \"() for input = \" + inputs[i];\n+                throw new RuntimeException(errorMsg);\n+            }\n+        }\n+    }\n+\n+    public boolean floatClassCheck(float f, String method) {\n+        int infBits = Float.floatToRawIntBits(Float.POSITIVE_INFINITY);\n+        int bits =  Float.floatToRawIntBits(f);\n+        bits = bits & Integer.MAX_VALUE;\n+        switch (method) {\n+            case \"isFinite\": return (bits < infBits);\n+            case \"isInfinite\": return (bits == infBits);\n+            case \"isNaN\": return (bits > infBits);\n+            default: throw new IllegalArgumentException(\"incorrect method for Float\");\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestFloatClassCheck.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Param;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGeneratorFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Fork(1)\n+public class DoubleClassCheck {\n+\n+    RandomGenerator rng;\n+    static final int BUFFER_SIZE = 1024;\n+    double[] inputs;\n+    boolean[] outputs;\n+\n+    @Setup\n+    public void setup() {\n+        outputs = new boolean[BUFFER_SIZE];\n+        inputs = new double[BUFFER_SIZE];\n+        RandomGenerator rng = RandomGeneratorFactory.getDefault().create(0);\n+        double input;\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            if (i % 5 == 0) {\n+                input = (i%2 == 0) ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n+            }\n+            else if (i % 3 == 0) input = Double.NaN;\n+            else input = rng.nextDouble();\n+            inputs[i] = input;\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(BUFFER_SIZE)\n+    public void testIsFinite() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            outputs[i] = Double.isFinite(inputs[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(BUFFER_SIZE)\n+    public void testIsInfinite() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            outputs[i] = Double.isInfinite(inputs[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(BUFFER_SIZE)\n+    public void testIsNaN() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            outputs[i] = Double.isNaN(inputs[i]);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/DoubleClassCheck.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Param;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGeneratorFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Fork(1)\n+public class FloatClassCheck {\n+\n+    RandomGenerator rng;\n+    static final int BUFFER_SIZE = 1024;\n+    float[] inputs;\n+    boolean[] outputs;\n+\n+    @Setup\n+    public void setup() {\n+        outputs = new boolean[BUFFER_SIZE];\n+        inputs = new float[BUFFER_SIZE];\n+        RandomGenerator rng = RandomGeneratorFactory.getDefault().create(0);\n+        float input;\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            if (i % 5 == 0) {\n+                input = (i%2 == 0) ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n+            }\n+            else if (i % 3 == 0) input = Float.NaN;\n+            else input = rng.nextFloat();\n+            inputs[i] = input;\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(BUFFER_SIZE)\n+    public void testIsFinite() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            outputs[i] = Float.isFinite(inputs[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(BUFFER_SIZE)\n+    public void testIsInfinite() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            outputs[i] = Float.isInfinite(inputs[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(BUFFER_SIZE)\n+    public void testIsNaN() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            outputs[i] = Float.isNaN(inputs[i]);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/FloatClassCheck.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"}]}