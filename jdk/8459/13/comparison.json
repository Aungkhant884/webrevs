{"files":[{"patch":"@@ -10413,0 +10413,20 @@\n+void Assembler::vfpclassss(KRegister kdst, XMMRegister src, uint8_t imm8) {\n+  \/\/ Encoding: EVEX.LIG.66.0F3A.W0 67 \/r ib\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(VM_Version::supports_avx512dq(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(kdst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24((unsigned char)0x67, (unsigned char)(0xC0 | encode), imm8);\n+}\n+\n+void Assembler::vfpclasssd(KRegister kdst, XMMRegister src, uint8_t imm8) {\n+  \/\/ Encoding: EVEX.LIG.66.0F3A.W1 67 \/r ib\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(VM_Version::supports_avx512dq(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(kdst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24((unsigned char)0x67, (unsigned char)(0xC0 | encode), imm8);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2749,0 +2749,4 @@\n+  \/\/ floating point class tests\n+  void vfpclassss(KRegister kdst, XMMRegister src, uint8_t imm8);\n+  void vfpclasssd(KRegister kdst, XMMRegister src, uint8_t imm8);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5319,0 +5319,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1465,0 +1465,6 @@\n+    case Op_IsInfiniteF:\n+    case Op_IsInfiniteD:\n+      if (!VM_Version::supports_avx512dq()) {\n+        return false;\n+      }\n+      break;\n@@ -10139,0 +10145,26 @@\n+\n+instruct FloatClassCheck_reg_reg_vfpclass(rRegI dst, regF src, kReg ktmp, rFlagsReg cr)\n+%{\n+  match(Set dst (IsInfiniteF src));\n+  effect(TEMP ktmp, KILL cr);\n+  format %{ \"float_class_check $dst, $src\" %}\n+  ins_encode %{\n+    __ vfpclassss($ktmp$$KRegister, $src$$XMMRegister, 0x18);\n+    __ kmovbl($dst$$Register, $ktmp$$KRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct DoubleClassCheck_reg_reg_vfpclass(rRegI dst, regD src, kReg ktmp, rFlagsReg cr)\n+%{\n+  match(Set dst (IsInfiniteD src));\n+  effect(TEMP ktmp, KILL cr);\n+  format %{ \"double_class_check $dst, $src\" %}\n+  ins_encode %{\n+    __ vfpclasssd($ktmp$$KRegister, $src$$XMMRegister, 0x18);\n+    __ kmovbl($dst$$Register, $ktmp$$KRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -206,0 +206,4 @@\n+  do_intrinsic(_floatIsInfinite,          java_lang_Float,        isInfinite_name,    float_bool_signature,      F_S)   \\\n+   do_name(     isInfinite_name,                                  \"isInfinite\")                                         \\\n+  do_intrinsic(_doubleIsInfinite,         java_lang_Double,       isInfinite_name,    double_bool_signature,     F_S)   \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -557,0 +557,2 @@\n+  template(float_bool_signature,                      \"(F)Z\")                                     \\\n+  template(double_bool_signature,                     \"(D)Z\")                                     \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -521,0 +521,6 @@\n+  case vmIntrinsics::_floatIsInfinite:\n+    if (!Matcher::match_rule_supported(Op_IsInfiniteF)) return false;\n+    break;\n+  case vmIntrinsics::_doubleIsInfinite:\n+    if (!Matcher::match_rule_supported(Op_IsInfiniteD)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -248,0 +248,2 @@\n+macro(IsInfiniteF)\n+macro(IsInfiniteD)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -265,0 +265,18 @@\n+\/\/---------- IsInfiniteFNode -----------------------------------------------------\n+class IsInfiniteFNode : public Node {\n+  public:\n+  IsInfiniteFNode(Node* in1) : Node(0, in1) {}\n+  virtual int   Opcode() const;\n+  const Type* bottom_type() const { return TypeInt::BOOL; }\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+};\n+\n+\/\/---------- IsInfiniteDNode -----------------------------------------------------\n+class IsInfiniteDNode : public Node {\n+  public:\n+  IsInfiniteDNode(Node* in1) : Node(0, in1) {}\n+  virtual int   Opcode() const;\n+  const Type* bottom_type() const { return TypeInt::BOOL; }\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -519,0 +519,3 @@\n+  case vmIntrinsics::_floatIsInfinite:\n+  case vmIntrinsics::_doubleIsInfinite:         return inline_fp_range_check(intrinsic_id());\n+\n@@ -4645,0 +4648,19 @@\n+bool LibraryCallKit::inline_fp_range_check(vmIntrinsics::ID id) {\n+  Node* arg = argument(0);\n+  Node* result = NULL;\n+\n+  switch (id) {\n+  case vmIntrinsics::_floatIsInfinite:\n+    result = new IsInfiniteFNode(arg);\n+    break;\n+  case vmIntrinsics::_doubleIsInfinite:\n+    result = new IsInfiniteDNode(arg);\n+    break;\n+  default:\n+    fatal_unexpected_iid(id);\n+    break;\n+  }\n+  set_result(_gvn.transform(result));\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -277,0 +277,1 @@\n+  bool inline_fp_range_check(vmIntrinsics::ID id);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1850,0 +1850,2 @@\n+  declare_c2_type(IsInfiniteFNode, Node)                                  \\\n+  declare_c2_type(IsInfiniteDNode, Node)                                  \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -686,0 +686,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -511,0 +511,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @summary Test x86_64 intrinsics for Double methods isNaN, isFinite, isInfinite.\n+* @requires vm.cpu.features ~= \".*avx512dq.*\"\n+* @library \/test\/lib \/\n+* @run driver compiler.intrinsics.TestDoubleClassCheck\n+*\/\n+\n+package compiler.intrinsics;\n+import compiler.lib.ir_framework.*;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGeneratorFactory;\n+\n+public class TestDoubleClassCheck {\n+    RandomGenerator rng;\n+    int BUFFER_SIZE = 1024;\n+    double[] inputs;\n+    boolean[] outputs;\n+\n+    public static void main(String args[]) {\n+        TestFramework.run(TestDoubleClassCheck.class);\n+    }\n+\n+    public TestDoubleClassCheck() {\n+        outputs = new boolean[BUFFER_SIZE];\n+        inputs = new double[BUFFER_SIZE];\n+        RandomGenerator rng = RandomGeneratorFactory.getDefault().create(0);\n+        double input;\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            if (i % 5 == 0) {\n+                input = (i%2 == 0) ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n+            }\n+            else if (i % 3 == 0) input = Double.NaN;\n+            else input = rng.nextDouble();\n+            inputs[i] = input;\n+        }\n+    }\n+\n+    @Test \/\/ needs to be run in (fast) debug mode\n+    @Warmup(10000)\n+    @IR(counts = {\"IsInfiniteD\", \">= 1\"}) \/\/ Atleast one IsInfiniteD node is generated if intrinsic is used\n+    public void testIsInfinite() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            outputs[i] = Double.isInfinite(inputs[i]);\n+        }\n+        checkResult(\"isInfinite\");\n+    }\n+\n+\n+    public void checkResult(String method) {\n+        for (int i=0; i < BUFFER_SIZE; i++) {\n+            boolean expected = doubleClassCheck(inputs[i], method);\n+            if (expected != outputs[i]) {\n+                String errorMsg = \"Correctness check failed for Double.\" + method +\n+                \"() for input = \" + inputs[i];\n+                throw new RuntimeException(errorMsg);\n+            }\n+        }\n+    }\n+\n+    public boolean doubleClassCheck(double f, String method) {\n+        long infBits = Double.doubleToRawLongBits(Double.POSITIVE_INFINITY);\n+        long bits =  Double.doubleToRawLongBits(f);\n+        bits = bits & Long.MAX_VALUE;\n+        switch (method) {\n+            case \"isFinite\": return (bits < infBits);\n+            case \"isInfinite\": return (bits == infBits);\n+            case \"isNaN\": return (bits > infBits);\n+            default: throw new IllegalArgumentException(\"incorrect method for Double\");\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestDoubleClassCheck.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @summary Test x86_64 intrinsics for Float methods isNaN, isFinite, isInfinite.\n+* @requires vm.cpu.features ~= \".*avx512dq.*\"\n+* @library \/test\/lib \/\n+* @run driver compiler.intrinsics.TestFloatClassCheck\n+*\/\n+\n+package compiler.intrinsics;\n+import compiler.lib.ir_framework.*;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGeneratorFactory;\n+\n+public class TestFloatClassCheck {\n+    RandomGenerator rng;\n+    int BUFFER_SIZE = 1024;\n+    float[] inputs;\n+    boolean[] outputs;\n+\n+    public static void main(String args[]) {\n+        TestFramework.run(TestFloatClassCheck.class);\n+    }\n+\n+    public TestFloatClassCheck() {\n+        outputs = new boolean[BUFFER_SIZE];\n+        inputs = new float[BUFFER_SIZE];\n+        RandomGenerator rng = RandomGeneratorFactory.getDefault().create(0);\n+        float input;\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            if (i % 5 == 0) {\n+                input = (i%2 == 0) ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n+            }\n+            else if (i % 3 == 0) input = Float.NaN;\n+            else input = rng.nextFloat();\n+            inputs[i] = input;\n+        }\n+    }\n+\n+    @Test \/\/ needs to be run in (fast) debug mode\n+    @Warmup(10000)\n+    @IR(counts = {\"IsInfiniteF\", \">= 1\"}) \/\/ Atleast one IsInfiniteF node is generated if intrinsic is used\n+    public void testIsInfinite() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            outputs[i] = Float.isInfinite(inputs[i]);\n+        }\n+        checkResult(\"isInfinite\");\n+    }\n+\n+    public void checkResult(String method) {\n+        for (int i=0; i < BUFFER_SIZE; i++) {\n+            boolean expected = floatClassCheck(inputs[i], method);\n+            if (expected != outputs[i]) {\n+                String errorMsg = \"Correctness check failed for Float.\" + method +\n+                \"() for input = \" + inputs[i];\n+                throw new RuntimeException(errorMsg);\n+            }\n+        }\n+    }\n+\n+    public boolean floatClassCheck(float f, String method) {\n+        int infBits = Float.floatToRawIntBits(Float.POSITIVE_INFINITY);\n+        int bits =  Float.floatToRawIntBits(f);\n+        bits = bits & Integer.MAX_VALUE;\n+        switch (method) {\n+            case \"isFinite\": return (bits < infBits);\n+            case \"isInfinite\": return (bits == infBits);\n+            case \"isNaN\": return (bits > infBits);\n+            default: throw new IllegalArgumentException(\"incorrect method for Float\");\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestFloatClassCheck.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Param;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGeneratorFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Fork(1)\n+public class DoubleClassCheck {\n+\n+    RandomGenerator rng;\n+    static final int BUFFER_SIZE = 1024;\n+    double[] inputs;\n+    boolean[] storeOutputs;\n+    int[] cmovOutputs;\n+    int[] branchOutputs;\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    static int call() {\n+        return 1;\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        storeOutputs = new boolean[BUFFER_SIZE];\n+        cmovOutputs = new int[BUFFER_SIZE];\n+        branchOutputs = new int[BUFFER_SIZE];\n+        inputs = new double[BUFFER_SIZE];\n+        RandomGenerator rng = RandomGeneratorFactory.getDefault().create(0);\n+        double input;\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            if (i % 5 == 0) {\n+                input = (i%2 == 0) ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n+            }\n+            else if (i % 3 == 0) input = Double.NaN;\n+            else input = rng.nextDouble();\n+            inputs[i] = input;\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(BUFFER_SIZE)\n+    public void testIsInfiniteStore() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            storeOutputs[i] = Double.isInfinite(inputs[i]);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    @OperationsPerInvocation(BUFFER_SIZE)\n+    public void testIsInfiniteCMov() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            cmovOutputs[i] = Double.isInfinite(inputs[i]) ? 9 : 7;\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    @OperationsPerInvocation(BUFFER_SIZE)\n+    public void testIsInfiniteBranch() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            cmovOutputs[i] = Double.isInfinite(inputs[i]) ? call() : 7;\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/DoubleClassCheck.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Param;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGeneratorFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Fork(1)\n+public class FloatClassCheck {\n+\n+    RandomGenerator rng;\n+    static final int BUFFER_SIZE = 1024;\n+    float[] inputs;\n+    boolean[] storeOutputs;\n+    int[] cmovOutputs;\n+    int[] branchOutputs;\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    static int call() {\n+        return 1;\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        storeOutputs = new boolean[BUFFER_SIZE];\n+        cmovOutputs = new int[BUFFER_SIZE];\n+        branchOutputs = new int[BUFFER_SIZE];\n+        inputs = new float[BUFFER_SIZE];\n+        RandomGenerator rng = RandomGeneratorFactory.getDefault().create(0);\n+        float input;\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            if (i % 5 == 0) {\n+                input = (i % 2 == 0) ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n+            } else if (i % 3 == 0)\n+                input = Float.NaN;\n+            else\n+                input = rng.nextFloat();\n+            inputs[i] = input;\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    @OperationsPerInvocation(BUFFER_SIZE)\n+    public void testIsInfiniteStore() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            storeOutputs[i] = Float.isInfinite(inputs[i]);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    @OperationsPerInvocation(BUFFER_SIZE)\n+    public void testIsInfiniteCMov() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            cmovOutputs[i] = Float.isInfinite(inputs[i]) ? 9 : 7;\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    @OperationsPerInvocation(BUFFER_SIZE)\n+    public void testIsInfiniteBranch() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            cmovOutputs[i] = Float.isInfinite(inputs[i]) ? call() : 7;\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/FloatClassCheck.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"}]}