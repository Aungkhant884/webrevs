{"files":[{"patch":"@@ -9712,0 +9712,66 @@\n+void Assembler::evpternlogd(XMMRegister dst, int imm8, KRegister mask, XMMRegister src2, XMMRegister src3, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"requires EVEX support\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"requires VL support\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src3->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int8(0x25);\n+  emit_int8((unsigned char)(0xC0 | encode));\n+  emit_int8(imm8);\n+}\n+\n+void Assembler::evpternlogd(XMMRegister dst, int imm8, KRegister mask, XMMRegister src2, Address src3, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"requires EVEX support\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"requires VL support\");\n+  assert(dst != xnoreg, \"sanity\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_64bit);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src3, src2->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int8(0x25);\n+  emit_operand(dst, src3);\n+  emit_int8(imm8);\n+}\n+\n+void Assembler::evpternlogq(XMMRegister dst, int imm8, KRegister mask, XMMRegister src2, XMMRegister src3, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"requires EVEX support\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"requires VL support\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src3->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int8(0x25);\n+  emit_int8((unsigned char)(0xC0 | encode));\n+  emit_int8(imm8);\n+}\n+\n+void Assembler::evpternlogq(XMMRegister dst, int imm8, KRegister mask, XMMRegister src2, Address src3, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"requires EVEX support\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"requires VL support\");\n+  assert(dst != xnoreg, \"sanity\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_64bit);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src3, src2->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int8(0x25);\n+  emit_operand(dst, src3);\n+  emit_int8(imm8);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":66,"deletions":0,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2413,0 +2413,6 @@\n+  void evpternlogd(XMMRegister dst, int imm8, KRegister mask, XMMRegister src2, XMMRegister src3, bool merge, int vector_len);\n+  void evpternlogd(XMMRegister dst, int imm8, KRegister mask, XMMRegister src2, Address src3, bool merge, int vector_len);\n+  void evpternlogq(XMMRegister dst, int imm8, KRegister mask, XMMRegister src2, XMMRegister src3, bool merge, int vector_len);\n+  void evpternlogq(XMMRegister dst, int imm8, KRegister mask, XMMRegister src2, Address src3, bool merge, int vector_len);\n+\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4155,0 +4155,20 @@\n+void C2_MacroAssembler::evpternlog(XMMRegister dst, int func, KRegister mask, XMMRegister src2, XMMRegister src3,\n+                                   bool merge, BasicType bt, int vlen_enc) {\n+  if (bt == T_INT) {\n+    evpternlogd(dst, func, mask, src2, src3, true, vlen_enc);\n+  } else {\n+    assert(bt == T_LONG, \"\");\n+    evpternlogq(dst, func, mask, src2, src3, true, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::evpternlog(XMMRegister dst, int func, KRegister mask, XMMRegister src2, Address src3,\n+                                   bool merge, BasicType bt, int vlen_enc) {\n+  if (bt == T_INT) {\n+    evpternlogd(dst, func, mask, src2, src3, true, vlen_enc);\n+  } else {\n+    assert(bt == T_LONG, \"\");\n+    evpternlogq(dst, func, mask, src2, src3, true, vlen_enc);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -308,0 +308,7 @@\n+\n+  void evpternlog(XMMRegister dst, int func, KRegister mask, XMMRegister src2, XMMRegister src3,\n+                  bool merge, BasicType bt, int vlen_enc);\n+\n+  void evpternlog(XMMRegister dst, int func, KRegister mask, XMMRegister src2, Address src3,\n+                  bool merge, BasicType bt, int vlen_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1889,0 +1889,6 @@\n+    case Op_MacroLogicV:\n+      if(bt != T_INT && bt != T_LONG) {\n+        return false;\n+      }\n+      return true;\n+\n@@ -9603,0 +9609,23 @@\n+instruct vternlog_reg_masked(vec dst, vec src2, vec src3, immU8 func, kReg mask) %{\n+  match(Set dst (MacroLogicV dst (Binary src2 (Binary src3 (Binary func mask)))));\n+  format %{ \"vternlog_masked $dst,$src2,$src3,$func,$mask\\t! vternlog masked operation\" %}\n+  ins_encode %{\n+    int vector_len = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ evpternlog($dst$$XMMRegister, $func$$constant, $mask$$KRegister,\n+                  $src2$$XMMRegister, $src3$$XMMRegister, true, bt, vector_len);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vternlogd_mem_masked(vec dst, vec src2, memory src3, immU8 func, kReg mask) %{\n+  match(Set dst (MacroLogicV dst (Binary src2 (Binary src3 (Binary func mask)))));\n+  format %{ \"vternlog_masked $dst,$src2,$src3,$func,$mask\\t! vternlog masked operation\" %}\n+  ins_encode %{\n+    int vector_len = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ evpternlog($dst$$XMMRegister, $func$$constant, $mask$$KRegister,\n+                  $src2$$XMMRegister, $src3$$Address, true, bt, vector_len);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2378,1 +2378,0 @@\n-         n->req() == 2 &&\n@@ -2386,1 +2385,1 @@\n-      return n->req() == 2;\n+      return true;\n@@ -2418,1 +2417,1 @@\n-static uint collect_unique_inputs(Node* n, Unique_Node_List& partition, Unique_Node_List& inputs) {\n+static uint collect_unique_inputs(Node* n, Unique_Node_List& inputs) {\n@@ -2421,0 +2420,1 @@\n+    uint inp_cnt = n->is_predicated_vector() ? n->req()-1 : n->req();\n@@ -2422,1 +2422,1 @@\n-      for (uint i = 1; i < n->req(); i++) {\n+      for (uint i = 1; i < inp_cnt; i++) {\n@@ -2432,1 +2432,1 @@\n-      uint last_req = n->req();\n+      uint last_req = inp_cnt;\n@@ -2434,1 +2434,1 @@\n-        last_req = n->req() - 1; \/\/ skip last input\n+        last_req = inp_cnt - 1; \/\/ skip last input\n@@ -2444,1 +2444,0 @@\n-    partition.push(n);\n@@ -2479,1 +2478,4 @@\n-  return igvn.transform(MacroLogicVNode::make(igvn, in3, in2, in1, func, vt));\n+\n+  Node* pn = partition.at(partition.size() - 1);\n+  Node* mask = pn->is_predicated_vector() ? pn->in(pn->req()-1) : NULL;\n+  return igvn.transform(MacroLogicVNode::make(igvn, in1, in2, in3, mask, func, vt));\n@@ -2559,1 +2561,1 @@\n-  uint input_funcs[] = { 0xAA,   \/\/ (_, _, a) -> a\n+  uint input_funcs[] = { 0xAA,   \/\/ (_, _, c) -> c\n@@ -2561,1 +2563,1 @@\n-                         0xF0 }; \/\/ (c, _, _) -> c\n+                         0xF0 }; \/\/ (a, _, _) -> a\n@@ -2563,1 +2565,1 @@\n-    eval_map.put(inputs.at(i), input_funcs[i]);\n+    eval_map.put(inputs.at(i), input_funcs[2-i]);\n@@ -2606,0 +2608,8 @@\n+\/\/ Criteria under which nodes gets packed into a macro logic node:-\n+\/\/  1) Parent and both child nodes are all unmasked or masked with\n+\/\/     same predicates.\n+\/\/  2) Masked parent can be packed with left child if it is predicated\n+\/\/     and both have same predicates.\n+\/\/  3) Masked parent can be packed with right child if its un-predicated\n+\/\/     or has matching predication condition.\n+\/\/  4) An unmasked parent can be packed with an unmasked child.\n@@ -2615,1 +2625,1 @@\n-    assert(collect_unique_inputs(n, partition, inputs) == 1, \"not unary\");\n+    assert(collect_unique_inputs(n, inputs) == 1, \"not unary\");\n@@ -2619,3 +2629,8 @@\n-  assert(is_vector_binary_bitwise_op(n), \"not binary\");\n-  Node* in1 = n->in(1);\n-  Node* in2 = n->in(2);\n+  bool pack_left_child = true;\n+  bool pack_right_child = true;\n+\n+  bool left_child_LOP = is_vector_bitwise_op(n->in(1));\n+  bool right_child_LOP = is_vector_bitwise_op(n->in(2));\n+\n+  int left_child_input_cnt = 0;\n+  int right_child_input_cnt = 0;\n@@ -2623,3 +2638,3 @@\n-  int in1_unique_inputs_cnt = collect_unique_inputs(in1, partition, inputs);\n-  int in2_unique_inputs_cnt = collect_unique_inputs(in2, partition, inputs);\n-  partition.push(n);\n+  bool parent_is_predicated = n->is_predicated_vector();\n+  bool left_child_predicated = n->in(1)->is_predicated_vector();\n+  bool right_child_predicated = n->in(2)->is_predicated_vector();\n@@ -2627,7 +2642,14 @@\n-  \/\/ Too many inputs?\n-  if (inputs.size() > 3) {\n-    partition.clear();\n-    inputs.clear();\n-    { \/\/ Recompute in2 inputs\n-      Unique_Node_List not_used;\n-      in2_unique_inputs_cnt = collect_unique_inputs(in2, not_used, not_used);\n+  Node* parent_pred = parent_is_predicated ? n->in(n->req()-1) : NULL;\n+  Node* left_child_pred = left_child_predicated ? n->in(1)->in(n->in(1)->req()-1) : NULL;\n+  Node* right_child_pred = right_child_predicated ? n->in(1)->in(n->in(1)->req()-1) : NULL;\n+\n+  do {\n+    if (pack_left_child && left_child_LOP &&\n+        ((!parent_is_predicated && !left_child_predicated) ||\n+        ((parent_is_predicated && left_child_predicated &&\n+          parent_pred == left_child_pred)))) {\n+       partition.push(n->in(1));\n+       left_child_input_cnt = collect_unique_inputs(n->in(1), inputs);\n+    } else {\n+       inputs.push(n->in(1));\n+       left_child_input_cnt = 1;\n@@ -2635,3 +2657,10 @@\n-    \/\/ Pick the node with minimum number of inputs.\n-    if (in1_unique_inputs_cnt >= 3 && in2_unique_inputs_cnt >= 3) {\n-      return false; \/\/ still too many inputs\n+\n+    if (pack_right_child && right_child_LOP &&\n+        (!right_child_predicated ||\n+         (right_child_predicated && parent_is_predicated &&\n+          parent_pred == right_child_pred))) {\n+       partition.push(n->in(2));\n+       right_child_input_cnt = collect_unique_inputs(n->in(2), inputs);\n+    } else {\n+       inputs.push(n->in(2));\n+       right_child_input_cnt = 1;\n@@ -2639,3 +2668,0 @@\n-    \/\/ Recompute partition & inputs.\n-    Node* child       = (in1_unique_inputs_cnt < in2_unique_inputs_cnt ? in1 : in2);\n-    collect_unique_inputs(child, partition, inputs);\n@@ -2643,2 +2669,13 @@\n-    Node* other_input = (in1_unique_inputs_cnt < in2_unique_inputs_cnt ? in2 : in1);\n-    inputs.push(other_input);\n+    if (inputs.size() > 3) {\n+      assert(partition.size() > 0, \"\");\n+      inputs.clear();\n+      partition.clear();\n+      if (left_child_input_cnt > right_child_input_cnt) {\n+        pack_left_child = false;\n+      } else {\n+        pack_right_child = false;\n+      }\n+    } else {\n+      break;\n+    }\n+  } while(true);\n@@ -2646,0 +2683,1 @@\n+  if(partition.size()) {\n@@ -2653,1 +2691,0 @@\n-\n@@ -2673,2 +2710,13 @@\n-    Node* macro_logic = xform_to_MacroLogicV(igvn, vt, partition, inputs);\n-    igvn.replace_node(n, macro_logic);\n+    Node* pn = partition.at(partition.size() - 1);\n+    Node* mask = pn->is_predicated_vector() ? pn->in(pn->req()-1) : NULL;\n+    if (mask == NULL ||\n+        Matcher::match_rule_supported_vector_masked(Op_MacroLogicV, vt->length(), vt->element_basic_type())) {\n+      Node* macro_logic = xform_to_MacroLogicV(igvn, vt, partition, inputs);\n+#ifdef ASSERT\n+      if (TraceNewVectors) {\n+        tty->print(\"new Vector node: \");\n+        macro_logic->dump();\n+      }\n+#endif\n+      igvn.replace_node(n, macro_logic);\n+    }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":84,"deletions":36,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2323,0 +2323,8 @@\n+    } else if (n->req() == 6) {\n+      Node* b3 = new BinaryNode(n->in(4), n->in(5));\n+      Node* b2 = new BinaryNode(n->in(3), b3);\n+      Node* b1 = new BinaryNode(n->in(2), b2);\n+      n->set_req(2, b1);\n+      n->del_req(5);\n+      n->del_req(4);\n+      n->del_req(3);\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1204,1 +1204,1 @@\n-                                       uint truth_table, const TypeVect* vt) {\n+                                       Node* mask, uint truth_table, const TypeVect* vt) {\n@@ -1209,0 +1209,1 @@\n+  assert(!mask || mask->bottom_type()->isa_vectmask(), \"predicated register type expected\");\n@@ -1210,1 +1211,1 @@\n-  return new MacroLogicVNode(in1, in2, in3, fn, vt);\n+  return new MacroLogicVNode(in1, in2, in3, fn, mask, vt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1278,2 +1278,7 @@\n-  MacroLogicVNode(Node* in1, Node* in2, Node* in3, Node* fn, const TypeVect* vt)\n-  : VectorNode(in1, in2, in3, fn, vt) {}\n+  MacroLogicVNode(Node* in1, Node* in2, Node* in3, Node* fn, Node* mask, const TypeVect* vt)\n+  : VectorNode(in1, in2, in3, fn, vt) {\n+     if (mask) {\n+       this->add_req(mask);\n+       this->add_flag(Node::Flag_is_predicated_vector);\n+     }\n+  }\n@@ -1284,1 +1289,2 @@\n-  static MacroLogicVNode* make(PhaseGVN& igvn, Node* in1, Node* in2, Node* in3, uint truth_table, const TypeVect* vt);\n+  static MacroLogicVNode* make(PhaseGVN& igvn, Node* in1, Node* in2, Node* in3,\n+                               Node* mask, uint truth_table, const TypeVect* vt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,842 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8273322\n+ * @summary Enhance macro logic optimization for masked logic operations.\n+ * @modules jdk.incubator.vector\n+ * @requires vm.compiler2.enabled\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorapi.TestMaskedMacroLogicVector\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import java.util.concurrent.Callable;\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.driver.IRViolationException;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import java.util.Random;\n+\n+import jdk.incubator.vector.*;\n+\n+public class TestMaskedMacroLogicVector {\n+    boolean [] br;\n+    boolean [] ba;\n+    boolean [] bb;\n+\n+    short [] sr;\n+    char  [] ca;\n+    char  [] cb;\n+\n+    int [] r;\n+    int [] a;\n+    int [] b;\n+    int [] c;\n+    int [] d;\n+    int [] e;\n+    int [] f;\n+\n+    long [] rl;\n+    long [] al;\n+    long [] bl;\n+    long [] cl;\n+\n+    boolean [] mask;\n+\n+    static boolean booleanFunc1(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\" , \" > 0 \"})\n+    public void testSubWordBoolean(boolean[] r, boolean[] a, boolean[] b) {\n+        for (int i = 0; i < r.length; i++) {\n+            r[i] = booleanFunc1(a[i], b[i]);\n+        }\n+    }\n+    public void verifySubWordBoolean(boolean[] r, boolean[] a, boolean[] b) {\n+        for (int i = 0; i < r.length; i++) {\n+            boolean expected = booleanFunc1(a[i], b[i]);\n+            if (r[i] != expected) {\n+                throw new AssertionError(\n+                        String.format(\"at #%d: r=%b, expected = %b = booleanFunc1(%b,%b)\",\n+                                      i, r[i], expected, a[i], b[i]));\n+            }\n+        }\n+    }\n+\n+\n+    static short charFunc1(char a, char b) {\n+        return (short)((a & b) & 1);\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\" , \" > 0 \"})\n+    public void testSubWordChar(short[] r, char[] a, char[] b) {\n+        for (int i = 0; i < r.length; i++) {\n+            r[i] = charFunc1(a[i], b[i]);\n+        }\n+    }\n+    public void verifySubWordChar(short[] r, char[] a, char[] b) {\n+        for (int i = 0; i < r.length; i++) {\n+            short expected = charFunc1(a[i], b[i]);\n+            if (r[i] != expected) {\n+                throw new AssertionError(\n+                        String.format(\"testSubWordChar: at #%d: r=%d, expected = %d = booleanFunc1(%d,%d)\",\n+                                      i, r[i], expected, (int)a[i], (int)b[i]));\n+            }\n+        }\n+    }\n+\n+    \/\/ Case 1): Unmasked expression tree.\n+    \/\/        P_LOP\n+    \/\/   L_LOP     R_LOP\n+\n+    static int intFunc1(int a, int b, int c) {\n+        return (a & b) ^ (a & c);\n+    }\n+\n+    @ForceInline\n+    public void testInt1Kernel(VectorSpecies SPECIES, int [] r, int [] a, int [] b, int [] c) {\n+        for (int i = 0; i < SPECIES.loopBound(r.length); i += SPECIES.length()) {\n+            IntVector va = IntVector.fromArray(SPECIES, a, i);\n+            IntVector vb = IntVector.fromArray(SPECIES, b, i);\n+            IntVector vc = IntVector.fromArray(SPECIES, c, i);\n+            va.lanewise(VectorOperators.AND, vc)\n+            .lanewise(VectorOperators.XOR, va.lanewise(VectorOperators.AND, vb))\n+            .intoArray(r, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    public void testInt1_Int128(int[] r, int[] a, int[] b, int[] c) {\n+        testInt1Kernel(IntVector.SPECIES_128, r, a, b, c);\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    public void testInt1_Int256(int[] r, int[] a, int[] b, int[] c) {\n+        testInt1Kernel(IntVector.SPECIES_256, r, a, b, c);\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    public void testInt1_Int512(int[] r, int[] a, int[] b, int[] c) {\n+        testInt1Kernel(IntVector.SPECIES_512, r, a, b, c);\n+    }\n+\n+    public void verifyInt1(int[] r, int[] a, int[] b, int[] c) {\n+        for (int i = 0; i < r.length; i++) {\n+            int expected = intFunc1(a[i], b[i], c[i]);\n+            if (r[i] != expected) {\n+                throw new AssertionError(String.format(\"testInt1: at #%d: r=%d, expected = %d = intFunc1(%d,%d,%d)\",\n+                                                       i, r[i], expected, a[i], b[i], c[i]));\n+            }\n+        }\n+    }\n+\n+    \/\/ Case 2): Only right child is masked.\n+    \/\/        P_LOP\n+    \/\/   L_LOP    R_LOP(mask)\n+\n+    static int intFunc2(int a, int b, int c, boolean mask) {\n+        return (a & b) ^ (mask == true ? a & c : a);\n+    }\n+\n+    @ForceInline\n+    public void testInt2Kernel(VectorSpecies SPECIES, int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < SPECIES.loopBound(r.length); i += SPECIES.length()) {\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask , i);\n+            IntVector va = IntVector.fromArray(SPECIES, a, i);\n+            IntVector vb = IntVector.fromArray(SPECIES, b, i);\n+            IntVector vc = IntVector.fromArray(SPECIES, c, i);\n+            va.lanewise(VectorOperators.AND, vb)\n+            .lanewise(VectorOperators.XOR,\n+                      va.lanewise(VectorOperators.AND, vc, vmask))\n+           .intoArray(r, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    public void testInt2_Int128(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        testInt2Kernel(IntVector.SPECIES_128, r, a, b, c, mask);\n+    }\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    public void testInt2_Int256(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        testInt2Kernel(IntVector.SPECIES_256, r, a, b, c, mask);\n+    }\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    public void testInt2_Int512(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        testInt2Kernel(IntVector.SPECIES_512, r, a, b, c, mask);\n+    }\n+\n+    public void verifyInt2(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < r.length; i++) {\n+            int expected = intFunc2(a[i], b[i], c[i], mask[i]);\n+            if (r[i] != expected) {\n+                throw new AssertionError(String.format(\"testInt2: at #%d: r=%d, expected = %d = intFunc2(%d,%d,%d,%b)\",\n+                                                       i, r[i], expected, a[i], b[i], c[i], mask[i]));\n+            }\n+        }\n+    }\n+\n+    \/\/ Case 3): Only left child is masked.\n+    \/\/             P_LOP\n+    \/\/   L_LOP(mask)    R_LOP\n+\n+    static int intFunc3(int a, int b, int c, boolean mask) {\n+        return (mask == true ? a & b : a) ^ (a & c);\n+    }\n+\n+    @ForceInline\n+    public void testInt3Kernel(VectorSpecies SPECIES, int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < SPECIES.loopBound(r.length); i += SPECIES.length()) {\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask , i);\n+            IntVector va = IntVector.fromArray(SPECIES, a, i);\n+            IntVector vb = IntVector.fromArray(SPECIES, b, i);\n+            IntVector vc = IntVector.fromArray(SPECIES, c, i);\n+            va.lanewise(VectorOperators.AND, vb, vmask)\n+            .lanewise(VectorOperators.XOR,\n+                      va.lanewise(VectorOperators.AND, vc))\n+           .intoArray(r, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    public void testInt3_Int128(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        testInt3Kernel(IntVector.SPECIES_128, r, a, b, c, mask);\n+    }\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    public void testInt3_Int256(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        testInt3Kernel(IntVector.SPECIES_256, r, a, b, c, mask);\n+    }\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    public void testInt3_Int512(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        testInt3Kernel(IntVector.SPECIES_512, r, a, b, c, mask);\n+    }\n+\n+\n+    @ForceInline\n+    public void verifyInt3(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < r.length; i++) {\n+            int expected = intFunc3(a[i], b[i], c[i], mask[i]);\n+            if (r[i] != expected) {\n+                throw new AssertionError(String.format(\"testInt3: at #%d: r=%d, expected = %d = intFunc3(%d,%d,%d,%b)\",\n+                                                       i, r[i], expected, a[i], b[i], c[i], mask[i]));\n+            }\n+        }\n+    }\n+\n+    \/\/ Case 4): Both child nodes are masked.\n+    \/\/             P_LOP\n+    \/\/   L_LOP(mask)    R_LOP(mask)\n+\n+    static int intFunc4(int a, int b, int c, boolean mask) {\n+        return (mask == true ? b & a : b) ^ (mask == true ? c & a : c);\n+    }\n+\n+    @ForceInline\n+    public void testInt4Kernel(VectorSpecies SPECIES, int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < SPECIES.loopBound(r.length); i += SPECIES.length()) {\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask , i);\n+            IntVector va = IntVector.fromArray(SPECIES, a, i);\n+            IntVector vb = IntVector.fromArray(SPECIES, b, i);\n+            IntVector vc = IntVector.fromArray(SPECIES, c, i);\n+            vb.lanewise(VectorOperators.AND, va, vmask)\n+            .lanewise(VectorOperators.XOR,\n+                      vc.lanewise(VectorOperators.AND, va, vmask))\n+           .intoArray(r, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"AndV\", \" > 0 \", \"XorV\", \" > 0 \"})\n+    public void testInt4_Int128(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        testInt4Kernel(IntVector.SPECIES_128, r, a, b, c, mask);\n+    }\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"AndV\", \" > 0 \", \"XorV\", \" > 0 \"})\n+    public void testInt4_Int256(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        testInt4Kernel(IntVector.SPECIES_256, r, a, b, c, mask);\n+    }\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"AndV\", \" > 0 \", \"XorV\", \" > 0 \"})\n+    public void testInt4_Int512(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        testInt4Kernel(IntVector.SPECIES_512, r, a, b, c, mask);\n+    }\n+\n+    public void verifyInt4(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < r.length; i++) {\n+            int expected = intFunc4(a[i], b[i], c[i], mask[i]);\n+            if (r[i] != expected) {\n+                throw new AssertionError(String.format(\"testInt4: at #%d: r=%d, expected = %d = intFunc4(%d,%d,%d,%b)\",\n+                                                       i, r[i], expected, a[i], b[i], c[i], mask[i]));\n+            }\n+        }\n+    }\n+\n+    \/\/ Case 5): Parent is masked with unmasked child expressions.\n+    \/\/        P_LOP(mask)\n+    \/\/   L_LOP     R_LOP\n+\n+    static int intFunc5(int a, int b, int c, boolean mask) {\n+        return mask == true ? ((a & b) ^ (a & c)) : (a & b);\n+    }\n+\n+    @ForceInline\n+    public void testInt5Kernel(VectorSpecies SPECIES, int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < SPECIES.loopBound(r.length); i += SPECIES.length()) {\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask , i);\n+            IntVector va = IntVector.fromArray(SPECIES, a, i);\n+            IntVector vb = IntVector.fromArray(SPECIES, b, i);\n+            IntVector vc = IntVector.fromArray(SPECIES, c, i);\n+            va.lanewise(VectorOperators.AND, vb)\n+            .lanewise(VectorOperators.XOR,\n+                      va.lanewise(VectorOperators.AND, vc), vmask)\n+           .intoArray(r, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    public void testInt5_Int128(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        testInt5Kernel(IntVector.SPECIES_128, r, a, b, c, mask);\n+    }\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    public void testInt5_Int256(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        testInt5Kernel(IntVector.SPECIES_256, r, a, b, c, mask);\n+    }\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    public void testInt5_Int512(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        testInt5Kernel(IntVector.SPECIES_512, r, a, b, c, mask);\n+    }\n+\n+    @ForceInline\n+    public void verifyInt5(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < r.length; i++) {\n+            int expected = intFunc5(a[i], b[i], c[i], mask[i]);\n+            if (r[i] != expected) {\n+                throw new AssertionError(String.format(\"testInt5: at #%d: r=%d, expected = %d = intFunc5(%d,%d,%d,%b)\",\n+                                                       i, r[i], expected, a[i], b[i], c[i], mask[i]));\n+            }\n+        }\n+    }\n+\n+    \/\/ Case 6): Parent and right child are masked.\n+    \/\/        P_LOP(mask)\n+    \/\/   L_LOP     R_LOP(mask)\n+\n+    static int intFunc6(int a, int b, int c, boolean mask) {\n+        return mask == true ? ((a & b) ^ (mask == true ? a & c : a)) : (a & b);\n+    }\n+\n+    @ForceInline\n+    public void testInt6Kernel(VectorSpecies SPECIES, int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < SPECIES.loopBound(r.length); i += SPECIES.length()) {\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask , i);\n+            IntVector va = IntVector.fromArray(SPECIES, a, i);\n+            IntVector vb = IntVector.fromArray(SPECIES, b, i);\n+            IntVector vc = IntVector.fromArray(SPECIES, c, i);\n+            va.lanewise(VectorOperators.AND, vb)\n+            .lanewise(VectorOperators.XOR,\n+                      va.lanewise(VectorOperators.AND, vc, vmask), vmask)\n+           .intoArray(r, i);\n+        }\n+    }\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    public void testInt6_Int128(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        testInt6Kernel(IntVector.SPECIES_128, r, a, b, c, mask);\n+    }\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    public void testInt6_Int256(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        testInt6Kernel(IntVector.SPECIES_256, r, a, b, c, mask);\n+    }\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    public void testInt6_Int512(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        testInt6Kernel(IntVector.SPECIES_512, r, a, b, c, mask);\n+    }\n+\n+\n+    public void verifyInt6(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < r.length; i++) {\n+            int expected = intFunc6(a[i], b[i], c[i], mask[i]);\n+            if (r[i] != expected) {\n+                throw new AssertionError(String.format(\"testInt6: at #%d: r=%d, expected = %d = intFunc6(%d,%d,%d,%b)\",\n+                                                       i, r[i], expected, a[i], b[i], c[i], mask[i]));\n+            }\n+        }\n+    }\n+\n+    \/\/ Case 7): Parent and left child are masked.\n+    \/\/            P_LOP(mask)\n+    \/\/   L_LOP(mask)       R_LOP\n+\n+    static int intFunc7(int a, int b, int c, boolean mask) {\n+        return mask == true ? ((mask == true ? a & b : a) ^ (a & c)) : a;\n+    }\n+\n+    @ForceInline\n+    public void testInt7Kernel(VectorSpecies SPECIES, int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < SPECIES.loopBound(r.length); i += SPECIES.length()) {\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask , i);\n+            IntVector va = IntVector.fromArray(SPECIES, a, i);\n+            IntVector vb = IntVector.fromArray(SPECIES, b, i);\n+            IntVector vc = IntVector.fromArray(SPECIES, c, i);\n+            va.lanewise(VectorOperators.AND, vb, vmask)\n+            .lanewise(VectorOperators.XOR,\n+                      va.lanewise(VectorOperators.AND, vc), vmask)\n+           .intoArray(r, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    public void testInt7_Int128(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        testInt7Kernel(IntVector.SPECIES_128, r, a, b, c, mask);\n+    }\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    public void testInt7_Int256(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        testInt7Kernel(IntVector.SPECIES_256, r, a, b, c, mask);\n+    }\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    public void testInt7_Int512(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        testInt7Kernel(IntVector.SPECIES_512, r, a, b, c, mask);\n+    }\n+\n+    public void verifyInt7(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < r.length; i++) {\n+            int expected = intFunc7(a[i], b[i], c[i], mask[i]);\n+            if (r[i] != expected) {\n+                throw new AssertionError(String.format(\"testInt7: at #%d: r=%d, expected = %d = intFunc7(%d,%d,%d,%b)\",\n+                                                       i, r[i], expected, a[i], b[i], c[i], mask[i]));\n+            }\n+        }\n+    }\n+\n+    \/\/ Case 8): Parent and both child expressions are masked.\n+    \/\/            P_LOP(mask)\n+    \/\/   L_LOP(mask)       R_LOP (mask)\n+\n+    static int intFunc8(int a, int b, int c, boolean mask) {\n+        return mask == true ? ((mask == true ? b & a : b) ^ (mask == true ? c & a  : c)) : b;\n+    }\n+\n+    @ForceInline\n+    public void testInt8Kernel(VectorSpecies SPECIES, int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < SPECIES.loopBound(r.length); i += SPECIES.length()) {\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask , i);\n+            IntVector va = IntVector.fromArray(SPECIES, a, i);\n+            IntVector vb = IntVector.fromArray(SPECIES, b, i);\n+            IntVector vc = IntVector.fromArray(SPECIES, c, i);\n+            vb.lanewise(VectorOperators.AND, va, vmask)\n+            .lanewise(VectorOperators.XOR,\n+                      vc.lanewise(VectorOperators.AND, va, vmask), vmask)\n+           .intoArray(r, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    public void testInt8_Int128(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        testInt8Kernel(IntVector.SPECIES_128, r, a, b, c, mask);\n+    }\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    public void testInt8_Int256(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        testInt8Kernel(IntVector.SPECIES_256, r, a, b, c, mask);\n+    }\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    public void testInt8_Int512(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        testInt8Kernel(IntVector.SPECIES_512, r, a, b, c, mask);\n+    }\n+\n+    public void verifyInt8(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < r.length; i++) {\n+            int expected = intFunc8(a[i], b[i], c[i], mask[i]);\n+            if (r[i] != expected) {\n+                throw new AssertionError(String.format(\"testInt8: at #%d: r=%d, expected = %d = intFunc8(%d,%d,%d,%b)\",\n+                                                       i, r[i], expected, a[i], b[i], c[i], mask[i]));\n+            }\n+        }\n+    }\n+\n+\n+    \/\/ ===================================================== \/\/\n+\n+    static long longFunc(long a, long b, long c) {\n+        long v1 = (a & b) ^ (a & c) ^ (b & c);\n+        long v2 = (~a & b) | (~b & c) | (~c & a);\n+        return v1 & v2;\n+    }\n+\n+    @ForceInline\n+    public void testLongKernel(VectorSpecies SPECIES, long[] r, long[] a, long[] b, long[] c) {\n+        for (int i = 0; i < SPECIES.loopBound(r.length); i  +=  SPECIES.length()) {\n+            LongVector va = LongVector.fromArray(SPECIES, a, i);\n+            LongVector vb = LongVector.fromArray(SPECIES, b, i);\n+            LongVector vc = LongVector.fromArray(SPECIES, c, i);\n+\n+            va.lanewise(VectorOperators.AND, vb)\n+            .lanewise(VectorOperators.XOR, va.lanewise(VectorOperators.AND, vc))\n+            .lanewise(VectorOperators.XOR, vb.lanewise(VectorOperators.AND, vc))\n+            .lanewise(VectorOperators.AND,\n+                       va.lanewise(VectorOperators.NOT).lanewise(VectorOperators.AND, vb)\n+                      .lanewise(VectorOperators.OR, vb.lanewise(VectorOperators.NOT).lanewise(VectorOperators.AND, vc))\n+                      .lanewise(VectorOperators.OR, vc.lanewise(VectorOperators.NOT).lanewise(VectorOperators.AND, va)))\n+            .intoArray(r, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    public void testLong_Long256(long[] r, long[] a, long[] b, long[] c) {\n+        testLongKernel(LongVector.SPECIES_256, r, a, b, c);\n+    }\n+    @Test\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    public void testLong_Long512(long[] r, long[] a, long[] b, long[] c) {\n+        testLongKernel(LongVector.SPECIES_512, r, a, b, c);\n+    }\n+\n+    public void verifyLong(long[] r, long[] a, long[] b, long[] c) {\n+        for (int i = 0; i < r.length; i++) {\n+            long expected = longFunc(a[i], b[i], c[i]);\n+            if (r[i] != expected) {\n+                throw new AssertionError(\n+                        String.format(\"testLong: at #%d: r=%d, expected = %d = longFunc(%d,%d,%d)\",\n+                                      i, r[i], expected, a[i], b[i], c[i]));\n+            }\n+        }\n+    }\n+\n+    \/\/ ===================================================== \/\/\n+\n+    private static final Random R = Utils.getRandomInstance();\n+\n+    static boolean[] fillBooleanRandom(Callable<boolean[]> factory) {\n+        try {\n+            boolean[] arr = factory.call();\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = R.nextBoolean();\n+            }\n+            return arr;\n+        } catch (Exception e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+    static char[] fillCharRandom(Callable<char[]> factory) {\n+        try {\n+            char[] arr = factory.call();\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = (char)R.nextInt();\n+            }\n+            return arr;\n+        } catch (Exception e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+    static int[] fillIntRandom(Callable<int[]> factory) {\n+        try {\n+            int[] arr = factory.call();\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = R.nextInt();\n+            }\n+            return arr;\n+        } catch (Exception e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+    static long[] fillLongRandom(Callable<long[]> factory) {\n+        try {\n+            long[] arr = factory.call();\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = R.nextLong();\n+            }\n+            return arr;\n+        } catch (Exception e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    \/\/ ===================================================== \/\/\n+\n+    static final int SIZE = 512;\n+\n+    @Run(test = {\"testInt4_Int128\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testInt4_Int128() {\n+        for (int i = 0; i < 10000; i++) {\n+            testInt4_Int128(r, a, b, c, mask);\n+            verifyInt4(r, a, b, c, mask);\n+        }\n+    }\n+    @Run(test = {\"testInt4_Int256\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testInt4_Int256() {\n+        for (int i = 0; i < 10000; i++) {\n+            testInt4_Int256(r, a, b, c, mask);\n+            verifyInt4(r, a, b, c, mask);\n+        }\n+    }\n+    @Run(test = {\"testInt4_Int512\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testInt4_Int512() {\n+        for (int i = 0; i < 10000; i++) {\n+            testInt4_Int512(r, a, b, c, mask);\n+            verifyInt4(r, a, b, c, mask);\n+        }\n+    }\n+\n+    @Run(test = {\"testSubWordBoolean\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_SubWordBoolean() {\n+        for (int i = 0; i < 10000; i++) {\n+            testSubWordBoolean(br, ba, bb);\n+            verifySubWordBoolean(br, ba, bb);\n+        }\n+    }\n+\n+    @Run(test = {\"testSubWordChar\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_SubWordChar() {\n+        for (int i = 0; i < 10000; i++) {\n+            testSubWordChar(sr, ca, cb);\n+            verifySubWordChar(sr, ca, cb);\n+        }\n+    }\n+\n+    @Run(test = {\"testInt1_Int128\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testInt1_Int128() {\n+        for (int i = 0; i < 10000; i++) {\n+            testInt1_Int128(r, a, b, c);\n+            verifyInt1(r, a, b, c);\n+        }\n+    }\n+    @Run(test = {\"testInt1_Int256\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testInt1_Int256() {\n+        for (int i = 0; i < 10000; i++) {\n+            testInt1_Int256(r, a, b, c);\n+            verifyInt1(r, a, b, c);\n+        }\n+    }\n+    @Run(test = {\"testInt1_Int512\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testInt1_Int512() {\n+        for (int i = 0; i < 10000; i++) {\n+            testInt1_Int512(r, a, b, c);\n+            verifyInt1(r, a, b, c);\n+        }\n+    }\n+\n+    @Run(test = {\"testInt2_Int128\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testInt2_Int128() {\n+        for (int i = 0; i < 10000; i++) {\n+            testInt2_Int128(r, a, b, c, mask);\n+            verifyInt2(r, a, b, c, mask);\n+        }\n+    }\n+    @Run(test = {\"testInt2_Int256\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testInt2_Int256() {\n+        for (int i = 0; i < 10000; i++) {\n+            testInt2_Int256(r, a, b, c, mask);\n+            verifyInt2(r, a, b, c, mask);\n+        }\n+    }\n+    @Run(test = {\"testInt2_Int512\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testInt2_Int512() {\n+        for (int i = 0; i < 10000; i++) {\n+            testInt2_Int512(r, a, b, c, mask);\n+            verifyInt2(r, a, b, c, mask);\n+        }\n+    }\n+\n+    @Run(test = {\"testInt3_Int128\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testInt3_Int128() {\n+        for (int i = 0; i < 10000; i++) {\n+            testInt3_Int128(r, a, b, c, mask);\n+            verifyInt3(r, a, b, c, mask);\n+        }\n+    }\n+    @Run(test = {\"testInt3_Int256\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testInt3_Int256() {\n+        for (int i = 0; i < 10000; i++) {\n+            testInt3_Int256(r, a, b, c, mask);\n+            verifyInt3(r, a, b, c, mask);\n+        }\n+    }\n+    @Run(test = {\"testInt3_Int512\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testInt3_Int512() {\n+        for (int i = 0; i < 10000; i++) {\n+            testInt3_Int512(r, a, b, c, mask);\n+            verifyInt3(r, a, b, c, mask);\n+        }\n+    }\n+\n+    @Run(test = {\"testInt5_Int128\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testInt5_128() {\n+        for (int i = 0; i < 10000; i++) {\n+            testInt5_Int128(r, a, b, c, mask);\n+            verifyInt5(r, a, b, c, mask);\n+        }\n+    }\n+    @Run(test = {\"testInt5_Int256\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testInt5_256() {\n+        for (int i = 0; i < 10000; i++) {\n+            testInt5_Int256(r, a, b, c, mask);\n+            verifyInt5(r, a, b, c, mask);\n+        }\n+    }\n+    @Run(test = {\"testInt5_Int512\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testInt5_Int512() {\n+        for (int i = 0; i < 10000; i++) {\n+            testInt5_Int512(r, a, b, c, mask);\n+            verifyInt5(r, a, b, c, mask);\n+        }\n+    }\n+\n+    @Run(test = {\"testInt6_Int128\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testInt6_Int128() {\n+        for (int i = 0; i < 10000; i++) {\n+            testInt6_Int128(r, a, b, c, mask);\n+            verifyInt6(r, a, b, c, mask);\n+        }\n+    }\n+    @Run(test = {\"testInt6_Int256\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testInt6_Int256() {\n+        for (int i = 0; i < 10000; i++) {\n+            testInt6_Int256(r, a, b, c, mask);\n+            verifyInt6(r, a, b, c, mask);\n+        }\n+    }\n+    @Run(test = {\"testInt6_Int512\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testInt6_Int512() {\n+        for (int i = 0; i < 10000; i++) {\n+            testInt6_Int512(r, a, b, c, mask);\n+            verifyInt6(r, a, b, c, mask);\n+        }\n+    }\n+\n+    @Run(test = {\"testInt7_Int128\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testInt7_Int128() {\n+        for (int i = 0; i < 10000; i++) {\n+            testInt7_Int128(r, a, b, c, mask);\n+            verifyInt7(r, a, b, c, mask);\n+        }\n+    }\n+    @Run(test = {\"testInt7_Int256\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testInt7_Int256() {\n+        for (int i = 0; i < 10000; i++) {\n+            testInt7_Int256(r, a, b, c, mask);\n+            verifyInt7(r, a, b, c, mask);\n+        }\n+    }\n+    @Run(test = {\"testInt7_Int512\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testInt7_Int512() {\n+        for (int i = 0; i < 10000; i++) {\n+            testInt7_Int512(r, a, b, c, mask);\n+            verifyInt7(r, a, b, c, mask);\n+        }\n+    }\n+\n+    @Run(test = {\"testInt8_Int128\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testInt8_Int128() {\n+        for (int i = 0; i < 10000; i++) {\n+            testInt8_Int128(r, a, b, c, mask);\n+            verifyInt8(r, a, b, c, mask);\n+        }\n+    }\n+    @Run(test = {\"testInt8_Int256\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testInt8_Int256() {\n+        for (int i = 0; i < 10000; i++) {\n+            testInt8_Int256(r, a, b, c, mask);\n+            verifyInt8(r, a, b, c, mask);\n+        }\n+    }\n+    @Run(test = {\"testInt8_Int512\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testInt8_Int512() {\n+        for (int i = 0; i < 10000; i++) {\n+            testInt8_Int512(r, a, b, c, mask);\n+            verifyInt8(r, a, b, c, mask);\n+        }\n+    }\n+\n+    @Run(test = {\"testLong_Long256\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testLong_Long256() {\n+        for (int i = 0; i < 10000; i++) {\n+            testLong_Long256(rl, al, bl, cl);\n+            verifyLong(rl, al, bl, cl);\n+        }\n+    }\n+    @Run(test = {\"testLong_Long512\"}, mode = RunMode.STANDALONE)\n+    public void kernel_testLong_Long512() {\n+        for (int i = 0; i < 10000; i++) {\n+            testLong_Long512(rl, al, bl, cl);\n+            verifyLong(rl, al, bl, cl);\n+        }\n+    }\n+\n+    public TestMaskedMacroLogicVector() {\n+        br = new boolean[SIZE];\n+        ba = fillBooleanRandom((()-> new boolean[SIZE]));\n+        bb = fillBooleanRandom((()-> new boolean[SIZE]));\n+\n+        sr = new short[SIZE];\n+        ca = fillCharRandom((()-> new char[SIZE]));\n+        cb = fillCharRandom((()-> new char[SIZE]));\n+\n+        r = new int[SIZE];\n+        a = fillIntRandom(()-> new int[SIZE]);\n+        b = fillIntRandom(()-> new int[SIZE]);\n+        c = fillIntRandom(()-> new int[SIZE]);\n+        d = fillIntRandom(()-> new int[SIZE]);\n+        e = fillIntRandom(()-> new int[SIZE]);\n+        f = fillIntRandom(()-> new int[SIZE]);\n+\n+        rl = new long[SIZE];\n+        al = fillLongRandom(() -> new long[SIZE]);\n+        bl = fillLongRandom(() -> new long[SIZE]);\n+        cl = fillLongRandom(() -> new long[SIZE]);\n+\n+        mask = fillBooleanRandom((()-> new boolean[SIZE]));\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:-TieredCompilation\",\n+                                   \"-XX:UseAVX=3\",\n+                                   \"--add-modules=jdk.incubator.vector\",\n+                                   \"-XX:CompileThresholdScaling=0.3\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestMaskedMacroLogicVector.java","additions":842,"deletions":0,"binary":false,"changes":842,"status":"added"},{"patch":"@@ -0,0 +1,331 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import jdk.incubator.vector.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class MaskedLogicOpts {\n+    @Param({\"256\",\"512\",\"1024\"})\n+    private int ARRAYLEN;\n+\n+    boolean [] mask_arr = {\n+        false, false, false, true, false, false, false, false,\n+        false, false, false, true, false, false, false, false,\n+        false, false, false, true, false, false, false, false,\n+        true, true, true, true, true, true, true, true,\n+        true, true, true, true, true, true, true, true,\n+        false, false, false, true, false, false, false, false,\n+        false, false, false, true, false, false, false, false,\n+        false, false, false, true, false, false, false, false\n+    };\n+\n+    int INVOC_COUNTER = 4096;\n+\n+    int [] i1 = new int[ARRAYLEN];\n+    int [] i2 = new int[ARRAYLEN];\n+    int [] i3 = new int[ARRAYLEN];\n+    int [] i4 = new int[ARRAYLEN];\n+    int [] i5 = new int[ARRAYLEN];\n+\n+    long [] l1 = new long[ARRAYLEN];\n+    long [] l2 = new long[ARRAYLEN];\n+    long [] l3 = new long[ARRAYLEN];\n+    long [] l4 = new long[ARRAYLEN];\n+    long [] l5 = new long[ARRAYLEN];\n+\n+    Vector<Integer> iv1;\n+    Vector<Integer> iv2;\n+    Vector<Integer> iv3;\n+    Vector<Integer> iv4;\n+    Vector<Integer> iv5;\n+\n+    Vector<Long> lv1;\n+    Vector<Long> lv2;\n+    Vector<Long> lv3;\n+    Vector<Long> lv4;\n+    Vector<Long> lv5;\n+\n+    VectorMask<Integer> imask;\n+    VectorMask<Long> lmask;\n+\n+    VectorSpecies<Integer> ispecies;\n+    VectorSpecies<Long> lspecies;\n+\n+    int int512_arr_idx;\n+    int int256_arr_idx;\n+    int int128_arr_idx;\n+    int long256_arr_idx;\n+    int long512_arr_idx;\n+\n+    private Random r = new Random();\n+\n+    @Setup(Level.Trial)\n+    public void init() {\n+        int512_arr_idx = 0;\n+        int256_arr_idx = 0;\n+        int128_arr_idx = 0;\n+        long256_arr_idx = 0;\n+        long512_arr_idx = 0;\n+        i1 = new int[ARRAYLEN];\n+        i2 = new int[ARRAYLEN];\n+        i3 = new int[ARRAYLEN];\n+        i4 = new int[ARRAYLEN];\n+        i5 = new int[ARRAYLEN];\n+\n+        l1 = new long[ARRAYLEN];\n+        l2 = new long[ARRAYLEN];\n+        l3 = new long[ARRAYLEN];\n+        l4 = new long[ARRAYLEN];\n+        l5 = new long[ARRAYLEN];\n+\n+        for (int i=0; i<ARRAYLEN; i++) {\n+            i1[i] = r.nextInt();\n+            i2[i] = r.nextInt();\n+            i3[i] = r.nextInt();\n+            i4[i] = r.nextInt();\n+            i5[i] = r.nextInt();\n+\n+            l1[i] = r.nextLong();\n+            l2[i] = r.nextLong();\n+            l3[i] = r.nextLong();\n+            l4[i] = r.nextLong();\n+            l5[i] = r.nextLong();\n+        }\n+\n+    }\n+\n+    @Setup(Level.Invocation)\n+    public void init_per_invoc() {\n+        int512_arr_idx = (int512_arr_idx + 16) & (ARRAYLEN-1);\n+        int256_arr_idx = (int256_arr_idx + 8) & (ARRAYLEN-1);\n+        int128_arr_idx = (int128_arr_idx + 4) & (ARRAYLEN-1);\n+        long512_arr_idx = (long512_arr_idx + 8) & (ARRAYLEN-1);\n+        long256_arr_idx = (long256_arr_idx + 4) & (ARRAYLEN-1);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public void maskedLogicKernel(VectorSpecies<Integer> SPECIES) {\n+        imask = VectorMask.fromArray(SPECIES, mask_arr, 0);\n+        iv2 = IntVector.fromArray(SPECIES, i2, int512_arr_idx);\n+        iv3 = IntVector.fromArray(SPECIES, i3, int512_arr_idx);\n+        iv4 = IntVector.fromArray(SPECIES, i4, int512_arr_idx);\n+        iv5 = IntVector.fromArray(SPECIES, i5, int512_arr_idx);\n+        for(int i = 0; i < INVOC_COUNTER; i++) {\n+            for(int j = 0 ; j < ARRAYLEN; j+= SPECIES.length()) {\n+                IntVector.fromArray(SPECIES, i1, j)\n+                    .lanewise(VectorOperators.AND, iv2, imask)\n+                    .lanewise(VectorOperators.OR,  iv2, imask)\n+                    .lanewise(VectorOperators.AND, iv3, imask)\n+                    .lanewise(VectorOperators.OR,  iv3, imask)\n+                    .lanewise(VectorOperators.AND, iv4, imask)\n+                    .lanewise(VectorOperators.OR,  iv4, imask)\n+                    .lanewise(VectorOperators.AND, iv5, imask)\n+                    .lanewise(VectorOperators.XOR, iv5, imask)\n+                    .intoArray(i1, j);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void maskedLogicOperationsInt512() {\n+       maskedLogicKernel(IntVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public void maskedLogicOperationsInt256() {\n+       maskedLogicKernel(IntVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public void maskedLogicOperationsInt128() {\n+       maskedLogicKernel(IntVector.SPECIES_128);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public void partiallyMaskedLogicOperationsIntKernel(VectorSpecies<Integer> SPECIES) {\n+       imask = VectorMask.fromArray(SPECIES, mask_arr, 0);\n+       iv2 = IntVector.fromArray(SPECIES, i2, int512_arr_idx);\n+       iv3 = IntVector.fromArray(SPECIES, i3, int512_arr_idx);\n+       iv4 = IntVector.fromArray(SPECIES, i4, int512_arr_idx);\n+       iv5 = IntVector.fromArray(SPECIES, i5, int512_arr_idx);\n+       for(int i = 0; i < INVOC_COUNTER; i++) {\n+           for(int j = 0 ; j < ARRAYLEN; j+= SPECIES.length()) {\n+               IntVector.fromArray(SPECIES, i1, j)\n+                   .lanewise(VectorOperators.AND, iv2, imask)\n+                   .lanewise(VectorOperators.OR,  iv2, imask)\n+                   .lanewise(VectorOperators.AND, iv3)\n+                   .lanewise(VectorOperators.OR,  iv3)\n+                   .lanewise(VectorOperators.OR,  iv4, imask)\n+                   .lanewise(VectorOperators.AND, iv4, imask)\n+                   .lanewise(VectorOperators.XOR, iv5, imask)\n+                   .intoArray(i1, j);\n+           }\n+       }\n+    }\n+\n+    @Benchmark\n+    public void partiallyMaskedLogicOperationsInt512() {\n+        partiallyMaskedLogicOperationsIntKernel(IntVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public void partiallyMaskedLogicOperationsInt256() {\n+        partiallyMaskedLogicOperationsIntKernel(IntVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public void partiallyMaskedLogicOperationsInt128() {\n+        partiallyMaskedLogicOperationsIntKernel(IntVector.SPECIES_128);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public void bitwiseBlendOperationIntKernel(VectorSpecies<Integer> SPECIES) {\n+       imask = VectorMask.fromArray(SPECIES, mask_arr, 0);\n+       iv2 = IntVector.fromArray(SPECIES, i2, int512_arr_idx);\n+       iv3 = IntVector.fromArray(SPECIES, i3, int512_arr_idx);\n+       iv4 = IntVector.fromArray(SPECIES, i4, int512_arr_idx);\n+       iv5 = IntVector.fromArray(SPECIES, i5, int512_arr_idx);\n+       for(int i = 0; i < INVOC_COUNTER; i++) {\n+           for(int j = 0 ; j < ARRAYLEN; j+= SPECIES.length()) {\n+               IntVector.fromArray(SPECIES, i1, j)\n+                   .lanewise(VectorOperators.BITWISE_BLEND, iv2, iv3, imask)\n+                   .lanewise(VectorOperators.BITWISE_BLEND, iv3, iv4, imask)\n+                   .lanewise(VectorOperators.BITWISE_BLEND, iv4, iv5, imask)\n+                   .intoArray(i1, j);\n+           }\n+       }\n+    }\n+\n+    @Benchmark\n+    public void bitwiseBlendOperationInt512() {\n+       bitwiseBlendOperationIntKernel(IntVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public void bitwiseBlendOperationInt256() {\n+       bitwiseBlendOperationIntKernel(IntVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public void bitwiseBlendOperationInt128() {\n+       bitwiseBlendOperationIntKernel(IntVector.SPECIES_128);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public void maskedLogicOperationsLongKernel(VectorSpecies<Long> SPECIES) {\n+       lmask = VectorMask.fromArray(SPECIES, mask_arr, 0);\n+       lv2 = LongVector.fromArray(SPECIES, l2, long256_arr_idx);\n+       lv3 = LongVector.fromArray(SPECIES, l3, long256_arr_idx);\n+       lv4 = LongVector.fromArray(SPECIES, l4, long256_arr_idx);\n+       lv5 = LongVector.fromArray(SPECIES, l5, long256_arr_idx);\n+       for(int i = 0; i < INVOC_COUNTER; i++) {\n+           for(int j = 0 ; j < ARRAYLEN; j+= SPECIES.length()) {\n+               LongVector.fromArray(SPECIES, l1, j)\n+                   .lanewise(VectorOperators.AND, lv2, lmask)\n+                   .lanewise(VectorOperators.OR,  lv3, lmask)\n+                   .lanewise(VectorOperators.AND, lv3, lmask)\n+                   .lanewise(VectorOperators.OR,  lv4, lmask)\n+                   .lanewise(VectorOperators.AND, lv4, lmask)\n+                   .lanewise(VectorOperators.XOR, lv5, lmask)\n+                   .intoArray(l1, j);\n+           }\n+       }\n+    }\n+\n+    @Benchmark\n+    public void maskedLogicOperationsLong512() {\n+       maskedLogicOperationsLongKernel(LongVector.SPECIES_512);\n+    }\n+    @Benchmark\n+    public void maskedLogicOperationsLong256() {\n+       maskedLogicOperationsLongKernel(LongVector.SPECIES_256);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public void partiallyMaskedLogicOperationsLongKernel(VectorSpecies<Long> SPECIES) {\n+       lmask = VectorMask.fromArray(SPECIES, mask_arr, 0);\n+       lv2 = LongVector.fromArray(SPECIES, l2, long512_arr_idx);\n+       lv3 = LongVector.fromArray(SPECIES, l3, long512_arr_idx);\n+       lv4 = LongVector.fromArray(SPECIES, l4, long512_arr_idx);\n+       lv5 = LongVector.fromArray(SPECIES, l5, long512_arr_idx);\n+       for(int i = 0; i < INVOC_COUNTER; i++) {\n+           for(int j = 0 ; j < ARRAYLEN; j+= SPECIES.length()) {\n+               LongVector.fromArray(SPECIES, l1, j)\n+                   .lanewise(VectorOperators.AND, lv2, lmask)\n+                   .lanewise(VectorOperators.OR,  lv2, lmask)\n+                   .lanewise(VectorOperators.AND, lv3)\n+                   .lanewise(VectorOperators.OR,  lv3)\n+                   .lanewise(VectorOperators.AND, lv4)\n+                   .lanewise(VectorOperators.OR,  lv4, lmask)\n+                   .lanewise(VectorOperators.XOR, lv5, lmask)\n+                   .intoArray(l1, j);\n+           }\n+       }\n+    }\n+\n+    @Benchmark\n+    public void partiallyMaskedLogicOperationsLong512() {\n+       partiallyMaskedLogicOperationsLongKernel(LongVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public void partiallyMaskedLogicOperationsLong256() {\n+       partiallyMaskedLogicOperationsLongKernel(LongVector.SPECIES_256);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public void bitwiseBlendOperationLongKernel(VectorSpecies<Long> SPECIES) {\n+       lmask = VectorMask.fromArray(SPECIES, mask_arr, 0);\n+       lv2 = LongVector.fromArray(SPECIES, l2, long512_arr_idx);\n+       lv3 = LongVector.fromArray(SPECIES, l3, long512_arr_idx);\n+       lv4 = LongVector.fromArray(SPECIES, l4, long512_arr_idx);\n+       lv5 = LongVector.fromArray(SPECIES, l5, long512_arr_idx);\n+       for(int i = 0; i < INVOC_COUNTER; i++) {\n+           for(int j = 0 ; j < ARRAYLEN; j+= SPECIES.length()) {\n+               LongVector.fromArray(SPECIES, l1, j)\n+                   .lanewise(VectorOperators.BITWISE_BLEND, lv2, lv3, lmask)\n+                   .lanewise(VectorOperators.BITWISE_BLEND, lv3, lv4, lmask)\n+                   .lanewise(VectorOperators.BITWISE_BLEND, lv4, lv5, lmask)\n+                   .intoArray(l1, j);\n+           }\n+       }\n+    }\n+\n+    @Benchmark\n+    public void bitwiseBlendOperationLong512() {\n+       bitwiseBlendOperationLongKernel(LongVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public void bitwiseBlendOperationLong256() {\n+       bitwiseBlendOperationLongKernel(LongVector.SPECIES_256);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MaskedLogicOpts.java","additions":331,"deletions":0,"binary":false,"changes":331,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-  @Param({\"64\",\"128\",\"256\",\"512\",\"1024\",\"2048\",\"4096\"}) private int VECLEN;\n+  @Param({\"64\",\"128\",\"256\",\"512\",\"1024\"}) private int VECLEN;\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/MacroLogicOpt.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}