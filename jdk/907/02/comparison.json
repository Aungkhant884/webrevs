{"files":[{"patch":"@@ -343,0 +343,3 @@\n+    SETBC_OPCODE  = (31u << OPCODE_SHIFT | 384u << 1),\n+    SETNBC_OPCODE = (31u << OPCODE_SHIFT | 448u << 1),\n+\n@@ -1680,0 +1683,6 @@\n+  \/\/ >= Power10\n+  inline void setbc( Register d, int biint);\n+  inline void setbc( Register d, ConditionRegister cr, Condition cc);\n+  inline void setnbc(Register d, int biint);\n+  inline void setnbc(Register d, ConditionRegister cr, Condition cc);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -384,0 +384,11 @@\n+inline void Assembler::setbc(Register d, int biint)\n+                                                  { emit_int32(SETBC_OPCODE | rt(d) | bi(biint)); }\n+inline void Assembler::setbc(Register d, ConditionRegister cr, Condition cc) {\n+    setbc(d, bi0(cr, cc));\n+}\n+inline void Assembler::setnbc(Register d, int biint)\n+                                                  { emit_int32(SETNBC_OPCODE | rt(d) | bi(biint)); }\n+inline void Assembler::setnbc(Register d, ConditionRegister cr, Condition cc) {\n+    setnbc(d, bi0(cr, cc));\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -11421,4 +11421,5 @@\n-instruct cmovI_conIvalueMinus1_conIvalue1(iRegIdst dst, flagsRegSrc crx) %{\n-  \/\/ no match-rule, false predicate\n-  effect(DEF dst, USE crx);\n-  predicate(false);\n+\/\/ Manifest a CmpL3 result in an integer register.\n+instruct cmpL3_reg_reg_Ex(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{\n+  match(Set dst (CmpL3 src1 src2));\n+  ins_cost(DEFAULT_COST*5);\n+  size(20);\n@@ -11426,1 +11427,1 @@\n-  ins_variable_size_depending_on_alignment(true);\n+  format %{ \"cmpL3_reg_reg_Ex $dst, $src1, $src2\" %}\n@@ -11428,3 +11429,0 @@\n-  format %{ \"cmovI   $crx, $dst, -1, 0, +1\" %}\n-  \/\/ Worst case is branch + move + branch + move + stop, no stop without scheduler.\n-  size(16);\n@@ -11432,72 +11430,12 @@\n-    Label done;\n-    \/\/ li(Rdst, 0);              \/\/ equal -> 0\n-    __ beq($crx$$CondRegister, done);\n-    __ li($dst$$Register, 1);    \/\/ greater -> +1\n-    __ bgt($crx$$CondRegister, done);\n-    __ li($dst$$Register, -1);   \/\/ unordered or less -> -1\n-    __ bind(done);\n-  %}\n-  ins_pipe(pipe_class_compare);\n-%}\n-\n-instruct cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(iRegIdst dst, flagsRegSrc crx) %{\n-  \/\/ no match-rule, false predicate\n-  effect(DEF dst, USE crx);\n-  predicate(false);\n-\n-  format %{ \"CmovI    $crx, $dst, -1, 0, +1 \\t\/\/ postalloc expanded\" %}\n-  postalloc_expand %{\n-    \/\/\n-    \/\/ replaces\n-    \/\/\n-    \/\/   region  crx\n-    \/\/    \\       |\n-    \/\/     dst=cmovI_conIvalueMinus1_conIvalue0_conIvalue1\n-    \/\/\n-    \/\/ with\n-    \/\/\n-    \/\/   region\n-    \/\/    \\\n-    \/\/     dst=loadConI16(0)\n-    \/\/      |\n-    \/\/      ^  region  crx\n-    \/\/      |   \\       |\n-    \/\/      dst=cmovI_conIvalueMinus1_conIvalue1\n-    \/\/\n-\n-    \/\/ Create new nodes.\n-    MachNode *m1 = new loadConI16Node();\n-    MachNode *m2 = new cmovI_conIvalueMinus1_conIvalue1Node();\n-\n-    \/\/ inputs for new nodes\n-    m1->add_req(n_region);\n-    m2->add_req(n_region, n_crx);\n-    m2->add_prec(m1);\n-\n-    \/\/ operands for new nodes\n-    m1->_opnds[0] = op_dst;\n-    m1->_opnds[1] = new immI16Oper(0);\n-    m2->_opnds[0] = op_dst;\n-    m2->_opnds[1] = op_crx;\n-\n-    \/\/ registers for new nodes\n-    ra_->set_pair(m1->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this)); \/\/ dst\n-    ra_->set_pair(m2->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this)); \/\/ dst\n-\n-    \/\/ Insert new nodes.\n-    nodes->push(m1);\n-    nodes->push(m2);\n-  %}\n-%}\n-\n-\/\/ Manifest a CmpL3 result in an integer register. Very painful.\n-\/\/ This is the test to avoid.\n-\/\/ (src1 < src2) ? -1 : ((src1 > src2) ? 1 : 0)\n-instruct cmpL3_reg_reg_ExEx(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{\n-  match(Set dst (CmpL3 src1 src2));\n-  ins_cost(DEFAULT_COST*5+BRANCH_COST);\n-\n-  expand %{\n-    flagsReg tmp1;\n-    cmpL_reg_reg(tmp1, src1, src2);\n-    cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);\n+    __ cmpd(CCR0, $src1$$Register, $src2$$Register);\n+    \/\/ P10, prefer using setbc intructions\n+    if (VM_Version::has_brw()) {\n+      __ setbc(R0, CCR0, Assembler::greater);\n+      __ setnbc($dst$$Register, CCR0, Assembler::less);\n+    }\n+    else {\n+      __ mfcr(R0); \/\/ set bit 32..33 as follows: <: 0b10, =: 0b00, >: 0b01\n+      __ srwi($dst$$Register, R0, 30);\n+      __ srawi(R0, R0, 31);\n+    }\n+    __ orr($dst$$Register, $dst$$Register, R0);\n@@ -11505,0 +11443,1 @@\n+  ins_pipe(pipe_class_default);\n@@ -11827,1 +11766,1 @@\n-instruct cmpF3_reg_reg_ExEx(iRegIdst dst, regF src1, regF src2) %{\n+instruct cmpF3_reg_reg_Ex(iRegIdst dst, regF src1, regF src2) %{\n@@ -11829,1 +11768,2 @@\n-  ins_cost(DEFAULT_COST*5+BRANCH_COST);\n+  ins_cost(DEFAULT_COST*5);\n+  size(20);\n@@ -11831,4 +11771,15 @@\n-  expand %{\n-    flagsReg tmp1;\n-    cmpFUnordered_reg_reg(tmp1, src1, src2);\n-    cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);\n+  format %{ \"cmpF3_reg_reg_Ex $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ fcmpu(CCR0, $src1$$FloatRegister, $src2$$FloatRegister);\n+    \/\/ P10, prefer using setbc intructions\n+    if (VM_Version::has_brw()) {\n+      __ setbc(R0, CCR0, Assembler::greater);\n+      __ setnbc($dst$$Register, CCR0, Assembler::less);\n+    }\n+    else {\n+      __ mfcr(R0); \/\/ set bit 32..33 as follows: <: 0b10, =: 0b00, >: 0b01\n+      __ srwi($dst$$Register, R0, 30);\n+      __ srawi(R0, R0, 31);\n+    }\n+    __ orr($dst$$Register, $dst$$Register, R0);\n@@ -11836,0 +11787,1 @@\n+  ins_pipe(pipe_class_default);\n@@ -11907,1 +11859,1 @@\n-instruct cmpD3_reg_reg_ExEx(iRegIdst dst, regD src1, regD src2) %{\n+instruct cmpD3_reg_reg_Ex(iRegIdst dst, regD src1, regD src2) %{\n@@ -11909,1 +11861,2 @@\n-  ins_cost(DEFAULT_COST*5+BRANCH_COST);\n+  ins_cost(DEFAULT_COST*5);\n+  size(20);\n@@ -11911,4 +11864,15 @@\n-  expand %{\n-    flagsReg tmp1;\n-    cmpDUnordered_reg_reg(tmp1, src1, src2);\n-    cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);\n+  format %{ \"cmpD3_reg_reg_Ex $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ fcmpu(CCR0, $src1$$FloatRegister, $src2$$FloatRegister);\n+    \/\/ P10, prefer using setbc intructions\n+    if (VM_Version::has_brw()) {\n+      __ setbc(R0, CCR0, Assembler::greater);\n+      __ setnbc($dst$$Register, CCR0, Assembler::less);\n+    }\n+    else {\n+      __ mfcr(R0); \/\/ set bit 32..33 as follows: <: 0b10, =: 0b00, >: 0b01\n+      __ srwi($dst$$Register, R0, 30);\n+      __ srawi(R0, R0, 31);\n+    }\n+    __ orr($dst$$Register, $dst$$Register, R0);\n@@ -11916,0 +11880,1 @@\n+  ins_pipe(pipe_class_default);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":57,"deletions":92,"binary":false,"changes":149,"status":"modified"}]}