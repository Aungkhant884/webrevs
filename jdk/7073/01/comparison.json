{"files":[{"patch":"@@ -45,0 +45,3 @@\n+import jdk.jfr.internal.LogLevel;\n+import jdk.jfr.internal.LogTag;\n+import jdk.jfr.internal.Logger;\n@@ -49,0 +52,1 @@\n+import jdk.jfr.internal.SecuritySupport;\n@@ -367,1 +371,1 @@\n-                                 trace from where the potential leaking object wasallocated.\n+                                 trace from where the potential leaking object was allocated.\n@@ -397,1 +401,1 @@\n-\n+               %s\n@@ -417,1 +421,22 @@\n-               \"\"\".formatted(exampleDirectory()).lines().toArray(String[]::new);\n+               \"\"\".formatted(jfcOptions(), exampleDirectory()).lines().toArray(String[]::new);\n+    }\n+\n+    private static String jfcOptions() {\n+        try {\n+            StringBuilder sb = new StringBuilder();\n+            for (SafePath s : SecuritySupport.getPredefinedJFCFiles()) {\n+                String name = JFC.nameFromPath(s.toPath());\n+                JFCModel model = new JFCModel(s, l -> {});\n+                sb.append('\\n');\n+                sb.append(\"Options for \").append(name).append(\":\\n\");\n+                sb.append('\\n');\n+                for (XmlInput input : model.getInputs()) {\n+                    sb.append(\"  \").append(input.getOptionSyntax()).append('\\n');\n+                    sb.append('\\n');\n+                }\n+            }\n+            return sb.toString();\n+        } catch (IOException | ParseException e) {\n+            Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG, \"Could not list .jfc options for JFR.start. \" + e.getMessage());\n+            return \"\";\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdStart.java","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"}]}