{"files":[{"patch":"@@ -145,2 +145,4 @@\n-  assert(!G1ThreadLocalData::satb_mark_queue(thread).is_active(), \"SATB queue should not be active\");\n-  assert(G1ThreadLocalData::satb_mark_queue(thread).is_empty(), \"SATB queue should be empty\");\n+  SATBMarkQueue& queue = G1ThreadLocalData::satb_mark_queue(thread);\n+  assert(!queue.is_active(), \"SATB queue should not be active\");\n+  assert(queue.buffer() == nullptr, \"SATB queue should not have a buffer\");\n+  assert(queue.index() == 0, \"SATB queue index should be zero\");\n@@ -154,2 +156,1 @@\n-  bool is_satb_active = _satb_mark_queue_set.is_active();\n-  G1ThreadLocalData::satb_mark_queue(thread).set_active(is_satb_active);\n+  queue.set_active(_satb_mark_queue_set.is_active());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1740,1 +1740,1 @@\n-  G1CMSATBBufferClosure _cm_satb_cl;\n+  G1SATBMarkQueueSet& _qset;\n@@ -1747,1 +1747,1 @@\n-    _cm_satb_cl(task, g1h),\n+    _qset(G1BarrierSet::satb_mark_queue_set()),\n@@ -1754,2 +1754,2 @@\n-      SATBMarkQueue& queue = G1ThreadLocalData::satb_mark_queue(thread);\n-      queue.apply_closure_and_empty(&_cm_satb_cl);\n+      \/\/ Transfer any partial buffer to the qset for completed buffer processing.\n+      _qset.flush_queue(G1ThreadLocalData::satb_mark_queue(thread));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -625,0 +625,2 @@\n+    G1DirtyCardQueueSet& _qset;\n+    AbandonThreadLogClosure(G1DirtyCardQueueSet& qset) : _qset(qset) {}\n@@ -626,3 +628,3 @@\n-      G1DirtyCardQueue& dcq = G1ThreadLocalData::dirty_card_queue(t);\n-      dcq.reset();\n-      dcq.refinement_stats()->reset();\n+      G1DirtyCardQueue& queue = G1ThreadLocalData::dirty_card_queue(t);\n+      _qset.reset_queue(queue);\n+      queue.refinement_stats()->reset();\n@@ -630,1 +632,1 @@\n-  } closure;\n+  } closure(*this);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -202,0 +202,6 @@\n+void PtrQueueSet::reset_queue(PtrQueue& queue) {\n+  if (queue.buffer() != nullptr) {\n+    queue.set_index(buffer_size());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/ptrQueue.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-  \/\/ capacity_in_bytes (indicating an empty buffer) and goes towards zero.\n+  \/\/ capacity (in bytes) (indicating an empty buffer) and goes towards zero.\n@@ -94,10 +94,0 @@\n-  size_t index_in_bytes() const {\n-    return _index;\n-  }\n-\n-  void set_index_in_bytes(size_t new_index) {\n-    assert(is_aligned(new_index, _element_size), \"precondition\");\n-    assert(new_index <= capacity_in_bytes(), \"precondition\");\n-    _index = new_index;\n-  }\n-\n@@ -105,1 +95,1 @@\n-    return byte_index_to_index(index_in_bytes());\n+    return byte_index_to_index(_index);\n@@ -109,1 +99,2 @@\n-    set_index_in_bytes(index_to_byte_index(new_index));\n+    assert(new_index <= capacity(), \"precondition\");\n+    _index = index_to_byte_index(new_index);\n@@ -116,21 +107,0 @@\n-  \/\/ Forcibly set empty.\n-  void reset() {\n-    if (_buf != NULL) {\n-      _index = capacity_in_bytes();\n-    }\n-  }\n-\n-  \/\/ Return the size of the in-use region.\n-  size_t size() const {\n-    size_t result = 0;\n-    if (_buf != NULL) {\n-      assert(_index <= capacity_in_bytes(), \"Invariant\");\n-      result = byte_index_to_index(capacity_in_bytes() - _index);\n-    }\n-    return result;\n-  }\n-\n-  bool is_empty() const {\n-    return _buf == NULL || capacity_in_bytes() == _index;\n-  }\n-\n@@ -263,0 +233,3 @@\n+  \/\/ Discard any buffered enqueued data.\n+  void reset_queue(PtrQueue& queue);\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/ptrQueue.hpp","additions":7,"deletions":34,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -50,9 +50,0 @@\n-void SATBMarkQueue::apply_closure_and_empty(SATBBufferClosure* cl) {\n-  assert(SafepointSynchronize::is_at_safepoint(),\n-         \"SATB queues must only be processed at safepoints\");\n-  if (_buf != NULL) {\n-    cl->do_buffer(&_buf[index()], size());\n-    reset();\n-  }\n-}\n-\n@@ -362,1 +353,1 @@\n-    SATBMarkQueueSet* _qset;\n+    SATBMarkQueueSet& _qset;\n@@ -364,1 +355,1 @@\n-    AbandonThreadQueueClosure(SATBMarkQueueSet* qset) : _qset(qset) {}\n+    AbandonThreadQueueClosure(SATBMarkQueueSet& qset) : _qset(qset) {}\n@@ -366,1 +357,1 @@\n-      _qset->satb_queue_for_thread(t).reset();\n+      _qset.reset_queue(_qset.satb_queue_for_thread(t));\n@@ -368,1 +359,1 @@\n-  } closure(this);\n+  } closure(*this);\n","filename":"src\/hotspot\/share\/gc\/shared\/satbMarkQueue.cpp","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -68,4 +68,0 @@\n-  \/\/ Apply cl to the active part of the buffer.\n-  \/\/ Prerequisite: Must be at a safepoint.\n-  void apply_closure_and_empty(SATBBufferClosure* cl);\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/satbMarkQueue.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -108,1 +108,2 @@\n-  assert( queue.is_empty(),  \"SATB queue should be empty\");\n+  assert(queue.buffer() == nullptr, \"SATB queue should not have a buffer\");\n+  assert(queue.index() == 0, \"SATB queue index should be zero\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -108,3 +108,3 @@\n-  ShenandoahSATBBufferClosure* _satb_cl;\n-  OopClosure*            const _cl;\n-  MarkingCodeBlobClosure*      _code_cl;\n+  SATBMarkQueueSet& _satb_qset;\n+  OopClosure* const _cl;\n+  MarkingCodeBlobClosure* _code_cl;\n@@ -114,2 +114,3 @@\n-  ShenandoahSATBAndRemarkCodeRootsThreadsClosure(ShenandoahSATBBufferClosure* satb_cl, OopClosure* cl, MarkingCodeBlobClosure* code_cl) :\n-    _satb_cl(satb_cl), _cl(cl), _code_cl(code_cl),\n+  ShenandoahSATBAndRemarkCodeRootsThreadsClosure(SATBMarkQueueSet& satb_qset, OopClosure* cl, MarkingCodeBlobClosure* code_cl) :\n+    _satb_qset(satb_qset),\n+    _cl(cl), _code_cl(code_cl),\n@@ -120,1 +121,2 @@\n-      ShenandoahThreadLocalData::satb_mark_queue(thread).apply_closure_and_empty(_satb_cl);\n+      \/\/ Transfer any partial buffer to the qset for completed buffer processing.\n+      _satb_qset.flush_queue(ShenandoahThreadLocalData::satb_mark_queue(thread));\n@@ -168,1 +170,1 @@\n-      ShenandoahSATBAndRemarkCodeRootsThreadsClosure tc(&cl,\n+      ShenandoahSATBAndRemarkCodeRootsThreadsClosure tc(satb_mq_set,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"}]}