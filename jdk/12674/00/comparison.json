{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -584,1 +584,1 @@\n-                    if (n >= 0) {\n+                    if (n > 0 || (n == 0 && isOpen())) {\n@@ -704,1 +704,1 @@\n-            if (n >= 0) {\n+            if (n > 0 || (n == 0 && isOpen())) {\n@@ -741,1 +741,1 @@\n-                if (n >= 0) {\n+                if (n > 0 || (n == 0 && isOpen())) {\n@@ -790,3 +790,3 @@\n-                            ((DirectBuffer)bb).address() + pos, rem,\n-                            sourceSockAddr.address(),\n-                            connected);\n+                             ((DirectBuffer)bb).address() + pos, rem,\n+                             sourceSockAddr.address(),\n+                             connected);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8280113\n+ * @summary Test async close of a DatagramSocket obtained from a DatagramChannel where\n+ *     the DatagramChannel's internal socket address caches are already populated\n+ * @enablePreview\n+ * @library \/test\/lib\n+ * @run junit AdaptorAsyncCloseAfterReceive\n+ *\/\n+\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.DatagramChannel;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.test.lib.thread.VThreadRunner;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.AfterAll;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class AdaptorAsyncCloseAfterReceive {\n+\n+    \/\/ used for scheduling socket close\n+    private static ScheduledExecutorService scheduler;\n+\n+    @BeforeAll\n+    static void setup() {\n+        scheduler = Executors.newSingleThreadScheduledExecutor();\n+    }\n+\n+    @AfterAll\n+    static void finish() {\n+        scheduler.shutdown();\n+    }\n+\n+    \/**\n+     * Test closing a DatagramSocket, obtained from a DatagramChannel, while the main\n+     * thread is blocked in receive. The receive method should throw rather than\n+     * completing with the sender address of a previous datagram.\n+     *\/\n+    @ParameterizedTest\n+    @CsvSource({\"0,0\", \"100,0\", \"0,60000\", \"100,60000\"})\n+    void testReceive(int maxLength, int timeout) throws Exception {\n+        try (DatagramChannel dc = DatagramChannel.open()) {\n+            dc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+\n+            populateSocketAddressCaches(dc);\n+\n+            \/\/ schedule socket to be closed while main thead blocked in receive\n+            DatagramSocket s = dc.socket();\n+            Future<?> future = scheduler.schedule(() -> s.close(), 1, TimeUnit.SECONDS);\n+            try {\n+                byte[] ba = new byte[maxLength];\n+                DatagramPacket p = new DatagramPacket(ba, maxLength);\n+                s.setSoTimeout(timeout);\n+                assertThrows(SocketException.class, () -> s.receive(p));\n+            } finally {\n+                future.cancel(true);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Send and receive a few messages to ensure that the DatagramChannel internal\n+     * socket address cache is populated. This setup is also done in a virtual\n+     * thread to ensure that the underlying socket is non-blocking.\n+     *\/\n+    private void populateSocketAddressCaches(DatagramChannel dc) throws Exception {\n+        VThreadRunner.run(() -> {\n+            InetSocketAddress remote = (InetSocketAddress) dc.getLocalAddress();\n+            if (remote.getAddress().isAnyLocalAddress()) {\n+                InetAddress lb = InetAddress.getLoopbackAddress();\n+                remote = new InetSocketAddress(lb, dc.socket().getLocalPort());\n+            }\n+            for (int i = 0; i < 2; i++) {\n+                ByteBuffer bb = ByteBuffer.allocate(32);\n+                dc.send(bb, remote);\n+                bb.rewind();\n+                dc.receive(bb);\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/AdaptorAsyncCloseAfterReceive.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"}]}