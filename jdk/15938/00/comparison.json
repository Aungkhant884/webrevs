{"files":[{"patch":"@@ -111,0 +111,21 @@\n+    \/**\n+     * Accepts a single feature pair which is composed of platform feature string followed by a true\/false\n+     * value where a true value necessities existence of platform feature and vice-versa.\n+     * IR verifications checks are enforced only if the specified feature constraint is met.\n+     *\/\n+    String[] applyIfPlatformFeature() default {};\n+\n+    \/**\n+     * Accepts a list of feature pairs where each pair is composed of target feature string followed by a true\/false\n+     * value where a true value necessities existence of target feature and vice-versa.\n+     * IR verifications checks are enforced only if all the specified feature constraints are met.\n+     *\/\n+    String[] applyIfPlatformFeatureAnd() default {};\n+\n+    \/**\n+     * Accepts a list of feature pairs where each pair is composed of target feature string followed by a true\/false\n+     * value where a true value necessities existence of target feature and vice-versa.\n+     * IR verifications checks are enforced if any of the specified feature constraint is met.\n+     *\/\n+    String[] applyIfPlatformFeatureOr() default {};\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IR.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -121,0 +121,5 @@\n+#### Disable\/Enable IR Rules based on available Platform Features\n+`@IR` rules based on platform features can be specified using `applyIfPlatformFeatureXXX` in [@IR](.\/IR.java). A reference for using these attributes can be found in [TestPlatformFeatureCheck](..\/..\/..\/testlibrary_tests\/ir_framework\/tests\/TestPlatformFeatureCheck.java) (internal framework test).\n+\n+Platform attributes are evaluated as a logical conjunction, and take precedence over VM Flag attributes. An example with both `applyIfPlatformFeatureXXX` and `applyIfXXX` can be found in [TestPreconditions](..\/..\/..\/testlibrary_tests\/ir_framework\/tests\/TestPreconditions.java) (internal framework test).\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/README.md","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.test.lib.Platform;\n@@ -58,0 +59,18 @@\n+    \/\/ Platform specific features for use in IR preconditions. Please verify that there is\n+    \/\/ a corresponding value e.g. in a jtreg @requires annotation before adding new features,\n+    \/\/ as adding non-existent features can lead to skipped tests.\n+    private static final List<String> verifiedPlatformFeatures = new ArrayList<String>( Arrays.asList(\n+        \/\/ os.family\n+        \"linux\",\n+        \"mac\",\n+        \"windows\",\n+        \/\/ vm.simpleArch values\n+        \"aarch64\",\n+        \"riscv64\",\n+        \"x64\",\n+        \"x86\",\n+        \/\/ corresponds to vm.bits\n+        \"32-bit\",\n+        \"64-bit\"\n+    ));\n+\n@@ -135,0 +154,9 @@\n+        } else if (irAnno.applyIfPlatformFeature().length != 0 && !hasAllRequiredPlatformFeature(irAnno.applyIfPlatformFeature())) {\n+            printDisableReason(m, \"Feature constraint not met (applyIfPlatformFeature)\", irAnno.applyIfPlatformFeature(), ruleIndex, ruleMax);\n+            return false;\n+        } else if (irAnno.applyIfPlatformFeatureAnd().length != 0 && !hasAllRequiredPlatformFeature(irAnno.applyIfPlatformFeatureAnd())) {\n+            printDisableReason(m, \"Not all feature constraints are met (applyIfPlatformFeatureAnd)\", irAnno.applyIfPlatformFeatureAnd(), ruleIndex, ruleMax);\n+            return false;\n+        } else if (irAnno.applyIfPlatformFeatureOr().length != 0 && !hasAnyRequiredPlatformFeature(irAnno.applyIfPlatformFeatureOr())) {\n+            printDisableReason(m, \"None of the feature constraints met (applyIfPlatformFeatureOr)\", irAnno.applyIfPlatformFeatureOr(), ruleIndex, ruleMax);\n+            return false;\n@@ -166,0 +194,1 @@\n+        int platformFeatureConstraints = 0;\n@@ -182,0 +211,15 @@\n+        if (irAnno.applyIfPlatformFeature().length != 0) {\n+            platformFeatureConstraints++;\n+            TestFormat.checkNoThrow(irAnno.applyIfPlatformFeature().length == 2,\n+                                    \"applyIfPlatformFeature expects single platform feature pair\" + failAt());\n+        }\n+        if (irAnno.applyIfPlatformFeatureAnd().length != 0) {\n+            platformFeatureConstraints++;\n+            TestFormat.checkNoThrow(irAnno.applyIfPlatformFeatureAnd().length % 2 == 0,\n+                                    \"applyIfPlatformFeatureAnd expects more than one platform feature pair\" + failAt());\n+        }\n+        if (irAnno.applyIfPlatformFeatureOr().length != 0) {\n+            platformFeatureConstraints++;\n+            TestFormat.checkNoThrow(irAnno.applyIfPlatformFeatureOr().length % 2 == 0,\n+                                    \"applyIfPlatformFeatureOr expects more than one platform feature pair\" + failAt());\n+        }\n@@ -203,0 +247,1 @@\n+        TestFormat.checkNoThrow(platformFeatureConstraints <= 1, \"Can only specify one platform feature constraint\" + failAt());\n@@ -236,0 +281,70 @@\n+    private boolean hasAllRequiredPlatformFeature(String[] andRules) {\n+        boolean returnValue = true;\n+        for (int i = 0; i < andRules.length; i++) {\n+            String feature = andRules[i].trim();\n+            i++;\n+            String value = andRules[i].trim();\n+            returnValue &= checkPlatformFeature(feature, value);\n+        }\n+        return returnValue;\n+    }\n+\n+    private boolean hasAnyRequiredPlatformFeature(String[] orRules) {\n+        boolean returnValue = false;\n+        for (int i = 0; i < orRules.length; i++) {\n+            String feature = orRules[i].trim();\n+            i++;\n+            String value = orRules[i].trim();\n+            returnValue |= checkPlatformFeature(feature, value);\n+        }\n+        return returnValue;\n+    }\n+\n+    private boolean checkPlatformFeature(String feature, String value) {\n+        if (feature.isEmpty()) {\n+            TestFormat.failNoThrow(\"Provided empty feature\" + failAt());\n+            return false;\n+        }\n+        if (value.isEmpty()) {\n+            TestFormat.failNoThrow(\"Provided empty value for feature \" + feature + failAt());\n+            return false;\n+        }\n+\n+        if (!verifiedPlatformFeatures.contains(feature)) {\n+            TestFormat.failNoThrow(\"Provided Platform feature is not in verified list: \" + feature + failAt());\n+            return false;\n+        }\n+\n+        boolean trueValue = value.contains(\"true\");\n+        boolean falseValue = value.contains(\"false\");\n+\n+        if (!trueValue && !falseValue) {\n+            TestFormat.failNoThrow(\"Provided incorrect value for feature \" + feature + failAt());\n+            return false;\n+        }\n+\n+        String os = \"\";\n+        if (Platform.isLinux()) {\n+            os = \"linux\";\n+        } else if (Platform.isOSX()) {\n+            os = \"mac\";\n+        } else if (Platform.isWindows()) {\n+            os = \"windows\";\n+        }\n+\n+        String arch = \"\";\n+        if (Platform.isAArch64()) {\n+            arch = \"aarch64\";\n+        } else if (Platform.isRISCV64()) {\n+            arch = \"riscv64\";\n+        } else if (Platform.isX64()) {\n+            arch = \"x64\";\n+        } else if (Platform.isX86()) {\n+            arch = \"x86\";\n+        }\n+\n+        String platformFeatures = os + \" \" + arch + \" \" + (Platform.is32bit() ? \"32-bit\" : \"64-bit\");\n+\n+        return (trueValue && platformFeatures.contains(feature)) || (falseValue && !platformFeatures.contains(feature));\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @requires vm.bits == \"64\"\n@@ -96,1 +95,2 @@\n-    @IR(applyIfCPUFeature = {\"avx2\", \"true\"},\n+    @IR(applyIfPlatformFeature = {\"32-bit\", \"false\"},\n+        applyIfCPUFeature = {\"avx2\", \"true\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRed_Long.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.driver.irmatching.IRViolationException;\n+\n+\/*\n+ * @test 8280120\n+ * @summary Add attribute to IR to enable\/disable IR matching based on the architecture\n+ * @library \/test\/lib \/\n+ * @run driver ir_framework.tests.TestPlatformFeatureCheck\n+ *\/\n+\n+public class TestPlatformFeatureCheck {\n+    private static final int SIZE = 1000;\n+    private static int[] a = new int[SIZE];\n+    private static int[] b = new int[SIZE];\n+    private static int[] res = new int[SIZE];\n+\n+    public static void setup() {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = i;\n+            b[i] = i;\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        setup();\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\"},\n+        applyIfPlatformFeature = {\"x64\", \"true\"},\n+        applyIfCPUFeature = {\"sse4.1\", \"true\"})\n+    public static void test1() {\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] + b[i];\n+        }\n+    }\n+\n+    \/\/ IR rule is enforced if all the feature conditions holds good\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\"},\n+        applyIfPlatformFeatureAnd = {\"x64\", \"true\", \"linux\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"true\"})\n+    public static void test2() {\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] + b[i];\n+        }\n+    }\n+\n+    \/\/ IR rule is enforced if any of the feature condition holds good\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\"},\n+        applyIfPlatformFeatureOr = {\"linux\", \"true\", \"mac\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"avx2\", \"true\"})\n+    public static void test3() {\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] + b[i];\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestPlatformFeatureCheck.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -84,0 +84,26 @@\n+\n+    \/\/ The IR check should not be applied, since OS can not be both linux and mac.\n+    @Test\n+    @IR(applyIfPlatformFeatureAnd = {\"linux\", \"true\", \"mac\", \"true\"},\n+        counts = {IRNode.LOOP, \">= 1000\"})\n+    public static void testApplyBothOs() {}\n+\n+    \/\/ The IR check should not be applied, since we can't have both 32-bit and 64-bit data model.\n+    @Test\n+    @IR(applyIfPlatformFeatureAnd = {\"32-bit\", \"true\", \"64-bit\", \"true\"},\n+        counts = {IRNode.LOOP, \">= 1000\"})\n+    public static void testApplyBothDataModel() {}\n+\n+    \/\/ The IR check should not be applied, since the arch can't be both x64 and aarch64.\n+    @Test\n+    @IR(applyIfPlatformFeatureAnd = {\"x64\", \"true\", \"aarch64\", \"true\"},\n+        counts = {IRNode.LOOP, \">= 1000\"})\n+    public static void testApplyBothArch() {}\n+\n+    \/\/ Platform version of testApplyBoth2.\n+    @Test\n+    @IR(applyIfPlatformFeature = {\"aarch64\", \"true\"},\n+        applyIfAnd = {\"UseSVE\", \"= 0\", \"LoopMaxUnroll\", \"= 0\"},\n+        counts = {IRNode.LOOP, \">= 1000\"})\n+    public static void testApplyBoth4() {}\n+\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestPreconditions.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"}]}