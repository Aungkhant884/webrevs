{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2195,78 +2195,0 @@\n-void C2_MacroAssembler::vpcmpu(BasicType typ, XMMRegister dst, XMMRegister src1, XMMRegister src2, ComparisonPredicate comparison,\n-                            int vlen_in_bytes, XMMRegister vtmp1, XMMRegister vtmp2, Register scratch) {\n-  int vlen_enc = vector_length_encoding(vlen_in_bytes*2);\n-  switch (typ) {\n-  case T_BYTE:\n-    vpmovzxbw(vtmp1, src1, vlen_enc);\n-    vpmovzxbw(vtmp2, src2, vlen_enc);\n-    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::W, vlen_enc, scratch);\n-    vpacksswb(dst, dst, dst, vlen_enc);\n-    break;\n-  case T_SHORT:\n-    vpmovzxwd(vtmp1, src1, vlen_enc);\n-    vpmovzxwd(vtmp2, src2, vlen_enc);\n-    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::D, vlen_enc, scratch);\n-    vpackssdw(dst, dst, dst, vlen_enc);\n-    break;\n-  case T_INT:\n-    vpmovzxdq(vtmp1, src1, vlen_enc);\n-    vpmovzxdq(vtmp2, src2, vlen_enc);\n-    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::Q, vlen_enc, scratch);\n-    vpermilps(dst, dst, 8, vlen_enc);\n-    break;\n-  default:\n-    assert(false, \"Should not reach here\");\n-  }\n-  if (vlen_in_bytes == 16) {\n-    vpermpd(dst, dst, 0x8, vlen_enc);\n-  }\n-}\n-\n-void C2_MacroAssembler::vpcmpu32(BasicType typ, XMMRegister dst, XMMRegister src1, XMMRegister src2, ComparisonPredicate comparison, int vlen_in_bytes,\n-                              XMMRegister vtmp1, XMMRegister vtmp2, XMMRegister vtmp3, Register scratch) {\n-  int vlen_enc = vector_length_encoding(vlen_in_bytes);\n-  switch (typ) {\n-  case T_BYTE:\n-    vpmovzxbw(vtmp1, src1, vlen_enc);\n-    vpmovzxbw(vtmp2, src2, vlen_enc);\n-    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::W, vlen_enc, scratch);\n-    vextracti128(vtmp1, src1, 1);\n-    vextracti128(vtmp2, src2, 1);\n-    vpmovzxbw(vtmp1, vtmp1, vlen_enc);\n-    vpmovzxbw(vtmp2, vtmp2, vlen_enc);\n-    vpcmpCCW(vtmp3, vtmp1, vtmp2, comparison, Assembler::W, vlen_enc, scratch);\n-    vpacksswb(dst, dst, vtmp3, vlen_enc);\n-    vpermpd(dst, dst, 0xd8, vlen_enc);\n-    break;\n-  case T_SHORT:\n-    vpmovzxwd(vtmp1, src1, vlen_enc);\n-    vpmovzxwd(vtmp2, src2, vlen_enc);\n-    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::D, vlen_enc, scratch);\n-    vextracti128(vtmp1, src1, 1);\n-    vextracti128(vtmp2, src2, 1);\n-    vpmovzxwd(vtmp1, vtmp1, vlen_enc);\n-    vpmovzxwd(vtmp2, vtmp2, vlen_enc);\n-    vpcmpCCW(vtmp3, vtmp1, vtmp2, comparison, Assembler::D,  vlen_enc, scratch);\n-    vpackssdw(dst, dst, vtmp3, vlen_enc);\n-    vpermpd(dst, dst, 0xd8, vlen_enc);\n-    break;\n-  case T_INT:\n-    vpmovzxdq(vtmp1, src1, vlen_enc);\n-    vpmovzxdq(vtmp2, src2, vlen_enc);\n-    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::Q, vlen_enc, scratch);\n-    vpshufd(dst, dst, 8, vlen_enc);\n-    vpermq(dst, dst, 8, vlen_enc);\n-    vextracti128(vtmp1, src1, 1);\n-    vextracti128(vtmp2, src2, 1);\n-    vpmovzxdq(vtmp1, vtmp1, vlen_enc);\n-    vpmovzxdq(vtmp2, vtmp2, vlen_enc);\n-    vpcmpCCW(vtmp3, vtmp1, vtmp2, comparison, Assembler::Q,  vlen_enc, scratch);\n-    vpshufd(vtmp3, vtmp3, 8, vlen_enc);\n-    vpermq(vtmp3, vtmp3, 0x80, vlen_enc);\n-    vpblendd(dst, dst, vtmp3, 0xf0, vlen_enc);\n-    break;\n-  default:\n-    assert(false, \"Should not reach here\");\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":1,"deletions":79,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,6 +149,0 @@\n-  \/\/ vector compare\n-  void vpcmpu(BasicType typ, XMMRegister dst, XMMRegister src1, XMMRegister src2, ComparisonPredicate comparison, int vlen_in_bytes,\n-              XMMRegister vtmp1, XMMRegister vtmp2, Register scratch);\n-  void vpcmpu32(BasicType typ, XMMRegister dst, XMMRegister src1, XMMRegister src2, ComparisonPredicate comparison, int vlen_in_bytes,\n-                XMMRegister vtmp1, XMMRegister vtmp2, XMMRegister vtmp3, Register scratch);\n-\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3154,0 +3154,9 @@\n+void MacroAssembler::vbroadcastsd(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch) {\n+  if (reachable(src)) {\n+    Assembler::vbroadcastsd(dst, as_Address(src), vector_len);\n+  } else {\n+    lea(rscratch, src);\n+    Assembler::vbroadcastsd(dst, Address(rscratch, 0), vector_len);\n+  }\n+}\n+\n@@ -3222,1 +3231,1 @@\n-void MacroAssembler::vpcmpCCW(XMMRegister dst, XMMRegister nds, XMMRegister src, ComparisonPredicate cond, Width width, int vector_len, Register scratch_reg) {\n+void MacroAssembler::vpcmpCCW(XMMRegister dst, XMMRegister nds, XMMRegister src, XMMRegister xtmp, ComparisonPredicate cond, Width width, int vector_len) {\n@@ -3235,1 +3244,2 @@\n-    vpxor(dst, dst, ExternalAddress(StubRoutines::x86::vector_all_bits_set()), vector_len, scratch_reg);\n+    vallones(xtmp, vector_len);\n+    vpxor(dst, xtmp, dst, vector_len);\n@@ -3239,1 +3249,2 @@\n-    vpxor(dst, dst, ExternalAddress(StubRoutines::x86::vector_all_bits_set()), vector_len, scratch_reg);\n+    vallones(xtmp, vector_len);\n+    vpxor(dst, xtmp, dst, vector_len);\n@@ -3243,1 +3254,2 @@\n-    vpxor(dst, dst, ExternalAddress(StubRoutines::x86::vector_all_bits_set()), vector_len, scratch_reg);\n+    vallones(xtmp, vector_len);\n+    vpxor(dst, xtmp, dst, vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1287,0 +1287,3 @@\n+  using Assembler::vbroadcastsd;\n+  void vbroadcastsd(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch = rscratch1);\n+\n@@ -1313,1 +1316,1 @@\n-  void vpcmpCCW(XMMRegister dst, XMMRegister nds, XMMRegister src, ComparisonPredicate cond, Width width, int vector_len, Register scratch_reg);\n+  void vpcmpCCW(XMMRegister dst, XMMRegister nds, XMMRegister src, XMMRegister xtmp, ComparisonPredicate cond, Width width, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,14 +169,1 @@\n-    int vlen_in_bytes = vlen * type2aelembytes(bt);\n-    if ((UseAVX > 2) && (VM_Version::supports_avx512vl() || vlen_in_bytes == 64))\n-      return true;\n-    else {\n-      \/\/ instruction set supports only signed comparison\n-      \/\/ so need to zero extend to higher integral type and perform comparison\n-      \/\/ cannot cast long to higher integral type\n-      \/\/ and on avx1 cannot cast 128 bit integral vectors to higher size\n-\n-      if ((bt != T_LONG)  &&\n-          ((UseAVX >= 2) || (vlen_in_bytes <= 8)))\n-        return true;\n-    }\n-    return false;\n+    return true;\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2564,0 +2564,12 @@\n+static inline jlong high_bit_set(BasicType bt) {\n+  switch (bt) {\n+    case T_BYTE:  return 0x8080808080808080;\n+    case T_SHORT: return 0x8000800080008000;\n+    case T_INT:   return 0x8000000080000000;\n+    case T_LONG:  return 0x8000000000000000;\n+    default:\n+      ShouldNotReachHere();\n+      return 0;\n+  }\n+}\n+\n@@ -7314,1 +7326,1 @@\n-instruct vcmp(legVec dst, legVec src1, legVec src2, immI8 cond, rRegP scratch) %{\n+instruct vcmp_pri(legVec dst, legVec src1, legVec src2, immI8 cond) %{\n@@ -7319,1 +7331,4 @@\n-            is_integral_type(Matcher::vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1\n+            is_integral_type(Matcher::vector_element_basic_type(n->in(1)->in(1))) &&\n+            (n->in(2)->get_int() == BoolTest::eq ||\n+             n->in(2)->get_int() == BoolTest::lt ||\n+             n->in(2)->get_int() == BoolTest::gt)); \/\/ cond\n@@ -7321,2 +7336,1 @@\n-  effect(TEMP scratch);\n-  format %{ \"vector_compare $dst,$src1,$src2,$cond\\t! using $scratch as TEMP\" %}\n+  format %{ \"vector_compare $dst,$src1,$src2,$cond\\t!\" %}\n@@ -7327,1 +7341,1 @@\n-    __ vpcmpCCW($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cmp, ww, vlen_enc, $scratch$$Register);\n+    __ vpcmpCCW($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, xnoreg, cmp, ww, vlen_enc);\n@@ -7332,1 +7346,1 @@\n-instruct vcmpu(legVec dst, legVec src1, legVec src2, immI8 cond, legVec vtmp1, legVec vtmp2, rRegP scratch) %{\n+instruct vcmp_sec(legVec dst, legVec src1, legVec src2, immI8 cond, legVec xtmp) %{\n@@ -7334,4 +7348,7 @@\n-            is_unsigned_booltest_pred(n->in(2)->get_int()) &&\n-            Matcher::vector_length_in_bytes(n->in(1)->in(1)) >=  8 && \/\/ src1\n-            Matcher::vector_length_in_bytes(n->in(1)->in(1)) <= 16 && \/\/ src1\n-            is_integral_type(Matcher::vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1\n+            !is_unsigned_booltest_pred(n->in(2)->get_int()) &&\n+            Matcher::vector_length_in_bytes(n->in(1)->in(1)) >=  4 && \/\/ src1\n+            Matcher::vector_length_in_bytes(n->in(1)->in(1)) <= 32 && \/\/ src1\n+            is_integral_type(Matcher::vector_element_basic_type(n->in(1)->in(1))) &&\n+            (n->in(2)->get_int() == BoolTest::ne ||\n+             n->in(2)->get_int() == BoolTest::le ||\n+             n->in(2)->get_int() == BoolTest::ge)); \/\/ cond\n@@ -7339,2 +7356,2 @@\n-  effect(TEMP vtmp1, TEMP vtmp2, TEMP scratch);\n-  format %{ \"vector_compareu $dst,$src1,$src2,$cond\\t! using $scratch as TEMP\" %}\n+  effect(TEMP dst, TEMP xtmp);\n+  format %{ \"vector_compare $dst,$src1,$src2,$cond\\t! using $xtmp as TEMP\" %}\n@@ -7342,1 +7359,1 @@\n-    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n+    int vlen_enc = vector_length_encoding(this, $src1);\n@@ -7344,3 +7361,2 @@\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src1);\n-    __ vpcmpu(bt, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen, $vtmp1$$XMMRegister,\n-              $vtmp2$$XMMRegister, $scratch$$Register);\n+    Assembler::Width ww = widthForType(Matcher::vector_element_basic_type(this, $src1));\n+    __ vpcmpCCW($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, $xtmp$$XMMRegister, cmp, ww, vlen_enc);\n@@ -7351,1 +7367,1 @@\n-instruct vcmpu32(legVec dst, legVec src1, legVec src2, immI8 cond, legVec vtmp1, legVec vtmp2, legVec vtmp3, rRegP scratch) %{\n+instruct vcmpu(legVec dst, legVec src1, legVec src2, immI8 cond, legVec xtmp, rRegP scratch) %{\n@@ -7354,1 +7370,2 @@\n-            Matcher::vector_length_in_bytes(n->in(1)->in(1)) == 32 && \/\/ src1\n+            Matcher::vector_length_in_bytes(n->in(1)->in(1)) >=  4 && \/\/ src1\n+            Matcher::vector_length_in_bytes(n->in(1)->in(1)) <= 32 && \/\/ src1\n@@ -7357,2 +7374,2 @@\n-  effect(TEMP dst, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP scratch);\n-  format %{ \"vector_compareu $dst,$src1,$src2,$cond\\t! using $scratch as TEMP\" %}\n+  effect(TEMP dst, TEMP xtmp, TEMP scratch);\n+  format %{ \"vector_compareu $dst,$src1,$src2,$cond\\t! using $xtmp and $scratch as TEMP\" %}\n@@ -7360,1 +7377,2 @@\n-    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n+    InternalAddress flip_bit = $constantaddress(high_bit_set(Matcher::vector_element_basic_type(this, $src1)));\n+    int vlen_enc = vector_length_encoding(this, $src1);\n@@ -7362,3 +7380,6 @@\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src1);\n-    __ vpcmpu32(bt, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen, $vtmp1$$XMMRegister,\n-                $vtmp2$$XMMRegister, $vtmp3$$XMMRegister, $scratch$$Register);\n+    Assembler::Width ww = widthForType(Matcher::vector_element_basic_type(this, $src1));\n+\n+    __ vbroadcastsd($xtmp$$XMMRegister, flip_bit, Assembler::AVX_256bit, $scratch$$Register);\n+    __ vpxor($dst$$XMMRegister, $xtmp$$XMMRegister, $src1$$XMMRegister, vlen_enc);\n+    __ vpxor($xtmp$$XMMRegister, $xtmp$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+    __ vpcmpCCW($dst$$XMMRegister, $dst$$XMMRegister, $xtmp$$XMMRegister, $xtmp$$XMMRegister, cmp, ww, vlen_enc);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":46,"deletions":25,"binary":false,"changes":71,"status":"modified"}]}