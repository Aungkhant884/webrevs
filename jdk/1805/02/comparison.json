{"files":[{"patch":"@@ -228,0 +228,12 @@\n+class ShenandoahClaimThreadClosure : public ThreadClosure {\n+private:\n+  const uintx _claim_token;\n+public:\n+  ShenandoahClaimThreadClosure() :\n+   _claim_token(Threads::thread_claim_token()) {}\n+\n+  virtual void do_thread(Thread* thread) {\n+    thread->claim_threads_do(false \/*is_par*\/, _claim_token);\n+  }\n+};\n+\n@@ -237,0 +249,7 @@\n+\n+    \/\/ Full GC does not need to remark threads and drain SATB buffers, but we need to claim the\n+    \/\/ threads - it requires a StrongRootsScope around the task.\n+    if (ShenandoahHeap::heap()->is_full_gc_in_progress()) {\n+      ShenandoahClaimThreadClosure tc;\n+      Threads::threads_do(&tc);\n+    }\n@@ -245,6 +264,1 @@\n-    \/\/ First drain remaining SATB buffers.\n-    \/\/ Notice that this is not strictly necessary for mark-compact. But since\n-    \/\/ it requires a StrongRootsScope around the task, we need to claim the\n-    \/\/ threads, and performance-wise it doesn't really matter. Adds about 1ms to\n-    \/\/ full-gc.\n-    {\n+    if (!heap->is_full_gc_in_progress()) {\n@@ -252,1 +266,0 @@\n-\n@@ -255,1 +268,3 @@\n-      while (satb_mq_set.apply_closure_to_completed_buffer(&cl));\n+      while (satb_mq_set.apply_closure_to_completed_buffer(&cl)) {}\n+\n+      assert(!heap->has_forwarded_objects(), \"Not expected\");\n@@ -257,15 +272,6 @@\n-      if (heap->has_forwarded_objects()) {\n-        ShenandoahMarkResolveRefsClosure resolve_mark_cl(q, rp);\n-        MarkingCodeBlobClosure blobsCl(&resolve_mark_cl, !CodeBlobToOopClosure::FixRelocations);\n-        ShenandoahSATBAndRemarkCodeRootsThreadsClosure tc(&cl,\n-                                                          ShenandoahStoreValEnqueueBarrier ? &resolve_mark_cl : NULL,\n-                                                          do_nmethods ? &blobsCl : NULL);\n-        Threads::threads_do(&tc);\n-      } else {\n-        ShenandoahMarkRefsClosure mark_cl(q, rp);\n-        MarkingCodeBlobClosure blobsCl(&mark_cl, !CodeBlobToOopClosure::FixRelocations);\n-        ShenandoahSATBAndRemarkCodeRootsThreadsClosure tc(&cl,\n-                                                          ShenandoahStoreValEnqueueBarrier ? &mark_cl : NULL,\n-                                                          do_nmethods ? &blobsCl : NULL);\n-        Threads::threads_do(&tc);\n-      }\n+      ShenandoahMarkRefsClosure mark_cl(q, rp);\n+      MarkingCodeBlobClosure blobsCl(&mark_cl, !CodeBlobToOopClosure::FixRelocations);\n+      ShenandoahSATBAndRemarkCodeRootsThreadsClosure tc(&cl,\n+                                                        ShenandoahStoreValEnqueueBarrier ? &mark_cl : NULL,\n+                                                        do_nmethods ? &blobsCl : NULL);\n+      Threads::threads_do(&tc);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":29,"deletions":23,"binary":false,"changes":52,"status":"modified"}]}