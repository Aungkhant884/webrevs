{"files":[{"patch":"@@ -3394,10 +3394,0 @@\n-      log_debug(gc, humongous)(\"Humongous region %u (object size \" SIZE_FORMAT \" @ \" PTR_FORMAT \") remset \" SIZE_FORMAT \" code roots \" SIZE_FORMAT \" marked %d reclaim candidate %d type array %d\",\n-                               index,\n-                               (size_t)cast_to_oop(hr->bottom())->size() * HeapWordSize,\n-                               p2i(hr->bottom()),\n-                               hr->rem_set()->occupied(),\n-                               hr->rem_set()->strong_code_roots_list_length(),\n-                               _g1h->concurrent_mark()->next_mark_bitmap()->is_marked(hr->bottom()),\n-                               _g1h->is_humongous_reclaim_candidate(index),\n-                               cast_to_oop(hr->bottom())->is_typeArray()\n-                              );\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -94,36 +94,0 @@\n-\n-  \/\/ Returns whether the given humongous object defined by the start region index\n-  \/\/ is reclaimable.\n-  \/\/\n-  \/\/ At this point in the garbage collection, checking whether the humongous object\n-  \/\/ is still a candidate is sufficient because:\n-  \/\/\n-  \/\/ - if it has not been a candidate at the start of collection, it will never\n-  \/\/ changed to be a candidate during the gc (and live).\n-  \/\/ - any found outstanding (i.e. in the DCQ, or in its remembered set)\n-  \/\/ references will set the candidate state to false.\n-  \/\/ - there can be no references from within humongous starts regions referencing\n-  \/\/ the object because we never allocate other objects into them.\n-  \/\/ (I.e. there can be no intra-region references)\n-  \/\/\n-  \/\/ It is not required to check whether the object has been found dead by marking\n-  \/\/ or not, in fact it would prevent reclamation within a concurrent cycle, as\n-  \/\/ all objects allocated during that time are considered live.\n-  \/\/ SATB marking is even more conservative than the remembered set.\n-  \/\/ So if at this point in the collection we did not find a reference during gc\n-  \/\/ (or it had enough references to not be a candidate, having many remembered\n-  \/\/ set entries), nobody has a reference to it.\n-  \/\/ At the start of collection we flush all refinement logs, and remembered sets\n-  \/\/ are completely up-to-date wrt to references to the humongous object.\n-  \/\/\n-  \/\/ So there is no need to re-check remembered set size of the humongous region.\n-  \/\/\n-  \/\/ Other implementation considerations:\n-  \/\/ - never consider object arrays at this time because they would pose\n-  \/\/ considerable effort for cleaning up the the remembered sets. This is\n-  \/\/ required because stale remembered sets might reference locations that\n-  \/\/ are currently allocated into.\n-  bool is_reclaimable(uint region_idx) const {\n-    return G1CollectedHeap::heap()->is_humongous_reclaim_candidate(region_idx);\n-  }\n-\n@@ -131,0 +95,1 @@\n+\n@@ -142,0 +107,33 @@\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+\n+    oop obj = cast_to_oop(r->bottom());\n+    G1CMBitMap* next_bitmap = g1h->concurrent_mark()->next_mark_bitmap();\n+\n+    \/\/ The following checks whether the humongous object is live are sufficient.\n+    \/\/ The main additional check (in addition to having a reference from the roots\n+    \/\/ or the young gen) is whether the humongous object has a remembered set entry.\n+    \/\/\n+    \/\/ A humongous object cannot be live if there is no remembered set for it\n+    \/\/ because:\n+    \/\/ - there can be no references from within humongous starts regions referencing\n+    \/\/ the object because we never allocate other objects into them.\n+    \/\/ (I.e. there are no intra-region references that may be missed by the\n+    \/\/ remembered set)\n+    \/\/ - as soon there is a remembered set entry to the humongous starts region\n+    \/\/ (i.e. it has \"escaped\" to an old object) this remembered set entry will stay\n+    \/\/ until the end of a concurrent mark.\n+    \/\/\n+    \/\/ It is not required to check whether the object has been found dead by marking\n+    \/\/ or not, in fact it would prevent reclamation within a concurrent cycle, as\n+    \/\/ all objects allocated during that time are considered live.\n+    \/\/ SATB marking is even more conservative than the remembered set.\n+    \/\/ So if at this point in the collection there is no remembered set entry,\n+    \/\/ nobody has a reference to it.\n+    \/\/ At the start of collection we flush all refinement logs, and remembered sets\n+    \/\/ are completely up-to-date wrt to references to the humongous object.\n+    \/\/\n+    \/\/ Other implementation considerations:\n+    \/\/ - never consider object arrays at this time because they would pose\n+    \/\/ considerable effort for cleaning up the the remembered sets. This is\n+    \/\/ required because stale remembered sets might reference locations that\n+    \/\/ are currently allocated into.\n@@ -143,1 +141,12 @@\n-    if (!is_reclaimable(region_idx)) {\n+    if (!g1h->is_humongous_reclaim_candidate(region_idx) ||\n+        !r->rem_set()->is_empty()) {\n+      log_debug(gc, humongous)(\"Live humongous region %u object size \" SIZE_FORMAT \" start \" PTR_FORMAT \"  with remset \" SIZE_FORMAT \" code roots \" SIZE_FORMAT \" is marked %d reclaim candidate %d type array %d\",\n+                               region_idx,\n+                               (size_t)obj->size() * HeapWordSize,\n+                               p2i(r->bottom()),\n+                               r->rem_set()->occupied(),\n+                               r->rem_set()->strong_code_roots_list_length(),\n+                               next_bitmap->is_marked(r->bottom()),\n+                               g1h->is_humongous_reclaim_candidate(region_idx),\n+                               obj->is_typeArray()\n+                              );\n@@ -147,1 +156,0 @@\n-    oop obj = cast_to_oop(r->bottom());\n@@ -152,1 +160,11 @@\n-    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    log_debug(gc, humongous)(\"Dead humongous region %u object size \" SIZE_FORMAT \" start \" PTR_FORMAT \" with remset \" SIZE_FORMAT \" code roots \" SIZE_FORMAT \" is marked %d reclaim candidate %d type array %d\",\n+                             region_idx,\n+                             (size_t)obj->size() * HeapWordSize,\n+                             p2i(r->bottom()),\n+                             r->rem_set()->occupied(),\n+                             r->rem_set()->strong_code_roots_list_length(),\n+                             next_bitmap->is_marked(r->bottom()),\n+                             g1h->is_humongous_reclaim_candidate(region_idx),\n+                             obj->is_typeArray()\n+                            );\n+\n@@ -171,5 +189,0 @@\n-    log_debug(gc, humongous)(\"Reclaimed humongous region %u (object size \" SIZE_FORMAT \" @ \" PTR_FORMAT \")\",\n-                             region_idx,\n-                             (size_t)obj->size() * HeapWordSize,\n-                             p2i(r->bottom())\n-                            );\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":57,"deletions":44,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-    System.out.println(output.getStdout());\n@@ -64,2 +63,2 @@\n-    output.shouldContain(\"Humongous region\");\n-    output.shouldContain(\"Reclaimed humongous region\");\n+    output.shouldContain(\"Live humongous\");\n+    output.shouldContain(\"Dead humongous region\");\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestG1TraceEagerReclaimHumongousObjects.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}