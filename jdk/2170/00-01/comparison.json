{"files":[{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2004, 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @bug 4952558\n+ * @library \/test\/lib\n+ * @build NonJavaNames\n+ * @run testng\/othervm NonJavaNameTest\n+ * @summary Verify names that aren't legal Java names are accepted by forName.\n+ * @author Joseph D. Darcy\n+ *\/\n+\n+public class NonJavaNameTest {\n+    private static final String SRC_DIR = System.getProperty(\"test.src\");\n+    private static final String NONJAVA_NAMES_SRC = SRC_DIR + \"\/classes\/\";\n+    private static final String NONJAVA_NAMES_CLASSES = System.getProperty(\"test.classes\", \".\");\n+    Path dhyphenPath, dcommaPath, dperiodPath, dleftsquarePath, drightsquarePath, dplusPath, dsemicolonPath, dzeroPath, dthreePath, dzadePath;\n+\n+    @BeforeClass\n+    public void createInvalidNameClasses() throws IOException {\n+        Path hyphenPath = Paths.get(NONJAVA_NAMES_SRC + \"hyphen.class\");\n+        Path commaPath = Paths.get(NONJAVA_NAMES_SRC + \"comma.class\");\n+        Path periodPath = Paths.get(NONJAVA_NAMES_SRC + \"period.class\");\n+        Path leftsquarePath = Paths.get(NONJAVA_NAMES_SRC + \"left-square.class\");\n+        Path rightsquarePath = Paths.get(NONJAVA_NAMES_SRC + \"right-square.class\");\n+        Path plusPath = Paths.get(NONJAVA_NAMES_SRC + \"plus.class\");\n+        Path semicolonPath = Paths.get(NONJAVA_NAMES_SRC + \"semicolon.class\");\n+        Path zeroPath = Paths.get(NONJAVA_NAMES_SRC + \"0.class\");\n+        Path threePath = Paths.get(NONJAVA_NAMES_SRC + \"3.class\");\n+        Path zadePath = Paths.get(NONJAVA_NAMES_SRC + \"Z.class\");\n+\n+        dhyphenPath = Paths.get(NONJAVA_NAMES_CLASSES + \"\/-.class\");\n+        dcommaPath = Paths.get(NONJAVA_NAMES_CLASSES + \"\/,.class\");\n+        dperiodPath = Paths.get(NONJAVA_NAMES_CLASSES + \"\/..class\");\n+        dleftsquarePath = Paths.get(NONJAVA_NAMES_CLASSES + \"\/[.class\");\n+        drightsquarePath = Paths.get(NONJAVA_NAMES_CLASSES + \"\/].class\");\n+        dplusPath = Paths.get(NONJAVA_NAMES_CLASSES + \"\/+.class\");\n+        dsemicolonPath = Paths.get(NONJAVA_NAMES_CLASSES + \"\/;.class\");\n+        dzeroPath = Paths.get(NONJAVA_NAMES_CLASSES + \"\/0.class\");\n+        dthreePath = Paths.get(NONJAVA_NAMES_CLASSES + \"\/3.class\");\n+        dzadePath = Paths.get(NONJAVA_NAMES_CLASSES + \"\/Z.class\");\n+\n+        Files.copy(hyphenPath, dhyphenPath, REPLACE_EXISTING);\n+        Files.copy(commaPath, dcommaPath, REPLACE_EXISTING);\n+        Files.copy(periodPath, dperiodPath, REPLACE_EXISTING);\n+        Files.copy(leftsquarePath, dleftsquarePath, REPLACE_EXISTING);\n+        Files.copy(rightsquarePath, drightsquarePath, REPLACE_EXISTING);\n+        Files.copy(plusPath, dplusPath, REPLACE_EXISTING);\n+        Files.copy(semicolonPath, dsemicolonPath, REPLACE_EXISTING);\n+        Files.copy(zeroPath, dzeroPath, REPLACE_EXISTING);\n+        Files.copy(threePath, dthreePath, REPLACE_EXISTING);\n+        Files.copy(zadePath, dzadePath, REPLACE_EXISTING);\n+    }\n+\n+    @Test\n+    public void NonJavaNamestest() throws Throwable {\n+        ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder( \"NonJavaNames\");\n+        OutputAnalyzer outputAnalyzer = ProcessTools.executeCommand(processBuilder);\n+        outputAnalyzer.shouldHaveExitValue(0);\n+    }\n+\n+    @AfterClass\n+    public void deleteInvalidNameClasses() throws IOException {\n+        Files.deleteIfExists(dhyphenPath);\n+        Files.deleteIfExists(dcommaPath);\n+        Files.deleteIfExists(dperiodPath);\n+        Files.deleteIfExists(dleftsquarePath);\n+        Files.deleteIfExists(drightsquarePath);\n+        Files.deleteIfExists(dplusPath);\n+        Files.deleteIfExists(dzeroPath);\n+        Files.deleteIfExists(dthreePath);\n+        Files.deleteIfExists(dzadePath);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Class\/forName\/NonJavaNameTest.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -24,5 +24,0 @@\n-\/*\n- * Used by NonJavaNames.sh; needs to be run with a classpath including\n- * test\/java\/lang\/Class\/forName\/classes\n- *\/\n-\n","filename":"test\/jdk\/java\/lang\/Class\/forName\/NonJavaNames.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,108 +0,0 @@\n-#\n-# Copyright (c) 2003, 2012, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# @test\n-# @bug 4952558\n-# @summary Verify names that aren't legal Java names are accepted by forName.\n-# @author Joseph D. Darcy\n-# @compile NonJavaNames.java\n-# @run shell NonJavaNames.sh\n-\n-# This test uses hand-generated class files stored in the .\/classes\n-# directory.  After the renaming done below, those class files have\n-# single character names that are legal class names under in the class\n-# file but *not* legal Java language identifiers; e.g. \"3\" and \"+\".\n-# First, Z.java is compiled to Z.class.  Next, to create a test class\n-# file, the appropriate name structures within the class files are\n-# updated, as is the \"Hello world\" string the class's main method\n-# prints out.\n-\n-# Verify directory context variables are set\n-if [ \"${TESTJAVA}\" = \"\" ]\n-then\n-  echo \"TESTJAVA not set.  Test cannot execute.  Failed.\"\n-  exit 1\n-fi\n-\n-if [ \"${TESTSRC}\" = \"\" ]\n-then\n-  echo \"TESTSRC not set.  Test cannot execute.  Failed.\"\n-  exit 1\n-fi\n-\n-if [ \"${TESTCLASSES}\" = \"\" ]\n-then\n-  echo \"TESTCLASSES not set.  Test cannot execute.  Failed.\"\n-  exit 1\n-fi\n-\n-# All preconditions are met; run the tests\n-\n-OS=`uname -s`;\n-# Set classpath separator\n-case \"$OS\" in\n-        Windows* | CYGWIN* )\n-\tSEP=\";\"\n-        ;;\n-\n-\t* )\n-\tSEP=\":\"\n-esac\n-\n-# Copy \"hyphen.class\" to \"-.class\"\n-\n-COPYHYPHEN=\"cp ${TESTSRC}\/classes\/hyphen.class ${TESTCLASSES}\/-.class\"\n-$COPYHYPHEN\n-\n-COPYCOMMA=\"cp ${TESTSRC}\/classes\/comma.class ${TESTCLASSES}\/,.class\"\n-$COPYCOMMA\n-\n-COPYPERIOD=\"cp ${TESTSRC}\/classes\/period.class ${TESTCLASSES}\/..class\"\n-$COPYPERIOD\n-\n-COPYLEFTSQUARE=\"cp ${TESTSRC}\/classes\/left-square.class ${TESTCLASSES}\/[.class\"\n-$COPYLEFTSQUARE\n-\n-COPYRIGHTSQUARE=\"cp ${TESTSRC}\/classes\/right-square.class ${TESTCLASSES}\/].class\"\n-$COPYRIGHTSQUARE\n-\n-COPYPLUS=\"cp ${TESTSRC}\/classes\/plus.class ${TESTCLASSES}\/+.class\"\n-$COPYPLUS\n-\n-COPYSEMICOLON=\"cp ${TESTSRC}\/classes\/semicolon.class ${TESTCLASSES}\/;.class\"\n-$COPYSEMICOLON\n-\n-JAVA=\"$TESTJAVA\/bin\/java ${TESTVMOPTS} -classpath ${TESTSRC}\/classes${SEP}${TESTCLASSES}\"\n-\n-$JAVA NonJavaNames\n-RESULT=$?\n-\n-case \"$RESULT\" in\n-        0 )\n-        exit 0;\n-        ;;\n-\n-        * )\n-        exit 1\n-esac\n-\n","filename":"test\/jdk\/java\/lang\/Class\/forName\/NonJavaNames.sh","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -56,0 +56,1 @@\n+import java.lang.reflect.Field;\n@@ -60,0 +61,1 @@\n+import common.TestMe;\n@@ -83,1 +85,1 @@\n-    public void createEnclosingClasses() {\n+    public void createEnclosingClasses() throws Throwable {\n@@ -100,0 +102,6 @@\n+\n+        String javacPath = JDKToolFinder.getJDKTool(\"javac\");\n+        OutputAnalyzer outputAnalyzer = ProcessTools.executeCommand(javacPath, \"-d\", System.getProperty(\"test.classes\", \".\"),\n+                SRC_DIR + \"\/EnclosingClass.java\", SRC_DIR + \"\/pkg1\/EnclosingClass.java\", SRC_DIR + \"\/pkg1\/pkg2\/EnclosingClass.java\");\n+\n+        outputAnalyzer.shouldHaveExitValue(0);\n@@ -104,6 +112,11 @@\n-        String javacPath = JDKToolFinder.getJDKTool(\"javac\");\n-        ProcessTools.executeCommand(javacPath, \"-d\", System.getProperty(\"test.classes\", \".\"),\n-                SRC_DIR + \"\/RunEnclosingClassTest.java\");\n-        ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(\"RunEnclosingClassTest\");\n-        OutputAnalyzer outputAnalyzer = ProcessTools.executeCommand(processBuilder);\n-        outputAnalyzer.shouldHaveExitValue(0);\n+        test(Class.forName(\"EnclosingClass\").getDeclaredConstructor().newInstance());\n+    }\n+\n+    @Test\n+    public void testEnclosingClassesInPackage() throws Throwable {\n+        test(Class.forName(\"pkg1.EnclosingClass\").getDeclaredConstructor().newInstance());\n+    }\n+\n+    @Test\n+    public void testEnclosingClassesInNestedPackage() throws Throwable {\n+        test(Class.forName(\"pkg1.pkg2.EnclosingClass\").getDeclaredConstructor().newInstance());\n@@ -128,1 +141,1 @@\n-    private void createAndWriteEnclosingClasses(final Path source, final Path target, String packagePath) {\n+    private void createAndWriteEnclosingClasses(final Path source, final Path target, final String packagePath) {\n@@ -146,0 +159,66 @@\n+\n+    private void info(final Class<?> c, final Class<?> encClass, final String desc) {\n+        if (!\"\".equals(desc)) {\n+            System.out.println(desc + \":\");\n+        }\n+        System.out.println(c);\n+        System.out.println(\"\\tis enclosed by:\\t\\t\" + encClass);\n+        System.out.println(\"\\thas simple name:\\t`\" + c.getSimpleName() + \"'\");\n+        System.out.println(\"\\thas canonical name:\\t`\" + c.getCanonicalName() + \"'\");\n+    }\n+\n+    private void match(final String actual, final String expected) {\n+        System.out.println(\"actual:\" + actual + \"expected:\" + expected);\n+        assert ((actual == null && expected == null) || actual.trim().equals(expected.trim()));\n+        System.out.println(\"\\t`\" + actual + \"' matches expected `\" + expected + \"'\");\n+    }\n+\n+    private void check(final Class<?> c, final Class<?> enc,\n+               final String encName, final String encNameExpected,\n+               final String simpleName, final String simpleNameExpected,\n+               final String canonicalName, final String canonicalNameExpected) {\n+        match(encName, encNameExpected);\n+        match(simpleName, simpleNameExpected);\n+        match(canonicalName, canonicalNameExpected);\n+    }\n+\n+    private void testClass(final Class<?> c, final TestMe annotation, final Field f) {\n+        if (Void.class.equals(c)) {\n+            return;\n+        }\n+        Class<?> encClass = c.getEnclosingClass();\n+        c.getEnclosingMethod(); \/\/ make sure it does not crash\n+        c.getEnclosingConstructor(); \/\/ make sure it does not crash\n+        info(c, encClass, annotation.desc());\n+        check(c, encClass,\n+                \"\" + encClass, annotation.encl(),\n+                c.getSimpleName(), annotation.simple(),\n+                c.getCanonicalName(),\n+                annotation.hasCanonical() ? annotation.canonical() : null);\n+        if (void.class.equals(c)) {\n+            return;\n+        }\n+        Class<?> array = java.lang.reflect.Array.newInstance(c, 0).getClass();\n+        check(array, array.getEnclosingClass(),\n+                \"\", \"\",\n+                array.getSimpleName(), annotation.simple() + \"[]\",\n+                array.getCanonicalName(),\n+                annotation.hasCanonical() ? annotation.canonical() + \"[]\" : null);\n+    }\n+\n+    private void test(final Object tests) {\n+        for (Field f : tests.getClass().getFields()) {\n+            TestMe annotation = f.getAnnotation(TestMe.class);\n+            if (annotation != null) {\n+                try {\n+                    testClass((Class<?>) f.get(tests), annotation, f);\n+                } catch (AssertionError ex) {\n+                    System.err.println(\"Error in \" + tests.getClass().getName() + \".\" + f.getName());\n+                    throw ex;\n+                } catch (IllegalAccessException ex) {\n+                    ex.printStackTrace();\n+                    throw new RuntimeException(ex);\n+                }\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/Class\/getEnclosingClass\/EnclosingClassTest.java","additions":87,"deletions":8,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -1,97 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2021 Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.reflect.Field;\n-\n-import common.TestMe;\n-\n-class RunEnclosingClassTest {\n-    static void info(Class<?> c, Class<?> encClass, String desc) {\n-        if (!\"\".equals(desc))\n-            System.out.println(desc + \":\");\n-        System.out.println(c);\n-        System.out.println(\"\\tis enclosed by:\\t\\t\" + encClass);\n-        System.out.println(\"\\thas simple name:\\t`\" +\n-                c.getSimpleName() + \"'\");\n-        System.out.println(\"\\thas canonical name:\\t`\" +\n-                c.getCanonicalName() + \"'\");\n-    }\n-\n-    static void match(String actual, String expected) {\n-        assert((actual == null && expected == null) || actual.equals(expected));\n-        System.out.println(\"\\t`\" + actual + \"' matches expected `\" + expected + \"'\");\n-    }\n-\n-    static void check(Class<?> c, Class<?> enc,\n-                      String encName, String encNameExpected,\n-                      String simpleName, String simpleNameExpected,\n-                      String canonicalName, String canonicalNameExpected) {\n-        match(encName, encNameExpected);\n-        match(simpleName, simpleNameExpected);\n-        match(canonicalName, canonicalNameExpected);\n-    }\n-\n-    static void testClass(Class<?> c, TestMe annotation, Field f) {\n-        if (Void.class.equals(c))\n-            return;\n-        Class<?> encClass = c.getEnclosingClass();\n-        c.getEnclosingMethod(); \/\/ make sure it does not crash\n-        c.getEnclosingConstructor(); \/\/ make sure it does not crash\n-        info(c, encClass, annotation.desc());\n-        check(c, encClass,\n-                \"\"+encClass, annotation.encl(),\n-                c.getSimpleName(), annotation.simple(),\n-                c.getCanonicalName(),\n-                annotation.hasCanonical() ? annotation.canonical() : null);\n-        if (void.class.equals(c))\n-            return;\n-        Class<?> array = java.lang.reflect.Array.newInstance(c, 0).getClass();\n-        check(array, array.getEnclosingClass(),\n-                \"\", \"\",\n-                array.getSimpleName(), annotation.simple() + \"[]\",\n-                array.getCanonicalName(),\n-                annotation.hasCanonical() ? annotation.canonical() + \"[]\" : null);\n-    }\n-\n-    static void test(final Object tests) {\n-        for (Field f : tests.getClass().getFields()) {\n-            TestMe annotation = f.getAnnotation(TestMe.class);\n-            if (annotation != null) {\n-                try {\n-                    testClass((Class<?>)f.get(tests), annotation, f);\n-                } catch (AssertionError ex) {\n-                    System.err.println(\"Error in \" + tests.getClass().getName() + \".\" + f.getName());\n-                    throw ex;\n-                } catch (IllegalAccessException ex) {\n-                    ex.printStackTrace();\n-                    throw new RuntimeException(ex);\n-                }\n-            }\n-        }\n-    }\n-    public static void main(final String[] args) {\n-        test(new EnclosingClass());\n-        test(new pkg1.EnclosingClass());\n-        test(new pkg1.pkg2.EnclosingClass());\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Class\/getEnclosingClass\/RunEnclosingClassTest.java","additions":0,"deletions":97,"binary":false,"changes":97,"status":"deleted"}]}