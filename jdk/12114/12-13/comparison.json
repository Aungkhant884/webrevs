{"files":[{"patch":"@@ -48,3 +48,3 @@\n-  static inline u2   get_Java_u2(address p)           { return byteswap<u2>(get_native_u2(p)); }\n-  static inline u4   get_Java_u4(address p)           { return byteswap<u4>(get_native_u4(p)); }\n-  static inline u8   get_Java_u8(address p)           { return byteswap<u8>(get_native_u8(p)); }\n+  static inline u2   get_Java_u2(address p)           { return byteswap(get_native_u2(p)); }\n+  static inline u4   get_Java_u4(address p)           { return byteswap(get_native_u4(p)); }\n+  static inline u8   get_Java_u8(address p)           { return byteswap(get_native_u8(p)); }\n@@ -52,3 +52,3 @@\n-  static inline void put_Java_u2(address p, u2 x)     { put_native_u2(p, byteswap<u2>(x)); }\n-  static inline void put_Java_u4(address p, u4 x)     { put_native_u4(p, byteswap<u4>(x)); }\n-  static inline void put_Java_u8(address p, u8 x)     { put_native_u8(p, byteswap<u8>(x)); }\n+  static inline void put_Java_u2(address p, u2 x)     { put_native_u2(p, byteswap(x)); }\n+  static inline void put_Java_u4(address p, u4 x)     { put_native_u4(p, byteswap(x)); }\n+  static inline void put_Java_u8(address p, u8 x)     { put_native_u8(p, byteswap(x)); }\n","filename":"src\/hotspot\/cpu\/aarch64\/bytes_aarch64.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -140,3 +140,3 @@\n-  static inline u2   get_Java_u2(address p) { return byteswap<u2>(get_native_u2(p)); }\n-  static inline u4   get_Java_u4(address p) { return byteswap<u4>(get_native_u4(p)); }\n-  static inline u8   get_Java_u8(address p) { return byteswap<u8>(get_native_u8(p)); }\n+  static inline u2   get_Java_u2(address p) { return byteswap(get_native_u2(p)); }\n+  static inline u4   get_Java_u4(address p) { return byteswap(get_native_u4(p)); }\n+  static inline u8   get_Java_u8(address p) { return byteswap(get_native_u8(p)); }\n@@ -144,3 +144,3 @@\n-  static inline void put_Java_u2(address p, u2 x)     { put_native_u2(p, byteswap<u2>(x)); }\n-  static inline void put_Java_u4(address p, u4 x)     { put_native_u4(p, byteswap<u4>(x)); }\n-  static inline void put_Java_u8(address p, u8 x)     { put_native_u8(p, byteswap<u8>(x)); }\n+  static inline void put_Java_u2(address p, u2 x)     { put_native_u2(p, byteswap(x)); }\n+  static inline void put_Java_u4(address p, u4 x)     { put_native_u4(p, byteswap(x)); }\n+  static inline void put_Java_u8(address p, u8 x)     { put_native_u8(p, byteswap(x)); }\n","filename":"src\/hotspot\/cpu\/ppc\/bytes_ppc.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -110,4 +110,4 @@\n-      a = byteswap<juint>(a);\n-      b = byteswap<juint>(b);\n-      c = byteswap<juint>(c);\n-      d = byteswap<juint>(d);\n+      a = byteswap(a);\n+      b = byteswap(b);\n+      c = byteswap(c);\n+      d = byteswap(d);\n","filename":"src\/hotspot\/cpu\/ppc\/stubRoutines_ppc_64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -158,3 +158,3 @@\n-  static inline u2 get_Java_u2(address p) { return byteswap<u2>(get_native_u2(p)); }\n-  static inline u4 get_Java_u4(address p) { return byteswap<u4>(get_native_u4(p)); }\n-  static inline u8 get_Java_u8(address p) { return byteswap<u8>(get_native_u8(p)); }\n+  static inline u2 get_Java_u2(address p) { return byteswap(get_native_u2(p)); }\n+  static inline u4 get_Java_u4(address p) { return byteswap(get_native_u4(p)); }\n+  static inline u8 get_Java_u8(address p) { return byteswap(get_native_u8(p)); }\n@@ -162,3 +162,3 @@\n-  static inline void put_Java_u2(address p, u2 x) { put_native_u2(p, byteswap<u2>(x)); }\n-  static inline void put_Java_u4(address p, u4 x) { put_native_u4(p, byteswap<u4>(x)); }\n-  static inline void put_Java_u8(address p, u8 x) { put_native_u8(p, byteswap<u8>(x)); }\n+  static inline void put_Java_u2(address p, u2 x) { put_native_u2(p, byteswap(x)); }\n+  static inline void put_Java_u4(address p, u4 x) { put_native_u4(p, byteswap(x)); }\n+  static inline void put_Java_u8(address p, u8 x) { put_native_u8(p, byteswap(x)); }\n","filename":"src\/hotspot\/cpu\/riscv\/bytes_riscv.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-      x = byteswap<T>(x);\n+      x = byteswap(x);\n@@ -86,1 +86,1 @@\n-      x = byteswap<T>(x);\n+      x = byteswap(x);\n","filename":"src\/hotspot\/cpu\/x86\/bytes_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"utilities\/moveBits.hpp\"\n+#include \"utilities\/reverse_bits.hpp\"\n","filename":"src\/hotspot\/share\/code\/compressedStream.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#include \"utilities\/moveBits.hpp\"\n+#include \"utilities\/reverse_bits.hpp\"\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,7 +28,0 @@\n-\/\/ Byte swapping for 8-bit, 16-bit, 32-bit, and 64-bit integers.\n-\n-\/\/ T byteswap<T>(T)\n-\/\/\n-\/\/ Reverses the bytes for the value of the integer type T. Partially compatible with std::byteswap\n-\/\/ introduced in C++23.\n-\n@@ -36,1 +29,0 @@\n-#include \"utilities\/debug.hpp\"\n@@ -38,1 +30,0 @@\n-#include \"utilities\/macros.hpp\"\n@@ -44,7 +35,0 @@\n-template <typename T>\n-using CanByteswapImpl = std::integral_constant<bool, (std::is_integral<T>::value &&\n-                                                      (sizeof(T) == 1 ||\n-                                                       sizeof(T) == 2 ||\n-                                                       sizeof(T) == 4 ||\n-                                                       sizeof(T) == 8))>;\n-\n@@ -54,2 +38,6 @@\n-template <typename T, ENABLE_IF(CanByteswapImpl<T>::value)>\n-ALWAYSINLINE T byteswap(T x) {\n+\/\/ T byteswap<T>(T)\n+\/\/\n+\/\/ Reverses the bytes for the value of the integer type T. Partially compatible with std::byteswap\n+\/\/ introduced in C++23.\n+template <typename T, ENABLE_IF(std::is_integral<T>::value)>\n+inline T byteswap(T x) {\n@@ -57,1 +45,0 @@\n-  STATIC_ASSERT(sizeof(T) == sizeof(U));\n@@ -61,0 +48,8 @@\n+\/\/ We support 8-bit integer types to be compatible with C++23's std::byteswap.\n+template <typename T>\n+struct ByteswapImpl<T, 1> {\n+  inline constexpr T operator()(T x) const {\n+    return x;\n+  }\n+};\n+\n@@ -68,11 +63,0 @@\n-\/\/ We support 8-bit integer types to be compatible with C++23's std::byteswap.\n-template <typename T>\n-struct ByteswapFallbackImpl<T, 1> {\n-  STATIC_ASSERT(CanByteswapImpl<T>::value);\n-  STATIC_ASSERT(sizeof(T) == 1);\n-\n-  ALWAYSINLINE T operator()(T x) const {\n-    return x;\n-  }\n-};\n-\n@@ -81,4 +65,1 @@\n-  STATIC_ASSERT(CanByteswapImpl<T>::value);\n-  STATIC_ASSERT(sizeof(T) == 2);\n-\n-  ALWAYSINLINE uint16_t operator()(uint16_t x) const {\n+  inline constexpr uint16_t operator()(uint16_t x) const {\n@@ -91,4 +72,1 @@\n-  STATIC_ASSERT(CanByteswapImpl<T>::value);\n-  STATIC_ASSERT(sizeof(T) == 4);\n-\n-  ALWAYSINLINE uint32_t operator()(uint32_t x) const {\n+  inline constexpr uint32_t operator()(uint32_t x) const {\n@@ -96,1 +74,1 @@\n-            ((x & UINT32_C(0x00ff0000)) >> 8) | ((x & UINT32_C(0xff000000)) >> 24));\n+            ((x & UINT32_C(0x00ff0000)) >> 8)  | ((x & UINT32_C(0xff000000)) >> 24));\n@@ -102,4 +80,1 @@\n-  STATIC_ASSERT(CanByteswapImpl<T>::value);\n-  STATIC_ASSERT(sizeof(T) == 8);\n-\n-  ALWAYSINLINE uint64_t operator()(uint64_t x) const {\n+  inline constexpr uint64_t operator()(uint64_t x) const {\n@@ -108,1 +83,1 @@\n-            ((x & UINT64_C(0x000000ff00000000)) >> 8) | ((x & UINT64_C(0x0000ff0000000000)) >> 24) |\n+            ((x & UINT64_C(0x000000ff00000000)) >> 8)  | ((x & UINT64_C(0x0000ff0000000000)) >> 24) |\n@@ -116,1 +91,1 @@\n-#if defined(TARGET_COMPILER_gcc)\n+#if defined(TARGET_COMPILER_gcc) || defined(TARGET_COMPILER_xlc)\n@@ -126,11 +101,0 @@\n-\/\/ We support 8-bit integer types to be compatible with C++23's std::byteswap.\n-template <typename T>\n-struct ByteswapImpl<T, 1> final {\n-  STATIC_ASSERT(CanByteswapImpl<T>::value);\n-  STATIC_ASSERT(sizeof(T) == 1);\n-\n-  ALWAYSINLINE T operator()(T x) const {\n-    return x;\n-  }\n-};\n-\n@@ -138,6 +102,3 @@\n-struct ByteswapImpl<T, 2> final {\n-  STATIC_ASSERT(CanByteswapImpl<T>::value);\n-  STATIC_ASSERT(sizeof(T) == sizeof(uint16_t));\n-\n-  ALWAYSINLINE T operator()(T x) const {\n-    return static_cast<T>(__builtin_bswap16(static_cast<uint16_t>(x)));\n+struct ByteswapImpl<T, 2> {\n+  inline constexpr uint16_t operator()(uint16_t x) const {\n+    return __builtin_bswap16(x);\n@@ -148,6 +109,3 @@\n-struct ByteswapImpl<T, 4> final {\n-  STATIC_ASSERT(CanByteswapImpl<T>::value);\n-  STATIC_ASSERT(sizeof(T) == sizeof(uint32_t));\n-\n-  ALWAYSINLINE T operator()(T x) const {\n-    return static_cast<T>(__builtin_bswap32(static_cast<uint32_t>(x)));\n+struct ByteswapImpl<T, 4> {\n+  inline constexpr uint32_t operator()(uint32_t x) const {\n+    return __builtin_bswap32(x);\n@@ -158,6 +116,3 @@\n-struct ByteswapImpl<T, 8> final {\n-  STATIC_ASSERT(CanByteswapImpl<T>::value);\n-  STATIC_ASSERT(sizeof(T) == sizeof(uint64_t));\n-\n-  ALWAYSINLINE T operator()(T x) const {\n-    return static_cast<T>(__builtin_bswap64(static_cast<uint64_t>(x)));\n+struct ByteswapImpl<T, 8> {\n+  inline constexpr uint64_t operator()(uint64_t x) const {\n+    return __builtin_bswap64(x);\n@@ -179,1 +134,1 @@\n-struct ByteswapImpl final : public ByteswapFallbackImpl<T, N> {};\n+struct ByteswapImpl : public ByteswapFallbackImpl<T, N> {};\n@@ -188,1 +143,1 @@\n-#include <stdlib.h>\n+#include <cstdlib>\n@@ -194,11 +149,0 @@\n-\/\/ We support 8-bit integer types to be compatible with C++23's std::byteswap.\n-template <typename T>\n-struct ByteswapImpl<T, 1> final {\n-  STATIC_ASSERT(CanByteswapImpl<T>::value);\n-  STATIC_ASSERT(sizeof(T) == 1);\n-\n-  ALWAYSINLINE T operator()(T x) const {\n-    return x;\n-  }\n-};\n-\n@@ -206,7 +150,3 @@\n-struct ByteswapImpl<T, 2> final {\n-  STATIC_ASSERT(CanByteswapImpl<T>::value);\n-  STATIC_ASSERT(sizeof(unsigned short) == 2);\n-  STATIC_ASSERT(sizeof(T) == sizeof(unsigned short));\n-\n-  ALWAYSINLINE T operator()(T x) const {\n-    return static_cast<T>(_byteswap_ushort(static_cast<unsigned short>(x)));\n+struct ByteswapImpl<T, 2> {\n+  inline unsigned short operator()(unsigned short x) const {\n+    return _byteswap_ushort(x);\n@@ -217,7 +157,3 @@\n-struct ByteswapImpl<T, 4> final {\n-  STATIC_ASSERT(CanByteswapImpl<T>::value);\n-  STATIC_ASSERT(sizeof(unsigned long) == 4);\n-  STATIC_ASSERT(sizeof(T) == sizeof(unsigned long));\n-\n-  ALWAYSINLINE T operator()(T x) const {\n-    return static_cast<T>(_byteswap_ulong(static_cast<unsigned long>(x)));\n+struct ByteswapImpl<T, 4> {\n+  inline unsigned long operator()(unsigned long x) const {\n+    return _byteswap_ulong(x);\n@@ -228,7 +164,3 @@\n-struct ByteswapImpl<T, 8> final {\n-  STATIC_ASSERT(CanByteswapImpl<T>::value);\n-  STATIC_ASSERT(sizeof(unsigned __int64) == 8);\n-  STATIC_ASSERT(sizeof(T) == sizeof(unsigned __int64));\n-\n-  ALWAYSINLINE T operator()(T x) const {\n-    return static_cast<T>(_byteswap_uint64(static_cast<unsigned __int64>(x)));\n+struct ByteswapImpl<T, 8> {\n+  inline unsigned __int64 operator()(unsigned __int64 x) const {\n+    return _byteswap_uint64(x);\n@@ -238,68 +170,0 @@\n-\/*****************************************************************************\n- * IBM XL C\/C++\n- *****************************************************************************\/\n-#elif defined(TARGET_COMPILER_xlc)\n-\n-#include <builtins.h>\n-\n-\/\/ We support 8-bit integer types to be compatible with C++23's std::byteswap.\n-template <typename T>\n-struct ByteswapImpl<T, 1> final {\n-  STATIC_ASSERT(CanByteswapImpl<T>::value);\n-  STATIC_ASSERT(sizeof(T) == 1);\n-\n-  ALWAYSINLINE T operator()(T x) const {\n-    return x;\n-  }\n-};\n-\n-template <typename T>\n-struct ByteswapImpl<T, 2> final {\n-  STATIC_ASSERT(CanByteswapImpl<T>::value);\n-  STATIC_ASSERT(sizeof(unsigned short) == 2);\n-  STATIC_ASSERT(sizeof(T) == sizeof(unsigned short));\n-\n-  ALWAYSINLINE T operator()(T x) const {\n-    unsigned short y;\n-    __store2r(static_cast<unsigned short>(x), &y);\n-    return static_cast<T>(y);\n-  }\n-};\n-\n-template <typename T>\n-struct ByteswapImpl<T, 4> final {\n-  STATIC_ASSERT(CanByteswapImpl<T>::value);\n-  STATIC_ASSERT(sizeof(unsigned int) == 4);\n-  STATIC_ASSERT(sizeof(T) == sizeof(unsigned int));\n-\n-  ALWAYSINLINE T operator()(T x) const {\n-    unsigned int y;\n-    __store4r(static_cast<unsigned int>(x), &y);\n-    return static_cast<T>(y);\n-  }\n-};\n-\n-#if defined(_ARCH_PWR7) && defined(_ARCH_PPC64)\n-\n-\/\/ __store8r is only available on POWER7 and newer in 64-bit mode.\n-\n-template <typename T>\n-struct ByteswapImpl<T, 8> final {\n-  STATIC_ASSERT(CanByteswapImpl<T>::value);\n-  STATIC_ASSERT(sizeof(unsigned long long) == 8);\n-  STATIC_ASSERT(sizeof(T) == sizeof(unsigned long long));\n-\n-  ALWAYSINLINE T operator()(T x) const {\n-    unsigned long long y;\n-    __store8r(static_cast<unsigned long long>(x), &y);\n-    return static_cast<T>(y);\n-  }\n-};\n-\n-#else\n-\n-template <typename T>\n-struct ByteswapImpl<T, 8> final : public ByteswapFallbackImpl<T, 8> {};\n-\n-#endif\n-\n","filename":"src\/hotspot\/share\/utilities\/byteswap.hpp","additions":40,"deletions":176,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-        tmp = byteswap<T>(tmp);\n+        tmp = byteswap(tmp);\n","filename":"src\/hotspot\/share\/utilities\/copy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,182 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023, Google and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_UTILITIES_MOVEBITS_HPP\n-#define SHARE_UTILITIES_MOVEBITS_HPP\n-\n-#include \"metaprogramming\/enableIf.hpp\"\n-#include \"utilities\/byteswap.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-#include <cstdint>\n-#include <type_traits>\n-\n-\/\/ T reverse_bits<T>(T)\n-\/\/\n-\/\/ Reverses the bits in the integral value of type T.\n-\n-template <typename T>\n-using CanReverseBitsImpl = std::integral_constant<bool, (std::is_integral<T>::value &&\n-                                                         (sizeof(T) == 1 ||\n-                                                          sizeof(T) == 2 ||\n-                                                          sizeof(T) == 4 ||\n-                                                          sizeof(T) == 8))>;\n-\n-template <typename T, size_t N = sizeof(T)>\n-struct ReverseBitsImpl;\n-\n-template <typename T, ENABLE_IF(CanReverseBitsImpl<T>::value)>\n-ALWAYSINLINE T reverse_bits(T x) {\n-  return ReverseBitsImpl<T>{}(x);\n-}\n-\n-\/*****************************************************************************\n- * Fallback\n- *****************************************************************************\/\n-\n-template <typename T>\n-struct ReverseBitsFallbackImpl {\n- private:\n-  static constexpr size_t NB = sizeof(T) * BitsPerByte;\n-\n-  \/\/ The unsigned integral type for calculations.\n-  using I = std::conditional_t<NB <= 32, uint32_t, uint64_t>;\n-\n-  static constexpr I rep_5555 = static_cast<I>(UINT64_C(0x5555555555555555));\n-  static constexpr I rep_3333 = static_cast<I>(UINT64_C(0x3333333333333333));\n-  static constexpr I rep_0F0F = static_cast<I>(UINT64_C(0x0F0F0F0F0F0F0F0F));\n-\n- public:\n-  STATIC_ASSERT(CanReverseBitsImpl<T>::value);\n-\n-  ALWAYSINLINE T operator()(T v) const {\n-    \/\/ Based on Hacker's Delight Section 7-1\n-    I x = static_cast<I>(v);\n-    x = ((x & rep_5555) << 1) | ((x >> 1) & rep_5555);\n-    x = ((x & rep_3333) << 2) | ((x >> 2) & rep_3333);\n-    x = ((x & rep_0F0F) << 4) | ((x >> 4) & rep_0F0F);\n-    return byteswap<T>(static_cast<T>(x));\n-  }\n-};\n-\n-\n-\/*****************************************************************************\n- * GCC and compatible (including Clang)\n- *****************************************************************************\/\n-#if defined(TARGET_COMPILER_gcc)\n-\n-\/\/ Default implementation for GCC-like compilers is the fallback. At the time of writing GCC does\n-\/\/ not have intrinsics for bit reversal while Clang does.\n-\n-template <typename T, size_t N>\n-struct ReverseBitsImpl final : public ReverseBitsFallbackImpl<T> {};\n-\n-#ifdef __has_builtin\n-\n-#if __has_builtin(__builtin_bitreverse8)\n-\n-template <typename T>\n-struct ReverseBitsImpl<T, 1> final {\n-  STATIC_ASSERT(CanReverseBitsImpl<T>::value);\n-  STATIC_ASSERT(sizeof(T) == 1);\n-\n-  ALWAYSINLINE T operator()(T v) const {\n-    return static_cast<T>(__builtin_bitreverse8(static_cast<uint8_t>(v)));\n-  }\n-};\n-\n-#endif \/\/ __has_builtin(__builtin_bitreverse8)\n-\n-#if __has_builtin(__builtin_bitreverse16)\n-\n-template <typename T>\n-struct ReverseBitsImpl<T, 2> final {\n-  STATIC_ASSERT(CanReverseBitsImpl<T>::value);\n-  STATIC_ASSERT(sizeof(T) == 2);\n-\n-  ALWAYSINLINE T operator()(T v) const {\n-    return static_cast<T>(__builtin_bitreverse16(static_cast<uint16_t>(v)));\n-  }\n-};\n-\n-#endif \/\/ __has_builtin(__builtin_bitreverse16)\n-\n-#if __has_builtin(__builtin_bitreverse32)\n-\n-template <typename T>\n-struct ReverseBitsImpl<T, 4> final {\n-  STATIC_ASSERT(CanReverseBitsImpl<T>::value);\n-  STATIC_ASSERT(sizeof(T) == 4);\n-\n-  ALWAYSINLINE T operator()(T v) const {\n-    return static_cast<T>(__builtin_bitreverse32(static_cast<uint32_t>(v)));\n-  }\n-};\n-\n-#endif \/\/ __has_builtin(__builtin_bitreverse32)\n-\n-#if __has_builtin(__builtin_bitreverse64)\n-\n-template <typename T>\n-struct ReverseBitsImpl<T, 8> final {\n-  STATIC_ASSERT(CanReverseBitsImpl<T>::value);\n-  STATIC_ASSERT(sizeof(T) == 8);\n-\n-  ALWAYSINLINE T operator()(T v) const {\n-    return static_cast<T>(__builtin_bitreverse64(static_cast<uint64_t>(v)));\n-  }\n-};\n-\n-#endif \/\/ __has_builtin(__builtin_bitreverse64)\n-\n-#endif \/\/ __has_builtin\n-\n-\/*****************************************************************************\n- * Microsoft Visual Studio\n- *****************************************************************************\/\n-#elif defined(TARGET_COMPILER_visCPP)\n-\n-template <typename T, size_t N>\n-struct ReverseBitsImpl final : public ReverseBitsFallbackImpl<T> {};\n-\n-\/*****************************************************************************\n- * IBM XL C\/C++\n- *****************************************************************************\/\n-#elif defined(TARGET_COMPILER_xlc)\n-\n-template <typename T, size_t N>\n-struct ReverseBitsImpl final : public ReverseBitsFallbackImpl<T> {};\n-\n-\/*****************************************************************************\n- * Unknown toolchain\n- *****************************************************************************\/\n-#else\n-\n-#error Unknown toolchain.\n-\n-#endif\n-\n-#endif \/\/ SHARE_UTILITIES_MOVEBITS_HPP\n","filename":"src\/hotspot\/share\/utilities\/moveBits.hpp","additions":0,"deletions":182,"binary":false,"changes":182,"status":"deleted"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_REVERSE_BITS_HPP\n+#define SHARE_UTILITIES_REVERSE_BITS_HPP\n+\n+#include \"metaprogramming\/enableIf.hpp\"\n+#include \"utilities\/byteswap.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <type_traits>\n+\n+template <typename T, size_t N = sizeof(T)>\n+struct ReverseBitsImpl;\n+\n+\/\/ T reverse_bits<T>(T)\n+\/\/\n+\/\/ Reverses the bits in the integral value of type T.\n+template <typename T, ENABLE_IF(std::is_integral<T>::value)>\n+inline T reverse_bits(T x) {\n+  using U = std::make_unsigned_t<T>;\n+  return static_cast<T>(ReverseBitsImpl<U>{}(static_cast<U>(x)));\n+}\n+\n+\/*****************************************************************************\n+ * Fallback\n+ *****************************************************************************\/\n+\n+template <typename T>\n+struct ReverseBitsFallbackImpl {\n+ private:\n+  \/\/ The unsigned integral type for calculations.\n+  using U = std::conditional_t<sizeof(T) <= 4, uint32_t, uint64_t>;\n+\n+  static constexpr U rep_5555 = static_cast<U>(UINT64_C(0x5555555555555555));\n+  static constexpr U rep_3333 = static_cast<U>(UINT64_C(0x3333333333333333));\n+  static constexpr U rep_0F0F = static_cast<U>(UINT64_C(0x0F0F0F0F0F0F0F0F));\n+\n+ public:\n+  inline T operator()(T v) const {\n+    \/\/ Based on Hacker's Delight Section 7-1\n+    U x = static_cast<U>(v);\n+    x = ((x & rep_5555) << 1) | ((x >> 1) & rep_5555);\n+    x = ((x & rep_3333) << 2) | ((x >> 2) & rep_3333);\n+    x = ((x & rep_0F0F) << 4) | ((x >> 4) & rep_0F0F);\n+    return byteswap(static_cast<T>(x));\n+  }\n+};\n+\n+\n+\/*****************************************************************************\n+ * GCC and compatible (including Clang)\n+ *****************************************************************************\/\n+#if defined(TARGET_COMPILER_gcc) || defined(TARGET_COMPILER_xlc)\n+\n+\/\/ Default implementation for GCC-like compilers is the fallback. At the time of writing GCC does\n+\/\/ not have intrinsics for bit reversal while Clang does.\n+\n+template <typename T, size_t N>\n+struct ReverseBitsImpl : public ReverseBitsFallbackImpl<T> {};\n+\n+#ifdef __has_builtin\n+\n+#if __has_builtin(__builtin_bitreverse8)\n+\n+template <typename T>\n+struct ReverseBitsImpl<T, 1> {\n+  inline uint8_t operator()(uint8_t x) const {\n+    return __builtin_bitreverse8(x);\n+  }\n+};\n+\n+#endif \/\/ __has_builtin(__builtin_bitreverse8)\n+\n+#if __has_builtin(__builtin_bitreverse16)\n+\n+template <typename T>\n+struct ReverseBitsImpl<T, 2> {\n+  inline uint16_t operator()(uint16_t x) const {\n+    return __builtin_bitreverse16(x);\n+  }\n+};\n+\n+#endif \/\/ __has_builtin(__builtin_bitreverse16)\n+\n+#if __has_builtin(__builtin_bitreverse32)\n+\n+template <typename T>\n+struct ReverseBitsImpl<T, 4> {\n+  inline uint32_t operator()(uint32_t x) const {\n+    return __builtin_bitreverse32(x);\n+  }\n+};\n+\n+#endif \/\/ __has_builtin(__builtin_bitreverse32)\n+\n+#if __has_builtin(__builtin_bitreverse64)\n+\n+template <typename T>\n+struct ReverseBitsImpl<T, 8> {\n+  inline uint64_t operator()(uint64_t x) const {\n+    return __builtin_bitreverse64(x);\n+  }\n+};\n+\n+#endif \/\/ __has_builtin(__builtin_bitreverse64)\n+\n+#endif \/\/ __has_builtin\n+\n+\/*****************************************************************************\n+ * Microsoft Visual Studio\n+ *****************************************************************************\/\n+#elif defined(TARGET_COMPILER_visCPP)\n+\n+template <typename T, size_t N>\n+struct ReverseBitsImpl : public ReverseBitsFallbackImpl<T> {};\n+\n+\/*****************************************************************************\n+ * Unknown toolchain\n+ *****************************************************************************\/\n+#else\n+\n+#error Unknown toolchain.\n+\n+#endif\n+\n+#endif \/\/ SHARE_UTILITIES_REVERSE_BITS_HPP\n","filename":"src\/hotspot\/share\/utilities\/reverse_bits.hpp","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -63,0 +63,22 @@\n+\n+\/\/ Here is some object code to look at if we want to do a manual\n+\/\/ study.  One could find the build file named test_byteswap.o.cmdline\n+\/\/ and hand-edit the command line to produce assembly code in\n+\/\/ test_byteswap.s.\n+\/\/\n+\/\/ Or, given the two empty \"fence functions\", one could do a\n+\/\/ quick scan like this:\n+\/\/\n+\/\/ $ objdump -D $(find build\/*release -name test_byteswap.o) \\\n+\/\/   | sed -n '\/start_code_quality\/,$p;\/end_code_quality\/q' \\\n+\/\/   | egrep -B10 bswap  # or grep -B20 cfi_endproc\n+\n+void start_code_quality_byteswap() { }\n+\n+int32_t code_quality_reverse_bytes_32(int32_t x) {\n+  return byteswap(x);\n+}\n+\n+int64_t code_quality_reverse_bytes_64(int64_t x) {\n+  return byteswap(x);\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_byteswap.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/moveBits.hpp\"\n-#include \"unittest.hpp\"\n-\n-template<typename T>\n-static inline void test_moveBits() {\n-  const int  NBIT = sizeof(T) * 8;\n-  const bool IS_U = (T)-1 > 0;\n-  const int XOR_REV_BITS = (NBIT - 1);\n-  ASSERT_EQ(reverse_bits((T)0), (T)0);\n-  ASSERT_EQ(reverse_bits((T)-1), (T)-1);\n-  for (int i1 = 0; i1 < NBIT; i1++) {\n-    T mask1 = (T)1 << i1;\n-    T revm1 = (T)1 << (i1 ^ XOR_REV_BITS);\n-    for (int i2 = 0; i2 <= i1; i2++) {\n-      T mask2 = (T)1 << i2;\n-      T revm2 = (T)1 << (i2 ^ XOR_REV_BITS);\n-      T mask = mask1|mask2;\n-#define STUFF (IS_U?\"u\":\"s\") << NBIT << \"@\" << i1 << \",\" << i2\n-      ASSERT_EQ(reverse_bits(mask), revm1|revm2) << STUFF;\n-      ASSERT_EQ((T)~reverse_bits((T)~mask), revm1|revm2) << STUFF;\n-    }\n-  }\n-}\n-\n-TEST_VM(utilities, moveBits) {\n-  test_moveBits<int64_t>();\n-  test_moveBits<uint64_t>();\n-  test_moveBits<int32_t>();\n-  test_moveBits<uint32_t>();\n-  test_moveBits<int16_t>();\n-  test_moveBits<uint16_t>();\n-  test_moveBits<int8_t>();\n-  test_moveBits<uint8_t>();\n-}\n-\n-\/\/ Here is some object code to look at if we want to do a manual\n-\/\/ study.  One could find the build file named test_moveBits.o.cmdline\n-\/\/ and hand-edit the command line to produce assembly code in\n-\/\/ test_moveBits.s.\n-\/\/\n-\/\/ Or, given the two empty \"fence functions\", one could do a\n-\/\/ quick scan like this:\n-\/\/\n-\/\/ $ objdump -D $(find build\/*release -name test_moveBits.o) \\\n-\/\/   | sed -n '\/start_code_quality\/,$p;\/end_code_quality\/q' \\\n-\/\/   | egrep -B10 bswap  # or grep -B20 cfi_endproc\n-\n-void start_code_quality_moveBits() { }\n-\n-int32_t code_quality_reverse_bits_32(int32_t x) {\n-  return reverse_bits(x);\n-}\n-\n-int32_t code_quality_reverse_bytes_32(int32_t x) {\n-  return byteswap(x);\n-}\n-\n-int64_t code_quality_reverse_bits_64(int64_t x) {\n-  return reverse_bits(x);\n-}\n-\n-int64_t code_quality_reverse_bytes_64(int64_t x) {\n-  return byteswap(x);\n-}\n","filename":"test\/hotspot\/gtest\/utilities\/test_moveBits.cpp","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/reverse_bits.hpp\"\n+#include \"unittest.hpp\"\n+\n+template<typename T>\n+static inline void test_reverse_bits() {\n+  const int  NBIT = sizeof(T) * 8;\n+  const bool IS_U = (T)-1 > 0;\n+  const int XOR_REV_BITS = (NBIT - 1);\n+  ASSERT_EQ(reverse_bits((T)0), (T)0);\n+  ASSERT_EQ(reverse_bits((T)-1), (T)-1);\n+  for (int i1 = 0; i1 < NBIT; i1++) {\n+    T mask1 = (T)1 << i1;\n+    T revm1 = (T)1 << (i1 ^ XOR_REV_BITS);\n+    for (int i2 = 0; i2 <= i1; i2++) {\n+      T mask2 = (T)1 << i2;\n+      T revm2 = (T)1 << (i2 ^ XOR_REV_BITS);\n+      T mask = mask1|mask2;\n+#define STUFF (IS_U?\"u\":\"s\") << NBIT << \"@\" << i1 << \",\" << i2\n+      ASSERT_EQ(reverse_bits(mask), revm1|revm2) << STUFF;\n+      ASSERT_EQ((T)~reverse_bits((T)~mask), revm1|revm2) << STUFF;\n+    }\n+  }\n+}\n+\n+TEST_VM(utilities, reverse_bits) {\n+  test_reverse_bits<int64_t>();\n+  test_reverse_bits<uint64_t>();\n+  test_reverse_bits<int32_t>();\n+  test_reverse_bits<uint32_t>();\n+  test_reverse_bits<int16_t>();\n+  test_reverse_bits<uint16_t>();\n+  test_reverse_bits<int8_t>();\n+  test_reverse_bits<uint8_t>();\n+}\n+\n+\/\/ Here is some object code to look at if we want to do a manual\n+\/\/ study.  One could find the build file named test_reverse_bits.o.cmdline\n+\/\/ and hand-edit the command line to produce assembly code in\n+\/\/ test_reverse_bits.s.\n+\/\/\n+\/\/ Or, given the two empty \"fence functions\", one could do a\n+\/\/ quick scan like this:\n+\/\/\n+\/\/ $ objdump -D $(find build\/*release -name test_reverse_bits.o) \\\n+\/\/   | sed -n '\/start_code_quality\/,$p;\/end_code_quality\/q' \\\n+\/\/   | egrep -B10 bswap  # or grep -B20 cfi_endproc\n+\n+void start_code_quality_reverse_bits() { }\n+\n+int32_t code_quality_reverse_bits_32(int32_t x) {\n+  return reverse_bits(x);\n+}\n+\n+int64_t code_quality_reverse_bits_64(int64_t x) {\n+  return reverse_bits(x);\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_reverse_bits.cpp","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"}]}