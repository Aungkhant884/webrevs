{"files":[{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"utilities\/byteswap.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/moveBits.hpp\"\n-#include \"unittest.hpp\"\n-\n-template<typename T>\n-static inline void test_moveBits() {\n-  const int  NBIT = sizeof(T) * 8;\n-  const bool IS_U = (T)-1 > 0;\n-  const int XOR_REV_BITS = (NBIT - 1);\n-  const int XOR_REV_BITS_IN_BYTES = 7;  \/\/ only flip position in byte\n-  const int XOR_REV_BYTES = XOR_REV_BITS ^ XOR_REV_BITS_IN_BYTES;\n-  printf(\"testing %sint%d_t...\\n\", IS_U ? \"u\" : \"\", NBIT);\n-  ASSERT_EQ(reverse_bits((T)0), (T)0);\n-  ASSERT_EQ(reverse_bits((T)-1), (T)-1);\n-  ASSERT_EQ(byteswap<T>((T)0), (T)0);\n-  ASSERT_EQ(byteswap<T>((T)-1), (T)-1);\n-  for (int i1 = 0; i1 < NBIT; i1++) {\n-    T mask1 = (T)1 << i1;\n-    T revm1 = (T)1 << (i1 ^ XOR_REV_BITS);\n-    T rbym1 = (T)1 << (i1 ^ XOR_REV_BYTES);\n-    T ribm1 = (T)1 << (i1 ^ XOR_REV_BITS_IN_BYTES);\n-    for (int i2 = 0; i2 <= i1; i2++) {\n-      T mask2 = (T)1 << i2;\n-      T revm2 = (T)1 << (i2 ^ XOR_REV_BITS);\n-      T rbym2 = (T)1 << (i2 ^ XOR_REV_BYTES);\n-      T ribm2 = (T)1 << (i2 ^ XOR_REV_BITS_IN_BYTES);\n-      T mask = mask1|mask2;\n-#define STUFF (IS_U?\"u\":\"s\") << NBIT << \"@\" << i1 << \",\" << i2\n-      ASSERT_EQ(reverse_bits(mask), revm1|revm2) << STUFF;\n-      ASSERT_EQ((T)~reverse_bits((T)~mask), revm1|revm2) << STUFF;\n-      ASSERT_EQ(byteswap<T>(mask), rbym1|rbym2) << STUFF;\n-      ASSERT_EQ((T)~byteswap<T>((T)~mask), rbym1|rbym2) << STUFF;\n-    }\n-  }\n-}\n-\n-TEST_VM(opto, moveBits) {\n-  test_moveBits<int64_t>();\n-  test_moveBits<uint64_t>();\n-  test_moveBits<int32_t>();\n-  test_moveBits<uint32_t>();\n-  test_moveBits<int16_t>();\n-  test_moveBits<uint16_t>();\n-  test_moveBits<int8_t>();\n-  test_moveBits<uint8_t>();\n-}\n-\n-\/\/ Here is some object code to look at if we want to do a manual\n-\/\/ study.  One could find the build file named test_moveBits.o.cmdline\n-\/\/ and hand-edit the command line to produce assembly code in\n-\/\/ test_moveBits.s.\n-\/\/\n-\/\/ Or, given the two empty \"fence functions\", one could do a\n-\/\/ quick scan like this:\n-\/\/\n-\/\/ $ objdump -D $(find build\/*release -name test_moveBits.o) \\\n-\/\/   | sed -n '\/start_code_quality\/,$p;\/end_code_quality\/q' \\\n-\/\/   | egrep -B10 bswap  # or grep -B20 cfi_endproc\n-\n-void start_code_quality_moveBits() { }\n-\n-int32_t code_quality_reverse_bits_32(int32_t x) {\n-  return reverse_bits(x);\n-}\n-\n-int32_t code_quality_reverse_bytes_32(int32_t x) {\n-  return byteswap(x);\n-}\n-\n-int64_t code_quality_reverse_bits_64(int64_t x) {\n-  return reverse_bits(x);\n-}\n-\n-int64_t code_quality_reverse_bytes_64(int64_t x) {\n-  return byteswap(x);\n-}\n","filename":"test\/hotspot\/gtest\/opto\/test_moveBits.cpp","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"utilities\/byteswap.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"unittest.hpp\"\n+\n+template<typename T>\n+static inline void test_byteswap() {\n+  const int  NBIT = sizeof(T) * 8;\n+  const bool IS_U = (T)-1 > 0;\n+  const int XOR_REV_BITS = (NBIT - 1);\n+  const int XOR_REV_BITS_IN_BYTES = 7;  \/\/ only flip position in byte\n+  const int XOR_REV_BYTES = XOR_REV_BITS ^ XOR_REV_BITS_IN_BYTES;\n+  ASSERT_EQ(byteswap<T>((T)0), (T)0);\n+  ASSERT_EQ(byteswap<T>((T)-1), (T)-1);\n+  for (int i1 = 0; i1 < NBIT; i1++) {\n+    T mask1 = (T)1 << i1;\n+    T rbym1 = (T)1 << (i1 ^ XOR_REV_BYTES);\n+    for (int i2 = 0; i2 <= i1; i2++) {\n+      T mask2 = (T)1 << i2;\n+      T rbym2 = (T)1 << (i2 ^ XOR_REV_BYTES);\n+      T mask = mask1|mask2;\n+#define STUFF (IS_U?\"u\":\"s\") << NBIT << \"@\" << i1 << \",\" << i2\n+      ASSERT_EQ(byteswap<T>(mask), rbym1|rbym2) << STUFF;\n+      ASSERT_EQ((T)~byteswap<T>((T)~mask), rbym1|rbym2) << STUFF;\n+    }\n+  }\n+}\n+\n+TEST_VM(utilities, byteswap) {\n+  test_byteswap<int64_t>();\n+  test_byteswap<uint64_t>();\n+  test_byteswap<int32_t>();\n+  test_byteswap<uint32_t>();\n+  test_byteswap<int16_t>();\n+  test_byteswap<uint16_t>();\n+  test_byteswap<int8_t>();\n+  test_byteswap<uint8_t>();\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_byteswap.cpp","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/moveBits.hpp\"\n+#include \"unittest.hpp\"\n+\n+template<typename T>\n+static inline void test_moveBits() {\n+  const int  NBIT = sizeof(T) * 8;\n+  const bool IS_U = (T)-1 > 0;\n+  const int XOR_REV_BITS = (NBIT - 1);\n+  ASSERT_EQ(reverse_bits((T)0), (T)0);\n+  ASSERT_EQ(reverse_bits((T)-1), (T)-1);\n+  for (int i1 = 0; i1 < NBIT; i1++) {\n+    T mask1 = (T)1 << i1;\n+    T revm1 = (T)1 << (i1 ^ XOR_REV_BITS);\n+    for (int i2 = 0; i2 <= i1; i2++) {\n+      T mask2 = (T)1 << i2;\n+      T revm2 = (T)1 << (i2 ^ XOR_REV_BITS);\n+      T mask = mask1|mask2;\n+#define STUFF (IS_U?\"u\":\"s\") << NBIT << \"@\" << i1 << \",\" << i2\n+      ASSERT_EQ(reverse_bits(mask), revm1|revm2) << STUFF;\n+      ASSERT_EQ((T)~reverse_bits((T)~mask), revm1|revm2) << STUFF;\n+    }\n+  }\n+}\n+\n+TEST_VM(utilities, moveBits) {\n+  test_moveBits<int64_t>();\n+  test_moveBits<uint64_t>();\n+  test_moveBits<int32_t>();\n+  test_moveBits<uint32_t>();\n+  test_moveBits<int16_t>();\n+  test_moveBits<uint16_t>();\n+  test_moveBits<int8_t>();\n+  test_moveBits<uint8_t>();\n+}\n+\n+\/\/ Here is some object code to look at if we want to do a manual\n+\/\/ study.  One could find the build file named test_moveBits.o.cmdline\n+\/\/ and hand-edit the command line to produce assembly code in\n+\/\/ test_moveBits.s.\n+\/\/\n+\/\/ Or, given the two empty \"fence functions\", one could do a\n+\/\/ quick scan like this:\n+\/\/\n+\/\/ $ objdump -D $(find build\/*release -name test_moveBits.o) \\\n+\/\/   | sed -n '\/start_code_quality\/,$p;\/end_code_quality\/q' \\\n+\/\/   | egrep -B10 bswap  # or grep -B20 cfi_endproc\n+\n+void start_code_quality_moveBits() { }\n+\n+int32_t code_quality_reverse_bits_32(int32_t x) {\n+  return reverse_bits(x);\n+}\n+\n+int32_t code_quality_reverse_bytes_32(int32_t x) {\n+  return byteswap(x);\n+}\n+\n+int64_t code_quality_reverse_bits_64(int64_t x) {\n+  return reverse_bits(x);\n+}\n+\n+int64_t code_quality_reverse_bytes_64(int64_t x) {\n+  return byteswap(x);\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_moveBits.cpp","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"}]}