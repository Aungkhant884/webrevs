{"files":[{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/byteswap.hpp\"\n@@ -77,6 +78,0 @@\n-#ifndef VM_LITTLE_ENDIAN\n-static void reverse_bytes(juint &w) {\n-  w = ((w >> 24) & 0xFF) | (((w >> 16) & 0xFF) << 8) | (((w >> 8) & 0xFF) << 16) | ((w & 0xFF) << 24);\n-}\n-#endif\n-\n@@ -115,4 +110,4 @@\n-      reverse_bytes(a);\n-      reverse_bytes(b);\n-      reverse_bytes(c);\n-      reverse_bytes(d);\n+      a = byteswap<juint>(a);\n+      b = byteswap<juint>(b);\n+      c = byteswap<juint>(c);\n+      d = byteswap<juint>(d);\n","filename":"src\/hotspot\/cpu\/ppc\/stubRoutines_ppc_64.cpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Google and\/or its affiliates. All rights reserved.\n@@ -29,0 +30,2 @@\n+#include \"utilities\/byteswap.hpp\"\n+#include \"utilities\/debug.hpp\"\n@@ -31,0 +34,1 @@\n+#include <cstdint>\n@@ -33,0 +37,4 @@\n+\/\/ T reverse_bits<T>(T)\n+\/\/\n+\/\/ Reverses the bits in the integral value of type T.\n+\n@@ -34,2 +42,17 @@\n-class ReverseBitsImpl {\n-  static const size_t NB = sizeof(T) * BitsPerByte;\n+using CanReverseBitsImpl = std::integral_constant<bool, (std::is_integral<T>::value &&\n+                                                         (sizeof(T) == 1 ||\n+                                                          sizeof(T) == 2 ||\n+                                                          sizeof(T) == 4 ||\n+                                                          sizeof(T) == 8))>;\n+\n+template <typename T, size_t N = sizeof(T)>\n+struct ReverseBitsImpl;\n+\n+template <typename T, ENABLE_IF(CanReverseBitsImpl<T>::value)>\n+ALWAYSINLINE T reverse_bits(T x) {\n+  return ReverseBitsImpl<T>{}(x);\n+}\n+\n+\/*****************************************************************************\n+ * Fallback\n+ *****************************************************************************\/\n@@ -37,2 +60,4 @@\n-  static_assert((NB == 8) || (NB == 16) || (NB == 32) || (NB == 64),\n-                \"unsupported size\");\n+template <typename T>\n+struct ReverseBitsFallbackImpl {\n+ private:\n+  static constexpr size_t NB = sizeof(T) * BitsPerByte;\n@@ -43,5 +68,3 @@\n-  static const I rep_5555 = static_cast<I>(UCONST64(0x5555555555555555));\n-  static const I rep_3333 = static_cast<I>(UCONST64(0x3333333333333333));\n-  static const I rep_0F0F = static_cast<I>(UCONST64(0x0F0F0F0F0F0F0F0F));\n-  static const I rep_00FF = static_cast<I>(UCONST64(0x00FF00FF00FF00FF));\n-  static const I rep_FFFF = static_cast<I>(UCONST64(0x0000FFFF0000FFFF));\n+  static constexpr I rep_5555 = static_cast<I>(UINT64_C(0x5555555555555555));\n+  static constexpr I rep_3333 = static_cast<I>(UINT64_C(0x3333333333333333));\n+  static constexpr I rep_0F0F = static_cast<I>(UINT64_C(0x0F0F0F0F0F0F0F0F));\n@@ -49,1 +72,2 @@\n-public:\n+ public:\n+  STATIC_ASSERT(CanReverseBitsImpl<T>::value);\n@@ -51,1 +75,1 @@\n-  static constexpr T reverse_bits_in_bytes(T v) {\n+  ALWAYSINLINE T operator()(T v) const {\n@@ -53,1 +77,1 @@\n-    auto x = static_cast<I>(v);\n+    I x = static_cast<I>(v);\n@@ -57,1 +81,1 @@\n-    return static_cast<T>(x);\n+    return byteswap<T>(static_cast<T>(x));\n@@ -59,0 +83,1 @@\n+};\n@@ -60,17 +85,23 @@\n-  static constexpr T reverse_bytes(T v) {\n-    \/\/ Based on Hacker's Delight Section 7-1\n-    \/\/ NB: Compilers are good at recognizing byte-swap code and transforming\n-    \/\/ it into platform-specific instructions like x86 bswap.\n-    auto x = static_cast<I>(v);\n-    switch (NB) {\n-    case 64:\n-      \/\/ The use of NB\/2 rather than 32 avoids a warning in dead code when\n-      \/\/ I is uint32_t, because shifting a 32bit type by 32 is UB.\n-      x = (x << (NB\/2)) | (x >> (NB\/2));\n-    case 32:                    \/\/ fallthrough\n-      x = ((x & rep_FFFF) << 16) | ((x >> 16) & rep_FFFF);\n-    case 16:                    \/\/ fallthrough\n-      x = ((x & rep_00FF) << 8)  | ((x >> 8)  & rep_00FF);\n-    default:                    \/\/ fallthrough\n-      return static_cast<T>(x);\n-    }\n+\n+\/*****************************************************************************\n+ * GCC and compatible (including Clang)\n+ *****************************************************************************\/\n+#if defined(TARGET_COMPILER_gcc)\n+\n+\/\/ Default implementation for GCC-like compilers is the fallback. At the time of writing GCC does\n+\/\/ not have intrinsics for bit reversal while Clang does.\n+\n+template <typename T, size_t N>\n+struct ReverseBitsImpl final : public ReverseBitsFallbackImpl<T> {};\n+\n+#ifdef __has_builtin\n+\n+#if __has_builtin(__builtin_bitreverse8)\n+\n+template <typename T>\n+struct ReverseBitsImpl<T, 1> final {\n+  STATIC_ASSERT(CanReverseBitsImpl<T>::value);\n+  STATIC_ASSERT(sizeof(T) == 1);\n+\n+  ALWAYSINLINE T operator()(T v) const {\n+    return static_cast<T>(__builtin_bitreverse8(static_cast<uint8_t>(v)));\n@@ -80,5 +111,1 @@\n-\/\/ Performs byte reversal of an integral type up to 64 bits.\n-template <typename T, ENABLE_IF(std::is_integral<T>::value)>\n-constexpr T reverse_bytes(T x) {\n-  return ReverseBitsImpl<T>::reverse_bytes(x);\n-}\n+#endif \/\/ __has_builtin(__builtin_bitreverse8)\n@@ -86,6 +113,1 @@\n-\/\/ Performs bytewise bit reversal of each byte of an integral\n-\/\/ type up to 64 bits.\n-template <typename T, ENABLE_IF(std::is_integral<T>::value)>\n-constexpr T reverse_bits_in_bytes(T x) {\n-  return ReverseBitsImpl<T>::reverse_bits_in_bytes(x);\n-}\n+#if __has_builtin(__builtin_bitreverse16)\n@@ -93,5 +115,66 @@\n-\/\/ Performs full bit reversal an integral type up to 64 bits.\n-template <typename T, ENABLE_IF(std::is_integral<T>::value)>\n-constexpr T reverse_bits(T x) {\n-  return reverse_bytes(reverse_bits_in_bytes(x));\n-}\n+template <typename T>\n+struct ReverseBitsImpl<T, 2> final {\n+  STATIC_ASSERT(CanReverseBitsImpl<T>::value);\n+  STATIC_ASSERT(sizeof(T) == 2);\n+\n+  ALWAYSINLINE T operator()(T v) const {\n+    return static_cast<T>(__builtin_bitreverse16(static_cast<uint16_t>(v)));\n+  }\n+};\n+\n+#endif \/\/ __has_builtin(__builtin_bitreverse16)\n+\n+#if __has_builtin(__builtin_bitreverse32)\n+\n+template <typename T>\n+struct ReverseBitsImpl<T, 4> final {\n+  STATIC_ASSERT(CanReverseBitsImpl<T>::value);\n+  STATIC_ASSERT(sizeof(T) == 4);\n+\n+  ALWAYSINLINE T operator()(T v) const {\n+    return static_cast<T>(__builtin_bitreverse32(static_cast<uint32_t>(v)));\n+  }\n+};\n+\n+#endif \/\/ __has_builtin(__builtin_bitreverse32)\n+\n+#if __has_builtin(__builtin_bitreverse64)\n+\n+template <typename T>\n+struct ReverseBitsImpl<T, 8> final {\n+  STATIC_ASSERT(CanReverseBitsImpl<T>::value);\n+  STATIC_ASSERT(sizeof(T) == 8);\n+\n+  ALWAYSINLINE T operator()(T v) const {\n+    return static_cast<T>(__builtin_bitreverse64(static_cast<uint64_t>(v)));\n+  }\n+};\n+\n+#endif \/\/ __has_builtin(__builtin_bitreverse64)\n+\n+#endif \/\/ __has_builtin\n+\n+\/*****************************************************************************\n+ * Microsoft Visual Studio\n+ *****************************************************************************\/\n+#elif defined(TARGET_COMPILER_visCPP)\n+\n+template <typename T, size_t N>\n+struct ReverseBitsImpl final : public ReverseBitsFallbackImpl<T> {};\n+\n+\/*****************************************************************************\n+ * IBM XL C\/C++\n+ *****************************************************************************\/\n+#elif defined(TARGET_COMPILER_xlc)\n+\n+template <typename T, size_t N>\n+struct ReverseBitsImpl final : public ReverseBitsFallbackImpl<T> {};\n+\n+\/*****************************************************************************\n+ * Unknown toolchain\n+ *****************************************************************************\/\n+#else\n+\n+#error Unknown toolchain.\n+\n+#endif\n","filename":"src\/hotspot\/share\/utilities\/moveBits.hpp","additions":129,"deletions":46,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"utilities\/byteswap.hpp\"\n@@ -30,32 +31,33 @@\n-template<typename T>\n-inline void test_moveBits() {\n-  const int  NBIT = sizeof(T) * 8;\n-  const bool IS_U = (T)-1 > 0;\n-  const int XOR_REV_BITS = (NBIT - 1);\n-  const int XOR_REV_BITS_IN_BYTES = 7;  \/\/ only flip position in byte\n-  const int XOR_REV_BYTES = XOR_REV_BITS ^ XOR_REV_BITS_IN_BYTES;\n-  printf(\"testing %sint%d_t...\\n\", IS_U ? \"u\" : \"\", NBIT);\n-  ASSERT_EQ(reverse_bits((T)0), (T)0);\n-  ASSERT_EQ(reverse_bits((T)-1), (T)-1);\n-  ASSERT_EQ(reverse_bytes((T)0), (T)0);\n-  ASSERT_EQ(reverse_bytes((T)-1), (T)-1);\n-  ASSERT_EQ(reverse_bits_in_bytes((T)0), (T)0);\n-  ASSERT_EQ(reverse_bits_in_bytes((T)-1), (T)-1);\n-  for (int i1 = 0; i1 < NBIT; i1++) {\n-    T mask1 = (T)1 << i1;\n-    T revm1 = (T)1 << (i1 ^ XOR_REV_BITS);\n-    T rbym1 = (T)1 << (i1 ^ XOR_REV_BYTES);\n-    T ribm1 = (T)1 << (i1 ^ XOR_REV_BITS_IN_BYTES);\n-    for (int i2 = 0; i2 <= i1; i2++) {\n-      T mask2 = (T)1 << i2;\n-      T revm2 = (T)1 << (i2 ^ XOR_REV_BITS);\n-      T rbym2 = (T)1 << (i2 ^ XOR_REV_BYTES);\n-      T ribm2 = (T)1 << (i2 ^ XOR_REV_BITS_IN_BYTES);\n-      T mask = mask1|mask2;\n-#define STUFF (IS_U?\"u\":\"s\") << NBIT << \"@\" << i1 << \",\" << i2\n-      ASSERT_EQ(reverse_bits(mask), revm1|revm2) << STUFF;\n-      ASSERT_EQ((T)~reverse_bits((T)~mask), revm1|revm2) << STUFF;\n-      ASSERT_EQ(reverse_bytes(mask), rbym1|rbym2) << STUFF;\n-      ASSERT_EQ((T)~reverse_bytes((T)~mask), rbym1|rbym2) << STUFF;\n-      ASSERT_EQ(reverse_bits_in_bytes(mask), ribm1|ribm2) << STUFF;\n-      ASSERT_EQ((T)~reverse_bits_in_bytes((T)~mask), ribm1|ribm2) << STUFF;\n+class MoveBitsTest final {\n+ public:\n+  template<typename T>\n+  static inline void test_moveBits() {\n+    using ReverseBitsImpl<T>::reverse_bytes;\n+\n+    const int  NBIT = sizeof(T) * 8;\n+    const bool IS_U = (T)-1 > 0;\n+    const int XOR_REV_BITS = (NBIT - 1);\n+    const int XOR_REV_BITS_IN_BYTES = 7;  \/\/ only flip position in byte\n+    const int XOR_REV_BYTES = XOR_REV_BITS ^ XOR_REV_BITS_IN_BYTES;\n+    printf(\"testing %sint%d_t...\\n\", IS_U ? \"u\" : \"\", NBIT);\n+    ASSERT_EQ(reverse_bits((T)0), (T)0);\n+    ASSERT_EQ(reverse_bits((T)-1), (T)-1);\n+    ASSERT_EQ(byteswap<T>((T)0), (T)0);\n+    ASSERT_EQ(byteswap<T>((T)-1), (T)-1);\n+    for (int i1 = 0; i1 < NBIT; i1++) {\n+      T mask1 = (T)1 << i1;\n+      T revm1 = (T)1 << (i1 ^ XOR_REV_BITS);\n+      T rbym1 = (T)1 << (i1 ^ XOR_REV_BYTES);\n+      T ribm1 = (T)1 << (i1 ^ XOR_REV_BITS_IN_BYTES);\n+      for (int i2 = 0; i2 <= i1; i2++) {\n+        T mask2 = (T)1 << i2;\n+        T revm2 = (T)1 << (i2 ^ XOR_REV_BITS);\n+        T rbym2 = (T)1 << (i2 ^ XOR_REV_BYTES);\n+        T ribm2 = (T)1 << (i2 ^ XOR_REV_BITS_IN_BYTES);\n+        T mask = mask1|mask2;\n+  #define STUFF (IS_U?\"u\":\"s\") << NBIT << \"@\" << i1 << \",\" << i2\n+        ASSERT_EQ(reverse_bits(mask), revm1|revm2) << STUFF;\n+        ASSERT_EQ((T)~reverse_bits((T)~mask), revm1|revm2) << STUFF;\n+        ASSERT_EQ(byteswap<T>(mask), rbym1|rbym2) << STUFF;\n+        ASSERT_EQ((T)~byteswap<T>((T)~mask), rbym1|rbym2) << STUFF;\n+      }\n@@ -64,1 +66,1 @@\n-}\n+};\n@@ -96,5 +98,1 @@\n-  return reverse_bytes(x);\n-}\n-\n-int32_t code_quality_reverse_bits_in_bytes_32(int32_t x) {\n-  return reverse_bits_in_bytes(x);\n+  return byteswap(x);\n@@ -108,5 +106,1 @@\n-  return reverse_bytes(x);\n-}\n-\n-int64_t code_quality_reverse_bits_in_bytes_64(int64_t x) {\n-  return reverse_bits_in_bytes(x);\n+  return byteswap(x);\n","filename":"test\/hotspot\/gtest\/opto\/test_moveBits.cpp","additions":37,"deletions":43,"binary":false,"changes":80,"status":"modified"}]}