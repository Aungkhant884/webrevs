{"files":[{"patch":"@@ -46,1 +46,5 @@\n-\/\/ Reserve space for a flush token, so 'push_back(Token)' always succeeds.\n+\/\/ LogDecorator::None applies to 'constant initialization' because of its constexpr constructor.\n+const LogDecorations& AsyncLogWriter::None = LogDecorations(LogLevel::Warning, LogTagSetMapping<LogTag::__NO_TAG>::tagset(),\n+                                      LogDecorators::None);\n+\n+\/\/ Reserve space for a flush token, so 'push_flush_token' always succeeds.\n@@ -48,3 +52,2 @@\n-  assert(capacity > (AsyncLogWriter::Token.size()), \"AsyncLogBuffer is too small!\");\n-  _buf = NEW_C_HEAP_ARRAY_RETURN_NULL(char, capacity, mtLogging);\n-  _capacity = capacity - (Token.size());\n+  _buf = NEW_C_HEAP_ARRAY(char, capacity, mtLogging);\n+  _capacity = capacity - AsyncLogWriter::TOKEN_SIZE;\n@@ -57,6 +60,3 @@\n-bool AsyncLogWriter::Buffer::is_valid() const {\n-  return _capacity > 0 && _buf != nullptr;\n-}\n-\n-bool AsyncLogWriter::Buffer::push_back(const AsyncLogMessage& msg) {\n-  size_t sz = msg.size();\n+bool AsyncLogWriter::Buffer::push_back(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg) {\n+  size_t len = strlen(msg) + 1; \/\/ including trailing zero\n+  int sz = align_up(sizeof(Message) + len, sizeof(void*));\n@@ -64,10 +64,2 @@\n-  if (_pos + sz <= _capacity || (&msg == &AsyncLogWriter::Token)) {\n-    memcpy(_buf + _pos, &msg, sizeof(AsyncLogMessage));\n-    char* dest = _buf + _pos + sizeof(AsyncLogMessage);\n-    if (msg.message() != nullptr) {\n-      strcpy(dest, msg.message());\n-    } else {\n-      dest = nullptr;\n-    }\n-    auto p = reinterpret_cast<AsyncLogMessage*>(_buf + _pos);\n-    p->set_message(dest);\n+  if (_pos + sz <= _capacity || output == nullptr\/*token*\/) {\n+    new(_buf + _pos) Message(output, decorations, msg);\n@@ -81,2 +73,8 @@\n-AsyncLogMessage* AsyncLogWriter::Buffer::Iterator::next() {\n-  auto msg = static_cast<AsyncLogMessage*>(raw_ptr());\n+void AsyncLogWriter::Buffer::push_flush_token() {\n+  bool result = push_back(nullptr, AsyncLogWriter::None, \"\");\n+  assert(result, \"fail to enqueue the flush token\");\n+}\n+\n+AsyncLogWriter::Message* AsyncLogWriter::Buffer::Iterator::next() {\n+  assert(_curr < _buf._pos, \"sanity check\");\n+  auto msg = reinterpret_cast<Message*>(_buf._buf + _curr);\n@@ -88,4 +86,4 @@\n-\/\/ LogDecorator::None applies to 'constant initialization' because of its constexpr constructor.\n-const LogDecorations& AsyncLogWriter::None = LogDecorations(LogLevel::Warning, LogTagSetMapping<LogTag::__NO_TAG>::tagset(),\n-                                      LogDecorators::None);\n-const AsyncLogMessage& AsyncLogWriter::Token = AsyncLogMessage(nullptr, None, nullptr);\n+void AsyncLogWriter::enqueue_locked(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg) {\n+  \/\/ To save space and streamline execution, we just ignore null message.\n+  \/\/ client should use \"\" instead.\n+  if (msg == nullptr) return;\n@@ -93,2 +91,1 @@\n-void AsyncLogWriter::enqueue_locked(const AsyncLogMessage& msg) {\n-  if (!_buffer->push_back(msg)) {\n+  if (!_buffer->push_back(output, decorations, msg)) {\n@@ -96,1 +93,1 @@\n-    uint32_t* counter = _stats.put_if_absent(msg.output(), 0, &p_created);\n+    uint32_t* counter = _stats.put_if_absent(output, 0, &p_created);\n@@ -106,6 +103,2 @@\n-  AsyncLogMessage m(&output, decorations, msg);\n-\n-  { \/\/ critical area\n-    AsyncLogLocker locker;\n-    enqueue_locked(m);\n-  }\n+  AsyncLogLocker locker;\n+  enqueue_locked(&output, decorations, msg);\n@@ -120,2 +113,1 @@\n-    AsyncLogMessage m(&output, msg_iterator.decorations(), msg_iterator.message());\n-    enqueue_locked(m);\n+    enqueue_locked(&output, msg_iterator.decorations(), msg_iterator.message());\n@@ -135,8 +127,0 @@\n-  if (_buffer->is_valid() && _buffer_staging->is_valid()) {\n-    log_info(logging)(\"AsyncLogBuffer estimates memory use: \" SIZE_FORMAT \" bytes\", size * 2);\n-  } else {\n-    log_warning(logging)(\"AsyncLogging failed to create buffer Objects. Falling back to synchronous logging.\");\n-    delete _buffer;\n-    delete _buffer_staging;\n-    return;\n-  }\n@@ -144,0 +128,1 @@\n+  log_info(logging)(\"AsyncLogBuffer estimates memory use: \" SIZE_FORMAT \" bytes\", size * 2);\n@@ -153,1 +138,2 @@\n-  using Map = ResourceHashtable<LogFileStreamOutput*, uint32_t,\n+  \/\/ Similar to AsyncLogMap but on resource_area\n+  ResourceHashtable<LogFileStreamOutput*, uint32_t,\n@@ -155,2 +141,1 @@\n-                          mtLogging>;\n-  Map snapshot;\n+                          mtLogging> snapshot;\n@@ -159,1 +144,1 @@\n-  { \/\/ critical region\n+  {\n@@ -180,2 +165,1 @@\n-    AsyncLogMessage* e = it.next();\n-    const char* msg = e->message();\n+    Message* e = it.next();\n@@ -183,3 +167,3 @@\n-    if (msg != nullptr) {\n-      e->output()->write_blocking(e->decorations(), msg);\n-    } else if (e->output() == nullptr) {\n+    if (!e->is_token()){\n+      e->output()->write_blocking(e->decorations(), e->message());\n+    } else {\n@@ -259,2 +243,1 @@\n-      bool result = _instance->_buffer->push_back(Token);\n-      assert(result, \"fail to enqueue the flush token!\");\n+      _instance->_buffer->push_flush_token();\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":39,"deletions":56,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-\/\/ Forward declaration\n@@ -37,27 +36,0 @@\n-\n-class AsyncLogMessage {\n-  LogFileStreamOutput* _output;\n-  const char* _message;\n-  const LogDecorations _decorations;\n-\n-public:\n-  AsyncLogMessage(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg)\n-    : _output(output), _message(msg), _decorations(decorations) {}\n-\n-  size_t size() const {\n-    constexpr size_t size = align_up(sizeof(*this), sizeof(void*));\n-    return _message != nullptr ? align_up(size + strlen(_message) + 1, sizeof(void*)): size;\n-  }\n-\n-  LogFileStreamOutput* output() const { return _output; }\n-  const LogDecorations& decorations() const { return _decorations; }\n-  void set_message(const char* msg) { _message = msg; }\n-  const char* message() const { return _message; }\n-};\n-\n-typedef ResourceHashtable<LogFileStreamOutput*,\n-                          uint32_t,\n-                          17, \/*table_size*\/\n-                          ResourceObj::C_HEAP,\n-                          mtLogging> AsyncLogMap;\n-\n@@ -86,1 +58,0 @@\n-  class AsyncLogLocker;\n@@ -88,0 +59,32 @@\n+  class AsyncLogLocker;\n+  using AsyncLogMap = ResourceHashtable<LogFileStreamOutput*,\n+                          uint32_t,\n+                          17, \/*table_size*\/\n+                          ResourceObj::C_HEAP,\n+                          mtLogging>;\n+  class Message {\n+    LogFileStreamOutput* const _output;\n+    const LogDecorations _decorations;\n+\n+   public:\n+    \/\/ only-valid for in-place new!\n+    Message(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg)\n+      : _output(output), _decorations(decorations) {\n+      assert(msg != nullptr, \"c-string message can not be null!\");\n+      PRAGMA_STRINGOP_OVERFLOW_IGNORED\n+      strcpy(reinterpret_cast<char* >(this+1), msg);\n+    }\n+\n+    size_t size() const {\n+      size_t len = strlen(message()) + 1;\n+      return align_up(sizeof(*this) + len, sizeof(void*));\n+    }\n+\n+    bool is_token() const { return _output == nullptr; }\n+    LogFileStreamOutput* output() const { return _output; }\n+    const LogDecorations& decorations() const { return _decorations; }\n+    const char* message() const { return reinterpret_cast<const char *>(this+1); }\n+  };\n+\n+  \/\/ A flush TOKEN is Message(nullptr, None, \"\");\n+  static const size_t TOKEN_SIZE = {align_up(sizeof(Message) + 1, sizeof(void*))};\n@@ -98,3 +101,2 @@\n-    bool is_valid() const;\n-\n-    bool push_back(const AsyncLogMessage& msg);\n+    void push_flush_token();\n+    bool push_back(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg);\n@@ -115,5 +117,0 @@\n-      void* raw_ptr() const {\n-        assert(_curr < _buf._pos, \"sanity check\");\n-        return _buf._buf + _curr;\n-      }\n-\n@@ -127,1 +124,1 @@\n-      AsyncLogMessage* next();\n+      Message* next();\n@@ -148,1 +145,0 @@\n-  static const AsyncLogMessage& Token;\n@@ -151,1 +147,1 @@\n-  void enqueue_locked(const AsyncLogMessage& msg);\n+  void enqueue_locked(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg);\n@@ -168,0 +164,1 @@\n+\n@@ -175,1 +172,0 @@\n-\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":37,"deletions":41,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -1974,1 +1974,1 @@\n-  product(size_t, AsyncLogBufferSize, 4*M,                                  \\\n+  product(size_t, AsyncLogBufferSize, 2*M,                                  \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}