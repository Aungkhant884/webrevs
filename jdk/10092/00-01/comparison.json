{"files":[{"patch":"@@ -47,2 +47,3 @@\n-AsyncLogWriter::Buffer::Buffer(char* buffer, size_t capacity) : _pos(0), _buf(buffer) {\n-  assert(capacity >= (AsyncLogWriter::Token.size()), \"AsyncLogBuffer is too small!\");\n+AsyncLogWriter::Buffer::Buffer(size_t capacity) : _pos(0) {\n+  assert(capacity > (AsyncLogWriter::Token.size()), \"AsyncLogBuffer is too small!\");\n+  _buf = NEW_C_HEAP_ARRAY_RETURN_NULL(char, capacity, mtLogging);\n@@ -52,0 +53,8 @@\n+AsyncLogWriter::Buffer::~Buffer() {\n+  FREE_C_HEAP_ARRAY(char, _buf);\n+}\n+\n+bool AsyncLogWriter::Buffer::is_valid() const {\n+  return _capacity > 0 && _buf != nullptr;\n+}\n+\n@@ -79,0 +88,1 @@\n+\/\/ LogDecorator::None applies to 'constant initialization' because of its constexpr constructor.\n@@ -81,2 +91,0 @@\n-\/\/ Note: there is an initializer order issue here. C++ cannot guarantee that 'None' is initialized before Token!\n-\/\/ It is okay because we expect None is zero'ed anyway.\n@@ -125,15 +133,4 @@\n-  char* buf0 = static_cast<char* >(os::malloc(size, mtLogging));\n-  char* buf1 = static_cast<char* >(os::malloc(size, mtLogging));\n-  if (buf0 != nullptr && buf1 != nullptr) {\n-    _buffer = new Buffer(buf0, size);\n-    _buffer_staging = new Buffer(buf1, size);\n-    if (_buffer != nullptr && _buffer_staging != nullptr) {\n-      log_info(logging)(\"AsyncLogBuffer estimates memory use: \" SIZE_FORMAT \" bytes\", size * 2);\n-    } else {\n-      log_warning(logging)(\"AsyncLogging failed to create buffer Objects. Falling back to synchronous logging.\");\n-      delete _buffer;\n-      delete _buffer_staging;\n-      os::free(buf0);\n-      os::free(buf1);\n-      return;\n-    }\n+  _buffer = new Buffer(size);\n+  _buffer_staging = new Buffer(size);\n+  if (_buffer->is_valid() && _buffer_staging->is_valid()) {\n+    log_info(logging)(\"AsyncLogBuffer estimates memory use: \" SIZE_FORMAT \" bytes\", size * 2);\n@@ -141,5 +138,3 @@\n-    log_warning(logging)(\"AsyncLogging failed to create buffers. Falling back to synchronous logging.\");\n-\n-    if (buf0 != nullptr) {\n-      os::free(buf0);\n-    }\n+    log_warning(logging)(\"AsyncLogging failed to create buffer Objects. Falling back to synchronous logging.\");\n+    delete _buffer;\n+    delete _buffer_staging;\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":19,"deletions":24,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+  friend class AsyncLogTest;\n@@ -90,1 +91,1 @@\n-    char* const _buf;\n+    char* _buf;\n@@ -94,1 +95,4 @@\n-    Buffer(char* buffer, size_t capacity);\n+    Buffer(size_t capacity);\n+    ~Buffer();\n+\n+    bool is_valid() const;\n@@ -126,1 +130,1 @@\n-    Iterator iterator() {\n+    Iterator iterator() const {\n@@ -162,0 +166,2 @@\n+  \/\/ for testing-only\n+  size_t throttle_buffers(size_t newsize);\n@@ -170,2 +176,0 @@\n-  \/\/ for testing-only\n-  size_t throttle_buffers(size_t newsize);\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -39,2 +39,2 @@\n-const LogDecorators LogDecorators::None = LogDecorators(0);\n-const LogDecorators LogDecorators::All  = LogDecorators(AllBitmask<time_decorator>::_value);\n+const LogDecorators LogDecorators::None = {0};\n+const LogDecorators LogDecorators::All = {AllBitmask<time_decorator>::_value};\n","filename":"src\/hotspot\/share\/logging\/logDecorators.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  LogDecorators(uint mask) : _decorators(mask) {\n+  constexpr LogDecorators(uint mask) : _decorators(mask) {\n","filename":"src\/hotspot\/share\/logging\/logDecorators.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}