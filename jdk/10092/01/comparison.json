{"files":[{"patch":"@@ -30,0 +30,1 @@\n+#include \"memory\/resourceArea.hpp\"\n@@ -45,0 +46,47 @@\n+\/\/ Reserve space for a flush token, so 'push_back(Token)' always succeeds.\n+AsyncLogWriter::Buffer::Buffer(size_t capacity) : _pos(0) {\n+  assert(capacity > (AsyncLogWriter::Token.size()), \"AsyncLogBuffer is too small!\");\n+  _buf = NEW_C_HEAP_ARRAY_RETURN_NULL(char, capacity, mtLogging);\n+  _capacity = capacity - (Token.size());\n+}\n+\n+AsyncLogWriter::Buffer::~Buffer() {\n+  FREE_C_HEAP_ARRAY(char, _buf);\n+}\n+\n+bool AsyncLogWriter::Buffer::is_valid() const {\n+  return _capacity > 0 && _buf != nullptr;\n+}\n+\n+bool AsyncLogWriter::Buffer::push_back(const AsyncLogMessage& msg) {\n+  size_t sz = msg.size();\n+\n+  if (_pos + sz <= _capacity || (&msg == &AsyncLogWriter::Token)) {\n+    memcpy(_buf + _pos, &msg, sizeof(AsyncLogMessage));\n+    char* dest = _buf + _pos + sizeof(AsyncLogMessage);\n+    if (msg.message() != nullptr) {\n+      strcpy(dest, msg.message());\n+    } else {\n+      dest = nullptr;\n+    }\n+    auto p = reinterpret_cast<AsyncLogMessage*>(_buf + _pos);\n+    p->set_message(dest);\n+    _pos += sz;\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+AsyncLogMessage* AsyncLogWriter::Buffer::Iterator::next() {\n+  auto msg = static_cast<AsyncLogMessage*>(raw_ptr());\n+  _curr += msg->size();\n+  _curr = MIN2(_curr, _buf._pos);\n+  return msg;\n+}\n+\n+\/\/ LogDecorator::None applies to 'constant initialization' because of its constexpr constructor.\n+const LogDecorations& AsyncLogWriter::None = LogDecorations(LogLevel::Warning, LogTagSetMapping<LogTag::__NO_TAG>::tagset(),\n+                                      LogDecorators::None);\n+const AsyncLogMessage& AsyncLogWriter::Token = AsyncLogMessage(nullptr, None, nullptr);\n+\n@@ -46,1 +94,1 @@\n-  if (_buffer.size() >= _buffer_max_size) {\n+  if (!_buffer->push_back(msg)) {\n@@ -50,2 +98,0 @@\n-    \/\/ drop the enqueueing message.\n-    os::free(msg.message());\n@@ -55,1 +101,0 @@\n-  _buffer.push_back(msg);\n@@ -61,1 +106,1 @@\n-  AsyncLogMessage m(&output, decorations, os::strdup(msg));\n+  AsyncLogMessage m(&output, decorations, msg);\n@@ -75,1 +120,1 @@\n-    AsyncLogMessage m(&output, msg_iterator.decorations(), os::strdup(msg_iterator.message()));\n+    AsyncLogMessage m(&output, msg_iterator.decorations(), msg_iterator.message());\n@@ -84,0 +129,15 @@\n+\n+  size_t page_size = os::vm_page_size();\n+  size_t size = align_up(AsyncLogBufferSize \/ 2, page_size);\n+\n+  _buffer = new Buffer(size);\n+  _buffer_staging = new Buffer(size);\n+  if (_buffer->is_valid() && _buffer_staging->is_valid()) {\n+    log_info(logging)(\"AsyncLogBuffer estimates memory use: \" SIZE_FORMAT \" bytes\", size * 2);\n+  } else {\n+    log_warning(logging)(\"AsyncLogging failed to create buffer Objects. Falling back to synchronous logging.\");\n+    delete _buffer;\n+    delete _buffer_staging;\n+    return;\n+  }\n+\n@@ -89,3 +149,0 @@\n-\n-  log_info(logging)(\"The maximum entries of AsyncLogBuffer: \" SIZE_FORMAT \", estimated memory use: \" SIZE_FORMAT \" bytes\",\n-                    _buffer_max_size, AsyncLogBufferSize);\n@@ -94,21 +151,0 @@\n-class AsyncLogMapIterator {\n-  AsyncLogBuffer& _logs;\n-\n- public:\n-  AsyncLogMapIterator(AsyncLogBuffer& logs) :_logs(logs) {}\n-  bool do_entry(LogFileStreamOutput* output, uint32_t& counter) {\n-    using none = LogTagSetMapping<LogTag::__NO_TAG>;\n-\n-    if (counter > 0) {\n-      LogDecorations decorations(LogLevel::Warning, none::tagset(), LogDecorators::All);\n-      stringStream ss;\n-      ss.print(UINT32_FORMAT_W(6) \" messages dropped due to async logging\", counter);\n-      AsyncLogMessage msg(output, decorations, ss.as_string(true \/*c_heap*\/));\n-      _logs.push_back(msg);\n-      counter = 0;\n-    }\n-\n-    return true;\n-  }\n-};\n-\n@@ -116,7 +152,5 @@\n-  \/\/ Use kind of copy-and-swap idiom here.\n-  \/\/ Empty 'logs' swaps the content with _buffer.\n-  \/\/ Along with logs destruction, all processed messages are deleted.\n-  \/\/\n-  \/\/ The operation 'pop_all()' is done in O(1). All I\/O jobs are then performed without\n-  \/\/ lock protection. This guarantees I\/O jobs don't block logsites.\n-  AsyncLogBuffer logs;\n+  ResourceMark rm;\n+  using Map = ResourceHashtable<LogFileStreamOutput*, uint32_t,\n+                          17\/*table_size*\/, ResourceObj::RESOURCE_AREA,\n+                          mtLogging>;\n+  Map snapshot;\n@@ -124,0 +158,1 @@\n+  \/\/ lock protection. This guarantees I\/O jobs don't block logsites.\n@@ -127,4 +162,12 @@\n-    _buffer.pop_all(&logs);\n-    \/\/ append meta-messages of dropped counters\n-    AsyncLogMapIterator dropped_counters_iter(logs);\n-    _stats.iterate(&dropped_counters_iter);\n+    _buffer_staging->reset();\n+    swap(_buffer, _buffer_staging);\n+\n+    \/\/ move counters to snapshot, and reset them.\n+    _stats.iterate([&] (LogFileStreamOutput* output, uint32_t& counter) {\n+      if (counter > 0) {\n+        bool created = snapshot.put(output, counter);\n+        assert(created == true, \"sanity check\");\n+        counter = 0;\n+      }\n+      return true;\n+    });\n@@ -134,2 +177,1 @@\n-  LinkedListIterator<AsyncLogMessage> it(logs.head());\n-\n+  auto it = _buffer_staging->iterator();\n@@ -139,1 +181,1 @@\n-    char* msg = e->message();\n+    const char* msg = e->message();\n@@ -143,1 +185,0 @@\n-      os::free(msg);\n@@ -151,0 +192,11 @@\n+  LogDecorations decorations(LogLevel::Warning, LogTagSetMapping<LogTag::__NO_TAG>::tagset(),\n+                             LogDecorators::All);\n+  snapshot.iterate([&](LogFileStreamOutput* output, uint32_t& counter) {\n+    if (counter > 0) {\n+      stringStream ss;\n+      ss.print(UINT32_FORMAT_W(6) \" messages dropped due to async logging\", counter);\n+      output->write_blocking(decorations, ss.as_string(false));\n+    }\n+    return true;\n+  });\n+\n@@ -189,0 +241,2 @@\n+  } else {\n+    delete self;\n@@ -203,1 +257,0 @@\n-      using none = LogTagSetMapping<LogTag::__NO_TAG>;\n@@ -205,3 +258,0 @@\n-      LogDecorations d(LogLevel::Off, none::tagset(), LogDecorators::None);\n-      AsyncLogMessage token(nullptr, d, nullptr);\n-\n@@ -209,1 +259,2 @@\n-      _instance->_buffer.push_back(token);\n+      bool result = _instance->_buffer->push_back(Token);\n+      assert(result, \"fail to enqueue the flush token!\");\n@@ -217,0 +268,8 @@\n+\n+size_t AsyncLogWriter::throttle_buffers(size_t newsize) {\n+  AsyncLogLocker locker;\n+\n+  size_t oldsize = _buffer->set_capacity(newsize);\n+  _buffer_staging->set_capacity(newsize);\n+  return oldsize;\n+}\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":109,"deletions":50,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"memory\/resourceArea.hpp\"\n+#include \"memory\/allocation.hpp\"\n@@ -34,59 +34,0 @@\n-#include \"utilities\/linkedlist.hpp\"\n-\n-template <typename E, MEMFLAGS F>\n-class LinkedListDeque : private LinkedListImpl<E, ResourceObj::C_HEAP, F> {\n- private:\n-  LinkedListNode<E>* _tail;\n-  size_t _size;\n-\n- public:\n-  LinkedListDeque() : _tail(NULL), _size(0) {}\n-  void push_back(const E& e) {\n-    if (!_tail) {\n-      _tail = this->add(e);\n-    } else {\n-      _tail = this->insert_after(e, _tail);\n-    }\n-\n-    ++_size;\n-  }\n-\n-  \/\/ pop all elements to logs.\n-  void pop_all(LinkedList<E>* logs) {\n-    logs->move(static_cast<LinkedList<E>* >(this));\n-    _tail = NULL;\n-    _size = 0;\n-  }\n-\n-  void pop_all(LinkedListDeque<E, F>* logs) {\n-    logs->_size = _size;\n-    logs->_tail = _tail;\n-    pop_all(static_cast<LinkedList<E>* >(logs));\n-  }\n-\n-  void pop_front() {\n-    LinkedListNode<E>* h = this->unlink_head();\n-    if (h == _tail) {\n-      _tail = NULL;\n-    }\n-\n-    if (h != NULL) {\n-      --_size;\n-      this->delete_node(h);\n-    }\n-  }\n-\n-  size_t size() const { return _size; }\n-\n-  const E* front() const {\n-    return this->_head == NULL ? NULL : this->_head->peek();\n-  }\n-\n-  const E* back() const {\n-    return _tail == NULL ? NULL : _tail->peek();\n-  }\n-\n-  LinkedListNode<E>* head() const {\n-    return this->_head;\n-  }\n-};\n@@ -99,0 +40,1 @@\n+  const char* _message;\n@@ -100,1 +42,0 @@\n-  char* _message;\n@@ -103,2 +44,2 @@\n-  AsyncLogMessage(LogFileStreamOutput* output, const LogDecorations& decorations, char* msg)\n-    : _output(output), _decorations(decorations), _message(msg) {}\n+  AsyncLogMessage(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg)\n+    : _output(output), _message(msg), _decorations(decorations) {}\n@@ -106,2 +47,4 @@\n-  \/\/ placeholder for LinkedListImpl.\n-  bool equals(const AsyncLogMessage& o) const { return false; }\n+  size_t size() const {\n+    constexpr size_t size = align_up(sizeof(*this), sizeof(void*));\n+    return _message != nullptr ? align_up(size + strlen(_message) + 1, sizeof(void*)): size;\n+  }\n@@ -111,1 +54,2 @@\n-  char* message() const { return _message; }\n+  void set_message(const char* msg) { _message = msg; }\n+  const char* message() const { return _message; }\n@@ -114,1 +58,0 @@\n-typedef LinkedListDeque<AsyncLogMessage, mtLogging> AsyncLogBuffer;\n@@ -144,0 +87,47 @@\n+  friend class AsyncLogTest;\n+\n+  class Buffer : public CHeapObj<mtLogging> {\n+    size_t _pos;\n+    char* _buf;\n+    size_t _capacity;\n+\n+   public:\n+    Buffer(size_t capacity);\n+    ~Buffer();\n+\n+    bool is_valid() const;\n+\n+    bool push_back(const AsyncLogMessage& msg);\n+\n+    \/\/ for testing-only!\n+    size_t set_capacity(size_t value) {\n+      size_t old = _capacity;\n+      _capacity = value;\n+      return old;\n+    }\n+\n+    void reset() { _pos = 0; }\n+\n+    class Iterator {\n+      const Buffer& _buf;\n+      size_t _curr;\n+\n+      void* raw_ptr() const {\n+        assert(_curr < _buf._pos, \"sanity check\");\n+        return _buf._buf + _curr;\n+      }\n+\n+    public:\n+      Iterator(const Buffer& buffer): _buf(buffer), _curr(0) {}\n+\n+      bool is_empty() const {\n+        return _curr >= _buf._pos;\n+      }\n+\n+      AsyncLogMessage* next();\n+    };\n+\n+    Iterator iterator() const {\n+      return Iterator(*this);\n+    }\n+  };\n@@ -152,1 +142,0 @@\n-  AsyncLogBuffer _buffer;\n@@ -154,3 +143,6 @@\n-  \/\/ The memory use of each AsyncLogMessage (payload) consists of itself and a variable-length c-str message.\n-  \/\/ A regular logging message is smaller than vwrite_buffer_size, which is defined in logtagset.cpp\n-  const size_t _buffer_max_size = {AsyncLogBufferSize \/ (sizeof(AsyncLogMessage) + vwrite_buffer_size)};\n+  \/\/ ping-pong buffers\n+  Buffer* _buffer;\n+  Buffer* _buffer_staging;\n+\n+  static const LogDecorations& None;\n+  static const AsyncLogMessage& Token;\n@@ -174,0 +166,2 @@\n+  \/\/ for testing-only\n+  size_t throttle_buffers(size_t newsize);\n@@ -181,0 +175,1 @@\n+\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":66,"deletions":71,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -39,2 +39,2 @@\n-const LogDecorators LogDecorators::None = LogDecorators(0);\n-const LogDecorators LogDecorators::All  = LogDecorators(AllBitmask<time_decorator>::_value);\n+const LogDecorators LogDecorators::None = {0};\n+const LogDecorators LogDecorators::All = {AllBitmask<time_decorator>::_value};\n","filename":"src\/hotspot\/share\/logging\/logDecorators.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  LogDecorators(uint mask) : _decorators(mask) {\n+  constexpr LogDecorators(uint mask) : _decorators(mask) {\n","filename":"src\/hotspot\/share\/logging\/logDecorators.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1974,1 +1974,1 @@\n-  product(size_t, AsyncLogBufferSize, 2*M,                                  \\\n+  product(size_t, AsyncLogBufferSize, 4*M,                                  \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,2 +72,3 @@\n-    if (AsyncLogWriter::instance() != nullptr) {\n-      const size_t sz = 100;\n+    auto writer = AsyncLogWriter::instance();\n+    if (writer != nullptr) {\n+      const size_t sz = 2000;\n@@ -76,1 +77,1 @@\n-      AutoModifyRestore<size_t> saver(AsyncLogBufferSize, sz * 1024 \/*in byte*\/);\n+      size_t saved = writer->throttle_buffers(1024\/*bytes*\/);\n@@ -79,2 +80,2 @@\n-      \/\/ write 100x more messages than its capacity in burst\n-      for (size_t i = 0; i < sz * 100; ++i) {\n+      \/\/ write more messages than its capacity in burst\n+      for (size_t i = 0; i < sz; ++i) {\n@@ -84,0 +85,1 @@\n+      writer->throttle_buffers(saved);\n@@ -104,72 +106,0 @@\n-TEST_VM(AsyncLogBufferTest, fifo) {\n-  LinkedListDeque<int, mtLogging> fifo;\n-  LinkedListImpl<int, ResourceObj::C_HEAP, mtLogging> result;\n-\n-  fifo.push_back(1);\n-  EXPECT_EQ((size_t)1, fifo.size());\n-  EXPECT_EQ(1, *(fifo.back()));\n-\n-  fifo.pop_all(&result);\n-  EXPECT_EQ((size_t)0, fifo.size());\n-  EXPECT_EQ(NULL, fifo.back());\n-  EXPECT_EQ((size_t)1, result.size());\n-  EXPECT_EQ(1, *(result.head()->data()));\n-  result.clear();\n-\n-  fifo.push_back(2);\n-  fifo.push_back(1);\n-  fifo.pop_all(&result);\n-  EXPECT_EQ((size_t)2, result.size());\n-  EXPECT_EQ(2, *(result.head()->data()));\n-  EXPECT_EQ(1, *(result.head()->next()->data()));\n-  result.clear();\n-  const int N = 1000;\n-  for (int i=0; i<N; ++i) {\n-    fifo.push_back(i);\n-  }\n-  fifo.pop_all(&result);\n-\n-  EXPECT_EQ((size_t)N, result.size());\n-  LinkedListIterator<int> it(result.head());\n-  for (int i=0; i<N; ++i) {\n-    int* e = it.next();\n-    EXPECT_EQ(i, *e);\n-  }\n-}\n-\n-TEST_VM(AsyncLogBufferTest, deque) {\n-  LinkedListDeque<int, mtLogging> deque;\n-  const int N = 10;\n-\n-  EXPECT_EQ(NULL, deque.front());\n-  EXPECT_EQ(NULL, deque.back());\n-  for (int i = 0; i < N; ++i) {\n-    deque.push_back(i);\n-  }\n-\n-  EXPECT_EQ(0, *(deque.front()));\n-  EXPECT_EQ(N-1, *(deque.back()));\n-  EXPECT_EQ((size_t)N, deque.size());\n-\n-  deque.pop_front();\n-  EXPECT_EQ((size_t)(N - 1), deque.size());\n-  EXPECT_EQ(1, *(deque.front()));\n-  EXPECT_EQ(N - 1, *(deque.back()));\n-\n-  deque.pop_front();\n-  EXPECT_EQ((size_t)(N - 2), deque.size());\n-  EXPECT_EQ(2, *(deque.front()));\n-  EXPECT_EQ(N - 1, *(deque.back()));\n-\n-\n-  for (int i=2; i < N-1; ++i) {\n-    deque.pop_front();\n-  }\n-  EXPECT_EQ((size_t)1, deque.size());\n-  EXPECT_EQ(N - 1, *(deque.back()));\n-  EXPECT_EQ(deque.back(), deque.front());\n-\n-  deque.pop_front();\n-  EXPECT_EQ((size_t)0, deque.size());\n-}\n-\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":7,"deletions":77,"binary":false,"changes":84,"status":"modified"}]}