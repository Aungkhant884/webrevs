{"files":[{"patch":"@@ -56,4 +56,0 @@\n-AsyncLogWriter::Buffer::~Buffer() {\n-  FREE_C_HEAP_ARRAY(char, _buf);\n-}\n-\n@@ -75,9 +71,1 @@\n-  assert(result, \"fail to enqueue the flush token\");\n-}\n-\n-AsyncLogWriter::Message* AsyncLogWriter::Buffer::Iterator::next() {\n-  assert(_curr < _buf._pos, \"sanity check\");\n-  auto msg = reinterpret_cast<Message*>(_buf._buf + _curr);\n-  _curr += msg->size();\n-  _curr = MIN2(_curr, _buf._pos);\n-  return msg;\n+  assert(result, \"fail to enqueue the flush token.\");\n@@ -122,3 +110,1 @@\n-  size_t page_size = os::vm_page_size();\n-  size_t size = align_up(AsyncLogBufferSize \/ 2, page_size);\n-\n+  size_t size = AsyncLogBufferSize \/ 2;\n@@ -127,1 +113,0 @@\n-\n@@ -162,1 +147,0 @@\n-  auto it = _buffer_staging->iterator();\n@@ -164,2 +148,3 @@\n-  while (!it.is_empty()) {\n-    Message* e = it.next();\n+  auto it = _buffer_staging->iterator();\n+  while (it.hasNext()) {\n+    const Message* e = it.next();\n@@ -188,1 +173,1 @@\n-    assert(req == 1, \"AsyncLogWriter::flush() is NOT MT-safe!\");\n+    assert(req == 1, \"Only one token is allowed in queue. AsyncLogWriter::flush() is NOT MT-safe!\");\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":6,"deletions":21,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+  friend class AsyncLogTest_logBuffer_vm_Test;\n@@ -65,0 +66,13 @@\n+\n+  \/\/ Messsage is the envelop of a log line and its associative data.\n+  \/\/ The size is variety-length with zero-terminated c-str. It is only valid when we create it using placement new\n+  \/\/ within a buffer.\n+  \/\/\n+  \/\/ Example layout:\n+  \/\/ ---------------------------------------------\n+  \/\/ |_output|_decorations|\"a log line\", |pad| <- pointer aligned.\n+  \/\/ |_output|_decorations|\"yet another\",|pad|\n+  \/\/ ...\n+  \/\/ |nullptr|_decorations|\"\",|pad| <- flush token\n+  \/\/ |<- _pos\n+  \/\/ ---------------------------------------------\n@@ -66,0 +80,2 @@\n+    NONCOPYABLE(Message);\n+    ~Message() = delete;\n@@ -68,1 +84,0 @@\n-\n@@ -70,1 +85,0 @@\n-    \/\/ only-valid for in-place new!\n@@ -93,1 +107,0 @@\n-    size_t _pos;\n@@ -95,0 +108,1 @@\n+    size_t _pos;\n@@ -99,1 +113,0 @@\n-    ~Buffer();\n@@ -120,2 +133,2 @@\n-      bool is_empty() const {\n-        return _curr >= _buf._pos;\n+      bool hasNext() const {\n+        return _curr < _buf._pos;\n@@ -124,1 +137,6 @@\n-      Message* next();\n+      const Message* next() {\n+        assert(hasNext(), \"sanity check\");\n+        auto msg = reinterpret_cast<Message*>(_buf._buf + _curr);\n+        _curr = MIN2(_curr + msg->size(), _buf._pos);\n+        return msg;\n+      }\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":25,"deletions":7,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"logging\/logFileOutput.hpp\"\n@@ -162,0 +163,84 @@\n+TEST_VM_F(AsyncLogTest, logBuffer) {\n+  const auto Default = LogDecorations(LogLevel::Warning, LogTagSetMapping<LogTag::__NO_TAG>::tagset(),\n+                                      LogDecorators());\n+  size_t len = strlen(TestLogFileName) + strlen(LogFileOutput::Prefix) + 1;\n+  char name[len];\n+  snprintf(name, len, \"%s%s\", LogFileOutput::Prefix, TestLogFileName);\n+\n+  LogFileStreamOutput* output = new LogFileOutput(name);\n+  output->initialize(nullptr, nullptr);\n+  auto buffer = new AsyncLogWriter::Buffer(1024);\n+\n+  int line = 0;\n+  int written;\n+  uintptr_t addr;\n+  const uintptr_t mask = (uintptr_t)(sizeof(void*) - 1);\n+  bool res;\n+\n+  res = buffer->push_back(output, Default, \"a log line\");\n+  EXPECT_TRUE(res) << \"first message should succeed.\";\n+  line++;\n+  res = buffer->push_back(output, Default, \"yet another\");\n+  EXPECT_TRUE(res) << \"second message should succeed.\";\n+  line++;\n+\n+  auto it = buffer->iterator();\n+  EXPECT_TRUE(it.hasNext());\n+  const AsyncLogWriter::Message* e = it.next();\n+  addr = reinterpret_cast<uintptr_t>(e);\n+  EXPECT_EQ(0, (int)(addr & (sizeof(void*)-1))); \/\/ returned vaue aligns on sizeof(pointer)\n+  EXPECT_EQ(output, e->output());\n+  EXPECT_EQ(0, memcmp(&Default, &e->decorations(), sizeof(LogDecorations)));\n+  EXPECT_STREQ(\"a log line\", e->message());\n+  written = e->output()->write_blocking(e->decorations(), e->message());\n+  EXPECT_GT(written, 0);\n+\n+  EXPECT_TRUE(it.hasNext());\n+  e = it.next();\n+  addr = reinterpret_cast<uintptr_t>(e);\n+  EXPECT_EQ(0, (int)(addr & (sizeof(void*)-1)));\n+  EXPECT_EQ(output, e->output());\n+  EXPECT_EQ(0, memcmp(&Default, &e->decorations(), sizeof(LogDecorations)));\n+  EXPECT_STREQ(\"yet another\", e->message());\n+  written = e->output()->write_blocking(e->decorations(), e->message());\n+  EXPECT_GT(written, 0);\n+\n+  while (buffer->push_back(output, Default, \"0123456789abcdef\")) {\n+    line++;\n+  }\n+\n+  EXPECT_GT(line, 2);\n+  while (it.hasNext()) {\n+    e = it.next();\n+    addr = reinterpret_cast<uintptr_t>(e);\n+    EXPECT_EQ(0, (int)(addr & (sizeof(void*)-1)));\n+    EXPECT_EQ(output, e->output());\n+    EXPECT_STREQ(\"0123456789abcdef\", e->message());\n+    written = e->output()->write_blocking(e->decorations(), e->message());\n+    EXPECT_GT(written, 0);\n+    line--;\n+  }\n+  EXPECT_EQ(line, 2);\n+\n+  \/\/ last one, flush token. expect to succeed even buffer has been full.\n+  buffer->push_flush_token();\n+  EXPECT_TRUE(it.hasNext());\n+  e = it.next();\n+  EXPECT_EQ(e->output(), nullptr);\n+  EXPECT_TRUE(e->is_token());\n+  EXPECT_STREQ(\"\", e->message());\n+  EXPECT_FALSE(it.hasNext());\n+\n+  \/\/ reset buffer\n+  buffer->reset();\n+  EXPECT_FALSE(buffer->iterator().hasNext());\n+\n+  delete output; \/\/ close file\n+  const char* strs[4];\n+  strs[0] = \"a log line\";\n+  strs[1] = \"yet another\";\n+  strs[2] = \"0123456789abcdef\";\n+  strs[3] = nullptr; \/\/ sentinel!\n+  EXPECT_TRUE(file_contains_substrings_in_order(TestLogFileName, strs));\n+}\n+\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":85,"deletions":0,"binary":false,"changes":85,"status":"modified"}]}