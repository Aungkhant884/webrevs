{"files":[{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ * copyright (c) 2005, 2021, oracle and\/or its affiliates. all rights reserved.\n+ * do not alter or remove copyright notices or this file header.\n@@ -5,3 +5,3 @@\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n+ * this code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the gnu general public license version 2 only, as\n+ * published by the free software foundation.\n@@ -9,4 +9,4 @@\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n+ * this code is distributed in the hope that it will be useful, but without\n+ * any warranty; without even the implied warranty of merchantability or\n+ * fitness for a particular purpose.  see the gnu general public license\n+ * version 2 for more details (a copy is included in the license file that\n@@ -15,3 +15,3 @@\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ * you should have received a copy of the gnu general public license version\n+ * 2 along with this work; if not, write to the free software foundation,\n+ * inc., 51 franklin st, fifth floor, boston, ma 02110-1301 usa.\n@@ -19,1 +19,1 @@\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * please contact oracle, 500 oracle parkway, redwood shores, ca 94065 usa\n@@ -26,36 +26,36 @@\n-#include \"aot\/aotLoader.hpp\"\n-#include \"classfile\/classLoaderDataGraph.hpp\"\n-#include \"classfile\/javaClasses.inline.hpp\"\n-#include \"classfile\/stringTable.hpp\"\n-#include \"classfile\/symbolTable.hpp\"\n-#include \"classfile\/systemDictionary.hpp\"\n-#include \"code\/codeCache.hpp\"\n-#include \"gc\/parallel\/parallelArguments.hpp\"\n-#include \"gc\/parallel\/parallelScavengeHeap.inline.hpp\"\n-#include \"gc\/parallel\/parMarkBitMap.inline.hpp\"\n-#include \"gc\/parallel\/psAdaptiveSizePolicy.hpp\"\n-#include \"gc\/parallel\/psCompactionManager.inline.hpp\"\n-#include \"gc\/parallel\/psOldGen.hpp\"\n-#include \"gc\/parallel\/psParallelCompact.inline.hpp\"\n-#include \"gc\/parallel\/psPromotionManager.inline.hpp\"\n-#include \"gc\/parallel\/psRootType.hpp\"\n-#include \"gc\/parallel\/psScavenge.hpp\"\n-#include \"gc\/parallel\/psYoungGen.hpp\"\n-#include \"gc\/shared\/gcCause.hpp\"\n-#include \"gc\/shared\/gcHeapSummary.hpp\"\n-#include \"gc\/shared\/gcId.hpp\"\n-#include \"gc\/shared\/gcLocker.hpp\"\n-#include \"gc\/shared\/gcTimer.hpp\"\n-#include \"gc\/shared\/gcTrace.hpp\"\n-#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n-#include \"gc\/shared\/isGCActiveMark.hpp\"\n-#include \"gc\/shared\/oopStorage.inline.hpp\"\n-#include \"gc\/shared\/oopStorageSet.inline.hpp\"\n-#include \"gc\/shared\/oopStorageSetParState.inline.hpp\"\n-#include \"gc\/shared\/referencePolicy.hpp\"\n-#include \"gc\/shared\/referenceProcessor.hpp\"\n-#include \"gc\/shared\/referenceProcessorPhaseTimes.hpp\"\n-#include \"gc\/shared\/spaceDecorator.inline.hpp\"\n-#include \"gc\/shared\/taskTerminator.hpp\"\n-#include \"gc\/shared\/weakProcessor.inline.hpp\"\n-#include \"gc\/shared\/workerPolicy.hpp\"\n+#include \"aot\/aotloader.hpp\"\n+#include \"classfile\/classloaderdatagraph.hpp\"\n+#include \"classfile\/javaclasses.inline.hpp\"\n+#include \"classfile\/stringtable.hpp\"\n+#include \"classfile\/symboltable.hpp\"\n+#include \"classfile\/systemdictionary.hpp\"\n+#include \"code\/codecache.hpp\"\n+#include \"gc\/parallel\/parallelarguments.hpp\"\n+#include \"gc\/parallel\/parallelscavengeheap.inline.hpp\"\n+#include \"gc\/parallel\/parmarkbitmap.inline.hpp\"\n+#include \"gc\/parallel\/psadaptivesizepolicy.hpp\"\n+#include \"gc\/parallel\/pscompactionmanager.inline.hpp\"\n+#include \"gc\/parallel\/psoldgen.hpp\"\n+#include \"gc\/parallel\/psparallelcompact.inline.hpp\"\n+#include \"gc\/parallel\/pspromotionmanager.inline.hpp\"\n+#include \"gc\/parallel\/psroottype.hpp\"\n+#include \"gc\/parallel\/psscavenge.hpp\"\n+#include \"gc\/parallel\/psyounggen.hpp\"\n+#include \"gc\/shared\/gccause.hpp\"\n+#include \"gc\/shared\/gcheapsummary.hpp\"\n+#include \"gc\/shared\/gcid.hpp\"\n+#include \"gc\/shared\/gclocker.hpp\"\n+#include \"gc\/shared\/gctimer.hpp\"\n+#include \"gc\/shared\/gctrace.hpp\"\n+#include \"gc\/shared\/gctracetime.inline.hpp\"\n+#include \"gc\/shared\/isgcactivemark.hpp\"\n+#include \"gc\/shared\/oopstorage.inline.hpp\"\n+#include \"gc\/shared\/oopstorageset.inline.hpp\"\n+#include \"gc\/shared\/oopstoragesetparstate.inline.hpp\"\n+#include \"gc\/shared\/referencepolicy.hpp\"\n+#include \"gc\/shared\/referenceprocessor.hpp\"\n+#include \"gc\/shared\/referenceprocessorphasetimes.hpp\"\n+#include \"gc\/shared\/spacedecorator.inline.hpp\"\n+#include \"gc\/shared\/taskterminator.hpp\"\n+#include \"gc\/shared\/weakprocessor.inline.hpp\"\n+#include \"gc\/shared\/workerpolicy.hpp\"\n@@ -65,2 +65,2 @@\n-#include \"memory\/metaspaceUtils.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n+#include \"memory\/metaspaceutils.hpp\"\n+#include \"memory\/resourcearea.hpp\"\n@@ -69,5 +69,5 @@\n-#include \"oops\/instanceClassLoaderKlass.inline.hpp\"\n-#include \"oops\/instanceKlass.inline.hpp\"\n-#include \"oops\/instanceMirrorKlass.inline.hpp\"\n-#include \"oops\/methodData.hpp\"\n-#include \"oops\/objArrayKlass.inline.hpp\"\n+#include \"oops\/instanceclassloaderklass.inline.hpp\"\n+#include \"oops\/instanceklass.inline.hpp\"\n+#include \"oops\/instancemirrorklass.inline.hpp\"\n+#include \"oops\/methoddata.hpp\"\n+#include \"oops\/objarrayklass.inline.hpp\"\n@@ -79,3 +79,3 @@\n-#include \"runtime\/vmThread.hpp\"\n-#include \"services\/memTracker.hpp\"\n-#include \"services\/memoryService.hpp\"\n+#include \"runtime\/vmthread.hpp\"\n+#include \"services\/memtracker.hpp\"\n+#include \"services\/memoryservice.hpp\"\n@@ -85,1 +85,1 @@\n-#include \"utilities\/formatBuffer.hpp\"\n+#include \"utilities\/formatbuffer.hpp\"\n@@ -88,1 +88,1 @@\n-#if INCLUDE_JVMCI\n+#if include_jvmci\n@@ -94,8 +94,8 @@\n-\/\/ All sizes are in HeapWords.\n-const size_t ParallelCompactData::Log2RegionSize  = 16; \/\/ 64K words\n-const size_t ParallelCompactData::RegionSize      = (size_t)1 << Log2RegionSize;\n-const size_t ParallelCompactData::RegionSizeBytes =\n-  RegionSize << LogHeapWordSize;\n-const size_t ParallelCompactData::RegionSizeOffsetMask = RegionSize - 1;\n-const size_t ParallelCompactData::RegionAddrOffsetMask = RegionSizeBytes - 1;\n-const size_t ParallelCompactData::RegionAddrMask       = ~RegionAddrOffsetMask;\n+\/\/ all sizes are in heapwords.\n+const size_t parallelcompactdata::log2regionsize  = 16; \/\/ 64k words\n+const size_t parallelcompactdata::regionsize      = (size_t)1 << log2regionsize;\n+const size_t parallelcompactdata::regionsizebytes =\n+  regionsize << logheapwordsize;\n+const size_t parallelcompactdata::regionsizeoffsetmask = regionsize - 1;\n+const size_t parallelcompactdata::regionaddroffsetmask = regionsizebytes - 1;\n+const size_t parallelcompactdata::regionaddrmask       = ~regionaddroffsetmask;\n@@ -103,7 +103,7 @@\n-const size_t ParallelCompactData::Log2BlockSize   = 7; \/\/ 128 words\n-const size_t ParallelCompactData::BlockSize       = (size_t)1 << Log2BlockSize;\n-const size_t ParallelCompactData::BlockSizeBytes  =\n-  BlockSize << LogHeapWordSize;\n-const size_t ParallelCompactData::BlockSizeOffsetMask = BlockSize - 1;\n-const size_t ParallelCompactData::BlockAddrOffsetMask = BlockSizeBytes - 1;\n-const size_t ParallelCompactData::BlockAddrMask       = ~BlockAddrOffsetMask;\n+const size_t parallelcompactdata::log2blocksize   = 7; \/\/ 128 words\n+const size_t parallelcompactdata::blocksize       = (size_t)1 << log2blocksize;\n+const size_t parallelcompactdata::blocksizebytes  =\n+  blocksize << logheapwordsize;\n+const size_t parallelcompactdata::blocksizeoffsetmask = blocksize - 1;\n+const size_t parallelcompactdata::blockaddroffsetmask = blocksizebytes - 1;\n+const size_t parallelcompactdata::blockaddrmask       = ~blockaddroffsetmask;\n@@ -111,3 +111,3 @@\n-const size_t ParallelCompactData::BlocksPerRegion = RegionSize \/ BlockSize;\n-const size_t ParallelCompactData::Log2BlocksPerRegion =\n-  Log2RegionSize - Log2BlockSize;\n+const size_t parallelcompactdata::blocksperregion = regionsize \/ blocksize;\n+const size_t parallelcompactdata::log2blocksperregion =\n+  log2regionsize - log2blocksize;\n@@ -115,2 +115,2 @@\n-const ParallelCompactData::RegionData::region_sz_t\n-ParallelCompactData::RegionData::dc_shift = 27;\n+const parallelcompactdata::regiondata::region_sz_t\n+parallelcompactdata::regiondata::dc_shift = 27;\n@@ -118,2 +118,2 @@\n-const ParallelCompactData::RegionData::region_sz_t\n-ParallelCompactData::RegionData::dc_mask = ~0U << dc_shift;\n+const parallelcompactdata::regiondata::region_sz_t\n+parallelcompactdata::regiondata::dc_mask = ~0u << dc_shift;\n@@ -121,2 +121,2 @@\n-const ParallelCompactData::RegionData::region_sz_t\n-ParallelCompactData::RegionData::dc_one = 0x1U << dc_shift;\n+const parallelcompactdata::regiondata::region_sz_t\n+parallelcompactdata::regiondata::dc_one = 0x1u << dc_shift;\n@@ -124,2 +124,2 @@\n-const ParallelCompactData::RegionData::region_sz_t\n-ParallelCompactData::RegionData::los_mask = ~dc_mask;\n+const parallelcompactdata::regiondata::region_sz_t\n+parallelcompactdata::regiondata::los_mask = ~dc_mask;\n@@ -127,2 +127,2 @@\n-const ParallelCompactData::RegionData::region_sz_t\n-ParallelCompactData::RegionData::dc_claimed = 0x8U << dc_shift;\n+const parallelcompactdata::regiondata::region_sz_t\n+parallelcompactdata::regiondata::dc_claimed = 0x8u << dc_shift;\n@@ -130,2 +130,2 @@\n-const ParallelCompactData::RegionData::region_sz_t\n-ParallelCompactData::RegionData::dc_completed = 0xcU << dc_shift;\n+const parallelcompactdata::regiondata::region_sz_t\n+parallelcompactdata::regiondata::dc_completed = 0xcu << dc_shift;\n@@ -133,1 +133,1 @@\n-SpaceInfo PSParallelCompact::_space_info[PSParallelCompact::last_space_id];\n+spaceinfo psparallelcompact::_space_info[psparallelcompact::last_space_id];\n@@ -135,2 +135,2 @@\n-SpanSubjectToDiscoveryClosure PSParallelCompact::_span_based_discoverer;\n-ReferenceProcessor* PSParallelCompact::_ref_processor = NULL;\n+spansubjecttodiscoveryclosure psparallelcompact::_span_based_discoverer;\n+referenceprocessor* psparallelcompact::_ref_processor = null;\n@@ -138,7 +138,7 @@\n-double PSParallelCompact::_dwl_mean;\n-double PSParallelCompact::_dwl_std_dev;\n-double PSParallelCompact::_dwl_first_term;\n-double PSParallelCompact::_dwl_adjustment;\n-#ifdef  ASSERT\n-bool   PSParallelCompact::_dwl_initialized = false;\n-#endif  \/\/ #ifdef ASSERT\n+double psparallelcompact::_dwl_mean;\n+double psparallelcompact::_dwl_std_dev;\n+double psparallelcompact::_dwl_first_term;\n+double psparallelcompact::_dwl_adjustment;\n+#ifdef  assert\n+bool   psparallelcompact::_dwl_initialized = false;\n+#endif  \/\/ #ifdef assert\n@@ -146,2 +146,2 @@\n-void SplitInfo::record(size_t src_region_idx, size_t partial_obj_size,\n-                       HeapWord* destination)\n+void splitinfo::record(size_t src_region_idx, size_t partial_obj_size,\n+                       heapword* destination)\n@@ -151,1 +151,1 @@\n-  assert(destination != NULL, \"invalid destination argument\");\n+  assert(destination != null, \"invalid destination argument\");\n@@ -157,3 +157,3 @@\n-  \/\/ These fields may not be updated below, so make sure they're clear.\n-  assert(_dest_region_addr == NULL, \"should have been cleared\");\n-  assert(_first_src_addr == NULL, \"should have been cleared\");\n+  \/\/ these fields may not be updated below, so make sure they're clear.\n+  assert(_dest_region_addr == null, \"should have been cleared\");\n+  assert(_first_src_addr == null, \"should have been cleared\");\n@@ -161,5 +161,5 @@\n-  \/\/ Determine the number of destination regions for the partial object.\n-  HeapWord* const last_word = destination + partial_obj_size - 1;\n-  const ParallelCompactData& sd = PSParallelCompact::summary_data();\n-  HeapWord* const beg_region_addr = sd.region_align_down(destination);\n-  HeapWord* const end_region_addr = sd.region_align_down(last_word);\n+  \/\/ determine the number of destination regions for the partial object.\n+  heapword* const last_word = destination + partial_obj_size - 1;\n+  const parallelcompactdata& sd = psparallelcompact::summary_data();\n+  heapword* const beg_region_addr = sd.region_align_down(destination);\n+  heapword* const end_region_addr = sd.region_align_down(last_word);\n@@ -168,1 +168,1 @@\n-    \/\/ One destination region.\n+    \/\/ one destination region.\n@@ -171,1 +171,1 @@\n-      \/\/ The destination falls on a region boundary, thus the first word of the\n+      \/\/ the destination falls on a region boundary, thus the first word of the\n@@ -177,1 +177,1 @@\n-    \/\/ Two destination regions.  When copied, the partial object will cross a\n+    \/\/ two destination regions.  when copied, the partial object will cross a\n@@ -188,1 +188,1 @@\n-void SplitInfo::clear()\n+void splitinfo::clear()\n@@ -192,1 +192,1 @@\n-  _destination = NULL;\n+  _destination = null;\n@@ -194,2 +194,2 @@\n-  _dest_region_addr = NULL;\n-  _first_src_addr = NULL;\n+  _dest_region_addr = null;\n+  _first_src_addr = null;\n@@ -199,2 +199,2 @@\n-#ifdef  ASSERT\n-void SplitInfo::verify_clear()\n+#ifdef  assert\n+void splitinfo::verify_clear()\n@@ -204,1 +204,1 @@\n-  assert(_destination == NULL, \"not clear\");\n+  assert(_destination == null, \"not clear\");\n@@ -206,2 +206,2 @@\n-  assert(_dest_region_addr == NULL, \"not clear\");\n-  assert(_first_src_addr == NULL, \"not clear\");\n+  assert(_dest_region_addr == null, \"not clear\");\n+  assert(_first_src_addr == null, \"not clear\");\n@@ -209,1 +209,1 @@\n-#endif  \/\/ #ifdef ASSERT\n+#endif  \/\/ #ifdef assert\n@@ -212,1 +212,1 @@\n-void PSParallelCompact::print_on_error(outputStream* st) {\n+void psparallelcompact::print_on_error(outputstream* st) {\n@@ -216,2 +216,2 @@\n-#ifndef PRODUCT\n-const char* PSParallelCompact::space_names[] = {\n+#ifndef product\n+const char* psparallelcompact::space_names[] = {\n@@ -221,2 +221,2 @@\n-void PSParallelCompact::print_region_ranges() {\n-  if (!log_develop_is_enabled(Trace, gc, compaction)) {\n+void psparallelcompact::print_region_ranges() {\n+  if (!log_develop_is_enabled(trace, gc, compaction)) {\n@@ -225,4 +225,4 @@\n-  Log(gc, compaction) log;\n-  ResourceMark rm;\n-  LogStream ls(log.trace());\n-  Universe::print_on(&ls);\n+  log(gc, compaction) log;\n+  resourcemark rm;\n+  logstream ls(log.trace());\n+  universe::print_on(&ls);\n@@ -233,1 +233,1 @@\n-    const MutableSpace* space = _space_info[id].space();\n+    const mutablespace* space = _space_info[id].space();\n@@ -235,2 +235,2 @@\n-              SIZE_FORMAT_W(10) \" \" SIZE_FORMAT_W(10) \" \"\n-              SIZE_FORMAT_W(10) \" \" SIZE_FORMAT_W(10) \" \",\n+              size_format_w(10) \" \" size_format_w(10) \" \"\n+              size_format_w(10) \" \" size_format_w(10) \" \",\n@@ -246,1 +246,1 @@\n-print_generic_summary_region(size_t i, const ParallelCompactData::RegionData* c)\n+print_generic_summary_region(size_t i, const parallelcompactdata::regiondata* c)\n@@ -248,2 +248,2 @@\n-#define REGION_IDX_FORMAT        SIZE_FORMAT_W(7)\n-#define REGION_DATA_FORMAT       SIZE_FORMAT_W(5)\n+#define region_idx_format        size_format_w(7)\n+#define region_data_format       size_format_w(5)\n@@ -251,1 +251,1 @@\n-  ParallelCompactData& sd = PSParallelCompact::summary_data();\n+  parallelcompactdata& sd = psparallelcompact::summary_data();\n@@ -254,4 +254,4 @@\n-      REGION_IDX_FORMAT \" \" PTR_FORMAT \" \"\n-      REGION_IDX_FORMAT \" \" PTR_FORMAT \" \"\n-      REGION_DATA_FORMAT \" \" REGION_DATA_FORMAT \" \"\n-      REGION_DATA_FORMAT \" \" REGION_IDX_FORMAT \" %d\",\n+      region_idx_format \" \" ptr_format \" \"\n+      region_idx_format \" \" ptr_format \" \"\n+      region_data_format \" \" region_data_format \" \"\n+      region_data_format \" \" region_idx_format \" %d\",\n@@ -262,2 +262,2 @@\n-#undef  REGION_IDX_FORMAT\n-#undef  REGION_DATA_FORMAT\n+#undef  region_idx_format\n+#undef  region_data_format\n@@ -267,3 +267,3 @@\n-print_generic_summary_data(ParallelCompactData& summary_data,\n-                           HeapWord* const beg_addr,\n-                           HeapWord* const end_addr)\n+print_generic_summary_data(parallelcompactdata& summary_data,\n+                           heapword* const beg_addr,\n+                           heapword* const end_addr)\n@@ -274,1 +274,1 @@\n-  HeapWord* pdest = 0;\n+  heapword* pdest = 0;\n@@ -277,1 +277,1 @@\n-    ParallelCompactData::RegionData* c = summary_data.region(i);\n+    parallelcompactdata::regiondata* c = summary_data.region(i);\n@@ -286,1 +286,1 @@\n-  log_develop_trace(gc, compaction)(\"summary_data_bytes=\" SIZE_FORMAT, total_words * HeapWordSize);\n+  log_develop_trace(gc, compaction)(\"summary_data_bytes=\" size_format, total_words * heapwordsize);\n@@ -290,3 +290,3 @@\n-PSParallelCompact::print_generic_summary_data(ParallelCompactData& summary_data,\n-                                              HeapWord* const beg_addr,\n-                                              HeapWord* const end_addr) {\n+psparallelcompact::print_generic_summary_data(parallelcompactdata& summary_data,\n+                                              heapword* const beg_addr,\n+                                              heapword* const end_addr) {\n@@ -297,2 +297,2 @@\n-print_generic_summary_data(ParallelCompactData& summary_data,\n-                           SpaceInfo* space_info)\n+print_generic_summary_data(parallelcompactdata& summary_data,\n+                           spaceinfo* space_info)\n@@ -300,1 +300,1 @@\n-  if (!log_develop_is_enabled(Trace, gc, compaction)) {\n+  if (!log_develop_is_enabled(trace, gc, compaction)) {\n@@ -304,2 +304,2 @@\n-  for (unsigned int id = 0; id < PSParallelCompact::last_space_id; ++id) {\n-    const MutableSpace* space = space_info[id].space();\n+  for (unsigned int id = 0; id < psparallelcompact::last_space_id; ++id) {\n+    const mutablespace* space = space_info[id].space();\n@@ -307,1 +307,1 @@\n-                               MAX2(space->top(), space_info[id].new_top()));\n+                               max2(space->top(), space_info[id].new_top()));\n@@ -312,2 +312,2 @@\n-print_initial_summary_data(ParallelCompactData& summary_data,\n-                           const MutableSpace* space) {\n+print_initial_summary_data(parallelcompactdata& summary_data,\n+                           const mutablespace* space) {\n@@ -318,3 +318,3 @@\n-  const size_t region_size = ParallelCompactData::RegionSize;\n-  typedef ParallelCompactData::RegionData RegionData;\n-  HeapWord* const top_aligned_up = summary_data.region_align_up(space->top());\n+  const size_t region_size = parallelcompactdata::regionsize;\n+  typedef parallelcompactdata::regiondata regiondata;\n+  heapword* const top_aligned_up = summary_data.region_align_up(space->top());\n@@ -322,2 +322,2 @@\n-  const RegionData* c = summary_data.region(end_region - 1);\n-  HeapWord* end_addr = c->destination() + c->data_size();\n+  const regiondata* c = summary_data.region(end_region - 1);\n+  heapword* end_addr = c->destination() + c->data_size();\n@@ -326,1 +326,1 @@\n-  \/\/ Print (and count) the full regions at the beginning of the space.\n+  \/\/ print (and count) the full regions at the beginning of the space.\n@@ -330,1 +330,1 @@\n-    ParallelCompactData::RegionData* c = summary_data.region(i);\n+    parallelcompactdata::regiondata* c = summary_data.region(i);\n@@ -332,1 +332,1 @@\n-        SIZE_FORMAT_W(5) \" \" PTR_FORMAT \" \" SIZE_FORMAT_W(5) \" \" SIZE_FORMAT_W(5) \" \" SIZE_FORMAT_W(5) \" \" SIZE_FORMAT_W(5) \" %d\",\n+        size_format_w(5) \" \" ptr_format \" \" size_format_w(5) \" \" size_format_w(5) \" \" size_format_w(5) \" \" size_format_w(5) \" %d\",\n@@ -347,2 +347,2 @@\n-  \/\/ Print the 'reclaimed ratio' for regions while there is something live in\n-  \/\/ the region or to the right of it.  The remaining regions are empty (and\n+  \/\/ print the 'reclaimed ratio' for regions while there is something live in\n+  \/\/ the region or to the right of it.  the remaining regions are empty (and\n@@ -352,1 +352,1 @@\n-    HeapWord* const region_addr = summary_data.region_to_addr(i);\n+    heapword* const region_addr = summary_data.region_to_addr(i);\n@@ -364,1 +364,1 @@\n-    ParallelCompactData::RegionData* c = summary_data.region(i);\n+    parallelcompactdata::regiondata* c = summary_data.region(i);\n@@ -366,2 +366,2 @@\n-        SIZE_FORMAT_W(5) \" \" PTR_FORMAT \" \" SIZE_FORMAT_W(5) \" \" SIZE_FORMAT_W(5) \" \" SIZE_FORMAT_W(5) \" \" SIZE_FORMAT_W(5) \" %d\"\n-        \"%12.10f \" SIZE_FORMAT_W(10) \" \" SIZE_FORMAT_W(10),\n+        size_format_w(5) \" \" ptr_format \" \" size_format_w(5) \" \" size_format_w(5) \" \" size_format_w(5) \" \" size_format_w(5) \" %d\"\n+        \"%12.10f \" size_format_w(10) \" \" size_format_w(10),\n@@ -378,1 +378,1 @@\n-  \/\/ Any remaining regions are empty.  Print one more if there is one.\n+  \/\/ any remaining regions are empty.  print one more if there is one.\n@@ -380,1 +380,1 @@\n-    ParallelCompactData::RegionData* c = summary_data.region(i);\n+    parallelcompactdata::regiondata* c = summary_data.region(i);\n@@ -382,1 +382,1 @@\n-        SIZE_FORMAT_W(5) \" \" PTR_FORMAT \" \" SIZE_FORMAT_W(5) \" \" SIZE_FORMAT_W(5) \" \" SIZE_FORMAT_W(5) \" \" SIZE_FORMAT_W(5) \" %d\",\n+        size_format_w(5) \" \" ptr_format \" \" size_format_w(5) \" \" size_format_w(5) \" \" size_format_w(5) \" \" size_format_w(5) \" %d\",\n@@ -388,1 +388,1 @@\n-  log_develop_trace(gc, compaction)(\"max:  \" SIZE_FORMAT_W(4) \" d2r=\" SIZE_FORMAT_W(10) \" l2r=\" SIZE_FORMAT_W(10) \" max_ratio=%14.12f\",\n+  log_develop_trace(gc, compaction)(\"max:  \" size_format_w(4) \" d2r=\" size_format_w(10) \" l2r=\" size_format_w(10) \" max_ratio=%14.12f\",\n@@ -393,3 +393,3 @@\n-print_initial_summary_data(ParallelCompactData& summary_data,\n-                           SpaceInfo* space_info) {\n-  if (!log_develop_is_enabled(Trace, gc, compaction)) {\n+print_initial_summary_data(parallelcompactdata& summary_data,\n+                           spaceinfo* space_info) {\n+  if (!log_develop_is_enabled(trace, gc, compaction)) {\n@@ -399,2 +399,2 @@\n-  unsigned int id = PSParallelCompact::old_space_id;\n-  const MutableSpace* space;\n+  unsigned int id = psparallelcompact::old_space_id;\n+  const mutablespace* space;\n@@ -404,1 +404,1 @@\n-  } while (++id < PSParallelCompact::eden_space_id);\n+  } while (++id < psparallelcompact::eden_space_id);\n@@ -409,1 +409,1 @@\n-  } while (++id < PSParallelCompact::last_space_id);\n+  } while (++id < psparallelcompact::last_space_id);\n@@ -411,1 +411,1 @@\n-#endif  \/\/ #ifndef PRODUCT\n+#endif  \/\/ #ifndef product\n@@ -413,1 +413,1 @@\n-#ifdef  ASSERT\n+#ifdef  assert\n@@ -418,1 +418,1 @@\n-#endif  \/\/ #ifdef ASSERT\n+#endif  \/\/ #ifdef assert\n@@ -420,4 +420,4 @@\n-ParallelCompactData::ParallelCompactData() :\n-  _region_start(NULL),\n-  DEBUG_ONLY(_region_end(NULL) COMMA)\n-  _region_vspace(NULL),\n+parallelcompactdata::parallelcompactdata() :\n+  _region_start(null),\n+  debug_only(_region_end(null) comma)\n+  _region_vspace(null),\n@@ -425,1 +425,1 @@\n-  _region_data(NULL),\n+  _region_data(null),\n@@ -427,2 +427,2 @@\n-  _block_vspace(NULL),\n-  _block_data(NULL),\n+  _block_vspace(null),\n+  _block_data(null),\n@@ -431,1 +431,1 @@\n-bool ParallelCompactData::initialize(MemRegion covered_region)\n+bool parallelcompactdata::initialize(memregion covered_region)\n@@ -435,1 +435,1 @@\n-  DEBUG_ONLY(_region_end = _region_start + region_size;)\n+  debug_only(_region_end = _region_start + region_size;)\n@@ -439,2 +439,2 @@\n-  assert((region_size & RegionSizeOffsetMask) == 0,\n-         \"region size not a multiple of RegionSize\");\n+  assert((region_size & regionsizeoffsetmask) == 0,\n+         \"region size not a multiple of regionsize\");\n@@ -446,2 +446,2 @@\n-PSVirtualSpace*\n-ParallelCompactData::create_vspace(size_t count, size_t element_size)\n+psvirtualspace*\n+parallelcompactdata::create_vspace(size_t count, size_t element_size)\n@@ -452,1 +452,1 @@\n-  _reserved_byte_size = align_up(raw_bytes, MAX2(page_sz, granularity));\n+  _reserved_byte_size = align_up(raw_bytes, max2(page_sz, granularity));\n@@ -455,3 +455,3 @@\n-    MAX2(page_sz, granularity);\n-  ReservedSpace rs(_reserved_byte_size, rs_align, rs_align > 0);\n-  os::trace_page_sizes(\"Parallel Compact Data\", raw_bytes, raw_bytes, page_sz, rs.base(),\n+    max2(page_sz, granularity);\n+  reservedspace rs(_reserved_byte_size, rs_align, rs_align > 0);\n+  os::trace_page_sizes(\"parallel compact data\", raw_bytes, raw_bytes, page_sz, rs.base(),\n@@ -460,1 +460,1 @@\n-  MemTracker::record_virtual_memory_type((address)rs.base(), mtGC);\n+  memtracker::record_virtual_memory_type((address)rs.base(), mtgc);\n@@ -462,1 +462,1 @@\n-  PSVirtualSpace* vspace = new PSVirtualSpace(rs, page_sz);\n+  psvirtualspace* vspace = new psvirtualspace(rs, page_sz);\n@@ -468,1 +468,1 @@\n-    \/\/ Release memory reserved in the space.\n+    \/\/ release memory reserved in the space.\n@@ -475,1 +475,1 @@\n-bool ParallelCompactData::initialize_region_data(size_t region_size)\n+bool parallelcompactdata::initialize_region_data(size_t region_size)\n@@ -477,2 +477,2 @@\n-  const size_t count = (region_size + RegionSizeOffsetMask) >> Log2RegionSize;\n-  _region_vspace = create_vspace(count, sizeof(RegionData));\n+  const size_t count = (region_size + regionsizeoffsetmask) >> log2regionsize;\n+  _region_vspace = create_vspace(count, sizeof(regiondata));\n@@ -480,1 +480,1 @@\n-    _region_data = (RegionData*)_region_vspace->reserved_low_addr();\n+    _region_data = (regiondata*)_region_vspace->reserved_low_addr();\n@@ -487,1 +487,1 @@\n-bool ParallelCompactData::initialize_block_data()\n+bool parallelcompactdata::initialize_block_data()\n@@ -490,2 +490,2 @@\n-  const size_t count = _region_count << Log2BlocksPerRegion;\n-  _block_vspace = create_vspace(count, sizeof(BlockData));\n+  const size_t count = _region_count << log2blocksperregion;\n+  _block_vspace = create_vspace(count, sizeof(blockdata));\n@@ -493,1 +493,1 @@\n-    _block_data = (BlockData*)_block_vspace->reserved_low_addr();\n+    _block_data = (blockdata*)_block_vspace->reserved_low_addr();\n@@ -500,1 +500,1 @@\n-void ParallelCompactData::clear()\n+void parallelcompactdata::clear()\n@@ -506,1 +506,1 @@\n-void ParallelCompactData::clear_range(size_t beg_region, size_t end_region) {\n+void parallelcompactdata::clear_range(size_t beg_region, size_t end_region) {\n@@ -509,1 +509,1 @@\n-  assert(RegionSize % BlockSize == 0, \"RegionSize not a multiple of BlockSize\");\n+  assert(regionsize % blocksize == 0, \"regionsize not a multiple of blocksize\");\n@@ -512,1 +512,1 @@\n-  memset(_region_data + beg_region, 0, region_cnt * sizeof(RegionData));\n+  memset(_region_data + beg_region, 0, region_cnt * sizeof(regiondata));\n@@ -514,3 +514,3 @@\n-  const size_t beg_block = beg_region * BlocksPerRegion;\n-  const size_t block_cnt = region_cnt * BlocksPerRegion;\n-  memset(_block_data + beg_block, 0, block_cnt * sizeof(BlockData));\n+  const size_t beg_block = beg_region * blocksperregion;\n+  const size_t block_cnt = region_cnt * blocksperregion;\n+  memset(_block_data + beg_block, 0, block_cnt * sizeof(blockdata));\n@@ -519,1 +519,1 @@\n-HeapWord* ParallelCompactData::partial_obj_end(size_t region_idx) const\n+heapword* parallelcompactdata::partial_obj_end(size_t region_idx) const\n@@ -521,2 +521,2 @@\n-  const RegionData* cur_cp = region(region_idx);\n-  const RegionData* const end_cp = region(region_count() - 1);\n+  const regiondata* cur_cp = region(region_idx);\n+  const regiondata* const end_cp = region(region_count() - 1);\n@@ -524,1 +524,1 @@\n-  HeapWord* result = region_to_addr(region_idx);\n+  heapword* result = region_to_addr(region_idx);\n@@ -528,1 +528,1 @@\n-    } while (cur_cp->partial_obj_size() == RegionSize && ++cur_cp < end_cp);\n+    } while (cur_cp->partial_obj_size() == regionsize && ++cur_cp < end_cp);\n@@ -533,1 +533,1 @@\n-void ParallelCompactData::add_obj(HeapWord* addr, size_t len)\n+void parallelcompactdata::add_obj(heapword* addr, size_t len)\n@@ -536,2 +536,2 @@\n-  const size_t beg_region = obj_ofs >> Log2RegionSize;\n-  const size_t end_region = (obj_ofs + len - 1) >> Log2RegionSize;\n+  const size_t beg_region = obj_ofs >> log2regionsize;\n+  const size_t end_region = (obj_ofs + len - 1) >> log2regionsize;\n@@ -539,2 +539,2 @@\n-  DEBUG_ONLY(Atomic::inc(&add_obj_count);)\n-  DEBUG_ONLY(Atomic::add(&add_obj_size, len);)\n+  debug_only(atomic::inc(&add_obj_count);)\n+  debug_only(atomic::add(&add_obj_size, len);)\n@@ -543,1 +543,1 @@\n-    \/\/ All in one region.\n+    \/\/ all in one region.\n@@ -548,1 +548,1 @@\n-  \/\/ First region.\n+  \/\/ first region.\n@@ -550,1 +550,1 @@\n-  _region_data[beg_region].add_live_obj(RegionSize - beg_ofs);\n+  _region_data[beg_region].add_live_obj(regionsize - beg_ofs);\n@@ -552,2 +552,2 @@\n-  Klass* klass = ((oop)addr)->klass();\n-  \/\/ Middle regions--completely spanned by this object.\n+  klass* klass = ((oop)addr)->klass();\n+  \/\/ middle regions--completely spanned by this object.\n@@ -555,1 +555,1 @@\n-    _region_data[region].set_partial_obj_size(RegionSize);\n+    _region_data[region].set_partial_obj_size(regionsize);\n@@ -559,1 +559,1 @@\n-  \/\/ Last region.\n+  \/\/ last region.\n@@ -566,1 +566,1 @@\n-ParallelCompactData::summarize_dense_prefix(HeapWord* beg, HeapWord* end)\n+parallelcompactdata::summarize_dense_prefix(heapword* beg, heapword* end)\n@@ -568,2 +568,2 @@\n-  assert(region_offset(beg) == 0, \"not RegionSize aligned\");\n-  assert(region_offset(end) == 0, \"not RegionSize aligned\");\n+  assert(region_offset(beg) == 0, \"not regionsize aligned\");\n+  assert(region_offset(end) == 0, \"not regionsize aligned\");\n@@ -573,1 +573,1 @@\n-  HeapWord* addr = beg;\n+  heapword* addr = beg;\n@@ -580,2 +580,2 @@\n-    \/\/ Update live_obj_size so the region appears completely full.\n-    size_t live_size = RegionSize - _region_data[cur_region].partial_obj_size();\n+    \/\/ update live_obj_size so the region appears completely full.\n+    size_t live_size = regionsize - _region_data[cur_region].partial_obj_size();\n@@ -585,1 +585,1 @@\n-    addr += RegionSize;\n+    addr += regionsize;\n@@ -589,1 +589,1 @@\n-\/\/ Find the point at which a space can be split and, if necessary, record the\n+\/\/ find the point at which a space can be split and, if necessary, record the\n@@ -592,1 +592,1 @@\n-\/\/ If the current src region (which overflowed the destination space) doesn't\n+\/\/ if the current src region (which overflowed the destination space) doesn't\n@@ -596,2 +596,2 @@\n-\/\/ If the current src region has a partial object, the split point is in the\n-\/\/ region where that partial object starts (call it the split_region).  If\n+\/\/ if the current src region has a partial object, the split point is in the\n+\/\/ region where that partial object starts (call it the split_region).  if\n@@ -600,1 +600,1 @@\n-\/\/ zero the partial_obj_size field).  With a \"hard\" split, we know that the\n+\/\/ zero the partial_obj_size field).  with a \"hard\" split, we know that the\n@@ -602,1 +602,1 @@\n-\/\/ the overflow starts in split_region.  If split_region doesn't have a partial\n+\/\/ the overflow starts in split_region.  if split_region doesn't have a partial\n@@ -605,6 +605,6 @@\n-HeapWord*\n-ParallelCompactData::summarize_split_space(size_t src_region,\n-                                           SplitInfo& split_info,\n-                                           HeapWord* destination,\n-                                           HeapWord* target_end,\n-                                           HeapWord** target_next)\n+heapword*\n+parallelcompactdata::summarize_split_space(size_t src_region,\n+                                           splitinfo& split_info,\n+                                           heapword* destination,\n+                                           heapword* target_end,\n+                                           heapword** target_next)\n@@ -618,1 +618,1 @@\n-  HeapWord* split_destination = destination;\n+  heapword* split_destination = destination;\n@@ -622,1 +622,1 @@\n-    \/\/ The split point is just after the partial object (if any) in the\n+    \/\/ the split point is just after the partial object (if any) in the\n@@ -626,1 +626,1 @@\n-    \/\/ Find the start of the \"overflow\" object and set split_region to the\n+    \/\/ find the start of the \"overflow\" object and set split_region to the\n@@ -628,1 +628,1 @@\n-    HeapWord* const overflow_obj = _region_data[src_region].partial_obj_addr();\n+    heapword* const overflow_obj = _region_data[src_region].partial_obj_addr();\n@@ -631,1 +631,1 @@\n-    \/\/ Clear the source_region field of all destination regions whose first word\n+    \/\/ clear the source_region field of all destination regions whose first word\n@@ -635,1 +635,1 @@\n-    \/\/ An alternative to the simple loop below:  clear during post_compact(),\n+    \/\/ an alternative to the simple loop below:  clear during post_compact(),\n@@ -637,1 +637,1 @@\n-    \/\/ parallelize.  (The downside is that it clears the entire RegionData\n+    \/\/ parallelize.  (the downside is that it clears the entire regiondata\n@@ -645,1 +645,1 @@\n-    \/\/ where clear_top is a new field in SpaceInfo.  Would have to set clear_top\n+    \/\/ where clear_top is a new field in spaceinfo.  would have to set clear_top\n@@ -647,1 +647,1 @@\n-    const RegionData* const sr = region(split_region);\n+    const regiondata* const sr = region(split_region);\n@@ -653,1 +653,1 @@\n-    log_develop_trace(gc, compaction)(\"split:  clearing source_region field in [\" SIZE_FORMAT \", \" SIZE_FORMAT \")\", beg_idx, end_idx);\n+    log_develop_trace(gc, compaction)(\"split:  clearing source_region field in [\" size_format \", \" size_format \")\", beg_idx, end_idx);\n@@ -658,1 +658,1 @@\n-    \/\/ Set split_destination and partial_obj_size to reflect the split region.\n+    \/\/ set split_destination and partial_obj_size to reflect the split region.\n@@ -663,1 +663,1 @@\n-  \/\/ The split is recorded only if a partial object extends onto the region.\n+  \/\/ the split is recorded only if a partial object extends onto the region.\n@@ -669,1 +669,1 @@\n-  \/\/ Setup the continuation addresses.\n+  \/\/ setup the continuation addresses.\n@@ -671,1 +671,1 @@\n-  HeapWord* const source_next = region_to_addr(split_region) + partial_obj_size;\n+  heapword* const source_next = region_to_addr(split_region) + partial_obj_size;\n@@ -673,1 +673,1 @@\n-  if (log_develop_is_enabled(Trace, gc, compaction)) {\n+  if (log_develop_is_enabled(trace, gc, compaction)) {\n@@ -675,1 +675,1 @@\n-    log_develop_trace(gc, compaction)(\"%s split:  src=\" PTR_FORMAT \" src_c=\" SIZE_FORMAT \" pos=\" SIZE_FORMAT,\n+    log_develop_trace(gc, compaction)(\"%s split:  src=\" ptr_format \" src_c=\" size_format \" pos=\" size_format,\n@@ -677,1 +677,1 @@\n-    log_develop_trace(gc, compaction)(\"%s split:  dst=\" PTR_FORMAT \" dst_c=\" SIZE_FORMAT \" tn=\" PTR_FORMAT,\n+    log_develop_trace(gc, compaction)(\"%s split:  dst=\" ptr_format \" dst_c=\" size_format \" tn=\" ptr_format,\n@@ -683,3 +683,3 @@\n-      HeapWord* const po_beg = split_info.destination();\n-      HeapWord* const po_end = po_beg + split_info.partial_obj_size();\n-      log_develop_trace(gc, compaction)(\"%s split:  po_beg=\" PTR_FORMAT \" \" SIZE_FORMAT \" po_end=\" PTR_FORMAT \" \" SIZE_FORMAT,\n+      heapword* const po_beg = split_info.destination();\n+      heapword* const po_end = po_beg + split_info.partial_obj_size();\n+      log_develop_trace(gc, compaction)(\"%s split:  po_beg=\" ptr_format \" \" size_format \" po_end=\" ptr_format \" \" size_format,\n@@ -695,5 +695,5 @@\n-bool ParallelCompactData::summarize(SplitInfo& split_info,\n-                                    HeapWord* source_beg, HeapWord* source_end,\n-                                    HeapWord** source_next,\n-                                    HeapWord* target_beg, HeapWord* target_end,\n-                                    HeapWord** target_next)\n+bool parallelcompactdata::summarize(splitinfo& split_info,\n+                                    heapword* source_beg, heapword* source_end,\n+                                    heapword** source_next,\n+                                    heapword* target_beg, heapword* target_end,\n+                                    heapword** target_next)\n@@ -701,1 +701,1 @@\n-  HeapWord* const source_next_val = source_next == NULL ? NULL : *source_next;\n+  heapword* const source_next_val = source_next == null ? null : *source_next;\n@@ -703,2 +703,2 @@\n-      \"sb=\" PTR_FORMAT \" se=\" PTR_FORMAT \" sn=\" PTR_FORMAT\n-      \"tb=\" PTR_FORMAT \" te=\" PTR_FORMAT \" tn=\" PTR_FORMAT,\n+      \"sb=\" ptr_format \" se=\" ptr_format \" sn=\" ptr_format\n+      \"tb=\" ptr_format \" te=\" ptr_format \" tn=\" ptr_format,\n@@ -711,1 +711,1 @@\n-  HeapWord *dest_addr = target_beg;\n+  heapword *dest_addr = target_beg;\n@@ -713,1 +713,1 @@\n-    \/\/ The destination must be set even if the region has no data.\n+    \/\/ the destination must be set even if the region has no data.\n@@ -718,1 +718,1 @@\n-      \/\/ If cur_region does not fit entirely into the target space, find a point\n+      \/\/ if cur_region does not fit entirely into the target space, find a point\n@@ -722,1 +722,1 @@\n-        assert(source_next != NULL, \"source_next is NULL when splitting\");\n+        assert(source_next != null, \"source_next is null when splitting\");\n@@ -728,2 +728,2 @@\n-      \/\/ Compute the destination_count for cur_region, and if necessary, update\n-      \/\/ source_region for a destination region.  The source_region field is\n+      \/\/ compute the destination_count for cur_region, and if necessary, update\n+      \/\/ source_region for a destination region.  the source_region field is\n@@ -733,1 +733,1 @@\n-      \/\/ The destination_count calculation is a bit subtle.  A region that has\n+      \/\/ the destination_count calculation is a bit subtle.  a region that has\n@@ -735,1 +735,1 @@\n-      \/\/ This maintains the invariant that a zero count means the region is\n+      \/\/ this maintains the invariant that a zero count means the region is\n@@ -739,1 +739,1 @@\n-        \/\/ The current region has been split:  the partial object will be copied\n+        \/\/ the current region has been split:  the partial object will be copied\n@@ -741,1 +741,1 @@\n-        \/\/ another destination space.  Adjust the initial destination_count and,\n+        \/\/ another destination space.  adjust the initial destination_count and,\n@@ -751,1 +751,1 @@\n-      HeapWord* const last_addr = dest_addr + words - 1;\n+      heapword* const last_addr = dest_addr + words - 1;\n@@ -755,2 +755,2 @@\n-      \/\/ Initially assume that the destination regions will be the same and\n-      \/\/ adjust the value below if necessary.  Under this assumption, if\n+      \/\/ initially assume that the destination regions will be the same and\n+      \/\/ adjust the value below if necessary.  under this assumption, if\n@@ -761,1 +761,1 @@\n-        \/\/ Destination regions differ; adjust destination_count.\n+        \/\/ destination regions differ; adjust destination_count.\n@@ -763,1 +763,1 @@\n-        \/\/ Data from cur_region will be copied to the start of dest_region_2.\n+        \/\/ data from cur_region will be copied to the start of dest_region_2.\n@@ -766,1 +766,1 @@\n-        \/\/ Data from cur_region will be copied to the start of the destination\n+        \/\/ data from cur_region will be copied to the start of the destination\n@@ -783,4 +783,4 @@\n-HeapWord* ParallelCompactData::calc_new_pointer(HeapWord* addr, ParCompactionManager* cm, bool use_block_table) const {\n-  assert(addr != NULL, \"Should detect NULL oop earlier\");\n-  assert(ParallelScavengeHeap::heap()->is_in(addr), \"not in heap\");\n-  assert(PSParallelCompact::mark_bitmap()->is_marked(addr), \"not marked\");\n+heapword* parallelcompactdata::calc_new_pointer(heapword* addr, parcompactionmanager* cm, bool use_block_table) const {\n+  assert(addr != null, \"should detect null oop earlier\");\n+  assert(parallelscavengeheap::heap()->is_in(addr), \"not in heap\");\n+  assert(psparallelcompact::mark_bitmap()->is_marked(addr), \"not marked\");\n@@ -788,3 +788,3 @@\n-  \/\/ Region covering the object.\n-  RegionData* const region_ptr = addr_to_region_ptr(addr);\n-  HeapWord* result = region_ptr->destination();\n+  \/\/ region covering the object.\n+  regiondata* const region_ptr = addr_to_region_ptr(addr);\n+  heapword* result = region_ptr->destination();\n@@ -792,2 +792,2 @@\n-  \/\/ If the entire Region is live, the new location is region->destination + the\n-  \/\/ offset of the object within in the Region.\n+  \/\/ if the entire region is live, the new location is region->destination + the\n+  \/\/ offset of the object within in the region.\n@@ -795,2 +795,2 @@\n-  \/\/ Run some performance tests to determine if this special case pays off.  It\n-  \/\/ is worth it for pointers into the dense prefix.  If the optimization to\n+  \/\/ run some performance tests to determine if this special case pays off.  it\n+  \/\/ is worth it for pointers into the dense prefix.  if the optimization to\n@@ -799,1 +799,1 @@\n-  if (region_ptr->data_size() == RegionSize) {\n+  if (region_ptr->data_size() == regionsize) {\n@@ -804,3 +804,3 @@\n-  \/\/ Otherwise, the new location is region->destination + #live words to left\n-  \/\/ of addr in this region. Calculating #live words naively means walking the\n-  \/\/ mark bitmap from the start of this region. Block table can be used to\n+  \/\/ otherwise, the new location is region->destination + #live words to left\n+  \/\/ of addr in this region. calculating #live words naively means walking the\n+  \/\/ mark bitmap from the start of this region. block table can be used to\n@@ -808,2 +808,3 @@\n-  \/\/ code, we prefer the side-effect free version so that no side-effect will\n-  \/\/ not leak into release code.\n+  \/\/ code (such as asserts), we prefer the slower but side-effect free version,\n+  \/\/ to avoid side effects that would not occur for release code and could\n+  \/\/ potentially affect future calculations.\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":325,"deletions":324,"binary":false,"changes":649,"status":"modified"}]}