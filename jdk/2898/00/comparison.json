{"files":[{"patch":"@@ -783,1 +783,1 @@\n-HeapWord* ParallelCompactData::calc_new_pointer(HeapWord* addr, ParCompactionManager* cm) const {\n+HeapWord* ParallelCompactData::calc_new_pointer(HeapWord* addr, ParCompactionManager* cm, bool use_block_table) const {\n@@ -804,3 +804,9 @@\n-  \/\/ Otherwise, the new location is region->destination + block offset + the\n-  \/\/ number of live words in the Block that are (a) to the left of addr and (b)\n-  \/\/ due to objects that start in the Block.\n+  \/\/ Otherwise, the new location is region->destination + #live words to left\n+  \/\/ of addr in this region. Calculating #live words naively means walking the\n+  \/\/ mark bitmap from the start of this region. Block table can be used to\n+  \/\/ speed up this process, but it would incur some side-effect. In debug-only\n+  \/\/ code, we prefer the side-effect free version so that no side-effect will\n+  \/\/ not leak into release code.\n+  if (use_block_table) {\n+    \/\/ #live words = block offset + #live words in the Block that are\n+    \/\/ (a) to the left of addr and (b) due to objects that start in the Block.\n@@ -808,7 +814,10 @@\n-  \/\/ Fill in the block table if necessary.  This is unsynchronized, so multiple\n-  \/\/ threads may fill the block table for a region (harmless, since it is\n-  \/\/ idempotent).\n-  if (!region_ptr->blocks_filled()) {\n-    PSParallelCompact::fill_blocks(addr_to_region_idx(addr));\n-    region_ptr->set_blocks_filled();\n-  }\n+    \/\/ Fill in the block table if necessary.  This is unsynchronized, so multiple\n+    \/\/ threads may fill the block table for a region (harmless, since it is\n+    \/\/ idempotent).\n+    if (!region_ptr->blocks_filled()) {\n+      PSParallelCompact::fill_blocks(addr_to_region_idx(addr));\n+      region_ptr->set_blocks_filled();\n+    }\n+\n+    HeapWord* const search_start = block_align_down(addr);\n+    const size_t block_offset = addr_to_block_ptr(addr)->offset();\n@@ -816,2 +825,10 @@\n-  HeapWord* const search_start = block_align_down(addr);\n-  const size_t block_offset = addr_to_block_ptr(addr)->offset();\n+    const ParMarkBitMap* bitmap = PSParallelCompact::mark_bitmap();\n+    const size_t live = bitmap->live_words_in_range(cm, search_start, oop(addr));\n+    result += block_offset + live;\n+  } else {\n+    guarantee(trueInDebug, \"Only in debug build\");\n+    auto bitmap = PSParallelCompact::mark_bitmap();\n+    auto live = region_ptr->partial_obj_size()\n+              + bitmap->live_words_in_range(cm, region_align_down(addr), oop(addr));\n+    result += live;\n+  }\n@@ -819,3 +836,0 @@\n-  const ParMarkBitMap* bitmap = PSParallelCompact::mark_bitmap();\n-  const size_t live = bitmap->live_words_in_range(cm, search_start, oop(addr));\n-  result += block_offset + live;\n@@ -3284,1 +3298,1 @@\n-  assert(PSParallelCompact::summary_data().calc_new_pointer(source(), compaction_manager()) ==\n+  assert(PSParallelCompact::summary_data().calc_new_pointer(source(), compaction_manager(), false) ==\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":31,"deletions":17,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -483,1 +483,3 @@\n-  HeapWord* calc_new_pointer(HeapWord* addr, ParCompactionManager* cm) const;\n+  HeapWord* calc_new_pointer(HeapWord* addr,\n+                             ParCompactionManager* cm,\n+                             bool use_block_table = true) const;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}