{"files":[{"patch":"@@ -338,1 +338,0 @@\n-            cert = new X509CertImpl(info);\n@@ -341,1 +340,1 @@\n-                cert.sign(signerPrivateKey, sigAlg);\n+                cert = X509CertImpl.newSigned(info, signerPrivateKey, sigAlg);\n@@ -343,1 +342,1 @@\n-                cert.sign(privateKey, sigAlg);\n+                cert = X509CertImpl.newSigned(info, privateKey, sigAlg);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/CertAndKeyGen.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1539,2 +1539,2 @@\n-        X509CertImpl cert = new X509CertImpl(info);\n-        cert.sign(privateKey, sigAlgName);\n+        X509CertImpl cert = X509CertImpl\n+                .newSigned(info, privateKey, sigAlgName);\n@@ -1592,2 +1592,3 @@\n-        X509CRLImpl crl = new X509CRLImpl(owner, firstDate, lastDate, badCerts);\n-        crl.sign(privateKey, sigAlgName);\n+        X509CRLImpl crl = X509CRLImpl.newSigned(\n+                new X509CRLImpl.TBSCertList(owner, firstDate, lastDate, badCerts),\n+                privateKey, sigAlgName);\n@@ -3231,2 +3232,2 @@\n-        X509CertImpl newCert = new X509CertImpl(certInfo);\n-        newCert.sign(privKey, sigAlgName);\n+        X509CertImpl newCert = X509CertImpl.newSigned(\n+                certInfo, privKey, sigAlgName);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/Main.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.io.OutputStream;\n@@ -91,0 +90,2 @@\n+    private TBSCertList info;\n+\n@@ -92,11 +93,126 @@\n-    private int              version;\n-    private AlgorithmId      infoSigAlgId; \/\/ sig alg in \"to-be-signed\" crl\n-    private X500Name         issuer = null;\n-    private X500Principal    issuerPrincipal = null;\n-    private Date             thisUpdate = null;\n-    private Date             nextUpdate = null;\n-    private final Map<X509IssuerSerial,X509CRLEntry> revokedMap =\n-            new TreeMap<>();\n-    private final List<X509CRLEntry> revokedList = new LinkedList<>();\n-    private CRLExtensions    extensions = null;\n-    private static final boolean isExplicit = true;\n+    public static class TBSCertList {\n+        private int version;\n+        private AlgorithmId infoSigAlgId; \/\/ sig alg in \"to-be-signed\" crl\n+        private X500Name issuer = null;\n+        private X500Principal issuerPrincipal = null;\n+        private Date thisUpdate = null;\n+        private Date nextUpdate = null;\n+        private final Map<X509IssuerSerial, X509CRLEntry> revokedMap =\n+                new TreeMap<>();\n+        private final List<X509CRLEntry> revokedList = new LinkedList<>();\n+        private CRLExtensions extensions = null;\n+\n+        \/**\n+         * Initial TBSCertList constructor, no revoked certs, and no extensions.\n+         *\n+         * @param issuer the name of the CA issuing this CRL.\n+         * @param thisDate the Date of this issue.\n+         * @param nextDate the Date of the next CRL.\n+         *\/\n+        public TBSCertList(X500Name issuer, Date thisDate, Date nextDate) {\n+            this.issuer = issuer;\n+            this.thisUpdate = thisDate;\n+            this.nextUpdate = nextDate;\n+        }\n+\n+        \/**\n+         * TBSCertList constructor, revoked certs, no extensions.\n+         *\n+         * @param issuer the name of the CA issuing this CRL.\n+         * @param thisDate the Date of this issue.\n+         * @param nextDate the Date of the next CRL.\n+         * @param badCerts the array of CRL entries.\n+         *\n+         * @exception CRLException on parsing\/construction errors.\n+         *\/\n+        public TBSCertList(X500Name issuer, Date thisDate, Date nextDate,\n+                           X509CRLEntry[] badCerts)\n+                throws CRLException\n+        {\n+            this.issuer = issuer;\n+            this.thisUpdate = thisDate;\n+            this.nextUpdate = nextDate;\n+            if (badCerts != null) {\n+                X500Principal crlIssuer = getIssuerX500Principal();\n+                X500Principal badCertIssuer = crlIssuer;\n+                for (int i = 0; i < badCerts.length; i++) {\n+                    X509CRLEntryImpl badCert = (X509CRLEntryImpl)badCerts[i];\n+                    badCertIssuer = getCertIssuer(badCert, badCertIssuer);\n+                    badCert.setCertificateIssuer(crlIssuer, badCertIssuer);\n+                    X509IssuerSerial issuerSerial = new X509IssuerSerial\n+                            (badCertIssuer, badCert.getSerialNumber());\n+                    this.revokedMap.put(issuerSerial, badCert);\n+                    this.revokedList.add(badCert);\n+                    if (badCert.hasExtensions()) {\n+                        this.version = 1;\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * TBSCertList constructor, revoked certs and extensions.\n+         *\n+         * @param issuer the name of the CA issuing this CRL.\n+         * @param thisDate the Date of this issue.\n+         * @param nextDate the Date of the next CRL.\n+         * @param badCerts the array of CRL entries.\n+         * @param crlExts the CRL extensions.\n+         *\n+         * @exception CRLException on parsing\/construction errors.\n+         *\/\n+        public TBSCertList(X500Name issuer, Date thisDate, Date nextDate,\n+                           X509CRLEntry[] badCerts, CRLExtensions crlExts)\n+                throws CRLException\n+        {\n+            this(issuer, thisDate, nextDate, badCerts);\n+            if (crlExts != null) {\n+                this.extensions = crlExts;\n+                this.version = 1;\n+            }\n+        }\n+\n+        \/**\n+         * Constructs from the encoding.\n+         *\/\n+        public TBSCertList(DerValue value) throws IOException, CRLException {\n+\n+            if (value.tag != DerValue.tag_Sequence)\n+                throw new CRLException(\"signed CRL fields invalid\");\n+\n+            \/\/ parse the information\n+            DerInputStream derStrm = value.data;\n+            DerValue       tmp;\n+            byte           nextByte;\n+\n+            \/\/ version (optional if v1)\n+            version = 0;   \/\/ by default, version = v1 == 0\n+            nextByte = (byte)derStrm.peekByte();\n+            if (nextByte == DerValue.tag_Integer) {\n+                version = derStrm.getInteger();\n+                if (version != 1)  \/\/ i.e. v2\n+                    throw new CRLException(\"Invalid version\");\n+            }\n+            tmp = derStrm.getDerValue();\n+\n+            \/\/ signature\n+            infoSigAlgId = AlgorithmId.parse(tmp);\n+\n+            \/\/ issuer\n+            issuer = new X500Name(derStrm);\n+            if (issuer.isEmpty()) {\n+                throw new CRLException(\"Empty issuer DN not allowed in X509CRLs\");\n+            }\n+\n+            \/\/ thisUpdate\n+            \/\/ check if UTCTime encoded or GeneralizedTime\n+\n+            nextByte = (byte)derStrm.peekByte();\n+            if (nextByte == DerValue.tag_UtcTime) {\n+                thisUpdate = derStrm.getUTCTime();\n+            } else if (nextByte == DerValue.tag_GeneralizedTime) {\n+                thisUpdate = derStrm.getGeneralizedTime();\n+            } else {\n+                throw new CRLException(\"Invalid encoding for thisUpdate\"\n+                        + \" (tag=\" + nextByte + \")\");\n+            }\n@@ -104,1 +220,126 @@\n-    private boolean readOnly = false;\n+            if (derStrm.available() == 0)\n+                return;     \/\/ done parsing no more optional fields present\n+\n+            \/\/ nextUpdate (optional)\n+            nextByte = (byte)derStrm.peekByte();\n+            if (nextByte == DerValue.tag_UtcTime) {\n+                nextUpdate = derStrm.getUTCTime();\n+            } else if (nextByte == DerValue.tag_GeneralizedTime) {\n+                nextUpdate = derStrm.getGeneralizedTime();\n+            } \/\/ else it is not present\n+\n+            if (derStrm.available() == 0)\n+                return;     \/\/ done parsing no more optional fields present\n+\n+            \/\/ revokedCertificates (optional)\n+            nextByte = (byte)derStrm.peekByte();\n+            if ((nextByte == DerValue.tag_SequenceOf)\n+                    && (! ((nextByte & 0x0c0) == 0x080))) {\n+                DerValue[] badCerts = derStrm.getSequence(4);\n+\n+                X500Principal crlIssuer = getIssuerX500Principal();\n+                X500Principal badCertIssuer = crlIssuer;\n+                for (int i = 0; i < badCerts.length; i++) {\n+                    X509CRLEntryImpl entry = new X509CRLEntryImpl(badCerts[i]);\n+                    badCertIssuer = getCertIssuer(entry, badCertIssuer);\n+                    entry.setCertificateIssuer(crlIssuer, badCertIssuer);\n+                    X509IssuerSerial issuerSerial = new X509IssuerSerial\n+                            (badCertIssuer, entry.getSerialNumber());\n+                    revokedMap.put(issuerSerial, entry);\n+                    revokedList.add(entry);\n+                }\n+            }\n+\n+            if (derStrm.available() == 0)\n+                return;     \/\/ done parsing no extensions\n+\n+            \/\/ crlExtensions (optional)\n+            tmp = derStrm.getDerValue();\n+            if (tmp.isConstructed() && tmp.isContextSpecific((byte)0)) {\n+                extensions = new CRLExtensions(tmp.data);\n+            }\n+        }\n+\n+        \/**\n+         * Return the issuer as X500Principal.\n+         *\/\n+        public X500Principal getIssuerX500Principal() {\n+            if (issuerPrincipal == null) {\n+                issuerPrincipal = issuer.asX500Principal();\n+            }\n+            return issuerPrincipal;\n+        }\n+\n+        \/**\n+         * Returns the X500 certificate issuer DN of a CRL entry.\n+         *\n+         * @param entry the entry to check\n+         * @param prevCertIssuer the previous entry's certificate issuer\n+         * @return the X500Principal in a CertificateIssuerExtension, or\n+         *   prevCertIssuer if it does not exist\n+         *\/\n+        private X500Principal getCertIssuer(X509CRLEntryImpl entry,\n+                                            X500Principal prevCertIssuer) {\n+\n+            CertificateIssuerExtension ciExt =\n+                    entry.getCertificateIssuerExtension();\n+            if (ciExt != null) {\n+                GeneralNames names = ciExt.getNames();\n+                X500Name issuerDN = (X500Name) names.get(0).getName();\n+                return issuerDN.asX500Principal();\n+            } else {\n+                return prevCertIssuer;\n+            }\n+        }\n+\n+        \/**\n+         * Encodes the \"to-be-signed\" TBSCertList to the OutputStream.\n+         *\n+         * @exception CRLException on encoding errors.\n+         *\/\n+        public byte[] encodeInfo() throws CRLException {\n+            try {\n+                DerOutputStream tmp = new DerOutputStream();\n+                DerOutputStream rCerts = new DerOutputStream();\n+                DerOutputStream seq = new DerOutputStream();\n+\n+                if (version != 0) \/\/ v2 crl encode version\n+                    tmp.putInteger(version);\n+                infoSigAlgId.encode(tmp);\n+                if ((version == 0) && (issuer.toString() == null))\n+                    throw new CRLException(\"Null Issuer DN not allowed in v1 CRL\");\n+                issuer.encode(tmp);\n+\n+                if (thisUpdate.getTime() < CertificateValidity.YR_2050)\n+                    tmp.putUTCTime(thisUpdate);\n+                else\n+                    tmp.putGeneralizedTime(thisUpdate);\n+\n+                if (nextUpdate != null) {\n+                    if (nextUpdate.getTime() < CertificateValidity.YR_2050)\n+                        tmp.putUTCTime(nextUpdate);\n+                    else\n+                        tmp.putGeneralizedTime(nextUpdate);\n+                }\n+\n+                if (!revokedList.isEmpty()) {\n+                    for (X509CRLEntry entry : revokedList) {\n+                        ((X509CRLEntryImpl)entry).encode(rCerts);\n+                    }\n+                    tmp.write(DerValue.tag_Sequence, rCerts);\n+                }\n+\n+                if (extensions != null)\n+                    extensions.encode(tmp, isExplicit);\n+\n+                seq.write(DerValue.tag_Sequence, tmp);\n+\n+                return seq.toByteArray();\n+            } catch (IOException e) {\n+                throw new CRLException(\"Encoding error: \" + e.getMessage());\n+            }\n+        }\n+\n+    }\n+\n+    private static final boolean isExplicit = true;\n@@ -120,2 +361,2 @@\n-     * Not to be used. As it would lead to cases of uninitialized\n-     * CRL objects.\n+     * Constructor simply setting all (non-cache) fields. Only used in\n+     * {@link #newSigned}.\n@@ -123,1 +364,8 @@\n-    private X509CRLImpl() { }\n+    public X509CRLImpl(TBSCertList info, AlgorithmId sigAlgId, byte[] signature,\n+                       byte[] tbsCertList, byte[] signedCRL) {\n+        this.info = info;\n+        this.sigAlgId = sigAlgId;\n+        this.signature = signature;\n+        this.tbsCertList = tbsCertList;\n+        this.signedCRL = Objects.requireNonNull(signedCRL);\n+    }\n@@ -139,1 +387,0 @@\n-            signedCRL = null;\n@@ -154,1 +401,0 @@\n-            signedCRL = null;\n@@ -170,1 +416,0 @@\n-            signedCRL = null;\n@@ -175,68 +420,2 @@\n-    \/**\n-     * Initial CRL constructor, no revoked certs, and no extensions.\n-     *\n-     * @param issuer the name of the CA issuing this CRL.\n-     * @param thisDate the Date of this issue.\n-     * @param nextDate the Date of the next CRL.\n-     *\/\n-    public X509CRLImpl(X500Name issuer, Date thisDate, Date nextDate) {\n-        this.issuer = issuer;\n-        this.thisUpdate = thisDate;\n-        this.nextUpdate = nextDate;\n-    }\n-\n-    \/**\n-     * CRL constructor, revoked certs, no extensions.\n-     *\n-     * @param issuer the name of the CA issuing this CRL.\n-     * @param thisDate the Date of this issue.\n-     * @param nextDate the Date of the next CRL.\n-     * @param badCerts the array of CRL entries.\n-     *\n-     * @exception CRLException on parsing\/construction errors.\n-     *\/\n-    public X509CRLImpl(X500Name issuer, Date thisDate, Date nextDate,\n-                       X509CRLEntry[] badCerts)\n-        throws CRLException\n-    {\n-        this.issuer = issuer;\n-        this.thisUpdate = thisDate;\n-        this.nextUpdate = nextDate;\n-        if (badCerts != null) {\n-            X500Principal crlIssuer = getIssuerX500Principal();\n-            X500Principal badCertIssuer = crlIssuer;\n-            for (int i = 0; i < badCerts.length; i++) {\n-                X509CRLEntryImpl badCert = (X509CRLEntryImpl)badCerts[i];\n-                badCertIssuer = getCertIssuer(badCert, badCertIssuer);\n-                badCert.setCertificateIssuer(crlIssuer, badCertIssuer);\n-                X509IssuerSerial issuerSerial = new X509IssuerSerial\n-                    (badCertIssuer, badCert.getSerialNumber());\n-                this.revokedMap.put(issuerSerial, badCert);\n-                this.revokedList.add(badCert);\n-                if (badCert.hasExtensions()) {\n-                    this.version = 1;\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * CRL constructor, revoked certs and extensions.\n-     *\n-     * @param issuer the name of the CA issuing this CRL.\n-     * @param thisDate the Date of this issue.\n-     * @param nextDate the Date of the next CRL.\n-     * @param badCerts the array of CRL entries.\n-     * @param crlExts the CRL extensions.\n-     *\n-     * @exception CRLException on parsing\/construction errors.\n-     *\/\n-    public X509CRLImpl(X500Name issuer, Date thisDate, Date nextDate,\n-               X509CRLEntry[] badCerts, CRLExtensions crlExts)\n-        throws CRLException\n-    {\n-        this(issuer, thisDate, nextDate, badCerts);\n-        if (crlExts != null) {\n-            this.extensions = crlExts;\n-            this.version = 1;\n-        }\n+    public TBSCertList info() {\n+        return info;\n@@ -251,3 +430,0 @@\n-        if (signedCRL == null) {\n-            throw new CRLException(\"Null CRL to encode\");\n-        }\n@@ -266,50 +442,0 @@\n-    \/**\n-     * Encodes the \"to-be-signed\" CRL to the OutputStream.\n-     *\n-     * @param out the OutputStream to write to.\n-     * @exception CRLException on encoding errors.\n-     *\/\n-    public void encodeInfo(OutputStream out) throws CRLException {\n-        try {\n-            DerOutputStream tmp = new DerOutputStream();\n-            DerOutputStream rCerts = new DerOutputStream();\n-            DerOutputStream seq = new DerOutputStream();\n-\n-            if (version != 0) \/\/ v2 crl encode version\n-                tmp.putInteger(version);\n-            infoSigAlgId.encode(tmp);\n-            if ((version == 0) && (issuer.toString() == null))\n-                throw new CRLException(\"Null Issuer DN not allowed in v1 CRL\");\n-            issuer.encode(tmp);\n-\n-            if (thisUpdate.getTime() < CertificateValidity.YR_2050)\n-                tmp.putUTCTime(thisUpdate);\n-            else\n-                tmp.putGeneralizedTime(thisUpdate);\n-\n-            if (nextUpdate != null) {\n-                if (nextUpdate.getTime() < CertificateValidity.YR_2050)\n-                    tmp.putUTCTime(nextUpdate);\n-                else\n-                    tmp.putGeneralizedTime(nextUpdate);\n-            }\n-\n-            if (!revokedList.isEmpty()) {\n-                for (X509CRLEntry entry : revokedList) {\n-                    ((X509CRLEntryImpl)entry).encode(rCerts);\n-                }\n-                tmp.write(DerValue.tag_Sequence, rCerts);\n-            }\n-\n-            if (extensions != null)\n-                extensions.encode(tmp, isExplicit);\n-\n-            seq.write(DerValue.tag_Sequence, tmp);\n-\n-            tbsCertList = seq.toByteArray();\n-            out.write(tbsCertList);\n-        } catch (IOException e) {\n-             throw new CRLException(\"Encoding error: \" + e.getMessage());\n-        }\n-    }\n-\n@@ -365,3 +491,0 @@\n-        if (signedCRL == null) {\n-            throw new CRLException(\"Uninitialized CRL\");\n-        }\n@@ -418,3 +541,0 @@\n-        if (signedCRL == null) {\n-            throw new CRLException(\"Uninitialized CRL\");\n-        }\n@@ -451,1 +571,1 @@\n-     * Encodes an X.509 CRL, and signs it using the given key.\n+     * Creates a new X.509 CRL, which is signed using the given key.\n@@ -453,0 +573,1 @@\n+     * @param info the TBSCertList to sign\n@@ -455,0 +576,1 @@\n+     * @return a newly signed CRL\n@@ -462,1 +584,1 @@\n-    public void sign(PrivateKey key, String algorithm)\n+    public static X509CRLImpl newSigned(TBSCertList info, PrivateKey key, String algorithm)\n@@ -465,1 +587,1 @@\n-        sign(key, algorithm, null);\n+        return newSigned(info, key, algorithm, null);\n@@ -469,1 +591,1 @@\n-     * Encodes an X.509 CRL, and signs it using the given key.\n+     * Creates a new X.509 CRL, which is signed using the given key.\n@@ -471,0 +593,1 @@\n+     * @param info the TBSCertList to sign\n@@ -474,0 +597,1 @@\n+     * @return a newly signed CRL\n@@ -481,1 +605,1 @@\n-    public void sign(PrivateKey key, String algorithm, String provider)\n+    public static X509CRLImpl newSigned(TBSCertList info, PrivateKey key, String algorithm, String provider)\n@@ -485,3 +609,0 @@\n-            if (readOnly)\n-                throw new CRLException(\"cannot over-write existing CRL\");\n-\n@@ -489,2 +610,2 @@\n-            sigAlgId = SignatureUtil.fromSignature(sigEngine, key);\n-            infoSigAlgId = sigAlgId;\n+            AlgorithmId sigAlgId = SignatureUtil.fromSignature(sigEngine, key);\n+            info.infoSigAlgId = sigAlgId;\n@@ -496,1 +617,2 @@\n-            encodeInfo(tmp);\n+            byte[] tbsCertList = info.encodeInfo();\n+            tmp.writeBytes(tbsCertList);\n@@ -503,1 +625,1 @@\n-            signature = sigEngine.sign();\n+            byte[] signature = sigEngine.sign();\n@@ -508,2 +630,1 @@\n-            signedCRL = out.toByteArray();\n-            readOnly = true;\n+            byte[] signedCRL = out.toByteArray();\n@@ -511,0 +632,2 @@\n+            return new X509CRLImpl(info, sigAlgId, signature,\n+                    tbsCertList, signedCRL);\n@@ -530,1 +653,1 @@\n-            .append(version+1)\n+            .append(info.version+1)\n@@ -538,1 +661,1 @@\n-        if (issuer != null)\n+        if (info.issuer != null)\n@@ -540,1 +663,1 @@\n-                .append(issuer)\n+                .append(info.issuer)\n@@ -542,1 +665,1 @@\n-        if (thisUpdate != null)\n+        if (info.thisUpdate != null)\n@@ -544,1 +667,1 @@\n-                .append(thisUpdate)\n+                .append(info.thisUpdate)\n@@ -546,1 +669,1 @@\n-        if (nextUpdate != null)\n+        if (info.nextUpdate != null)\n@@ -548,1 +671,1 @@\n-                .append(nextUpdate)\n+                .append(info.nextUpdate)\n@@ -550,1 +673,1 @@\n-        if (revokedList.isEmpty())\n+        if (info.revokedList.isEmpty())\n@@ -554,1 +677,1 @@\n-                .append(revokedList.size());\n+                .append(info.revokedList.size());\n@@ -556,1 +679,1 @@\n-            for (X509CRLEntry entry: revokedList) {\n+            for (X509CRLEntry entry: info.revokedList) {\n@@ -563,2 +686,2 @@\n-        if (extensions != null) {\n-            Collection<Extension> allExts = extensions.getAllExtensions();\n+        if (info.extensions != null) {\n+            Collection<Extension> allExts = info.extensions.getAllExtensions();\n@@ -612,1 +735,1 @@\n-        if (revokedMap.isEmpty() ||\n+        if (info.revokedMap.isEmpty() ||\n@@ -617,1 +740,1 @@\n-        return revokedMap.containsKey(issuerSerial);\n+        return info.revokedMap.containsKey(issuerSerial);\n@@ -631,1 +754,1 @@\n-        return version+1;\n+        return info.version+1;\n@@ -664,1 +787,1 @@\n-        return issuer;\n+        return info.issuer;\n@@ -672,4 +795,1 @@\n-        if (issuerPrincipal == null) {\n-            issuerPrincipal = issuer.asX500Principal();\n-        }\n-        return issuerPrincipal;\n+        return info.getIssuerX500Principal();\n@@ -685,1 +805,1 @@\n-        return new Date(thisUpdate.getTime());\n+        return new Date(info.thisUpdate.getTime());\n@@ -695,1 +815,1 @@\n-        if (nextUpdate == null)\n+        if (info.nextUpdate == null)\n@@ -697,1 +817,1 @@\n-        return new Date(nextUpdate.getTime());\n+        return new Date(info.nextUpdate.getTime());\n@@ -708,1 +828,1 @@\n-        if (revokedMap.isEmpty()) {\n+        if (info.revokedMap.isEmpty()) {\n@@ -714,1 +834,1 @@\n-        return revokedMap.get(issuerSerial);\n+        return info.revokedMap.get(issuerSerial);\n@@ -721,1 +841,1 @@\n-        if (revokedMap.isEmpty()) {\n+        if (info.revokedMap.isEmpty()) {\n@@ -725,1 +845,1 @@\n-        return revokedMap.get(issuerSerial);\n+        return info.revokedMap.get(issuerSerial);\n@@ -737,1 +857,1 @@\n-        if (revokedList.isEmpty()) {\n+        if (info.revokedList.isEmpty()) {\n@@ -740,1 +860,1 @@\n-            return new TreeSet<>(revokedList);\n+            return new TreeSet<>(info.revokedList);\n@@ -932,1 +1052,1 @@\n-        if (extensions == null)\n+        if (info.extensions == null)\n@@ -934,1 +1054,1 @@\n-        return extensions.hasUnsupportedCriticalExtension();\n+        return info.extensions.hasUnsupportedCriticalExtension();\n@@ -946,1 +1066,1 @@\n-        if (extensions == null) {\n+        if (info.extensions == null) {\n@@ -950,1 +1070,1 @@\n-        for (Extension ex : extensions.getAllExtensions()) {\n+        for (Extension ex : info.extensions.getAllExtensions()) {\n@@ -967,1 +1087,1 @@\n-        if (extensions == null) {\n+        if (info.extensions == null) {\n@@ -971,1 +1091,1 @@\n-        for (Extension ex : extensions.getAllExtensions()) {\n+        for (Extension ex : info.extensions.getAllExtensions()) {\n@@ -991,1 +1111,1 @@\n-        if (extensions == null)\n+        if (info.extensions == null)\n@@ -999,1 +1119,1 @@\n-                for (Extension ex : extensions.getAllExtensions()) {\n+                for (Extension ex : info.extensions.getAllExtensions()) {\n@@ -1007,1 +1127,1 @@\n-                crlExt = extensions.getExtension(extAlias);\n+                crlExt = info.extensions.getExtension(extAlias);\n@@ -1028,1 +1148,1 @@\n-        if (extensions == null)\n+        if (info.extensions == null)\n@@ -1032,1 +1152,1 @@\n-        return extensions.getExtension(OIDMap.getName(oid));\n+        return info.extensions.getExtension(OIDMap.getName(oid));\n@@ -1039,3 +1159,0 @@\n-        \/\/ check if we can overwrite the certificate\n-        if (readOnly)\n-            throw new CRLException(\"cannot over-write existing CRL\");\n@@ -1057,2 +1174,1 @@\n-        if (seq[0].tag != DerValue.tag_Sequence)\n-            throw new CRLException(\"signed CRL fields invalid\");\n+        info = new TBSCertList(seq[0]);\n@@ -1061,0 +1177,5 @@\n+        \/\/ the \"inner\" and \"outer\" signature algorithms must match\n+        if (!sigAlgId.equals(info.infoSigAlgId)) {\n+            throw new CRLException(\"Signature algorithm mismatch\");\n+        }\n+\n@@ -1072,77 +1193,0 @@\n-        \/\/ parse the information\n-        DerInputStream derStrm = seq[0].data;\n-        DerValue       tmp;\n-        byte           nextByte;\n-\n-        \/\/ version (optional if v1)\n-        version = 0;   \/\/ by default, version = v1 == 0\n-        nextByte = (byte)derStrm.peekByte();\n-        if (nextByte == DerValue.tag_Integer) {\n-            version = derStrm.getInteger();\n-            if (version != 1)  \/\/ i.e. v2\n-                throw new CRLException(\"Invalid version\");\n-        }\n-        tmp = derStrm.getDerValue();\n-\n-        \/\/ signature\n-        AlgorithmId tmpId = AlgorithmId.parse(tmp);\n-\n-        \/\/ the \"inner\" and \"outer\" signature algorithms must match\n-        if (! tmpId.equals(sigAlgId))\n-            throw new CRLException(\"Signature algorithm mismatch\");\n-        infoSigAlgId = tmpId;\n-\n-        \/\/ issuer\n-        issuer = new X500Name(derStrm);\n-        if (issuer.isEmpty()) {\n-            throw new CRLException(\"Empty issuer DN not allowed in X509CRLs\");\n-        }\n-\n-        \/\/ thisUpdate\n-        \/\/ check if UTCTime encoded or GeneralizedTime\n-\n-        nextByte = (byte)derStrm.peekByte();\n-        if (nextByte == DerValue.tag_UtcTime) {\n-            thisUpdate = derStrm.getUTCTime();\n-        } else if (nextByte == DerValue.tag_GeneralizedTime) {\n-            thisUpdate = derStrm.getGeneralizedTime();\n-        } else {\n-            throw new CRLException(\"Invalid encoding for thisUpdate\"\n-                                   + \" (tag=\" + nextByte + \")\");\n-        }\n-\n-        if (derStrm.available() == 0)\n-           return;     \/\/ done parsing no more optional fields present\n-\n-        \/\/ nextUpdate (optional)\n-        nextByte = (byte)derStrm.peekByte();\n-        if (nextByte == DerValue.tag_UtcTime) {\n-            nextUpdate = derStrm.getUTCTime();\n-        } else if (nextByte == DerValue.tag_GeneralizedTime) {\n-            nextUpdate = derStrm.getGeneralizedTime();\n-        } \/\/ else it is not present\n-\n-        if (derStrm.available() == 0)\n-            return;     \/\/ done parsing no more optional fields present\n-\n-        \/\/ revokedCertificates (optional)\n-        nextByte = (byte)derStrm.peekByte();\n-        if ((nextByte == DerValue.tag_SequenceOf)\n-            && (! ((nextByte & 0x0c0) == 0x080))) {\n-            DerValue[] badCerts = derStrm.getSequence(4);\n-\n-            X500Principal crlIssuer = getIssuerX500Principal();\n-            X500Principal badCertIssuer = crlIssuer;\n-            for (int i = 0; i < badCerts.length; i++) {\n-                X509CRLEntryImpl entry = new X509CRLEntryImpl(badCerts[i]);\n-                badCertIssuer = getCertIssuer(entry, badCertIssuer);\n-                entry.setCertificateIssuer(crlIssuer, badCertIssuer);\n-                X509IssuerSerial issuerSerial = new X509IssuerSerial\n-                    (badCertIssuer, entry.getSerialNumber());\n-                revokedMap.put(issuerSerial, entry);\n-                revokedList.add(entry);\n-            }\n-        }\n-\n-        if (derStrm.available() == 0)\n-            return;     \/\/ done parsing no extensions\n@@ -1150,6 +1194,0 @@\n-        \/\/ crlExtensions (optional)\n-        tmp = derStrm.getDerValue();\n-        if (tmp.isConstructed() && tmp.isContextSpecific((byte)0)) {\n-            extensions = new CRLExtensions(tmp.data);\n-        }\n-        readOnly = true;\n@@ -1215,22 +1253,0 @@\n-    \/**\n-     * Returns the X500 certificate issuer DN of a CRL entry.\n-     *\n-     * @param entry the entry to check\n-     * @param prevCertIssuer the previous entry's certificate issuer\n-     * @return the X500Principal in a CertificateIssuerExtension, or\n-     *   prevCertIssuer if it does not exist\n-     *\/\n-    private X500Principal getCertIssuer(X509CRLEntryImpl entry,\n-        X500Principal prevCertIssuer) {\n-\n-        CertificateIssuerExtension ciExt =\n-            entry.getCertificateIssuerExtension();\n-        if (ciExt != null) {\n-            GeneralNames names = ciExt.getNames();\n-            X500Name issuerDN = (X500Name) names.get(0).getName();\n-            return issuerDN.asX500Principal();\n-        } else {\n-            return prevCertIssuer;\n-        }\n-    }\n-\n@@ -1239,2 +1255,0 @@\n-        if (signedCRL == null)\n-            throw new IOException(\"Null CRL to encode\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509CRLImpl.java","additions":326,"deletions":312,"binary":false,"changes":638,"status":"modified"},{"patch":"@@ -28,6 +28,1 @@\n-import java.io.BufferedReader;\n-import java.io.BufferedInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n+import java.io.*;\n@@ -82,4 +77,0 @@\n-    \/\/ when we sign and decode we set this to true\n-    \/\/ this is our means to make certificates immutable\n-    private boolean readOnly = false;\n-\n@@ -127,1 +118,2 @@\n-     * Default constructor.\n+     * Constructor simply setting all (non-cache) fields. Only used in\n+     * {@link #newSigned}.\n@@ -129,1 +121,7 @@\n-    public X509CertImpl() { }\n+    public X509CertImpl(X509CertInfo info, AlgorithmId algId, byte[] signature,\n+                        byte[] signedCert) {\n+        this.info = info;\n+        this.algId = algId;\n+        this.signature = signature;\n+        this.signedCert = Objects.requireNonNull(signedCert);\n+    }\n@@ -147,1 +145,0 @@\n-            signedCert = null;\n@@ -153,1 +150,17 @@\n-     * unmarshals an X.509 certificate from an input stream.  If the\n+     * Unmarshals a certificate from its encoded form, parsing a DER value.\n+     * This form of constructor is used by agents which need to examine\n+     * and use certificate contents.\n+     *\n+     * @param derVal the der value containing the encoded cert.\n+     * @exception CertificateException on parsing and initialization errors.\n+     *\/\n+    public X509CertImpl(DerValue derVal) throws CertificateException {\n+        try {\n+            parse(derVal);\n+        } catch (IOException e) {\n+            throw new CertificateException(\"Unable to initialize, \" + e, e);\n+        }\n+    }\n+\n+    \/**\n+     * Unmarshals an X.509 certificate from an input stream.  If the\n@@ -238,31 +251,0 @@\n-    \/**\n-     * Construct an initialized X509 Certificate. The certificate is stored\n-     * in raw form and has to be signed to be useful.\n-     *\n-     * The ALGORITHM_ID attribute will be rewritten when signed. The initial\n-     * value is ignored.\n-     *\n-     * @param certInfo the X509CertificateInfo which the Certificate is to be\n-     *             created from.\n-     *\/\n-    public X509CertImpl(X509CertInfo certInfo) {\n-        this.info = certInfo;\n-    }\n-\n-    \/**\n-     * Unmarshal a certificate from its encoded form, parsing a DER value.\n-     * This form of constructor is used by agents which need to examine\n-     * and use certificate contents.\n-     *\n-     * @param derVal the der value containing the encoded cert.\n-     * @exception CertificateException on parsing and initialization errors.\n-     *\/\n-    public X509CertImpl(DerValue derVal) throws CertificateException {\n-        try {\n-            parse(derVal);\n-        } catch (IOException e) {\n-            signedCert = null;\n-            throw new CertificateException(\"Unable to initialize, \" + e, e);\n-        }\n-    }\n-\n@@ -286,2 +268,0 @@\n-        if (signedCert == null)\n-            throw new IOException(\"Null certificate to encode\");\n@@ -309,4 +289,0 @@\n-        if (signedCert == null) {\n-            throw new CertificateEncodingException(\n-                          \"Null certificate to encode\");\n-        }\n@@ -370,3 +346,0 @@\n-        if (signedCert == null) {\n-            throw new CertificateEncodingException(\"Uninitialized certificate\");\n-        }\n@@ -424,3 +397,0 @@\n-        if (signedCert == null) {\n-            throw new CertificateEncodingException(\"Uninitialized certificate\");\n-        }\n@@ -458,1 +428,1 @@\n-     * Creates an X.509 certificate, and signs it using the given key\n+     * Creates a new X.509 certificate, which is signed using the given key\n@@ -463,0 +433,1 @@\n+     * @param info the X509CertInfo to sign\n@@ -465,0 +436,1 @@\n+     * @return the newly signed certificate\n@@ -472,1 +444,1 @@\n-    public void sign(PrivateKey key, String algorithm)\n+    public static X509CertImpl newSigned(X509CertInfo info, PrivateKey key, String algorithm)\n@@ -475,1 +447,1 @@\n-        sign(key, algorithm, null);\n+        return newSigned(info, key, algorithm, null);\n@@ -479,1 +451,1 @@\n-     * Creates an X.509 certificate, and signs it using the given key\n+     * Creates a new X.509 certificate, which is signed using the given key\n@@ -484,0 +456,1 @@\n+     * @param info the X509CertInfo to sign\n@@ -487,0 +460,1 @@\n+     * @return the newly signed certificate\n@@ -494,1 +468,1 @@\n-    public void sign(PrivateKey key, String algorithm, String provider)\n+    public static X509CertImpl newSigned(X509CertInfo info, PrivateKey key, String algorithm, String provider)\n@@ -498,4 +472,0 @@\n-            if (readOnly) {\n-                throw new CertificateEncodingException(\n-                        \"cannot over-write existing certificate\");\n-            }\n@@ -504,1 +474,1 @@\n-            algId = SignatureUtil.fromSignature(sigEngine, key);\n+            AlgorithmId algId = SignatureUtil.fromSignature(sigEngine, key);\n@@ -519,1 +489,1 @@\n-            signature = sigEngine.sign();\n+            byte[] signature = sigEngine.sign();\n@@ -524,2 +494,1 @@\n-            signedCert = out.toByteArray();\n-            readOnly = true;\n+            byte[] signedCert = out.toByteArray();\n@@ -527,0 +496,1 @@\n+            return new X509CertImpl(info, algId, signature, signedCert);\n@@ -1163,1 +1133,1 @@\n-        if (readOnly && extKeyUsage != null) {\n+        if (extKeyUsage != null) {\n@@ -1354,1 +1324,1 @@\n-        if (readOnly && subjectAlternativeNames != null)  {\n+        if (subjectAlternativeNames != null) {\n@@ -1406,1 +1376,1 @@\n-        if (readOnly && issuerAlternativeNames != null) {\n+        if (issuerAlternativeNames != null) {\n@@ -1466,1 +1436,1 @@\n-    throws CertificateException, IOException {\n+            throws CertificateException, IOException {\n@@ -1468,3 +1438,0 @@\n-        if (readOnly)\n-            throw new CertificateParsingException(\n-                      \"cannot over-write existing certificate\");\n@@ -1507,1 +1474,0 @@\n-        readOnly = true;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509CertImpl.java","additions":44,"deletions":78,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -82,3 +82,4 @@\n-        X509CRLImpl crl = new X509CRLImpl(\n-                new X500Name(\"CN=Issuer\"), new Date(), new Date());\n-        crl.sign(kp.getPrivate(), name);\n+        X509CRLImpl crl = X509CRLImpl.newSigned(\n+                new X509CRLImpl.TBSCertList(new X500Name(\"CN=Issuer\"),\n+                        new Date(), new Date()),\n+                kp.getPrivate(), name);\n","filename":"test\/jdk\/sun\/security\/ec\/ed\/EdCRLSign.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -257,2 +257,1 @@\n-        certLocal = new X509CertImpl(info);\n-        certLocal.sign(privateKey, algId.getName());\n+        certLocal = X509CertImpl.newSigned(info, privateKey, algId.getName());\n","filename":"test\/jdk\/sun\/security\/pkcs\/pkcs7\/SignerOrder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -72,2 +72,3 @@\n-        X509CRLImpl crl = new X509CRLImpl(owner, date, date, badCerts);\n-        crl.sign(privateKey, sigAlgName);\n+        X509CRLImpl crl = X509CRLImpl.newSigned(\n+                new X509CRLImpl.TBSCertList(owner, date, date, badCerts),\n+                privateKey, sigAlgName);\n","filename":"test\/jdk\/sun\/security\/provider\/X509Factory\/BigCRL.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -52,3 +52,3 @@\n-        X509CRLImpl crl = new X509CRLImpl(\n-                new X500Name(\"CN=Issuer\"), new Date(), new Date());\n-        crl.sign(kpg.generateKeyPair().getPrivate(), \"RSASSA-PSS\");\n+        X509CRLImpl crl = X509CRLImpl.newSigned(\n+                new X509CRLImpl.TBSCertList(new X500Name(\"CN=Issuer\"), new Date(), new Date()),\n+                kpg.generateKeyPair().getPrivate(), \"RSASSA-PSS\");\n","filename":"test\/jdk\/sun\/security\/rsa\/pss\/DefaultParamSpec.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -228,1 +228,1 @@\n-        return new X509CertImpl() {\n+        return new X509CertImpl(null, null, null, new byte[0]) {\n","filename":"test\/jdk\/sun\/security\/util\/HostnameChecker\/TestHostnameChecker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-        X509CRLImpl crl = new X509CRLImpl(owner, new Date(), new Date(), badCerts);\n@@ -60,1 +59,3 @@\n-        crl.sign(kpg.genKeyPair().getPrivate(), \"SHA1withRSA\");\n+        X509CRLImpl crl = X509CRLImpl.newSigned(\n+                new X509CRLImpl.TBSCertList(owner, new Date(), new Date(), badCerts),\n+                kpg.genKeyPair().getPrivate(), \"SHA1withRSA\");\n","filename":"test\/jdk\/sun\/security\/x509\/X509CRLImpl\/OrderAndDup.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -208,2 +208,1 @@\n-        X509CertImpl crt = new X509CertImpl(cert);\n-        crt.sign(privateKey, sigAlg);\n+        X509CertImpl crt = X509CertImpl.newSigned(cert, privateKey, sigAlg);\n","filename":"test\/jdk\/sun\/security\/x509\/X509CertImpl\/V3Certificate.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}