{"files":[{"patch":"@@ -33,1 +33,0 @@\n-import java.util.regex.Matcher;\n@@ -221,2 +220,7 @@\n-        Matcher matcher = Formatter.FORMAT_SPECIFIER_PATTERN.matcher(fragment);\n-        String group;\n+        Formatter.FormatSpecifierParser parser = null;\n+        int max = fragment.length();\n+        for (int i = 0; i < max;) {\n+            int n = fragment.indexOf('%', i);\n+            if (n < 0) {\n+                return false;\n+            }\n@@ -224,2 +228,4 @@\n-        while (matcher.find()) {\n-            group = matcher.group();\n+            i = n + 1;\n+            if (i >= max) {\n+                return false;\n+            }\n@@ -227,3 +233,14 @@\n-            if (!group.equals(\"%%\") && !group.equals(\"%n\")) {\n-                if (matcher.end() == fragment.length() && needed) {\n-                    return true;\n+            char c = fragment.charAt(i);\n+            if (parser == null) {\n+                parser = new Formatter.FormatSpecifierParser(null, c, i, fragment, max);\n+            } else {\n+                parser.reset(c, i);\n+            }\n+\n+            String group;\n+            int off = parser.parse();\n+\n+            if (off == 1) {\n+                char c1 = fragment.charAt(off);\n+                if (c1 == '%' || c1 == 'n') {\n+                    continue;\n@@ -231,0 +248,1 @@\n+            }\n@@ -232,2 +250,8 @@\n-                throw new MissingFormatArgumentException(group +\n-                        \" is not immediately followed by an embedded expression\");\n+            if (off > 0) {\n+                \/\/ if (!group.equals(\"%%\") && !group.equals(\"%n\")) {\n+                if (i + off == max && needed) {\n+                    return true;\n+                }\n+                group = fragment.substring(i - 1, i + off + 1);\n+            } else {\n+                group = String.valueOf(c);\n@@ -235,0 +259,1 @@\n+            throw new MissingFormatArgumentException(group + \" is not immediately followed by an embedded expression\");\n@@ -236,1 +261,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatProcessor.java","additions":35,"deletions":11,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -52,2 +52,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -2807,6 +2805,0 @@\n-    \/\/ %[argument_index$][flags][width][.precision][t]conversion\n-    static final String FORMAT_SPECIFIER\n-        = \"%(\\\\d+\\\\$)?([-#+ 0,(\\\\<]*)?(\\\\d+)?(\\\\.\\\\d+)?([tT])?([a-zA-Z%])\";\n-\n-    static final Pattern FORMAT_SPECIFIER_PATTERN = Pattern.compile(FORMAT_SPECIFIER);\n-\n@@ -2817,0 +2809,1 @@\n+        FormatSpecifierParser parser = null;\n@@ -2820,1 +2813,0 @@\n-        Matcher m = null; \/\/ create if needed\n@@ -2843,3 +2835,0 @@\n-                if (m == null) {\n-                    m = FORMAT_SPECIFIER_PATTERN.matcher(s);\n-                }\n@@ -2848,3 +2837,8 @@\n-                if (m.find(n) && m.start() == n) {\n-                    al.add(new FormatSpecifier(s, m));\n-                    i = m.end();\n+                if (parser == null) {\n+                    parser = new FormatSpecifierParser(al, c, i, s, max);\n+                } else {\n+                    parser.reset(c, i);\n+                }\n+                int off = parser.parse();\n+                if (off > 0) {\n+                    i += off;\n@@ -2859,0 +2853,165 @@\n+    static final class FormatSpecifierParser {\n+        final ArrayList<FormatString> al;\n+        final String s;\n+        final int max;\n+        char first;\n+        int start;\n+        int off;\n+        char c;\n+        int argSize;\n+        int flagSize;\n+        int widthSize;\n+\n+        FormatSpecifierParser(ArrayList<FormatString> al, char first, int start, String s, int max) {\n+            this.al = al;\n+\n+            this.first = first;\n+            this.c = first;\n+            this.start = start;\n+            this.off = start;\n+\n+            this.s = s;\n+            this.max = max;\n+        }\n+\n+        void reset(char first, int start) {\n+            this.first = first;\n+            this.c = first;\n+            this.start = start;\n+            this.off = start;\n+\n+            argSize = 0;\n+            flagSize = 0;\n+            widthSize = 0;\n+        }\n+\n+        int parse() {\n+            \/\/ %[argument_index$][flags][width][.precision][t]conversion\n+            \/\/ %(\\d+\\$)?([-#+ 0,(\\<]*)?(\\d+)?(\\.\\d+)?([tT])?([a-zA-Z%])\n+            int precisionSize = 0;\n+\n+           parseArgument();\n+\n+            if (widthSize == 0) {\n+                if (flagSize == 0) {\n+                    parseFlag();\n+                }\n+                parseWidth();\n+            }\n+\n+            if (c == '.' && off + 1 < max) {\n+                \/\/ (\\.\\d+)?\n+                precisionSize = parsePrecision();\n+                if (precisionSize == 0) {\n+                    return 0;\n+                }\n+            }\n+\n+            \/\/ ([tT])?([a-zA-Z%])\n+            char t = '\\0', conversion = '\\0';\n+            if ((c == 't' || c == 'T') && off + 1 < max) {\n+                char c1 = s.charAt(off + 1);\n+                if (isConversion(c1)) {\n+                    t = c;\n+                    conversion = c1;\n+                    off += 2;\n+                }\n+            }\n+            if (conversion == '\\0' && isConversion(c)) {\n+                conversion = c;\n+                ++off;\n+            }\n+\n+            if (argSize + flagSize + widthSize + precisionSize + t + conversion != 0) {\n+                if (al != null) {\n+                    FormatSpecifier formatSpecifier\n+                            = new FormatSpecifier(s, start, argSize, flagSize, widthSize, precisionSize, t, conversion);\n+                    al.add(formatSpecifier);\n+                }\n+                return off - start;\n+            }\n+            return 0;\n+        }\n+\n+        private void parseArgument() {\n+            \/\/ (\\d+\\$)?\n+            for (int size = 0; off < max; ++off, c = s.charAt(off), size++) {\n+                if (!isDigit(c)) {\n+                    if (size > 0) {\n+                        if (c == '$') {\n+                            ++off;\n+                            argSize = size + 1;\n+                            size = 0;\n+                            if (off < max) {\n+                                c = s.charAt(off);\n+                            }\n+                        } else {\n+                            if (first == '0') {\n+                                boolean nextFlag = off < max && Flags.isFlag(s.charAt(off));\n+                                if (!nextFlag) {\n+                                    flagSize = 1;\n+                                    off = start + 1;\n+                                    if (off < max) {\n+                                        c = s.charAt(off);\n+                                    }\n+                                } else {\n+                                    off = start;\n+                                    c = first;\n+                                }\n+                            } else {\n+                                widthSize = size;\n+                            }\n+                            size = 0;\n+                        }\n+                    }\n+                    break;\n+                }\n+            }\n+        }\n+\n+        private void parseFlag() {\n+            \/\/ ([-#+ 0,(\\<]*)?\n+            for (int size = 0; off < max; ++off, c = s.charAt(off), size++) {\n+                if (!Flags.isFlag(c)) {\n+                    flagSize = size;\n+                    size = 0;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        private void parseWidth() {\n+            \/\/ (\\d+)?\n+            for (int size = 0; off < max; ++off, c = s.charAt(off), size++) {\n+                if (!isDigit(c)) {\n+                    widthSize = size;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        private int parsePrecision() {\n+            \/\/ (\\.\\d+)?\n+            c = s.charAt(++off);\n+            for (int size = 0; off < max; ++off, c = s.charAt(off), size++) {\n+                if (!isDigit(c)) {\n+                    if (size > 0) {\n+                        return size + 1;\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            return 0;\n+        }\n+    }\n+\n+    static boolean isConversion(char c) {\n+        return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '%';\n+    }\n+\n+    private static boolean isDigit(char c) {\n+        return c >= '0' && c <= '9';\n+    }\n+\n@@ -2981,8 +3140,28 @@\n-        FormatSpecifier(String s, Matcher m) {\n-            index(s, m.start(1), m.end(1));\n-            flags(s, m.start(2), m.end(2));\n-            width(s, m.start(3), m.end(3));\n-            precision(s, m.start(4), m.end(4));\n-\n-            int tTStart = m.start(5);\n-            if (tTStart >= 0) {\n+        FormatSpecifier(\n+                String s,\n+                int i,\n+                int argSize,\n+                int flagSize,\n+                int widthSize,\n+                int precisionSize,\n+                char t,\n+                char conversion\n+        ) {\n+            int argEnd = i + argSize;\n+            int flagEnd = argEnd + flagSize;\n+            int widthEnd = flagEnd + widthSize;\n+            int precesionEnd = widthEnd + precisionSize;\n+\n+            if (argSize > 0) {\n+                index(s, i, argEnd);\n+            }\n+            if (flagSize > 0) {\n+                flags(s, argEnd, flagEnd);\n+            }\n+            if (widthSize > 0) {\n+                width(s, flagEnd, widthEnd);\n+            }\n+            if (precisionSize > 0) {\n+                precision(s, widthEnd, precesionEnd);\n+            }\n+            if (t != '\\0') {\n@@ -2990,1 +3169,1 @@\n-                if (s.charAt(tTStart) == 'T') {\n+                if (t == 'T') {\n@@ -2994,1 +3173,3 @@\n-            conversion(s.charAt(m.start(6)));\n+            conversion(conversion);\n+            check();\n+        }\n@@ -2996,0 +3177,1 @@\n+        private void check() {\n@@ -4689,0 +4871,7 @@\n+        private static boolean isFlag(char c) {\n+            return switch (c) {\n+                case '-', '#', '+', ' ', '0', ',', '(', '<' -> true;\n+                default -> false;\n+            };\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/Formatter.java","additions":214,"deletions":25,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.math.BigDecimal;\n@@ -50,0 +51,6 @@\n+    public static final BigDecimal pi  = new BigDecimal(Math.PI);\n+\n+    @Benchmark\n+    public String decimalFormat() {\n+        return \"%010.3f\".formatted(pi);\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringFormat.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}