{"files":[{"patch":"@@ -2107,4 +2107,4 @@\n-        \"The target VM may not support, or may only provide limited support, for \"\n-        \"this command when the thread is a virtual thread. It may, for example, \"\n-        \"only support this command when the virtual thread is suspended at a \"\n-        \"breakpoint or singlestep event.\"\n+        \"This command may be used to force a return from the current frame \"\n+        \"of a virtual thread when it is suspended at an event. \"\n+        \"An implementation may support forcing a return from the current frame \"\n+        \"of a suspended virtual thread in other cases.\"\n@@ -2150,1 +2150,1 @@\n-                                     \"the thread is a virtual thread and the target \"\n+                                     \"the thread is a suspended virtual thread and the target \"\n","filename":"src\/java.se\/share\/data\/jdwp\/jdwp.spec","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -439,4 +439,4 @@\n-     * The target VM may not support, or may only provide limited support,\n-     * for forcing a method to return when the thread is a virtual thread.\n-     * It may, for example, only support this operation when the virtual\n-     * thread is suspended at a breakpoint or singlestep event.\n+     * This method may be used to force a return from the current frame\n+     * of a virtual thread when it is suspended at an event.\n+     * An implementation may support forcing a return from the current frame\n+     * of a suspended virtual thread in other cases.\n@@ -487,1 +487,1 @@\n-     * @throws OpaqueFrameException if this thread is a virtual thread and the\n+     * @throws OpaqueFrameException if this thread is a suspended virtual thread and the\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/ThreadReference.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -96,10 +96,0 @@\n-####\n-## JVMTI ForceEarlyReturn not supported for vthreads (JVMTI_ERROR_OPAQUE_FRAME)\n-## Note forceEarlyReturn002 was converted to support vthreads. The rest were not\n-## since there is no added value (JVMTI_ERROR_OPAQUE_FRAME is expected).\n-\n-vmTestbase\/nsk\/jdi\/ThreadReference\/forceEarlyReturn\/forceEarlyReturn002\/forceEarlyReturn002.java\n-vmTestbase\/nsk\/jdi\/ThreadReference\/forceEarlyReturn\/forceEarlyReturn014\/forceEarlyReturn014.java 8285415 generic-all\n-vmTestbase\/nsk\/jdi\/stress\/serial\/forceEarlyReturn001\/TestDescription.java 8285415 generic-all\n-vmTestbase\/nsk\/jdi\/stress\/serial\/forceEarlyReturn002\/TestDescription.java 8285415 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList-Virtual.txt","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,1 +150,1 @@\n-        boolean vthreadMode = \"Virtual\".equals(System.getProperty(\"main.wrapper\"));\n+\n@@ -152,1 +152,1 @@\n-            \/\/ don't expect any exception, except for vthreads expect OpaqueFrameException\n+            \/\/ don't expect any exception\n@@ -154,4 +154,0 @@\n-            if (vthreadMode) {\n-                setSuccess(false);\n-                log.complain(\"Expected OpaqueFrameException\");\n-            }\n@@ -159,7 +155,3 @@\n-            if (vthreadMode && (e instanceof OpaqueFrameException)) {\n-                \/\/ pass\n-            } else {\n-                setSuccess(false);\n-                log.complain(\"Unexpected exception: \" + e);\n-                e.printStackTrace(log.getOutStream());\n-            }\n+            setSuccess(false);\n+            log.complain(\"Unexpected exception: \" + e);\n+            e.printStackTrace(log.getOutStream());\n@@ -168,6 +160,1 @@\n-        if (vthreadMode) {\n-            \/\/ MethodExit event won't be as expected if using vthreads, so just resume\n-            threadReference.resume();\n-        } else {\n-            testMethodExitEvent(threadReference, ClassUsingTestClass.breakpointMethodName);\n-        }\n+        testMethodExitEvent(threadReference, ClassUsingTestClass.breakpointMethodName);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadReference\/forceEarlyReturn\/forceEarlyReturn002\/forceEarlyReturn002.java","additions":7,"deletions":20,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,3 +86,1 @@\n-            boolean vthreadMode = \"Virtual\".equals(System.getProperty(\"main.wrapper\"));\n-            \/\/ expectedValue should be set as expected unless in vthread mode\n-            if (vthreadMode == (ClassUsingTestClass.expectedValue == value)) {\n+            if (ClassUsingTestClass.expectedValue != value) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadReference\/forceEarlyReturn\/forceEarlyReturn002\/forceEarlyReturn002a.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-com\/sun\/jdi\/EarlyReturnTest.java 8285422 generic-all\n","filename":"test\/jdk\/ProblemList-Virtual.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,263 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Call forceEarlyReturn() on threads in various states not covered\n+ *          well by other tests. Most notably, this test includes a\n+ *          test case for a suspended but unmounted virtual thread.\n+ *\n+ * @run build TestScaffold VMConnection TargetListener TargetAdapter\n+ * @run compile -g ForceEarlyReturnTest.java\n+ * @run driver ForceEarlyReturnTest NATIVE\n+ * @run driver ForceEarlyReturnTest LOOP\n+ * @run driver ForceEarlyReturnTest SLEEP\n+ *\/\n+import com.sun.jdi.*;\n+import com.sun.jdi.event.*;\n+import java.util.*;\n+\n+\/*\n+ * There are three test modes covered by this test:\n+ *   NATIVE: the debuggee sits in a native method.\n+ *   SLEEP:  the debuggee blocks in Thread.sleep().\n+ *   LOOP:   the debuggee sits in a tight loop.\n+ *\n+ * In all cases the thread is suspended and errors such as IllegalArgumentException\n+ * and InvalidStackFrameException should not happen. The forceEarlyReturn() calls should\n+ * either pass, or produce OpaqueFrameException or NativeMethodException.\n+ *\n+ * Call stacks for each test mode (and expected result):\n+ *\n+ * NATIVE (NativeMethodException):\n+ *   nativeMethod()  <-- native method, which sleeps\n+ *   loopOrSleep()\n+ *   main()\n+ *\n+ * LOOP (no exception):\n+ *   loopOrSleep()  <-- tight loop\n+ *   main()\n+ *\n+ * SLEEP (NativeMethodException for platform thread or OpaqueFrameException\n+ * for virtual thread. See explanation in runTests().):\n+ *   Thread.sleep() + methods called by Thread.sleep()\n+ *   loopOrSleep()\n+ *   main()\n+ *\/\n+\n+class ForceEarlyReturnTestTarg {\n+    static TestMode mode;\n+\n+    static {\n+        System.loadLibrary(\"ForceEarlyReturnTestTarg\");\n+    }\n+\n+    public static void loopOrSleep() {\n+        switch (mode) {\n+        case TestMode.LOOP:\n+            while (true);\n+        case TestMode.SLEEP:\n+            try {\n+                Thread.sleep(10000);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+            break;\n+        case TestMode.NATIVE:\n+            nativeMethod();\n+            break;\n+        }\n+    }\n+\n+    public static native void nativeMethod(); \/\/ native method that does a very long sleep\n+\n+    public static void main(String[] args) {\n+        System.out.println(\"    debuggee: Howdy!\");\n+\n+        \/\/ We expect just one argument, which is the test mode, such as SLEEP.\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"Must pass 1 arguments to ForceEarlyReturnTestTarg\");\n+        }\n+        System.out.println(\"    debuggee: args[0]: \" + args[0]);\n+        mode = Enum.valueOf(TestMode.class, args[0]); \/\/ convert test mode string to an enum\n+        System.out.println(\"    debuggee: test mode: \" + mode);\n+\n+        loopOrSleep();\n+\n+        System.out.println(\"    debuggee: Goodbye from ForceEarlyReturnTest!\");\n+    }\n+}\n+\n+\/*\n+ * The different modes the test can be run in. See test description comment above.\n+ *\/\n+enum TestMode {\n+    NATIVE,\n+    SLEEP,\n+    LOOP;\n+}\n+\n+\/********** test program **********\/\n+\n+public class ForceEarlyReturnTest extends TestScaffold {\n+    private static TestMode mode;\n+\n+    ForceEarlyReturnTest(String args[]) {\n+        super(args);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ We should get one argument that indicates the test mode, such as SLEEP.\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"Must pass one argument to ForceEarlyReturnTestTarg\");\n+        }\n+        mode = Enum.valueOf(TestMode.class, args[0]); \/\/ convert test mode string to an enum\n+\n+        \/*\n+         * The @run command looks something like:\n+         *   @run driver ForceEarlyReturnTest SLEEP\n+         * We need to pass SLEEP to the debuggee. We also need to insert\n+         * -Djava.library.path so the native method can be accessed if called.\n+         *\/\n+        String nativePath = \"-Djava.library.path=\" + System.getProperty(\"java.library.path\");\n+        String[] newArgs = new String[2];\n+        newArgs[0] = nativePath;\n+        newArgs[1] = args[0]; \/\/ pass test mode, such as SLEEP_NONATIVE\n+\n+        new ForceEarlyReturnTest(newArgs).startTests();\n+    }\n+\n+    public void printStack(ThreadReference thread, String msg) throws Exception {\n+        System.out.println(msg);\n+        List<StackFrame> stack_frames = thread.frames();\n+        int i = 0;\n+        String sourceName;\n+        for (StackFrame f : stack_frames) {\n+            try {\n+                sourceName = f.location().sourceName();\n+            } catch (AbsentInformationException aie) {\n+                sourceName = \"Unknown source\";\n+            }\n+            System.out.println(\"frame[\" + i++ +\"]: \" + f.location().method() +\n+                               \" (bci:\"+ f.location().codeIndex() + \")\" +\n+                               \" (\" + sourceName + \":\"+ f.location().lineNumber() + \")\");\n+        }\n+    }\n+\n+    \/********** test core **********\/\n+\n+    protected void runTests() throws Exception {\n+        BreakpointEvent bpe = startTo(\"ForceEarlyReturnTestTarg\", \"loopOrSleep\", \"()V\");\n+        ThreadReference mainThread = bpe.thread();\n+        boolean is_vthread_mode = \"Virtual\".equals(System.getProperty(\"main.wrapper\"));\n+\n+        \/\/ Resume main thread until it is in Thread.sleep() or the infinite loop.\n+        mainThread.resume();\n+        try {\n+            Thread.sleep(1000); \/\/ give thread chance to get into Thread.sleep() or loop\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+        mainThread.suspend(); \/\/ Suspend thread while in Thread.sleep() or loop\n+        printStack(mainThread, \"Debuggee stack before forceEarlyReturn():\");\n+\n+        \/*\n+         * Figure out which exception forceEarlyReturn() should throw.\n+         *\/\n+        Class expected_exception;\n+        switch(mode) {\n+        case NATIVE:\n+            \/*\n+             * There is a native frame on the top of the stack, so we expect NativeMethodException.\n+             *\/\n+            expected_exception = NativeMethodException.class;\n+            break;\n+        case LOOP:\n+            \/*\n+             * There is a java frame on the top of the stack, so we expect no exception.\n+             *\/\n+            expected_exception = null;\n+            break;\n+        case SLEEP:\n+            \/*\n+             * For platform threads, Thread.sleep() results in the Thread.sleep0() native\n+             * frame on the stack, so the end result is NativeMethodException. For virtual\n+             * threads it is not quite so simple. If the thead is pinned (such as when\n+             * there is already a native method on the stack), you end up in\n+             * VirtualThread.parkOnCarrierThread(), which calls Unsafe.park(), which is a\n+             * native method, so again this results in NativeMethodException. However, for\n+             * a virtual thread that is not pinned (which is true for this test case), you\n+             * end up with no native methods on the stack due to how Continuation.yield()\n+             * works. So you have an unmounted virtual thread with no native frames, which\n+             * results in OpaqueFrameException being thrown.\n+             *\/\n+            if (is_vthread_mode) {\n+                expected_exception = OpaqueFrameException.class;\n+            } else {\n+                expected_exception = NativeMethodException.class;\n+            }\n+            break;\n+        default:\n+            throw new RuntimeException(\"Bad test mode: \" + mode);\n+        }\n+\n+        \/*\n+         * Call ThreadReference.forceEarlyReturn() and check for errors.\n+         *\/\n+        try {\n+            if (is_vthread_mode && mode == TestMode.SLEEP) {\n+                \/\/ For this test case with virtual threads, the topmost frame is for\n+                \/\/ Continuation.yield0(), which returns a boolean.\n+                BooleanValue theValue = vm().mirrorOf(true);\n+                mainThread.forceEarlyReturn(theValue);\n+            } else {\n+                \/\/ For all other cases, the topmost frame will be one that returns void.\n+                VoidValue theValue = vm().mirrorOfVoid();\n+                mainThread.forceEarlyReturn(theValue);\n+            }\n+            if (expected_exception != null) {\n+                failure(\"failure: forceEarlyReturn() did not get expected exception: \" + expected_exception);\n+            } else {\n+                System.out.println(\"success: no exception for forceEarlyReturn()\");\n+            }\n+        } catch (Exception ex) {\n+            if (expected_exception == ex.getClass()) {\n+                System.out.println(\"success: forceEarlyReturn() got expected exception: \" + ex);\n+            } else {\n+                failure(\"failure: forceEarlyReturn() got unexpected exception: \" + ex);\n+            }\n+        }\n+\n+        \/*\n+         * Most tests do a listenUntilVMDisconnect() here, but there is no real need for it\n+         * with this test, and doing so would require finding a way to get the debuggee\n+         * to exit the endless loop it might be in. When we return, TestScaffold will\n+         * call TestScaffold.shutdown(), causing the debuggee process to be terminated quickly.\n+         *\/\n+\n+        if (testFailed) {\n+            throw new Exception(\"ForceEarlyReturnTest failed\");\n+        }\n+        System.out.println(\"Passed:\");\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/ForceEarlyReturnTest.java","additions":263,"deletions":0,"binary":false,"changes":263,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#include \"jni.h\"\n+\n+\/*\n+ * Class:     NativeMethod\n+ * Method:    nativeMethod\n+ * Signature: ()V\n+ *\/\n+JNIEXPORT void JNICALL Java_ForceEarlyReturnTestTarg_nativeMethod(JNIEnv *env, jobject obj) {\n+    \/* Just spin. We don't need to ever return from here. *\/\n+    while(JNI_TRUE);\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/libForceEarlyReturnTestTarg.c","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"}]}