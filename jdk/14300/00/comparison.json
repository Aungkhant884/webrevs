{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import java.util.concurrent.atomic.LongAdder;\n@@ -53,1 +52,1 @@\n-            throw new InternalError(e);\n+            throw new ExceptionInInitializerError(e);\n@@ -60,3 +59,0 @@\n-    \/\/ the number of threads in the container\n-    private final LongAdder threadCount;\n-\n@@ -79,1 +75,0 @@\n-        this.threadCount = new LongAdder();\n@@ -122,1 +117,0 @@\n-        threadCount.add(1L);\n@@ -127,1 +121,0 @@\n-        threadCount.add(-1L);\n@@ -132,5 +125,0 @@\n-    @Override\n-    public long threadCount() {\n-        return threadCount.sum();\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/SharedThreadContainer.java","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import sun.nio.ch.Poller;\n@@ -40,2 +39,1 @@\n- * This class consists exclusively of static methods to support debugging and\n- * monitoring of threads.\n+ * This class consists exclusively of static methods to support groupings of threads.\n@@ -46,0 +44,6 @@\n+    \/\/ true if all threads are tracked\n+    private static final boolean TRACK_ALL_THREADS;\n+\n+    \/\/ the root container\n+    private static final RootContainer ROOT_CONTAINER;\n+\n@@ -50,0 +54,11 @@\n+    static {\n+        String s = GetPropertyAction.privilegedGetProperty(\"jdk.trackAllThreads\");\n+        if (s == null || s.isEmpty() || Boolean.parseBoolean(s)) {\n+            TRACK_ALL_THREADS = true;\n+            ROOT_CONTAINER = new RootContainer.TrackingRootContainer();\n+        } else {\n+            TRACK_ALL_THREADS = false;\n+            ROOT_CONTAINER = new RootContainer.CountingRootContainer();\n+        }\n+    }\n+\n@@ -62,0 +77,7 @@\n+    \/**\n+     * Returns true if all threads are tracked.\n+     *\/\n+    public static boolean trackAllThreads() {\n+        return TRACK_ALL_THREADS;\n+    }\n+\n@@ -86,1 +108,1 @@\n-        return RootContainer.INSTANCE;\n+        return ROOT_CONTAINER;\n@@ -186,3 +208,2 @@\n-     * Root container that \"contains\" all platform threads not started in a\n-     * container plus some (or all) virtual threads that are started directly\n-     * with the Thread API.\n+     * Root container that \"contains\" all platform threads not started in a container.\n+     * It may include all virtual threads started directly with the Thread API.\n@@ -191,9 +212,0 @@\n-        static final RootContainer INSTANCE;\n-        static {\n-            String s = GetPropertyAction.privilegedGetProperty(\"jdk.trackAllThreads\");\n-            if (s != null && (s.isEmpty() || Boolean.parseBoolean(s))) {\n-                INSTANCE = new TrackingRootContainer();\n-            } else {\n-                INSTANCE = new CountingRootContainer();\n-            }\n-        }\n@@ -273,5 +285,1 @@\n-                \/\/ virtual threads in this container that are those blocked on I\/O.\n-                Stream<Thread> blockedVirtualThreads = Poller.blockedThreads()\n-                        .filter(t -> t.isVirtual()\n-                                && JLA.threadContainer(t) == this);\n-                return Stream.concat(platformThreads(), blockedVirtualThreads);\n+                return platformThreads();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadContainers.java","additions":29,"deletions":21,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -243,1 +243,3 @@\n-        threadCount = Long.max(threadCount, container.threadCount());\n+        if (!ThreadContainers.trackAllThreads()) {\n+            threadCount = Long.max(threadCount, container.threadCount());\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadDumper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-        threadDump(file, \"-format=json\").shouldMatch(\"Created\");\n+        jcmdThreadDumpToFile(file, \"-format=json\").shouldMatch(\"Created\");\n@@ -92,1 +92,1 @@\n-        threadDump(file, \"\").shouldMatch(\"exists\");\n+        jcmdThreadDumpToFile(file, \"\").shouldMatch(\"exists\");\n@@ -105,1 +105,1 @@\n-        testPlainThreadDump(file, \"-overwrite\");\n+        jcmdThreadDumpToFile(file, \"-overwrite\");\n@@ -112,1 +112,1 @@\n-        threadDump(file, options).shouldMatch(\"Created\");\n+        jcmdThreadDumpToFile(file, options).shouldMatch(\"Created\");\n@@ -121,0 +121,3 @@\n+    \/**\n+     * Generate a file path with the given suffix to use for the thread dump.\n+     *\/\n@@ -128,1 +131,4 @@\n-    private OutputAnalyzer threadDump(Path file, String... options) {\n+    \/**\n+     * Launches jcmd Thread.dump_to_file to obtain a thread dump of this VM.\n+     *\/\n+    private OutputAnalyzer jcmdThreadDumpToFile(Path file, String... options) {\n@@ -136,0 +142,3 @@\n+    \/**\n+     * Returns true if the given file contains a line with the string.\n+     *\/\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/thread\/ThreadDumpToFileTest.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8284161 8287008\n+ * @bug 8284161 8287008 8309406\n@@ -28,0 +28,2 @@\n+ * @requires vm.continuations\n+ * @modules jdk.management\n@@ -32,1 +34,1 @@\n- * @run junit\/othervm -Djdk.trackAllThreadds=false DumpThreads\n+ * @run junit\/othervm -Djdk.trackAllThreads=false DumpThreads\n@@ -39,0 +41,1 @@\n+import java.util.Objects;\n@@ -40,0 +43,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -42,1 +46,2 @@\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ForkJoinPool;\n@@ -50,0 +55,3 @@\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -53,2 +61,4 @@\n-    private static final boolean TRACK_ALL_THREADS;\n-    static {\n+    private static boolean trackAllThreads;\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n@@ -56,1 +66,1 @@\n-        TRACK_ALL_THREADS = (s != null) && (s.isEmpty() || Boolean.parseBoolean(s));\n+        trackAllThreads = (s == null) || s.isEmpty() || Boolean.parseBoolean(s);\n@@ -60,1 +70,2 @@\n-     * Thread dump in plain text format.\n+     * ExecutorService implementations that have their object identity in the container\n+     * name so they can be found in the JSON format.\n@@ -62,13 +73,6 @@\n-    @Test\n-    void testPlainText() throws Exception {\n-        var mbean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n-        Path file = genOutputPath(\"txt\");\n-        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n-            Thread vthread = forkParker(executor);\n-            try {\n-                mbean.dumpThreads(file.toString(), ThreadDumpFormat.TEXT_PLAIN);\n-                cat(file);\n-\n-                \/\/ pid should be on the first line\n-                String pid = \"\" + ProcessHandle.current().pid();\n-                assertTrue(line(file, 0).contains(pid));\n+    static Stream<ExecutorService> executors() {\n+        return Stream.of(\n+                Executors.newFixedThreadPool(1),\n+                Executors.newVirtualThreadPerTaskExecutor()\n+        );\n+    }\n@@ -76,3 +80,13 @@\n-                \/\/ runtime version should be on third line\n-                String vs = Runtime.version().toString();\n-                assertTrue(line(file, 2).contains(vs));\n+    \/**\n+     * Test thread dump in plain text format contains information about the current\n+     * thread and a virtual thread created directly with the Thread API.\n+     *\/\n+    @Test\n+    void testRootContainerPlainTextFormat() throws Exception {\n+        Thread vthread = Thread.ofVirtual().start(LockSupport::park);\n+        try {\n+            testDumpThreadsPlainText(vthread, trackAllThreads);\n+        } finally {\n+            LockSupport.unpark(vthread);\n+        }\n+    }\n@@ -80,2 +94,13 @@\n-                \/\/ virtual thread should be found\n-                assertTrue(isPresent(file, vthread));\n+    \/**\n+     * Test thread dump in JSON format contains information about the current\n+     * thread and a virtual thread created directly with the Thread API.\n+     *\/\n+    @Test\n+    void testRootContainerJsonFormat() throws Exception {\n+        Thread vthread = Thread.ofVirtual().start(LockSupport::park);\n+        try {\n+            testDumpThreadsJson(null, vthread, trackAllThreads);\n+        } finally {\n+            LockSupport.unpark(vthread);\n+        }\n+    }\n@@ -83,5 +108,11 @@\n-                \/\/ if the current thread is a platform thread then it should be included\n-                Thread currentThread = Thread.currentThread();\n-                if (!currentThread.isVirtual() || TRACK_ALL_THREADS) {\n-                    assertTrue(isPresent(file, currentThread));\n-                }\n+    \/**\n+     * Test thread dump in plain text format includes a thread executing a task in the\n+     * given ExecutorService.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testExecutorServicePlainTextFormat(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Thread thread = forkParker(executor);\n+            try {\n+                testDumpThreadsPlainText(thread, true);\n@@ -89,1 +120,1 @@\n-                LockSupport.unpark(vthread);\n+                LockSupport.unpark(thread);\n@@ -91,2 +122,0 @@\n-        } finally {\n-            Files.deleteIfExists(file);\n@@ -97,1 +126,2 @@\n-     * Thread dump in JSON format.\n+     * Test thread dump in JSON format includes a thread executing a task in the\n+     * given ExecutorService.\n@@ -99,6 +129,5 @@\n-    @Test\n-    void testJson() throws Exception {\n-        var mbean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n-        Path file = genOutputPath(\"json\");\n-        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n-            Thread vthread = forkParker(executor);\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testExecutorServiceJsonFormat(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Thread thread = forkParker(executor);\n@@ -106,34 +135,1 @@\n-                mbean.dumpThreads(file.toString(), ThreadDumpFormat.JSON);\n-                cat(file);\n-\n-                \/\/ parse the JSON text\n-                String jsonText = Files.readString(file);\n-                ThreadDump threadDump = ThreadDump.parse(jsonText);\n-\n-                \/\/ test threadDump\/processId\n-                assertTrue(threadDump.processId() == ProcessHandle.current().pid());\n-\n-                \/\/ test threadDump\/time can be parsed\n-                ZonedDateTime.parse(threadDump.time());\n-\n-                \/\/ test threadDump\/runtimeVersion\n-                assertEquals(Runtime.version().toString(), threadDump.runtimeVersion());\n-\n-                \/\/ test root container\n-                var rootContainer = threadDump.rootThreadContainer();\n-                assertFalse(rootContainer.owner().isPresent());\n-                assertFalse(rootContainer.parent().isPresent());\n-\n-                \/\/ if the current thread is a platform thread then it will be in root container\n-                Thread currentThread = Thread.currentThread();\n-                if (!currentThread.isVirtual() || TRACK_ALL_THREADS) {\n-                    rootContainer.findThread(currentThread.threadId()).orElseThrow();\n-                }\n-\n-                \/\/ find the thread container for the executor. The name of this executor\n-                \/\/ is its String representaiton in this case.\n-                String name = executor.toString();\n-                var container = threadDump.findThreadContainer(name).orElseThrow();\n-                assertFalse(container.owner().isPresent());\n-                assertTrue(container.parent().get() == rootContainer);\n-                container.findThread(vthread.threadId()).orElseThrow();\n+                testDumpThreadsJson(Objects.toIdentityString(executor), thread, true);\n@@ -141,1 +137,1 @@\n-                LockSupport.unpark(vthread);\n+                LockSupport.unpark(thread);\n@@ -143,0 +139,13 @@\n+        }\n+    }\n+\n+    \/**\n+     * Test thread dump in JSON format includes a thread executing a task in the\n+     * fork-join common pool.\n+     *\/\n+    @Test\n+    void testForkJoinPool() throws Exception {\n+        ForkJoinPool pool = ForkJoinPool.commonPool();\n+        Thread thread = forkParker(pool);\n+        try {\n+            testDumpThreadsJson(\"ForkJoinPool.commonPool\", thread, true);\n@@ -144,1 +153,1 @@\n-            Files.deleteIfExists(file);\n+            LockSupport.unpark(thread);\n@@ -148,0 +157,93 @@\n+    \/**\n+     * Invoke HotSpotDiagnosticMXBean.dumpThreads to create a thread dump in plain text\n+     * format, then sanity check that the thread dump includes expected strings, the\n+     * current thread, and maybe the given thread.\n+     * @param thread the thread to test if included\n+     * @param expectInDump true if the thread is expected to be included\n+     *\/\n+    private void testDumpThreadsPlainText(Thread thread, boolean expectInDump) throws Exception {\n+        Path file = genOutputPath(\".txt\");\n+        var mbean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n+        mbean.dumpThreads(file.toString(), ThreadDumpFormat.TEXT_PLAIN);\n+        System.err.format(\"Dumped to %s%n\", file);\n+\n+        \/\/ pid should be on the first line\n+        String line1 = line(file, 0);\n+        String pid = Long.toString(ProcessHandle.current().pid());\n+        assertTrue(line1.contains(pid));\n+\n+        \/\/ timestamp should be on the second line\n+        String line2 = line(file, 1);\n+        ZonedDateTime.parse(line2);\n+\n+        \/\/ runtime version should be on third line\n+        String line3 = line(file, 2);\n+        String vs = Runtime.version().toString();\n+        assertTrue(line3.contains(vs));\n+\n+        \/\/ test if thread is included in thread dump\n+        assertEquals(expectInDump, isPresent(file, thread));\n+\n+        \/\/ current thread should be included if platform thread or tracking all threads\n+        Thread currentThread = Thread.currentThread();\n+        boolean currentThreadExpected = trackAllThreads || !currentThread.isVirtual();\n+        assertEquals(currentThreadExpected, isPresent(file, currentThread));\n+    }\n+\n+    \/**\n+     * Invoke HotSpotDiagnosticMXBean.dumpThreads to create a thread dump in JSON format.\n+     * The thread dump is parsed as a JSON object and checked to ensure that it contains\n+     * expected data, the current thread, and maybe the given thread.\n+     * @param containerName the name of the container or null for the root container\n+     * @param thread the thread to test if included\n+     * @param expect true if the thread is expected to be included\n+     *\/\n+    private void testDumpThreadsJson(String containerName,\n+                                     Thread thread,\n+                                     boolean expectInDump) throws Exception {\n+        Path file = genOutputPath(\".json\");\n+        var mbean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n+        mbean.dumpThreads(file.toString(), ThreadDumpFormat.JSON);\n+        System.err.format(\"Dumped to %s%n\", file);\n+\n+        \/\/ parse the JSON text\n+        String jsonText = Files.readString(file);\n+        ThreadDump threadDump = ThreadDump.parse(jsonText);\n+\n+        \/\/ test threadDump\/processId\n+        assertTrue(threadDump.processId() == ProcessHandle.current().pid());\n+\n+        \/\/ test threadDump\/time can be parsed\n+        ZonedDateTime.parse(threadDump.time());\n+\n+        \/\/ test threadDump\/runtimeVersion\n+        assertEquals(Runtime.version().toString(), threadDump.runtimeVersion());\n+\n+        \/\/ test root container, has no parent and no owner\n+        var rootContainer = threadDump.rootThreadContainer();\n+        assertFalse(rootContainer.owner().isPresent());\n+        assertFalse(rootContainer.parent().isPresent());\n+\n+        \/\/ test that the container contains the given thread\n+        ThreadDump.ThreadContainer container;\n+        if (containerName == null) {\n+            \/\/ root container, the thread should be found if trackAllThreads is true\n+            container = rootContainer;\n+        } else {\n+            \/\/ find the container\n+            container = threadDump.findThreadContainer(containerName).orElse(null);\n+            assertNotNull(container, containerName + \" not found\");\n+            assertFalse(container.owner().isPresent());\n+            assertTrue(container.parent().get() == rootContainer);\n+\n+        }\n+        boolean found = container.findThread(thread.threadId()).isPresent();\n+        assertEquals(expectInDump, found);\n+\n+        \/\/ current thread should be in root container if platform thread or tracking all threads\n+        Thread currentThread = Thread.currentThread();\n+        boolean currentThreadExpected = trackAllThreads || !currentThread.isVirtual();\n+        found = rootContainer.findThread(currentThread.threadId()).isPresent();\n+        assertEquals(currentThreadExpected, found);\n+    }\n+\n@@ -189,2 +291,3 @@\n-    private static Thread forkParker(ExecutorService executor) throws Exception {\n-        var ref = new AtomicReference<Thread>();\n+    private static Thread forkParker(ExecutorService executor) {\n+        class Box { static volatile Thread thread;}\n+        var latch = new CountDownLatch(1);\n@@ -192,1 +295,2 @@\n-            ref.set(Thread.currentThread());\n+            Box.thread = Thread.currentThread();\n+            latch.countDown();\n@@ -195,3 +299,4 @@\n-        Thread thread;\n-        while ((thread = ref.get()) == null) {\n-            Thread.sleep(10);\n+        try {\n+            latch.await();\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n@@ -199,1 +304,1 @@\n-        return thread;\n+        return Box.thread;\n@@ -203,1 +308,1 @@\n-     * Returns true if the file contains #<tid>\n+     * Returns true if a Thread is present in a plain text thread dump.\n@@ -238,9 +343,0 @@\n-\n-    \/**\n-     * Print the given file to standard output.\n-     *\/\n-    private static void cat(Path file) throws Exception {\n-        try (Stream<String> stream = Files.lines(file)) {\n-            stream.forEach(System.out::println);\n-        }\n-    }\n","filename":"test\/jdk\/com\/sun\/management\/HotSpotDiagnosticMXBean\/DumpThreads.java","additions":189,"deletions":93,"binary":false,"changes":282,"status":"modified"},{"patch":"@@ -179,1 +179,0 @@\n-\n","filename":"test\/lib\/jdk\/test\/lib\/threaddump\/ThreadDump.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}