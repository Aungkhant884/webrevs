{"files":[{"patch":"@@ -34,23 +34,31 @@\n-DumpTimeClassInfo DumpTimeClassInfo::clone() {\n-  DumpTimeClassInfo clone;\n-  clone._klass = _klass;\n-  clone._nest_host = _nest_host;\n-  clone._failed_verification = _failed_verification;\n-  clone._is_archived_lambda_proxy = _is_archived_lambda_proxy;\n-  clone._has_checked_exclusion = _has_checked_exclusion;\n-  clone._id = _id;\n-  clone._clsfile_size = _clsfile_size;\n-  clone._clsfile_crc32 = _clsfile_crc32;\n-  clone._excluded = _excluded;\n-  clone._is_early_klass = _is_early_klass;\n-  clone._verifier_constraints = NULL;\n-  clone._verifier_constraint_flags = NULL;\n-  clone._loader_constraints = NULL;\n-  clone._enum_klass_static_fields = NULL;\n-  int clone_num_verifier_constraints = num_verifier_constraints();\n-  if (clone_num_verifier_constraints > 0) {\n-    clone._verifier_constraints = new (ResourceObj::C_HEAP, mtClass) GrowableArray<DTVerifierConstraint>(clone_num_verifier_constraints, mtClass);\n-    clone._verifier_constraint_flags = new (ResourceObj::C_HEAP, mtClass) GrowableArray<char>(clone_num_verifier_constraints, mtClass);\n-    for (int i = 0; i < clone_num_verifier_constraints; i++) {\n-      clone._verifier_constraints->append(_verifier_constraints->at(i));\n-      clone._verifier_constraint_flags->append(_verifier_constraint_flags->at(i));\n+\/\/ This constructor is used only by SystemDictionaryShared::clone_dumptime_tables().\n+\/\/ See comments there about the need for making a deep copy.\n+DumpTimeClassInfo::DumpTimeClassInfo(const DumpTimeClassInfo& src) {\n+  assert(DynamicDumpSharedSpaces, \"must be\");\n+\n+  _klass = src._klass;\n+  _nest_host = src._nest_host;\n+  _failed_verification = src._failed_verification;\n+  _is_archived_lambda_proxy = src._is_archived_lambda_proxy;\n+  _has_checked_exclusion = src._has_checked_exclusion;\n+  _id = src._id;\n+  _clsfile_size = src._clsfile_size;\n+  _clsfile_crc32 = src._clsfile_crc32;\n+  _excluded = src._excluded;\n+  _is_early_klass = src._is_early_klass;\n+  _verifier_constraints = NULL;\n+  _verifier_constraint_flags = NULL;\n+  _loader_constraints = NULL;\n+\n+  assert(src._enum_klass_static_fields == NULL, \"This should not happen with dynamic dump.\");\n+  _enum_klass_static_fields = NULL;\n+\n+  {\n+    int n = src.num_verifier_constraints();\n+    if (n > 0) {\n+      _verifier_constraints = new (ResourceObj::C_HEAP, mtClass) GrowableArray<DTVerifierConstraint>(n, mtClass);\n+      _verifier_constraint_flags = new (ResourceObj::C_HEAP, mtClass) GrowableArray<char>(n, mtClass);\n+      for (int i = 0; i < n; i++) {\n+        _verifier_constraints->append(src._verifier_constraints->at(i));\n+        _verifier_constraint_flags->append(src._verifier_constraint_flags->at(i));\n+      }\n@@ -59,5 +67,8 @@\n-  int clone_num_loader_constraints = num_loader_constraints();\n-  if (clone_num_loader_constraints > 0) {\n-    clone._loader_constraints = new (ResourceObj::C_HEAP, mtClass) GrowableArray<DTLoaderConstraint>(clone_num_loader_constraints, mtClass);\n-    for (int i = 0; i < clone_num_loader_constraints; i++) {\n-      clone._loader_constraints->append(_loader_constraints->at(i));\n+\n+  {\n+    int n = src.num_loader_constraints();\n+    if (n > 0) {\n+      _loader_constraints = new (ResourceObj::C_HEAP, mtClass) GrowableArray<DTLoaderConstraint>(n, mtClass);\n+      for (int i = 0; i < n; i++) {\n+        _loader_constraints->append(src._loader_constraints->at(i));\n+      }\n@@ -66,2 +77,11 @@\n-  assert(_enum_klass_static_fields == NULL, \"This should not happen with jcmd VM.cds dumping\");\n-  return clone;\n+}\n+\n+DumpTimeClassInfo::~DumpTimeClassInfo() {\n+  if (_verifier_constraints != NULL) {\n+    assert(_verifier_constraint_flags != NULL, \"must be\");\n+    delete _verifier_constraints;\n+    delete _verifier_constraint_flags;\n+  }\n+  if (_loader_constraints != NULL) {\n+    delete _loader_constraints;\n+  }\n@@ -86,2 +106,1 @@\n-    DTVerifierConstraint* p = vc_array->adr_at(i);\n-    if (name == p->_name && from_name == p->_from_name) {\n+    if (vc_array->at(i).equals(name, from_name)) {\n@@ -131,2 +150,1 @@\n-    DTLoaderConstraint dt = _loader_constraints->at(i);\n-    if (lc.equals(dt)) {\n+    if (lc.equals(_loader_constraints->at(i))) {\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.cpp","additions":52,"deletions":34,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -43,2 +43,2 @@\n-public:\n-  struct DTLoaderConstraint {\n+\n+  class DTLoaderConstraint {\n@@ -48,0 +48,2 @@\n+  public:\n+    DTLoaderConstraint() : _name(NULL), _loader_type1('0'), _loader_type2('0') {}\n@@ -49,1 +51,1 @@\n-      _name->increment_refcount();\n+      Symbol::maybe_increment_refcount(_name);\n@@ -51,1 +53,16 @@\n-    DTLoaderConstraint() : _name(NULL), _loader_type1('0'), _loader_type2('0') {}\n+    DTLoaderConstraint(const DTLoaderConstraint& src) {\n+      _name = src._name;\n+      _loader_type1 = src._loader_type1;\n+      _loader_type2 = src._loader_type2;\n+      Symbol::maybe_increment_refcount(_name);\n+    }\n+    DTLoaderConstraint& operator=(DTLoaderConstraint src) {\n+      swap(_name, src._name); \/\/ c++ copy-and-swap idiom\n+      _loader_type1 = src._loader_type1;\n+      _loader_type2 = src._loader_type2;\n+      return *this;\n+    }\n+    ~DTLoaderConstraint() {\n+      Symbol::maybe_decrement_refcount(_name);\n+    }\n+\n@@ -57,0 +74,7 @@\n+    void metaspace_pointers_do(MetaspaceClosure* it) {\n+      it->push(&_name);\n+    }\n+\n+    Symbol* name()      { return _name;         }\n+    char loader_type1() { return _loader_type1; }\n+    char loader_type2() { return _loader_type2; }\n@@ -59,1 +83,1 @@\n-  struct DTVerifierConstraint {\n+  class DTVerifierConstraint {\n@@ -62,0 +86,1 @@\n+  public:\n@@ -64,2 +89,17 @@\n-      _name->increment_refcount();\n-      _from_name->increment_refcount();\n+      Symbol::maybe_increment_refcount(_name);\n+      Symbol::maybe_increment_refcount(_from_name);\n+    }\n+    DTVerifierConstraint(const DTVerifierConstraint& src) {\n+      _name = src._name;\n+      _from_name = src._from_name;\n+      Symbol::maybe_increment_refcount(_name);\n+      Symbol::maybe_increment_refcount(_from_name);\n+    }\n+    DTVerifierConstraint& operator=(DTVerifierConstraint src) {\n+      swap(_name, src._name); \/\/ c++ copy-and-swap idiom\n+      swap(_from_name, src._from_name); \/\/ c++ copy-and-swap idiom\n+      return *this;\n+    }\n+    ~DTVerifierConstraint() {\n+      Symbol::maybe_decrement_refcount(_name);\n+      Symbol::maybe_decrement_refcount(_from_name);\n@@ -67,0 +107,10 @@\n+    bool equals(Symbol* n, Symbol* fn) {\n+      return (_name == n) && (_from_name == fn);\n+    }\n+    void metaspace_pointers_do(MetaspaceClosure* it) {\n+      it->push(&_name);\n+      it->push(&_from_name);\n+    }\n+\n+    Symbol* name()      { return _name;      }\n+    Symbol* from_name() { return _from_name; }\n@@ -69,0 +119,1 @@\n+public:\n@@ -97,0 +148,3 @@\n+  DumpTimeClassInfo(const DumpTimeClassInfo& src);\n+  DumpTimeClassInfo& operator=(const DumpTimeClassInfo&) = delete;\n+  ~DumpTimeClassInfo();\n@@ -134,3 +188,1 @@\n-        DTVerifierConstraint* cons = _verifier_constraints->adr_at(i);\n-        it->push(&cons->_name);\n-        it->push(&cons->_from_name);\n+        _verifier_constraints->adr_at(i)->metaspace_pointers_do(it);\n@@ -141,2 +193,1 @@\n-        DTLoaderConstraint* lc = _loader_constraints->adr_at(i);\n-        it->push(&lc->_name);\n+        _loader_constraints->adr_at(i)->metaspace_pointers_do(it);\n@@ -165,1 +216,0 @@\n-  DumpTimeClassInfo clone();\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.hpp","additions":63,"deletions":13,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,8 +30,9 @@\n-DumpTimeLambdaProxyClassInfo DumpTimeLambdaProxyClassInfo::clone() {\n-  DumpTimeLambdaProxyClassInfo res;\n-  res._proxy_klasses = NULL;\n-  if (_proxy_klasses != NULL && _proxy_klasses->length() > 0) {\n-    int num_proxy_klasses = _proxy_klasses->length();\n-    res._proxy_klasses = new (ResourceObj::C_HEAP, mtClassShared) GrowableArray<InstanceKlass*>(num_proxy_klasses, mtClassShared);\n-    for (int i = 0; i < num_proxy_klasses; i++) {\n-      res._proxy_klasses->append(_proxy_klasses->at(i));\n+\/\/ This constructor is used only by SystemDictionaryShared::clone_dumptime_tables().\n+\/\/ See comments there about the need for making a deep copy.\n+DumpTimeLambdaProxyClassInfo::DumpTimeLambdaProxyClassInfo(const DumpTimeLambdaProxyClassInfo& src) {\n+  _proxy_klasses = NULL;\n+  if (src._proxy_klasses != NULL && src._proxy_klasses->length() > 0) {\n+    int n = src._proxy_klasses->length();\n+    _proxy_klasses = new (ResourceObj::C_HEAP, mtClassShared) GrowableArray<InstanceKlass*>(n, mtClassShared);\n+    for (int i = 0; i < n; i++) {\n+      _proxy_klasses->append(src._proxy_klasses->at(i));\n@@ -40,1 +41,6 @@\n-  return res;\n+}\n+\n+DumpTimeLambdaProxyClassInfo::~DumpTimeLambdaProxyClassInfo() {\n+  if (_proxy_klasses != NULL) {\n+    delete _proxy_klasses;\n+  }\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.cpp","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,0 +111,4 @@\n+  DumpTimeLambdaProxyClassInfo(const DumpTimeLambdaProxyClassInfo& src);\n+  DumpTimeLambdaProxyClassInfo& operator=(const DumpTimeLambdaProxyClassInfo&) = delete;\n+  ~DumpTimeLambdaProxyClassInfo();\n+\n@@ -124,1 +128,0 @@\n-  DumpTimeLambdaProxyClassInfo clone(); \/\/ copy ctor will cause implicitly-declared\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -47,2 +47,2 @@\n-      vf_constraints[i]._name      = builder->any_to_offset_u4(info._verifier_constraints->at(i)._name);\n-      vf_constraints[i]._from_name = builder->any_to_offset_u4(info._verifier_constraints->at(i)._from_name);\n+      vf_constraints[i]._name      = builder->any_to_offset_u4(info._verifier_constraints->at(i).name());\n+      vf_constraints[i]._from_name = builder->any_to_offset_u4(info._verifier_constraints->at(i).from_name());\n@@ -58,3 +58,3 @@\n-      ld_constraints[i]._name = builder->any_to_offset_u4(info._loader_constraints->at(i)._name);\n-      ld_constraints[i]._loader_type1 = info._loader_constraints->at(i)._loader_type1;\n-      ld_constraints[i]._loader_type2 = info._loader_constraints->at(i)._loader_type2;\n+      ld_constraints[i]._name = builder->any_to_offset_u4(info._loader_constraints->at(i).name());\n+      ld_constraints[i]._loader_type1 = info._loader_constraints->at(i).loader_type1();\n+      ld_constraints[i]._loader_type2 = info._loader_constraints->at(i).loader_type2();\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -518,29 +518,0 @@\n-  DumpTimeClassInfo* p = _dumptime_table->get(k);\n-  if (p == NULL) {\n-    return;\n-  }\n-  if (p->_verifier_constraints != NULL) {\n-    for (int i = 0; i < p->_verifier_constraints->length(); i++) {\n-      DumpTimeClassInfo::DTVerifierConstraint constraint = p->_verifier_constraints->at(i);\n-      if (constraint._name != NULL ) {\n-        constraint._name->decrement_refcount();\n-      }\n-      if (constraint._from_name != NULL ) {\n-        constraint._from_name->decrement_refcount();\n-      }\n-    }\n-    FREE_C_HEAP_ARRAY(DumpTimeClassInfo::DTVerifierConstraint, p->_verifier_constraints);\n-    p->_verifier_constraints = NULL;\n-    FREE_C_HEAP_ARRAY(char, p->_verifier_constraint_flags);\n-    p->_verifier_constraint_flags = NULL;\n-  }\n-  if (p->_loader_constraints != NULL) {\n-    for (int i = 0; i < p->_loader_constraints->length(); i++) {\n-      DumpTimeClassInfo::DTLoaderConstraint ld =  p->_loader_constraints->at(i);\n-      if (ld._name != NULL) {\n-        ld._name->decrement_refcount();\n-      }\n-    }\n-    FREE_C_HEAP_ARRAY(DumpTimeClassInfo::DTLoaderConstraint, p->_loader_constraints);\n-    p->_loader_constraints = NULL;\n-  }\n@@ -762,7 +733,4 @@\n-  DumpTimeLambdaProxyClassInfo* lambda_info = _dumptime_lambda_proxy_class_dictionary->get(key);\n-  if (lambda_info == NULL) {\n-    DumpTimeLambdaProxyClassInfo info;\n-    info.add_proxy_klass(proxy_klass);\n-    _dumptime_lambda_proxy_class_dictionary->put(key, info);\n-    \/\/lambda_info = _dumptime_lambda_proxy_class_dictionary->get(key);\n-    \/\/assert(lambda_info->_proxy_klass == proxy_klass, \"must be\"); \/\/ debug only -- remove\n+  bool created;\n+  DumpTimeLambdaProxyClassInfo* info = _dumptime_lambda_proxy_class_dictionary->put_if_absent(key, &created);\n+  info->add_proxy_klass(proxy_klass);\n+  if (created) {\n@@ -770,2 +738,0 @@\n-  } else {\n-    lambda_info->add_proxy_klass(proxy_klass);\n@@ -1487,1 +1453,2 @@\n-      _cloned_table->put_if_absent(k, info.clone(), &created);\n+      _cloned_table->put_if_absent(k, info, &created);\n+      assert(created, \"must be\");\n@@ -1508,1 +1475,2 @@\n-    _cloned_table->put_if_absent(keyCopy, info.clone(), &created);\n+    _cloned_table->put_if_absent(keyCopy, info, &created);\n+    assert(created, \"must be\");\n@@ -1514,0 +1482,12 @@\n+\/\/ When dumping the CDS archive, the ArchiveBuilder will irrecoverably modify the\n+\/\/ _dumptime_table and _dumptime_lambda_proxy_class_dictionary (e.g., metaspace\n+\/\/ pointers are changed to use \"buffer\" addresses.)\n+\/\/\n+\/\/ We save a copy of these tables and restore them after the dumping is finished.\n+\/\/ This makes it possible to repeat the dumping operation (e.g., use\n+\/\/ \"jcmd VM.cds dynamic_dump\" multiple times on the same JVM process).\n+\/\/\n+\/\/ We use the copy constructors to clone the values in these tables. The copy constructors\n+\/\/ must make a deep copy, as internal data structures such as the contents of\n+\/\/ DumpTimeClassInfo::_loader_constraints are also modified by the ArchiveBuilder.\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":20,"deletions":40,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -175,0 +175,10 @@\n+  static void maybe_increment_refcount(Symbol* s) {\n+    if (s != NULL) {\n+      s->increment_refcount();\n+    }\n+  }\n+  static void maybe_decrement_refcount(Symbol* s) {\n+    if (s != NULL) {\n+      s->decrement_refcount();\n+    }\n+  }\n","filename":"src\/hotspot\/share\/oops\/symbol.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}