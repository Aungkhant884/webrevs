{"files":[{"patch":"@@ -91,15 +91,0 @@\n-\/* read_mem_swap\n- *\n- * Returns the memory and swap metric. Note that calling code\n- * needs to handle re-casting for negative values.\n- *\n- * return:\n- *    A number > 0 if available,\n- *    OSCONTAINER_ERROR (as julong) for not supported\n- *\/\n-julong CgroupV1Subsystem::read_mem_swap() {\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.memsw.limit_in_bytes\",\n-                     \"Memory and Swap Limit is: \", JULONG_FORMAT, JULONG_FORMAT, memswlimit);\n-  return memswlimit;\n-}\n-\n@@ -129,7 +114,13 @@\n-jlong CgroupV1Subsystem::memory_and_swap_limit_in_bytes() {\n-  julong memswlimit = read_mem_swap();\n-  jlong swap_limit = (jlong)memswlimit; \/\/ For OSCONTAINER_ERROR which is < 0\n-  if (swap_limit < 0) {\n-    \/\/ swap disabled on kernel level. Treat it as no swap.\n-    return read_memory_limit_in_bytes();\n-  }\n+\/* read_mem_swap\n+ *\n+ * Determine the memory and swap limit metric. Returns a positive limit value strictly\n+ * lower than the physical memory and swap limit iff there is a limit. Otherwise a\n+ * negative value is returned indicating the determined status.\n+ *\n+ * returns:\n+ *    * A number > 0 if the limit is available and lower than a physical upper bound.\n+ *    * OSCONTAINER_ERROR if the limit cannot be retrieved (i.e. not supported) or\n+ *    * -1 if there isn't any limit in place (note: includes values which exceed a physical\n+ *      upper bound)\n+ *\/\n+jlong CgroupV1Subsystem::read_mem_swap() {\n@@ -137,0 +128,2 @@\n+  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.memsw.limit_in_bytes\",\n+                     \"Memory and Swap Limit is: \", JULONG_FORMAT, JULONG_FORMAT, memswlimit);\n@@ -148,8 +141,0 @@\n-        jlong swappiness = read_mem_swappiness();\n-        if (swappiness == 0) {\n-            const char* matchmemline = \"hierarchical_memory_limit\";\n-            GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", matchmemline,\n-                             \"Hierarchical Memory Limit is : \" JULONG_FORMAT, JULONG_FORMAT, hier_memlimit)\n-            log_trace(os, container)(\"Memory and Swap Limit has been reset to \" JULONG_FORMAT \" because swappiness is 0\", hier_memlimit);\n-            return (jlong)hier_memlimit;\n-        }\n@@ -161,6 +146,0 @@\n-    jlong swappiness = read_mem_swappiness();\n-    if (swappiness == 0) {\n-      jlong memlimit = read_memory_limit_in_bytes();\n-      log_trace(os, container)(\"Memory and Swap Limit has been reset to \" JULONG_FORMAT \" because swappiness is 0\", memlimit);\n-      return memlimit;\n-    }\n@@ -171,0 +150,21 @@\n+jlong CgroupV1Subsystem::memory_and_swap_limit_in_bytes() {\n+  jlong memory_swap = read_mem_swap();\n+  if (memory_swap == -1) {\n+    return memory_swap;\n+  }\n+  \/\/ If there is a swap limit, but swappiness == 0, reset the limit\n+  \/\/ to the memory limit. Do the same for cases where swap isn't\n+  \/\/ supported.\n+  jlong swappiness = read_mem_swappiness();\n+  if (swappiness == 0 || memory_swap == OSCONTAINER_ERROR) {\n+    jlong memlimit = read_memory_limit_in_bytes();\n+    if (memory_swap == OSCONTAINER_ERROR) {\n+      log_trace(os, container)(\"Memory and Swap Limit has been reset to \" JLONG_FORMAT \" because swap is not supported\", memlimit);\n+    } else {\n+      log_trace(os, container)(\"Memory and Swap Limit has been reset to \" JLONG_FORMAT \" because swappiness is 0\", memlimit);\n+    }\n+    return memlimit;\n+  }\n+  return memory_swap;\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":36,"deletions":36,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-    julong read_mem_swap();\n+    jlong read_mem_swap();\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}