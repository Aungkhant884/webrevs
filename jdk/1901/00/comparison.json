{"files":[{"patch":"@@ -631,1 +631,1 @@\n-            reset(false);\n+            reset(true);\n@@ -749,1 +749,1 @@\n-            reset(false);\n+            reset(true);\n@@ -802,1 +802,0 @@\n-            doCancel = false;\n@@ -887,1 +886,0 @@\n-            doCancel = false;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8258833\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\/sun.security.pkcs11:open\n+ * @run main\/othervm CancelMultipart\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.nio.ByteBuffer;\n+import java.security.Key;\n+import java.security.Provider;\n+import java.security.ProviderException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+public class CancelMultipart extends PKCS11Test {\n+\n+    private static Provider provider;\n+    private static Key key;\n+\n+    static {\n+        key = new SecretKeySpec(new byte[16], \"AES\");\n+    }\n+\n+    private static class SessionLeaker {\n+        private LeakOperation op;\n+        private LeakInputType type;\n+\n+        SessionLeaker(LeakOperation op, LeakInputType type) {\n+            this.op = op;\n+            this.type = type;\n+        }\n+\n+        private void leakAndTry() throws Exception {\n+            Cipher cipher = op.getCipher();\n+            try {\n+                type.doOperation(cipher,\n+                        (op instanceof LeakDecrypt ?\n+                                LeakInputType.DECRYPT_MODE :\n+                                LeakInputType.ENCRYPT_MODE));\n+                throw new Exception(\"PKCS11Exception expected, invalid block\"\n+                        + \"size\");\n+            } catch (ProviderException | IllegalBlockSizeException e) {\n+                \/\/ Exception expected - session returned to the SessionManager\n+                \/\/ should be cancelled. That's what will be tested now.\n+            }\n+\n+            tryCipherInit();\n+        }\n+    }\n+\n+    private static interface LeakOperation {\n+        Cipher getCipher() throws Exception;\n+    }\n+\n+    private static interface LeakInputType {\n+        static int ENCRYPT_MODE = 1;\n+        static int DECRYPT_MODE = 2;\n+        void doOperation(Cipher cipher, int mode) throws Exception;\n+    }\n+\n+    private static class LeakDecrypt implements LeakOperation {\n+        public Cipher getCipher() throws Exception {\n+            Cipher cipher = Cipher.getInstance(\n+                    \"AES\/ECB\/PKCS5Padding\", provider);\n+            cipher.init(Cipher.DECRYPT_MODE, key);\n+            return cipher;\n+        }\n+    }\n+\n+    private static class LeakEncrypt implements LeakOperation {\n+        public Cipher getCipher() throws Exception {\n+            Cipher cipher = Cipher.getInstance(\n+                    \"AES\/ECB\/NoPadding\", provider);\n+            cipher.init(Cipher.ENCRYPT_MODE, key);\n+            return cipher;\n+        }\n+    }\n+\n+    private static class LeakByteBuffer implements LeakInputType {\n+        public void doOperation(Cipher cipher, int mode) throws Exception {\n+            if (mode == DECRYPT_MODE) {\n+                cipher.update(ByteBuffer.allocate(1), ByteBuffer.allocate(1));\n+                cipher.doFinal(ByteBuffer.allocate(0), ByteBuffer.allocate(1));\n+            } else {\n+                cipher.update(ByteBuffer.allocate(1), ByteBuffer.allocate(2));\n+            }\n+        }\n+    }\n+\n+    private static class LeakByteArray implements LeakInputType {\n+        public void doOperation(Cipher cipher, int mode) throws Exception {\n+            if (mode == DECRYPT_MODE) {\n+                cipher.update(new byte[1]);\n+                cipher.doFinal(new byte[1], 0, 0);\n+            } else {\n+                cipher.update(new byte[1]);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new CancelMultipart(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        init(p);\n+\n+        \/\/ Try multiple paths:\n+\n+        executeTest(new SessionLeaker(new LeakEncrypt(), new LeakByteArray()),\n+                \"P11Cipher::implUpdate(byte[], int, int, byte[], int, int)\");\n+\n+        executeTest(new SessionLeaker(new LeakEncrypt(), new LeakByteBuffer()),\n+                \"P11Cipher::implUpdate(ByteBuffer, ByteBuffer)\");\n+\n+        executeTest(new SessionLeaker(new LeakDecrypt(), new LeakByteArray()),\n+                \"P11Cipher::implDoFinal(byte[], int, int)\");\n+\n+        executeTest(new SessionLeaker(new LeakDecrypt(), new LeakByteBuffer()),\n+                \"P11Cipher::implDoFinal(ByteBuffer)\");\n+\n+        System.out.println(\"TEST PASS - OK\");\n+    }\n+\n+    private static void executeTest(SessionLeaker sl, String testName)\n+            throws Exception {\n+        try {\n+            sl.leakAndTry();\n+            System.out.println(testName +  \": OK\");\n+        } catch (Exception e) {\n+            System.out.println(testName +  \": FAILED\");\n+            throw e;\n+        }\n+    }\n+\n+    private static void init(Provider p) throws Exception {\n+        provider = p;\n+\n+        \/\/ The max number of sessions is 2 because, in addition to the\n+        \/\/ operation (i.e. PKCS11::getNativeKeyInfo), a session to hold\n+        \/\/ the P11Key object is needed.\n+        setMaxSessions(2);\n+    }\n+\n+    \/*\n+     * This method is intended to generate pression on the number of sessions\n+     * to be used from the NSS Software Token, so sessions with (potentially)\n+     * active operations are reused.\n+     *\/\n+    private static void setMaxSessions(int maxSessions) throws Exception {\n+        Field tokenField = Class.forName(\"sun.security.pkcs11.SunPKCS11\")\n+                .getDeclaredField(\"token\");\n+        tokenField.setAccessible(true);\n+        Field sessionManagerField = Class.forName(\"sun.security.pkcs11.Token\")\n+                .getDeclaredField(\"sessionManager\");\n+        sessionManagerField.setAccessible(true);\n+        Field maxSessionsField = Class.forName(\"sun.security.pkcs11.SessionManager\")\n+                .getDeclaredField(\"maxSessions\");\n+        maxSessionsField.setAccessible(true);\n+        Object sessionManagerObj = sessionManagerField.get(\n+                tokenField.get(provider));\n+        maxSessionsField.setInt(sessionManagerObj, maxSessions);\n+    }\n+\n+    private static void tryCipherInit() throws Exception {\n+        Cipher cipher = Cipher.getInstance(\"AES\/ECB\/NoPadding\", provider);\n+        cipher.init(Cipher.ENCRYPT_MODE, key);\n+\n+        \/\/ If initialization passes, finish gracefully so other paths can\n+        \/\/ be tested under the current max number of sessions.\n+        cipher.doFinal(new byte[16], 0, 0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/CancelMultipart.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"}]}