{"files":[{"patch":"@@ -353,0 +353,7 @@\n+            if (e.getErrorCode() == CKR_OPERATION_NOT_INITIALIZED) {\n+                \/\/ Cancel Operation may be invoked after an error on a PKCS#11\n+                \/\/ call. If the operation inside the token was already cancelled,\n+                \/\/ do not fail here. This is part of a defensive mechanism for\n+                \/\/ PKCS#11 libraries that do not strictly follow the standard.\n+                return;\n+            }\n@@ -619,0 +626,6 @@\n+            \/\/ As per the PKCS#11 standard, C_Encrypt and C_Decrypt may only\n+            \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n+            \/\/ successful calls to determine the output length. However,\n+            \/\/ these cases are not expected here because the output length\n+            \/\/ is checked in the OpenJDK side before making the PKCS#11 call.\n+            \/\/ Thus, doCancel can safely be 'false'.\n@@ -705,0 +718,6 @@\n+            \/\/ As per the PKCS#11 standard, C_Encrypt and C_Decrypt may only\n+            \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n+            \/\/ successful calls to determine the output length. However,\n+            \/\/ these cases are not expected here because the output length\n+            \/\/ is checked in the OpenJDK side before making the PKCS#11 call.\n+            \/\/ Thus, doCancel can safely be 'false'.\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -442,0 +442,7 @@\n+            if (e.getErrorCode() == CKR_OPERATION_NOT_INITIALIZED) {\n+                \/\/ Cancel Operation may be invoked after an error on a PKCS#11\n+                \/\/ call. If the operation inside the token was already cancelled,\n+                \/\/ do not fail here. This is part of a defensive mechanism for\n+                \/\/ PKCS#11 libraries that do not strictly follow the standard.\n+                return;\n+            }\n@@ -631,1 +638,1 @@\n-            reset(false);\n+            reset(true);\n@@ -749,1 +756,1 @@\n-            reset(false);\n+            reset(true);\n@@ -802,1 +809,0 @@\n-            doCancel = false;\n@@ -848,0 +854,1 @@\n+                doCancel = false;\n@@ -850,1 +857,0 @@\n-                doCancel = false;\n@@ -864,0 +870,1 @@\n+                    doCancel = false;\n@@ -866,1 +873,0 @@\n-                    doCancel = false;\n@@ -873,0 +879,1 @@\n+                    doCancel = false;\n@@ -875,1 +882,0 @@\n-                    doCancel = false;\n@@ -887,1 +893,0 @@\n-            doCancel = false;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -154,0 +154,7 @@\n+            if (e.getErrorCode() == CKR_OPERATION_NOT_INITIALIZED) {\n+                \/\/ Cancel Operation may be invoked after an error on a PKCS#11\n+                \/\/ call. If the operation inside the token was already cancelled,\n+                \/\/ do not fail here. This is part of a defensive mechanism for\n+                \/\/ PKCS#11 libraries that do not strictly follow the standard.\n+                return;\n+            }\n@@ -216,0 +223,5 @@\n+            \/\/ As per the PKCS#11 standard, C_SignFinal may only\n+            \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n+            \/\/ successful calls to determine the output length. However,\n+            \/\/ these cases are handled at OpenJDK's libj2pkcs11 native\n+            \/\/ library. Thus, doCancel can safely be 'false' here.\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Mac.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -301,0 +301,7 @@\n+            if (e.getErrorCode() == CKR_OPERATION_NOT_INITIALIZED) {\n+                \/\/ Cancel Operation may be invoked after an error on a PKCS#11\n+                \/\/ call. If the operation inside the token was already cancelled,\n+                \/\/ do not fail here. This is part of a defensive mechanism for\n+                \/\/ PKCS#11 libraries that do not strictly follow the standard.\n+                return;\n+            }\n@@ -665,0 +672,5 @@\n+            \/\/ As per the PKCS#11 standard, C_Sign and C_SignFinal may only\n+            \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n+            \/\/ successful calls to determine the output length. However,\n+            \/\/ these cases are handled at OpenJDK's libj2pkcs11 native\n+            \/\/ library. Thus, doCancel can safely be 'false' here.\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11PSSSignature.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -317,0 +317,7 @@\n+            if (e.getErrorCode() == CKR_OPERATION_NOT_INITIALIZED) {\n+                \/\/ Cancel Operation may be invoked after an error on a PKCS#11\n+                \/\/ call. If the operation inside the token was already cancelled,\n+                \/\/ do not fail here. This is part of a defensive mechanism for\n+                \/\/ PKCS#11 libraries that do not strictly follow the standard.\n+                return;\n+            }\n@@ -657,0 +664,5 @@\n+            \/\/ As per the PKCS#11 standard, C_Sign and C_SignFinal may only\n+            \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n+            \/\/ successful calls to determine the output length. However,\n+            \/\/ these cases are handled at OpenJDK's libj2pkcs11 native\n+            \/\/ library. Thus, doCancel can safely be 'false' here.\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Signature.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8258833\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\/sun.security.pkcs11:open\n+ * @run main\/othervm CancelMultipart\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.nio.ByteBuffer;\n+import java.security.Key;\n+import java.security.Provider;\n+import java.security.ProviderException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+public class CancelMultipart extends PKCS11Test {\n+\n+    private static Provider provider;\n+    private static Key key;\n+\n+    static {\n+        key = new SecretKeySpec(new byte[16], \"AES\");\n+    }\n+\n+    private static class SessionLeaker {\n+        private LeakOperation op;\n+        private LeakInputType type;\n+\n+        SessionLeaker(LeakOperation op, LeakInputType type) {\n+            this.op = op;\n+            this.type = type;\n+        }\n+\n+        private void leakAndTry() throws Exception {\n+            Cipher cipher = op.getCipher();\n+            try {\n+                type.doOperation(cipher,\n+                        (op instanceof LeakDecrypt ?\n+                                LeakInputType.DECRYPT_MODE :\n+                                LeakInputType.ENCRYPT_MODE));\n+                throw new Exception(\"PKCS11Exception expected, invalid block\"\n+                        + \"size\");\n+            } catch (ProviderException | IllegalBlockSizeException e) {\n+                \/\/ Exception expected - session returned to the SessionManager\n+                \/\/ should be cancelled. That's what will be tested now.\n+            }\n+\n+            tryCipherInit();\n+        }\n+    }\n+\n+    private static interface LeakOperation {\n+        Cipher getCipher() throws Exception;\n+    }\n+\n+    private static interface LeakInputType {\n+        static int ENCRYPT_MODE = 1;\n+        static int DECRYPT_MODE = 2;\n+        void doOperation(Cipher cipher, int mode) throws Exception;\n+    }\n+\n+    private static class LeakDecrypt implements LeakOperation {\n+        public Cipher getCipher() throws Exception {\n+            Cipher cipher = Cipher.getInstance(\n+                    \"AES\/ECB\/PKCS5Padding\", provider);\n+            cipher.init(Cipher.DECRYPT_MODE, key);\n+            return cipher;\n+        }\n+    }\n+\n+    private static class LeakEncrypt implements LeakOperation {\n+        public Cipher getCipher() throws Exception {\n+            Cipher cipher = Cipher.getInstance(\n+                    \"AES\/ECB\/NoPadding\", provider);\n+            cipher.init(Cipher.ENCRYPT_MODE, key);\n+            return cipher;\n+        }\n+    }\n+\n+    private static class LeakByteBuffer implements LeakInputType {\n+        public void doOperation(Cipher cipher, int mode) throws Exception {\n+            if (mode == DECRYPT_MODE) {\n+                cipher.update(ByteBuffer.allocate(1), ByteBuffer.allocate(1));\n+                cipher.doFinal(ByteBuffer.allocate(0), ByteBuffer.allocate(1));\n+            } else {\n+                cipher.update(ByteBuffer.allocate(1), ByteBuffer.allocate(2));\n+            }\n+        }\n+    }\n+\n+    private static class LeakByteArray implements LeakInputType {\n+        public void doOperation(Cipher cipher, int mode) throws Exception {\n+            if (mode == DECRYPT_MODE) {\n+                cipher.update(new byte[1]);\n+                cipher.doFinal(new byte[1], 0, 0);\n+            } else {\n+                cipher.update(new byte[1]);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new CancelMultipart(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        init(p);\n+\n+        \/\/ Try multiple paths:\n+\n+        executeTest(new SessionLeaker(new LeakEncrypt(), new LeakByteArray()),\n+                \"P11Cipher::implUpdate(byte[], int, int, byte[], int, int)\");\n+\n+        executeTest(new SessionLeaker(new LeakEncrypt(), new LeakByteBuffer()),\n+                \"P11Cipher::implUpdate(ByteBuffer, ByteBuffer)\");\n+\n+        executeTest(new SessionLeaker(new LeakDecrypt(), new LeakByteArray()),\n+                \"P11Cipher::implDoFinal(byte[], int, int)\");\n+\n+        executeTest(new SessionLeaker(new LeakDecrypt(), new LeakByteBuffer()),\n+                \"P11Cipher::implDoFinal(ByteBuffer)\");\n+\n+        System.out.println(\"TEST PASS - OK\");\n+    }\n+\n+    private static void executeTest(SessionLeaker sl, String testName)\n+            throws Exception {\n+        try {\n+            sl.leakAndTry();\n+            System.out.println(testName +  \": OK\");\n+        } catch (Exception e) {\n+            System.out.println(testName +  \": FAILED\");\n+            throw e;\n+        }\n+    }\n+\n+    private static void init(Provider p) throws Exception {\n+        provider = p;\n+\n+        \/\/ The max number of sessions is 2 because, in addition to the\n+        \/\/ operation (i.e. PKCS11::getNativeKeyInfo), a session to hold\n+        \/\/ the P11Key object is needed.\n+        setMaxSessions(2);\n+    }\n+\n+    \/*\n+     * This method is intended to generate pression on the number of sessions\n+     * to be used from the NSS Software Token, so sessions with (potentially)\n+     * active operations are reused.\n+     *\/\n+    private static void setMaxSessions(int maxSessions) throws Exception {\n+        Field tokenField = Class.forName(\"sun.security.pkcs11.SunPKCS11\")\n+                .getDeclaredField(\"token\");\n+        tokenField.setAccessible(true);\n+        Field sessionManagerField = Class.forName(\"sun.security.pkcs11.Token\")\n+                .getDeclaredField(\"sessionManager\");\n+        sessionManagerField.setAccessible(true);\n+        Field maxSessionsField = Class.forName(\"sun.security.pkcs11.SessionManager\")\n+                .getDeclaredField(\"maxSessions\");\n+        maxSessionsField.setAccessible(true);\n+        Object sessionManagerObj = sessionManagerField.get(\n+                tokenField.get(provider));\n+        maxSessionsField.setInt(sessionManagerObj, maxSessions);\n+    }\n+\n+    private static void tryCipherInit() throws Exception {\n+        Cipher cipher = Cipher.getInstance(\"AES\/ECB\/NoPadding\", provider);\n+\n+        \/\/ A CKR_OPERATION_ACTIVE error may be thrown if a session was\n+        \/\/ returned to the Session Manager with an active operation, and\n+        \/\/ we try to initialize the Cipher using it.\n+        \/\/\n+        \/\/ Given that the maximum number of sessions was forced to 2, we know\n+        \/\/ that the session to be used here was already used in a previous\n+        \/\/ (failed) operation. Thus, the test asserts that the operation was\n+        \/\/ properly cancelled.\n+        cipher.init(Cipher.ENCRYPT_MODE, key);\n+\n+        \/\/ If initialization passes, finish gracefully so other paths can\n+        \/\/ be tested under the current maximum number of sessions.\n+        cipher.doFinal(new byte[16], 0, 0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/CancelMultipart.java","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"}]}