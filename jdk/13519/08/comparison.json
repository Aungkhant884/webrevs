{"files":[{"patch":"@@ -786,12 +786,14 @@\n-    ThreadsListHandle tlh;\n-    JavaThread* thr = nullptr;\n-    oop java_thread = nullptr;\n-    (void) tlh.cv_internal_thread_to_JavaThread(jthread, &thr, &java_thread);\n-    if (java_thread != nullptr) {\n-      \/\/ This is a valid oop.\n-      if (thr != nullptr) {\n-        \/\/ The JavaThread is alive.\n-        Parker* p = thr->parker();\n-        HOTSPOT_THREAD_UNPARK((uintptr_t) p);\n-        p->unpark();\n-      }\n+    oop thread_oop = JNIHandles::resolve_non_null(jthread);\n+    \/\/ Get the JavaThread* stored in the java.lang.Thread object _before_\n+    \/\/ the embedded ThreadsListHandle is constructed so we know if the\n+    \/\/ early life stage of the JavaThread* is protected. We use acquire\n+    \/\/ here to ensure that if we see a non-nullptr value, then we also\n+    \/\/ see the main ThreadsList updates from the JavaThread* being added.\n+    FastThreadsListHandle ftlh(thread_oop, java_lang_Thread::thread_acquire(thread_oop));\n+    JavaThread* thr = ftlh.protected_java_thread();\n+    if (thr != nullptr) {\n+      \/\/ The still live JavaThread* is protected by the FastThreadsListHandle\n+      \/\/ so it is safe to access.\n+      Parker* p = thr->parker();\n+      HOTSPOT_THREAD_UNPARK((uintptr_t) p);\n+      p->unpark();\n@@ -799,2 +801,1 @@\n-  } \/\/ ThreadsListHandle is destroyed here.\n-\n+  } \/\/ FastThreadsListHandle is destroyed here.\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -842,0 +842,14 @@\n+FastThreadsListHandle::FastThreadsListHandle(oop thread_oop, JavaThread* java_thread) : _protected_java_thread(nullptr) {\n+  assert(thread_oop != nullptr, \"must be\");\n+  if (java_thread != nullptr) {\n+    \/\/ We captured a non-nullptr JavaThread* before the _tlh was created\n+    \/\/ so that covers the early life stage of the target JavaThread.\n+    _protected_java_thread = java_lang_Thread::thread(thread_oop);\n+    assert(_protected_java_thread == nullptr || _tlh.includes(_protected_java_thread), \"must be\");\n+    \/\/ If we captured a non-nullptr JavaThread* after the _tlh was created\n+    \/\/ then that covers the end life stage of the target JavaThread and we\n+    \/\/ we know that _tlh protects the JavaThread*. The underlying atomic\n+    \/\/ load is sufficient (no acquire necessary here).\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -336,0 +336,23 @@\n+\/\/ This stack allocated FastThreadsListHandle implements the special case\n+\/\/ where we want to quickly determine if a JavaThread* is protected by the\n+\/\/ embedded ThreadsListHandle.\n+\/\/\n+class FastThreadsListHandle : public StackObj {\n+  JavaThread* _protected_java_thread;\n+  ThreadsListHandle _tlh;\n+\n+public:\n+  \/\/ The 'java_thread' parameter to the constructor must be provided\n+  \/\/ by a java_lang_Thread::thread_acquire(thread_oop) call which gets\n+  \/\/ us the JavaThread* stored in the java.lang.Thread object _before_\n+  \/\/ the embedded ThreadsListHandle is constructed. We use acquire there\n+  \/\/ to ensure that if we see a non-nullptr value, then we also see the\n+  \/\/ main ThreadsList updates from the JavaThread* being added.\n+  \/\/\n+  FastThreadsListHandle(oop thread_oop, JavaThread* java_thread);\n+\n+  JavaThread* protected_java_thread() {\n+    return _protected_java_thread;\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"}]}