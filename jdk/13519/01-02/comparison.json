{"files":[{"patch":"@@ -786,0 +786,9 @@\n+    \/\/ ThreadsListHandle.cv_internal_thread_to_JavaThread() would normally\n+    \/\/ be used for this conversion from jthread -> JavaThread*, but we've\n+    \/\/ seen performance issues with very large numbers of threads due to\n+    \/\/ the ThreadsListHandle.includes() call in the conversion function.\n+    \/\/\n+    \/\/ So we verify that java_lang_Thread::thread(thread_oop) != nullptr\n+    \/\/ before and after creating tlh below and that lets us know that thr\n+    \/\/ is protected by tlh without a tlh.includes() call.\n+    \/\/\n@@ -789,13 +798,9 @@\n-      ThreadsListHandle tlh; \/\/ Provides memory barrier\n-      if (java_lang_Thread::thread(thread_oop) != nullptr) {\n-        \/\/ The still live JavaThread is protected by the ThreadsListHandle.\n-        JavaThread* thr = nullptr;\n-        \/\/ We verified that java_lang_Thread::thread(thread_oop) != nullptr\n-        \/\/ before and after creating tlh above so quick_mode can be used in\n-        \/\/ this conversion call.\n-        if (tlh.cv_internal_thread_to_JavaThread(jthread, &thr, nullptr, true \/* quick_mode *\/)) {\n-          \/\/ The JavaThread is safe to access.\n-          Parker* p = thr->parker();\n-          HOTSPOT_THREAD_UNPARK((uintptr_t) p);\n-          p->unpark();\n-        }\n+      ThreadsListHandle tlh;\n+      JavaThread* thr = nullptr;\n+      if ((thr = java_lang_Thread::thread(thread_oop)) != nullptr) {\n+        \/\/ The still live JavaThread is protected by the ThreadsListHandle\n+        \/\/ so it is safe to access.\n+        assert(tlh.includes(thr), \"must be\");\n+        Parker* p = thr->parker();\n+        HOTSPOT_THREAD_UNPARK((uintptr_t) p);\n+        p->unpark();\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -798,4 +798,0 @@\n-\/\/ If quick_mode is true, java_lang_Thread::thread(thread_oop) was verified\n-\/\/ in the caller to be a non-nullptr before and after the ThreadsListHandle\n-\/\/ was created so we can skip the ThreadsList search.\n-\/\/\n@@ -804,2 +800,1 @@\n-                                                         oop * thread_oop_p,\n-                                                         bool quick_mode) {\n+                                                         oop * thread_oop_p) {\n@@ -834,7 +829,2 @@\n-    \/\/ against the ThreadsList unless we're in quick_mode.\n-    \/\/\n-    \/\/ In quick_mode, java_lang_Thread::thread(thread_oop) was verified\n-    \/\/ in the caller to be a non-nullptr before and after creation of the\n-    \/\/ ThreadsListHandle so we can skip the ThreadsList search.\n-    \/\/\n-    if (!quick_mode && !includes(java_thread)) {\n+    \/\/ against the ThreadsList:\n+    if (!includes(java_thread)) {\n@@ -846,2 +836,0 @@\n-  assert(includes(java_thread), \"must be\");\n-\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -61,18 +61,0 @@\n-\/\/ JNI jobject example with quick_mode enabled:\n-\/\/   jobject jthread = ...;\n-\/\/   :\n-\/\/   oop thread_oop = JNIHandles::resolve_non_null(jthread);\n-\/\/   if (java_lang_Thread::thread(thread_oop) != nullptr) {\n-\/\/     ThreadsListHandle tlh;\n-\/\/     if (java_lang_Thread::thread(thread_oop) != nullptr) {\n-\/\/       JavaThread* jt = nullptr;\n-\/\/       bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &jt, nullptr, true \/* quick_mode *\/);\n-\/\/       if (is_alive) {\n-\/\/         :  \/\/ do stuff with 'jt'...\n-\/\/       }\n-\/\/     }\n-\/\/   }\n-\/\/ Because java_lang_Thread::thread(thread_oop) is verified to be a\n-\/\/ non-nullptr before and after the ThreadsListHandle is created, we\n-\/\/ do not have to do the ThreadsList search in the conversion function.\n-\/\/\n@@ -339,1 +321,1 @@\n-  bool cv_internal_thread_to_JavaThread(jobject jthread, JavaThread ** jt_pp, oop * thread_oop_p, bool quick_mode = false);\n+  bool cv_internal_thread_to_JavaThread(jobject jthread, JavaThread ** jt_pp, oop * thread_oop_p);\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.hpp","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"}]}