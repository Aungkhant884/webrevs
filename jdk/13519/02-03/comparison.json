{"files":[{"patch":"@@ -1568,1 +1568,1 @@\n-  return reinterpret_cast<JavaThread*>(java_thread->address_field(_eetop_offset));\n+  return reinterpret_cast<JavaThread*>(java_thread->address_field_acquire(_eetop_offset));\n@@ -1572,1 +1572,1 @@\n-  java_thread->address_field_put(_eetop_offset, (address)thread);\n+  java_thread->release_address_field_put(_eetop_offset, (address)thread);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -786,9 +786,0 @@\n-    \/\/ ThreadsListHandle.cv_internal_thread_to_JavaThread() would normally\n-    \/\/ be used for this conversion from jthread -> JavaThread*, but we've\n-    \/\/ seen performance issues with very large numbers of threads due to\n-    \/\/ the ThreadsListHandle.includes() call in the conversion function.\n-    \/\/\n-    \/\/ So we verify that java_lang_Thread::thread(thread_oop) != nullptr\n-    \/\/ before and after creating tlh below and that lets us know that thr\n-    \/\/ is protected by tlh without a tlh.includes() call.\n-    \/\/\n@@ -796,14 +787,13 @@\n-    if (java_lang_Thread::thread(thread_oop) != nullptr) {\n-      \/\/ Try to capture the live JavaThread in a ThreadsListHandle:\n-      ThreadsListHandle tlh;\n-      JavaThread* thr = nullptr;\n-      if ((thr = java_lang_Thread::thread(thread_oop)) != nullptr) {\n-        \/\/ The still live JavaThread is protected by the ThreadsListHandle\n-        \/\/ so it is safe to access.\n-        assert(tlh.includes(thr), \"must be\");\n-        Parker* p = thr->parker();\n-        HOTSPOT_THREAD_UNPARK((uintptr_t) p);\n-        p->unpark();\n-      }\n-    } \/\/ ThreadsListHandle is destroyed here.\n-  }\n+    \/\/ Get the JavaThread* stored in the java.lang.Thread object _before_\n+    \/\/ the embedded ThreadsListHandle is constructed so we know if the\n+    \/\/ early life stage of the JavaThread* is protected.\n+    FastThreadsListHandle ftlh(thread_oop, java_lang_Thread::thread(thread_oop));\n+    JavaThread* thr = ftlh.protected_java_thread();\n+    if (thr != nullptr) {\n+      \/\/ The still live JavaThread* is protected by the FastThreadsListHandle\n+      \/\/ so it is safe to access.\n+      Parker* p = thr->parker();\n+      HOTSPOT_THREAD_UNPARK((uintptr_t) p);\n+      p->unpark();\n+    }\n+  } \/\/ FastThreadsListHandle is destroyed here.\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":13,"deletions":23,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -741,4 +741,4 @@\n-  \/\/ Clear the native thread instance - this makes isAlive return false and allows the join()\n-  \/\/ to complete once we've done the notify_all below. Needs a release() to obey Java Memory Model\n-  \/\/ requirements.\n-  OrderAccess::release();\n+  \/\/ Clear the native thread instance - this makes isAlive return false and\n+  \/\/ allows the join() to complete once we've done the notify_all() below.\n+  \/\/ Needs a release() to obey Java Memory Model requirements (which is done\n+  \/\/ in set_thread()).\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -842,0 +842,13 @@\n+FastThreadsListHandle::FastThreadsListHandle(oop thread_oop, JavaThread* java_thread) : _protected_java_thread(nullptr) {\n+  assert(thread_oop != nullptr, \"must be\");\n+  if (java_thread != nullptr) {\n+    \/\/ We captured a non-nullptr JavaThread* before the _tlh was created\n+    \/\/ so that covers the early life stage of the target JavaThread.\n+    _protected_java_thread = java_lang_Thread::thread(thread_oop);\n+    assert(_protected_java_thread == nullptr || _tlh.includes(_protected_java_thread), \"must be\");\n+    \/\/ If we captured a non-nullptr JavaThread* after the _tlh was created\n+    \/\/ then that covers the end life stage of the target JavaThread and we\n+    \/\/ we know that _tlh protects the JavaThread*.\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -336,0 +336,21 @@\n+\/\/ This stack allocated FastThreadsListHandle implements the special case\n+\/\/ where we want to quickly determine if a JavaThread* is protected by the\n+\/\/ embedded ThreadsListHandle.\n+\/\/\n+class FastThreadsListHandle : public StackObj {\n+  JavaThread* _protected_java_thread;\n+  ThreadsListHandle _tlh;\n+\n+public:\n+  \/\/ The 'java_thread' parameter to the constructor must be provided\n+  \/\/ by a java_lang_Thread::thread(thread_oop) call which gets us the\n+  \/\/ JavaThread* stored in the java.lang.Thread object _before_ the\n+  \/\/ embedded ThreadsListHandle is constructed.\n+  \/\/\n+  FastThreadsListHandle(oop thread_oop, JavaThread* java_thread);\n+\n+  JavaThread* protected_java_thread() {\n+    return _protected_java_thread;\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.hpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"}]}