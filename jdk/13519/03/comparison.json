{"files":[{"patch":"@@ -1568,1 +1568,1 @@\n-  return reinterpret_cast<JavaThread*>(java_thread->address_field(_eetop_offset));\n+  return reinterpret_cast<JavaThread*>(java_thread->address_field_acquire(_eetop_offset));\n@@ -1572,1 +1572,1 @@\n-  java_thread->address_field_put(_eetop_offset, (address)thread);\n+  java_thread->release_address_field_put(_eetop_offset, (address)thread);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -811,2 +811,0 @@\n-  \/\/ We do not check the EnableThreadSMRExtraValidityChecks option\n-  \/\/ for this includes() call because JVM\/TI's spec is tighter.\n@@ -854,2 +852,0 @@\n-  \/\/ We do not check the EnableThreadSMRExtraValidityChecks option\n-  \/\/ for this includes() call because JVM\/TI's spec is tighter.\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -786,12 +786,12 @@\n-    ThreadsListHandle tlh;\n-    JavaThread* thr = nullptr;\n-    oop java_thread = nullptr;\n-    (void) tlh.cv_internal_thread_to_JavaThread(jthread, &thr, &java_thread);\n-    if (java_thread != nullptr) {\n-      \/\/ This is a valid oop.\n-      if (thr != nullptr) {\n-        \/\/ The JavaThread is alive.\n-        Parker* p = thr->parker();\n-        HOTSPOT_THREAD_UNPARK((uintptr_t) p);\n-        p->unpark();\n-      }\n+    oop thread_oop = JNIHandles::resolve_non_null(jthread);\n+    \/\/ Get the JavaThread* stored in the java.lang.Thread object _before_\n+    \/\/ the embedded ThreadsListHandle is constructed so we know if the\n+    \/\/ early life stage of the JavaThread* is protected.\n+    FastThreadsListHandle ftlh(thread_oop, java_lang_Thread::thread(thread_oop));\n+    JavaThread* thr = ftlh.protected_java_thread();\n+    if (thr != nullptr) {\n+      \/\/ The still live JavaThread* is protected by the FastThreadsListHandle\n+      \/\/ so it is safe to access.\n+      Parker* p = thr->parker();\n+      HOTSPOT_THREAD_UNPARK((uintptr_t) p);\n+      p->unpark();\n@@ -799,2 +799,1 @@\n-  } \/\/ ThreadsListHandle is destroyed here.\n-\n+  } \/\/ FastThreadsListHandle is destroyed here.\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -952,3 +952,0 @@\n-  product(bool, EnableThreadSMRExtraValidityChecks, true, DIAGNOSTIC,       \\\n-             \"Enable Thread SMR extra validity checks\")                     \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -741,4 +741,4 @@\n-  \/\/ Clear the native thread instance - this makes isAlive return false and allows the join()\n-  \/\/ to complete once we've done the notify_all below. Needs a release() to obey Java Memory Model\n-  \/\/ requirements.\n-  OrderAccess::release();\n+  \/\/ Clear the native thread instance - this makes isAlive return false and\n+  \/\/ allows the join() to complete once we've done the notify_all() below.\n+  \/\/ Needs a release() to obey Java Memory Model requirements (which is done\n+  \/\/ in set_thread()).\n@@ -1659,1 +1659,0 @@\n-  java_lang_Thread::set_thread(thread_oop(), this);\n@@ -1675,0 +1674,3 @@\n+  \/\/ Publish the JavaThread* in java.lang.Thread after the JavaThread* is\n+  \/\/ on a ThreadsList.\n+  java_lang_Thread::set_thread(thread_oop(), this);\n@@ -2098,3 +2100,0 @@\n-\n-  java_lang_Thread::set_thread(thread_oop(), target); \/\/ isAlive == true now\n-\n@@ -2113,0 +2112,3 @@\n+  \/\/ Publish the JavaThread* in java.lang.Thread after the JavaThread* is\n+  \/\/ on a ThreadsList.\n+  java_lang_Thread::set_thread(thread_oop(), target); \/\/ isAlive == true now\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -820,2 +820,3 @@\n-    \/\/ The java.lang.Thread does not contain a JavaThread * so it has\n-    \/\/ not yet run or it has died.\n+    \/\/ The java.lang.Thread does not contain a JavaThread* so it has not\n+    \/\/ run enough to be put on a ThreadsList or it has exited enough to\n+    \/\/ make it past ensure_join() where the JavaThread* is cleared.\n@@ -827,4 +828,4 @@\n-    \/\/ jthread is not for the current JavaThread so have to verify\n-    \/\/ the JavaThread * against the ThreadsList.\n-    if (EnableThreadSMRExtraValidityChecks && !includes(java_thread)) {\n-      \/\/ Not on the JavaThreads list so it is not alive.\n+    \/\/ java_thread is not the current JavaThread so we have to verify it\n+    \/\/ against the ThreadsList:\n+    if (!includes(java_thread)) {\n+      \/\/ Not on this ThreadsList so it is not protected.\n@@ -841,0 +842,13 @@\n+FastThreadsListHandle::FastThreadsListHandle(oop thread_oop, JavaThread* java_thread) : _protected_java_thread(nullptr) {\n+  assert(thread_oop != nullptr, \"must be\");\n+  if (java_thread != nullptr) {\n+    \/\/ We captured a non-nullptr JavaThread* before the _tlh was created\n+    \/\/ so that covers the early life stage of the target JavaThread.\n+    _protected_java_thread = java_lang_Thread::thread(thread_oop);\n+    assert(_protected_java_thread == nullptr || _tlh.includes(_protected_java_thread), \"must be\");\n+    \/\/ If we captured a non-nullptr JavaThread* after the _tlh was created\n+    \/\/ then that covers the end life stage of the target JavaThread and we\n+    \/\/ we know that _tlh protects the JavaThread*.\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -336,0 +336,21 @@\n+\/\/ This stack allocated FastThreadsListHandle implements the special case\n+\/\/ where we want to quickly determine if a JavaThread* is protected by the\n+\/\/ embedded ThreadsListHandle.\n+\/\/\n+class FastThreadsListHandle : public StackObj {\n+  JavaThread* _protected_java_thread;\n+  ThreadsListHandle _tlh;\n+\n+public:\n+  \/\/ The 'java_thread' parameter to the constructor must be provided\n+  \/\/ by a java_lang_Thread::thread(thread_oop) call which gets us the\n+  \/\/ JavaThread* stored in the java.lang.Thread object _before_ the\n+  \/\/ embedded ThreadsListHandle is constructed.\n+  \/\/\n+  FastThreadsListHandle(oop thread_oop, JavaThread* java_thread);\n+\n+  JavaThread* protected_java_thread() {\n+    return _protected_java_thread;\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.hpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"}]}