{"files":[{"patch":"@@ -1573,0 +1573,4 @@\n+JavaThread* java_lang_Thread::thread_acquire(oop java_thread) {\n+  return reinterpret_cast<JavaThread*>(java_thread->address_field_acquire(_eetop_offset));\n+}\n+\n@@ -1577,0 +1581,4 @@\n+void java_lang_Thread::release_set_thread(oop java_thread, JavaThread* thread) {\n+  java_thread->release_address_field_put(_eetop_offset, (address)thread);\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -369,0 +369,1 @@\n+  static JavaThread* thread_acquire(oop java_thread);\n@@ -371,0 +372,1 @@\n+  static void release_set_thread(oop java_thread, JavaThread* thread);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -832,2 +832,0 @@\n-  \/\/ We do not check the EnableThreadSMRExtraValidityChecks option\n-  \/\/ for this includes() call because JVM\/TI's spec is tighter.\n@@ -875,2 +873,0 @@\n-  \/\/ We do not check the EnableThreadSMRExtraValidityChecks option\n-  \/\/ for this includes() call because JVM\/TI's spec is tighter.\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -786,12 +786,14 @@\n-    ThreadsListHandle tlh;\n-    JavaThread* thr = nullptr;\n-    oop java_thread = nullptr;\n-    (void) tlh.cv_internal_thread_to_JavaThread(jthread, &thr, &java_thread);\n-    if (java_thread != nullptr) {\n-      \/\/ This is a valid oop.\n-      if (thr != nullptr) {\n-        \/\/ The JavaThread is alive.\n-        Parker* p = thr->parker();\n-        HOTSPOT_THREAD_UNPARK((uintptr_t) p);\n-        p->unpark();\n-      }\n+    oop thread_oop = JNIHandles::resolve_non_null(jthread);\n+    \/\/ Get the JavaThread* stored in the java.lang.Thread object _before_\n+    \/\/ the embedded ThreadsListHandle is constructed so we know if the\n+    \/\/ early life stage of the JavaThread* is protected. We use acquire\n+    \/\/ here to ensure that if we see a non-nullptr value, then we also\n+    \/\/ see the main ThreadsList updates from the JavaThread* being added.\n+    FastThreadsListHandle ftlh(thread_oop, java_lang_Thread::thread_acquire(thread_oop));\n+    JavaThread* thr = ftlh.protected_java_thread();\n+    if (thr != nullptr) {\n+      \/\/ The still live JavaThread* is protected by the FastThreadsListHandle\n+      \/\/ so it is safe to access.\n+      Parker* p = thr->parker();\n+      HOTSPOT_THREAD_UNPARK((uintptr_t) p);\n+      p->unpark();\n@@ -799,2 +801,1 @@\n-  } \/\/ ThreadsListHandle is destroyed here.\n-\n+  } \/\/ FastThreadsListHandle is destroyed here.\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -956,3 +956,0 @@\n-  product(bool, EnableThreadSMRExtraValidityChecks, true, DIAGNOSTIC,       \\\n-             \"Enable Thread SMR extra validity checks\")                     \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -746,2 +746,1 @@\n-  OrderAccess::release();\n-  java_lang_Thread::set_thread(threadObj(), nullptr);\n+  java_lang_Thread::release_set_thread(threadObj(), nullptr);\n@@ -1671,1 +1670,0 @@\n-  java_lang_Thread::set_thread(thread_oop(), this);\n@@ -1687,0 +1685,5 @@\n+  \/\/ Publish the JavaThread* in java.lang.Thread after the JavaThread* is\n+  \/\/ on a ThreadsList. We don't want to wait for the release when the\n+  \/\/ Theads_lock is dropped somewhere in the caller since the JavaThread*\n+  \/\/ is already visible to JVM\/TI via the ThreadsList.\n+  java_lang_Thread::release_set_thread(thread_oop(), this);\n@@ -2124,3 +2127,0 @@\n-\n-  java_lang_Thread::set_thread(thread_oop(), target); \/\/ isAlive == true now\n-\n@@ -2139,0 +2139,5 @@\n+  \/\/ Publish the JavaThread* in java.lang.Thread after the JavaThread* is\n+  \/\/ on a ThreadsList. We don't want to wait for the release when the\n+  \/\/ Theads_lock is dropped when the 'mu' destructor is run since the\n+  \/\/ JavaThread* is already visible to JVM\/TI via the ThreadsList.\n+  java_lang_Thread::release_set_thread(thread_oop(), target); \/\/ isAlive == true now\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -818,1 +818,1 @@\n-  JavaThread *java_thread = java_lang_Thread::thread(thread_oop);\n+  JavaThread *java_thread = java_lang_Thread::thread_acquire(thread_oop);\n@@ -820,2 +820,3 @@\n-    \/\/ The java.lang.Thread does not contain a JavaThread * so it has\n-    \/\/ not yet run or it has died.\n+    \/\/ The java.lang.Thread does not contain a JavaThread* so it has not\n+    \/\/ run enough to be put on a ThreadsList or it has exited enough to\n+    \/\/ make it past ensure_join() where the JavaThread* is cleared.\n@@ -827,4 +828,4 @@\n-    \/\/ jthread is not for the current JavaThread so have to verify\n-    \/\/ the JavaThread * against the ThreadsList.\n-    if (EnableThreadSMRExtraValidityChecks && !includes(java_thread)) {\n-      \/\/ Not on the JavaThreads list so it is not alive.\n+    \/\/ java_thread is not the current JavaThread so we have to verify it\n+    \/\/ against the ThreadsList.\n+    if (!includes(java_thread)) {\n+      \/\/ Not on this ThreadsList so it is not protected.\n@@ -841,0 +842,14 @@\n+FastThreadsListHandle::FastThreadsListHandle(oop thread_oop, JavaThread* java_thread) : _protected_java_thread(nullptr) {\n+  assert(thread_oop != nullptr, \"must be\");\n+  if (java_thread != nullptr) {\n+    \/\/ We captured a non-nullptr JavaThread* before the _tlh was created\n+    \/\/ so that covers the early life stage of the target JavaThread.\n+    _protected_java_thread = java_lang_Thread::thread(thread_oop);\n+    assert(_protected_java_thread == nullptr || _tlh.includes(_protected_java_thread), \"must be\");\n+    \/\/ If we captured a non-nullptr JavaThread* after the _tlh was created\n+    \/\/ then that covers the end life stage of the target JavaThread and we\n+    \/\/ we know that _tlh protects the JavaThread*. The underlying atomic\n+    \/\/ load is sufficient (no acquire necessary here).\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -336,0 +336,23 @@\n+\/\/ This stack allocated FastThreadsListHandle implements the special case\n+\/\/ where we want to quickly determine if a JavaThread* is protected by the\n+\/\/ embedded ThreadsListHandle.\n+\/\/\n+class FastThreadsListHandle : public StackObj {\n+  JavaThread* _protected_java_thread;\n+  ThreadsListHandle _tlh;\n+\n+public:\n+  \/\/ The 'java_thread' parameter to the constructor must be provided\n+  \/\/ by a java_lang_Thread::thread_acquire(thread_oop) call which gets\n+  \/\/ us the JavaThread* stored in the java.lang.Thread object _before_\n+  \/\/ the embedded ThreadsListHandle is constructed. We use acquire there\n+  \/\/ to ensure that if we see a non-nullptr value, then we also see the\n+  \/\/ main ThreadsList updates from the JavaThread* being added.\n+  \/\/\n+  FastThreadsListHandle(oop thread_oop, JavaThread* java_thread);\n+\n+  JavaThread* protected_java_thread() {\n+    return _protected_java_thread;\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"}]}