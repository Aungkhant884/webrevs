{"files":[{"patch":"@@ -1570,0 +1570,4 @@\n+  return reinterpret_cast<JavaThread*>(java_thread->address_field(_eetop_offset));\n+}\n+\n+JavaThread* java_lang_Thread::thread_acquire(oop java_thread) {\n@@ -1574,0 +1578,4 @@\n+  java_thread->address_field_put(_eetop_offset, (address)thread);\n+}\n+\n+void java_lang_Thread::release_set_thread(oop java_thread, JavaThread* thread) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -369,0 +369,1 @@\n+  static JavaThread* thread_acquire(oop java_thread);\n@@ -371,0 +372,1 @@\n+  static void release_set_thread(oop java_thread, JavaThread* thread);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -790,1 +790,1 @@\n-    FastThreadsListHandle ftlh(thread_oop, java_lang_Thread::thread(thread_oop));\n+    FastThreadsListHandle ftlh(thread_oop, java_lang_Thread::thread_acquire(thread_oop));\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -741,5 +741,4 @@\n-  \/\/ Clear the native thread instance - this makes isAlive return false and\n-  \/\/ allows the join() to complete once we've done the notify_all() below.\n-  \/\/ Needs a release() to obey Java Memory Model requirements (which is done\n-  \/\/ in set_thread()).\n-  java_lang_Thread::set_thread(threadObj(), nullptr);\n+  \/\/ Clear the native thread instance - this makes isAlive return false and allows the join()\n+  \/\/ to complete once we've done the notify_all below. Needs a release() to obey Java Memory Model\n+  \/\/ requirements.\n+  java_lang_Thread::release_set_thread(threadObj(), nullptr);\n@@ -1675,2 +1674,3 @@\n-  \/\/ on a ThreadsList.\n-  java_lang_Thread::set_thread(thread_oop(), this);\n+  \/\/ on a ThreadsList. There will be a release when the Theads_lock is\n+  \/\/ dropped somewhere in the caller, but let's be more proactive.\n+  java_lang_Thread::release_set_thread(thread_oop(), this);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -818,1 +818,1 @@\n-  JavaThread *java_thread = java_lang_Thread::thread(thread_oop);\n+  JavaThread *java_thread = java_lang_Thread::thread_acquire(thread_oop);\n@@ -847,1 +847,1 @@\n-    _protected_java_thread = java_lang_Thread::thread(thread_oop);\n+    _protected_java_thread = java_lang_Thread::thread_acquire(thread_oop);\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -346,3 +346,3 @@\n-  \/\/ by a java_lang_Thread::thread(thread_oop) call which gets us the\n-  \/\/ JavaThread* stored in the java.lang.Thread object _before_ the\n-  \/\/ embedded ThreadsListHandle is constructed.\n+  \/\/ by a java_lang_Thread::thread_acquire(thread_oop) call which gets\n+  \/\/ us the JavaThread* stored in the java.lang.Thread object _before_\n+  \/\/ the embedded ThreadsListHandle is constructed.\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}