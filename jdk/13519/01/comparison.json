{"files":[{"patch":"@@ -811,2 +811,0 @@\n-  \/\/ We do not check the EnableThreadSMRExtraValidityChecks option\n-  \/\/ for this includes() call because JVM\/TI's spec is tighter.\n@@ -854,2 +852,0 @@\n-  \/\/ We do not check the EnableThreadSMRExtraValidityChecks option\n-  \/\/ for this includes() call because JVM\/TI's spec is tighter.\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -786,11 +786,16 @@\n-    ThreadsListHandle tlh;\n-    JavaThread* thr = nullptr;\n-    oop java_thread = nullptr;\n-    (void) tlh.cv_internal_thread_to_JavaThread(jthread, &thr, &java_thread);\n-    if (java_thread != nullptr) {\n-      \/\/ This is a valid oop.\n-      if (thr != nullptr) {\n-        \/\/ The JavaThread is alive.\n-        Parker* p = thr->parker();\n-        HOTSPOT_THREAD_UNPARK((uintptr_t) p);\n-        p->unpark();\n+    oop thread_oop = JNIHandles::resolve_non_null(jthread);\n+    if (java_lang_Thread::thread(thread_oop) != nullptr) {\n+      \/\/ Try to capture the live JavaThread in a ThreadsListHandle:\n+      ThreadsListHandle tlh; \/\/ Provides memory barrier\n+      if (java_lang_Thread::thread(thread_oop) != nullptr) {\n+        \/\/ The still live JavaThread is protected by the ThreadsListHandle.\n+        JavaThread* thr = nullptr;\n+        \/\/ We verified that java_lang_Thread::thread(thread_oop) != nullptr\n+        \/\/ before and after creating tlh above so quick_mode can be used in\n+        \/\/ this conversion call.\n+        if (tlh.cv_internal_thread_to_JavaThread(jthread, &thr, nullptr, true \/* quick_mode *\/)) {\n+          \/\/ The JavaThread is safe to access.\n+          Parker* p = thr->parker();\n+          HOTSPOT_THREAD_UNPARK((uintptr_t) p);\n+          p->unpark();\n+        }\n@@ -798,3 +803,2 @@\n-    }\n-  } \/\/ ThreadsListHandle is destroyed here.\n-\n+    } \/\/ ThreadsListHandle is destroyed here.\n+  }\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -952,3 +952,0 @@\n-  product(bool, EnableThreadSMRExtraValidityChecks, true, DIAGNOSTIC,       \\\n-             \"Enable Thread SMR extra validity checks\")                     \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1659,1 +1659,0 @@\n-  java_lang_Thread::set_thread(thread_oop(), this);\n@@ -1675,0 +1674,3 @@\n+  \/\/ Publish the JavaThread* in java.lang.Thread after the JavaThread* is\n+  \/\/ on a ThreadsList.\n+  java_lang_Thread::set_thread(thread_oop(), this);\n@@ -2098,3 +2100,0 @@\n-\n-  java_lang_Thread::set_thread(thread_oop(), target); \/\/ isAlive == true now\n-\n@@ -2113,0 +2112,3 @@\n+  \/\/ Publish the JavaThread* in java.lang.Thread after the JavaThread* is\n+  \/\/ on a ThreadsList.\n+  java_lang_Thread::set_thread(thread_oop(), target); \/\/ isAlive == true now\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -798,0 +798,4 @@\n+\/\/ If quick_mode is true, java_lang_Thread::thread(thread_oop) was verified\n+\/\/ in the caller to be a non-nullptr before and after the ThreadsListHandle\n+\/\/ was created so we can skip the ThreadsList search.\n+\/\/\n@@ -800,1 +804,2 @@\n-                                                         oop * thread_oop_p) {\n+                                                         oop * thread_oop_p,\n+                                                         bool quick_mode) {\n@@ -820,2 +825,3 @@\n-    \/\/ The java.lang.Thread does not contain a JavaThread * so it has\n-    \/\/ not yet run or it has died.\n+    \/\/ The java.lang.Thread does not contain a JavaThread* so it has not\n+    \/\/ run enough to be put on a ThreadsList or it has exited enough to\n+    \/\/ make it past ensure_join() where the JavaThread* is cleared.\n@@ -827,4 +833,9 @@\n-    \/\/ jthread is not for the current JavaThread so have to verify\n-    \/\/ the JavaThread * against the ThreadsList.\n-    if (EnableThreadSMRExtraValidityChecks && !includes(java_thread)) {\n-      \/\/ Not on the JavaThreads list so it is not alive.\n+    \/\/ java_thread is not the current JavaThread so we have to verify it\n+    \/\/ against the ThreadsList unless we're in quick_mode.\n+    \/\/\n+    \/\/ In quick_mode, java_lang_Thread::thread(thread_oop) was verified\n+    \/\/ in the caller to be a non-nullptr before and after creation of the\n+    \/\/ ThreadsListHandle so we can skip the ThreadsList search.\n+    \/\/\n+    if (!quick_mode && !includes(java_thread)) {\n+      \/\/ Not on this ThreadsList so it is not protected.\n@@ -835,0 +846,2 @@\n+  assert(includes(java_thread), \"must be\");\n+\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -61,0 +61,18 @@\n+\/\/ JNI jobject example with quick_mode enabled:\n+\/\/   jobject jthread = ...;\n+\/\/   :\n+\/\/   oop thread_oop = JNIHandles::resolve_non_null(jthread);\n+\/\/   if (java_lang_Thread::thread(thread_oop) != nullptr) {\n+\/\/     ThreadsListHandle tlh;\n+\/\/     if (java_lang_Thread::thread(thread_oop) != nullptr) {\n+\/\/       JavaThread* jt = nullptr;\n+\/\/       bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &jt, nullptr, true \/* quick_mode *\/);\n+\/\/       if (is_alive) {\n+\/\/         :  \/\/ do stuff with 'jt'...\n+\/\/       }\n+\/\/     }\n+\/\/   }\n+\/\/ Because java_lang_Thread::thread(thread_oop) is verified to be a\n+\/\/ non-nullptr before and after the ThreadsListHandle is created, we\n+\/\/ do not have to do the ThreadsList search in the conversion function.\n+\/\/\n@@ -321,1 +339,1 @@\n-  bool cv_internal_thread_to_JavaThread(jobject jthread, JavaThread ** jt_pp, oop * thread_oop_p);\n+  bool cv_internal_thread_to_JavaThread(jobject jthread, JavaThread ** jt_pp, oop * thread_oop_p, bool quick_mode = false);\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.hpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"}]}