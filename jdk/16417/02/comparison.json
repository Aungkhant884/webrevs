{"files":[{"patch":"@@ -4417,0 +4417,206 @@\n+#ifdef COMPILER2\n+\n+  \/\/ In sun.security.util.math.intpoly.IntegerPolynomial1305, integers\n+  \/\/ are represented as long[5], with BITS_PER_LIMB = 26.\n+  \/\/ Pack five 26-bit limbs into three 64-bit registers.\n+  void pack_26(Register dest0, Register dest1, Register dest2, Register src) {\n+    const Register t3 = x28;\n+    const Register t4 = x29;\n+    assert_different_registers(dest0, dest1, dest2, src, t3, t4);\n+\n+    \/\/ The goal is to have 128-bit value in dest2:dest1:dest0\n+    __ ld(dest0, Address(src, 0));    \/\/ 26 bits in dest0\n+\n+    __ ld(t3, Address(src, sizeof(jlong)));\n+    __ slli(t3, t3, 26);\n+    __ add(dest0, dest0, t3);       \/\/ 52 bits in dest0\n+\n+    __ ld(t4, Address(src, 2 * sizeof(jlong)));\n+    __ slli(t3, t4, 52);\n+    __ add(dest0, dest0, t3);       \/\/ dest0 is full\n+\n+    __ srli(dest1, t4, 12);         \/\/ 14-bit in dest1\n+\n+    __ ld(t3, Address(src, 3 * sizeof(jlong)));\n+    __ slli(t3, t3, 14);\n+    __ add(dest1, dest1, t3);       \/\/ 40-bit in dest1\n+\n+    __ ld(t3, Address(src, 4 * sizeof(jlong)));\n+    __ slli(t4, t3, 40);\n+    __ add(dest1, dest1, t4);       \/\/ dest1 is full\n+\n+    __ srli(t3, t3, 24);\n+    if (dest2->is_valid()) {\n+      __ add(dest2, zr, t3);        \/\/ 2 bits in dest2\n+    } else {\n+#ifdef ASSERT\n+      Label OK;\n+      __ beq(zr, t3, OK);           \/\/ 2 bits\n+      __ stop(\"high bits of Poly1305 integer should be zero\");\n+      __ should_not_reach_here();\n+      __ bind(OK);\n+#endif\n+    }\n+  }\n+\n+  \/\/ As above, but return only a 128-bit integer, packed into two\n+  \/\/ 64-bit registers.\n+  void pack_26(Register dest0, Register dest1, Register src) {\n+    pack_26(dest0, dest1, noreg, src);\n+  }\n+\n+  \/\/ Multiply and multiply-accumulate unsigned 64-bit registers.\n+  void wide_mul(Register prod_lo, Register prod_hi, Register n, Register m) {\n+    __ mul(prod_lo, n, m);\n+    __ mulhu(prod_hi, n, m);\n+  }\n+  void wide_madd(Register sum_lo, Register sum_hi, Register n,\n+                 Register m, Register tmp1, Register tmp2) {\n+    wide_mul(tmp1, tmp2, n, m);\n+    __ cad(sum_lo, sum_lo, tmp1, tmp1);  \/\/ Add tmp1 to sum_lo with carry output to tmp1\n+    __ adc(sum_hi, sum_hi, tmp2, tmp1);  \/\/ Add tmp2 with carry to sum_hi\n+  }\n+\n+  \/\/ Poly1305, RFC 7539\n+\n+  \/\/ See https:\/\/loup-vaillant.fr\/tutorials\/poly1305-design for a\n+  \/\/ description of the tricks used to simplify and accelerate this\n+  \/\/ computation.\n+\n+  address generate_poly1305_processBlocks() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"poly1305_processBlocks\");\n+    address start = __ pc();\n+    Label here;\n+\n+    RegSet saved_regs = RegSet::range(x18, x25);\n+    __ push_reg(saved_regs, sp);\n+\n+    RegSetIterator<Register> regs = RegSet::range(x10, x31).begin();\n+\n+    \/\/ Arguments\n+    const Register input_start = *regs, length = *++regs, acc_start = *++regs, r_start = *++regs;\n+\n+    \/\/ R_n is the 128-bit randomly-generated key, packed into two\n+    \/\/ registers. The caller passes this key to us as long[5], with\n+    \/\/ BITS_PER_LIMB = 26.\n+    const Register R_0 = *++regs, R_1 = *++regs;\n+    pack_26(R_0, R_1, r_start);\n+\n+    const Register tmp1 = t0;\n+    const Register tmp2 = t1;\n+    const Register tmp3 = t2;\n+\n+    \/\/ RR_n is (R_n >> 2) * 5\n+    const Register RR_0 = *++regs, RR_1 = *++regs;\n+    __ srli(tmp1, R_0, 2);\n+    __ shadd(RR_0, tmp1, tmp1, tmp2, 2);\n+    __ srli(tmp1, R_1, 2);\n+    __ shadd(RR_1, tmp1, tmp1, tmp2, 2);\n+\n+    \/\/ U_n is the current checksum\n+    const Register U_0 = *++regs, U_1 = *++regs, U_2 = *++regs;\n+    pack_26(U_0, U_1, U_2, acc_start);\n+\n+    static constexpr int BLOCK_LENGTH = 16;\n+    Label DONE, LOOP;\n+\n+    __ addi(tmp1, zr, checked_cast<u1>(BLOCK_LENGTH));\n+    __ blt(length, tmp1, DONE); {\n+      __ bind(LOOP);\n+\n+      \/\/ S_n is to be the sum of U_n and the next block of data\n+      const Register S_0 = *++regs, S_1 = *++regs, S_2 = *++regs;\n+      __ ld(S_0, Address(input_start, 0));\n+      __ ld(S_1, Address(input_start, wordSize));\n+\n+      __ cad(S_0, S_0, U_0, tmp1); \/\/ Add U_0 to S_0 with carry output to tmp1\n+      __ cadc(S_1, S_1, U_1, tmp1); \/\/ Add U_1 with carry to S_1 with carry output to tmp1\n+      __ adc(S_2, zr, U_2, tmp1);\n+\n+      __ addi(S_2, S_2, 1);\n+\n+      const Register U_0HI = *++regs, U_1HI = *++regs;\n+\n+      \/\/ NB: this logic depends on some of the special properties of\n+      \/\/ Poly1305 keys. In particular, because we know that the top\n+      \/\/ four bits of R_0 and R_1 are zero, we can add together\n+      \/\/ partial products without any risk of needing to propagate a\n+      \/\/ carry out.\n+      wide_mul(U_0, U_0HI, S_0, R_0);  wide_madd(U_0, U_0HI, S_1, RR_1, tmp1, tmp2); wide_madd(U_0, U_0HI, S_2, RR_0, tmp1, tmp2);\n+      wide_mul(U_1, U_1HI, S_0, R_1);  wide_madd(U_1, U_1HI, S_1, R_0, tmp1, tmp2);  wide_madd(U_1, U_1HI, S_2, RR_1, tmp1, tmp2);\n+      __ andi(U_2, R_0, 3);\n+      __ mul(U_2, S_2, U_2);\n+\n+      \/\/ Recycle registers S_0, S_1, S_2\n+      regs = (regs.remaining() + S_0 + S_1 + S_2).begin();\n+\n+      \/\/ Partial reduction mod 2**130 - 5\n+      __ cad(U_1, U_1, U_0HI, tmp1); \/\/ Add U_0HI to U_1 with carry output to tmp1\n+      __ adc(U_2, U_2, U_1HI, tmp1);\n+      \/\/ Sum now in U_2:U_1:U_0.\n+      \/\/ Dead: U_0HI, U_1HI.\n+      regs = (regs.remaining() + U_0HI + U_1HI).begin();\n+\n+      \/\/ U_2:U_1:U_0: += (U_2 >> 2) * 5\n+      __ srli(tmp1, U_2, 2);\n+      const int64_t bits2 = right_n_bits(2);\n+      __ andi(U_2, U_2, bits2); \/\/ Clear U_2 except for the first two bits\n+      __ shadd(tmp1, tmp1, tmp1, tmp2, 2); \/\/ tmp1 is impossible to overflow since two leftmost bits are zero'ed in 'srli(tmp1, U_2, 2)'\n+      __ cad(U_0, U_0, tmp1, tmp3); \/\/ Add tmp1 (= (U_2 >> 2) * 5) to U_0 with carry output to tmp3\n+      __ cadc(U_1, U_1, zr, tmp3); \/\/ Add carry to U_1 with carry output to tmp3\n+      __ add(U_2, U_2, tmp3);\n+\n+      __ sub(length, length, checked_cast<u1>(BLOCK_LENGTH));\n+      __ addi(input_start, input_start, 2 * wordSize);\n+      __ addi(tmp1, zr, checked_cast<u1>(BLOCK_LENGTH));\n+      __ bge(length, tmp1, LOOP);\n+    }\n+\n+    \/\/ Further reduce modulo 2^130 - 5\n+    __ srli(tmp1, U_2, 2);\n+    __ shadd(tmp1, tmp1, tmp1, tmp2, 2); \/\/ tmp1 = U_2 * 5\n+    __ cad(U_0, U_0, tmp1, tmp3); \/\/ U_0 += U_2 * 5 with carry output to tmp3\n+    __ cadc(U_1, U_1, zr, tmp3); \/\/ Add carry to U_1 with carry output to tmp3\n+    __ andi(U_2, U_2, 3);\n+    __ add(U_2, U_2, tmp3); \/\/ Add carry to U_2\n+\n+    \/\/ Unpack the sum into five 26-bit limbs and write to memory.\n+    const int64_t bits26 = right_n_bits(26);\n+    \/\/ First 26 bits is the first limb\n+    __ andi(tmp1, U_0, bits26); \/\/ Take lowest 26 bits\n+    __ sd(tmp1, Address(acc_start)); \/\/ First 26-bit limb\n+\n+    \/\/ 27-52 bits of U_0 is the second limb\n+    __ srli(tmp2, U_0, 26);\n+    __ andi(tmp2, tmp2, bits26); \/\/ Take next 27-52 bits\n+    __ sd(tmp2, Address(acc_start, sizeof (jlong))); \/\/ Second 26-bit limb\n+\n+    \/\/ Getting 53-64 bits of U_0 and 1-14 bits of U_1 in one register\n+    __ srli(tmp1, U_0, 52);\n+    __ slli(tmp2, U_1, 12);\n+    __ addw(tmp1, tmp1, tmp2);\n+    __ andi(tmp3, tmp1, bits26, tmp2); \/\/ Take remaining bits of tmp1\n+    __ sd(tmp3, Address(acc_start, 2 * sizeof (jlong))); \/\/ Third 26-bit limb\n+\n+    \/\/ Storing 15-40 bits of U_1\n+    __ srli(tmp3, U_1, 14); \/\/ Already used up 14 bits\n+    __ andi(tmp1, tmp3, bits26); \/\/ Clear all other bits from tmp3\n+    __ sd(tmp1, Address(acc_start, 3 * sizeof (jlong))); \/\/ Fourth 26-bit limb\n+\n+    \/\/ Storing 41-64 bits of U_1 and first two bits from U_2 in one register\n+    __ srli(tmp1, U_1, 40);\n+    __ andi(tmp2, U_2, 3); \/\/ Clear all bits in U_2 except for first 2\n+    __ slli(tmp2, tmp2, 24);\n+    __ addw(tmp1, tmp1, tmp2);\n+    __ sd(tmp1, Address(acc_start, 4 * sizeof (jlong))); \/\/ Fifth 26-bit limb\n+\n+    __ bind(DONE);\n+    __ pop_reg(saved_regs, sp);\n+    __ ret();\n+\n+    return start;\n+  }\n+\n+#endif \/\/ COMPILER2\n+\n@@ -4638,0 +4844,4 @@\n+    if (UsePoly1305Intrinsics) {\n+      StubRoutines::_poly1305_processBlocks = generate_poly1305_processBlocks();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":210,"deletions":0,"binary":false,"changes":210,"status":"modified"},{"patch":"@@ -194,0 +194,4 @@\n+  if (FLAG_IS_DEFAULT(UsePoly1305Intrinsics)) {\n+    FLAG_SET_DEFAULT(UsePoly1305Intrinsics, true);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}