{"files":[{"patch":"@@ -2211,1 +2211,1 @@\n-  \/\/ Modern Linux kernels (after 2.6.23 2007) support O_CLOEXEC with open().\n+\n@@ -2214,7 +2214,2 @@\n-  \/\/ is unset.  On ancient Linux kernels the O_CLOEXEC flag will be ignored\n-  \/\/ and we fall back to using FD_CLOEXEC (see below).\n-#ifdef O_CLOEXEC\n-  oflag |= O_CLOEXEC;\n-#endif\n-\n-  int fd = ::open(path, oflag, mode);\n+  \/\/ is unset.\n+  int fd = ::open(path, oflag|O_CLOEXEC, mode);\n@@ -2241,15 +2236,0 @@\n-#ifdef FD_CLOEXEC\n-  \/\/ Validate that the use of the O_CLOEXEC flag on open above worked.\n-  \/\/ With recent kernels, we will perform this check exactly once.\n-  static sig_atomic_t O_CLOEXEC_is_known_to_work = 0;\n-  if (!O_CLOEXEC_is_known_to_work) {\n-    int flags = ::fcntl(fd, F_GETFD);\n-    if (flags != -1) {\n-      if ((flags & FD_CLOEXEC) != 0)\n-        O_CLOEXEC_is_known_to_work = 1;\n-      else\n-        ::fcntl(fd, F_SETFD, flags | FD_CLOEXEC);\n-    }\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":3,"deletions":23,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -890,0 +890,10 @@\n+\n+TEST_VM(os, open_O_CLOEXEC) {\n+#if defined(__APPLE__)\n+  int fd = os::open(\"gtest.cmdline\", 0, O_RDONLY); \/\/ open will use O_CLOEXEC\n+  EXPECT_TRUE(fd > 0);\n+  int flags = ::fcntl(fd, F_GETFD);\n+  EXPECT_TRUE((flags & FD_CLOEXEC) != 0); \/\/ if O_CLOEXEC worked, then FD_CLOEXEC should be ON\n+  ::close(fd);\n+#endif\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}