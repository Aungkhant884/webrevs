{"files":[{"patch":"@@ -49,15 +49,26 @@\n-    @Test(dataProvider = \"slices\")\n-    public void testByteCopy(SegmentSlice s1, SegmentSlice s2) {\n-        int size = Math.min(s1.byteSize(), s2.byteSize());\n-        \/\/prepare source and target segments\n-        for (int i = 0 ; i < size ; i++) {\n-            Type.BYTE.set(s2, i, 0);\n-        }\n-        for (int i = 0 ; i < size ; i++) {\n-            Type.BYTE.set(s1, i, i);\n-        }\n-        \/\/perform copy\n-        MemorySegment.copy(s1.segment, 0, s2.segment, 0, size);\n-        \/\/check that copy actually worked\n-        for (int i = 0 ; i < size ; i++) {\n-            Type.BYTE.check(s2, i, i);\n+    static final int TEST_BYTE_SIZE = 16;\n+\n+    @Test(dataProvider = \"segmentKinds\")\n+    public void testByteCopy(SegmentKind kind1, SegmentKind kind2) {\n+        MemorySegment s1 = kind1.makeSegment(TEST_BYTE_SIZE);\n+        MemorySegment s2 = kind2.makeSegment(TEST_BYTE_SIZE);\n+\n+        \/\/ for all offsets\n+        for (int s1Offset = 0; s1Offset < s1.byteSize(); s1Offset++) {\n+            for (int s2Offset = 0; s2Offset < s2.byteSize(); s2Offset++) {\n+                long slice1ByteSize = s1.byteSize() - s1Offset;\n+                long slice2ByteSize = s2.byteSize() - s2Offset;\n+\n+                long copySize = Math.min(slice1ByteSize, slice2ByteSize);\n+\n+                \/\/prepare source slice\n+                for (int i = 0 ; i < copySize; i++) {\n+                    Type.BYTE.set(s1, s1Offset, i, i);\n+                }\n+                \/\/perform copy\n+                MemorySegment.copy(s1, Type.BYTE.layout, s1Offset, s2, Type.BYTE.layout, s2Offset, copySize);\n+                \/\/check that copy actually worked\n+                for (int i = 0; i < copySize; i++) {\n+                    Type.BYTE.check(s2, s2Offset, i, i);\n+                }\n+            }\n@@ -67,16 +78,27 @@\n-    @Test(dataProvider = \"slices\")\n-    public void testElementCopy(SegmentSlice s1, SegmentSlice s2) {\n-        if (s1.type.carrier != s2.type.carrier) return;\n-        int size = Math.min(s1.elementSize(), s2.elementSize());\n-        \/\/prepare source and target segments\n-        for (int i = 0 ; i < size ; i++) {\n-            s2.set(i, 0);\n-        }\n-        for (int i = 0 ; i < size ; i++) {\n-            s1.set(i, i);\n-        }\n-        \/\/perform copy\n-        MemorySegment.copy(s1.segment, s1.type.layout, 0, s2.segment, s2.type.layout, 0, size);\n-        \/\/check that copy actually worked\n-        for (int i = 0; i < size; i++) {\n-            s2.check(i, i);\n+    @Test(dataProvider = \"segmentKindsAndTypes\")\n+    public void testElementCopy(SegmentKind kind1, SegmentKind kind2, Type type1, Type type2) {\n+        MemorySegment s1 = kind1.makeSegment(TEST_BYTE_SIZE);\n+        MemorySegment s2 = kind2.makeSegment(TEST_BYTE_SIZE);\n+\n+        \/\/ for all offsets\n+        for (int s1Offset = 0; s1Offset < s1.byteSize(); s1Offset++) {\n+            for (int s2Offset = 0; s2Offset < s2.byteSize(); s2Offset++) {\n+                long slice1ByteSize = s1.byteSize() - s1Offset;\n+                long slice2ByteSize = s2.byteSize() - s2Offset;\n+\n+                long slice1ElementSize = slice1ByteSize \/ type1.size();\n+                long slice2ElementSize = slice2ByteSize \/ type2.size();\n+\n+                long copySize = Math.min(slice1ElementSize, slice2ElementSize);\n+\n+                \/\/prepare source slice\n+                for (int i = 0 ; i < copySize; i++) {\n+                    type1.set(s1, s1Offset, i, i);\n+                }\n+                \/\/perform copy\n+                MemorySegment.copy(s1, type1.layout, s1Offset, s2, type2.layout, s2Offset, copySize);\n+                \/\/check that copy actually worked\n+                for (int i = 0; i < copySize; i++) {\n+                    type2.check(s2, s2Offset, i, i);\n+                }\n+            }\n@@ -102,6 +124,6 @@\n-        SHORT_LE(short.class, ValueLayout.JAVA_SHORT.withBitAlignment(8).withOrder(ByteOrder.LITTLE_ENDIAN), i -> (short)i),\n-        CHAR_LE(char.class, ValueLayout.JAVA_CHAR.withBitAlignment(8).withOrder(ByteOrder.LITTLE_ENDIAN), i -> (char)i),\n-        INT_LE(int.class, ValueLayout.JAVA_INT.withBitAlignment(8).withOrder(ByteOrder.LITTLE_ENDIAN), i -> i),\n-        FLOAT_LE(float.class, ValueLayout.JAVA_FLOAT.withBitAlignment(8).withOrder(ByteOrder.LITTLE_ENDIAN), i -> (float)i),\n-        LONG_LE(long.class, ValueLayout.JAVA_LONG.withBitAlignment(8).withOrder(ByteOrder.LITTLE_ENDIAN), i -> (long)i),\n-        DOUBLE_LE(double.class, ValueLayout.JAVA_DOUBLE.withBitAlignment(8).withOrder(ByteOrder.LITTLE_ENDIAN), i -> (double)i),\n+        SHORT_LE(short.class, ValueLayout.JAVA_SHORT_UNALIGNED.withOrder(ByteOrder.LITTLE_ENDIAN), i -> (short)i),\n+        CHAR_LE(char.class, ValueLayout.JAVA_CHAR_UNALIGNED.withOrder(ByteOrder.LITTLE_ENDIAN), i -> (char)i),\n+        INT_LE(int.class, ValueLayout.JAVA_INT_UNALIGNED.withOrder(ByteOrder.LITTLE_ENDIAN), i -> i),\n+        FLOAT_LE(float.class, ValueLayout.JAVA_FLOAT_UNALIGNED.withOrder(ByteOrder.LITTLE_ENDIAN), i -> (float)i),\n+        LONG_LE(long.class, ValueLayout.JAVA_LONG_UNALIGNED.withOrder(ByteOrder.LITTLE_ENDIAN), i -> (long)i),\n+        DOUBLE_LE(double.class, ValueLayout.JAVA_DOUBLE_UNALIGNED.withOrder(ByteOrder.LITTLE_ENDIAN), i -> (double)i),\n@@ -109,6 +131,6 @@\n-        SHORT_BE(short.class, ValueLayout.JAVA_SHORT.withBitAlignment(8).withOrder(ByteOrder.BIG_ENDIAN), i -> (short)i),\n-        CHAR_BE(char.class, ValueLayout.JAVA_CHAR.withBitAlignment(8).withOrder(ByteOrder.BIG_ENDIAN), i -> (char)i),\n-        INT_BE(int.class, ValueLayout.JAVA_INT.withBitAlignment(8).withOrder(ByteOrder.BIG_ENDIAN), i -> i),\n-        FLOAT_BE(float.class, ValueLayout.JAVA_FLOAT.withBitAlignment(8).withOrder(ByteOrder.BIG_ENDIAN), i -> (float)i),\n-        LONG_BE(long.class, ValueLayout.JAVA_LONG.withBitAlignment(8).withOrder(ByteOrder.BIG_ENDIAN), i -> (long)i),\n-        DOUBLE_BE(double.class, ValueLayout.JAVA_DOUBLE.withBitAlignment(8).withOrder(ByteOrder.BIG_ENDIAN), i -> (double)i);\n+        SHORT_BE(short.class, ValueLayout.JAVA_SHORT_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN), i -> (short)i),\n+        CHAR_BE(char.class, ValueLayout.JAVA_CHAR_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN), i -> (char)i),\n+        INT_BE(int.class, ValueLayout.JAVA_INT_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN), i -> i),\n+        FLOAT_BE(float.class, ValueLayout.JAVA_FLOAT_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN), i -> (float)i),\n+        LONG_BE(long.class, ValueLayout.JAVA_LONG_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN), i -> (long)i),\n+        DOUBLE_BE(double.class, ValueLayout.JAVA_DOUBLE_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN), i -> (double)i);\n@@ -127,2 +149,2 @@\n-        int size() {\n-            return (int)layout.byteSize();\n+        long size() {\n+            return layout.byteSize();\n@@ -135,2 +157,2 @@\n-        void set(SegmentSlice slice, int index, int val) {\n-            handle().set(slice.segment, index * size(), valueConverter.apply(val));\n+        void set(MemorySegment segment, long offset, int index, int val) {\n+            handle().set(segment, offset + (index * size()), valueConverter.apply(val));\n@@ -139,2 +161,2 @@\n-        void check(SegmentSlice slice, int index, int val) {\n-            assertEquals(handle().get(slice.segment, index * size()), valueConverter.apply(val));\n+        void check(MemorySegment segment, long offset, int index, int val) {\n+            assertEquals(handle().get(segment, offset + (index * size())), valueConverter.apply(val));\n@@ -144,11 +166,3 @@\n-    static class SegmentSlice {\n-\n-        enum Kind {\n-            NATIVE(i -> Arena.ofAuto().allocate(i, 1)),\n-            ARRAY(i -> MemorySegment.ofArray(new byte[i]));\n-\n-            final IntFunction<MemorySegment> segmentFactory;\n-\n-            Kind(IntFunction<MemorySegment> segmentFactory) {\n-                this.segmentFactory = segmentFactory;\n-            }\n+    enum SegmentKind {\n+        NATIVE(i -> Arena.ofAuto().allocate(i, 1)),\n+        ARRAY(i -> MemorySegment.ofArray(new byte[i]));\n@@ -156,18 +170,1 @@\n-            MemorySegment makeSegment(int elems) {\n-                return segmentFactory.apply(elems);\n-            }\n-        }\n-\n-        final Kind kind;\n-        final Type type;\n-        final int first;\n-        final int last;\n-        final MemorySegment segment;\n-\n-        public SegmentSlice(Kind kind, Type type, int first, int last, MemorySegment segment) {\n-            this.kind = kind;\n-            this.type = type;\n-            this.first = first;\n-            this.last = last;\n-            this.segment = segment;\n-        }\n+        final IntFunction<MemorySegment> segmentFactory;\n@@ -175,2 +172,2 @@\n-        void set(int index, int val) {\n-            type.set(this, index, val);\n+        SegmentKind(IntFunction<MemorySegment> segmentFactory) {\n+            this.segmentFactory = segmentFactory;\n@@ -179,10 +176,2 @@\n-        void check(int index, int val) {\n-            type.check(this, index, val);\n-        }\n-\n-        int byteSize() {\n-            return last - first + 1;\n-        }\n-\n-        int elementSize() {\n-            return byteSize() \/ type.size();\n+        MemorySegment makeSegment(int size) {\n+            return segmentFactory.apply(size);\n@@ -190,0 +179,1 @@\n+    }\n@@ -191,3 +181,7 @@\n-        @Override\n-        public String toString() {\n-            return String.format(\"SegmentSlice{%s, %d, %d}\", type, first, last);\n+    @DataProvider\n+    static Object[][] segmentKinds() {\n+        List<Object[]> cases = new ArrayList<>();\n+        for (SegmentKind kind1 : SegmentKind.values()) {\n+            for (SegmentKind kind2 : SegmentKind.values()) {\n+                cases.add(new Object[] {kind1, kind2});\n+            }\n@@ -195,0 +189,1 @@\n+        return cases.toArray(Object[][]::new);\n@@ -197,12 +192,9 @@\n-    @DataProvider(name = \"slices\")\n-    static Object[][] elementSlices() {\n-        List<SegmentSlice> slices = new ArrayList<>();\n-        for (SegmentSlice.Kind kind : SegmentSlice.Kind.values()) {\n-            MemorySegment segment = kind.makeSegment(16);\n-            \/\/compute all slices\n-            for (Type type : Type.values()) {\n-                for (int index = 0; index < 16; index += type.size()) {\n-                    MemorySegment first = segment.asSlice(0, index);\n-                    slices.add(new SegmentSlice(kind, type, 0, index - 1, first));\n-                    MemorySegment second = segment.asSlice(index);\n-                    slices.add(new SegmentSlice(kind, type, index, 15, second));\n+    @DataProvider\n+    static Object[][] segmentKindsAndTypes() {\n+        List<Object[]> cases = new ArrayList<>();\n+        for (Object[] segmentKinds : segmentKinds()) {\n+            for (Type type1 : Type.values()) {\n+                for (Type type2 : Type.values()) {\n+                    if (type1.layout.carrier() == type2.layout.carrier()) {\n+                        cases.add(new Object[]{segmentKinds[0], segmentKinds[1], type1, type2});\n+                    }\n@@ -212,7 +204,1 @@\n-        Object[][] sliceArray = new Object[slices.size() * slices.size()][];\n-        for (int i = 0 ; i < slices.size() ; i++) {\n-            for (int j = 0 ; j < slices.size() ; j++) {\n-                sliceArray[i * slices.size() + j] = new Object[] { slices.get(i), slices.get(j) };\n-            }\n-        }\n-        return sliceArray;\n+        return cases.toArray(Object[][]::new);\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":98,"deletions":112,"binary":false,"changes":210,"status":"modified"}]}