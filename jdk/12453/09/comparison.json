{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -3537,0 +3538,3 @@\n+        if (newLength == original.length) {\n+            return copyOf(original);\n+        }\n@@ -3543,0 +3547,7 @@\n+    @ForceInline\n+    private static byte[] copyOf(byte[] original) {\n+        byte[] copy = new byte[original.length];\n+        System.arraycopy(original, 0, copy, 0, original.length);\n+        return copy;\n+    }\n+\n@@ -3561,0 +3572,3 @@\n+        if (newLength == original.length) {\n+            return copyOf(original);\n+        }\n@@ -3567,0 +3581,7 @@\n+    @ForceInline\n+    private static short[] copyOf(short[] original) {\n+        short[] copy = new short[original.length];\n+        System.arraycopy(original, 0, copy, 0, original.length);\n+        return copy;\n+    }\n+\n@@ -3585,0 +3606,3 @@\n+        if (newLength == original.length) {\n+            return copyOf(original);\n+        }\n@@ -3591,0 +3615,7 @@\n+    @ForceInline\n+    private static int[] copyOf(int[] original) {\n+        int[] copy = new int[original.length];\n+        System.arraycopy(original, 0, copy, 0, original.length);\n+        return copy;\n+    }\n+\n@@ -3609,0 +3640,3 @@\n+        if (newLength == original.length) {\n+            return copyOf(original);\n+        }\n@@ -3615,0 +3649,7 @@\n+    @ForceInline\n+    private static long[] copyOf(long[] original) {\n+        long[] copy = new long[original.length];\n+        System.arraycopy(original, 0, copy, 0, original.length);\n+        return copy;\n+    }\n+\n@@ -3633,0 +3674,3 @@\n+        if (newLength == original.length) {\n+            return copyOf(original);\n+        }\n@@ -3639,0 +3683,7 @@\n+    @ForceInline\n+    private static char[] copyOf(char[] original) {\n+        char[] copy = new char[original.length];\n+        System.arraycopy(original, 0, copy, 0, original.length);\n+        return copy;\n+    }\n+\n@@ -3657,0 +3708,3 @@\n+        if (newLength == original.length) {\n+            return copyOf(original);\n+        }\n@@ -3663,0 +3717,7 @@\n+    @ForceInline\n+    private static float[] copyOf(float[] original) {\n+        float[] copy = new float[original.length];\n+        System.arraycopy(original, 0, copy, 0, original.length);\n+        return copy;\n+    }\n+\n@@ -3681,0 +3742,3 @@\n+        if (newLength == original.length) {\n+            return copyOf(original);\n+        }\n@@ -3687,0 +3751,7 @@\n+    @ForceInline\n+    private static double[] copyOf(double[] original) {\n+        double[] copy = new double[original.length];\n+        System.arraycopy(original, 0, copy, 0, original.length);\n+        return copy;\n+    }\n+\n@@ -3705,0 +3776,3 @@\n+        if (newLength == original.length) {\n+            return copyOf(original);\n+        }\n@@ -3711,0 +3785,7 @@\n+    @ForceInline\n+    private static boolean[] copyOf(boolean[] original) {\n+        boolean[] copy = new boolean[original.length];\n+        System.arraycopy(original, 0, copy, 0, original.length);\n+        return copy;\n+    }\n+\n@@ -3792,0 +3873,7 @@\n+    @ForceInline\n+    private static void checkLength(int from, int to) {\n+        if (to < from) {\n+            throw new IllegalArgumentException(from + \" > \" + to);\n+        }\n+    }\n+\n@@ -3819,0 +3907,10 @@\n+        \/\/ Tickle the JIT to fold special cases optimally\n+        if (from != 0 || to != original.length)\n+            return copyOfRangeByte(original, from, to);\n+        else \/\/ from == 0 && to == original.length\n+            return copyOf(original);\n+    }\n+\n+    @ForceInline\n+    private static byte[] copyOfRangeByte(byte[] original, int from, int to) {\n+        checkLength(from, to);\n@@ -3820,2 +3918,0 @@\n-        if (newLength < 0)\n-            throw new IllegalArgumentException(from + \" > \" + to);\n@@ -3855,0 +3951,10 @@\n+        \/\/ Tickle the JIT to fold special cases optimally\n+        if (from != 0 || to != original.length)\n+            return copyOfRangeShort(original, from, to);\n+        else \/\/ from == 0 && to == original.length\n+            return copyOf(original);\n+    }\n+\n+    @ForceInline\n+    private static short[] copyOfRangeShort(short[] original, int from, int to) {\n+        checkLength(from, to);\n@@ -3856,2 +3962,0 @@\n-        if (newLength < 0)\n-            throw new IllegalArgumentException(from + \" > \" + to);\n@@ -3891,0 +3995,10 @@\n+        \/\/ Tickle the JIT to fold special cases optimally\n+        if (from != 0 || to != original.length)\n+            return copyOfRangeInt(original, from, to);\n+        else \/\/ from == 0 && to == original.length\n+            return copyOf(original);\n+    }\n+\n+    @ForceInline\n+    private static int[] copyOfRangeInt(int[] original, int from, int to) {\n+        checkLength(from, to);\n@@ -3892,2 +4006,0 @@\n-        if (newLength < 0)\n-            throw new IllegalArgumentException(from + \" > \" + to);\n@@ -3927,0 +4039,10 @@\n+        \/\/ Tickle the JIT to fold special cases optimally\n+        if (from != 0 || to != original.length)\n+            return copyOfRangeLong(original, from, to);\n+        else \/\/ from == 0 && to == original.length\n+            return copyOf(original);\n+    }\n+\n+    @ForceInline\n+    private static long[] copyOfRangeLong(long[] original, int from, int to) {\n+        checkLength(from, to);\n@@ -3928,2 +4050,0 @@\n-        if (newLength < 0)\n-            throw new IllegalArgumentException(from + \" > \" + to);\n@@ -3963,0 +4083,10 @@\n+        \/\/ Tickle the JIT to fold special cases optimally\n+        if (from != 0 || to != original.length)\n+            return copyOfRangeChar(original, from, to);\n+        else \/\/ from == 0 && to == original.length\n+            return copyOf(original);\n+    }\n+\n+    @ForceInline\n+    private static char[] copyOfRangeChar(char[] original, int from, int to) {\n+        checkLength(from, to);\n@@ -3964,2 +4094,0 @@\n-        if (newLength < 0)\n-            throw new IllegalArgumentException(from + \" > \" + to);\n@@ -3999,0 +4127,10 @@\n+        \/\/ Tickle the JIT to fold special cases optimally\n+        if (from != 0 || to != original.length)\n+            return copyOfRangeFloat(original, from, to);\n+        else \/\/ from == 0 && to == original.length\n+            return copyOf(original);\n+    }\n+\n+    @ForceInline\n+    private static float[] copyOfRangeFloat(float[] original, int from, int to) {\n+        checkLength(from, to);\n@@ -4000,2 +4138,0 @@\n-        if (newLength < 0)\n-            throw new IllegalArgumentException(from + \" > \" + to);\n@@ -4035,0 +4171,10 @@\n+        \/\/ Tickle the JIT to fold special cases optimally\n+        if (from != 0 || to != original.length)\n+            return copyOfRangeDouble(original, from, to);\n+        else \/\/ from == 0 && to == original.length\n+            return copyOf(original);\n+    }\n+\n+    @ForceInline\n+    private static double[] copyOfRangeDouble(double[] original, int from, int to) {\n+        checkLength(from, to);\n@@ -4036,2 +4182,0 @@\n-        if (newLength < 0)\n-            throw new IllegalArgumentException(from + \" > \" + to);\n@@ -4071,0 +4215,10 @@\n+        \/\/ Tickle the JIT to fold special cases optimally\n+        if (from != 0 || to != original.length)\n+            return copyOfRangeBoolean(original, from, to);\n+        else \/\/ from == 0 && to == original.length\n+            return copyOf(original);\n+    }\n+\n+    @ForceInline\n+    private static boolean[] copyOfRangeBoolean(boolean[] original, int from, int to) {\n+        checkLength(from, to);\n@@ -4072,2 +4226,0 @@\n-        if (newLength < 0)\n-            throw new IllegalArgumentException(from + \" > \" + to);\n","filename":"src\/java.base\/share\/classes\/java\/util\/Arrays.java","additions":168,"deletions":16,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-@Fork(5)\n@@ -35,2 +34,3 @@\n-@Warmup(iterations = 5, time = 5)\n-@Measurement(iterations = 10, time = 5)\n+@Warmup(iterations = 5, time = 3)\n+@Measurement(iterations = 5, time = 3)\n+@Fork(3)\n@@ -38,0 +38,7 @@\n+\n+  @Param({\"7\", \"64\"})\n+  public int size;\n+\n+  \/\/ Offset to use for ranged newStrings\n+  @Param(\"1\")\n+  public int offset;\n@@ -42,1 +49,4 @@\n-    array = \"\".getBytes(StandardCharsets.UTF_8);\n+      if (offset > size) {\n+        offset = size;\n+      }\n+      array = \"a\".repeat(size).getBytes(StandardCharsets.UTF_8);\n@@ -47,1 +57,1 @@\n-    return new String(array);\n+      return new String(array);\n@@ -52,1 +62,1 @@\n-    return new String(array, StandardCharsets.UTF_8);\n+      return new String(array, StandardCharsets.UTF_8);\n@@ -57,1 +67,1 @@\n-    return new String(array, StandardCharsets.UTF_8.name());\n+      return new String(array, StandardCharsets.UTF_8.name());\n@@ -62,1 +72,1 @@\n-    return new String(array, 0, 0);\n+    return new String(array, offset, array.length - offset);\n@@ -67,1 +77,1 @@\n-    return new String(array, 0, 0, StandardCharsets.UTF_8);\n+      return new String(array, offset, array.length - offset, StandardCharsets.UTF_8);\n@@ -70,4 +80,0 @@\n-  @Benchmark\n-  public String newStringFromRangedArrayWithCharsetName() throws Exception {\n-    return new String(array, 0, 0, StandardCharsets.UTF_8.name());\n-  }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringConstructor.java","additions":20,"deletions":14,"binary":false,"changes":34,"status":"modified"}]}