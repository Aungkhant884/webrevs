{"files":[{"patch":"@@ -1289,0 +1289,10 @@\n+  \/\/ Some classes are pre-resolved (like Throwable) which may lead to\n+  \/\/ consider it as a different entry. We then revert them back temporarily\n+  \/\/ to ensure proper comparison.\n+  if (t1 == JVM_CONSTANT_Class) {\n+    t1 = JVM_CONSTANT_UnresolvedClass;\n+  }\n+  if (t2 == JVM_CONSTANT_Class) {\n+    t2 = JVM_CONSTANT_UnresolvedClass;\n+  }\n+\n@@ -1300,9 +1310,0 @@\n-  case JVM_CONSTANT_Class:\n-  {\n-    Klass* k1 = resolved_klass_at(index1);\n-    Klass* k2 = cp2->resolved_klass_at(index2);\n-    if (k1 == k2) {\n-      return true;\n-    }\n-  } break;\n-\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1285,29 +1285,0 @@\n-\/\/ Returns true if the current mismatch is due to a resolved\/unresolved\n-\/\/ class pair. Otherwise, returns false.\n-bool VM_RedefineClasses::is_unresolved_class_mismatch(const constantPoolHandle& cp1,\n-       int index1, const constantPoolHandle& cp2, int index2) {\n-\n-  jbyte t1 = cp1->tag_at(index1).value();\n-  if (t1 != JVM_CONSTANT_Class && t1 != JVM_CONSTANT_UnresolvedClass) {\n-    return false;  \/\/ wrong entry type; not our special case\n-  }\n-\n-  jbyte t2 = cp2->tag_at(index2).value();\n-  if (t2 != JVM_CONSTANT_Class && t2 != JVM_CONSTANT_UnresolvedClass) {\n-    return false;  \/\/ wrong entry type; not our special case\n-  }\n-\n-  if (t1 == t2) {\n-    return false;  \/\/ not a mismatch; not our special case\n-  }\n-\n-  char *s1 = cp1->klass_name_at(index1)->as_C_string();\n-  char *s2 = cp2->klass_name_at(index2)->as_C_string();\n-  if (strcmp(s1, s2) != 0) {\n-    return false;  \/\/ strings don't match; not our special case\n-  }\n-\n-  return true;  \/\/ made it through the gauntlet; this is our special case\n-} \/\/ end is_unresolved_class_mismatch()\n-\n-\n@@ -1703,8 +1674,0 @@\n-      } else if (is_unresolved_class_mismatch(scratch_cp, scratch_i,\n-                                              *merge_cp_p, scratch_i)) {\n-        \/\/ The mismatch in compare_entry_to() above is because of a\n-        \/\/ resolved versus unresolved class entry at the same index\n-        \/\/ with the same string value. Since Pass 0 reverted any\n-        \/\/ class entries to unresolved class entries in *merge_cp_p,\n-        \/\/ we go with the unresolved class entry.\n-        continue;\n@@ -1724,7 +1687,0 @@\n-      \/\/ The find_matching_entry() call above could fail to find a match\n-      \/\/ due to a resolved versus unresolved class or string entry situation\n-      \/\/ like we solved above with the is_unresolved_*_mismatch() calls.\n-      \/\/ However, we would have to call is_unresolved_*_mismatch() over\n-      \/\/ all of *merge_cp_p (potentially) and that doesn't seem to be\n-      \/\/ worth the time.\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -441,2 +441,0 @@\n-  bool is_unresolved_class_mismatch(const constantPoolHandle& cp1, int index1,\n-    const constantPoolHandle& cp2, int index2);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -543,0 +543,1 @@\n+  -serviceability\/jvmti\/RedefineClasses\/RedefineLeakThrowable.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ # @bug 8308762\n+ * @library \/test\/lib\n+ * @summary Test that redefinition of class containing Throwable refs does not leak constant pool\n+ * @requires vm.jvmti\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.misc\n+ * @modules java.instrument\n+ *          java.compiler\n+ * @run main RedefineClassHelper\n+ * @run main\/othervm\/timeout=6000 -javaagent:redefineagent.jar -XX:MetaspaceSize=12m  -XX:MaxMetaspaceSize=12m RedefineLeakThrowable\n+ *\/\n+\n+class Tester {\n+    void test() {\n+        try {\n+            int i = 42;\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+        }\n+    }\n+}\n+\n+public class RedefineLeakThrowable {\n+\n+    static final String NEW_TESTER = \n+        \"class Tester {\" +\n+        \"   void test() {\" +\n+        \"        try {\" +\n+        \"            int i = 42;\" +\n+        \"        } catch (Throwable t) {\" +\n+        \"            t.printStackTrace();\" +\n+        \"        }\" +\n+        \"    }\" +\n+        \"}\";\n+\n+\n+    public static void main(String argv[]) throws Exception {\n+        for (int i = 0; i < 500; i++) {\n+            RedefineClassHelper.redefineClass(Tester.class, NEW_TESTER);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineLeakThrowable.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"}]}