{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -432,1 +432,1 @@\n-void LoaderConstraintTable::verify(PlaceholderTable* placeholders) {\n+void LoaderConstraintTable::verify() {\n@@ -453,1 +453,1 @@\n-          PlaceholderEntry* entry = placeholders->get_entry(name_hash, name, loader_data);\n+          PlaceholderEntry* entry = PlaceholderTable::get_entry(name, loader_data);\n","filename":"src\/hotspot\/share\/classfile\/loaderConstraints.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-  void verify(PlaceholderTable* placeholders);\n+  void verify();\n","filename":"src\/hotspot\/share\/classfile\/loaderConstraints.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,20 @@\n-#include \"utilities\/hashtable.inline.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+class PlaceholderKey {\n+  Symbol* _name;\n+  ClassLoaderData* _loader_data;\n+ public:\n+  PlaceholderKey(Symbol* name, ClassLoaderData* l) : _name(name), _loader_data(l) {}\n+\n+  static bool equals(PlaceholderKey const& k1, PlaceholderKey const& k2) {\n+    return (k1._name == k2._name && k1._loader_data == k2._loader_data);\n+  }\n+  static unsigned hash(PlaceholderKey const& k) {\n+    return (unsigned) k._name->identity_hash() ^ (int)((intptr_t)k._loader_data >> 3);\n+  }\n+  void print_on(outputStream* st) const;\n+};\n+\n+const int _placeholder_table_size = 503;   \/\/ Does this really have to be prime?\n+ResourceHashtable<PlaceholderKey, PlaceholderEntry, _placeholder_table_size, ResourceObj::C_HEAP, mtClass,\n+                  PlaceholderKey::hash, PlaceholderKey::equals> _placeholders;\n@@ -176,24 +195,0 @@\n-PlaceholderEntry* PlaceholderTable::new_entry(int hash, Symbol* name,\n-                                              ClassLoaderData* loader_data,\n-                                              Symbol* supername) {\n-  PlaceholderEntry* entry = (PlaceholderEntry*)Hashtable<Symbol*, mtClass>::new_entry(hash, name);\n-  \/\/ Hashtable with Symbol* literal must increment and decrement refcount.\n-  name->increment_refcount();\n-  entry->set_loader_data(loader_data);\n-  entry->set_supername(supername);\n-  entry->set_superThreadQ(NULL);\n-  entry->set_loadInstanceThreadQ(NULL);\n-  entry->set_defineThreadQ(NULL);\n-  entry->set_definer(NULL);\n-  entry->set_instance_klass(NULL);\n-  return entry;\n-}\n-\n-void PlaceholderTable::free_entry(PlaceholderEntry* entry) {\n-  \/\/ decrement Symbol refcount here because Hashtable doesn't.\n-  entry->literal()->decrement_refcount();\n-  if (entry->supername() != NULL) entry->supername()->decrement_refcount();\n-  BasicHashtable<mtClass>::free_entry(entry);\n-}\n-\n-\n@@ -204,3 +199,2 @@\n-PlaceholderEntry* PlaceholderTable::add_entry(unsigned int hash,\n-                                              Symbol* class_name, ClassLoaderData* loader_data,\n-                                              Symbol* supername){\n+PlaceholderEntry* add_entry(Symbol* class_name, ClassLoaderData* loader_data,\n+                            Symbol* supername){\n@@ -210,6 +204,9 @@\n-  \/\/ Both readers and writers are locked so it's safe to just\n-  \/\/ create the placeholder and insert it in the list without a membar.\n-  PlaceholderEntry* entry = new_entry(hash, class_name, loader_data, supername);\n-  int index = hash_to_index(hash);\n-  Hashtable<Symbol*, mtClass>::add_entry(index, entry);\n-  return entry;\n+  PlaceholderEntry entry;\n+  entry.set_supername(supername);\n+  PlaceholderKey key(class_name, loader_data);\n+  \/\/ Since we're storing this key in the hashtable, we need to increment the refcount.\n+  class_name->increment_refcount();\n+  bool created;\n+  PlaceholderEntry* table_copy = _placeholders.put_if_absent(key, entry, &created);\n+  assert(created, \"better be absent\");\n+  return table_copy;\n@@ -218,1 +215,0 @@\n-\n@@ -220,21 +216,1 @@\n-void PlaceholderTable::remove_entry(unsigned int hash,\n-                                    Symbol* class_name,\n-                                    ClassLoaderData* loader_data) {\n-  assert_locked_or_safepoint(SystemDictionary_lock);\n-  int index = hash_to_index(hash);\n-  PlaceholderEntry** p = bucket_addr(index);\n-  while (*p != NULL) {\n-    PlaceholderEntry *probe = *p;\n-    if (probe->hash() == hash && probe->equals(class_name, loader_data)) {\n-      \/\/ Delete entry\n-      *p = probe->next();\n-      free_entry(probe);\n-      return;\n-    }\n-    p = probe->next_addr();\n-  }\n-}\n-\n-PlaceholderEntry* PlaceholderTable::get_entry(unsigned int hash,\n-                                              Symbol* class_name,\n-                                              ClassLoaderData* loader_data) {\n+void remove_entry(Symbol* class_name, ClassLoaderData* loader_data) {\n@@ -243,10 +219,4 @@\n-  int index = hash_to_index(hash);\n-  for (PlaceholderEntry *place_probe = bucket(index);\n-                         place_probe != NULL;\n-                         place_probe = place_probe->next()) {\n-    if (place_probe->hash() == hash &&\n-        place_probe->equals(class_name, loader_data)) {\n-      return place_probe;\n-    }\n-  }\n-  return NULL;\n+  PlaceholderKey key(class_name, loader_data);\n+  _placeholders.remove(key);\n+  \/\/ Decrement the refcount in key, since it's no longer in the table.\n+  class_name->decrement_refcount();\n@@ -255,5 +225,5 @@\n-Symbol* PlaceholderTable::find_entry(unsigned int hash,\n-                                     Symbol* class_name,\n-                                     ClassLoaderData* loader_data) {\n-  PlaceholderEntry* probe = get_entry(hash, class_name, loader_data);\n-  return (probe != NULL ? probe->klassname() : NULL);\n+\n+PlaceholderEntry* PlaceholderTable::get_entry(Symbol* class_name, ClassLoaderData* loader_data) {\n+  assert_locked_or_safepoint(SystemDictionary_lock);\n+  PlaceholderKey key(class_name, loader_data);\n+  return _placeholders.get(key);\n@@ -277,1 +247,1 @@\n-    entry->print_entry(&ls);\n+    entry->print_on(&ls);\n@@ -286,2 +256,1 @@\n-PlaceholderEntry* PlaceholderTable::find_and_add(unsigned int hash,\n-                                                 Symbol* name,\n+PlaceholderEntry* PlaceholderTable::find_and_add(Symbol* name,\n@@ -293,1 +262,1 @@\n-  PlaceholderEntry* probe = get_entry(hash, name, loader_data);\n+  PlaceholderEntry* probe = get_entry(name, loader_data);\n@@ -296,1 +265,1 @@\n-    probe = add_entry(hash, name, loader_data, supername);\n+    probe = add_entry(name, loader_data, supername);\n@@ -321,2 +290,1 @@\n-void PlaceholderTable::find_and_remove(unsigned int hash,\n-                                       Symbol* name, ClassLoaderData* loader_data,\n+void PlaceholderTable::find_and_remove(Symbol* name, ClassLoaderData* loader_data,\n@@ -325,10 +293,10 @@\n-    assert_locked_or_safepoint(SystemDictionary_lock);\n-    PlaceholderEntry *probe = get_entry(hash, name, loader_data);\n-    if (probe != NULL) {\n-       log(probe, \"find_and_remove\", action);\n-       probe->remove_seen_thread(thread, action);\n-       \/\/ If no other threads using this entry, and this thread is not using this entry for other states\n-       if ((probe->superThreadQ() == NULL) && (probe->loadInstanceThreadQ() == NULL)\n-          && (probe->defineThreadQ() == NULL) && (probe->definer() == NULL)) {\n-         remove_entry(hash, name, loader_data);\n-       }\n+  assert_locked_or_safepoint(SystemDictionary_lock);\n+  PlaceholderEntry* probe = get_entry(name, loader_data);\n+  if (probe != NULL) {\n+    log(probe, \"find_and_remove\", action);\n+    probe->remove_seen_thread(thread, action);\n+    \/\/ If no other threads using this entry, and this thread is not using this entry for other states\n+    if ((probe->superThreadQ() == NULL) && (probe->loadInstanceThreadQ() == NULL)\n+        && (probe->defineThreadQ() == NULL) && (probe->definer() == NULL)) {\n+      probe->clear_supername();\n+      remove_entry(name, loader_data);\n@@ -337,3 +305,0 @@\n-\n-PlaceholderTable::PlaceholderTable(int table_size)\n-    : Hashtable<Symbol*, mtClass>(table_size, sizeof(PlaceholderEntry)) {\n@@ -342,7 +307,4 @@\n-void PlaceholderEntry::verify() const {\n-  guarantee(loader_data() != NULL, \"Must have been setup.\");\n-  guarantee(loader_data()->class_loader() == NULL || loader_data()->class_loader()->is_instance(),\n-            \"checking type of _loader\");\n-  guarantee(instance_klass() == NULL\n-            || instance_klass()->is_instance_klass(),\n-            \"checking type of instance_klass result\");\n+void PlaceholderKey::print_on(outputStream* st) const {\n+  _name->print_value_on(st);\n+  st->print(\", loader \");\n+  _loader_data->print_value_on(st);\n@@ -351,14 +313,1 @@\n-void PlaceholderTable::verify() {\n-  verify_table<PlaceholderEntry>(\"Placeholder Table\");\n-}\n-\n-\n-\/\/ Note, doesn't append a cr\n-\/\/ Can't call this print_on because HashtableEntry doesn't initialize its vptr\n-\/\/ and print_on is a virtual function so the vptr call crashes.\n-void PlaceholderEntry::print_entry(outputStream* st) const {\n-  klassname()->print_value_on(st);\n-  if (loader_data() != NULL) {\n-    st->print(\", loader \");\n-    loader_data()->print_value_on(st);\n-  }\n+void PlaceholderEntry::print_on(outputStream* st) const {\n@@ -389,1 +338,7 @@\n-void PlaceholderTable::print_on(outputStream* st) const {\n+void PlaceholderTable::print_on(outputStream* st) {\n+  auto printer = [&] (PlaceholderKey& key, PlaceholderEntry& entry) {\n+      st->print(\"placeholder \");\n+      key.print_on(st);\n+      entry.print_on(st);\n+      return true;\n+  };\n@@ -391,9 +346,2 @@\n-                table_size(), number_of_entries());\n-  for (int pindex = 0; pindex < table_size(); pindex++) {\n-    for (PlaceholderEntry* probe = bucket(pindex);\n-                           probe != NULL;\n-                           probe = probe->next()) {\n-      st->print(\"%4d: placeholder \", pindex);\n-      probe->print_entry(st);\n-    }\n-  }\n+                _placeholders.table_size(), _placeholders.number_of_entries());\n+  _placeholders.iterate(printer);\n@@ -402,1 +350,1 @@\n-void PlaceholderTable::print() const { return print_on(tty); }\n+void PlaceholderTable::print() { return print_on(tty); }\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":72,"deletions":124,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-#include \"utilities\/hashtable.hpp\"\n-\n@@ -39,38 +37,13 @@\n-class PlaceholderTable : public Hashtable<Symbol*, mtClass> {\n-\n-public:\n-  PlaceholderTable(int table_size);\n-\n-  PlaceholderEntry* new_entry(int hash, Symbol* name, ClassLoaderData* loader_data, Symbol* supername);\n-  void free_entry(PlaceholderEntry* entry);\n-\n-  PlaceholderEntry* bucket(int i) const {\n-    return (PlaceholderEntry*)Hashtable<Symbol*, mtClass>::bucket(i);\n-  }\n-\n-  PlaceholderEntry** bucket_addr(int i) {\n-    return (PlaceholderEntry**)Hashtable<Symbol*, mtClass>::bucket_addr(i);\n-  }\n-\n-  PlaceholderEntry* add_entry(unsigned int hash, Symbol* name,\n-                              ClassLoaderData* loader_data,\n-                              Symbol* supername);\n-\n-  \/\/ This returns a Symbol* to match type for SystemDictionary\n-  Symbol* find_entry(unsigned int hash,\n-                     Symbol* name, ClassLoaderData* loader_data);\n-\n-  PlaceholderEntry* get_entry(unsigned int hash,\n-                              Symbol* name, ClassLoaderData* loader_data);\n-\n-\/\/ caller to create a placeholder entry must enumerate an action\n-\/\/ caller claims ownership of that action\n-\/\/ For parallel classloading:\n-\/\/ multiple LOAD_INSTANCE threads can proceed in parallel\n-\/\/ multiple LOAD_SUPER threads can proceed in parallel\n-\/\/ LOAD_SUPER needed to check for class circularity\n-\/\/ DEFINE_CLASS: ultimately define class must be single threaded\n-\/\/ on a class\/classloader basis\n-\/\/ so the head of that queue owns the token\n-\/\/ and the rest of the threads return the result the first thread gets\n- enum classloadAction {\n+class PlaceholderTable : public AllStatic {\n+ public:\n+  \/\/ caller to create a placeholder entry must enumerate an action\n+  \/\/ caller claims ownership of that action\n+  \/\/ For parallel classloading:\n+  \/\/ multiple LOAD_INSTANCE threads can proceed in parallel\n+  \/\/ multiple LOAD_SUPER threads can proceed in parallel\n+  \/\/ LOAD_SUPER needed to check for class circularity\n+  \/\/ DEFINE_CLASS: ultimately define class must be single threaded\n+  \/\/ on a class\/classloader basis\n+  \/\/ so the head of that queue owns the token\n+  \/\/ and the rest of the threads return the result the first thread gets\n+  enum classloadAction {\n@@ -80,1 +53,3 @@\n- };\n+  };\n+\n+  static PlaceholderEntry* get_entry(Symbol* name, ClassLoaderData* loader_data);\n@@ -85,7 +60,3 @@\n-  PlaceholderEntry* find_and_add(unsigned int hash,\n-                                 Symbol* name, ClassLoaderData* loader_data,\n-                                 classloadAction action, Symbol* supername,\n-                                 JavaThread* thread);\n-\n-  void remove_entry(unsigned int hash,\n-                    Symbol* name, ClassLoaderData* loader_data);\n+  static PlaceholderEntry* find_and_add(Symbol* name, ClassLoaderData* loader_data,\n+                                        classloadAction action, Symbol* supername,\n+                                        JavaThread* thread);\n@@ -95,2 +66,1 @@\n-  void find_and_remove(unsigned int hash,\n-                       Symbol* name, ClassLoaderData* loader_data,\n+  static void find_and_remove(Symbol* name, ClassLoaderData* loader_data,\n@@ -99,3 +69,2 @@\n-  void print_on(outputStream* st) const;\n-  void print() const;\n-  void verify();\n+  static void print_on(outputStream* st);\n+  static void print();\n@@ -111,3 +80,1 @@\n-\n-class PlaceholderEntry : public HashtableEntry<Symbol*, mtClass> {\n-\n+class PlaceholderEntry {\n@@ -115,1 +82,0 @@\n-\n@@ -117,1 +83,0 @@\n-  ClassLoaderData*  _loader_data;   \/\/ initiating loader\n@@ -137,5 +102,3 @@\n-  \/\/ Simple accessors, used only by SystemDictionary\n-  Symbol*            klassname()           const { return literal(); }\n-\n-  ClassLoaderData*   loader_data()         const { return _loader_data; }\n-  void               set_loader_data(ClassLoaderData* loader_data) { _loader_data = loader_data; }\n+  PlaceholderEntry() :\n+     _supername(nullptr), _definer(nullptr), _instanceKlass(nullptr),\n+     _superThreadQ(nullptr), _loadInstanceThreadQ(nullptr), _defineThreadQ(nullptr) { }\n@@ -145,0 +108,1 @@\n+    Symbol::maybe_decrement_refcount(_supername);\n@@ -146,1 +110,5 @@\n-    if (_supername != NULL) _supername->increment_refcount();\n+    Symbol::maybe_increment_refcount(_supername);\n+  }\n+  void               clear_supername() {\n+    Symbol::maybe_decrement_refcount(_supername);\n+    _supername = nullptr;\n@@ -164,14 +132,0 @@\n-  PlaceholderEntry* next() const {\n-    return (PlaceholderEntry*)HashtableEntry<Symbol*, mtClass>::next();\n-  }\n-\n-  PlaceholderEntry** next_addr() {\n-    return (PlaceholderEntry**)HashtableEntry<Symbol*, mtClass>::next_addr();\n-  }\n-\n-  \/\/ Test for equality\n-  \/\/ Entries are unique for class\/classloader name pair\n-  bool equals(Symbol* class_name, ClassLoaderData* loader) const {\n-    return (klassname() == class_name && loader_data() == loader);\n-  }\n-\n@@ -193,3 +147,1 @@\n-  \/\/ Print method doesn't append a cr\n-  void print_entry(outputStream* st) const;\n-  void verify() const;\n+  void print_on(outputStream* st) const;\n","filename":"src\/hotspot\/share\/classfile\/placeholders.hpp","additions":34,"deletions":82,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -129,5 +129,0 @@\n-\/\/ Hashtable holding placeholders for classes being loaded.\n-const int _placeholder_table_size = 1009;\n-static PlaceholderTable* _placeholders   = NULL;\n-static PlaceholderTable*   placeholders() { return _placeholders; }\n-\n@@ -392,1 +387,1 @@\n-    probe->print_entry(&ls);\n+    probe->print_on(&ls);\n@@ -445,1 +440,0 @@\n-  assert(placeholders()->compute_hash(class_name) == name_hash, \"they're the same hashcode\");\n@@ -463,1 +457,1 @@\n-      PlaceholderEntry* probe = placeholders()->get_entry(name_hash, class_name, loader_data);\n+      PlaceholderEntry* probe = PlaceholderTable::get_entry(class_name, loader_data);\n@@ -472,5 +466,4 @@\n-      PlaceholderEntry* newprobe = placeholders()->find_and_add(name_hash,\n-                                                                class_name,\n-                                                                loader_data,\n-                                                                PlaceholderTable::LOAD_SUPER,\n-                                                                super_name, THREAD);\n+      PlaceholderEntry* newprobe = PlaceholderTable::find_and_add(class_name,\n+                                                                  loader_data,\n+                                                                  PlaceholderTable::LOAD_SUPER,\n+                                                                  super_name, THREAD);\n@@ -495,1 +488,1 @@\n-    placeholders()->find_and_remove(name_hash, class_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);\n+    PlaceholderTable::find_and_remove(class_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);\n@@ -582,1 +575,1 @@\n-  PlaceholderEntry* oldprobe = placeholders()->get_entry(name_hash, name, loader_data);\n+  PlaceholderEntry* oldprobe = PlaceholderTable::get_entry(name, loader_data);\n@@ -623,1 +616,1 @@\n-        oldprobe = placeholders()->get_entry(name_hash, name, loader_data);\n+        oldprobe = PlaceholderTable::get_entry(name, loader_data);\n@@ -692,2 +685,0 @@\n-  assert(placeholders()->compute_hash(name) == name_hash, \"they're the same hashcode\");\n-\n@@ -702,1 +693,1 @@\n-      PlaceholderEntry* placeholder = placeholders()->get_entry(name_hash, name, loader_data);\n+      PlaceholderEntry* placeholder = PlaceholderTable::get_entry(name, loader_data);\n@@ -760,4 +751,4 @@\n-          PlaceholderEntry* newprobe = placeholders()->find_and_add(name_hash, name, loader_data,\n-                                                                    PlaceholderTable::LOAD_INSTANCE,\n-                                                                    NULL,\n-                                                                    THREAD);\n+          PlaceholderEntry* newprobe = PlaceholderTable::find_and_add(name, loader_data,\n+                                                                      PlaceholderTable::LOAD_INSTANCE,\n+                                                                      NULL,\n+                                                                      THREAD);\n@@ -777,1 +768,1 @@\n-    \/\/ placeholders()->find_and_add(PlaceholderTable::LOAD_INSTANCE),\n+    \/\/ PlaceholderTable::find_and_add(PlaceholderTable::LOAD_INSTANCE),\n@@ -791,1 +782,1 @@\n-      placeholders()->find_and_remove(name_hash, name, loader_data, PlaceholderTable::LOAD_INSTANCE, THREAD);\n+      PlaceholderTable::find_and_remove(name, loader_data, PlaceholderTable::LOAD_INSTANCE, THREAD);\n@@ -1541,1 +1532,1 @@\n-\/\/ placeholders()->find_and_add(PlaceholderTable::DEFINE_CLASS),\n+\/\/ PlaceholderTable::find_and_add(PlaceholderTable::DEFINE_CLASS),\n@@ -1565,3 +1556,2 @@\n-    assert(placeholders()->compute_hash(name_h) == name_hash, \"they're the same hashcode\");\n-    PlaceholderEntry* probe = placeholders()->find_and_add(name_hash, name_h, loader_data,\n-                                                           PlaceholderTable::DEFINE_CLASS, NULL, THREAD);\n+    PlaceholderEntry* probe = PlaceholderTable::find_and_add(name_h, loader_data,\n+                                                             PlaceholderTable::DEFINE_CLASS, NULL, THREAD);\n@@ -1580,1 +1570,1 @@\n-      placeholders()->find_and_remove(name_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);\n+      PlaceholderTable::find_and_remove(name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);\n@@ -1598,1 +1588,1 @@\n-    PlaceholderEntry* probe = placeholders()->get_entry(name_hash, name_h, loader_data);\n+    PlaceholderEntry* probe = PlaceholderTable::get_entry(name_h, loader_data);\n@@ -1604,1 +1594,1 @@\n-    placeholders()->find_and_remove(name_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);\n+    PlaceholderTable::find_and_remove(name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);\n@@ -1727,1 +1717,0 @@\n-  _placeholders        = new PlaceholderTable(_placeholder_table_size);\n@@ -2492,1 +2481,1 @@\n-  placeholders()->print_on(st);\n+  PlaceholderTable::print_on(st);\n@@ -2508,2 +2497,0 @@\n-  guarantee(placeholders()->number_of_entries() >= 0,\n-            \"Verify of placeholders failed\");\n@@ -2516,2 +2503,0 @@\n-  placeholders()->verify();\n-\n@@ -2520,1 +2505,1 @@\n-  constraints()->verify(placeholders());\n+  constraints()->verify();\n@@ -2532,1 +2517,0 @@\n-    placeholders()->print_table_statistics(st, \"Placeholder Table\");\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":24,"deletions":40,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -287,1 +287,0 @@\n-template void BasicHashtable<mtClass>::verify_table<PlaceholderEntry>(char const*);\n","filename":"src\/hotspot\/share\/utilities\/hashtable.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}