{"files":[{"patch":"@@ -58,27 +58,28 @@\n- * measured in terms of <i>ulps<\/i>, units in the last place.  For a\n- * given floating-point format, an {@linkplain #ulp(double) ulp} of a\n- * specific real number value is the distance between the two\n- * floating-point values bracketing that numerical value.  When\n- * discussing the accuracy of a method as a whole rather than at a\n- * specific argument, the number of ulps cited is for the worst-case\n- * error at any argument.  If a method always has an error less than\n- * 0.5 ulps, the method always returns the floating-point number\n- * nearest the exact result; such a method is <i>correctly\n- * rounded<\/i>.  A correctly rounded method is generally the best a\n- * floating-point approximation can be; however, it is impractical for\n- * many floating-point methods to be correctly rounded.  Instead, for\n- * the {@code Math} class, a larger error bound of 1 or 2 ulps is\n- * allowed for certain methods.  Informally, with a 1 ulp error bound,\n- * when the exact result is a representable number, the exact result\n- * should be returned as the computed result; otherwise, either of the\n- * two floating-point values which bracket the exact result may be\n- * returned.  For exact results large in magnitude, one of the\n- * endpoints of the bracket may be infinite.  Besides accuracy at\n- * individual arguments, maintaining proper relations between the\n- * method at different arguments is also important.  Therefore, most\n- * methods with more than 0.5 ulp errors are required to be\n- * <i>semi-monotonic<\/i>: whenever the mathematical function is\n- * non-decreasing, so is the floating-point approximation, likewise,\n- * whenever the mathematical function is non-increasing, so is the\n- * floating-point approximation.  Not all approximations that have 1\n- * ulp accuracy will automatically meet the monotonicity requirements.\n+ * measured in terms of <dfn>{@index ulp}s<\/dfn>, {@index \"units in\n+ * the last place\"}.  For a given floating-point format, an\n+ * {@linkplain #ulp(double) ulp} of a specific real number value is\n+ * the distance between the two floating-point values bracketing that\n+ * numerical value.  When discussing the accuracy of a method as a\n+ * whole rather than at a specific argument, the number of ulps cited\n+ * is for the worst-case error at any argument.  If a method always\n+ * has an error less than 0.5 ulps, the method always returns the\n+ * floating-point number nearest the exact result; such a method is\n+ * <dfn>correctly rounded<\/dfn>.  A {@index \"correctly rounded\"}\n+ * method is generally the best a floating-point approximation can be;\n+ * however, it is impractical for many floating-point methods to be\n+ * correctly rounded.  Instead, for the {@code Math} class, a larger\n+ * error bound of 1 or 2 ulps is allowed for certain methods.\n+ * Informally, with a 1 ulp error bound, when the exact result is a\n+ * representable number, the exact result should be returned as the\n+ * computed result; otherwise, either of the two floating-point values\n+ * which bracket the exact result may be returned.  For exact results\n+ * large in magnitude, one of the endpoints of the bracket may be\n+ * infinite.  Besides accuracy at individual arguments, maintaining\n+ * proper relations between the method at different arguments is also\n+ * important.  Therefore, most methods with more than 0.5 ulp errors\n+ * are required to be <dfn>{@index \"semi-monotonic\"}<\/dfn>: whenever\n+ * the mathematical function is non-decreasing, so is the\n+ * floating-point approximation, likewise, whenever the mathematical\n+ * function is non-increasing, so is the floating-point approximation.\n+ * Not all approximations that have 1 ulp accuracy will automatically\n+ * meet the monotonicity requirements.\n@@ -88,8 +89,9 @@\n- * int and long primitive types.  The developer should choose\n- * the primitive type to ensure that arithmetic operations consistently\n- * produce correct results, which in some cases means the operations\n- * will not overflow the range of values of the computation.\n- * The best practice is to choose the primitive type and algorithm to avoid\n- * overflow. In cases where the size is {@code int} or {@code long} and\n- * overflow errors need to be detected, the methods whose names end with\n- * {@code Exact} throw an {@code ArithmeticException} when the results overflow.\n+ * {@code int} and {@code long} primitive types.  The developer should\n+ * choose the primitive type to ensure that arithmetic operations\n+ * consistently produce correct results, which in some cases means the\n+ * operations will not overflow the range of values of the\n+ * computation.  The best practice is to choose the primitive type and\n+ * algorithm to avoid overflow. In cases where the size is {@code int}\n+ * or {@code long} and overflow errors need to be detected, the\n+ * methods whose names end with {@code Exact} throw an {@code\n+ * ArithmeticException} when the results overflow.\n@@ -122,1 +124,0 @@\n- * @author  Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":37,"deletions":36,"binary":false,"changes":73,"status":"modified"}]}