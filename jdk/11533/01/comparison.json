{"files":[{"patch":"@@ -227,2 +227,4 @@\n-     * Submits the runContinuation task to the scheduler.\n-     * @param {@code lazySubmit} to lazy submit\n+     * Submits the runContinuation task to the scheduler. For the default scheduler,\n+     * and calling it on a worker thread, the task will be pushed to the local queue,\n+     * otherwise it will be pushed to a submission queue.\n+     *\n@@ -230,1 +232,0 @@\n-     * @see ForkJoinPool#lazySubmit(ForkJoinTask)\n@@ -232,1 +233,1 @@\n-    private void submitRunContinuation(boolean lazySubmit) {\n+    private void submitRunContinuation() {\n@@ -234,5 +235,1 @@\n-            if (lazySubmit && scheduler instanceof ForkJoinPool pool) {\n-                pool.lazySubmit(ForkJoinTask.adapt(runContinuation));\n-            } else {\n-                scheduler.execute(runContinuation);\n-            }\n+            scheduler.execute(runContinuation);\n@@ -240,7 +237,1 @@\n-            \/\/ record event\n-            var event = new VirtualThreadSubmitFailedEvent();\n-            if (event.isEnabled()) {\n-                event.javaThreadId = threadId();\n-                event.exceptionMessage = ree.getMessage();\n-                event.commit();\n-            }\n+            submitFailed(ree);\n@@ -252,1 +243,1 @@\n-     * Submits the runContinuation task to the scheduler.\n+     * Submits the runContinuation task to the scheduler with a lazy submit.\n@@ -254,0 +245,1 @@\n+     * @see ForkJoinPool#lazySubmit(ForkJoinTask)\n@@ -255,2 +247,7 @@\n-    private void submitRunContinuation() {\n-        submitRunContinuation(false);\n+    private void lazySubmitRunContinuation(ForkJoinPool pool) {\n+        try {\n+            pool.lazySubmit(ForkJoinTask.adapt(runContinuation));\n+        } catch (RejectedExecutionException ree) {\n+            submitFailed(ree);\n+            throw ree;\n+        }\n@@ -260,2 +257,1 @@\n-     * Submits the runContinuation task to the scheduler and without signalling\n-     * any threads if possible.\n+     * Submits the runContinuation task to the scheduler as an external submit.\n@@ -263,0 +259,1 @@\n+     * @see ForkJoinPool#externalSubmit(ForkJoinTask)\n@@ -264,2 +261,19 @@\n-    private void lazySubmitRunContinuation() {\n-        submitRunContinuation(true);\n+    private void externalSubmitRunContinuation(ForkJoinPool pool) {\n+        try {\n+            pool.externalSubmit(ForkJoinTask.adapt(runContinuation));\n+        } catch (RejectedExecutionException ree) {\n+            submitFailed(ree);\n+            throw ree;\n+        }\n+    }\n+\n+    \/**\n+     * If enabled, emits a JFR VirtualThreadSubmitFailedEvent.\n+     *\/\n+    private void submitFailed(RejectedExecutionException ree) {\n+        var event = new VirtualThreadSubmitFailedEvent();\n+        if (event.isEnabled()) {\n+            event.javaThreadId = threadId();\n+            event.exceptionMessage = ree.getMessage();\n+            event.commit();\n+        }\n@@ -440,1 +454,6 @@\n-                lazySubmitRunContinuation();\n+                if (currentThread() instanceof CarrierThread ct) {\n+                    lazySubmitRunContinuation(ct.getPool());\n+                } else {\n+                    submitRunContinuation();\n+                }\n+\n@@ -448,2 +467,6 @@\n-            \/\/ lazy submit to continue on the current thread as carrier if possible\n-            lazySubmitRunContinuation();\n+            \/\/ external submit if there are no tasks in the local task queue\n+            if (currentThread() instanceof CarrierThread ct && ct.getQueuedTaskCount() == 0) {\n+                externalSubmitRunContinuation(ct.getPool());\n+            } else {\n+                submitRunContinuation();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":49,"deletions":26,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test Thread.yield submits the virtual thread task to the expected queue\n+ * @requires vm.continuations\n+ * @enablePreview\n+ * @run junit\/othervm -Djdk.virtualThreadScheduler.maxPoolSize=1 YieldQueuing\n+ *\/\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.LockSupport;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class YieldQueuing {\n+\n+    \/**\n+     * Test Thread.yield submits the task for the current virtual thread to a scheduler\n+     * submission queue when there are no tasks in the local queue.\n+     *\/\n+    @Test\n+    void testYieldWithEmptyLocalQueue() throws Exception {\n+        var list = new CopyOnWriteArrayList<String>();\n+\n+        var threadsStarted = new AtomicBoolean();\n+\n+        var threadA = Thread.ofVirtual().unstarted(() -> {\n+            \/\/ pin thread until task for B is in submission queue\n+            while (!threadsStarted.get()) {\n+                Thread.onSpinWait();\n+            }\n+\n+            list.add(\"A\");\n+            Thread.yield();      \/\/ push task for A to submission queue, B should run\n+            list.add(\"A\");\n+        });\n+\n+        var threadB = Thread.ofVirtual().unstarted(() -> {\n+            list.add(\"B\");\n+        });\n+\n+        \/\/ push tasks for A and B to submission queue\n+        threadA.start();\n+        threadB.start();\n+\n+        \/\/ release A\n+        threadsStarted.set(true);\n+\n+        \/\/ wait for result\n+        threadA.join();\n+        threadB.join();\n+        assertEquals(list, List.of(\"A\", \"B\", \"A\"));\n+    }\n+\n+    \/**\n+     * Test Thread.yield submits the task for the current virtual thread to the local\n+     * queue when there are tasks in the local queue.\n+     *\/\n+    @Test\n+    void testYieldWithNonEmptyLocalQueue() throws Exception {\n+        var list = new CopyOnWriteArrayList<String>();\n+\n+        var threadsStarted = new AtomicBoolean();\n+\n+        var threadA = Thread.ofVirtual().unstarted(() -> {\n+            \/\/ pin thread until tasks for B and C are in submission queue\n+            while (!threadsStarted.get()) {\n+                Thread.onSpinWait();\n+            }\n+\n+            list.add(\"A\");\n+            LockSupport.park();   \/\/ B should run\n+            list.add(\"A\");\n+        });\n+\n+        var threadB = Thread.ofVirtual().unstarted(() -> {\n+            list.add(\"B\");\n+            LockSupport.unpark(threadA);  \/\/ push task for A to local queue\n+            Thread.yield();               \/\/ push task for B to local queue, A should run\n+            list.add(\"B\");\n+        });\n+\n+        var threadC = Thread.ofVirtual().unstarted(() -> {\n+            list.add(\"C\");\n+        });\n+\n+        \/\/ push tasks for A, B and C to submission queue\n+        threadA.start();\n+        threadB.start();\n+        threadC.start();\n+\n+        \/\/ release A\n+        threadsStarted.set(true);\n+\n+        \/\/ wait for result\n+        threadA.join();\n+        threadB.join();\n+        threadC.join();\n+        assertEquals(list, List.of(\"A\", \"B\", \"A\", \"B\", \"C\"));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/YieldQueuing.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main YieldALot 500000\n+ * @run main YieldALot 350000\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/YieldALot.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}