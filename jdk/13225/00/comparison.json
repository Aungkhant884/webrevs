{"files":[{"patch":"@@ -1332,10 +1332,0 @@\n-static jlong millis_to_nanos_bounded(jlong millis) {\n-  \/\/ We have to watch for overflow when converting millis to nanos,\n-  \/\/ but if millis is that large then we will end up limiting to\n-  \/\/ MAX_SECS anyway, so just do that here.\n-  if (millis \/ MILLIUNITS > MAX_SECS) {\n-    millis = jlong(MAX_SECS) * MILLIUNITS;\n-  }\n-  return millis_to_nanos(millis);\n-}\n-\n@@ -1375,1 +1365,1 @@\n-  to_abstime(abstime, millis_to_nanos_bounded(millis),\n+  to_abstime(abstime, millis_to_nanos_bounded(millis, 0, MAX_SECS),\n@@ -1541,0 +1531,7 @@\n+  return park(millis, 0);\n+}\n+\n+int PlatformEvent::park(jlong millis, jint nanos) {\n+  assert(0 <= millis, \"millis are in range\");\n+  assert(0 <= nanos && nanos < NANOSECS_PER_MILLISEC, \"nanos are in range\");\n+\n@@ -1560,1 +1557,2 @@\n-    to_abstime(&abst, millis_to_nanos_bounded(millis), false, false);\n+    jlong timeout = millis_to_nanos_bounded(millis, nanos, MAX_SECS);\n+    to_abstime(&abst, timeout, false, false);\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+  int  park(jlong millis, jint nanos);\n","filename":"src\/hotspot\/os\/posix\/park_posix.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5252,0 +5252,12 @@\n+int PlatformEvent::park(jlong millis, jint nanos) {\n+  assert(0 <= nanos && nanos < NANOSECS_PER_MILLISEC, \"nanos are in range\");\n+\n+  \/\/ Windows timers are still quite unpredictable to handle sub-millisecond granularity.\n+  \/\/ Instead of implementing this method, fall back to the millisecond sleep, treating\n+  \/\/ any positive requested nanos as a full millisecond.\n+  if (millis < max_jlong && nanos > 0) {\n+    millis++;\n+  }\n+  return park(millis);\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+    int  park (jlong millis, jint nanos);\n","filename":"src\/hotspot\/os\/windows\/park_windows.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -279,1 +279,1 @@\n-JVM_Sleep(JNIEnv *env, jclass threadClass, jlong millis);\n+JVM_Sleep(JNIEnv *env, jclass threadClass, jlong millis, jint nanos);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3058,1 +3058,1 @@\n-JVM_ENTRY(void, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong millis))\n+JVM_ENTRY(void, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong millis, jint nanos))\n@@ -3062,0 +3062,3 @@\n+  if (0 > nanos || nanos >= NANOSECS_PER_MILLISEC) {\n+    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), \"nanosecond timeout value out of range\");\n+  }\n@@ -3073,1 +3076,1 @@\n-  if (millis == 0) {\n+  if (millis == 0 && nanos == 0) {\n@@ -3078,1 +3081,1 @@\n-    if (!thread->sleep(millis)) { \/\/ interrupted\n+    if (!thread->sleep(millis, nanos)) { \/\/ interrupted\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1978,0 +1978,4 @@\n+  return sleep(millis, 0);\n+}\n+\n+bool JavaThread::sleep(jlong millis, jint nanos) {\n@@ -1979,0 +1983,2 @@\n+  assert(0 <= millis, \"millis are in range\");\n+  assert(0 <= nanos && nanos < NANOSECS_PER_MILLISEC, \"nanos are in range\");\n@@ -1992,0 +1998,5 @@\n+  \/\/ Be conscious about math overflows when converting millis to nanos:\n+  \/\/ cap the millis to max_secs.\n+  static const jlong max_secs = 100000000;\n+  jlong nanos_remaining = millis_to_nanos_bounded(millis, nanos, max_secs);\n+\n@@ -1998,1 +2009,1 @@\n-    if (millis <= 0) {\n+    if (nanos_remaining <= 0) {\n@@ -2005,1 +2016,3 @@\n-      slp->park(millis);\n+      jlong step_millis = nanos_to_millis(nanos_remaining);\n+      jlong step_nanos  = nanos_remaining - millis_to_nanos(step_millis);\n+      slp->park(step_millis, step_nanos);\n@@ -2016,1 +2029,1 @@\n-      millis -= (newtime - prevtime) \/ NANOSECS_PER_MILLISEC;\n+      nanos_remaining -= (newtime - prevtime);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1138,0 +1138,1 @@\n+  bool sleep(jlong millis, jint nanos);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -344,0 +344,10 @@\n+inline int64_t millis_to_nanos_bounded(int64_t millis, int64_t nanos, int64_t max_secs) {\n+  \/\/ We have to watch for overflow when converting millis to nanos,\n+  \/\/ but if millis is that large then we will end up limiting to\n+  \/\/ max_secs anyway, so just do that here.\n+  if (millis \/ MILLIUNITS > max_secs) {\n+    millis = max_secs * MILLIUNITS;\n+  }\n+  return millis_to_nanos(millis) + nanos;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -464,22 +464,1 @@\n-        if (millis < 0) {\n-            throw new IllegalArgumentException(\"timeout value is negative\");\n-        }\n-\n-        if (currentThread() instanceof VirtualThread vthread) {\n-            long nanos = MILLISECONDS.toNanos(millis);\n-            vthread.sleepNanos(nanos);\n-            return;\n-        }\n-\n-        if (ThreadSleepEvent.isTurnedOn()) {\n-            ThreadSleepEvent event = new ThreadSleepEvent();\n-            try {\n-                event.time = MILLISECONDS.toNanos(millis);\n-                event.begin();\n-                sleep0(millis);\n-            } finally {\n-                event.commit();\n-            }\n-        } else {\n-            sleep0(millis);\n-        }\n+        sleep(millis, 0);\n@@ -488,2 +467,0 @@\n-    private static native void sleep0(long millis) throws InterruptedException;\n-\n@@ -529,2 +506,11 @@\n-        if (nanos > 0 && millis < Long.MAX_VALUE) {\n-            millis++;\n+        if (ThreadSleepEvent.isTurnedOn()) {\n+            ThreadSleepEvent event = new ThreadSleepEvent();\n+            try {\n+                event.time = MILLISECONDS.toNanos(millis) + nanos;\n+                event.begin();\n+                sleep0(millis, nanos);\n+            } finally {\n+                event.commit();\n+            }\n+        } else {\n+            sleep0(millis, nanos);\n@@ -532,1 +518,0 @@\n-        sleep(millis);\n@@ -535,0 +520,2 @@\n+    private static native void sleep0(long millis, int nanos) throws InterruptedException;\n+\n@@ -561,6 +548,4 @@\n-        \/\/ convert to milliseconds\n-        long millis = MILLISECONDS.convert(nanos, NANOSECONDS);\n-        if (nanos > NANOSECONDS.convert(millis, MILLISECONDS)) {\n-            millis += 1L;\n-        }\n-        sleep(millis);\n+        \/\/ convert to milliseconds and nanos\n+        long millis = NANOSECONDS.toMillis(nanos);\n+        nanos -= MILLISECONDS.toNanos(millis);\n+        sleep(millis, (int)nanos);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":18,"deletions":33,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    {\"sleep0\",           \"(J)V\",       (void *)&JVM_Sleep},\n+    {\"sleep0\",           \"(JI)V\",      (void *)&JVM_Sleep},\n","filename":"src\/java.base\/share\/native\/libjava\/Thread.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2023, Amazon.com Inc. or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Sanity test Thread.sleep behavior\n+ * @run junit SleepSanity\n+ *\/\n+\n+import java.util.concurrent.TimeUnit;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class SleepSanity {\n+\n+    static final int[] TRY_MILLIS = new int[] { 0, 1, 10, 100, 1_000 };\n+    static final int[] TRY_NANOS  = new int[] { 0, 1, 10, 100, 1_000, 10_000, 100_000, 999_999 };\n+\n+    @Test\n+    void testMs() throws Exception {\n+        testIAE(() -> Thread.sleep(-1), \"timeout value is negative\");\n+\n+        testTimeout(() -> Thread.sleep(10_000),            5_000);\n+        testTimeout(() -> Thread.sleep(Integer.MAX_VALUE), 5_000);\n+        testTimeout(() -> Thread.sleep(Long.MAX_VALUE),    5_000);\n+\n+        for (final int millis : TRY_MILLIS) {\n+            testTimes(() -> Thread.sleep(millis), millis, 10_000);\n+        }\n+    }\n+\n+    @Test\n+    void testMsNs() throws Exception {\n+        testIAE(() -> Thread.sleep(-1),    \"timeout value is negative\");\n+\n+        testIAE(() -> Thread.sleep(0, -1),                \"nanosecond timeout value out of range\");\n+        testIAE(() -> Thread.sleep(0, 1_000_000),         \"nanosecond timeout value out of range\");\n+        testIAE(() -> Thread.sleep(0, Integer.MAX_VALUE), \"nanosecond timeout value out of range\");\n+\n+        testTimeout(() -> Thread.sleep(10_000, 0),            5_000);\n+        testTimeout(() -> Thread.sleep(Integer.MAX_VALUE, 0), 5_000);\n+        testTimeout(() -> Thread.sleep(Long.MAX_VALUE, 0),    5_000);\n+\n+        testTimeout(() -> Thread.sleep(10_000, 999_999),            5_000);\n+        testTimeout(() -> Thread.sleep(Integer.MAX_VALUE, 999_999), 5_000);\n+        testTimeout(() -> Thread.sleep(Long.MAX_VALUE, 999_999),    5_000);\n+\n+        for (final int millis : TRY_MILLIS) {\n+            for (final int nanos : TRY_NANOS) {\n+                testTimes(() -> Thread.sleep(millis, nanos), millis, 10_000);\n+            }\n+        }\n+    }\n+\n+    private static void testTimes(TestCase t, long min, long max) throws Exception {\n+        long start = System.nanoTime();\n+        t.run();\n+        long end = System.nanoTime();\n+        long duration = TimeUnit.NANOSECONDS.toMillis(end - start);\n+        assertTrue(duration >= min, \"Duration \" + duration + \"ms, expected >= \" + min + \"ms\");\n+        assertTrue(duration <= max, \"Duration \" + duration + \"ms, expected <= \" + max + \"ms\");\n+    }\n+\n+    private static void testTimeout(TestCase t, long timeout) throws Exception {\n+        Thread captThread = Thread.currentThread();\n+        Thread watcher = new Thread(() -> {\n+            try {\n+                Thread.sleep(timeout);\n+            } catch (InterruptedException ie)  {\n+                \/\/ Do nothing\n+            }\n+            captThread.interrupt();\n+        });\n+        watcher.setDaemon(true);\n+        watcher.start();\n+        try {\n+            t.run();\n+            fail(\"Exited before timeout\");\n+        } catch (InterruptedException ie) {\n+            \/\/ Expected\n+        }\n+        watcher.join();\n+    }\n+\n+    private static void testIAE(TestCase t, String msg) throws Exception {\n+        try {\n+            t.run();\n+            fail(\"Should have thrown the IAE\");\n+        } catch (IllegalArgumentException iae) {\n+            assertTrue(iae.getMessage().contains(msg),\n+                       \"Thrown IAE does not contain the string: \" + msg + \" \" + iae);\n+        }\n+    }\n+\n+    private interface TestCase {\n+        void run() throws Exception;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/SleepSanity.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2023, Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(3)\n+@State(Scope.Benchmark)\n+public class ThreadSleep {\n+\n+    @Param({\"0\",\n+            \"1\",\n+            \"10\",\n+            \"100\",\n+            \"1000\",\n+            \"10000\",\n+            \"100000\",\n+            \"1000000\",\n+            \"10000000\",\n+            \"100000000\",\n+            \"1000000000\"})\n+    private int sleep;\n+\n+    private long millis;\n+    private int nanos;\n+\n+    @Setup\n+    public void setup() {\n+        millis = TimeUnit.NANOSECONDS.toMillis(sleep);\n+        nanos = (int)(sleep - TimeUnit.MILLISECONDS.toNanos(millis));\n+    }\n+\n+    @Benchmark\n+    public void millis() throws InterruptedException {\n+        Thread.sleep(millis);\n+    }\n+\n+    @Benchmark\n+    public void millisNanos() throws InterruptedException {\n+        Thread.sleep(millis, nanos);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ThreadSleep.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"}]}