{"files":[{"patch":"@@ -1541,0 +1541,6 @@\n+  return park_nanos(millis_to_nanos_bounded(millis));\n+}\n+\n+int PlatformEvent::park_nanos(jlong nanos) {\n+  assert(nanos > 0, \"nanos are positive\");\n+\n@@ -1560,1 +1566,1 @@\n-    to_abstime(&abst, millis_to_nanos_bounded(millis), false, false);\n+    to_abstime(&abst, nanos, false, false);\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+  int  park_nanos(jlong nanos);\n","filename":"src\/hotspot\/os\/posix\/park_posix.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5252,0 +5252,15 @@\n+int PlatformEvent::park_nanos(jlong nanos) {\n+  assert(nanos > 0, \"nanos are positive\");\n+\n+  \/\/ Windows timers are still quite unpredictable to handle sub-millisecond granularity.\n+  \/\/ Instead of implementing sub-millisecond sleeps, fall back to the usual behavior of\n+  \/\/ rounding up any excess requested nanos to the full millisecond. This is how\n+  \/\/ Thread.sleep(millis, nanos) has always behaved with only millisecond granularity.\n+  jlong millis = nanos \/ NANOSECS_PER_MILLISEC;\n+  if (nanos > millis * NANOSECS_PER_MILLISEC) {\n+    millis++;\n+  }\n+  assert(millis > 0, \"should always be positive\");\n+  return park(millis);\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -51,3 +51,4 @@\n-    void park () ;\n-    void unpark () ;\n-    int  park (jlong millis) ;\n+    void park();\n+    void unpark();\n+    int  park(jlong millis);\n+    int  park_nanos(jlong nanos);\n","filename":"src\/hotspot\/os\/windows\/park_windows.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -276,1 +276,1 @@\n-JVM_Sleep(JNIEnv *env, jclass threadClass, jlong millis);\n+JVM_Sleep(JNIEnv *env, jclass threadClass, jlong nanos);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3046,3 +3046,3 @@\n-JVM_ENTRY(void, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong millis))\n-  if (millis < 0) {\n-    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), \"timeout value is negative\");\n+JVM_ENTRY(void, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong nanos))\n+  if (nanos < 0) {\n+    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), \"nanosecond timeout value out of range\");\n@@ -3059,1 +3059,1 @@\n-  HOTSPOT_THREAD_SLEEP_BEGIN(millis);\n+  HOTSPOT_THREAD_SLEEP_BEGIN(nanos \/ NANOSECS_PER_MILLISEC);\n@@ -3061,1 +3061,1 @@\n-  if (millis == 0) {\n+  if (nanos == 0) {\n@@ -3066,1 +3066,1 @@\n-    if (!thread->sleep(millis)) { \/\/ interrupted\n+    if (!thread->sleep_nanos(nanos)) { \/\/ interrupted\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1983,0 +1983,12 @@\n+\/\/ Internal convenience function for millisecond resolution sleeps.\n+bool JavaThread::sleep(jlong millis) {\n+  jlong nanos;\n+  if (millis > max_jlong \/ NANOUNITS_PER_MILLIUNIT) {\n+    \/\/ Conversion to nanos would overflow, saturate at max\n+    nanos = max_jlong;\n+  } else {\n+    nanos = millis * NANOUNITS_PER_MILLIUNIT;\n+  }\n+  return sleep_nanos(nanos);\n+}\n+\n@@ -1986,1 +1998,1 @@\n-bool JavaThread::sleep(jlong millis) {\n+bool JavaThread::sleep_nanos(jlong nanos) {\n@@ -1988,0 +2000,1 @@\n+  assert(nanos >= 0, \"nanos are in range\");\n@@ -2001,0 +2014,2 @@\n+  jlong nanos_remaining = nanos;\n+\n@@ -2007,1 +2022,1 @@\n-    if (millis <= 0) {\n+    if (nanos_remaining <= 0) {\n@@ -2014,1 +2029,1 @@\n-      slp->park(millis);\n+      slp->park_nanos(nanos_remaining);\n@@ -2025,1 +2040,1 @@\n-      millis -= (newtime - prevtime) \/ NANOSECS_PER_MILLISEC;\n+      nanos_remaining -= (newtime - prevtime);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1145,0 +1145,1 @@\n+  bool sleep_nanos(jlong nanos);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -509,1 +509,1 @@\n-                sleep0(millis);\n+                sleep0(nanos);\n@@ -516,1 +516,1 @@\n-    private static native void sleep0(long millis) throws InterruptedException;\n+    private static native void sleep0(long nanos) throws InterruptedException;\n@@ -558,5 +558,1 @@\n-                \/\/ millisecond precision\n-                if (nanos > 0 && millis < Long.MAX_VALUE) {\n-                    millis++;\n-                }\n-                sleep0(millis);\n+                sleep0(totalNanos);\n@@ -596,6 +592,1 @@\n-                \/\/ millisecond precision\n-                long millis = NANOSECONDS.toMillis(nanos);\n-                if (nanos > MILLISECONDS.toNanos(millis)) {\n-                    millis += 1L;\n-                }\n-                sleep0(millis);\n+                sleep0(nanos);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Sanity test Thread.sleep behavior\n+ * @run junit SleepSanity\n+ *\/\n+\n+import java.util.concurrent.TimeUnit;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class SleepSanity {\n+\n+    static final int[] TRY_MILLIS = new int[] { 0, 1, 10, 100, 1_000 };\n+    static final int[] TRY_NANOS  = new int[] { 0, 1, 10, 100, 1_000, 10_000, 100_000, 999_999 };\n+\n+    @Test\n+    void testMillis() throws Exception {\n+        testIAE(() -> Thread.sleep(-1), \"timeout value is negative\");\n+\n+        testTimeout(() -> Thread.sleep(10_000),            5_000);\n+        testTimeout(() -> Thread.sleep(Integer.MAX_VALUE), 5_000);\n+        testTimeout(() -> Thread.sleep(Long.MAX_VALUE),    5_000);\n+\n+        for (final int millis : TRY_MILLIS) {\n+            testTimes(() -> Thread.sleep(millis), millis, 20_000);\n+        }\n+    }\n+\n+    @Test\n+    void testMillisNanos() throws Exception {\n+        testIAE(() -> Thread.sleep(-1),    \"timeout value is negative\");\n+\n+        testIAE(() -> Thread.sleep(0, -1),                \"nanosecond timeout value out of range\");\n+        testIAE(() -> Thread.sleep(0, 1_000_000),         \"nanosecond timeout value out of range\");\n+        testIAE(() -> Thread.sleep(0, Integer.MAX_VALUE), \"nanosecond timeout value out of range\");\n+\n+        testTimeout(() -> Thread.sleep(10_000, 0),            5_000);\n+        testTimeout(() -> Thread.sleep(Integer.MAX_VALUE, 0), 5_000);\n+        testTimeout(() -> Thread.sleep(Long.MAX_VALUE, 0),    5_000);\n+\n+        testTimeout(() -> Thread.sleep(10_000, 999_999),            5_000);\n+        testTimeout(() -> Thread.sleep(Integer.MAX_VALUE, 999_999), 5_000);\n+        testTimeout(() -> Thread.sleep(Long.MAX_VALUE, 999_999),    5_000);\n+\n+        for (final int millis : TRY_MILLIS) {\n+            for (final int nanos : TRY_NANOS) {\n+                testTimes(() -> Thread.sleep(millis, nanos), millis, 20_000);\n+            }\n+        }\n+    }\n+\n+    private static void testTimes(TestCase t, long millisMin, long millisMax) throws Exception {\n+        long start = System.nanoTime();\n+        t.run();\n+        long end = System.nanoTime();\n+        long duration = TimeUnit.NANOSECONDS.toMillis(end - start);\n+        assertTrue(duration >= millisMin, \"Duration \" + duration + \"ms, expected >= \" + millisMin + \"ms\");\n+        assertTrue(duration <= millisMax, \"Duration \" + duration + \"ms, expected <= \" + millisMax + \"ms\");\n+    }\n+\n+    private static void testTimeout(TestCase t, long millis) throws Exception {\n+        Thread captThread = Thread.currentThread();\n+        Thread watcher = new Thread(() -> {\n+            try {\n+                Thread.sleep(millis);\n+            } catch (InterruptedException ie)  {\n+                \/\/ Do nothing\n+            }\n+            captThread.interrupt();\n+        });\n+        watcher.setDaemon(true);\n+        watcher.start();\n+        try {\n+            t.run();\n+            fail(\"Exited before timeout\");\n+        } catch (InterruptedException ie) {\n+            \/\/ Expected\n+        }\n+        watcher.join();\n+    }\n+\n+    private static void testIAE(TestCase t, String msg) throws Exception {\n+        try {\n+            t.run();\n+            fail(\"Should have thrown the IAE\");\n+        } catch (IllegalArgumentException iae) {\n+            assertTrue(iae.getMessage().contains(msg),\n+                       \"Thrown IAE does not contain the string: \" + msg + \" \" + iae);\n+        }\n+    }\n+\n+    private interface TestCase {\n+        void run() throws Exception;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/SleepSanity.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(3)\n+@State(Scope.Benchmark)\n+public class ThreadSleep {\n+\n+    @Param({\"0\",\n+            \"1\",\n+            \"10\",\n+            \"100\",\n+            \"1000\",\n+            \"10000\",\n+            \"100000\",\n+            \"1000000\",\n+            \"10000000\",\n+            \"100000000\",\n+            \"1000000000\"})\n+    private int sleep;\n+\n+    private long millis;\n+    private int nanos;\n+\n+    @Setup\n+    public void setup() {\n+        millis = TimeUnit.NANOSECONDS.toMillis(sleep);\n+        nanos = (int)(sleep - TimeUnit.MILLISECONDS.toNanos(millis));\n+    }\n+\n+    @Benchmark\n+    public void millis() throws InterruptedException {\n+        Thread.sleep(millis);\n+    }\n+\n+    @Benchmark\n+    public void millisNanos() throws InterruptedException {\n+        Thread.sleep(millis, nanos);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ThreadSleep.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"}]}