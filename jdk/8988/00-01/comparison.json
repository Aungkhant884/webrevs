{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+#include \"utilities\/stringUtils.hpp\"\n@@ -1611,0 +1612,1 @@\n+\n@@ -1620,0 +1622,1 @@\n+\n@@ -1623,0 +1626,1 @@\n+\n@@ -1626,0 +1630,1 @@\n+\n@@ -1627,1 +1632,0 @@\n-  uint _index = 0;\n@@ -1670,56 +1674,0 @@\n-\/\/ find needle in haystack, case insensitive\n-\/\/ custom implementation of strcasestr, as it is not available on windows\n-const char* strstr_nocase(const char* haystack, const char* needle) {\n-  if (needle[0] == '\\0') {\n-    return haystack; \/\/ empty needle matches with anything\n-  }\n-  for (size_t i = 0; haystack[i] != '\\0'; i++) {\n-    bool matches = true;\n-    for (size_t j = 0; needle[j] != '\\0'; j++) {\n-      if (haystack[i + j] == '\\0') {\n-        return nullptr; \/\/ hit end of haystack, abort\n-      }\n-      if (tolower(haystack[i + j]) != tolower(needle[j])) {\n-        matches = false;\n-        break; \/\/ abort, try next i\n-      }\n-    }\n-    if (matches) {\n-      return &haystack[i]; \/\/ all j were ok for this i\n-    }\n-  }\n-  return nullptr; \/\/ no i was a match\n-}\n-\n-\/\/ check if str matches the star_pattern\n-\/\/ eg. str \"_abc____def__\" would match pattern \"abc*def\"\n-\/\/ the matching is case insensitive\n-bool is_star_match(const char* star_pattern, const char* str) {\n-  const int N = 1000;\n-  char pattern[N]; \/\/ copy pattern into this to ensure null termination\n-  jio_snprintf(pattern, N, \"%s\", star_pattern);\/\/ ensures null termination\n-  char buf[N]; \/\/ copy parts of pattern into this\n-  const char* s = str;\n-  const char* r = &pattern[0]; \/\/ cast array to char*\n-  while (strlen(r) > 0) {\n-    \/\/ find next section in pattern\n-    const char* r_end = strstr(r, \"*\");\n-    const char* r_part = r;\n-    if (r_end != nullptr) { \/\/ copy part into buffer\n-      size_t r_part_len = r_end-r;\n-      strncpy(buf, r, r_part_len);\n-      buf[r_part_len] = '\\0'; \/\/ end of string\n-      r_part = &buf[0]; \/\/ cast array to char*\n-    }\n-    \/\/ find this section in s, case insensitive\n-    const char* s_match = strstr_nocase(s, r_part);\n-    if (s_match == nullptr) {\n-      return false; \/\/ r_part did not match - abort\n-    }\n-    size_t match_len = strlen(r_part);\n-    s = s_match + match_len; \/\/ advance to match position plus part length\n-    r += match_len + (r_end == nullptr ? 0 : 1); \/\/ advance by part length and \"*\"\n-  }\n-  return true; \/\/ all parts of pattern matched\n-}\n-\n@@ -1734,1 +1682,1 @@\n-    if (is_star_match(name, n->Name())) {\n+    if (StringUtils::is_star_match(name, n->Name())) {\n@@ -1753,1 +1701,1 @@\n-    if (is_star_match(pattern, stream.base())) {\n+    if (StringUtils::is_star_match(pattern, stream.base())) {\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":8,"deletions":60,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -70,0 +70,53 @@\n+\n+const char* StringUtils::strstr_nocase(const char* haystack, const char* needle) {\n+  if (needle[0] == '\\0') {\n+    return haystack; \/\/ empty needle matches with anything\n+  }\n+  for (size_t i = 0; haystack[i] != '\\0'; i++) {\n+    bool matches = true;\n+    for (size_t j = 0; needle[j] != '\\0'; j++) {\n+      if (haystack[i + j] == '\\0') {\n+        return nullptr; \/\/ hit end of haystack, abort\n+      }\n+      if (tolower(haystack[i + j]) != tolower(needle[j])) {\n+        matches = false;\n+        break; \/\/ abort, try next i\n+      }\n+    }\n+    if (matches) {\n+      return &haystack[i]; \/\/ all j were ok for this i\n+    }\n+  }\n+  return nullptr; \/\/ no i was a match\n+}\n+\n+bool StringUtils::is_star_match(const char* star_pattern, const char* str) {\n+  const int N = 1000;\n+  char pattern[N]; \/\/ copy pattern into this to ensure null termination\n+  jio_snprintf(pattern, N, \"%s\", star_pattern);\/\/ ensures null termination\n+  char buf[N]; \/\/ copy parts of pattern into this\n+  const char* str_idx = str;\n+  const char* pattern_idx = pattern;\n+  while (strlen(pattern_idx) > 0) {\n+    \/\/ find next section in pattern\n+    const char* pattern_part_end = strstr(pattern_idx, \"*\");\n+    const char* pattern_part = pattern_idx;\n+    if (pattern_part_end != nullptr) { \/\/ copy part into buffer\n+      size_t pattern_part_len = pattern_part_end-pattern_part;\n+      strncpy(buf, pattern_part, pattern_part_len);\n+      buf[pattern_part_len] = '\\0'; \/\/ end of string\n+      pattern_part = buf;\n+    }\n+    \/\/ find this section in s, case insensitive\n+    const char* str_match = strstr_nocase(str_idx, pattern_part);\n+    if (str_match == nullptr) {\n+      return false; \/\/ r_part did not match - abort\n+    }\n+    size_t match_len = strlen(pattern_part);\n+    \/\/ advance to match position plus part length\n+    str_idx = str_match + match_len;\n+    \/\/ advance by part length and \"*\"\n+    pattern_idx += match_len + (pattern_part_end == nullptr ? 0 : 1);\n+  }\n+  return true; \/\/ all parts of pattern matched\n+}\n","filename":"src\/hotspot\/share\/utilities\/stringUtils.cpp","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -43,0 +43,9 @@\n+\n+  \/\/ Find needle in haystack, case insensitive.\n+  \/\/ Custom implementation of strcasestr, as it is not available on windows.\n+  static const char* strstr_nocase(const char* haystack, const char* needle);\n+\n+  \/\/ Check if str matches the star_pattern.\n+  \/\/ eg. str \"_abc____def__\" would match pattern \"abc*def\".\n+  \/\/ The matching is case insensitive.\n+  static bool is_star_match(const char* star_pattern, const char* str);\n","filename":"src\/hotspot\/share\/utilities\/stringUtils.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}