{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+#include \"utilities\/stringUtils.hpp\"\n@@ -1604,0 +1605,113 @@\n+\/\/ BFS traverse all reachable nodes from start, call callback on them\n+template <typename Callback>\n+void visit_nodes(Node* start, Callback callback, bool traverse_output, bool only_ctrl) {\n+  Unique_Mixed_Node_List worklist;\n+  worklist.add(start);\n+  for (uint i = 0; i < worklist.size(); i++) {\n+    Node* n = worklist[i];\n+    callback(n);\n+    for (uint i = 0; i < n->len(); i++) {\n+      if (!only_ctrl || n->is_Region() || (n->Opcode() == Op_Root) || (i == TypeFunc::Control)) {\n+        \/\/ If only_ctrl is set: Add regions, the root node, or control inputs only\n+        worklist.add(n->in(i));\n+      }\n+    }\n+    if (traverse_output && !only_ctrl) {\n+      for (uint i = 0; i < n->outcnt(); i++) {\n+        worklist.add(n->raw_out(i));\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ BFS traverse from start, return node with idx\n+Node* find_node_by_idx(Node* start, uint idx, bool traverse_output, bool only_ctrl) {\n+  ResourceMark rm;\n+  Node* result = nullptr;\n+  auto callback = [&] (Node* n) {\n+    if (n->_idx == idx) {\n+      if (result != nullptr) {\n+        tty->print(\"find_node_by_idx: \" INTPTR_FORMAT \" and \" INTPTR_FORMAT \" both have idx==%d\\n\",\n+          (uintptr_t)result, (uintptr_t)n, idx);\n+      }\n+      result = n;\n+    }\n+  };\n+  visit_nodes(start, callback, traverse_output, only_ctrl);\n+  return result;\n+}\n+\n+int node_idx_cmp(Node** n1, Node** n2) {\n+  return (*n1)->_idx - (*n2)->_idx;\n+}\n+\n+Node* find_node_by_name(Node* start, const char* name) {\n+  ResourceMark rm;\n+  Node* result = nullptr;\n+  GrowableArray<Node*> ns;\n+  auto callback = [&] (Node* n) {\n+    if (StringUtils::is_star_match(name, n->Name())) {\n+      ns.push(n);\n+      result = n;\n+    }\n+  };\n+  visit_nodes(start, callback, true, false);\n+  ns.sort(node_idx_cmp);\n+  for (int i = 0; i < ns.length(); i++) {\n+    ns.at(i)->dump();\n+  }\n+  return result;\n+}\n+\n+Node* find_node_by_dump(Node* start, const char* pattern) {\n+  ResourceMark rm;\n+  Node* result = nullptr;\n+  GrowableArray<Node*> ns;\n+  auto callback = [&] (Node* n) {\n+    stringStream stream;\n+    n->dump(\"\", false, &stream);\n+    if (StringUtils::is_star_match(pattern, stream.base())) {\n+      ns.push(n);\n+      result = n;\n+    }\n+  };\n+  visit_nodes(start, callback, true, false);\n+  ns.sort(node_idx_cmp);\n+  for (int i = 0; i < ns.length(); i++) {\n+    ns.at(i)->dump();\n+  }\n+  return result;\n+}\n+\n+\/\/ call from debugger: find node with name pattern in new\/current graph\n+\/\/ name can contain \"*\" in match pattern to match any characters\n+\/\/ the matching is case insensitive\n+Node* find_node_by_name(const char* name) {\n+  Node* root = Compile::current()->root();\n+  return find_node_by_name(root, name);\n+}\n+\n+\/\/ call from debugger: find node with name pattern in old graph\n+\/\/ name can contain \"*\" in match pattern to match any characters\n+\/\/ the matching is case insensitive\n+Node* find_old_node_by_name(const char* name) {\n+  Node* root = old_root();\n+  return find_node_by_name(root, name);\n+}\n+\n+\/\/ call from debugger: find node with dump pattern in new\/current graph\n+\/\/ can contain \"*\" in match pattern to match any characters\n+\/\/ the matching is case insensitive\n+Node* find_node_by_dump(const char* pattern) {\n+  Node* root = Compile::current()->root();\n+  return find_node_by_dump(root, pattern);\n+}\n+\n+\/\/ call from debugger: find node with name pattern in old graph\n+\/\/ can contain \"*\" in match pattern to match any characters\n+\/\/ the matching is case insensitive\n+Node* find_old_node_by_dump(const char* pattern) {\n+  Node* root = old_root();\n+  return find_node_by_dump(root, pattern);\n+}\n+\n@@ -1649,48 +1763,1 @@\n-  VectorSet old_space;\n-  VectorSet new_space;\n-  Node_List worklist;\n-  Arena* old_arena = Compile::current()->old_arena();\n-  add_to_worklist(this, &worklist, old_arena, &old_space, &new_space);\n-  Node* result = NULL;\n-  int node_idx = (idx >= 0) ? idx : -idx;\n-\n-  for (uint list_index = 0; list_index < worklist.size(); list_index++) {\n-    Node* n = worklist[list_index];\n-\n-    if ((int)n->_idx == node_idx debug_only(|| n->debug_idx() == node_idx)) {\n-      if (result != NULL) {\n-        tty->print(\"find: \" INTPTR_FORMAT \" and \" INTPTR_FORMAT \" both have idx==%d\\n\",\n-                  (uintptr_t)result, (uintptr_t)n, node_idx);\n-      }\n-      result = n;\n-    }\n-\n-    for (uint i = 0; i < n->len(); i++) {\n-      if (!only_ctrl || n->is_Region() || (n->Opcode() == Op_Root) || (i == TypeFunc::Control)) {\n-        \/\/ If only_ctrl is set: Add regions, the root node, or control inputs only\n-        add_to_worklist(n->in(i), &worklist, old_arena, &old_space, &new_space);\n-      }\n-    }\n-\n-    \/\/ Also search along forward edges if idx is negative and the search is not done on control nodes only\n-    if (idx < 0 && !only_ctrl) {\n-      for (uint i = 0; i < n->outcnt(); i++) {\n-        add_to_worklist(n->raw_out(i), &worklist, old_arena, &old_space, &new_space);\n-      }\n-    }\n-  }\n-  return result;\n-}\n-\n-bool Node::add_to_worklist(Node* n, Node_List* worklist, Arena* old_arena, VectorSet* old_space, VectorSet* new_space) {\n-  if (not_a_node(n)) {\n-    return false; \/\/ Gracefully handle NULL, -1, 0xabababab, etc.\n-  }\n-\n-  \/\/ Contained in new_space or old_space? Check old_arena first since it's mostly empty.\n-  VectorSet* v = old_arena->contains(n) ? old_space : new_space;\n-  if (!v->test_set(n->_idx)) {\n-    worklist->push(n);\n-    return true;\n-  }\n-  return false;\n+  return find_node_by_idx(this, abs(idx), (idx < 0), only_ctrl);\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":116,"deletions":49,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -1656,0 +1656,30 @@\n+\/\/ Unique_Mixed_Node_List\n+\/\/ unique: nodes are added only once\n+\/\/ mixed: allow new and old nodes\n+class Unique_Mixed_Node_List : public ResourceObj {\n+public:\n+  Unique_Mixed_Node_List() : _visited_set(cmpkey, hashkey) {}\n+\n+  void add(Node* node) {\n+    if (not_a_node(node)) {\n+      return; \/\/ Gracefully handle NULL, -1, 0xabababab, etc.\n+    }\n+    if (_visited_set[node] == nullptr) {\n+      _visited_set.Insert(node, node);\n+      _worklist.push(node);\n+    }\n+  }\n+\n+  Node* operator[] (uint i) const {\n+    return _worklist[i];\n+  }\n+\n+  size_t size() {\n+    return _worklist.size();\n+  }\n+\n+private:\n+  Dict _visited_set;\n+  Node_List _worklist;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"jvm_io.h\"\n@@ -29,0 +30,1 @@\n+#include <ctype.h>\n@@ -70,0 +72,53 @@\n+\n+const char* StringUtils::strstr_nocase(const char* haystack, const char* needle) {\n+  if (needle[0] == '\\0') {\n+    return haystack; \/\/ empty needle matches with anything\n+  }\n+  for (size_t i = 0; haystack[i] != '\\0'; i++) {\n+    bool matches = true;\n+    for (size_t j = 0; needle[j] != '\\0'; j++) {\n+      if (haystack[i + j] == '\\0') {\n+        return nullptr; \/\/ hit end of haystack, abort\n+      }\n+      if (tolower(haystack[i + j]) != tolower(needle[j])) {\n+        matches = false;\n+        break; \/\/ abort, try next i\n+      }\n+    }\n+    if (matches) {\n+      return &haystack[i]; \/\/ all j were ok for this i\n+    }\n+  }\n+  return nullptr; \/\/ no i was a match\n+}\n+\n+bool StringUtils::is_star_match(const char* star_pattern, const char* str) {\n+  const int N = 1000;\n+  char pattern[N]; \/\/ copy pattern into this to ensure null termination\n+  jio_snprintf(pattern, N, \"%s\", star_pattern);\/\/ ensures null termination\n+  char buf[N]; \/\/ copy parts of pattern into this\n+  const char* str_idx = str;\n+  const char* pattern_idx = pattern;\n+  while (strlen(pattern_idx) > 0) {\n+    \/\/ find next section in pattern\n+    const char* pattern_part_end = strstr(pattern_idx, \"*\");\n+    const char* pattern_part = pattern_idx;\n+    if (pattern_part_end != nullptr) { \/\/ copy part into buffer\n+      size_t pattern_part_len = pattern_part_end-pattern_part;\n+      strncpy(buf, pattern_part, pattern_part_len);\n+      buf[pattern_part_len] = '\\0'; \/\/ end of string\n+      pattern_part = buf;\n+    }\n+    \/\/ find this section in s, case insensitive\n+    const char* str_match = strstr_nocase(str_idx, pattern_part);\n+    if (str_match == nullptr) {\n+      return false; \/\/ r_part did not match - abort\n+    }\n+    size_t match_len = strlen(pattern_part);\n+    \/\/ advance to match position plus part length\n+    str_idx = str_match + match_len;\n+    \/\/ advance by part length and \"*\"\n+    pattern_idx += match_len + (pattern_part_end == nullptr ? 0 : 1);\n+  }\n+  return true; \/\/ all parts of pattern matched\n+}\n","filename":"src\/hotspot\/share\/utilities\/stringUtils.cpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -43,0 +43,9 @@\n+\n+  \/\/ Find needle in haystack, case insensitive.\n+  \/\/ Custom implementation of strcasestr, as it is not available on windows.\n+  static const char* strstr_nocase(const char* haystack, const char* needle);\n+\n+  \/\/ Check if str matches the star_pattern.\n+  \/\/ eg. str \"_abc____def__\" would match pattern \"abc*def\".\n+  \/\/ The matching is case insensitive.\n+  static bool is_star_match(const char* star_pattern, const char* str);\n","filename":"src\/hotspot\/share\/utilities\/stringUtils.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}