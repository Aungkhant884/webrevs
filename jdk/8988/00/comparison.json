{"files":[{"patch":"@@ -25,0 +25,1 @@\n+#include \"jvm_io.h\"\n@@ -1604,0 +1605,193 @@\n+\/\/ UniqueMixedNodeList\n+\/\/ unique: nodes are added only once\n+\/\/ mixed: allow new and old nodes\n+class UniqueMixedNodeList {\n+public:\n+  UniqueMixedNodeList() : _visited_set(cmpkey, hashkey) {}\n+  void add(Node* node) {\n+    if (not_a_node(node)) {\n+      return; \/\/ Gracefully handle NULL, -1, 0xabababab, etc.\n+    }\n+    if (_visited_set[node] == nullptr) {\n+      _visited_set.Insert(node, node);\n+      _worklist.push(node);\n+    }\n+  }\n+  Node* operator[] (uint i) const {\n+    return _worklist[i];\n+  }\n+  size_t size() {\n+    return _worklist.size();\n+  }\n+private:\n+  uint _index = 0;\n+  Dict _visited_set;\n+  Node_List _worklist;\n+};\n+\n+\/\/ BFS traverse all reachable nodes from start, call callback on them\n+template <typename Callback>\n+void visit_nodes(Node* start, Callback callback, bool traverse_output, bool only_ctrl) {\n+  UniqueMixedNodeList worklist;\n+  worklist.add(start);\n+  for (uint i = 0; i < worklist.size(); i++) {\n+    Node* n = worklist[i];\n+    callback(n);\n+    for (uint i = 0; i < n->len(); i++) {\n+      if (!only_ctrl || n->is_Region() || (n->Opcode() == Op_Root) || (i == TypeFunc::Control)) {\n+        \/\/ If only_ctrl is set: Add regions, the root node, or control inputs only\n+        worklist.add(n->in(i));\n+      }\n+    }\n+    if (traverse_output && !only_ctrl) {\n+      for (uint i = 0; i < n->outcnt(); i++) {\n+        worklist.add(n->raw_out(i));\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ BFS traverse from start, return node with idx\n+Node* find_node_by_idx(Node* start, uint idx, bool traverse_output, bool only_ctrl) {\n+  Node* result = nullptr;\n+  auto callback = [&] (Node* n) {\n+    if (n->_idx == idx) {\n+      if (result != nullptr) {\n+        tty->print(\"find_node_by_idx: \" INTPTR_FORMAT \" and \" INTPTR_FORMAT \" both have idx==%d\\n\",\n+          (uintptr_t)result, (uintptr_t)n, idx);\n+      }\n+      result = n;\n+    }\n+  };\n+  visit_nodes(start, callback, traverse_output, only_ctrl);\n+  return result;\n+}\n+\n+\/\/ find needle in haystack, case insensitive\n+\/\/ custom implementation of strcasestr, as it is not available on windows\n+const char* strstr_nocase(const char* haystack, const char* needle) {\n+  if (needle[0] == '\\0') {\n+    return haystack; \/\/ empty needle matches with anything\n+  }\n+  for (size_t i = 0; haystack[i] != '\\0'; i++) {\n+    bool matches = true;\n+    for (size_t j = 0; needle[j] != '\\0'; j++) {\n+      if (haystack[i + j] == '\\0') {\n+        return nullptr; \/\/ hit end of haystack, abort\n+      }\n+      if (tolower(haystack[i + j]) != tolower(needle[j])) {\n+        matches = false;\n+        break; \/\/ abort, try next i\n+      }\n+    }\n+    if (matches) {\n+      return &haystack[i]; \/\/ all j were ok for this i\n+    }\n+  }\n+  return nullptr; \/\/ no i was a match\n+}\n+\n+\/\/ check if str matches the star_pattern\n+\/\/ eg. str \"_abc____def__\" would match pattern \"abc*def\"\n+\/\/ the matching is case insensitive\n+bool is_star_match(const char* star_pattern, const char* str) {\n+  const int N = 1000;\n+  char pattern[N]; \/\/ copy pattern into this to ensure null termination\n+  jio_snprintf(pattern, N, \"%s\", star_pattern);\/\/ ensures null termination\n+  char buf[N]; \/\/ copy parts of pattern into this\n+  const char* s = str;\n+  const char* r = &pattern[0]; \/\/ cast array to char*\n+  while (strlen(r) > 0) {\n+    \/\/ find next section in pattern\n+    const char* r_end = strstr(r, \"*\");\n+    const char* r_part = r;\n+    if (r_end != nullptr) { \/\/ copy part into buffer\n+      size_t r_part_len = r_end-r;\n+      strncpy(buf, r, r_part_len);\n+      buf[r_part_len] = '\\0'; \/\/ end of string\n+      r_part = &buf[0]; \/\/ cast array to char*\n+    }\n+    \/\/ find this section in s, case insensitive\n+    const char* s_match = strstr_nocase(s, r_part);\n+    if (s_match == nullptr) {\n+      return false; \/\/ r_part did not match - abort\n+    }\n+    size_t match_len = strlen(r_part);\n+    s = s_match + match_len; \/\/ advance to match position plus part length\n+    r += match_len + (r_end == nullptr ? 0 : 1); \/\/ advance by part length and \"*\"\n+  }\n+  return true; \/\/ all parts of pattern matched\n+}\n+\n+int node_idx_cmp(Node** n1, Node** n2) {\n+  return (*n1)->_idx - (*n2)->_idx;\n+}\n+\n+Node* find_node_by_name(Node* start, const char* name) {\n+  Node* result = nullptr;\n+  GrowableArray<Node*> ns;\n+  auto callback = [&] (Node* n) {\n+    if (is_star_match(name, n->Name())) {\n+      ns.push(n);\n+      result = n;\n+    }\n+  };\n+  visit_nodes(start, callback, true, false);\n+  ns.sort(node_idx_cmp);\n+  for (int i = 0; i < ns.length(); i++) {\n+    ns.at(i)->dump();\n+  }\n+  return result;\n+}\n+\n+Node* find_node_by_dump(Node* start, const char* pattern) {\n+  Node* result = nullptr;\n+  GrowableArray<Node*> ns;\n+  auto callback = [&] (Node* n) {\n+    stringStream stream;\n+    n->dump(\"\", false, &stream);\n+    if (is_star_match(pattern, stream.base())) {\n+      ns.push(n);\n+      result = n;\n+    }\n+  };\n+  visit_nodes(start, callback, true, false);\n+  ns.sort(node_idx_cmp);\n+  for (int i = 0; i < ns.length(); i++) {\n+    ns.at(i)->dump();\n+  }\n+  return result;\n+}\n+\n+\/\/ call from debugger: find node with name pattern in new\/current graph\n+\/\/ name can contain \"*\" in match pattern to match any characters\n+\/\/ the matching is case insensitive\n+Node* find_node_by_name(const char* name) {\n+  Node* root = Compile::current()->root();\n+  return find_node_by_name(root, name);\n+}\n+\n+\/\/ call from debugger: find node with name pattern in old graph\n+\/\/ name can contain \"*\" in match pattern to match any characters\n+\/\/ the matching is case insensitive\n+Node* find_old_node_by_name(const char* name) {\n+  Node* root = old_root();\n+  return find_node_by_name(root, name);\n+}\n+\n+\/\/ call from debugger: find node with dump pattern in new\/current graph\n+\/\/ can contain \"*\" in match pattern to match any characters\n+\/\/ the matching is case insensitive\n+Node* find_node_by_dump(const char* pattern) {\n+  Node* root = Compile::current()->root();\n+  return find_node_by_dump(root, pattern);\n+}\n+\n+\/\/ call from debugger: find node with name pattern in old graph\n+\/\/ can contain \"*\" in match pattern to match any characters\n+\/\/ the matching is case insensitive\n+Node* find_old_node_by_dump(const char* pattern) {\n+  Node* root = old_root();\n+  return find_node_by_dump(root, pattern);\n+}\n+\n@@ -1649,48 +1843,1 @@\n-  VectorSet old_space;\n-  VectorSet new_space;\n-  Node_List worklist;\n-  Arena* old_arena = Compile::current()->old_arena();\n-  add_to_worklist(this, &worklist, old_arena, &old_space, &new_space);\n-  Node* result = NULL;\n-  int node_idx = (idx >= 0) ? idx : -idx;\n-\n-  for (uint list_index = 0; list_index < worklist.size(); list_index++) {\n-    Node* n = worklist[list_index];\n-\n-    if ((int)n->_idx == node_idx debug_only(|| n->debug_idx() == node_idx)) {\n-      if (result != NULL) {\n-        tty->print(\"find: \" INTPTR_FORMAT \" and \" INTPTR_FORMAT \" both have idx==%d\\n\",\n-                  (uintptr_t)result, (uintptr_t)n, node_idx);\n-      }\n-      result = n;\n-    }\n-\n-    for (uint i = 0; i < n->len(); i++) {\n-      if (!only_ctrl || n->is_Region() || (n->Opcode() == Op_Root) || (i == TypeFunc::Control)) {\n-        \/\/ If only_ctrl is set: Add regions, the root node, or control inputs only\n-        add_to_worklist(n->in(i), &worklist, old_arena, &old_space, &new_space);\n-      }\n-    }\n-\n-    \/\/ Also search along forward edges if idx is negative and the search is not done on control nodes only\n-    if (idx < 0 && !only_ctrl) {\n-      for (uint i = 0; i < n->outcnt(); i++) {\n-        add_to_worklist(n->raw_out(i), &worklist, old_arena, &old_space, &new_space);\n-      }\n-    }\n-  }\n-  return result;\n-}\n-\n-bool Node::add_to_worklist(Node* n, Node_List* worklist, Arena* old_arena, VectorSet* old_space, VectorSet* new_space) {\n-  if (not_a_node(n)) {\n-    return false; \/\/ Gracefully handle NULL, -1, 0xabababab, etc.\n-  }\n-\n-  \/\/ Contained in new_space or old_space? Check old_arena first since it's mostly empty.\n-  VectorSet* v = old_arena->contains(n) ? old_space : new_space;\n-  if (!v->test_set(n->_idx)) {\n-    worklist->push(n);\n-    return true;\n-  }\n-  return false;\n+  return find_node_by_idx(this, abs(idx), (idx < 0), only_ctrl);\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":195,"deletions":48,"binary":false,"changes":243,"status":"modified"}]}