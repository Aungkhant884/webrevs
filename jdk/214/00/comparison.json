{"files":[{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/g1\/g1MMUTracker.hpp\"\n+#include \"gc\/g1\/g1MMUTrackerQueue.hpp\"\n@@ -81,1 +81,1 @@\n-  \/\/    - G1MMUTracker::add_pause(), when_sec() and when_max_gc_sec() can be called\n+  \/\/    - G1MMUTrackerQueue::add_pause(), when_sec() and when_max_gc_sec() can be called\n@@ -93,1 +93,1 @@\n-  G1MMUTracker *mmu_tracker = policy->mmu_tracker();\n+  G1MMUTrackerQueue *mmu_tracker = policy->mmu_tracker();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,131 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1MMUTRACKER_HPP\n-#define SHARE_GC_G1_G1MMUTRACKER_HPP\n-\n-#include \"gc\/shared\/gcId.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"utilities\/debug.hpp\"\n-\n-\/\/ Two major user controls over G1 behavior are setting a pause time goal (MaxGCPauseMillis),\n-\/\/ over a time slice (GCPauseIntervalMillis). This defines the Minimum Mutator\n-\/\/ Utilisation (MMU) goal.\n-\/\/\n-\/\/ * Definitions *\n-\/\/ Mutator Utilisation:\n-\/\/ - for a given time slice duration \"ts\",\n-\/\/ - mutator utilisation is the following fraction:\n-\/\/     non_gc_time \/ ts\n-\/\/\n-\/\/ Minimum Mutator Utilisation (MMU):\n-\/\/ - the worst mutator utilisation across all time slices.\n-\/\/\n-\/\/ G1MMUTracker keeps track of the GC work and decides when it is OK to do GC work\n-\/\/ and for how long so that the MMU invariants are maintained.\n-\/\/\n-\/\/ ***** ALL TIMES ARE IN SECS!!!!!!! *****\n-\/\/ this is the \"interface\"\n-class G1MMUTracker: public CHeapObj<mtGC> {\n-protected:\n-  double          _time_slice;\n-  double          _max_gc_time; \/\/ this is per time slice\n-\n-public:\n-  G1MMUTracker(double time_slice, double max_gc_time);\n-\n-  virtual void add_pause(double start, double end) = 0;\n-  virtual double when_sec(double current_time, double pause_time) = 0;\n-\n-  double max_gc_time() const {\n-    return _max_gc_time;\n-  }\n-\n-  inline double when_max_gc_sec(double current_time) {\n-    return when_sec(current_time, max_gc_time());\n-  }\n-};\n-\n-class G1MMUTrackerQueueElem {\n-private:\n-  double _start_time;\n-  double _end_time;\n-\n-public:\n-  inline double start_time() { return _start_time; }\n-  inline double end_time()   { return _end_time; }\n-  inline double duration()   { return _end_time - _start_time; }\n-\n-  G1MMUTrackerQueueElem() {\n-    _start_time = 0.0;\n-    _end_time   = 0.0;\n-  }\n-\n-  G1MMUTrackerQueueElem(double start_time, double end_time) {\n-    _start_time = start_time;\n-    _end_time   = end_time;\n-  }\n-};\n-\n-\/\/ this is an implementation of the MMUTracker using a (fixed-size) queue\n-\/\/ that keeps track of all the recent pause times\n-class G1MMUTrackerQueue: public G1MMUTracker {\n-private:\n-  enum PrivateConstants {\n-    QueueLength = 64\n-  };\n-\n-  \/\/ The array keeps track of all the pauses that fall within a time\n-  \/\/ slice (the last time slice during which pauses took place).\n-  \/\/ The data structure implemented is a circular queue.\n-  \/\/ Head \"points\" to the most recent addition, tail to the oldest one.\n-  \/\/ The array is of fixed size and I don't think we'll need more than\n-  \/\/ two or three entries with the current behavior of G1 pauses.\n-  \/\/ If the array is full, an easy fix is to look for the pauses with\n-  \/\/ the shortest gap between them and consolidate them.\n-  \/\/ For now, we have taken the expedient alternative of forgetting\n-  \/\/ the oldest entry in the event that +G1UseFixedWindowMMUTracker, thus\n-  \/\/ potentially violating MMU specs for some time thereafter.\n-\n-  G1MMUTrackerQueueElem _array[QueueLength];\n-  int                   _head_index;\n-  int                   _tail_index;\n-  int                   _no_entries;\n-\n-  inline int trim_index(int index) {\n-    return (index + QueueLength) % QueueLength;\n-  }\n-\n-  void remove_expired_entries(double current_time);\n-  double calculate_gc_time(double current_time);\n-\n-public:\n-  G1MMUTrackerQueue(double time_slice, double max_gc_time);\n-\n-  virtual void add_pause(double start, double end);\n-\n-  virtual double when_sec(double current_time, double pause_time);\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1MMUTRACKER_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MMUTracker.hpp","additions":0,"deletions":131,"binary":false,"changes":131,"status":"deleted"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"gc\/g1\/g1MMUTracker.hpp\"\n+#include \"gc\/g1\/g1MMUTrackerQueue.hpp\"\n@@ -40,4 +40,0 @@\n-G1MMUTracker::G1MMUTracker(double time_slice, double max_gc_time) :\n-  _time_slice(time_slice),\n-  _max_gc_time(max_gc_time) { }\n-\n@@ -45,1 +41,2 @@\n-  G1MMUTracker(time_slice, max_gc_time),\n+  _time_slice(time_slice),\n+  _max_gc_time(max_gc_time),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MMUTrackerQueue.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"previous_filename":"src\/hotspot\/share\/gc\/g1\/g1MMUTracker.cpp","status":"renamed"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1MMUTRACKERQUEUE_HPP\n+#define SHARE_GC_G1_G1MMUTRACKERQUEUE_HPP\n+\n+#include \"gc\/shared\/gcId.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+class G1MMUTrackerQueueElem {\n+private:\n+  double _start_time;\n+  double _end_time;\n+\n+public:\n+  inline double start_time() { return _start_time; }\n+  inline double end_time()   { return _end_time; }\n+  inline double duration()   { return _end_time - _start_time; }\n+\n+  G1MMUTrackerQueueElem() {\n+    _start_time = 0.0;\n+    _end_time   = 0.0;\n+  }\n+\n+  G1MMUTrackerQueueElem(double start_time, double end_time) {\n+    _start_time = start_time;\n+    _end_time   = end_time;\n+  }\n+};\n+\n+\n+\/\/ This implementation uses a fixed-size queue to keep track of all\n+\/\/ recent pause times. Two major user controls over G1 behavior are\n+\/\/ setting a pause time goal (MaxGCPauseMillis), over a time slice\n+\/\/ (GCPauseIntervalMillis). This defines the Minimum Mutator\n+\/\/ Utilisation (MMU) goal.\n+\/\/\n+\/\/ * Definitions *\n+\/\/ Mutator Utilisation:\n+\/\/ - for a given time slice duration \"ts\",\n+\/\/ - mutator utilisation is the following fraction:\n+\/\/     non_gc_time \/ ts\n+\/\/\n+\/\/ Minimum Mutator Utilisation (MMU):\n+\/\/ - the worst mutator utilisation across all time slices.\n+\/\/\n+\/\/ ***** ALL TIMES ARE IN SECS!!!!!!! *****\n+class G1MMUTrackerQueue: public CHeapObj<mtGC> {\n+private:\n+  enum PrivateConstants {\n+    QueueLength = 64\n+  };\n+\n+  double                _time_slice;\n+  double                _max_gc_time; \/\/ this is per time slice\n+\n+  \/\/ The array keeps track of all the pauses that fall within a time\n+  \/\/ slice (the last time slice during which pauses took place).\n+  \/\/ The data structure implemented is a circular queue.\n+  \/\/ Head \"points\" to the most recent addition, tail to the oldest one.\n+  \/\/ The array is of fixed size and I don't think we'll need more than\n+  \/\/ two or three entries with the current behavior of G1 pauses.\n+  \/\/ If the array is full, an easy fix is to look for the pauses with\n+  \/\/ the shortest gap between them and consolidate them.\n+  \/\/ For now, we have taken the expedient alternative of forgetting\n+  \/\/ the oldest entry in the event that +G1UseFixedWindowMMUTracker, thus\n+  \/\/ potentially violating MMU specs for some time thereafter.\n+\n+  G1MMUTrackerQueueElem _array[QueueLength];\n+  int                   _head_index;\n+  int                   _tail_index;\n+  int                   _no_entries;\n+\n+  inline int trim_index(int index) {\n+    return (index + QueueLength) % QueueLength;\n+  }\n+\n+  void remove_expired_entries(double current_time);\n+  double calculate_gc_time(double current_time);\n+\n+public:\n+  G1MMUTrackerQueue(double time_slice, double max_gc_time);\n+\n+  void add_pause(double start, double end);\n+\n+  double when_sec(double current_time, double pause_time);\n+\n+  double max_gc_time() const {\n+    return _max_gc_time;\n+  }\n+\n+  inline double when_max_gc_sec(double current_time) {\n+    return when_sec(current_time, max_gc_time());\n+  }\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1MMUTRACKERQUEUE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MMUTrackerQueue.hpp","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"gc\/g1\/g1MMUTracker.hpp\"\n+#include \"gc\/g1\/g1MMUTrackerQueue.hpp\"\n@@ -70,1 +70,1 @@\n-  G1MMUTracker* _mmu_tracker;\n+  G1MMUTrackerQueue* _mmu_tracker;\n@@ -157,1 +157,1 @@\n-  G1MMUTracker* mmu_tracker() {\n+  G1MMUTrackerQueue* mmu_tracker() {\n@@ -161,1 +161,1 @@\n-  const G1MMUTracker* mmu_tracker() const {\n+  const G1MMUTrackerQueue* mmu_tracker() const {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}