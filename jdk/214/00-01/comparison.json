{"files":[{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/g1\/g1MMUTrackerQueue.hpp\"\n+#include \"gc\/g1\/g1MMUTracker.hpp\"\n@@ -81,1 +81,1 @@\n-  \/\/    - G1MMUTrackerQueue::add_pause(), when_sec() and when_max_gc_sec() can be called\n+  \/\/    - G1MMUTracker::add_pause(), when_sec() and when_max_gc_sec() can be called\n@@ -93,1 +93,1 @@\n-  G1MMUTrackerQueue *mmu_tracker = policy->mmu_tracker();\n+  G1MMUTracker *mmu_tracker = policy->mmu_tracker();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1MMUTracker.hpp\"\n+#include \"gc\/g1\/g1Trace.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+\/\/ can't rely on comparing doubles with tolerating a small margin for error\n+#define SMALL_MARGIN 0.0000001\n+#define is_double_leq_0(_value) ( (_value) < SMALL_MARGIN )\n+#define is_double_leq(_val1, _val2) is_double_leq_0((_val1) - (_val2))\n+#define is_double_geq(_val1, _val2) is_double_leq_0((_val2) - (_val1))\n+\n+\/***** ALL TIMES ARE IN SECS!!!!!!! *****\/\n+\n+G1MMUTracker::G1MMUTracker(double time_slice, double max_gc_time) :\n+  _time_slice(time_slice),\n+  _max_gc_time(max_gc_time),\n+  _head_index(0),\n+  _tail_index(trim_index(_head_index+1)),\n+  _no_entries(0) { }\n+\n+void G1MMUTracker::remove_expired_entries(double current_time) {\n+  double limit = current_time - _time_slice;\n+  while (_no_entries > 0) {\n+    if (is_double_geq(limit, _array[_tail_index].end_time())) {\n+      _tail_index = trim_index(_tail_index + 1);\n+      --_no_entries;\n+    } else\n+      return;\n+  }\n+  guarantee(_no_entries == 0, \"should have no entries in the array\");\n+}\n+\n+double G1MMUTracker::calculate_gc_time(double current_time) {\n+  double gc_time = 0.0;\n+  double limit = current_time - _time_slice;\n+  for (int i = 0; i < _no_entries; ++i) {\n+    int index = trim_index(_tail_index + i);\n+    G1MMUTrackerElem *elem = &_array[index];\n+    if (elem->end_time() > limit) {\n+      if (elem->start_time() > limit)\n+        gc_time += elem->duration();\n+      else\n+        gc_time += elem->end_time() - limit;\n+    }\n+  }\n+  return gc_time;\n+}\n+\n+void G1MMUTracker::add_pause(double start, double end) {\n+  remove_expired_entries(end);\n+  if (_no_entries == QueueLength) {\n+    \/\/ OK, we've filled up the queue. There are a few ways\n+    \/\/ of dealing with this \"gracefully\"\n+    \/\/   increase the array size (:-)\n+    \/\/   remove the oldest entry (this might allow more GC time for\n+    \/\/     the time slice than what's allowed) - this is what we\n+    \/\/     currently do\n+    \/\/   consolidate the two entries with the minimum gap between them\n+    \/\/     (this might allow less GC time than what's allowed)\n+\n+    \/\/ In the case where ScavengeALot is true, such overflow is not\n+    \/\/ uncommon; in such cases, we can, without much loss of precision\n+    \/\/ or performance (we are GC'ing most of the time anyway!),\n+    \/\/ simply overwrite the oldest entry in the tracker.\n+\n+    _head_index = trim_index(_head_index + 1);\n+    assert(_head_index == _tail_index, \"Because we have a full circular buffer\");\n+    _tail_index = trim_index(_tail_index + 1);\n+  } else {\n+    _head_index = trim_index(_head_index + 1);\n+    ++_no_entries;\n+  }\n+  _array[_head_index] = G1MMUTrackerElem(start, end);\n+\n+  \/\/ Current entry needs to be added before calculating the value\n+  double slice_time = calculate_gc_time(end);\n+  G1MMUTracer::report_mmu(_time_slice, slice_time, _max_gc_time);\n+\n+  if (slice_time < _max_gc_time) {\n+    log_debug(gc, mmu)(\"MMU: %.1lfms (%.1lfms\/%.1lfms)\",\n+                       slice_time * 1000.0, _max_gc_time * 1000.0, _time_slice * 1000);\n+  } else {\n+    log_info(gc, mmu)(\"MMU target violated: %.1lfms (%.1lfms\/%.1lfms)\",\n+                      slice_time * 1000.0, _max_gc_time * 1000.0, _time_slice * 1000);\n+  }\n+}\n+\n+double G1MMUTracker::when_sec(double current_time, double pause_time) {\n+  \/\/ if the pause is over the maximum, just assume that it's the maximum\n+  double adjusted_pause_time =\n+    (pause_time > max_gc_time()) ? max_gc_time() : pause_time;\n+  double earliest_end = current_time + adjusted_pause_time;\n+  double limit = earliest_end - _time_slice;\n+  double gc_time = calculate_gc_time(earliest_end);\n+  double diff = gc_time + adjusted_pause_time - max_gc_time();\n+  if (is_double_leq_0(diff))\n+    return 0.0;\n+\n+  if (adjusted_pause_time == max_gc_time()) {\n+    G1MMUTrackerElem *elem = &_array[_head_index];\n+    return elem->end_time() - limit;\n+  }\n+\n+  int index = _tail_index;\n+  while ( 1 ) {\n+    G1MMUTrackerElem *elem = &_array[index];\n+    if (elem->end_time() > limit) {\n+      if (elem->start_time() > limit)\n+        diff -= elem->duration();\n+      else\n+        diff -= elem->end_time() - limit;\n+      if (is_double_leq_0(diff))\n+        return elem->end_time() + diff - limit;\n+    }\n+    index = trim_index(index+1);\n+    guarantee(index != trim_index(_head_index + 1), \"should not go past head\");\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MMUTracker.cpp","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1MMUTRACKER_HPP\n+#define SHARE_GC_G1_G1MMUTRACKER_HPP\n+\n+#include \"gc\/shared\/gcId.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+class G1MMUTrackerElem {\n+private:\n+  double _start_time;\n+  double _end_time;\n+\n+public:\n+  inline double start_time() { return _start_time; }\n+  inline double end_time()   { return _end_time; }\n+  inline double duration()   { return _end_time - _start_time; }\n+\n+  G1MMUTrackerElem() {\n+    _start_time = 0.0;\n+    _end_time   = 0.0;\n+  }\n+\n+  G1MMUTrackerElem(double start_time, double end_time) {\n+    _start_time = start_time;\n+    _end_time   = end_time;\n+  }\n+};\n+\n+\n+\/\/ This implementation uses a fixed-size queue to keep track of all\n+\/\/ recent pause times. Two major user controls over G1 behavior are\n+\/\/ setting a pause time goal (MaxGCPauseMillis), over a time slice\n+\/\/ (GCPauseIntervalMillis). This defines the Minimum Mutator\n+\/\/ Utilisation (MMU) goal.\n+\/\/\n+\/\/ * Definitions *\n+\/\/ Mutator Utilisation:\n+\/\/ - for a given time slice duration \"ts\",\n+\/\/ - mutator utilisation is the following fraction:\n+\/\/     non_gc_time \/ ts\n+\/\/\n+\/\/ Minimum Mutator Utilisation (MMU):\n+\/\/ - the worst mutator utilisation across all time slices.\n+\/\/\n+\/\/ ***** ALL TIMES ARE IN SECS!!!!!!! *****\n+class G1MMUTracker: public CHeapObj<mtGC> {\n+private:\n+  enum PrivateConstants {\n+    QueueLength = 64\n+  };\n+\n+  double                _time_slice;\n+  double                _max_gc_time; \/\/ this is per time slice\n+\n+  \/\/ The array keeps track of all the pauses that fall within a time\n+  \/\/ slice (the last time slice during which pauses took place).\n+  \/\/ The data structure implemented is a circular queue.\n+  \/\/ Head \"points\" to the most recent addition, tail to the oldest one.\n+  \/\/ The array is of fixed size and I don't think we'll need more than\n+  \/\/ two or three entries with the current behavior of G1 pauses.\n+  \/\/ If the array is full, an easy fix is to look for the pauses with\n+  \/\/ the shortest gap between them and consolidate them.\n+  \/\/ For now, we have taken the expedient alternative of forgetting\n+  \/\/ the oldest entry in the event that +G1UseFixedWindowMMUTracker, thus\n+  \/\/ potentially violating MMU specs for some time thereafter.\n+\n+  G1MMUTrackerElem _array[QueueLength];\n+  int                   _head_index;\n+  int                   _tail_index;\n+  int                   _no_entries;\n+\n+  inline int trim_index(int index) {\n+    return (index + QueueLength) % QueueLength;\n+  }\n+\n+  void remove_expired_entries(double current_time);\n+  double calculate_gc_time(double current_time);\n+\n+public:\n+  G1MMUTracker(double time_slice, double max_gc_time);\n+\n+  void add_pause(double start, double end);\n+\n+  double when_sec(double current_time, double pause_time);\n+\n+  double max_gc_time() const {\n+    return _max_gc_time;\n+  }\n+\n+  inline double when_max_gc_sec(double current_time) {\n+    return when_sec(current_time, max_gc_time());\n+  }\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1MMUTRACKER_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MMUTracker.hpp","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -1,144 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/g1\/g1MMUTrackerQueue.hpp\"\n-#include \"gc\/g1\/g1Trace.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"runtime\/mutexLocker.hpp\"\n-#include \"utilities\/ostream.hpp\"\n-\n-\/\/ can't rely on comparing doubles with tolerating a small margin for error\n-#define SMALL_MARGIN 0.0000001\n-#define is_double_leq_0(_value) ( (_value) < SMALL_MARGIN )\n-#define is_double_leq(_val1, _val2) is_double_leq_0((_val1) - (_val2))\n-#define is_double_geq(_val1, _val2) is_double_leq_0((_val2) - (_val1))\n-\n-\/***** ALL TIMES ARE IN SECS!!!!!!! *****\/\n-\n-G1MMUTrackerQueue::G1MMUTrackerQueue(double time_slice, double max_gc_time) :\n-  _time_slice(time_slice),\n-  _max_gc_time(max_gc_time),\n-  _head_index(0),\n-  _tail_index(trim_index(_head_index+1)),\n-  _no_entries(0) { }\n-\n-void G1MMUTrackerQueue::remove_expired_entries(double current_time) {\n-  double limit = current_time - _time_slice;\n-  while (_no_entries > 0) {\n-    if (is_double_geq(limit, _array[_tail_index].end_time())) {\n-      _tail_index = trim_index(_tail_index + 1);\n-      --_no_entries;\n-    } else\n-      return;\n-  }\n-  guarantee(_no_entries == 0, \"should have no entries in the array\");\n-}\n-\n-double G1MMUTrackerQueue::calculate_gc_time(double current_time) {\n-  double gc_time = 0.0;\n-  double limit = current_time - _time_slice;\n-  for (int i = 0; i < _no_entries; ++i) {\n-    int index = trim_index(_tail_index + i);\n-    G1MMUTrackerQueueElem *elem = &_array[index];\n-    if (elem->end_time() > limit) {\n-      if (elem->start_time() > limit)\n-        gc_time += elem->duration();\n-      else\n-        gc_time += elem->end_time() - limit;\n-    }\n-  }\n-  return gc_time;\n-}\n-\n-void G1MMUTrackerQueue::add_pause(double start, double end) {\n-  remove_expired_entries(end);\n-  if (_no_entries == QueueLength) {\n-    \/\/ OK, we've filled up the queue. There are a few ways\n-    \/\/ of dealing with this \"gracefully\"\n-    \/\/   increase the array size (:-)\n-    \/\/   remove the oldest entry (this might allow more GC time for\n-    \/\/     the time slice than what's allowed) - this is what we\n-    \/\/     currently do\n-    \/\/   consolidate the two entries with the minimum gap between them\n-    \/\/     (this might allow less GC time than what's allowed)\n-\n-    \/\/ In the case where ScavengeALot is true, such overflow is not\n-    \/\/ uncommon; in such cases, we can, without much loss of precision\n-    \/\/ or performance (we are GC'ing most of the time anyway!),\n-    \/\/ simply overwrite the oldest entry in the tracker.\n-\n-    _head_index = trim_index(_head_index + 1);\n-    assert(_head_index == _tail_index, \"Because we have a full circular buffer\");\n-    _tail_index = trim_index(_tail_index + 1);\n-  } else {\n-    _head_index = trim_index(_head_index + 1);\n-    ++_no_entries;\n-  }\n-  _array[_head_index] = G1MMUTrackerQueueElem(start, end);\n-\n-  \/\/ Current entry needs to be added before calculating the value\n-  double slice_time = calculate_gc_time(end);\n-  G1MMUTracer::report_mmu(_time_slice, slice_time, _max_gc_time);\n-\n-  if (slice_time < _max_gc_time) {\n-    log_debug(gc, mmu)(\"MMU: %.1lfms (%.1lfms\/%.1lfms)\",\n-                       slice_time * 1000.0, _max_gc_time * 1000.0, _time_slice * 1000);\n-  } else {\n-    log_info(gc, mmu)(\"MMU target violated: %.1lfms (%.1lfms\/%.1lfms)\",\n-                      slice_time * 1000.0, _max_gc_time * 1000.0, _time_slice * 1000);\n-  }\n-}\n-\n-double G1MMUTrackerQueue::when_sec(double current_time, double pause_time) {\n-  \/\/ if the pause is over the maximum, just assume that it's the maximum\n-  double adjusted_pause_time =\n-    (pause_time > max_gc_time()) ? max_gc_time() : pause_time;\n-  double earliest_end = current_time + adjusted_pause_time;\n-  double limit = earliest_end - _time_slice;\n-  double gc_time = calculate_gc_time(earliest_end);\n-  double diff = gc_time + adjusted_pause_time - max_gc_time();\n-  if (is_double_leq_0(diff))\n-    return 0.0;\n-\n-  if (adjusted_pause_time == max_gc_time()) {\n-    G1MMUTrackerQueueElem *elem = &_array[_head_index];\n-    return elem->end_time() - limit;\n-  }\n-\n-  int index = _tail_index;\n-  while ( 1 ) {\n-    G1MMUTrackerQueueElem *elem = &_array[index];\n-    if (elem->end_time() > limit) {\n-      if (elem->start_time() > limit)\n-        diff -= elem->duration();\n-      else\n-        diff -= elem->end_time() - limit;\n-      if (is_double_leq_0(diff))\n-        return elem->end_time() + diff - limit;\n-    }\n-    index = trim_index(index+1);\n-    guarantee(index != trim_index(_head_index + 1), \"should not go past head\");\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MMUTrackerQueue.cpp","additions":0,"deletions":144,"binary":false,"changes":144,"status":"deleted"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1MMUTRACKERQUEUE_HPP\n-#define SHARE_GC_G1_G1MMUTRACKERQUEUE_HPP\n-\n-#include \"gc\/shared\/gcId.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"utilities\/debug.hpp\"\n-\n-class G1MMUTrackerQueueElem {\n-private:\n-  double _start_time;\n-  double _end_time;\n-\n-public:\n-  inline double start_time() { return _start_time; }\n-  inline double end_time()   { return _end_time; }\n-  inline double duration()   { return _end_time - _start_time; }\n-\n-  G1MMUTrackerQueueElem() {\n-    _start_time = 0.0;\n-    _end_time   = 0.0;\n-  }\n-\n-  G1MMUTrackerQueueElem(double start_time, double end_time) {\n-    _start_time = start_time;\n-    _end_time   = end_time;\n-  }\n-};\n-\n-\n-\/\/ This implementation uses a fixed-size queue to keep track of all\n-\/\/ recent pause times. Two major user controls over G1 behavior are\n-\/\/ setting a pause time goal (MaxGCPauseMillis), over a time slice\n-\/\/ (GCPauseIntervalMillis). This defines the Minimum Mutator\n-\/\/ Utilisation (MMU) goal.\n-\/\/\n-\/\/ * Definitions *\n-\/\/ Mutator Utilisation:\n-\/\/ - for a given time slice duration \"ts\",\n-\/\/ - mutator utilisation is the following fraction:\n-\/\/     non_gc_time \/ ts\n-\/\/\n-\/\/ Minimum Mutator Utilisation (MMU):\n-\/\/ - the worst mutator utilisation across all time slices.\n-\/\/\n-\/\/ ***** ALL TIMES ARE IN SECS!!!!!!! *****\n-class G1MMUTrackerQueue: public CHeapObj<mtGC> {\n-private:\n-  enum PrivateConstants {\n-    QueueLength = 64\n-  };\n-\n-  double                _time_slice;\n-  double                _max_gc_time; \/\/ this is per time slice\n-\n-  \/\/ The array keeps track of all the pauses that fall within a time\n-  \/\/ slice (the last time slice during which pauses took place).\n-  \/\/ The data structure implemented is a circular queue.\n-  \/\/ Head \"points\" to the most recent addition, tail to the oldest one.\n-  \/\/ The array is of fixed size and I don't think we'll need more than\n-  \/\/ two or three entries with the current behavior of G1 pauses.\n-  \/\/ If the array is full, an easy fix is to look for the pauses with\n-  \/\/ the shortest gap between them and consolidate them.\n-  \/\/ For now, we have taken the expedient alternative of forgetting\n-  \/\/ the oldest entry in the event that +G1UseFixedWindowMMUTracker, thus\n-  \/\/ potentially violating MMU specs for some time thereafter.\n-\n-  G1MMUTrackerQueueElem _array[QueueLength];\n-  int                   _head_index;\n-  int                   _tail_index;\n-  int                   _no_entries;\n-\n-  inline int trim_index(int index) {\n-    return (index + QueueLength) % QueueLength;\n-  }\n-\n-  void remove_expired_entries(double current_time);\n-  double calculate_gc_time(double current_time);\n-\n-public:\n-  G1MMUTrackerQueue(double time_slice, double max_gc_time);\n-\n-  void add_pause(double start, double end);\n-\n-  double when_sec(double current_time, double pause_time);\n-\n-  double max_gc_time() const {\n-    return _max_gc_time;\n-  }\n-\n-  inline double when_max_gc_sec(double current_time) {\n-    return when_sec(current_time, max_gc_time());\n-  }\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1MMUTRACKERQUEUE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MMUTrackerQueue.hpp","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -59,1 +59,1 @@\n-  _mmu_tracker(new G1MMUTrackerQueue(GCPauseIntervalMillis \/ 1000.0, MaxGCPauseMillis \/ 1000.0)),\n+  _mmu_tracker(new G1MMUTracker(GCPauseIntervalMillis \/ 1000.0, MaxGCPauseMillis \/ 1000.0)),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"gc\/g1\/g1MMUTrackerQueue.hpp\"\n+#include \"gc\/g1\/g1MMUTracker.hpp\"\n@@ -70,1 +70,1 @@\n-  G1MMUTrackerQueue* _mmu_tracker;\n+  G1MMUTracker* _mmu_tracker;\n@@ -157,1 +157,1 @@\n-  G1MMUTrackerQueue* mmu_tracker() {\n+  G1MMUTracker* mmu_tracker() {\n@@ -161,1 +161,1 @@\n-  const G1MMUTrackerQueue* mmu_tracker() const {\n+  const G1MMUTracker* mmu_tracker() const {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}