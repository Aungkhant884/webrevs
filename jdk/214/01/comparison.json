{"files":[{"patch":"@@ -42,4 +42,1 @@\n-  _max_gc_time(max_gc_time) { }\n-\n-G1MMUTrackerQueue::G1MMUTrackerQueue(double time_slice, double max_gc_time) :\n-  G1MMUTracker(time_slice, max_gc_time),\n+  _max_gc_time(max_gc_time),\n@@ -50,1 +47,1 @@\n-void G1MMUTrackerQueue::remove_expired_entries(double current_time) {\n+void G1MMUTracker::remove_expired_entries(double current_time) {\n@@ -62,1 +59,1 @@\n-double G1MMUTrackerQueue::calculate_gc_time(double current_time) {\n+double G1MMUTracker::calculate_gc_time(double current_time) {\n@@ -67,1 +64,1 @@\n-    G1MMUTrackerQueueElem *elem = &_array[index];\n+    G1MMUTrackerElem *elem = &_array[index];\n@@ -78,1 +75,1 @@\n-void G1MMUTrackerQueue::add_pause(double start, double end) {\n+void G1MMUTracker::add_pause(double start, double end) {\n@@ -102,1 +99,1 @@\n-  _array[_head_index] = G1MMUTrackerQueueElem(start, end);\n+  _array[_head_index] = G1MMUTrackerElem(start, end);\n@@ -117,1 +114,1 @@\n-double G1MMUTrackerQueue::when_sec(double current_time, double pause_time) {\n+double G1MMUTracker::when_sec(double current_time, double pause_time) {\n@@ -129,1 +126,1 @@\n-    G1MMUTrackerQueueElem *elem = &_array[_head_index];\n+    G1MMUTrackerElem *elem = &_array[_head_index];\n@@ -135,1 +132,1 @@\n-    G1MMUTrackerQueueElem *elem = &_array[index];\n+    G1MMUTrackerElem *elem = &_array[index];\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MMUTracker.cpp","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,39 +32,1 @@\n-\/\/ Two major user controls over G1 behavior are setting a pause time goal (MaxGCPauseMillis),\n-\/\/ over a time slice (GCPauseIntervalMillis). This defines the Minimum Mutator\n-\/\/ Utilisation (MMU) goal.\n-\/\/\n-\/\/ * Definitions *\n-\/\/ Mutator Utilisation:\n-\/\/ - for a given time slice duration \"ts\",\n-\/\/ - mutator utilisation is the following fraction:\n-\/\/     non_gc_time \/ ts\n-\/\/\n-\/\/ Minimum Mutator Utilisation (MMU):\n-\/\/ - the worst mutator utilisation across all time slices.\n-\/\/\n-\/\/ G1MMUTracker keeps track of the GC work and decides when it is OK to do GC work\n-\/\/ and for how long so that the MMU invariants are maintained.\n-\/\/\n-\/\/ ***** ALL TIMES ARE IN SECS!!!!!!! *****\n-\/\/ this is the \"interface\"\n-class G1MMUTracker: public CHeapObj<mtGC> {\n-protected:\n-  double          _time_slice;\n-  double          _max_gc_time; \/\/ this is per time slice\n-\n-public:\n-  G1MMUTracker(double time_slice, double max_gc_time);\n-\n-  virtual void add_pause(double start, double end) = 0;\n-  virtual double when_sec(double current_time, double pause_time) = 0;\n-\n-  double max_gc_time() const {\n-    return _max_gc_time;\n-  }\n-\n-  inline double when_max_gc_sec(double current_time) {\n-    return when_sec(current_time, max_gc_time());\n-  }\n-};\n-\n-class G1MMUTrackerQueueElem {\n+class G1MMUTrackerElem {\n@@ -80,1 +42,1 @@\n-  G1MMUTrackerQueueElem() {\n+  G1MMUTrackerElem() {\n@@ -85,1 +47,1 @@\n-  G1MMUTrackerQueueElem(double start_time, double end_time) {\n+  G1MMUTrackerElem(double start_time, double end_time) {\n@@ -91,3 +53,18 @@\n-\/\/ this is an implementation of the MMUTracker using a (fixed-size) queue\n-\/\/ that keeps track of all the recent pause times\n-class G1MMUTrackerQueue: public G1MMUTracker {\n+\n+\/\/ This implementation uses a fixed-size queue to keep track of all\n+\/\/ recent pause times. Two major user controls over G1 behavior are\n+\/\/ setting a pause time goal (MaxGCPauseMillis), over a time slice\n+\/\/ (GCPauseIntervalMillis). This defines the Minimum Mutator\n+\/\/ Utilisation (MMU) goal.\n+\/\/\n+\/\/ * Definitions *\n+\/\/ Mutator Utilisation:\n+\/\/ - for a given time slice duration \"ts\",\n+\/\/ - mutator utilisation is the following fraction:\n+\/\/     non_gc_time \/ ts\n+\/\/\n+\/\/ Minimum Mutator Utilisation (MMU):\n+\/\/ - the worst mutator utilisation across all time slices.\n+\/\/\n+\/\/ ***** ALL TIMES ARE IN SECS!!!!!!! *****\n+class G1MMUTracker: public CHeapObj<mtGC> {\n@@ -99,0 +76,3 @@\n+  double                _time_slice;\n+  double                _max_gc_time; \/\/ this is per time slice\n+\n@@ -111,1 +91,1 @@\n-  G1MMUTrackerQueueElem _array[QueueLength];\n+  G1MMUTrackerElem _array[QueueLength];\n@@ -124,1 +104,3 @@\n-  G1MMUTrackerQueue(double time_slice, double max_gc_time);\n+  G1MMUTracker(double time_slice, double max_gc_time);\n+\n+  void add_pause(double start, double end);\n@@ -126,1 +108,1 @@\n-  virtual void add_pause(double start, double end);\n+  double when_sec(double current_time, double pause_time);\n@@ -128,1 +110,7 @@\n-  virtual double when_sec(double current_time, double pause_time);\n+  double max_gc_time() const {\n+    return _max_gc_time;\n+  }\n+\n+  inline double when_max_gc_sec(double current_time) {\n+    return when_sec(current_time, max_gc_time());\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MMUTracker.hpp","additions":37,"deletions":49,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  _mmu_tracker(new G1MMUTrackerQueue(GCPauseIntervalMillis \/ 1000.0, MaxGCPauseMillis \/ 1000.0)),\n+  _mmu_tracker(new G1MMUTracker(GCPauseIntervalMillis \/ 1000.0, MaxGCPauseMillis \/ 1000.0)),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}