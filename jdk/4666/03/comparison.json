{"files":[{"patch":"@@ -62,1 +62,1 @@\n-                            writeHeapRecordPrologue();\n+                            writeHeapRecordPrologue(calculateOopDumpRecordSize(oop));\n@@ -130,0 +130,12 @@\n+    protected int calculateGlobalJNIHandlesDumpRecordSize() {\n+        return 0;\n+    }\n+\n+    protected int calculateJavaThreadsDumpRecordSize() {\n+        return 0;\n+    }\n+\n+    protected int calculateOopDumpRecordSize(Oop oop) throws IOException {\n+        return 0;\n+    }\n+\n@@ -423,0 +435,3 @@\n+    protected void writeHeapRecordPrologue(int size) throws IOException {\n+    }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/AbstractHeapGraphWriter.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -410,1 +410,0 @@\n-        hprofBufferedOut = null;\n@@ -412,0 +411,1 @@\n+        hprofBufferedOut = dataOut;\n@@ -420,3 +420,1 @@\n-            hprofBufferedOut = new SegmentedOutputStream(dataOut);\n-        } else {\n-            hprofBufferedOut = new SegmentedOutputStream(fos, false \/* allowSegmented *\/);\n+            hprofBufferedOut = dataOut;\n@@ -473,1 +471,0 @@\n-\n@@ -475,1 +472,0 @@\n-            \/\/ Fill in final length.\n@@ -478,1 +474,0 @@\n-            hprofBufferedOut.finish();\n@@ -484,1 +479,0 @@\n-\n@@ -490,0 +484,179 @@\n+        currentSegmentStart = 0;\n+    }\n+\n+    protected int calculateOopDumpRecordSize(Oop oop) throws IOException {\n+        if (oop instanceof TypeArray) {\n+            return calculatePrimitiveArrayDumpRecordSize((TypeArray)oop);\n+        } else if (oop instanceof ObjArray) {\n+            Klass klass = oop.getKlass();\n+            ObjArrayKlass oak = (ObjArrayKlass) klass;\n+            Klass bottomType = oak.getBottomKlass();\n+            if (bottomType instanceof InstanceKlass ||\n+                    bottomType instanceof TypeArrayKlass) {\n+                return calculateObjectArrayDumpRecordSize((ObjArray)oop);\n+            } else {\n+                \/\/ internal object, nothing to write.\n+                return 0;\n+            }\n+        } else if (oop instanceof Instance) {\n+            Instance instance = (Instance) oop;\n+            Klass klass = instance.getKlass();\n+            Symbol name = klass.getName();\n+            if (name.equals(javaLangString)) {\n+                return calculateStringDumpRecordSize(instance);\n+            } else if (name.equals(javaLangClass)) {\n+                return calculateClassInstanceDumpRecordSize(instance);\n+            } else if (name.equals(javaLangThread)) {\n+                return calculateThreadDumpRecordSize(instance);\n+            } else {\n+                klass = klass.getSuper();\n+                while (klass != null) {\n+                    name = klass.getName();\n+                    if (name.equals(javaLangThread)) {\n+                        return calculateThreadDumpRecordSize(instance);\n+                    }\n+                    klass = klass.getSuper();\n+                }\n+                return calculateInstanceDumpRecordSize(instance);\n+            }\n+        } else {\n+            \/\/ not-a-Java-visible oop\n+            return 0;\n+        }\n+    }\n+\n+    private int calculateInstanceDumpRecordSize(Instance instance) {\n+        Klass klass = instance.getKlass();\n+        if (klass.getClassLoaderData() == null) {\n+            \/\/ Ignoring this object since the corresponding Klass is not loaded.\n+            \/\/ Might be a dormant archive object.\n+            return 0;\n+        }\n+\n+        ClassData cd = (ClassData) classDataCache.get(klass);\n+        if (Assert.ASSERTS_ENABLED) {\n+            Assert.that(cd != null, \"can not get class data for \" + klass.getName().asString() + klass.getAddress());\n+        }\n+        List<Field> fields = cd.fields;\n+        return (int) BYTE_SIZE + (int)OBJ_ID_SIZE * 2 + (int)INT_SIZE * 2 + getSizeForFields(fields);\n+    }\n+\n+    private int calculateThreadDumpRecordSize(Instance instance) {\n+        return calculateInstanceDumpRecordSize(instance);\n+    }\n+\n+    private int calculateClassDumpRecordSize(Klass k) throws IOException {\n+\n+        int size = (int)BYTE_SIZE + (int)INT_SIZE + (int)OBJ_ID_SIZE * 2;\n+\n+        if (k instanceof InstanceKlass) {\n+            InstanceKlass ik = (InstanceKlass) k;\n+            List<Field> fields = getInstanceFields(ik);\n+            List<Field> declaredFields = ik.getImmediateFields();\n+            List<Field> staticFields = new ArrayList<>();\n+            List<Field> instanceFields = new ArrayList<>();\n+            Iterator<Field> itr = null;\n+\n+            size += OBJ_ID_SIZE * 5 + INT_SIZE + SHORT_SIZE;\n+\n+            for (itr = declaredFields.iterator(); itr.hasNext();) {\n+                Field field = itr.next();\n+                if (field.isStatic()) {\n+                    staticFields.add(field);\n+                } else {\n+                    instanceFields.add(field);\n+                }\n+            }\n+\n+            \/\/ size of static field descriptors\n+            size += calculateFieldDescriptorsDumpRecordSize(staticFields, ik);\n+\n+            \/\/ size of instance field descriptors\n+            size += calculateFieldDescriptorsDumpRecordSize(instanceFields, null);\n+        } else {\n+            size += OBJ_ID_SIZE * 5  + INT_SIZE + SHORT_SIZE * 3;\n+        }\n+        return size;\n+    }\n+\n+    private int calculateFieldDescriptorsDumpRecordSize(List<Field> fields, InstanceKlass ik)\n+            throws IOException {\n+        int size = 0;\n+        \/\/ ik == null for instance fields.\n+        size += SHORT_SIZE;\n+        for (Iterator<Field> itr = fields.iterator(); itr.hasNext();) {\n+            Field field = itr.next();\n+            char typeCode = (char) field.getSignature().getByteAt(0);\n+            size += OBJ_ID_SIZE + BYTE_SIZE;\n+            if (ik != null) {\n+                \/\/ static field\n+                size += calculateFieldDumpRecordSize(field, ik.getJavaMirror());\n+            }\n+        }\n+        return size;\n+    }\n+\n+    private int calculateFieldDumpRecordSize(Field field, Oop oop) throws IOException {\n+        char typeCode = (char) field.getSignature().getByteAt(0);\n+        int size = 0;\n+        switch (typeCode) {\n+            case JVM_SIGNATURE_BOOLEAN:\n+            case JVM_SIGNATURE_BYTE:\n+                size++;\n+                break;\n+            case JVM_SIGNATURE_CHAR:\n+            case JVM_SIGNATURE_SHORT:\n+                size += 2;\n+                break;\n+            case JVM_SIGNATURE_INT:\n+            case JVM_SIGNATURE_FLOAT:\n+                size += 4;\n+                break;\n+            case JVM_SIGNATURE_CLASS:\n+            case JVM_SIGNATURE_ARRAY:\n+                size += OBJ_ID_SIZE;\n+                break;\n+            case JVM_SIGNATURE_LONG:\n+            case JVM_SIGNATURE_DOUBLE:\n+                size += 8;\n+                break;\n+            default:\n+                throw new RuntimeException(\"should not reach here\");\n+        }\n+        return size;\n+    }\n+\n+    private int calculateClassInstanceDumpRecordSize(Instance instance) {\n+        Klass reflectedKlass = java_lang_Class.asKlass(instance);\n+        \/\/ dump instance record only for primitive type Class objects.\n+        \/\/ all other Class objects are covered by writeClassDumpRecords.\n+        if (reflectedKlass == null) {\n+            return calculateInstanceDumpRecordSize(instance);\n+        }\n+        return 0;\n+    }\n+\n+    private int calculateStringDumpRecordSize(Instance instance) {\n+        return calculateInstanceDumpRecordSize(instance);\n+    }\n+\n+    private int calculateObjectArrayDumpRecordSize(ObjArray array) throws IOException {\n+        int headerSize = getArrayHeaderSize(true);\n+        final int length = calculateArrayMaxLength(array.getLength(),\n+                headerSize,\n+                OBJ_ID_SIZE,\n+                \"Object\");\n+        return headerSize + length * OBJ_ID_SIZE;\n+    }\n+\n+    private int calculatePrimitiveArrayDumpRecordSize(TypeArray array) throws IOException {\n+        int headerSize = getArrayHeaderSize(false);\n+        TypeArrayKlass tak = (TypeArrayKlass) array.getKlass();\n+        final int type = (int) tak.getElementType();\n+        final String typeName = tak.getElementTypeName();\n+        final long typeSize = getSizeForType(type);\n+        final int length = calculateArrayMaxLength(array.getLength(),\n+                                                   headerSize,\n+                                                   typeSize,\n+                                                   typeName);\n+        return headerSize + (int)typeSize * length;\n@@ -493,1 +666,5 @@\n-    protected void writeHeapRecordPrologue() throws IOException {\n+    protected void writeHeapRecordPrologue(int size) throws IOException {\n+        if (size == 0 || (currentSegmentStart > 0)) {\n+            return;\n+        }\n+        \/\/ write heap data header\n@@ -495,3 +672,4 @@\n-            hprofBufferedOut.enterSegmentMode();\n-        } else if (currentSegmentStart == 0) {\n-            \/\/ write heap data header\n+            out.writeByte((byte)HPROF_HEAP_DUMP_SEGMENT);\n+            out.writeInt(0);\n+            out.writeInt(size);\n+        } else {\n@@ -500,4 +678,1 @@\n-\n-            \/\/ remember position of dump length, we will fixup\n-            \/\/ length later - hprof format requires length.\n-            out.flush();\n+            \/\/ record position of the length slot\n@@ -505,1 +680,1 @@\n-            \/\/ write dummy length of 0 and we'll fix it later.\n+            \/\/ write dummy zero for length\n@@ -511,5 +686,1 @@\n-    protected void writeHeapRecordEpilogue() throws IOException {\n-        if (useSegmentedHeapDump) {\n-            hprofBufferedOut.exitSegmentMode();\n-        }\n-    }\n+    protected void writeHeapRecordEpilogue() throws IOException { }\n@@ -577,1 +748,2 @@\n-    \/\/ Check if we need to truncate an array\n+    \/\/ Check if we need to truncate an array.\n+    \/\/ The limitation is that the size of \"heap dump\" or \"heap dump segment\" must be <= MAX_U4_VALUE\n@@ -585,2 +757,0 @@\n-        \/\/ now get the current position to calculate length\n-        long dumpEnd = fos.getChannel().position();\n@@ -589,12 +759,0 @@\n-        \/\/ calculate the length of heap data\n-        \/\/ only process when segmented heap dump is not used, since SegmentedOutputStream\n-        \/\/ could create segment automatically.\n-        long currentRecordLength = (dumpEnd - currentSegmentStart - 4L);\n-        if ((!useSegmentedHeapDump) && currentRecordLength > 0 &&\n-            (currentRecordLength + headerSize + originalLengthInBytes) > MAX_U4_VALUE) {\n-            fillInHeapRecordLength();\n-            currentSegmentStart = 0;\n-            writeHeapRecordPrologue();\n-            currentRecordLength = 0;\n-        }\n-\n@@ -602,1 +760,1 @@\n-        long maxBytes = (MAX_U4_VALUE - (headerSize + currentRecordLength));\n+        long maxBytes = (MAX_U4_VALUE - headerSize);\n@@ -619,1 +777,1 @@\n-                                    writeHeapRecordPrologue();\n+                                    writeHeapRecordPrologue(calculateClassDumpRecordSize(k));\n@@ -788,0 +946,2 @@\n+        int size = (int)BYTE_SIZE + (int)OBJ_ID_SIZE + (int)INT_SIZE * 2;\n+        writeHeapRecordPrologue(size);\n@@ -792,0 +952,1 @@\n+\n@@ -808,0 +969,2 @@\n+                                           int size = (int)BYTE_SIZE + (int)OBJ_ID_SIZE + (int)INT_SIZE * 2;\n+                                           writeHeapRecordPrologue(size);\n@@ -834,0 +997,2 @@\n+            int size = (int)BYTE_SIZE + (int)OBJ_ID_SIZE * 2;\n+            writeHeapRecordPrologue(size);\n@@ -1268,1 +1433,1 @@\n-    private SegmentedOutputStream hprofBufferedOut;\n+    private OutputStream hprofBufferedOut;\n@@ -1311,217 +1476,0 @@\n-\n-    \/**\n-     * The class implements a buffered output stream for segmented data dump.\n-     * It is used inside HeapHprofBinWritter only for heap dump.\n-     * Because the current implementation of segmented heap dump needs to update\n-     * the segment size at segment header, and because it is hard to modify the\n-     * compressed data after they are written to file, this class first saves the\n-     * uncompressed data into an internal buffer, and then writes through to the\n-     * GZIPOutputStream when the whole segmented data are ready and the size is updated.\n-     * If the data to be written are larger than internal buffer, or the internal buffer\n-     * is full, the internal buffer will be extend to a larger one.\n-     * This class defines a switch to turn on\/off the segmented mode. If turned off,\n-     * it behaves the same as BufferedOutputStream.\n-     * *\/\n-    private class SegmentedOutputStream extends BufferedOutputStream {\n-        \/**\n-         * Creates a new buffered output stream to support segmented heap dump data.\n-         *\n-         * @param   out                 the underlying output stream.\n-         * @param   allowSegmented      whether allow segmental dump.\n-         *\/\n-        public SegmentedOutputStream(OutputStream out, boolean allowSegmented) {\n-            super(out, 8192);\n-            segmentMode = false;\n-            this.allowSegmented = allowSegmented;\n-            segmentBuffer = new byte[SEGMENT_BUFFER_SIZE];\n-            segmentWritten = 0;\n-        }\n-\n-        \/**\n-         * Creates a new buffered output stream to support segmented heap dump data.\n-         *\n-         * @param   out      the underlying output stream.\n-         *\/\n-        public SegmentedOutputStream(OutputStream out) {\n-            this(out, true);\n-        }\n-\n-        \/**\n-         * Writes the specified byte to this buffered output stream.\n-         *\n-         * @param      b   the byte to be written.\n-         * @throws     IOException  if an I\/O error occurs.\n-         *\/\n-        @Override\n-        public synchronized void write(int b) throws IOException {\n-           if (segmentMode) {\n-               if (segmentWritten == 0) {\n-                   \/\/ At the begining of the segment.\n-                   writeSegmentHeader();\n-               } else if (segmentWritten == segmentBuffer.length) {\n-                   \/\/ Internal buffer is full, extend a larger one.\n-                   int newSize = segmentBuffer.length + SEGMENT_BUFFER_INC_SIZE;\n-                   byte newBuf[] = new byte[newSize];\n-                   System.arraycopy(segmentBuffer, 0, newBuf, 0, segmentWritten);\n-                   segmentBuffer = newBuf;\n-               }\n-               segmentBuffer[segmentWritten++] = (byte)b;\n-               return;\n-           }\n-           super.write(b);\n-        }\n-\n-        \/**\n-         * Writes {@code len} bytes from the specified byte array\n-         * starting at offset {@code off} to this output stream.\n-         *\n-         * @param      b     the data.\n-         * @param      off   the start offset in the data.\n-         * @param      len   the number of bytes to write.\n-         * @throws     IOException  if an I\/O error occurs.\n-         *\/\n-        @Override\n-        public synchronized void write(byte b[], int off, int len) throws IOException {\n-            if (segmentMode) {\n-                if (segmentWritten == 0) {\n-                    writeSegmentHeader();\n-                }\n-                \/\/ Data size is larger than segment buffer length, extend segment buffer.\n-                if (segmentWritten + len > segmentBuffer.length) {\n-                    int newSize = segmentBuffer.length + Math.max(SEGMENT_BUFFER_INC_SIZE, len);\n-                    byte newBuf[] = new byte[newSize];\n-                    System.arraycopy(segmentBuffer, 0, newBuf, 0, segmentWritten);\n-                    segmentBuffer = newBuf;\n-                }\n-                System.arraycopy(b, off, segmentBuffer, segmentWritten, len);\n-                segmentWritten += len;\n-                return;\n-            }\n-            super.write(b, off, len);\n-        }\n-\n-        \/**\n-         * Flushes this buffered output stream. This forces any buffered\n-         * output bytes to be written out to the underlying output stream.\n-         *\n-         * @throws     IOException  if an I\/O error occurs.\n-         * @see        java.io.FilterOutputStream#out\n-         *\/\n-        @Override\n-        public synchronized void flush() throws IOException {\n-            if (segmentMode) {\n-                \/\/ The case that nothing has been written in segment.\n-                if (segmentWritten == 0) return;\n-                \/\/ There must be more data than just header size written for non-empty segment.\n-                assert segmentWritten > SEGMENT_HEADER_SIZE\n-                        : \"invalid header in segmented mode\";\n-\n-                if (segmentWritten > (segmentBuffer.length)) {\n-                    throw new RuntimeException(\"Heap segment size overflow.\");\n-                }\n-\n-                if (segmentWritten > SEGMENT_HEADER_SIZE) {\n-                    fillSegmentSize(segmentWritten - SEGMENT_HEADER_SIZE);\n-                    super.write(segmentBuffer, 0, segmentWritten);\n-                    super.flush();\n-                    segmentWritten = 0;\n-                }\n-                return;\n-            }\n-            super.flush();\n-        }\n-\n-        \/**\n-         * Enters segmented mode, flush buffered data and set flag.\n-         *\/\n-        public void enterSegmentMode() throws IOException {\n-            if (allowSegmented && !segmentMode && segmentWritten == 0) {\n-                super.flush();\n-                segmentMode = true;\n-                segmentWritten = 0;\n-            }\n-        }\n-\n-        \/**\n-         * Before finish, flush all data in buffer.\n-         *\/\n-        public void finish() throws IOException {\n-            if (allowSegmented && segmentMode) {\n-                flush();\n-                assert segmentWritten == 0;\n-                segmentMode = false;\n-            }\n-        }\n-\n-        \/**\n-         * Exits segmented mode, flush segmented data.\n-         * @param    force    flush data regardless whether the buffer is full\n-         *\/\n-        public void exitSegmentMode() throws IOException {\n-            if (allowSegmented && segmentMode && shouldFlush()) {\n-                flush();\n-                assert segmentWritten == 0;\n-                segmentMode = false;\n-            }\n-        }\n-\n-\n-        \/**\n-         * Check whether the data should be flush based on data saved in\n-         * segmentBuffer.\n-         * This method is used to control the segments number and the memory usage.\n-         * If segment is too small, there will be lots segments in final dump file.\n-         * If it is too large, lots of memory is used in RAM.\n-         *\/\n-        private boolean shouldFlush() {\n-            \/\/ return true if data in segmentBuffer has been extended.\n-            return segmentWritten > SEGMENT_BUFFER_SIZE;\n-        }\n-\n-        \/**\n-         * Writes the write segment header into internal buffer.\n-         *\/\n-        private void writeSegmentHeader() {\n-            assert segmentWritten == 0;\n-            segmentBuffer[segmentWritten++] = (byte)HPROF_HEAP_DUMP_SEGMENT;\n-            writeInteger(0);\n-            \/\/ segment size, write dummy length of 0 and we'll fix it later.\n-            writeInteger(0);\n-        }\n-\n-        \/**\n-         * Fills the segmented data size into the header.\n-         *\/\n-        private void fillSegmentSize(int size) {\n-            byte[] lenBytes = genByteArrayFromInt(size);\n-            System.arraycopy(lenBytes, 0, segmentBuffer, 5, 4);\n-        }\n-\n-        \/**\n-         * Writes an {@code int} to the internal segment buffer\n-         * {@code written} is incremented by {@code 4}.\n-         *\/\n-        private final void writeInteger(int value) {\n-            byte[] intBytes = genByteArrayFromInt(value);\n-            System.arraycopy(intBytes, 0, segmentBuffer, segmentWritten, 4);\n-            segmentWritten += 4;\n-        }\n-\n-        \/\/ The buffer size for segmentBuffer.\n-        \/\/ Since it is hard to calculate and fill the data size of an segment in compressed\n-        \/\/ data, making the segmented data stored in this buffer could help rewrite the data\n-        \/\/ size before the segmented data are written to underlying GZIPOutputStream.\n-        private static final int SEGMENT_BUFFER_SIZE = 1 << 20;\n-        \/\/ Buffer size used to extend the segment buffer.\n-        private static final int SEGMENT_BUFFER_INC_SIZE = 1 << 10;\n-        \/\/ Headers:\n-        \/\/    1 byte for HPROF_HEAP_DUMP_SEGMENT\n-        \/\/    4 bytes for timestamp\n-        \/\/    4 bytes for size\n-        private static final int SEGMENT_HEADER_SIZE = 9;\n-        \/\/ Segment support.\n-        private boolean segmentMode;\n-        private boolean allowSegmented;\n-        private byte segmentBuffer[];\n-        private int segmentWritten;\n-    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/HeapHprofBinWriter.java","additions":205,"deletions":257,"binary":false,"changes":462,"status":"modified"},{"patch":"@@ -111,1 +111,0 @@\n-resourcehogs\/serviceability\/sa\/TestHeapDumpForLargeArray.java 8262386 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}