{"files":[{"patch":"@@ -199,2 +199,2 @@\n-        DerInputStream dis = new DerInputStream(content.toByteArray());\n-        return dis.getOctetString();\n+        DerValue v = new DerValue(content.toByteArray());\n+        return v.getOctetString();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/ContentInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+import java.security.interfaces.EdECPrivateKey;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.security.spec.PSSParameterSpec;\n@@ -38,0 +41,1 @@\n+import java.util.function.Function;\n@@ -39,0 +43,1 @@\n+import sun.security.provider.SHAKE256;\n@@ -41,5 +46,1 @@\n-import sun.security.x509.AlgorithmId;\n-import sun.security.x509.X509CertImpl;\n-import sun.security.x509.X509CertInfo;\n-import sun.security.x509.X509CRLImpl;\n-import sun.security.x509.X500Name;\n+import sun.security.x509.*;\n@@ -89,10 +90,0 @@\n-    \/*\n-     * Object identifier for the timestamping key purpose.\n-     *\/\n-    private static final String KP_TIMESTAMPING_OID = \"1.3.6.1.5.5.7.3.8\";\n-\n-    \/*\n-     * Object identifier for extendedKeyUsage extension\n-     *\/\n-    private static final String EXTENDED_KEY_USAGE_OID = \"2.5.29.37\";\n-\n@@ -181,3 +172,3 @@\n-        contentInfo = new ContentInfo(derin, oldStyle);\n-        contentType = contentInfo.contentType;\n-        DerValue content = contentInfo.getContent();\n+        ContentInfo block = new ContentInfo(derin, oldStyle);\n+        contentType = block.contentType;\n+        DerValue content = block.getContent();\n@@ -776,0 +767,122 @@\n+    \/**\n+     * Generate a PKCS7 data block.\n+     *\n+     * @param sigalg signature algorithm to be used\n+     * @param sigProvider (optional) provider\n+     * @param privateKey signer's private ky\n+     * @param signerChain signer's certificate chain\n+     * @param content the content to sign\n+     * @param internalsf whether the content should be include in output\n+     * @param directsign if the content is signed directly or thru authattrs\n+     * @param ts (optional) timestamper\n+     * @return the pkcs7 output in an array\n+     * @throws SignatureException if signing failed\n+     * @throws InvalidKeyException if key cannot be used\n+     * @throws IOException should not happen here, all byte array\n+     * @throws NoSuchAlgorithmException if siglag is bad\n+     *\/\n+    public static byte[] generateNewSignedData(\n+            String sigalg, Provider sigProvider,\n+            PrivateKey privateKey, X509Certificate[] signerChain,\n+            byte[] content, boolean internalsf, boolean directsign,\n+            Function<byte[], PKCS9Attributes> ts)\n+                throws SignatureException, InvalidKeyException, IOException,\n+                    NoSuchAlgorithmException {\n+\n+        Signature signer = SignatureUtil.fromKey(sigalg, privateKey, sigProvider);\n+\n+        AlgorithmId digAlgID = SignatureUtil.getDigestAlgInPkcs7SignerInfo(\n+                signer, sigalg, privateKey, directsign);\n+        AlgorithmId sigAlgID = SignatureUtil.fromSignature(signer, privateKey);\n+\n+        PKCS9Attributes authAttrs = null;\n+        if (!directsign) {\n+            \/\/ MessageDigest\n+            byte[] md;\n+            String digAlgName = digAlgID.getName();\n+            if (digAlgName.equals(\"SHAKE256\") || digAlgName.equals(\"SHAKE256-LEN\")) {\n+                \/\/ No MessageDigest impl for SHAKE256 yet\n+                var shaker = new SHAKE256(64);\n+                shaker.update(content, 0, content.length);\n+                md = shaker.digest();\n+            } else {\n+                md = MessageDigest.getInstance(digAlgName)\n+                        .digest(content);\n+            }\n+            \/\/ CMSAlgorithmProtection (RFC6211)\n+            DerOutputStream derAp = new DerOutputStream();\n+            DerOutputStream derAlgs = new DerOutputStream();\n+            digAlgID.derEncode(derAlgs);\n+            DerOutputStream derSigAlg = new DerOutputStream();\n+            sigAlgID.derEncode(derSigAlg);\n+            derAlgs.writeImplicit((byte)0xA1, derSigAlg);\n+            derAp.write(DerValue.tag_Sequence, derAlgs);\n+            authAttrs = new PKCS9Attributes(new PKCS9Attribute[]{\n+                    new PKCS9Attribute(PKCS9Attribute.CONTENT_TYPE_OID,\n+                            ContentInfo.DATA_OID),\n+                    new PKCS9Attribute(PKCS9Attribute.SIGNING_TIME_OID,\n+                            new Date()),\n+                    new PKCS9Attribute(PKCS9Attribute.CMS_ALGORITHM_PROTECTION_OID,\n+                            derAp.toByteArray()),\n+                    new PKCS9Attribute(PKCS9Attribute.MESSAGE_DIGEST_OID,\n+                            md)\n+            });\n+            signer.update(authAttrs.getDerEncoding());\n+        } else {\n+            signer.update(content);\n+        }\n+\n+        byte[] signature = signer.sign();\n+\n+        return constructToken(signature, signerChain,\n+                internalsf ? content : null,\n+                authAttrs,\n+                ts == null ? null : ts.apply(signature),\n+                digAlgID,\n+                sigAlgID);\n+    }\n+\n+    \/**\n+     * Assemble a PKCS7 token from its components\n+     * @param signature the signature\n+     * @param signerChain the signer's certificate chain\n+     * @param content (optional) encapsulated content\n+     * @param authAttrs (optional) authenticated attributes\n+     * @param unauthAttrs (optional) unauthenticated attributes\n+     * @param digAlgID digest algorithm identifier\n+     * @param encAlgID encryption algorithm identifier\n+     * @return the token in a byte array\n+     * @throws IOException should not happen here, all byte array\n+     *\/\n+    private static byte[] constructToken(byte[] signature,\n+                                         X509Certificate[] signerChain,\n+                                         byte[] content,\n+                                         PKCS9Attributes authAttrs,\n+                                         PKCS9Attributes unauthAttrs,\n+                                         AlgorithmId digAlgID,\n+                                         AlgorithmId encAlgID)\n+            throws IOException {\n+        \/\/ Create the SignerInfo\n+        X500Name issuerName =\n+                X500Name.asX500Name(signerChain[0].getIssuerX500Principal());\n+        BigInteger serialNumber = signerChain[0].getSerialNumber();\n+        SignerInfo signerInfo = new SignerInfo(issuerName, serialNumber,\n+                digAlgID, authAttrs,\n+                encAlgID,\n+                signature, unauthAttrs);\n+\n+        \/\/ Create the PKCS #7 signed data message\n+        SignerInfo[] signerInfos = {signerInfo};\n+        AlgorithmId[] algorithms = {signerInfo.getDigestAlgorithmId()};\n+        \/\/ Include or exclude content\n+        ContentInfo contentInfo = (content == null)\n+                ? new ContentInfo(ContentInfo.DATA_OID, null)\n+                : new ContentInfo(content);\n+        PKCS7 pkcs7 = new PKCS7(algorithms, contentInfo,\n+                signerChain, signerInfos);\n+        ByteArrayOutputStream p7out = new ByteArrayOutputStream();\n+        pkcs7.encodeSignedData(p7out);\n+\n+        return p7out.toByteArray();\n+    }\n+\n@@ -800,0 +913,1 @@\n+    @Deprecated(since=\"16\", forRemoval=true)\n@@ -827,14 +941,6 @@\n-        \/\/ Create the SignerInfo\n-        X500Name issuerName =\n-            X500Name.asX500Name(signerChain[0].getIssuerX500Principal());\n-        BigInteger serialNumber = signerChain[0].getSerialNumber();\n-        String encAlg = AlgorithmId.getEncAlgFromSigAlg(signatureAlgorithm);\n-        String digAlg = AlgorithmId.getDigAlgFromSigAlg(signatureAlgorithm);\n-        if (digAlg == null) {\n-            throw new UnsupportedOperationException(\"Unable to determine \" +\n-                    \"the digest algorithm from the signature algorithm.\");\n-        }\n-        SignerInfo signerInfo = new SignerInfo(issuerName, serialNumber,\n-                                               AlgorithmId.get(digAlg), null,\n-                                               AlgorithmId.get(encAlg),\n-                                               signature, unauthAttrs);\n+        return constructToken(signature, signerChain, content,\n+                null,\n+                unauthAttrs,\n+                AlgorithmId.get(SignatureUtil.extractDigestAlgFromDwithE(signatureAlgorithm)),\n+                AlgorithmId.get(signatureAlgorithm));\n+    }\n@@ -842,11 +948,11 @@\n-        \/\/ Create the PKCS #7 signed data message\n-        SignerInfo[] signerInfos = {signerInfo};\n-        AlgorithmId[] algorithms = {signerInfo.getDigestAlgorithmId()};\n-        \/\/ Include or exclude content\n-        ContentInfo contentInfo = (content == null)\n-            ? new ContentInfo(ContentInfo.DATA_OID, null)\n-            : new ContentInfo(content);\n-        PKCS7 pkcs7 = new PKCS7(algorithms, contentInfo,\n-                                signerChain, signerInfos);\n-        ByteArrayOutputStream p7out = new ByteArrayOutputStream();\n-        pkcs7.encodeSignedData(p7out);\n+    \/**\n+     * Examine the certificate for a Subject Information Access extension\n+     * (<a href=\"http:\/\/tools.ietf.org\/html\/rfc5280\">RFC 5280<\/a>).\n+     * The extension's {@code accessMethod} field should contain the object\n+     * identifier defined for timestamping: 1.3.6.1.5.5.7.48.3 and its\n+     * {@code accessLocation} field should contain an HTTP or HTTPS URL.\n+     *\n+     * @param tsaCertificate (optional) X.509 certificate for the TSA.\n+     * @return An HTTP or HTTPS URI or null if none was found.\n+     *\/\n+    public static URI getTimestampingURI(X509Certificate tsaCertificate) {\n@@ -854,1 +960,34 @@\n-        return p7out.toByteArray();\n+        if (tsaCertificate == null) {\n+            return null;\n+        }\n+        \/\/ Parse the extensions\n+        try {\n+            byte[] extensionValue = tsaCertificate.getExtensionValue\n+                    (KnownOIDs.SubjectInfoAccess.value());\n+            if (extensionValue == null) {\n+                return null;\n+            }\n+            DerInputStream der = new DerInputStream(extensionValue);\n+            der = new DerInputStream(der.getOctetString());\n+            DerValue[] derValue = der.getSequence(5);\n+            AccessDescription description;\n+            GeneralName location;\n+            URIName uri;\n+            for (int i = 0; i < derValue.length; i++) {\n+                description = new AccessDescription(derValue[i]);\n+                if (description.getAccessMethod()\n+                        .equals(ObjectIdentifier.of(KnownOIDs.AD_TimeStamping))) {\n+                    location = description.getAccessLocation();\n+                    if (location.getType() == GeneralNameInterface.NAME_URI) {\n+                        uri = (URIName) location.getName();\n+                        if (uri.getScheme().equalsIgnoreCase(\"http\") ||\n+                                uri.getScheme().equalsIgnoreCase(\"https\")) {\n+                            return uri.getURI();\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (IOException ioe) {\n+            \/\/ ignore\n+        }\n+        return null;\n@@ -876,1 +1015,1 @@\n-    private static byte[] generateTimestampToken(Timestamper tsa,\n+    public static byte[] generateTimestampToken(Timestamper tsa,\n@@ -947,1 +1086,1 @@\n-                        EXTENDED_KEY_USAGE_OID)) {\n+                        KnownOIDs.extendedKeyUsage.value())) {\n@@ -953,1 +1092,1 @@\n-                        !keyPurposes.contains(KP_TIMESTAMPING_OID)) {\n+                        !keyPurposes.contains(KnownOIDs.KP_TimeStamping.value())) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS7.java","additions":186,"deletions":47,"binary":false,"changes":233,"status":"modified"},{"patch":"@@ -167,0 +167,7 @@\n+ * <TR>\n+ * <TD>1.2.840.113549.1.9.16.2.52<\/TD>\n+ * <TD>CMSAlgorithmProtection<\/TD>\n+ * <TD>Single-valued<\/TD>\n+ * <TD>byte[]<\/TD>\n+ * <\/TR>\n+ *\n@@ -179,1 +186,1 @@\n-    static final ObjectIdentifier[] PKCS9_OIDS = new ObjectIdentifier[18];\n+    static final ObjectIdentifier[] PKCS9_OIDS = new ObjectIdentifier[19];\n@@ -226,0 +233,3 @@\n+    public static final ObjectIdentifier CMS_ALGORITHM_PROTECTION_OID =\n+            PKCS9_OIDS[18] =\n+            ObjectIdentifier.of(KnownOIDs.CMSAlgorithmProtection);\n@@ -264,1 +274,2 @@\n-        {DerValue.tag_Sequence}     \/\/ SignatureTimestampToken\n+        {DerValue.tag_Sequence},    \/\/ SignatureTimestampToken\n+        {DerValue.tag_Sequence}     \/\/ CMSAlgorithmProtection\n@@ -267,1 +278,1 @@\n-    private static final Class<?>[] VALUE_CLASSES = new Class<?>[18];\n+    private static final Class<?>[] VALUE_CLASSES = new Class<?>[19];\n@@ -295,0 +306,1 @@\n+            VALUE_CLASSES[18] = BYTE_ARRAY_CLASS;  \/\/ CMSAlgorithmProtection\n@@ -322,1 +334,2 @@\n-      true     \/\/ SignatureTimestampToken\n+      true,    \/\/ SignatureTimestampToken\n+      true,    \/\/ CMSAlgorithmProtection\n@@ -499,0 +512,5 @@\n+\n+        case 18:    \/\/ CMSAlgorithmProtection\n+            value = elems[0].toByteArray();\n+            break;\n+\n@@ -626,0 +644,4 @@\n+        case 18:    \/\/ CMSAlgorithmProtection\n+            temp.write(DerValue.tag_Set, (byte[])value);\n+            break;\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS9Attribute.java","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.security.spec.PSSParameterSpec;\n@@ -43,0 +44,1 @@\n+import sun.security.provider.SHAKE256;\n@@ -44,10 +46,1 @@\n-import sun.security.util.ConstraintsParameters;\n-import sun.security.util.Debug;\n-import sun.security.util.DerEncoder;\n-import sun.security.util.DerInputStream;\n-import sun.security.util.DerOutputStream;\n-import sun.security.util.DerValue;\n-import sun.security.util.DisabledAlgorithmConstraints;\n-import sun.security.util.HexDumpEncoder;\n-import sun.security.util.KeyUtil;\n-import sun.security.util.ObjectIdentifier;\n+import sun.security.util.*;\n@@ -57,1 +50,0 @@\n-import sun.security.util.SignatureUtil;\n@@ -95,6 +87,2 @@\n-        this.version = BigInteger.ONE;\n-        this.issuerName = issuerName;\n-        this.certificateSerialNumber = serial;\n-        this.digestAlgorithmId = digestAlgorithmId;\n-        this.digestEncryptionAlgorithmId = digestEncryptionAlgorithmId;\n-        this.encryptedDigest = encryptedDigest;\n+        this(issuerName, serial, digestAlgorithmId, null,\n+                digestEncryptionAlgorithmId, encryptedDigest, null);\n@@ -201,0 +189,30 @@\n+\n+        \/\/ verify CMSAlgorithmProtection\n+        checkCMSAlgorithmProtection();\n+    }\n+\n+    \/\/ CMSAlgorithmProtection verification as described in RFC 6211\n+    private void checkCMSAlgorithmProtection() throws IOException {\n+        if (authenticatedAttributes == null) {\n+            return;\n+        }\n+        PKCS9Attribute ap = authenticatedAttributes.getAttribute(\n+                PKCS9Attribute.CMS_ALGORITHM_PROTECTION_OID);\n+        if (ap == null) {\n+            return;\n+        }\n+        DerValue dv = new DerValue((byte[])ap.getValue());\n+        DerInputStream data = dv.data();\n+        AlgorithmId d = AlgorithmId.parse(data.getDerValue());\n+        DerValue ds = data.getDerValue();\n+        if (data.available() > 0) {\n+            throw new IOException(\"Unknown field in CMSAlgorithmProtection\");\n+        }\n+        if (!ds.isContextSpecific((byte)1)) {\n+            throw new IOException(\"No signature algorithm in CMSAlgorithmProtection\");\n+        }\n+        AlgorithmId s = AlgorithmId.parse(ds.withTag(DerValue.tag_Sequence));\n+        if (!s.equals(digestEncryptionAlgorithmId)\n+                || !d.equals(digestAlgorithmId)) {\n+            throw new IOException(\"CMSAlgorithmProtection check failed\");\n+        }\n@@ -330,1 +348,0 @@\n-            String digestAlgname = getDigestAlgorithmId().getName();\n@@ -356,0 +373,2 @@\n+                String digestAlgname = digestAlgorithmId.getName();\n+\n@@ -363,2 +382,18 @@\n-                MessageDigest md = MessageDigest.getInstance(digestAlgname);\n-                byte[] computedMessageDigest = md.digest(data);\n+                byte[] computedMessageDigest;\n+                if (digestAlgname.equals(\"SHAKE256\")\n+                        || digestAlgname.equals(\"SHAKE256-LEN\")) {\n+                    if (digestAlgname.equals(\"SHAKE256-LEN\")) {\n+                        int v = new DerValue(digestAlgorithmId\n+                                .getEncodedParams()).getInteger();\n+                        if (v != 512) {\n+                            throw new SignatureException(\n+                                    \"Unsupported id-shake256-\" + v);\n+                        }\n+                    }\n+                    var md = new SHAKE256(64);\n+                    md.update(data, 0, data.length);\n+                    computedMessageDigest = md.digest();\n+                } else {\n+                    MessageDigest md = MessageDigest.getInstance(digestAlgname);\n+                    computedMessageDigest = md.digest(data);\n+                }\n@@ -383,10 +418,5 @@\n-            \/\/ to form signing algorithm\n-            String encryptionAlgname =\n-                getDigestEncryptionAlgorithmId().getName();\n-\n-            \/\/ Workaround: sometimes the encryptionAlgname is actually\n-            \/\/ a signature name\n-            String tmp = AlgorithmId.getEncAlgFromSigAlg(encryptionAlgname);\n-            if (tmp != null) encryptionAlgname = tmp;\n-            String algname = AlgorithmId.makeSigAlg(\n-                    digestAlgname, encryptionAlgname);\n+            \/\/ to form signing algorithm. See makeSigAlg for details.\n+            String algname = makeSigAlg(\n+                    digestAlgorithmId,\n+                    digestEncryptionAlgorithmId,\n+                    authenticatedAttributes == null);\n@@ -438,2 +468,2 @@\n-                boolean digSigAllowed = keyUsage.get(\n-                        KeyUsageExtension.DIGITAL_SIGNATURE).booleanValue();\n+                boolean digSigAllowed\n+                        = keyUsage.get(KeyUsageExtension.DIGITAL_SIGNATURE);\n@@ -441,2 +471,2 @@\n-                boolean nonRepuAllowed = keyUsage.get(\n-                        KeyUsageExtension.NON_REPUDIATION).booleanValue();\n+                boolean nonRepuAllowed\n+                        = keyUsage.get(KeyUsageExtension.NON_REPUDIATION);\n@@ -474,0 +504,51 @@\n+    \/**\n+     * Derives the signature algorithm name from the digest algorithm\n+     * name and the encryption algorithm name inside a PKCS7 SignerInfo.\n+     *\n+     * For old style PKCS7 files where we use RSA, DSA, EC asencAlgId\n+     * a DIGESTwithENC algorithm is returned. For new style RSASSA-PSS\n+     * and EdDSA encryption, this method ensures digAlgId is compatible\n+     * with the algorithm.\n+     *\n+     * @param digAlgId the digest algorithm\n+     * @param encAlgId the encryption or signature algorithm\n+     * @param directSign whether the signature is calculated on the content\n+     *                   directly. This makes difference for Ed448.\n+     *\/\n+    public static String makeSigAlg(AlgorithmId digAlgId, AlgorithmId encAlgId,\n+            boolean directSign) throws NoSuchAlgorithmException {\n+        String encAlg = encAlgId.getName();\n+        if (encAlg.contains(\"with\")) {\n+            return encAlg;\n+        }\n+        switch (encAlg) {\n+            case \"RSASSA-PSS\":\n+                PSSParameterSpec spec = (PSSParameterSpec)\n+                        SignatureUtil.getParamSpec(encAlg, encAlgId.getParameters());\n+                if (!AlgorithmId.get(spec.getDigestAlgorithm()).equals(digAlgId)) {\n+                    throw new NoSuchAlgorithmException(\"Incompatible digest algorithm\");\n+                }\n+                return encAlg;\n+            case \"Ed25519\":\n+                if (!digAlgId.equals(SignatureUtil.EdDSADigestAlgHolder.sha512)) {\n+                    throw new NoSuchAlgorithmException(\"Incompatible digest algorithm\");\n+                }\n+                return encAlg;\n+            case \"Ed448\":\n+                if (directSign) {\n+                    if (!digAlgId.equals(SignatureUtil.EdDSADigestAlgHolder.shake256)) {\n+                        throw new NoSuchAlgorithmException(\"Incompatible digest algorithm\");\n+                    }\n+                } else {\n+                    if (!digAlgId.equals(SignatureUtil.EdDSADigestAlgHolder.shake256$512)) {\n+                        throw new NoSuchAlgorithmException(\"Incompatible digest algorithm\");\n+                    }\n+                }\n+                return encAlg;\n+            default:\n+                String digAlg = digAlgId.getName().replace(\"-\", \"\");\n+                if (encAlg.equals(\"EC\")) encAlg = \"ECDSA\";\n+                return digAlg + \"with\" + encAlg;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/SignerInfo.java","additions":115,"deletions":34,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.security.cert.CertificateException;\n@@ -192,1 +191,2 @@\n-     * @param signature private key and signing algorithm to use.\n+     * @param key private key to use.\n+     * @param algorithm signing algorithm to use.\n@@ -194,1 +194,0 @@\n-     * @exception CertificateException on certificate handling errors.\n@@ -196,0 +195,2 @@\n+     * @exception NoSuchAlgorithmException algorithm is not recognized\n+     * @exception InvalidKeyException key has a problem\n@@ -197,2 +198,4 @@\n-    public void encodeAndSign(X500Name subject, Signature signature)\n-    throws CertificateException, IOException, SignatureException {\n+    public void encodeAndSign(X500Name subject, PrivateKey key, String algorithm)\n+            throws IOException, SignatureException,\n+                    NoSuchAlgorithmException, InvalidKeyException {\n+\n@@ -203,1 +206,1 @@\n-        if (encoded != null)\n+        if (encoded != null) {\n@@ -205,0 +208,4 @@\n+        }\n+\n+        Signature signature = SignatureUtil.fromKey(\n+                algorithm, key, (Provider)null);\n@@ -233,9 +240,1 @@\n-        AlgorithmId algId = null;\n-        try {\n-            AlgorithmParameters params = signature.getParameters();\n-            algId = params == null\n-                    ? AlgorithmId.get(signature.getAlgorithm())\n-                    : AlgorithmId.get(params);\n-        } catch (NoSuchAlgorithmException nsae) {\n-            throw new SignatureException(nsae);\n-        }\n+        AlgorithmId algId = SignatureUtil.fromSignature(signature, key);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs10\/PKCS10.java","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.security.spec.AlgorithmParameterSpec;\n@@ -39,0 +38,1 @@\n+import sun.security.util.SignatureUtil;\n@@ -190,1 +190,1 @@\n-            sigAlg = AlgorithmId.getDefaultSigAlgForKey(privateKey);\n+            sigAlg = SignatureUtil.getDefaultSigAlgForKey(privateKey);\n@@ -285,2 +285,0 @@\n-            AlgorithmParameterSpec params = AlgorithmId\n-                    .getDefaultAlgorithmParameterSpec(sigAlg, privateKey);\n@@ -295,3 +293,0 @@\n-            AlgorithmId algID = AlgorithmId.getWithParameterSpec(sigAlg, params);\n-            info.set(X509CertInfo.ALGORITHM_ID,\n-                     new CertificateAlgorithmId(algID));\n@@ -305,4 +300,1 @@\n-            cert.sign(privateKey,\n-                    params,\n-                    sigAlg,\n-                    null);\n+            cert.sign(privateKey, sigAlg);\n@@ -310,1 +302,1 @@\n-            return (X509Certificate)cert;\n+            return cert;\n@@ -315,3 +307,0 @@\n-        } catch (InvalidAlgorithmParameterException e2) {\n-            throw new SignatureException(\n-                    \"Unsupported PSSParameterSpec: \" + e2.getMessage());\n@@ -329,38 +318,0 @@\n-    \/**\n-     * Returns a PKCS #10 certificate request.  The caller uses either\n-     * <code>PKCS10.print<\/code> or <code>PKCS10.toByteArray<\/code>\n-     * operations on the result, to get the request in an appropriate\n-     * transmission format.\n-     *\n-     * <P>PKCS #10 certificate requests are sent, along with some proof\n-     * of identity, to Certificate Authorities (CAs) which then issue\n-     * X.509 public key certificates.\n-     *\n-     * @param myname X.500 name of the subject\n-     * @exception InvalidKeyException on key handling errors.\n-     * @exception SignatureException on signature handling errors.\n-     *\/\n-    \/\/ This method is not used inside JDK. Will not update it.\n-    public PKCS10 getCertRequest (X500Name myname)\n-    throws InvalidKeyException, SignatureException\n-    {\n-        PKCS10  req = new PKCS10 (publicKey);\n-\n-        try {\n-            Signature signature = Signature.getInstance(sigAlg);\n-            signature.initSign (privateKey);\n-            req.encodeAndSign(myname, signature);\n-\n-        } catch (CertificateException e) {\n-            throw new SignatureException (sigAlg + \" CertificateException\");\n-\n-        } catch (IOException e) {\n-            throw new SignatureException (sigAlg + \" IOException\");\n-\n-        } catch (NoSuchAlgorithmException e) {\n-            \/\/ \"can't happen\"\n-            throw new SignatureException (sigAlg + \" unavailable?\");\n-        }\n-        return req;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/CertAndKeyGen.java","additions":5,"deletions":54,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -31,15 +31,1 @@\n-import java.security.AlgorithmParameters;\n-import java.security.CodeSigner;\n-import java.security.CryptoPrimitive;\n-import java.security.KeyStore;\n-import java.security.KeyStoreException;\n-import java.security.MessageDigest;\n-import java.security.Key;\n-import java.security.PublicKey;\n-import java.security.PrivateKey;\n-import java.security.SecureRandom;\n-import java.security.Signature;\n-import java.security.Timestamp;\n-import java.security.UnrecoverableEntryException;\n-import java.security.UnrecoverableKeyException;\n-import java.security.Principal;\n+import java.security.*;\n@@ -56,0 +42,1 @@\n+import java.security.interfaces.EdECKey;\n@@ -103,1 +90,0 @@\n-import java.security.Security;\n@@ -1452,6 +1438,0 @@\n-        Signature signature = Signature.getInstance(sigAlgName);\n-        AlgorithmParameterSpec params = AlgorithmId\n-                .getDefaultAlgorithmParameterSpec(sigAlgName, privateKey);\n-\n-        SignatureUtil.initSignWithParam(signature, privateKey, params, null);\n-\n@@ -1459,1 +1439,0 @@\n-        AlgorithmId algID = AlgorithmId.getWithParameterSpec(sigAlgName, params);\n@@ -1465,2 +1444,0 @@\n-        info.set(X509CertInfo.ALGORITHM_ID,\n-                    new CertificateAlgorithmId(algID));\n@@ -1510,1 +1487,1 @@\n-        cert.sign(privateKey, params, sigAlgName, null);\n+        cert.sign(privateKey, sigAlgName);\n@@ -1611,5 +1588,0 @@\n-        Signature signature = Signature.getInstance(sigAlgName);\n-        AlgorithmParameterSpec params = AlgorithmId\n-                .getDefaultAlgorithmParameterSpec(sigAlgName, privKey);\n-        SignatureUtil.initSignWithParam(signature, privKey, params, null);\n-\n@@ -1621,1 +1593,1 @@\n-        request.encodeAndSign(subject, signature);\n+        request.encodeAndSign(subject, privKey, sigAlgName);\n@@ -1850,1 +1822,1 @@\n-        String result = AlgorithmId.getDefaultSigAlgForKey(key);\n+        String result = SignatureUtil.getDefaultSigAlgForKey(key);\n@@ -2540,1 +2512,1 @@\n-        X509CRLImpl xcrl = (X509CRLImpl)crl;\n+        X509CRL xcrl = (X509CRL)crl;\n@@ -2548,1 +2520,1 @@\n-                        ((X509CRLImpl)crl).verify(cert.getPublicKey());\n+                        ((X509CRL)crl).verify(cert.getPublicKey());\n@@ -2986,12 +2958,0 @@\n-        \/\/ The inner and outer signature algorithms have to match.\n-        \/\/ The way we achieve that is really ugly, but there seems to be no\n-        \/\/ other solution: We first sign the cert, then retrieve the\n-        \/\/ outer sigalg and use it to set the inner sigalg\n-        X509CertImpl newCert = new X509CertImpl(certInfo);\n-        AlgorithmParameterSpec params = AlgorithmId\n-                .getDefaultAlgorithmParameterSpec(sigAlgName, privKey);\n-        newCert.sign(privKey, params, sigAlgName, null);\n-        AlgorithmId sigAlgid = (AlgorithmId)newCert.get(X509CertImpl.SIG_ALG);\n-        certInfo.set(CertificateAlgorithmId.NAME + \".\" +\n-                     CertificateAlgorithmId.ALGORITHM, sigAlgid);\n-\n@@ -3009,2 +2969,2 @@\n-        newCert = new X509CertImpl(certInfo);\n-        newCert.sign(privKey, params, sigAlgName, null);\n+        X509CertImpl newCert = new X509CertImpl(certInfo);\n+        newCert.sign(privKey, sigAlgName);\n@@ -3337,1 +3297,2 @@\n-                result += \" (\" + paramSpec.toString().split(\" \")[0] + \")\";\n+                NamedCurve nc = (NamedCurve)paramSpec;\n+                result += \" (\" + nc.getNameAndAliases()[0] + \")\";\n@@ -3339,0 +3300,2 @@\n+        } else if (key instanceof EdECKey) {\n+            result = ((EdECKey) key).getParams().getName();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/Main.java","additions":13,"deletions":50,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -147,0 +147,1 @@\n+    SHAKE256_LEN(\"2.16.840.1.101.3.4.2.18\", \"SHAKE256-LEN\"),\n@@ -184,1 +185,1 @@\n-    RSASSA_PSS(\"1.2.840.113549.1.1.10\", \"RSASSA-PSS\"),\n+    RSASSA_PSS(\"1.2.840.113549.1.1.10\", \"RSASSA-PSS\", \"PSS\"),\n@@ -234,0 +235,1 @@\n+    CMSAlgorithmProtection(\"1.2.840.113549.1.9.52\"),\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KnownOIDs.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.security.PrivateKey;\n@@ -176,0 +177,1 @@\n+     * @see #getBlockExtension(PrivateKey)\n@@ -186,0 +188,20 @@\n+    \/**\n+     * Returns the signed JAR block file extension for a key.\n+     *\n+     * @param key the key used to sign the JAR file\n+     * @return the extension\n+     * @see #isBlockOrSF(String)\n+     *\/\n+    public static String getBlockExtension(PrivateKey key) {\n+        String keyAlgorithm = key.getAlgorithm().toUpperCase(Locale.ENGLISH);\n+        if (keyAlgorithm.equals(\"RSASSA-PSS\")) {\n+            return \"RSA\";\n+        } else if (keyAlgorithm.equals(\"EDDSA\")\n+                || keyAlgorithm.equals(\"ED25519\")\n+                || keyAlgorithm.equals(\"ED448\")) {\n+            return \"EC\";\n+        } else {\n+            return keyAlgorithm;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SignatureFileVerifier.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,3 @@\n+import java.security.interfaces.EdECKey;\n+import java.security.interfaces.EdECPrivateKey;\n+import java.security.interfaces.RSAKey;\n@@ -32,0 +35,1 @@\n+\n@@ -34,0 +38,1 @@\n+import sun.security.x509.AlgorithmId;\n@@ -44,1 +49,9 @@\n-    private static String checkName(String algName) throws ProviderException {\n+    \/**\n+     * Convent OID.1.2.3.4 or 1.2.3.4 to the matched stdName.\n+     *\n+     * @param algName input, could be in any form\n+     * @return the original name is it does not look like an OID,\n+     *         the matched name for an OID, or the OID itself\n+     *         if no match is found.\n+     *\/\n+    private static String checkName(String algName) {\n@@ -47,6 +60,7 @@\n-        }\n-        \/\/ convert oid to String\n-        try {\n-            return Signature.getInstance(algName).getAlgorithm();\n-        } catch (Exception e) {\n-            throw new ProviderException(\"Error mapping algorithm name\", e);\n+        } else {\n+            \/\/ convert oid to String\n+            if (algName.startsWith(\"OID.\")) {\n+                algName = algName.substring(4);\n+            }\n+            KnownOIDs ko = KnownOIDs.findMatch(algName);\n+            return ko != null ? ko.stdName() : algName;\n@@ -72,2 +86,9 @@\n-    \/\/ Utility method for converting the specified AlgorithmParameters object\n-    \/\/ into an AlgorithmParameterSpec object.\n+    \/**\n+     * Utility method for converting the specified AlgorithmParameters object\n+     * into an AlgorithmParameterSpec object.\n+     *\n+     * @param sigName signature algorithm\n+     * @param params (optional) parameters\n+     * @return an AlgorithmParameterSpec object\n+     * @throws ProviderException\n+     *\/\n@@ -106,0 +127,2 @@\n+        } else {\n+            paramSpec = getDefaultAlgorithmParameterSpec(sigName, null);\n@@ -140,0 +163,2 @@\n+        } else {\n+            paramSpec = getDefaultAlgorithmParameterSpec(sigName, null);\n@@ -171,0 +196,326 @@\n+\n+    public static class EdDSADigestAlgHolder {\n+        public final static AlgorithmId sha512;\n+        public final static AlgorithmId shake256;\n+        public final static AlgorithmId shake256$512;\n+\n+        static {\n+            try {\n+                sha512 = AlgorithmId.get(KnownOIDs.SHA_512.stdName());\n+                shake256 = AlgorithmId.get(KnownOIDs.SHAKE256.stdName());\n+                shake256$512 = new AlgorithmId(\n+                        ObjectIdentifier.of(KnownOIDs.SHAKE256_LEN),\n+                        new DerValue((byte) 2, new byte[]{2, 0})); \/\/ int 512\n+            } catch (IOException | NoSuchAlgorithmException e) {\n+                throw new AssertionError(\"Shoudl not happen\", e);\n+            }\n+        }\n+    }\n+    \/**\n+     * Determines the digestEncryptionAlgorithmId in PKCS& SignerInfo.\n+     *\n+     * @param signer Signature object that tells you RSASA-PSS params\n+     * @param sigalg Signature algorithm tells you who with who\n+     * @param privateKey key tells you EdDSA params\n+     * @param directsign Ed448 uses different digest algs depending on this\n+     * @return the digest alg\n+     * @throws NoSuchAlgorithmException\n+     *\/\n+    public static AlgorithmId getDigestAlgInPkcs7SignerInfo(\n+            Signature signer, String sigalg, PrivateKey privateKey, boolean directsign)\n+            throws NoSuchAlgorithmException {\n+        AlgorithmId digAlgID;\n+        String kAlg = privateKey.getAlgorithm();\n+        if (privateKey instanceof EdECPrivateKey\n+                || kAlg.equalsIgnoreCase(\"Ed25519\")\n+                || kAlg.equalsIgnoreCase(\"Ed448\")) {\n+            if (privateKey instanceof EdECPrivateKey) {\n+                \/\/ Note: SunEC's kAlg is EdDSA, find out the real one\n+                kAlg = ((EdECPrivateKey) privateKey).getParams().getName();\n+            }\n+            \/\/ https:\/\/www.rfc-editor.org\/rfc\/rfc8419.html#section-3\n+            switch (kAlg.toUpperCase(Locale.ENGLISH)) {\n+                case \"ED25519\":\n+                    digAlgID = EdDSADigestAlgHolder.sha512;\n+                    break;\n+                case \"ED448\":\n+                    if (directsign) {\n+                        digAlgID = EdDSADigestAlgHolder.shake256;\n+                    } else {\n+                        digAlgID = EdDSADigestAlgHolder.shake256$512;\n+                    }\n+                    break;\n+                default:\n+                    throw new AssertionError(\"Unknown curve name: \" + kAlg);\n+            }\n+        } else {\n+            if (sigalg.equalsIgnoreCase(\"RSASSA-PSS\")) {\n+                try {\n+                    digAlgID = AlgorithmId.get(signer.getParameters()\n+                            .getParameterSpec(PSSParameterSpec.class)\n+                            .getDigestAlgorithm());\n+                } catch (InvalidParameterSpecException e) {\n+                    throw new AssertionError(\"Should not happen\", e);\n+                }\n+            } else {\n+                digAlgID = AlgorithmId.get(extractDigestAlgFromDwithE(sigalg));\n+            }\n+        }\n+        return digAlgID;\n+    }\n+\n+    \/**\n+     * Extracts the digest algorithm names from a signature\n+     * algorithm name in either the \"DIGESTwithENCRYPTION\" or the\n+     * \"DIGESTwithENCRYPTIONandWHATEVER\" format.\n+     *\n+     * It's OK to return \"SHA1\" instead of \"SHA-1\".\n+     *\/\n+    public static String extractDigestAlgFromDwithE(String signatureAlgorithm) {\n+        signatureAlgorithm = signatureAlgorithm.toUpperCase(Locale.ENGLISH);\n+        int with = signatureAlgorithm.indexOf(\"WITH\");\n+        if (with > 0) {\n+            return signatureAlgorithm.substring(0, with);\n+        } else {\n+            throw new IllegalArgumentException(\n+                    \"Unknown algorithm: \" + signatureAlgorithm);\n+        }\n+    }\n+\n+    \/**\n+     * Returns default AlgorithmParameterSpec for a key used in a signature.\n+     * This is only useful for RSASSA-PSS now, which is the only algorithm\n+     * that must be initialized with a AlgorithmParameterSpec now.\n+     *\/\n+    public static AlgorithmParameterSpec getDefaultAlgorithmParameterSpec(\n+            String sigAlg, Key k) {\n+        sigAlg = checkName(sigAlg);\n+        if (sigAlg.equalsIgnoreCase(\"RSASSA-PSS\")) {\n+            if (k instanceof RSAKey) {\n+                AlgorithmParameterSpec spec = ((RSAKey) k).getParams();\n+                if (spec instanceof PSSParameterSpec) {\n+                    return spec;\n+                }\n+            }\n+            switch (ifcFfcStrength(KeyUtil.getKeySize(k))) {\n+                case \"SHA256\":\n+                    return PSSParamsHolder.PSS_256_SPEC;\n+                case \"SHA384\":\n+                    return PSSParamsHolder.PSS_384_SPEC;\n+                case \"SHA512\":\n+                    return PSSParamsHolder.PSS_512_SPEC;\n+                default:\n+                    throw new AssertionError(\"Should not happen\");\n+            }\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * Create a Signature that has been initialized with proper key and params.\n+     *\n+     * @param sigAlg signature algorithms\n+     * @param key public or private key\n+     * @param provider (optional) provider\n+     *\/\n+    public static Signature fromKey(String sigAlg, Key key, String provider)\n+            throws NoSuchAlgorithmException, NoSuchProviderException,\n+                   InvalidKeyException{\n+        Signature sigEngine = (provider == null || provider.isEmpty())\n+                ? Signature.getInstance(sigAlg)\n+                : Signature.getInstance(sigAlg, provider);\n+        return autoInitInternal(sigAlg, key, sigEngine);\n+    }\n+\n+    \/**\n+     * Create a Signature that has been initialized with proper key and params.\n+     *\n+     * @param sigAlg signature algorithms\n+     * @param key public or private key\n+     * @param provider (optional) provider\n+     *\/\n+    public static Signature fromKey(String sigAlg, Key key, Provider provider)\n+            throws NoSuchAlgorithmException, InvalidKeyException{\n+        Signature sigEngine = (provider == null)\n+                ? Signature.getInstance(sigAlg)\n+                : Signature.getInstance(sigAlg, provider);\n+        return autoInitInternal(sigAlg, key, sigEngine);\n+    }\n+\n+    private static Signature autoInitInternal(String alg, Key key, Signature s)\n+            throws InvalidKeyException {\n+        AlgorithmParameterSpec params = SignatureUtil\n+                .getDefaultAlgorithmParameterSpec(alg, key);\n+        try {\n+            if (key instanceof PrivateKey) {\n+                SignatureUtil.initSignWithParam(s, (PrivateKey) key, params,\n+                        null);\n+            } else {\n+                SignatureUtil.initVerifyWithParam(s, (PublicKey) key, params);\n+            }\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new AssertionError(\"Should not happen\", e);\n+        }\n+        return s;\n+    }\n+\n+    \/**\n+     * Derives AlgorithmId from a signature object and a key.\n+     * @param sigEngine the signature object\n+     * @param key the private key\n+     * @return the AlgorithmIA, not null\n+     * @throws SignatureException if cannot find one\n+     *\/\n+    public static AlgorithmId fromSignature(Signature sigEngine, PrivateKey key)\n+            throws SignatureException {\n+        try {\n+            if (key instanceof EdECKey) {\n+                return AlgorithmId.get(((EdECKey) key).getParams().getName());\n+            }\n+\n+            AlgorithmParameters params = null;\n+            try {\n+                params = sigEngine.getParameters();\n+            } catch (UnsupportedOperationException e) {\n+                \/\/ some provider does not support it\n+            }\n+            if (params != null) {\n+                return AlgorithmId.get(sigEngine.getParameters());\n+            } else {\n+                String sigAlg = sigEngine.getAlgorithm();\n+                if (sigAlg.equalsIgnoreCase(\"EdDSA\")) {\n+                    \/\/ Hopefully key knows if it's Ed25519 or Ed448\n+                    sigAlg = key.getAlgorithm();\n+                }\n+                return AlgorithmId.get(sigAlg);\n+            }\n+        } catch (NoSuchAlgorithmException e) {\n+            \/\/ This could happen if both sig alg and key alg is EdDSA,\n+            \/\/ we don't know which provider does this.\n+            throw new SignatureException(\"Cannot derive AlgorithmIdentifier\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Checks if a signature algorithm matches a key, i.e. if this\n+     * signature can be initialized with this key. Currently used\n+     * in {@link jdk.security.jarsigner.JarSigner} to fail early.\n+     *\n+     * Note: Unknown signature algorithms are allowed.\n+     *\n+     * @param key must not be null\n+     * @param sAlg must not be null\n+     * @throws IllegalArgumentException if they are known to not match\n+     *\/\n+    public static void checkKeyAndSigAlgMatch(PrivateKey key, String sAlg) {\n+        String kAlg = key.getAlgorithm().toUpperCase(Locale.ENGLISH);\n+        sAlg = checkName(sAlg).toUpperCase(Locale.ENGLISH);\n+        switch (sAlg) {\n+            case \"RSASSA-PSS\" -> {\n+                if (!kAlg.equals(\"RSASSA-PSS\")\n+                        && !kAlg.equals(\"RSA\")) {\n+                    throw new IllegalArgumentException(\n+                            \"key algorithm not compatible with signature algorithm\");\n+                }\n+            }\n+            case \"EDDSA\" -> {\n+                \/\/ General EdDSA, any EDDSA name variance is OK\n+                if (!kAlg.equals(\"EDDSA\") && !kAlg.equals(\"ED448\")\n+                        && !kAlg.equals(\"ED25519\")) {\n+                    throw new IllegalArgumentException(\n+                            \"key algorithm not compatible with signature algorithm\");\n+                }\n+            }\n+            case \"ED25519\", \"ED448\" -> {\n+                \/\/ fix-size EdDSA\n+                if (key instanceof EdECKey) {\n+                    \/\/ SunEC's key alg is fix-size. Must match.\n+                    String groupName = ((EdECKey) key).getParams()\n+                            .getName().toUpperCase(Locale.US);\n+                    if (!sAlg.equals(groupName)) {\n+                        throw new IllegalArgumentException(\n+                                \"key algorithm not compatible with signature algorithm\");\n+                    }\n+                } else {\n+                    \/\/ Other vendor might be generalized or fix-size\n+                    if (!kAlg.equals(\"EDDSA\") && !kAlg.equals(sAlg)) {\n+                        throw new IllegalArgumentException(\n+                                \"key algorithm not compatible with signature algorithm\");\n+                    }\n+                }\n+            }\n+            default -> {\n+                if (sAlg.contains(\"WITH\")) {\n+                    if ((sAlg.endsWith(\"WITHRSA\") && !kAlg.equals(\"RSA\")) ||\n+                            (sAlg.endsWith(\"WITHECDSA\") && !kAlg.equals(\"EC\")) ||\n+                            (sAlg.endsWith(\"WITHDSA\") && !kAlg.equals(\"DSA\"))) {\n+                        throw new IllegalArgumentException(\n+                                \"key algorithm not compatible with signature algorithm\");\n+                    }\n+                }\n+                \/\/ Do not fail now. Maybe new algorithm we don't know.\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns the default signature algorithm for a private key.\n+     *\n+     * @param k cannot be null\n+     * @return the default alg, might be null if unsupported\n+     *\/\n+    public static String getDefaultSigAlgForKey(PrivateKey k) {\n+        String kAlg = k.getAlgorithm();\n+        return switch (kAlg.toUpperCase(Locale.ENGLISH)) {\n+            case \"DSA\", \"RSA\" -> ifcFfcStrength(KeyUtil.getKeySize(k))\n+                    + \"with\" + kAlg;\n+            case \"EC\" -> ecStrength(KeyUtil.getKeySize(k))\n+                    + \"withECDSA\";\n+            case \"EDDSA\" -> k instanceof EdECPrivateKey\n+                    ? ((EdECPrivateKey) k).getParams().getName()\n+                    : kAlg;\n+            case \"RSASSA-PSS\", \"ED25519\", \"ED448\" -> kAlg;\n+            default -> null;\n+        };\n+    }\n+\n+    \/\/ Useful PSSParameterSpec objects\n+    private static class PSSParamsHolder {\n+        final static PSSParameterSpec PSS_256_SPEC = new PSSParameterSpec(\n+                \"SHA-256\", \"MGF1\",\n+                new MGF1ParameterSpec(\"SHA-256\"),\n+                32, PSSParameterSpec.TRAILER_FIELD_BC);\n+        final static PSSParameterSpec PSS_384_SPEC = new PSSParameterSpec(\n+                \"SHA-384\", \"MGF1\",\n+                new MGF1ParameterSpec(\"SHA-384\"),\n+                48, PSSParameterSpec.TRAILER_FIELD_BC);\n+        final static PSSParameterSpec PSS_512_SPEC = new PSSParameterSpec(\n+                \"SHA-512\", \"MGF1\",\n+                new MGF1ParameterSpec(\"SHA-512\"),\n+                64, PSSParameterSpec.TRAILER_FIELD_BC);\n+    }\n+\n+    \/\/ Values from SP800-57 part 1 rev 4 tables 2 and 3\n+    \/\/ Attention: sync with JarSigner.Builder#getDefaultSignatureAlgorithm\n+    private static String ecStrength (int bitLength) {\n+        if (bitLength >= 512) { \/\/ 256 bits of strength\n+            return \"SHA512\";\n+        } else if (bitLength >= 384) {  \/\/ 192 bits of strength\n+            return \"SHA384\";\n+        } else { \/\/ 128 bits of strength and less\n+            return \"SHA256\";\n+        }\n+    }\n+\n+    \/\/ Same values for RSA and DSA\n+    \/\/ Attention: sync with JarSigner.Builder#getDefaultSignatureAlgorithm\n+    private static String ifcFfcStrength (int bitLength) {\n+        if (bitLength > 7680) { \/\/ 256 bits\n+            return \"SHA512\";\n+        } else if (bitLength > 3072) {  \/\/ 192 bits\n+            return \"SHA384\";\n+        } else  { \/\/ 128 bits and less\n+            return \"SHA256\";\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SignatureUtil.java","additions":361,"deletions":10,"binary":false,"changes":371,"status":"modified"},{"patch":"@@ -29,6 +29,0 @@\n-import java.security.interfaces.RSAKey;\n-import java.security.spec.AlgorithmParameterSpec;\n-import java.security.spec.EdDSAParameterSpec;\n-import java.security.spec.InvalidParameterSpecException;\n-import java.security.spec.MGF1ParameterSpec;\n-import java.security.spec.PSSParameterSpec;\n@@ -38,1 +32,0 @@\n-import java.security.interfaces.*;\n@@ -40,1 +33,0 @@\n-import sun.security.rsa.PSSParameters;\n@@ -121,1 +113,1 @@\n-    private AlgorithmId(ObjectIdentifier oid, DerValue params)\n+    public AlgorithmId(ObjectIdentifier oid, DerValue params)\n@@ -273,1 +265,1 @@\n-                    AlgorithmId paramsId =\n+                    AlgorithmId digestParams =\n@@ -275,2 +267,2 @@\n-                    String paramsName = paramsId.getName();\n-                    return makeSigAlg(paramsName, \"EC\");\n+                    String digestAlg = digestParams.getName();\n+                    return digestAlg.replace(\"-\", \"\") + \"withECDSA\";\n@@ -671,206 +663,0 @@\n-\n-    \/**\n-     * Creates a signature algorithm name from a digest algorithm\n-     * name and a encryption algorithm name.\n-     *\/\n-    public static String makeSigAlg(String digAlg, String encAlg) {\n-        digAlg = digAlg.replace(\"-\", \"\");\n-        if (encAlg.equalsIgnoreCase(\"EC\")) encAlg = \"ECDSA\";\n-\n-        return digAlg + \"with\" + encAlg;\n-    }\n-\n-    \/**\n-     * Extracts the encryption algorithm name from a signature\n-     * algorithm name.\n-     *\/\n-    public static String getEncAlgFromSigAlg(String signatureAlgorithm) {\n-        signatureAlgorithm = signatureAlgorithm.toUpperCase(Locale.ENGLISH);\n-        int with = signatureAlgorithm.indexOf(\"WITH\");\n-        String keyAlgorithm = null;\n-        if (with > 0) {\n-            int and = signatureAlgorithm.indexOf(\"AND\", with + 4);\n-            if (and > 0) {\n-                keyAlgorithm = signatureAlgorithm.substring(with + 4, and);\n-            } else {\n-                keyAlgorithm = signatureAlgorithm.substring(with + 4);\n-            }\n-            if (keyAlgorithm.equalsIgnoreCase(\"ECDSA\")) {\n-                keyAlgorithm = \"EC\";\n-            }\n-        }\n-        return keyAlgorithm;\n-    }\n-\n-    \/**\n-     * Extracts the digest algorithm name from a signature\n-     * algorithm name.\n-     *\/\n-    public static String getDigAlgFromSigAlg(String signatureAlgorithm) {\n-        signatureAlgorithm = signatureAlgorithm.toUpperCase(Locale.ENGLISH);\n-        int with = signatureAlgorithm.indexOf(\"WITH\");\n-        if (with > 0) {\n-            return signatureAlgorithm.substring(0, with);\n-        }\n-        return null;\n-    }\n-\n-    \/**\n-     * Checks if a signature algorithm matches a key algorithm, i.e. a\n-     * signature can be initialized with a key.\n-     *\n-     * @param kAlg must not be null\n-     * @param sAlg must not be null\n-     * @throws IllegalArgumentException if they do not match\n-     *\/\n-    public static void checkKeyAndSigAlgMatch(String kAlg, String sAlg) {\n-        String sAlgUp = sAlg.toUpperCase(Locale.US);\n-        if ((sAlgUp.endsWith(\"WITHRSA\") && !kAlg.equalsIgnoreCase(\"RSA\")) ||\n-                (sAlgUp.endsWith(\"WITHECDSA\") && !kAlg.equalsIgnoreCase(\"EC\")) ||\n-                (sAlgUp.endsWith(\"WITHDSA\") && !kAlg.equalsIgnoreCase(\"DSA\"))) {\n-            throw new IllegalArgumentException(\n-                    \"key algorithm not compatible with signature algorithm\");\n-        }\n-    }\n-\n-    \/**\n-     * Returns the default signature algorithm for a private key. The digest\n-     * part might evolve with time. Remember to update the spec of\n-     * {@link jdk.security.jarsigner.JarSigner.Builder#getDefaultSignatureAlgorithm(PrivateKey)}\n-     * if updated.\n-     *\n-     * @param k cannot be null\n-     * @return the default alg, might be null if unsupported\n-     *\/\n-    public static String getDefaultSigAlgForKey(PrivateKey k) {\n-        switch (k.getAlgorithm().toUpperCase(Locale.ENGLISH)) {\n-            case \"EC\":\n-                return ecStrength(KeyUtil.getKeySize(k))\n-                    + \"withECDSA\";\n-            case \"DSA\":\n-                return ifcFfcStrength(KeyUtil.getKeySize(k))\n-                    + \"withDSA\";\n-            case \"RSA\":\n-                return ifcFfcStrength(KeyUtil.getKeySize(k))\n-                    + \"withRSA\";\n-            case \"RSASSA-PSS\":\n-                return \"RSASSA-PSS\";\n-            case \"EDDSA\":\n-                return edAlgFromKey(k);\n-            default:\n-                return null;\n-        }\n-    }\n-\n-    \/\/ Most commonly used PSSParameterSpec and AlgorithmId\n-    private static class PSSParamsHolder {\n-\n-        final static PSSParameterSpec PSS_256_SPEC = new PSSParameterSpec(\n-                \"SHA-256\", \"MGF1\",\n-                new MGF1ParameterSpec(\"SHA-256\"),\n-                32, PSSParameterSpec.TRAILER_FIELD_BC);\n-        final static PSSParameterSpec PSS_384_SPEC = new PSSParameterSpec(\n-                \"SHA-384\", \"MGF1\",\n-                new MGF1ParameterSpec(\"SHA-384\"),\n-                48, PSSParameterSpec.TRAILER_FIELD_BC);\n-        final static PSSParameterSpec PSS_512_SPEC = new PSSParameterSpec(\n-                \"SHA-512\", \"MGF1\",\n-                new MGF1ParameterSpec(\"SHA-512\"),\n-                64, PSSParameterSpec.TRAILER_FIELD_BC);\n-\n-        final static AlgorithmId PSS_256_ID;\n-        final static AlgorithmId PSS_384_ID;\n-        final static AlgorithmId PSS_512_ID;\n-\n-        static {\n-            try {\n-                PSS_256_ID = new AlgorithmId(RSASSA_PSS_oid,\n-                        new DerValue(PSSParameters.getEncoded(PSS_256_SPEC)));\n-                PSS_384_ID = new AlgorithmId(RSASSA_PSS_oid,\n-                        new DerValue(PSSParameters.getEncoded(PSS_384_SPEC)));\n-                PSS_512_ID = new AlgorithmId(RSASSA_PSS_oid,\n-                        new DerValue(PSSParameters.getEncoded(PSS_512_SPEC)));\n-            } catch (IOException e) {\n-                throw new AssertionError(\"Should not happen\", e);\n-            }\n-        }\n-    }\n-\n-    public static AlgorithmId getWithParameterSpec(String algName,\n-            AlgorithmParameterSpec spec) throws NoSuchAlgorithmException {\n-\n-        if (spec == null) {\n-            return AlgorithmId.get(algName);\n-        } else if (spec == PSSParamsHolder.PSS_256_SPEC) {\n-            return PSSParamsHolder.PSS_256_ID;\n-        } else if (spec == PSSParamsHolder.PSS_384_SPEC) {\n-            return PSSParamsHolder.PSS_384_ID;\n-        } else if (spec == PSSParamsHolder.PSS_512_SPEC) {\n-            return PSSParamsHolder.PSS_512_ID;\n-        } else if (spec instanceof EdDSAParameterSpec) {\n-            return AlgorithmId.get(algName);\n-        } else {\n-            try {\n-                AlgorithmParameters result =\n-                        AlgorithmParameters.getInstance(algName);\n-                result.init(spec);\n-                return get(result);\n-            } catch (InvalidParameterSpecException | NoSuchAlgorithmException e) {\n-                throw new ProviderException(e);\n-            }\n-        }\n-    }\n-\n-    public static AlgorithmParameterSpec getDefaultAlgorithmParameterSpec(\n-            String sigAlg, PrivateKey k) {\n-        if (sigAlg.equalsIgnoreCase(\"RSASSA-PSS\")) {\n-            if (k instanceof RSAKey) {\n-                AlgorithmParameterSpec spec = ((RSAKey) k).getParams();\n-                if (spec instanceof PSSParameterSpec) {\n-                    return spec;\n-                }\n-            }\n-            switch (ifcFfcStrength(KeyUtil.getKeySize(k))) {\n-                case \"SHA256\":\n-                    return PSSParamsHolder.PSS_256_SPEC;\n-                case \"SHA384\":\n-                    return PSSParamsHolder.PSS_384_SPEC;\n-                case \"SHA512\":\n-                    return PSSParamsHolder.PSS_512_SPEC;\n-                default:\n-                    throw new AssertionError(\"Should not happen\");\n-            }\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    private static String edAlgFromKey(PrivateKey k) {\n-        if (k instanceof EdECPrivateKey) {\n-            EdECPrivateKey edKey = (EdECPrivateKey) k;\n-            return edKey.getParams().getName();\n-        }\n-        return \"EdDSA\";\n-    }\n-\n-    \/\/ Values from SP800-57 part 1 rev 4 tables 2 and 3\n-    private static String ecStrength (int bitLength) {\n-        if (bitLength >= 512) { \/\/ 256 bits of strength\n-            return \"SHA512\";\n-        } else if (bitLength >= 384) {  \/\/ 192 bits of strength\n-            return \"SHA384\";\n-        } else { \/\/ 128 bits of strength and less\n-            return \"SHA256\";\n-        }\n-    }\n-\n-    \/\/ Same values for RSA and DSA\n-    private static String ifcFfcStrength (int bitLength) {\n-        if (bitLength > 7680) { \/\/ 256 bits\n-            return \"SHA512\";\n-        } else if (bitLength > 3072) {  \/\/ 192 bits\n-            return \"SHA384\";\n-        } else  { \/\/ 128 bits and less\n-            return \"SHA256\";\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AlgorithmId.java","additions":4,"deletions":218,"binary":false,"changes":222,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.security.spec.AlgorithmParameterSpec;\n@@ -460,2 +459,1 @@\n-     * @exception NoSuchAlgorithmException on unsupported signature\n-     * algorithms.\n+     * @exception NoSuchAlgorithmException on unsupported signature algorithms.\n@@ -468,2 +466,2 @@\n-    throws CRLException, NoSuchAlgorithmException, InvalidKeyException,\n-        NoSuchProviderException, SignatureException {\n+            throws CRLException, NoSuchAlgorithmException, InvalidKeyException,\n+                   NoSuchProviderException, SignatureException {\n@@ -478,1 +476,1 @@\n-     * @param provider the name of the provider.\n+     * @param provider (optional) the name of the provider.\n@@ -480,2 +478,1 @@\n-     * @exception NoSuchAlgorithmException on unsupported signature\n-     * algorithms.\n+     * @exception NoSuchAlgorithmException on unsupported signature algorithms.\n@@ -488,2 +485,2 @@\n-    throws CRLException, NoSuchAlgorithmException, InvalidKeyException,\n-        NoSuchProviderException, SignatureException {\n+            throws CRLException, NoSuchAlgorithmException, InvalidKeyException,\n+                   NoSuchProviderException, SignatureException {\n@@ -493,13 +490,0 @@\n-            Signature sigEngine = null;\n-            if (provider == null || provider.isEmpty())\n-                sigEngine = Signature.getInstance(algorithm);\n-            else\n-                sigEngine = Signature.getInstance(algorithm, provider);\n-\n-            AlgorithmParameterSpec params = AlgorithmId\n-                    .getDefaultAlgorithmParameterSpec(algorithm, key);\n-            try {\n-                SignatureUtil.initSignWithParam(sigEngine, key, params, null);\n-            } catch (InvalidAlgorithmParameterException e) {\n-                throw new SignatureException(e);\n-            }\n@@ -507,6 +491,2 @@\n-            if (params != null) {\n-                sigAlgId = AlgorithmId.get(sigEngine.getParameters());\n-            } else {\n-                \/\/ in case the name is reset\n-                sigAlgId = AlgorithmId.get(sigEngine.getAlgorithm());\n-            }\n+            Signature sigEngine = SignatureUtil.fromKey(algorithm, key, provider);\n+            sigAlgId = SignatureUtil.fromSignature(sigEngine, key);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509CRLImpl.java","additions":9,"deletions":29,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.security.spec.AlgorithmParameterSpec;\n@@ -281,0 +280,3 @@\n+     * The ALGORITHM_ID attribute will be rewritten when signed. The initial\n+     * value is ignored.\n+     *\n@@ -513,2 +515,1 @@\n-     * @exception NoSuchAlgorithmException on unsupported signature\n-     * algorithms.\n+     * @exception NoSuchAlgorithmException on unsupported signature algorithms.\n@@ -520,2 +521,2 @@\n-    throws CertificateException, NoSuchAlgorithmException,\n-        InvalidKeyException, NoSuchProviderException, SignatureException {\n+            throws CertificateException, NoSuchAlgorithmException,\n+            InvalidKeyException, NoSuchProviderException, SignatureException {\n@@ -533,1 +534,1 @@\n-     * @param provider the name of the provider.\n+     * @param provider (optional) the name of the provider.\n@@ -535,2 +536,1 @@\n-     * @exception NoSuchAlgorithmException on unsupported signature\n-     * algorithms.\n+     * @exception NoSuchAlgorithmException on unsupported signature algorithms.\n@@ -543,35 +543,0 @@\n-    throws CertificateException, NoSuchAlgorithmException,\n-        InvalidKeyException, NoSuchProviderException, SignatureException {\n-        try {\n-            sign(key, null, algorithm, provider);\n-        } catch (InvalidAlgorithmParameterException e) {\n-            \/\/ should not happen; re-throw just in case\n-            throw new SignatureException(e);\n-        }\n-    }\n-\n-    \/**\n-     * Creates an X.509 certificate, and signs it using the given key\n-     * (associating a signature algorithm and an X.500 name), signature\n-     * parameters, and security provider. If the given provider name\n-     * is null or empty, the implementation look up will be based on\n-     * provider configurations.\n-     * This operation is used to implement the certificate generation\n-     * functionality of a certificate authority.\n-     *\n-     * @param key the private key used for signing\n-     * @param signingParams the parameters used for signing\n-     * @param algorithm the name of the signature algorithm used\n-     * @param provider the name of the provider, may be null\n-     *\n-     * @exception NoSuchAlgorithmException on unsupported signature\n-     *            algorithms\n-     * @exception InvalidKeyException on incorrect key\n-     * @exception InvalidAlgorithmParameterException on invalid signature\n-     *            parameters\n-     * @exception NoSuchProviderException on incorrect provider\n-     * @exception SignatureException on signature errors\n-     * @exception CertificateException on encoding errors\n-     *\/\n-    public void sign(PrivateKey key, AlgorithmParameterSpec signingParams,\n-            String algorithm, String provider)\n@@ -579,2 +544,1 @@\n-            InvalidKeyException, InvalidAlgorithmParameterException,\n-            NoSuchProviderException, SignatureException {\n+            InvalidKeyException, NoSuchProviderException, SignatureException {\n@@ -586,6 +550,3 @@\n-            Signature sigEngine = null;\n-            if (provider == null || provider.isEmpty()) {\n-                sigEngine = Signature.getInstance(algorithm);\n-            } else {\n-                sigEngine = Signature.getInstance(algorithm, provider);\n-            }\n+            Signature sigEngine = SignatureUtil.fromKey(\n+                    algorithm, key, provider);\n+            algId = SignatureUtil.fromSignature(sigEngine, key);\n@@ -593,9 +554,0 @@\n-            SignatureUtil.initSignWithParam(sigEngine, key, signingParams,\n-                    null);\n-\n-            if (signingParams != null) {\n-                algId = AlgorithmId.get(sigEngine.getParameters());\n-            } else {\n-                \/\/ in case the name is reset\n-                algId = AlgorithmId.get(sigEngine.getAlgorithm());\n-            }\n@@ -606,0 +558,2 @@\n+            info.set(X509CertInfo.ALGORITHM_ID,\n+                    new CertificateAlgorithmId(algId));\n@@ -624,1 +578,1 @@\n-      }\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509CertImpl.java","additions":15,"deletions":61,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -32,0 +32,4 @@\n+import sun.security.pkcs.PKCS7;\n+import sun.security.pkcs.PKCS9Attribute;\n+import sun.security.pkcs.PKCS9Attributes;\n+import sun.security.timestamp.HttpTimestamper;\n@@ -37,0 +41,1 @@\n+import sun.security.util.SignatureUtil;\n@@ -50,0 +55,1 @@\n+import java.security.spec.InvalidParameterSpecException;\n@@ -52,0 +58,1 @@\n+import java.util.function.Function;\n@@ -116,2 +123,3 @@\n-        boolean signManifest = true;\n-        boolean externalSF = true;\n+        boolean sectionsonly = false;\n+        boolean internalsf = false;\n+        boolean directsign = false;\n@@ -239,2 +247,1 @@\n-            AlgorithmId.checkKeyAndSigAlgMatch(\n-                    privateKey.getAlgorithm(), algorithm);\n+            SignatureUtil.checkKeyAndSigAlgMatch(privateKey, algorithm);\n@@ -270,2 +277,1 @@\n-            AlgorithmId.checkKeyAndSigAlgMatch(\n-                    privateKey.getAlgorithm(), algorithm);\n+            SignatureUtil.checkKeyAndSigAlgMatch(privateKey, algorithm);\n@@ -355,0 +361,4 @@\n+         * <li>\"directsign\": \"true\" if the signature is calculated on the\n+         * content directly, \"false\" if it's calculated on signed attributes\n+         * which itself is calculated from the content and stored in the\n+         * signer's SignerInfo. Default \"false\".\n@@ -383,11 +393,1 @@\n-                    switch (value) {\n-                        case \"true\":\n-                            externalSF = false;\n-                            break;\n-                        case \"false\":\n-                            externalSF = true;\n-                            break;\n-                        default:\n-                            throw new IllegalArgumentException(\n-                                \"Invalid internalsf value\");\n-                    }\n+                    this.internalsf = parseBoolean(\"interalsf\", value);\n@@ -396,11 +396,4 @@\n-                    switch (value) {\n-                        case \"true\":\n-                            signManifest = false;\n-                            break;\n-                        case \"false\":\n-                            signManifest = true;\n-                            break;\n-                        default:\n-                            throw new IllegalArgumentException(\n-                                \"Invalid signManifest value\");\n-                    }\n+                    this.sectionsonly = parseBoolean(\"sectionsonly\", value);\n+                    break;\n+                case \"directsign\":\n+                    this.directsign = parseBoolean(\"directsign\", value);\n@@ -421,0 +414,12 @@\n+        private static boolean parseBoolean(String name, String value) {\n+            switch (value) {\n+                case \"true\":\n+                    return true;\n+                case \"false\":\n+                    return false;\n+                default:\n+                    throw new IllegalArgumentException(\n+                            \"Invalid \" + name + \" value\");\n+            }\n+        }\n+\n@@ -456,1 +461,3 @@\n-            return AlgorithmId.getDefaultSigAlgForKey(Objects.requireNonNull(key));\n+            \/\/ Attention: sync the spec with SignatureUtil::ecStrength and\n+            \/\/ SignatureUtil::ifcFfcStrength.\n+            return SignatureUtil.getDefaultSigAlgForKey(Objects.requireNonNull(key));\n@@ -504,2 +511,5 @@\n-    private final boolean signManifest; \/\/ \"sign\" the whole manifest\n-    private final boolean externalSF; \/\/ leave the .SF out of the PKCS7 block\n+    private final boolean sectionsonly; \/\/ do not \"sign\" the whole manifest\n+    private final boolean internalsf; \/\/ include the .SF inside the PKCS7 block\n+    private final boolean directsign;\n+\n+    @Deprecated(since=\"16\", forRemoval=true)\n@@ -507,0 +517,1 @@\n+    @Deprecated(since=\"16\", forRemoval=true)\n@@ -548,2 +559,2 @@\n-        this.signManifest = builder.signManifest;\n-        this.externalSF = builder.externalSF;\n+        this.sectionsonly = builder.sectionsonly;\n+        this.internalsf = builder.internalsf;\n@@ -552,0 +563,4 @@\n+\n+        this.directsign = this.altSigner != null\n+                ? true\n+                : builder.directsign;\n@@ -577,1 +592,2 @@\n-        } catch (NoSuchAlgorithmException | InvalidKeyException e) {\n+        } catch (NoSuchAlgorithmException | InvalidKeyException\n+                | InvalidParameterSpecException e) {\n@@ -648,1 +664,1 @@\n-                return Boolean.toString(!externalSF);\n+                return Boolean.toString(internalsf);\n@@ -650,1 +666,1 @@\n-                return Boolean.toString(!signManifest);\n+                return Boolean.toString(sectionsonly);\n@@ -653,0 +669,2 @@\n+            case \"directsign\":\n+                return Boolean.toString(directsign);\n@@ -663,1 +681,1 @@\n-            SignatureException, InvalidKeyException {\n+            SignatureException, InvalidKeyException, InvalidParameterSpecException {\n@@ -832,1 +850,1 @@\n-                signerName, signManifest);\n+                signerName, sectionsonly);\n@@ -836,8 +854,0 @@\n-        Signature signer;\n-        if (sigProvider == null ) {\n-            signer = Signature.getInstance(sigalg);\n-        } else {\n-            signer = Signature.getInstance(sigalg, sigProvider);\n-        }\n-        signer.initSign(privateKey);\n-\n@@ -848,8 +858,54 @@\n-        signer.update(content);\n-        byte[] signature = signer.sign();\n-\n-        @SuppressWarnings(\"removal\")\n-        ContentSigner signingMechanism = null;\n-        if (altSigner != null) {\n-            signingMechanism = loadSigningMechanism(altSigner,\n-                    altSignerPath);\n+        \/\/ Use new method is directSign is false or it's a modern\n+        \/\/ algorithm not supported by existing ContentSigner.\n+        \/\/ Make this always true after we remove ContentSigner.\n+        boolean useNewMethod = !directsign\n+                || !sigalg.toUpperCase(Locale.ENGLISH).contains(\"WITH\");\n+\n+        \/\/ For newer sigalg without \"with\", always use the new PKCS7\n+        \/\/ generateToken method. Otherwise, use deprecated ContentSigner.\n+        if (useNewMethod) {\n+            if (altSigner != null) {\n+                throw new IllegalArgumentException(directsign\n+                        ? (\"Customized ContentSigner is not supported for \" + sigalg)\n+                        : \"Customized ContentSigner does not support authenticated attributes\");\n+            }\n+            Function<byte[], PKCS9Attributes> timestamper = null;\n+            if (tsaUrl != null) {\n+                timestamper = s -> {\n+                    try {\n+                        \/\/ Timestamp the signature\n+                        HttpTimestamper tsa = new HttpTimestamper(tsaUrl);\n+                        byte[] tsToken = PKCS7.generateTimestampToken(\n+                                tsa, tSAPolicyID, tSADigestAlg, s);\n+\n+                        return new PKCS9Attributes(new PKCS9Attribute[]{\n+                                new PKCS9Attribute(\n+                                        PKCS9Attribute.SIGNATURE_TIMESTAMP_TOKEN_OID,\n+                                        tsToken)});\n+                    } catch (IOException | CertificateException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                };\n+            }\n+            \/\/ We now create authAttrs in block data, so \"direct == false\".\n+            block = PKCS7.generateNewSignedData(sigalg, sigProvider, privateKey, certChain,\n+                    content, internalsf, directsign, timestamper);\n+        } else {\n+            Signature signer = SignatureUtil.fromKey(sigalg, privateKey, sigProvider);\n+            signer.update(content);\n+            byte[] signature = signer.sign();\n+\n+            @SuppressWarnings(\"removal\")\n+            ContentSignerParameters params =\n+                    new JarSignerParameters(null, tsaUrl, tSAPolicyID,\n+                            tSADigestAlg, signature,\n+                            signer.getAlgorithm(), certChain, content, zipFile);\n+            @SuppressWarnings(\"removal\")\n+            ContentSigner signingMechanism = (altSigner != null)\n+                    ? loadSigningMechanism(altSigner, altSignerPath)\n+                    : new TimestampedSigner();\n+            block = signingMechanism.generateSignedData(\n+                    params,\n+                    !internalsf,\n+                    params.getTimestampingAuthority() != null\n+                            || params.getTimestampingAuthorityCertificate() != null);\n@@ -858,7 +914,0 @@\n-        @SuppressWarnings(\"removal\")\n-        ContentSignerParameters params =\n-                new JarSignerParameters(null, tsaUrl, tSAPolicyID,\n-                        tSADigestAlg, signature,\n-                        signer.getAlgorithm(), certChain, content, zipFile);\n-        block = sf.generateBlock(params, externalSF, signingMechanism);\n-\n@@ -1124,1 +1173,1 @@\n-                             boolean signManifest) {\n+                             boolean sectionsonly) {\n@@ -1137,1 +1186,1 @@\n-            if (signManifest) {\n+            if (!sectionsonly) {\n@@ -1191,20 +1240,2 @@\n-            String keyAlgorithm = privateKey.getAlgorithm();\n-            return getBaseSignatureFilesName(baseName) + keyAlgorithm;\n-        }\n-\n-        \/\/ Generates the PKCS#7 content of block file\n-        @SuppressWarnings(\"removal\")\n-        public byte[] generateBlock(ContentSignerParameters params,\n-                                    boolean externalSF,\n-                                    ContentSigner signingMechanism)\n-                throws NoSuchAlgorithmException,\n-                       IOException, CertificateException {\n-\n-            if (signingMechanism == null) {\n-                signingMechanism = new TimestampedSigner();\n-            }\n-            return signingMechanism.generateSignedData(\n-                    params,\n-                    externalSF,\n-                    params.getTimestampingAuthority() != null\n-                        || params.getTimestampingAuthorityCertificate() != null);\n+            String type = SignatureFileVerifier.getBlockExtension(privateKey);\n+            return getBaseSignatureFilesName(baseName) + type;\n@@ -1215,0 +1246,1 @@\n+    @Deprecated(since=\"16\", forRemoval=true)\n","filename":"src\/jdk.jartool\/share\/classes\/jdk\/security\/jarsigner\/JarSigner.java","additions":115,"deletions":83,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -166,0 +166,1 @@\n+    boolean directSign = false; \/\/ sign SF directly or thru signedAttrs\n@@ -475,0 +476,2 @@\n+            } else if (collator.compare(flags, \"-directsign\") ==0) {\n+                directSign = true;\n@@ -663,0 +666,3 @@\n+        System.out.println(rb.getString\n+                (\".directsign.sign.the.SF.file.directly.no.signed.attributes\"));\n+        System.out.println();\n@@ -958,3 +964,4 @@\n-                            String sigAlg = AlgorithmId.makeSigAlg(\n-                                    si.getDigestAlgorithmId().getName(),\n-                                    si.getDigestEncryptionAlgorithmId().getName());\n+                            String sigAlg = SignerInfo.makeSigAlg(\n+                                    si.getDigestAlgorithmId(),\n+                                    si.getDigestEncryptionAlgorithmId(),\n+                                    si.getAuthenticatedAttributes() == null);\n@@ -971,3 +978,4 @@\n-                                String tsSigAlg = AlgorithmId.makeSigAlg(\n-                                        tsSi.getDigestAlgorithmId().getName(),\n-                                        tsSi.getDigestEncryptionAlgorithmId().getName());\n+                                String tsSigAlg = SignerInfo.makeSigAlg(\n+                                        tsSi.getDigestAlgorithmId(),\n+                                        tsSi.getDigestEncryptionAlgorithmId(),\n+                                        tsSi.getAuthenticatedAttributes() == null);\n@@ -1601,1 +1609,1 @@\n-     * {@link #store} (as values).\n+     * {@link #keystore} (as values).\n@@ -1728,1 +1736,1 @@\n-            tsaURI = TimestampedSigner.getTimestampingURI(tsaCert);\n+            tsaURI = PKCS7.getTimestampingURI(tsaCert);\n@@ -1768,0 +1776,1 @@\n+        builder.setProperty(\"directsign\", Boolean.toString(directSign));\n@@ -1833,1 +1842,2 @@\n-                    \"META-INF\/\" + sigfile + \".\" + privateKey.getAlgorithm())));\n+                    \"META-INF\/\" + sigfile + \".\"\n+                            + SignatureFileVerifier.getBlockExtension(privateKey))));\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Main.java","additions":19,"deletions":9,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -104,0 +104,2 @@\n+        {\".directsign.sign.the.SF.file.directly.no.signed.attributes\",\n+                \"[-directsign]               sign the .SF file directly (no signed attributes)\"},\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Resources.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-import sun.security.util.*;\n-import sun.security.x509.*;\n@@ -48,0 +46,1 @@\n+@Deprecated(since=\"16\", forRemoval=true)\n@@ -51,6 +50,0 @@\n-    \/*\n-     * Object identifier for the timestamping access descriptors.\n-     *\/\n-    private static final ObjectIdentifier AD_TIMESTAMPING_Id =\n-            ObjectIdentifier.of(KnownOIDs.AD_TimeStamping);\n-\n@@ -96,6 +89,0 @@\n-        \/\/ Parse the signature algorithm to extract the digest\n-        \/\/ algorithm. The expected format is:\n-        \/\/     \"<digest>with<encryption>\"\n-        \/\/ or  \"<digest>with<encryption>and<mgf>\"\n-        String signatureAlgorithm = params.getSignatureAlgorithm();\n-\n@@ -113,1 +100,1 @@\n-                tsaURI = getTimestampingURI(\n+                tsaURI = PKCS7.getTimestampingURI(\n@@ -126,48 +113,0 @@\n-\n-    \/**\n-     * Examine the certificate for a Subject Information Access extension\n-     * (<a href=\"http:\/\/tools.ietf.org\/html\/rfc5280\">RFC 5280<\/a>).\n-     * The extension's {@code accessMethod} field should contain the object\n-     * identifier defined for timestamping: 1.3.6.1.5.5.7.48.3 and its\n-     * {@code accessLocation} field should contain an HTTP or HTTPS URL.\n-     *\n-     * @param tsaCertificate An X.509 certificate for the TSA.\n-     * @return An HTTP or HTTPS URI or null if none was found.\n-     *\/\n-    public static URI getTimestampingURI(X509Certificate tsaCertificate) {\n-\n-        if (tsaCertificate == null) {\n-            return null;\n-        }\n-        \/\/ Parse the extensions\n-        try {\n-            byte[] extensionValue = tsaCertificate.getExtensionValue\n-                    (KnownOIDs.SubjectInfoAccess.value());\n-            if (extensionValue == null) {\n-                return null;\n-            }\n-            DerInputStream der = new DerInputStream(extensionValue);\n-            der = new DerInputStream(der.getOctetString());\n-            DerValue[] derValue = der.getSequence(5);\n-            AccessDescription description;\n-            GeneralName location;\n-            URIName uri;\n-            for (int i = 0; i < derValue.length; i++) {\n-                description = new AccessDescription(derValue[i]);\n-                if (description.getAccessMethod()\n-                        .equals(AD_TIMESTAMPING_Id)) {\n-                    location = description.getAccessLocation();\n-                    if (location.getType() == GeneralNameInterface.NAME_URI) {\n-                        uri = (URIName) location.getName();\n-                        if (uri.getScheme().equalsIgnoreCase(\"http\") ||\n-                                uri.getScheme().equalsIgnoreCase(\"https\")) {\n-                            return uri.getURI();\n-                        }\n-                    }\n-                }\n-            }\n-        } catch (IOException ioe) {\n-            \/\/ ignore\n-        }\n-        return null;\n-    }\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/TimestampedSigner.java","additions":2,"deletions":63,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8242068\n+ * @summary test the properties\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.tools.keytool\n+ *          java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ *          jdk.jartool\n+ *\/\n+\n+import jdk.security.jarsigner.JarSigner;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.security.DerUtils;\n+import jdk.test.lib.util.JarUtils;\n+import sun.security.tools.keytool.CertAndKeyGen;\n+import sun.security.x509.X500Name;\n+\n+import java.io.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.cert.CertificateFactory;\n+import java.util.List;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarInputStream;\n+import java.util.zip.ZipFile;\n+\n+public class Properties {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        Files.writeString(Path.of(\"anything\"), \"anything\");\n+        JarUtils.createJarFile(Path.of(\"src.jar\"), Path.of(\".\"),\n+                Files.write(Path.of(\"anything\"), new byte[100]));\n+\n+        var cakg = new CertAndKeyGen(\"EC\", \"SHA1withECDSA\");\n+        cakg.generate(\"secp256r1\");\n+        JarSigner.Builder jsb = new JarSigner.Builder(\n+                cakg.getPrivateKey(),\n+                CertificateFactory.getInstance(\"X.509\").generateCertPath(List.of(\n+                        cakg.getSelfCertificate(new X500Name(\"CN=Me\"), 100))));\n+        jsb.signerName(\"E\");\n+        String sf;\n+\n+        byte[] i0 = sign(jsb.setProperty(\"internalsf\", \"false\"));\n+        \/\/ EncapsulatedContentInfo no content\n+        DerUtils.shouldNotExist(i0, \"1021\");\n+\n+        byte[] i1 = sign(jsb.setProperty(\"internalsf\", \"true\"));\n+        \/\/ EncapsulatedContentInfo has content being the SF\n+        sf = new String(DerUtils.innerDerValue(i1, \"10210\").getOctetString());\n+        Asserts.assertTrue(sf.startsWith(\"Signature-Version\"));\n+\n+        \/\/ There is a SignedAttributes\n+        byte[] d0 = sign(jsb.setProperty(\"directsign\", \"false\"));\n+        Asserts.assertTrue(DerUtils.innerDerValue(d0, \"10403\")\n+                .isContextSpecific((byte)0));\n+\n+        \/\/ There is no SignedAttributes\n+        byte[] d1 = sign(jsb.setProperty(\"directsign\", \"true\"));\n+        Asserts.assertFalse(DerUtils.innerDerValue(d1, \"10403\")\n+                .isContextSpecific((byte)0));\n+\n+        \/\/ Has a hash for the whole manifest\n+        byte[] s0 = sign(jsb.setProperty(\"sectionsonly\", \"false\"));\n+        sf = new String(DerUtils.innerDerValue(s0, \"10210\").getOctetString());\n+        Asserts.assertTrue(sf.contains(\"SHA-256-Digest-Manifest:\"));\n+\n+        \/\/ Has no hash for the whole manifest\n+        byte[] s1 = sign(jsb.setProperty(\"sectionsonly\", \"true\"));\n+        sf = new String(DerUtils.innerDerValue(s1, \"10210\").getOctetString());\n+        Asserts.assertFalse(sf.contains(\"SHA-256-Digest-Manifest:\"));\n+    }\n+\n+    \/\/ Sign and returns the content of the PKCS7 signature block inside\n+    static byte[] sign(JarSigner.Builder b) throws Exception {\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        try (ZipFile zf = new ZipFile(\"src.jar\")) {\n+            b.build().sign(zf, bout);\n+        }\n+        var jf = new JarInputStream(\n+                new ByteArrayInputStream(bout.toByteArray()));\n+        while (true) {\n+            JarEntry je = jf.getNextJarEntry();\n+            if (je == null) {\n+                throw new RuntimeException(\"Cannot find signature\");\n+            }\n+            if (je.getName().equals(\"META-INF\/E.EC\")) {\n+                return jf.readAllBytes();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/security\/jarsigner\/Properties.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -128,1 +128,3 @@\n-        npe(()->b1.setProperty(\"altsigner\", null));\n+        npe(()->b1.setProperty(\"sectionsonly\", null));\n+        iae(()->b1.setProperty(\"directsign\", \"OK\"));\n+        npe(()->b1.setProperty(\"directsign\", null));\n@@ -146,0 +148,1 @@\n+        assertTrue(js2.getProperty(\"directsign\").equals(\"false\"));\n@@ -162,0 +165,1 @@\n+                .setProperty(\"directsign\", \"true\")\n@@ -174,0 +178,1 @@\n+        assertTrue(js3.getProperty(\"directsign\").equals(\"true\"));\n","filename":"test\/jdk\/jdk\/security\/jarsigner\/Spec.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.security.Signature;\n@@ -83,3 +82,0 @@\n-        Signature signature = Signature.getInstance(sigAlg);\n-        signature.initSign(privateKey);\n-\n@@ -98,1 +94,1 @@\n-        req.encodeAndSign(subject, signature);\n+        req.encodeAndSign(subject, privateKey, sigAlg);\n","filename":"test\/jdk\/sun\/security\/pkcs\/pkcs10\/PKCS10AttrEncoding.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n- * @bug 8242184\n- * @summary CRL generation error with RSASSA-PSS\n+ * @bug 8242184 8242068\n+ * @summary keytool and jarsigner for all algorithms\n@@ -29,0 +29,2 @@\n+ * @modules java.base\/sun.security.util\n+ * @run testng\/timeout=300 GenerateAll\n@@ -33,0 +35,24 @@\n+import jdk.test.lib.security.DerUtils;\n+import jdk.test.lib.util.JarUtils;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+import static sun.security.util.KnownOIDs.*;\n+\n+import sun.security.util.KnownOIDs;\n+import sun.security.util.ObjectIdentifier;\n+import sun.security.util.SignatureUtil;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.util.Base64;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import java.util.stream.Collectors;\n@@ -36,1 +62,91 @@\n-    public static void main(String[] args) throws Throwable {\n+    @BeforeTest\n+    public void beforeTest() throws Exception {\n+        \/\/ Create a CA in a separate keystore\n+        kt(\"-genkeypair -alias ca -dname CN=CA -keyalg ec -ext bc -keystore ca\");\n+        kt(\"-export -alias ca -file ca.crt -rfc -keystore ca\");\n+\n+        \/\/ Import CA cert to user keystore so we can import reply later\n+        kt(\"-import -alias root -file ca.crt -noprompt\");\n+\n+        JarUtils.createJarFile(Path.of(\"a.jar\"), Path.of(\".\"), Path.of(\"ks\"));\n+    }\n+\n+    @DataProvider(name = \"eddsa\")\n+    public Object[][] eddsaData() {\n+        return new Object[][]{\n+                {\"eddsa\", null, \"ed25519\"},\n+                {\"eddsa\", \"eddsa\", \"ed25519\"},\n+                {\"eddsa\", \"ed25519\", \"ed25519\"},\n+                {\"eddsa\", \"ed448\", null},\n+                {\"ed25519\", null, \"ed25519\"},\n+                {\"ed25519\", \"eddsa\", \"ed25519\"},\n+                {\"ed25519\", \"ed25519\", \"ed25519\"},\n+                {\"ed25519\", \"ed448\", null},\n+                {\"ed448\", null, \"ed448\"},\n+                {\"ed448\", \"eddsa\", \"ed448\"},\n+                {\"ed448\", \"ed25519\", null},\n+                {\"ed448\", \"ed448\", \"ed448\"},\n+        };\n+    }\n+\n+    \/**\n+     * Test various names of EdDSA\n+     * @param keyAlg keytool -keyalg\n+     * @param sigAlg (optional) keytool -sigalg\n+     * @param expected expected algorithm of generated signature\n+     *\/\n+    @Test(dataProvider = \"eddsa\")\n+    public void eddsaTest(String keyAlg, String sigAlg, String expected)\n+            throws Exception {\n+        String alias = keyAlg + \"-\" + sigAlg;\n+        OutputAnalyzer oa = kt0(\"-genkeypair -alias \" + alias\n+                + \" -dname CN=\" + alias + \" -keyalg \" + keyAlg\n+                + (sigAlg == null ? \"\" : (\" -sigalg \" + sigAlg)));\n+        if (expected == null) {\n+            oa.shouldNotHaveExitValue(0);\n+        } else {\n+            oa.shouldHaveExitValue(0);\n+            kt(\"-alias \" + alias + \" -export -file \" + alias + \".crt\");\n+            byte[] crt = Files.readAllBytes(Path.of(alias + \".crt\"));\n+            ObjectIdentifier oid = oid(expected);\n+            DerUtils.checkAlg(crt, \"020\", oid);     \/\/ tbsCertificate.signature\n+            DerUtils.checkAlg(crt, \"0600\", oid);    \/\/ tbsCertificate.subjectPublicKeyInfo.algorithm\n+            DerUtils.checkAlg(crt, \"10\", oid);      \/\/ signatureAlgorithm\n+        }\n+    }\n+\n+    @DataProvider(name = \"all\")\n+    public Object[][] dataProvider() {\n+        return new Object[][]{\n+                {\"rsa\", \"rsa\", null, \"RSA\", SHA_256, SHA256withRSA},\n+                {\"dsa\", \"dsa\", null, \"DSA\", SHA_256, SHA256withDSA},\n+                {\"r\", \"rsa\", \"rsassa-pss\", \"RSA\", SHA_256, RSASSA_PSS},\n+                {\"pss\", \"rsassa-pss\", null, \"RSA\", SHA_256, RSASSA_PSS},\n+                {\"ec\", \"ec\", null, \"EC\", SHA_256, SHA256withECDSA},\n+                {\"ed25519\", \"ed25519\", null, \"EC\", SHA_512, Ed25519},\n+                {\"ed448\", \"ed448\", null, \"EC\", SHAKE256_LEN, Ed448},\n+        };\n+    }\n+\n+    \/**\n+     * Testing all algorithms.\n+     * @param alias alias\n+     * @param keyAlg keytool -keyalg\n+     * @param sigAlg (optional) keytool -sigalg\n+     * @param ext block extension inside signed JAR\n+     * @param expDigAlg expected digAlg in PKCS7 SignerInfo\n+     * @param expEncAlg expected encAlg in PKCS7 SignerInfo\n+     *\/\n+    @Test(dataProvider = \"all\")\n+    public void test(String alias, String keyAlg, String sigAlg, String ext,\n+                     KnownOIDs expDigAlg, KnownOIDs expEncAlg) throws Throwable {\n+\n+        char[] pass = \"changeit\".toCharArray();\n+\n+        \/\/ If no sigAlg, derive automatically\n+        String extra = sigAlg == null ? \"\" : (\" -sigalg \" + sigAlg);\n+\n+        \/\/ gen\n+        kt(\"-genkeypair -alias \" + alias + \" -dname CN=\" + alias\n+                + \" -keyalg \" + keyAlg + extra);\n+        kt(\"-export -alias \" + alias + \" -rfc -file \" + alias + \".self\");\n@@ -38,1 +154,3 @@\n-        kt(\"-genkeypair -alias ca -dname CN=CA -keyalg ec\");\n+        \/\/ req\n+        kt(\"-certreq -alias \" + alias + \" -file \" + alias + \".req\" + extra);\n+        kt(\"-printcertreq -file \" + alias + \".req\");\n@@ -40,2 +158,5 @@\n-        String[] aliases = {\n-                \"rsa\", \"dsa\", \"rrr\", \"rsassa-pss\", \"ec\"};\n+        \/\/ gencert\n+        kt(\"-gencert -alias ca -infile \" + alias\n+                + \".req -outfile \" + alias + \".crt -rfc -keystore ca\");\n+        kt(\"-printcert -file \" + alias + \".crt\");\n+        kt(\"-importcert -alias \" + alias + \" -file \" + alias + \".crt\");\n@@ -43,5 +164,5 @@\n-        for (String alias : aliases) {\n-            \/\/ \"rrr\": keyalg is rsa, sigalg is rsassa-pss\n-            \/\/ otherwise: keyalg is alias, sigalg auto derived\n-            String keyAlg = alias.equals(\"rrr\") ? \"rsa\" : alias;\n-            String extra = alias.equals(\"rrr\") ? \" -sigalg rsassa-pss\" : \"\";\n+        \/\/ crl\n+        kt(\"-gencrl -alias \" + alias + \" -id 0 -rfc -file \"\n+                + alias + \".crl\" + extra);\n+        kt(\"-printcrl -file \" + alias + \".crl\")\n+                .shouldContain(\"Verified by \" + alias);\n@@ -49,3 +170,2 @@\n-            \/\/ gen\n-            kt(\"-genkeypair -alias \" + alias + \" -dname CN=\" + alias\n-                    + \" -keyalg \" + keyAlg + extra);\n+        \/\/ sign\n+        js(\"a.jar \" + alias + extra);\n@@ -53,3 +173,3 @@\n-            \/\/ req\n-            kt(\"-certreq -alias \" + alias + \" -file \" + alias + \".req\");\n-            kt(\"-printcertreq -file \" + alias + \".req\");\n+        \/\/ check data\n+        KeyStore ks = KeyStore.getInstance(new File(\"ks\"), pass);\n+        PrivateKey pk = (PrivateKey)ks.getKey(alias, pass);\n@@ -57,4 +177,14 @@\n-            \/\/ gencert\n-            kt(\"-gencert -alias ca -infile \" + alias\n-                    + \".req -outfile \" + alias + \".crt\");\n-            kt(\"-printcert -file \" + alias + \".crt\");\n+        if (sigAlg == null) {\n+            sigAlg = SignatureUtil.getDefaultSigAlgForKey(pk);\n+        }\n+\n+        byte[] crt = read(alias + \".self\");\n+        DerUtils.checkAlg(crt, \"020\", oid(sigAlg));  \/\/ tbsCertificate.signature\n+        DerUtils.checkAlg(crt, \"0600\", oid(keyAlg)); \/\/ tbsCertificate.subjectPublicKeyInfo.algorithm\n+        assertEquals(\n+                DerUtils.innerDerValue(crt, \"02\"),   \/\/ tbsCertificate.signature\n+                DerUtils.innerDerValue(crt, \"1\"));   \/\/ signatureAlgorithm\n+\n+        byte[] req = read(alias + \".req\");\n+        DerUtils.checkAlg(req, \"10\", oid(sigAlg));   \/\/ signatureAlgorithm\n+        DerUtils.checkAlg(req, \"0200\", oid(keyAlg)); \/\/ certificationRequestInfo.subjectPKInfo.algorithm\n@@ -62,4 +192,39 @@\n-            \/\/ crl\n-            kt(\"-gencrl -alias \" + alias + \" -id 0 -file \" + alias + \".crl\");\n-            kt(\"-printcrl -file \" + alias + \".crl\")\n-                    .shouldContain(\"Verified by \" + alias);\n+        byte[] crl = read(alias + \".crl\");\n+        DerUtils.checkAlg(crl, \"000\", oid(sigAlg));  \/\/ tbsCertList.signature\n+        assertEquals(\n+                DerUtils.innerDerValue(crl, \"00\"),   \/\/ tbsCertList.signature\n+                DerUtils.innerDerValue(crl, \"1\"));   \/\/ signatureAlgorithm\n+\n+        try (JarFile jf = new JarFile(\"a.jar\")) {\n+            JarEntry je = jf.getJarEntry(\n+                    \"META-INF\/\" + alias.toUpperCase() + \".\" + ext);\n+            byte[] p7 = jf.getInputStream(je).readAllBytes();\n+            \/\/ SignerInfo.digestAlgorithm\n+            DerUtils.checkAlg(p7, \"104020\", oid(expDigAlg));\n+            \/\/ SignerInfo.signatureAlgorithm\n+            if (DerUtils.innerDerValue(p7, \"10403\").isContextSpecific()) {\n+                \/\/ SignerInfo has signedAttributes at 104030\n+                DerUtils.checkAlg(p7, \"104040\", oid(expEncAlg));\n+            } else {\n+                DerUtils.checkAlg(p7, \"104030\", oid(expEncAlg));\n+            }\n+        }\n+    }\n+\n+    @AfterTest\n+    public void afterTest() throws Exception {\n+        js(\"-verify a.jar -verbose -certs\");\n+    }\n+\n+    static ObjectIdentifier oid(String name) {\n+        return ObjectIdentifier.of(KnownOIDs.findMatch(name));\n+    }\n+\n+    static ObjectIdentifier oid(KnownOIDs ko) {\n+        return ObjectIdentifier.of(ko);\n+    }\n+\n+    static byte[] read(String f) throws IOException {\n+        try (var v = Files.lines(Path.of(f))) {\n+            return Base64.getDecoder().decode(v.filter(s -> !s.startsWith(\"-----\"))\n+                    .collect(Collectors.joining(\"\")));\n@@ -70,1 +235,9 @@\n-        return SecurityTools.keytool(\"-keystore ks -storepass changeit \" + arg)\n+        return kt0(arg).shouldHaveExitValue(0);\n+    }\n+\n+    static OutputAnalyzer kt0(String arg) throws Exception {\n+        return SecurityTools.keytool(\"-keystore ks -storepass changeit \" + arg);\n+    }\n+\n+    static OutputAnalyzer js(String arg) throws Exception {\n+        return SecurityTools.jarsigner(\"-keystore ks -storepass changeit \" + arg)\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/GenerateAll.java","additions":199,"deletions":26,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -36,4 +36,1 @@\n-import java.util.Arrays;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.List;\n+import java.util.*;\n@@ -45,0 +42,1 @@\n+import sun.security.util.SignatureUtil;\n@@ -211,3 +209,12 @@\n-            String keyAlgo = sigAlgo == null\n-                             ? null\n-                             : AlgorithmId.getEncAlgFromSigAlg(sigAlgo);\n+            String keyAlgo;\n+            if (sigAlgo == null) {\n+                keyAlgo = null;\n+            } else {\n+                String lower = sigAlgo.toLowerCase(Locale.ROOT);\n+                int pos = lower.indexOf(\"with\");\n+                if (pos < 0) {\n+                    keyAlgo = sigAlgo;\n+                } else {\n+                    keyAlgo = sigAlgo.substring(pos + 4);\n+                }\n+            }\n","filename":"test\/lib\/jdk\/test\/lib\/security\/timestamp\/TsaHandler.java","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -37,4 +37,1 @@\n-import sun.security.util.DerOutputStream;\n-import sun.security.util.DerValue;\n-import sun.security.util.KnownOIDs;\n-import sun.security.util.ObjectIdentifier;\n+import sun.security.util.*;\n@@ -212,1 +209,1 @@\n-            String defaultSigAlgo =  AlgorithmId.getDefaultSigAlgForKey(\n+            String defaultSigAlgo =  SignatureUtil.getDefaultSigAlgForKey(\n@@ -224,2 +221,1 @@\n-                    AlgorithmId.get(\n-                            AlgorithmId.getDigAlgFromSigAlg(sigAlgo)),\n+                    AlgorithmId.get(SignatureUtil.extractDigestAlgFromDwithE(sigAlgo)),\n","filename":"test\/lib\/jdk\/test\/lib\/security\/timestamp\/TsaSigner.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"}]}