{"files":[{"patch":"@@ -27,0 +27,5 @@\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n@@ -40,10 +45,0 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.ConstantDynamic;\n-import jdk.internal.org.objectweb.asm.Handle;\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n-import jdk.internal.org.objectweb.asm.util.CheckClassAdapter;\n-import sun.security.action.GetBooleanAction;\n@@ -53,2 +48,5 @@\n-import java.io.PrintWriter;\n-import java.lang.constant.ConstantDescs;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.Constable;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -68,2 +66,3 @@\n-import static java.lang.invoke.MethodType.methodType;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import static java.lang.constant.ConstantDescs.*;\n+import static jdk.internal.classfile.Classfile.*;\n+import static jdk.internal.classfile.TypeKind.*;\n@@ -74,2 +73,0 @@\n-    private static final boolean PERFORM_VERIFICATION\n-        = GetBooleanAction.privilegedGetProperty(\"jdk.internal.foreign.abi.Specializer.PERFORM_VERIFICATION\");\n@@ -80,35 +77,40 @@\n-    private static final String OBJECT_DESC = Object.class.descriptorString();\n-    private static final String OBJECT_INTRN = Type.getInternalName(Object.class);\n-\n-    private static final String VOID_DESC = methodType(void.class).descriptorString();\n-\n-    private static final String ARENA_DESC = Arena.class.descriptorString();\n-    private static final String NEW_BOUNDED_ARENA_DESC = methodType(Arena.class, long.class).descriptorString();\n-    private static final String NEW_EMPTY_ARENA_DESC = methodType(Arena.class).descriptorString();\n-    private static final String SCOPE_DESC = methodType(MemorySegment.Scope.class).descriptorString();\n-    private static final String SESSION_IMPL_DESC = methodType(MemorySessionImpl.class).descriptorString();\n-    private static final String CLOSE_DESC = VOID_DESC;\n-    private static final String UNBOX_SEGMENT_DESC = methodType(long.class, MemorySegment.class).descriptorString();\n-    private static final String COPY_DESC = methodType(void.class, MemorySegment.class, long.class, MemorySegment.class, long.class, long.class).descriptorString();\n-    private static final String LONG_TO_ADDRESS_NO_SCOPE_DESC = methodType(MemorySegment.class, long.class, long.class, long.class).descriptorString();\n-    private static final String LONG_TO_ADDRESS_SCOPE_DESC = methodType(MemorySegment.class, long.class, long.class, long.class, MemorySessionImpl.class).descriptorString();\n-    private static final String ALLOCATE_DESC = methodType(MemorySegment.class, long.class, long.class).descriptorString();\n-    private static final String HANDLE_UNCAUGHT_EXCEPTION_DESC = methodType(void.class, Throwable.class).descriptorString();\n-    private static final String METHOD_HANDLES_INTRN = Type.getInternalName(MethodHandles.class);\n-    private static final String CLASS_DATA_DESC = methodType(Object.class, MethodHandles.Lookup.class, String.class, Class.class).descriptorString();\n-    private static final String RELEASE0_DESC = VOID_DESC;\n-    private static final String ACQUIRE0_DESC = VOID_DESC;\n-    private static final String INTEGER_TO_UNSIGNED_LONG_DESC = MethodType.methodType(long.class, int.class).descriptorString();\n-    private static final String SHORT_TO_UNSIGNED_LONG_DESC = MethodType.methodType(long.class, short.class).descriptorString();\n-    private static final String BYTE_TO_UNSIGNED_LONG_DESC = MethodType.methodType(long.class, byte.class).descriptorString();\n-\n-    private static final Handle BSM_CLASS_DATA = new Handle(\n-            H_INVOKESTATIC,\n-            METHOD_HANDLES_INTRN,\n-            \"classData\",\n-            CLASS_DATA_DESC,\n-            false);\n-    private static final ConstantDynamic CLASS_DATA_CONDY = new ConstantDynamic(\n-            ConstantDescs.DEFAULT_NAME,\n-            OBJECT_DESC,\n-            BSM_CLASS_DATA);\n+    private static final MethodTypeDesc MTD_VOID = MethodTypeDesc.of(CD_void);\n+\n+    private static final ClassDesc CD_Arena = desc(Arena.class);\n+    private static final ClassDesc CD_MemorySegment = desc(MemorySegment.class);\n+    private static final ClassDesc CD_MemorySegment_Scope = desc(MemorySegment.Scope.class);\n+    private static final ClassDesc CD_SharedUtils = desc(SharedUtils.class);\n+    private static final ClassDesc CD_AbstractMemorySegmentImpl = desc(AbstractMemorySegmentImpl.class);\n+    private static final ClassDesc CD_MemorySessionImpl = desc(MemorySessionImpl.class);\n+    private static final ClassDesc CD_Utils = desc(Utils.class);\n+    private static final ClassDesc CD_SegmentAllocator = desc(SegmentAllocator.class);\n+    private static final ClassDesc CD_ValueLayout = desc(ValueLayout.class);\n+    private static final ClassDesc CD_ValueLayout_OfBoolean = desc(ValueLayout.OfBoolean.class);\n+    private static final ClassDesc CD_ValueLayout_OfByte = desc(ValueLayout.OfByte.class);\n+    private static final ClassDesc CD_ValueLayout_OfShort = desc(ValueLayout.OfShort.class);\n+    private static final ClassDesc CD_ValueLayout_OfChar = desc(ValueLayout.OfChar.class);\n+    private static final ClassDesc CD_ValueLayout_OfInt = desc(ValueLayout.OfInt.class);\n+    private static final ClassDesc CD_ValueLayout_OfLong = desc(ValueLayout.OfLong.class);\n+    private static final ClassDesc CD_ValueLayout_OfFloat = desc(ValueLayout.OfFloat.class);\n+    private static final ClassDesc CD_ValueLayout_OfDouble = desc(ValueLayout.OfDouble.class);\n+    private static final ClassDesc CD_AddressLayout = desc(AddressLayout.class);\n+\n+    private static final MethodTypeDesc MTD_NEW_BOUNDED_ARENA = MethodTypeDesc.of(CD_Arena, CD_long);\n+    private static final MethodTypeDesc MTD_NEW_EMPTY_ARENA = MethodTypeDesc.of(CD_Arena);\n+    private static final MethodTypeDesc MTD_SCOPE = MethodTypeDesc.of(CD_MemorySegment_Scope);\n+    private static final MethodTypeDesc MTD_SESSION_IMPL = MethodTypeDesc.of(CD_MemorySessionImpl);\n+    private static final MethodTypeDesc MTD_CLOSE = MTD_VOID;\n+    private static final MethodTypeDesc MTD_UNBOX_SEGMENT = MethodTypeDesc.of(CD_long, CD_MemorySegment);\n+    private static final MethodTypeDesc MTD_COPY = MethodTypeDesc.of(CD_void, CD_MemorySegment, CD_long, CD_MemorySegment, CD_long, CD_long);\n+    private static final MethodTypeDesc MTD_LONG_TO_ADDRESS_NO_SCOPE = MethodTypeDesc.of(CD_MemorySegment, CD_long, CD_long, CD_long);\n+    private static final MethodTypeDesc MTD_LONG_TO_ADDRESS_SCOPE = MethodTypeDesc.of(CD_MemorySegment, CD_long, CD_long, CD_long, CD_MemorySessionImpl);\n+    private static final MethodTypeDesc MTD_ALLOCATE = MethodTypeDesc.of(CD_MemorySegment, CD_long, CD_long);\n+    private static final MethodTypeDesc MTD_HANDLE_UNCAUGHT_EXCEPTION = MethodTypeDesc.of(CD_void, CD_Throwable);\n+    private static final MethodTypeDesc MTD_RELEASE0 = MTD_VOID;\n+    private static final MethodTypeDesc MTD_ACQUIRE0 = MTD_VOID;\n+    private static final MethodTypeDesc MTD_INTEGER_TO_UNSIGNED_LONG = MethodTypeDesc.of(CD_long, CD_int);\n+    private static final MethodTypeDesc MTD_SHORT_TO_UNSIGNED_LONG = MethodTypeDesc.of(CD_long, CD_short);\n+    private static final MethodTypeDesc MTD_BYTE_TO_UNSIGNED_LONG = MethodTypeDesc.of(CD_long, CD_byte);\n+    private static final MethodTypeDesc MTD_BYTE_TO_BOOLEAN = MethodTypeDesc.of(CD_boolean, CD_byte);\n+\n+    private static final ConstantDesc CLASS_DATA_DESC = DynamicConstantDesc.of(BSM_CLASS_DATA);\n@@ -120,2 +122,0 @@\n-    private static final String SUPER_NAME = OBJECT_INTRN;\n-\n@@ -123,1 +123,1 @@\n-    private final MethodVisitor mv;\n+    private final CodeBuilder cb;\n@@ -129,2 +129,0 @@\n-    private int localIdx = 0;\n-    private int[] paramIndex2ParamSlot;\n@@ -143,2 +141,3 @@\n-    private BindingSpecializer(MethodVisitor mv, MethodType callerMethodType, CallingSequence callingSequence, ABIDescriptor abi, MethodType leafType) {\n-        this.mv = mv;\n+    private BindingSpecializer(CodeBuilder cb, MethodType callerMethodType,\n+                               CallingSequence callingSequence, ABIDescriptor abi, MethodType leafType) {\n+        this.cb = cb;\n@@ -189,10 +188,4 @@\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(CLASSFILE_VERSION, ACC_PUBLIC + ACC_FINAL + ACC_SUPER, className, null, SUPER_NAME, null);\n-\n-        String descriptor = callerMethodType.descriptorString();\n-        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, METHOD_NAME, descriptor, null, null);\n-\n-        new BindingSpecializer(mv, callerMethodType, callingSequence, abi, leafType).specialize();\n-\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n+        byte[] bytes = Classfile.build(ClassDesc.ofInternalName(className), clb -> {\n+            clb.withFlags(ACC_PUBLIC + ACC_FINAL + ACC_SUPER);\n+            clb.withSuperclass(CD_Object);\n+            clb.withVersion(CLASSFILE_VERSION, 0);\n@@ -200,1 +193,3 @@\n-        cw.visitEnd();\n+            clb.withMethodBody(METHOD_NAME, desc(callerMethodType), ACC_PUBLIC | ACC_STATIC,\n+                    cb -> new BindingSpecializer(cb, callerMethodType, callingSequence, abi, leafType).specialize());\n+        });\n@@ -202,1 +197,0 @@\n-        byte[] bytes = cw.toByteArray();\n@@ -214,5 +208,0 @@\n-        if (PERFORM_VERIFICATION) {\n-            boolean printResults = false; \/\/ only print in case of exception\n-            CheckClassAdapter.verify(new ClassReader(bytes), null, printResults, new PrintWriter(System.err));\n-        }\n-\n@@ -256,6 +245,0 @@\n-        \/\/ map of parameter indexes to local var table slots\n-        paramIndex2ParamSlot = new int[callerMethodType.parameterCount()];\n-        for (int i = 0; i < callerMethodType.parameterCount(); i++) {\n-            paramIndex2ParamSlot[i] = newLocal(callerMethodType.parameterType(i));\n-        }\n-\n@@ -265,1 +248,1 @@\n-            leafArgSlots[i] = newLocal(leafType.parameterType(i));\n+            leafArgSlots[i] = cb.allocateLocal(TypeKind.from(leafType.parameterType(i)));\n@@ -278,1 +261,1 @@\n-                    int scopeLocal = newLocal(Object.class);\n+                    int scopeLocal = cb.allocateLocal(ReferenceType);\n@@ -280,2 +263,2 @@\n-                    emitConst(null);\n-                    emitStore(Object.class, scopeLocal); \/\/ need to initialize all scope locals here in case an exception occurs\n+                    cb.constantInstruction(null);\n+                    cb.storeInstruction(ReferenceType, scopeLocal); \/\/ need to initialize all scope locals here in case an exception occurs\n@@ -290,2 +273,2 @@\n-            emitConst(callingSequence.allocationSize());\n-            emitInvokeStatic(SharedUtils.class, \"newBoundedArena\", NEW_BOUNDED_ARENA_DESC);\n+            cb.constantInstruction(callingSequence.allocationSize());\n+            cb.invokestatic(CD_SharedUtils, \"newBoundedArena\", MTD_NEW_BOUNDED_ARENA);\n@@ -293,1 +276,1 @@\n-            emitInvokeStatic(SharedUtils.class, \"newEmptyArena\", NEW_EMPTY_ARENA_DESC);\n+            cb.invokestatic(CD_SharedUtils, \"newEmptyArena\", MTD_NEW_EMPTY_ARENA);\n@@ -295,1 +278,1 @@\n-            emitGetStatic(SharedUtils.class, \"DUMMY_ARENA\", ARENA_DESC);\n+            cb.getstatic(CD_SharedUtils, \"DUMMY_ARENA\", CD_Arena);\n@@ -297,2 +280,2 @@\n-        contextIdx = newLocal(Object.class);\n-        emitStore(Object.class, contextIdx);\n+        contextIdx = cb.allocateLocal(ReferenceType);\n+        cb.storeInstruction(ReferenceType, contextIdx);\n@@ -305,2 +288,2 @@\n-            returnBufferIdx = newLocal(Object.class);\n-            emitStore(Object.class, returnBufferIdx);\n+            returnBufferIdx = cb.allocateLocal(ReferenceType);\n+            cb.storeInstruction(ReferenceType, returnBufferIdx);\n@@ -309,3 +292,3 @@\n-        Label tryStart = new Label();\n-        Label tryEnd = new Label();\n-        Label catchStart = new Label();\n+        Label tryStart = cb.newLabel();\n+        Label tryEnd = cb.newLabel();\n+        Label catchStart = cb.newLabel();\n@@ -313,1 +296,1 @@\n-        mv.visitLabel(tryStart);\n+        cb.labelBinding(tryStart);\n@@ -329,1 +312,1 @@\n-                    emitLoad(Object.class, returnBufferIdx);\n+                    cb.loadInstruction(ReferenceType, returnBufferIdx);\n@@ -344,2 +327,2 @@\n-                    returnBufferIdx = newLocal(Object.class);\n-                    emitStore(Object.class, returnBufferIdx);\n+                    returnBufferIdx = cb.allocateLocal(ReferenceType);\n+                    cb.storeInstruction(ReferenceType, returnBufferIdx);\n@@ -358,1 +341,1 @@\n-            mv.visitLdcInsn(CLASS_DATA_CONDY);\n+            cb.constantInstruction(CLASS_DATA_DESC);\n@@ -360,1 +343,1 @@\n-            emitLoad(Object.class, 0); \/\/ load target arg\n+            cb.loadInstruction(ReferenceType, 0); \/\/ load target arg\n@@ -362,1 +345,1 @@\n-        emitCheckCast(MethodHandle.class);\n+        cb.checkcast(CD_MethodHandle);\n@@ -365,1 +348,1 @@\n-            emitLoad(leafArgTypes.get(i), leafArgSlots[i]);\n+            cb.loadInstruction(TypeKind.from(leafArgTypes.get(i)), leafArgSlots[i]);\n@@ -368,1 +351,1 @@\n-        emitInvokeVirtual(MethodHandle.class, \"invokeExact\", leafType.descriptorString());\n+        cb.invokevirtual(CD_MethodHandle, \"invokeExact\", desc(leafType));\n@@ -391,1 +374,1 @@\n-            mv.visitLabel(tryEnd);\n+            cb.labelBinding(tryEnd);\n@@ -398,1 +381,1 @@\n-                mv.visitInsn(RETURN);\n+                cb.return_();\n@@ -402,1 +385,1 @@\n-                emitReturn(callerMethodType.returnType());\n+                cb.returnInstruction(TypeKind.from(callerMethodType.returnType()));\n@@ -407,1 +390,1 @@\n-            mv.visitLabel(tryEnd);\n+            cb.labelBinding(tryEnd);\n@@ -410,1 +393,1 @@\n-            mv.visitInsn(RETURN);\n+            cb.return_();\n@@ -413,1 +396,1 @@\n-        mv.visitLabel(catchStart);\n+        cb.labelBinding(catchStart);\n@@ -417,1 +400,1 @@\n-            mv.visitInsn(ATHROW);\n+            cb.throwInstruction();\n@@ -419,1 +402,1 @@\n-            emitInvokeStatic(SharedUtils.class, \"handleUncaughtException\", HANDLE_UNCAUGHT_EXCEPTION_DESC);\n+            cb.invokestatic(CD_SharedUtils, \"handleUncaughtException\", MTD_HANDLE_UNCAUGHT_EXCEPTION);\n@@ -421,2 +404,3 @@\n-                emitConstZero(callerMethodType.returnType());\n-                emitReturn(callerMethodType.returnType());\n+                TypeKind returnTypeKind = TypeKind.from(callerMethodType.returnType());\n+                emitConstZero(returnTypeKind);\n+                cb.returnInstruction(returnTypeKind);\n@@ -424,1 +408,1 @@\n-                mv.visitInsn(RETURN);\n+                cb.return_();\n@@ -428,1 +412,1 @@\n-        mv.visitTryCatchBlock(tryStart, tryEnd, catchStart, null);\n+        cb.exceptionCatchAll(tryStart, tryEnd, catchStart);\n@@ -479,1 +463,1 @@\n-        emitStore(storeType, leafArgSlots[leafArgTypes.size()]);\n+        cb.storeInstruction(TypeKind.from(storeType), leafArgSlots[leafArgTypes.size()]);\n@@ -485,1 +469,1 @@\n-        emitLoad(highLevelType, paramIndex2ParamSlot[paramIndex]);\n+        cb.loadInstruction(TypeKind.from(highLevelType), cb.parameterSlot(paramIndex));\n@@ -488,1 +472,1 @@\n-            emitDup(Object.class);\n+            cb.dup();\n@@ -497,4 +481,4 @@\n-        emitCheckCast(AbstractMemorySegmentImpl.class);\n-        emitInvokeVirtual(AbstractMemorySegmentImpl.class, \"sessionImpl\", SESSION_IMPL_DESC);\n-        Label skipAcquire = new Label();\n-        Label end = new Label();\n+        cb.checkcast(CD_AbstractMemorySegmentImpl);\n+        cb.invokevirtual(CD_AbstractMemorySegmentImpl, \"sessionImpl\", MTD_SESSION_IMPL);\n+        Label skipAcquire = cb.newLabel();\n+        Label end = cb.newLabel();\n@@ -506,3 +490,3 @@\n-            emitDup(Object.class); \/\/ dup for comparison\n-            emitLoad(Object.class, scopeSlots[i]);\n-            mv.visitJumpInsn(IF_ACMPEQ, skipAcquire);\n+            cb.dup(); \/\/ dup for comparison\n+            cb.loadInstruction(ReferenceType, scopeSlots[i]);\n+            cb.if_acmpeq(skipAcquire);\n@@ -512,1 +496,1 @@\n-        emitDup(Object.class);\n+        cb.dup();\n@@ -515,2 +499,2 @@\n-        emitInvokeVirtual(MemorySessionImpl.class, \"acquire0\", ACQUIRE0_DESC); \/\/ call acquire on the other\n-        emitStore(Object.class, nextScopeLocal); \/\/ store off one to release later\n+        cb.invokevirtual(CD_MemorySessionImpl, \"acquire0\", MTD_ACQUIRE0); \/\/ call acquire on the other\n+        cb.storeInstruction(ReferenceType, nextScopeLocal); \/\/ store off one to release later\n@@ -519,1 +503,1 @@\n-            mv.visitJumpInsn(GOTO, end);\n+            cb.goto_(end);\n@@ -521,2 +505,2 @@\n-            mv.visitLabel(skipAcquire);\n-            mv.visitInsn(POP); \/\/ drop scope\n+            cb.labelBinding(skipAcquire);\n+            cb.pop(); \/\/ drop scope\n@@ -525,1 +509,1 @@\n-        mv.visitLabel(end);\n+        cb.labelBinding(end);\n@@ -530,7 +514,5 @@\n-            Label skipRelease = new Label();\n-\n-            emitLoad(Object.class, scopeLocal);\n-            mv.visitJumpInsn(IFNULL, skipRelease);\n-            emitLoad(Object.class, scopeLocal);\n-            emitInvokeVirtual(MemorySessionImpl.class, \"release0\", RELEASE0_DESC);\n-            mv.visitLabel(skipRelease);\n+            cb.loadInstruction(ReferenceType, scopeLocal);\n+            cb.ifThen(Opcode.IFNONNULL, ifCb -> {\n+                ifCb.loadInstruction(ReferenceType, scopeLocal);\n+                ifCb.invokevirtual(CD_MemorySessionImpl, \"release0\", MTD_RELEASE0);\n+            });\n@@ -541,2 +523,3 @@\n-        retValIdx = newLocal(storeType);\n-        emitStore(storeType, retValIdx);\n+        TypeKind typeKind = TypeKind.from(storeType);\n+        retValIdx = cb.allocateLocal(typeKind);\n+        cb.storeInstruction(typeKind, retValIdx);\n@@ -547,1 +530,1 @@\n-        emitLoad(loadType, retValIdx);\n+        cb.loadInstruction(TypeKind.from(loadType), retValIdx);\n@@ -551,6 +534,0 @@\n-    private int newLocal(Class<?> type) {\n-        int idx = localIdx;\n-        localIdx += Type.getType(type).getSize();\n-        return idx;\n-    }\n-\n@@ -559,4 +536,4 @@\n-        emitLoad(Object.class, contextIdx);\n-        emitCheckCast(Arena.class);\n-        emitInvokeInterface(Arena.class, \"scope\", SCOPE_DESC);\n-        emitCheckCast(MemorySessionImpl.class);\n+        cb.loadInstruction(ReferenceType, contextIdx);\n+        cb.checkcast(CD_Arena);\n+        cb.invokeinterface(CD_Arena, \"scope\", MTD_SCOPE);\n+        cb.checkcast(CD_MemorySessionImpl);\n@@ -567,1 +544,1 @@\n-        emitLoad(Object.class, contextIdx);\n+        cb.loadInstruction(ReferenceType, contextIdx);\n@@ -572,3 +549,3 @@\n-        emitLoad(Object.class, contextIdx);\n-        emitCheckCast(Arena.class);\n-        emitInvokeInterface(Arena.class, \"close\", CLOSE_DESC);\n+        cb.loadInstruction(ReferenceType, contextIdx);\n+        cb.checkcast(CD_Arena);\n+        cb.invokeinterface(CD_Arena, \"close\", MTD_CLOSE);\n@@ -579,2 +556,2 @@\n-        emitConst(boxAddress.size());\n-        emitConst(boxAddress.align());\n+        cb.constantInstruction(boxAddress.size());\n+        cb.constantInstruction(boxAddress.align());\n@@ -583,1 +560,1 @@\n-            emitInvokeStatic(Utils.class, \"longToAddress\", LONG_TO_ADDRESS_SCOPE_DESC);\n+            cb.invokestatic(CD_Utils, \"longToAddress\", MTD_LONG_TO_ADDRESS_SCOPE);\n@@ -585,1 +562,1 @@\n-            emitInvokeStatic(Utils.class, \"longToAddress\", LONG_TO_ADDRESS_NO_SCOPE_DESC);\n+            cb.invokestatic(CD_Utils, \"longToAddress\", MTD_LONG_TO_ADDRESS_NO_SCOPE);\n@@ -593,1 +570,1 @@\n-            emitLoad(Object.class, returnAllocatorIdx);\n+            cb.loadInstruction(ReferenceType, returnAllocatorIdx);\n@@ -603,0 +580,1 @@\n+        TypeKind storeTypeKind = TypeKind.from(storeType);\n@@ -610,8 +588,8 @@\n-            int valueIdx = newLocal(storeType);\n-            emitStore(storeType, valueIdx);\n-\n-            Class<?> valueLayoutType = emitLoadLayoutConstant(storeType);\n-            emitConst(offset);\n-            emitLoad(storeType, valueIdx);\n-            String descriptor = methodType(void.class, valueLayoutType, long.class, storeType).descriptorString();\n-            emitInvokeInterface(MemorySegment.class, \"set\", descriptor);\n+            int valueIdx = cb.allocateLocal(storeTypeKind);\n+            cb.storeInstruction(storeTypeKind, valueIdx);\n+\n+            ClassDesc valueLayoutType = emitLoadLayoutConstant(storeType);\n+            cb.constantInstruction(offset);\n+            cb.loadInstruction(storeTypeKind, valueIdx);\n+            MethodTypeDesc descriptor = MethodTypeDesc.of(CD_void, valueLayoutType, CD_long, desc(storeType));\n+            cb.invokeinterface(CD_MemorySegment, \"set\", descriptor);\n@@ -621,1 +599,1 @@\n-                mv.visitInsn(I2L);\n+                cb.i2l();\n@@ -625,4 +603,4 @@\n-            int longValueIdx = newLocal(long.class);\n-            emitStore(long.class, longValueIdx);\n-            int writeAddrIdx = newLocal(MemorySegment.class);\n-            emitStore(MemorySegment.class, writeAddrIdx);\n+            int longValueIdx = cb.allocateLocal(LongType);\n+            cb.storeInstruction(LongType, longValueIdx);\n+            int writeAddrIdx = cb.allocateLocal(ReferenceType);\n+            cb.storeInstruction(ReferenceType, writeAddrIdx);\n@@ -655,3 +633,3 @@\n-                emitLoad(long.class, longValueIdx);\n-                emitConst(mask);\n-                mv.visitInsn(LAND);\n+                cb.loadInstruction(LongType, longValueIdx);\n+                cb.constantInstruction(mask);\n+                cb.land();\n@@ -659,2 +637,2 @@\n-                    emitConst(shiftAmount);\n-                    mv.visitInsn(LUSHR);\n+                    cb.constantInstruction(shiftAmount);\n+                    cb.lushr();\n@@ -662,3 +640,4 @@\n-                mv.visitInsn(L2I);\n-                int chunkIdx = newLocal(chunkStoreType);\n-                emitStore(chunkStoreType, chunkIdx);\n+                cb.l2i();\n+                TypeKind chunkStoreTypeKind = TypeKind.from(chunkStoreType);\n+                int chunkIdx = cb.allocateLocal(chunkStoreTypeKind);\n+                cb.storeInstruction(chunkStoreTypeKind, chunkIdx);\n@@ -668,2 +647,2 @@\n-                emitLoad(MemorySegment.class, writeAddrIdx);\n-                Class<?> valueLayoutType = emitLoadLayoutConstant(chunkStoreType);\n+                cb.loadInstruction(ReferenceType, writeAddrIdx);\n+                ClassDesc valueLayoutType = emitLoadLayoutConstant(chunkStoreType);\n@@ -671,4 +650,4 @@\n-                emitConst(writeOffset);\n-                emitLoad(chunkStoreType, chunkIdx);\n-                String descriptor = methodType(void.class, valueLayoutType, long.class, chunkStoreType).descriptorString();\n-                emitInvokeInterface(MemorySegment.class, \"set\", descriptor);\n+                cb.constantInstruction(writeOffset);\n+                cb.loadInstruction(chunkStoreTypeKind, chunkIdx);\n+                MethodTypeDesc descriptor = MethodTypeDesc.of(CD_void, valueLayoutType, CD_long, desc(chunkStoreType));\n+                cb.invokeinterface(CD_MemorySegment, \"set\", descriptor);\n@@ -685,0 +664,1 @@\n+        TypeKind storeTypeKind = TypeKind.from(storeType);\n@@ -695,2 +675,2 @@\n-                int valueIdx = newLocal(storeType);\n-                emitStore(storeType, valueIdx); \/\/ store away the stored value, need it later\n+                int valueIdx = cb.allocateLocal(storeTypeKind);\n+                cb.storeInstruction(storeTypeKind, valueIdx); \/\/ store away the stored value, need it later\n@@ -699,6 +679,6 @@\n-                emitLoad(Object.class, returnBufferIdx);\n-                Class<?> valueLayoutType = emitLoadLayoutConstant(storeType);\n-                emitConst(retBufOffset);\n-                emitLoad(storeType, valueIdx);\n-                String descriptor = methodType(void.class, valueLayoutType, long.class, storeType).descriptorString();\n-                emitInvokeInterface(MemorySegment.class, \"set\", descriptor);\n+                cb.loadInstruction(ReferenceType, returnBufferIdx);\n+                ClassDesc valueLayoutType = emitLoadLayoutConstant(storeType);\n+                cb.constantInstruction(retBufOffset);\n+                cb.loadInstruction(storeTypeKind, valueIdx);\n+                MethodTypeDesc descriptor = MethodTypeDesc.of(CD_void, valueLayoutType, CD_long, desc(storeType));\n+                cb.invokeinterface(CD_MemorySegment, \"set\", descriptor);\n@@ -719,5 +699,5 @@\n-                emitLoad(Object.class, returnBufferIdx);\n-                Class<?> valueLayoutType = emitLoadLayoutConstant(loadType);\n-                emitConst(retBufOffset);\n-                String descriptor = methodType(loadType, valueLayoutType, long.class).descriptorString();\n-                emitInvokeInterface(MemorySegment.class, \"get\", descriptor);\n+                cb.loadInstruction(ReferenceType, returnBufferIdx);\n+                ClassDesc valueLayoutType = emitLoadLayoutConstant(loadType);\n+                cb.constantInstruction(retBufOffset);\n+                MethodTypeDesc descriptor = MethodTypeDesc.of(desc(loadType), valueLayoutType, CD_long);\n+                cb.invokeinterface(CD_MemorySegment, \"get\", descriptor);\n@@ -749,2 +729,2 @@\n-                emitConst(0xFF);\n-                mv.visitInsn(IAND);\n+                cb.constantInstruction(0xFF);\n+                cb.iand();\n@@ -753,1 +733,1 @@\n-                emitInvokeStatic(Utils.class, \"byteToBoolean\", \"(B)Z\");\n+                cb.invokestatic(CD_Utils, \"byteToBoolean\", MTD_BYTE_TO_BOOLEAN);\n@@ -755,3 +735,3 @@\n-            case INT_TO_BYTE -> mv.visitInsn(I2B);\n-            case INT_TO_CHAR -> mv.visitInsn(I2C);\n-            case INT_TO_SHORT -> mv.visitInsn(I2S);\n+            case INT_TO_BYTE -> cb.i2b();\n+            case INT_TO_CHAR -> cb.i2c();\n+            case INT_TO_SHORT -> cb.i2s();\n@@ -768,1 +748,1 @@\n-        emitInvokeStatic(SharedUtils.class, \"unboxSegment\", UNBOX_SEGMENT_DESC);\n+        cb.invokestatic(CD_SharedUtils, \"unboxSegment\", MTD_UNBOX_SEGMENT);\n@@ -780,4 +760,4 @@\n-            Class<?> valueLayoutType = emitLoadLayoutConstant(loadType);\n-            emitConst(offset);\n-            String descriptor = methodType(loadType, valueLayoutType, long.class).descriptorString();\n-            emitInvokeInterface(MemorySegment.class, \"get\", descriptor);\n+            ClassDesc valueLayoutType = emitLoadLayoutConstant(loadType);\n+            cb.constantInstruction(offset);\n+            MethodTypeDesc descriptor = MethodTypeDesc.of(desc(loadType), valueLayoutType, CD_long);\n+            cb.invokeinterface(CD_MemorySegment, \"get\", descriptor);\n@@ -786,2 +766,2 @@\n-            int readAddrIdx = newLocal(MemorySegment.class);\n-            emitStore(MemorySegment.class, readAddrIdx);\n+            int readAddrIdx = cb.allocateLocal(ReferenceType);\n+            cb.storeInstruction(ReferenceType, readAddrIdx);\n@@ -789,3 +769,3 @@\n-            emitConstZero(long.class); \/\/ result\n-            int resultIdx = newLocal(long.class);\n-            emitStore(long.class, resultIdx);\n+            cb.constantInstruction(0L); \/\/ result\n+            int resultIdx = cb.allocateLocal(LongType);\n+            cb.storeInstruction(LongType, resultIdx);\n@@ -798,2 +778,2 @@\n-                Class<?> toULongHolder;\n-                String toULongDescriptor;\n+                ClassDesc toULongHolder;\n+                MethodTypeDesc toULongDescriptor;\n@@ -803,2 +783,2 @@\n-                        toULongHolder = Integer.class;\n-                        toULongDescriptor = INTEGER_TO_UNSIGNED_LONG_DESC;\n+                        toULongHolder = CD_Integer;\n+                        toULongDescriptor = MTD_INTEGER_TO_UNSIGNED_LONG;\n@@ -808,2 +788,2 @@\n-                        toULongHolder = Short.class;\n-                        toULongDescriptor = SHORT_TO_UNSIGNED_LONG_DESC;\n+                        toULongHolder = CD_Short;\n+                        toULongDescriptor = MTD_SHORT_TO_UNSIGNED_LONG;\n@@ -813,2 +793,2 @@\n-                        toULongHolder = Byte.class;\n-                        toULongDescriptor = BYTE_TO_UNSIGNED_LONG_DESC;\n+                        toULongHolder = CD_Byte;\n+                        toULongDescriptor = MTD_BYTE_TO_UNSIGNED_LONG;\n@@ -820,3 +800,3 @@\n-                emitLoad(MemorySegment.class, readAddrIdx);\n-                Class<?> valueLayoutType = emitLoadLayoutConstant(chunkType);\n-                String descriptor = methodType(chunkType, valueLayoutType, long.class).descriptorString();\n+                cb.loadInstruction(ReferenceType, readAddrIdx);\n+                ClassDesc valueLayoutType = emitLoadLayoutConstant(chunkType);\n+                MethodTypeDesc descriptor = MethodTypeDesc.of(desc(chunkType), valueLayoutType, CD_long);\n@@ -824,3 +804,3 @@\n-                emitConst(readOffset);\n-                emitInvokeInterface(MemorySegment.class, \"get\", descriptor);\n-                emitInvokeStatic(toULongHolder, \"toUnsignedLong\", toULongDescriptor);\n+                cb.constantInstruction(readOffset);\n+                cb.invokeinterface(CD_MemorySegment, \"get\", descriptor);\n+                cb.invokestatic(toULongHolder, \"toUnsignedLong\", toULongDescriptor);\n@@ -831,2 +811,2 @@\n-                    emitConst(shiftAmount);\n-                    mv.visitInsn(LSHL);\n+                    cb.constantInstruction(shiftAmount);\n+                    cb.lshl();\n@@ -835,3 +815,3 @@\n-                emitLoad(long.class, resultIdx);\n-                mv.visitInsn(LOR);\n-                emitStore(long.class, resultIdx);\n+                cb.loadInstruction(LongType, resultIdx);\n+                cb.lor();\n+                cb.storeInstruction(LongType, resultIdx);\n@@ -843,1 +823,1 @@\n-            emitLoad(long.class, resultIdx);\n+            cb.loadInstruction(LongType, resultIdx);\n@@ -845,1 +825,1 @@\n-                mv.visitInsn(L2I);\n+                cb.l2i();\n@@ -863,1 +843,1 @@\n-        emitConst(0L);\n+        cb.constantInstruction(0L);\n@@ -868,8 +848,8 @@\n-        emitDup(Object.class);\n-        int storeIdx = newLocal(Object.class);\n-        emitStore(Object.class, storeIdx);\n-        emitConst(0L);\n-        emitConst(size);\n-        emitInvokeStatic(MemorySegment.class, \"copy\", COPY_DESC);\n-\n-        emitLoad(Object.class, storeIdx);\n+        cb.dup();\n+        int storeIdx = cb.allocateLocal(ReferenceType);\n+        cb.storeInstruction(ReferenceType, storeIdx);\n+        cb.constantInstruction(0L);\n+        cb.constantInstruction(size);\n+        cb.invokestatic(CD_MemorySegment, \"copy\", MTD_COPY, true);\n+\n+        cb.loadInstruction(ReferenceType, storeIdx);\n@@ -880,3 +860,3 @@\n-        emitConst(size);\n-        emitConst(alignment);\n-        emitInvokeInterface(SegmentAllocator.class, \"allocate\", ALLOCATE_DESC);\n+        cb.constantInstruction(size);\n+        cb.constantInstruction(alignment);\n+        cb.invokeinterface(CD_SegmentAllocator, \"allocate\", MTD_ALLOCATE);\n@@ -885,2 +865,2 @@\n-    private Class<?> emitLoadLayoutConstant(Class<?> type) {\n-        Class<?> valueLayoutType = valueLayoutTypeFor(type);\n+    private ClassDesc emitLoadLayoutConstant(Class<?> type) {\n+        ClassDesc valueLayoutType = valueLayoutTypeFor(type);\n@@ -888,1 +868,1 @@\n-        emitGetStatic(ValueLayout.class, valueLayoutConstantName, valueLayoutType.descriptorString());\n+        cb.getstatic(CD_ValueLayout, valueLayoutConstantName, valueLayoutType);\n@@ -916,1 +896,1 @@\n-    private static Class<?> valueLayoutTypeFor(Class<?> type) {\n+    private static ClassDesc valueLayoutTypeFor(Class<?> type) {\n@@ -918,1 +898,1 @@\n-            return ValueLayout.OfBoolean.class;\n+            return CD_ValueLayout_OfBoolean;\n@@ -920,1 +900,1 @@\n-            return ValueLayout.OfByte.class;\n+            return CD_ValueLayout_OfByte;\n@@ -922,1 +902,1 @@\n-            return ValueLayout.OfShort.class;\n+            return CD_ValueLayout_OfShort;\n@@ -924,1 +904,1 @@\n-            return ValueLayout.OfChar.class;\n+            return CD_ValueLayout_OfChar;\n@@ -926,1 +906,1 @@\n-            return ValueLayout.OfInt.class;\n+            return CD_ValueLayout_OfInt;\n@@ -928,1 +908,1 @@\n-            return ValueLayout.OfLong.class;\n+            return CD_ValueLayout_OfLong;\n@@ -930,1 +910,1 @@\n-            return ValueLayout.OfFloat.class;\n+            return CD_ValueLayout_OfFloat;\n@@ -932,1 +912,1 @@\n-            return ValueLayout.OfDouble.class;\n+            return CD_ValueLayout_OfDouble;\n@@ -934,1 +914,1 @@\n-            return AddressLayout.class;\n+            return CD_AddressLayout;\n@@ -940,20 +920,0 @@\n-    private void emitInvokeStatic(Class<?> owner, String methodName, String descriptor) {\n-        mv.visitMethodInsn(INVOKESTATIC, Type.getInternalName(owner), methodName, descriptor, owner.isInterface());\n-    }\n-\n-    private void emitInvokeInterface(Class<?> owner, String methodName, String descriptor) {\n-        mv.visitMethodInsn(INVOKEINTERFACE, Type.getInternalName(owner), methodName, descriptor, true);\n-    }\n-\n-    private void emitInvokeVirtual(Class<?> owner, String methodName, String descriptor) {\n-        mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(owner), methodName, descriptor, false);\n-    }\n-\n-    private void emitGetStatic(Class<?> owner, String fieldName, String descriptor) {\n-        mv.visitFieldInsn(GETSTATIC, Type.getInternalName(owner), fieldName, descriptor);\n-    }\n-\n-    private void emitCheckCast(Class<?> cls) {\n-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(cls));\n-    }\n-\n@@ -962,1 +922,1 @@\n-            mv.visitInsn(DUP2);\n+            cb.dup2();\n@@ -964,1 +924,1 @@\n-            mv.visitInsn(Opcodes.DUP);\n+            cb.dup();\n@@ -972,15 +932,7 @@\n-    private void emitConstZero(Class<?> type) {\n-        emitConst(switch (Type.getType(type).getSort()) {\n-            case Type.BOOLEAN, Type.BYTE, Type.SHORT, Type.CHAR, Type.INT -> 0;\n-            case Type.LONG -> 0L;\n-            case Type.FLOAT -> 0F;\n-            case Type.DOUBLE -> 0D;\n-            case Type.OBJECT -> null;\n-            default -> throw new IllegalArgumentException(\"Unknown type: \" + type);\n-        });\n-    }\n-\n-    private void emitConst(Object con) {\n-        if (con == null) {\n-            mv.visitInsn(Opcodes.ACONST_NULL);\n-            return;\n+    private void emitConstZero(TypeKind kind) {\n+        switch (kind) {\n+            case BooleanType, ByteType, ShortType, CharType, IntType -> cb.iconst_0();\n+            case LongType -> cb.lconst_0();\n+            case FloatType -> cb.fconst_0();\n+            case DoubleType -> cb.dconst_0();\n+            case ReferenceType -> cb.aconst_null();\n@@ -988,61 +940,0 @@\n-        if (con instanceof Integer i) {\n-            emitIconstInsn(i);\n-            return;\n-        }\n-        if (con instanceof Byte b) {\n-            emitIconstInsn(b);\n-            return;\n-        }\n-        if (con instanceof Short s) {\n-            emitIconstInsn(s);\n-            return;\n-        }\n-        if (con instanceof Character c) {\n-            emitIconstInsn(c);\n-            return;\n-        }\n-        if (con instanceof Long l) {\n-            long x = l;\n-            short sx = (short)x;\n-            if (x == sx) {\n-                if (sx >= 0 && sx <= 1) {\n-                    mv.visitInsn(Opcodes.LCONST_0 + (int) sx);\n-                } else {\n-                    emitIconstInsn((int) x);\n-                    mv.visitInsn(Opcodes.I2L);\n-                }\n-                return;\n-            }\n-        }\n-        if (con instanceof Float f) {\n-            float x = f;\n-            short sx = (short)x;\n-            if (x == sx) {\n-                if (sx >= 0 && sx <= 2) {\n-                    mv.visitInsn(Opcodes.FCONST_0 + (int) sx);\n-                } else {\n-                    emitIconstInsn((int) x);\n-                    mv.visitInsn(Opcodes.I2F);\n-                }\n-                return;\n-            }\n-        }\n-        if (con instanceof Double d) {\n-            double x = d;\n-            short sx = (short)x;\n-            if (x == sx) {\n-                if (sx >= 0 && sx <= 1) {\n-                    mv.visitInsn(Opcodes.DCONST_0 + (int) sx);\n-                } else {\n-                    emitIconstInsn((int) x);\n-                    mv.visitInsn(Opcodes.I2D);\n-                }\n-                return;\n-            }\n-        }\n-        if (con instanceof Boolean b) {\n-            emitIconstInsn(b ? 1 : 0);\n-            return;\n-        }\n-        \/\/ fall through:\n-        mv.visitLdcInsn(con);\n@@ -1051,10 +942,3 @@\n-    private void emitIconstInsn(int cst) {\n-        if (cst >= -1 && cst <= 5) {\n-            mv.visitInsn(Opcodes.ICONST_0 + cst);\n-        } else if (cst >= Byte.MIN_VALUE && cst <= Byte.MAX_VALUE) {\n-            mv.visitIntInsn(Opcodes.BIPUSH, cst);\n-        } else if (cst >= Short.MIN_VALUE && cst <= Short.MAX_VALUE) {\n-            mv.visitIntInsn(Opcodes.SIPUSH, cst);\n-        } else {\n-            mv.visitLdcInsn(cst);\n-        }\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> T desc(Constable c) {\n+        return (T) c.describeConstable().orElseThrow();\n@@ -1062,16 +946,0 @@\n-\n-    private void emitLoad(Class<?> type, int index) {\n-        int opcode = Type.getType(type).getOpcode(ILOAD);\n-        mv.visitVarInsn(opcode, index);\n-    }\n-\n-    private void emitStore(Class<?> type, int index) {\n-        int opcode =  Type.getType(type).getOpcode(ISTORE);\n-        mv.visitVarInsn(opcode, index);\n-    }\n-\n-    private void emitReturn(Class<?> type) {\n-        int opcode = Type.getType(type).getOpcode(IRETURN);\n-        mv.visitInsn(opcode);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":257,"deletions":389,"binary":false,"changes":646,"status":"modified"}]}