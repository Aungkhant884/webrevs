{"files":[{"patch":"@@ -39,0 +39,1 @@\n+import java.lang.ref.Cleaner.Cleanable;\n@@ -193,8 +194,5 @@\n-        var executor = new ThreadPoolExecutor(1, 1,\n-                                              0L, TimeUnit.MILLISECONDS,\n-                                              new LinkedBlockingQueue<Runnable>(),\n-                                              threadFactory);\n-        var wrapper = new DelegatedExecutorService(executor);\n-        \/\/ Register action to shut down executor when wrapper becomes phantom reachable\n-        CleanerFactory.cleaner().register(wrapper, new ShutdownAction(executor));\n-        return wrapper;\n+        return new AutoShutdownDelegatedExecutorService\n+            (new ThreadPoolExecutor(1, 1,\n+                                    0L, TimeUnit.MILLISECONDS,\n+                                    new LinkedBlockingQueue<Runnable>(),\n+                                    threadFactory));\n@@ -828,0 +826,22 @@\n+    \/**\n+     * A DelegatedExecutorService that uses a Cleaner to shut down the underlying\n+     * ExecutorService when the wrapper becomes phantom reachable.\n+     *\/\n+    private static class AutoShutdownDelegatedExecutorService\n+            extends DelegatedExecutorService {\n+        private final Cleanable cleaner;\n+        AutoShutdownDelegatedExecutorService(ExecutorService executor) {\n+            super(executor);\n+            Runnable action = () -> {\n+                PrivilegedAction<Void> pa = () -> { executor.shutdown(); return null; };\n+                @SuppressWarnings(\"removal\")\n+                var ignore = AccessController.doPrivileged(pa);\n+            };\n+            cleaner = CleanerFactory.cleaner().register(this, action);\n+        }\n+        @Override\n+        public void shutdown() {\n+            cleaner.clean();\n+        }\n+    }\n+\n@@ -854,16 +874,0 @@\n-    \/**\n-     * An action that shuts down an ExecutorService.\n-     *\/\n-    private static class ShutdownAction implements Runnable {\n-        private final ExecutorService e;\n-        ShutdownAction(ExecutorService executor) {\n-            e = executor;\n-        }\n-        @Override\n-        public void run() {\n-            PrivilegedAction<Void> pa = () -> { e.shutdown(); return null; };\n-            @SuppressWarnings(\"removal\")\n-            var ignore = AccessController.doPrivileged(pa);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Executors.java","additions":28,"deletions":24,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.util.stream.IntStream;\n@@ -58,5 +59,3 @@\n-        Integer[] queuedTaskCounts = { 0, 1, 2 };\n-        return executors()\n-                .flatMap(s -> Stream.of(queuedTaskCounts)\n-                                    .flatMap(i -> Stream.of(Arguments.of(s, i))));\n-\n+        int[] queuedTaskCounts = { 0, 1, 2 };\n+        return executors().flatMap(s -> IntStream.of(queuedTaskCounts)\n+                .mapToObj(i -> Arguments.of(s, i)));\n","filename":"test\/jdk\/java\/util\/concurrent\/Executors\/AutoShutdown.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"}]}