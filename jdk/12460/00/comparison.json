{"files":[{"patch":"@@ -1175,0 +1175,12 @@\n+  <Event name=\"LoadedAgent\" category=\"Java Virtual Machine, Diagnostics\" label=\"Loaded Agent\"\n+    thread=\"false\" startTime=\"false\" period=\"endChunk\" stackTrace=\"false\">\n+    <Field type=\"string\" name=\"name\" label=\"Name\" \/>\n+    <Field type=\"string\" name=\"options\" label=\"Options\" \/>\n+    <Field type=\"boolean\" name=\"java\" label=\"Java Agent\"\n+      description=\"If the agent is implemented using java.lang.instrument\" \/>\n+    <Field type=\"boolean\" name=\"dynamic\" label=\"Dynamically Loaded\"\n+      description=\"If the agent was loaded after startup using the attach mechanism\" \/>\n+    <Field type=\"long\" contentType=\"epochmillis\" name=\"loadTime\" label=\"Load Time\"\n+     description=\"Timestamp taken at JVM startup or when agent is loaded by the attach mechanism\"\/>\n+  <\/Event>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -272,0 +272,22 @@\n+TRACE_REQUEST_FUNC(LoadedAgent) {\n+  MutexLocker m(JfrAgentList_lock, Mutex::_no_safepoint_check_flag);\n+  for (AgentLibrary* a = Arguments::agents(); a != nullptr; a = a->next()) {\n+    assert (a->load_time_epoch_ms() != 0, \"agent not loaded\");\n+    EventLoadedAgent event(UNTIMED);\n+    event.set_starttime(timestamp());\n+    event.set_endtime(timestamp());\n+    event.set_dynamic(a->is_dynamic());\n+    event.set_loadTime(a->load_time_epoch_ms());\n+    if (a->is_instrument_lib()) {\n+      event.set_java(true);\n+      event.set_name(a->instrument_name());\n+      event.set_options(a->instrument_options());\n+    } else {\n+      event.set_java(false);\n+      event.set_name(a->name());\n+      event.set_options(a->options());\n+    }\n+    event.commit();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2946,0 +2946,1 @@\n+  bool instrument = agent != nullptr && strcmp(\"instrument\", agent) == 0;\n@@ -2947,1 +2948,1 @@\n-  AgentLibrary *agent_lib = new AgentLibrary(agent, options, is_absolute_path, nullptr);\n+  AgentLibrary *agent_lib = new AgentLibrary(agent, options, is_absolute_path, nullptr, true, instrument);\n@@ -2997,0 +2998,1 @@\n+        agent_lib->set_load_time();\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -218,1 +219,1 @@\n-               bool instrument_lib) {\n+               bool is_dynamic, bool instrument_lib) {\n@@ -233,0 +234,24 @@\n+  _is_dynamic = is_dynamic;\n+  _load_time_epoch_ms = 0;\n+  _instrument_lib_options = nullptr;\n+  _instrument_lib_name = nullptr;\n+  if (_is_instrument_lib && _options != nullptr) {\n+    const char *p = strchr(options, '=');\n+    size_t length = strlen(options);\n+    if (p != nullptr) {\n+      size_t name_length = p - options;\n+      size_t option_length = length - name_length - 1;\n+      _instrument_lib_name = AllocateHeap(name_length + 1, mtArguments);\n+      jio_snprintf(_instrument_lib_name, name_length + 1, \"%s\", options);\n+      _instrument_lib_options = AllocateHeap(option_length + 1, mtArguments);\n+      jio_snprintf(_instrument_lib_options, option_length + 1, \"%s\", p + 1);\n+    } else {\n+      _instrument_lib_name = AllocateHeap(length + 1, mtArguments);\n+      jio_snprintf(_instrument_lib_name, length + 1, \"%s\", options);\n+    }\n+  }\n+}\n+\n+void AgentLibrary::set_load_time() {\n+  \/\/ Using epoch millis since Ticks system is not initialized this early.\n+  _load_time_epoch_ms = os::javaTimeMillis();\n@@ -326,1 +351,1 @@\n-  _libraryList.add(new AgentLibrary(name, options, false, nullptr));\n+  _libraryList.add(new AgentLibrary(name, options, false, nullptr, false, false));\n@@ -330,1 +355,1 @@\n-  _agentList.add(new AgentLibrary(name, options, absolute_path, nullptr));\n+  _agentList.add(new AgentLibrary(name, options, absolute_path, nullptr, false, false));\n@@ -334,1 +359,1 @@\n-  _agentList.add(new AgentLibrary(name, options, absolute_path, nullptr, true));\n+  _agentList.add(new AgentLibrary(name, options, absolute_path, nullptr, false, true));\n@@ -339,0 +364,1 @@\n+  JFR_ONLY(MutexLocker m(JfrAgentList_lock, Mutex::_no_safepoint_check_flag);)\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":30,"deletions":4,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -160,0 +160,4 @@\n+  char*           _instrument_lib_name;\n+  char*           _instrument_lib_options;\n+  bool            _is_dynamic;\n+  jlong           _load_time_epoch_ms;\n@@ -173,0 +177,3 @@\n+  char* instrument_name() const             { return _instrument_lib_name; }\n+  char* instrument_options() const          { return _instrument_lib_options; }\n+  bool is_dynamic() const                   { return _is_dynamic; }\n@@ -176,0 +183,2 @@\n+  jlong load_time_epoch_ms() const          { return _load_time_epoch_ms; }\n+  void set_load_time();\n@@ -179,1 +188,1 @@\n-               void* os_lib, bool instrument_lib=false);\n+               void* os_lib, bool dynamic, bool instrument_lib);\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+Mutex*   JfrAgentList_lock            = nullptr;\n@@ -311,0 +312,1 @@\n+  def(JfrAgentList_lock            , PaddedMutex, nosafepoint);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+extern Mutex*   JfrAgentList_lock;               \/\/ protects AgentLibraryList\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -952,0 +952,1 @@\n+      agent->set_load_time();\n@@ -1006,0 +1007,1 @@\n+      agent->set_load_time();\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -861,0 +861,5 @@\n+    <event name=\"jdk.LoadedAgent\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"period\">endChunk<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -861,0 +861,5 @@\n+    <event name=\"jdk.LoadedAgent\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"period\">endChunk<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.runtime;\n+\n+import java.lang.instrument.Instrumentation;\n+\n+public class JavaAgent {\n+\n+    public static void agentmain(String agentArgs, Instrumentation inst) throws Exception {\n+        System.out.println(\"agentmain: \" + agentArgs);\n+    }\n+\n+    public static void premain(String agentArgs, Instrumentation inst) throws Exception {\n+        System.out.println(\"premain: \" + agentArgs);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/JavaAgent.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.runtime;\n+\n+import java.lang.reflect.Method;\n+import java.security.Timestamp;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import com.sun.tools.attach.VirtualMachine;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedClassLoader;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.Event;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.jfr.TestClassLoader;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @summary Tests Loaded Agent event by starting native and Java agents\n+ * @requires vm.hasJFR\n+ *\n+ * @library \/test\/lib\n+ * @modules java.instrument\n+ *\n+ * @build jdk.jfr.event.runtime.JavaAgent\n+ *\n+ * @run driver jdk.test.lib.util.JavaAgentBuilder\n+ *      jdk.jfr.event.runtime.JavaAgent\n+ *      JavaAgent.jar\n+ *\n+ * @run main\/othervm -javaagent:JavaAgent.jar=foo=bar\n+ *      jdk.jfr.event.runtime.TestLoadedAgentEvent\n+ *      testJavaStatic\n+ *\n+ * @run main\/othervm -Djdk.attach.allowAttachSelf=true\n+ *      jdk.jfr.event.runtime.TestLoadedAgentEvent\n+ *      testJavaDynamic\n+ *\n+ * @run main\/othervm -agentlib:jdwp=transport=dt_socket,server=y,address=any,onjcmd=y\n+ *      jdk.jfr.event.runtime.TestLoadedAgentEvent\n+ *      testNativeStatic\n+ *\/\n+public final class TestLoadedAgentEvent {\n+    private static final String JAVA_AGENT_JAR = \"JavaAgent.jar\";\n+    private static final String EVENT_NAME = \"jdk.LoadedAgent\";\n+\n+    public static void main(String[] args) throws Throwable {\n+        String testMethod = args[0];\n+        Method m = TestLoadedAgentEvent.class.getDeclaredMethod(testMethod, new Class[0]);\n+        if (m == null) {\n+            throw new Exception(\"Unknown test method: \" + testMethod);\n+        }\n+        m.invoke(null, new Object[0]);\n+    }\n+\n+    private static void testJavaStatic() throws Throwable {\n+        try (Recording r = new Recording()) {\n+            r.enable(EVENT_NAME);\n+            r.start();\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            Events.hasEvents(events);\n+            RecordedEvent e = events.get(0);\n+            System.out.println(e);\n+            Events.assertField(e, \"name\").equal(JAVA_AGENT_JAR);\n+            Events.assertField(e, \"options\").equal(\"foo=bar\");\n+            Events.assertField(e, \"java\").equal(true);\n+            Events.assertField(e, \"dynamic\").equal(false);\n+        }\n+    }\n+\n+    private static void testNativeStatic() throws Throwable {\n+        try (Recording r = new Recording()) {\n+            r.enable(EVENT_NAME);\n+            r.start();\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            Events.hasEvents(events);\n+            RecordedEvent e = events.get(0);\n+            System.out.println(e);\n+            Events.assertField(e, \"name\").equal(\"jdwp\");\n+            Events.assertField(e, \"options\").equal(\"transport=dt_socket,server=y,address=any,onjcmd=y\");\n+            Events.assertField(e, \"dynamic\").equal(false);\n+            Events.assertField(e, \"java\").equals(false);\n+        }\n+    }\n+\n+    private static void testJavaDynamic() throws Throwable {\n+        try (Recording r = new Recording()) {\n+            r.enable(EVENT_NAME);\n+            long start = System.currentTimeMillis();\n+            r.start();\n+            long pid = ProcessHandle.current().pid();\n+            VirtualMachine vm = VirtualMachine.attach(Long.toString(pid));\n+            vm.loadAgent(JAVA_AGENT_JAR, \"bar=baz\");\n+            vm.detach();\n+            vm = VirtualMachine.attach(Long.toString(pid));\n+            vm.loadAgent(JAVA_AGENT_JAR); \/\/ options = null\n+            vm.detach();\n+            vm = VirtualMachine.attach(Long.toString(pid));\n+            vm.loadAgent(JAVA_AGENT_JAR, \"\");\n+            vm.loadAgent(JAVA_AGENT_JAR, \"=\");\n+            vm.detach();\n+            r.stop();\n+            long stop = System.currentTimeMillis();\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            Events.hasEvents(events);\n+            Instant endTime = events.get(0).getEndTime();\n+            for (RecordedEvent e : events) {\n+                System.out.println(e);\n+                if (!e.getEndTime().equals(endTime)) {\n+                    throw new Exception(\"Expected all events to have the same end time\");\n+                }\n+                if (!e.getStartTime().equals(endTime)) {\n+                    throw new Exception(\"Expected start and end time to be the same\");\n+                }\n+                long loadTime = e.getInstant(\"loadTime\").toEpochMilli();\n+                if (loadTime < start) {\n+                    throw new Exception(\"Expected agent to be loaded after recording start\");\n+                }\n+                if (loadTime > stop) {\n+                    throw new Exception(\"Expected agent to be loaded before recording stop\");\n+                }\n+                Events.assertField(e, \"name\").equal(JAVA_AGENT_JAR);\n+                Events.assertField(e, \"dynamic\").equal(true);\n+                Events.assertField(e, \"java\").equal(true);\n+            }\n+            Events.assertField(events.get(0), \"options\").equal(\"bar=baz\");\n+            Events.assertField(events.get(1), \"options\").equal(null);\n+            Events.assertField(events.get(2), \"options\").equal(\"\");\n+            Events.assertField(events.get(3), \"options\").equal(\"=\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestLoadedAgentEvent.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -91,0 +91,1 @@\n+    public static final String Agent = PREFIX + \"LoadedAgent\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}