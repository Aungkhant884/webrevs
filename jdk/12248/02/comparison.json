{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-    assert(info == NULL, \"sanity\");\n+    assert(info == nullptr, \"sanity\");\n@@ -126,1 +126,1 @@\n-  \/\/ If the \"new_val\" is a constant NULL, no barrier is necessary.\n+  \/\/ If the \"new_val\" is a constant null, no barrier is necessary.\n@@ -128,1 +128,1 @@\n-      new_val->as_constant_ptr()->as_jobject() == NULL) return;\n+      new_val->as_constant_ptr()->as_jobject() == nullptr) return;\n@@ -207,1 +207,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -215,1 +215,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/share\/gc\/g1\/c1\/g1BarrierSetC1.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-    _patch_code(lir_patch_none), _info(NULL)\n+    _patch_code(lir_patch_none), _info(nullptr)\n@@ -77,1 +77,1 @@\n-      if (_info != NULL)\n+      if (_info != nullptr)\n@@ -137,2 +137,2 @@\n-    : _pre_barrier_c1_runtime_code_blob(NULL),\n-      _post_barrier_c1_runtime_code_blob(NULL) {}\n+    : _pre_barrier_c1_runtime_code_blob(nullptr),\n+      _post_barrier_c1_runtime_code_blob(nullptr) {}\n","filename":"src\/hotspot\/share\/gc\/g1\/c1\/g1BarrierSetC1.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,2 +76,2 @@\n- * If the previous value is NULL there is no need to save the old value.\n- * References that are NULL are filtered during runtime by the barrier\n+ * If the previous value is null there is no need to save the old value.\n+ * References that are null are filtered during runtime by the barrier\n@@ -81,1 +81,1 @@\n- * prove that the reference about to be overwritten is NULL during compile\n+ * prove that the reference about to be overwritten is null during compile\n@@ -103,1 +103,1 @@\n-  if (alloc == NULL) {\n+  if (alloc == nullptr) {\n@@ -119,1 +119,1 @@\n-      if (st_base == NULL) {\n+      if (st_base == nullptr) {\n@@ -159,1 +159,1 @@\n-        \/\/ Check that the initialization is storing NULL so that no previous store\n+        \/\/ Check that the initialization is storing null so that no previous store\n@@ -164,1 +164,1 @@\n-        if (captured_store == NULL || captured_store == st_init->zero_memory()) {\n+        if (captured_store == nullptr || captured_store == st_init->zero_memory()) {\n@@ -194,4 +194,4 @@\n-    assert(obj != NULL, \"must have a base\");\n-    assert(adr != NULL, \"where are loading from?\");\n-    assert(pre_val == NULL, \"loaded already?\");\n-    assert(val_type != NULL, \"need a type\");\n+    assert(obj != nullptr, \"must have a base\");\n+    assert(adr != nullptr, \"where are loading from?\");\n+    assert(pre_val == nullptr, \"loaded already?\");\n+    assert(val_type != nullptr, \"need a type\");\n@@ -206,1 +206,1 @@\n-    assert(pre_val != NULL, \"must be loaded already\");\n+    assert(pre_val != nullptr, \"must be loaded already\");\n@@ -251,1 +251,1 @@\n-    \/\/ if (pre_val != NULL)\n+    \/\/ if (pre_val != nullptr)\n@@ -273,1 +273,1 @@\n-    } __ end_if();  \/\/ (pre_val != NULL)\n+    } __ end_if();  \/\/ (pre_val != nullptr)\n@@ -291,1 +291,1 @@\n- * the same region as the reference, when the NULL is being written or\n+ * the same region as the reference, when the null is being written or\n@@ -316,1 +316,1 @@\n-  if (alloc == NULL) {\n+  if (alloc == nullptr) {\n@@ -380,1 +380,1 @@\n-  \/\/ If we are writing a NULL then we need no post barrier\n+  \/\/ If we are writing a null then we need no post barrier\n@@ -382,2 +382,2 @@\n-  if (val != NULL && val->is_Con() && val->bottom_type() == TypePtr::NULL_PTR) {\n-    \/\/ Must be NULL\n+  if (val != nullptr && val->is_Con() && val->bottom_type() == TypePtr::NULL_PTR) {\n+    \/\/ Must be null\n@@ -385,2 +385,2 @@\n-    assert(t == Type::TOP || t == TypePtr::NULL_PTR, \"must be NULL\");\n-    \/\/ No post barrier if writing NULLx\n+    assert(t == Type::TOP || t == TypePtr::NULL_PTR, \"must be null\");\n+    \/\/ No post barrier if writing null\n@@ -409,1 +409,1 @@\n-  assert(adr != NULL, \"\");\n+  assert(adr != nullptr, \"\");\n@@ -451,1 +451,1 @@\n-  if (val != NULL) {\n+  if (val != nullptr) {\n@@ -462,1 +462,1 @@\n-      \/\/ No barrier if we are storing a NULL\n+      \/\/ No barrier if we are storing a null.\n@@ -512,1 +512,1 @@\n-  if (otype != NULL && otype->is_con() &&\n+  if (otype != nullptr && otype->is_con() &&\n@@ -520,1 +520,1 @@\n-  if (btype != NULL) {\n+  if (btype != nullptr) {\n@@ -527,1 +527,1 @@\n-    if (itype != NULL) {\n+    if (itype != nullptr) {\n@@ -566,1 +566,1 @@\n-      \/\/ is_instof == 0 if base_oop == NULL\n+      \/\/ is_instof == 0 if base_oop == nullptr\n@@ -575,1 +575,1 @@\n-                    NULL \/* obj *\/, NULL \/* adr *\/, max_juint \/* alias_idx *\/, NULL \/* val *\/, NULL \/* val_type *\/,\n+                    nullptr \/* obj *\/, nullptr \/* adr *\/, max_juint \/* alias_idx *\/, nullptr \/* val *\/, nullptr \/* val_type *\/,\n@@ -650,1 +650,1 @@\n-                NULL \/* obj *\/, NULL \/* adr *\/, max_juint \/* alias_idx *\/, NULL \/* val *\/, NULL \/* val_type *\/,\n+                nullptr \/* obj *\/, nullptr \/* adr *\/, max_juint \/* alias_idx *\/, nullptr \/* val *\/, nullptr \/* val_type *\/,\n@@ -672,1 +672,1 @@\n-  if (call->_name == NULL) {\n+  if (call->_name == nullptr) {\n@@ -723,1 +723,1 @@\n-    \/\/ An other case of only one user (Xor) is when the value check for NULL\n+    \/\/ An other case of only one user (Xor) is when the value check for null\n@@ -730,1 +730,1 @@\n-    assert(this_region != NULL, \"\");\n+    assert(this_region != nullptr, \"\");\n@@ -738,1 +738,1 @@\n-    if (xorx != NULL) {\n+    if (xorx != nullptr) {\n@@ -749,1 +749,1 @@\n-      \/\/ There is no G1 pre barrier if previous stored value is NULL\n+      \/\/ There is no G1 pre barrier if previous stored value is null\n@@ -780,1 +780,1 @@\n-      assert(shift != NULL, \"missing G1 post barrier\");\n+      assert(shift != nullptr, \"missing G1 post barrier\");\n@@ -783,1 +783,1 @@\n-      assert(load != NULL, \"missing G1 post barrier\");\n+      assert(load != nullptr, \"missing G1 post barrier\");\n@@ -800,1 +800,1 @@\n-      c != NULL && c->is_Region() && c->req() == 3) {\n+      c != nullptr && c->is_Region() && c->req() == 3) {\n@@ -802,1 +802,1 @@\n-      if (c->in(i) != NULL && c->in(i)->is_Region() &&\n+      if (c->in(i) != nullptr && c->in(i)->is_Region() &&\n@@ -806,2 +806,2 @@\n-          if (r->in(j) != NULL && r->in(j)->is_Proj() &&\n-              r->in(j)->in(0) != NULL &&\n+          if (r->in(j) != nullptr && r->in(j)->is_Proj() &&\n+              r->in(j)->in(0) != nullptr &&\n@@ -812,1 +812,1 @@\n-            if (c != NULL && c->Opcode() != Op_Parm) {\n+            if (c != nullptr && c->Opcode() != Op_Parm) {\n@@ -814,1 +814,1 @@\n-              if (c != NULL) {\n+              if (c != nullptr) {\n@@ -816,5 +816,5 @@\n-                assert(call->in(0) == NULL ||\n-                       call->in(0)->in(0) == NULL ||\n-                       call->in(0)->in(0)->in(0) == NULL ||\n-                       call->in(0)->in(0)->in(0)->in(0) == NULL ||\n-                       call->in(0)->in(0)->in(0)->in(0)->in(0) == NULL ||\n+                assert(call->in(0) == nullptr ||\n+                       call->in(0)->in(0) == nullptr ||\n+                       call->in(0)->in(0)->in(0) == nullptr ||\n+                       call->in(0)->in(0)->in(0)->in(0) == nullptr ||\n+                       call->in(0)->in(0)->in(0)->in(0)->in(0) == nullptr ||\n@@ -867,1 +867,1 @@\n-  if (pre_val_if != NULL) {\n+  if (pre_val_if != nullptr) {\n@@ -894,1 +894,1 @@\n-        assert(x->in(0) != NULL, \"Pre-val load has to have a control\");\n+        assert(x->in(0) != nullptr, \"Pre-val load has to have a control\");\n@@ -938,1 +938,1 @@\n-    if (x == NULL || x == compile->top()) continue;\n+    if (x == nullptr || x == compile->top()) continue;\n@@ -976,1 +976,1 @@\n-    if (x == NULL || x == compile->top()) continue;\n+    if (x == nullptr || x == compile->top()) continue;\n@@ -1016,1 +1016,1 @@\n-              assert(load_ctrl != NULL && if_ctrl == load_ctrl, \"controls must match\");\n+              assert(load_ctrl != nullptr && if_ctrl == load_ctrl, \"controls must match\");\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":54,"deletions":54,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,2 @@\n-G1CollectedHeap* G1AllocRegion::_g1h = NULL;\n-HeapRegion* G1AllocRegion::_dummy_region = NULL;\n+G1CollectedHeap* G1AllocRegion::_g1h = nullptr;\n+HeapRegion* G1AllocRegion::_dummy_region = nullptr;\n@@ -40,2 +40,2 @@\n-  assert(_dummy_region == NULL, \"should be set once\");\n-  assert(dummy_region != NULL, \"pre-condition\");\n+  assert(_dummy_region == nullptr, \"should be set once\");\n+  assert(dummy_region != nullptr, \"pre-condition\");\n@@ -47,1 +47,1 @@\n-  assert(dummy_region->par_allocate(1, 1, &assert_tmp) == NULL, \"should fail\");\n+  assert(dummy_region->par_allocate(1, 1, &assert_tmp) == nullptr, \"should fail\");\n@@ -54,1 +54,1 @@\n-  assert(alloc_region != NULL && alloc_region != _dummy_region,\n+  assert(alloc_region != nullptr && alloc_region != _dummy_region,\n@@ -76,1 +76,1 @@\n-    if (dummy != NULL) {\n+    if (dummy != nullptr) {\n@@ -118,1 +118,1 @@\n-  assert_alloc_region(_alloc_region != NULL, \"not initialized properly\");\n+  assert_alloc_region(_alloc_region != nullptr, \"not initialized properly\");\n@@ -140,1 +140,1 @@\n-  if (new_alloc_region != NULL) {\n+  if (new_alloc_region != nullptr) {\n@@ -145,1 +145,1 @@\n-    assert_alloc_region(result != NULL, \"the allocation should succeeded\");\n+    assert_alloc_region(result != nullptr, \"the allocation should succeeded\");\n@@ -156,1 +156,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -163,2 +163,2 @@\n-  assert_alloc_region(_alloc_region == NULL && _used_bytes_before == 0, \"pre-condition\");\n-  assert_alloc_region(_dummy_region != NULL, \"should have been set\");\n+  assert_alloc_region(_alloc_region == nullptr && _used_bytes_before == 0, \"pre-condition\");\n+  assert_alloc_region(_dummy_region != nullptr, \"should have been set\");\n@@ -174,1 +174,1 @@\n-  assert_alloc_region(alloc_region != NULL && !alloc_region->is_empty(), \"pre-condition\");\n+  assert_alloc_region(alloc_region != nullptr && !alloc_region->is_empty(), \"pre-condition\");\n@@ -189,1 +189,1 @@\n-  assert_alloc_region(alloc_region != NULL && !alloc_region->is_empty(), \"pre-condition\");\n+  assert_alloc_region(alloc_region != nullptr && !alloc_region->is_empty(), \"pre-condition\");\n@@ -201,1 +201,1 @@\n-  _alloc_region = NULL;\n+  _alloc_region = nullptr;\n@@ -203,1 +203,1 @@\n-  return (alloc_region == _dummy_region) ? NULL : alloc_region;\n+  return (alloc_region == _dummy_region) ? nullptr : alloc_region;\n@@ -220,1 +220,1 @@\n-  if ((actual_word_size == 0 && result == NULL) || detailed_info) {\n+  if ((actual_word_size == 0 && result == nullptr) || detailed_info) {\n@@ -228,2 +228,2 @@\n-    if (_alloc_region == NULL) {\n-      out->print(\"NULL\");\n+    if (_alloc_region == nullptr) {\n+      out->print(\"null\");\n@@ -239,1 +239,1 @@\n-      if (result != NULL) {\n+      if (result != nullptr) {\n@@ -254,1 +254,1 @@\n-  : _alloc_region(NULL),\n+  : _alloc_region(nullptr),\n@@ -272,1 +272,1 @@\n-  assert(_retained_alloc_region == NULL, \"Pre-condition\");\n+  assert(_retained_alloc_region == nullptr, \"Pre-condition\");\n@@ -283,1 +283,1 @@\n-  if (_retained_alloc_region != NULL &&\n+  if (_retained_alloc_region != nullptr &&\n@@ -295,1 +295,1 @@\n-  if (current_region != NULL) {\n+  if (current_region != nullptr) {\n@@ -300,1 +300,1 @@\n-      if (_retained_alloc_region != NULL) {\n+      if (_retained_alloc_region != nullptr) {\n@@ -318,1 +318,1 @@\n-  if (hr != NULL) {\n+  if (hr != nullptr) {\n@@ -323,1 +323,1 @@\n-  if (hr != NULL) {\n+  if (hr != nullptr) {\n@@ -335,1 +335,1 @@\n-  if (_retained_alloc_region != NULL) {\n+  if (_retained_alloc_region != nullptr) {\n@@ -337,1 +337,1 @@\n-    _retained_alloc_region = NULL;\n+    _retained_alloc_region = nullptr;\n@@ -362,1 +362,1 @@\n-  if (retired != NULL) {\n+  if (retired != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.cpp","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-  \/\/ it can never be NULL) and this object can be used to satisfy\n+  \/\/ it can never be null) and this object can be used to satisfy\n@@ -52,1 +52,1 @@\n-  \/\/ then _alloc_region is NULL and this object should not be used to\n+  \/\/ then _alloc_region is null and this object should not be used to\n@@ -78,1 +78,1 @@\n-  \/\/ whether the _alloc_region is NULL or not.\n+  \/\/ whether the _alloc_region is null or not.\n@@ -147,1 +147,1 @@\n-    return (hr == _dummy_region) ? NULL : hr;\n+    return (hr == _dummy_region) ? nullptr : hr;\n@@ -156,1 +156,1 @@\n-  \/\/ or return NULL if it was unable to.\n+  \/\/ or return null if it was unable to.\n@@ -163,1 +163,1 @@\n-  \/\/ out of the active region, or return NULL if it was unable to.\n+  \/\/ out of the active region, or return null if it was unable to.\n@@ -202,1 +202,1 @@\n-             HeapWord* result = NULL) PRODUCT_RETURN;\n+             HeapWord* result = nullptr) PRODUCT_RETURN;\n@@ -227,1 +227,1 @@\n-      _retained_alloc_region(NULL) { }\n+      _retained_alloc_region(nullptr) { }\n@@ -238,1 +238,1 @@\n-  \/\/ out of the retained region, or return NULL if it was unable to.\n+  \/\/ out of the retained region, or return null if it was unable to.\n@@ -244,1 +244,1 @@\n-  \/\/ region is retired and set to NULL.\n+  \/\/ region is retired and set to null.\n@@ -264,1 +264,1 @@\n-    assert(stats != NULL, \"Must pass non-NULL PLAB statistics\");\n+    assert(stats != nullptr, \"Must pass non-null PLAB statistics\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-  assert(alloc_region != NULL, \"pre-condition\");\n+  assert(alloc_region != nullptr, \"pre-condition\");\n@@ -60,1 +60,1 @@\n-  assert(alloc_region != NULL, \"pre-condition\");\n+  assert(alloc_region != nullptr, \"pre-condition\");\n@@ -75,1 +75,1 @@\n-  assert_alloc_region(alloc_region != NULL, \"not initialized properly\");\n+  assert_alloc_region(alloc_region != nullptr, \"not initialized properly\");\n@@ -78,1 +78,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -83,1 +83,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -95,1 +95,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -107,1 +107,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -113,1 +113,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -117,1 +117,1 @@\n-  assert_alloc_region(_alloc_region != NULL, \"not initialized properly\");\n+  assert_alloc_region(_alloc_region != nullptr, \"not initialized properly\");\n@@ -121,1 +121,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -126,1 +126,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -132,1 +132,1 @@\n-  if (_retained_alloc_region != NULL) {\n+  if (_retained_alloc_region != nullptr) {\n@@ -134,1 +134,1 @@\n-    if (result != NULL) {\n+    if (result != nullptr) {\n@@ -139,1 +139,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.inline.hpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-  _mutator_alloc_regions(NULL),\n-  _survivor_gc_alloc_regions(NULL),\n+  _mutator_alloc_regions(nullptr),\n+  _survivor_gc_alloc_regions(nullptr),\n@@ -49,1 +49,1 @@\n-  _retained_old_gc_alloc_region(NULL) {\n+  _retained_old_gc_alloc_region(nullptr) {\n@@ -73,1 +73,1 @@\n-  return mutator_alloc_region(node_index)->get() != NULL;\n+  return mutator_alloc_region(node_index)->get() != nullptr;\n@@ -79,1 +79,1 @@\n-    assert(mutator_alloc_region(i)->get() == NULL, \"pre-condition\");\n+    assert(mutator_alloc_region(i)->get() == nullptr, \"pre-condition\");\n@@ -87,1 +87,1 @@\n-    assert(mutator_alloc_region(i)->get() == NULL, \"post-condition\");\n+    assert(mutator_alloc_region(i)->get() == nullptr, \"post-condition\");\n@@ -99,1 +99,1 @@\n-  *retained_old = NULL;\n+  *retained_old = nullptr;\n@@ -110,1 +110,1 @@\n-  if (retained_region != NULL &&\n+  if (retained_region != nullptr &&\n@@ -153,1 +153,1 @@\n-  \/\/ _retained_old_gc_alloc_region will become NULL. This is what we\n+  \/\/ _retained_old_gc_alloc_region will become null. This is what we\n@@ -161,1 +161,1 @@\n-    assert(survivor_gc_alloc_region(i)->get() == NULL, \"pre-condition\");\n+    assert(survivor_gc_alloc_region(i)->get() == nullptr, \"pre-condition\");\n@@ -163,2 +163,2 @@\n-  assert(old_gc_alloc_region()->get() == NULL, \"pre-condition\");\n-  _retained_old_gc_alloc_region = NULL;\n+  assert(old_gc_alloc_region()->get() == nullptr, \"pre-condition\");\n+  _retained_old_gc_alloc_region = nullptr;\n@@ -194,1 +194,1 @@\n-  if (hr == NULL) {\n+  if (hr == nullptr) {\n@@ -202,1 +202,1 @@\n-  assert(Heap_lock->owner() != NULL, \"Should be owned on this thread's behalf.\");\n+  assert(Heap_lock->owner() != nullptr, \"Should be owned on this thread's behalf.\");\n@@ -216,1 +216,1 @@\n-  assert(result == NULL || temp == word_size,\n+  assert(result == nullptr || temp == word_size,\n@@ -234,1 +234,1 @@\n-      return NULL; \/\/ Keep some compilers happy\n+      return nullptr; \/\/ Keep some compilers happy\n@@ -248,1 +248,1 @@\n-  if (result == NULL && !survivor_is_full()) {\n+  if (result == nullptr && !survivor_is_full()) {\n@@ -257,1 +257,1 @@\n-      if (result == NULL) {\n+      if (result == nullptr) {\n@@ -262,1 +262,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -277,1 +277,1 @@\n-  if (result == NULL && !old_is_full()) {\n+  if (result == nullptr && !old_is_full()) {\n@@ -286,1 +286,1 @@\n-      if (result == NULL) {\n+      if (result == nullptr) {\n@@ -401,1 +401,1 @@\n-    assert(buf == NULL || ((actual_plab_size >= required_in_plab) && (actual_plab_size <= plab_word_size)),\n+    assert(buf == nullptr || ((actual_plab_size >= required_in_plab) && (actual_plab_size <= plab_word_size)),\n@@ -405,1 +405,1 @@\n-    if (buf != NULL) {\n+    if (buf != nullptr) {\n@@ -409,1 +409,1 @@\n-      assert(obj != NULL, \"PLAB should have been big enough, tried to allocate \"\n+      assert(obj != nullptr, \"PLAB should have been big enough, tried to allocate \"\n@@ -419,1 +419,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -435,1 +435,1 @@\n-      if (buf != NULL) {\n+      if (buf != nullptr) {\n@@ -461,1 +461,1 @@\n-      if (buf != NULL) {\n+      if (buf != nullptr) {\n@@ -478,1 +478,1 @@\n-      if (buf != NULL) {\n+      if (buf != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -206,1 +206,1 @@\n-  \/\/ allocating a new PLAB. Returns the address of the allocated memory, NULL if\n+  \/\/ allocating a new PLAB. Returns the address of the allocated memory, null if\n@@ -215,1 +215,1 @@\n-  \/\/ allocated memory, NULL if not successful.\n+  \/\/ allocated memory, null if not successful.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -69,1 +69,1 @@\n-  assert(result != NULL || mutator_alloc_region(node_index)->get() == NULL,\n+  assert(result != nullptr || mutator_alloc_region(node_index)->get() == nullptr,\n@@ -83,1 +83,1 @@\n-         \"Allocation buffer is NULL: %s\", dest.get_type_str());\n+         \"Allocation buffer is null: %s\", dest.get_type_str());\n@@ -120,1 +120,1 @@\n-  if (obj != NULL) {\n+  if (obj != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,1 @@\n-    while (token != NULL) {\n+    while (token != nullptr) {\n@@ -86,1 +86,1 @@\n-      token = strtok_r(NULL, delimiter, &save_ptr);\n+      token = strtok_r(nullptr, delimiter, &save_ptr);\n@@ -170,1 +170,1 @@\n-    vm_exit_during_initialization(\"The flag -XX:+UseG1GC can not be combined with -XX:ParallelGCThreads=0\", NULL);\n+    vm_exit_during_initialization(\"The flag -XX:+UseG1GC can not be combined with -XX:ParallelGCThreads=0\", nullptr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,1 +101,1 @@\n-  if (needs_enqueue && value != NULL) {\n+  if (needs_enqueue && value != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n-  _alloc_base(NULL),\n-  _base(NULL),\n+  _alloc_base(nullptr),\n+  _base(nullptr),\n@@ -33,1 +33,1 @@\n-  _biased_base(NULL),\n+  _biased_base(nullptr),\n@@ -50,1 +50,1 @@\n-  guarantee(_base != NULL, \"Array not initialized\");\n+  guarantee(_base != nullptr, \"Array not initialized\");\n@@ -55,1 +55,1 @@\n-  guarantee(_biased_base != NULL, \"Array not initialized\");\n+  guarantee(_biased_base != nullptr, \"Array not initialized\");\n@@ -62,1 +62,1 @@\n-  guarantee(_biased_base != NULL, \"Array not initialized\");\n+  guarantee(_biased_base != nullptr, \"Array not initialized\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BiasedArray.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-    assert(base != NULL, \"just checking\");\n+    assert(base != nullptr, \"just checking\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BiasedArray.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-  _reserved(heap), _offset_array(NULL) {\n+  _reserved(heap), _offset_array(nullptr) {\n@@ -189,1 +189,1 @@\n-  assert(blk_start != NULL && blk_end > blk_start,\n+  assert(blk_start != nullptr && blk_end > blk_start,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -862,1 +862,1 @@\n-    st->print(\"NULL card set\");\n+    st->print(\"null card set\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-  G1CardTableChangedListener() : _card_table(NULL) { }\n+  G1CardTableChangedListener() : _card_table(nullptr) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTable.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-    if (bs_nm != NULL) {\n+    if (bs_nm != nullptr) {\n@@ -104,1 +104,1 @@\n-  if (bs_nm != NULL) {\n+  if (bs_nm != nullptr) {\n@@ -128,1 +128,1 @@\n-  if (nm == NULL) {\n+  if (nm == nullptr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeBlobClosure.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-    HeapRegionGatheringOopClosure(OopClosure* oc) : _g1h(G1CollectedHeap::heap()), _work(oc), _nm(NULL) {}\n+    HeapRegionGatheringOopClosure(OopClosure* oc) : _g1h(G1CollectedHeap::heap()), _work(oc), _nm(nullptr) {}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeBlobClosure.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -173,1 +173,1 @@\n-  if (res == NULL && do_expand) {\n+  if (res == nullptr && do_expand) {\n@@ -189,1 +189,1 @@\n-      \/\/ In either case allocate_free_region() will check for NULL.\n+      \/\/ In either case allocate_free_region() will check for null.\n@@ -282,1 +282,1 @@\n-  assert(first_hr != NULL, \"pre-condition\");\n+  assert(first_hr != nullptr, \"pre-condition\");\n@@ -351,1 +351,1 @@\n-  if (humongous_start == NULL) {\n+  if (humongous_start == nullptr) {\n@@ -356,1 +356,1 @@\n-    if (humongous_start != NULL) {\n+    if (humongous_start != nullptr) {\n@@ -366,2 +366,2 @@\n-  HeapWord* result = NULL;\n-  if (humongous_start != NULL) {\n+  HeapWord* result = nullptr;\n+  if (humongous_start != nullptr) {\n@@ -369,1 +369,1 @@\n-    assert(result != NULL, \"it should always return a valid result\");\n+    assert(result != nullptr, \"it should always return a valid result\");\n@@ -418,2 +418,2 @@\n-  \/\/ return NULL.\n-  HeapWord* result = NULL;\n+  \/\/ return null.\n+  HeapWord* result = nullptr;\n@@ -430,1 +430,1 @@\n-      if (result != NULL) {\n+      if (result != nullptr) {\n@@ -441,1 +441,1 @@\n-        if (result != NULL) {\n+        if (result != nullptr) {\n@@ -457,2 +457,2 @@\n-      if (result != NULL) {\n-        assert(succeeded, \"only way to get back a non-NULL result\");\n+      if (result != nullptr) {\n+        assert(succeeded, \"only way to get back a non-null result\");\n@@ -466,1 +466,1 @@\n-        \/\/ point in trying to allocate further. We'll just return NULL.\n+        \/\/ point in trying to allocate further. We'll just return null.\n@@ -469,1 +469,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -478,1 +478,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -498,1 +498,1 @@\n-    if (result != NULL) {\n+    if (result != nullptr) {\n@@ -511,1 +511,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -640,1 +640,1 @@\n-  if (result == NULL) {\n+  if (result == nullptr) {\n@@ -646,1 +646,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -687,2 +687,2 @@\n-  \/\/ return NULL.\n-  HeapWord* result = NULL;\n+  \/\/ return null.\n+  HeapWord* result = nullptr;\n@@ -702,1 +702,1 @@\n-      if (result != NULL) {\n+      if (result != nullptr) {\n@@ -719,2 +719,2 @@\n-      if (result != NULL) {\n-        assert(succeeded, \"only way to get back a non-NULL result\");\n+      if (result != nullptr) {\n+        assert(succeeded, \"only way to get back a non-null result\");\n@@ -731,1 +731,1 @@\n-        \/\/ point in trying to allocate further. We'll just return NULL.\n+        \/\/ point in trying to allocate further. We'll just return null.\n@@ -734,1 +734,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -743,1 +743,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -771,1 +771,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -778,1 +778,1 @@\n-         \"the current alloc region was unexpectedly found to be non-NULL\");\n+         \"the current alloc region was unexpectedly found to be non-null\");\n@@ -784,1 +784,1 @@\n-    if (result != NULL && policy()->need_to_start_conc_mark(\"STW humongous allocation\")) {\n+    if (result != nullptr && policy()->need_to_start_conc_mark(\"STW humongous allocation\")) {\n@@ -928,1 +928,1 @@\n-  GCTraceTime(Info, gc) tm(\"Pause Full\", NULL, gc_cause(), true);\n+  GCTraceTime(Info, gc) tm(\"Pause Full\", nullptr, gc_cause(), true);\n@@ -984,1 +984,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -993,1 +993,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1011,1 +1011,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1026,1 +1026,1 @@\n-  if (result != NULL || !*succeeded) {\n+  if (result != nullptr || !*succeeded) {\n@@ -1037,1 +1037,1 @@\n-  if (result != NULL || !*succeeded) {\n+  if (result != nullptr || !*succeeded) {\n@@ -1048,1 +1048,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1059,1 +1059,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1065,1 +1065,1 @@\n-\/\/ allocated block, or else \"NULL\".\n+\/\/ allocated block, or else null.\n@@ -1083,1 +1083,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1104,1 +1104,1 @@\n-  if (expand_time_ms != NULL) {\n+  if (expand_time_ms != nullptr) {\n@@ -1223,5 +1223,5 @@\n-  _service_thread(NULL),\n-  _periodic_gc_task(NULL),\n-  _free_arena_memory_task(NULL),\n-  _workers(NULL),\n-  _card_table(NULL),\n+  _service_thread(nullptr),\n+  _periodic_gc_task(nullptr),\n+  _free_arena_memory_task(nullptr),\n+  _workers(nullptr),\n+  _card_table(nullptr),\n@@ -1232,1 +1232,1 @@\n-  _bot(NULL),\n+  _bot(nullptr),\n@@ -1236,1 +1236,1 @@\n-  _allocator(NULL),\n+  _allocator(nullptr),\n@@ -1238,1 +1238,1 @@\n-  _verifier(NULL),\n+  _verifier(nullptr),\n@@ -1255,1 +1255,1 @@\n-  _heap_sizing_policy(NULL),\n+  _heap_sizing_policy(nullptr),\n@@ -1257,1 +1257,1 @@\n-  _rem_set(NULL),\n+  _rem_set(nullptr),\n@@ -1260,5 +1260,5 @@\n-  _cm(NULL),\n-  _cm_thread(NULL),\n-  _cr(NULL),\n-  _task_queues(NULL),\n-  _ref_processor_stw(NULL),\n+  _cm(nullptr),\n+  _cm_thread(nullptr),\n+  _cr(nullptr),\n+  _task_queues(nullptr),\n+  _ref_processor_stw(nullptr),\n@@ -1267,1 +1267,1 @@\n-  _ref_processor_cm(NULL),\n+  _ref_processor_cm(nullptr),\n@@ -1297,1 +1297,1 @@\n-  guarantee(_task_queues != NULL, \"task_queues allocation failure.\");\n+  guarantee(_task_queues != nullptr, \"task_queues allocation failure.\");\n@@ -1333,1 +1333,1 @@\n-  if (_service_thread->osthread() == NULL) {\n+  if (_service_thread->osthread() == nullptr) {\n@@ -1402,1 +1402,1 @@\n-  if(heap_storage == NULL) {\n+  if(heap_storage == nullptr) {\n@@ -1464,1 +1464,1 @@\n-  if (_workers == NULL) {\n+  if (_workers == nullptr) {\n@@ -2096,1 +2096,1 @@\n-    if (hr_claimer == NULL || hr_claimer->claim_region(region_idx)) {\n+    if (hr_claimer == nullptr || hr_claimer->claim_region(region_idx)) {\n@@ -2257,1 +2257,1 @@\n-  if (_cm != NULL) {\n+  if (_cm != nullptr) {\n@@ -2377,2 +2377,2 @@\n-  assert(result == NULL || ret_succeeded,\n-         \"the result should be NULL if the VM did not succeed\");\n+  assert(result == nullptr || ret_succeeded,\n+         \"the result should be null if the VM did not succeed\");\n@@ -2600,1 +2600,1 @@\n-  assert(obj != NULL, \"must not be NULL\");\n+  assert(obj != nullptr, \"must not be null\");\n@@ -2611,1 +2611,1 @@\n-    if (pll_head != NULL) {\n+    if (pll_head != nullptr) {\n@@ -2625,1 +2625,1 @@\n-  return candidates != NULL && candidates->num_remaining() > 0;\n+  return candidates != nullptr && candidates->num_remaining() > 0;\n@@ -2657,1 +2657,1 @@\n-  if (free_list != NULL) {\n+  if (free_list != nullptr) {\n@@ -2680,1 +2680,1 @@\n-  assert(list != NULL, \"list can't be null\");\n+  assert(list != nullptr, \"list can't be null\");\n@@ -2880,1 +2880,1 @@\n-    if (new_alloc_region != NULL) {\n+    if (new_alloc_region != nullptr) {\n@@ -2887,1 +2887,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2920,1 +2920,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2935,1 +2935,1 @@\n-  if (new_alloc_region != NULL) {\n+  if (new_alloc_region != nullptr) {\n@@ -2948,1 +2948,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2980,1 +2980,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3045,1 +3045,1 @@\n-  guarantee(nm != NULL, \"sanity\");\n+  guarantee(nm != nullptr, \"sanity\");\n@@ -3051,1 +3051,1 @@\n-  guarantee(nm != NULL, \"sanity\");\n+  guarantee(nm != nullptr, \"sanity\");\n@@ -3078,1 +3078,1 @@\n-    if (nm != NULL) {\n+    if (nm != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":81,"deletions":81,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -355,4 +355,4 @@\n-#define assert_at_safepoint_on_vm_thread()                                    \\\n-  do {                                                                        \\\n-    assert_at_safepoint();                                                    \\\n-    assert(Thread::current_or_null() != NULL, \"no current thread\");           \\\n+#define assert_at_safepoint_on_vm_thread()                                        \\\n+  do {                                                                            \\\n+    assert_at_safepoint();                                                        \\\n+    assert(Thread::current_or_null() != nullptr, \"no current thread\");            \\\n@@ -407,1 +407,1 @@\n-  \/\/ NULL if unsuccessful.\n+  \/\/ null if unsuccessful.\n@@ -430,1 +430,1 @@\n-  \/\/   an evacuation pause, allocate_new_tlab() will return NULL,\n+  \/\/   an evacuation pause, allocate_new_tlab() will return null,\n@@ -464,1 +464,1 @@\n-  \/\/ specifies whether the mutator alloc region is expected to be NULL\n+  \/\/ specifies whether the mutator alloc region is expected to be null\n@@ -522,1 +522,1 @@\n-  \/\/ allocated block, or else \"NULL\".\n+  \/\/ allocated block, or else null.\n@@ -577,1 +577,1 @@\n-  bool expand(size_t expand_bytes, WorkerThreads* pretouch_workers = NULL, double* expand_time_ms = NULL);\n+  bool expand(size_t expand_bytes, WorkerThreads* pretouch_workers = nullptr, double* expand_time_ms = nullptr);\n@@ -681,1 +681,1 @@\n-  \/\/ to the master free list later or NULL if free list management is handled\n+  \/\/ to the master free list later or null if free list management is handled\n@@ -1121,1 +1121,1 @@\n-    collection_set_iterate_increment_from(blk, NULL, worker_id);\n+    collection_set_iterate_increment_from(blk, nullptr, worker_id);\n@@ -1133,1 +1133,1 @@\n-  \/\/ Returns the HeapRegion that contains addr. addr must not be nullptr.\n+  \/\/ Returns the HeapRegion that contains addr. addr must not be null.\n@@ -1136,2 +1136,2 @@\n-  \/\/ Returns the HeapRegion that contains addr, or nullptr if that is an uncommitted\n-  \/\/ region. addr must not be nullptr.\n+  \/\/ Returns the HeapRegion that contains addr, or null if that is an uncommitted\n+  \/\/ region. addr must not be null.\n@@ -1229,1 +1229,1 @@\n-  \/\/ If obj is NULL it is not dead.\n+  \/\/ If obj is null it is not dead.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-      return NULL; \/\/ Keep some compilers happy\n+      return nullptr; \/\/ Keep some compilers happy\n@@ -107,1 +107,1 @@\n-\/\/ Return the region with the given index, or NULL if unmapped. It assumes the index is valid.\n+\/\/ Return the region with the given index, or null if unmapped. It assumes the index is valid.\n@@ -233,1 +233,1 @@\n-  if (obj == NULL) {\n+  if (obj == nullptr) {\n@@ -240,2 +240,2 @@\n-  assert(obj != NULL, \"\");\n-  return !heap_region_containing(obj)->is_young(); \/\/ is_in_young does an unnecessary NULL check\n+  assert(obj != nullptr, \"\");\n+  return !heap_region_containing(obj)->is_young(); \/\/ is_in_young does an unnecessary null check\n@@ -254,1 +254,1 @@\n-  if (obj == NULL) {\n+  if (obj == nullptr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-  _candidates(NULL),\n+  _candidates(nullptr),\n@@ -57,1 +57,1 @@\n-  _collection_set_regions(NULL),\n+  _collection_set_regions(nullptr),\n@@ -86,1 +86,1 @@\n-  guarantee(_collection_set_regions == NULL, \"Must only initialize once.\");\n+  guarantee(_collection_set_regions == nullptr, \"Must only initialize once.\");\n@@ -97,1 +97,1 @@\n-  _candidates = NULL;\n+  _candidates = nullptr;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -214,1 +214,1 @@\n-    assert(_candidates == NULL, \"Trying to replace collection set candidates.\");\n+    assert(_candidates == nullptr, \"Trying to replace collection set candidates.\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    _regions[cur_idx] = NULL;\n+    _regions[cur_idx] = nullptr;\n@@ -82,1 +82,1 @@\n-  HeapRegion *prev = NULL;\n+  HeapRegion *prev = nullptr;\n@@ -85,1 +85,1 @@\n-    guarantee(cur != NULL, \"Regions after _front_idx %u cannot be NULL but %u is\", _front_idx, idx);\n+    guarantee(cur != nullptr, \"Regions after _front_idx %u cannot be null but %u is\", _front_idx, idx);\n@@ -91,1 +91,1 @@\n-    if (prev != NULL) {\n+    if (prev != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-    HeapRegion* res = NULL;\n+    HeapRegion* res = nullptr;\n@@ -72,1 +72,1 @@\n-      assert(res != NULL, \"Unexpected NULL HeapRegion at index %u\", idx);\n+      assert(res != nullptr, \"Unexpected null HeapRegion at index %u\", idx);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,3 +42,3 @@\n-  \/\/ Make sure that NULL entries are moved to the end.\n-  if (hr1 == NULL) {\n-    if (hr2 == NULL) {\n+  \/\/ Make sure that null entries are moved to the end.\n+  if (hr1 == nullptr) {\n+    if (hr2 == nullptr) {\n@@ -49,1 +49,1 @@\n-  } else if (hr2 == NULL) {\n+  } else if (hr2 == nullptr) {\n@@ -77,1 +77,1 @@\n-  \/\/ Array elements may be NULL as threads might not get enough regions to fill\n+  \/\/ Array elements may be null as threads might not get enough regions to fill\n@@ -105,1 +105,1 @@\n-        _data[i] = NULL;\n+        _data[i] = nullptr;\n@@ -126,1 +126,1 @@\n-      assert(_data[idx] == NULL, \"Value must not have been set.\");\n+      assert(_data[idx] == nullptr, \"Value must not have been set.\");\n@@ -135,1 +135,1 @@\n-        assert(_data[i] == NULL, \"must be\");\n+        assert(_data[i] == nullptr, \"must be\");\n@@ -139,1 +139,1 @@\n-        assert(_data[i] == NULL, \"must be\");\n+        assert(_data[i] == nullptr, \"must be\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-  _base(NULL),\n+  _base(nullptr),\n@@ -112,1 +112,1 @@\n-  if (new_base == NULL) {\n+  if (new_base == nullptr) {\n@@ -117,1 +117,1 @@\n-  if (_base != NULL) {\n+  if (_base != nullptr) {\n@@ -170,1 +170,1 @@\n-  if (_base != NULL) {\n+  if (_base != nullptr) {\n@@ -193,1 +193,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -202,1 +202,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -218,1 +218,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -223,1 +223,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -227,1 +227,1 @@\n-  result->next = NULL;\n+  result->next = nullptr;\n@@ -235,1 +235,1 @@\n-  if (new_chunk == NULL) {\n+  if (new_chunk == nullptr) {\n@@ -239,1 +239,1 @@\n-    if (new_chunk == NULL) {\n+    if (new_chunk == nullptr) {\n@@ -254,1 +254,1 @@\n-  if (cur == NULL) {\n+  if (cur == nullptr) {\n@@ -267,2 +267,2 @@\n-  _chunk_list = NULL;\n-  _free_list = NULL;\n+  _chunk_list = nullptr;\n+  _free_list = nullptr;\n@@ -291,1 +291,1 @@\n-  assert(start != NULL && end != NULL && start <= end, \"Start (\" PTR_FORMAT \") should be less or equal to \"\n+  assert(start != nullptr && end != nullptr && start <= end, \"Start (\" PTR_FORMAT \") should be less or equal to \"\n@@ -308,1 +308,1 @@\n-    \/\/ If someone has set the should_abort flag, we return NULL to\n+    \/\/ If someone has set the should_abort flag, we return null to\n@@ -310,1 +310,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -314,1 +314,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -321,1 +321,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -407,1 +407,1 @@\n-  _accum_task_vtime(NULL),\n+  _accum_task_vtime(nullptr),\n@@ -409,1 +409,1 @@\n-  _concurrent_workers(NULL),\n+  _concurrent_workers(nullptr),\n@@ -417,1 +417,1 @@\n-  assert(CGC_lock != NULL, \"CGC_lock must be initialized\");\n+  assert(CGC_lock != nullptr, \"CGC_lock must be initialized\");\n@@ -423,1 +423,1 @@\n-  if (_cm_thread->osthread() == NULL) {\n+  if (_cm_thread->osthread() == nullptr) {\n@@ -471,1 +471,1 @@\n-    _top_at_rebuild_starts[i] = NULL;\n+    _top_at_rebuild_starts[i] = nullptr;\n@@ -483,1 +483,1 @@\n-  _top_at_rebuild_starts[region_idx] = NULL;\n+  _top_at_rebuild_starts[region_idx] = nullptr;\n@@ -956,1 +956,1 @@\n-    while (region != NULL) {\n+    while (region != nullptr) {\n@@ -1352,1 +1352,1 @@\n-        hr->set_containing_set(NULL);\n+        hr->set_containing_set(nullptr);\n@@ -1724,1 +1724,1 @@\n-    return obj != NULL &&\n+    return obj != nullptr &&\n@@ -1870,1 +1870,1 @@\n-    \/\/ Above heap_region_containing may return NULL as we always scan claim\n+    \/\/ Above heap_region_containing may return null as we always scan claim\n@@ -1890,1 +1890,1 @@\n-        \/\/ we return NULL and the caller should try calling\n+        \/\/ We return null and the caller should try calling\n@@ -1950,1 +1950,1 @@\n-    \/\/ Since we always iterate over all regions, we might get a nullptr HeapRegion\n+    \/\/ Since we always iterate over all regions, we might get a null HeapRegion\n@@ -2083,1 +2083,1 @@\n-  assert(result != NULL, \"CM reference processor should not be NULL\");\n+  assert(result != nullptr, \"CM reference processor should not be null\");\n@@ -2094,2 +2094,2 @@\n-  assert(hr != NULL,\n-        \"claim_region() should have filtered out NULL regions\");\n+  assert(hr != nullptr,\n+        \"claim_region() should have filtered out null regions\");\n@@ -2134,1 +2134,1 @@\n-  assert(_curr_region != NULL, \"invariant\");\n+  assert(_curr_region != nullptr, \"invariant\");\n@@ -2141,3 +2141,3 @@\n-  _curr_region   = NULL;\n-  _finger        = NULL;\n-  _region_limit  = NULL;\n+  _curr_region   = nullptr;\n+  _finger        = nullptr;\n+  _region_limit  = nullptr;\n@@ -2147,2 +2147,2 @@\n-  if (cm_oop_closure == NULL) {\n-    assert(_cm_oop_closure != NULL, \"invariant\");\n+  if (cm_oop_closure == nullptr) {\n+    assert(_cm_oop_closure != nullptr, \"invariant\");\n@@ -2150,1 +2150,1 @@\n-    assert(_cm_oop_closure == NULL, \"invariant\");\n+    assert(_cm_oop_closure == nullptr, \"invariant\");\n@@ -2156,1 +2156,1 @@\n-  guarantee(mark_bitmap != NULL, \"invariant\");\n+  guarantee(mark_bitmap != nullptr, \"invariant\");\n@@ -2607,1 +2607,1 @@\n-    if (!has_aborted() && _curr_region != NULL) {\n+    if (!has_aborted() && _curr_region != nullptr) {\n@@ -2609,2 +2609,2 @@\n-      assert(_finger != NULL, \"if region is not NULL, then the finger \"\n-             \"should not be NULL either\");\n+      assert(_finger != nullptr, \"if region is not null, then the finger \"\n+             \"should not be null either\");\n@@ -2659,1 +2659,1 @@\n-        assert(_finger != NULL, \"invariant\");\n+        assert(_finger != nullptr, \"invariant\");\n@@ -2685,1 +2685,1 @@\n-    \/\/ return NULL with potentially more regions available for\n+    \/\/ return null with potentially more regions available for\n@@ -2688,1 +2688,1 @@\n-    while (!has_aborted() && _curr_region == NULL && !_cm->out_of_regions()) {\n+    while (!has_aborted() && _curr_region == nullptr && !_cm->out_of_regions()) {\n@@ -2692,3 +2692,3 @@\n-      assert(_curr_region  == NULL, \"invariant\");\n-      assert(_finger       == NULL, \"invariant\");\n-      assert(_region_limit == NULL, \"invariant\");\n+      assert(_curr_region  == nullptr, \"invariant\");\n+      assert(_finger       == nullptr, \"invariant\");\n+      assert(_region_limit == nullptr, \"invariant\");\n@@ -2696,1 +2696,1 @@\n-      if (claimed_region != NULL) {\n+      if (claimed_region != nullptr) {\n@@ -2709,1 +2709,1 @@\n-    if (!has_aborted() && _curr_region == NULL) {\n+    if (!has_aborted() && _curr_region == nullptr) {\n@@ -2713,1 +2713,1 @@\n-  } while ( _curr_region != NULL && !has_aborted());\n+  } while ( _curr_region != nullptr && !has_aborted());\n@@ -2795,1 +2795,1 @@\n-  set_cm_oop_closure(NULL);\n+  set_cm_oop_closure(nullptr);\n@@ -2867,1 +2867,1 @@\n-  _mark_bitmap(NULL),\n+  _mark_bitmap(nullptr),\n@@ -2873,4 +2873,4 @@\n-  _cm_oop_closure(NULL),\n-  _curr_region(NULL),\n-  _finger(NULL),\n-  _region_limit(NULL),\n+  _cm_oop_closure(nullptr),\n+  _curr_region(nullptr),\n+  _finger(nullptr),\n+  _region_limit(nullptr),\n@@ -2892,1 +2892,1 @@\n-  guarantee(task_queue != NULL, \"invariant\");\n+  guarantee(task_queue != nullptr, \"invariant\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":61,"deletions":61,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-    assert(_holder != NULL, \"Not allowed to set NULL task queue element\");\n+    assert(_holder != nullptr, \"Not allowed to set null task queue element\");\n@@ -68,1 +68,1 @@\n-  G1TaskQueueEntry() : _holder(NULL) { }\n+  G1TaskQueueEntry() : _holder(nullptr) { }\n@@ -86,1 +86,1 @@\n-  bool is_null() const { return _holder == NULL; }\n+  bool is_null() const { return _holder == nullptr; }\n@@ -121,1 +121,1 @@\n-\/\/ have a NULL element as a terminating element.\n+\/\/ have a null element as a terminating element.\n@@ -155,1 +155,1 @@\n-  \/\/ NULL if out of memory.\n+  \/\/ null if out of memory.\n@@ -160,1 +160,1 @@\n-  \/\/ Atomically remove and return a chunk from the given list. Returns NULL if the\n+  \/\/ Atomically remove and return a chunk from the given list. Returns null if the\n@@ -186,1 +186,1 @@\n-  \/\/ be terminated with a NULL.\n+  \/\/ be terminated with a null.\n@@ -193,1 +193,1 @@\n-  \/\/ element in the array is a NULL pointer.\n+  \/\/ element in the array is a null pointer.\n@@ -198,1 +198,1 @@\n-  bool is_empty() const { return _chunk_list == NULL; }\n+  bool is_empty() const { return _chunk_list == nullptr; }\n@@ -253,1 +253,1 @@\n-  \/\/ Forces get_next() to return NULL so that the iteration aborts early.\n+  \/\/ Forces get_next() to return null so that the iteration aborts early.\n@@ -260,1 +260,1 @@\n-  \/\/ Claim the next root MemRegion to scan atomically, or return NULL if\n+  \/\/ Claim the next root MemRegion to scan atomically, or return null if\n@@ -409,1 +409,1 @@\n-  \/\/ task\/thread. It might return NULL if the next region is empty or\n+  \/\/ task\/thread. It might return null if the next region is empty or\n@@ -457,1 +457,1 @@\n-  \/\/ for regions which remembered sets need to be rebuilt. A NULL for a given region\n+  \/\/ for regions which remembered sets need to be rebuilt. A null for a given region\n@@ -658,1 +658,1 @@\n-  \/\/ Region this task is scanning, NULL if we're not scanning any\n+  \/\/ Region this task is scanning, null if we're not scanning any\n@@ -660,1 +660,1 @@\n-  \/\/ Local finger of this task, NULL if we're not scanning a region\n+  \/\/ Local finger of this task, null if we're not scanning a region\n@@ -662,1 +662,1 @@\n-  \/\/ Limit of the region this task is scanning, NULL if we're not scanning one\n+  \/\/ Limit of the region this task is scanning, null if we're not scanning one\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-  if (obj == NULL) {\n-    \/\/ Return true to avoid discovery when the referent is NULL.\n+  if (obj == nullptr) {\n+    \/\/ Return true to avoid discovery when the referent is null.\n@@ -66,1 +66,1 @@\n-  if (obj == NULL) {\n+  if (obj == nullptr) {\n@@ -99,1 +99,1 @@\n-  while (cur != NULL) {\n+  while (cur != nullptr) {\n@@ -145,1 +145,1 @@\n-  if (_finger != NULL) {\n+  if (_finger != nullptr) {\n@@ -148,1 +148,1 @@\n-    \/\/ Finger and region values are all NULL or all non-NULL.  We\n+    \/\/ Finger and region values are all null or all non-null.  We\n@@ -150,2 +150,2 @@\n-    assert(_curr_region != NULL, \"invariant\");\n-    assert(_region_limit != NULL, \"invariant\");\n+    assert(_curr_region != nullptr, \"invariant\");\n+    assert(_region_limit != nullptr, \"invariant\");\n@@ -200,2 +200,2 @@\n-  assert(_top_at_rebuild_starts[region] == NULL,\n-         \"TARS for region %u has already been set to \" PTR_FORMAT \" should be NULL\",\n+  assert(_top_at_rebuild_starts[region] == nullptr,\n+         \"TARS for region %u has already been set to \" PTR_FORMAT \" should be null\",\n@@ -207,1 +207,1 @@\n-    \/\/ Leave TARS at NULL.\n+    \/\/ Leave TARS at null.\n@@ -272,1 +272,1 @@\n-  if (obj == NULL) {\n+  if (obj == nullptr) {\n@@ -283,1 +283,1 @@\n-  assert(p != NULL && oopDesc::is_oop(p), \"expected an oop\");\n+  assert(p != nullptr && oopDesc::is_oop(p), \"expected an oop\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.inline.hpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-  G1CMBitMapMappingChangedListener() : _bm(NULL) {}\n+  G1CMBitMapMappingChangedListener() : _bm(nullptr) {}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkBitMap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-\/\/ Note that bottom <= parsable_bottom <= tars; if there is no tars (i.e. NULL),\n+\/\/ Note that bottom <= parsable_bottom <= tars; if there is no tars (i.e. null),\n@@ -102,1 +102,1 @@\n-    \/\/ the value may be changed to nullptr during rebuilding if the region has either:\n+    \/\/ the value may be changed to null during rebuilding if the region has either:\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-  assert(cr != NULL, \"G1ConcurrentRefine must not be NULL\");\n+  assert(cr != nullptr, \"G1ConcurrentRefine must not be null\");\n@@ -141,1 +141,1 @@\n-    if (_threads[i] != NULL) {\n+    if (_threads[i] != nullptr) {\n@@ -149,1 +149,1 @@\n-    if (_threads[i] != NULL) {\n+    if (_threads[i] != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,1 +158,1 @@\n-  \/\/ G1ConcurrentRefine instance. Otherwise, returns nullptr with error code.\n+  \/\/ G1ConcurrentRefine instance. Otherwise, returns null with error code.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-  assert(cbn != NULL, \"precondition\");\n+  assert(cbn != nullptr, \"precondition\");\n@@ -137,1 +137,1 @@\n-\/\/ It has a limitation that it may return NULL when there are objects\n+\/\/ It has a limitation that it may return null when there are objects\n@@ -141,1 +141,1 @@\n-  BufferNode* result = NULL;\n+  BufferNode* result = nullptr;\n@@ -158,1 +158,1 @@\n-  if (result == NULL) {         \/\/ Unlikely if no paused buffers.\n+  if (result == nullptr) {         \/\/ Unlikely if no paused buffers.\n@@ -161,1 +161,1 @@\n-    if (result == NULL) return NULL;\n+    if (result == nullptr) return nullptr;\n@@ -182,1 +182,1 @@\n-  _head(NULL), _tail(NULL),\n+  _head(nullptr), _tail(nullptr),\n@@ -188,2 +188,2 @@\n-  assert(Atomic::load(&_head) == NULL, \"precondition\");\n-  assert(_tail == NULL, \"precondition\");\n+  assert(Atomic::load(&_head) == nullptr, \"precondition\");\n+  assert(_tail == nullptr, \"precondition\");\n@@ -202,2 +202,2 @@\n-  if (old_head == NULL) {\n-    assert(_tail == NULL, \"invariant\");\n+  if (old_head == nullptr) {\n+    assert(_tail == nullptr, \"invariant\");\n@@ -213,2 +213,2 @@\n-  Atomic::store(&_head, (BufferNode*)NULL);\n-  _tail = NULL;\n+  Atomic::store(&_head, (BufferNode*)nullptr);\n+  _tail = nullptr;\n@@ -218,1 +218,1 @@\n-G1DirtyCardQueueSet::PausedBuffers::PausedBuffers() : _plist(NULL) {}\n+G1DirtyCardQueueSet::PausedBuffers::PausedBuffers() : _plist(nullptr) {}\n@@ -222,1 +222,1 @@\n-  assert(Atomic::load(&_plist) == NULL, \"invariant\");\n+  assert(Atomic::load(&_plist) == nullptr, \"invariant\");\n@@ -229,1 +229,1 @@\n-  if (plist == NULL) {\n+  if (plist == nullptr) {\n@@ -232,2 +232,2 @@\n-    PausedList* old_plist = Atomic::cmpxchg(&_plist, (PausedList*)NULL, plist);\n-    if (old_plist != NULL) {\n+    PausedList* old_plist = Atomic::cmpxchg(&_plist, (PausedList*)nullptr, plist);\n+    if (old_plist != nullptr) {\n@@ -251,1 +251,1 @@\n-    if ((previous == NULL) ||   \/\/ Nothing to take.\n+    if ((previous == nullptr) ||   \/\/ Nothing to take.\n@@ -254,1 +254,1 @@\n-        (Atomic::cmpxchg(&_plist, previous, (PausedList*)NULL) != previous)) {\n+        (Atomic::cmpxchg(&_plist, previous, (PausedList*)nullptr) != previous)) {\n@@ -272,2 +272,2 @@\n-  if (plist != NULL) {\n-    Atomic::store(&_plist, (PausedList*)NULL);\n+  if (plist != nullptr) {\n+    Atomic::store(&_plist, (PausedList*)nullptr);\n@@ -282,1 +282,1 @@\n-  assert(node->next() == NULL, \"precondition\");\n+  assert(node->next() == nullptr, \"precondition\");\n@@ -294,2 +294,2 @@\n-  if (paused._head != NULL) {\n-    assert(paused._tail != NULL, \"invariant\");\n+  if (paused._head != nullptr) {\n+    assert(paused._tail != nullptr, \"invariant\");\n@@ -314,1 +314,1 @@\n-  while (buffers_to_delete != NULL) {\n+  while (buffers_to_delete != nullptr) {\n@@ -317,1 +317,1 @@\n-    bn->set_next(NULL);\n+    bn->set_next(nullptr);\n@@ -327,1 +327,1 @@\n-  if (from._head != NULL) {\n+  if (from._head != nullptr) {\n@@ -507,1 +507,1 @@\n-  if (node == NULL) return;     \/\/ Didn't get a buffer to process.\n+  if (node == nullptr) return;     \/\/ Didn't get a buffer to process.\n@@ -526,1 +526,1 @@\n-  if (node == NULL) return false; \/\/ Didn't get a buffer to process.\n+  if (node == nullptr) return false; \/\/ Didn't get a buffer to process.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-    HeadTail() : _head(NULL), _tail(NULL) {}\n+    HeadTail() : _head(nullptr), _tail(nullptr) {}\n@@ -129,1 +129,1 @@\n-    \/\/ a previous safepoint, or might be NULL if the next list hasn't been\n+    \/\/ a previous safepoint, or might be null if the next list hasn't been\n@@ -214,1 +214,1 @@\n-  \/\/ Returns NULL if the queue is empty, or if a concurrent push\/append\n+  \/\/ Returns null if the queue is empty, or if a concurrent push\/append\n@@ -217,1 +217,1 @@\n-  \/\/ Remove and return a completed buffer from the list, or return NULL\n+  \/\/ Remove and return a completed buffer from the list, or return null\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-  _next(NULL),         \/\/ array of \"next\" indices\n+  _next(nullptr),      \/\/ array of \"next\" indices\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FreeIdSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-uintptr_t** G1FromCardCache::_cache = NULL;\n+uintptr_t** G1FromCardCache::_cache = nullptr;\n@@ -43,1 +43,1 @@\n-  guarantee(_cache == NULL, \"Should not call this multiple times\");\n+  guarantee(_cache == nullptr, \"Should not call this multiple times\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FromCardCache.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    assert(p != NULL, \"must be\");\n+    assert(p != nullptr, \"must be\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-  return _current_region != NULL;\n+  return _current_region != nullptr;\n@@ -74,1 +74,1 @@\n-  assert(next != NULL, \"Must return valid region\");\n+  assert(next != nullptr, \"Must return valid region\");\n@@ -96,1 +96,1 @@\n-  assert(_current_region != NULL, \"Must have been initialized\");\n+  assert(_current_region != nullptr, \"Must have been initialized\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-    if (_gc_par_phases[i] != NULL) {\n+    if (_gc_par_phases[i] != nullptr) {\n@@ -206,1 +206,1 @@\n-    assert(_gc_par_phases[phase] == NULL || _gc_par_phases[phase]->get(i) == uninitialized, \"Phase \" #phase \" reported for thread that was not started\");\n+    assert(_gc_par_phases[phase] == nullptr || _gc_par_phases[phase]->get(i) == uninitialized, \"Phase \" #phase \" reported for thread that was not started\");\n@@ -209,1 +209,1 @@\n-  if (_gc_par_phases[phase] == NULL) {\n+  if (_gc_par_phases[phase] == nullptr) {\n@@ -290,1 +290,1 @@\n-  if (_gc_par_phases[phase] == NULL) {\n+  if (_gc_par_phases[phase] == nullptr) {\n@@ -297,1 +297,1 @@\n-  if (_gc_par_phases[phase] == NULL) {\n+  if (_gc_par_phases[phase] == nullptr) {\n@@ -300,1 +300,1 @@\n-  assert(_gc_par_phases[phase]->thread_work_items(index) != NULL, \"No sub count\");\n+  assert(_gc_par_phases[phase]->thread_work_items(index) != nullptr, \"No sub count\");\n@@ -317,1 +317,1 @@\n-    if (work_items != NULL) {\n+    if (work_items != nullptr) {\n@@ -605,1 +605,1 @@\n-  if (_phase_times != NULL) {\n+  if (_phase_times != nullptr) {\n@@ -611,1 +611,1 @@\n-  if (_phase_times != NULL) {\n+  if (_phase_times != nullptr) {\n@@ -632,1 +632,1 @@\n-  if (_phase_times != NULL) {\n+  if (_phase_times != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-      default: ShouldNotReachHere(); return NULL;\n+      default: ShouldNotReachHere(); return nullptr;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionTraceType.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,2 +38,2 @@\n-  _eden_length_per_node(NULL),\n-  _survivor_length_per_node(NULL) {\n+  _eden_length_per_node(nullptr),\n+  _survivor_length_per_node(nullptr) {\n@@ -114,2 +114,2 @@\n-    \/\/ Not NULL only if gc+heap+numa at Debug level is enabled.\n-    if (before_per_node_length != NULL && after_per_node_length != NULL) {\n+    \/\/ Not null only if gc+heap+numa at Debug level is enabled.\n+    if (before_per_node_length != nullptr && after_per_node_length != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapTransition.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-    _g1h(g1h), _root_cl(root_cl), _nm(NULL), _vo(vo), _failures(false) {}\n+    _g1h(g1h), _root_cl(root_cl), _nm(nullptr), _vo(vo), _failures(false) {}\n@@ -147,1 +147,1 @@\n-    if (nm != NULL) {\n+    if (nm != nullptr) {\n@@ -194,1 +194,1 @@\n-    guarantee(obj == NULL || !_g1h->is_obj_dead_cond(obj, _vo),\n+    guarantee(obj == nullptr || !_g1h->is_obj_dead_cond(obj, _vo),\n@@ -213,1 +213,1 @@\n-    assert(o != NULL, \"Huh?\");\n+    assert(o != nullptr, \"Huh?\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,12 +94,12 @@\n-  _eden_space_pool(NULL),\n-  _survivor_space_pool(NULL),\n-  _old_gen_pool(NULL),\n-  _young_collection_counters(NULL),\n-  _full_collection_counters(NULL),\n-  _conc_collection_counters(NULL),\n-  _young_gen_counters(NULL),\n-  _old_gen_counters(NULL),\n-  _old_space_counters(NULL),\n-  _eden_space_counters(NULL),\n-  _from_space_counters(NULL),\n-  _to_space_counters(NULL),\n+  _eden_space_pool(nullptr),\n+  _survivor_space_pool(nullptr),\n+  _old_gen_pool(nullptr),\n+  _young_collection_counters(nullptr),\n+  _full_collection_counters(nullptr),\n+  _conc_collection_counters(nullptr),\n+  _young_gen_counters(nullptr),\n+  _old_gen_counters(nullptr),\n+  _old_space_counters(nullptr),\n+  _eden_space_counters(nullptr),\n+  _from_space_counters(nullptr),\n+  _to_space_counters(nullptr),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonitoringSupport.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-G1NUMA* G1NUMA::_inst = NULL;\n+G1NUMA* G1NUMA::_inst = nullptr;\n@@ -47,1 +47,1 @@\n-  guarantee(_inst == NULL, \"Should be called once.\");\n+  guarantee(_inst == nullptr, \"Should be called once.\");\n@@ -75,3 +75,3 @@\n-  _node_id_to_index_map(NULL), _len_node_id_to_index_map(0),\n-  _node_ids(NULL), _num_active_node_ids(0),\n-  _region_size(0), _page_size(0), _stats(NULL) {\n+  _node_id_to_index_map(nullptr), _len_node_id_to_index_map(0),\n+  _node_ids(nullptr), _num_active_node_ids(0),\n+  _region_size(0), _page_size(0), _stats(nullptr) {\n@@ -235,1 +235,1 @@\n-  if (_stats == NULL) {\n+  if (_stats == nullptr) {\n@@ -253,1 +253,1 @@\n-  if (_stats == NULL) {\n+  if (_stats == nullptr) {\n@@ -261,1 +261,1 @@\n-  if (_stats == NULL) {\n+  if (_stats == nullptr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1NUMA.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-  assert(result != NULL, \"Invariant\");\n+  assert(result != nullptr, \"Invariant\");\n@@ -80,1 +80,1 @@\n-  assert(result != NULL, \"Invariant\");\n+  assert(result != nullptr, \"Invariant\");\n@@ -115,1 +115,1 @@\n-  assert(stat != NULL, \"Invariant\");\n+  assert(stat != nullptr, \"Invariant\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1NUMAStats.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-  _scanned_cld(NULL),\n+  _scanned_cld(nullptr),\n@@ -55,1 +55,1 @@\n-    _closure->set_scanned_cld(NULL);\n+    _closure->set_scanned_cld(nullptr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,1 +151,1 @@\n-  assert(to_rem_set != NULL, \"Need per-region 'into' remsets.\");\n+  assert(to_rem_set != nullptr, \"Need per-region 'into' remsets.\");\n@@ -235,1 +235,1 @@\n-    assert(forwardee != NULL, \"forwardee should not be NULL\");\n+    assert(forwardee != nullptr, \"forwardee should not be null\");\n@@ -260,1 +260,1 @@\n-  if (obj == NULL) {\n+  if (obj == nullptr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-  G1OopStarChunkedList() : _used_memory(0), _roots(NULL), _croots(NULL), _oops(NULL), _coops(NULL) {}\n+  G1OopStarChunkedList() : _used_memory(0), _roots(nullptr), _croots(nullptr), _oops(nullptr), _coops(nullptr) {}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopStarChunkedList.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-  if (list == NULL) {\n+  if (list == nullptr) {\n@@ -68,1 +68,1 @@\n-  while (c != NULL) {\n+  while (c != nullptr) {\n@@ -78,1 +78,1 @@\n-  for (ChunkedList<T*, mtGC>* c = head; c != NULL; c = c->next_used()) {\n+  for (ChunkedList<T*, mtGC>* c = head; c != nullptr; c = c->next_used()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopStarChunkedList.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  _low_boundary(NULL), _high_boundary(NULL), _tail_size(0), _page_size(0),\n+  _low_boundary(nullptr), _high_boundary(nullptr), _tail_size(0), _page_size(0),\n@@ -47,1 +47,1 @@\n-  vmassert(_low_boundary == NULL, \"VirtualSpace already initialized\");\n+  vmassert(_low_boundary == nullptr, \"VirtualSpace already initialized\");\n@@ -79,2 +79,2 @@\n-  _low_boundary           = NULL;\n-  _high_boundary          = NULL;\n+  _low_boundary           = nullptr;\n+  _high_boundary          = nullptr;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PageBasedVirtualSpace.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,1 +114,1 @@\n-  void pretouch(size_t start_page, size_t size_in_pages, WorkerThreads* pretouch_workers = NULL);\n+  void pretouch(size_t start_page, size_t size_in_pages, WorkerThreads* pretouch_workers = nullptr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PageBasedVirtualSpace.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,2 +69,2 @@\n-    _closures(NULL),\n-    _plab_allocator(NULL),\n+    _closures(nullptr),\n+    _plab_allocator(nullptr),\n@@ -79,2 +79,2 @@\n-    _surviving_young_words_base(NULL),\n-    _surviving_young_words(NULL),\n+    _surviving_young_words_base(nullptr),\n+    _surviving_young_words(nullptr),\n@@ -88,1 +88,1 @@\n-    _obj_alloc_stat(NULL),\n+    _obj_alloc_stat(nullptr),\n@@ -151,1 +151,1 @@\n-  assert(task != NULL, \"invariant\");\n+  assert(task != nullptr, \"invariant\");\n@@ -159,1 +159,1 @@\n-  assert(task != NULL, \"invariant\");\n+  assert(task != nullptr, \"invariant\");\n@@ -187,1 +187,1 @@\n-  \/\/ Reference should not be NULL here as such are never pushed to the task queue.\n+  \/\/ Reference should not be null here as such are never pushed to the task queue.\n@@ -349,1 +349,1 @@\n-    if (obj_ptr != NULL) {\n+    if (obj_ptr != nullptr) {\n@@ -361,1 +361,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -399,1 +399,1 @@\n-  HeapWord* obj_ptr = NULL;\n+  HeapWord* obj_ptr = nullptr;\n@@ -407,1 +407,1 @@\n-    if (obj_ptr == NULL) {\n+    if (obj_ptr == nullptr) {\n@@ -414,1 +414,1 @@\n-  if (obj_ptr != NULL) {\n+  if (obj_ptr != nullptr) {\n@@ -466,2 +466,2 @@\n-  \/\/ normally check against NULL once and that's it.\n-  if (obj_ptr == NULL) {\n+  \/\/ normally check against null once and that's it.\n+  if (obj_ptr == nullptr) {\n@@ -469,1 +469,1 @@\n-    if (obj_ptr == NULL) {\n+    if (obj_ptr == nullptr) {\n@@ -476,1 +476,1 @@\n-  assert(obj_ptr != NULL, \"when we get here, allocation should have succeeded\");\n+  assert(obj_ptr != nullptr, \"when we get here, allocation should have succeeded\");\n@@ -497,1 +497,1 @@\n-  if (forward_ptr == NULL) {\n+  if (forward_ptr == nullptr) {\n@@ -566,1 +566,1 @@\n-  if (_states[worker_id] == NULL) {\n+  if (_states[worker_id] == nullptr) {\n@@ -624,1 +624,1 @@\n-  if (forward_ptr == NULL) {\n+  if (forward_ptr == nullptr) {\n@@ -679,1 +679,1 @@\n-  if (_obj_alloc_stat != NULL) {\n+  if (_obj_alloc_stat != nullptr) {\n@@ -686,1 +686,1 @@\n-  if (_obj_alloc_stat != NULL) {\n+  if (_obj_alloc_stat != nullptr) {\n@@ -708,1 +708,1 @@\n-    _states[i] = NULL;\n+    _states[i] = nullptr;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -188,1 +188,1 @@\n-  \/\/ Returns a non-NULL pointer if successful, and updates dest if required.\n+  \/\/ Returns a non-null pointer if successful, and updates dest if required.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -76,2 +76,2 @@\n-  _collection_set(NULL),\n-  _g1h(NULL),\n+  _collection_set(nullptr),\n+  _g1h(nullptr),\n@@ -79,1 +79,1 @@\n-  _phase_times(NULL),\n+  _phase_times(nullptr),\n@@ -520,1 +520,1 @@\n-  if (_phase_times == NULL) {\n+  if (_phase_times == nullptr) {\n@@ -1038,1 +1038,1 @@\n-  if (bytes_to_copy != NULL) {\n+  if (bytes_to_copy != nullptr) {\n@@ -1284,1 +1284,1 @@\n-  if (_collection_set->candidates() == NULL) {\n+  if (_collection_set->candidates() == nullptr) {\n@@ -1376,1 +1376,1 @@\n-  if (candidates == NULL || candidates->is_empty()) {\n+  if (candidates == nullptr || candidates->is_empty()) {\n@@ -1421,1 +1421,1 @@\n-  assert(candidates != NULL, \"Must be\");\n+  assert(candidates != nullptr, \"Must be\");\n@@ -1444,1 +1444,1 @@\n-  while (hr != NULL) {\n+  while (hr != nullptr) {\n@@ -1485,1 +1485,1 @@\n-  if (hr == NULL) {\n+  if (hr == nullptr) {\n@@ -1512,1 +1512,1 @@\n-    assert(r != NULL, \"Region must exist\");\n+    assert(r != nullptr, \"Region must exist\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,1 +157,1 @@\n-  \/\/ bytes_to_copy is non-nullptr.\n+  \/\/ bytes_to_copy is non-null.\n@@ -316,1 +316,1 @@\n-  bool concurrent_operation_is_full_mark(const char* msg = NULL);\n+  bool concurrent_operation_is_full_mark(const char* msg = nullptr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,2 @@\n-  assert(_buffers._head == NULL, \"unflushed qset\");\n-  assert(_buffers._tail == NULL, \"invariant\");\n+  assert(_buffers._head == nullptr, \"unflushed qset\");\n+  assert(_buffers._tail == nullptr, \"invariant\");\n@@ -52,1 +52,1 @@\n-  if (_buffers._tail == NULL) {\n+  if (_buffers._tail == nullptr) {\n@@ -91,1 +91,1 @@\n-  _tail(NULL)\n+  _tail(nullptr)\n@@ -102,1 +102,1 @@\n-  assert(_tail == NULL, \"invariant\");\n+  assert(_tail == nullptr, \"invariant\");\n@@ -115,1 +115,1 @@\n-  _tail = NULL;\n+  _tail = nullptr;\n@@ -123,1 +123,1 @@\n-  \/\/ _list.  If, after that prepend, node's follower is NULL, then node is\n+  \/\/ _list.  If, after that prepend, node's follower is null, then node is\n@@ -125,2 +125,2 @@\n-  if (node->next() == NULL) {\n-    assert(_tail == NULL, \"invariant\");\n+  if (node->next() == nullptr) {\n+    assert(_tail == nullptr, \"invariant\");\n@@ -140,2 +140,2 @@\n-  if (buffers._head != NULL) {\n-    assert(buffers._tail != NULL, \"invariant\");\n+  if (buffers._head != nullptr) {\n+    assert(buffers._tail != nullptr, \"invariant\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RedirtyCardsQueue.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  _listener(NULL),\n+  _listener(nullptr),\n@@ -256,1 +256,1 @@\n-  if (_listener != NULL) {\n+  if (_listener != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-  virtual void commit_regions(uint start_idx, size_t num_regions = 1, WorkerThreads* pretouch_workers = NULL) = 0;\n+  virtual void commit_regions(uint start_idx, size_t num_regions = 1, WorkerThreads* pretouch_workers = nullptr) = 0;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-G1RegionsOnNodes::G1RegionsOnNodes() : _count_per_node(NULL), _numa(G1NUMA::numa()) {\n+G1RegionsOnNodes::G1RegionsOnNodes() : _count_per_node(nullptr), _numa(G1NUMA::numa()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionsOnNodes.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -260,2 +260,2 @@\n-    _collection_set_iter_state(NULL),\n-    _card_table_scan_state(NULL),\n+    _collection_set_iter_state(nullptr),\n+    _card_table_scan_state(nullptr),\n@@ -264,1 +264,1 @@\n-    _region_scan_chunks(NULL),\n+    _region_scan_chunks(nullptr),\n@@ -267,3 +267,3 @@\n-    _all_dirty_regions(NULL),\n-    _next_dirty_regions(NULL),\n-    _scan_top(NULL) {\n+    _all_dirty_regions(nullptr),\n+    _next_dirty_regions(nullptr),\n+    _scan_top(nullptr) {\n@@ -280,1 +280,1 @@\n-    assert(_collection_set_iter_state == NULL, \"Must not be initialized twice\");\n+    assert(_collection_set_iter_state == nullptr, \"Must not be initialized twice\");\n@@ -330,1 +330,1 @@\n-    return (hr != NULL && !hr->in_collection_set() && hr->is_old_or_humongous());\n+    return (hr != nullptr && !hr->in_collection_set() && hr->is_old_or_humongous());\n@@ -371,1 +371,1 @@\n-    _all_dirty_regions = NULL;\n+    _all_dirty_regions = nullptr;\n@@ -374,1 +374,1 @@\n-    _next_dirty_regions = NULL;\n+    _next_dirty_regions = nullptr;\n@@ -455,1 +455,1 @@\n-    set_scan_top(region_idx, NULL);\n+    set_scan_top(region_idx, nullptr);\n@@ -539,1 +539,1 @@\n-    assert(scanned_to != NULL, \"Should be able to scan range\");\n+    assert(scanned_to != nullptr, \"Should be able to scan range\");\n@@ -672,1 +672,1 @@\n-    \/\/ Set the current scan \"finger\" to NULL for every heap region to scan. Since\n+    \/\/ Set the current scan \"finger\" to null for every heap region to scan. Since\n@@ -676,1 +676,1 @@\n-    _scanned_to = NULL;\n+    _scanned_to = nullptr;\n@@ -711,1 +711,1 @@\n-    _scanned_to(NULL),\n+    _scanned_to(nullptr),\n@@ -871,1 +871,1 @@\n-  assert(_scan_state->scan_top(hrm_index) == NULL,\n+  assert(_scan_state->scan_top(hrm_index) == nullptr,\n@@ -883,1 +883,1 @@\n-  \/\/ to NULL (don't scan) in the initialization.\n+  \/\/ to null (don't scan) in the initialization.\n@@ -1447,1 +1447,1 @@\n-  if (r == NULL) {\n+  if (r == nullptr) {\n@@ -1454,1 +1454,1 @@\n-  \/\/ We cannot load the card value before the \"r == NULL\" check, because G1\n+  \/\/ We cannot load the card value before the \"r == nullptr\" check above, because G1\n@@ -1535,1 +1535,1 @@\n-  if (r->oops_on_memregion_seq_iterate_careful<false>(dirty_region, &conc_refine_cl) != NULL) {\n+  if (r->oops_on_memregion_seq_iterate_careful<false>(dirty_region, &conc_refine_cl) != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  assert(_rs_threads_vtimes != NULL, \"just checking\");\n+  assert(_rs_threads_vtimes != nullptr, \"just checking\");\n@@ -64,1 +64,1 @@\n-  assert(_rs_threads_vtimes != NULL, \"just checking\");\n+  assert(_rs_threads_vtimes != nullptr, \"just checking\");\n@@ -85,1 +85,1 @@\n-  assert(other != NULL, \"just checking\");\n+  assert(other != nullptr, \"just checking\");\n@@ -92,1 +92,1 @@\n-  assert(other != NULL, \"just checking\");\n+  assert(other != nullptr, \"just checking\");\n@@ -214,2 +214,2 @@\n-    _max_rs_mem_sz(0), _max_rs_mem_sz_region(NULL),\n-    _max_code_root_mem_sz(0), _max_code_root_mem_sz_region(NULL)\n+    _max_rs_mem_sz(0), _max_rs_mem_sz_region(nullptr),\n+    _max_code_root_mem_sz(0), _max_code_root_mem_sz_region(nullptr)\n@@ -237,1 +237,1 @@\n-    RegionTypeCounter* current = NULL;\n+    RegionTypeCounter* current = nullptr;\n@@ -258,1 +258,1 @@\n-    RegionTypeCounter* counters[] = { &_young, &_humongous, &_free, &_old, NULL };\n+    RegionTypeCounter* counters[] = { &_young, &_humongous, &_free, &_old, nullptr };\n@@ -266,1 +266,1 @@\n-    for (RegionTypeCounter** current = &counters[0]; *current != NULL; current++) {\n+    for (RegionTypeCounter** current = &counters[0]; *current != nullptr; current++) {\n@@ -272,1 +272,1 @@\n-    for (RegionTypeCounter** current = &counters[0]; *current != NULL; current++) {\n+    for (RegionTypeCounter** current = &counters[0]; *current != nullptr; current++) {\n@@ -296,1 +296,1 @@\n-    for (RegionTypeCounter** current = &counters[0]; *current != NULL; current++) {\n+    for (RegionTypeCounter** current = &counters[0]; *current != nullptr; current++) {\n@@ -302,1 +302,1 @@\n-    for (RegionTypeCounter** current = &counters[0]; *current != NULL; current++) {\n+    for (RegionTypeCounter** current = &counters[0]; *current != nullptr; current++) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-  G1EvacuationRootClosures* res = NULL;\n+  G1EvacuationRootClosures* res = nullptr;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RootClosures.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,1 +90,1 @@\n-  CLDClosure* weak_clds()        { return NULL; }\n+  CLDClosure* weak_clds()        { return nullptr; }\n@@ -101,2 +101,2 @@\n-  process_java_roots(&closures, NULL, 0);\n-  process_vm_roots(&closures, NULL, 0);\n+  process_java_roots(&closures, nullptr, 0);\n+  process_vm_roots(&closures, nullptr, 0);\n@@ -126,1 +126,1 @@\n-  \/\/ We don't want to visit code blobs more than once, so we return NULL for the\n+  \/\/ We don't want to visit code blobs more than once, so we return null for the\n@@ -128,1 +128,1 @@\n-  CodeBlobClosure* strong_codeblobs() { return NULL; }\n+  CodeBlobClosure* strong_codeblobs() { return nullptr; }\n@@ -136,2 +136,2 @@\n-  process_java_roots(&closures, NULL, 0);\n-  process_vm_roots(&closures, NULL, 0);\n+  process_java_roots(&closures, nullptr, 0);\n+  process_vm_roots(&closures, nullptr, 0);\n@@ -139,1 +139,1 @@\n-  process_code_cache_roots(blobs, NULL, 0);\n+  process_code_cache_roots(blobs, nullptr, 0);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RootProcessor.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-\/\/ be a NULL pointer.  NULL pointers are pre-filtered and never\n+\/\/ be a null pointer.  null pointers are pre-filtered and never\n@@ -84,1 +84,1 @@\n-  \/\/ Includes rejection of NULL pointers.\n+  \/\/ Includes rejection of null pointers.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SATBMarkQueueSet.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-  guarantee(task->next() == NULL, \"Task already in queue\");\n+  guarantee(task->next() == nullptr, \"Task already in queue\");\n@@ -73,1 +73,1 @@\n-  guarantee(task->next() == NULL, \"Task already in queue\");\n+  guarantee(task->next() == nullptr, \"Task already in queue\");\n@@ -117,1 +117,1 @@\n-  return nullptr;               \/\/ Return nullptr when terminating.\n+  return nullptr;               \/\/ Return null when terminating.\n@@ -157,2 +157,2 @@\n-  _next(NULL),\n-  _service_thread(NULL) { }\n+  _next(nullptr),\n+  _service_thread(nullptr) { }\n@@ -165,1 +165,1 @@\n-  return _service_thread != NULL;\n+  return _service_thread != nullptr;\n@@ -180,1 +180,1 @@\n-  assert(_next == NULL, \"Not allowed to update time while in queue\");\n+  assert(_next == nullptr, \"Not allowed to update time while in queue\");\n@@ -203,1 +203,1 @@\n-  task->set_next(NULL);\n+  task->set_next(nullptr);\n@@ -216,2 +216,2 @@\n-  assert(task != NULL, \"not a valid task\");\n-  assert(task->next() == NULL, \"invariant\");\n+  assert(task != nullptr, \"not a valid task\");\n+  assert(task->next() == nullptr, \"invariant\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,1 +114,1 @@\n-  \/\/ Instead returns nullptr if termination requested.\n+  \/\/ Instead returns null if termination requested.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-  _accum_surv_rate_pred(NULL),\n+  _accum_surv_rate_pred(nullptr),\n@@ -37,1 +37,1 @@\n-  _surv_rate_predictors(NULL),\n+  _surv_rate_predictors(nullptr),\n@@ -60,1 +60,1 @@\n-  guarantee(_surv_rate_predictors[0] != NULL, \"invariant\" );\n+  guarantee(_surv_rate_predictors[0] != nullptr, \"invariant\" );\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SurvRateGroup.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-G1UncommitRegionTask* G1UncommitRegionTask::_instance = NULL;\n+G1UncommitRegionTask* G1UncommitRegionTask::_instance = nullptr;\n@@ -41,1 +41,1 @@\n-  assert(_instance == NULL, \"Already initialized\");\n+  assert(_instance == nullptr, \"Already initialized\");\n@@ -51,1 +51,1 @@\n-  if (_instance == NULL) {\n+  if (_instance == nullptr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1UncommitRegionTask.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,1 +132,1 @@\n-    if (_result != NULL) {\n+    if (_result != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-    _tt(update_young_gc_name(), NULL, GCCause::_no_gc, true) {\n+    _tt(update_young_gc_name(), nullptr, GCCause::_no_gc, true) {\n@@ -796,1 +796,1 @@\n-    assert(obj != NULL, \"the caller should have filtered out NULL values\");\n+    assert(obj != nullptr, \"the caller should have filtered out null values\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -113,3 +113,3 @@\n-  set_next(NULL);\n-  set_prev(NULL);\n-  set_containing_set(NULL);\n+  set_next(nullptr);\n+  set_prev(nullptr);\n+  set_containing_set(nullptr);\n@@ -207,1 +207,1 @@\n-  _humongous_start_region = NULL;\n+  _humongous_start_region = nullptr;\n@@ -220,1 +220,1 @@\n-  _top(NULL),\n+  _top(nullptr),\n@@ -222,2 +222,2 @@\n-  _pre_dummy_top(NULL),\n-  _rem_set(NULL),\n+  _pre_dummy_top(nullptr),\n+  _rem_set(nullptr),\n@@ -226,1 +226,1 @@\n-  _humongous_start_region(NULL),\n+  _humongous_start_region(nullptr),\n@@ -228,1 +228,1 @@\n-  _next(NULL), _prev(NULL),\n+  _next(nullptr), _prev(nullptr),\n@@ -230,1 +230,1 @@\n-  _containing_set(NULL),\n+  _containing_set(nullptr),\n@@ -232,2 +232,2 @@\n-  _top_at_mark_start(NULL),\n-  _parsable_bottom(NULL),\n+  _top_at_mark_start(nullptr),\n+  _parsable_bottom(nullptr),\n@@ -236,1 +236,1 @@\n-  _surv_rate_group(NULL), _age_index(G1SurvRateGroup::InvalidAgeIndex), _gc_efficiency(-1.0),\n+  _surv_rate_group(nullptr), _age_index(G1SurvRateGroup::InvalidAgeIndex), _gc_efficiency(-1.0),\n@@ -357,2 +357,2 @@\n-    nmethod* nm = (cb == NULL) ? NULL : cb->as_compiled_method()->as_nmethod_or_null();\n-    if (nm != NULL) {\n+    nmethod* nm = (cb == nullptr) ? nullptr : cb->as_compiled_method()->as_nmethod_or_null();\n+    if (nm != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -100,2 +100,2 @@\n-  HeapWord* pre_dummy_top() const { return (_pre_dummy_top == NULL) ? top() : _pre_dummy_top; }\n-  void reset_pre_dummy_top() { _pre_dummy_top = NULL; }\n+  HeapWord* pre_dummy_top() const { return (_pre_dummy_top == nullptr) ? top() : _pre_dummy_top; }\n+  void reset_pre_dummy_top() { _pre_dummy_top = nullptr; }\n@@ -131,1 +131,1 @@\n-  \/\/ Returns NULL if not possible, otherwise sets actual_word_size to the amount of\n+  \/\/ Returns null if not possible, otherwise sets actual_word_size to the amount of\n@@ -137,1 +137,1 @@\n-  \/\/ Returns NULL if not possible, otherwise sets actual_word_size to the amount of\n+  \/\/ Returns null if not possible, otherwise sets actual_word_size to the amount of\n@@ -272,1 +272,1 @@\n-  \/\/ Returns the address after the last actually scanned or NULL if the area could\n+  \/\/ Returns the address after the last actually scanned or null if the area could\n@@ -315,2 +315,2 @@\n-    assert(p != NULL, \"p can't be NULL\");\n-    assert(obj != NULL, \"obj can't be NULL\");\n+    assert(p != nullptr, \"p can't be null\");\n+    assert(obj != nullptr, \"obj can't be null\");\n@@ -467,2 +467,2 @@\n-    assert((containing_set != NULL && _containing_set == NULL) ||\n-            containing_set == NULL,\n+    assert((containing_set != nullptr && _containing_set == nullptr) ||\n+            containing_set == nullptr,\n@@ -549,1 +549,1 @@\n-  \/\/ processed, NULL if an unparseable part of the heap was encountered (That should\n+  \/\/ processed, null if an unparseable part of the heap was encountered (That should\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -80,1 +80,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -338,1 +338,1 @@\n-  \/\/ If concurrent and klass_or_null is NULL, then space has been\n+  \/\/ If concurrent and klass_or_null is null, then space has been\n@@ -344,2 +344,2 @@\n-  if (!in_gc_pause && (obj->klass_or_null_acquire() == NULL)) {\n-    return NULL;\n+  if (!in_gc_pause && (obj->klass_or_null_acquire() == nullptr)) {\n+    return nullptr;\n@@ -494,1 +494,1 @@\n-  \/\/ region, the objects in these parts of the heap have non-NULL\n+  \/\/ region, the objects in these parts of the heap have non-null\n@@ -515,1 +515,1 @@\n-  return _surv_rate_group != NULL;\n+  return _surv_rate_group != nullptr;\n@@ -524,1 +524,1 @@\n-  assert(surv_rate_group != NULL, \"pre-condition\");\n+  assert(surv_rate_group != nullptr, \"pre-condition\");\n@@ -537,1 +537,1 @@\n-    _surv_rate_group = NULL;\n+    _surv_rate_group = nullptr;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,2 +65,2 @@\n-  _bot_mapper(NULL),\n-  _cardtable_mapper(NULL),\n+  _bot_mapper(nullptr),\n+  _cardtable_mapper(nullptr),\n@@ -69,2 +69,2 @@\n-  _regions(), _heap_mapper(NULL),\n-  _bitmap_mapper(NULL),\n+  _regions(), _heap_mapper(nullptr),\n+  _bitmap_mapper(nullptr),\n@@ -93,1 +93,1 @@\n-  HeapRegion* hr = NULL;\n+  HeapRegion* hr = nullptr;\n@@ -102,1 +102,1 @@\n-  if (hr == NULL) {\n+  if (hr == nullptr) {\n@@ -108,2 +108,2 @@\n-  if (hr != NULL) {\n-    assert(hr->next() == NULL, \"Single region should not have next\");\n+  if (hr != nullptr) {\n+    assert(hr->next() == nullptr, \"Single region should not have next\");\n@@ -123,1 +123,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -131,1 +131,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -167,1 +167,1 @@\n-    if (hr == NULL) {\n+    if (hr == nullptr) {\n@@ -201,1 +201,1 @@\n-      assert(hr != NULL, \"Region should still be present\");\n+      assert(hr != nullptr, \"Region should still be present\");\n@@ -419,1 +419,1 @@\n-  expand_exact(expand_candidate, 1, NULL);\n+  expand_exact(expand_candidate, 1, nullptr);\n@@ -490,1 +490,1 @@\n-  guarantee(r != NULL, \"Start region must be a valid region\");\n+  guarantee(r != nullptr, \"Start region must be a valid region\");\n@@ -498,1 +498,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -508,1 +508,1 @@\n-    guarantee(at(i) != NULL, \"Tried to access region %u that has a NULL HeapRegion*\", i);\n+    guarantee(at(i) != nullptr, \"Tried to access region %u that has a null HeapRegion*\", i);\n@@ -538,1 +538,1 @@\n-    if (hr == NULL || !is_available(curr)) {\n+    if (hr == nullptr || !is_available(curr)) {\n@@ -540,1 +540,1 @@\n-      expand_exact(curr, 1, NULL);\n+      expand_exact(curr, 1, nullptr);\n@@ -650,1 +650,1 @@\n-  guarantee(res_idx != NULL, \"checking\");\n+  guarantee(res_idx != nullptr, \"checking\");\n@@ -698,1 +698,1 @@\n-    guarantee(hr != NULL, \"invariant: i: %u\", i);\n+    guarantee(hr != nullptr, \"invariant: i: %u\", i);\n@@ -714,1 +714,1 @@\n-    guarantee(_regions.get_by_index(i) == NULL, \"invariant i: %u\", i);\n+    guarantee(_regions.get_by_index(i) == nullptr, \"invariant i: %u\", i);\n@@ -728,1 +728,1 @@\n-    _n_workers(n_workers), _n_regions(G1CollectedHeap::heap()->_hrm._allocated_heapregions_length), _claims(NULL) {\n+    _n_workers(n_workers), _n_regions(G1CollectedHeap::heap()->_hrm._allocated_heapregions_length), _claims(nullptr) {\n@@ -801,1 +801,1 @@\n-      if (region != NULL && region->is_free()) {\n+      if (region != nullptr && region->is_free()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionManager.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-  virtual HeapRegion* default_value() const { return NULL; }\n+  virtual HeapRegion* default_value() const { return nullptr; }\n@@ -91,1 +91,1 @@\n-  void commit_regions(uint index, size_t num_regions = 1, WorkerThreads* pretouch_workers = NULL);\n+  void commit_regions(uint index, size_t num_regions = 1, WorkerThreads* pretouch_workers = nullptr);\n@@ -128,1 +128,1 @@\n-  void expand(uint index, uint num_regions, WorkerThreads* pretouch_workers = NULL);\n+  void expand(uint index, uint num_regions, WorkerThreads* pretouch_workers = nullptr);\n@@ -177,1 +177,1 @@\n-  \/\/ Return the HeapRegion at the given index, NULL if the index\n+  \/\/ Return the HeapRegion at the given index, null if the index\n@@ -189,1 +189,1 @@\n-  \/\/ HeapRegion, otherwise return NULL.\n+  \/\/ HeapRegion, otherwise return null.\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionManager.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-  assert(hr != NULL, \"sanity\");\n+  assert(hr != nullptr, \"sanity\");\n@@ -56,1 +56,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -59,1 +59,1 @@\n-  assert(hr != NULL, \"All available regions must have a HeapRegion but index %u has not.\", index);\n+  assert(hr != nullptr, \"All available regions must have a HeapRegion but index %u has not.\", index);\n@@ -72,1 +72,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionManager.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-  assert(nm != NULL, \"sanity\");\n+  assert(nm != nullptr, \"sanity\");\n@@ -116,1 +116,1 @@\n-  assert(nm != NULL, \"sanity\");\n+  assert(nm != nullptr, \"sanity\");\n@@ -130,1 +130,1 @@\n-  assert(nm != NULL, \"sanity\");\n+  assert(nm != nullptr, \"sanity\");\n@@ -133,1 +133,1 @@\n-  MutexLocker ml(CodeCache_lock->owned_by_self() ? NULL : &_m, Mutex::_no_safepoint_check_flag);\n+  MutexLocker ml(CodeCache_lock->owned_by_self() ? nullptr : &_m, Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  assert(_checker == NULL || _checker->is_correct_type(hr), \"Wrong type of region %u (%s) and set %s\",\n+  assert(_checker == nullptr || _checker->is_correct_type(hr), \"Wrong type of region %u (%s) and set %s\",\n@@ -103,1 +103,1 @@\n-  while (curr != NULL) {\n+  while (curr != nullptr) {\n@@ -107,3 +107,3 @@\n-    curr->set_next(NULL);\n-    curr->set_prev(NULL);\n-    curr->set_containing_set(NULL);\n+    curr->set_next(nullptr);\n+    curr->set_prev(nullptr);\n+    curr->set_containing_set(nullptr);\n@@ -130,1 +130,1 @@\n-  if (_node_info != NULL && from_list->_node_info != NULL) {\n+  if (_node_info != nullptr && from_list->_node_info != nullptr) {\n@@ -139,3 +139,3 @@\n-    \/\/ from NULL to non-NULL or vice versa to catch bugs. So, we have\n-    \/\/ to NULL it first before setting it to the value.\n-    hr->set_containing_set(NULL);\n+    \/\/ from null to non-null or vice versa to catch bugs. So, we have\n+    \/\/ to null it first before setting it to the value.\n+    hr->set_containing_set(nullptr);\n@@ -164,1 +164,1 @@\n-    assert_free_region_list(length() == 0 && _tail == NULL, \"invariant\");\n+    assert_free_region_list(length() == 0 && _tail == nullptr, \"invariant\");\n@@ -188,1 +188,1 @@\n-    assert_free_region_list(length() == 0 && _tail == NULL, \"invariant\");\n+    assert_free_region_list(length() == 0 && _tail == nullptr, \"invariant\");\n@@ -195,2 +195,2 @@\n-    while (curr_from != NULL) {\n-      while (curr_to != NULL && curr_to->hrm_index() < curr_from->hrm_index()) {\n+    while (curr_from != nullptr) {\n+      while (curr_to != nullptr && curr_to->hrm_index() < curr_from->hrm_index()) {\n@@ -200,1 +200,1 @@\n-      if (curr_to == NULL) {\n+      if (curr_to == nullptr) {\n@@ -204,1 +204,1 @@\n-        curr_from = NULL;\n+        curr_from = nullptr;\n@@ -210,1 +210,1 @@\n-        if (curr_to->prev() == NULL) {\n+        if (curr_to->prev() == nullptr) {\n@@ -232,1 +232,1 @@\n-  if (next != NULL) {\n+  if (next != nullptr) {\n@@ -239,1 +239,1 @@\n-  if (prev == NULL) {\n+  if (prev == nullptr) {\n@@ -271,1 +271,1 @@\n-      _last = NULL;\n+      _last = nullptr;\n@@ -274,2 +274,2 @@\n-    curr->set_next(NULL);\n-    curr->set_prev(NULL);\n+    curr->set_next(nullptr);\n+    curr->set_prev(nullptr);\n@@ -285,1 +285,1 @@\n-  if (prev == NULL) {\n+  if (prev == nullptr) {\n@@ -290,1 +290,1 @@\n-  if (next == NULL) {\n+  if (next == nullptr) {\n@@ -322,3 +322,3 @@\n-  _head = NULL;\n-  _tail = NULL;\n-  _last = NULL;\n+  _head = nullptr;\n+  _tail = nullptr;\n+  _last = nullptr;\n@@ -326,1 +326,1 @@\n-  if (_node_info!= NULL) {\n+  if (_node_info!= nullptr) {\n@@ -333,2 +333,2 @@\n-  HeapRegion* prev1 = NULL;\n-  HeapRegion* prev0 = NULL;\n+  HeapRegion* prev1 = nullptr;\n+  HeapRegion* prev0 = nullptr;\n@@ -339,2 +339,2 @@\n-  guarantee(_head == NULL || _head->prev() == NULL, \"_head should not have a prev\");\n-  while (curr != NULL) {\n+  guarantee(_head == nullptr || _head->prev() == nullptr, \"_head should not have a prev\");\n+  while (curr != nullptr) {\n@@ -348,1 +348,1 @@\n-    if (curr->next() != NULL) {\n+    if (curr->next() != nullptr) {\n@@ -362,1 +362,1 @@\n-  guarantee(_tail == NULL || _tail->next() == NULL, \"_tail should not have a next\");\n+  guarantee(_tail == nullptr || _tail->next() == nullptr, \"_tail should not have a next\");\n@@ -369,1 +369,1 @@\n-  _node_info(G1NUMA::numa()->is_enabled() ? new NodeInfo() : NULL) {\n+  _node_info(G1NUMA::numa()->is_enabled() ? new NodeInfo() : nullptr) {\n@@ -375,1 +375,1 @@\n-  if (_node_info != NULL) {\n+  if (_node_info != nullptr) {\n@@ -380,1 +380,1 @@\n-FreeRegionList::NodeInfo::NodeInfo() : _numa(G1NUMA::numa()), _length_of_node(NULL),\n+FreeRegionList::NodeInfo::NodeInfo() : _numa(G1NUMA::numa()), _length_of_node(nullptr),\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionSet.cpp","additions":36,"deletions":36,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-    if (_checker != NULL) {\n+    if (_checker != nullptr) {\n@@ -193,1 +193,1 @@\n-  FreeRegionList(const char* name, HeapRegionSetChecker* checker = NULL);\n+  FreeRegionList(const char* name, HeapRegionSetChecker* checker = nullptr);\n@@ -252,1 +252,1 @@\n-    return _curr != NULL;\n+    return _curr != nullptr;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionSet.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,3 +34,3 @@\n-  assert_heap_region_set(hr->containing_set() == NULL, \"should not already have a containing set\");\n-  assert_heap_region_set(hr->next() == NULL, \"should not already be linked\");\n-  assert_heap_region_set(hr->prev() == NULL, \"should not already be linked\");\n+  assert_heap_region_set(hr->containing_set() == nullptr, \"should not already have a containing set\");\n+  assert_heap_region_set(hr->next() == nullptr, \"should not already be linked\");\n+  assert_heap_region_set(hr->prev() == nullptr, \"should not already be linked\");\n@@ -46,2 +46,2 @@\n-  assert_heap_region_set(hr->next() == NULL, \"should already be unlinked\");\n-  assert_heap_region_set(hr->prev() == NULL, \"should already be unlinked\");\n+  assert_heap_region_set(hr->next() == nullptr, \"should already be unlinked\");\n+  assert_heap_region_set(hr->prev() == nullptr, \"should already be unlinked\");\n@@ -49,1 +49,1 @@\n-  hr->set_containing_set(NULL);\n+  hr->set_containing_set(nullptr);\n@@ -55,2 +55,2 @@\n-  assert_free_region_list((length() == 0 && _head == NULL && _tail == NULL && _last == NULL) ||\n-                          (length() >  0 && _head != NULL && _tail != NULL && _tail->hrm_index() < region_to_add->hrm_index()),\n+  assert_free_region_list((length() == 0 && _head == nullptr && _tail == nullptr && _last == nullptr) ||\n+                          (length() >  0 && _head != nullptr && _tail != nullptr && _tail->hrm_index() < region_to_add->hrm_index()),\n@@ -61,2 +61,2 @@\n-  if (_head != NULL) {\n-    \/\/ Link into list, next is already NULL, no need to set.\n+  if (_head != nullptr) {\n+    \/\/ Link into list, next is already null, no need to set.\n@@ -75,2 +75,2 @@\n-  assert_free_region_list((length() == 0 && _head == NULL && _tail == NULL && _last == NULL) ||\n-                          (length() >  0 && _head != NULL && _tail != NULL),\n+  assert_free_region_list((length() == 0 && _head == nullptr && _tail == nullptr && _last == nullptr) ||\n+                          (length() >  0 && _head != nullptr && _tail != nullptr),\n@@ -82,1 +82,1 @@\n-  if (_head != NULL) {\n+  if (_head != nullptr) {\n@@ -85,1 +85,1 @@\n-    if (_last != NULL && _last->hrm_index() < hr->hrm_index()) {\n+    if (_last != nullptr && _last->hrm_index() < hr->hrm_index()) {\n@@ -92,1 +92,1 @@\n-    while (curr != NULL && curr->hrm_index() < hr->hrm_index()) {\n+    while (curr != nullptr && curr->hrm_index() < hr->hrm_index()) {\n@@ -98,1 +98,1 @@\n-    if (curr == NULL) {\n+    if (curr == nullptr) {\n@@ -103,1 +103,1 @@\n-    } else if (curr->prev() == NULL) {\n+    } else if (curr->prev() == nullptr) {\n@@ -105,1 +105,1 @@\n-      hr->set_prev(NULL);\n+      hr->set_prev(nullptr);\n@@ -126,2 +126,2 @@\n-  if (_head == NULL) {\n-    _tail = NULL;\n+  if (_head == nullptr) {\n+    _tail = nullptr;\n@@ -129,1 +129,1 @@\n-    _head->set_prev(NULL);\n+    _head->set_prev(nullptr);\n@@ -131,1 +131,1 @@\n-  result->set_next(NULL);\n+  result->set_next(nullptr);\n@@ -139,2 +139,2 @@\n-  if (_tail == NULL) {\n-    _head = NULL;\n+  if (_tail == nullptr) {\n+    _head = nullptr;\n@@ -142,1 +142,1 @@\n-    _tail->set_next(NULL);\n+    _tail->set_next(nullptr);\n@@ -144,1 +144,1 @@\n-  result->set_prev(NULL);\n+  result->set_prev(nullptr);\n@@ -153,1 +153,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -155,1 +155,1 @@\n-  assert_free_region_list(length() > 0 && _head != NULL && _tail != NULL, \"invariant\");\n+  assert_free_region_list(length() > 0 && _head != nullptr && _tail != nullptr, \"invariant\");\n@@ -166,1 +166,1 @@\n-    _last = NULL;\n+    _last = nullptr;\n@@ -188,1 +188,1 @@\n-         cur != NULL && cur_depth < max_search_depth;\n+         cur != nullptr && cur_depth < max_search_depth;\n@@ -196,1 +196,1 @@\n-         cur != NULL && cur_depth < max_search_depth;\n+         cur != nullptr && cur_depth < max_search_depth;\n@@ -205,2 +205,2 @@\n-  if (cur == NULL || cur_depth >= max_search_depth) {\n-    return NULL;\n+  if (cur == nullptr || cur_depth >= max_search_depth) {\n+    return nullptr;\n@@ -212,1 +212,1 @@\n-  if (prev == NULL) {\n+  if (prev == nullptr) {\n@@ -217,1 +217,1 @@\n-  if (next == NULL) {\n+  if (next == nullptr) {\n@@ -222,2 +222,2 @@\n-  cur->set_prev(NULL);\n-  cur->set_next(NULL);\n+  cur->set_prev(nullptr);\n+  cur->set_next(nullptr);\n@@ -226,1 +226,1 @@\n-    _last = NULL;\n+    _last = nullptr;\n@@ -255,1 +255,1 @@\n-  if (_node_info != NULL) {\n+  if (_node_info != nullptr) {\n@@ -261,1 +261,1 @@\n-  if (_node_info != NULL) {\n+  if (_node_info != nullptr) {\n@@ -267,1 +267,1 @@\n-  if (_node_info != NULL) {\n+  if (_node_info != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionSet.inline.hpp","additions":42,"deletions":42,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-      return NULL; \/\/ keep some compilers happy\n+      return nullptr; \/\/ keep some compilers happy\n@@ -74,1 +74,1 @@\n-      return NULL; \/\/ keep some compilers happy\n+      return nullptr; \/\/ keep some compilers happy\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionType.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}