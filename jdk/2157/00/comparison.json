{"files":[{"patch":"@@ -29,0 +29,1 @@\n+#include \"asm\/assembler.hpp\"\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"assembler_ppc.hpp\"\n@@ -496,0 +497,5 @@\n+\n+\/\/ HAVE_FUNCTION_DESCRIPTORS\n+void* os::resolve_function_descriptor_to_code_pointer(void* p) {\n+  return ((const FunctionDescriptor*)p)->entry();\n+}\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,3 +35,6 @@\n-#define PLATFORM_PRINT_NATIVE_STACK 1\n-static bool platform_print_native_stack(outputStream* st, void* context,\n-                                        char *buf, int buf_size);\n+  #define PLATFORM_PRINT_NATIVE_STACK 1\n+  static bool platform_print_native_stack(outputStream* st, void* context,\n+                                          char *buf, int buf_size);\n+\n+  #define HAVE_FUNCTION_DESCRIPTORS 1\n+  static void* resolve_function_descriptor_to_code_pointer(void* p);\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"assembler_ppc.hpp\"\n@@ -501,0 +502,5 @@\n+\n+\/\/ HAVE_FUNCTION_DESCRIPTORS\n+void* os::resolve_function_descriptor_to_code_pointer(void* p) {\n+  return ((const FunctionDescriptor*)p)->entry();\n+}\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+  #define HAVE_FUNCTION_DESCRIPTORS 1\n+  static void* resolve_function_descriptor_to_code_pointer(void* p);\n+\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -900,2 +900,18 @@\n-  const bool have_function_name = dll_address_to_function_name(addr, p, buflen,\n-                                                               &offset, demangle);\n+  bool have_function_name = dll_address_to_function_name(addr, p, buflen,\n+                                                         &offset, demangle);\n+  bool is_function_descriptor = false;\n+#ifdef HAVE_FUNCTION_DESCRIPTORS\n+  \/\/ When we deal with a function descriptor instead of a real code pointer, try to\n+  \/\/ resolve it. There is a small chance that a random pointer given to this function\n+  \/\/ may just happen to look like a valid descriptor, but this is rare and worth the\n+  \/\/ risk to see resolved function names. But we will print a little suffix to mark\n+  \/\/ this as a function descriptor for the reader (see below).\n+  if (!have_function_name && os::is_readable_pointer(addr)) {\n+    address addr2 = (address)os::resolve_function_descriptor_to_code_pointer(addr);\n+    if (have_function_name = is_function_descriptor =\n+        dll_address_to_function_name(addr2, p, buflen, &offset, demangle)) {\n+      addr = addr2;\n+    }\n+  }\n+#endif \/\/ HANDLE_FUNCTION_DESCRIPTORS\n+\n@@ -936,0 +952,6 @@\n+\n+  \/\/ Write a trailing marker if this was a function descriptor\n+  if (have_function_name && is_function_descriptor) {\n+    st->print_raw(\" (FD)\");\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"}]}