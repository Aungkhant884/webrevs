{"files":[{"patch":"@@ -72,91 +72,0 @@\n-    private static long getRandomBetween(long start, long end) throws Exception {\n-        if (start > end) {\n-            throw new IllegalArgumentException(\"start must be less than end\");\n-        }\n-        Random aRandom = Utils.getRandomInstance();\n-        int d = aRandom.nextInt((int)(end - start));\n-        if (d < 1) {\n-            d = 1;\n-        }\n-        return start + d;\n-    }\n-\n-    public static void modifyJsaContentRandomly(File jsaFile) throws Exception {\n-        \/\/ corrupt random area in the data areas\n-        long[] used = new long[num_regions]; \/\/ record used bytes\n-        long start0, start, end, offset;\n-        int bufSize;\n-\n-        System.out.printf(\"%-24s%12s%12s%16s\\n\", \"Space Name\", \"Used bytes\", \"Reg Start\", \"Random Offset\");\n-        start0 = CDSArchiveUtils.fileHeaderSize();\n-        for (int i = 0; i < num_regions; i++) {\n-            used[i] = CDSArchiveUtils.usedRegionSizeAligned(jsaFile, i);\n-            start = start0;\n-            for (int j = 0; j < i; j++) {\n-                start += CDSArchiveUtils.alignUpWithPageSize(used[j]);\n-            }\n-            end = start + used[i];\n-            if (start == end) {\n-                continue; \/\/ Ignore empty regions\n-            }\n-            offset = getRandomBetween(start, end);\n-            System.out.printf(\"%-24s%12d%12d%16d\\n\", shared_region_name[i], used[i], start, offset);\n-            if (end - offset < 1024) {\n-                bufSize = (int)(end - offset + 1);\n-            } else {\n-                bufSize = 1024;\n-            }\n-            CDSArchiveUtils.writeData(jsaFile, offset, new byte[bufSize]);\n-        }\n-    }\n-\n-    public static boolean modifyJsaContent(int region, File jsaFile) throws Exception {\n-        byte[] buf = new byte[4096];\n-\n-        long total = 0L;\n-        long[] used = new long[num_regions];\n-        System.out.printf(\"%-24s%12s\\n\", \"Space name\", \"Used bytes\");\n-        for (int i = 0; i < num_regions; i++) {\n-            used[i] = CDSArchiveUtils.usedRegionSizeAligned(jsaFile, i);\n-            System.out.printf(\"%-24s%12d\\n\", shared_region_name[i], used[i]);\n-            total += used[i];\n-        }\n-        System.out.printf(\"%-24s%12d\\n\", \"Total: \", total);\n-        long regionStartOffset = CDSArchiveUtils.fileHeaderSize();\n-        for (int i = 0; i < region; i++) {\n-            regionStartOffset += used[i];\n-        }\n-        if (used[region] == 0) {\n-            System.out.println(\"Region \" + shared_region_name[region] + \" is empty. Nothing to corrupt.\");\n-            return false;\n-        }\n-        System.out.println(\"Corrupt \" + shared_region_name[region] + \" section, start = \" + regionStartOffset\n-                           + \" (header_size + 0x\" + Long.toHexString(regionStartOffset - CDSArchiveUtils.fileHeaderSize()) + \")\");\n-        long bytesWritten = 0L;\n-        while (bytesWritten < used[region]) {\n-            CDSArchiveUtils.writeData(jsaFile, regionStartOffset + bytesWritten, buf);\n-            bytesWritten += 4096;\n-        }\n-\n-        return true;\n-    }\n-\n-    public static void modifyJsaHeader(File jsaFile) throws Exception {\n-        \/\/ screw up header info\n-        byte[] buf = new byte[CDSArchiveUtils.fileHeaderSize()];\n-        System.out.println(\"CDSArchiveUtils.fileHeaderSize = \" + CDSArchiveUtils.fileHeaderSize());\n-        CDSArchiveUtils.writeData(jsaFile, 0, buf);\n-    }\n-\n-    public static void modifyJvmIdent(File jsaFile) throws Exception {\n-        System.out.println(\"    offset_jvm_ident \" + CDSArchiveUtils.offsetJvmIdent);\n-        byte[] buf = new String(\"Bad JDK 1.0001\").getBytes();\n-        CDSArchiveUtils.writeData(jsaFile, (long)CDSArchiveUtils.offsetJvmIdent, buf);\n-    }\n-\n-    public static void modifyHeaderIntField(File jsaFile, long offset, int value) throws Exception {\n-        System.out.println(\"    offset \" + offset);\n-        byte[] buf = { (byte)(value >> 24), (byte)(value >> 16), (byte)(value >> 8), (byte)(value)};\n-        CDSArchiveUtils.writeData(jsaFile, offset, buf);\n-    }\n-\n@@ -171,12 +80,0 @@\n-    \/\/ Copy file with bytes deleted or inserted\n-    \/\/ delete or insert number of bytes into\/from archive\n-    public static void insertOrDeleteBytes(File orgJsaFile, boolean del) throws Exception {\n-        File newJsaFile = new File(startNewArchive(del ? \"delete-bytes\" : \"insert-bytes\"));\n-        int n = (int)getRandomBetween(0, 1024);\n-        if (del) {\n-            CDSArchiveUtils.deleteBytesAtOffset(orgJsaFile, newJsaFile, CDSArchiveUtils.fileHeaderSize(), n);\n-        } else {\n-            CDSArchiveUtils.insertBytesAtOffset(orgJsaFile, newJsaFile, CDSArchiveUtils.fileHeaderSize(), new byte[n]);\n-        }\n-    }\n-\n@@ -204,1 +101,1 @@\n-    \/\/   7) randomly corrupt data in each region specified by shared_region_name[]\n+    \/\/   7) randomly corrupt data in each region in shared_region_name[]\n@@ -213,2 +110,1 @@\n-        WhiteBox box = WhiteBox.getWhiteBox();\n-        CDSArchiveUtils.initialize(box);  \/\/ all offsets available\n+        CDSArchiveUtils.initialize();  \/\/ all offsets available\n@@ -246,1 +142,1 @@\n-        modifyJsaHeader(copiedJsa);\n+        CDSArchiveUtils.modifyFileHeader(copiedJsa);\n@@ -259,1 +155,1 @@\n-        modifyJvmIdent(copiedJsa);\n+        CDSArchiveUtils.modifyJvmIdent(copiedJsa, \"My non-exist jdk 1.000001\");\n@@ -269,3 +165,3 @@\n-        String modHeadIntField = startNewArchive(\"modify-magic\");\n-        copiedJsa = CDSArchiveUtils.copyArchiveFile(orgJsaFile, modHeadIntField);\n-        modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetMagic, 0x00000000);\n+        String modMagic = startNewArchive(\"modify-magic\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(orgJsaFile, modMagic);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetMagic, -1);\n@@ -281,3 +177,3 @@\n-        modHeadIntField = startNewArchive(\"modify-version\");\n-        copiedJsa = CDSArchiveUtils.copyArchiveFile(orgJsaFile, modHeadIntField);\n-        modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion, 0x00000000);\n+        String modVersion = startNewArchive(\"modify-version\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(orgJsaFile, modVersion);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion, 0x00000000);\n@@ -296,1 +192,1 @@\n-            if (modifyJsaContent(i, copiedJsa)) {\n+            if (CDSArchiveUtils.modifyRegionContent(i, copiedJsa)) {\n@@ -305,2 +201,2 @@\n-        modifyJsaHeader(copiedJsa);\n-        modifyJsaContent(0, copiedJsa);  \/\/ this will not be reached since failed on header change first\n+        CDSArchiveUtils.modifyFileHeader(copiedJsa);\n+        CDSArchiveUtils.modifyRegionContent(0, copiedJsa);  \/\/ this will not be reached since failed on header change first\n@@ -316,1 +212,2 @@\n-        insertOrDeleteBytes(orgJsaFile, true);\n+        String insertBytes = startNewArchive(\"insert-bytes\");\n+        CDSArchiveUtils.insertBytesRandomlyAfterHeader(orgJsaFile, insertBytes, new byte[4096]);\n@@ -321,1 +218,2 @@\n-        insertOrDeleteBytes(orgJsaFile, false);\n+        String deleteBytes = startNewArchive(\"delete-bytes\");\n+        CDSArchiveUtils.deleteBytesAtRandomPositionAfterHeader(orgJsaFile, deleteBytes, 4096 \/*bytes*\/);\n@@ -327,1 +225,1 @@\n-        modifyJsaContentRandomly(copiedJsa);\n+        CDSArchiveUtils.modifyRegionContentRandomly(copiedJsa);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/SharedArchiveConsistency.java","additions":18,"deletions":120,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import jdk.test.lib.Utils;\n+import java.util.Random;\n@@ -43,1 +43,1 @@\n-import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.Utils;\n@@ -48,2 +48,0 @@\n-    \/\/ wb must be assigned first to use the functions\n-    public static WhiteBox wb;\n@@ -54,1 +52,1 @@\n-    private static int fileHeaderSize = -1;  \/\/ total size of header, aligned with pageSize\n+    public static int fileHeaderSize;        \/\/ total size of header, aligned with alignment\n@@ -60,1 +58,0 @@\n-    public static int pageSize;              \/\/ page size\n@@ -63,2 +60,14 @@\n-    public static void initialize(WhiteBox box) throws Exception {\n-        wb = box;\n+    \/\/ The following should be consistent with the enum in the C++ MetaspaceShared class\n+    public static String[] shared_region_name = {\n+        \"rw\",          \/\/ ReadWrite\n+        \"ro\",          \/\/ ReadOnly\n+        \"bm\",          \/\/ relocation bitmaps\n+        \"first_closed_archive\",\n+        \"last_closed_archive\",\n+        \"first_open_archive\",\n+        \"last_open_archive\"\n+    };\n+    public static int num_regions = shared_region_name.length;\n+\n+    public static void initialize() throws Exception {\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n@@ -81,1 +90,0 @@\n-        pageSize = wb.getVMPageSize();\n@@ -83,17 +91,3 @@\n-        \/\/ fileHeaderSize may not be available\n-        \/\/ fileHeaderSize = (int)alignUpWithPageSize(wb.getOffsetForName(\"file_header_size\"));\n-    }\n-\n-    public static int fileHeaderSize() throws Exception {\n-        if (fileHeaderSize > 0) {\n-            return fileHeaderSize;\n-        }\n-\n-        \/\/ this is not real header size, it is struct size\n-        intSize = wb.getOffsetForName(\"int_size\");\n-        fileHeaderSize = wb.getOffsetForName(\"file_header_size\");\n-        fileHeaderSize = (int)alignUpWithPageSize(fileHeaderSize);\n-        if (fileHeaderSize <= 0 ) {\n-            throw new RuntimeException(\"file_header_size is not available\");\n-        }\n-        return fileHeaderSize;\n+        \/\/ file_header_size is structure size, real size aligned with alignment\n+        \/\/ so must be after alignment available\n+        fileHeaderSize = (int)alignUpWithAlignment(wb.getOffsetForName(\"file_header_size\"));\n@@ -102,5 +96,1 @@\n-    public static long alignUpWithPageSize(long l) {\n-        return (l + pageSize - 1) & (~ (pageSize - 1));\n-    }\n-\n-    public static long alignUpWithAlignment(long l) {\n+    private static long alignUpWithAlignment(long l) {\n@@ -110,4 +100,0 @@\n-    public static int offsetByName(String name) throws Exception {\n-        return wb.getOffsetForName(name);\n-    }\n-\n@@ -127,0 +113,116 @@\n+    public static long getRandomBetween(long start, long end) throws Exception {\n+        if (start > end) {\n+            throw new IllegalArgumentException(\"start must be less than end\");\n+        }\n+        Random aRandom = Utils.getRandomInstance();\n+        int d = aRandom.nextInt((int)(end - start));\n+        if (d < 1) {\n+            d = 1;\n+        }\n+        return start + d;\n+    }\n+\n+    public static void modifyContentRandomly(File jsaFile) throws Exception {\n+        \/\/ corrupt random area in the data areas\n+        long[] used = new long[num_regions]; \/\/ record used bytes\n+        long start0, start, end, offset;\n+        int bufSize;\n+\n+        System.out.printf(\"%-24s%12s%12s%16s\\n\", \"Space Name\", \"Used bytes\", \"Reg Start\", \"Random Offset\");\n+        start0 = fileHeaderSize;\n+        for (int i = 0; i < num_regions; i++) {\n+            used[i] = usedRegionSizeAligned(jsaFile, i);\n+            start = start0;\n+            for (int j = 0; j < i; j++) {\n+                start += alignUpWithAlignment(used[j]);\n+            }\n+            end = start + used[i];\n+            if (start == end) {\n+                continue; \/\/ Ignore empty regions\n+            }\n+            offset = getRandomBetween(start, end);\n+            System.out.printf(\"%-24s%12d%12d%16d\\n\", shared_region_name[i], used[i], start, offset);\n+            if (end - offset < 1024) {\n+                bufSize = (int)(end - offset + 1);\n+            } else {\n+                bufSize = 1024;\n+            }\n+            writeData(jsaFile, offset, new byte[bufSize]);\n+        }\n+    }\n+\n+    public static void modifyRegionContentRandomly(File jsaFile) throws Exception {\n+        \/\/ corrupt random area in the data areas\n+        long[] used = new long[num_regions]; \/\/ record used bytes\n+        long start0, start, end, offset;\n+        int bufSize;\n+\n+        System.out.printf(\"%-24s%12s%12s%16s\\n\", \"Space Name\", \"Used bytes\", \"Reg Start\", \"Random Offset\");\n+        start0 = fileHeaderSize;\n+        for (int i = 0; i < num_regions; i++) {\n+            used[i] = usedRegionSizeAligned(jsaFile, i);\n+            start = start0;\n+            for (int j = 0; j < i; j++) {\n+                start += alignUpWithAlignment(used[j]);\n+            }\n+            end = start + used[i];\n+            if (start == end) {\n+                continue; \/\/ Ignore empty regions\n+            }\n+            offset = getRandomBetween(start, end);\n+            System.out.printf(\"%-24s%12d%12d%16d\\n\", shared_region_name[i], used[i], start, offset);\n+            if (end - offset < 1024) {\n+                bufSize = (int)(end - offset + 1);\n+            } else {\n+                bufSize = 1024;\n+            }\n+            writeData(jsaFile, offset, new byte[bufSize]);\n+        }\n+    }\n+\n+    public static boolean modifyRegionContent(int region, File jsaFile) throws Exception {\n+        long total = 0L;\n+        long[] used = new long[num_regions];\n+        System.out.printf(\"%-24s%12s\\n\", \"Space name\", \"Used bytes\");\n+        for (int i = 0; i < num_regions; i++) {\n+            used[i] = usedRegionSizeAligned(jsaFile, i);\n+            System.out.printf(\"%-24s%12d\\n\", shared_region_name[i], used[i]);\n+            total += used[i];\n+        }\n+        if (used[region] == 0) {\n+            System.out.println(\"Region \" + shared_region_name[region] + \" is empty. Nothing to corrupt.\");\n+            return false;\n+        }\n+        byte[] buf = new byte[4096];\n+        System.out.printf(\"%-24s%12d\\n\", \"Total: \", total);\n+        long regionStartOffset = fileHeaderSize;\n+        for (int i = 0; i < region; i++) {\n+            regionStartOffset += used[i];\n+        }\n+        System.out.println(\"Corrupt \" + shared_region_name[region] + \" section, start = \" + regionStartOffset\n+                           + \" (header_size + 0x\" + Long.toHexString(regionStartOffset - fileHeaderSize) + \")\");\n+        long bytesWritten = 0L;\n+        while (bytesWritten < used[region]) {\n+            bytesWritten += writeData(jsaFile, regionStartOffset + bytesWritten, buf);\n+        }\n+        return true;\n+    }\n+\n+    public static void modifyFileHeader(File jsaFile) throws Exception {\n+        \/\/ screw up header info\n+        byte[] buf = new byte[fileHeaderSize];\n+        writeData(jsaFile, 0, buf);\n+    }\n+\n+    public static void modifyJvmIdent(File jsaFile, String newJvmIdent) throws Exception {\n+        byte[] buf = newJvmIdent.getBytes();\n+        writeData(jsaFile, (long)offsetJvmIdent, buf);\n+    }\n+\n+    public static void modifyHeaderIntField(File jsaFile, long offset, int value) throws Exception {\n+        System.out.println(\"    offset \" + offset);\n+\n+        byte[] bytes = ByteBuffer.allocate(4).putInt(value).array();\n+        writeData(jsaFile, offset, bytes);\n+    }\n+\n@@ -160,1 +262,1 @@\n-    private static void writeData(FileChannel fc, long offset, ByteBuffer bb) throws Exception {\n+    private static long writeData(FileChannel fc, long offset, ByteBuffer bb) throws Exception {\n@@ -162,1 +264,1 @@\n-        fc.write(bb);\n+        return fc.write(bb);\n@@ -165,1 +267,1 @@\n-    public static void writeData(File file, long offset, byte[] array) throws Exception {\n+    public static long writeData(File file, long offset, byte[] array) throws Exception {\n@@ -168,1 +270,1 @@\n-            writeData(fc, offset, bbuf);\n+            return writeData(fc, offset, bbuf);\n@@ -172,9 +274,0 @@\n-    public static File modifyByOffsetName(File archiveFile, String offsetName, byte[] replace) throws Exception {\n-        int offset = offsetByName(offsetName);\n-        try (FileChannel fc = getFileChannel(archiveFile)) {\n-            ByteBuffer bbuf = ByteBuffer.wrap(replace);\n-            writeData(fc, offset, bbuf);\n-        }\n-        return archiveFile;\n-    }\n-\n@@ -182,1 +275,3 @@\n-    public static File insertBytesAtOffset(File orgFile, File dstFile, long offset, byte[] bytes) throws Exception {\n+    public static File insertBytesRandomlyAfterHeader(File orgFile, String newFileName, byte[] bytes) throws Exception {\n+        long offset = fileHeaderSize + getRandomBetween(0L, 4096L);\n+        File dstFile = new File(newFileName);\n@@ -194,1 +289,3 @@\n-    public static File deleteBytesAtOffset(File orgFile, File dstFile, long offset, int nBytes) throws Exception {\n+    public static File deleteBytesAtRandomPositionAfterHeader(File orgFile, String newFileName, int nBytes) throws Exception {\n+        long offset = fileHeaderSize + getRandomBetween(0L, 4096L);\n+        File dstFile = new File(newFileName);\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSArchiveUtils.java","additions":147,"deletions":50,"binary":false,"changes":197,"status":"modified"}]}