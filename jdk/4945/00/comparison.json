{"files":[{"patch":"@@ -37,0 +37,1 @@\n+import jdk.test.lib.cds.CDSArchiveUtils;\n@@ -40,2 +41,0 @@\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n@@ -43,13 +42,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-import java.nio.channels.FileChannel;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n-import java.nio.file.StandardOpenOption;\n-import static java.nio.file.StandardOpenOption.READ;\n-import static java.nio.file.StandardOpenOption.WRITE;\n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.List;\n@@ -60,13 +46,0 @@\n-    public static WhiteBox wb;\n-    public static int offset_magic;     \/\/ CDSFileMapHeaderBase::_magic\n-    public static int offset_version;   \/\/ CDSFileMapHeaderBase::_version\n-    public static int offset_jvm_ident; \/\/ FileMapHeader::_jvm_ident\n-    public static int sp_offset_crc;    \/\/ CDSFileMapRegion::_crc\n-    public static int file_header_size = -1;\/\/ total size of header, variant, need calculation\n-    public static int CDSFileMapRegion_size; \/\/ size of CDSFileMapRegion\n-    public static int sp_offset;       \/\/ offset of CDSFileMapRegion\n-    public static int sp_used_offset;  \/\/ offset of CDSFileMapRegion::_used\n-    public static int size_t_size;     \/\/ size of size_t\n-    public static int int_size;        \/\/ size of int\n-    public static long alignment;      \/\/ MetaspaceShared::core_region_alignment\n-\n@@ -92,0 +65,2 @@\n+        \"The shared archive file has a bad magic number\",\n+        \"Unable to map shared spaces\",\n@@ -97,40 +72,0 @@\n-    public static void getFileOffsetInfo() throws Exception {\n-        wb = WhiteBox.getWhiteBox();\n-        offset_magic = wb.getOffsetForName(\"FileMapHeader::_magic\");\n-        offset_version = wb.getOffsetForName(\"FileMapHeader::_version\");\n-        offset_jvm_ident = wb.getOffsetForName(\"FileMapHeader::_jvm_ident\");\n-        sp_offset_crc = wb.getOffsetForName(\"CDSFileMapRegion::_crc\");\n-        try {\n-            int nonExistOffset = wb.getOffsetForName(\"FileMapHeader::_non_exist_offset\");\n-            System.exit(-1); \/\/ should fail\n-        } catch (Exception e) {\n-            \/\/ success\n-        }\n-\n-        sp_offset = wb.getOffsetForName(\"FileMapHeader::_space[0]\") - offset_magic;\n-        sp_used_offset = wb.getOffsetForName(\"CDSFileMapRegion::_used\") - sp_offset_crc;\n-        size_t_size = wb.getOffsetForName(\"size_t_size\");\n-        CDSFileMapRegion_size  = wb.getOffsetForName(\"CDSFileMapRegion_size\");\n-        alignment = wb.metaspaceSharedRegionAlignment();\n-    }\n-\n-    public static int getFileHeaderSize(FileChannel fc) throws Exception {\n-        if (file_header_size != -1) {\n-            return file_header_size;\n-        }\n-        \/\/ this is not real header size, it is struct size\n-        int_size = wb.getOffsetForName(\"int_size\");\n-        file_header_size = wb.getOffsetForName(\"file_header_size\");\n-        System.out.println(\"file_header_size      = \" + file_header_size);\n-        file_header_size = (int)align_up_page(file_header_size);\n-        System.out.println(\"file_header_size (aligned to page) = \" + file_header_size);\n-        return file_header_size;\n-    }\n-\n-    public static long align_up_page(long l) throws Exception {\n-        \/\/ wb is obtained in getFileOffsetInfo() which is called first in main() else we should call\n-        \/\/ WhiteBox.getWhiteBox() here first.\n-        int pageSize = wb.getVMPageSize();\n-        return (l + pageSize -1) & (~ (pageSize - 1));\n-    }\n-\n@@ -149,20 +84,0 @@\n-    public static long readInt(FileChannel fc, long offset, int nbytes) throws Exception {\n-        ByteBuffer bb = ByteBuffer.allocate(nbytes);\n-        bb.order(ByteOrder.nativeOrder());\n-        fc.position(offset);\n-        fc.read(bb);\n-        return  (nbytes > 4 ? bb.getLong(0) : bb.getInt(0));\n-    }\n-\n-    public static void writeData(FileChannel fc, long offset, ByteBuffer bb) throws Exception {\n-        fc.position(offset);\n-        fc.write(bb);\n-    }\n-\n-    public static FileChannel getFileChannel(File jsaFile) throws Exception {\n-        List<StandardOpenOption> arry = new ArrayList<StandardOpenOption>();\n-        arry.add(READ);\n-        arry.add(WRITE);\n-        return FileChannel.open(jsaFile.toPath(), new HashSet<StandardOpenOption>(arry));\n-    }\n-\n@@ -170,1 +85,0 @@\n-        FileChannel fc = getFileChannel(jsaFile);\n@@ -172,4 +86,2 @@\n-        long[] used    = new long[num_regions];       \/\/ record used bytes\n-        long start0, start, end, off;\n-        int used_offset, path_info_size;\n-\n+        long[] used = new long[num_regions]; \/\/ record used bytes\n+        long start0, start, end, offset;\n@@ -177,0 +89,1 @@\n+\n@@ -178,1 +91,1 @@\n-        start0 = getFileHeaderSize(fc);\n+        start0 = CDSArchiveUtils.fileHeaderSize();\n@@ -180,1 +93,1 @@\n-            used[i] = get_region_used_size_aligned(fc, i);\n+            used[i] = CDSArchiveUtils.usedRegionSizeAligned(jsaFile, i);\n@@ -183,1 +96,1 @@\n-                start += align_up_page(used[j]);\n+                start += CDSArchiveUtils.alignUpWithPageSize(used[j]);\n@@ -189,4 +102,4 @@\n-            off = getRandomBetween(start, end);\n-            System.out.printf(\"%-24s%12d%12d%16d\\n\", shared_region_name[i], used[i], start, off);\n-            if (end - off < 1024) {\n-                bufSize = (int)(end - off + 1);\n+            offset = getRandomBetween(start, end);\n+            System.out.printf(\"%-24s%12d%12d%16d\\n\", shared_region_name[i], used[i], start, offset);\n+            if (end - offset < 1024) {\n+                bufSize = (int)(end - offset + 1);\n@@ -196,5 +109,1 @@\n-            ByteBuffer bbuf = ByteBuffer.wrap(new byte[bufSize]);\n-            writeData(fc, off, bbuf);\n-        }\n-        if (fc.isOpen()) {\n-            fc.close();\n+            CDSArchiveUtils.writeData(jsaFile, offset, new byte[bufSize]);\n@@ -204,7 +113,0 @@\n-    static long get_region_used_size_aligned(FileChannel fc, int region) throws Exception {\n-        long n = sp_offset + CDSFileMapRegion_size * region + sp_used_offset;\n-        long used = readInt(fc, n, size_t_size);\n-        used = (used + alignment - 1) & ~(alignment - 1);\n-        return used;\n-    }\n-\n@@ -212,1 +114,0 @@\n-        FileChannel fc = getFileChannel(jsaFile);\n@@ -214,1 +115,0 @@\n-        ByteBuffer bbuf = ByteBuffer.wrap(buf);\n@@ -220,1 +120,1 @@\n-            used[i] = get_region_used_size_aligned(fc, i);\n+            used[i] = CDSArchiveUtils.usedRegionSizeAligned(jsaFile, i);\n@@ -225,4 +125,3 @@\n-        long header_size = getFileHeaderSize(fc);\n-        long region_start_offset = header_size;\n-        for (int i=0; i<region; i++) {\n-            region_start_offset += used[i];\n+        long regionStartOffset = CDSArchiveUtils.fileHeaderSize();\n+        for (int i = 0; i < region; i++) {\n+            regionStartOffset += used[i];\n@@ -234,10 +133,6 @@\n-        System.out.println(\"Corrupt \" + shared_region_name[region] + \" section, start = \" + region_start_offset\n-                           + \" (header_size + 0x\" + Long.toHexString(region_start_offset-header_size) + \")\");\n-        long bytes_written = 0L;\n-        while (bytes_written < used[region]) {\n-            writeData(fc, region_start_offset + bytes_written, bbuf);\n-            bbuf.clear();\n-            bytes_written += 4096;\n-        }\n-        if (fc.isOpen()) {\n-            fc.close();\n+        System.out.println(\"Corrupt \" + shared_region_name[region] + \" section, start = \" + regionStartOffset\n+                           + \" (header_size + 0x\" + Long.toHexString(regionStartOffset - CDSArchiveUtils.fileHeaderSize()) + \")\");\n+        long bytesWritten = 0L;\n+        while (bytesWritten < used[region]) {\n+            CDSArchiveUtils.writeData(jsaFile, regionStartOffset + bytesWritten, buf);\n+            bytesWritten += 4096;\n@@ -245,0 +140,1 @@\n+\n@@ -249,1 +145,0 @@\n-        FileChannel fc = getFileChannel(jsaFile);\n@@ -251,6 +146,3 @@\n-        byte[] buf = new byte[getFileHeaderSize(fc)];\n-        ByteBuffer bbuf = ByteBuffer.wrap(buf);\n-        writeData(fc, 0L, bbuf);\n-        if (fc.isOpen()) {\n-            fc.close();\n-        }\n+        byte[] buf = new byte[CDSArchiveUtils.fileHeaderSize()];\n+        System.out.println(\"CDSArchiveUtils.fileHeaderSize = \" + CDSArchiveUtils.fileHeaderSize());\n+        CDSArchiveUtils.writeData(jsaFile, 0, buf);\n@@ -260,9 +152,3 @@\n-        FileChannel fc = getFileChannel(jsaFile);\n-        int headerSize = getFileHeaderSize(fc);\n-        System.out.println(\"    offset_jvm_ident \" + offset_jvm_ident);\n-        byte[] buf = new byte[256];\n-        ByteBuffer bbuf = ByteBuffer.wrap(buf);\n-        writeData(fc, (long)offset_jvm_ident, bbuf);\n-        if (fc.isOpen()) {\n-            fc.close();\n-        }\n+        System.out.println(\"    offset_jvm_ident \" + CDSArchiveUtils.offsetJvmIdent);\n+        byte[] buf = new String(\"Bad JDK 1.0001\").getBytes();\n+        CDSArchiveUtils.writeData(jsaFile, (long)CDSArchiveUtils.offsetJvmIdent, buf);\n@@ -272,2 +158,0 @@\n-        FileChannel fc = getFileChannel(jsaFile);\n-        int headerSize = getFileHeaderSize(fc);\n@@ -275,6 +159,2 @@\n-        byte[] buf = ByteBuffer.allocate(4).putInt(value).array();\n-        ByteBuffer bbuf = ByteBuffer.wrap(buf);\n-        writeData(fc, offset, bbuf);\n-        if (fc.isOpen()) {\n-            fc.close();\n-        }\n+        byte[] buf = { (byte)(value >> 24), (byte)(value >> 16), (byte)(value >> 8), (byte)(value)};\n+        CDSArchiveUtils.writeData(jsaFile, offset, buf);\n@@ -284,1 +164,1 @@\n-    public static String startNewTestArchive(String testName) {\n+    public static String startNewArchive(String testName) {\n@@ -291,16 +171,0 @@\n-    public static File copyFile(File orgJsaFile, String testName) throws Exception {\n-        File newJsaFile = new File(startNewTestArchive(testName));\n-        if (newJsaFile.exists()) {\n-            if (!newJsaFile.delete()) {\n-                throw new IOException(\"Could not delete file \" + newJsaFile);\n-            }\n-        }\n-        Files.copy(orgJsaFile.toPath(), newJsaFile.toPath(), REPLACE_EXISTING);\n-\n-        \/\/ orgJsaFile is read only, and Files.copy passes on this attribute to newJsaFile.\n-        \/\/ Since we need to modify newJsaFile later, let's set it to r\/w\n-        setReadWritePermission(newJsaFile);\n-\n-        return newJsaFile;\n-    }\n-\n@@ -308,36 +172,8 @@\n-    \/\/ del -- true, deleted, false, inserted\n-    public static File insertOrDeleteBytes(File orgJsaFile, boolean del) throws Exception {\n-        File newJsaFile = new File(startNewTestArchive(del ? \"delete-bytes\" : \"insert-bytes\"));\n-        try (\n-            FileChannel inputChannel = new FileInputStream(orgJsaFile).getChannel();\n-            FileChannel outputChannel = new FileOutputStream(newJsaFile).getChannel()\n-        ) {\n-            long size = inputChannel.size();\n-            int init_size = getFileHeaderSize(inputChannel);\n-            outputChannel.transferFrom(inputChannel, 0, init_size);\n-            int n = (int)getRandomBetween(0, 1024);\n-            if (del) {\n-                System.out.println(\"Delete \" + n + \" bytes at data start section\");\n-                inputChannel.position(init_size + n);\n-                outputChannel.transferFrom(inputChannel, init_size, size - init_size - n);\n-            } else {\n-                System.out.println(\"Insert \" + n + \" bytes at data start section\");\n-                outputChannel.position(init_size);\n-                outputChannel.write(ByteBuffer.wrap(new byte[n]));\n-                outputChannel.transferFrom(inputChannel, init_size + n , size - init_size);\n-            }\n-        }\n-\n-        return newJsaFile;\n-    }\n-\n-    public static void setReadWritePermission(File file) throws Exception {\n-        if (!file.canRead()) {\n-            if (!file.setReadable(true)) {\n-                throw new IOException(\"Cannot modify file \" + file + \" as readable\");\n-            }\n-        }\n-        if (!file.canWrite()) {\n-            if (!file.setWritable(true)) {\n-                throw new IOException(\"Cannot modify file \" + file + \" as writable\");\n-            }\n+    \/\/ delete or insert number of bytes into\/from archive\n+    public static void insertOrDeleteBytes(File orgJsaFile, boolean del) throws Exception {\n+        File newJsaFile = new File(startNewArchive(del ? \"delete-bytes\" : \"insert-bytes\"));\n+        int n = (int)getRandomBetween(0, 1024);\n+        if (del) {\n+            CDSArchiveUtils.deleteBytesAtOffset(orgJsaFile, newJsaFile, CDSArchiveUtils.fileHeaderSize(), n);\n+        } else {\n+            CDSArchiveUtils.insertBytesAtOffset(orgJsaFile, newJsaFile, CDSArchiveUtils.fileHeaderSize(), new byte[n]);\n@@ -377,7 +213,2 @@\n-\n-        \/\/ must call to get offset info first!!!\n-        getFileOffsetInfo();\n-        Path currentRelativePath = Paths.get(\"\");\n-        String currentDir = currentRelativePath.toAbsolutePath().toString();\n-        System.out.println(\"Current relative path is: \" + currentDir);\n-        \/\/ get jar file\n+        WhiteBox box = WhiteBox.getWhiteBox();\n+        CDSArchiveUtils.initialize(box);  \/\/ all offsets available\n@@ -412,0 +243,2 @@\n+        String modifyHeader = startNewArchive(\"modify-header\");\n+        File copiedJsa = CDSArchiveUtils.copyArchiveFile(orgJsaFile, modifyHeader);\n@@ -413,1 +246,1 @@\n-        modifyJsaHeader(copyFile(orgJsaFile, \"corrupt-header\"));\n+        modifyJsaHeader(copiedJsa);\n@@ -423,1 +256,4 @@\n-        modifyJvmIdent(copyFile(orgJsaFile, \"modify-jvm-ident\"));\n+\n+        String modJvmIdent = startNewArchive(\"modify-jvm-ident\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(orgJsaFile, modJvmIdent);\n+        modifyJvmIdent(copiedJsa);\n@@ -433,1 +269,3 @@\n-        modifyHeaderIntField(copyFile(orgJsaFile, \"modify-magic\"), offset_magic, 0x00000000);\n+        String modHeadIntField = startNewArchive(\"modify-magic\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(orgJsaFile, modHeadIntField);\n+        modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetMagic, 0x00000000);\n@@ -443,1 +281,3 @@\n-        modifyHeaderIntField(copyFile(orgJsaFile, \"modify-version\"), offset_version, 0x00000000);\n+        modHeadIntField = startNewArchive(\"modify-version\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(orgJsaFile, modHeadIntField);\n+        modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion, 0x00000000);\n@@ -454,2 +294,3 @@\n-            File newJsaFile = copyFile(orgJsaFile, (shared_region_name[i]));\n-            if (modifyJsaContent(i, newJsaFile)) {\n+            String newArchiveName = startNewArchive(shared_region_name[i]);\n+            copiedJsa  = CDSArchiveUtils.copyArchiveFile(orgJsaFile, newArchiveName);\n+            if (modifyJsaContent(i, copiedJsa)) {\n@@ -462,3 +303,4 @@\n-        File newJsaFile = copyFile(orgJsaFile, \"header-and-content\");\n-        modifyJsaHeader(newJsaFile);\n-        modifyJsaContent(0, newJsaFile);  \/\/ this will not be reached since failed on header change first\n+        String headerAndContent = startNewArchive(\"header-and-content\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(orgJsaFile, headerAndContent);\n+        modifyJsaHeader(copiedJsa);\n+        modifyJsaContent(0, copiedJsa);  \/\/ this will not be reached since failed on header change first\n@@ -483,1 +325,3 @@\n-        modifyJsaContentRandomly(copyFile(orgJsaFile, \"random-areas\"));\n+        String randomAreas = startNewArchive(\"random-areas\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(orgJsaFile, randomAreas);\n+        modifyJsaContentRandomly(copiedJsa);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/SharedArchiveConsistency.java","additions":67,"deletions":223,"binary":false,"changes":290,"status":"modified"},{"patch":"@@ -0,0 +1,211 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.test.lib.cds;\n+\n+import java.io.IOException;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import jdk.test.lib.Utils;\n+\n+import java.nio.file.Files;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+import java.nio.file.StandardOpenOption;\n+import static java.nio.file.StandardOpenOption.READ;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+\n+import jdk.test.lib.cds.CDSTestUtils;\n+import sun.hotspot.WhiteBox;\n+\n+\/\/ This class performs operations on shared archive file\n+public class CDSArchiveUtils {\n+    \/\/ wb must be assigned first to use the functions\n+    public static WhiteBox wb;\n+    public static int offsetMagic;           \/\/ CDSFileMapHeaderBase::_magic\n+    public static int offsetVersion;         \/\/ CDSFileMapHeaderBase::_version\n+    public static int offsetJvmIdent;        \/\/ FileMapHeader::_jvm_ident\n+    public static int spOffsetCrc;           \/\/ CDSFileMapRegion::_crc\n+    private static int fileHeaderSize = -1;  \/\/ total size of header, aligned with pageSize\n+    public static int cdsFileMapRegionSize;  \/\/ size of CDSFileMapRegion\n+    public static int spOffset;              \/\/ offset of CDSFileMapRegion\n+    public static int spUsedOffset;          \/\/ offset of CDSFileMapRegion::_used\n+    public static int sizetSize;             \/\/ size of size_t\n+    public static int intSize;               \/\/ size of int\n+    public static int pageSize;              \/\/ page size\n+    public static long alignment;            \/\/ MetaspaceShared::core_region_alignment\n+\n+    public static void initialize(WhiteBox box) throws Exception {\n+        wb = box;\n+        offsetMagic = wb.getOffsetForName(\"FileMapHeader::_magic\");\n+        offsetVersion = wb.getOffsetForName(\"FileMapHeader::_version\");\n+        offsetJvmIdent = wb.getOffsetForName(\"FileMapHeader::_jvm_ident\");\n+        spOffsetCrc = wb.getOffsetForName(\"CDSFileMapRegion::_crc\");\n+        try {\n+            int nonExistOffset = wb.getOffsetForName(\"FileMapHeader::_non_exist_offset\");\n+            System.exit(-1); \/\/ should fail\n+        } catch (Exception e) {\n+            \/\/ success\n+        }\n+\n+        spOffset = wb.getOffsetForName(\"FileMapHeader::_space[0]\") - offsetMagic;\n+        spUsedOffset = wb.getOffsetForName(\"CDSFileMapRegion::_used\") - spOffsetCrc;\n+        sizetSize = wb.getOffsetForName(\"size_t_size\");\n+        intSize = wb.getOffsetForName(\"int_size\");\n+        cdsFileMapRegionSize  = wb.getOffsetForName(\"CDSFileMapRegion_size\");\n+        pageSize = wb.getVMPageSize();\n+        alignment = wb.metaspaceSharedRegionAlignment();\n+        \/\/ fileHeaderSize may not be available\n+        \/\/ fileHeaderSize = (int)alignUpWithPageSize(wb.getOffsetForName(\"file_header_size\"));\n+    }\n+\n+    public static int fileHeaderSize() throws Exception {\n+        if (fileHeaderSize > 0) {\n+            return fileHeaderSize;\n+        }\n+\n+        \/\/ this is not real header size, it is struct size\n+        intSize = wb.getOffsetForName(\"int_size\");\n+        fileHeaderSize = wb.getOffsetForName(\"file_header_size\");\n+        fileHeaderSize = (int)alignUpWithPageSize(fileHeaderSize);\n+        if (fileHeaderSize <= 0 ) {\n+            throw new RuntimeException(\"file_header_size is not available\");\n+        }\n+        return fileHeaderSize;\n+    }\n+\n+    public static long alignUpWithPageSize(long l) {\n+        return (l + pageSize - 1) & (~ (pageSize - 1));\n+    }\n+\n+    public static long alignUpWithAlignment(long l) {\n+        return (l + alignment - 1) & (~ (alignment - 1));\n+    }\n+\n+    public static int offsetByName(String name) throws Exception {\n+        return wb.getOffsetForName(name);\n+    }\n+\n+    private static void setReadWritePermission(File file) throws Exception {\n+        if (!file.canRead()) {\n+            if (!file.setReadable(true)) {\n+                throw new IOException(\"Cannot modify file \" + file + \" as readable\");\n+            }\n+        }\n+        if (!file.canWrite()) {\n+            if (!file.setWritable(true)) {\n+                throw new IOException(\"Cannot modify file \" + file + \" as writable\");\n+            }\n+        }\n+    }\n+\n+    \/\/ copy archive and set copied read\/write permit\n+    public static File copyArchiveFile(File orgJsaFile, String newName) throws Exception {\n+        File newJsaFile = new File(newName);\n+        if (newJsaFile.exists()) {\n+            if (!newJsaFile.delete()) {\n+                throw new IOException(\"Could not delete file \" + newJsaFile);\n+            }\n+        }\n+        Files.copy(orgJsaFile.toPath(), newJsaFile.toPath(), REPLACE_EXISTING);\n+\n+        \/\/ change permission\n+        setReadWritePermission(newJsaFile);\n+\n+        return newJsaFile;\n+    }\n+\n+    private static FileChannel getFileChannel(File file) throws Exception {\n+        List<StandardOpenOption> arry = new ArrayList<StandardOpenOption>();\n+        arry.add(READ);\n+        arry.add(WRITE);\n+        return FileChannel.open(file.toPath(), new HashSet<StandardOpenOption>(arry));\n+    }\n+\n+    public static long readInt(File file, long offset, int nBytes) throws Exception {\n+        try (FileChannel fc = getFileChannel(file)) {\n+            ByteBuffer bb = ByteBuffer.allocate(nBytes);\n+            bb.order(ByteOrder.nativeOrder());\n+            fc.position(offset);\n+            fc.read(bb);\n+            return  (nBytes > 4 ? bb.getLong(0) : bb.getInt(0));\n+        }\n+    }\n+\n+    private static void writeData(FileChannel fc, long offset, ByteBuffer bb) throws Exception {\n+        fc.position(offset);\n+        fc.write(bb);\n+    }\n+\n+    public static void writeData(File file, long offset, byte[] array) throws Exception {\n+        try (FileChannel fc = getFileChannel(file)) {\n+            ByteBuffer bbuf = ByteBuffer.wrap(array);\n+            writeData(fc, offset, bbuf);\n+         }\n+    }\n+\n+    public static File modifyByOffsetName(File archiveFile, String offsetName, byte[] replace) throws Exception {\n+        int offset = offsetByName(offsetName);\n+        try (FileChannel fc = getFileChannel(archiveFile)) {\n+            ByteBuffer bbuf = ByteBuffer.wrap(replace);\n+            writeData(fc, offset, bbuf);\n+        }\n+        return archiveFile;\n+    }\n+\n+    \/\/ dstFile will keep original size so will remove corresponding bytes.length bytes at end of file\n+    public static File insertBytesAtOffset(File orgFile, File dstFile, long offset, byte[] bytes) throws Exception {\n+        try (FileChannel inputChannel = new FileInputStream(orgFile).getChannel();\n+             FileChannel outputChannel = new FileOutputStream(dstFile).getChannel()) {\n+            long orgSize = inputChannel.size();\n+            outputChannel.transferFrom(inputChannel, 0, offset);\n+            outputChannel.write(ByteBuffer.wrap(bytes));\n+            outputChannel.transferFrom(inputChannel, offset + bytes.length, orgSize - bytes.length);\n+        }\n+        return dstFile;\n+    }\n+\n+    \/\/ delete nBytes bytes from offset, so new file will be smaller than the original\n+    public static File deleteBytesAtOffset(File orgFile, File dstFile, long offset, int nBytes) throws Exception {\n+        try (FileChannel inputChannel = new FileInputStream(orgFile).getChannel();\n+             FileChannel outputChannel = new FileOutputStream(dstFile).getChannel()) {\n+            long orgSize = inputChannel.size();\n+            outputChannel.transferFrom(inputChannel, 0, offset);\n+            inputChannel.position(offset + nBytes);\n+            outputChannel.transferFrom(inputChannel, offset, orgSize - nBytes);\n+        }\n+        return dstFile;\n+    }\n+\n+    \/\/ used region size\n+    public static long usedRegionSizeAligned(File archiveFile, int region) throws Exception {\n+        long offset = spOffset + cdsFileMapRegionSize * region + spUsedOffset;\n+        long used = readInt(archiveFile, offset, sizetSize);\n+        return alignUpWithAlignment(used);\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSArchiveUtils.java","additions":211,"deletions":0,"binary":false,"changes":211,"status":"added"}]}