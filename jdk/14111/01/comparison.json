{"files":[{"patch":"@@ -1145,11 +1145,9 @@\n-        if (TieredCompilation) {\n-          \/\/ If there is an old version we're done with it\n-          CompiledMethod* old = method->code();\n-          if (TraceMethodReplacement && old != nullptr) {\n-            ResourceMark rm;\n-            char *method_name = method->name_and_sig_as_C_string();\n-            tty->print_cr(\"Replacing method %s\", method_name);\n-          }\n-          if (old != nullptr) {\n-            old->make_not_used();\n-          }\n+        \/\/ If there is an old version we're done with it\n+        CompiledMethod* old = method->code();\n+        if (TraceMethodReplacement && old != nullptr) {\n+          ResourceMark rm;\n+          char *method_name = method->name_and_sig_as_C_string();\n+          tty->print_cr(\"Replacing method %s\", method_name);\n+        }\n+        if (old != nullptr) {\n+          old->make_not_used();\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"compiler\/compilerDirectives.hpp\"\n@@ -1359,0 +1360,36 @@\n+void CodeCache::mark_directives_matches() {\n+  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+  Thread *thread = Thread::current();\n+  HandleMark hm(thread);\n+\n+  CompiledMethodIterator iter(CompiledMethodIterator::only_not_unloading);\n+  while(iter.next()) {\n+    CompiledMethod* nm = iter.method();\n+    methodHandle mh(thread, nm->method());\n+    if (DirectivesStack::hasMatchingDirectives(mh)) {\n+      ResourceMark rm;\n+      log_trace(codecache)(\"Mark because of matching directives %s\", mh->external_name());\n+      mh->set_has_matching_directives();\n+    }\n+  }\n+}\n+\n+void CodeCache::recompile_marked_directives_matches() {\n+  Thread *thread = Thread::current();\n+  HandleMark hm(thread);\n+\n+  RelaxedCompiledMethodIterator iter(RelaxedCompiledMethodIterator::only_not_unloading);\n+  while(iter.next()) {\n+    CompiledMethod* nm = iter.method();\n+    methodHandle mh(thread, nm->method());\n+    if (mh->has_matching_directives()) {\n+      ResourceMark rm;\n+      log_trace(codecache)(\"Recompile because of matching directives %s\", mh->external_name());\n+      mh->clear_method_flags();\n+      CompileBroker::compile_method(mh, InvocationEntryBci, CompLevel::CompLevel_full_optimization,\n+                                      methodHandle(), 0, CompileTask::Reason_DirectivesChanged, (JavaThread *)thread);\n+      gc_on_allocation(); \/\/ Flush unused methods from CodeCache if required\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -312,0 +312,3 @@\n+  static void mark_directives_matches();\n+  static void recompile_marked_directives_matches();\n+\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1160,5 +1160,7 @@\n-  \/\/ A request has been made for compilation.  Before we do any\n-  \/\/ real work, check to see if the method has been compiled\n-  \/\/ in the meantime with a definitive result.\n-  if (compilation_is_complete(method, osr_bci, comp_level)) {\n-    return;\n+  if (compile_reason != CompileTask::Reason_DirectivesChanged) {\n+    \/\/ A request has been made for compilation.  Before we do any\n+    \/\/ real work, check to see if the method has been compiled\n+    \/\/ in the meantime with a definitive result.\n+    if (compilation_is_complete(method, osr_bci, comp_level)) {\n+      return;\n+    }\n@@ -1209,5 +1211,7 @@\n-    \/\/ We need to check again to see if the compilation has\n-    \/\/ completed.  A previous compilation may have registered\n-    \/\/ some result.\n-    if (compilation_is_complete(method, osr_bci, comp_level)) {\n-      return;\n+    if (compile_reason != CompileTask::Reason_DirectivesChanged) {\n+      \/\/ We need to check again to see if the compilation has\n+      \/\/ completed.  A previous compilation may have registered\n+      \/\/ some result.\n+      if (compilation_is_complete(method, osr_bci, comp_level)) {\n+        return;\n+      }\n@@ -1360,1 +1364,2 @@\n-    if (method_code != nullptr && method_code->is_nmethod()) {\n+    if (method_code != nullptr && method_code->is_nmethod()\n+                      && (compile_reason != CompileTask::Reason_DirectivesChanged)) {\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+      Reason_DirectivesChanged, \/\/ Changed CompilerDirectivesStack\n@@ -71,1 +72,2 @@\n-      \"bootstrap\"\n+      \"bootstrap\",\n+      \"directives_changed\"\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -697,0 +697,20 @@\n+bool DirectivesStack::hasMatchingDirectives(const methodHandle& method) {\n+  assert(_depth > 0, \"Must never be empty\");\n+  bool match_found = false;\n+  {\n+    MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);\n+\n+    CompilerDirectives* dir = _top;\n+    assert(dir != nullptr, \"Must be initialized\");\n+\n+    while (dir != nullptr) {\n+      if (!dir->is_default_directive() && dir->match(method)) {\n+        match_found = true;\n+        break;\n+      }\n+      dir = dir->next();\n+    }\n+  }\n+  return match_found;\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+  static bool hasMatchingDirectives(const methodHandle& method);\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -872,0 +872,6 @@\n+  \/\/ Clear the flags related to compiler directives that were set by the compilerBroker, \n+  \/\/ because the directives can be updated.\n+  void clear_method_flags() {\n+    set_has_matching_directives(false);\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+   status(has_matching_directives     , 1 << 16) \/* The method has matching directives *\/ \\\n","filename":"src\/hotspot\/share\/oops\/methodFlags.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -274,1 +274,1 @@\n-  MUTEX_DEFN(DirectivesStack_lock            , PaddedMutex  , nosafepoint);\n+  MUTEX_DEFN(DirectivesStack_lock            , PaddedMutex  , nosafepoint-3);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -138,0 +139,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CompilerDirectivesReplaceDCmd>(full_export, true, false));\n@@ -887,1 +889,3 @@\n-  _filename(\"filename\",\"Name of the directives file\", \"STRING\",true) {\n+  _filename(\"filename\", \"Name of the directives file\", \"STRING\", true),\n+  _force_deopt(\"-d\", \"Force deoptimization of affected methods.\", \"BOOLEAN\", false, \"false\") {\n+\n@@ -889,0 +893,1 @@\n+  _dcmdparser.add_dcmd_option(&_force_deopt);\n@@ -893,0 +898,38 @@\n+  if (_force_deopt.value()) {\n+    CodeCache::mark_directives_matches();\n+    CodeCache::recompile_marked_directives_matches();\n+  }\n+}\n+\n+CompilerDirectivesReplaceDCmd::CompilerDirectivesReplaceDCmd(outputStream* output, bool heap) :\n+                           DCmdWithParser(output, heap),\n+  _filename(\"filename\", \"Name of the directives file\", \"STRING\", true),\n+  _force_deopt(\"-d\", \"Force deoptimization of affected methods.\", \"BOOLEAN\", false, \"false\") {\n+\n+  _dcmdparser.add_dcmd_argument(&_filename);\n+  _dcmdparser.add_dcmd_option(&_force_deopt);\n+}\n+\n+void CompilerDirectivesReplaceDCmd::execute(DCmdSource source, TRAPS) {\n+  \/\/ Need to do it twice, to account for the method that doesn't match\n+  \/\/ the directives anymore\n+  if (_force_deopt.value()) {\n+    CodeCache::mark_directives_matches();\n+\n+    DirectivesStack::clear();\n+    DirectivesParser::parse_from_file(_filename.value(), output());\n+\n+    CodeCache::mark_directives_matches();\n+    CodeCache::recompile_marked_directives_matches();\n+  }\n+  else {\n+    DirectivesStack::clear();\n+    DirectivesParser::parse_from_file(_filename.value(), output());\n+  }\n+}\n+\n+CompilerDirectivesRemoveDCmd::CompilerDirectivesRemoveDCmd(outputStream* output, bool heap) :\n+                           DCmdWithParser(output, heap),\n+  _force_deopt(\"-d\", \"Force deoptimization of affected methods.\", \"BOOLEAN\", false, \"false\") {\n+\n+  _dcmdparser.add_dcmd_option(&_force_deopt);\n@@ -896,1 +939,16 @@\n-  DirectivesStack::pop(1);\n+  \/\/ Have to duplicate code to shut an assert in DTR of DeoptimizationScope\n+  if (_force_deopt.value()) {\n+    CodeCache::mark_directives_matches();\n+    DirectivesStack::pop(1);\n+    CodeCache::recompile_marked_directives_matches();\n+  }\n+  else {\n+    DirectivesStack::pop(1);\n+  }\n+}\n+\n+CompilerDirectivesClearDCmd::CompilerDirectivesClearDCmd(outputStream* output, bool heap) :\n+                           DCmdWithParser(output, heap),\n+  _force_deopt(\"-d\", \"Force deoptimization of affected methods.\", \"BOOLEAN\", false, \"false\") {\n+\n+  _dcmdparser.add_dcmd_option(&_force_deopt);\n@@ -900,1 +958,9 @@\n-  DirectivesStack::clear();\n+  \/\/ Have to duplicate code to shut an assert in DTR of DeoptimizationScope\n+  if (_force_deopt.value()) {\n+    CodeCache::mark_directives_matches();\n+    DirectivesStack::clear();\n+    CodeCache::recompile_marked_directives_matches();\n+  }\n+  else {\n+    DirectivesStack::clear();\n+  }\n@@ -902,0 +968,1 @@\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":70,"deletions":3,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -687,1 +687,3 @@\n-class CompilerDirectivesRemoveDCmd : public DCmd {\n+class CompilerDirectivesRemoveDCmd : public DCmdWithParser {\n+protected:\n+  DCmdArgument<bool> _force_deopt; \/\/ true if deopt should be forced after directives changes.\n@@ -689,1 +691,2 @@\n-  CompilerDirectivesRemoveDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n+  static int num_arguments() { return 1; }\n+  CompilerDirectivesRemoveDCmd(outputStream* output, bool heap);\n@@ -710,0 +713,1 @@\n+  DCmdArgument<bool> _force_deopt; \/\/ true if deopt should be forced after directives changes.\n@@ -711,1 +715,1 @@\n-  static int num_arguments() { return 1; }\n+  static int num_arguments() { return 2; }\n@@ -730,1 +734,27 @@\n-class CompilerDirectivesClearDCmd : public DCmd {\n+class CompilerDirectivesReplaceDCmd : public DCmdWithParser {\n+protected:\n+  DCmdArgument<char*> _filename;\n+  DCmdArgument<bool> _force_deopt; \/\/ true if deopt should be forced after directives changes.\n+public:\n+  static int num_arguments() { return 2; }\n+  CompilerDirectivesReplaceDCmd(outputStream* output, bool heap);\n+  static const char* name() {\n+    return \"Compiler.directives_replace\";\n+  }\n+  static const char* description() {\n+    return \"Clear directives stack, and load new compiler directives from file.\";\n+  }\n+  static const char* impact() {\n+    return \"Low\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"monitor\", NULL};\n+    return p;\n+  }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n+class CompilerDirectivesClearDCmd : public DCmdWithParser {\n+protected:\n+  DCmdArgument<bool> _force_deopt; \/\/ true if deopt should be forced after directives changes.\n@@ -732,1 +762,2 @@\n-  CompilerDirectivesClearDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n+  static int num_arguments() { return 1; }\n+  CompilerDirectivesClearDCmd(outputStream* output, bool heap);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,2 @@\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n@@ -58,1 +60,5 @@\n-        testAddAndRemoveCommand(executor);\n+        testAddAndRemoveCommand(executor, false \/*don't force deopt*\/);\n+        testAddAndRemoveCommand(executor, true \/*force deopt*\/);\n+\n+        filename = System.getProperty(\"test.src\", \".\") + File.separator + \"control3.txt\";\n+        testForcedDeopt(executor);\n@@ -71,1 +77,17 @@\n-    public static void testAddAndRemoveCommand(CommandExecutor executor) {\n+    public static void testForcedDeopt(CommandExecutor executor) {\n+        OutputAnalyzer output;\n+\n+        \/\/ j.l.S.equals is already compiled, so in the output of the Compiler.codelist\n+        \/\/ command we see the method in state 0 (in use). After forced de-optimisation,\n+        \/\/ the method will be shown in state 2 (marked for de-optimisation) or\n+        \/\/ doesn't appear in the output at all.\n+\n+        output = executor.execute(\"Compiler.directives_replace \" + filename + \" -d\");\n+        output = executor.execute(\"Compiler.codelist \");\n+        int count = findPattern(output, \"[0-9]+ 4 0 java.lang.String.equals\\\\(.*\");\n+        if (count != 0) {\n+            Assert.fail(\"Expected no c2 compiled instances of j.l.S.equals - found \" + count);\n+        }\n+    }\n+\n+    public static void testAddAndRemoveCommand(CommandExecutor executor, boolean force_deopt) {\n@@ -74,0 +96,1 @@\n+        String fdeo = (force_deopt) ? \" -d\" : \"\";\n@@ -76,1 +99,1 @@\n-        output = executor.execute(\"Compiler.directives_clear\");\n+        output = executor.execute(\"Compiler.directives_clear\" + fdeo);\n@@ -84,1 +107,1 @@\n-        output = executor.execute(\"Compiler.directives_remove\");\n+        output = executor.execute(\"Compiler.directives_remove\" + fdeo);\n@@ -92,1 +115,9 @@\n-        output = executor.execute(\"Compiler.directives_add \" + filename);\n+        output = executor.execute(\"Compiler.directives_add \" + filename + fdeo);\n+        output = executor.execute(\"Compiler.directives_print\");\n+        count = find(output, \"Directive:\");\n+        if (count != 3) {\n+            Assert.fail(\"Expected three directives - found \" + count);\n+        }\n+\n+        \/\/ Test replace directives from file\n+        output = executor.execute(\"Compiler.directives_replace \" + filename + fdeo);\n@@ -100,1 +131,1 @@\n-        output = executor.execute(\"Compiler.directives_remove\");\n+        output = executor.execute(\"Compiler.directives_remove\" + fdeo);\n@@ -108,1 +139,1 @@\n-        output = executor.execute(\"Compiler.directives_add \" + filename);\n+        output = executor.execute(\"Compiler.directives_add \" + filename + fdeo);\n@@ -116,1 +147,1 @@\n-        output = executor.execute(\"Compiler.directives_clear\");\n+        output = executor.execute(\"Compiler.directives_clear\" + fdeo);\n@@ -124,1 +155,1 @@\n-        output = executor.execute(\"Compiler.directives_clear\");\n+        output = executor.execute(\"Compiler.directives_clear\" + fdeo);\n@@ -132,1 +163,1 @@\n-        output = executor.execute(\"Compiler.directives_remove\");\n+        output = executor.execute(\"Compiler.directives_remove\" + fdeo);\n@@ -151,0 +182,14 @@\n+    public static int findPattern(OutputAnalyzer output, String regexp) {\n+        int count = 0;\n+        Pattern pattern = Pattern.compile(regexp);\n+\n+        for (String line : output.asLines()) {\n+            Matcher matcher = pattern.matcher(line);\n+            if (matcher.matches()) {\n+                count++;\n+            }\n+        }\n+        return count;\n+    }\n+\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/CompilerDirectivesDCMDTest.java","additions":56,"deletions":11,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -0,0 +1,6 @@\n+[\n+  {\n+    match: \"java\/lang\/String.equals\",\n+    Exclude: true\n+  }\n+]\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/control3.txt","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"}]}