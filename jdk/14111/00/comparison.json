{"files":[{"patch":"@@ -38,0 +38,1 @@\n+#include \"compiler\/compilerDirectives.hpp\"\n@@ -1371,0 +1372,17 @@\n+void CodeCache::mark_for_deoptimization_directives_matches(DeoptimizationScope *deopt_scope) {\n+  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+  Thread *thread = Thread::current();\n+\n+  CompiledMethodIterator iter(CompiledMethodIterator::only_not_unloading);\n+  while(iter.next()) {\n+    CompiledMethod* nm = iter.method();\n+    HandleMark hm(thread);\n+    methodHandle mh(thread, nm->method());\n+    if (DirectivesStack::hasMatchingDirectives(mh)) {\n+      ResourceMark rm;\n+      log_trace(codecache)(\"Mark for deopt because of matching directives %s\", mh->external_name());\n+      deopt_scope->mark(nm);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -311,0 +311,1 @@\n+  static void mark_for_deoptimization_directives_matches(DeoptimizationScope *deopt_scope);\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -697,0 +697,20 @@\n+bool DirectivesStack::hasMatchingDirectives(const methodHandle& method) {\n+  assert(_depth > 0, \"Must never be empty\");\n+  bool match_found = false;\n+  {\n+    MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);\n+\n+    CompilerDirectives* dir = _top;\n+    assert(dir != nullptr, \"Must be initialized\");\n+\n+    while (dir != nullptr) {\n+      if (!dir->is_default_directive() && dir->match(method)) {\n+        match_found = true;\n+        break;\n+      }\n+      dir = dir->next();\n+    }\n+  }\n+  return match_found;\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+  static bool hasMatchingDirectives(const methodHandle& method);\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -274,1 +274,1 @@\n-  MUTEX_DEFN(DirectivesStack_lock            , PaddedMutex  , nosafepoint);\n+  MUTEX_DEFN(DirectivesStack_lock            , PaddedMutex  , nosafepoint-3);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -138,0 +139,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CompilerDirectivesReplaceDCmd>(full_export, true, false));\n@@ -887,1 +889,3 @@\n-  _filename(\"filename\",\"Name of the directives file\", \"STRING\",true) {\n+  _filename(\"filename\", \"Name of the directives file\", \"STRING\", true),\n+  _force_deopt(\"-d\", \"Force deoptimization of affected methods.\", \"BOOLEAN\", false, \"false\") {\n+\n@@ -889,0 +893,1 @@\n+  _dcmdparser.add_dcmd_option(&_force_deopt);\n@@ -893,0 +898,41 @@\n+  if (_force_deopt.value()) {\n+    DeoptimizationScope deopt_scope;\n+    CodeCache::mark_for_deoptimization_directives_matches(&deopt_scope);\n+    deopt_scope.deoptimize_marked();\n+  }\n+}\n+\n+CompilerDirectivesReplaceDCmd::CompilerDirectivesReplaceDCmd(outputStream* output, bool heap) :\n+                           DCmdWithParser(output, heap),\n+  _filename(\"filename\", \"Name of the directives file\", \"STRING\", true),\n+  _force_deopt(\"-d\", \"Force deoptimization of affected methods.\", \"BOOLEAN\", false, \"false\") {\n+\n+  _dcmdparser.add_dcmd_argument(&_filename);\n+  _dcmdparser.add_dcmd_option(&_force_deopt);\n+}\n+\n+void CompilerDirectivesReplaceDCmd::execute(DCmdSource source, TRAPS) {\n+  \/\/ Need to do it twice, to account for the method that doesn't match\n+  \/\/ the directives anymore\n+  \/\/ Have to duplicate code to shut an assert in DTR of DeoptimizationScope\n+  if (_force_deopt.value()) {\n+    DeoptimizationScope deopt_scope;\n+    CodeCache::mark_for_deoptimization_directives_matches(&deopt_scope);\n+\n+    DirectivesStack::clear();\n+    DirectivesParser::parse_from_file(_filename.value(), output());\n+\n+    CodeCache::mark_for_deoptimization_directives_matches(&deopt_scope);\n+    deopt_scope.deoptimize_marked();\n+  }\n+  else {\n+    DirectivesStack::clear();\n+    DirectivesParser::parse_from_file(_filename.value(), output());\n+  }\n+}\n+\n+CompilerDirectivesRemoveDCmd::CompilerDirectivesRemoveDCmd(outputStream* output, bool heap) :\n+                           DCmdWithParser(output, heap),\n+  _force_deopt(\"-d\", \"Force deoptimization of affected methods.\", \"BOOLEAN\", false, \"false\") {\n+\n+  _dcmdparser.add_dcmd_option(&_force_deopt);\n@@ -896,1 +942,17 @@\n-  DirectivesStack::pop(1);\n+  \/\/ Have to duplicate code to shut an assert in DTR of DeoptimizationScope\n+  if (_force_deopt.value()) {\n+    DeoptimizationScope deopt_scope;\n+    CodeCache::mark_for_deoptimization_directives_matches(&deopt_scope);\n+    DirectivesStack::pop(1);\n+    deopt_scope.deoptimize_marked();\n+  }\n+  else {\n+    DirectivesStack::pop(1);\n+  }\n+}\n+\n+CompilerDirectivesClearDCmd::CompilerDirectivesClearDCmd(outputStream* output, bool heap) :\n+                           DCmdWithParser(output, heap),\n+  _force_deopt(\"-d\", \"Force deoptimization of affected methods.\", \"BOOLEAN\", false, \"false\") {\n+\n+  _dcmdparser.add_dcmd_option(&_force_deopt);\n@@ -900,1 +962,10 @@\n-  DirectivesStack::clear();\n+  \/\/ Have to duplicate code to shut an assert in DTR of DeoptimizationScope\n+  if (_force_deopt.value()) {\n+    DeoptimizationScope deopt_scope;\n+    CodeCache::mark_for_deoptimization_directives_matches(&deopt_scope);\n+    DirectivesStack::clear();\n+    deopt_scope.deoptimize_marked();\n+  }\n+  else {\n+    DirectivesStack::clear();\n+  }\n@@ -902,0 +973,1 @@\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":75,"deletions":3,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -687,1 +687,3 @@\n-class CompilerDirectivesRemoveDCmd : public DCmd {\n+class CompilerDirectivesRemoveDCmd : public DCmdWithParser {\n+protected:\n+  DCmdArgument<bool> _force_deopt; \/\/ true if deopt should be forced after directives changes.\n@@ -689,1 +691,2 @@\n-  CompilerDirectivesRemoveDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n+  static int num_arguments() { return 1; }\n+  CompilerDirectivesRemoveDCmd(outputStream* output, bool heap);\n@@ -710,0 +713,1 @@\n+  DCmdArgument<bool> _force_deopt; \/\/ true if deopt should be forced after directives changes.\n@@ -711,1 +715,1 @@\n-  static int num_arguments() { return 1; }\n+  static int num_arguments() { return 2; }\n@@ -730,1 +734,27 @@\n-class CompilerDirectivesClearDCmd : public DCmd {\n+class CompilerDirectivesReplaceDCmd : public DCmdWithParser {\n+protected:\n+  DCmdArgument<char*> _filename;\n+  DCmdArgument<bool> _force_deopt; \/\/ true if deopt should be forced after directives changes.\n+public:\n+  static int num_arguments() { return 2; }\n+  CompilerDirectivesReplaceDCmd(outputStream* output, bool heap);\n+  static const char* name() {\n+    return \"Compiler.directives_replace\";\n+  }\n+  static const char* description() {\n+    return \"Clear derectives stack amd load new compiler directives from file.\";\n+  }\n+  static const char* impact() {\n+    return \"Low\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"monitor\", NULL};\n+    return p;\n+  }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n+class CompilerDirectivesClearDCmd : public DCmdWithParser {\n+protected:\n+  DCmdArgument<bool> _force_deopt; \/\/ true if deopt should be forced after directives changes.\n@@ -732,1 +762,2 @@\n-  CompilerDirectivesClearDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n+  static int num_arguments() { return 1; }\n+  CompilerDirectivesClearDCmd(outputStream* output, bool heap);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,2 @@\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n@@ -58,1 +60,5 @@\n-        testAddAndRemoveCommand(executor);\n+        testAddAndRemoveCommand(executor, false \/*don't force deopt*\/);\n+        testAddAndRemoveCommand(executor, true \/*force deopt*\/);\n+\n+        filename = System.getProperty(\"test.src\", \".\") + File.separator + \"control3.txt\";\n+        testForcedDeopt(executor);\n@@ -71,1 +77,17 @@\n-    public static void testAddAndRemoveCommand(CommandExecutor executor) {\n+    public static void testForcedDeopt(CommandExecutor executor) {\n+        OutputAnalyzer output;\n+\n+        \/\/ j.l.S.equals is already compiled, so in the output of the Compiler.codelist\n+        \/\/ command we see the method in state 0 (in use). After forced de-optimisation,\n+        \/\/ the method will be shown in state 2 (marked for de-optimisation) or\n+        \/\/ doesn't appear in the output at all.\n+\n+        output = executor.execute(\"Compiler.directives_replace \" + filename + \" -d\");\n+        output = executor.execute(\"Compiler.codelist \");\n+        int count = findPattern(output, \"[0-9]+ 4 0 java.lang.String.equals\\\\(.*\");\n+        if (count != 0) {\n+            Assert.fail(\"Expected no c2 compiled instances of j.l.S.equals - found \" + count);\n+        }\n+    }\n+\n+    public static void testAddAndRemoveCommand(CommandExecutor executor, boolean force_deopt) {\n@@ -74,0 +96,1 @@\n+        String fdeo = (force_deopt) ? \" -d\" : \"\";\n@@ -76,1 +99,1 @@\n-        output = executor.execute(\"Compiler.directives_clear\");\n+        output = executor.execute(\"Compiler.directives_clear\" + fdeo);\n@@ -84,1 +107,1 @@\n-        output = executor.execute(\"Compiler.directives_remove\");\n+        output = executor.execute(\"Compiler.directives_remove\" + fdeo);\n@@ -92,1 +115,9 @@\n-        output = executor.execute(\"Compiler.directives_add \" + filename);\n+        output = executor.execute(\"Compiler.directives_add \" + filename + fdeo);\n+        output = executor.execute(\"Compiler.directives_print\");\n+        count = find(output, \"Directive:\");\n+        if (count != 3) {\n+            Assert.fail(\"Expected three directives - found \" + count);\n+        }\n+\n+        \/\/ Test replace directives from file\n+        output = executor.execute(\"Compiler.directives_replace \" + filename + fdeo);\n@@ -100,1 +131,1 @@\n-        output = executor.execute(\"Compiler.directives_remove\");\n+        output = executor.execute(\"Compiler.directives_remove\" + fdeo);\n@@ -108,1 +139,1 @@\n-        output = executor.execute(\"Compiler.directives_add \" + filename);\n+        output = executor.execute(\"Compiler.directives_add \" + filename + fdeo);\n@@ -116,1 +147,1 @@\n-        output = executor.execute(\"Compiler.directives_clear\");\n+        output = executor.execute(\"Compiler.directives_clear\" + fdeo);\n@@ -124,1 +155,1 @@\n-        output = executor.execute(\"Compiler.directives_clear\");\n+        output = executor.execute(\"Compiler.directives_clear\" + fdeo);\n@@ -132,1 +163,1 @@\n-        output = executor.execute(\"Compiler.directives_remove\");\n+        output = executor.execute(\"Compiler.directives_remove\" + fdeo);\n@@ -151,0 +182,14 @@\n+    public static int findPattern(OutputAnalyzer output, String regexp) {\n+        int count = 0;\n+        Pattern pattern = Pattern.compile(regexp);\n+\n+        for (String line : output.asLines()) {\n+            Matcher matcher = pattern.matcher(line);\n+            if (matcher.matches()) {\n+                count++;\n+            }\n+        }\n+        return count;\n+    }\n+\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/CompilerDirectivesDCMDTest.java","additions":56,"deletions":11,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -0,0 +1,6 @@\n+[\n+  {\n+    match: \"java\/lang\/String.equals\",\n+    Exclude: true\n+  }\n+]\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/control3.txt","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"}]}