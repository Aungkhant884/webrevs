{"files":[{"patch":"@@ -902,2 +902,3 @@\n-  static inline oop referent(oop ref);\n-  static inline void set_referent(oop ref, oop value);\n+  static inline oop weak_referent_no_keepalive(oop ref);\n+  static inline oop phantom_referent_no_keepalive(oop ref);\n+  static inline oop unknown_referent_no_keepalive(oop ref);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -103,2 +103,7 @@\n-oop java_lang_ref_Reference::referent(oop ref) {\n-  return ref->obj_field(_referent_offset);\n+\n+oop java_lang_ref_Reference::weak_referent_no_keepalive(oop ref) {\n+  return ref->obj_field_access<ON_WEAK_OOP_REF | AS_NO_KEEPALIVE>(_referent_offset);\n+}\n+\n+oop java_lang_ref_Reference::phantom_referent_no_keepalive(oop ref) {\n+  return ref->obj_field_access<ON_PHANTOM_OOP_REF | AS_NO_KEEPALIVE>(_referent_offset);\n@@ -107,2 +112,2 @@\n-void java_lang_ref_Reference::set_referent(oop ref, oop value) {\n-  ref->obj_field_put(_referent_offset, value);\n+oop java_lang_ref_Reference::unknown_referent_no_keepalive(oop ref) {\n+  return ref->obj_field_access<ON_UNKNOWN_OOP_REF | AS_NO_KEEPALIVE>(_referent_offset);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -265,1 +265,1 @@\n-  _referent = java_lang_ref_Reference::referent(_current_discovered);\n+  _referent = java_lang_ref_Reference::unknown_referent_no_keepalive(_current_discovered);\n@@ -1061,1 +1061,1 @@\n-  oop referent = java_lang_ref_Reference::referent(obj);\n+  oop referent = java_lang_ref_Reference::unknown_referent_no_keepalive(obj);\n@@ -1122,1 +1122,2 @@\n-    if (is_alive_non_header()->do_object_b(java_lang_ref_Reference::referent(obj))) {\n+    oop referent = java_lang_ref_Reference::unknown_referent_no_keepalive(obj);\n+    if (is_alive_non_header()->do_object_b(referent)) {\n@@ -1172,1 +1173,1 @@\n-         is_subject_to_discovery(java_lang_ref_Reference::referent(obj)))) {\n+         is_subject_to_discovery(java_lang_ref_Reference::unknown_referent_no_keepalive(obj)))) {\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-  oop referent = java_lang_ref_Reference::referent(obj);\n+  oop referent = java_lang_ref_Reference::unknown_referent_no_keepalive(obj);\n","filename":"src\/hotspot\/share\/oops\/instanceRefKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3440,8 +3440,0 @@\n-template<DecoratorSet on_ref>\n-static bool referenceRefersTo(jobject ref, jobject o) {\n-  const int offset = java_lang_ref_Reference::referent_offset();\n-  oop ref_oop = JNIHandles::resolve_non_null(ref);\n-  oop referent = HeapAccess<on_ref | AS_NO_KEEPALIVE>::oop_load_at(ref_oop, offset);\n-  return referent == JNIHandles::resolve(o);\n-}\n-\n@@ -3450,1 +3442,3 @@\n-  return referenceRefersTo<ON_WEAK_OOP_REF>(ref, o);\n+  oop ref_oop = JNIHandles::resolve_non_null(ref);\n+  oop referent = java_lang_ref_Reference::weak_referent_no_keepalive(ref_oop);\n+  return referent == JNIHandles::resolve(o);\n@@ -3459,1 +3453,3 @@\n-  return referenceRefersTo<ON_PHANTOM_OOP_REF>(ref, o);\n+  oop ref_oop = JNIHandles::resolve_non_null(ref);\n+  oop referent = java_lang_ref_Reference::phantom_referent_no_keepalive(ref_oop);\n+  return referent == JNIHandles::resolve(o);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -63,1 +63,5 @@\n-    \/* Type-erased implementation of refersTo(). *\/\n+    \/* Override the implementation of Reference.refersTo.\n+     * Phantom references are weaker than finalization, so the referent\n+     * access needs to be handled differently for garbage collectors that\n+     * do reference processing concurrently.\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/PhantomReference.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -360,1 +360,2 @@\n-    \/* Type-erased implementation of refersTo(). *\/\n+    \/* Implementation of refersTo() for non-phantom references.\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -139,0 +139,8 @@\n+    private static void expectNotValue(Reference<TestObject> ref,\n+                                       TestObject value,\n+                                       String which) throws Exception {\n+        if (ref.refersTo(value)) {\n+            fail(which + \" refers to unexpected value\");\n+        }\n+    }\n+\n@@ -149,1 +157,1 @@\n-        testObject3 = null;\n+        \/\/ testObject3 not dropped\n@@ -177,0 +185,3 @@\n+            expectNotValue(testWeak2, testObject3, \"testWeak2\");\n+            expectValue(testWeak3, testObject3, \"testWeak3\");\n+\n@@ -178,2 +189,0 @@\n-            \/\/ For example, SATB collectors or ZGC, but not collectors using\n-            \/\/ incremental update barriers like CMS.\n@@ -190,1 +199,1 @@\n-            expectCleared(testWeak3, \"testWeak3\");\n+            expectNotCleared(testWeak3, \"testWeak3\");\n@@ -193,0 +202,4 @@\n+            expectNotValue(testPhantom1, testObject3, \"testPhantom1\");\n+            expectValue(testWeak3, testObject3, \"testWeak3\");\n+            expectNotValue(testWeak4, testObject3, \"testWeak4\");\n+\n@@ -196,2 +209,7 @@\n-            } else if (testWeak3.get() != null) {\n-                fail(\"testWeak3.get() != null\");\n+            }\n+\n+            TestObject obj3 = testWeak3.get();\n+            if (obj3 == null) {\n+                fail(\"testWeak3.get() returned null\");\n+            } else if (obj3.value != 3) {\n+                fail(\"testWeak3.get().value is \" + obj3.value);\n@@ -201,4 +219,4 @@\n-            if (obj4 != null) {\n-                if (obj4.value != 4) {\n-                    fail(\"testWeak4.get().value is \" + obj4.value);\n-                }\n+            if (obj4 == null) {\n+                fail(\"testWeak4.get() returned null\");\n+            } else if (obj4.value != 4) {\n+                fail(\"testWeak4.get().value is \" + obj4.value);\n@@ -229,2 +247,2 @@\n-            } else if (testWeak3 != null) {\n-                fail(\"testWeak3 not notified\");\n+            } else if (testWeak3 == null) {\n+                fail(\"testWeak3 notified\");\n@@ -263,1 +281,1 @@\n-        expectCleared(testWeak3, \"testWeak3\");\n+        expectNotCleared(testWeak3, \"testWeak3\");\n@@ -266,0 +284,3 @@\n+        expectNotValue(testWeak2, testObject3, \"testWeak2\");\n+        expectValue(testWeak3, testObject3, \"testWeak3\");\n+\n@@ -269,3 +290,3 @@\n-        } else if (testWeak3.get() != null) {\n-            fail(\"testWeak3.get() != null\");\n-        } else if (tw4 != testWeak4.get()) {\n+        } else if (testWeak3.get() != testObject3) {\n+            fail(\"testWeak3.get() is not expected value\");\n+        } else if (testWeak4.get() != tw4) {\n","filename":"test\/hotspot\/jtreg\/gc\/TestReferenceRefersTo.java","additions":37,"deletions":16,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Basic functional test of Reference.refersTo.\n+ *\/\n+\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.PhantomReference;\n+import java.lang.ref.SoftReference;\n+import java.lang.ref.WeakReference;\n+\n+public class ReferenceRefersTo {\n+    private static final class TestObject {\n+        public final int value;\n+\n+        public TestObject(int value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    private static final void fail(String msg) throws Exception {\n+        throw new RuntimeException(msg);\n+    }\n+\n+    private static final <T extends Reference>\n+    void test(T ref,\n+              TestObject expectedValue,\n+              TestObject unexpectedValue,\n+              String kind) throws Exception {\n+        if ((expectedValue != null) && ref.refersTo(null)) {\n+            fail(kind + \"refers to null\");\n+        } else if (!ref.refersTo(expectedValue)) {\n+            fail(kind + \" doesn't refer to expected value\");\n+        } else if (ref.refersTo(unexpectedValue)) {\n+            fail(kind + \" refers to unexpected value\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        var queue = new ReferenceQueue<TestObject>();\n+\n+        var obj0 = new TestObject(0);\n+        var obj1 = new TestObject(1);\n+        var obj2 = new TestObject(2);\n+        var obj3 = new TestObject(3);\n+\n+        var pref = new PhantomReference(obj0, queue);\n+        var wref = new WeakReference(obj1);\n+        var sref = new SoftReference(obj2);\n+\n+        test(pref, obj0, obj3, \"phantom\");\n+        test(wref, obj1, obj3, \"weak\");\n+        test(sref, obj2, obj3, \"soft\");\n+\n+        pref.clear();\n+        wref.clear();\n+        sref.clear();\n+\n+        test(pref, null, obj3, \"phantom\");\n+        test(wref, null, obj3, \"weak\");\n+        test(sref, null, obj3, \"soft\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ref\/ReferenceRefersTo.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"}]}