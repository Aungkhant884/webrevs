{"files":[{"patch":"@@ -3704,18 +3704,2 @@\n-  \/\/ iteration.  Then the CountedLoopEnd will collapse (backedge never\n-  \/\/ taken) and all loop-invariant uses of the exit values will be correct.\n-  Node *phi = cl->phi();\n-  Node *exact_limit = phase->exact_limit(this);\n-  if (exact_limit != cl->limit()) {\n-    \/\/ We also need to replace the original limit to collapse loop exit.\n-    Node* cmp = cl->loopexit()->cmp_node();\n-    assert(cl->limit() == cmp->in(2), \"sanity\");\n-    \/\/ Duplicate cmp node if it has other users\n-    if (cmp->outcnt() > 1) {\n-      cmp = cmp->clone();\n-      cmp = phase->_igvn.register_new_node_with_optimizer(cmp);\n-      BoolNode *bol = cl->loopexit()->in(CountedLoopEndNode::TestValue)->as_Bool();\n-      phase->_igvn.replace_input_of(bol, 1, cmp); \/\/ put bol on worklist\n-    }\n-    phase->_igvn._worklist.push(cmp->in(2)); \/\/ put limit on worklist\n-    phase->_igvn.replace_input_of(cmp, 2, exact_limit); \/\/ put cmp on worklist\n-  }\n+  \/\/ iteration (exact_limit - stride), to make sure the loop exit value\n+  \/\/ is correct, for any users after the loop.\n@@ -3724,3 +3708,11 @@\n-  Node *final = new SubINode(exact_limit, cl->stride());\n-  phase->register_new_node(final,cl->in(LoopNode::EntryControl));\n-  phase->_igvn.replace_node(phi,final);\n+  Node* phi = cl->phi();\n+  Node* exact_limit = phase->exact_limit(this);\n+  Node* final_iv = new SubINode(exact_limit, cl->stride());\n+  phase->register_new_node(final_iv, cl->in(LoopNode::EntryControl));\n+  phase->_igvn.replace_node(phi, final_iv);\n+\n+  \/\/ Set loop-exit condition to false. Then the CountedLoopEnd will collapse,\n+  \/\/ because the back edge is never taken.\n+  Node* zero = phase->_igvn.intcon(0);\n+  phase->_igvn.replace_input_of(cl->loopexit(), CountedLoopEndNode::TestValue, zero);\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":13,"deletions":21,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +27,1 @@\n- * @bug 8231988\n+ * @bug 8231988 8293996\n@@ -37,1 +38,1 @@\n-    public void test() {\n+    public void test_cmp_helper() {\n@@ -39,0 +40,1 @@\n+        \/\/ The empty loop that collapses\n@@ -40,0 +42,1 @@\n+        \/\/ If uses same Cmp node as the loop condition\n@@ -47,2 +50,2 @@\n-    public static void main(String[] args) {\n-        TestRemoveEmptyLoop _instance = new TestRemoveEmptyLoop();\n+    public void test_cmp() {\n+        \/\/ Loop is OSR compiled, and test_cmp_helper inlined\n@@ -50,1 +53,22 @@\n-            _instance.test();\n+            test_cmp_helper();\n+        }\n+    }\n+\n+    void test_collapse_helper() {\n+        int o = 11;\n+        int e = 43542;\n+        for (int i = 524; i < 19325; i += 1) {\n+            \/\/ The empty loop that is supposed to collapse\n+            for (int j = 0; j < 32767; j++) {\n+                o++;\n+            }\n+            for (int k = 0; k < o; k++) {\n+                e++;\n+            }\n+        }\n+    }\n+\n+    public void test_collapse() {\n+        \/\/ Loop is OSR compiled, and test_collapse_helper inlined\n+        for (int i = 0; i < 50000; i++) {\n+            test_collapse_helper();\n@@ -52,1 +76,0 @@\n-        System.out.println(\"Test passed.\");\n@@ -55,0 +78,6 @@\n+    public static void main(String[] args) {\n+        TestRemoveEmptyLoop _instance = new TestRemoveEmptyLoop();\n+        _instance.test_cmp();\n+        _instance.test_collapse();\n+        System.out.println(\"Test passed.\");\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestRemoveEmptyLoop.java","additions":35,"deletions":6,"binary":false,"changes":41,"status":"modified"}]}