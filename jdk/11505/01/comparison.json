{"files":[{"patch":"@@ -43,2 +43,14 @@\n-Address::Address(address target, relocInfo::relocType rtype) : _base(noreg), _offset(0), _mode(literal) {\n-  _target = target;\n+#ifdef ASSERT\n+\n+void Address::assert_is_literal() const {\n+  assert(_mode == literal, \"addressing mode is non-literal: %d\", _mode);\n+}\n+\n+void Address::assert_is_nonliteral() const {\n+  assert(_mode != literal, \"unexpected literal addressing mode\");\n+  assert(_mode != no_mode, \"unexpected no_mode addressing mode\");\n+}\n+\n+#endif \/\/ ASSERT\n+\n+static RelocationHolder address_relocation(address target, relocInfo::relocType rtype) {\n@@ -52,1 +64,1 @@\n-      break;\n+      return RelocationHolder::none;\n@@ -54,2 +66,1 @@\n-      _rspec = external_word_Relocation::spec(target);\n-      break;\n+      return external_word_Relocation::spec(target);\n@@ -57,2 +68,1 @@\n-      _rspec = internal_word_Relocation::spec(target);\n-      break;\n+      return internal_word_Relocation::spec(target);\n@@ -60,2 +70,1 @@\n-      _rspec = opt_virtual_call_Relocation::spec();\n-      break;\n+      return opt_virtual_call_Relocation::spec();\n@@ -63,2 +72,1 @@\n-      _rspec = static_call_Relocation::spec();\n-      break;\n+      return static_call_Relocation::spec();\n@@ -66,2 +74,1 @@\n-      _rspec = runtime_call_Relocation::spec();\n-      break;\n+      return runtime_call_Relocation::spec();\n@@ -70,2 +77,1 @@\n-      _rspec = Relocation::spec_simple(rtype);\n-      break;\n+      return Relocation::spec_simple(rtype);\n@@ -73,2 +79,1 @@\n-      _rspec = RelocationHolder::none;\n-      break;\n+      return RelocationHolder::none;\n@@ -77,0 +82,1 @@\n+      return RelocationHolder::none;\n@@ -79,0 +85,5 @@\n+\n+Address::Address(address target, relocInfo::relocType rtype) :\n+  _mode(literal),\n+  _literal(target, address_relocation(target, rtype))\n+{}\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.cpp","additions":28,"deletions":17,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include <type_traits>\n@@ -156,1 +160,1 @@\n-  enum mode { no_mode, base_plus_offset, pcrel, literal };\n+  enum mode { no_mode, base_plus_offset, literal };\n@@ -159,4 +163,15 @@\n-  Register _base;\n-  Register _index;\n-  int64_t _offset;\n-  enum mode _mode;\n+  struct Nonliteral {\n+    Nonliteral(Register base, Register index, int64_t offset)\n+      : _base(base), _index(index), _offset(offset) {}\n+    Register _base;\n+    Register _index;\n+    int64_t _offset;\n+  };\n+\n+  struct Literal {\n+    Literal(address target, const RelocationHolder& rspec)\n+      : _target(target), _rspec(rspec) {}\n+    \/\/ If the target is far we'll need to load the ea of this to a\n+    \/\/ register to reach it. Otherwise if near we can do PC-relative\n+    \/\/ addressing.\n+    address _target;\n@@ -164,1 +179,2 @@\n-  RelocationHolder _rspec;\n+    RelocationHolder _rspec;\n+  };\n@@ -166,4 +182,24 @@\n-  \/\/ If the target is far we'll need to load the ea of this to a\n-  \/\/ register to reach it. Otherwise if near we can do PC-relative\n-  \/\/ addressing.\n-  address          _target;\n+  void assert_is_nonliteral() const NOT_DEBUG_RETURN;\n+  void assert_is_literal() const NOT_DEBUG_RETURN;\n+\n+  \/\/ Discriminated union, based on _mode.\n+  \/\/ - no_mode: uses dummy _nonliteral, for ease of copying.\n+  \/\/ - literal: only _literal is used.\n+  \/\/ - others: only _nonliteral is used.\n+  enum mode _mode;\n+  union {\n+    Nonliteral _nonliteral;\n+    Literal _literal;\n+  };\n+\n+  \/\/ Helper for copy constructor and assignment operator.\n+  \/\/ Copy mode-relevant part of a into this.\n+  void copy_data(const Address& a) {\n+    assert(_mode == a._mode, \"precondition\");\n+    if (_mode == literal) {\n+      new (&_literal) Literal(a._literal);\n+    } else {\n+      \/\/ non-literal mode or no_mode.\n+      new (&_nonliteral) Nonliteral(a._nonliteral);\n+    }\n+  }\n@@ -172,2 +208,5 @@\n-  Address()\n-    : _base(noreg), _index(noreg), _offset(0), _mode(no_mode), _target(NULL) { }\n+  \/\/ no_mode initializes _nonliteral for ease of copying.\n+  Address() :\n+    _mode(no_mode),\n+    _nonliteral(noreg, noreg, 0)\n+  {}\n@@ -175,2 +214,4 @@\n-  Address(Register r)\n-    : _base(r), _index(noreg), _offset(0), _mode(base_plus_offset), _target(NULL) { }\n+  Address(Register r) :\n+    _mode(base_plus_offset),\n+    _nonliteral(r, noreg, 0)\n+  {}\n@@ -179,2 +220,4 @@\n-  Address(Register r, T o)\n-    : _base(r), _index(noreg), _offset(o), _mode(base_plus_offset), _target(NULL) {}\n+  Address(Register r, T o) :\n+    _mode(base_plus_offset),\n+    _nonliteral(r, noreg, o)\n+  {}\n@@ -182,2 +225,1 @@\n-  Address(Register r, ByteSize disp)\n-    : Address(r, in_bytes(disp)) {}\n+  Address(Register r, ByteSize disp) : Address(r, in_bytes(disp)) {}\n@@ -185,7 +227,4 @@\n-  Address(address target, RelocationHolder const& rspec)\n-    : _base(noreg),\n-      _index(noreg),\n-      _offset(0),\n-      _mode(literal),\n-      _rspec(rspec),\n-      _target(target) { }\n+  Address(address target, const RelocationHolder& rspec) :\n+    _mode(literal),\n+    _literal(target, rspec)\n+  {}\n@@ -195,0 +234,16 @@\n+  Address(const Address& a) : _mode(a._mode) { copy_data(a); }\n+\n+  \/\/ Verify the value is trivially destructible regardless of mode, so our\n+  \/\/ destructor can also be trivial, and so our assignment operator doesn't\n+  \/\/ need to destruct the old value before copying over it.\n+  static_assert(std::is_trivially_destructible<Literal>::value, \"must be\");\n+  static_assert(std::is_trivially_destructible<Nonliteral>::value, \"must be\");\n+\n+  Address& operator=(const Address& a) {\n+    _mode = a._mode;\n+    copy_data(a);\n+    return *this;\n+  }\n+\n+  ~Address() = default;\n+\n@@ -196,2 +251,2 @@\n-    guarantee((_mode == base_plus_offset | _mode == pcrel | _mode == literal), \"wrong mode\");\n-    return _base;\n+    assert_is_nonliteral();\n+    return _nonliteral._base;\n@@ -199,0 +254,1 @@\n+\n@@ -200,1 +256,2 @@\n-    return _offset;\n+    assert_is_nonliteral();\n+    return _nonliteral._offset;\n@@ -202,0 +259,1 @@\n+\n@@ -203,1 +261,2 @@\n-    return _index;\n+    assert_is_nonliteral();\n+    return _nonliteral._index;\n@@ -205,0 +264,1 @@\n+\n@@ -209,3 +269,13 @@\n-  bool uses(Register reg) const { return _base == reg; }\n-  const address target() const { return _target; }\n-  const RelocationHolder& rspec() const { return _rspec; }\n+  bool uses(Register reg) const {\n+    return base() == reg;\n+  }\n+\n+  const address target() const {\n+    assert_is_literal();\n+    return _literal._target;\n+  }\n+\n+  const RelocationHolder& rspec() const {\n+    assert_is_literal();\n+    return _literal._rspec;\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":102,"deletions":32,"binary":false,"changes":134,"status":"modified"}]}