{"files":[{"patch":"@@ -1031,0 +1031,1 @@\n+    gdata->rememberVThreadsWhenDisconnected = JNI_FALSE;\n@@ -1145,0 +1146,2 @@\n+            \/\/ These two flags always set the same for now.\n+            gdata->rememberVThreadsWhenDisconnected = gdata->includeVThreads;\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/debugInit.c","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,0 +100,1 @@\n+    eventHandler_onConnect();\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/debugLoop.c","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -135,0 +135,4 @@\n+                \/* Notify anyone waiting for callbacks to exit *\/       \\\n+                if (active_callbacks == 0) {                            \\\n+                    debugMonitorNotifyAll(callbackLock);                \\\n+                }                                                       \\\n@@ -1512,2 +1516,5 @@\n-    \/* Only enable vthread events if vthread support is enabled. *\/\n-    if (gdata->vthreadsSupported) {\n+    \/*\n+     * Only enable vthread START and END events if we want to remember\n+     * vthreads when no debugger is connected.\n+     *\/\n+    if (gdata->vthreadsSupported && gdata->rememberVThreadsWhenDisconnected) {\n@@ -1585,0 +1592,27 @@\n+void\n+eventHandler_onConnect() {\n+    debugMonitorEnter(handlerLock);\n+\n+    \/*\n+     * Enable vthread START and END events if they are not already always enabled.\n+     * They are always enabled if we are remembering vthreads when no debugger is\n+     * connected. Otherwise they are only enabled when connected because they can\n+     * be very noisy and hurt performance a lot.\n+     *\/\n+    if (gdata->vthreadsSupported && !gdata->rememberVThreadsWhenDisconnected) {\n+        jvmtiError error;\n+        error = threadControl_setEventMode(JVMTI_ENABLE,\n+                                           EI_VIRTUAL_THREAD_START, NULL);\n+        if (error != JVMTI_ERROR_NONE) {\n+            EXIT_ERROR(error,\"Can't disable vthread start events\");\n+        }\n+        error = threadControl_setEventMode(JVMTI_ENABLE,\n+                                           EI_VIRTUAL_THREAD_END, NULL);\n+        if (error != JVMTI_ERROR_NONE) {\n+            EXIT_ERROR(error,\"Can't disable vthread end events\");\n+        }\n+    }\n+\n+    debugMonitorExit(handlerLock);\n+}\n+\n@@ -1599,0 +1633,18 @@\n+    \/* Disable vthread START and END events unless we are remembering vthreads\n+     * when no debugger is connected. We do this because these events can\n+     * be very noisy and hurt performance a lot.\n+     *\/\n+    if (gdata->vthreadsSupported && !gdata->rememberVThreadsWhenDisconnected) {\n+        jvmtiError error;\n+        error = threadControl_setEventMode(JVMTI_DISABLE,\n+                                           EI_VIRTUAL_THREAD_START, NULL);\n+        if (error != JVMTI_ERROR_NONE) {\n+            EXIT_ERROR(error,\"Can't disable vthread start events\");\n+        }\n+        error = threadControl_setEventMode(JVMTI_DISABLE,\n+                                           EI_VIRTUAL_THREAD_END, NULL);\n+        if (error != JVMTI_ERROR_NONE) {\n+            EXIT_ERROR(error,\"Can't disable vthread end events\");\n+        }\n+    }\n+\n@@ -1615,0 +1667,17 @@\n+void\n+eventHandler_waitForActiveCallbacks()\n+{\n+    \/*\n+     * Wait for active callbacks to complete. It is ok if more callbacks come in\n+     * after this point. This is being done so threadControl_reset() can safely\n+     * remove all vthreads without worry that they might be referenced in an active\n+     * callback. The only callbacks enabled at this point are the permanent ones,\n+     * and they never involve vthreads.\n+     *\/\n+    debugMonitorEnter(callbackLock);\n+    while (active_callbacks > 0) {\n+        debugMonitorWait(callbackLock);\n+    }\n+    debugMonitorExit(callbackLock);\n+}\n+\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.c","additions":71,"deletions":2,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,1 @@\n+void eventHandler_onConnect();\n@@ -75,0 +76,1 @@\n+void eventHandler_waitForActiveCallbacks();\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -513,0 +513,13 @@\n+static void\n+removeVThreads(JNIEnv *env)\n+{\n+    ThreadList *list = &runningVThreads;\n+    ThreadNode *node = list->first;\n+    while (node != NULL) {\n+        ThreadNode *temp = node->next;\n+        removeNode(list, node);\n+        clearThread(env, node);\n+        node = temp;\n+    }\n+}\n+\n@@ -2757,0 +2770,24 @@\n+\n+    \/*\n+     * Unless we are remembering all vthreads when the debugger is not connected,\n+     * we free them all up here.\n+     *\/\n+    if (!gdata->rememberVThreadsWhenDisconnected) {\n+        \/*\n+         * First we need to wait for all active callbacks to complete. They were resumed\n+         * above by the resetHelper. We can't remove the vthreads until after they complete,\n+         * because the vthread ThreadNodes might be referenced as the callbacks unwind.\n+         * We do this outside of any locking, because the callbacks may need to acquire locks\n+         * in order to complete. It's ok if there are more callbacks after this point because\n+         * the only callbacks enabled are the permanent ones, and they never involve vthreads.\n+         *\/\n+        eventHandler_waitForActiveCallbacks();\n+        \/*\n+         * Now that event callbacks have exited, we can reacquire the threadLock, which\n+         * is needed before before calling removeVThreads().\n+         *\/\n+        debugMonitorEnter(threadLock);\n+        removeVThreads(env);\n+        debugMonitorExit(threadLock);\n+    }\n+\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+    jboolean rememberVThreadsWhenDisconnected;\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}