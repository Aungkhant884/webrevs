{"files":[{"patch":"@@ -275,0 +275,2 @@\n+  template(reflect_MethodAccessor,                    \"jdk\/internal\/reflect\/MethodAccessor\")          \\\n+  template(reflect_ConstructorAccessor,               \"jdk\/internal\/reflect\/ConstructorAccessor\")     \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -85,1 +86,1 @@\n-   _vfst(cont.is_null()\n+    _vfst(cont.is_null()\n@@ -87,1 +88,2 @@\n-      : vframeStream(cont(), cont_scope)) {\n+      : vframeStream(cont(), cont_scope)),\n+    _needs_caller_sensitive_check(true) {\n@@ -146,0 +148,19 @@\n+static bool is_reflection_or_methodhandle_frame(Method* method, TRAPS) {\n+  static InstanceKlass* method_accessor = nullptr;\n+  static InstanceKlass* constructor_accessor = nullptr;\n+  if (method_accessor == nullptr) {\n+    Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::reflect_MethodAccessor(), true, THREAD);\n+    assert(k != nullptr, \"Can't load MethodAccessor\");\n+    method_accessor = InstanceKlass::cast(k);\n+    k = SystemDictionary::resolve_or_fail(vmSymbols::reflect_ConstructorAccessor(), true, THREAD);\n+    assert(k != nullptr, \"Can't load ConstructorAccessor\");\n+    constructor_accessor = InstanceKlass::cast(k);\n+  }\n+  return (method->method_holder() == vmClasses::reflect_Method_klass() ||\n+    method->method_holder() == vmClasses::reflect_Constructor_klass() ||\n+    method->method_holder()->is_subtype_of(method_accessor) ||\n+    method->method_holder()->is_subtype_of(constructor_accessor) ||\n+    \/\/ MethodHandle frames are not hidden and StackWalker::getCallerClass has to filter them out\n+    method->method_holder()->name()->starts_with(\"java\/lang\/invoke\"));\n+}\n+\n@@ -168,1 +189,1 @@\n-                              int& end_index, bool is_first_batch, TRAPS) {\n+                              int& end_index, TRAPS) {\n@@ -187,3 +208,4 @@\n-    \/\/ skip hidden frames for default StackWalker option (i.e. SHOW_HIDDEN_FRAMES\n-    \/\/ not set) and when StackWalker::getCallerClass is called\n-    if (!ShowHiddenFrames && (skip_hidden_frames(mode) || get_caller_class(mode))) {\n+    \/\/ Always skip hidden frames when StackWalker::getCallerClass is called or for the\n+    \/\/ default StackWalker option (i.e. SHOW_HIDDEN_FRAMES not set) if ShowHiddenFrames is false.\n+    \/\/ For StackWalker::getCallerClass also skip reflective\/methodhandle frames.\n+    if (get_caller_class(mode) || (skip_hidden_frames(mode) && !ShowHiddenFrames)) {\n@@ -203,0 +225,11 @@\n+      if (get_caller_class(mode) && is_reflection_or_methodhandle_frame(method, THREAD)) {\n+        LogTarget(Debug, stackwalk) lt;\n+        if (lt.is_enabled()) {\n+          ResourceMark rm(THREAD);\n+          LogStream ls(lt);\n+          ls.print(\"  reflective\/methodhandle method: \");\n+          method->print_short_name(&ls);\n+          ls.cr();\n+        }\n+        continue;\n+      }\n@@ -216,5 +249,11 @@\n-          is_first_batch && index == start_index && method->caller_sensitive()) {\n-      ResourceMark rm(THREAD);\n-      THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(),\n-        err_msg(\"StackWalker::getCallerClass called from @CallerSensitive '%s' method\",\n-                method->external_name()));\n+        \/\/ if we're in \"get_caller_class\" mode, 'stream' is a \"JavaFrameStream\"\n+        ((JavaFrameStream&)stream).needs_caller_sensitive_check()) {\n+      \/\/ reflective and method handle frames have already been skipped in the previous step\n+      if (method->caller_sensitive()) {\n+        ResourceMark rm(THREAD);\n+        THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(),\n+          err_msg(\"StackWalker::getCallerClass called from @CallerSensitive '%s' method\",\n+                  method->external_name()));\n+      } else {\n+        ((JavaFrameStream&)stream).caller_sensitive_check_done();\n+      }\n@@ -222,0 +261,1 @@\n+\n@@ -501,1 +541,1 @@\n-                               frames_array, end_index, true, CHECK_NULL);\n+                               frames_array, end_index, CHECK_NULL);\n@@ -586,1 +626,1 @@\n-                             frames_array, end_index, false, CHECK_0);\n+                             frames_array, end_index, CHECK_0);\n","filename":"src\/hotspot\/share\/prims\/stackwalk.cpp","additions":53,"deletions":13,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+  bool                  _needs_caller_sensitive_check;\n@@ -106,0 +107,7 @@\n+\n+  bool needs_caller_sensitive_check() {\n+    return _needs_caller_sensitive_check;\n+  }\n+  void caller_sensitive_check_done() {\n+    _needs_caller_sensitive_check = false;\n+  }\n@@ -148,1 +156,1 @@\n-                            int& end_index, bool is_first_batch, TRAPS);\n+                            int& end_index, TRAPS);\n","filename":"src\/hotspot\/share\/prims\/stackwalk.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -274,2 +274,1 @@\n-         * or {@code null} if no more frame. If advanceToNextBatch is true,\n-         * it will only fetch the next batch.\n+         * or {@code null} if no more frame.\n@@ -388,1 +387,1 @@\n-         * {@link Option#SHOW_REFLECT_FRAMES}\n+         * {@link Option#SHOW_REFLECT_FRAMES} or {@link Option#SHOW_HIDDEN_FRAMES}\n@@ -735,3 +734,4 @@\n-            \/\/ 0: StackWalker::getCallerClass\n-            \/\/ 1: caller-sensitive method\n-            \/\/ 2: caller class\n+            \/\/  : StackWalker::getCallerClass (already skipped in the VM)\n+            \/\/ 0: caller-sensitive method\n+            \/\/  : reflection and MethodHandle frames are skipped in the VM for GET_CALLER_CLASS mode\n+            \/\/ 1: caller class\n@@ -739,2 +739,0 @@\n-                if (isMethodHandleFrame(caller)) { continue; }\n-                if (isReflectionFrame(caller)) { continue; }\n@@ -1051,6 +1049,0 @@\n-    \/\/ MethodHandle frames are not hidden and CallerClassFinder has\n-    \/\/ to filter them out\n-    private static boolean isMethodHandleFrame(Class<?> c) {\n-        return c.getName().startsWith(\"java.lang.invoke.\");\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StackStreamFactory.java","additions":6,"deletions":14,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8311500\n+ * @summary StackWalker.getCallerClass() can throw if invoked reflectively\n+ * @library src\n+ * @build java.base\/java.util.CSM\n+ * @run main\/othervm ReflectiveGetCallerClassTest\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames ReflectiveGetCallerClassTest\n+ *\/\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.CSM;\n+\n+public class ReflectiveGetCallerClassTest {\n+    private static StackWalker WALKER = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n+    private static Method gcc, swgcc, inv;\n+    static {\n+        try {\n+            inv = Method.class.getDeclaredMethod(\"invoke\", Object.class, Object[].class);\n+            gcc = ReflectiveGetCallerClassTest.class.getDeclaredMethod(\"getCallerClass\");\n+            swgcc = StackWalker.class.getDeclaredMethod(\"getCallerClass\");\n+        } catch (SecurityException se) {\n+            \/\/ This test can't run if a security manager prohibits \"getStackWalkerWithClassReference\"\n+            System.err.println(se);\n+            System.exit(0);\n+        } catch (Exception e) {\n+            System.err.println(e);\n+            System.exit(1);\n+        }\n+    }\n+\n+    public static void getCallerClass() {\n+        System.out.println(\"ReflectiveGetCallerClassTest::getCallerClass() called from \" + WALKER.getCallerClass());\n+    }\n+\n+    \/\/ Create a list of Object[] of the form:\n+    \/\/   { m, first }\n+    \/\/   { m, { m, first } }\n+    \/\/   { m, { m, { m, first } } }\n+    static List<Object[]> prepareArgs(Object[] first, Method m, int depth) {\n+        List<Object[]> l = new ArrayList<Object[]>(depth + 1);\n+        l.add(first);\n+        while (depth-- > 0) {\n+            l.add(new Object[] { m, l.get(l.size() - 1) });\n+        }\n+        return l;\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+\n+        \/\/ gcc is ReflectiveGetCallerClassTest::getCallerClass()\n+        \/\/ inv is Method::invoke()\n+        for (Object[] params : prepareArgs(new Object[] { gcc, new Object[] { null, null } }, inv, 10)) {\n+            inv.invoke(inv, inv, params);\n+        }\n+\n+        \/\/ swgcc is StackWalker::getCallerClass()\n+        \/\/ inv is Method::invoke()\n+        CSM.getCallerClassReflectively(inv, prepareArgs(new Object[] { swgcc, new Object[] { WALKER, null } }, inv, 10));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/StackWalker\/CallerSensitiveMethod\/ReflectiveGetCallerClassTest.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.reflect.Method;\n@@ -74,0 +75,40 @@\n+    \/*\n+     * All invocations of StackWalker::getCallerClass() from this @CallerSensitive method\n+     * should fail with an UnsupportedOperationException.\n+     *\/\n+    @CallerSensitive\n+    public static void getCallerClassReflectively(Method inv, List<Object[]> parameters) {\n+        String msg = \"when calling StackWalker::getCallerClass() from @CallerSensitive method\";\n+        for (Object[] params : parameters) {\n+            try {\n+                Object res;\n+                if (params[0] != inv) {\n+                    \/\/ First invocation is a direct reflective call of StackWalker::getCallerClass.\n+                    \/\/ params[0]    = StackWalker::getCallerClass()\n+                    \/\/ params[1][0] = StackWalker instance\n+                    \/\/ params[1][1] = null\n+                    res = ((Method)params[0]).invoke(((Object[])params[1])[0], (Object[])((Object[])params[1])[1]);\n+                } else {\n+                    \/\/ Subsequent invocations reflectively call StackWalker::getCallerClass via reflective calls to Method::invoke.\n+                    \/\/ inv    = Method::invoke()\n+                    \/\/ params = { .. { inv, { StackWalker::getCallerClass, new Object[] { WALKER, null } } } }\n+                    res = inv.invoke(inv, inv, params);\n+                }\n+                System.out.println(\"CallerSensitiveMethod::getCallerClass() called from \" + res);\n+            } catch (Throwable expected) {\n+                while (expected.getCause() != null) {\n+                    expected = expected.getCause();\n+                }\n+                if (expected instanceof UnsupportedOperationException) {\n+                    System.out.println(\"Caught expected UnsupportedOperationException \" + msg + \" reflectively:\");\n+                    expected.printStackTrace(System.out);\n+                    continue;\n+                } else {\n+                    System.out.println(\"Unexpected exception \" + msg + \" reflectively:\");\n+                    expected.printStackTrace(System.out);\n+                }\n+            }\n+            throw new RuntimeException(\"Expected UnsupportedOperationException \" + msg + \" reflectively\");\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StackWalker\/CallerSensitiveMethod\/src\/java.base\/java\/util\/CSM.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires vm.opt.ShowHiddenFrames == false\n","filename":"test\/jdk\/java\/lang\/StackWalker\/DumpStackTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires vm.opt.ShowHiddenFrames == false\n","filename":"test\/jdk\/java\/lang\/StackWalker\/GetCallerClassTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires vm.opt.ShowHiddenFrames == false\n","filename":"test\/jdk\/java\/lang\/StackWalker\/HiddenFrames.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires vm.opt.ShowHiddenFrames == false\n","filename":"test\/jdk\/java\/lang\/StackWalker\/ReflectionFrames.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8311500\n- * @summary StackWalker.getCallerClass() can throw if invoked reflectively\n- * @run main\/othervm ReflectiveGetCallerClassTest\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames ReflectiveGetCallerClassTest\n- *\/\n-\n-import java.lang.reflect.Method;\n-import java.util.List;\n-import java.util.ArrayList;\n-\n-public class ReflectiveGetCallerClassTest {\n-    private static StackWalker WALKER = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n-    private static Method gcc, inv;\n-    static {\n-        try {\n-            inv = Method.class.getDeclaredMethod(\"invoke\", Object.class, Object[].class);\n-            gcc = ReflectiveGetCallerClassTest.class.getDeclaredMethod(\"getCallerClass\");\n-        } catch (SecurityException se) {\n-            \/\/ This test can't run if a security manager prohibits \"getStackWalkerWithClassReference\"\n-            System.err.println(se);\n-            System.exit(0);\n-        } catch (Exception e) {\n-            System.err.println(e);\n-            System.exit(1);\n-        }\n-    }\n-\n-    public static void getCallerClass() {\n-        System.out.println(WALKER.getCallerClass());\n-    }\n-\n-    \/\/ Create a list of Object[] of the form:\n-    \/\/   { m, first }\n-    \/\/   { m, { m, first } }\n-    \/\/   { m, { m, { m, first } } }\n-    static List<Object[]> prepareArgs(Object[] first, Method m, int depth) {\n-        List<Object[]> l = new ArrayList<Object[]>(depth + 1);\n-        l.add(first);\n-        while (depth-- > 0) {\n-            l.add(new Object[] { m, l.get(l.size() - 1) });\n-        }\n-        return l;\n-    }\n-\n-    public static void main(String[] args) throws Throwable {\n-        \/\/ gcc is ReflectiveGetCallerClassTest::getCallerClass()\n-        \/\/ inv is Method::invoke()\n-        for (Object[] params : prepareArgs(new Object[] { gcc, new Object[] { null, null } }, inv, 10)) {\n-            inv.invoke(inv, inv, params);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/StackWalker\/ReflectiveGetCallerClassTest.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -40,0 +40,1 @@\n+ * @requires vm.opt.ShowHiddenFrames == false\n","filename":"test\/jdk\/java\/lang\/StackWalker\/StackWalkTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+ * @requires vm.opt.ShowHiddenFrames == false\n","filename":"test\/jdk\/java\/lang\/StackWalker\/VerifyStackTrace.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @requires vm.opt.ShowHiddenFrames == false\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/GetStackTrace.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}