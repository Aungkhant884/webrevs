{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+import java.util.Objects;\n+import java.util.function.Predicate;\n@@ -41,0 +43,2 @@\n+import jdk.jfr.internal.consumer.ChunkParser.ParserConfiguration;\n+import jdk.jfr.internal.consumer.ParserFilter;\n@@ -46,0 +50,1 @@\n+import jdk.jfr.internal.consumer.filter.ChunkWriter;\n@@ -59,0 +64,1 @@\n+    private final ChunkWriter chunkWriter;\n@@ -80,0 +86,9 @@\n+        this.chunkWriter = null;\n+        findNext();\n+    }\n+\n+    \/\/ Only used by RecordingFile::write(Path, Predicate<RecordedEvent>)\n+    private RecordingFile(ChunkWriter chunkWriter) throws IOException {\n+        this.file = null; \/\/ not used\n+        this.input = chunkWriter.getInput();\n+        this.chunkWriter = chunkWriter;\n@@ -202,0 +217,28 @@\n+    \/**\n+     * Filter out events and write them to a new file.\n+     *\n+     * @param destination path where the new file should be written, not\n+     *                    {@code null}\n+     *\n+     * @param filter      filter that determines if an event should be included, not\n+     *                    {@code null}\n+     * @throws IOException       if an I\/O error occurred, it's not a Flight\n+     *                           Recorder file or a version of a JFR file that can't\n+     *                           be parsed\n+     *\n+     * @throws SecurityException if a security manager exists and its\n+     *                           {@code checkWrite} method denies write access to the\n+     *                           file\n+     *\/\n+    public void write(Path destination, Predicate<RecordedEvent> filter) throws IOException {\n+        Objects.requireNonNull(destination, \"destination\");\n+        Objects.requireNonNull(filter, \"filter\");\n+        try (ChunkWriter cw = new ChunkWriter(file.toPath(), destination, filter)) {\n+            try (RecordingFile rf = new RecordingFile(cw)) {\n+                while (rf.hasMoreEvents()) {\n+                    rf.readEvent();\n+                }\n+            }\n+        }\n+    }\n+\n@@ -240,1 +283,0 @@\n-\n@@ -245,1 +287,1 @@\n-                chunkParser = new ChunkParser(input, parserState);\n+                chunkParser = createChunkParser();\n@@ -247,1 +289,1 @@\n-                chunkParser = chunkParser.nextChunkParser();\n+                chunkParser = nextChunkParser();\n@@ -249,0 +291,1 @@\n+                endChunkParser();\n@@ -259,0 +302,30 @@\n+    private ChunkParser createChunkParser() throws IOException {\n+        if (chunkWriter != null) {\n+            boolean reuse = true;\n+            boolean ordered = false;\n+            ParserConfiguration pc = new ParserConfiguration(0, Long.MAX_VALUE, reuse, ordered, ParserFilter.ACCEPT_ALL, chunkWriter);\n+            ChunkParser chunkParser = new ChunkParser(chunkWriter.getInput(), pc, new ParserState());\n+            chunkWriter.beginChunk(chunkParser.getHeader());\n+            return chunkParser;\n+        } else {\n+            return new ChunkParser(input, parserState);\n+        }\n+    }\n+\n+    private void endChunkParser() throws IOException {\n+        if (chunkWriter != null) {\n+            chunkWriter.endChunk(chunkParser.getHeader());\n+        }\n+    }\n+\n+    private ChunkParser nextChunkParser() throws IOException {\n+        if (chunkWriter != null) {\n+            chunkWriter.endChunk(chunkParser.getHeader());\n+        }\n+        ChunkParser next = chunkParser.nextChunkParser();\n+        if (chunkWriter != null) {\n+            chunkWriter.beginChunk(next.getHeader());\n+        }\n+        return next;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingFile.java","additions":77,"deletions":4,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-    static final long HEADER_SIZE = 68;\n+    public static final long HEADER_SIZE = 68;\n@@ -39,1 +39,1 @@\n-    static final long CHUNK_SIZE_POSITION = 8;\n+    public static final long CHUNK_SIZE_POSITION = 8;\n@@ -95,4 +95,4 @@\n-        input.readRawLong(); \/\/ constant pool position\n-        Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, \"Chunk: constantPoolPosition=\" + constantPoolPosition);\n-        input.readRawLong(); \/\/ metadata position\n-        Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, \"Chunk: metadataPosition=\" + metadataPosition);\n+        long cp = input.readRawLong(); \/\/ constant pool position\n+        Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, \"Chunk: constantPoolPosition=\" + cp);\n+        long mp = input.readRawLong(); \/\/ metadata position\n+        Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, \"Chunk: metadataPosition=\" + mp);\n@@ -246,1 +246,1 @@\n-    public long getMetataPosition() {\n+    public long getMetadataPosition() {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ChunkHeader.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,2 @@\n+import jdk.jfr.internal.consumer.filter.CheckPointEvent;\n+import jdk.jfr.internal.consumer.filter.ChunkWriter;\n@@ -51,1 +53,1 @@\n-    static final class ParserConfiguration {\n+    public static final class ParserConfiguration {\n@@ -55,0 +57,1 @@\n+        private final ChunkWriter chunkWriter;\n@@ -59,1 +62,1 @@\n-        ParserConfiguration(long filterStart, long filterEnd, boolean reuse, boolean ordered, ParserFilter filter) {\n+        public ParserConfiguration(long filterStart, long filterEnd, boolean reuse, boolean ordered, ParserFilter filter, ChunkWriter chunkWriter) {\n@@ -65,0 +68,1 @@\n+            this.chunkWriter = chunkWriter;\n@@ -68,1 +72,1 @@\n-            this(0, Long.MAX_VALUE, false, false, ParserFilter.ACCEPT_ALL);\n+            this(0, Long.MAX_VALUE, false, false, ParserFilter.ACCEPT_ALL, null);\n@@ -116,1 +120,1 @@\n-    ChunkParser(RecordingInput input, ParserConfiguration pc, ParserState ps) throws IOException {\n+    public ChunkParser(RecordingInput input, ParserConfiguration pc, ParserState ps) throws IOException {\n@@ -122,1 +126,1 @@\n-     }\n+    }\n@@ -202,1 +206,1 @@\n-        long metadataPosition = chunkHeader.getMetataPosition();\n+        long metadataPosition = chunkHeader.getMetadataPosition();\n@@ -211,1 +215,1 @@\n-        if (chunkHeader.getMetataPosition() != metadataPosition) {\n+        if (chunkHeader.getMetadataPosition() != metadataPosition) {\n@@ -250,0 +254,10 @@\n+                    ChunkWriter chunkWriter = configuration.chunkWriter;\n+                    if (chunkWriter != null) {\n+                        if (chunkWriter.accept(event)) {\n+                            chunkWriter.writeEvent(pos, input.position());\n+                            input.position(pos);\n+                            input.readInt(); \/\/ size\n+                            input.readLong(); \/\/ type\n+                            chunkWriter.touch(ep.parseReferences(input));\n+                        }\n+                    }\n@@ -306,0 +320,4 @@\n+            CheckPointEvent cp = null;\n+            if (configuration.chunkWriter != null) {\n+                cp = configuration.chunkWriter.newCheckPointEvent(thisCP);\n+            }\n@@ -336,1 +354,1 @@\n-                    ConstantMap pool = new ConstantMap(ObjectFactory.create(type, timeConverter), type.getName());\n+                    ConstantMap pool = new ConstantMap(ObjectFactory.create(type, timeConverter), type);\n@@ -353,0 +371,1 @@\n+                        long position = input.position();\n@@ -364,0 +383,6 @@\n+                        if (cp != null) {\n+                            input.position(position);\n+                            input.readLong();\n+                            Object refs = parser.parseReferences(input);\n+                            cp.addEntry(type, key, position, input.position(), refs);\n+                        }\n@@ -439,1 +464,1 @@\n-    ChunkParser newChunkParser() throws IOException {\n+    public ChunkParser newChunkParser() throws IOException {\n@@ -491,0 +516,4 @@\n+\n+    public ChunkHeader getHeader() {\n+        return chunkHeader;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ChunkParser.java","additions":39,"deletions":10,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.consumer;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+\n+public final class CompositeParser extends Parser {\n+    final Parser[] parsers;\n+\n+    public CompositeParser(Parser[] valueParsers) {\n+        this.parsers = valueParsers;\n+    }\n+\n+    @Override\n+    public Object parse(RecordingInput input) throws IOException {\n+        final Object[] values = new Object[parsers.length];\n+        for (int i = 0; i < values.length; i++) {\n+            values[i] = parsers[i].parse(input);\n+        }\n+        return values;\n+    }\n+\n+    @Override\n+    public void skip(RecordingInput input) throws IOException {\n+        for (int i = 0; i < parsers.length; i++) {\n+            parsers[i].skip(input);\n+        }\n+    }\n+\n+    @Override\n+    public Object parseReferences(RecordingInput input) throws IOException {\n+        return parseReferences(input, parsers);\n+    }\n+\n+    static Object parseReferences(RecordingInput input, Parser[] parsers) throws IOException {\n+        ArrayList<Object> refs = new ArrayList<>(parsers.length);\n+        for (int i = 0; i < parsers.length; i++) {\n+            Object ref = parsers[i].parseReferences(input);\n+            if (ref != null) {\n+                refs.add(ref);\n+            }\n+        }\n+        if (refs.isEmpty()) {\n+            return null;\n+        }\n+        if (refs.size() == 1) {\n+            return refs.get(0);\n+        }\n+        return refs.toArray();\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/CompositeParser.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-    private final Type type;\n+    final Type type;\n@@ -50,1 +50,1 @@\n-        current = new ConstantMap(current.factory, current.name);\n+        current = new ConstantMap(current.factory, current.type);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ConstantLookup.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import jdk.jfr.internal.Type;\n@@ -41,1 +42,0 @@\n-\n@@ -46,23 +46,0 @@\n-    \/\/ A temporary placeholder, so objects can\n-    \/\/ reference themselves (directly, or indirectly),\n-    \/\/ when making a transition from numeric id references\n-    \/\/ to normal Java references.\n-    private static final class Reference {\n-        private final long key;\n-        private final ConstantMap pool;\n-\n-        Reference(ConstantMap pool, long key) {\n-            this.pool = pool;\n-            this.key = key;\n-        }\n-\n-        Object resolve() {\n-            return pool.get(key);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"ref: \" + pool.name + \"[\" + key + \"]\";\n-        }\n-    }\n-\n@@ -70,2 +47,1 @@\n-    final String name;\n-\n+    final Type type;\n@@ -73,1 +49,0 @@\n-\n@@ -78,1 +53,1 @@\n-        this(null, \"<empty>\");\n+        this(null, null);\n@@ -82,2 +57,2 @@\n-    ConstantMap(ObjectFactory<?> factory, String name) {\n-        this.name = name;\n+    ConstantMap(ObjectFactory<?> factory, Type type) {\n+        this.type = type;\n@@ -103,1 +78,1 @@\n-                Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, \"Missing object id=\" + id + \" in pool \" + name + \". All ids should reference an object\");\n+                Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, \"Missing object id=\" + id + \" in pool \" + getName() + \". All ids should reference an object\");\n@@ -177,1 +152,6 @@\n-        return name;\n+        return type == null ? \"<empty>\" : type.getName();\n+    }\n+\n+    \/\/ Can be null\n+    public Type getType() {\n+        return type;\n@@ -192,0 +172,4 @@\n+\n+    public LongMap<Object> getObjects() {\n+       return objects;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ConstantMap.java","additions":17,"deletions":33,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-        this.parserConfiguration = new ParserConfiguration(0, Long.MAX_VALUE, c.reuse, c.ordered, buildFilter(dispatchers));\n+        this.parserConfiguration = new ParserConfiguration(0, Long.MAX_VALUE, c.reuse, c.ordered, buildFilter(dispatchers), null);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/Dispatcher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.util.ArrayList;\n@@ -32,0 +33,1 @@\n+import java.util.function.Predicate;\n@@ -157,0 +159,5 @@\n+    @Override\n+    public Object parseReferences(RecordingInput input) throws IOException {\n+        return CompositeParser.parseReferences(input, parsers);\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventParser.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-     * @return an object\n+     * @return an {@code Object}, an {@code Object[]}, or {@code null}\n@@ -44,0 +44,16 @@\n+    \/**\n+     * Parses data from a {@link RecordingInput} to find references to constants. If\n+     * data is not a reference, {@code null} is returned.\n+     * <p>\n+     * @implSpec The default implementation of this method skips data and returns\n+     * {@code Object}.\n+     *\n+     * @param input input to read from, not {@code null}\n+     * @return a {@code Reference}, a {@code Reference[]}, or {@code null}\n+     * @throws IOException if operation couldn't be completed due to I\/O problems\n+     *\/\n+    public Object parseReferences(RecordingInput input) throws IOException {\n+        skip(input);\n+        return null;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/Parser.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-                ConstantMap pool = new ConstantMap(ObjectFactory.create(type, timeConverter), type.getName());\n+                ConstantMap pool = new ConstantMap(ObjectFactory.create(type, timeConverter), type);\n@@ -143,1 +143,1 @@\n-            ConstantMap pool = new ConstantMap(ObjectFactory.create(type, timeConverter), type.getName());\n+            ConstantMap pool = new ConstantMap(ObjectFactory.create(type, timeConverter), type);\n@@ -307,1 +307,1 @@\n-        public void skip(RecordingInput input) throws IOException {\n+        public Object parseReferences(RecordingInput input) throws IOException {\n@@ -309,0 +309,1 @@\n+            final Object[] array = new Object[size];\n@@ -310,17 +311,1 @@\n-                elementParser.skip(input);\n-            }\n-        }\n-    }\n-\n-    private static final class CompositeParser extends Parser {\n-        private final Parser[] parsers;\n-\n-        public CompositeParser(Parser[] valueParsers) {\n-            this.parsers = valueParsers;\n-        }\n-\n-        @Override\n-        public Object parse(RecordingInput input) throws IOException {\n-            final Object[] values = new Object[parsers.length];\n-            for (int i = 0; i < values.length; i++) {\n-                values[i] = parsers[i].parse(input);\n+                array[i] = elementParser.parse(input);\n@@ -328,1 +313,1 @@\n-            return values;\n+            return array;\n@@ -333,2 +318,3 @@\n-            for (int i = 0; i < parsers.length; i++) {\n-                parsers[i].skip(input);\n+            final int size = input.readInt();\n+            for (int i = 0; i < size; i++) {\n+                elementParser.skip(input);\n@@ -343,0 +329,2 @@\n+        private Object lastReferenceValue;\n+        private long lastReferenceKey = -1;\n@@ -362,0 +350,11 @@\n+\n+        @Override\n+        public Object parseReferences(RecordingInput input) throws IOException {\n+            long key = input.readLong();\n+            if (key == lastReferenceKey) {\n+                return lastReferenceValue;\n+            }\n+            lastReferenceKey = key;\n+            lastReferenceValue = new Reference(lookup.getLatestPool(), key);\n+            return lastReferenceValue;\n+        }\n@@ -379,0 +378,5 @@\n+\n+        @Override\n+        public Object parseReferences(RecordingInput input) throws IOException {\n+            return new Reference(lookup.getLatestPool(), input.readLong());\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ParserFactory.java","additions":28,"deletions":24,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-final class ParserFilter {\n+public final class ParserFilter {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ParserFilter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.consumer;\n+\n+import jdk.jfr.internal.Type;\n+\n+\/**\n+ * A temporary placeholder, so objects can reference themselves (directly, or\n+ * indirectly), when making a transition from numeric id references to Java\n+ * object references.\n+ *\/\n+public record Reference(ConstantMap pool, long key) {\n+\n+    Object resolve() {\n+        return pool.get(key);\n+    }\n+\n+    public Type type() {\n+        return pool.getType();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"ref: \" + pool.getName() + \"[\" + key + \"]\";\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/Reference.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -223,0 +223,27 @@\n+\n+    @Override\n+    public Object parseReferences(RecordingInput input) throws IOException {\n+        byte encoding = input.readByte();\n+        if (Encoding.CONSTANT_POOL.is(encoding)) {\n+            return new Reference(stringLookup.getLatestPool(), input.readLong());\n+        }\n+        if (Encoding.EMPTY_STRING.is(encoding)) {\n+            return null;\n+        }\n+        if (Encoding.NULL.is(encoding)) {\n+            return null;\n+        }\n+        if (Encoding.CHAR_ARRAY.is(encoding)) {\n+            charArrayParser.skip(input);\n+            return null;\n+        }\n+        if (Encoding.UT8_BYTE_ARRAY.is(encoding)) {\n+            utf8parser.skip(input);\n+            return null;\n+        }\n+        if (Encoding.LATIN1_BYTE_ARRAY.is(encoding)) {\n+            latin1parser.skip(input);\n+            return null;\n+        }\n+        throw new IOException(\"Unknown string encoding \" + encoding);\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/StringParser.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.consumer.filter;\n+\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+\n+import jdk.jfr.internal.Type;\n+\n+\/**\n+ * Represents a checkpoint event.\n+ * <p>\n+ * All positional values are relative to file start, not the chunk.\n+ *\/\n+public final class CheckPointEvent {\n+    private final ChunkWriter chunkWriter;\n+    private final LinkedHashMap<Long, CheckPointPool> pools = new LinkedHashMap<>();\n+    private final long startPosition;\n+\n+    public CheckPointEvent(ChunkWriter chunkWriter, long startPosition) {\n+        this.chunkWriter = chunkWriter;\n+        this.startPosition = startPosition;\n+    }\n+\n+    public PoolEntry addEntry(Type type, long id, long startPosition, long endPosition, Object references) {\n+        long typeId = type.getId();\n+        PoolEntry pe = new PoolEntry(startPosition, endPosition, type, id, references);\n+        var cpp = pools.computeIfAbsent(typeId, k -> new CheckPointPool(typeId));\n+        cpp.add(pe);\n+        chunkWriter.getPool(type).add(id, pe);\n+        return pe;\n+    }\n+\n+    public long touchedPools() {\n+        int count = 0;\n+        for (CheckPointPool cpp : pools.values()) {\n+            if (cpp.isTouched()) {\n+                count++;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    public Collection<CheckPointPool> getPools() {\n+        return pools.values();\n+    }\n+\n+    public long getStartPosition() {\n+        return startPosition;\n+    }\n+\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        for (CheckPointPool p : pools.values()) {\n+            for (var e : p.getEntries()) {\n+                if (e.isTouched()) {\n+                    sb.append(e.getType().getName() + \" \" + e.getId() + \"\\n\");\n+                }\n+            }\n+        }\n+        return sb.toString();\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/filter\/CheckPointEvent.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.consumer.filter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\/**\n+ * Represents a constant pool in a checkpoint, both entries and type id\n+ *\/\n+final class CheckPointPool {\n+    private final List<PoolEntry> entries = new ArrayList<>();\n+    private final long typeId;\n+\n+    public CheckPointPool(long typeId) {\n+        this.typeId = typeId;\n+    }\n+\n+    public boolean isTouched() {\n+        for (var entry : entries) {\n+            if (entry.isTouched()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public long getTouchedCount() {\n+        int count = 0;\n+        for (var entry : entries) {\n+            if (entry.isTouched()) {\n+                count++;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    public void add(PoolEntry pe) {\n+        entries.add(pe);\n+    }\n+\n+    public long getTypeId() {\n+        return typeId;\n+    }\n+\n+    public List<PoolEntry> getEntries() {\n+        return entries;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/filter\/CheckPointPool.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,239 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.consumer.filter;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.function.Predicate;\n+\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.internal.LongMap;\n+import jdk.jfr.internal.Type;\n+import jdk.jfr.internal.consumer.ChunkHeader;\n+import jdk.jfr.internal.consumer.FileAccess;\n+import jdk.jfr.internal.Logger;\n+import jdk.jfr.internal.LogLevel;\n+import jdk.jfr.internal.LogTag;\n+import jdk.jfr.internal.consumer.RecordingInput;\n+import jdk.jfr.internal.consumer.Reference;\n+\n+\/**\n+ * Class that can filter out events and associated constants from a recording\n+ * file.\n+ * <p>\n+ * All positional values are relative to file start, not the chunk.\n+ *\/\n+public final class ChunkWriter implements Closeable {\n+    private LongMap<Constants> pools = new LongMap<>();\n+    private final Deque<CheckPointEvent> checkPoints = new ArrayDeque<>();\n+    private final Path destination;\n+    private final RecordingInput input;\n+    private final RecordingOutput output;\n+    private final Predicate<RecordedEvent> filter;\n+\n+    private long chunkStartPosition;\n+    private boolean chunkComplete;\n+    private long lastCheckPoint;\n+\n+    public ChunkWriter(Path source, Path destination, Predicate<RecordedEvent> filter) throws IOException {\n+        this.destination = destination;\n+        this.output = new RecordingOutput(destination.toFile());\n+        this.input = new RecordingInput(source.toFile(), FileAccess.UNPRIVILEGED);\n+        this.filter = filter;\n+    }\n+\n+    Constants getPool(Type type) {\n+        long typeId = type.getId();\n+        Constants pool = pools.get(typeId);\n+        if (pool == null) {\n+            pool = new Constants(type);\n+            pools.put(typeId, pool);\n+        }\n+        return pool;\n+    }\n+\n+    public CheckPointEvent newCheckPointEvent(long startPosition) {\n+        CheckPointEvent event = new CheckPointEvent(this, startPosition);\n+        checkPoints.add(event);\n+        return event;\n+    }\n+\n+    public boolean accept(RecordedEvent event) {\n+        return filter.test(event);\n+    }\n+\n+    public void touch(Object object) {\n+        if (object instanceof Object[] array) {\n+            for (int i = 0; i < array.length; i++) {\n+                touch(array[i]);\n+            }\n+            return;\n+        }\n+        if (object instanceof Reference ref) {\n+            touchRef(ref);\n+        }\n+    }\n+\n+    private void touchRef(Reference ref) {\n+        Constants pool = pools.get(ref.type().getId());\n+        if (pool == null) {\n+            String msg = \"Can't resolve \" + ref.type().getName() + \"[\" + ref.key() + \"]\";\n+            Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.DEBUG, msg);\n+            return;\n+        }\n+        PoolEntry entry = pool.get(ref.key());\n+        if (entry != null && !entry.isTouched()) {\n+            entry.touch();\n+            touch(entry.getReferences());\n+        }\n+    }\n+    public void writeEvent(long startPosition, long endPosition) throws IOException {\n+        writeCheckpointEvents(startPosition);\n+        write(startPosition, endPosition);\n+    }\n+\n+    \/\/ Write check point events before a position\n+    private void writeCheckpointEvents(long before) throws IOException {\n+        CheckPointEvent cp = checkPoints.peek();\n+        while (cp != null && cp.getStartPosition() < before) {\n+            checkPoints.poll();\n+            long delta = 0;\n+            if (lastCheckPoint != 0) {\n+                delta = lastCheckPoint - output.position();\n+            }\n+            lastCheckPoint = output.position();\n+            write(cp, delta);\n+            cp = checkPoints.peek();\n+        }\n+    }\n+\n+    public void write(long startPosition, long endPosition) throws IOException {\n+        if (endPosition < startPosition) {\n+            throw new IOException(\"Start position must come before end position, start=\" + startPosition + \", end=\" + endPosition);\n+        }\n+        long backup = input.position();\n+        input.position(startPosition);\n+        long n = endPosition - startPosition;\n+        for (long i = 0; i < n; i++) {\n+            output.writeByte(input.readByte());\n+        }\n+        input.position(backup);\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        try {\n+            output.close();\n+        } finally {\n+            if (!chunkComplete) {\n+                \/\/ Error occurred, clean up\n+                if (Files.exists(destination)) {\n+                    Files.delete(destination);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void beginChunk(ChunkHeader header) throws IOException {\n+        this.chunkComplete = false;\n+        this.chunkStartPosition = output.position();\n+        input.position(header.getAbsoluteChunkStart());\n+        for (int i = 0; i < ChunkHeader.HEADER_SIZE; i++) {\n+            output.writeByte(input.readByte());\n+        }\n+    }\n+\n+    public void endChunk(ChunkHeader header) throws IOException {\n+        \/\/ write all outstanding checkpoints\n+        writeCheckpointEvents(Long.MAX_VALUE);\n+        long metadata = output.position();\n+        writeMetadataEvent(header);\n+        updateHeader(output.position(), lastCheckPoint, metadata);\n+        pools = new LongMap<>();\n+        chunkComplete = true;\n+        lastCheckPoint = 0;\n+    }\n+\n+    private void writeMetadataEvent(ChunkHeader header) throws IOException {\n+        long metadataposition = header.getMetadataPosition() + header.getAbsoluteChunkStart();\n+        input.position(metadataposition);\n+        long size = input.readLong();\n+        input.position(metadataposition);\n+        for (int i = 0; i < size; i++) {\n+            output.writeByte(input.readByte());\n+        }\n+    }\n+\n+    private void write(CheckPointEvent event, long delta) throws IOException {\n+        input.position(event.getStartPosition());\n+        long startPosition = output.position();\n+\n+        input.readLong(); \/\/ Read size\n+        output.writePaddedUnsignedInt(0); \/\/ Size, 4 bytes reserved\n+        output.writeLong(input.readLong()); \/\/ Constant pool id\n+        output.writeLong(input.readLong()); \/\/ Start time\n+        output.writeLong(input.readLong()); \/\/ Duration\n+        input.readLong(); \/\/ Read delta\n+        output.writeLong(delta); \/\/ Delta\n+        output.writeByte(input.readByte()); \/\/ flush marker\n+\n+        \/\/ Write even if touched pools are zero, checkpoint works as sync point\n+        output.writeLong(event.touchedPools()); \/\/ Pool count\n+        for (CheckPointPool pool : event.getPools()) {\n+            if (pool.isTouched()) {\n+                output.writeLong(pool.getTypeId());\n+                output.writeLong(pool.getTouchedCount());\n+                for (PoolEntry pe : pool.getEntries()) {\n+                    if (pe.isTouched()) {\n+                        write(pe.getStartPosition(), pe.getEndPosition()); \/\/ key + value\n+                    }\n+                }\n+            }\n+        }\n+        long endPosition = output.position();\n+        long size = endPosition - startPosition;\n+        output.position(startPosition);\n+        output.writePaddedUnsignedInt(size);\n+        output.position(endPosition);\n+    }\n+\n+    private void updateHeader(long size, long constantPosition, long metadataPosition) throws IOException {\n+        long backup = output.position();\n+        output.position(ChunkHeader.CHUNK_SIZE_POSITION + chunkStartPosition);\n+        \/\/ Write chunk relative values\n+        output.writeRawLong(size - chunkStartPosition);\n+        output.writeRawLong(constantPosition - chunkStartPosition);\n+        output.writeRawLong(metadataPosition - chunkStartPosition);\n+        output.position(backup);\n+    }\n+\n+    public RecordingInput getInput() {\n+        return input;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/filter\/ChunkWriter.java","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.consumer.filter;\n+\n+import jdk.jfr.internal.LongMap;\n+import jdk.jfr.internal.Type;\n+\n+\/**\n+ * Holds the chunk global state of constants\n+ *\/\n+final class Constants {\n+    private final LongMap<PoolEntry> table = new LongMap<>();\n+    private final Type type;\n+\n+    public Constants(Type type) {\n+        this.type = type;\n+    }\n+\n+    public void add(long key, PoolEntry entry) {\n+        table.put(key, entry);\n+    }\n+\n+    public PoolEntry get(long key) {\n+        return table.get(key);\n+    }\n+\n+    public String toString() {\n+        return \"Pool: \" + type.getName() + \" size = \" + table.size();\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/filter\/Constants.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.consumer.filter;\n+\n+import jdk.jfr.internal.Type;\n+\n+\/**\n+ * Represents the binary content of constant pool, both key and value.\n+ * <p>\n+ * All positional values are relative to file start, not the chunk.\n+ *\/\n+final class PoolEntry {\n+    private final long startPosition;\n+    private final long endPosition;\n+    private final Type type;\n+    private final long keyId;\n+    private final Object references;\n+\n+    private boolean touched;\n+\n+    PoolEntry(long startPosition, long endPosition, Type type, long keyId, Object references) {\n+        this.startPosition = startPosition;\n+        this.endPosition = endPosition;\n+        this.type = type;\n+        this.keyId = keyId;\n+        this.references = references;\n+    }\n+\n+    public void touch() {\n+        this.touched = true;\n+    }\n+\n+    public boolean isTouched() {\n+        return touched;\n+    }\n+\n+    public Object getReferences() {\n+        return references;\n+    }\n+\n+    public long getStartPosition() {\n+        return startPosition;\n+    }\n+\n+    public long getEndPosition() {\n+        return endPosition;\n+    }\n+\n+    public Type getType() {\n+        return type;\n+    }\n+\n+    public long getId() {\n+        return keyId;\n+    }\n+\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"start: \").append(startPosition).append(\"\\n\");\n+        sb.append(\"end: \").append(endPosition).append(\"\\n\");\n+        sb.append(\"type: \").append(type).append(\" (\").append(type.getId()).append(\")\\n\");\n+        sb.append(\"key: \").append(keyId).append(\"\\n\");\n+        sb.append(\"object: \").append(references).append(\"\\n\");\n+        return sb.toString();\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/filter\/PoolEntry.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.consumer.filter;\n+\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+\n+\/**\n+ * Write cache and LEB128 encoder\n+ *\/\n+final class RecordingOutput implements Closeable {\n+    private final RandomAccessFile file;\n+    private final byte[] buffer = new byte[16384];\n+    private int bufferPosition;\n+    private long position;\n+\n+    public RecordingOutput(File file) throws IOException {\n+        this.file = new RandomAccessFile(file, \"rw\");\n+    }\n+\n+    public void writeByte(byte value) throws IOException {\n+        if (!(bufferPosition < buffer.length)) {\n+            flush();\n+        }\n+        buffer[bufferPosition++] = value;\n+        position++;\n+    }\n+\n+    public void writeRawLong(long v) throws IOException {\n+        writeByte((byte) ((v >> 56) & 0xff));\n+        writeByte((byte) ((v >> 48) & 0xff));\n+        writeByte((byte) ((v >> 40) & 0xff));\n+        writeByte((byte) ((v >> 32) & 0xff));\n+        writeByte((byte) ((v >> 24) & 0xff));\n+        writeByte((byte) ((v >> 16) & 0xff));\n+        writeByte((byte) ((v >> 8) & 0xff));\n+        writeByte((byte) ((v) & 0xff));\n+    }\n+\n+    public void writePaddedUnsignedInt(long value) throws IOException {\n+        if (value < 0) {\n+            throw new IOException(\"Padded value can't be negative\");\n+        }\n+        if (value >= 1 << 28) {\n+            throw new IOException(\"Padded value must fit four bytes\");\n+        }\n+        byte b0 = (byte) (value | 0x80);\n+        byte b1 = (byte) (value >> 7 | 0x80);\n+        byte b2 = (byte) (value >> 14 | 0x80);\n+        byte b3 = (byte) (value >> 21);\n+        writeByte(b0);\n+        writeByte(b1);\n+        writeByte(b2);\n+        writeByte(b3);\n+    }\n+\n+    \/\/ Essentially copied from EventWriter#putLong\n+    public void writeLong(long v) throws IOException {\n+        if ((v & ~0x7FL) == 0L) {\n+            writeByte((byte) v); \/\/ 0-6\n+            return;\n+        }\n+        writeByte((byte) (v | 0x80L)); \/\/ 0-6\n+        v >>>= 7;\n+        if ((v & ~0x7FL) == 0L) {\n+            writeByte((byte) v); \/\/ 7-13\n+            return;\n+        }\n+        writeByte((byte) (v | 0x80L)); \/\/ 7-13\n+        v >>>= 7;\n+        if ((v & ~0x7FL) == 0L) {\n+            writeByte((byte) v); \/\/ 14-20\n+            return;\n+        }\n+        writeByte((byte) (v | 0x80L)); \/\/ 14-20\n+        v >>>= 7;\n+        if ((v & ~0x7FL) == 0L) {\n+            writeByte((byte) v); \/\/ 21-27\n+            return;\n+        }\n+        writeByte((byte) (v | 0x80L)); \/\/ 21-27\n+        v >>>= 7;\n+        if ((v & ~0x7FL) == 0L) {\n+            writeByte((byte) v); \/\/ 28-34\n+            return;\n+        }\n+        writeByte((byte) (v | 0x80L)); \/\/ 28-34\n+        v >>>= 7;\n+        if ((v & ~0x7FL) == 0L) {\n+            writeByte((byte) v); \/\/ 35-41\n+            return;\n+        }\n+        writeByte((byte) (v | 0x80L)); \/\/ 35-41\n+        v >>>= 7;\n+        if ((v & ~0x7FL) == 0L) {\n+            writeByte((byte) v); \/\/ 42-48\n+            return;\n+        }\n+        writeByte((byte) (v | 0x80L)); \/\/ 42-48\n+        v >>>= 7;\n+\n+        if ((v & ~0x7FL) == 0L) {\n+            writeByte((byte) v); \/\/ 49-55\n+            return;\n+        }\n+        writeByte((byte) (v | 0x80L)); \/\/ 49-55\n+        writeByte((byte) (v >>> 7)); \/\/ 56-63, last byte as is.\n+    }\n+\n+    public void position(long pos) throws IOException {\n+        flush();\n+        position = pos;\n+        file.seek(position);\n+    }\n+\n+    public long position() throws IOException {\n+        return position;\n+    }\n+\n+    public void flush() throws IOException {\n+        file.write(buffer, 0, bufferPosition);\n+        bufferPosition = 0;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        flush();\n+        file.close();\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/filter\/RecordingOutput.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-import java.util.HashMap;\n@@ -43,5 +42,0 @@\n-import java.util.Map;\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n-\n-import jdk.jfr.EventType;\n@@ -59,0 +53,1 @@\n+        commands.add(new Scrub());\n@@ -290,0 +285,4 @@\n+    protected static char quoteCharacter() {\n+        return File.pathSeparatorChar == ';' ? '\"' : '\\'';\n+    }\n+\n@@ -302,0 +301,6 @@\n+    public static void checkCommonError(Deque<String> options, String typo, String correct) throws UserSyntaxException {\n+        if (typo.equals(options.peek())) {\n+            throw new UserSyntaxException(\"unknown option \" + typo + \", did you mean \" + correct + \"?\");\n+        }\n+    }\n+\n@@ -322,103 +327,0 @@\n-    public static void checkCommonError(Deque<String> options, String typo, String correct) throws UserSyntaxException {\n-        if (typo.equals(options.peek())) {\n-            throw new UserSyntaxException(\"unknown option \" + typo + \", did you mean \" + correct + \"?\");\n-        }\n-    }\n-\n-    protected static final char quoteCharacter() {\n-        return File.pathSeparatorChar == ';' ? '\"' : '\\'';\n-    }\n-\n-    private static <T> Predicate<T> recurseIfPossible(Predicate<T> filter) {\n-        return x -> filter != null && filter.test(x);\n-    }\n-\n-    private static String acronomify(String multipleWords) {\n-        boolean newWord = true;\n-        String acronym = \"\";\n-        for (char c : multipleWords.toCharArray()) {\n-            if (newWord) {\n-                if (Character.isAlphabetic(c) && Character.isUpperCase(c)) {\n-                    acronym += c;\n-                }\n-            }\n-            newWord = Character.isWhitespace(c);\n-        }\n-        return acronym;\n-    }\n-\n-    private static boolean match(String text, String filter) {\n-        if (filter.length() == 0) {\n-            \/\/ empty filter string matches if string is empty\n-            return text.length() == 0;\n-        }\n-        if (filter.charAt(0) == '*') { \/\/ recursive check\n-            filter = filter.substring(1);\n-            for (int n = 0; n <= text.length(); n++) {\n-                if (match(text.substring(n), filter))\n-                    return true;\n-            }\n-        } else if (text.length() == 0) {\n-            \/\/ empty string and non-empty filter does not match\n-            return false;\n-        } else if (filter.charAt(0) == '?') {\n-            \/\/ eat any char and move on\n-            return match(text.substring(1), filter.substring(1));\n-        } else if (filter.charAt(0) == text.charAt(0)) {\n-            \/\/ eat chars and move on\n-            return match(text.substring(1), filter.substring(1));\n-        }\n-        return false;\n-    }\n-\n-    private static List<String> explodeFilter(String filter) throws UserSyntaxException {\n-        List<String> list = new ArrayList<>();\n-        for (String s : filter.split(\",\")) {\n-            s = s.trim();\n-            if (!s.isEmpty()) {\n-                list.add(s);\n-            }\n-        }\n-        return list;\n-    }\n-\n-    protected static final Predicate<EventType> addCategoryFilter(String filterText, Predicate<EventType> eventFilter) throws UserSyntaxException {\n-        List<String> filters = explodeFilter(filterText);\n-        Predicate<EventType> newFilter = recurseIfPossible(eventType -> {\n-            for (String category : eventType.getCategoryNames()) {\n-                for (String filter : filters) {\n-                    if (match(category, filter)) {\n-                        return true;\n-                    }\n-                    if (category.contains(\" \") && acronomify(category).equals(filter)) {\n-                        return true;\n-                    }\n-                }\n-            }\n-            return false;\n-        });\n-        return eventFilter == null ? newFilter : eventFilter.or(newFilter);\n-    }\n-\n-    protected static final Predicate<EventType> addEventFilter(String filterText, final Predicate<EventType> eventFilter) throws UserSyntaxException {\n-        List<String> filters = explodeFilter(filterText);\n-        Predicate<EventType> newFilter = recurseIfPossible(eventType -> {\n-            for (String filter : filters) {\n-                String fullEventName = eventType.getName();\n-                if (match(fullEventName, filter)) {\n-                    return true;\n-                }\n-                String eventName = fullEventName.substring(fullEventName.lastIndexOf(\".\") + 1);\n-                if (match(eventName, filter)) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        });\n-        return eventFilter == null ? newFilter : eventFilter.or(newFilter);\n-    }\n-\n-    protected static final <T, X> Predicate<T> addCache(final Predicate<T> filter, Function<T, X> cacheFunction) {\n-        Map<X, Boolean> cache = new HashMap<>();\n-        return t -> cache.computeIfAbsent(cacheFunction.apply(t), x -> filter.test(t));\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Command.java","additions":12,"deletions":110,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.tool;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import jdk.jfr.EventType;\n+import jdk.jfr.consumer.RecordedThread;\n+import jdk.jfr.consumer.RecordedEvent;\n+\n+\/**\n+ * Helper class for creating filters.\n+ *\/\n+public class Filters {\n+    private static final Predicate<RecordedThread> FALSE_THREAD_PREDICATE = e -> false;\n+\n+    static Predicate<EventType> createCategoryFilter(String filterText) throws UserSyntaxException {\n+        List<String> filters = explodeFilter(filterText);\n+        Predicate<EventType> f = eventType -> {\n+            for (String category : eventType.getCategoryNames()) {\n+                for (String filter : filters) {\n+                    if (match(category, filter)) {\n+                        return true;\n+                    }\n+                    if (category.contains(\" \") && acronymify(category).equals(filter)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        };\n+        return createCache(f, EventType::getId);\n+    }\n+\n+    static Predicate<EventType> createEventTypeFilter(String filterText) throws UserSyntaxException {\n+        List<String> filters = explodeFilter(filterText);\n+        Predicate<EventType> f = eventType -> {\n+            for (String filter : filters) {\n+                String fullEventName = eventType.getName();\n+                if (match(fullEventName, filter)) {\n+                    return true;\n+                }\n+                String eventName = fullEventName.substring(fullEventName.lastIndexOf(\".\") + 1);\n+                if (match(eventName, filter)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        };\n+        return createCache(f, EventType::getId);\n+    }\n+\n+    public static <T> Predicate<T> matchAny(List<Predicate<T>> filters) {\n+        if (filters.isEmpty()) {\n+            return t -> true;\n+        }\n+        if (filters.size() == 1) {\n+            return filters.get(0);\n+        }\n+        return t -> {\n+            for (Predicate<T> p : filters) {\n+                if (!p.test(t)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        };\n+    }\n+\n+    static Predicate<RecordedEvent> fromEventType(Predicate<EventType> filter) {\n+        return e -> filter.test(e.getEventType());\n+    }\n+\n+    static Predicate<RecordedEvent> fromRecordedThread(Predicate<RecordedThread> filter) {\n+        Predicate<RecordedThread> cachePredicate = createCache(filter, RecordedThread::getId);\n+        return event -> {\n+            RecordedThread t = event.getThread();\n+            if (t == null || t.getJavaName() == null) {\n+                return false;\n+            }\n+            return cachePredicate.test(t);\n+        };\n+    }\n+\n+    static Predicate<RecordedThread> createThreadFilter(String filterText) throws UserSyntaxException {\n+        List<String> filters = explodeFilter(filterText);\n+        return thread -> {\n+            String threadName = thread.getJavaName();\n+            for (String filter : filters) {\n+                if (match(threadName, filter)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private static final <T, X> Predicate<T> createCache(final Predicate<T> filter, Function<T, X> cacheFunction) {\n+        Map<X, Boolean> cache = new HashMap<>();\n+        return t -> cache.computeIfAbsent(cacheFunction.apply(t), x -> filter.test(t));\n+    }\n+\n+    private static String acronymify(String multipleWords) {\n+        boolean newWord = true;\n+        String acronym = \"\";\n+        for (char c : multipleWords.toCharArray()) {\n+            if (newWord) {\n+                if (Character.isAlphabetic(c) && Character.isUpperCase(c)) {\n+                    acronym += c;\n+                }\n+            }\n+            newWord = Character.isWhitespace(c);\n+        }\n+        return acronym;\n+    }\n+\n+    private static boolean match(String text, String filter) {\n+        if (filter.length() == 0) {\n+            \/\/ empty filter string matches if string is empty\n+            return text.length() == 0;\n+        }\n+        if (filter.charAt(0) == '*') { \/\/ recursive check\n+            filter = filter.substring(1);\n+            for (int n = 0; n <= text.length(); n++) {\n+                if (match(text.substring(n), filter))\n+                    return true;\n+            }\n+        } else if (text.length() == 0) {\n+            \/\/ empty string and non-empty filter does not match\n+            return false;\n+        } else if (filter.charAt(0) == '?') {\n+            \/\/ eat any char and move on\n+            return match(text.substring(1), filter.substring(1));\n+        } else if (filter.charAt(0) == text.charAt(0)) {\n+            \/\/ eat chars and move on\n+            return match(text.substring(1), filter.substring(1));\n+        }\n+        return false;\n+    }\n+\n+    private static List<String> explodeFilter(String filter) throws UserSyntaxException {\n+        List<String> list = new ArrayList<>();\n+        for (String s : filter.split(\",\")) {\n+            s = s.trim();\n+            if (!s.isEmpty()) {\n+                list.add(s);\n+            }\n+        }\n+        return list;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Filters.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-            char q = Print.quoteCharacter();\n+            char q = Command.quoteCharacter();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Main.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -166,0 +166,1 @@\n+        List<Predicate<EventType>> filters = new ArrayList<>();\n@@ -180,1 +181,1 @@\n-                filter = addEventFilter(filterStr, filter);\n+                filters.add(Filters.createEventTypeFilter(filterStr));\n@@ -189,1 +190,1 @@\n-                filter = addCategoryFilter(filterStr, filter);\n+                filters.add(Filters.createCategoryFilter(filterStr));\n@@ -203,2 +204,2 @@\n-            if (filter != null) {\n-                filter = addCache(filter, type -> type.getId());\n+            if (!filters.isEmpty()) {\n+                filter =  Filters.matchAny(filters);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Metadata.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,1 @@\n-        Predicate<EventType> eventFilter = null;\n+        List<Predicate<EventType>> eventFilters = new ArrayList<>();\n@@ -119,1 +119,1 @@\n-                eventFilter = addEventFilter(filter, eventFilter);\n+                eventFilters.add(Filters.createEventTypeFilter(filter));\n@@ -128,1 +128,1 @@\n-                eventFilter = addCategoryFilter(filter, eventFilter);\n+                eventFilters.add(Filters.createCategoryFilter(filter));\n@@ -159,3 +159,2 @@\n-        if (eventFilter != null) {\n-            eventFilter = addCache(eventFilter, eventType -> eventType.getId());\n-            eventWriter.setEventFilter(eventFilter);\n+        if (!eventFilters.isEmpty()) {\n+            eventWriter.setEventFilter(Filters.matchAny(eventFilters));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Print.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.tool;\n+\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.function.Predicate;\n+\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingFile;\n+\n+final class Scrub extends Command {\n+\n+    @Override\n+    public String getName() {\n+        return \"scrub\";\n+    }\n+\n+    @Override\n+    public List<String> getOptionSyntax() {\n+        List<String> list = new ArrayList<>();\n+        list.add(\"[--include-events <filter>]\");\n+        list.add(\"[--exclude-events <filter>]\");\n+        list.add(\"[--include-categories <filter>]\");\n+        list.add(\"[--exclude-categories <filter>]\");\n+        list.add(\"[--include-threads <filter>]\");\n+        list.add(\"[--exclude-threads <filter>]\");\n+        list.add(\"<input-file>\");\n+        list.add(\"[<output-file>]\");\n+        return list;\n+    }\n+\n+    @Override\n+    protected String getTitle() {\n+        return \"Scrub contents of a recording file\";\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return getTitle() + \". See 'jfr help scrub' for details.\";\n+    }\n+\n+    @Override\n+    public void displayOptionUsage(PrintStream stream) {\n+        \/\/ 01234567890123456789012345678901234567890123467890123456789012345678901234567890\n+        stream.println(\"  --include-events <filter>       Select events matching an event name\");\n+        stream.println();\n+        stream.println(\"  --exclude-events <filter>       Exclude events matching an event name\");\n+        stream.println();\n+        stream.println(\"  --include-categories <filter>   Select events matching a category name\");\n+        stream.println();\n+        stream.println(\"  --exclude-categories <filter>   Exclude events matching a category name\");\n+        stream.println();\n+        stream.println(\"  --include-threads <filter>      Select events matching a thread name\");\n+        stream.println();\n+        stream.println(\"  --exclude-threads <filter>      Exclude events matching a thread name\");\n+        stream.println();\n+        stream.println(\"  <input-file>                    The input file to read events from\");\n+        stream.println();\n+        stream.println(\"  <output-file>                   The output file to write filter events to. \");\n+        stream.println(\"                                  If no file is specified, it will be written to\");\n+        stream.println(\"                                  the same  path as the input file, but with\");\n+        stream.println(\"                                  \\\"-scrubbed\\\" appended to the filename\");\n+        stream.println();\n+        stream.println(\"  The filter is a comma-separated list of names, simple and\/or qualified,\");\n+        stream.println(\"  and\/or quoted glob patterns. If multiple filters are used, they \");\n+        stream.println(\"  are applied in the specified order\");\n+        stream.println();\n+        stream.println(\"Example usage:\");\n+        stream.println();\n+        stream.println(\" jfr scrub --include-events 'jdk.Socket*' recording.jfr socket-only.jfr\");\n+        stream.println();\n+        stream.println(\" jfr scrub --exclude-events InitialEnvironmentVariable recording.jfr no-psw.jfr\");\n+        stream.println();\n+        stream.println(\" jfr scrub --include-threads main recording.jfr\");\n+        stream.println();\n+        stream.println(\" jfr scrub --exclude-threads 'Foo*' recording.jfr\");\n+        stream.println();\n+        stream.println(\" jfr scrub --include-categories 'My App' recording.jfr\");\n+        stream.println();\n+        stream.println(\" jfr scrub --exclude-categories JVM,OS recording.jfr\");\n+    }\n+\n+    @Override\n+    public void execute(Deque<String> options) throws UserSyntaxException, UserDataException {\n+        ensureMinArgumentCount(options, 1);\n+\n+        Path last = Path.of(options.pollLast());\n+        ensureFileExtension(last, \".jfr\");\n+        Path output = null;\n+        Path input = null;\n+        String peek = options.peekLast();\n+        if (peek != null && peek.endsWith(\".jfr\")) {\n+            \/\/ Both source and destination specified\n+            input =  Path.of(options.pollLast());\n+            output = last;\n+        } else {\n+            \/\/ Only source file specified\n+            Path file = last.getFileName();\n+            Path dir = last.getParent();\n+            String filename = file.toString();\n+            int index = filename.lastIndexOf(\".\");\n+            String s = filename.substring(0, index);\n+            String t = s + \"-scrubbed.jfr\";\n+            input = last;\n+            output = dir == null ? Path.of(t) : dir.resolve(t);\n+        }\n+        ensureFileDoesNotExist(output);\n+\n+        List<Predicate<RecordedEvent>> filters = new ArrayList<>();\n+        int optionCount = options.size();\n+        while (optionCount > 0) {\n+            if (acceptFilterOption(options, \"--include-events\")) {\n+                String filter = options.remove();\n+                warnForWildcardExpansion(\"--include-events\", filter);\n+                var f = Filters.createEventTypeFilter(filter);\n+                filters.add(Filters.fromEventType(f));\n+            }\n+            if (acceptFilterOption(options, \"--exclude-events\")) {\n+                String filter = options.remove();\n+                warnForWildcardExpansion(\"--exclude-events\", filter);\n+                var f = Filters.createEventTypeFilter(filter);\n+                filters.add(Filters.fromEventType(f.negate()));\n+            }\n+            if (acceptFilterOption(options, \"--include-categories\")) {\n+                String filter = options.remove();\n+                warnForWildcardExpansion(\"--include-categories\", filter);\n+                var f = Filters.createCategoryFilter(filter);\n+                filters.add(Filters.fromEventType(f));\n+            }\n+            if (acceptFilterOption(options, \"--exclude-categories\")) {\n+                String filter = options.remove();\n+                warnForWildcardExpansion(\"--exclude-categories\", filter);\n+                var f = Filters.createCategoryFilter(filter);\n+                filters.add(Filters.fromEventType(f.negate()));\n+            }\n+            if (acceptFilterOption(options, \"--include-threads\")) {\n+                String filter = options.remove();\n+                warnForWildcardExpansion(\"--include-threads\", filter);\n+                var f = Filters.createThreadFilter(filter);\n+                filters.add(Filters.fromRecordedThread(f));\n+            }\n+            if (acceptFilterOption(options, \"--exclude-threads\")) {\n+                String filter = options.remove();\n+                warnForWildcardExpansion(\"--exclude-threads\", filter);\n+                var f = Filters.createThreadFilter(filter);\n+                filters.add(Filters.fromRecordedThread(f).negate());\n+            }\n+            if (optionCount == options.size()) {\n+                \/\/ No progress made\n+                checkCommonError(options, \"--include-event\", \"--include-events\");\n+                checkCommonError(options, \"--include-category\", \"--include-categories\");\n+                checkCommonError(options, \"--include-thread\", \"--include-threads\");\n+                throw new UserSyntaxException(\"unknown option \" + options.peek());\n+            }\n+            optionCount = options.size();\n+        }\n+\n+        try (RecordingFile rf = new RecordingFile(input)) {\n+            rf.write(output, Filters.matchAny(filters));\n+        } catch (IOException ioe) {\n+            couldNotReadError(input, ioe);\n+        }\n+        println(\"Scrubbed recording file written to:\");\n+        println(output.toAbsolutePath().toString());\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Scrub.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.api.consumer;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.jfr.Name;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import jdk.jfr.Event;\n+\n+\/**\n+ * @test\n+ * @summary Verifies that all traces of sensitive data is removed\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.api.consumer.TestRecordingFileSanitization\n+ *\/\n+public class TestRecordingFileSanitization {\n+    \/\/ Less than 16 characters, stored in event\n+    private final static String SHORT_PASSWORD = \"abcde123\";\n+    \/\/ More than 16 characters, stored in constant pool\n+    private final static String LONG_PASSWORD = \"abcdefghijklmnopqrstuvxyz1234567890\";\n+\n+    @Name(\"Sensitive\")\n+    public static class SensitiveEvent extends Event {\n+        String shortPassword;\n+        String longPassword;\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        Path sensitive = Path.of(\"sensitive.jfr\");\n+        Path sanitized = Path.of(\"sanitized.jfr\");\n+        try (Recording r = new Recording()) {\n+            r.start();\n+            SensitiveEvent e = new SensitiveEvent();\n+            e.shortPassword = SHORT_PASSWORD;\n+            e.longPassword = LONG_PASSWORD;\n+            e.commit();\n+            r.stop();\n+            r.dump(sensitive);\n+        }\n+        try (RecordingFile r = new RecordingFile(sensitive)) {\n+            r.write(sanitized, e -> !e.getEventType().getName().equals(\"Sensitive\"));\n+        }\n+\n+        expect(sensitive, SHORT_PASSWORD);\n+        expect(sensitive, LONG_PASSWORD);\n+        missing(sanitized, SHORT_PASSWORD);\n+        missing(sanitized, LONG_PASSWORD);\n+    }\n+\n+    private static void expect(Path file, String text) throws IOException {\n+        if (!find(file, text)) {\n+            throw new AssertionError(\"Expected to find '\" + text +\"' in \" + file);\n+        }\n+        System.out.println(\"OK, found '\" + text + \"' in \" + file );\n+    }\n+\n+    private static void missing(Path file, String text) throws IOException {\n+        if (find(file, text)) {\n+            throw new AssertionError(\"Didn't expect to find '\" + text +\"' in \" + file);\n+        }\n+        System.out.println(\"OK, missing '\" + text + \"' in \" + file);\n+    }\n+\n+    private static boolean find(Path file, String text) throws IOException {\n+        byte[] textBytes = stringToBytes(text);\n+        byte[] fileBytes = Files.readAllBytes(file);\n+        for (int i = 0; i < fileBytes.length - textBytes.length; i++) {\n+            if (find(fileBytes, i, textBytes)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static boolean find(byte[] haystack, int start, byte[] needle) {\n+        for (int i = 0; i < needle.length; i++) {\n+            if (haystack[start + i] != needle[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private static byte[] stringToBytes(String text) {\n+        byte[] bytes = new byte[text.length()];\n+        for (int i = 0; i < text.length(); i++) {\n+            if (text.charAt(i) > 127) {\n+                throw new Error(\"Test only allows characters that becomes one byte with LEB128\");\n+            }\n+            bytes[i] = (byte)(text.charAt(i));\n+        }\n+        return bytes;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/TestRecordingFileSanitization.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.api.consumer;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+import java.util.Random;\n+\n+import jdk.jfr.Configuration;\n+import jdk.jfr.Event;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordingFile;\n+\n+\/**\n+ * @test\n+ * @summary Tests RecordingFile::write(Path, Predicate<RecordedEvent>)\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.api.consumer.TestRecordingFileWrite\n+ *\/\n+public class TestRecordingFileWrite {\n+\n+    static class ScrubEvent extends Event {\n+        long id;\n+        String message;\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        Path scrubbed = Paths.get(\"scrubbed.jfr\");\n+        Path original = Paths.get(\"original.jfr\");\n+\n+        createRecording(original);\n+        Queue<String> ids = scrubRecording(original, scrubbed);\n+        System.out.println(\"Original size: \" + Files.size(original));\n+        System.out.println(\"Scrubbed size: \" + Files.size(scrubbed));\n+        System.out.println(\"Scrubbed event count: \" + ids.size());\n+        if (ids.size() < 50_000) {\n+            throw new AssertionError(\"Expected at least 50 000 events to be included\");\n+        }\n+        verify(scrubbed, ids);\n+    }\n+\n+    private static void verify(Path scrubbed, Queue<String> events) throws Exception {\n+        try (RecordingFile rf = new RecordingFile(scrubbed)) {\n+            while (rf.hasMoreEvents()) {\n+                String event = rf.readEvent().toString();\n+                String expected = events.poll();\n+                if (!event.equals(expected)) {\n+                    System.out.println(\"Found:\");\n+                    System.out.println(event);\n+                    System.out.println(\"Expected:\");\n+                    System.out.println(expected);\n+                    throw new Exception(\"Found event that should not be there. See log\");\n+                }\n+            }\n+        }\n+        if (!events.isEmpty()) {\n+            throw new AssertionError(\"Missing events \" + events);\n+        }\n+    }\n+\n+    private static Queue<String> scrubRecording(Path original, Path scrubbed) throws IOException {\n+        Queue<String> events = new ArrayDeque<>(150_000);\n+        Random random = new Random();\n+        try (RecordingFile rf = new RecordingFile(original)) {\n+            rf.write(scrubbed, event -> {\n+                boolean keep = random.nextInt(10) == 0;\n+                if (event.getEventType().getName().equals(\"jdk.OldObjectSample\")) {\n+                    System.out.println(event);\n+                    keep = true;\n+                }\n+                if (keep) {\n+                    events.add(event.toString());\n+                }\n+                return keep;\n+            });\n+        }\n+        return events;\n+    }\n+\n+    private static void createRecording(Path file) throws Exception {\n+        \/\/ Use profile configuration so more complex data structures\n+        \/\/ are serialized\n+        Configuration c = Configuration.getConfiguration(\"profile\");\n+        try (Recording r = new Recording(c)) {\n+            r.start();\n+            String s = \"A\";\n+            \/\/ Generate sufficient number of events to provoke\n+            \/\/ chunk rotations\n+            for (int i = 0; i < 1_000_000; i++) {\n+                ScrubEvent event = new ScrubEvent();\n+                event.message = s.repeat(i % 30);\n+                event.id = i;\n+                event.commit();\n+            }\n+            r.stop();\n+            r.dump(file);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/TestRecordingFileWrite.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,313 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.tool;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.jfr.Name;\n+import jdk.jfr.Recording;\n+import jdk.jfr.Category;\n+import jdk.jfr.Event;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingFile;\n+\n+\/**\n+ * @test\n+ * @summary Test jfr scrub\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.tool.TestScrub\n+ *\/\n+public class TestScrub {\n+\n+    @Name(\"example.Tiger\")\n+    @Category(\"Mammal\")\n+    private static class TigerEvent extends Event {\n+    }\n+\n+    @Name(\"example.Zebra\")\n+    @Category(\"Mammal\")\n+\n+    private static class ZebraEvent extends Event {\n+    }\n+\n+    @Name(\"example.Tigerfish\")\n+    @Category(\"Fish\")\n+    private static class TigerfishEvent extends Event {\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        Path file = Path.of(\"recording.jfr\");\n+        Path autogenerated = Path.of(\"recording-scrubbed.jfr\");\n+\n+        try (Recording r = new Recording()) {\n+            r.start();\n+            emit(100, \"India\", TigerEvent.class);\n+            emit(100, \"Namibia\", ZebraEvent.class);\n+            emit(10000, \"Lake Tanganyika\", TigerfishEvent.class);\n+            r.stop();\n+            r.dump(file);\n+        }\n+        testAutogeneratedFilename(file, autogenerated);\n+\n+        testEventInclude(file);\n+        testEventExclude(file);\n+        testEventMixedIncludeExclude(file);\n+\n+        testCategoryExclude(file);\n+        testCategoryInclude(file);\n+\n+        testThreadExclude(file);\n+        testThreadInclude(file);\n+    }\n+\n+    private static void testAutogeneratedFilename(Path file, Path autogenerated) throws Throwable {\n+        List<String> arguments = new ArrayList<>();\n+        arguments.add(\"scrub\");\n+        arguments.add(file.toAbsolutePath().toString());\n+        ExecuteHelper.jfr(arguments.toArray(String[]::new));\n+\n+        if (!Files.exists(autogenerated)) {\n+            throw new AssertionError(\"Expected to find auto-generated file \" + autogenerated);\n+        }\n+        Files.delete(autogenerated);\n+    }\n+\n+    private static void testEventInclude(Path file) throws Throwable {\n+        for (var event : scrub(file, \"--include-events\", \"Zebra\")) {\n+            assertEvent(event, \"Zebra\");\n+            assertNotEvent(event, \"Tiger\", \"Tigerfish\");\n+        }\n+        for (var event : scrub(file, \"--include-events\", \"Tiger*\")) {\n+            assertEvent(event, \"Tiger\", \"Tigerfish\");\n+            assertNotEvent(event, \"Zebra\");\n+        }\n+        for (var event : scrub(file, \"--include-events\", \"Tiger,Zebra\")) {\n+            assertEvent(event, \"Tiger\", \"Zebra\");\n+            assertNotEvent(event, \"Tigerfish\");\n+        }\n+        for (var event : scrub(file, \"--include-events\", \"Tiger\", \"--include-events\", \"Zebra\")) {\n+            assertEvent(event, \"Tiger\", \"Zebra\");\n+            assertNotEvent(event, \"Tigerfish\");\n+        }\n+    }\n+\n+    private static void testEventExclude(Path file) throws Throwable {\n+        for (var event : scrub(file, \"--exclude-events\", \"Zebra\")) {\n+            assertNotEvent(event, \"Zebra\");\n+            assertEvent(event, \"Tiger\", \"Tigerfish\");\n+        }\n+        for (var event : scrub(file, \"--exclude-events\", \"Tiger*\")) {\n+            assertEvent(event, \"Zebra\");\n+            assertNotEvent(event, \"Tiger\", \"Tigerfish\");\n+        }\n+        for (var event : scrub(file, \"--exclude-events\", \"Tiger,Zebra\")) {\n+            assertEvent(event, \"Tigerfish\");\n+            assertNotEvent(event, \"Tiger\", \"Zebra\");\n+        }\n+\n+        for (var event : scrub(file, \"--exclude-events\", \"Tiger\", \"--exclude-events\", \"Zebra\")) {\n+            assertEvent(event, \"Tigerfish\");\n+            assertNotEvent(event, \"Tiger\", \"Zebra\");\n+        }\n+    }\n+\n+    private static void testEventMixedIncludeExclude(Path file) throws Throwable {\n+        for (var event : scrub(file, \"--include-events\", \"Tiger*\", \"--exclude-events\", \"Tigerfish\")) {\n+            assertNotEvent(event, \"Zebra\", \"Tigerfish\");\n+            assertEvent(event, \"Tiger\");\n+        }\n+        for (var event : scrub(file, \"--exclude-events\", \"Tiger*\", \"--include-events\", \"Tiger\")) {\n+            assertEvent(event, \"Zebra\", \"Tiger\");\n+            assertNotEvent(event, \"Tigerfish\");\n+        }\n+        for (var event : scrub(file, \"--exclude-events\", \"example.*\", \"--include-events\", \"example.*\")) {\n+            assertNotEvent(event, \"Tigerfish\", \"Tiger\", \"Zebra\");\n+        }\n+        for (var event : scrub(file, \"--include-events\", \"example.*\", \"--exclude-events\", \"example.*\")) {\n+            assertNotEvent(event, \"Tigerfish\", \"Tiger\", \"Zebra\");\n+        }\n+    }\n+\n+    private static void testCategoryInclude(Path file) throws Throwable {\n+        for (var event : scrub(file, \"--include-categories\", \"Mammal\")) {\n+            assertEvent(event, \"Zebra\", \"Tiger\");\n+            assertNotEvent(event, \"Tigerfish\");\n+        }\n+        for (var event : scrub(file, \"--include-categories\", \"Sahara\")) {\n+            assertNotEvent(event, \"Tiger\", \"Tigerfish\", \"Zebra\");\n+        }\n+        for (var event : scrub(file, \"--include-categories\", \"Fish,Mammal\")) {\n+            assertEvent(event, \"Tiger\", \"Zebra\", \"Tigerfish\");\n+        }\n+        for (var event : scrub(file, \"--include-categories\", \"Mammal\", \"--include-categories\", \"Fish\")) {\n+            assertEvent(event, \"Tiger\", \"Zebra\", \"Tigerfish\");\n+        }\n+    }\n+\n+    private static void testCategoryExclude(Path file) throws Throwable {\n+        for (var event : scrub(file, \"--exclude-categories\", \"Mammal\")) {\n+            assertNotEvent(event, \"Zebra\", \"Tiger\");\n+            assertEvent(event, \"Tigerfish\");\n+        }\n+        for (var event : scrub(file, \"--exclude-categories\", \"Mammal,Fish\")) {\n+            assertNotEvent(event, \"Zebra\", \"Tiger\", \"Tigerfish\");\n+        }\n+        for (var event : scrub(file, \"--exclude-categories\", \"Mammal\")) {\n+            assertNotEvent(event, \"Zebra\", \"Tiger\");\n+            assertEvent(event, \"Tigerfish\");\n+        }\n+        for (var event : scrub(file, \"--exclude-categories\", \"Mammal\")) {\n+            assertNotEvent(event, \"Zebra\", \"Tiger\");\n+            assertEvent(event, \"Tigerfish\");\n+        }\n+    }\n+\n+    private static void testThreadInclude(Path file) throws Throwable {\n+        for (var event : scrub(file, \"--include-threads\", \"Namibia\")) {\n+            assertThread(event, \"Namibia\");\n+            assertNotThread(event, \"India\", \"Lake Tanganyika\");\n+        }\n+\n+        for (var event : scrub(file, \"--include-threads\", \"Nam*\")) {\n+            assertThread(event, \"Namibia\");\n+            assertNotThread(event, \"Lake Tanganyika\", \"India\");\n+        }\n+\n+        for (var event : scrub(file, \"--include-threads\", \"Namibia,Lake\")) {\n+            assertThread(event, \"Namibia\", \"Lake Tanganyika\");\n+            assertNotThread(event, \"India\");\n+        }\n+\n+        for (var event : scrub(file, \"--include-threads\", \"India\", \"--include-threads\", \"Lake Tanganyika\")) {\n+            assertThread(event, \"India\", \"Lake Tanganyika\");\n+            assertNotThread(event, \"Namibia\");\n+        }\n+    }\n+\n+    private static void testThreadExclude(Path file) throws Throwable {\n+        for (var event : scrub(file, \"--exclude-threads\", \"Namibia\")) {\n+            assertThread(event, \"India\", \"Lake Tanganyika\");\n+            assertNotThread(event, \"Namibia\");\n+        }\n+\n+        for (var event : scrub(file, \"--exclude-threads\", \"Nam*\")) {\n+            assertThread(event, \"Lake Tanganyika\", \"India\");\n+            assertNotThread(event, \"Namibia\");\n+        }\n+\n+        for (var event : scrub(file, \"--exclude-threads\", \"Namibia,Lake Tanganyika\")) {\n+            assertThread(event, \"India\");\n+            assertNotThread(event, \"Namibia\", \"Lake Tanganyika\");\n+        }\n+\n+        for (var event : scrub(file, \"--exclude-events\", \"India\", \"--include-events\", \"Lake Tanganyika\")) {\n+            assertThread(event, \"Namibia\");\n+            assertNotThread(event, \"India\", \"Lake Tanganyika\");\n+        }\n+    }\n+\n+    private static void assertNotThread(RecordedEvent event, String... threadNames) {\n+        String s = event.getThread().getJavaName();\n+        for (String threadName : threadNames) {\n+            if (threadName.equals(s)) {\n+                throw new AssertionError(\"Found unexpected thread\" + threadName);\n+            }\n+        }\n+    }\n+\n+    private static void assertThread(RecordedEvent event, String... threadNames) {\n+        String s = event.getThread().getJavaName();\n+        for (String threadName : threadNames) {\n+            if (threadName.equals(s)) {\n+                return;\n+            }\n+        }\n+        throw new AssertionError(\"Found unexpected thread\" + s);\n+    }\n+\n+    private static void assertNotEvent(RecordedEvent event, String... eventNames) {\n+        String s = event.getEventType().getName();\n+        for (String eventName : eventNames) {\n+            String n = \"example.\" + eventName;\n+            if (n.equals(s)) {\n+                throw new AssertionError(\"Found unexpected \" + eventName + \" event\");\n+            }\n+        }\n+    }\n+\n+    private static void assertEvent(RecordedEvent event, String... eventNames) {\n+        String s = event.getEventType().getName();\n+        for (String eventName : eventNames) {\n+            String n = \"example.\" + eventName;\n+            if (n.equals(s)) {\n+                return;\n+            }\n+        }\n+        throw new AssertionError(\"Found unexpected \" + s + \" event\");\n+    }\n+\n+    private static List<RecordedEvent> scrub(Path input, String... options) throws Throwable {\n+        Path output = Path.of(\"scrubbed.jfr\");\n+        List<String> arguments = new ArrayList<>();\n+        arguments.add(\"scrub\");\n+        arguments.addAll(Arrays.asList(options));\n+        arguments.add(input.toAbsolutePath().toString());\n+        arguments.add(output.toAbsolutePath().toString());\n+\n+        var outp = ExecuteHelper.jfr(arguments.toArray(String[]::new));\n+        System.out.println(outp.getStderr());\n+        System.out.println(outp.getStdout());\n+        List<RecordedEvent> events = RecordingFile.readAllEvents(output);\n+        Files.delete(output);\n+        return events;\n+    }\n+\n+    private static void emit(int count, String threadName, Class<? extends Event> eventClass) throws Throwable {\n+        Thread t = new Thread(() -> emitEvents(count, eventClass), threadName);\n+        t.start();\n+        t.join();\n+    }\n+\n+    private static void emitEvents(int count, Class<? extends Event> eventClass) {\n+        for (int i = 0; i < count; i++) {\n+            try {\n+                Event event = eventClass.getDeclaredConstructor().newInstance();\n+                event.commit();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/tool\/TestScrub.java","additions":313,"deletions":0,"binary":false,"changes":313,"status":"added"}]}