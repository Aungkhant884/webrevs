{"files":[{"patch":"@@ -3903,4 +3903,1 @@\n-            \/\/ Skip over Record attribute if not supported or if super class is\n-            \/\/ not java.lang.Record.\n-            if (supports_records() &&\n-                cp->klass_name_at(_super_class_index) == vmSymbols::java_lang_Record()) {\n+            if (supports_records()) { \/\/ Skip over Record attribute if not supported.\n@@ -3911,5 +3908,0 @@\n-              \/\/ Check that class is final and not abstract.\n-              if (!_access_flags.is_final() || _access_flags.is_abstract()) {\n-                classfile_parse_error(\"Record attribute in non-final or abstract class file %s\", THREAD);\n-                return;\n-              }\n@@ -3925,9 +3917,3 @@\n-              if (supports_records()) {\n-                log_info(class, record)(\n-                  \"Ignoring Record attribute in class %s because super type is not java.lang.Record\",\n-                  _class_name->as_C_string());\n-              } else {\n-                log_info(class, record)(\n-                  \"Ignoring Record attribute in class %s because class file version is not %d.65535\",\n-                   _class_name->as_C_string(), JVM_CLASSFILE_MAJOR_VERSION);\n-              }\n+              log_info(class, record)(\n+                \"Ignoring Record attribute in class %s because class file version is not %d.65535\",\n+                 _class_name->as_C_string(), JVM_CLASSFILE_MAJOR_VERSION);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,2 @@\n-\/\/ This test is a Record marked as abstract.  It should result in a\n-\/\/ ClassFormatError exception.\n+\/\/ This test is a Record marked as abstract.  Loading this class should\n+\/\/ not cause a ClassFormatError exception.\n","filename":"test\/hotspot\/jtreg\/runtime\/records\/abstractRecord.jcod","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,6 +40,0 @@\n-            \"-Xlog:class+record\", \"-Xshare:off\", \"superNotJLRecord\");\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"Ignoring Record attribute\");\n-        output.shouldContain(\"because super type is not java.lang.Record\");\n-\n-        pb = ProcessTools.createJavaProcessBuilder(\"--enable-preview\",\n@@ -47,1 +41,1 @@\n-        output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n","filename":"test\/hotspot\/jtreg\/runtime\/records\/ignoreRecordAttribute.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-\/\/ This test is a Record but not marked final.  It should result in a\n-\/\/ ClassFormatError exception.\n+\/\/ This test is a Record but not marked final.  Loading this class should\n+\/\/ not cause a ClassFormatError exception.\n","filename":"test\/hotspot\/jtreg\/runtime\/records\/notFinalRecord.jcod","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,3 +57,2 @@\n-        \/\/ Test loading a Record type marked abstract. This should throw ClassFormatError.\n-        runTest(\"abstractRecord\",\n-                \"Record attribute in non-final or abstract class\");\n+        \/\/ Test loading a Record type marked abstract. This should not throw ClassFormatError.\n+        Class abstractClass = Class.forName(\"abstractRecord\");\n@@ -61,3 +60,2 @@\n-        \/\/ Test loading a Record type that is not final. This should throw ClassFormatError.\n-        runTest(\"notFinalRecord\",\n-                \"Record attribute in non-final or abstract class\");\n+        \/\/ Test loading a Record type that is not final. This should not throw ClassFormatError.\n+        Class notFinalClass = Class.forName(\"notFinalRecord\");\n@@ -76,3 +74,3 @@\n-        \/\/ Test that loading a class whose super class is not java.lang.Record\n-        \/\/ ignores a badly formed Record attribute. No exception should be thrown.\n-        newClass = Class.forName(\"superNotJLRecord\");\n+        \/\/ Test that loading a class causes the Record attribute to get parsed\n+        \/\/ even if its super class is not java.lang.Record\n+        runTest(\"superNotJLRecord\", \"Truncated class file\");\n","filename":"test\/hotspot\/jtreg\/runtime\/records\/recordAttributeTest.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-\/\/ This test has a Record attribute that is too short but its super class is\n-\/\/ not java.lang.Record.  So, the bogus Record attribute should be ignored.\n+\/\/ This test has a Record attribute that is too short and its super class is\n+\/\/ not java.lang.Record.  The bad Record attribute should still be detected.\n","filename":"test\/hotspot\/jtreg\/runtime\/records\/superNotJLRecord.jcod","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}