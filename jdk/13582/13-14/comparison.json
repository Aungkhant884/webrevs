{"files":[{"patch":"@@ -34,0 +34,2 @@\n+\/\/ We cannot use 0, because that may already be a valid base address in zero-based heaps.\n+\/\/ 0x1 is safe because heap base addresses must be aligned by much larger alginemnt\n@@ -39,0 +41,1 @@\n+    _region_size_words(region_size_words),\n@@ -40,1 +43,1 @@\n-  _target_base_table(nullptr),\n+  _bases_table(nullptr),\n@@ -48,1 +51,2 @@\n-    _region_size_words_shift = log2i_exact(round_up_power_of_2(heap_size_words));\n+    _region_size_words = round_up_power_of_2(heap_size_words);\n+    _region_size_words_shift = log2i_exact(_region_size_words);\n@@ -53,3 +57,3 @@\n-  if (_target_base_table != nullptr) {\n-    FREE_C_HEAP_ARRAY(HeapWord*, _target_base_table);\n-    _target_base_table = nullptr;\n+  if (_bases_table != nullptr) {\n+    FREE_C_HEAP_ARRAY(HeapWord*, _bases_table);\n+    _bases_table = nullptr;\n@@ -64,1 +68,1 @@\n-  assert(_target_base_table == nullptr, \"Should be uninitialized\");\n+  assert(_bases_table == nullptr, \"Should be uninitialized\");\n@@ -66,1 +70,1 @@\n-  _target_base_table = NEW_C_HEAP_ARRAY(HeapWord*, max, mtGC);\n+  _bases_table = NEW_C_HEAP_ARRAY(HeapWord*, max, mtGC);\n@@ -68,1 +72,1 @@\n-    _target_base_table[i] = UNUSED_BASE;\n+    _bases_table[i] = UNUSED_BASE;\n@@ -73,3 +77,3 @@\n-  assert(_target_base_table != nullptr, \"Should be initialized\");\n-  FREE_C_HEAP_ARRAY(HeapWord*, _target_base_table);\n-  _target_base_table = nullptr;\n+  assert(_bases_table != nullptr, \"Should be initialized\");\n+  FREE_C_HEAP_ARRAY(HeapWord*, _bases_table);\n+  _bases_table = nullptr;\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.cpp","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -71,33 +71,6 @@\n- *\n- *   void forward_to(oop* from, oop* to) {\n- *     \/\/ Identifying the offset in the target region is easy:\n- *     intptr_t to_region_addr = oop_to_region_addr(to);\n- *     u4 mark_offset = encode_offset(to_region_addr, to);\n- *\n- *     \/\/ Now we need to record the target region address in the bases table.\n- *     \/\/ There are two entries per region: primary and alternative.\n- *     int reg_prim = oop_to_region_idx(from);\n- *     int reg_alt = reg_prim + 1;\n- *\n- *     bool alt_region = false;\n- *     if (bases_table[reg_prim] == UNUSED) {\n- *       \/\/ Primary entry is free, take it.\n- *       bases_table[reg_prim] = to_region_addr;\n- *     } else if (bases_table[reg_prim] != to_region_addr) {\n- *       \/\/ Primary entry is taken by incompatible \"to\" address, use the alternate.\n- *       if (bases_table[reg_alt] == UNUSED) {\n- *         \/\/ Alternate is unused, take it.\n- *         bases_table[reg_alt] = to_region_addr;\n- *       } else {\n- *         \/\/ Since we see two \"to\" regions only, we know alternate entry has the\n- *         \/\/ correct \"to\" address for this mapping.\n- *       }\n- *       alt_region = true;\n- *     }\n- *\n- *     \/\/ All done, we only need to record which mapping to use\n- *     u1 mark_region_select = encode_region_select(alt_region);\n- *\n- *     \/\/ Store everything in the object header\n- *     from->update_mark(FORWARDED | mark_region_select | mark_offset);\n- *   }\n+ *   1. Compute the \"to\" offset in the \"to\" region, this gives \"offset\".\n+ *   2. Check if the primary \"from\" offset at base table contains \"to\" region base, use it.\n+ *      If not usable, continue to next step. If usable, set \"alternate\" = \"false\" and jump to (4).\n+ *   3. Check if the alternate \"from\" offset at base table contains \"to\" region base, use it.\n+ *      This gives us \"alternate\" = \"true\". This should always complete for sliding forwarding.\n+ *   4. Compute the mark word from \"offset\" and \"alternate\", write it out\n@@ -106,14 +79,4 @@\n- *\n- *   oop* forwardee(oop* obj) {\n- *     \/\/ Load and decode the forwarding\n- *     mark m = obj->mark();\n- *     u1 region_select = decode_region_select(m);\n- *     u4 offset = decode_offset(m);\n- *\n- *     \/\/ Figure out which region the original region is forwarded to:\n- *     int reg_idx = oop_to_region_idx(obj) + region_select;\n- *     intptr_t fwd_base = bases_table[reg_idx];\n- *\n- *     \/\/ Compute the forwarding address\n- *     return fwd_base + offset;\n- *   }\n+ *   1. Load the mark from object, and decode \"offset\" and \"alternate\" from there\n+ *   2. Compute the \"from\" base offset from the object\n+ *   3. Look up \"to\" region base from the base table either at primary or alternate indices, using \"alternate\" flag\n+ *   4. Compute the \"to\" address from \"to\" region base and \"offset\"\n@@ -133,2 +96,1 @@\n-  \/\/ The 3rd bit (fallback-bit) indicates that the forwardee should be\n-  \/\/ looked-up in a fallback-table.\n+  \/\/ The next bit indicates that the forwardee should be looked-up in a fallback-table.\n@@ -138,3 +100,0 @@\n-  \/\/ The 4th bit selects the target region.\n-  static const int REGION_SHIFT = FALLBACK_SHIFT + FALLBACK_BITS;\n-  static const int REGION_BITS = 1;\n@@ -142,2 +101,5 @@\n-  \/\/ The compressed address bits start here.\n-  static const int COMPRESSED_BITS_SHIFT = REGION_SHIFT + REGION_BITS;\n+  \/\/ Next bit selects the target region\n+  static const int ALT_REGION_SHIFT = FALLBACK_SHIFT + FALLBACK_BITS;\n+  static const int ALT_REGION_BITS = 1;\n+  \/\/ This will be \"2\" always, but expose it as named constant for clarity\n+  static const size_t NUM_TARGET_REGIONS = 1 << ALT_REGION_BITS;\n@@ -145,2 +107,2 @@\n-  \/\/ How many bits we use for the compressed pointer\n-  static const int NUM_COMPRESSED_BITS = 32 - COMPRESSED_BITS_SHIFT;\n+  \/\/ The offset bits start then\n+  static const int OFFSET_BITS_SHIFT = ALT_REGION_SHIFT + ALT_REGION_BITS;\n@@ -148,1 +110,2 @@\n-  static const size_t NUM_TARGET_REGIONS = 1 << REGION_BITS;\n+  \/\/ How many bits we use for the compressed pointer\n+  static const int NUM_COMPRESSED_BITS = 32 - OFFSET_BITS_SHIFT;\n@@ -150,2 +113,1 @@\n-  \/\/ Indicates an usused base address in the target base table. We cannot use 0, because that may already be\n-  \/\/ a valid base address in zero-based heaps. 0x1 is safe because heap base addresses must be aligned by 2^X.\n+  \/\/ Indicates an unused base address in the target base table.\n@@ -156,0 +118,1 @@\n+  size_t           _region_size_words;\n@@ -157,1 +120,1 @@\n-  HeapWord**       _target_base_table;\n+  HeapWord**       _bases_table;\n@@ -164,2 +127,2 @@\n-  inline uintptr_t encode_forwarding(HeapWord* original, HeapWord* target);\n-  inline HeapWord* decode_forwarding(HeapWord* original, uintptr_t encoded) const;\n+  inline uintptr_t encode_forwarding(HeapWord* from, HeapWord* to);\n+  inline HeapWord* decode_forwarding(HeapWord* from, uintptr_t encoded) const;\n@@ -177,2 +140,2 @@\n-  inline void forward_to(oop original, oop target);\n-  inline oop forwardee(oop original) const;\n+  inline void forward_to(oop from, oop to);\n+  inline oop forwardee(oop from) const;\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.hpp","additions":27,"deletions":64,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  return addr >= region_base && pointer_delta(addr, region_base) < (1ull << _region_size_words_shift);\n+  return (region_base <= addr) && (addr < (region_base + _region_size_words));\n@@ -45,15 +45,24 @@\n-uintptr_t SlidingForwarding::encode_forwarding(HeapWord* original, HeapWord* target) {\n-  size_t orig_idx = region_index_containing(original);\n-  size_t base_table_idx = orig_idx * 2;\n-  size_t target_idx = region_index_containing(target);\n-  HeapWord* encode_base;\n-  uintptr_t region_idx;\n-  for (region_idx = 0; region_idx < NUM_TARGET_REGIONS; region_idx++) {\n-    encode_base = _target_base_table[base_table_idx + region_idx];\n-    if (encode_base == UNUSED_BASE) {\n-      size_t region_size = 1ull << _region_size_words_shift;\n-      encode_base = _heap_start + target_idx * region_size;\n-      _target_base_table[base_table_idx + region_idx] = encode_base;\n-      break;\n-    } else if (region_contains(encode_base, target)) {\n-      break;\n+uintptr_t SlidingForwarding::encode_forwarding(HeapWord* from, HeapWord* to) {\n+  size_t from_reg_idx = region_index_containing(from);\n+  size_t to_reg_idx = region_index_containing(to);\n+\n+  HeapWord* to_region_base = _heap_start + to_reg_idx * _region_size_words;\n+  size_t base_idx = from_reg_idx * NUM_TARGET_REGIONS;\n+\n+  bool alt_region = false;\n+  if (_bases_table[base_idx] == UNUSED_BASE) {\n+    \/\/ Primary is free\n+    _bases_table[base_idx] = to_region_base;\n+  } else if (region_contains(_bases_table[base_idx], to)) {\n+    \/\/ Primary is good\n+  } else {\n+    size_t base_idx_alt = base_idx + 1;\n+    if (_bases_table[base_idx_alt] == UNUSED_BASE) {\n+      \/\/ Alternate is free\n+      _bases_table[base_idx_alt] = to_region_base;\n+    } else if (region_contains(_bases_table[base_idx_alt], to)) {\n+      \/\/ Alternate is good\n+    } else {\n+      \/\/ Both primary and alternate are not fitting\n+      assert(UseG1GC, \"Only happens with G1 serial compaction\");\n+      return (1 << FALLBACK_SHIFT) | markWord::marked_value;\n@@ -61,0 +70,1 @@\n+    alt_region = true;\n@@ -62,14 +72,11 @@\n-  if (region_idx >= NUM_TARGET_REGIONS) {\n-    assert(UseG1GC, \"Only happens with G1 serial compaction\");\n-    return 1 << FALLBACK_SHIFT | markWord::marked_value;\n-  }\n-  assert(region_idx < NUM_TARGET_REGIONS, \"need to have found an encoding base\");\n-  assert(target >= encode_base, \"target must be above encode base, target:\" PTR_FORMAT \", encoded_base: \" PTR_FORMAT\n-         \",  target_idx: \" SIZE_FORMAT \", heap start: \" PTR_FORMAT \", region_idx: \" INTPTR_FORMAT,\n-         p2i(target), p2i(encode_base), target_idx, p2i(_heap_start), region_idx);\n-  assert(region_contains(encode_base, target), \"region must contain target: original: \" PTR_FORMAT\n-         \", target: \" PTR_FORMAT \", encode_base: \" PTR_FORMAT \", region_idx: \" INTPTR_FORMAT \", region_size: \" INTPTR_FORMAT,\n-         p2i(original), p2i(target), p2i(encode_base), region_idx, uintptr_t(1) << _region_size_words_shift);\n-  uintptr_t encoded = (pointer_delta(target, encode_base) << COMPRESSED_BITS_SHIFT) |\n-                      (region_idx << REGION_SHIFT) | markWord::marked_value;\n-  assert(target == decode_forwarding(original, encoded), \"must be reversible\");\n+\n+  size_t offset = pointer_delta(to, to_region_base);\n+  assert(offset < _region_size_words, \"Offset should be within the region. from: \" PTR_FORMAT\n+         \", to: \" PTR_FORMAT \", to_region_base: \" PTR_FORMAT \", offset: \" SIZE_FORMAT,\n+         p2i(from), p2i(to), p2i(to_region_base), offset);\n+\n+  uintptr_t encoded = (offset << OFFSET_BITS_SHIFT) |\n+                      (alt_region << ALT_REGION_SHIFT) |\n+                      markWord::marked_value;\n+\n+  assert(to == decode_forwarding(from, encoded), \"must be reversible\");\n@@ -79,1 +86,1 @@\n-HeapWord* SlidingForwarding::decode_forwarding(HeapWord* original, uintptr_t encoded) const {\n+HeapWord* SlidingForwarding::decode_forwarding(HeapWord* from, uintptr_t encoded) const {\n@@ -81,6 +88,12 @@\n-  size_t orig_idx = region_index_containing(original);\n-  size_t region_idx = (encoded >> REGION_SHIFT) & right_n_bits(REGION_BITS);\n-  size_t base_table_idx = orig_idx * 2 + region_idx;\n-  HeapWord* decoded = _target_base_table[base_table_idx] + (encoded >> COMPRESSED_BITS_SHIFT);\n-  assert(decoded >= _heap_start, \"must be above heap start, encoded: \" INTPTR_FORMAT \", region_idx: \" SIZE_FORMAT \", base: \" PTR_FORMAT,\n-         encoded, region_idx, p2i(_target_base_table[base_table_idx]));\n+  size_t alt_region = (encoded >> ALT_REGION_SHIFT) & right_n_bits(ALT_REGION_BITS);\n+  assert(alt_region < NUM_TARGET_REGIONS, \"Sanity\");\n+  uintptr_t offset = (encoded >> OFFSET_BITS_SHIFT);\n+\n+  size_t from_idx = region_index_containing(from) * NUM_TARGET_REGIONS;\n+  size_t base_idx = from_idx + alt_region;\n+\n+  HeapWord* decoded = _bases_table[base_idx] + offset;\n+  assert(decoded >= _heap_start,\n+         \"Address must be above heap start. encoded: \" INTPTR_FORMAT \", alt_region: \" SIZE_FORMAT \", base: \" PTR_FORMAT,\n+         encoded, alt_region, p2i(_bases_table[base_idx]));\n+\n@@ -90,5 +103,6 @@\n-void SlidingForwarding::forward_to(oop original, oop target) {\n-  assert(_target_base_table != nullptr, \"call begin() before forwarding\");\n-  markWord header = original->mark();\n-  if (header.has_displaced_mark_helper()) {\n-    header = header.displaced_mark_helper();\n+void SlidingForwarding::forward_to(oop from, oop to) {\n+  assert(_bases_table != nullptr, \"call begin() before forwarding\");\n+\n+  markWord from_header = from->mark();\n+  if (from_header.has_displaced_mark_helper()) {\n+    from_header = from_header.displaced_mark_helper();\n@@ -96,5 +110,7 @@\n-  HeapWord* from = cast_from_oop<HeapWord*>(original);\n-  HeapWord* to   = cast_from_oop<HeapWord*>(target);\n-  uintptr_t encoded = encode_forwarding(from, to);\n-  header = markWord((header.value() & ~MARK_LOWER_HALF_MASK) | encoded);\n-  original->set_mark(header);\n+\n+  HeapWord* from_hw = cast_from_oop<HeapWord*>(from);\n+  HeapWord* to_hw   = cast_from_oop<HeapWord*>(to);\n+  uintptr_t encoded = encode_forwarding(from_hw, to_hw);\n+  markWord new_header = markWord((from_header.value() & ~MARK_LOWER_HALF_MASK) | encoded);\n+  from->set_mark(new_header);\n+\n@@ -102,1 +118,1 @@\n-    fallback_forward_to(from, to);\n+    fallback_forward_to(from_hw, to_hw);\n@@ -106,4 +122,5 @@\n-oop SlidingForwarding::forwardee(oop original) const {\n-  assert(_target_base_table != nullptr, \"call begin() before forwarding\");\n-  markWord header = original->mark();\n-  HeapWord* from = cast_from_oop<HeapWord*>(original);\n+oop SlidingForwarding::forwardee(oop from) const {\n+  assert(_bases_table != nullptr, \"call begin() before asking for forwarding\");\n+\n+  markWord header = from->mark();\n+  HeapWord* from_hw = cast_from_oop<HeapWord*>(from);\n@@ -111,1 +128,1 @@\n-    HeapWord* to = fallback_forwardee(from);\n+    HeapWord* to = fallback_forwardee(from_hw);\n@@ -115,2 +132,2 @@\n-  HeapWord* forwardee = decode_forwarding(from, encoded);\n-  return cast_to_oop(forwardee);\n+  HeapWord* to = decode_forwarding(from_hw, encoded);\n+  return cast_to_oop(to);\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.inline.hpp","additions":72,"deletions":55,"binary":false,"changes":127,"status":"modified"}]}