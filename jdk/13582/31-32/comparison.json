{"files":[{"patch":"@@ -42,1 +42,1 @@\n-FallbackTable* SlidingForwarding::_fallback_table = nullptr;\n+SlidingForwarding::FallbackTable* SlidingForwarding::_fallback_table = nullptr;\n@@ -106,1 +106,1 @@\n-FallbackTable::FallbackTable() {\n+SlidingForwarding::FallbackTable::FallbackTable() {\n@@ -114,1 +114,1 @@\n-FallbackTable::~FallbackTable() {\n+SlidingForwarding::FallbackTable::~FallbackTable() {\n@@ -125,1 +125,1 @@\n-size_t FallbackTable::home_index(HeapWord* from) {\n+size_t SlidingForwarding::FallbackTable::home_index(HeapWord* from) {\n@@ -131,1 +131,1 @@\n-void FallbackTable::forward_to(HeapWord* from, HeapWord* to) {\n+void SlidingForwarding::FallbackTable::forward_to(HeapWord* from, HeapWord* to) {\n@@ -154,1 +154,1 @@\n-HeapWord* FallbackTable::forwardee(HeapWord* from) const {\n+HeapWord* SlidingForwarding::FallbackTable::forwardee(HeapWord* from) const {\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-class FallbackTable;\n-\n@@ -51,1 +49,1 @@\n- * two target regions. The table table holds N*2 entries for N logical regions. For each region, it gives the base\n+ * two target regions. The table holds N*2 entries for N logical regions. For each region, it gives the base\n@@ -77,1 +75,1 @@\n- * Similarily, looking up the target address, given an original object address generally works as follows:\n+ * Similarly, looking up the target address, given an original object address generally works as follows:\n@@ -92,0 +90,35 @@\n+\n+  \/*\n+   * A simple hash-table that acts as fallback for the sliding forwarding.\n+   * This is used in the case of G1 serial compaction, which violates the\n+   * assumption of sliding forwarding that each object of any region is only\n+   * ever forwarded to one of two target regions. At this point, the GC is\n+   * scrambling to free up more Java heap memory, and therefore performance\n+   * is not the major concern.\n+   *\n+   * The implementation is a straightforward open hashtable.\n+   * It is a single-threaded (not thread-safe) implementation, and that\n+   * is sufficient because G1 serial compaction is single-threaded.\n+   *\/\n+  class FallbackTable : public CHeapObj<mtGC>{\n+  private:\n+    struct FallbackTableEntry {\n+      FallbackTableEntry* _next;\n+      HeapWord* _from;\n+      HeapWord* _to;\n+    };\n+\n+    static const uint TABLE_SIZE = 1024;\n+    FallbackTableEntry _table[TABLE_SIZE];\n+\n+    static size_t home_index(HeapWord* from);\n+\n+  public:\n+    FallbackTable();\n+    ~FallbackTable();\n+\n+    void forward_to(HeapWord* from, HeapWord* to);\n+    HeapWord* forwardee(HeapWord* from) const;\n+  };\n+\n+\n@@ -147,33 +180,0 @@\n-\/*\n- * A simple hash-table that acts as fallback for the sliding forwarding.\n- * This is used in the case of G1 serial compaction, which violates the\n- * assumption of sliding forwarding that each object of any region is only\n- * ever forwarded to one of two target regions. At this point, the GC is\n- * scrambling to free up more Java heap memory, and therefore performance\n- * is not the major concern.\n- *\n- * The implementation is a straightforward open hashtable.\n- * It is a single-threaded (not thread-safe) implementation, and that\n- * is sufficient because G1 serial compaction is single-threaded.\n- *\/\n-class FallbackTable : public CHeapObj<mtGC>{\n-private:\n-  struct FallbackTableEntry {\n-    FallbackTableEntry* _next;\n-    HeapWord* _from;\n-    HeapWord* _to;\n-  };\n-\n-  static const uint TABLE_SIZE = 1024;\n-  FallbackTableEntry _table[TABLE_SIZE];\n-\n-  static size_t home_index(HeapWord* from);\n-\n-public:\n-  FallbackTable();\n-  ~FallbackTable();\n-\n-  void forward_to(HeapWord* from, HeapWord* to);\n-  HeapWord* forwardee(HeapWord* from) const;\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.hpp","additions":37,"deletions":37,"binary":false,"changes":74,"status":"modified"}]}