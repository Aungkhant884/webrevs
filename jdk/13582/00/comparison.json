{"files":[{"patch":"@@ -79,0 +79,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -1689,0 +1690,2 @@\n+  GCForwarding::initialize(heap_rs.region(), HeapRegion::GrainWords);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -214,0 +215,2 @@\n+  GCForwarding::begin();\n+\n@@ -226,0 +229,2 @@\n+  GCForwarding::end();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -44,1 +45,1 @@\n-  if (obj->is_forwarded()) {\n+  if (GCForwarding::is_forwarded(obj)) {\n@@ -55,2 +56,2 @@\n-  assert(obj->is_forwarded(), \"Sanity!\");\n-  assert(obj->forwardee() != obj, \"Object must have a new location\");\n+  assert(GCForwarding::is_forwarded(obj), \"Sanity!\");\n+  assert(GCForwarding::forwardee(obj) != obj, \"Object must have a new location\");\n@@ -61,1 +62,1 @@\n-  HeapWord* destination = cast_from_oop<HeapWord*>(obj->forwardee());\n+  HeapWord* destination = cast_from_oop<HeapWord*>(GCForwarding::forwardee(obj));\n@@ -124,1 +125,1 @@\n-  HeapWord* destination = cast_from_oop<HeapWord*>(obj->forwardee());\n+  HeapWord* destination = cast_from_oop<HeapWord*>(GCForwarding::forwardee(obj));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -105,2 +106,2 @@\n-    object->forward_to(cast_to_oop(_compaction_top));\n-    assert(object->is_forwarded(), \"must be forwarded\");\n+    GCForwarding::forward_to(object, cast_to_oop(_compaction_top));\n+    assert(GCForwarding::is_forwarded(object), \"must be forwarded\");\n@@ -108,1 +109,1 @@\n-    assert(!object->is_forwarded(), \"must not be forwarded\");\n+    assert(GCForwarding::is_not_forwarded(object), \"must not be forwarded\");\n@@ -171,2 +172,2 @@\n-  obj->forward_to(cast_to_oop(dest_hr->bottom()));\n-  assert(obj->is_forwarded(), \"Object must be forwarded!\");\n+  GCForwarding::forward_to(obj, cast_to_oop(dest_hr->bottom()));\n+  assert(GCForwarding::is_forwarded(obj), \"Object must be forwarded!\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -68,2 +69,2 @@\n-  if (obj->is_forwarded()) {\n-    oop forwardee = obj->forwardee();\n+  if (GCForwarding::is_forwarded(obj)) {\n+    oop forwardee = GCForwarding::forwardee(obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -117,1 +118,1 @@\n-  if (obj->is_forwarded()) {\n+  if (GCForwarding::is_forwarded(obj)) {\n@@ -120,1 +121,1 @@\n-    if (cast_from_oop<HeapWord*>(obj->forwardee()) < _dense_prefix_top) {\n+    if (cast_from_oop<HeapWord*>(GCForwarding::forwardee(obj)) < _dense_prefix_top) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -90,0 +91,2 @@\n+  GCForwarding::begin();\n+\n@@ -108,0 +111,2 @@\n+  GCForwarding::end();\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -48,2 +49,2 @@\n-    if (obj->is_forwarded()) {\n-      oop new_obj = obj->forwardee();\n+    if (GCForwarding::is_forwarded(obj)) {\n+      oop new_obj = GCForwarding::forwardee(obj);\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/gcForwarding.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"gc\/shared\/slidingForwarding.hpp\"\n+\n+SlidingForwarding* GCForwarding::_sliding_forwarding = nullptr;\n+\n+void GCForwarding::initialize(MemRegion heap, size_t region_size_words) {\n+#ifdef _LP64\n+  if (UseAltGCForwarding) {\n+    assert(_sliding_forwarding == nullptr, \"only call this once\");\n+    _sliding_forwarding = new SlidingForwarding(heap, region_size_words);\n+  }\n+#endif\n+}\n+\n+void GCForwarding::begin() {\n+#ifdef _LP64\n+  if (UseAltGCForwarding) {\n+    assert(_sliding_forwarding != nullptr, \"expect sliding forwarding initialized\");\n+    _sliding_forwarding->begin();\n+  }\n+#endif\n+}\n+\n+void GCForwarding::end() {\n+#ifdef _LP64\n+  if (UseAltGCForwarding) {\n+    assert(_sliding_forwarding != nullptr, \"expect sliding forwarding initialized\");\n+    _sliding_forwarding->end();\n+  }\n+#endif\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/gcForwarding.cpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_GCFORWARDING_HPP\n+#define SHARE_GC_SHARED_GCFORWARDING_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"memory\/memRegion.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+class SlidingForwarding;\n+\n+class GCForwarding : public AllStatic {\n+private:\n+  static SlidingForwarding* _sliding_forwarding;\n+\n+public:\n+  static void initialize(MemRegion heap, size_t region_size_words_shift);\n+  static void begin();\n+  static void end();\n+\n+  static inline bool is_forwarded(oop obj);\n+  static inline bool is_not_forwarded(oop obj);\n+  static inline oop forwardee(oop obj);\n+  static inline void forward_to(oop obj, oop fwd);\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_GCFORWARDING_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/gcForwarding.hpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_GCFORWARDING_INLINE_HPP\n+#define SHARE_GC_SHARED_GCFORWARDING_INLINE_HPP\n+\n+#include \"gc\/shared\/gcForwarding.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+\n+inline bool GCForwarding::is_forwarded(oop obj) {\n+  return obj->is_forwarded();\n+}\n+\n+inline bool GCForwarding::is_not_forwarded(oop obj) {\n+  return !obj->is_forwarded();\n+}\n+\n+inline oop GCForwarding::forwardee(oop obj) {\n+#ifdef _LP64\n+  if (UseAltGCForwarding) {\n+    assert(_sliding_forwarding != nullptr, \"expect sliding forwarding initialized\");\n+    return _sliding_forwarding->forwardee(obj);\n+  } else\n+#endif\n+    return obj->forwardee();\n+}\n+\n+inline void GCForwarding::forward_to(oop obj, oop fwd) {\n+#ifdef _LP64\n+  if (UseAltGCForwarding) {\n+    assert(_sliding_forwarding != nullptr, \"expect sliding forwarding initialized\");\n+    _sliding_forwarding->forward_to(obj, fwd);\n+    assert(forwardee(obj) == fwd, \"must be forwarded to correct forwardee\");\n+  } else\n+#endif\n+    obj->forward_to(fwd);\n+}\n+\n+#endif \/\/ SHARE_GC_SHARED_GCFORWARDING_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/gcForwarding.inline.hpp","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -696,2 +696,6 @@\n-          constraint(GCCardSizeInBytesConstraintFunc,AtParse)\n-  \/\/ end of GC_FLAGS\n+          constraint(GCCardSizeInBytesConstraintFunc,AtParse)               \\\n+                                                                            \\\n+  product(bool, UseAltGCForwarding, true, EXPERIMENTAL,                    \\\n+          \"Use alternative GC forwarding that preserves object headers\")    \\\n+\n+\/\/ end of GC_FLAGS\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -135,0 +136,2 @@\n+  GCForwarding::initialize(_reserved, SpaceAlignment);\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -49,2 +50,2 @@\n-    if (obj->is_forwarded()) {\n-      elem->set_oop(obj->forwardee());\n+    if (GCForwarding::is_forwarded(obj)) {\n+      elem->set_oop(GCForwarding::forwardee(obj));\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifdef _LP64\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"gc\/shared\/slidingForwarding.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+\n+HeapWord* const SlidingForwarding::UNUSED_BASE = reinterpret_cast<HeapWord*>(0x1);\n+\n+SlidingForwarding::SlidingForwarding(MemRegion heap, size_t region_size_words)\n+  : _heap_start(heap.start()),\n+    _num_regions(((heap.end() - heap.start()) \/ region_size_words) + 1),\n+    _region_size_words_shift(log2i_exact(region_size_words)),\n+  _target_base_table(nullptr),\n+  _fallback_table(nullptr) {\n+  assert(_region_size_words_shift <= NUM_COMPRESSED_BITS, \"regions must not be larger than maximum addressing bits allow\");\n+  size_t heap_size_words = heap.end() - heap.start();\n+  if (UseSerialGC && heap_size_words <= (1 << NUM_COMPRESSED_BITS)) {\n+    \/\/ In this case we can treat the whole heap as a single region and\n+    \/\/ make the encoding very simple.\n+    _num_regions = 1;\n+    _region_size_words_shift = log2i_exact(round_up_power_of_2(heap_size_words));\n+  }\n+}\n+\n+SlidingForwarding::~SlidingForwarding() {\n+  if (_target_base_table != nullptr) {\n+    FREE_C_HEAP_ARRAY(HeapWord*, _target_base_table);\n+  }\n+  if (_fallback_table != nullptr) {\n+    delete _fallback_table;\n+  }\n+}\n+\n+void SlidingForwarding::begin() {\n+  assert(_target_base_table == nullptr, \"Should be uninitialized\");\n+  _target_base_table = NEW_C_HEAP_ARRAY(HeapWord*, _num_regions * NUM_TARGET_REGIONS, mtGC);\n+  size_t max = _num_regions * NUM_TARGET_REGIONS;\n+  for (size_t i = 0; i < max; i++) {\n+    _target_base_table[i] = UNUSED_BASE;\n+  }\n+}\n+\n+void SlidingForwarding::end() {\n+  assert(_target_base_table != nullptr, \"Should be initialized\");\n+  FREE_C_HEAP_ARRAY(HeapWord*, _target_base_table);\n+  _target_base_table = nullptr;\n+\n+  if (_fallback_table != nullptr) {\n+    delete _fallback_table;\n+    _fallback_table = nullptr;\n+  }\n+}\n+\n+void SlidingForwarding::fallback_forward_to(HeapWord* from, HeapWord* to) {\n+  if (_fallback_table == nullptr) {\n+    _fallback_table = new FallbackTable();\n+  }\n+  _fallback_table->forward_to(from, to);\n+}\n+\n+HeapWord* SlidingForwarding::fallback_forwardee(HeapWord* from) const {\n+  if (_fallback_table == nullptr) {\n+    return nullptr;\n+  } else {\n+    return _fallback_table->forwardee(from);\n+  }\n+}\n+\n+FallbackTable::FallbackTable() {\n+  for (size_t i = 0; i < TABLE_SIZE; i++) {\n+    _table[i]._next = nullptr;\n+    _table[i]._from = nullptr;\n+    _table[i]._to   = nullptr;\n+  }\n+}\n+\n+FallbackTable::~FallbackTable() {\n+  for (size_t i = 0; i < TABLE_SIZE; i++) {\n+    FallbackTableEntry* entry = _table[i]._next;\n+    while (entry != nullptr) {\n+      FallbackTableEntry* next = entry->_next;\n+      FREE_C_HEAP_OBJ(entry);\n+      entry = next;\n+    }\n+  }\n+}\n+\n+size_t FallbackTable::home_index(HeapWord* from) {\n+  uint64_t val = reinterpret_cast<uint64_t>(from);\n+  val *= 0xbf58476d1ce4e5b9ull;\n+  val ^= val >> 56;\n+  val *= 0x94d049bb133111ebull;\n+  val = (val * 11400714819323198485llu) >> (64 - log2i_exact(TABLE_SIZE));\n+  assert(val < TABLE_SIZE, \"must fit in table: val: \" UINT64_FORMAT \", table-size: \" UINTX_FORMAT \", table-size-bits: %d\", val, TABLE_SIZE, log2i_exact(TABLE_SIZE));\n+  return reinterpret_cast<uintx>(val);\n+}\n+\n+void FallbackTable::forward_to(HeapWord* from, HeapWord* to) {\n+  size_t idx = home_index(from);\n+  if (_table[idx]._from != nullptr) {\n+    FallbackTableEntry* entry = NEW_C_HEAP_OBJ(FallbackTableEntry, mtGC);\n+    entry->_next = _table[idx]._next;\n+    entry->_from = _table[idx]._from;\n+    entry->_to = _table[idx]._to;\n+    _table[idx]._next = entry;\n+  }\n+  _table[idx]._from = from;\n+  _table[idx]._to   = to;\n+}\n+\n+HeapWord* FallbackTable::forwardee(HeapWord* from) const {\n+  size_t idx = home_index(from);\n+  const FallbackTableEntry* entry = &_table[idx];\n+  while (entry != nullptr) {\n+    if (entry->_from == from) {\n+      return entry->_to;\n+    }\n+    entry = entry->_next;\n+  }\n+  return nullptr;\n+}\n+\n+#endif \/\/ _LP64\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.cpp","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_SLIDINGFORWARDING_HPP\n+#define SHARE_GC_SHARED_SLIDINGFORWARDING_HPP\n+\n+#ifdef _LP64\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/memRegion.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+class FallbackTable;\n+\n+\/**\n+ * SlidingForwarding is a method to store forwarding information in a compressed form into the object header,\n+ * that has been specifically designed for sliding compaction GCs.\n+ * It avoids overriding the compressed class pointer in the upper bits of the header, which would otherwise\n+ * be lost. SlidingForwarding requires only small side tables and guarantees constant-time access and modification.\n+ *\n+ * The idea is to use a pointer compression scheme very similar to the one that is used for compressed oops.\n+ * We divide the heap into number of logical regions. Each region spans maximum of 2^NUM_BITS words.\n+ * We take advantage of the fact that sliding compaction can forward objects from one region to a maximum of\n+ * two regions (including itself, but that does not really matter). We need 1 bit to indicate which region is forwarded\n+ * into. We also currently require the two lowest header bits to indicate that the object is forwarded.\n+ *\n+ * For addressing, we need a table with N*2 entries, for N logical regions. For each region, it gives the base\n+ * address of the two target regions, or a special placeholder if not used.\n+ *\n+ * Adding a forwarding then works as follows:\n+ * Given an original address 'orig', and a 'target' address:\n+ * - Look-up first target base of region of orig. If not yet used,\n+ *   establish it to be the base of region of target address. Use that base in step 3.\n+ * - Else, if first target base is already used, check second target base. This must either be unused, or the\n+ *   base of the region of our target address. If unused, establish it to be the base of the region of our target\n+ *   address. Use that base for next step.\n+ * - Now we found a base address. Encode the target address with that base into lowest NUM_BITS bits, and shift\n+ *   that up by 3 bits. Set the 3rd bit if we used the secondary target base, otherwise leave it at 0. Set the\n+ *   lowest two bits to indicate that the object has been forwarded. Store that in the lowest NUM_BITS+3 bits of the\n+ *   original object's header.\n+ *\n+ * Similarily, looking up the target address, given an original object address works as follows:\n+ * - Load lowest NUM_BITS + 3 from original object header. Extract target region bit and compressed address bits.\n+ * - Depending on target region bit, load base address from the target base table by looking up the corresponding entry\n+ *   for the region of the original object.\n+ * - Decode the target address by using the target base address and the compressed address bits.\n+ *\/\n+class SlidingForwarding : public CHeapObj<mtGC> {\n+private:\n+  static const uintptr_t MARK_LOWER_HALF_MASK = 0xffffffff;\n+\n+  \/\/ We need the lowest three bits to indicate a forwarded object and self-forwarding.\n+  static const int FALLBACK_SHIFT = markWord::lock_bits;\n+  static const int FALLBACK_BITS = 1;\n+  static const int FALLBACK_MASK = right_n_bits(FALLBACK_BITS) << FALLBACK_SHIFT;\n+  static const int REGION_SHIFT = FALLBACK_SHIFT + FALLBACK_BITS;\n+  static const int REGION_BITS = 1;\n+\n+  \/\/ The compressed address bits start here.\n+  static const int COMPRESSED_BITS_SHIFT = REGION_SHIFT + REGION_BITS;\n+\n+  \/\/ How many bits we use for the compressed pointer (we are going to need one more bit to indicate target region, and\n+  \/\/ two lowest bits to mark objects as forwarded)\n+  static const int NUM_COMPRESSED_BITS = 32 - COMPRESSED_BITS_SHIFT;\n+\n+  static const size_t NUM_TARGET_REGIONS = 1 << REGION_BITS;\n+\n+  \/\/ Indicates an usused base address in the target base table. We cannot use 0, because that may already be\n+  \/\/ a valid base address in zero-based heaps. 0x1 is safe because heap base addresses must be aligned by 2^X.\n+  static HeapWord* const UNUSED_BASE;\n+\n+  HeapWord*  const _heap_start;\n+  size_t           _num_regions;\n+  size_t           _region_size_words_shift;\n+  HeapWord**       _target_base_table;\n+\n+  FallbackTable* _fallback_table;\n+\n+  inline size_t region_index_containing(HeapWord* addr) const;\n+  inline bool region_contains(HeapWord* region_base, HeapWord* addr) const;\n+\n+  inline uintptr_t encode_forwarding(HeapWord* original, HeapWord* target);\n+  inline HeapWord* decode_forwarding(HeapWord* original, uintptr_t encoded) const;\n+\n+  void fallback_forward_to(HeapWord* from, HeapWord* to);\n+  HeapWord* fallback_forwardee(HeapWord* from) const;\n+\n+public:\n+  SlidingForwarding(MemRegion heap, size_t region_size_words);\n+  ~SlidingForwarding();\n+\n+  void begin();\n+  void end();\n+\n+  inline void forward_to(oop original, oop target);\n+  inline oop forwardee(oop original) const;\n+};\n+\n+\/*\n+ * A simple hash-table that acts as fallback for the sliding forwarding.\n+ * This is used in the case of G1 serial compactio, which violates the\n+ * assumption of sliding forwarding that each object of any region is only\n+ * ever forwarded to one of two target regions. At this point, the GC is\n+ * scrambling to free up more Java heap memory, and therefore performance\n+ * is not the major concern.\n+ *\n+ * The implementation is a straightforward open hashtable.\n+ * It is a single-threaded (not thread-safe) implementation, and that\n+ * is sufficient because G1 serial compaction is single-threaded.\n+ *\/\n+class FallbackTable : public CHeapObj<mtGC>{\n+private:\n+  struct FallbackTableEntry {\n+    FallbackTableEntry* _next;\n+    HeapWord* _from;\n+    HeapWord* _to;\n+  };\n+\n+  static const size_t TABLE_SIZE = 128;\n+  FallbackTableEntry _table[TABLE_SIZE];\n+\n+  static size_t home_index(HeapWord* from);\n+\n+public:\n+  FallbackTable();\n+  ~FallbackTable();\n+\n+  void forward_to(HeapWord* from, HeapWord* to);\n+  HeapWord* forwardee(HeapWord* from) const;\n+};\n+\n+#endif \/\/ _LP64\n+#endif \/\/ SHARE_GC_SHARED_SLIDINGFORWARDING_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.hpp","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_SLIDINGFORWARDING_INLINE_HPP\n+#define SHARE_GC_SHARED_SLIDINGFORWARDING_INLINE_HPP\n+\n+#ifdef _LP64\n+\n+#include \"gc\/shared\/slidingForwarding.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+\n+size_t SlidingForwarding::region_index_containing(HeapWord* addr) const {\n+  assert(addr >= _heap_start, \"sanity: addr: \" PTR_FORMAT \" heap base: \" PTR_FORMAT, p2i(addr), p2i(_heap_start));\n+  size_t index = ((size_t) (addr - _heap_start)) >> _region_size_words_shift;\n+  assert(index < _num_regions, \"Region index is in bounds: \" PTR_FORMAT, p2i(addr));\n+  return index;\n+}\n+\n+bool SlidingForwarding::region_contains(HeapWord* region_base, HeapWord* addr) const {\n+  return uintptr_t(addr - region_base) < (1u << _region_size_words_shift);\n+}\n+\n+\n+uintptr_t SlidingForwarding::encode_forwarding(HeapWord* original, HeapWord* target) {\n+  size_t orig_idx = region_index_containing(original);\n+  size_t base_table_idx = orig_idx * 2;\n+  size_t target_idx = region_index_containing(target);\n+  HeapWord* encode_base;\n+  uintptr_t region_idx;\n+  for (region_idx = 0; region_idx < NUM_TARGET_REGIONS; region_idx++) {\n+    encode_base = _target_base_table[base_table_idx + region_idx];\n+    if (encode_base == UNUSED_BASE) {\n+      encode_base = _heap_start + target_idx * (1 << _region_size_words_shift);\n+      _target_base_table[base_table_idx + region_idx] = encode_base;\n+      break;\n+    } else if (region_contains(encode_base, target)) {\n+      break;\n+    }\n+  }\n+  if (region_idx >= NUM_TARGET_REGIONS) {\n+    assert(UseG1GC, \"Only happens with G1 serial compaction\");\n+    return 1 << FALLBACK_SHIFT | markWord::marked_value;\n+  }\n+  assert(region_idx < NUM_TARGET_REGIONS, \"need to have found an encoding base\");\n+  assert(target >= encode_base, \"target must be above encode base, target:\" PTR_FORMAT \", encoded_base: \" PTR_FORMAT \",  target_idx: \" SIZE_FORMAT \", heap start: \" PTR_FORMAT \", region_idx: \" INTPTR_FORMAT,\n+         p2i(target), p2i(encode_base), target_idx, p2i(_heap_start), region_idx);\n+  assert(region_contains(encode_base, target), \"region must contain target: original: \" PTR_FORMAT \", target: \" PTR_FORMAT \", encode_base: \" PTR_FORMAT \", region_idx: \" INTPTR_FORMAT, p2i(original), p2i(target), p2i(encode_base), region_idx);\n+  uintptr_t encoded = (((uintptr_t)(target - encode_base)) << COMPRESSED_BITS_SHIFT) |\n+                      (region_idx << REGION_SHIFT) | markWord::marked_value;\n+  assert(target == decode_forwarding(original, encoded), \"must be reversible\");\n+  return encoded;\n+}\n+\n+HeapWord* SlidingForwarding::decode_forwarding(HeapWord* original, uintptr_t encoded) const {\n+  assert((encoded & markWord::marked_value) == markWord::marked_value, \"must be marked as forwarded\");\n+  size_t orig_idx = region_index_containing(original);\n+  size_t region_idx = (encoded >> REGION_SHIFT) & right_n_bits(REGION_BITS);\n+  size_t base_table_idx = orig_idx * 2 + region_idx;\n+  HeapWord* decoded = _target_base_table[base_table_idx] + (encoded >> COMPRESSED_BITS_SHIFT);\n+  assert(decoded >= _heap_start, \"must be above heap start, encoded: \" INTPTR_FORMAT \", region_idx: \" SIZE_FORMAT \", base: \" PTR_FORMAT, encoded, region_idx, p2i(_target_base_table[base_table_idx]));\n+  return decoded;\n+}\n+\n+void SlidingForwarding::forward_to(oop original, oop target) {\n+  assert(_target_base_table != nullptr, \"call begin() before forwarding\");\n+  markWord header = original->mark();\n+  if (header.has_displaced_mark_helper()) {\n+    header = header.displaced_mark_helper();\n+  }\n+  HeapWord* from = cast_from_oop<HeapWord*>(original);\n+  HeapWord* to   = cast_from_oop<HeapWord*>(target);\n+  uintptr_t encoded = encode_forwarding(from, to);\n+  header = markWord((header.value() & ~MARK_LOWER_HALF_MASK) | encoded);\n+  original->set_mark(header);\n+  if ((encoded & FALLBACK_MASK) != 0) {\n+    fallback_forward_to(from, to);\n+    return;\n+  }\n+}\n+\n+oop SlidingForwarding::forwardee(oop original) const {\n+  assert(_target_base_table != nullptr, \"call begin() before forwarding\");\n+  markWord header = original->mark();\n+  if ((header.value() & FALLBACK_MASK) != 0) {\n+    HeapWord* from = cast_from_oop<HeapWord*>(original);\n+    HeapWord* to = fallback_forwardee(from);\n+    return cast_to_oop(to);\n+  }\n+  uintptr_t encoded = header.value() & MARK_LOWER_HALF_MASK;\n+  HeapWord* forwardee = decode_forwarding(cast_from_oop<HeapWord*>(original), encoded);\n+  return cast_to_oop(forwardee);\n+}\n+\n+#endif \/\/ _LP64\n+#endif \/\/ SHARE_GC_SHARED_SLIDINGFORWARDING_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.inline.hpp","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -272,1 +273,1 @@\n-    q->forward_to(cast_to_oop(compact_top));\n+    GCForwarding::forward_to(q, cast_to_oop(compact_top));\n@@ -278,1 +279,1 @@\n-    assert(!q->is_forwarded(), \"should not be forwarded\");\n+    assert(GCForwarding::is_not_forwarded(q), \"should not be forwarded\");\n@@ -438,1 +439,1 @@\n-    if (!cast_to_oop(cur_obj)->is_forwarded()) {\n+    if (GCForwarding::is_not_forwarded(cast_to_oop(cur_obj))) {\n@@ -449,1 +450,1 @@\n-      HeapWord* compaction_top = cast_from_oop<HeapWord*>(cast_to_oop(cur_obj)->forwardee());\n+      HeapWord* compaction_top = cast_from_oop<HeapWord*>(GCForwarding::forwardee(cast_to_oop(cur_obj)));\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -224,0 +225,2 @@\n+    GCForwarding::begin();\n+\n@@ -237,0 +240,1 @@\n+    GCForwarding::end();\n@@ -366,1 +370,1 @@\n-    p->forward_to(cast_to_oop(_compact_point));\n+    GCForwarding::forward_to(p, cast_to_oop(_compact_point));\n@@ -474,1 +478,1 @@\n-        old_obj->forward_to(cast_to_oop(heap->get_region(start)->bottom()));\n+        GCForwarding::forward_to(old_obj, cast_to_oop(heap->get_region(start)->bottom()));\n@@ -734,2 +738,2 @@\n-      if (obj->is_forwarded()) {\n-        oop forw = obj->forwardee();\n+      if (GCForwarding::is_forwarded(obj)) {\n+        oop forw = GCForwarding::forwardee(obj);\n@@ -845,1 +849,1 @@\n-    if (p->is_forwarded()) {\n+    if (GCForwarding::is_forwarded(p)) {\n@@ -847,1 +851,1 @@\n-      HeapWord* compact_to = cast_from_oop<HeapWord*>(p->forwardee());\n+      HeapWord* compact_to = cast_from_oop<HeapWord*>(GCForwarding::forwardee(p));\n@@ -949,1 +953,1 @@\n-      if (!old_obj->is_forwarded()) {\n+      if (GCForwarding::is_not_forwarded(old_obj)) {\n@@ -958,1 +962,1 @@\n-      size_t new_start = heap->heap_region_index_containing(old_obj->forwardee());\n+      size_t new_start = heap->heap_region_index_containing(GCForwarding::forwardee(old_obj));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -407,0 +408,2 @@\n+  GCForwarding::initialize(_heap_region, ShenandoahHeapRegion::region_size_words());\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -58,0 +58,2 @@\n+  FlagSetting fs(UseAltGCForwarding, false);\n+\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_preservedMarks.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ Test simple forwarding within the same region.\n+TEST_VM(SlidingForwarding, simple) {\n+  HeapWord heap[16];\n+  oop obj1 = cast_to_oop(&heap[2]);\n+  oop obj2 = cast_to_oop(&heap[0]);\n+  SlidingForwarding sf(MemRegion(&heap[0], &heap[16]), 8);\n+  obj1->set_mark(markWord::prototype());\n+  sf.begin();\n+\n+  sf.forward_to(obj1, obj2);\n+  ASSERT_EQ(obj1->mark().value(), uintptr_t(3));\n+  ASSERT_EQ(sf.forwardee(obj1), obj2);\n+\n+  sf.end();\n+}\n+\n+\/\/ Test forwardings crossing 2 regions.\n+TEST_VM(SlidingForwarding, tworegions) {\n+  HeapWord heap[16];\n+  oop obj1 = cast_to_oop(&heap[14]);\n+  oop obj2 = cast_to_oop(&heap[2]);\n+  oop obj3 = cast_to_oop(&heap[10]);\n+  SlidingForwarding sf(MemRegion(&heap[0], &heap[16]), 8);\n+  obj1->set_mark(markWord::prototype());\n+  sf.begin();\n+\n+  sf.forward_to(obj1, obj2);\n+  ASSERT_EQ(obj1->mark().value(), uintptr_t((2 << 4) | 3));\n+  ASSERT_EQ(sf.forwardee(obj1), obj2);\n+\n+  sf.forward_to(obj1, obj3);\n+  ASSERT_EQ(obj1->mark().value(), uintptr_t((2 << 4) | (1 << 3) | 3));\n+  ASSERT_EQ(sf.forwardee(obj1), obj3);\n+\n+  sf.end();\n+}\n+\n+\/\/ Test fallback forwardings crossing 4 regions.\n+TEST_VM(SlidingForwarding, fallback) {\n+  HeapWord heap[16];\n+  oop obj1 = cast_to_oop(&heap[14]);\n+  oop obj2 = cast_to_oop(&heap[2]);\n+  oop obj3 = cast_to_oop(&heap[4]);\n+  oop obj4 = cast_to_oop(&heap[10]);\n+  oop obj5 = cast_to_oop(&heap[12]);\n+  SlidingForwarding sf(MemRegion(&heap[0], &heap[16]), 4);\n+  obj1->set_mark(markWord::prototype());\n+  sf.begin();\n+\n+  sf.forward_to(obj1, obj2);\n+  ASSERT_EQ(obj1->mark().value(), uintptr_t((2 << 4) | 3));\n+  ASSERT_EQ(sf.forwardee(obj1), obj2);\n+\n+  sf.forward_to(obj1, obj3);\n+  ASSERT_EQ(obj1->mark().value(), uintptr_t((1 << 3) | 3));\n+  ASSERT_EQ(sf.forwardee(obj1), obj3);\n+\n+  sf.forward_to(obj1, obj4);\n+  ASSERT_EQ(obj1->mark().value(), uintptr_t((1 << 2) | 3));\n+  ASSERT_EQ(sf.forwardee(obj1), obj4);\n+\n+  sf.forward_to(obj1, obj5);\n+  ASSERT_EQ(obj1->mark().value(), uintptr_t((1 << 2) | 3));\n+  ASSERT_EQ(sf.forwardee(obj1), obj5);\n+\n+  sf.end();\n+}\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_slidingForwarding.cpp","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"}]}