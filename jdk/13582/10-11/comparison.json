{"files":[{"patch":"@@ -40,3 +40,6 @@\n- * that has been specifically designed for sliding compaction GCs.\n- * It avoids overriding the compressed class pointer in the upper bits of the header, which would otherwise\n- * be lost. SlidingForwarding requires only small side tables and guarantees constant-time access and modification.\n+ * that has been specifically designed for sliding compaction GCs and compact object headers. With compact object\n+ * headers, we store the compressed class pointer in the header, which would be overwritten by full forwarding\n+ * pointer, if we allow the legacy forwarding code to act. This would lose the class information for the object,\n+ * which is required later in GC cycle to iterate the reference fields and get the object size for copying.\n+ *\n+ * SlidingForwarding requires only small side tables and guarantees constant-time access and modification.\n@@ -46,33 +49,78 @@\n- * We take advantage of the fact that sliding compaction can forward objects from one region to a maximum of\n- * two regions (including itself, but that does not really matter). We need 1 bit to indicate which region is forwarded\n- * into. We also currently require the two lowest header bits to indicate that the object is forwarded. In addition to that,\n- * we use 1 more bit to indicate that we should use a fallback-lookup-table instead of using the sliding encoding.\n- *\n- * For addressing, we need a table with N*2 entries, for N logical regions. For each region, it gives the base\n- * address of the two target regions, or a special placeholder if not used.\n- *\n- * Adding a forwarding then works as follows:\n- * Given an original address 'orig', and a 'target' address:\n- * - Look-up first target base of region of orig. If it is already established and the region\n- *   that 'target' is in, then use it in step 3. If not yet used, establish it to be the base of region of target\n-     address. Use that base in step 3.\n- * - Else, if first target base is already used, check second target base. This must either be unused, or the\n- *   base of the region of our target address. If unused, establish it to be the base of the region of our target\n- *   address. Use that base for next step.\n- * - Now we found a base address. Encode the target address with that base into lowest NUM_COMPRESSED_BITS bits, and shift\n- *   that up by 4 bits. Set the 3rd bit if we used the secondary target base, otherwise leave it at 0. Set the\n- *   lowest two bits to indicate that the object has been forwarded. Store that in the lowest 32 bits of the\n- *   original object's header.\n- *\n- * Similarily, looking up the target address, given an original object address works as follows:\n- * - Load lowest 32 from original object header. Extract target region bit and compressed address bits.\n- * - Depending on target region bit, load base address from the target base table by looking up the corresponding entry\n- *   for the region of the original object.\n- * - Decode the target address by using the target base address and the compressed address bits.\n- *\n- * One complication is that G1 serial compaction breaks the assumption that we only forward\n- * to two target regions. When that happens, we initialize a fallback-hashtable for storing those extra\n- * forwardings, and set the 4th bit in the header to indicate that the forwardee is not encoded but\n- * should be looked-up in the hashtable. G1 serial compaction is not very common -  it is the last-last-ditch\n- * GC that is used when the JVM is scrambling to squeeze more space out of the heap, and at that\n- * point, ultimate performance is no longer the main concern.\n+ *\n+ * The key advantage of sliding compaction for encoding efficiency: it can forward objects from one region to a\n+ * maximum of two regions. This is an intuitive property: when we slide the compact region full of data, it can\n+ * only span two adjacent regions. This property allows us to use the off-side table to record the addresses of\n+ * two target regions. The table table holds N*2 entries for N logical regions. For each region, it gives the base\n+ * address of the two target regions, or a special placeholder if not used. A single bit in forwarding would\n+ * indicate to which of the two \"to\" regions the object is forwarded into.\n+ *\n+ * This encoding efficiency allows to store the forwarding information in the object header _together_ with the\n+ * compressed class pointer.\n+ *\n+ * When recording the sliding forwarding, the mark word would look roughly like this:\n+ *\n+ *    0                        32                     64\n+ *    [TT|F|A|OOOOOOOOOOOOOOOOO|......................]\n+ *      ^----------------------------------------------- normal lock bits, would record \"object is forwarded\"\n+ *        ^--------------------------------------------- fallback bit (explained below)\n+ *          ^------------------------------------------- alternate region select\n+ *            ^----------------------------------------- in-region offset\n+ *                              ^----------------------- compressed class pointer (not handled, but also *not touched* by this code)\n+ *\n+ * Adding a forwarding then generally works as follows:\n+ *\n+ *   void forward_to(oop* from, oop* to) {\n+ *     \/\/ Identifying the offset in the target region is easy:\n+ *     intptr_t to_region_addr = oop_to_region_addr(to);\n+ *     u4 mark_offset = encode_offset(to_region_addr, to);\n+ *\n+ *     \/\/ Now we need to record the target region address in the bases table.\n+ *     \/\/ There are two entries per region: primary and alternative.\n+ *     int reg_prim = oop_to_region_idx(from);\n+ *     int reg_alt = reg_prim + 1;\n+ *\n+ *     bool alt_region = false;\n+ *     if (bases_table[reg_prim] == UNUSED) {\n+ *       \/\/ Primary entry is free, take it.\n+ *       bases_table[reg_prim] = to_region_addr;\n+ *     } else if (bases_table[reg_prim] != to_region_addr) {\n+ *       \/\/ Primary entry is taken by incompatible \"to\" address, use the alternate.\n+ *       if (bases_table[reg_alt] == UNUSED) {\n+ *         \/\/ Alternate is unused, take it.\n+ *         bases_table[reg_alt] = to_region_addr;\n+ *       } else {\n+ *         \/\/ Since we see two \"to\" regions only, we know alternate entry has the\n+ *         \/\/ correct \"to\" address for this mapping.\n+ *       }\n+ *       alt_region = true;\n+ *     }\n+ *\n+ *     \/\/ All done, we only need to record which mapping to use\n+ *     u1 mark_region_select = encode_region_select(alt_region);\n+ *\n+ *     \/\/ Store everything in the object header\n+ *     from->update_mark(FORWARDED | mark_region_select | mark_offset);\n+ *   }\n+ *\n+ * Similarily, looking up the target address, given an original object address generally works as follows:\n+ *\n+ *   oop* forwardee(oop* obj) {\n+ *     \/\/ Load and decode the forwarding\n+ *     mark m = obj->mark();\n+ *     u1 region_select = decode_region_select(m);\n+ *     u4 offset = decode_offset(m);\n+ *\n+ *     \/\/ Figure out which region the original region is forwarded to:\n+ *     int reg_idx = oop_to_region_idx(obj) + region_select;\n+ *     intptr_t fwd_base = bases_table[reg_idx];\n+ *\n+ *     \/\/ Compute the forwarding address\n+ *     return fwd_base + offset;\n+ *   }\n+ *\n+ * This algorithm is broken by G1 last-ditch serial compaction: there, object from a single region can be\n+ * forwarded to multiple, more than two regions. To deal with that, we initialize a fallback-hashtable for\n+ * storing those extra forwardings, and set another bit in the header to indicate that the forwardee is not\n+ * encoded but should be looked-up in the hashtable. G1 serial compaction is not very common - it is the\n+ * last-last-ditch GC that is used when the JVM is scrambling to squeeze more space out of the heap, and at\n+ * that point, ultimate performance is no longer the main concern.\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.hpp","additions":84,"deletions":36,"binary":false,"changes":120,"status":"modified"}]}