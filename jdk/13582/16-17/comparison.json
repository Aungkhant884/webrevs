{"files":[{"patch":"@@ -35,1 +35,1 @@\n-\/\/ 0x1 is safe because heap base addresses must be aligned by much larger alginemnt\n+\/\/ 0x1 is safe because heap base addresses must be aligned by much larger alignment\n@@ -45,0 +45,2 @@\n+  assert(_region_size_words >= 1, \"regions must be at least a word large\");\n+  assert(_region_size_words <= pointer_delta(heap.end(), heap.start()), \"\");\n@@ -57,8 +59,4 @@\n-  if (_bases_table != nullptr) {\n-    FREE_C_HEAP_ARRAY(HeapWord*, _bases_table);\n-    _bases_table = nullptr;\n-  }\n-  if (_fallback_table != nullptr) {\n-    delete _fallback_table;\n-    _fallback_table = nullptr;\n-  }\n+  FREE_C_HEAP_ARRAY(region_bases, _bases_table);\n+  _bases_table = nullptr;\n+  delete _fallback_table;\n+  _fallback_table = nullptr;\n@@ -81,4 +79,2 @@\n-  if (_fallback_table != nullptr) {\n-    delete _fallback_table;\n-    _fallback_table = nullptr;\n-  }\n+  delete _fallback_table;\n+  _fallback_table = nullptr;\n@@ -118,1 +114,1 @@\n-size_t FallbackTable::home_index(HeapWord* from) {\n+uint FallbackTable::home_index(HeapWord* from) {\n@@ -129,2 +125,2 @@\n-  size_t idx = static_cast<size_t>(val);\n-  assert(idx < TABLE_SIZE, \"must fit in table: idx: \" SIZE_FORMAT \", table-size: \" SIZE_FORMAT \", table-size-bits: %d\",\n+  uint idx = static_cast<uint>(val);\n+  assert(idx < TABLE_SIZE, \"must fit in table: idx: %u, table-size: %u, table-size-bits: %d\",\n@@ -136,7 +132,10 @@\n-  size_t idx = home_index(from);\n-  if (_table[idx]._from != nullptr) {\n-    FallbackTableEntry* entry = NEW_C_HEAP_OBJ(FallbackTableEntry, mtGC);\n-    entry->_next = _table[idx]._next;\n-    entry->_from = _table[idx]._from;\n-    entry->_to = _table[idx]._to;\n-    _table[idx]._next = entry;\n+  uint idx = home_index(from);\n+  HeapWord* found = _table[idx]._from;\n+  if (found != nullptr) {\n+    if (found != from) {\n+      FallbackTableEntry* entry = NEW_C_HEAP_OBJ(FallbackTableEntry, mtGC);\n+      entry->_next = _table[idx]._next;\n+      entry->_from = _table[idx]._from;\n+      entry->_to = _table[idx]._to;\n+      _table[idx]._next = entry;\n+    } \/\/ Else fall-through and update entry below.\n@@ -151,1 +150,1 @@\n-  size_t idx = home_index(from);\n+  uint idx = home_index(from);\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.cpp","additions":23,"deletions":24,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-  static const size_t TABLE_SIZE = 1024;\n+  static const uint TABLE_SIZE = 1024;\n@@ -168,1 +168,1 @@\n-  static size_t home_index(HeapWord* from);\n+  static uint home_index(HeapWord* from);\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  } else if (region_contains(_bases_table[base_idx], to)) {\n+  } else if (_bases_table[base_idx] == to_region_base) {\n@@ -63,1 +63,1 @@\n-    } else if (region_contains(_bases_table[base_idx_alt], to)) {\n+    } else if (_bases_table[base_idx_alt] == to_region_base) {\n@@ -88,0 +88,1 @@\n+  assert((encoded & FALLBACK_MASK) == 0, \"must not be fallback-forwarded\");\n@@ -95,1 +96,3 @@\n-  HeapWord* decoded = _bases_table[base_idx] + offset;\n+  HeapWord* base = _bases_table[base_idx];\n+  assert(base != UNUSED_BASE, \"must not be unused base\");\n+  HeapWord* decoded = base + offset;\n@@ -98,1 +101,1 @@\n-         encoded, alt_region, p2i(_bases_table[base_idx]));\n+         encoded, alt_region, p2i(base));\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.inline.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"}]}