{"files":[{"patch":"@@ -1182,1 +1182,1 @@\n-static ResourceHashtable<\n+class LoadedUnregisteredClassesTable : public ResourceHashtable<\n@@ -1187,1 +1187,3 @@\n-  ResourceObj::C_HEAP> _loaded_unregistered_classes;\n+  ResourceObj::C_HEAP> {};\n+\n+static LoadedUnregisteredClassesTable* _loaded_unregistered_classes = NULL;\n@@ -1193,0 +1195,3 @@\n+  if (_loaded_unregistered_classes == NULL) {\n+    _loaded_unregistered_classes = new (ResourceObj::C_HEAP, mtClass)LoadedUnregisteredClassesTable();\n+  }\n@@ -1194,1 +1199,1 @@\n-  _loaded_unregistered_classes.put_if_absent(name, true, &created);\n+  _loaded_unregistered_classes->put_if_absent(name, true, &created);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -48,0 +49,21 @@\n+class AdapterHandlerEntry;\n+\n+class MethodTrampolineInfo {\n+  address _c2i_entry_trampoline;\n+  AdapterHandlerEntry** _adapter_trampoline;\n+public:\n+  address c2i_entry_trampoline() { return _c2i_entry_trampoline; }\n+  AdapterHandlerEntry** adapter_trampoline() { return _adapter_trampoline; }\n+  void set_c2i_entry_trampoline(address addr) { _c2i_entry_trampoline = addr; }\n+  void set_adapter_trampoline(AdapterHandlerEntry** entry) { _adapter_trampoline = entry; }\n+};\n+\n+class AdapterToTrampoline : public ResourceHashtable<\n+  AdapterHandlerEntry*, MethodTrampolineInfo,\n+  primitive_hash<AdapterHandlerEntry*>,\n+  primitive_equals<AdapterHandlerEntry*>,\n+  941, \/\/ prime number\n+  ResourceObj::C_HEAP> {};\n+\n+static AdapterToTrampoline* _adapter_to_trampoline = NULL;\n+\n@@ -262,0 +284,2 @@\n+    allocate_method_trampoline_info();\n+    allocate_method_trampolines();\n@@ -801,0 +825,86 @@\n+\n+void ArchiveBuilder::allocate_method_trampolines_for(InstanceKlass* ik) {\n+  if (ik->methods() != NULL) {\n+    for (int j = 0; j < ik->methods()->length(); j++) {\n+      \/\/ Walk the methods in a deterministic order so that the trampolines are\n+      \/\/ created in a deterministic order.\n+      Method* m = ik->methods()->at(j);\n+      AdapterHandlerEntry* ent = m->adapter(); \/\/ different methods can share the same AdapterHandlerEntry\n+      MethodTrampolineInfo* info = _adapter_to_trampoline->get(ent);\n+      if (info->c2i_entry_trampoline() == NULL) {\n+        info->set_c2i_entry_trampoline(\n+          (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size()));\n+        info->set_adapter_trampoline(\n+          (AdapterHandlerEntry**)MetaspaceShared::misc_code_space_alloc(sizeof(AdapterHandlerEntry*)));\n+      }\n+    }\n+  }\n+}\n+\n+void ArchiveBuilder::allocate_method_trampolines() {\n+  for (int i = 0; i < _klasses->length(); i++) {\n+    Klass* k = _klasses->at(i);\n+    if (k->is_instance_klass()) {\n+      InstanceKlass* ik = InstanceKlass::cast(k);\n+      allocate_method_trampolines_for(ik);\n+    }\n+  }\n+}\n+\n+\/\/ Allocate MethodTrampolineInfo for all Methods that will be archived. Also\n+\/\/ return the total number of bytes needed by the method trampolines in the MC\n+\/\/ region.\n+size_t ArchiveBuilder::allocate_method_trampoline_info() {\n+  size_t total = 0;\n+  size_t each_method_bytes =\n+    align_up(SharedRuntime::trampoline_size(), BytesPerWord) +\n+    align_up(sizeof(AdapterHandlerEntry*), BytesPerWord);\n+\n+  if (_adapter_to_trampoline == NULL) {\n+    _adapter_to_trampoline = new (ResourceObj::C_HEAP, mtClass)AdapterToTrampoline();\n+  }\n+  int count = 0;\n+  for (int i = 0; i < _klasses->length(); i++) {\n+    Klass* k = _klasses->at(i);\n+    if (k->is_instance_klass()) {\n+      InstanceKlass* ik = InstanceKlass::cast(k);\n+      if (ik->methods() != NULL) {\n+        for (int j = 0; j < ik->methods()->length(); j++) {\n+          Method* m = ik->methods()->at(j);\n+          AdapterHandlerEntry* ent = m->adapter(); \/\/ different methods can share the same AdapterHandlerEntry\n+          bool is_created = false;\n+          MethodTrampolineInfo* info = _adapter_to_trampoline->put_if_absent(ent, &is_created);\n+          if (is_created) {\n+            count++;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  if (count == 0) {\n+    \/\/ We have nothing to archive, but let's avoid having an empty region.\n+    total = SharedRuntime::trampoline_size();\n+  } else {\n+    total = count * each_method_bytes;\n+  }\n+  return align_up(total, SharedSpaceObjectAlignment);\n+}\n+\n+void ArchiveBuilder::update_method_trampolines() {\n+  for (int i = 0; i < klasses()->length(); i++) {\n+    Klass* k = klasses()->at(i);\n+    if (k->is_instance_klass()) {\n+      InstanceKlass* ik = InstanceKlass::cast(k);\n+      Array<Method*>* methods = ik->methods();\n+      for (int j = 0; j < methods->length(); j++) {\n+        Method* m = methods->at(j);\n+        AdapterHandlerEntry* ent = m->adapter();\n+        MethodTrampolineInfo* info = _adapter_to_trampoline->get(ent);\n+        \/\/ m is the \"copy\" of the original Method, but its adapter() field is still valid because\n+        \/\/ we haven't called make_klasses_shareable() yet.\n+        m->set_from_compiled_entry(to_target(info->c2i_entry_trampoline()));\n+        m->set_adapter_trampoline(to_target(info->adapter_trampoline()));\n+      }\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.cpp","additions":110,"deletions":0,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -282,0 +282,7 @@\n+\n+  \/\/ Method trampolines related functions\n+  void allocate_method_trampolines();\n+  void allocate_method_trampolines_for(InstanceKlass* ik);\n+  size_t allocate_method_trampoline_info();\n+  void update_method_trampolines();\n+\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -96,1 +96,0 @@\n-  size_t estimate_trampoline_size();\n@@ -101,1 +100,0 @@\n-  void make_trampolines();\n@@ -119,6 +117,0 @@\n-  void reserve_buffers_for_trampolines() {\n-    size_t n = _estimated_trampoline_bytes;\n-    assert(n >= SharedRuntime::trampoline_size(), \"dont want to be empty\");\n-    MetaspaceShared::misc_code_space_alloc(n);\n-  }\n-\n@@ -187,1 +179,1 @@\n-    reserve_buffers_for_trampolines();\n+    allocate_method_trampolines();\n@@ -224,1 +216,1 @@\n-    make_trampolines();\n+    update_method_trampolines();\n@@ -257,1 +249,1 @@\n-  _estimated_trampoline_bytes = estimate_trampoline_size();\n+  _estimated_trampoline_bytes = allocate_method_trampoline_info();\n@@ -340,48 +332,0 @@\n-size_t DynamicArchiveBuilder::estimate_trampoline_size() {\n-  size_t total = 0;\n-  size_t each_method_bytes =\n-    align_up(SharedRuntime::trampoline_size(), BytesPerWord) +\n-    align_up(sizeof(AdapterHandlerEntry*), BytesPerWord);\n-\n-  for (int i = 0; i < klasses()->length(); i++) {\n-    Klass* k = klasses()->at(i);\n-    if (k->is_instance_klass()) {\n-      Array<Method*>* methods = InstanceKlass::cast(k)->methods();\n-      total += each_method_bytes * methods->length();\n-    }\n-  }\n-  if (total == 0) {\n-    \/\/ We have nothing to archive, but let's avoid having an empty region.\n-    total = SharedRuntime::trampoline_size();\n-  }\n-  return align_up(total, SharedSpaceObjectAlignment);\n-}\n-\n-void DynamicArchiveBuilder::make_trampolines() {\n-  DumpRegion* mc_space = MetaspaceShared::misc_code_dump_space();\n-  char* p = mc_space->base();\n-  for (int i = 0; i < klasses()->length(); i++) {\n-    Klass* k = klasses()->at(i);\n-    if (!k->is_instance_klass()) {\n-      continue;\n-    }\n-    InstanceKlass* ik = InstanceKlass::cast(k);\n-    Array<Method*>* methods = ik->methods();\n-    for (int j = 0; j < methods->length(); j++) {\n-      Method* m = methods->at(j);\n-      address c2i_entry_trampoline = (address)p;\n-      p += SharedRuntime::trampoline_size();\n-      assert(p >= mc_space->base() && p <= mc_space->top(), \"must be\");\n-      m->set_from_compiled_entry(to_target(c2i_entry_trampoline));\n-\n-      AdapterHandlerEntry** adapter_trampoline =(AdapterHandlerEntry**)p;\n-      p += sizeof(AdapterHandlerEntry*);\n-      assert(p >= mc_space->base() && p <= mc_space->top(), \"must be\");\n-      *adapter_trampoline = NULL;\n-      m->set_adapter_trampoline(to_target(adapter_trampoline));\n-    }\n-  }\n-\n-  guarantee(p <= mc_space->top(), \"Estimate of trampoline size is insufficient\");\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/dynamicArchive.cpp","additions":3,"deletions":59,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -773,0 +773,3 @@\n+  log_info(cds)(\"Update method trampolines\");\n+  builder.update_method_trampolines();\n+\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1110,8 +1110,2 @@\n-  if (DynamicDumpSharedSpaces) {\n-    assert(_from_compiled_entry != NULL, \"sanity\");\n-  } else {\n-    \/\/ TODO: Simplify the adapter trampoline allocation for static archiving.\n-    \/\/       Remove the use of CDSAdapterHandlerEntry.\n-    CDSAdapterHandlerEntry* cds_adapter = (CDSAdapterHandlerEntry*)adapter();\n-    constMethod()->set_adapter_trampoline(cds_adapter->get_adapter_trampoline());\n-    _from_compiled_entry = cds_adapter->get_c2i_entry_trampoline();\n+  assert(_from_compiled_entry != NULL, \"sanity\");\n+  if (DumpSharedSpaces) {\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2457,1 +2457,1 @@\n-    : BasicHashtable<mtCode>(293, (DumpSharedSpaces ? sizeof(CDSAdapterHandlerEntry) : sizeof(AdapterHandlerEntry))) { }\n+    : BasicHashtable<mtCode>(293, (sizeof(AdapterHandlerEntry))) { }\n@@ -2463,3 +2463,0 @@\n-    if (DumpSharedSpaces) {\n-      ((CDSAdapterHandlerEntry*)entry)->init();\n-    }\n@@ -3133,11 +3130,0 @@\n-#if INCLUDE_CDS\n-\n-void CDSAdapterHandlerEntry::init() {\n-  assert(DumpSharedSpaces, \"used during dump time only\");\n-  _c2i_entry_trampoline = (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size());\n-  _adapter_trampoline = (AdapterHandlerEntry**)MetaspaceShared::misc_code_space_alloc(sizeof(AdapterHandlerEntry*));\n-};\n-\n-#endif \/\/ INCLUDE_CDS\n-\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -682,14 +682,0 @@\n-\/\/ This class is used only with DumpSharedSpaces==true. It holds extra information\n-\/\/ that's used only during CDS dump time.\n-\/\/ For details, see comments around Method::link_method()\n-class CDSAdapterHandlerEntry: public AdapterHandlerEntry {\n-  address               _c2i_entry_trampoline;   \/\/ allocated from shared spaces \"MC\" region\n-  AdapterHandlerEntry** _adapter_trampoline;     \/\/ allocated from shared spaces \"MD\" region\n-\n-public:\n-  address get_c2i_entry_trampoline()             const { return _c2i_entry_trampoline; }\n-  AdapterHandlerEntry** get_adapter_trampoline() const { return _adapter_trampoline; }\n-  void init() NOT_CDS_RETURN;\n-};\n-\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"}]}