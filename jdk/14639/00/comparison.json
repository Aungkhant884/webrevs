{"files":[{"patch":"@@ -238,0 +238,1 @@\n+    \/\/ For externalization lint checking\n@@ -239,0 +240,2 @@\n+    public final Type objectInputType;\n+    public final Type objectOutputType;\n@@ -625,0 +628,2 @@\n+        objectInputType  = enterClass(\"java.io.ObjectInput\");\n+        objectOutputType = enterClass(\"java.io.ObjectOutput\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4768,2 +4768,1 @@\n-        }\n-        catch (CompletionFailure e) {\n+        } catch (CompletionFailure e) {\n@@ -5140,0 +5139,27 @@\n+        private void checkWriteExternalRecord(JCClassDecl tree, Element e, MethodSymbol method) {\n+            \/\/public void writeExternal(ObjectOutput) throws IOException\n+            checkExternMethodRecord(tree, e, method, syms.objectOutputType);\n+        }\n+\n+        private void checkReadExternalRecord(JCClassDecl tree, Element e, MethodSymbol method) {\n+             \/\/ public void readExternal(ObjectInput) throws IOException\n+            checkExternMethodRecord(tree, e, method, syms.objectInputType);\n+         }\n+\n+        private void checkExternMethodRecord(JCClassDecl tree, Element e, MethodSymbol method, Type argType) {\n+            long flags = method.flags();\n+\n+            if (isExternalizable((Type)(e.asType()))) {\n+                Type rtype = method.getReturnType();\n+                if ( ((flags & PUBLIC) != 0) &&\n+                     ((flags & STATIC) == 0) &&\n+                     types.isSameType(syms.voidType, rtype) &&\n+                     hasExactlyOneArgWithType(tree, e, method, argType)) {\n+                    \/\/ Not necessary to check throws clause in this context\n+                    log.warning(LintCategory.SERIAL,\n+                                TreeInfo.diagnosticPositionFor(method, tree),\n+                                Warnings.IneffectualExternalizableMethodRecord(method.getSimpleName().toString()));\n+                }\n+            }\n+        }\n+\n@@ -5327,0 +5353,3 @@\n+                        case \"writeExternal\" -> checkWriteExternalRecord(tree, e, method);\n+                        case \"readExternal\"  -> checkReadExternalRecord(tree, e, method);\n+\n@@ -5396,0 +5425,10 @@\n+        private boolean hasExactlyOneArgWithType(JCClassDecl tree,\n+                                                 Element enclosing,\n+                                                 MethodSymbol method,\n+                                                 Type expectedType) {\n+            var parameters= method.getParameters();\n+            return (parameters.size() == 1) &&\n+                types.isSameType(parameters.get(0).asType(), expectedType);\n+        }\n+\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":41,"deletions":2,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2025,0 +2025,4 @@\n+# 0: string\n+compiler.warn.ineffectual.externalizable.method.record=\\\n+    externalization-related method {0} is not effective in a record class\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.ineffectual.externalizable.method.record\n+\n+\/\/ options: -Xlint:serial\n+\n+import java.io.*;\n+\n+record IneffectualExternRecord(int foo) implements Externalizable {\n+    @Override\n+    public void writeExternal(ObjectOutput oo) {\n+        ;\n+    }\n+\n+    @Override\n+    public void readExternal(ObjectInput oi) {\n+        ;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/IneffectualExternRecord.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8310835\n+ * @compile\/ref=RecordExtern.out -XDrawDiagnostics -Xlint:serial RecordExtern.java\n+ *\/\n+\n+import java.io.*;\n+\n+record RecordExtern(int foo) implements Externalizable {\n+    \/\/ Verify a warning is generated in a record class for each of the\n+    \/\/ ineffectual extern methods.\n+\n+    \/\/ ineffective Externalizable methods\n+    @Override\n+    public void writeExternal(ObjectOutput oo) {\n+        ;\n+    }\n+\n+    @Override\n+    public void readExternal(ObjectInput oi) {\n+        ;\n+    }\n+\n+    \/\/ *Not* Externalizable methods\n+    public void writeExternal() {\n+        ;\n+    }\n+\n+    public void readExternal() {\n+        ;\n+    }\n+\n+    \/\/ Check warnings for serialization methods and fields too\n+\n+    \/\/ partially effective\n+    private static final long serialVersionUID = 42;\n+\n+    \/\/ ineffectual\n+    private static final ObjectStreamField[] serialPersistentFields = {};\n+\n+    \/\/ ineffectual\n+    private void writeObject(ObjectOutputStream stream) throws IOException {\n+        stream.defaultWriteObject();\n+    }\n+\n+    \/\/ (possibly) effective\n+    private Object writeReplace() throws ObjectStreamException {\n+        return null;\n+    }\n+\n+    \/\/ ineffectual\n+    private void readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+    }\n+\n+    \/\/ ineffectual\n+    private void readObjectNoData() throws ObjectStreamException {\n+        return;\n+    }\n+\n+    \/\/ (possibly) effective\n+    private Object readResolve() throws ObjectStreamException {\n+        return null;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/RecordExtern.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+RecordExtern.java:15:17: compiler.warn.ineffectual.externalizable.method.record: writeExternal\n+RecordExtern.java:20:17: compiler.warn.ineffectual.externalizable.method.record: readExternal\n+RecordExtern.java:39:46: compiler.warn.ineffectual.serial.field.record\n+RecordExtern.java:42:18: compiler.warn.ineffectual.serial.method.record: writeObject\n+RecordExtern.java:52:18: compiler.warn.ineffectual.serial.method.record: readObject\n+RecordExtern.java:58:18: compiler.warn.ineffectual.serial.method.record: readObjectNoData\n+6 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/RecordExtern.out","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"}]}