{"files":[{"patch":"@@ -16364,1 +16364,1 @@\n-instruct string_indexofU_char(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n+instruct string_indexof_char(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n@@ -16369,0 +16369,1 @@\n+  predicate(((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::U);\n@@ -16372,1 +16373,1 @@\n-  format %{ \"String IndexOf char[] $str1,$cnt1,$ch -> $result\" %}\n+  format %{ \"StringUTF16 IndexOf char[] $str1,$cnt1,$ch -> $result\" %}\n@@ -16382,0 +16383,19 @@\n+instruct stringL_indexof_char(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n+                              iRegI_R0 result, iRegINoSp tmp1, iRegINoSp tmp2,\n+                              iRegINoSp tmp3, rFlagsReg cr)\n+%{\n+  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n+  predicate(((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::L);\n+  effect(USE_KILL str1, USE_KILL cnt1, USE_KILL ch,\n+         TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+\n+  format %{ \"StringLatin1 IndexOf char[] $str1,$cnt1,$ch -> $result\" %}\n+\n+  ins_encode %{\n+    __ stringL_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register,\n+                           $result$$Register, $tmp1$$Register, $tmp2$$Register,\n+                           $tmp3$$Register);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -541,0 +541,64 @@\n+void C2_MacroAssembler::stringL_indexof_char(Register str1, Register cnt1,\n+                                            Register ch, Register result,\n+                                            Register tmp1, Register tmp2, Register tmp3)\n+{\n+  Label CH1_LOOP, HAS_ZERO, DO1_SHORT, DO1_LOOP, MATCH, NOMATCH, DONE;\n+  Register cnt1_neg = cnt1;\n+  Register ch1 = rscratch1;\n+  Register result_tmp = rscratch2;\n+\n+  cbz(cnt1, NOMATCH);\n+\n+  cmp(cnt1, (u1)8);\n+  br(LT, DO1_SHORT);\n+\n+  orr(ch, ch, ch, LSL, 8);\n+  orr(ch, ch, ch, LSL, 16);\n+  orr(ch, ch, ch, LSL, 32);\n+\n+  sub(cnt1, cnt1, 8);\n+  mov(result_tmp, cnt1);\n+  lea(str1, Address(str1, cnt1));\n+  sub(cnt1_neg, zr, cnt1);\n+\n+  mov(tmp3, 0x0101010101010101);\n+\n+  BIND(CH1_LOOP);\n+    ldr(ch1, Address(str1, cnt1_neg));\n+    eor(ch1, ch, ch1);\n+    sub(tmp1, ch1, tmp3);\n+    orr(tmp2, ch1, 0x7f7f7f7f7f7f7f7f);\n+    bics(tmp1, tmp1, tmp2);\n+    br(NE, HAS_ZERO);\n+    adds(cnt1_neg, cnt1_neg, 8);\n+    br(LT, CH1_LOOP);\n+\n+    cmp(cnt1_neg, (u1)8);\n+    mov(cnt1_neg, 0);\n+    br(LT, CH1_LOOP);\n+    b(NOMATCH);\n+\n+  BIND(HAS_ZERO);\n+    rev(tmp1, tmp1);\n+    clz(tmp1, tmp1);\n+    add(cnt1_neg, cnt1_neg, tmp1, LSR, 3);\n+    b(MATCH);\n+\n+  BIND(DO1_SHORT);\n+    mov(result_tmp, cnt1);\n+    lea(str1, Address(str1, cnt1));\n+    sub(cnt1_neg, zr, cnt1);\n+  BIND(DO1_LOOP);\n+    ldrb(ch1, Address(str1, cnt1_neg));\n+    cmp(ch, ch1);\n+    br(EQ, MATCH);\n+    adds(cnt1_neg, cnt1_neg, 1);\n+    br(LT, DO1_LOOP);\n+  BIND(NOMATCH);\n+    mov(result, -1);\n+    b(DONE);\n+  BIND(MATCH);\n+    add(result, result_tmp, cnt1_neg);\n+  BIND(DONE);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":64,"deletions":0,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -48,0 +48,4 @@\n+  void stringL_indexof_char(Register str1, Register cnt1,\n+                           Register ch, Register result,\n+                           Register tmp1, Register tmp2, Register tmp3);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1862,0 +1862,93 @@\n+void C2_MacroAssembler::stringL_indexof_char(Register str1, Register cnt1, Register ch, Register result,\n+                                            XMMRegister vec1, XMMRegister vec2, XMMRegister vec3, Register tmp) {\n+  ShortBranchVerifier sbv(this);\n+  assert(UseSSE42Intrinsics, \"SSE4.2 intrinsics are required\");\n+\n+  int stride = 16;\n+\n+  Label FOUND_CHAR, SCAN_TO_CHAR_INIT, SCAN_TO_CHAR_LOOP,\n+        SCAN_TO_16_CHAR, SCAN_TO_16_CHAR_LOOP, SCAN_TO_32_CHAR_LOOP,\n+        RET_NOT_FOUND, SCAN_TO_16_CHAR_INIT,\n+        FOUND_SEQ_CHAR, DONE_LABEL;\n+\n+  movptr(result, str1);\n+  if (UseAVX >= 2) {\n+    cmpl(cnt1, stride);\n+    jcc(Assembler::less, SCAN_TO_CHAR_INIT);\n+    cmpl(cnt1, stride*2);\n+    jcc(Assembler::less, SCAN_TO_16_CHAR_INIT);\n+    movdl(vec1, ch);\n+    vpbroadcastb(vec1, vec1, Assembler::AVX_256bit);\n+    vpxor(vec2, vec2);\n+    movl(tmp, cnt1);\n+    andl(tmp, 0xFFFFFFE0);  \/\/vector count (in chars)\n+    andl(cnt1,0x0000001F);  \/\/tail count (in chars)\n+\n+    bind(SCAN_TO_32_CHAR_LOOP);\n+    vmovdqu(vec3, Address(result, 0));\n+    vpcmpeqb(vec3, vec3, vec1, Assembler::AVX_256bit);\n+    vptest(vec2, vec3);\n+    jcc(Assembler::carryClear, FOUND_CHAR);\n+    addptr(result, 32);\n+    subl(tmp, stride*2);\n+    jcc(Assembler::notZero, SCAN_TO_32_CHAR_LOOP);\n+    jmp(SCAN_TO_16_CHAR);\n+\n+    bind(SCAN_TO_16_CHAR_INIT);\n+    movdl(vec1, ch);\n+    pxor(vec2, vec2);\n+    pshufb(vec1, vec2);\n+  }\n+\n+  bind(SCAN_TO_16_CHAR);\n+  cmpl(cnt1, stride);\n+  jcc(Assembler::less, SCAN_TO_CHAR_INIT);\/\/less than 16 entires left\n+  if (UseAVX < 2) {\n+    movdl(vec1, ch);\n+    pxor(vec2, vec2);\n+    pshufb(vec1, vec2);\n+  }\n+  movl(tmp, cnt1);\n+  andl(tmp, 0xFFFFFFF0);  \/\/vector count (in bytes)\n+  andl(cnt1,0x0000000F);  \/\/tail count (in bytes)\n+\n+  bind(SCAN_TO_16_CHAR_LOOP);\n+  movdqu(vec3, Address(result, 0));\n+  pcmpeqb(vec3, vec1);\n+  ptest(vec2, vec3);\n+  jcc(Assembler::carryClear, FOUND_CHAR);\n+  addptr(result, 16);\n+  subl(tmp, stride);\n+  jcc(Assembler::notZero, SCAN_TO_16_CHAR_LOOP);\/\/last 16 items...\n+\n+  bind(SCAN_TO_CHAR_INIT);\n+  testl(cnt1, cnt1);\n+  jcc(Assembler::zero, RET_NOT_FOUND);\n+  bind(SCAN_TO_CHAR_LOOP);\n+  load_unsigned_byte(tmp, Address(result, 0));\n+  cmpl(ch, tmp);\n+  jccb(Assembler::equal, FOUND_SEQ_CHAR);\n+  addptr(result, 1);\n+  subl(cnt1, 1);\n+  jccb(Assembler::zero, RET_NOT_FOUND);\n+  jmp(SCAN_TO_CHAR_LOOP);\n+\n+  bind(RET_NOT_FOUND);\n+  movl(result, -1);\n+  jmpb(DONE_LABEL);\n+\n+  bind(FOUND_CHAR);\n+  if (UseAVX >= 2) {\n+    vpmovmskb(tmp, vec3);\n+  } else {\n+    pmovmskb(tmp, vec3);\n+  }\n+  bsfl(ch, tmp);\n+  addl(result, ch);\n+\n+  bind(FOUND_SEQ_CHAR);\n+  subptr(result, str1);\n+\n+  bind(DONE_LABEL);\n+} \/\/ stringL_indexof_char\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":93,"deletions":0,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -134,0 +134,3 @@\n+  void stringL_indexof_char(Register str1, Register cnt1, Register ch, Register result,\n+                           XMMRegister vec1, XMMRegister vec2, XMMRegister vec3, Register tmp);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -11827,1 +11827,1 @@\n-instruct string_indexofU_char(eDIRegP str1, eDXRegI cnt1, eAXRegI ch,\n+instruct string_indexof_char(eDIRegP str1, eDXRegI cnt1, eAXRegI ch,\n@@ -11829,1 +11829,1 @@\n-  predicate(UseSSE42Intrinsics);\n+  predicate(UseSSE42Intrinsics && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::U));\n@@ -11832,1 +11832,1 @@\n-  format %{ \"String IndexOf char[] $str1,$cnt1,$ch -> $result   \/\/ KILL all\" %}\n+  format %{ \"StringUTF16 IndexOf char[] $str1,$cnt1,$ch -> $result   \/\/ KILL all\" %}\n@@ -11840,0 +11840,14 @@\n+instruct stringL_indexof_char(eDIRegP str1, eDXRegI cnt1, eAXRegI ch,\n+                              eBXRegI result, regD vec1, regD vec2, regD vec3, eCXRegI tmp, eFlagsReg cr) %{\n+  predicate(UseSSE42Intrinsics && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::L));\n+  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n+  effect(TEMP vec1, TEMP vec2, TEMP vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);\n+  format %{ \"StringLatin1 IndexOf char[] $str1,$cnt1,$ch -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ stringL_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,\n+                           $vec1$$XMMRegister, $vec2$$XMMRegister, $vec3$$XMMRegister, $tmp$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -11036,1 +11036,1 @@\n-instruct string_indexofU_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,\n+instruct string_indexof_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,\n@@ -11039,1 +11039,1 @@\n-  predicate(UseSSE42Intrinsics);\n+  predicate(UseSSE42Intrinsics && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::U));\n@@ -11042,1 +11042,1 @@\n-  format %{ \"String IndexOf char[] $str1,$cnt1,$ch -> $result   \/\/ KILL all\" %}\n+  format %{ \"StringUTF16 IndexOf char[] $str1,$cnt1,$ch -> $result   \/\/ KILL all\" %}\n@@ -11050,0 +11050,14 @@\n+instruct stringL_indexof_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,\n+                              rbx_RegI result, legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, rcx_RegI tmp, rFlagsReg cr)\n+%{\n+  predicate(UseSSE42Intrinsics && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::L));\n+  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n+  effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);\n+  format %{ \"StringLatin1 IndexOf char[] $str1,$cnt1,$ch -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ stringL_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,\n+                           $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister, $tmp$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -249,0 +249,1 @@\n+    case vmIntrinsics::_indexOfL_char:\n@@ -534,0 +535,1 @@\n+  case vmIntrinsics::_indexOfL_char:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -312,0 +312,1 @@\n+  do_intrinsic(_indexOfL_char,            java_lang_StringLatin1,indexOfChar_name, indexOfChar_signature,        F_S)   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -499,0 +499,1 @@\n+  case vmIntrinsics::_indexOfL_char:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  \/\/ Possible encodings of the two parameters passed to the string intrinsic.\n+  \/\/ Possible encodings of the parameters passed to the string intrinsic.\n@@ -53,1 +53,2 @@\n-  typedef enum ArgEncoding { LL, LU, UL, UU, none } ArgEnc;\n+  \/\/ 'L' means that the single string is Latin1 encoded\n+  typedef enum ArgEncoding { LL, LU, UL, UU, L, U, none } ArgEnc;\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-  bool inline_string_indexOfChar();\n+  bool inline_string_indexOfChar(StrIntrinsicNode::ArgEnc ae);\n@@ -594,1 +594,2 @@\n-  case vmIntrinsics::_indexOfU_char:            return inline_string_indexOfChar();\n+  case vmIntrinsics::_indexOfU_char:            return inline_string_indexOfChar(StrIntrinsicNode::U);\n+  case vmIntrinsics::_indexOfL_char:            return inline_string_indexOfChar(StrIntrinsicNode::L);\n@@ -1434,1 +1435,1 @@\n-bool LibraryCallKit::inline_string_indexOfChar() {\n+bool LibraryCallKit::inline_string_indexOfChar(StrIntrinsicNode::ArgEnc ae) {\n@@ -1449,1 +1450,1 @@\n-  Node* src_offset = _gvn.transform(new LShiftINode(from_index, intcon(1)));\n+  Node* src_offset = ae == StrIntrinsicNode::L ? from_index : _gvn.transform(new LShiftINode(from_index, intcon(1)));\n@@ -1454,1 +1455,1 @@\n-  generate_string_range_check(src, src_offset, src_count, true);\n+  generate_string_range_check(src, src_offset, src_count, ae == StrIntrinsicNode::U);\n@@ -1462,1 +1463,1 @@\n-  Node* result = new StrIndexOfCharNode(control(), memory(TypeAryPtr::BYTES), src_start, src_count, tgt, StrIntrinsicNode::none);\n+  Node* result = new StrIndexOfCharNode(control(), memory(TypeAryPtr::BYTES), src_start, src_count, tgt, ae);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -213,0 +213,5 @@\n+        return indexOfChar(value, ch, fromIndex, max);\n+    }\n+\n+    @HotSpotIntrinsicCandidate\n+    private static int indexOfChar(byte[] value, int ch, int fromIndex, int max) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * @test\n+ * @bug 8173585\n+ * @summary Test intrinsification of StringLatin1.indexOf(char). Note that\n+ * differing code paths are taken contingent upon the length of the input String.\n+ * Hence we must test against differing string lengths in order to validate\n+ * correct functionality. We also ensure the strings are long enough to trigger\n+ * the looping conditions of the individual code paths.\n+ *\n+ * Run with varing levels of AVX and SSE support, also without the intrinsic at all\n+ *\n+ * @library \/compiler\/patches \/test\/lib\n+ * @run main\/othervm -Xbatch -XX:Tier4InvocationThreshold=200 -XX:CompileThreshold=100 compiler.intrinsics.string.TestStringLatin1IndexOfChar\n+ * @run main\/othervm -Xbatch -XX:Tier4InvocationThreshold=200 -XX:CompileThreshold=100 -XX:+UnlockDiagnosticVMOptions -XX:DisableIntrinsic=_indexOfL_char compiler.intrinsics.string.TestStringLatin1IndexOfChar\n+ * @run main\/othervm -Xbatch -XX:Tier4InvocationThreshold=200 -XX:CompileThreshold=100 -XX:+IgnoreUnrecognizedVMOptions -XX:UseSSE=0 compiler.intrinsics.string.TestStringLatin1IndexOfChar\n+ * @run main\/othervm -Xbatch -XX:Tier4InvocationThreshold=200 -XX:CompileThreshold=100 -XX:+IgnoreUnrecognizedVMOptions -XX:UseAVX=1 compiler.intrinsics.string.TestStringLatin1IndexOfChar\n+ * @run main\/othervm -Xbatch -XX:Tier4InvocationThreshold=200 -XX:CompileThreshold=100 -XX:+IgnoreUnrecognizedVMOptions -XX:UseAVX=2 compiler.intrinsics.string.TestStringLatin1IndexOfChar\n+ * @run main\/othervm -Xbatch -XX:Tier4InvocationThreshold=200 -XX:CompileThreshold=100 -XX:+IgnoreUnrecognizedVMOptions -XX:UseAVX=3 compiler.intrinsics.string.TestStringLatin1IndexOfChar\n+ *\/\n+\n+package compiler.intrinsics.string;\n+\n+import jdk.test.lib.Asserts;\n+\n+public class TestStringLatin1IndexOfChar{\n+    private final static int MAX_LENGTH = 2048;\/\/future proof for AVX-512 instructions\n+\n+    public static void main(String[] args) throws Exception {\n+        for (int i = 0; i < 1_000; ++i) {\/\/repeat such that we enter into C2 code...\n+            findOneItem();\n+            withOffsetTest();\n+            testEmpty();\n+        }\n+    }\n+\n+    private static void testEmpty(){\n+        Asserts.assertEQ(\"\".indexOf('a'), -1);\n+    }\n+\n+    private final static char SEARCH_CHAR = 'z';\n+    private final static char INVERLEAVING_CHAR = 'a';\n+    private final static char MISSING_CHAR = 'd';\n+\n+    private static void findOneItem(){\n+        \/\/test strings of varying length ensuring that for all lengths one instance of the\n+        \/\/search char can be found. We check what happens when the search character is in\n+        \/\/each position of the search string (including first and last positions)\n+        for(int strLength : new int[]{1, 15, 31, 32, 79}){\n+            for(int searchPos = 0; searchPos < strLength; searchPos++){\n+                String totest = makeOneItemStringLatin1(strLength, searchPos);\n+\n+                int intri = totest.indexOf(SEARCH_CHAR);\n+                int nonintri = indexOfCharNonIntrinsic(totest, SEARCH_CHAR, 0);\n+                Asserts.assertEQ(intri, nonintri);\n+            }\n+        }\n+    }\n+\n+    private static String makeOneItemStringLatin1(int length, int searchPos){\n+        StringBuilder sb = new StringBuilder(length);\n+\n+        for(int n =0; n < length; n++){\n+            sb.append(searchPos==n?SEARCH_CHAR:INVERLEAVING_CHAR);\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    private static void withOffsetTest(){\n+        \/\/progressivly move through string checking indexes and starting offset correctly processed\n+        \/\/string is of form azaza, aazaazaa, aaazaaazaaa, etc\n+        \/\/we find n s.t. maxlength = (n*3) + 2\n+        int maxaInstances = (MAX_LENGTH-2)\/3;\n+\n+        for(int aInstances = 5; aInstances < MAX_LENGTH; aInstances++){\n+            String totest = makeWithOffsetStringLatin1(aInstances);\n+\n+            int startoffset;\n+            {\n+                int intri = totest.indexOf(SEARCH_CHAR);\n+                int nonintri = indexOfCharNonIntrinsic(totest, SEARCH_CHAR, 0);\n+\n+                Asserts.assertEQ(intri, nonintri);\n+                startoffset = intri+1;\n+            }\n+\n+            {\n+                int intri = totest.indexOf(SEARCH_CHAR, startoffset);\n+                int nonintri = indexOfCharNonIntrinsic(totest, SEARCH_CHAR, startoffset);\n+\n+                Asserts.assertEQ(intri, nonintri);\n+                startoffset = intri+1;\n+            }\n+\n+            Asserts.assertEQ(totest.indexOf(SEARCH_CHAR, startoffset), -1);\/\/only two SEARCH_CHAR per string\n+            Asserts.assertEQ(totest.indexOf(MISSING_CHAR), -1);\n+        }\n+    }\n+\n+    private static String makeWithOffsetStringLatin1(int aInstances){\n+        StringBuilder sb = new StringBuilder((aInstances*3) + 2);\n+        for(int n =0; n < aInstances; n++){\n+            sb.append(INVERLEAVING_CHAR);\n+        }\n+\n+        sb.append(SEARCH_CHAR);\n+\n+        for(int n =0; n < aInstances; n++){\n+            sb.append(INVERLEAVING_CHAR);\n+        }\n+\n+        sb.append(SEARCH_CHAR);\n+\n+        for(int n =0; n < aInstances; n++){\n+            sb.append(INVERLEAVING_CHAR);\n+        }\n+        return sb.toString();\n+    }\n+\n+    private static int indexOfCharNonIntrinsic(String value, int ch, int fromIndex) {\n+        \/\/non intrinsic version of indexOfChar\n+        byte c = (byte)ch;\n+        for (int i = fromIndex; i < value.length(); i++) {\n+            if (value.charAt(i) == c) {\n+               return i;\n+            }\n+        }\n+        return -1;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestStringLatin1IndexOfChar.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,199 @@\n+package org.openjdk.bench.java.lang;\n+\n+import java.util.Random;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * This benchmark can be used to measure performance between StringLatin1 and StringUTF16 in terms of\n+ * performance of the indexOf(char) and indexOf(String) methods which are intrinsified.\n+ * On x86 the behaviour of the indexOf method is contingent upon the length of the string\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class IndexOfBenchmark {\n+    private static final int loops = 100000;\n+    private static final Random rng = new Random(1999);\n+    private static final int pathCnt = 1000;\n+    private static final String [] latn1_short        = new String[pathCnt];\n+    private static final String [] latn1_sse4         = new String[pathCnt];\n+    private static final String [] latn1_avx2         = new String[pathCnt];\n+    private static final String [] latn1_mixedLength  = new String[pathCnt];\n+    private static final String [] utf16_short        = new String[pathCnt];\n+    private static final String [] utf16_sse4         = new String[pathCnt];\n+    private static final String [] utf16_avx2         = new String[pathCnt];\n+    private static final String [] utf16_mixedLength  = new String[pathCnt];\n+    static {\n+        for (int i = 0; i < pathCnt; i++) {\n+            latn1_short[i] = makeRndString(false, 15);\n+            latn1_sse4[i]  = makeRndString(false, 16);\n+            latn1_avx2[i]  = makeRndString(false, 32);\n+            utf16_short[i] = makeRndString(true, 7);\n+            utf16_sse4[i]  = makeRndString(true, 8);\n+            utf16_avx2[i]  = makeRndString(true, 16);\n+            latn1_mixedLength[i] = makeRndString(false, rng.nextInt(65));\n+            utf16_mixedLength[i] = makeRndString(true, rng.nextInt(65));\n+        }\n+    }\n+\n+    private static String makeRndString(boolean isUtf16, int length) {\n+        StringBuilder sb = new StringBuilder(length);\n+        if(length > 0){\n+            sb.append(isUtf16?'☺':'b');\n+\n+            for (int i = 1; i < length-1; i++) {\n+                sb.append((char)('b' + rng.nextInt(26)));\n+            }\n+\n+            sb.append(rng.nextInt(3) >= 1?'a':'b');\/\/66.6% of time 'a' is in string\n+        }\n+        return sb.toString();\n+    }\n+\n+\n+    @Benchmark\n+    public static void latin1_mixed_char() {\n+        int ret = 0;\n+        for (String what : latn1_mixedLength) {\n+            ret += what.indexOf('a');\n+        }\n+    }\n+\n+    @Benchmark\n+    public static void utf16_mixed_char() {\n+        int ret = 0;\n+        for (String what : utf16_mixedLength) {\n+            ret += what.indexOf('a');\n+        }\n+    }\n+\n+    @Benchmark\n+    public static void latin1_mixed_String() {\n+        int ret = 0;\n+        for (String what : latn1_mixedLength) {\n+            ret += what.indexOf(\"a\");\n+        }\n+    }\n+\n+    @Benchmark\n+    public static void utf16_mixed_String() {\n+        int ret = 0;\n+        for (String what : utf16_mixedLength) {\n+            ret += what.indexOf(\"a\");\n+        }\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/ more detailed code path dependent tests \/\/\/\/\/\/\/\/\/\/\n+\n+    @Benchmark\n+    public static void latin1_Short_char() {\n+        int ret = 0;\n+        for (String what : latn1_short) {\n+            ret += what.indexOf('a');\n+        }\n+    }\n+\n+    @Benchmark\n+    public static void latin1_SSE4_char() {\n+        int ret = 0;\n+        for (String what : latn1_sse4) {\n+            ret += what.indexOf('a');\n+        }\n+    }\n+\n+    @Benchmark\n+    public static void latin1_AVX2_char() {\n+        int ret = 0;\n+        for (String what : latn1_avx2) {\n+            ret += what.indexOf('a');\n+        }\n+    }\n+\n+    @Benchmark\n+    public static int utf16_Short_char() {\n+        int ret = 0;\n+        for (String what : utf16_short) {\n+            ret += what.indexOf('a');\n+        }\n+        return ret;\n+    }\n+\n+    @Benchmark\n+    public static int utf16_SSE4_char() {\n+        int ret = 0;\n+        for (String what : utf16_sse4) {\n+            ret += what.indexOf('a');\n+        }\n+        return ret;\n+    }\n+\n+    @Benchmark\n+    public static int utf16_AVX2_char() {\n+        int ret = 0;\n+        for (String what : utf16_avx2) {\n+            ret += what.indexOf('a');\n+        }\n+        return ret;\n+    }\n+\n+    @Benchmark\n+    public static int latin1_Short_String() {\n+        int ret = 0;\n+        for (String what : latn1_short) {\n+            ret += what.indexOf(\"a\");\n+        }\n+        return ret;\n+    }\n+\n+    @Benchmark\n+    public static int latin1_SSE4_String() {\n+        int ret = 0;\n+        for (String what : latn1_sse4) {\n+            ret += what.indexOf(\"a\");\n+        }\n+        return ret;\n+    }\n+\n+    @Benchmark\n+    public static int latin1_AVX2_String() {\n+        int ret = 0;\n+        for (String what : latn1_avx2) {\n+            ret += what.indexOf(\"a\");\n+        }\n+        return ret;\n+    }\n+\n+    @Benchmark\n+    public static int utf16_Short_String() {\n+        int ret = 0;\n+        for (String what : utf16_short) {\n+            ret += what.indexOf(\"a\");\n+        }\n+        return ret;\n+    }\n+\n+    @Benchmark\n+    public static int utf16_SSE4_String() {\n+        int ret = 0;\n+        for (String what : utf16_sse4) {\n+            ret += what.indexOf(\"a\");\n+        }\n+        return ret;\n+    }\n+\n+    @Benchmark\n+    public static int utf16_AVX2_String() {\n+        int ret = 0;\n+        for (String what : utf16_avx2) {\n+            ret += what.indexOf(\"a\");\n+        }\n+        return ret;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringIndexOfChar.java","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"}]}