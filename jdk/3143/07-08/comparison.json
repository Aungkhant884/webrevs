{"files":[{"patch":"@@ -426,1 +426,1 @@\n-    bool proactive_collection_required = false;\n+    bool preventive_collection_required = false;\n@@ -440,2 +440,2 @@\n-      proactive_collection_required = policy()->proactive_collection_required(1);\n-      if (!proactive_collection_required) {\n+      preventive_collection_required = policy()->preventive_collection_required(1);\n+      if (!preventive_collection_required) {\n@@ -471,1 +471,1 @@\n-      GCCause::Cause gc_cause = proactive_collection_required ? GCCause::_g1_proactive_collection\n+      GCCause::Cause gc_cause = preventive_collection_required ? GCCause::_g1_preventive_collection\n@@ -868,1 +868,1 @@\n-    bool proactive_collection_required = false;\n+    bool preventive_collection_required = false;\n@@ -876,2 +876,2 @@\n-      proactive_collection_required = policy()->proactive_collection_required((uint)size_in_regions);\n-      if (!proactive_collection_required) {\n+      preventive_collection_required = policy()->preventive_collection_required((uint)size_in_regions);\n+      if (!preventive_collection_required) {\n@@ -898,1 +898,1 @@\n-      GCCause::Cause gc_cause = proactive_collection_required ? GCCause::_g1_proactive_collection\n+      GCCause::Cause gc_cause = preventive_collection_required ? GCCause::_g1_preventive_collection\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1416,3 +1416,3 @@\n-bool G1Policy::proactive_collection_required(uint alloc_region_count) {\n-  if (!G1AllowProactiveGC || !Universe::is_fully_initialized()) {\n-    \/\/ Don't attempt any proactive GC's if the feature is disabled,\n+bool G1Policy::preventive_collection_required(uint alloc_region_count) {\n+  if (!G1AllowPreventiveGC || !Universe::is_fully_initialized()) {\n+    \/\/ Don't attempt any preventive GC's if the feature is disabled,\n@@ -1435,1 +1435,1 @@\n-    log_debug(gc, ergo, cset)(\"Proactive GC, insufficient free regions. Predicted need %u. Curr Eden %u (Pred %u). Curr Survivor %u (Pred %u). Curr Old %u (Pred %u) Free %u Alloc %u\",\n+    log_debug(gc, ergo, cset)(\"Preventive GC, insufficient free regions. Predicted need %u. Curr Eden %u (Pred %u). Curr Survivor %u (Pred %u). Curr Old %u (Pred %u) Free %u Alloc %u\",\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -356,1 +356,1 @@\n-  bool proactive_collection_required(uint region_count);\n+  bool preventive_collection_required(uint region_count);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,2 +123,2 @@\n-  \/\/ Don't allocate before a proactive GC.\n-  return _gc_cause != GCCause::_g1_proactive_collection;\n+  \/\/ Don't allocate before a preventive GC.\n+  return _gc_cause != GCCause::_g1_preventive_collection;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -307,1 +307,1 @@\n-  product(bool, G1AllowProactiveGC, true, DIAGNOSTIC,                       \\\n+  product(bool, G1AllowPreventiveGC, true, DIAGNOSTIC,                       \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,2 +102,2 @@\n-    case _g1_proactive_collection:\n-      return \"G1 Proactive Collection\";\n+    case _g1_preventive_collection:\n+      return \"G1 Preventive Collection\";\n","filename":"src\/hotspot\/share\/gc\/shared\/gcCause.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-    _g1_proactive_collection,\n+    _g1_preventive_collection,\n","filename":"src\/hotspot\/share\/gc\/shared\/gcCause.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}