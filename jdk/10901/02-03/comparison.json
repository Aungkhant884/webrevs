{"files":[{"patch":"@@ -733,1 +733,1 @@\n-GrowableArray<ciInstanceKlass*>* ciInstanceKlass::transitive_interfaces() {\n+GrowableArray<ciInstanceKlass*>* ciInstanceKlass::transitive_interfaces() const{\n@@ -735,14 +735,1 @@\n-    GUARDED_VM_ENTRY(\n-            InstanceKlass* ik = get_instanceKlass();\n-            Array<InstanceKlass*>* interfaces = ik->transitive_interfaces();\n-            Arena* arena = CURRENT_ENV->arena();\n-            int len = interfaces->length() + (is_interface() ? 1 : 0);\n-            GrowableArray<ciInstanceKlass*>* transitive_interfaces = new (arena)GrowableArray<ciInstanceKlass*>(arena, len, 0, NULL);\n-            for (int i = 0; i < interfaces->length(); i++) {\n-              transitive_interfaces->append(CURRENT_ENV->get_instance_klass(interfaces->at(i)));\n-            }\n-            if (is_interface()) {\n-              transitive_interfaces->append(this);\n-            }\n-            _transitive_interfaces = transitive_interfaces;\n-    );\n+    const_cast<ciInstanceKlass*>(this)->compute_transitive_interfaces();\n@@ -753,0 +740,18 @@\n+void ciInstanceKlass::compute_transitive_interfaces() {\n+  GUARDED_VM_ENTRY(\n+          InstanceKlass* ik = get_instanceKlass();\n+          Array<InstanceKlass*>* interfaces = ik->transitive_interfaces();\n+          Arena* arena = CURRENT_ENV->arena();\n+          int len = interfaces->length() + (is_interface() ? 1 : 0);\n+          GrowableArray<ciInstanceKlass*>* transitive_interfaces = new(arena)GrowableArray<ciInstanceKlass*>(arena, len,\n+                                                                                                             0, NULL);\n+          for (int i = 0; i < interfaces->length(); i++) {\n+            transitive_interfaces->append(CURRENT_ENV->get_instance_klass(interfaces->at(i)));\n+          }\n+          if (is_interface()) {\n+            transitive_interfaces->append(this);\n+          }\n+          _transitive_interfaces = transitive_interfaces;\n+  );\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+  void compute_transitive_interfaces();\n@@ -296,1 +297,1 @@\n-  GrowableArray<ciInstanceKlass*>* transitive_interfaces();\n+  GrowableArray<ciInstanceKlass*>* transitive_interfaces() const;\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -156,11 +156,3 @@\n-  \/\/ ciInstanceKlass objects for interfaces that the vm class implements must also be allocated from the long lived arena\n-#define VM_CLASS_DEFN(name, ignore_s)                                \\\n-  if (vmClasses::name##_is_loaded()) {                               \\\n-    InstanceKlass* ik = vmClasses::name();                           \\\n-    ciEnv::_##name = get_metadata(ik)->as_instance_klass();          \\\n-    Array<InstanceKlass*>* interfaces = ik->transitive_interfaces(); \\\n-    for (int i = 0; i < interfaces->length(); i++) {                 \\\n-      InstanceKlass* interface = interfaces->at(i);                  \\\n-      get_metadata(interface);                                       \\\n-    }                                                                \\\n-  }\n+#define VM_CLASS_DEFN(name, ignore_s)                              \\\n+  if (vmClasses::name##_is_loaded()) \\\n+    ciEnv::_##name = get_metadata(vmClasses::name())->as_instance_klass();\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1050,1 +1050,1 @@\n-  return phase->makecon(TypeKlassPtr::make(mirror_type->as_klass(),  Type::trust_interfaces));\n+  return phase->makecon(TypeKlassPtr::make(mirror_type->as_klass(), Type::trust_interfaces));\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4003,3 +4003,3 @@\n-    if(      loaded->ptr() == TypePtr::TopPTR ) { return unloaded; }\n-    else if (loaded->ptr() == TypePtr::AnyNull) { return make(ptr, unloaded->klass(), interfaces, false, NULL, off, instance_id, speculative, depth); }\n-    else if (loaded->ptr() == TypePtr::BotPTR ) { return TypeInstPtr::BOTTOM; }\n+    if (loaded->ptr() == TypePtr::TopPTR)        { return unloaded; }\n+    else if (loaded->ptr() == TypePtr::AnyNull)  { return make(ptr, unloaded->klass(), interfaces, false, NULL, off, instance_id, speculative, depth); }\n+    else if (loaded->ptr() == TypePtr::BotPTR)   { return TypeInstPtr::BOTTOM; }\n@@ -4007,2 +4007,2 @@\n-      if (unloaded->ptr() == TypePtr::BotPTR  ) { return TypeInstPtr::BOTTOM;  }\n-      else                                      { return TypeInstPtr::NOTNULL; }\n+      if (unloaded->ptr() == TypePtr::BotPTR)    { return TypeInstPtr::BOTTOM;  }\n+      else                                       { return TypeInstPtr::NOTNULL; }\n@@ -4010,1 +4010,1 @@\n-    else if( unloaded->ptr() == TypePtr::TopPTR )  { return unloaded; }\n+    else if (unloaded->ptr() == TypePtr::TopPTR) { return unloaded; }\n@@ -4017,1 +4017,1 @@\n-  if( ptr != TypePtr::BotPTR ) {\n+  if (ptr != TypePtr::BotPTR) {\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"}]}