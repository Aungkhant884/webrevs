{"files":[{"patch":"@@ -57,0 +57,1 @@\n+        CATEGORIES_ORDER.add(Category.IMAGE_TRANSFORMER);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImagePluginConfiguration.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.tools.jlink.internal.plugins;\n+\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import jdk.tools.jlink.internal.ResourcePoolManager.ResourcePoolImpl;\n+import jdk.tools.jlink.plugin.ResourcePool;\n+import jdk.tools.jlink.plugin.ResourcePoolBuilder;\n+import jdk.tools.jlink.internal.ImagePluginStack;\n+import jdk.tools.jlink.internal.ResourcePoolManager;\n+import jdk.tools.jlink.internal.ResourcePrevisitor;\n+import jdk.tools.jlink.internal.StringTable;\n+\n+\/**\n+ *\n+ * ZIP and String Sharing compression plugin\n+ *\/\n+public final class CompactConstantPoolsPlugin extends AbstractPlugin implements ResourcePrevisitor {\n+\n+    private static final String FILTER = \"filter\";\n+    private StringSharingPlugin ss;\n+\n+    public CompactConstantPoolsPlugin() {\n+        super(\"compact-constant-pools\");\n+    }\n+\n+    @Override\n+    public ResourcePool transform(ResourcePool in, ResourcePoolBuilder out) {\n+        return ss.transform(in, out);\n+    }\n+\n+    @Override\n+    public void previsit(ResourcePool resources, StringTable strings) {\n+        if (ss != null) {\n+            ss.previsit(resources, strings);\n+        }\n+    }\n+\n+    @Override\n+    public Category getType() {\n+        return Category.IMAGE_TRANSFORMER;\n+    }\n+\n+    @Override\n+    public boolean hasArguments() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void configure(Map<String, String> config) {\n+        ResourceFilter resFilter = ResourceFilter.includeFilter(config.get(FILTER));\n+        ss = new StringSharingPlugin(resFilter);\n+    }\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/CompactConstantPoolsPlugin.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -105,0 +105,7 @@\n+                    if (level.length() == 5 && level.startsWith(\"zip-\")) {\n+                        try {\n+                            int zipLevel = Integer.parseInt(level.substring(4));\n+                            zip = new ZipPlugin(resFilter, zipLevel);\n+                            break;\n+                        } catch (NumberFormatException ignored) {}\n+                    }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/DefaultCompressPlugin.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -48,0 +48,3 @@\n+    private static final int DEFAULT_COMPRESSION = 6;\n+    private final int compressionLevel;\n+\n@@ -57,0 +60,4 @@\n+        this(predicate, DEFAULT_COMPRESSION);\n+    }\n+\n+    ZipPlugin(Predicate<String> predicate, int compressionLevel) {\n@@ -59,0 +66,1 @@\n+        this.compressionLevel = compressionLevel;\n@@ -76,2 +84,2 @@\n-    static byte[] compress(byte[] bytesIn) {\n-        Deflater deflater = new Deflater();\n+    static byte[] compress(byte[] bytesIn, int compressionLevel) {\n+        Deflater deflater = new Deflater(compressionLevel);\n@@ -107,1 +115,1 @@\n-                compressed = compress(resource.contentBytes());\n+                compressed = compress(resource.contentBytes(), this.compressionLevel);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/ZipPlugin.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -64,1 +64,3 @@\n-        PACKAGER(\"PACKAGER\");\n+        PACKAGER(\"PACKAGER\"),\n+\n+        IMAGE_TRANSFORMER(\"IMAGE_TRANSFORMER\");\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/plugin\/Plugin.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-compress.argument=<0|1|2>[:filter=<pattern-list>]\n+compress.argument=<0|1|2|zip-[0-9]>[:filter=<pattern-list>]\n@@ -65,6 +65,9 @@\n-Compress all resources in the output image.\\n\\\n-Level 0: No compression\\n\\\n-Level 1: Constant string sharing\\n\\\n-Level 2: ZIP.\\n\\\n-An optional <pattern-list> filter can be specified to list the pattern of\\n\\\n-files to be included.\n+Compression to use in compressing resources:\\n\\\n+Accepted values are:\\n\\\n+zip-[0-9], where zip-0 provides no\\n\\\n+compression, and zip-9 provides the\\n\\\n+best compression. Default is zip-6.\\n\\\n+Deprecated values:\\n\\\n+0:  No compression. Equivalent to zip-0.\\n\\\n+1:  Equivalent to --compact-constant-pools\\n\\\n+2:  Equivalent to zip-6.\n@@ -73,12 +76,13 @@\n-\\  --compress <0|1|2>[:filter=<pattern-list>]\\n\\\n-\\                            Compress all resources in the output image.\\n\\\n-\\                            Level 0: No compression\\n\\\n-\\                            Level 1: Constant string sharing\\n\\\n-\\                            Level 2: ZIP.\\n\\\n-\\                            An optional <pattern-list> filter can be\\n\\\n-\\                            specified to list the pattern of \\n\\\n-\\                            files to be included.\n-\n-compact-cp.argument=<resource paths>\n-\n-compact-cp.description=Constant Pool strings sharing.\\n\\\n+\\  --compress <compress>     Compression to use in compressing resources:\\n\\\n+\\                            Accepted values are:\\n\\\n+\\                            zip-[0-9], where zip-0 provides no\\n\\\n+\\                            compression, and zip-9 provides the\\n\\\n+\\                            best compression. Default is zip-6.\\n\\\n+\\                            Deprecated values:\\n\\\n+\\                            0:  No compression. Equivalent to zip-0.\\n\\\n+\\                            1:  Equivalent to --compact-constant-pools\\n\\\n+\\                            2:  Equivalent to zip-6.\n+\n+compact-constant-pools.argument=<resource paths>\n+\n+compact-constant-pools.description=Constant Pool strings sharing.\\n\\\n@@ -88,6 +92,6 @@\n-compact-cp.usage=\\\n-\\ --compact-cp <resource paths>\\n\\\n-\\                             Constant Pool strings sharing.\\n\\\n-\\                             By default, all resources are compressed.\\n\\\n-\\                             You can express the set of resources to\\n\\\n-\\                             compress or not compress (use ^ for negation).\n+compact-constant-pools.usage=\\\n+\\  --compact-cp <resource paths>\\n\\\n+\\                            Constant Pool strings sharing.\\n\\\n+\\                            By default, all resources are compressed.\\n\\\n+\\                            You can express the set of resources to\\n\\\n+\\                            compress or not compress (use ^ for negation).\n@@ -326,4 +330,9 @@\n-\\  -c, --compress=<0|1|2>                Enable compression of resources:\\n\\\n-\\                                          Level 0: No compression\\n\\\n-\\                                          Level 1: Constant string sharing\\n\\\n-\\                                          Level 2: ZIP\n+\\      --compress <compress>             Compression to use in compressing resources:\\n\\\n+\\                                        Accepted values are:\\n\\\n+\\                                        zip-[0-9], where zip-0 provides no\\n\\\n+\\                                        compression, and zip-9 provides the\\n\\\n+\\                                        best compression. Default is zip-6.\\n\\\n+\\                                        Deprecated values:\\n\\\n+\\                                        0:  No compression. Equivalent to zip-0.\\n\\\n+\\                                        1:  Equivalent to --compact-constant-pools\\n\\\n+\\                                        2:  Equivalent to zip-6.\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/plugins.properties","additions":38,"deletions":29,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -84,1 +84,2 @@\n-        jdk.tools.jlink.internal.plugins.SaveJlinkArgfilesPlugin;\n+        jdk.tools.jlink.internal.plugins.SaveJlinkArgfilesPlugin,\n+        jdk.tools.jlink.internal.plugins.CompactConstantPoolsPlugin;\n","filename":"src\/jdk.jlink\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,281 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test compressor\n+ * @author Ian Graves\n+ * @modules java.base\/jdk.internal.jimage.decompressor\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.internal.plugins\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ * @run main CompactConstantPoolsPluginTest\n+ *\/\n+\n+import jdk.internal.jimage.decompressor.*;\n+import jdk.tools.jlink.internal.ResourcePoolManager;\n+import jdk.tools.jlink.internal.StringTable;\n+import jdk.tools.jlink.internal.plugins.CompactConstantPoolsPlugin;\n+import jdk.tools.jlink.internal.plugins.DefaultCompressPlugin;\n+import jdk.tools.jlink.internal.plugins.StringSharingPlugin;\n+import jdk.tools.jlink.internal.plugins.ZipPlugin;\n+import jdk.tools.jlink.plugin.Plugin;\n+import jdk.tools.jlink.plugin.ResourcePool;\n+import jdk.tools.jlink.plugin.ResourcePoolBuilder;\n+import jdk.tools.jlink.plugin.ResourcePoolEntry;\n+\n+import java.net.URI;\n+import java.nio.ByteOrder;\n+import java.nio.file.*;\n+import java.util.*;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class CompactConstantPoolsPluginTest {\n+    private static int strID = 1;\n+\n+    public static void main(String[] args) throws Exception {\n+        new CompactConstantPoolsPluginTest().test();\n+    }\n+\n+    public void test() throws Exception {\n+        FileSystem fs;\n+        try {\n+            fs = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n+        } catch (ProviderNotFoundException | FileSystemNotFoundException e) {\n+            System.err.println(\"Not an image build, test skipped.\");\n+            return;\n+        }\n+        Path javabase = fs.getPath(\"\/modules\/java.base\");\n+        ResourcePool classes = gatherClasses(javabase);\n+        CompactConstantPoolsPlugin compressPlugin;\n+\n+        \/\/ Compact Constnat Pools\n+        Properties options1 = new Properties();\n+        compressPlugin = new CompactConstantPoolsPlugin();\n+        checkCompress(classes, compressPlugin,\n+                options1,\n+                new ResourceDecompressorFactory[]{\n+                        new StringSharingDecompressorFactory()\n+                });\n+\n+        \/\/ Compact Constant Pools + filter\n+        options1.setProperty(DefaultCompressPlugin.FILTER,\n+                \"**Exception.class\");\n+        compressPlugin = new CompactConstantPoolsPlugin();\n+        checkCompress(classes, compressPlugin,\n+                options1,\n+                new ResourceDecompressorFactory[]{\n+                        new StringSharingDecompressorFactory()\n+                }, Collections.singletonList(\".*Exception.class\"));\n+    }\n+\n+    private ResourcePool gatherResources(Path module) throws Exception {\n+        ResourcePoolManager poolMgr = new ResourcePoolManager(ByteOrder.nativeOrder(), new StringTable() {\n+\n+            @Override\n+            public int addString(String str) {\n+                return -1;\n+            }\n+\n+            @Override\n+            public String getString(int id) {\n+                return null;\n+            }\n+        });\n+\n+        ResourcePoolBuilder poolBuilder = poolMgr.resourcePoolBuilder();\n+        try (Stream<Path> stream = Files.walk(module)) {\n+            for (Iterator<Path> iterator = stream.iterator(); iterator.hasNext();) {\n+                Path p = iterator.next();\n+                if (Files.isRegularFile(p)) {\n+                    byte[] content = Files.readAllBytes(p);\n+                    poolBuilder.add(ResourcePoolEntry.create(p.toString(), content));\n+                }\n+            }\n+        }\n+        return poolBuilder.build();\n+    }\n+\n+    private ResourcePool gatherClasses(Path module) throws Exception {\n+        ResourcePoolManager poolMgr = new ResourcePoolManager(ByteOrder.nativeOrder(), new StringTable() {\n+\n+            @Override\n+            public int addString(String str) {\n+                return -1;\n+            }\n+\n+            @Override\n+            public String getString(int id) {\n+                return null;\n+            }\n+        });\n+\n+        ResourcePoolBuilder poolBuilder = poolMgr.resourcePoolBuilder();\n+        try (Stream<Path> stream = Files.walk(module)) {\n+            for (Iterator<Path> iterator = stream.iterator(); iterator.hasNext();) {\n+                Path p = iterator.next();\n+                if (Files.isRegularFile(p) && p.toString().endsWith(\".class\")) {\n+                    byte[] content = Files.readAllBytes(p);\n+                    poolBuilder.add(ResourcePoolEntry.create(p.toString(), content));\n+                }\n+            }\n+        }\n+        return poolBuilder.build();\n+    }\n+\n+    private void checkCompress(ResourcePool resources, Plugin prov,\n+                               Properties config,\n+                               ResourceDecompressorFactory[] factories) throws Exception {\n+        checkCompress(resources, prov, config, factories, Collections.emptyList());\n+    }\n+\n+    private void checkCompress(ResourcePool resources, Plugin prov,\n+                               Properties config,\n+                               ResourceDecompressorFactory[] factories,\n+                               List<String> includes) throws Exception {\n+        if (factories.length == 0) {\n+            \/\/ no compression, nothing to check!\n+            return;\n+        }\n+\n+        long[] original = new long[1];\n+        long[] compressed = new long[1];\n+        resources.entries().forEach(resource -> {\n+            List<Pattern> includesPatterns = includes.stream()\n+                    .map(Pattern::compile)\n+                    .collect(Collectors.toList());\n+\n+            Map<String, String> props = new HashMap<>();\n+            if (config != null) {\n+                for (String p : config.stringPropertyNames()) {\n+                    props.put(p, config.getProperty(p));\n+                }\n+            }\n+            prov.configure(props);\n+            final Map<Integer, String> strings = new HashMap<>();\n+            ResourcePoolManager inputResourcesMgr = new ResourcePoolManager(ByteOrder.nativeOrder(), new StringTable() {\n+                @Override\n+                public int addString(String str) {\n+                    int id = strID;\n+                    strID += 1;\n+                    strings.put(id, str);\n+                    return id;\n+                }\n+\n+                @Override\n+                public String getString(int id) {\n+                    return strings.get(id);\n+                }\n+            });\n+            inputResourcesMgr.add(resource);\n+            ResourcePool compressedResources = applyCompressor(prov, inputResourcesMgr, resource, includesPatterns);\n+            original[0] += resource.contentLength();\n+            compressed[0] += compressedResources.findEntry(resource.path()).get().contentLength();\n+            applyDecompressors(factories, inputResourcesMgr.resourcePool(), compressedResources, strings, includesPatterns);\n+        });\n+        String compressors = Stream.of(factories)\n+                .map(Object::getClass)\n+                .map(Class::getSimpleName)\n+                .collect(Collectors.joining(\", \"));\n+        String size = \"Compressed size: \" + compressed[0] + \", original size: \" + original[0];\n+        System.out.println(\"Used \" + compressors + \". \" + size);\n+        if (original[0] <= compressed[0]) {\n+            throw new AssertionError(\"java.base not compressed.\");\n+        }\n+    }\n+\n+    private ResourcePool applyCompressor(Plugin plugin,\n+                                         ResourcePoolManager inputResources,\n+                                         ResourcePoolEntry res,\n+                                         List<Pattern> includesPatterns) {\n+        ResourcePoolManager resMgr = new ResourcePoolManager(ByteOrder.nativeOrder(),\n+                inputResources.getStringTable());\n+        ResourcePool compressedResourcePool = plugin.transform(inputResources.resourcePool(),\n+                resMgr.resourcePoolBuilder());\n+        String path = res.path();\n+        ResourcePoolEntry compressed = compressedResourcePool.findEntry(path).get();\n+        CompressedResourceHeader header\n+                = CompressedResourceHeader.readFromResource(ByteOrder.nativeOrder(), compressed.contentBytes());\n+        if (isIncluded(includesPatterns, path)) {\n+            if (header == null) {\n+                throw new AssertionError(\"Path should be compressed: \" + path);\n+            }\n+            if (header.getDecompressorNameOffset() == 0) {\n+                throw new AssertionError(\"Invalid plugin offset \"\n+                        + header.getDecompressorNameOffset());\n+            }\n+            if (header.getResourceSize() <= 0) {\n+                throw new AssertionError(\"Invalid compressed size \"\n+                        + header.getResourceSize());\n+            }\n+        } else if (header != null) {\n+            throw new AssertionError(\"Path should not be compressed: \" + path);\n+        }\n+        return compressedResourcePool;\n+    }\n+\n+    private void applyDecompressors(ResourceDecompressorFactory[] decompressors,\n+                                    ResourcePool inputResources,\n+                                    ResourcePool compressedResources,\n+                                    Map<Integer, String> strings,\n+                                    List<Pattern> includesPatterns) {\n+        compressedResources.entries().forEach(compressed -> {\n+            CompressedResourceHeader header = CompressedResourceHeader.readFromResource(\n+                    ByteOrder.nativeOrder(), compressed.contentBytes());\n+            String path = compressed.path();\n+            ResourcePoolEntry orig = inputResources.findEntry(path).get();\n+            if (!isIncluded(includesPatterns, path)) {\n+                return;\n+            }\n+            byte[] decompressed = compressed.contentBytes();\n+            for (ResourceDecompressorFactory factory : decompressors) {\n+                try {\n+                    ResourceDecompressor decompressor = factory.newDecompressor(new Properties());\n+                    decompressed = decompressor.decompress(\n+                            strings::get, decompressed,\n+                            CompressedResourceHeader.getSize(), header.getUncompressedSize());\n+                } catch (Exception exp) {\n+                    throw new RuntimeException(exp);\n+                }\n+            }\n+\n+            if (decompressed.length != orig.contentLength()) {\n+                throw new AssertionError(\"Invalid uncompressed size \"\n+                        + header.getUncompressedSize());\n+            }\n+            byte[] origContent = orig.contentBytes();\n+            for (int i = 0; i < decompressed.length; i++) {\n+                if (decompressed[i] != origContent[i]) {\n+                    throw new AssertionError(\"Decompressed and original differ at index \" + i);\n+                }\n+            }\n+        });\n+    }\n+\n+    private boolean isIncluded(List<Pattern> includesPatterns, String path) {\n+        return includesPatterns.isEmpty() ||\n+                includesPatterns.stream().anyMatch((pattern) -> pattern.matcher(path).matches());\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/plugins\/CompactConstantPoolsPluginTest.java","additions":281,"deletions":0,"binary":false,"changes":281,"status":"added"},{"patch":"@@ -149,0 +149,59 @@\n+\n+        \/\/ compress level zip-0 == no compression\n+        Properties optionsZip0 = new Properties();\n+        DefaultCompressPlugin compressPluginZip0 = new DefaultCompressPlugin();\n+        options0.setProperty(compressPluginZip0.getName(), \"zip-0\");\n+        checkCompress(classes, compressPlugin,\n+                optionsZip0,\n+                new ResourceDecompressorFactory[]{\n+                });\n+\n+        \/\/ compress level zip-[1-9] == varied compression levels\n+        for(int i = 1; i < 10; i++) {\n+            Properties optionsZip = new Properties();\n+            compressPlugin = new DefaultCompressPlugin();\n+            optionsZip.setProperty(compressPlugin.getName(), \"zip-\" + i);\n+            checkCompress(classes, compressPlugin,\n+                    optionsZip,\n+                    new ResourceDecompressorFactory[]{\n+                            new ZipDecompressorFactory(),\n+                    });\n+        }\n+\n+        \/\/ compress level zip-[1-9] == varied compression levels + filter\n+        for(int i = 1; i < 10; i++) {\n+            Properties optionsZip = new Properties();\n+            compressPlugin = new DefaultCompressPlugin();\n+            optionsZip.setProperty(DefaultCompressPlugin.FILTER, \"**Exception.class\");\n+            optionsZip.setProperty(compressPlugin.getName(), \"zip-\" + i);\n+            checkCompress(classes, compressPlugin,\n+                    optionsZip,\n+                    new ResourceDecompressorFactory[]{\n+                            new ZipDecompressorFactory(),\n+                    }, Collections.singletonList(\".*Exception.class\"));\n+        }\n+\n+        testBadCompressProps(classes, \"zip-10\");\n+        testBadCompressProps(classes, \"zip-badarg\");\n+        testBadCompressProps(classes, \"zip-10000000\");\n+\n+    }\n+\n+    private void testBadCompressProps(ResourcePool classes, String compressArg) throws Exception {\n+        Properties badProps = new Properties();\n+        DefaultCompressPlugin compressPlugin = new DefaultCompressPlugin();\n+        badProps.setProperty(compressPlugin.getName(), compressArg);\n+        try {\n+            checkCompress(classes, compressPlugin,\n+                    badProps,\n+                    new ResourceDecompressorFactory[]{\n+                            new ZipDecompressorFactory(),\n+                    });\n+        } catch (IllegalArgumentException e) {\n+            if (e.getMessage().contains(\"Invalid compression level\")) {\n+                return;\n+            }\n+        }\n+\n+        throw new Exception(\"Expected compression IAE with \" + compressArg + \" but didn't get one.\");\n+\n","filename":"test\/jdk\/tools\/jlink\/plugins\/CompressorPluginTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"modified"}]}