{"files":[{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.tools.jlink.internal.plugins;\n-\n-import java.util.Map;\n-import java.util.function.Function;\n-\n-import jdk.tools.jlink.internal.ResourcePoolManager.ResourcePoolImpl;\n-import jdk.tools.jlink.plugin.ResourcePool;\n-import jdk.tools.jlink.plugin.ResourcePoolBuilder;\n-import jdk.tools.jlink.internal.ImagePluginStack;\n-import jdk.tools.jlink.internal.ResourcePoolManager;\n-import jdk.tools.jlink.internal.ResourcePrevisitor;\n-import jdk.tools.jlink.internal.StringTable;\n-\n-\/**\n- *\n- * ZIP and String Sharing compression plugin\n- *\/\n-public final class CompactConstantPoolsPlugin extends AbstractPlugin implements ResourcePrevisitor {\n-\n-    private static final String FILTER = \"filter\";\n-    private StringSharingPlugin ss;\n-\n-    public CompactConstantPoolsPlugin() {\n-        super(\"compact-constant-pools\");\n-    }\n-\n-    @Override\n-    public ResourcePool transform(ResourcePool in, ResourcePoolBuilder out) {\n-        return ss.transform(in, out);\n-    }\n-\n-    @Override\n-    public void previsit(ResourcePool resources, StringTable strings) {\n-        if (ss != null) {\n-            ss.previsit(resources, strings);\n-        }\n-    }\n-\n-    @Override\n-    public Category getType() {\n-        return Category.IMAGE_TRANSFORMER;\n-    }\n-\n-    @Override\n-    public boolean hasArguments() {\n-        return false;\n-    }\n-\n-    @Override\n-    public void configure(Map<String, String> config) {\n-        ResourceFilter resFilter = ResourceFilter.includeFilter(config.get(FILTER));\n-        ss = new StringSharingPlugin(resFilter);\n-    }\n-}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/CompactConstantPoolsPlugin.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -72,1 +72,1 @@\n-1:  Equivalent to --compact-constant-pools\\n\\\n+1:  Constant string sharing\\n\\\n@@ -83,1 +83,1 @@\n-\\                            1:  Equivalent to --compact-constant-pools\\n\\\n+\\                            1:  Constant string sharing\\n\\\n@@ -86,12 +86,0 @@\n-compact-constant-pools.argument=<resource paths>\n-\n-compact-constant-pools.description=Constant Pool strings sharing.\\n\\\n-By default, all resources are compressed. You can express the set \\n\\\n-of resources to compress or not compress (use ^ for negation).\n-\n-compact-constant-pools.usage=\\\n-\\  --compact-cp <resource paths>\\n\\\n-\\                            Constant Pool strings sharing.\\n\\\n-\\                            By default, all resources are compressed.\\n\\\n-\\                            You can express the set of resources to\\n\\\n-\\                            compress or not compress (use ^ for negation).\n@@ -337,1 +325,1 @@\n-\\                                        1:  Equivalent to --compact-constant-pools\\n\\\n+\\                                        1:  Constant String Sharing\\n\\\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/plugins.properties","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -84,3 +84,1 @@\n-        jdk.tools.jlink.internal.plugins.SaveJlinkArgfilesPlugin,\n-        jdk.tools.jlink.internal.plugins.CompactConstantPoolsPlugin;\n-\n+        jdk.tools.jlink.internal.plugins.SaveJlinkArgfilesPlugin;\n","filename":"src\/jdk.jlink\/share\/classes\/module-info.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,281 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test compressor\n- * @author Ian Graves\n- * @modules java.base\/jdk.internal.jimage.decompressor\n- *          jdk.jlink\/jdk.tools.jlink.internal\n- *          jdk.jlink\/jdk.tools.jlink.internal.plugins\n- *          jdk.jlink\/jdk.tools.jlink.plugin\n- * @run main CompactConstantPoolsPluginTest\n- *\/\n-\n-import jdk.internal.jimage.decompressor.*;\n-import jdk.tools.jlink.internal.ResourcePoolManager;\n-import jdk.tools.jlink.internal.StringTable;\n-import jdk.tools.jlink.internal.plugins.CompactConstantPoolsPlugin;\n-import jdk.tools.jlink.internal.plugins.DefaultCompressPlugin;\n-import jdk.tools.jlink.internal.plugins.StringSharingPlugin;\n-import jdk.tools.jlink.internal.plugins.ZipPlugin;\n-import jdk.tools.jlink.plugin.Plugin;\n-import jdk.tools.jlink.plugin.ResourcePool;\n-import jdk.tools.jlink.plugin.ResourcePoolBuilder;\n-import jdk.tools.jlink.plugin.ResourcePoolEntry;\n-\n-import java.net.URI;\n-import java.nio.ByteOrder;\n-import java.nio.file.*;\n-import java.util.*;\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-public class CompactConstantPoolsPluginTest {\n-    private static int strID = 1;\n-\n-    public static void main(String[] args) throws Exception {\n-        new CompactConstantPoolsPluginTest().test();\n-    }\n-\n-    public void test() throws Exception {\n-        FileSystem fs;\n-        try {\n-            fs = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n-        } catch (ProviderNotFoundException | FileSystemNotFoundException e) {\n-            System.err.println(\"Not an image build, test skipped.\");\n-            return;\n-        }\n-        Path javabase = fs.getPath(\"\/modules\/java.base\");\n-        ResourcePool classes = gatherClasses(javabase);\n-        CompactConstantPoolsPlugin compressPlugin;\n-\n-        \/\/ Compact Constnat Pools\n-        Properties options1 = new Properties();\n-        compressPlugin = new CompactConstantPoolsPlugin();\n-        checkCompress(classes, compressPlugin,\n-                options1,\n-                new ResourceDecompressorFactory[]{\n-                        new StringSharingDecompressorFactory()\n-                });\n-\n-        \/\/ Compact Constant Pools + filter\n-        options1.setProperty(DefaultCompressPlugin.FILTER,\n-                \"**Exception.class\");\n-        compressPlugin = new CompactConstantPoolsPlugin();\n-        checkCompress(classes, compressPlugin,\n-                options1,\n-                new ResourceDecompressorFactory[]{\n-                        new StringSharingDecompressorFactory()\n-                }, Collections.singletonList(\".*Exception.class\"));\n-    }\n-\n-    private ResourcePool gatherResources(Path module) throws Exception {\n-        ResourcePoolManager poolMgr = new ResourcePoolManager(ByteOrder.nativeOrder(), new StringTable() {\n-\n-            @Override\n-            public int addString(String str) {\n-                return -1;\n-            }\n-\n-            @Override\n-            public String getString(int id) {\n-                return null;\n-            }\n-        });\n-\n-        ResourcePoolBuilder poolBuilder = poolMgr.resourcePoolBuilder();\n-        try (Stream<Path> stream = Files.walk(module)) {\n-            for (Iterator<Path> iterator = stream.iterator(); iterator.hasNext();) {\n-                Path p = iterator.next();\n-                if (Files.isRegularFile(p)) {\n-                    byte[] content = Files.readAllBytes(p);\n-                    poolBuilder.add(ResourcePoolEntry.create(p.toString(), content));\n-                }\n-            }\n-        }\n-        return poolBuilder.build();\n-    }\n-\n-    private ResourcePool gatherClasses(Path module) throws Exception {\n-        ResourcePoolManager poolMgr = new ResourcePoolManager(ByteOrder.nativeOrder(), new StringTable() {\n-\n-            @Override\n-            public int addString(String str) {\n-                return -1;\n-            }\n-\n-            @Override\n-            public String getString(int id) {\n-                return null;\n-            }\n-        });\n-\n-        ResourcePoolBuilder poolBuilder = poolMgr.resourcePoolBuilder();\n-        try (Stream<Path> stream = Files.walk(module)) {\n-            for (Iterator<Path> iterator = stream.iterator(); iterator.hasNext();) {\n-                Path p = iterator.next();\n-                if (Files.isRegularFile(p) && p.toString().endsWith(\".class\")) {\n-                    byte[] content = Files.readAllBytes(p);\n-                    poolBuilder.add(ResourcePoolEntry.create(p.toString(), content));\n-                }\n-            }\n-        }\n-        return poolBuilder.build();\n-    }\n-\n-    private void checkCompress(ResourcePool resources, Plugin prov,\n-                               Properties config,\n-                               ResourceDecompressorFactory[] factories) throws Exception {\n-        checkCompress(resources, prov, config, factories, Collections.emptyList());\n-    }\n-\n-    private void checkCompress(ResourcePool resources, Plugin prov,\n-                               Properties config,\n-                               ResourceDecompressorFactory[] factories,\n-                               List<String> includes) throws Exception {\n-        if (factories.length == 0) {\n-            \/\/ no compression, nothing to check!\n-            return;\n-        }\n-\n-        long[] original = new long[1];\n-        long[] compressed = new long[1];\n-        resources.entries().forEach(resource -> {\n-            List<Pattern> includesPatterns = includes.stream()\n-                    .map(Pattern::compile)\n-                    .collect(Collectors.toList());\n-\n-            Map<String, String> props = new HashMap<>();\n-            if (config != null) {\n-                for (String p : config.stringPropertyNames()) {\n-                    props.put(p, config.getProperty(p));\n-                }\n-            }\n-            prov.configure(props);\n-            final Map<Integer, String> strings = new HashMap<>();\n-            ResourcePoolManager inputResourcesMgr = new ResourcePoolManager(ByteOrder.nativeOrder(), new StringTable() {\n-                @Override\n-                public int addString(String str) {\n-                    int id = strID;\n-                    strID += 1;\n-                    strings.put(id, str);\n-                    return id;\n-                }\n-\n-                @Override\n-                public String getString(int id) {\n-                    return strings.get(id);\n-                }\n-            });\n-            inputResourcesMgr.add(resource);\n-            ResourcePool compressedResources = applyCompressor(prov, inputResourcesMgr, resource, includesPatterns);\n-            original[0] += resource.contentLength();\n-            compressed[0] += compressedResources.findEntry(resource.path()).get().contentLength();\n-            applyDecompressors(factories, inputResourcesMgr.resourcePool(), compressedResources, strings, includesPatterns);\n-        });\n-        String compressors = Stream.of(factories)\n-                .map(Object::getClass)\n-                .map(Class::getSimpleName)\n-                .collect(Collectors.joining(\", \"));\n-        String size = \"Compressed size: \" + compressed[0] + \", original size: \" + original[0];\n-        System.out.println(\"Used \" + compressors + \". \" + size);\n-        if (original[0] <= compressed[0]) {\n-            throw new AssertionError(\"java.base not compressed.\");\n-        }\n-    }\n-\n-    private ResourcePool applyCompressor(Plugin plugin,\n-                                         ResourcePoolManager inputResources,\n-                                         ResourcePoolEntry res,\n-                                         List<Pattern> includesPatterns) {\n-        ResourcePoolManager resMgr = new ResourcePoolManager(ByteOrder.nativeOrder(),\n-                inputResources.getStringTable());\n-        ResourcePool compressedResourcePool = plugin.transform(inputResources.resourcePool(),\n-                resMgr.resourcePoolBuilder());\n-        String path = res.path();\n-        ResourcePoolEntry compressed = compressedResourcePool.findEntry(path).get();\n-        CompressedResourceHeader header\n-                = CompressedResourceHeader.readFromResource(ByteOrder.nativeOrder(), compressed.contentBytes());\n-        if (isIncluded(includesPatterns, path)) {\n-            if (header == null) {\n-                throw new AssertionError(\"Path should be compressed: \" + path);\n-            }\n-            if (header.getDecompressorNameOffset() == 0) {\n-                throw new AssertionError(\"Invalid plugin offset \"\n-                        + header.getDecompressorNameOffset());\n-            }\n-            if (header.getResourceSize() <= 0) {\n-                throw new AssertionError(\"Invalid compressed size \"\n-                        + header.getResourceSize());\n-            }\n-        } else if (header != null) {\n-            throw new AssertionError(\"Path should not be compressed: \" + path);\n-        }\n-        return compressedResourcePool;\n-    }\n-\n-    private void applyDecompressors(ResourceDecompressorFactory[] decompressors,\n-                                    ResourcePool inputResources,\n-                                    ResourcePool compressedResources,\n-                                    Map<Integer, String> strings,\n-                                    List<Pattern> includesPatterns) {\n-        compressedResources.entries().forEach(compressed -> {\n-            CompressedResourceHeader header = CompressedResourceHeader.readFromResource(\n-                    ByteOrder.nativeOrder(), compressed.contentBytes());\n-            String path = compressed.path();\n-            ResourcePoolEntry orig = inputResources.findEntry(path).get();\n-            if (!isIncluded(includesPatterns, path)) {\n-                return;\n-            }\n-            byte[] decompressed = compressed.contentBytes();\n-            for (ResourceDecompressorFactory factory : decompressors) {\n-                try {\n-                    ResourceDecompressor decompressor = factory.newDecompressor(new Properties());\n-                    decompressed = decompressor.decompress(\n-                            strings::get, decompressed,\n-                            CompressedResourceHeader.getSize(), header.getUncompressedSize());\n-                } catch (Exception exp) {\n-                    throw new RuntimeException(exp);\n-                }\n-            }\n-\n-            if (decompressed.length != orig.contentLength()) {\n-                throw new AssertionError(\"Invalid uncompressed size \"\n-                        + header.getUncompressedSize());\n-            }\n-            byte[] origContent = orig.contentBytes();\n-            for (int i = 0; i < decompressed.length; i++) {\n-                if (decompressed[i] != origContent[i]) {\n-                    throw new AssertionError(\"Decompressed and original differ at index \" + i);\n-                }\n-            }\n-        });\n-    }\n-\n-    private boolean isIncluded(List<Pattern> includesPatterns, String path) {\n-        return includesPatterns.isEmpty() ||\n-                includesPatterns.stream().anyMatch((pattern) -> pattern.matcher(path).matches());\n-    }\n-}\n","filename":"test\/jdk\/tools\/jlink\/plugins\/CompactConstantPoolsPluginTest.java","additions":0,"deletions":281,"binary":false,"changes":281,"status":"deleted"}]}