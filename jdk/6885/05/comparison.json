{"files":[{"patch":"@@ -415,7 +415,0 @@\n-\n-    if test \"x$TOOLCHAIN_TYPE\" = xxlc; then\n-      # We need '-qminimaltoc' or '-qpic=large -bbigtoc' if the TOC overflows.\n-      # Hotspot now overflows its 64K TOC (currently only for debug),\n-      # so for debug we build with '-qpic=large -bbigtoc'.\n-      DEBUG_CFLAGS_JVM=\"-qpic=large\"\n-    fi\n@@ -436,1 +429,1 @@\n-    ALWAYS_DEFINES_JVM=\"-D_REENTRANT\"\n+    ALWAYS_DEFINES_JVM=\"-D_REENTRANT -qpic=large\"\n","filename":"make\/autoconf\/flags-cflags.m4","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -268,16 +268,0 @@\n-###############################################################################\n-# Check if the feature 'jfr' is available on this platform.\n-#\n-AC_DEFUN_ONCE([JVM_FEATURES_CHECK_JFR],\n-[\n-  JVM_FEATURES_CHECK_AVAILABILITY(jfr, [\n-    AC_MSG_CHECKING([if platform is supported by JFR])\n-    if test \"x$OPENJDK_TARGET_OS\" = xaix; then\n-      AC_MSG_RESULT([no, $OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU])\n-      AVAILABLE=false\n-    else\n-      AC_MSG_RESULT([yes])\n-    fi\n-  ])\n-])\n-\n@@ -403,1 +387,0 @@\n-  JVM_FEATURES_CHECK_JFR\n@@ -409,6 +392,0 @@\n-  # Filter out features by default for all variants on certain platforms.\n-  # Make sure to just add to JVM_FEATURES_PLATFORM_FILTER, since it could\n-  # have a value already from custom extensions.\n-  if test \"x$OPENJDK_TARGET_OS\" = xaix; then\n-    JVM_FEATURES_PLATFORM_FILTER=\"$JVM_FEATURES_PLATFORM_FILTER jfr\"\n-  fi\n","filename":"make\/autoconf\/jvm-features.m4","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+#include <libperfstat.h>\n+#include <sys\/procfs.h>\n@@ -48,89 +50,6 @@\n-\/**\n-   \/proc\/[number]\/stat\n-              Status information about the process.  This is used by ps(1).  It is defined in \/usr\/src\/linux\/fs\/proc\/array.c.\n-\n-              The fields, in order, with their proper scanf(3) format specifiers, are:\n-\n-              1. pid %d The process id.\n-\n-              2. comm %s\n-                     The filename of the executable, in parentheses.  This is visible whether or not the executable is swapped out.\n-\n-              3. state %c\n-                     One  character  from  the  string \"RSDZTW\" where R is running, S is sleeping in an interruptible wait, D is waiting in uninterruptible disk\n-                     sleep, Z is zombie, T is traced or stopped (on a signal), and W is paging.\n-\n-              4. ppid %d\n-                     The PID of the parent.\n-\n-              5. pgrp %d\n-                     The process group ID of the process.\n-\n-              6. session %d\n-                     The session ID of the process.\n-\n-              7. tty_nr %d\n-                     The tty the process uses.\n-\n-              8. tpgid %d\n-                     The process group ID of the process which currently owns the tty that the process is connected to.\n-\n-              9. flags %lu\n-                     The flags of the process.  The math bit is decimal 4, and the traced bit is decimal 10.\n-\n-              10. minflt %lu\n-                     The number of minor faults the process has made which have not required loading a memory page from disk.\n-\n-              11. cminflt %lu\n-                     The number of minor faults that the process's waited-for children have made.\n-\n-              12. majflt %lu\n-                     The number of major faults the process has made which have required loading a memory page from disk.\n-\n-              13. cmajflt %lu\n-                     The number of major faults that the process's waited-for children have made.\n-\n-              14. utime %lu\n-                     The number of jiffies that this process has been scheduled in user mode.\n-\n-              15. stime %lu\n-                     The number of jiffies that this process has been scheduled in kernel mode.\n-\n-              16. cutime %ld\n-                     The number of jiffies that this process's waited-for children have been scheduled in user mode. (See also times(2).)\n-\n-              17. cstime %ld\n-                     The number of jiffies that this process' waited-for children have been scheduled in kernel mode.\n-\n-              18. priority %ld\n-                     The standard nice value, plus fifteen.  The value is never negative in the kernel.\n-\n-              19. nice %ld\n-                     The nice value ranges from 19 (nicest) to -19 (not nice to others).\n-\n-              20. 0 %ld  This value is hard coded to 0 as a placeholder for a removed field.\n-\n-              21. itrealvalue %ld\n-                     The time in jiffies before the next SIGALRM is sent to the process due to an interval timer.\n-\n-              22. starttime %lu\n-                     The time in jiffies the process started after system boot.\n-\n-              23. vsize %lu\n-                     Virtual memory size in bytes.\n-\n-              24. rss %ld\n-                     Resident Set Size: number of pages the process has in real memory, minus 3 for administrative purposes. This is just the pages which  count\n-                     towards text, data, or stack space.  This does not include pages which have not been demand-loaded in, or which are swapped out.\n-\n-              25. rlim %lu\n-                     Current limit in bytes on the rss of the process (usually 4294967295 on i386).\n-\n-              26. startcode %lu\n-                     The address above which program text can run.\n-\n-              27. endcode %lu\n-                     The address below which program text can run.\n-\n-              28. startstack %lu\n-                     The address of the start of the stack.\n+typedef struct {\n+  u_longlong_t  user;\n+  u_longlong_t  sys;\n+  u_longlong_t  idle;\n+  u_longlong_t  wait;\n+} CPUPerfTicks;\n@@ -138,80 +57,4 @@\n-              29. kstkesp %lu\n-                     The current value of esp (stack pointer), as found in the kernel stack page for the process.\n-\n-              30. kstkeip %lu\n-                     The current EIP (instruction pointer).\n-\n-              31. signal %lu\n-                     The bitmap of pending signals (usually 0).\n-\n-              32. blocked %lu\n-                     The bitmap of blocked signals (usually 0, 2 for shells).\n-\n-              33. sigignore %lu\n-                     The bitmap of ignored signals.\n-\n-              34. sigcatch %lu\n-                     The bitmap of catched signals.\n-\n-              35. wchan %lu\n-                     This  is the \"channel\" in which the process is waiting.  It is the address of a system call, and can be looked up in a namelist if you need\n-                     a textual name.  (If you have an up-to-date \/etc\/psdatabase, then try ps -l to see the WCHAN field in action.)\n-\n-              36. nswap %lu\n-                     Number of pages swapped - not maintained.\n-\n-              37. cnswap %lu\n-                     Cumulative nswap for child processes.\n-\n-              38. exit_signal %d\n-                     Signal to be sent to parent when we die.\n-\n-              39. processor %d\n-                     CPU number last executed on.\n-\n-\n-\n- \/\/\/\/\/ SSCANF FORMAT STRING. Copy and use.\n-\n-field:        1  2  3  4  5  6  7  8  9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38 39\n-format:       %d %s %c %d %d %d %d %d %lu %lu %lu %lu %lu %lu %lu %ld %ld %ld %ld %ld %ld %lu %lu %ld %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %d %d\n-\n-\n-*\/\n-\n-\/**\n- * For platforms that have them, when declaring\n- * a printf-style function,\n- *   formatSpec is the parameter number (starting at 1)\n- *       that is the format argument (\"%d pid %s\")\n- *   params is the parameter number where the actual args to\n- *       the format starts. If the args are in a va_list, this\n- *       should be 0.\n- *\/\n-#ifndef PRINTF_ARGS\n-#  define PRINTF_ARGS(formatSpec,  params) ATTRIBUTE_PRINTF(formatSpec, params)\n-#endif\n-\n-#ifndef SCANF_ARGS\n-#  define SCANF_ARGS(formatSpec,   params) ATTRIBUTE_SCANF(formatSpec, params)\n-#endif\n-\n-#ifndef _PRINTFMT_\n-#  define _PRINTFMT_\n-#endif\n-\n-#ifndef _SCANFMT_\n-#  define _SCANFMT_\n-#endif\n-\n-\n-struct CPUPerfTicks {\n-  uint64_t  used;\n-  uint64_t  usedKernel;\n-  uint64_t  total;\n-};\n-\n-typedef enum {\n-  CPU_LOAD_VM_ONLY,\n-  CPU_LOAD_GLOBAL,\n-} CpuLoadTarget;\n+typedef struct {\n+  double utime;\n+  double stime;\n+} JVMTime;\n@@ -226,10 +69,2 @@\n-struct CPUPerfCounters {\n-  int   nProcs;\n-  CPUPerfTicks jvmTicks;\n-  CPUPerfTicks* cpus;\n-};\n-\n-static double get_cpu_load(int which_logical_cpu, CPUPerfCounters* counters, double* pkernelLoad, CpuLoadTarget target);\n-\n-\/** reads \/proc\/<pid>\/stat data, with some checks and some skips.\n- *  Ensure that 'fmt' does _NOT_ contain the first two \"%d %s\"\n+\/**\n+ * Get and set ticks for the specified lcpu\n@@ -237,4 +72,2 @@\n-static int SCANF_ARGS(2, 0) vread_statdata(const char* procfile, _SCANFMT_ const char* fmt, va_list args) {\n-  FILE*f;\n-  int n;\n-  char buf[2048];\n+static OSReturn get_lcpu_ticks(perfstat_id_t* lcpu_name, CPUPerfTicks* pticks) {\n+  perfstat_cpu_t lcpu_stats;\n@@ -242,2 +75,2 @@\n-  if ((f = fopen(procfile, \"r\")) == NULL) {\n-    return -1;\n+  if (!pticks) {\n+    return OS_ERR;\n@@ -246,13 +79,7 @@\n-  if ((n = fread(buf, 1, sizeof(buf), f)) != -1) {\n-    char *tmp;\n-\n-    buf[n-1] = '\\0';\n-    \/** skip through pid and exec name. *\/\n-    if ((tmp = strrchr(buf, ')')) != NULL) {\n-      \/\/ skip the ')' and the following space\n-      \/\/ but check that buffer is long enough\n-      tmp += 2;\n-      if (tmp < buf + n) {\n-        n = vsscanf(tmp, fmt, args);\n-      }\n-    }\n+  \/\/ populate cpu_stats\n+  if (perfstat_cpu(lcpu_name, &lcpu_stats, sizeof(perfstat_cpu_t), 1) < 1) {\n+    pticks->user = 0;\n+    pticks->sys  = 0;\n+    pticks->idle = 0;\n+    pticks->wait = 0;\n+    return OS_ERR;\n@@ -261,8 +88,4 @@\n-  fclose(f);\n-\n-  return n;\n-}\n-\n-static int SCANF_ARGS(2, 3) read_statdata(const char* procfile, _SCANFMT_ const char* fmt, ...) {\n-  int   n;\n-  va_list args;\n+  pticks->user = lcpu_stats.user;\n+  pticks->sys  = lcpu_stats.sys;\n+  pticks->idle = lcpu_stats.idle;\n+  pticks->wait = lcpu_stats.wait;\n@@ -270,4 +93,1 @@\n-  va_start(args, fmt);\n-  n = vread_statdata(procfile, fmt, args);\n-  va_end(args);\n-  return n;\n+  return OS_OK;\n@@ -277,2 +97,1 @@\n- * on Linux we got the ticks related information from \/proc\/stat\n- * this does not work on AIX, libperfstat might be an alternative\n+ * Return CPU load caused by the currently executing process (the jvm).\n@@ -280,3 +99,3 @@\n-static OSReturn get_total_ticks(int which_logical_cpu, CPUPerfTicks* pticks) {\n-  return OS_ERR;\n-}\n+static OSReturn get_jvm_load(double* jvm_uload, double* jvm_sload) {\n+  static clock_t ticks_per_sec = sysconf(_SC_CLK_TCK);\n+  static u_longlong_t last_timebase = 0;\n@@ -284,5 +103,3 @@\n-\/** read user and system ticks from a named procfile, assumed to be in 'stat' format then. *\/\n-static int read_ticks(const char* procfile, uint64_t* userTicks, uint64_t* systemTicks) {\n-  return read_statdata(procfile, \"%*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u \" UINT64_FORMAT \" \" UINT64_FORMAT,\n-    userTicks, systemTicks);\n-}\n+  perfstat_process_t jvm_stats;\n+  perfstat_id_t name_holder;\n+  u_longlong_t timebase_diff;\n@@ -290,29 +107,3 @@\n-\/**\n- * Return the number of ticks spent in any of the processes belonging\n- * to the JVM on any CPU.\n- *\/\n-static OSReturn get_jvm_ticks(CPUPerfTicks* pticks) {\n-  return OS_ERR;\n-}\n-\n-\/**\n- * Return the load of the CPU as a double. 1.0 means the CPU process uses all\n- * available time for user or system processes, 0.0 means the CPU uses all time\n- * being idle.\n- *\n- * Returns a negative value if there is a problem in determining the CPU load.\n- *\/\n-static double get_cpu_load(int which_logical_cpu, CPUPerfCounters* counters, double* pkernelLoad, CpuLoadTarget target) {\n-  uint64_t udiff, kdiff, tdiff;\n-  CPUPerfTicks* pticks;\n-  CPUPerfTicks  tmp;\n-  double user_load;\n-\n-  *pkernelLoad = 0.0;\n-\n-  if (target == CPU_LOAD_VM_ONLY) {\n-    pticks = &counters->jvmTicks;\n-  } else if (-1 == which_logical_cpu) {\n-    pticks = &counters->cpus[counters->nProcs];\n-  } else {\n-    pticks = &counters->cpus[which_logical_cpu];\n+  snprintf(name_holder.name, IDENTIFIER_LENGTH, \"%d\", getpid());\n+  if (perfstat_process(&name_holder, &jvm_stats, sizeof(perfstat_process_t), 1) < 1) {\n+    return OS_ERR;\n@@ -321,1 +112,3 @@\n-  tmp = *pticks;\n+  \/\/ Update timebase\n+  timebase_diff = jvm_stats.last_timebase - last_timebase;\n+  last_timebase = jvm_stats.last_timebase;\n@@ -323,6 +116,5 @@\n-  if (target == CPU_LOAD_VM_ONLY) {\n-    if (get_jvm_ticks(pticks) != OS_OK) {\n-      return -1.0;\n-    }\n-  } else if (get_total_ticks(which_logical_cpu, pticks) != OS_OK) {\n-    return -1.0;\n+  if (jvm_uload) {\n+    *jvm_uload = jvm_stats.ucpu_time \/ timebase_diff;\n+  }\n+  if (jvm_sload) {\n+    *jvm_sload = jvm_stats.scpu_time \/ timebase_diff;\n@@ -331,6 +123,7 @@\n-  \/\/ seems like we sometimes end up with less kernel ticks when\n-  \/\/ reading \/proc\/self\/stat a second time, timing issue between cpus?\n-  if (pticks->usedKernel < tmp.usedKernel) {\n-    kdiff = 0;\n-  } else {\n-    kdiff = pticks->usedKernel - tmp.usedKernel;\n+  return OS_OK;\n+}\n+\n+static void update_prev_time(JVMTime* from, JVMTime* to) {\n+  if (from && to) {\n+    to->utime = from->utime;\n+    to->stime = from->stime;\n@@ -338,2 +131,1 @@\n-  tdiff = pticks->total - tmp.total;\n-  udiff = pticks->used - tmp.used;\n+}\n@@ -341,4 +133,6 @@\n-  if (tdiff == 0) {\n-    return 0.0;\n-  } else if (tdiff < (udiff + kdiff)) {\n-    tdiff = udiff + kdiff;\n+static void update_prev_ticks(CPUPerfTicks* from, CPUPerfTicks* to) {\n+  if (from && to) {\n+    to->user = from->user;\n+    to->sys  = from->sys;\n+    to->idle = from->idle;\n+    to->wait = from->wait;\n@@ -346,4 +140,1 @@\n-  *pkernelLoad = (kdiff \/ (double)tdiff);\n-  \/\/ BUG9044876, normalize return values to sane values\n-  *pkernelLoad = MAX2<double>(*pkernelLoad, 0.0);\n-  *pkernelLoad = MIN2<double>(*pkernelLoad, 1.0);\n+}\n@@ -351,3 +142,5 @@\n-  user_load = (udiff \/ (double)tdiff);\n-  user_load = MAX2<double>(user_load, 0.0);\n-  user_load = MIN2<double>(user_load, 1.0);\n+\/**\n+ * Calculate the current system load from current ticks using previous ticks as a starting point.\n+ *\/\n+static void calculate_updated_load(CPUPerfTicks* update, CPUPerfTicks* prev, double* load) {\n+  CPUPerfTicks diff;\n@@ -355,2 +148,5 @@\n-  return user_load;\n-}\n+  if (update && prev && load) {\n+    diff.user = update->user - prev->user;\n+    diff.sys  = update->sys  - prev->sys;\n+    diff.idle = update->idle - prev->idle;\n+    diff.wait = update->wait - prev->wait;\n@@ -358,2 +154,2 @@\n-static int SCANF_ARGS(1, 2) parse_stat(_SCANFMT_ const char* fmt, ...) {\n-  return OS_ERR;\n+    *load = 1.0 - diff.idle\/(diff.sys + diff.user + diff.idle + diff.wait);\n+  }\n@@ -362,3 +158,7 @@\n-static int get_noof_context_switches(uint64_t* switches) {\n-  return parse_stat(\"ctxt \" UINT64_FORMAT \"\\n\", switches);\n-}\n+\/**\n+ * Look up lcpu names for later re-use.\n+ *\/\n+static void populate_lcpu_names(int ncpus, perfstat_id_t* lcpu_names) {\n+  perfstat_cpu_t* all_lcpu_stats;\n+  perfstat_cpu_t* lcpu_stats;\n+  perfstat_id_t   name_holder;\n@@ -366,4 +166,1 @@\n-\/** returns boot time in _seconds_ since epoch *\/\n-static int get_boot_time(uint64_t* time) {\n-  return parse_stat(\"btime \" UINT64_FORMAT \"\\n\", time);\n-}\n+  assert(lcpu_names, \"Names pointer NULL\");\n@@ -371,6 +168,1 @@\n-static int perf_context_switch_rate(double* rate) {\n-  static pthread_mutex_t contextSwitchLock = PTHREAD_MUTEX_INITIALIZER;\n-  static uint64_t      bootTime;\n-  static uint64_t      lastTimeNanos;\n-  static uint64_t      lastSwitches;\n-  static double        lastRate;\n+  strncpy(name_holder.name, FIRST_CPU, IDENTIFIER_LENGTH);\n@@ -378,2 +170,1 @@\n-  uint64_t bt = 0;\n-  int res = 0;\n+  all_lcpu_stats = (perfstat_cpu_t*) NEW_RESOURCE_ARRAY(perfstat_cpu_t, ncpus);\n@@ -381,7 +172,5 @@\n-  \/\/ First time through bootTime will be zero.\n-  if (bootTime == 0) {\n-    uint64_t tmp;\n-    if (get_boot_time(&tmp) < 0) {\n-      return OS_ERR;\n-    }\n-    bt = tmp * 1000;\n+  \/\/ populate cpu_stats && check that the expected number of records have been populated\n+  if (ncpus > perfstat_cpu(&name_holder, all_lcpu_stats, sizeof(perfstat_cpu_t), ncpus)) {\n+    FREE_RESOURCE_ARRAY(perfstat_cpu_t, all_lcpu_stats, ncpus);\n+    lcpu_names = NULL;\n+    return;\n@@ -390,21 +179,3 @@\n-  res = OS_OK;\n-\n-  pthread_mutex_lock(&contextSwitchLock);\n-  {\n-\n-    uint64_t sw;\n-    s8 t, d;\n-\n-    if (bootTime == 0) {\n-      \/\/ First interval is measured from boot time which is\n-      \/\/ seconds since the epoch. Thereafter we measure the\n-      \/\/ elapsed time using javaTimeNanos as it is monotonic-\n-      \/\/ non-decreasing.\n-      lastTimeNanos = os::javaTimeNanos();\n-      t = os::javaTimeMillis();\n-      d = t - bt;\n-      \/\/ keep bootTime zero for now to use as a first-time-through flag\n-    } else {\n-      t = os::javaTimeNanos();\n-      d = nanos_to_millis(t - lastTimeNanos);\n-    }\n+  for (int n=0; n < ncpus; n++) {\n+    strncpy(lcpu_names[n].name, all_lcpu_stats[n].name, IDENTIFIER_LENGTH);\n+  }\n@@ -412,17 +183,2 @@\n-    if (d == 0) {\n-      *rate = lastRate;\n-    } else if (get_noof_context_switches(&sw) == 0) {\n-      *rate      = ( (double)(sw - lastSwitches) \/ d ) * 1000;\n-      lastRate     = *rate;\n-      lastSwitches = sw;\n-      if (bootTime != 0) {\n-        lastTimeNanos = t;\n-      }\n-    } else {\n-      *rate = 0;\n-      res   = OS_ERR;\n-    }\n-    if (*rate <= 0) {\n-      *rate = 0;\n-      lastRate = 0;\n-    }\n+  FREE_RESOURCE_ARRAY(perfstat_cpu_t, all_lcpu_stats, ncpus);\n+}\n@@ -430,5 +186,13 @@\n-    if (bootTime == 0) {\n-      bootTime = bt;\n-    }\n-  }\n-  pthread_mutex_unlock(&contextSwitchLock);\n+\/**\n+ * Calculates the context switch rate.\n+ * (Context Switches \/ Tick) * (Tick \/ s) = Context Switches per second\n+ *\/\n+static OSReturn perf_context_switch_rate(double* rate) {\n+  static clock_t ticks_per_sec = sysconf(_SC_CLK_TCK);\n+\n+  u_longlong_t ticks;\n+  perfstat_cpu_total_t cpu_stats;\n+\n+   if (perfstat_cpu_total(NULL, &cpu_stats, sizeof(perfstat_cpu_total_t), 1) < 0) {\n+     return OS_ERR;\n+   }\n@@ -436,1 +200,4 @@\n-  return res;\n+   ticks = cpu_stats.user + cpu_stats.sys + cpu_stats.idle + cpu_stats.wait;\n+   *rate = (cpu_stats.pswitch \/ ticks) * ticks_per_sec;\n+\n+   return OS_OK;\n@@ -440,1 +207,0 @@\n-  friend class CPUPerformanceInterface;\n@@ -442,6 +208,3 @@\n-  CPUPerfCounters _counters;\n-\n-  int cpu_load(int which_logical_cpu, double* cpu_load);\n-  int context_switch_rate(double* rate);\n-  int cpu_load_total_process(double* cpu_load);\n-  int cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad);\n+  int _ncpus;\n+  perfstat_id_t* _lcpu_names;\n+  CPUPerfTicks* _prev_ticks;\n@@ -453,0 +216,5 @@\n+\n+  int cpu_load(int which_logical_cpu, double* cpu_load);\n+  int context_switch_rate(double* rate);\n+  int cpu_load_total_process(double* cpu_load);\n+  int cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad);\n@@ -455,4 +223,4 @@\n-CPUPerformanceInterface::CPUPerformance::CPUPerformance() {\n-  _counters.nProcs = os::active_processor_count();\n-  _counters.cpus = NULL;\n-}\n+CPUPerformanceInterface::CPUPerformance::CPUPerformance():\n+  _ncpus(0),\n+  _lcpu_names(NULL),\n+  _prev_ticks(NULL) {}\n@@ -461,6 +229,1 @@\n-  size_t array_entry_count = _counters.nProcs + 1;\n-  _counters.cpus = NEW_C_HEAP_ARRAY(CPUPerfTicks, array_entry_count, mtInternal);\n-  memset(_counters.cpus, 0, array_entry_count * sizeof(*_counters.cpus));\n-\n-  \/\/ For the CPU load total\n-  get_total_ticks(-1, &_counters.cpus[_counters.nProcs]);\n+  perfstat_cpu_total_t cpu_stats;\n@@ -468,3 +231,2 @@\n-  \/\/ For each CPU\n-  for (int i = 0; i < _counters.nProcs; i++) {\n-    get_total_ticks(i, &_counters.cpus[i]);\n+   if (perfstat_cpu_total(NULL, &cpu_stats, sizeof(perfstat_cpu_total_t), 1) < 0) {\n+     return false;\n@@ -472,2 +234,0 @@\n-  \/\/ For JVM load\n-  get_jvm_ticks(&_counters.jvmTicks);\n@@ -475,4 +235,1 @@\n-  \/\/ initialize context switch system\n-  \/\/ the double is only for init\n-  double init_ctx_switch_rate;\n-  perf_context_switch_rate(&init_ctx_switch_rate);\n+  _ncpus = cpu_stats.ncpus;\n@@ -480,1 +237,14 @@\n-  return true;\n+  _lcpu_names = NEW_C_HEAP_ARRAY(perfstat_id_t, _ncpus, mtInternal);\n+  populate_lcpu_names(_ncpus, _lcpu_names);\n+\n+  _prev_ticks = NEW_C_HEAP_ARRAY(CPUPerfTicks,  _ncpus, mtInternal);\n+  \/\/ Set all prev-tick values to 0\n+  \/\/ memset(_prev_ticks, 0, _ncpus*sizeof(CPUPerfTicks));\n+  for (int n = 0; n < _ncpus; n++) {\n+    _prev_ticks[n].user = 0;\n+    _prev_ticks[n].sys  = 0;\n+    _prev_ticks[n].idle = 0;\n+    _prev_ticks[n].wait = 0;\n+  }\n+\n+  return _lcpu_names != NULL;\n@@ -484,2 +254,2 @@\n-  if (_counters.cpus != NULL) {\n-    FREE_C_HEAP_ARRAY(char, _counters.cpus);\n+  if (_lcpu_names) {\n+    FREE_C_HEAP_ARRAY(perfstat_id_t, _lcpu_names);\n@@ -489,5 +259,11 @@\n-int CPUPerformanceInterface::CPUPerformance::cpu_load(int which_logical_cpu, double* cpu_load) {\n-  double u, s;\n-  u = get_cpu_load(which_logical_cpu, &_counters, &s, CPU_LOAD_GLOBAL);\n-  if (u < 0) {\n-    *cpu_load = 0.0;\n+\/**\n+ * Get CPU load for all processes on specified logical CPU.\n+ *\/\n+int CPUPerformanceInterface::CPUPerformance::cpu_load(int lcpu_number, double* lcpu_load) {\n+  CPUPerfTicks ticks;\n+\n+  assert(lcpu_load != NULL, \"NULL pointer passed to cpu_load\");\n+  assert(lcpu_number < _ncpus, \"Invalid lcpu passed to cpu_load\");\n+\n+  if (get_lcpu_ticks(&_lcpu_names[lcpu_number], &ticks) == OS_ERR) {\n+    *lcpu_load = -1.0;\n@@ -496,2 +272,4 @@\n-  \/\/ Cap total systemload to 1.0\n-  *cpu_load = MIN2<double>((u + s), 1.0);\n+\n+  calculate_updated_load(&ticks, &_prev_ticks[lcpu_number], lcpu_load);\n+  update_prev_ticks(&ticks, &_prev_ticks[lcpu_number]);\n+\n@@ -501,6 +279,39 @@\n-int CPUPerformanceInterface::CPUPerformance::cpu_load_total_process(double* cpu_load) {\n-  double u, s;\n-  u = get_cpu_load(-1, &_counters, &s, CPU_LOAD_VM_ONLY);\n-  if (u < 0) {\n-    *cpu_load = 0.0;\n-    return OS_ERR;\n+\/**\n+ * Get CPU load for all processes on all CPUs.\n+ *\/\n+int CPUPerformanceInterface::CPUPerformance::cpu_load_total_process(double* total_load) {\n+  CPUPerfTicks total_ticks;\n+  CPUPerfTicks prev_total_ticks;\n+\n+  assert(total_load != NULL, \"NULL pointer passed to cpu_load_total_process\");\n+\n+  total_ticks.user = 0;\n+  total_ticks.sys  = 0;\n+  total_ticks.idle = 0;\n+  total_ticks.wait = 0;\n+\n+  prev_total_ticks.user = 0;\n+  prev_total_ticks.sys  = 0;\n+  prev_total_ticks.idle = 0;\n+  prev_total_ticks.wait = 0;\n+\n+  for (int lcpu = 0; lcpu < _ncpus; lcpu++) {\n+    CPUPerfTicks lcpu_ticks;\n+\n+    if (get_lcpu_ticks(&_lcpu_names[lcpu], &lcpu_ticks) == OS_ERR) {\n+      *total_load = -1.0;\n+      printf(\"Error: Could not calculate load for lcpu %s\\n\", _lcpu_names[lcpu].name);\n+      return OS_ERR;\n+    }\n+\n+    total_ticks.user = lcpu_ticks.user;\n+    total_ticks.sys  = lcpu_ticks.sys;\n+    total_ticks.idle = lcpu_ticks.idle;\n+    total_ticks.wait = lcpu_ticks.wait;\n+\n+    prev_total_ticks.user += _prev_ticks[lcpu].user;\n+    prev_total_ticks.sys  += _prev_ticks[lcpu].sys;\n+    prev_total_ticks.idle += _prev_ticks[lcpu].idle;\n+    prev_total_ticks.wait += _prev_ticks[lcpu].wait;\n+\n+    update_prev_ticks(&lcpu_ticks, &_prev_ticks[lcpu]);\n@@ -508,1 +319,3 @@\n-  *cpu_load = u + s;\n+\n+  calculate_updated_load(&total_ticks, &prev_total_ticks, total_load);\n+\n@@ -512,0 +325,11 @@\n+\/**\n+ * Get CPU load for all CPUs.\n+ *\n+ * Set values for:\n+ * - pjvmUserLoad:     CPU load due to jvm process in user mode. Jvm process assumed to be self process\n+ * - pjvmKernelLoad:   CPU load due to jvm process in kernel mode. Jvm process assumed to be self process\n+ * - psystemTotalLoad: Total CPU load from all process on all logical CPUs\n+ *\n+ * Note: If any of the above loads cannot be calculated, this procedure returns OS_ERR and any load that could not be calculated is set to -1\n+ *\n+ *\/\n@@ -513,5 +337,1 @@\n-  double u, s, t;\n-\n-  assert(pjvmUserLoad != NULL, \"pjvmUserLoad not inited\");\n-  assert(pjvmKernelLoad != NULL, \"pjvmKernelLoad not inited\");\n-  assert(psystemTotalLoad != NULL, \"psystemTotalLoad not inited\");\n+  double u, k, t;\n@@ -519,6 +339,3 @@\n-  u = get_cpu_load(-1, &_counters, &s, CPU_LOAD_VM_ONLY);\n-  if (u < 0) {\n-    *pjvmUserLoad = 0.0;\n-    *pjvmKernelLoad = 0.0;\n-    *psystemTotalLoad = 0.0;\n-    return OS_ERR;\n+  int retval = OS_OK;\n+  if (get_jvm_load(&u, &k) == OS_ERR || cpu_load_total_process(&t) == OS_ERR) {\n+    retval = OS_ERR;\n@@ -527,4 +344,8 @@\n-  cpu_load(-1, &t);\n-  \/\/ clamp at user+system and 1.0\n-  if (u + s > t) {\n-    t = MIN2<double>(u + s, 1.0);\n+  if (pjvmUserLoad) {\n+    *pjvmUserLoad = u;\n+  }\n+  if (pjvmKernelLoad) {\n+    *pjvmKernelLoad = k;\n+  }\n+  if (psystemTotalLoad) {\n+    *psystemTotalLoad = t;\n@@ -533,5 +354,1 @@\n-  *pjvmUserLoad = u;\n-  *pjvmKernelLoad = s;\n-  *psystemTotalLoad = t;\n-\n-  return OS_OK;\n+  return retval;\n@@ -576,30 +393,4 @@\n-  friend class SystemProcessInterface;\n- private:\n-  class ProcessIterator : public CHeapObj<mtInternal> {\n-    friend class SystemProcessInterface::SystemProcesses;\n-   private:\n-    DIR*           _dir;\n-    struct dirent* _entry;\n-    bool           _valid;\n-    char           _exeName[PATH_MAX];\n-    char           _exePath[PATH_MAX];\n-\n-    ProcessIterator();\n-    ~ProcessIterator();\n-    bool initialize();\n-\n-    bool is_valid() const { return _valid; }\n-    bool is_valid_entry(struct dirent* entry) const;\n-    bool is_dir(const char* name) const;\n-    int  fsize(const char* name, uint64_t& size) const;\n-\n-    char* allocate_string(const char* str) const;\n-    void  get_exe_name();\n-    char* get_exe_path();\n-    char* get_cmdline();\n-\n-    int current(SystemProcess* process_info);\n-    int next_process();\n-  };\n-\n-  ProcessIterator* _iterator;\n+  private:\n+  char* allocate_string(const char* str) const;\n+\n+  public:\n@@ -609,2 +400,0 @@\n-\n-  \/\/information about system processes\n@@ -614,69 +403,1 @@\n-bool SystemProcessInterface::SystemProcesses::ProcessIterator::is_dir(const char* name) const {\n-  struct stat mystat;\n-  int ret_val = 0;\n-\n-  ret_val = stat(name, &mystat);\n-  if (ret_val < 0) {\n-    return false;\n-  }\n-  ret_val = S_ISDIR(mystat.st_mode);\n-  return ret_val > 0;\n-}\n-\n-int SystemProcessInterface::SystemProcesses::ProcessIterator::fsize(const char* name, uint64_t& size) const {\n-  assert(name != NULL, \"name pointer is NULL!\");\n-  size = 0;\n-  struct stat fbuf;\n-\n-  if (stat(name, &fbuf) < 0) {\n-    return OS_ERR;\n-  }\n-  size = fbuf.st_size;\n-  return OS_OK;\n-}\n-\n-\/\/ if it has a numeric name, is a directory and has a 'stat' file in it\n-bool SystemProcessInterface::SystemProcesses::ProcessIterator::is_valid_entry(struct dirent* entry) const {\n-  char buffer[PATH_MAX];\n-  uint64_t size = 0;\n-\n-  if (atoi(entry->d_name) != 0) {\n-    jio_snprintf(buffer, PATH_MAX, \"\/proc\/%s\", entry->d_name);\n-    buffer[PATH_MAX - 1] = '\\0';\n-\n-    if (is_dir(buffer)) {\n-      jio_snprintf(buffer, PATH_MAX, \"\/proc\/%s\/stat\", entry->d_name);\n-      buffer[PATH_MAX - 1] = '\\0';\n-      if (fsize(buffer, size) != OS_ERR) {\n-        return true;\n-      }\n-    }\n-  }\n-  return false;\n-}\n-\n-\/\/ get exe-name from \/proc\/<pid>\/stat\n-void SystemProcessInterface::SystemProcesses::ProcessIterator::get_exe_name() {\n-  FILE* fp;\n-  char  buffer[PATH_MAX];\n-\n-  jio_snprintf(buffer, PATH_MAX, \"\/proc\/%s\/stat\", _entry->d_name);\n-  buffer[PATH_MAX - 1] = '\\0';\n-  if ((fp = fopen(buffer, \"r\")) != NULL) {\n-    if (fgets(buffer, PATH_MAX, fp) != NULL) {\n-      char* start, *end;\n-      \/\/ exe-name is between the first pair of ( and )\n-      start = strchr(buffer, '(');\n-      if (start != NULL && start[1] != '\\0') {\n-        start++;\n-        end = strrchr(start, ')');\n-        if (end != NULL) {\n-          size_t len;\n-          len = MIN2<size_t>(end - start, sizeof(_exeName) - 1);\n-          memcpy(_exeName, start, len);\n-          _exeName[len] = '\\0';\n-        }\n-      }\n-    }\n-    fclose(fp);\n-  }\n+SystemProcessInterface::SystemProcesses::SystemProcesses() {\n@@ -685,35 +406,2 @@\n-\/\/ get command line from \/proc\/<pid>\/cmdline\n-char* SystemProcessInterface::SystemProcesses::ProcessIterator::get_cmdline() {\n-  FILE* fp;\n-  char  buffer[PATH_MAX];\n-  char* cmdline = NULL;\n-\n-  jio_snprintf(buffer, PATH_MAX, \"\/proc\/%s\/cmdline\", _entry->d_name);\n-  buffer[PATH_MAX - 1] = '\\0';\n-  if ((fp = fopen(buffer, \"r\")) != NULL) {\n-    size_t size = 0;\n-    char   dummy;\n-\n-    \/\/ find out how long the file is (stat always returns 0)\n-    while (fread(&dummy, 1, 1, fp) == 1) {\n-      size++;\n-    }\n-    if (size > 0) {\n-      cmdline = NEW_C_HEAP_ARRAY(char, size + 1, mtInternal);\n-      cmdline[0] = '\\0';\n-      if (fseek(fp, 0, SEEK_SET) == 0) {\n-        if (fread(cmdline, 1, size, fp) == size) {\n-          \/\/ the file has the arguments separated by '\\0',\n-          \/\/ so we translate '\\0' to ' '\n-          for (size_t i = 0; i < size; i++) {\n-            if (cmdline[i] == '\\0') {\n-              cmdline[i] = ' ';\n-            }\n-          }\n-          cmdline[size] = '\\0';\n-        }\n-      }\n-    }\n-    fclose(fp);\n-  }\n-  return cmdline;\n+bool SystemProcessInterface::SystemProcesses::initialize() {\n+  return true;\n@@ -722,7 +410,1 @@\n-\/\/ get full path to exe from \/proc\/<pid>\/exe symlink\n-char* SystemProcessInterface::SystemProcesses::ProcessIterator::get_exe_path() {\n-  char buffer[PATH_MAX];\n-\n-  jio_snprintf(buffer, PATH_MAX, \"\/proc\/%s\/exe\", _entry->d_name);\n-  buffer[PATH_MAX - 1] = '\\0';\n-  return realpath(buffer, _exePath);\n+SystemProcessInterface::SystemProcesses::~SystemProcesses() {\n@@ -731,1 +413,1 @@\n-char* SystemProcessInterface::SystemProcesses::ProcessIterator::allocate_string(const char* str) const {\n+char* SystemProcessInterface::SystemProcesses::allocate_string(const char* str) const {\n@@ -738,6 +420,5 @@\n-int SystemProcessInterface::SystemProcesses::ProcessIterator::current(SystemProcess* process_info) {\n-  if (!is_valid()) {\n-    return OS_ERR;\n-  }\n-\n-  process_info->set_pid(atoi(_entry->d_name));\n+int SystemProcessInterface::SystemProcesses::system_processes(SystemProcess** system_processes, int* nprocs) const {\n+  perfstat_process_t* proc_stats;\n+  SystemProcess* head;\n+  perfstat_id_t name_holder;\n+  int records_requested;\n@@ -745,13 +426,2 @@\n-  get_exe_name();\n-  process_info->set_name(allocate_string(_exeName));\n-\n-  if (get_exe_path() != NULL) {\n-     process_info->set_path(allocate_string(_exePath));\n-  }\n-\n-  char* cmdline = NULL;\n-  cmdline = get_cmdline();\n-  if (cmdline != NULL) {\n-    process_info->set_command_line(allocate_string(cmdline));\n-    FREE_C_HEAP_ARRAY(char, cmdline);\n-  }\n+  assert(system_processes != NULL, \"system_processes pointer is NULL!\");\n+  assert(nprocs != NULL, \"system_processes counter pointers is NULL!\");\n@@ -759,2 +429,3 @@\n-  return OS_OK;\n-}\n+  head = NULL;\n+  *nprocs = 0;\n+  strncpy(name_holder.name, \"\", IDENTIFIER_LENGTH);\n@@ -762,2 +433,4 @@\n-int SystemProcessInterface::SystemProcesses::ProcessIterator::next_process() {\n-  if (!is_valid()) {\n+  \/\/ calling perfstat_<subsystem>(NULL, NULL, _, 0) returns number of available records\n+  *nprocs = perfstat_process(NULL, NULL, sizeof(perfstat_process_t), 0);\n+  if(*nprocs < 1) {\n+    \/\/ expect at least 1 process\n@@ -767,8 +440,2 @@\n-  do {\n-    _entry = os::readdir(_dir);\n-    if (_entry == NULL) {\n-      \/\/ Error or reached end.  Could use errno to distinguish those cases.\n-      _valid = false;\n-      return OS_ERR;\n-    }\n-  } while(!is_valid_entry(_entry));\n+  records_requested = *nprocs;\n+  proc_stats = (perfstat_process_t*) NEW_RESOURCE_ARRAY(perfstat_process_t, records_requested);\n@@ -776,3 +443,3 @@\n-  _valid = true;\n-  return OS_OK;\n-}\n+  \/\/ populate stats && set the actual number of procs that have been populated\n+  \/\/ should never be higher than requested, but may be lower due to process death\n+  *nprocs = perfstat_process(&name_holder, proc_stats, sizeof(perfstat_process_t), records_requested);\n@@ -780,5 +447,4 @@\n-SystemProcessInterface::SystemProcesses::ProcessIterator::ProcessIterator() {\n-  _dir = NULL;\n-  _entry = NULL;\n-  _valid = false;\n-}\n+  for (int n = 0; n < *nprocs; n++) {\n+    char* name     = NEW_C_HEAP_ARRAY(char, IDENTIFIER_LENGTH, mtInternal);\n+    char* path     = NEW_C_HEAP_ARRAY(char, IDENTIFIER_LENGTH, mtInternal);\n+    char* cmd_line = NEW_C_HEAP_ARRAY(char, IDENTIFIER_LENGTH, mtInternal);\n@@ -786,4 +452,4 @@\n-bool SystemProcessInterface::SystemProcesses::ProcessIterator::initialize() {\n-  \/\/ Not yet implemented.\n-  return false;\n-}\n+    strncpy(name, proc_stats[n].proc_name, IDENTIFIER_LENGTH);\n+    \/\/ TODO: Read \/proc\/<pid>\/psinfo for additional data to populate the fields below\n+    strncpy(path,     \"\", IDENTIFIER_LENGTH);\n+    strncpy(cmd_line, \"\", IDENTIFIER_LENGTH);\n@@ -791,3 +457,8 @@\n-SystemProcessInterface::SystemProcesses::ProcessIterator::~ProcessIterator() {\n-  if (_dir != NULL) {\n-    os::closedir(_dir);\n+    \/\/ create a new SystemProcess with next pointing to current head.\n+    SystemProcess* sp = new SystemProcess(proc_stats[n].pid,\n+                                          name,\n+                                          path,\n+                                          cmd_line,\n+                                          head);\n+    \/\/ update head.\n+    head = sp;\n@@ -795,1 +466,0 @@\n-}\n@@ -797,8 +467,1 @@\n-SystemProcessInterface::SystemProcesses::SystemProcesses() {\n-  _iterator = NULL;\n-}\n-\n-bool SystemProcessInterface::SystemProcesses::initialize() {\n-  _iterator = new SystemProcessInterface::SystemProcesses::ProcessIterator();\n-  return _iterator->initialize();\n-}\n+  FREE_RESOURCE_ARRAY(perfstat_process_t, proc_stats, records_requested);\n@@ -806,31 +469,1 @@\n-SystemProcessInterface::SystemProcesses::~SystemProcesses() {\n-  if (_iterator != NULL) {\n-    delete _iterator;\n-  }\n-}\n-\n-int SystemProcessInterface::SystemProcesses::system_processes(SystemProcess** system_processes, int* no_of_sys_processes) const {\n-  assert(system_processes != NULL, \"system_processes pointer is NULL!\");\n-  assert(no_of_sys_processes != NULL, \"system_processes counter pointers is NULL!\");\n-  assert(_iterator != NULL, \"iterator is NULL!\");\n-\n-  \/\/ initialize pointers\n-  *no_of_sys_processes = 0;\n-  *system_processes = NULL;\n-\n-  while (_iterator->is_valid()) {\n-    SystemProcess* tmp = new SystemProcess();\n-    _iterator->current(tmp);\n-\n-    \/\/if already existing head\n-    if (*system_processes != NULL) {\n-      \/\/move \"first to second\"\n-      tmp->set_next(*system_processes);\n-    }\n-    \/\/ new head\n-    *system_processes = tmp;\n-    \/\/ increment\n-    (*no_of_sys_processes)++;\n-    \/\/ step forward\n-    _iterator->next_process();\n-  }\n+  *system_processes = head;\n@@ -900,1 +533,2 @@\n-  friend class NetworkPerformanceInterface;\n+  NONCOPYABLE(NetworkPerformance);\n+\n@@ -902,0 +536,3 @@\n+  char* allocate_string(const char* str) const;\n+\n+  public:\n@@ -903,1 +540,0 @@\n-  NONCOPYABLE(NetworkPerformance);\n@@ -909,1 +545,1 @@\n-NetworkPerformanceInterface::NetworkPerformance::NetworkPerformance() {\n+NetworkPerformanceInterface::NetworkPerformance::NetworkPerformance() {}\n@@ -911,1 +547,1 @@\n-}\n+bool NetworkPerformanceInterface::NetworkPerformance::initialize() { return true; }\n@@ -913,6 +549,1 @@\n-bool NetworkPerformanceInterface::NetworkPerformance::initialize() {\n-  return true;\n-}\n-\n-NetworkPerformanceInterface::NetworkPerformance::~NetworkPerformance() {\n-}\n+NetworkPerformanceInterface::NetworkPerformance::~NetworkPerformance() {}\n@@ -922,1 +553,34 @@\n-  return FUNCTIONALITY_NOT_IMPLEMENTED;\n+  int n_records = 0;\n+  perfstat_netinterface_t* net_stats;\n+  perfstat_id_t name_holder;\n+\n+  assert(network_interfaces != NULL, \"network_interfaces is NULL\");\n+\n+  *network_interfaces = NULL;\n+  strncpy(name_holder.name , FIRST_NETINTERFACE, IDENTIFIER_LENGTH);\n+\n+  \/\/ calling perfstat_<subsystem>(NULL, NULL, _, 0) returns number of available records\n+  n_records = perfstat_netinterface(NULL, NULL, sizeof(perfstat_netinterface_t), 0);\n+  if (n_records < 0) {\n+    return OS_ERR;\n+  }\n+\n+  net_stats = NEW_RESOURCE_ARRAY(perfstat_netinterface_t, n_records);\n+\n+  \/\/ populate net_stats && check that the expected number of records have been populated\n+  if (n_records > (perfstat_netinterface(&name_holder, net_stats, sizeof(perfstat_netinterface_t), n_records))) {\n+    FREE_RESOURCE_ARRAY(perfstat_netinterface_t, net_stats, n_records);\n+    return OS_ERR;\n+  }\n+\n+  for (int i = 0; i < n_records; i++) {\n+    \/\/ Create new Network interface *with current head as next node*\n+    NetworkInterface* new_interface = new NetworkInterface(net_stats[i].name,\n+                                                           net_stats[i].ibytes,\n+                                                           net_stats[i].obytes,\n+                                                           *network_interfaces);\n+    *network_interfaces = new_interface;\n+  }\n+\n+  FREE_RESOURCE_ARRAY(perfstat_netinterface_t, net_stats, n_records);\n+  return OS_OK;\n","filename":"src\/hotspot\/os\/aix\/os_perf_aix.cpp","additions":313,"deletions":649,"binary":false,"changes":962,"status":"modified"},{"patch":"@@ -822,1 +822,1 @@\n-jdk\/jfr\/event\/runtime\/TestNetworkUtilizationEvent.java          8228990 generic-all\n+jdk\/jfr\/event\/runtime\/TestNetworkUtilizationEvent.java          8228990 macoss-all,linux-all,windows-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,0 +80,2 @@\n+        } else if (Platform.isAix()) {\n+            libTemplate = \"lib%s.so\";\n@@ -81,0 +83,1 @@\n+\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestNativeLibrariesEvent.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}