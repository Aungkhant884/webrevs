{"files":[{"patch":"@@ -37,0 +37,2 @@\n+  \/\/ Assume spill slot for link register contains a suitable pc.\n+  \/\/ Should have been filled by method entry code.\n@@ -44,4 +46,59 @@\n-  ucontext_t* uc = (ucontext_t*) ucontext;\n-  *fr_addr = frame((intptr_t*)uc->uc_mcontext.jmp_context.gpr[1\/*REG_SP*\/],\n-                   (address)uc->uc_mcontext.jmp_context.iar);\n-  return true;\n+\n+  \/\/ If we have a last_Java_frame, then we should use it even if\n+  \/\/ isInJava == true.  It should be more reliable than ucontext info.\n+  if (has_last_Java_frame() && frame_anchor()->walkable()) {\n+    *fr_addr = pd_last_frame();\n+    return true;\n+  }\n+\n+  \/\/ At this point, we don't have a last_Java_frame, so\n+  \/\/ we try to glean some information out of the ucontext\n+  \/\/ if we were running Java code when SIGPROF came in.\n+  if (isInJava) {\n+    ucontext_t* uc = (ucontext_t*) ucontext;\n+    frame ret_frame((intptr_t*)uc->uc_mcontext.regs->gpr[1\/*REG_SP*\/],\n+                     (address)uc->uc_mcontext.regs->nip);\n+\n+    if (ret_frame.pc() == NULL) {\n+      \/\/ ucontext wasn't useful\n+      return false;\n+    }\n+\n+    if (ret_frame.fp() == NULL) {\n+      \/\/ The found frame does not have a valid frame pointer.\n+      \/\/ Bail out because this will create big trouble later on, either\n+      \/\/  - when using istate, calculated as (NULL - ijava_state_size) or\n+      \/\/  - when using fp() directly in safe_for_sender()\n+      \/\/\n+      \/\/ There is no conclusive description (yet) how this could happen, but it does.\n+      \/\/ For more details on what was observed, see thread_linux_s390.cpp\n+      return false;\n+    }\n+\n+    if (ret_frame.is_interpreted_frame()) {\n+      frame::ijava_state *istate = ret_frame.get_ijava_state();\n+      const Method *m = (const Method*)(istate->method);\n+      if (!Method::is_valid_method(m)) return false;\n+      if (!Metaspace::contains(m->constMethod())) return false;\n+\n+      uint64_t reg_bcp = uc->uc_mcontext.regs->gpr[14\/*R14_bcp*\/];\n+      uint64_t istate_bcp = istate->bcp;\n+      uint64_t code_start = (uint64_t)(m->code_base());\n+      uint64_t code_end = (uint64_t)(m->code_base() + m->code_size());\n+      if (istate_bcp >= code_start && istate_bcp < code_end) {\n+        \/\/ we have a valid bcp, don't touch it, do nothing\n+      } else if (reg_bcp >= code_start && reg_bcp < code_end) {\n+        istate->bcp = reg_bcp;\n+      } else {\n+        return false;\n+      }\n+    }\n+    if (!ret_frame.safe_for_sender(this)) {\n+      \/\/ nothing else to try if the frame isn't good\n+      return false;\n+    }\n+    *fr_addr = ret_frame;\n+    return true;\n+  }\n+  \/\/ nothing else to try\n+  return false;\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/thread_aix_ppc.cpp","additions":61,"deletions":4,"binary":false,"changes":65,"status":"modified"}]}