{"files":[{"patch":"@@ -58,9 +58,3 @@\n-  pid64_t pid;\n-  char    name[PRFNSZ];\n-  char    command_line[PRARGSZ];\n-} psinfo_subset_t;\n-\n-typedef enum {\n-  CPU_LOAD_VM_ONLY,\n-  CPU_LOAD_GLOBAL,\n-} CpuLoadTarget;\n+  double utime;\n+  double stime;\n+} JVMTime;\n@@ -81,3 +75,3 @@\n-  assert(pticks != NULL, \"NULL pointer passed\");\n-  assert(_lcpu_names != NULL, \"CPUPerformance un-initialized\");\n-  assert(lcpu_idx < _ncpus, \"Invalid CPU index\");\n+  if (!pticks) {\n+    return OS_ERR;\n+  }\n@@ -86,1 +80,5 @@\n-  if (1 == perfstat_cpu(lcpu_name, &lcpu_stats, sizeof(perfstat_cpu_t), 1)) {\n+  if (perfstat_cpu(lcpu_name, &lcpu_stats, sizeof(perfstat_cpu_t), 1) < 1) {\n+    pticks->user = 0;\n+    pticks->sys  = 0;\n+    pticks->idle = 0;\n+    pticks->wait = 0;\n@@ -98,12 +96,0 @@\n-\/**\n- * Set and return a value in [0.0, 1.0] by capping any value above the range to 1.0,\n- * and any value below the range to 0.0. Any value already in (0.0, 1.0) remains unchanged.\n- *\n- * For convenienve, this procedure both sets the pointer to the (possibly) new value, and returns a copy.\n- *\/\n-static double normalize(double* val) {\n-  *val = MIN2<double>(*val, 1.0);\n-  *val = MAX2<double>(*val, 0.0);\n-  return *val;\n-}\n-\n@@ -113,3 +99,3 @@\n-static OSReturn get_jvm_load(double* jvm_user_load, double* jvm_kernel_load, double* jvm_total_load) {\n-  perfstat_process_t jvm_stats;\n-  perfstat_rawdata_t perfstat_lookup_data;\n+static OSReturn get_jvm_load(double* jvm_uload, double* jvm_sload) {\n+  static clock_t ticks_per_sec = sysconf(_SC_CLK_TCK);\n+  static u_longlong_t last_timebase = 0;\n@@ -117,7 +103,3 @@\n-  perfstat_lookup_data.type = UTIL_PROCESS;\n-  snprintf(perfstat_lookup_data.name.name, IDENTIFIER_LENGTH, \"%d\", getpid());\n-  perfstat_lookup_data.curstat = NULL;\n-  perfstat_lookup_data.prevstat = NULL;\n-  perfstat_lookup_data.sizeof_data = sizeof(perfstat_process_t);\n-  perfstat_lookup_data.cur_elems = 0;\n-  perfstat_lookup_data.prev_elems = 0;\n+  perfstat_process_t jvm_stats;\n+  perfstat_id_t name_holder;\n+  u_longlong_t timebase_diff;\n@@ -125,1 +107,2 @@\n-  if (0 < perfstat_process_util(&perfstat_lookup_data, &jvm_stats, sizeof(perfstat_process_t), 1)) {\n+  snprintf(name_holder.name, IDENTIFIER_LENGTH, \"%d\", getpid());\n+  if (perfstat_process(&name_holder, &jvm_stats, sizeof(perfstat_process_t), 1) < 1) {\n@@ -129,7 +112,6 @@\n-  \/\/ when called via perfstat_process_util, ucpu_time and scpu_time fields are\n-  \/\/ populated with percentages rather than time.\n-  if (jvm_user_load) {\n-    *jvm_user_load = jvm_stats.ucpu_time;\n-  }\n-  if (jvm_kernel_load) {\n-    *jvm_kernel_load = jvm_stats.scpu_time;\n+  \/\/ Update timebase\n+  timebase_diff = jvm_stats.last_timebase - last_timebase;\n+  last_timebase = jvm_stats.last_timebase;\n+\n+  if (jvm_uload) {\n+    *jvm_uload = jvm_stats.ucpu_time \/ timebase_diff;\n@@ -137,2 +119,2 @@\n-  if (jvm_total_load) {\n-    *jvm_total_load = jvm_stats.ucpu_time + jvm_stats.scpu_time;\n+  if (jvm_sload) {\n+    *jvm_sload = jvm_stats.scpu_time \/ timebase_diff;\n@@ -144,1 +126,8 @@\n-static void update_last_ticks(CPUPerfTicks* from, CPUPerfTicks* to) {\n+static void update_prev_time(JVMTime* from, JVMTime* to) {\n+  if (from && to) {\n+    to->utime = from->utime;\n+    to->stime = from->stime;\n+  }\n+}\n+\n+static void update_prev_ticks(CPUPerfTicks* from, CPUPerfTicks* to) {\n@@ -173,1 +162,0 @@\n-  int n_records;\n@@ -178,1 +166,1 @@\n-  strncpy(name_holder.name, FIRST_CPU, IDENTIFIER_LENGTH);\n+  assert(lcpu_names, \"Names pointer NULL\");\n@@ -180,2 +168,1 @@\n-  \/\/ calling perfstat_<subsystem>(NULL, NULL, _, 0) returns number of available records\n-  assert(0 > (n_records = perfstat_cpu(NULL, NULL, sizeof(perfstat_cpu_t), 0)));\n+  strncpy(name_holder.name, FIRST_CPU, IDENTIFIER_LENGTH);\n@@ -183,1 +170,1 @@\n-  all_lcpu_stats = (perfstat_cpu_t*) NEW_RESOURCE_ARRAY(perfstat_cpu_t, n_records);\n+  all_lcpu_stats = (perfstat_cpu_t*) NEW_RESOURCE_ARRAY(perfstat_cpu_t, ncpus);\n@@ -186,1 +173,5 @@\n-  assert(ncpus == perfstat_cpu(&name_holder, all_lcpu_stats, sizeof(perfstat_cpu_t), n_records));\n+  if (ncpus > perfstat_cpu(&name_holder, all_lcpu_stats, sizeof(perfstat_cpu_t), ncpus)) {\n+    FREE_RESOURCE_ARRAY(perfstat_cpu_t, all_lcpu_stats, ncpus);\n+    lcpu_names = NULL;\n+    return;\n+  }\n@@ -188,2 +179,2 @@\n-  for (int record=0; record < n_records; record++) {\n-    strncpy(lcpu_names[record].name, all_lcpu_stats[record].name, IDENTIFIER_LENGTH);\n+  for (int n=0; n < ncpus; n++) {\n+    strncpy(lcpu_names[n].name, all_lcpu_stats[n].name, IDENTIFIER_LENGTH);\n@@ -192,1 +183,1 @@\n-  FREE_RESOURCE_ARRAY(perfstat_cpu_t, all_lcpu_stats, n_records);\n+  FREE_RESOURCE_ARRAY(perfstat_cpu_t, all_lcpu_stats, ncpus);\n@@ -203,3 +194,1 @@\n-  perfstat_cpu_total_t* cpu_stats;\n-\n-  assert(rate != NULL, \"NULL pointer passed\");\n+  perfstat_cpu_total_t cpu_stats;\n@@ -207,3 +196,1 @@\n-  cpu_stats = (perfstat_cpu_total_t*) NEW_RESOURCE_ARRAY(perfstat_cpu_total_t, 1);\n-\n-   if (0 < perfstat_cpu_total(NULL, cpu_stats, sizeof(perfstat_cpu_total_t), 1)) {\n+   if (perfstat_cpu_total(NULL, &cpu_stats, sizeof(perfstat_cpu_total_t), 1) < 0) {\n@@ -213,4 +200,2 @@\n-   ticks = cpu_stats->user + cpu_stats->sys + cpu_stats->idle + cpu_stats->wait;\n-   *rate = (cpu_stats->pswitch \/ ticks) * ticks_per_sec;\n-\n-   FREE_RESOURCE_ARRAY(perfstat_cpu_total_t, cpu_stats, 1);\n+   ticks = cpu_stats.user + cpu_stats.sys + cpu_stats.idle + cpu_stats.wait;\n+   *rate = (cpu_stats.pswitch \/ ticks) * ticks_per_sec;\n@@ -225,1 +210,1 @@\n-  CPUPerfTicks _last_total_ticks;\n+  CPUPerfTicks* _prev_ticks;\n@@ -238,10 +223,4 @@\n-CPUPerformanceInterface::CPUPerformance::CPUPerformance() {\n-  \/* Set default values only *\/\n-  _ncpus = 0;\n-  _lcpu_names = NULL;\n-\n-  _last_total_ticks.user = 0;\n-  _last_total_ticks.sys  = 0;\n-  _last_total_ticks.idle = 0;\n-  _last_total_ticks.wait = 0;\n-}\n+CPUPerformanceInterface::CPUPerformance::CPUPerformance():\n+  _ncpus(0),\n+  _lcpu_names(NULL),\n+  _prev_ticks(NULL) {}\n@@ -250,1 +229,1 @@\n-  perfstat_cpu_total_t* cpu_stats;\n+  perfstat_cpu_total_t cpu_stats;\n@@ -252,4 +231,1 @@\n-  cpu_stats = (perfstat_cpu_total_t*) NEW_RESOURCE_ARRAY(perfstat_cpu_total_t, 1);\n-\n-   if (perfstat_cpu_total(NULL, cpu_stats, sizeof(perfstat_cpu_total_t), 1) < 0) {\n-     FREE_RESOURCE_ARRAY(perfstat_cpu_total_t, cpu_stats, 1);\n+   if (perfstat_cpu_total(NULL, &cpu_stats, sizeof(perfstat_cpu_total_t), 1) < 0) {\n@@ -259,2 +235,3 @@\n-  _ncpus = cpu_stats->ncpus;\n-  _lcpu_names = NEW_C_HEAP_ARRAY(perfstat_id_t, cpu_stats->ncpus, mtInternal);\n+  _ncpus = cpu_stats.ncpus;\n+\n+  _lcpu_names = NEW_C_HEAP_ARRAY(perfstat_id_t, _ncpus, mtInternal);\n@@ -263,2 +240,11 @@\n-  FREE_RESOURCE_ARRAY(perfstat_cpu_total_t, cpu_stats, 1);\n-  return true;\n+  _prev_ticks = NEW_C_HEAP_ARRAY(CPUPerfTicks,  _ncpus, mtInternal);\n+  \/\/ Set all prev-tick values to 0\n+  \/\/ memset(_prev_ticks, 0, _ncpus*sizeof(CPUPerfTicks));\n+  for (int n = 0; n < _ncpus; n++) {\n+    _prev_ticks[n].user = 0;\n+    _prev_ticks[n].sys  = 0;\n+    _prev_ticks[n].idle = 0;\n+    _prev_ticks[n].wait = 0;\n+  }\n+\n+  return _lcpu_names != NULL;\n@@ -276,2 +262,2 @@\n-int CPUPerformanceInterface::CPUPerformance::cpu_load(int which_logical_cpu, double* lcpu_load) {\n-  CPUPerfTicks lcpu_stats;\n+int CPUPerformanceInterface::CPUPerformance::cpu_load(int lcpu_number, double* lcpu_load) {\n+  CPUPerfTicks ticks;\n@@ -280,0 +266,1 @@\n+  assert(lcpu_number < _ncpus, \"Invalid lcpu passed to cpu_load\");\n@@ -281,2 +268,2 @@\n-  if (get_lcpu_ticks(&_lcpu_names[which_logical_cpu], &lcpu_stats) == OS_ERR) {\n-    *lcpu_load = 0.0;\n+  if (get_lcpu_ticks(&_lcpu_names[lcpu_number], &ticks) == OS_ERR) {\n+    *lcpu_load = -1.0;\n@@ -286,2 +273,2 @@\n-  calculate_updated_load(&lcpu_stats, &_last_total_ticks, lcpu_load);\n-  update_last_ticks(&lcpu_stats, &_last_total_ticks);\n+  calculate_updated_load(&ticks, &_prev_ticks[lcpu_number], lcpu_load);\n+  update_prev_ticks(&ticks, &_prev_ticks[lcpu_number]);\n@@ -296,1 +283,2 @@\n-  double load_avg = 0.0;\n+  CPUPerfTicks total_ticks;\n+  CPUPerfTicks prev_total_ticks;\n@@ -300,4 +288,17 @@\n-  for (int cpu=0; cpu < _ncpus; cpu++) {\n-    double l;\n-    if (cpu_load(cpu, &l) != OS_ERR) {\n-      load_avg += l;\n+  total_ticks.user = 0;\n+  total_ticks.sys  = 0;\n+  total_ticks.idle = 0;\n+  total_ticks.wait = 0;\n+\n+  prev_total_ticks.user = 0;\n+  prev_total_ticks.sys  = 0;\n+  prev_total_ticks.idle = 0;\n+  prev_total_ticks.wait = 0;\n+\n+  for (int lcpu = 0; lcpu < _ncpus; lcpu++) {\n+    CPUPerfTicks lcpu_ticks;\n+\n+    if (get_lcpu_ticks(&_lcpu_names[lcpu], &lcpu_ticks) == OS_ERR) {\n+      *total_load = -1.0;\n+      printf(\"Error: Could not calculate load for lcpu %s\\n\", _lcpu_names[lcpu].name);\n+      return OS_ERR;\n@@ -305,0 +306,12 @@\n+\n+    total_ticks.user = lcpu_ticks.user;\n+    total_ticks.sys  = lcpu_ticks.sys;\n+    total_ticks.idle = lcpu_ticks.idle;\n+    total_ticks.wait = lcpu_ticks.wait;\n+\n+    prev_total_ticks.user += _prev_ticks[lcpu].user;\n+    prev_total_ticks.sys  += _prev_ticks[lcpu].sys;\n+    prev_total_ticks.idle += _prev_ticks[lcpu].idle;\n+    prev_total_ticks.wait += _prev_ticks[lcpu].wait;\n+\n+    update_prev_ticks(&lcpu_ticks, &_prev_ticks[lcpu]);\n@@ -306,1 +319,0 @@\n-  load_avg = load_avg\/_ncpus;\n@@ -308,1 +320,1 @@\n-  *total_load = load_avg;\n+  calculate_updated_load(&total_ticks, &prev_total_ticks, total_load);\n@@ -321,0 +333,2 @@\n+ * Note: If any of the above loads cannot be calculated, this procedure returns OS_ERR and any load that could not be calculated is set to -1\n+ *\n@@ -325,11 +339,3 @@\n-  assert(pjvmUserLoad     != NULL, \"pjvmUserLoad not inited\");\n-  assert(pjvmKernelLoad   != NULL, \"pjvmKernelLoad not inited\");\n-  assert(psystemTotalLoad != NULL, \"psystemTotalLoad not inited\");\n-\n-  if (get_jvm_load(&u, &k, NULL) == OS_ERR ||\n-      cpu_load_total_process(&t) == OS_ERR)\n-  {\n-    *pjvmUserLoad     = 0.0;\n-    *pjvmKernelLoad   = 0.0;\n-    *psystemTotalLoad = 0.0;\n-    return OS_ERR;\n+  int retval = OS_OK;\n+  if (get_jvm_load(&u, &k) == OS_ERR || cpu_load_total_process(&t) == OS_ERR) {\n+    retval = OS_ERR;\n@@ -338,3 +344,9 @@\n-  *pjvmUserLoad     = normalize(&u);\n-  *pjvmKernelLoad   = normalize(&k);\n-  *psystemTotalLoad = normalize(&t);\n+  if (pjvmUserLoad) {\n+    *pjvmUserLoad = u;\n+  }\n+  if (pjvmKernelLoad) {\n+    *pjvmKernelLoad = k;\n+  }\n+  if (psystemTotalLoad) {\n+    *psystemTotalLoad = t;\n+  }\n@@ -342,1 +354,1 @@\n-  return OS_OK;\n+  return retval;\n@@ -409,1 +421,0 @@\n-  perfstat_process_t* all_proc_stats;\n@@ -411,1 +422,3 @@\n-  perfstat_id_t       name_holder;\n+  SystemProcess* head;\n+  perfstat_id_t name_holder;\n+  int records_requested;\n@@ -416,1 +429,1 @@\n-  \/\/ initialize pointers\n+  head = NULL;\n@@ -418,3 +431,1 @@\n-  *system_processes = NULL;\n-\n-  strcpy(name_holder.name, \"\");\n+  strncpy(name_holder.name, \"\", IDENTIFIER_LENGTH);\n@@ -423,1 +434,2 @@\n-  if((*nprocs = perfstat_process(NULL, NULL, sizeof(perfstat_process_t), 0)) < 1) {\n+  *nprocs = perfstat_process(NULL, NULL, sizeof(perfstat_process_t), 0);\n+  if(*nprocs < 1) {\n@@ -428,14 +440,23 @@\n-  all_proc_stats = (perfstat_process_t*) NEW_RESOURCE_ARRAY(perfstat_process_t, *nprocs);\n-\n-  \/\/ populate stats && (re)set the number of procs that have been populated\n-  *nprocs = perfstat_process(&name_holder, all_proc_stats, sizeof(perfstat_process_t), *nprocs);\n-\n-  for (int record=0; record < *nprocs; record++) {\n-    proc_stats = &(all_proc_stats[record]);\n-\n-    \/\/ create new SystemProcess. With next pointing to current head.\n-    SystemProcess* sp = new SystemProcess(proc_stats->pid,\n-                                          allocate_string(proc_stats->proc_name),\n-                                          NULL,\n-                                          NULL,\n-                                          *system_processes);\n+  records_requested = *nprocs;\n+  proc_stats = (perfstat_process_t*) NEW_RESOURCE_ARRAY(perfstat_process_t, records_requested);\n+\n+  \/\/ populate stats && set the actual number of procs that have been populated\n+  \/\/ should never be higher than requested, but may be lower due to process death\n+  *nprocs = perfstat_process(&name_holder, proc_stats, sizeof(perfstat_process_t), records_requested);\n+\n+  for (int n = 0; n < *nprocs; n++) {\n+    char* name     = NEW_C_HEAP_ARRAY(char, IDENTIFIER_LENGTH, mtInternal);\n+    char* path     = NEW_C_HEAP_ARRAY(char, IDENTIFIER_LENGTH, mtInternal);\n+    char* cmd_line = NEW_C_HEAP_ARRAY(char, IDENTIFIER_LENGTH, mtInternal);\n+\n+    strncpy(name, proc_stats[n].proc_name, IDENTIFIER_LENGTH);\n+    \/\/ TODO: Read \/proc\/<pid>\/psinfo for additional data to populate the fields below\n+    strncpy(path,     \"\", IDENTIFIER_LENGTH);\n+    strncpy(cmd_line, \"\", IDENTIFIER_LENGTH);\n+\n+    \/\/ create a new SystemProcess with next pointing to current head.\n+    SystemProcess* sp = new SystemProcess(proc_stats[n].pid,\n+                                          name,\n+                                          path,\n+                                          cmd_line,\n+                                          head);\n@@ -443,1 +464,1 @@\n-    *system_processes = sp;\n+    head = sp;\n@@ -446,1 +467,3 @@\n-  FREE_RESOURCE_ARRAY(perfstat_process_t, all_proc_stats, 1);\n+  FREE_RESOURCE_ARRAY(perfstat_process_t, proc_stats, records_requested);\n+\n+  *system_processes = head;\n@@ -528,7 +551,0 @@\n-char* NetworkPerformanceInterface::NetworkPerformance::allocate_string(const char* str) const {\n-  if (str != NULL) {\n-    return os::strdup_check_oom(str, mtInternal);\n-  }\n-  return NULL;\n-}\n-\n@@ -537,2 +553,0 @@\n-  assert(network_interfaces != NULL, \"network_interfaces is NULL\");\n-\n@@ -540,1 +554,0 @@\n-  NetworkInterface* head = *network_interfaces;\n@@ -542,1 +555,0 @@\n-  perfstat_netinterface_t* all_net_stats;\n@@ -545,1 +557,3 @@\n-  head = NULL;\n+  assert(network_interfaces != NULL, \"network_interfaces is NULL\");\n+\n+  *network_interfaces = NULL;\n@@ -548,2 +562,3 @@\n-  \/\/ calling perfstat_<subsyste>(NULL, NULL, ..., 0) returns number of available records\n-  if (0 > (n_records = perfstat_netinterface(NULL, NULL, sizeof(perfstat_netinterface_t), 0))) {\n+  \/\/ calling perfstat_<subsystem>(NULL, NULL, _, 0) returns number of available records\n+  n_records = perfstat_netinterface(NULL, NULL, sizeof(perfstat_netinterface_t), 0);\n+  if (n_records < 0) {\n@@ -553,1 +568,1 @@\n-  all_net_stats = (perfstat_netinterface_t*) NEW_RESOURCE_ARRAY(perfstat_netinterface_t, n_records);\n+  net_stats = NEW_RESOURCE_ARRAY(perfstat_netinterface_t, n_records);\n@@ -556,2 +571,2 @@\n-  if (n_records > (perfstat_netinterface(&name_holder, all_net_stats, sizeof(perfstat_netinterface_t), n_records))) {\n-    FREE_RESOURCE_ARRAY(perfstat_netinterface_t, all_net_stats, 1);\n+  if (n_records > (perfstat_netinterface(&name_holder, net_stats, sizeof(perfstat_netinterface_t), n_records))) {\n+    FREE_RESOURCE_ARRAY(perfstat_netinterface_t, net_stats, n_records);\n@@ -561,3 +576,1 @@\n-  for (int i = n_records - 1; i >= 0; i--) {\n-    net_stats = &all_net_stats[i];\n-\n+  for (int i = 0; i < n_records; i++) {\n@@ -565,5 +578,5 @@\n-    NetworkInterface* net_interface = new NetworkInterface(allocate_string(net_stats->name),\n-                                                           net_stats->ibytes,\n-                                                           net_stats->obytes,\n-                                                           head);\n-    head = net_interface;\n+    NetworkInterface* new_interface = new NetworkInterface(net_stats[i].name,\n+                                                           net_stats[i].ibytes,\n+                                                           net_stats[i].obytes,\n+                                                           *network_interfaces);\n+    *network_interfaces = new_interface;\n@@ -572,1 +585,1 @@\n-  FREE_RESOURCE_ARRAY(perfstat_netinterface_t, all_net_stats, 1);\n+  FREE_RESOURCE_ARRAY(perfstat_netinterface_t, net_stats, n_records);\n","filename":"src\/hotspot\/os\/aix\/os_perf_aix.cpp","additions":175,"deletions":162,"binary":false,"changes":337,"status":"modified"},{"patch":"@@ -1,95 +0,0 @@\n-#include \"precompiled.hpp\"\n-#include \"unittest.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"runtime\/os_perf.hpp\"\n-\n-TEST(NetworkPerformance, NetworkUtiliazation) {\n-    NetworkPerformanceInterface* netperf = new NetworkPerformanceInterface();\n-    NetworkInterface* netperf_stats;\n-\n-    netperf->initialize();\n-    netperf->network_utilization(&netperf_stats);\n-\n-    int n_interfaces = 0;\n-    for(const NetworkInterface* ptr = netperf_stats; ptr; ptr = ptr->next()) {\n-        \/\/ TODO: Test the interface metadata?\n-        n_interfaces++;\n-    }\n-    ASSERT_GT(n_interfaces, 0) << \"expected non-zero number of interfaces\";\n-}\n-\n-TEST(CPUPerformance, CPULoad) {\n-    int lcpu;\n-    double load;\n-    CPUPerformanceInterface* cpu_perf = new CPUPerformanceInterface();\n-\n-    cpu_perf->initialize();\n-    load = 0.0;\n-\n-    for(lcpu=0; cpu_perf->cpu_load(lcpu,&load) == OS_OK; lcpu++) {\n-        ASSERT_GE(load, 0.0);\n-        ASSERT_LE(load, 1.0);\n-    }\n-\n-    ASSERT_GT(lcpu, 0);\n-}\n-\n-TEST(CPUPerformance, ContextSwitchRate) {\n-    double rate;\n-    CPUPerformanceInterface* cpu_perf = new CPUPerformanceInterface();\n-\n-    cpu_perf->initialize();\n-    rate = 0.0;\n-\n-    cpu_perf->context_switch_rate(&rate);\n-\n-    ASSERT_GT(rate, 0.0);\n-}\n-\n-TEST(CPUPerformance, CPULoadTotalProcess) {\n-    double load;\n-    CPUPerformanceInterface* cpu_perf = new CPUPerformanceInterface();\n-\n-    cpu_perf->initialize();\n-    load = 0.0;\n-\n-    cpu_perf->cpu_load_total_process(&load);\n-\n-    ASSERT_GE(load, 0.0);\n-}\n-\n-TEST(CPUPerformance, CPULoadsProcess) {\n-    double jvm_uload, jvm_kload, sys_load;\n-    CPUPerformanceInterface* cpu_perf = new CPUPerformanceInterface();\n-\n-    cpu_perf->initialize();\n-    jvm_uload = 0.0;\n-    jvm_kload = 0.0;\n-    sys_load  = 0.0;\n-\n-    cpu_perf->cpu_loads_process(&jvm_uload, &jvm_kload, &sys_load);\n-\n-    ASSERT_GE(jvm_uload, 0.0);\n-    ASSERT_GE(jvm_kload, 0.0);\n-    ASSERT_GE(sys_load,  0.0);\n-\n-    ASSERT_LE(jvm_uload, 1.0);\n-    ASSERT_LE(jvm_kload, 1.0);\n-    ASSERT_LE(sys_load,  1.0);\n-}\n-\n-TEST(SystemProcessInterface, SystemProcesses) {\n-   SystemProcessInterface* proc_info = new SystemProcessInterface();\n-   SystemProcess* proc;\n-   int n_procs;\n-\n-   n_procs = 0;\n-   proc_info->initialize();\n-   proc_info->system_processes(&proc, &n_procs);\n-   ASSERT_GT(n_procs, 0) << \"expected non-zero number of processes\";\n-\n-   for( ; proc ; proc = proc->next()) {\n-       ASSERT_NE(0, proc->pid());\n-       ASSERT_NE(nullptr, proc->name());\n-   }\n-}\n","filename":"test\/hotspot\/gtest\/runtime\/test_jfr_interfaces.cpp","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -822,1 +822,1 @@\n-jdk\/jfr\/event\/runtime\/TestNetworkUtilizationEvent.java          8228990 generic-all\n+jdk\/jfr\/event\/runtime\/TestNetworkUtilizationEvent.java          8228990 macoss-all,linux-all,windows-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-            libTemplate = \"\";\n+            libTemplate = \"lib%s.so\";\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestNativeLibrariesEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}