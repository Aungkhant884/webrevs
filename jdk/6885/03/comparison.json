{"files":[{"patch":"@@ -415,7 +415,0 @@\n-\n-    if test \"x$TOOLCHAIN_TYPE\" = xxlc; then\n-      # We need '-qminimaltoc' or '-qpic=large -bbigtoc' if the TOC overflows.\n-      # Hotspot now overflows its 64K TOC (currently only for debug),\n-      # so for debug we build with '-qpic=large -bbigtoc'.\n-      DEBUG_CFLAGS_JVM=\"-qpic=large\"\n-    fi\n@@ -436,1 +429,1 @@\n-    ALWAYS_DEFINES_JVM=\"-D_REENTRANT\"\n+    ALWAYS_DEFINES_JVM=\"-D_REENTRANT -qpic=large\"\n","filename":"make\/autoconf\/flags-cflags.m4","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -268,16 +268,0 @@\n-###############################################################################\n-# Check if the feature 'jfr' is available on this platform.\n-#\n-AC_DEFUN_ONCE([JVM_FEATURES_CHECK_JFR],\n-[\n-  JVM_FEATURES_CHECK_AVAILABILITY(jfr, [\n-    AC_MSG_CHECKING([if platform is supported by JFR])\n-    if test \"x$OPENJDK_TARGET_OS\" = xaix; then\n-      AC_MSG_RESULT([no, $OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU])\n-      AVAILABLE=false\n-    else\n-      AC_MSG_RESULT([yes])\n-    fi\n-  ])\n-])\n-\n@@ -403,1 +387,0 @@\n-  JVM_FEATURES_CHECK_JFR\n@@ -409,6 +392,0 @@\n-  # Filter out features by default for all variants on certain platforms.\n-  # Make sure to just add to JVM_FEATURES_PLATFORM_FILTER, since it could\n-  # have a value already from custom extensions.\n-  if test \"x$OPENJDK_TARGET_OS\" = xaix; then\n-    JVM_FEATURES_PLATFORM_FILTER=\"$JVM_FEATURES_PLATFORM_FILTER jfr\"\n-  fi\n","filename":"make\/autoconf\/jvm-features.m4","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -47,166 +47,15 @@\n-\n-\/**\n-   \/proc\/[number]\/stat\n-              Status information about the process.  This is used by ps(1).  It is defined in \/usr\/src\/linux\/fs\/proc\/array.c.\n-\n-              The fields, in order, with their proper scanf(3) format specifiers, are:\n-\n-              1. pid %d The process id.\n-\n-              2. comm %s\n-                     The filename of the executable, in parentheses.  This is visible whether or not the executable is swapped out.\n-\n-              3. state %c\n-                     One  character  from  the  string \"RSDZTW\" where R is running, S is sleeping in an interruptible wait, D is waiting in uninterruptible disk\n-                     sleep, Z is zombie, T is traced or stopped (on a signal), and W is paging.\n-\n-              4. ppid %d\n-                     The PID of the parent.\n-\n-              5. pgrp %d\n-                     The process group ID of the process.\n-\n-              6. session %d\n-                     The session ID of the process.\n-\n-              7. tty_nr %d\n-                     The tty the process uses.\n-\n-              8. tpgid %d\n-                     The process group ID of the process which currently owns the tty that the process is connected to.\n-\n-              9. flags %lu\n-                     The flags of the process.  The math bit is decimal 4, and the traced bit is decimal 10.\n-\n-              10. minflt %lu\n-                     The number of minor faults the process has made which have not required loading a memory page from disk.\n-\n-              11. cminflt %lu\n-                     The number of minor faults that the process's waited-for children have made.\n-\n-              12. majflt %lu\n-                     The number of major faults the process has made which have required loading a memory page from disk.\n-\n-              13. cmajflt %lu\n-                     The number of major faults that the process's waited-for children have made.\n-\n-              14. utime %lu\n-                     The number of jiffies that this process has been scheduled in user mode.\n-\n-              15. stime %lu\n-                     The number of jiffies that this process has been scheduled in kernel mode.\n-\n-              16. cutime %ld\n-                     The number of jiffies that this process's waited-for children have been scheduled in user mode. (See also times(2).)\n-\n-              17. cstime %ld\n-                     The number of jiffies that this process' waited-for children have been scheduled in kernel mode.\n-\n-              18. priority %ld\n-                     The standard nice value, plus fifteen.  The value is never negative in the kernel.\n-\n-              19. nice %ld\n-                     The nice value ranges from 19 (nicest) to -19 (not nice to others).\n-\n-              20. 0 %ld  This value is hard coded to 0 as a placeholder for a removed field.\n-\n-              21. itrealvalue %ld\n-                     The time in jiffies before the next SIGALRM is sent to the process due to an interval timer.\n-\n-              22. starttime %lu\n-                     The time in jiffies the process started after system boot.\n-\n-              23. vsize %lu\n-                     Virtual memory size in bytes.\n-\n-              24. rss %ld\n-                     Resident Set Size: number of pages the process has in real memory, minus 3 for administrative purposes. This is just the pages which  count\n-                     towards text, data, or stack space.  This does not include pages which have not been demand-loaded in, or which are swapped out.\n-\n-              25. rlim %lu\n-                     Current limit in bytes on the rss of the process (usually 4294967295 on i386).\n-\n-              26. startcode %lu\n-                     The address above which program text can run.\n-\n-              27. endcode %lu\n-                     The address below which program text can run.\n-\n-              28. startstack %lu\n-                     The address of the start of the stack.\n-\n-              29. kstkesp %lu\n-                     The current value of esp (stack pointer), as found in the kernel stack page for the process.\n-\n-              30. kstkeip %lu\n-                     The current EIP (instruction pointer).\n-\n-              31. signal %lu\n-                     The bitmap of pending signals (usually 0).\n-\n-              32. blocked %lu\n-                     The bitmap of blocked signals (usually 0, 2 for shells).\n-\n-              33. sigignore %lu\n-                     The bitmap of ignored signals.\n-\n-              34. sigcatch %lu\n-                     The bitmap of catched signals.\n-\n-              35. wchan %lu\n-                     This  is the \"channel\" in which the process is waiting.  It is the address of a system call, and can be looked up in a namelist if you need\n-                     a textual name.  (If you have an up-to-date \/etc\/psdatabase, then try ps -l to see the WCHAN field in action.)\n-\n-              36. nswap %lu\n-                     Number of pages swapped - not maintained.\n-\n-              37. cnswap %lu\n-                     Cumulative nswap for child processes.\n-\n-              38. exit_signal %d\n-                     Signal to be sent to parent when we die.\n-\n-              39. processor %d\n-                     CPU number last executed on.\n-\n-\n-\n- \/\/\/\/\/ SSCANF FORMAT STRING. Copy and use.\n-\n-field:        1  2  3  4  5  6  7  8  9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38 39\n-format:       %d %s %c %d %d %d %d %d %lu %lu %lu %lu %lu %lu %lu %ld %ld %ld %ld %ld %ld %lu %lu %ld %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %d %d\n-\n-\n-*\/\n-\n-\/**\n- * For platforms that have them, when declaring\n- * a printf-style function,\n- *   formatSpec is the parameter number (starting at 1)\n- *       that is the format argument (\"%d pid %s\")\n- *   params is the parameter number where the actual args to\n- *       the format starts. If the args are in a va_list, this\n- *       should be 0.\n- *\/\n-#ifndef PRINTF_ARGS\n-#  define PRINTF_ARGS(formatSpec,  params) ATTRIBUTE_PRINTF(formatSpec, params)\n-#endif\n-\n-#ifndef SCANF_ARGS\n-#  define SCANF_ARGS(formatSpec,   params) ATTRIBUTE_SCANF(formatSpec, params)\n-#endif\n-\n-#ifndef _PRINTFMT_\n-#  define _PRINTFMT_\n-#endif\n-\n-#ifndef _SCANFMT_\n-#  define _SCANFMT_\n-#endif\n-\n-\n-struct CPUPerfTicks {\n-  uint64_t  used;\n-  uint64_t  usedKernel;\n-  uint64_t  total;\n-};\n+#include <libperfstat.h>\n+#include <sys\/procfs.h>\n+\n+typedef struct {\n+  u_longlong_t  user;\n+  u_longlong_t  sys;\n+  u_longlong_t  idle;\n+  u_longlong_t  wait;\n+} CPUPerfTicks;\n+\n+typedef struct {\n+  pid64_t pid;\n+  char    name[PRFNSZ];\n+  char    command_line[PRARGSZ];\n+} psinfo_subset_t;\n@@ -226,10 +75,2 @@\n-struct CPUPerfCounters {\n-  int   nProcs;\n-  CPUPerfTicks jvmTicks;\n-  CPUPerfTicks* cpus;\n-};\n-\n-static double get_cpu_load(int which_logical_cpu, CPUPerfCounters* counters, double* pkernelLoad, CpuLoadTarget target);\n-\n-\/** reads \/proc\/<pid>\/stat data, with some checks and some skips.\n- *  Ensure that 'fmt' does _NOT_ contain the first two \"%d %s\"\n+\/**\n+ * Get and set ticks for the specified lcpu\n@@ -237,4 +78,2 @@\n-static int SCANF_ARGS(2, 0) vread_statdata(const char* procfile, _SCANFMT_ const char* fmt, va_list args) {\n-  FILE*f;\n-  int n;\n-  char buf[2048];\n+static OSReturn get_lcpu_ticks(perfstat_id_t* lcpu_name, CPUPerfTicks* pticks) {\n+  perfstat_cpu_t lcpu_stats;\n@@ -242,3 +81,3 @@\n-  if ((f = fopen(procfile, \"r\")) == NULL) {\n-    return -1;\n-  }\n+  assert(pticks != NULL, \"NULL pointer passed\");\n+  assert(_lcpu_names != NULL, \"CPUPerformance un-initialized\");\n+  assert(lcpu_idx < _ncpus, \"Invalid CPU index\");\n@@ -246,13 +85,3 @@\n-  if ((n = fread(buf, 1, sizeof(buf), f)) != -1) {\n-    char *tmp;\n-\n-    buf[n-1] = '\\0';\n-    \/** skip through pid and exec name. *\/\n-    if ((tmp = strrchr(buf, ')')) != NULL) {\n-      \/\/ skip the ')' and the following space\n-      \/\/ but check that buffer is long enough\n-      tmp += 2;\n-      if (tmp < buf + n) {\n-        n = vsscanf(tmp, fmt, args);\n-      }\n-    }\n+  \/\/ populate cpu_stats\n+  if (1 == perfstat_cpu(lcpu_name, &lcpu_stats, sizeof(perfstat_cpu_t), 1)) {\n+    return OS_ERR;\n@@ -261,1 +90,4 @@\n-  fclose(f);\n+  pticks->user = lcpu_stats.user;\n+  pticks->sys  = lcpu_stats.sys;\n+  pticks->idle = lcpu_stats.idle;\n+  pticks->wait = lcpu_stats.wait;\n@@ -263,1 +95,1 @@\n-  return n;\n+  return OS_OK;\n@@ -266,8 +98,10 @@\n-static int SCANF_ARGS(2, 3) read_statdata(const char* procfile, _SCANFMT_ const char* fmt, ...) {\n-  int   n;\n-  va_list args;\n-\n-  va_start(args, fmt);\n-  n = vread_statdata(procfile, fmt, args);\n-  va_end(args);\n-  return n;\n+\/**\n+ * Set and return a value in [0.0, 1.0] by capping any value above the range to 1.0,\n+ * and any value below the range to 0.0. Any value already in (0.0, 1.0) remains unchanged.\n+ *\n+ * For convenienve, this procedure both sets the pointer to the (possibly) new value, and returns a copy.\n+ *\/\n+static double normalize(double* val) {\n+  *val = MIN2<double>(*val, 1.0);\n+  *val = MAX2<double>(*val, 0.0);\n+  return *val;\n@@ -277,2 +111,1 @@\n- * on Linux we got the ticks related information from \/proc\/stat\n- * this does not work on AIX, libperfstat might be an alternative\n+ * Return CPU load caused by the currently executing process (the jvm).\n@@ -280,3 +113,15 @@\n-static OSReturn get_total_ticks(int which_logical_cpu, CPUPerfTicks* pticks) {\n-  return OS_ERR;\n-}\n+static OSReturn get_jvm_load(double* jvm_user_load, double* jvm_kernel_load, double* jvm_total_load) {\n+  perfstat_process_t jvm_stats;\n+  perfstat_rawdata_t perfstat_lookup_data;\n+\n+  perfstat_lookup_data.type = UTIL_PROCESS;\n+  snprintf(perfstat_lookup_data.name.name, IDENTIFIER_LENGTH, \"%d\", getpid());\n+  perfstat_lookup_data.curstat = NULL;\n+  perfstat_lookup_data.prevstat = NULL;\n+  perfstat_lookup_data.sizeof_data = sizeof(perfstat_process_t);\n+  perfstat_lookup_data.cur_elems = 0;\n+  perfstat_lookup_data.prev_elems = 0;\n+\n+  if (0 < perfstat_process_util(&perfstat_lookup_data, &jvm_stats, sizeof(perfstat_process_t), 1)) {\n+    return OS_ERR;\n+  }\n@@ -284,4 +129,13 @@\n-\/** read user and system ticks from a named procfile, assumed to be in 'stat' format then. *\/\n-static int read_ticks(const char* procfile, uint64_t* userTicks, uint64_t* systemTicks) {\n-  return read_statdata(procfile, \"%*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u \" UINT64_FORMAT \" \" UINT64_FORMAT,\n-    userTicks, systemTicks);\n+  \/\/ when called via perfstat_process_util, ucpu_time and scpu_time fields are\n+  \/\/ populated with percentages rather than time.\n+  if (jvm_user_load) {\n+    *jvm_user_load = jvm_stats.ucpu_time;\n+  }\n+  if (jvm_kernel_load) {\n+    *jvm_kernel_load = jvm_stats.scpu_time;\n+  }\n+  if (jvm_total_load) {\n+    *jvm_total_load = jvm_stats.ucpu_time + jvm_stats.scpu_time;\n+  }\n+\n+  return OS_OK;\n@@ -290,6 +144,7 @@\n-\/**\n- * Return the number of ticks spent in any of the processes belonging\n- * to the JVM on any CPU.\n- *\/\n-static OSReturn get_jvm_ticks(CPUPerfTicks* pticks) {\n-  return OS_ERR;\n+static void update_last_ticks(CPUPerfTicks* from, CPUPerfTicks* to) {\n+  if (from && to) {\n+    to->user = from->user;\n+    to->sys  = from->sys;\n+    to->idle = from->idle;\n+    to->wait = from->wait;\n+  }\n@@ -299,5 +154,1 @@\n- * Return the load of the CPU as a double. 1.0 means the CPU process uses all\n- * available time for user or system processes, 0.0 means the CPU uses all time\n- * being idle.\n- *\n- * Returns a negative value if there is a problem in determining the CPU load.\n+ * Calculate the current system load from current ticks using previous ticks as a starting point.\n@@ -305,15 +156,2 @@\n-static double get_cpu_load(int which_logical_cpu, CPUPerfCounters* counters, double* pkernelLoad, CpuLoadTarget target) {\n-  uint64_t udiff, kdiff, tdiff;\n-  CPUPerfTicks* pticks;\n-  CPUPerfTicks  tmp;\n-  double user_load;\n-\n-  *pkernelLoad = 0.0;\n-\n-  if (target == CPU_LOAD_VM_ONLY) {\n-    pticks = &counters->jvmTicks;\n-  } else if (-1 == which_logical_cpu) {\n-    pticks = &counters->cpus[counters->nProcs];\n-  } else {\n-    pticks = &counters->cpus[which_logical_cpu];\n-  }\n+static void calculate_updated_load(CPUPerfTicks* update, CPUPerfTicks* prev, double* load) {\n+  CPUPerfTicks diff;\n@@ -321,1 +159,5 @@\n-  tmp = *pticks;\n+  if (update && prev && load) {\n+    diff.user = update->user - prev->user;\n+    diff.sys  = update->sys  - prev->sys;\n+    diff.idle = update->idle - prev->idle;\n+    diff.wait = update->wait - prev->wait;\n@@ -323,6 +165,1 @@\n-  if (target == CPU_LOAD_VM_ONLY) {\n-    if (get_jvm_ticks(pticks) != OS_OK) {\n-      return -1.0;\n-    }\n-  } else if (get_total_ticks(which_logical_cpu, pticks) != OS_OK) {\n-    return -1.0;\n+    *load = 1.0 - diff.idle\/(diff.sys + diff.user + diff.idle + diff.wait);\n@@ -330,0 +167,1 @@\n+}\n@@ -331,9 +169,8 @@\n-  \/\/ seems like we sometimes end up with less kernel ticks when\n-  \/\/ reading \/proc\/self\/stat a second time, timing issue between cpus?\n-  if (pticks->usedKernel < tmp.usedKernel) {\n-    kdiff = 0;\n-  } else {\n-    kdiff = pticks->usedKernel - tmp.usedKernel;\n-  }\n-  tdiff = pticks->total - tmp.total;\n-  udiff = pticks->used - tmp.used;\n+\/**\n+ * Look up lcpu names for later re-use.\n+ *\/\n+static void populate_lcpu_names(int ncpus, perfstat_id_t* lcpu_names) {\n+  int n_records;\n+  perfstat_cpu_t* all_lcpu_stats;\n+  perfstat_cpu_t* lcpu_stats;\n+  perfstat_id_t   name_holder;\n@@ -341,9 +178,1 @@\n-  if (tdiff == 0) {\n-    return 0.0;\n-  } else if (tdiff < (udiff + kdiff)) {\n-    tdiff = udiff + kdiff;\n-  }\n-  *pkernelLoad = (kdiff \/ (double)tdiff);\n-  \/\/ BUG9044876, normalize return values to sane values\n-  *pkernelLoad = MAX2<double>(*pkernelLoad, 0.0);\n-  *pkernelLoad = MIN2<double>(*pkernelLoad, 1.0);\n+  strncpy(name_holder.name, FIRST_CPU, IDENTIFIER_LENGTH);\n@@ -351,3 +180,2 @@\n-  user_load = (udiff \/ (double)tdiff);\n-  user_load = MAX2<double>(user_load, 0.0);\n-  user_load = MIN2<double>(user_load, 1.0);\n+  \/\/ calling perfstat_<subsystem>(NULL, NULL, _, 0) returns number of available records\n+  assert(0 > (n_records = perfstat_cpu(NULL, NULL, sizeof(perfstat_cpu_t), 0)));\n@@ -355,2 +183,1 @@\n-  return user_load;\n-}\n+  all_lcpu_stats = (perfstat_cpu_t*) NEW_RESOURCE_ARRAY(perfstat_cpu_t, n_records);\n@@ -358,3 +185,2 @@\n-static int SCANF_ARGS(1, 2) parse_stat(_SCANFMT_ const char* fmt, ...) {\n-  return OS_ERR;\n-}\n+  \/\/ populate cpu_stats && check that the expected number of records have been populated\n+  assert(ncpus == perfstat_cpu(&name_holder, all_lcpu_stats, sizeof(perfstat_cpu_t), n_records));\n@@ -362,3 +188,3 @@\n-static int get_noof_context_switches(uint64_t* switches) {\n-  return parse_stat(\"ctxt \" UINT64_FORMAT \"\\n\", switches);\n-}\n+  for (int record=0; record < n_records; record++) {\n+    strncpy(lcpu_names[record].name, all_lcpu_stats[record].name, IDENTIFIER_LENGTH);\n+  }\n@@ -366,3 +192,1 @@\n-\/** returns boot time in _seconds_ since epoch *\/\n-static int get_boot_time(uint64_t* time) {\n-  return parse_stat(\"btime \" UINT64_FORMAT \"\\n\", time);\n+  FREE_RESOURCE_ARRAY(perfstat_cpu_t, all_lcpu_stats, n_records);\n@@ -371,6 +195,6 @@\n-static int perf_context_switch_rate(double* rate) {\n-  static pthread_mutex_t contextSwitchLock = PTHREAD_MUTEX_INITIALIZER;\n-  static uint64_t      bootTime;\n-  static uint64_t      lastTimeNanos;\n-  static uint64_t      lastSwitches;\n-  static double        lastRate;\n+\/**\n+ * Calculates the context switch rate.\n+ * (Context Switches \/ Tick) * (Tick \/ s) = Context Switches per second\n+ *\/\n+static OSReturn perf_context_switch_rate(double* rate) {\n+  static clock_t ticks_per_sec = sysconf(_SC_CLK_TCK);\n@@ -378,2 +202,2 @@\n-  uint64_t bt = 0;\n-  int res = 0;\n+  u_longlong_t ticks;\n+  perfstat_cpu_total_t* cpu_stats;\n@@ -381,8 +205,1 @@\n-  \/\/ First time through bootTime will be zero.\n-  if (bootTime == 0) {\n-    uint64_t tmp;\n-    if (get_boot_time(&tmp) < 0) {\n-      return OS_ERR;\n-    }\n-    bt = tmp * 1000;\n-  }\n+  assert(rate != NULL, \"NULL pointer passed\");\n@@ -390,1 +207,1 @@\n-  res = OS_OK;\n+  cpu_stats = (perfstat_cpu_total_t*) NEW_RESOURCE_ARRAY(perfstat_cpu_total_t, 1);\n@@ -392,19 +209,3 @@\n-  pthread_mutex_lock(&contextSwitchLock);\n-  {\n-\n-    uint64_t sw;\n-    s8 t, d;\n-\n-    if (bootTime == 0) {\n-      \/\/ First interval is measured from boot time which is\n-      \/\/ seconds since the epoch. Thereafter we measure the\n-      \/\/ elapsed time using javaTimeNanos as it is monotonic-\n-      \/\/ non-decreasing.\n-      lastTimeNanos = os::javaTimeNanos();\n-      t = os::javaTimeMillis();\n-      d = t - bt;\n-      \/\/ keep bootTime zero for now to use as a first-time-through flag\n-    } else {\n-      t = os::javaTimeNanos();\n-      d = nanos_to_millis(t - lastTimeNanos);\n-    }\n+   if (0 < perfstat_cpu_total(NULL, cpu_stats, sizeof(perfstat_cpu_total_t), 1)) {\n+     return OS_ERR;\n+   }\n@@ -412,17 +213,2 @@\n-    if (d == 0) {\n-      *rate = lastRate;\n-    } else if (get_noof_context_switches(&sw) == 0) {\n-      *rate      = ( (double)(sw - lastSwitches) \/ d ) * 1000;\n-      lastRate     = *rate;\n-      lastSwitches = sw;\n-      if (bootTime != 0) {\n-        lastTimeNanos = t;\n-      }\n-    } else {\n-      *rate = 0;\n-      res   = OS_ERR;\n-    }\n-    if (*rate <= 0) {\n-      *rate = 0;\n-      lastRate = 0;\n-    }\n+   ticks = cpu_stats->user + cpu_stats->sys + cpu_stats->idle + cpu_stats->wait;\n+   *rate = (cpu_stats->pswitch \/ ticks) * ticks_per_sec;\n@@ -430,5 +216,1 @@\n-    if (bootTime == 0) {\n-      bootTime = bt;\n-    }\n-  }\n-  pthread_mutex_unlock(&contextSwitchLock);\n+   FREE_RESOURCE_ARRAY(perfstat_cpu_total_t, cpu_stats, 1);\n@@ -436,1 +218,1 @@\n-  return res;\n+   return OS_OK;\n@@ -440,1 +222,0 @@\n-  friend class CPUPerformanceInterface;\n@@ -442,6 +223,3 @@\n-  CPUPerfCounters _counters;\n-\n-  int cpu_load(int which_logical_cpu, double* cpu_load);\n-  int context_switch_rate(double* rate);\n-  int cpu_load_total_process(double* cpu_load);\n-  int cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad);\n+  int _ncpus;\n+  perfstat_id_t* _lcpu_names;\n+  CPUPerfTicks _last_total_ticks;\n@@ -453,0 +231,5 @@\n+\n+  int cpu_load(int which_logical_cpu, double* cpu_load);\n+  int context_switch_rate(double* rate);\n+  int cpu_load_total_process(double* cpu_load);\n+  int cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad);\n@@ -456,2 +239,8 @@\n-  _counters.nProcs = os::active_processor_count();\n-  _counters.cpus = NULL;\n+  \/* Set default values only *\/\n+  _ncpus = 0;\n+  _lcpu_names = NULL;\n+\n+  _last_total_ticks.user = 0;\n+  _last_total_ticks.sys  = 0;\n+  _last_total_ticks.idle = 0;\n+  _last_total_ticks.wait = 0;\n@@ -461,3 +250,1 @@\n-  size_t array_entry_count = _counters.nProcs + 1;\n-  _counters.cpus = NEW_C_HEAP_ARRAY(CPUPerfTicks, array_entry_count, mtInternal);\n-  memset(_counters.cpus, 0, array_entry_count * sizeof(*_counters.cpus));\n+  perfstat_cpu_total_t* cpu_stats;\n@@ -465,2 +252,1 @@\n-  \/\/ For the CPU load total\n-  get_total_ticks(-1, &_counters.cpus[_counters.nProcs]);\n+  cpu_stats = (perfstat_cpu_total_t*) NEW_RESOURCE_ARRAY(perfstat_cpu_total_t, 1);\n@@ -468,3 +254,3 @@\n-  \/\/ For each CPU\n-  for (int i = 0; i < _counters.nProcs; i++) {\n-    get_total_ticks(i, &_counters.cpus[i]);\n+   if (perfstat_cpu_total(NULL, cpu_stats, sizeof(perfstat_cpu_total_t), 1) < 0) {\n+     FREE_RESOURCE_ARRAY(perfstat_cpu_total_t, cpu_stats, 1);\n+     return false;\n@@ -472,2 +258,0 @@\n-  \/\/ For JVM load\n-  get_jvm_ticks(&_counters.jvmTicks);\n@@ -475,4 +259,3 @@\n-  \/\/ initialize context switch system\n-  \/\/ the double is only for init\n-  double init_ctx_switch_rate;\n-  perf_context_switch_rate(&init_ctx_switch_rate);\n+  _ncpus = cpu_stats->ncpus;\n+  _lcpu_names = NEW_C_HEAP_ARRAY(perfstat_id_t, cpu_stats->ncpus, mtInternal);\n+  populate_lcpu_names(_ncpus, _lcpu_names);\n@@ -480,0 +263,1 @@\n+  FREE_RESOURCE_ARRAY(perfstat_cpu_total_t, cpu_stats, 1);\n@@ -484,2 +268,2 @@\n-  if (_counters.cpus != NULL) {\n-    FREE_C_HEAP_ARRAY(char, _counters.cpus);\n+  if (_lcpu_names) {\n+    FREE_C_HEAP_ARRAY(perfstat_id_t, _lcpu_names);\n@@ -489,5 +273,10 @@\n-int CPUPerformanceInterface::CPUPerformance::cpu_load(int which_logical_cpu, double* cpu_load) {\n-  double u, s;\n-  u = get_cpu_load(which_logical_cpu, &_counters, &s, CPU_LOAD_GLOBAL);\n-  if (u < 0) {\n-    *cpu_load = 0.0;\n+\/**\n+ * Get CPU load for all processes on specified logical CPU.\n+ *\/\n+int CPUPerformanceInterface::CPUPerformance::cpu_load(int which_logical_cpu, double* lcpu_load) {\n+  CPUPerfTicks lcpu_stats;\n+\n+  assert(lcpu_load != NULL, \"NULL pointer passed to cpu_load\");\n+\n+  if (get_lcpu_ticks(&_lcpu_names[which_logical_cpu], &lcpu_stats) == OS_ERR) {\n+    *lcpu_load = 0.0;\n@@ -496,2 +285,4 @@\n-  \/\/ Cap total systemload to 1.0\n-  *cpu_load = MIN2<double>((u + s), 1.0);\n+\n+  calculate_updated_load(&lcpu_stats, &_last_total_ticks, lcpu_load);\n+  update_last_ticks(&lcpu_stats, &_last_total_ticks);\n+\n@@ -501,6 +292,13 @@\n-int CPUPerformanceInterface::CPUPerformance::cpu_load_total_process(double* cpu_load) {\n-  double u, s;\n-  u = get_cpu_load(-1, &_counters, &s, CPU_LOAD_VM_ONLY);\n-  if (u < 0) {\n-    *cpu_load = 0.0;\n-    return OS_ERR;\n+\/**\n+ * Get CPU load for all processes on all CPUs.\n+ *\/\n+int CPUPerformanceInterface::CPUPerformance::cpu_load_total_process(double* total_load) {\n+  double load_avg = 0.0;\n+\n+  assert(total_load != NULL, \"NULL pointer passed to cpu_load_total_process\");\n+\n+  for (int cpu=0; cpu < _ncpus; cpu++) {\n+    double l;\n+    if (cpu_load(cpu, &l) != OS_ERR) {\n+      load_avg += l;\n+    }\n@@ -508,1 +306,4 @@\n-  *cpu_load = u + s;\n+  load_avg = load_avg\/_ncpus;\n+\n+  *total_load = load_avg;\n+\n@@ -512,0 +313,9 @@\n+\/**\n+ * Get CPU load for all CPUs.\n+ *\n+ * Set values for:\n+ * - pjvmUserLoad:     CPU load due to jvm process in user mode. Jvm process assumed to be self process\n+ * - pjvmKernelLoad:   CPU load due to jvm process in kernel mode. Jvm process assumed to be self process\n+ * - psystemTotalLoad: Total CPU load from all process on all logical CPUs\n+ *\n+ *\/\n@@ -513,1 +323,1 @@\n-  double u, s, t;\n+  double u, k, t;\n@@ -515,2 +325,2 @@\n-  assert(pjvmUserLoad != NULL, \"pjvmUserLoad not inited\");\n-  assert(pjvmKernelLoad != NULL, \"pjvmKernelLoad not inited\");\n+  assert(pjvmUserLoad     != NULL, \"pjvmUserLoad not inited\");\n+  assert(pjvmKernelLoad   != NULL, \"pjvmKernelLoad not inited\");\n@@ -519,4 +329,5 @@\n-  u = get_cpu_load(-1, &_counters, &s, CPU_LOAD_VM_ONLY);\n-  if (u < 0) {\n-    *pjvmUserLoad = 0.0;\n-    *pjvmKernelLoad = 0.0;\n+  if (get_jvm_load(&u, &k, NULL) == OS_ERR ||\n+      cpu_load_total_process(&t) == OS_ERR)\n+  {\n+    *pjvmUserLoad     = 0.0;\n+    *pjvmKernelLoad   = 0.0;\n@@ -527,9 +338,3 @@\n-  cpu_load(-1, &t);\n-  \/\/ clamp at user+system and 1.0\n-  if (u + s > t) {\n-    t = MIN2<double>(u + s, 1.0);\n-  }\n-\n-  *pjvmUserLoad = u;\n-  *pjvmKernelLoad = s;\n-  *psystemTotalLoad = t;\n+  *pjvmUserLoad     = normalize(&u);\n+  *pjvmKernelLoad   = normalize(&k);\n+  *psystemTotalLoad = normalize(&t);\n@@ -576,30 +381,4 @@\n-  friend class SystemProcessInterface;\n- private:\n-  class ProcessIterator : public CHeapObj<mtInternal> {\n-    friend class SystemProcessInterface::SystemProcesses;\n-   private:\n-    DIR*           _dir;\n-    struct dirent* _entry;\n-    bool           _valid;\n-    char           _exeName[PATH_MAX];\n-    char           _exePath[PATH_MAX];\n-\n-    ProcessIterator();\n-    ~ProcessIterator();\n-    bool initialize();\n-\n-    bool is_valid() const { return _valid; }\n-    bool is_valid_entry(struct dirent* entry) const;\n-    bool is_dir(const char* name) const;\n-    int  fsize(const char* name, uint64_t& size) const;\n-\n-    char* allocate_string(const char* str) const;\n-    void  get_exe_name();\n-    char* get_exe_path();\n-    char* get_cmdline();\n-\n-    int current(SystemProcess* process_info);\n-    int next_process();\n-  };\n-\n-  ProcessIterator* _iterator;\n+  private:\n+  char* allocate_string(const char* str) const;\n+\n+  public:\n@@ -609,2 +388,0 @@\n-\n-  \/\/information about system processes\n@@ -614,69 +391,1 @@\n-bool SystemProcessInterface::SystemProcesses::ProcessIterator::is_dir(const char* name) const {\n-  struct stat mystat;\n-  int ret_val = 0;\n-\n-  ret_val = stat(name, &mystat);\n-  if (ret_val < 0) {\n-    return false;\n-  }\n-  ret_val = S_ISDIR(mystat.st_mode);\n-  return ret_val > 0;\n-}\n-\n-int SystemProcessInterface::SystemProcesses::ProcessIterator::fsize(const char* name, uint64_t& size) const {\n-  assert(name != NULL, \"name pointer is NULL!\");\n-  size = 0;\n-  struct stat fbuf;\n-\n-  if (stat(name, &fbuf) < 0) {\n-    return OS_ERR;\n-  }\n-  size = fbuf.st_size;\n-  return OS_OK;\n-}\n-\n-\/\/ if it has a numeric name, is a directory and has a 'stat' file in it\n-bool SystemProcessInterface::SystemProcesses::ProcessIterator::is_valid_entry(struct dirent* entry) const {\n-  char buffer[PATH_MAX];\n-  uint64_t size = 0;\n-\n-  if (atoi(entry->d_name) != 0) {\n-    jio_snprintf(buffer, PATH_MAX, \"\/proc\/%s\", entry->d_name);\n-    buffer[PATH_MAX - 1] = '\\0';\n-\n-    if (is_dir(buffer)) {\n-      jio_snprintf(buffer, PATH_MAX, \"\/proc\/%s\/stat\", entry->d_name);\n-      buffer[PATH_MAX - 1] = '\\0';\n-      if (fsize(buffer, size) != OS_ERR) {\n-        return true;\n-      }\n-    }\n-  }\n-  return false;\n-}\n-\n-\/\/ get exe-name from \/proc\/<pid>\/stat\n-void SystemProcessInterface::SystemProcesses::ProcessIterator::get_exe_name() {\n-  FILE* fp;\n-  char  buffer[PATH_MAX];\n-\n-  jio_snprintf(buffer, PATH_MAX, \"\/proc\/%s\/stat\", _entry->d_name);\n-  buffer[PATH_MAX - 1] = '\\0';\n-  if ((fp = fopen(buffer, \"r\")) != NULL) {\n-    if (fgets(buffer, PATH_MAX, fp) != NULL) {\n-      char* start, *end;\n-      \/\/ exe-name is between the first pair of ( and )\n-      start = strchr(buffer, '(');\n-      if (start != NULL && start[1] != '\\0') {\n-        start++;\n-        end = strrchr(start, ')');\n-        if (end != NULL) {\n-          size_t len;\n-          len = MIN2<size_t>(end - start, sizeof(_exeName) - 1);\n-          memcpy(_exeName, start, len);\n-          _exeName[len] = '\\0';\n-        }\n-      }\n-    }\n-    fclose(fp);\n-  }\n+SystemProcessInterface::SystemProcesses::SystemProcesses() {\n@@ -685,35 +394,2 @@\n-\/\/ get command line from \/proc\/<pid>\/cmdline\n-char* SystemProcessInterface::SystemProcesses::ProcessIterator::get_cmdline() {\n-  FILE* fp;\n-  char  buffer[PATH_MAX];\n-  char* cmdline = NULL;\n-\n-  jio_snprintf(buffer, PATH_MAX, \"\/proc\/%s\/cmdline\", _entry->d_name);\n-  buffer[PATH_MAX - 1] = '\\0';\n-  if ((fp = fopen(buffer, \"r\")) != NULL) {\n-    size_t size = 0;\n-    char   dummy;\n-\n-    \/\/ find out how long the file is (stat always returns 0)\n-    while (fread(&dummy, 1, 1, fp) == 1) {\n-      size++;\n-    }\n-    if (size > 0) {\n-      cmdline = NEW_C_HEAP_ARRAY(char, size + 1, mtInternal);\n-      cmdline[0] = '\\0';\n-      if (fseek(fp, 0, SEEK_SET) == 0) {\n-        if (fread(cmdline, 1, size, fp) == size) {\n-          \/\/ the file has the arguments separated by '\\0',\n-          \/\/ so we translate '\\0' to ' '\n-          for (size_t i = 0; i < size; i++) {\n-            if (cmdline[i] == '\\0') {\n-              cmdline[i] = ' ';\n-            }\n-          }\n-          cmdline[size] = '\\0';\n-        }\n-      }\n-    }\n-    fclose(fp);\n-  }\n-  return cmdline;\n+bool SystemProcessInterface::SystemProcesses::initialize() {\n+  return true;\n@@ -722,7 +398,1 @@\n-\/\/ get full path to exe from \/proc\/<pid>\/exe symlink\n-char* SystemProcessInterface::SystemProcesses::ProcessIterator::get_exe_path() {\n-  char buffer[PATH_MAX];\n-\n-  jio_snprintf(buffer, PATH_MAX, \"\/proc\/%s\/exe\", _entry->d_name);\n-  buffer[PATH_MAX - 1] = '\\0';\n-  return realpath(buffer, _exePath);\n+SystemProcessInterface::SystemProcesses::~SystemProcesses() {\n@@ -731,1 +401,1 @@\n-char* SystemProcessInterface::SystemProcesses::ProcessIterator::allocate_string(const char* str) const {\n+char* SystemProcessInterface::SystemProcesses::allocate_string(const char* str) const {\n@@ -738,6 +408,4 @@\n-int SystemProcessInterface::SystemProcesses::ProcessIterator::current(SystemProcess* process_info) {\n-  if (!is_valid()) {\n-    return OS_ERR;\n-  }\n-\n-  process_info->set_pid(atoi(_entry->d_name));\n+int SystemProcessInterface::SystemProcesses::system_processes(SystemProcess** system_processes, int* nprocs) const {\n+  perfstat_process_t* all_proc_stats;\n+  perfstat_process_t* proc_stats;\n+  perfstat_id_t       name_holder;\n@@ -745,6 +413,2 @@\n-  get_exe_name();\n-  process_info->set_name(allocate_string(_exeName));\n-\n-  if (get_exe_path() != NULL) {\n-     process_info->set_path(allocate_string(_exePath));\n-  }\n+  assert(system_processes != NULL, \"system_processes pointer is NULL!\");\n+  assert(nprocs != NULL, \"system_processes counter pointers is NULL!\");\n@@ -752,6 +416,3 @@\n-  char* cmdline = NULL;\n-  cmdline = get_cmdline();\n-  if (cmdline != NULL) {\n-    process_info->set_command_line(allocate_string(cmdline));\n-    FREE_C_HEAP_ARRAY(char, cmdline);\n-  }\n+  \/\/ initialize pointers\n+  *nprocs = 0;\n+  *system_processes = NULL;\n@@ -759,2 +420,1 @@\n-  return OS_OK;\n-}\n+  strcpy(name_holder.name, \"\");\n@@ -762,2 +422,3 @@\n-int SystemProcessInterface::SystemProcesses::ProcessIterator::next_process() {\n-  if (!is_valid()) {\n+  \/\/ calling perfstat_<subsystem>(NULL, NULL, _, 0) returns number of available records\n+  if((*nprocs = perfstat_process(NULL, NULL, sizeof(perfstat_process_t), 0)) < 1) {\n+    \/\/ expect at least 1 process\n@@ -767,29 +428,1 @@\n-  do {\n-    _entry = os::readdir(_dir);\n-    if (_entry == NULL) {\n-      \/\/ Error or reached end.  Could use errno to distinguish those cases.\n-      _valid = false;\n-      return OS_ERR;\n-    }\n-  } while(!is_valid_entry(_entry));\n-\n-  _valid = true;\n-  return OS_OK;\n-}\n-\n-SystemProcessInterface::SystemProcesses::ProcessIterator::ProcessIterator() {\n-  _dir = NULL;\n-  _entry = NULL;\n-  _valid = false;\n-}\n-\n-bool SystemProcessInterface::SystemProcesses::ProcessIterator::initialize() {\n-  \/\/ Not yet implemented.\n-  return false;\n-}\n-\n-SystemProcessInterface::SystemProcesses::ProcessIterator::~ProcessIterator() {\n-  if (_dir != NULL) {\n-    os::closedir(_dir);\n-  }\n-}\n+  all_proc_stats = (perfstat_process_t*) NEW_RESOURCE_ARRAY(perfstat_process_t, *nprocs);\n@@ -797,3 +430,2 @@\n-SystemProcessInterface::SystemProcesses::SystemProcesses() {\n-  _iterator = NULL;\n-}\n+  \/\/ populate stats && (re)set the number of procs that have been populated\n+  *nprocs = perfstat_process(&name_holder, all_proc_stats, sizeof(perfstat_process_t), *nprocs);\n@@ -801,4 +433,2 @@\n-bool SystemProcessInterface::SystemProcesses::initialize() {\n-  _iterator = new SystemProcessInterface::SystemProcesses::ProcessIterator();\n-  return _iterator->initialize();\n-}\n+  for (int record=0; record < *nprocs; record++) {\n+    proc_stats = &(all_proc_stats[record]);\n@@ -806,3 +436,8 @@\n-SystemProcessInterface::SystemProcesses::~SystemProcesses() {\n-  if (_iterator != NULL) {\n-    delete _iterator;\n+    \/\/ create new SystemProcess. With next pointing to current head.\n+    SystemProcess* sp = new SystemProcess(proc_stats->pid,\n+                                          allocate_string(proc_stats->proc_name),\n+                                          NULL,\n+                                          NULL,\n+                                          *system_processes);\n+    \/\/ update head.\n+    *system_processes = sp;\n@@ -810,14 +445,0 @@\n-}\n-\n-int SystemProcessInterface::SystemProcesses::system_processes(SystemProcess** system_processes, int* no_of_sys_processes) const {\n-  assert(system_processes != NULL, \"system_processes pointer is NULL!\");\n-  assert(no_of_sys_processes != NULL, \"system_processes counter pointers is NULL!\");\n-  assert(_iterator != NULL, \"iterator is NULL!\");\n-\n-  \/\/ initialize pointers\n-  *no_of_sys_processes = 0;\n-  *system_processes = NULL;\n-\n-  while (_iterator->is_valid()) {\n-    SystemProcess* tmp = new SystemProcess();\n-    _iterator->current(tmp);\n@@ -825,12 +446,1 @@\n-    \/\/if already existing head\n-    if (*system_processes != NULL) {\n-      \/\/move \"first to second\"\n-      tmp->set_next(*system_processes);\n-    }\n-    \/\/ new head\n-    *system_processes = tmp;\n-    \/\/ increment\n-    (*no_of_sys_processes)++;\n-    \/\/ step forward\n-    _iterator->next_process();\n-  }\n+  FREE_RESOURCE_ARRAY(perfstat_process_t, all_proc_stats, 1);\n@@ -900,1 +510,2 @@\n-  friend class NetworkPerformanceInterface;\n+  NONCOPYABLE(NetworkPerformance);\n+\n@@ -902,0 +513,3 @@\n+  char* allocate_string(const char* str) const;\n+\n+  public:\n@@ -903,1 +517,0 @@\n-  NONCOPYABLE(NetworkPerformance);\n@@ -909,1 +522,1 @@\n-NetworkPerformanceInterface::NetworkPerformance::NetworkPerformance() {\n+NetworkPerformanceInterface::NetworkPerformance::NetworkPerformance() {}\n@@ -911,1 +524,1 @@\n-}\n+bool NetworkPerformanceInterface::NetworkPerformance::initialize() { return true; }\n@@ -913,3 +526,1 @@\n-bool NetworkPerformanceInterface::NetworkPerformance::initialize() {\n-  return true;\n-}\n+NetworkPerformanceInterface::NetworkPerformance::~NetworkPerformance() {}\n@@ -917,1 +528,5 @@\n-NetworkPerformanceInterface::NetworkPerformance::~NetworkPerformance() {\n+char* NetworkPerformanceInterface::NetworkPerformance::allocate_string(const char* str) const {\n+  if (str != NULL) {\n+    return os::strdup_check_oom(str, mtInternal);\n+  }\n+  return NULL;\n@@ -922,1 +537,38 @@\n-  return FUNCTIONALITY_NOT_IMPLEMENTED;\n+  assert(network_interfaces != NULL, \"network_interfaces is NULL\");\n+\n+  int n_records = 0;\n+  NetworkInterface* head = NULL;\n+  perfstat_netinterface_t* net_stats;\n+  perfstat_netinterface_t* all_net_stats;\n+  perfstat_id_t name_holder;\n+\n+  *network_interfaces = NULL;\n+  strncpy(name_holder.name , FIRST_NETINTERFACE, IDENTIFIER_LENGTH);\n+\n+  \/\/ calling perfstat_<subsyste>(NULL, NULL, ..., 0) returns number of available records\n+  if (0 > (n_records = perfstat_netinterface(NULL, NULL, sizeof(perfstat_netinterface_t), 0))) {\n+    return OS_ERR;\n+  }\n+\n+  all_net_stats = (perfstat_netinterface_t*) NEW_RESOURCE_ARRAY(perfstat_netinterface_t, n_records);\n+\n+  \/\/ populate net_stats && check that the expected number of records have been populated\n+  if (n_records > (perfstat_netinterface(&name_holder, all_net_stats, sizeof(perfstat_netinterface_t), n_records))) {\n+    FREE_RESOURCE_ARRAY(perfstat_netinterface_t, all_net_stats, 1);\n+    return OS_ERR;\n+  }\n+\n+  for (int i = n_records - 1; i >= 0; i--) {\n+    net_stats = &all_net_stats[i];\n+\n+    \/\/ Create new Network interface *with current head as next node*\n+    NetworkInterface* net_interface = new NetworkInterface(allocate_string(net_stats->name),\n+                                                           net_stats->ibytes,\n+                                                           net_stats->obytes,\n+                                                           head);\n+    head = net_interface;\n+  }\n+\n+  FREE_RESOURCE_ARRAY(perfstat_netinterface_t, all_net_stats, 1);\n+\n+  return OS_OK;\n","filename":"src\/hotspot\/os\/aix\/os_perf_aix.cpp","additions":286,"deletions":634,"binary":false,"changes":920,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+#include \"precompiled.hpp\"\n+#include \"unittest.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/os_perf.hpp\"\n+\n+TEST(NetworkPerformance, NetworkUtiliazation) {\n+    NetworkPerformanceInterface* netperf = new NetworkPerformanceInterface();\n+    NetworkInterface* netperf_stats;\n+\n+    netperf->initialize();\n+    netperf->network_utilization(&netperf_stats);\n+\n+    int n_interfaces = 0;\n+    for(const NetworkInterface* ptr = netperf_stats; ptr; ptr = ptr->next()) {\n+        \/\/ TODO: Test the interface metadata?\n+        n_interfaces++;\n+    }\n+    ASSERT_GT(n_interfaces, 0) << \"expected non-zero number of interfaces\";\n+}\n+\n+TEST(CPUPerformance, CPULoad) {\n+    int lcpu;\n+    double load;\n+    CPUPerformanceInterface* cpu_perf = new CPUPerformanceInterface();\n+\n+    cpu_perf->initialize();\n+    load = 0.0;\n+\n+    for(lcpu=0; cpu_perf->cpu_load(lcpu,&load) == OS_OK; lcpu++) {\n+        ASSERT_GE(load, 0.0);\n+        ASSERT_LE(load, 1.0);\n+    }\n+\n+    ASSERT_GT(lcpu, 0);\n+}\n+\n+TEST(CPUPerformance, ContextSwitchRate) {\n+    double rate;\n+    CPUPerformanceInterface* cpu_perf = new CPUPerformanceInterface();\n+\n+    cpu_perf->initialize();\n+    rate = 0.0;\n+\n+    cpu_perf->context_switch_rate(&rate);\n+\n+    ASSERT_GT(rate, 0.0);\n+}\n+\n+TEST(CPUPerformance, CPULoadTotalProcess) {\n+    double load;\n+    CPUPerformanceInterface* cpu_perf = new CPUPerformanceInterface();\n+\n+    cpu_perf->initialize();\n+    load = 0.0;\n+\n+    cpu_perf->cpu_load_total_process(&load);\n+\n+    ASSERT_GE(load, 0.0);\n+}\n+\n+TEST(CPUPerformance, CPULoadsProcess) {\n+    double jvm_uload, jvm_kload, sys_load;\n+    CPUPerformanceInterface* cpu_perf = new CPUPerformanceInterface();\n+\n+    cpu_perf->initialize();\n+    jvm_uload = 0.0;\n+    jvm_kload = 0.0;\n+    sys_load  = 0.0;\n+\n+    cpu_perf->cpu_loads_process(&jvm_uload, &jvm_kload, &sys_load);\n+\n+    ASSERT_GE(jvm_uload, 0.0);\n+    ASSERT_GE(jvm_kload, 0.0);\n+    ASSERT_GE(sys_load,  0.0);\n+\n+    ASSERT_LE(jvm_uload, 1.0);\n+    ASSERT_LE(jvm_kload, 1.0);\n+    ASSERT_LE(sys_load,  1.0);\n+}\n+\n+TEST(SystemProcessInterface, SystemProcesses) {\n+   SystemProcessInterface* proc_info = new SystemProcessInterface();\n+   SystemProcess* proc;\n+   int n_procs;\n+\n+   n_procs = 0;\n+   proc_info->initialize();\n+   proc_info->system_processes(&proc, &n_procs);\n+   ASSERT_GT(n_procs, 0) << \"expected non-zero number of processes\";\n+\n+   for( ; proc ; proc = proc->next()) {\n+       ASSERT_NE(0, proc->pid());\n+       ASSERT_NE(nullptr, proc->name());\n+   }\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_jfr_interfaces.cpp","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -80,0 +80,2 @@\n+        } else if (Platform.isAix()) {\n+            libTemplate = \"\";\n@@ -81,0 +83,1 @@\n+\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestNativeLibrariesEvent.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}