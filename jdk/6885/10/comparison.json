{"files":[{"patch":"@@ -424,0 +424,8 @@\n+    if test \"x$TOOLCHAIN_TYPE\" = xxlc; then\n+      # We need '-qminimaltoc' or '-qpic=large -bbigtoc' if the TOC overflows.\n+      # Hotspot now overflows its 64K TOC (currently only for debug),\n+      # so for debug we build with '-qpic=large -bbigtoc'.\n+      DEBUG_CFLAGS_JVM=\"-qpic=large\"\n+    fi\n+  fi\n+\n","filename":"make\/autoconf\/flags-cflags.m4","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -268,16 +268,0 @@\n-###############################################################################\n-# Check if the feature 'jfr' is available on this platform.\n-#\n-AC_DEFUN_ONCE([JVM_FEATURES_CHECK_JFR],\n-[\n-  JVM_FEATURES_CHECK_AVAILABILITY(jfr, [\n-    AC_MSG_CHECKING([if platform is supported by JFR])\n-    if test \"x$OPENJDK_TARGET_OS\" = xaix; then\n-      AC_MSG_RESULT([no, $OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU])\n-      AVAILABLE=false\n-    else\n-      AC_MSG_RESULT([yes])\n-    fi\n-  ])\n-])\n-\n@@ -403,1 +387,0 @@\n-  JVM_FEATURES_CHECK_JFR\n@@ -409,6 +392,0 @@\n-  # Filter out features by default for all variants on certain platforms.\n-  # Make sure to just add to JVM_FEATURES_PLATFORM_FILTER, since it could\n-  # have a value already from custom extensions.\n-  if test \"x$OPENJDK_TARGET_OS\" = xaix; then\n-    JVM_FEATURES_PLATFORM_FILTER=\"$JVM_FEATURES_PLATFORM_FILTER jfr\"\n-  fi\n","filename":"make\/autoconf\/jvm-features.m4","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2022, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +34,3 @@\n+typedef int (*fun_perfstat_cpu_t) (perfstat_id_t *name, PERFSTAT_CPU_T_LATEST* userbuff,\n+                                   int sizeof_userbuff, int desired_number);\n+\n@@ -39,0 +43,7 @@\n+typedef int (*fun_perfstat_netinterface_t) (perfstat_id_t *name, perfstat_netinterface_t* userbuff,\n+                                            int sizeof_userbuff, int desired_number);\n+\n+typedef int (*fun_perfstat_process_t) (perfstat_id_t *name,\n+                                       PERFSTAT_PROCESS_T_LATEST* userbuff, int sizeof_userbuff,\n+                                       int desired_number);\n+\n@@ -51,2 +62,4 @@\n-static fun_perfstat_cpu_total_t     g_fun_perfstat_cpu_total = NULL;\n-static fun_perfstat_memory_total_t  g_fun_perfstat_memory_total = NULL;\n+static fun_perfstat_cpu_total_t       g_fun_perfstat_cpu_total       = NULL;\n+static fun_perfstat_cpu_t             g_fun_perfstat_cpu             = NULL;\n+static fun_perfstat_memory_total_t    g_fun_perfstat_memory_total    = NULL;\n+static fun_perfstat_netinterface_t    g_fun_perfstat_netinterface    = NULL;\n@@ -54,3 +67,4 @@\n-static fun_perfstat_wpar_total_t    g_fun_perfstat_wpar_total = NULL;\n-static fun_perfstat_reset_t         g_fun_perfstat_reset = NULL;\n-static fun_wpar_getcid_t            g_fun_wpar_getcid = NULL;\n+static fun_perfstat_process_t         g_fun_perfstat_process         = NULL;\n+static fun_perfstat_wpar_total_t      g_fun_perfstat_wpar_total      = NULL;\n+static fun_perfstat_reset_t           g_fun_perfstat_reset           = NULL;\n+static fun_wpar_getcid_t              g_fun_wpar_getcid              = NULL;\n@@ -87,0 +101,1 @@\n+  RESOLVE_FUN(perfstat_cpu);\n@@ -88,0 +103,2 @@\n+  RESOLVE_FUN(perfstat_netinterface);\n+  RESOLVE_FUN(perfstat_process);\n@@ -111,0 +128,16 @@\n+int libperfstat::perfstat_cpu_total(perfstat_id_t *name, PERFSTAT_CPU_TOTAL_T_LATEST* userbuff,\n+                                    int sizeof_userbuff, int desired_number) {\n+  if (g_fun_perfstat_cpu_total == NULL) {\n+    return -1;\n+  }\n+  return g_fun_perfstat_cpu_total(name, userbuff, sizeof_userbuff, desired_number);\n+}\n+\n+int libperfstat::perfstat_cpu(perfstat_id_t *name, PERFSTAT_CPU_T_LATEST* userbuff,\n+                              int sizeof_userbuff, int desired_number) {\n+  if (g_fun_perfstat_cpu == NULL) {\n+    return -1;\n+  }\n+  return g_fun_perfstat_cpu(name, userbuff, sizeof_userbuff, desired_number);\n+}\n+\n@@ -120,3 +153,4 @@\n-int libperfstat::perfstat_cpu_total(perfstat_id_t *name, PERFSTAT_CPU_TOTAL_T_LATEST* userbuff,\n-                                    int sizeof_userbuff, int desired_number) {\n-  if (g_fun_perfstat_cpu_total == NULL) {\n+int libperfstat::perfstat_netinterface(perfstat_id_t *name,\n+                                       perfstat_netinterface_t* userbuff,\n+                                       int sizeof_userbuff, int desired_number) {\n+  if (g_fun_perfstat_netinterface == NULL) {\n@@ -125,1 +159,1 @@\n-  return g_fun_perfstat_cpu_total(name, userbuff, sizeof_userbuff, desired_number);\n+  return g_fun_perfstat_netinterface(name, userbuff, sizeof_userbuff, desired_number);\n@@ -136,0 +170,8 @@\n+int libperfstat::perfstat_process(perfstat_id_t *name, perfstat_process_t* userbuff,\n+                                  int sizeof_userbuff, int desired_number) {\n+  if (g_fun_perfstat_process == NULL) {\n+    return -1;\n+  }\n+  return g_fun_perfstat_process(name, userbuff, sizeof_userbuff, desired_number);\n+}\n+\n","filename":"src\/hotspot\/os\/aix\/libperfstat_aix.cpp","additions":51,"deletions":9,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2022, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +51,3 @@\n-#define IDENTIFIER_LENGTH 64    \/* length of strings included in the structures *\/\n+#define IDENTIFIER_LENGTH  64    \/* length of strings included in the structures *\/\n+#define FIRST_CPU          \"\"    \/* pseudo-name for fist CPU *\/\n+#define FIRST_NETINTERFACE \"\"    \/* pseudo-name for first NETINTERFACE *\/\n@@ -442,0 +445,96 @@\n+typedef struct { \/* component perfstat_cpu_t from AIX 7.2 documentation *\/\n+  char name [IDENTIFIER_LENGTH];            \/* Logical processor name (processor0, processor1,.). *\/\n+  ulong_t state;                            \/* Specifies whether the CPU is offline or online.\n+                                             * (NOTE: The type of 'state' is not specified in the documentation, but\n+                                             * ulong_t is the correct length) *\/\n+  u_longlong_t user;                        \/* Raw number of clock ticks spent in user mode. *\/\n+  u_longlong_t sys;                         \/* Raw number of clock ticks spent in system mode. *\/\n+  u_longlong_t idle;                        \/* Raw number of clock ticks spent idle. *\/\n+  u_longlong_t wait;                        \/* Raw number of clock ticks spent waiting for I\/O. *\/\n+  u_longlong_t pswitch;                     \/* Number of context switches (changes of currently running process). *\/\n+  u_longlong_t syscall;                     \/* Number of system calls executed. *\/\n+  u_longlong_t sysread;                     \/* Number of read system calls executed. *\/\n+  u_longlong_t syswrite;                    \/* Number of write system calls executed. *\/\n+  u_longlong_t sysfork;                     \/* Number of fork system call executed. *\/\n+  u_longlong_t sysexec;                     \/* Number of exec system call executed. *\/\n+  u_longlong_t readch;                      \/* Number of characters transferred with read system call. *\/\n+  u_longlong_t writech;                     \/* Number of characters transferred with write system call. *\/\n+  u_longlong_t bread;                       \/* Number of block reads. *\/\n+  u_longlong_t bwrite;                      \/* Number of block writes. *\/\n+  u_longlong_t lread;                       \/* Number of logical read requests. *\/\n+  u_longlong_t lwrite;                      \/* Number of logical write requests. *\/\n+  u_longlong_t phread;                      \/* Number of physical reads (reads on raw device). *\/\n+  u_longlong_t phwrite;                     \/* Number of physical writes (writes on raw device). *\/\n+  u_longlong_t iget;                        \/* Number of inode lookups. *\/\n+  u_longlong_t namei;                       \/* Number of vnode lookup from a path name. *\/\n+  u_longlong_t dirblk;                      \/* Number of 512-byte blocks reads by the directory search routine to locate an entry for a file. *\/\n+  u_longlong_t msg;                         \/* Number of interprocess communication (IPC) message operations. *\/\n+  u_longlong_t sema;                        \/* Number of IPC semaphore operations. *\/\n+  u_longlong_t minfaults;                   \/* Number of page faults with no I\/O. *\/\n+  u_longlong_t majfaults;                   \/* Number of page faults with disk I\/O. *\/\n+  u_longlong_t puser;                       \/* Raw number of physical processor ticks in user mode. *\/\n+  u_longlong_t psys;                        \/* Raw number of physical processor ticks in system mode. *\/\n+  u_longlong_t pidle;                       \/* Raw number of physical processor ticks idle. *\/\n+  u_longlong_t pwait;                       \/* Raw number of physical processor ticks waiting for I\/O. *\/\n+  u_longlong_t redisp_sd0;                  \/* Number of thread redispatches within the scheduler affinity domain 0. *\/\n+  u_longlong_t redisp_sd1;                  \/* Number of thread redispatches within the scheduler affinity domain 1. *\/\n+  u_longlong_t redisp_sd2;                  \/* Number of thread redispatches within the scheduler affinity domain 2. *\/\n+  u_longlong_t redisp_sd3;                  \/* Number of thread redispatches within the scheduler affinity domain 3. *\/\n+  u_longlong_t redisp_sd4;                  \/* Number of thread redispatches within the scheduler affinity domain 4. *\/\n+  u_longlong_t redisp_sd5;                  \/* Number of thread redispatches within the scheduler affinity domain 5. *\/\n+  u_longlong_t migration_push;              \/* Number of thread migrations from the local runque to another queue due to starvation load balancing. *\/\n+  u_longlong_t migration_S3grq;             \/* Number of thread migrations from the global runque to the local runque resulting in a move across scheduling domain 3. *\/\n+  u_longlong_t migration_S3pull;            \/* Number of thread migrations from another processor's runque resulting in a move across scheduling domain 3. *\/\n+  u_longlong_t invol_cswitch;               \/* Number of involuntary thread context switches. *\/\n+  u_longlong_t vol_cswitch;                 \/* Number of voluntary thread context switches. *\/\n+  u_longlong_t runque;                      \/* Number of threads on the runque. *\/\n+  u_longlong_t bound;                       \/* Number of bound threads. *\/\n+  u_longlong_t decrintrs;                   \/* Number of decrementer interrupts. *\/\n+  u_longlong_t mpcrintrs;                   \/* Number of received interrupts for MPC. *\/\n+  u_longlong_t mpcsintrs;                   \/* Number of sent interrupts for MPC. *\/\n+  u_longlong_t devintrs;                    \/* Number of device interrupts. *\/\n+  u_longlong_t softintrs;                   \/* Number of offlevel handlers called. *\/\n+  u_longlong_t phantintrs;                  \/* Number of phantom interrupts. *\/\n+  u_longlong_t idle_donated_purr;           \/* Number of idle cycles donated by a dedicated partition enabled for donation. *\/\n+  u_longlong_t idle_donated_spurr;          \/* Number of idle spurr cycles donated by a dedicated partition enabled for donation. *\/\n+  u_longlong_t busy_donated_purr;           \/* Number of busy cycles donated by a dedicated partition enabled for donation. *\/\n+  u_longlong_t busy_donated_spurr;          \/* Number of busy spurr cycles donated by a dedicated partition enabled for donation. *\/\n+  u_longlong_t idle_stolen_purr;            \/* Number of idle cycles stolen by the hypervisor from a dedicated partition. *\/\n+  u_longlong_t idle_stolen_spurr;           \/* Number of idle spurr cycles stolen by the hypervisor from a dedicated partition. *\/\n+  u_longlong_t busy_stolen_purr;            \/* Number of busy cycles stolen by the hypervisor from a dedicated partition. *\/\n+  u_longlong_t busy_stolen_spurr;           \/* Number of busy spurr cycles stolen by the hypervisor from a dedicated partition.*\/\n+  u_longlong_t shcpus_in_sys;               \/* Number of physical processors allocated for shared processor use, across all shared processors pools. *\/\n+  u_longlong_t entitled_pool_capacity;      \/* Entitled processor capacity of partition’s pool. *\/\n+  u_longlong_t pool_max_time;               \/* Summation of maximum time that can be consumed by the pool (nanoseconds). *\/\n+  u_longlong_t pool_busy_time;              \/* Summation of busy (nonidle) time accumulated across all partitions in the pool (nanoseconds). *\/\n+  u_longlong_t pool_scaled_busy_time;       \/* Scaled summation of busy (nonidle) time accumulated across all partitions in the pool (nanoseconds). *\/\n+  u_longlong_t shcpu_tot_time;              \/* Summation of total time across all physical processors allocated for shared processor use (nanoseconds). *\/\n+  u_longlong_t shcpu_busy_time;             \/* Summation of busy (nonidle) time accumulated across all shared processor partitions (nanoseconds). *\/\n+  u_longlong_t shcpu_scaled_busy_time;      \/* Scaled summation of busy time accumulated across all shared processor partitions (nanoseconds). *\/\n+  int ams_pool_id;                          \/* AMS pool ID of the pool the LPAR belongs to. *\/\n+  int var_mem_weight;                       \/* Variable memory capacity weight. *\/\n+  u_longlong_t iome;                        \/* I\/O memory entitlement of the partition in bytes. *\/\n+  u_longlong_t pmem;                        \/* Physical memory currently backing the partition's logical memory in bytes. *\/\n+  u_longlong_t hpi;                         \/* Number of hypervisor page-ins. *\/\n+  u_longlong_t hpit;                        \/* Time spent in hypervisor page-ins (in nanoseconds). *\/\n+  u_longlong_t hypv_pagesize;               \/* Hypervisor page size in KB. *\/\n+  uint online_lcpus;                        \/* Number of online logical processors. *\/\n+  uint smt_thrds;                           \/* Number of SMT threads. *\/\n+} perfstat_cpu_t;\n+\n+typedef struct {\n+  char name[IDENTIFIER_LENGTH];             \/* Name of the interface. *\/\n+  char description[IDENTIFIER_LENGTH];      \/* Interface description (from ODM, similar to lscfg output). *\/\n+  uchar type;                               \/* Ethernet, token ring, and so on. Interpretation can be done using the \/usr\/include\/net\/if_types.h file. *\/\n+  u_longlong_t mtu;                         \/* Network frame size. *\/\n+  u_longlong_t ipacets;                     \/* Number of packets received on interface. *\/\n+  u_longlong_t ibytes;                      \/* Number of bytes received on interface. *\/\n+  u_longlong_t ierrors;                     \/* Number of input errors on interface. *\/\n+  u_longlong_t opackets;                    \/* Number of packets sent on interface. *\/\n+  u_longlong_t obytes;                      \/* Number of bytes sent on interface. *\/\n+  u_longlong_t oerrors;                     \/* Number of output errors on interface. *\/\n+  u_longlong_t collisions;                  \/* Number of collisions on csma interface. *\/\n+  u_longlong_t bitrate;                     \/* Adapter rating in bit per second. *\/\n+  u_longlong_t if_iqdrops;                  \/* Dropped on input, this interface. *\/\n+  u_longlong_t if_arpdrops;                 \/* Dropped because no arp response. *\/\n+} perfstat_netinterface_t;\n@@ -800,0 +899,32 @@\n+typedef struct {\n+        u_longlong_t version;                 \/* Version number of the data structure. *\/\n+        u_longlong_t pid;                     \/* Process ID. *\/\n+        char proc_name[64];                   \/* Name of the process. *\/\n+        int proc_priority;                    \/* Process priority. *\/\n+        u_longlong_t num_threads;             \/* Thread count. *\/\n+        u_longlong_t proc_uid;                \/* Owner information. *\/\n+        u_longlong_t proc_classid;            \/* WLM class name. *\/\n+        u_longlong_t proc_size;               \/* Virtual size of the process (exclusive usage, leaving all shared library text & shared file pages, shared memory, and memory mapped). *\/\n+        u_longlong_t proc_real_mem_data;      \/* Real memory used for data in KB. *\/\n+        u_longlong_t proc_real_mem_text;      \/* Real memory used for text in KB. *\/\n+        u_longlong_t proc_virt_mem_data;      \/* Virtual memory used for data in KB. *\/\n+        u_longlong_t proc_virt_mem_text;      \/* Virtual memory used for text in KB. *\/\n+        u_longlong_t shared_lib_data_size;    \/* Data size from shared library in KB. *\/\n+        u_longlong_t heap_size;               \/* Heap size in KB. *\/\n+        u_longlong_t real_inuse;              \/* The Real memory (in KB) in use by the process including all kind of segments (excluding system segments). This includes text, data, shared library text, shared library data, file pages, shared memory, and memory mapped. *\/\n+        u_longlong_t virt_inuse;              \/* The virtual memory (in KB) in use by the process including all kind of segments (excluding system segments). This includes text, data, shared library text, shared library data, file pages, shared memory, and memory mapped. *\/\n+        u_longlong_t pinned;                  \/* Pinned memory (in KB) for this process inclusive of all segments. *\/\n+        u_longlong_t pgsp_inuse;              \/* Paging space used (in KB) inclusive of all segments. *\/\n+        u_longlong_t filepages;               \/* File pages used (in KB) including shared pages. *\/\n+        u_longlong_t real_inuse_map;          \/* Real memory used (in KB) for shared memory and memory mapped regions *\/\n+        u_longlong_t virt_inuse_map;          \/* Virtual memory used (in KB) for shared memory and memory mapped regions. *\/\n+        u_longlong_t pinned_inuse_map;        \/* Pinned memory used (in KB) for shared memory and memory mapped regions. *\/\n+        double ucpu_time;                     \/* User mode CPU time is in percentage or milliseconds, which is based on, whether it is filled by perfstat_process_util or perfstat_process respectively. *\/\n+        double scpu_time;                     \/* System mode CPU time is in percentage or milliseconds, which is based on whether it is filled by perfstat_process_util or perfstat_process respectively. *\/\n+        u_longlong_t last_timebase;           \/* Timebase counter. *\/\n+        u_longlong_t inBytes;                 \/* Bytes written to disk. *\/\n+        u_longlong_t outBytes;                \/* Bytes read from disk. *\/\n+        u_longlong_t inOps;                   \/* In operations from disk. *\/\n+        u_longlong_t outOps;                  \/* Out operations from disk *\/\n+} perfstat_process_t;\n+\n@@ -857,3 +988,8 @@\n-#define PERFSTAT_PARTITON_TOTAL_T_LATEST perfstat_partition_total_t_71_1\/* latest perfstat_partition_total_t structure *\/\n-#define PERFSTAT_CPU_TOTAL_T_LATEST perfstat_cpu_total_t_72             \/* latest perfstat_cpu_total_t structure *\/\n-#define PERFSTAT_WPAR_TOTAL_T_LATEST perfstat_wpar_total_t_71           \/* latest perfstat_wpar_total_t structure *\/\n+#define PERFSTAT_PARTITON_TOTAL_T_LATEST perfstat_partition_total_t_71_1 \/* latest perfstat_partition_total_t structure *\/\n+#define PERFSTAT_PROCESS_T_LATEST perfstat_process_t                     \/* latest perfstat_process_t structure *\/\n+#define PERFSTAT_CPU_TOTAL_T_LATEST perfstat_cpu_total_t_72              \/* latest perfstat_cpu_total_t structure *\/\n+#define PERFSTAT_CPU_T_LATEST perfstat_cpu_t                             \/* latest perfstat_cpu_t structure *\/\n+#define PERFSTAT_NETINTERFACE_T_LATEST perfstat_netinterface_t           \/* latest perfstat_netinterface_t structure *\/\n+#define PERFSTAT_WPAR_TOTAL_T_LATEST perfstat_wpar_total_t_71            \/* latest perfstat_wpar_total_t structure *\/\n+\n+typedef PERFSTAT_CPU_TOTAL_T_LATEST perfstat_cpu_total_t;\n@@ -889,0 +1025,8 @@\n+  static int perfstat_cpu(perfstat_id_t *name, PERFSTAT_CPU_T_LATEST* userbuff,\n+                          int sizeof_userbuff, int desired_number);\n+\n+  static int perfstat_process(perfstat_id_t *name, PERFSTAT_PROCESS_T_LATEST* userbuff,\n+                              int sizeof_userbuff, int desired_number);\n+\n+  static int perfstat_netinterface(perfstat_id_t *name, PERFSTAT_NETINTERFACE_T_LATEST* userbuff,\n+                                   int sizeof_userbuff, int desired_number);\n","filename":"src\/hotspot\/os\/aix\/libperfstat_aix.hpp","additions":148,"deletions":4,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -307,0 +307,9 @@\n+static bool copy_list_internal(LoadedModuleList** head) {\n+  *head = nullptr;\n+\n+  for (entry_t* e = g_first; e; e = e->next) {\n+    *head = new LoadedModuleList(e->info, *head);\n+  }\n+\n+  return true;\n+}\n@@ -366,0 +375,14 @@\n+bool LoadedLibraries::copy_list(LoadedModuleList** head) {\n+  MiscUtils::AutoCritSect lck(&g_cs);\n+\n+  if (!g_first) {\n+    if (!reload_table()) {\n+      \/\/ If the table is not loaded and cannot be initialized,\n+      \/\/ then we must quit.\n+      return false;\n+    }\n+  }\n+\n+  return copy_list_internal(head);\n+}\n+\n","filename":"src\/hotspot\/os\/aix\/loadlib_aix.cpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2022, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +36,2 @@\n+#include \"misc_aix.hpp\"\n+\n@@ -71,0 +74,31 @@\n+\/\/ A linked-list storage container for loaded modules\n+class LoadedModuleList {\n+\n+  private:\n+    const loaded_module_t _module;\n+    const LoadedModuleList* _next;\n+\n+  public:\n+    LoadedModuleList(loaded_module_t module, LoadedModuleList* next) :\n+      _module(module),\n+      _next(next)\n+    {}\n+    ~LoadedModuleList() {\n+      if (_next) {\n+        delete _next;\n+      }\n+    }\n+    const LoadedModuleList* next() const {\n+      return _next;\n+    }\n+    const char* get_shortname() const {\n+      return _module.shortname;\n+    }\n+    const uintptr_t get_text_area_base() const {\n+      return (uintptr_t) _module.text;\n+    }\n+    const uintptr_t get_text_area_top() const {\n+      return (uintptr_t) _module.text + _module.text_len;\n+    }\n+};\n+\n@@ -102,0 +136,3 @@\n+    \/\/ Copy information from the current list into a list starting from the given head.\n+    static bool copy_list(LoadedModuleList**);\n+\n","filename":"src\/hotspot\/os\/aix\/loadlib_aix.hpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1134,2 +1134,18 @@\n-  \/\/ Not yet implemented.\n-  return 0;\n+  LoadedModuleList* head = nullptr;\n+\n+  if (!LoadedLibraries::copy_list(&head)) {\n+    return -1;\n+  }\n+\n+  for (const LoadedModuleList* entry = head; entry; entry = entry->next()) {\n+    \/\/ const char* name -> address base -> address top -> void* param -> int\n+    callback(entry->get_shortname(),\n+             (address) entry->get_text_area_base(),\n+             (address) entry->get_text_area_top(),\n+             param);\n+  }\n+\n+  if (!head) {\n+    delete head;\n+  }\n+  return 0; \/\/ What value indicates success (>= 0)?\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-#include \"precompiled.hpp\"\n@@ -27,0 +26,1 @@\n+#include \"libperfstat_aix.hpp\"\n@@ -29,0 +29,1 @@\n+#include \"precompiled.hpp\"\n@@ -34,3 +35,2 @@\n-#include <stdio.h>\n-#include <stdarg.h>\n-#include <unistd.h>\n+#include <dirent.h>\n+#include <dlfcn.h>\n@@ -38,0 +38,4 @@\n+#include <limits.h>\n+#include <pthread.h>\n+#include <stdarg.h>\n+#include <stdio.h>\n@@ -39,0 +43,1 @@\n+#include <sys\/procfs.h>\n@@ -40,1 +45,0 @@\n-#include <sys\/types.h>\n@@ -42,1 +46,1 @@\n-#include <dirent.h>\n+#include <sys\/types.h>\n@@ -44,108 +48,1 @@\n-#include <dlfcn.h>\n-#include <pthread.h>\n-#include <limits.h>\n-\n-\/**\n-   \/proc\/[number]\/stat\n-              Status information about the process.  This is used by ps(1).  It is defined in \/usr\/src\/linux\/fs\/proc\/array.c.\n-\n-              The fields, in order, with their proper scanf(3) format specifiers, are:\n-\n-              1. pid %d The process id.\n-\n-              2. comm %s\n-                     The filename of the executable, in parentheses.  This is visible whether or not the executable is swapped out.\n-\n-              3. state %c\n-                     One  character  from  the  string \"RSDZTW\" where R is running, S is sleeping in an interruptible wait, D is waiting in uninterruptible disk\n-                     sleep, Z is zombie, T is traced or stopped (on a signal), and W is paging.\n-\n-              4. ppid %d\n-                     The PID of the parent.\n-\n-              5. pgrp %d\n-                     The process group ID of the process.\n-\n-              6. session %d\n-                     The session ID of the process.\n-\n-              7. tty_nr %d\n-                     The tty the process uses.\n-\n-              8. tpgid %d\n-                     The process group ID of the process which currently owns the tty that the process is connected to.\n-\n-              9. flags %lu\n-                     The flags of the process.  The math bit is decimal 4, and the traced bit is decimal 10.\n-\n-              10. minflt %lu\n-                     The number of minor faults the process has made which have not required loading a memory page from disk.\n-\n-              11. cminflt %lu\n-                     The number of minor faults that the process's waited-for children have made.\n-\n-              12. majflt %lu\n-                     The number of major faults the process has made which have required loading a memory page from disk.\n-\n-              13. cmajflt %lu\n-                     The number of major faults that the process's waited-for children have made.\n-\n-              14. utime %lu\n-                     The number of jiffies that this process has been scheduled in user mode.\n-\n-              15. stime %lu\n-                     The number of jiffies that this process has been scheduled in kernel mode.\n-\n-              16. cutime %ld\n-                     The number of jiffies that this process's waited-for children have been scheduled in user mode. (See also times(2).)\n-\n-              17. cstime %ld\n-                     The number of jiffies that this process' waited-for children have been scheduled in kernel mode.\n-\n-              18. priority %ld\n-                     The standard nice value, plus fifteen.  The value is never negative in the kernel.\n-\n-              19. nice %ld\n-                     The nice value ranges from 19 (nicest) to -19 (not nice to others).\n-\n-              20. 0 %ld  This value is hard coded to 0 as a placeholder for a removed field.\n-\n-              21. itrealvalue %ld\n-                     The time in jiffies before the next SIGALRM is sent to the process due to an interval timer.\n-\n-              22. starttime %lu\n-                     The time in jiffies the process started after system boot.\n-\n-              23. vsize %lu\n-                     Virtual memory size in bytes.\n-\n-              24. rss %ld\n-                     Resident Set Size: number of pages the process has in real memory, minus 3 for administrative purposes. This is just the pages which  count\n-                     towards text, data, or stack space.  This does not include pages which have not been demand-loaded in, or which are swapped out.\n-\n-              25. rlim %lu\n-                     Current limit in bytes on the rss of the process (usually 4294967295 on i386).\n-\n-              26. startcode %lu\n-                     The address above which program text can run.\n-\n-              27. endcode %lu\n-                     The address below which program text can run.\n-\n-              28. startstack %lu\n-                     The address of the start of the stack.\n-\n-              29. kstkesp %lu\n-                     The current value of esp (stack pointer), as found in the kernel stack page for the process.\n-\n-              30. kstkeip %lu\n-                     The current EIP (instruction pointer).\n-\n-              31. signal %lu\n-                     The bitmap of pending signals (usually 0).\n-\n-              32. blocked %lu\n-                     The bitmap of blocked signals (usually 0, 2 for shells).\n-\n-              33. sigignore %lu\n-                     The bitmap of ignored signals.\n+#include <unistd.h>\n@@ -153,2 +50,6 @@\n-              34. sigcatch %lu\n-                     The bitmap of catched signals.\n+typedef struct {\n+  u_longlong_t  user;\n+  u_longlong_t  sys;\n+  u_longlong_t  idle;\n+  u_longlong_t  wait;\n+} CPUPerfTicks;\n@@ -156,3 +57,4 @@\n-              35. wchan %lu\n-                     This  is the \"channel\" in which the process is waiting.  It is the address of a system call, and can be looked up in a namelist if you need\n-                     a textual name.  (If you have an up-to-date \/etc\/psdatabase, then try ps -l to see the WCHAN field in action.)\n+typedef struct {\n+  double utime;\n+  double stime;\n+} JVMTime;\n@@ -160,2 +62,6 @@\n-              36. nswap %lu\n-                     Number of pages swapped - not maintained.\n+enum {\n+  UNDETECTED,\n+  UNDETECTABLE,\n+  LINUX26_NPTL,\n+  BAREMETAL\n+};\n@@ -163,2 +69,2 @@\n-              37. cnswap %lu\n-                     Cumulative nswap for child processes.\n+static bool initialize_libperfstat() {\n+  static bool is_libperfstat_loaded = false;\n@@ -166,2 +72,3 @@\n-              38. exit_signal %d\n-                     Signal to be sent to parent when we die.\n+  if (!is_libperfstat_loaded) {\n+    is_libperfstat_loaded = libperfstat::init();\n+  }\n@@ -169,2 +76,4 @@\n-              39. processor %d\n-                     CPU number last executed on.\n+  \/\/ If library is still not initialized, assume error.\n+  if (!is_libperfstat_loaded) {\n+    printf(\"Error: failed to load libperfstat (%s)\", dlerror());\n+  }\n@@ -172,0 +81,2 @@\n+  return is_libperfstat_loaded;\n+}\n@@ -173,0 +84,5 @@\n+\/**\n+ * Get info for requested PID from \/proc\/<pid>\/psinfo file\n+ *\/\n+static bool read_psinfo(const u_longlong_t& pid, psinfo_t& psinfo) {\n+  static size_t BUF_LENGTH = 32 + sizeof(u_longlong_t);\n@@ -174,1 +90,3 @@\n- \/\/\/\/\/ SSCANF FORMAT STRING. Copy and use.\n+  FILE* fp;\n+  char buf[BUF_LENGTH];\n+  int len;\n@@ -176,2 +94,3 @@\n-field:        1  2  3  4  5  6  7  8  9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38 39\n-format:       %d %s %c %d %d %d %d %d %lu %lu %lu %lu %lu %lu %lu %ld %ld %ld %ld %ld %ld %lu %lu %ld %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %d %d\n+  memset(buf, 0, BUF_LENGTH);\n+  snprintf(buf, BUF_LENGTH, \"\/proc\/%llu\/psinfo\", pid);\n+  fp = fopen(buf, \"r\");\n@@ -179,0 +98,3 @@\n+  if (!fp) {\n+    return false;\n+  }\n@@ -180,1 +102,3 @@\n-*\/\n+  len = fread(&psinfo, sizeof(char), sizeof(psinfo_t), fp);\n+  return len == sizeof(psinfo_t);\n+}\n@@ -183,7 +107,1 @@\n- * For platforms that have them, when declaring\n- * a printf-style function,\n- *   formatSpec is the parameter number (starting at 1)\n- *       that is the format argument (\"%d pid %s\")\n- *   params is the parameter number where the actual args to\n- *       the format starts. If the args are in a va_list, this\n- *       should be 0.\n+ * Get and set ticks for the specified lcpu\n@@ -191,3 +109,2 @@\n-#ifndef PRINTF_ARGS\n-#  define PRINTF_ARGS(formatSpec,  params) ATTRIBUTE_PRINTF(formatSpec, params)\n-#endif\n+static OSReturn get_lcpu_ticks(perfstat_id_t* lcpu_name, CPUPerfTicks* pticks) {\n+  perfstat_cpu_t lcpu_stats;\n@@ -195,3 +112,3 @@\n-#ifndef SCANF_ARGS\n-#  define SCANF_ARGS(formatSpec,   params) ATTRIBUTE_SCANF(formatSpec, params)\n-#endif\n+  if (!pticks) {\n+    return OS_ERR;\n+  }\n@@ -199,3 +116,8 @@\n-#ifndef _PRINTFMT_\n-#  define _PRINTFMT_\n-#endif\n+  \/\/ populate cpu_stats\n+  if (libperfstat::perfstat_cpu(lcpu_name, &lcpu_stats, sizeof(perfstat_cpu_t), 1) < 1) {\n+    pticks->user = 0;\n+    pticks->sys  = 0;\n+    pticks->idle = 0;\n+    pticks->wait = 0;\n+    return OS_ERR;\n+  }\n@@ -203,3 +125,4 @@\n-#ifndef _SCANFMT_\n-#  define _SCANFMT_\n-#endif\n+  pticks->user = lcpu_stats.user;\n+  pticks->sys  = lcpu_stats.sys;\n+  pticks->idle = lcpu_stats.idle;\n+  pticks->wait = lcpu_stats.wait;\n@@ -207,0 +130,2 @@\n+  return OS_OK;\n+}\n@@ -208,5 +133,6 @@\n-struct CPUPerfTicks {\n-  uint64_t  used;\n-  uint64_t  usedKernel;\n-  uint64_t  total;\n-};\n+\/**\n+ * Return CPU load caused by the currently executing process (the jvm).\n+ *\/\n+static OSReturn get_jvm_load(double* jvm_uload, double* jvm_sload) {\n+  static clock_t ticks_per_sec = sysconf(_SC_CLK_TCK);\n+  static u_longlong_t last_timebase = 0;\n@@ -214,4 +140,3 @@\n-typedef enum {\n-  CPU_LOAD_VM_ONLY,\n-  CPU_LOAD_GLOBAL,\n-} CpuLoadTarget;\n+  perfstat_process_t jvm_stats;\n+  perfstat_id_t name_holder;\n+  u_longlong_t timebase_diff;\n@@ -219,6 +144,1 @@\n-enum {\n-  UNDETECTED,\n-  UNDETECTABLE,\n-  LINUX26_NPTL,\n-  BAREMETAL\n-};\n+  assert(initialize_libperfstat(), \"perfstat lib not available\");\n@@ -226,5 +146,4 @@\n-struct CPUPerfCounters {\n-  int   nProcs;\n-  CPUPerfTicks jvmTicks;\n-  CPUPerfTicks* cpus;\n-};\n+  snprintf(name_holder.name, IDENTIFIER_LENGTH, \"%d\", getpid());\n+  if (libperfstat::perfstat_process(&name_holder, &jvm_stats, sizeof(perfstat_process_t), 1) < 1) {\n+    return OS_ERR;\n+  }\n@@ -232,1 +151,3 @@\n-static double get_cpu_load(int which_logical_cpu, CPUPerfCounters* counters, double* pkernelLoad, CpuLoadTarget target);\n+  \/\/ Update timebase\n+  timebase_diff = jvm_stats.last_timebase - last_timebase;\n+  last_timebase = jvm_stats.last_timebase;\n@@ -234,25 +155,5 @@\n-\/** reads \/proc\/<pid>\/stat data, with some checks and some skips.\n- *  Ensure that 'fmt' does _NOT_ contain the first two \"%d %s\"\n- *\/\n-static int SCANF_ARGS(2, 0) vread_statdata(const char* procfile, _SCANFMT_ const char* fmt, va_list args) {\n-  FILE*f;\n-  int n;\n-  char buf[2048];\n-\n-  if ((f = os::fopen(procfile, \"r\")) == NULL) {\n-    return -1;\n-  }\n-\n-  if ((n = fread(buf, 1, sizeof(buf), f)) != -1) {\n-    char *tmp;\n-\n-    buf[n-1] = '\\0';\n-    \/** skip through pid and exec name. *\/\n-    if ((tmp = strrchr(buf, ')')) != NULL) {\n-      \/\/ skip the ')' and the following space\n-      \/\/ but check that buffer is long enough\n-      tmp += 2;\n-      if (tmp < buf + n) {\n-        n = vsscanf(tmp, fmt, args);\n-      }\n-    }\n+  if (jvm_uload) {\n+    *jvm_uload = jvm_stats.ucpu_time \/ timebase_diff;\n+  }\n+  if (jvm_sload) {\n+    *jvm_sload = jvm_stats.scpu_time \/ timebase_diff;\n@@ -261,3 +162,1 @@\n-  fclose(f);\n-\n-  return n;\n+  return OS_OK;\n@@ -266,3 +165,6 @@\n-static int SCANF_ARGS(2, 3) read_statdata(const char* procfile, _SCANFMT_ const char* fmt, ...) {\n-  int   n;\n-  va_list args;\n+static void update_prev_time(JVMTime* from, JVMTime* to) {\n+  if (from && to) {\n+    to->utime = from->utime;\n+    to->stime = from->stime;\n+  }\n+}\n@@ -270,4 +172,7 @@\n-  va_start(args, fmt);\n-  n = vread_statdata(procfile, fmt, args);\n-  va_end(args);\n-  return n;\n+static void update_prev_ticks(CPUPerfTicks* from, CPUPerfTicks* to) {\n+  if (from && to) {\n+    to->user = from->user;\n+    to->sys  = from->sys;\n+    to->idle = from->idle;\n+    to->wait = from->wait;\n+  }\n@@ -277,2 +182,1 @@\n- * on Linux we got the ticks related information from \/proc\/stat\n- * this does not work on AIX, libperfstat might be an alternative\n+ * Calculate the current system load from current ticks using previous ticks as a starting point.\n@@ -280,3 +184,2 @@\n-static OSReturn get_total_ticks(int which_logical_cpu, CPUPerfTicks* pticks) {\n-  return OS_ERR;\n-}\n+static void calculate_updated_load(CPUPerfTicks* update, CPUPerfTicks* prev, double* load) {\n+  CPUPerfTicks diff;\n@@ -284,5 +187,5 @@\n-\/** read user and system ticks from a named procfile, assumed to be in 'stat' format then. *\/\n-static int read_ticks(const char* procfile, uint64_t* userTicks, uint64_t* systemTicks) {\n-  return read_statdata(procfile, \"%*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u \" UINT64_FORMAT \" \" UINT64_FORMAT,\n-    userTicks, systemTicks);\n-}\n+  if (update && prev && load) {\n+    diff.user = update->user - prev->user;\n+    diff.sys  = update->sys  - prev->sys;\n+    diff.idle = update->idle - prev->idle;\n+    diff.wait = update->wait - prev->wait;\n@@ -290,6 +193,2 @@\n-\/**\n- * Return the number of ticks spent in any of the processes belonging\n- * to the JVM on any CPU.\n- *\/\n-static OSReturn get_jvm_ticks(CPUPerfTicks* pticks) {\n-  return OS_ERR;\n+    *load = 1.0 - diff.idle\/(diff.sys + diff.user + diff.idle + diff.wait);\n+  }\n@@ -299,5 +198,1 @@\n- * Return the load of the CPU as a double. 1.0 means the CPU process uses all\n- * available time for user or system processes, 0.0 means the CPU uses all time\n- * being idle.\n- *\n- * Returns a negative value if there is a problem in determining the CPU load.\n+ * Look up lcpu names for later re-use.\n@@ -305,7 +200,4 @@\n-static double get_cpu_load(int which_logical_cpu, CPUPerfCounters* counters, double* pkernelLoad, CpuLoadTarget target) {\n-  uint64_t udiff, kdiff, tdiff;\n-  CPUPerfTicks* pticks;\n-  CPUPerfTicks  tmp;\n-  double user_load;\n-\n-  *pkernelLoad = 0.0;\n+static bool populate_lcpu_names(int ncpus, perfstat_id_t* lcpu_names) {\n+  perfstat_cpu_t* all_lcpu_stats;\n+  perfstat_cpu_t* lcpu_stats;\n+  perfstat_id_t   name_holder;\n@@ -313,7 +205,2 @@\n-  if (target == CPU_LOAD_VM_ONLY) {\n-    pticks = &counters->jvmTicks;\n-  } else if (-1 == which_logical_cpu) {\n-    pticks = &counters->cpus[counters->nProcs];\n-  } else {\n-    pticks = &counters->cpus[which_logical_cpu];\n-  }\n+  assert(lcpu_names, \"Names pointer NULL\");\n+  assert(initialize_libperfstat(), \"perfstat lib not available\");\n@@ -321,1 +208,1 @@\n-  tmp = *pticks;\n+  strncpy(name_holder.name, FIRST_CPU, IDENTIFIER_LENGTH);\n@@ -323,7 +210,1 @@\n-  if (target == CPU_LOAD_VM_ONLY) {\n-    if (get_jvm_ticks(pticks) != OS_OK) {\n-      return -1.0;\n-    }\n-  } else if (get_total_ticks(which_logical_cpu, pticks) != OS_OK) {\n-    return -1.0;\n-  }\n+  all_lcpu_stats = NEW_RESOURCE_ARRAY(perfstat_cpu_t, ncpus);\n@@ -331,6 +212,4 @@\n-  \/\/ seems like we sometimes end up with less kernel ticks when\n-  \/\/ reading \/proc\/self\/stat a second time, timing issue between cpus?\n-  if (pticks->usedKernel < tmp.usedKernel) {\n-    kdiff = 0;\n-  } else {\n-    kdiff = pticks->usedKernel - tmp.usedKernel;\n+  \/\/ populate cpu_stats && check that the expected number of records have been populated\n+  if (ncpus != libperfstat::perfstat_cpu(&name_holder, all_lcpu_stats, sizeof(perfstat_cpu_t), ncpus)) {\n+    FREE_RESOURCE_ARRAY(perfstat_cpu_t, all_lcpu_stats, ncpus);\n+    return false;\n@@ -338,2 +217,0 @@\n-  tdiff = pticks->total - tmp.total;\n-  udiff = pticks->used - tmp.used;\n@@ -341,4 +218,2 @@\n-  if (tdiff == 0) {\n-    return 0.0;\n-  } else if (tdiff < (udiff + kdiff)) {\n-    tdiff = udiff + kdiff;\n+  for (int n = 0; n < ncpus; n++) {\n+    strncpy(lcpu_names[n].name, all_lcpu_stats[n].name, IDENTIFIER_LENGTH);\n@@ -346,11 +221,0 @@\n-  *pkernelLoad = (kdiff \/ (double)tdiff);\n-  \/\/ BUG9044876, normalize return values to sane values\n-  *pkernelLoad = MAX2<double>(*pkernelLoad, 0.0);\n-  *pkernelLoad = MIN2<double>(*pkernelLoad, 1.0);\n-\n-  user_load = (udiff \/ (double)tdiff);\n-  user_load = MAX2<double>(user_load, 0.0);\n-  user_load = MIN2<double>(user_load, 1.0);\n-\n-  return user_load;\n-}\n@@ -358,11 +222,2 @@\n-static int SCANF_ARGS(1, 2) parse_stat(_SCANFMT_ const char* fmt, ...) {\n-  return OS_ERR;\n-}\n-\n-static int get_noof_context_switches(uint64_t* switches) {\n-  return parse_stat(\"ctxt \" UINT64_FORMAT \"\\n\", switches);\n-}\n-\n-\/** returns boot time in _seconds_ since epoch *\/\n-static int get_boot_time(uint64_t* time) {\n-  return parse_stat(\"btime \" UINT64_FORMAT \"\\n\", time);\n+  FREE_RESOURCE_ARRAY(perfstat_cpu_t, all_lcpu_stats, ncpus);\n+  return true;\n@@ -371,23 +226,6 @@\n-static int perf_context_switch_rate(double* rate) {\n-  static pthread_mutex_t contextSwitchLock = PTHREAD_MUTEX_INITIALIZER;\n-  static uint64_t      bootTime;\n-  static uint64_t      lastTimeNanos;\n-  static uint64_t      lastSwitches;\n-  static double        lastRate;\n-\n-  uint64_t bt = 0;\n-  int res = 0;\n-\n-  \/\/ First time through bootTime will be zero.\n-  if (bootTime == 0) {\n-    uint64_t tmp;\n-    if (get_boot_time(&tmp) < 0) {\n-      return OS_ERR;\n-    }\n-    bt = tmp * 1000;\n-  }\n-\n-  res = OS_OK;\n-\n-  pthread_mutex_lock(&contextSwitchLock);\n-  {\n+\/**\n+ * Calculates the context switch rate.\n+ * (Context Switches \/ Tick) * (Tick \/ s) = Context Switches per second\n+ *\/\n+static OSReturn perf_context_switch_rate(double* rate) {\n+  static clock_t ticks_per_sec = sysconf(_SC_CLK_TCK);\n@@ -395,2 +233,2 @@\n-    uint64_t sw;\n-    s8 t, d;\n+  u_longlong_t ticks;\n+  perfstat_cpu_total_t cpu_stats;\n@@ -398,13 +236,1 @@\n-    if (bootTime == 0) {\n-      \/\/ First interval is measured from boot time which is\n-      \/\/ seconds since the epoch. Thereafter we measure the\n-      \/\/ elapsed time using javaTimeNanos as it is monotonic-\n-      \/\/ non-decreasing.\n-      lastTimeNanos = os::javaTimeNanos();\n-      t = os::javaTimeMillis();\n-      d = t - bt;\n-      \/\/ keep bootTime zero for now to use as a first-time-through flag\n-    } else {\n-      t = os::javaTimeNanos();\n-      d = nanos_to_millis(t - lastTimeNanos);\n-    }\n+  assert(initialize_libperfstat(), \"perfstat lib not available\");\n@@ -412,17 +238,3 @@\n-    if (d == 0) {\n-      *rate = lastRate;\n-    } else if (get_noof_context_switches(&sw) == 0) {\n-      *rate      = ( (double)(sw - lastSwitches) \/ d ) * 1000;\n-      lastRate     = *rate;\n-      lastSwitches = sw;\n-      if (bootTime != 0) {\n-        lastTimeNanos = t;\n-      }\n-    } else {\n-      *rate = 0;\n-      res   = OS_ERR;\n-    }\n-    if (*rate <= 0) {\n-      *rate = 0;\n-      lastRate = 0;\n-    }\n+   if (libperfstat::perfstat_cpu_total(NULL, &cpu_stats, sizeof(perfstat_cpu_total_t), 1) < 0) {\n+     return OS_ERR;\n+   }\n@@ -430,5 +242,2 @@\n-    if (bootTime == 0) {\n-      bootTime = bt;\n-    }\n-  }\n-  pthread_mutex_unlock(&contextSwitchLock);\n+   ticks = cpu_stats.user + cpu_stats.sys + cpu_stats.idle + cpu_stats.wait;\n+   *rate = (cpu_stats.pswitch \/ ticks) * ticks_per_sec;\n@@ -436,1 +245,1 @@\n-  return res;\n+   return OS_OK;\n@@ -440,1 +249,0 @@\n-  friend class CPUPerformanceInterface;\n@@ -442,6 +250,3 @@\n-  CPUPerfCounters _counters;\n-\n-  int cpu_load(int which_logical_cpu, double* cpu_load);\n-  int context_switch_rate(double* rate);\n-  int cpu_load_total_process(double* cpu_load);\n-  int cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad);\n+  int _ncpus;\n+  perfstat_id_t* _lcpu_names;\n+  CPUPerfTicks* _prev_ticks;\n@@ -453,0 +258,5 @@\n+\n+  int cpu_load(int which_logical_cpu, double* cpu_load);\n+  int context_switch_rate(double* rate);\n+  int cpu_load_total_process(double* cpu_load);\n+  int cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad);\n@@ -455,4 +265,4 @@\n-CPUPerformanceInterface::CPUPerformance::CPUPerformance() {\n-  _counters.nProcs = os::active_processor_count();\n-  _counters.cpus = NULL;\n-}\n+CPUPerformanceInterface::CPUPerformance::CPUPerformance():\n+  _ncpus(0),\n+  _lcpu_names(NULL),\n+  _prev_ticks(NULL) {}\n@@ -461,6 +271,1 @@\n-  size_t array_entry_count = _counters.nProcs + 1;\n-  _counters.cpus = NEW_C_HEAP_ARRAY(CPUPerfTicks, array_entry_count, mtInternal);\n-  memset(_counters.cpus, 0, array_entry_count * sizeof(*_counters.cpus));\n-\n-  \/\/ For the CPU load total\n-  get_total_ticks(-1, &_counters.cpus[_counters.nProcs]);\n+  perfstat_cpu_total_t cpu_stats;\n@@ -468,3 +273,2 @@\n-  \/\/ For each CPU\n-  for (int i = 0; i < _counters.nProcs; i++) {\n-    get_total_ticks(i, &_counters.cpus[i]);\n+  if (!initialize_libperfstat()) {\n+    return false;\n@@ -472,2 +276,9 @@\n-  \/\/ For JVM load\n-  get_jvm_ticks(&_counters.jvmTicks);\n+  if (libperfstat::perfstat_cpu_total(NULL, &cpu_stats, sizeof(perfstat_cpu_total_t), 1) < 0) {\n+    return false;\n+  }\n+  if (cpu_stats.ncpus <= 0) {\n+    return false;\n+  }\n+\n+  _ncpus = cpu_stats.ncpus;\n+  _lcpu_names = NEW_C_HEAP_ARRAY(perfstat_id_t, _ncpus, mtInternal);\n@@ -475,4 +286,7 @@\n-  \/\/ initialize context switch system\n-  \/\/ the double is only for init\n-  double init_ctx_switch_rate;\n-  perf_context_switch_rate(&init_ctx_switch_rate);\n+  _prev_ticks = NEW_C_HEAP_ARRAY(CPUPerfTicks, _ncpus, mtInternal);\n+  \/\/ Set all prev-tick values to 0\n+  memset(_prev_ticks, 0, _ncpus*sizeof(CPUPerfTicks));\n+\n+  if (!populate_lcpu_names(_ncpus, _lcpu_names)) {\n+    return false;\n+  }\n@@ -484,2 +298,5 @@\n-  if (_counters.cpus != NULL) {\n-    FREE_C_HEAP_ARRAY(char, _counters.cpus);\n+  if (_lcpu_names) {\n+    FREE_C_HEAP_ARRAY(perfstat_id_t, _lcpu_names);\n+  }\n+  if (_prev_ticks) {\n+    FREE_C_HEAP_ARRAY(CPUPerfTicks, _prev_ticks);\n@@ -489,5 +306,11 @@\n-int CPUPerformanceInterface::CPUPerformance::cpu_load(int which_logical_cpu, double* cpu_load) {\n-  double u, s;\n-  u = get_cpu_load(which_logical_cpu, &_counters, &s, CPU_LOAD_GLOBAL);\n-  if (u < 0) {\n-    *cpu_load = 0.0;\n+\/**\n+ * Get CPU load for all processes on specified logical CPU.\n+ *\/\n+int CPUPerformanceInterface::CPUPerformance::cpu_load(int lcpu_number, double* lcpu_load) {\n+  CPUPerfTicks ticks;\n+\n+  assert(lcpu_load != NULL, \"NULL pointer passed to cpu_load\");\n+  assert(lcpu_number < _ncpus, \"Invalid lcpu passed to cpu_load\");\n+\n+  if (get_lcpu_ticks(&_lcpu_names[lcpu_number], &ticks) == OS_ERR) {\n+    *lcpu_load = -1.0;\n@@ -496,2 +319,4 @@\n-  \/\/ Cap total systemload to 1.0\n-  *cpu_load = MIN2<double>((u + s), 1.0);\n+\n+  calculate_updated_load(&ticks, &_prev_ticks[lcpu_number], lcpu_load);\n+  update_prev_ticks(&ticks, &_prev_ticks[lcpu_number]);\n+\n@@ -501,6 +326,38 @@\n-int CPUPerformanceInterface::CPUPerformance::cpu_load_total_process(double* cpu_load) {\n-  double u, s;\n-  u = get_cpu_load(-1, &_counters, &s, CPU_LOAD_VM_ONLY);\n-  if (u < 0) {\n-    *cpu_load = 0.0;\n-    return OS_ERR;\n+\/**\n+ * Get CPU load for all processes on all CPUs.\n+ *\/\n+int CPUPerformanceInterface::CPUPerformance::cpu_load_total_process(double* total_load) {\n+  CPUPerfTicks total_ticks;\n+  CPUPerfTicks prev_total_ticks;\n+\n+  assert(total_load != NULL, \"NULL pointer passed to cpu_load_total_process\");\n+\n+  total_ticks.user = 0;\n+  total_ticks.sys  = 0;\n+  total_ticks.idle = 0;\n+  total_ticks.wait = 0;\n+\n+  prev_total_ticks.user = 0;\n+  prev_total_ticks.sys  = 0;\n+  prev_total_ticks.idle = 0;\n+  prev_total_ticks.wait = 0;\n+\n+  for (int lcpu = 0; lcpu < _ncpus; lcpu++) {\n+    CPUPerfTicks lcpu_ticks;\n+\n+    if (get_lcpu_ticks(&_lcpu_names[lcpu], &lcpu_ticks) == OS_ERR) {\n+      *total_load = -1.0;\n+      return OS_ERR;\n+    }\n+\n+    total_ticks.user = lcpu_ticks.user;\n+    total_ticks.sys  = lcpu_ticks.sys;\n+    total_ticks.idle = lcpu_ticks.idle;\n+    total_ticks.wait = lcpu_ticks.wait;\n+\n+    prev_total_ticks.user += _prev_ticks[lcpu].user;\n+    prev_total_ticks.sys  += _prev_ticks[lcpu].sys;\n+    prev_total_ticks.idle += _prev_ticks[lcpu].idle;\n+    prev_total_ticks.wait += _prev_ticks[lcpu].wait;\n+\n+    update_prev_ticks(&lcpu_ticks, &_prev_ticks[lcpu]);\n@@ -508,1 +365,3 @@\n-  *cpu_load = u + s;\n+\n+  calculate_updated_load(&total_ticks, &prev_total_ticks, total_load);\n+\n@@ -512,0 +371,11 @@\n+\/**\n+ * Get CPU load for all CPUs.\n+ *\n+ * Set values for:\n+ * - pjvmUserLoad:     CPU load due to jvm process in user mode. Jvm process assumed to be self process\n+ * - pjvmKernelLoad:   CPU load due to jvm process in kernel mode. Jvm process assumed to be self process\n+ * - psystemTotalLoad: Total CPU load from all process on all logical CPUs\n+ *\n+ * Note: If any of the above loads cannot be calculated, this procedure returns OS_ERR and any load that could not be calculated is set to -1\n+ *\n+ *\/\n@@ -513,5 +383,1 @@\n-  double u, s, t;\n-\n-  assert(pjvmUserLoad != NULL, \"pjvmUserLoad not inited\");\n-  assert(pjvmKernelLoad != NULL, \"pjvmKernelLoad not inited\");\n-  assert(psystemTotalLoad != NULL, \"psystemTotalLoad not inited\");\n+  double u, k, t;\n@@ -519,6 +385,3 @@\n-  u = get_cpu_load(-1, &_counters, &s, CPU_LOAD_VM_ONLY);\n-  if (u < 0) {\n-    *pjvmUserLoad = 0.0;\n-    *pjvmKernelLoad = 0.0;\n-    *psystemTotalLoad = 0.0;\n-    return OS_ERR;\n+  int retval = OS_OK;\n+  if (get_jvm_load(&u, &k) == OS_ERR || cpu_load_total_process(&t) == OS_ERR) {\n+    retval = OS_ERR;\n@@ -527,4 +390,8 @@\n-  cpu_load(-1, &t);\n-  \/\/ clamp at user+system and 1.0\n-  if (u + s > t) {\n-    t = MIN2<double>(u + s, 1.0);\n+  if (pjvmUserLoad) {\n+    *pjvmUserLoad = u;\n+  }\n+  if (pjvmKernelLoad) {\n+    *pjvmKernelLoad = k;\n+  }\n+  if (psystemTotalLoad) {\n+    *psystemTotalLoad = t;\n@@ -533,5 +400,1 @@\n-  *pjvmUserLoad = u;\n-  *pjvmKernelLoad = s;\n-  *psystemTotalLoad = t;\n-\n-  return OS_OK;\n+  return retval;\n@@ -576,30 +439,4 @@\n-  friend class SystemProcessInterface;\n- private:\n-  class ProcessIterator : public CHeapObj<mtInternal> {\n-    friend class SystemProcessInterface::SystemProcesses;\n-   private:\n-    DIR*           _dir;\n-    struct dirent* _entry;\n-    bool           _valid;\n-    char           _exeName[PATH_MAX];\n-    char           _exePath[PATH_MAX];\n-\n-    ProcessIterator();\n-    ~ProcessIterator();\n-    bool initialize();\n-\n-    bool is_valid() const { return _valid; }\n-    bool is_valid_entry(struct dirent* entry) const;\n-    bool is_dir(const char* name) const;\n-    int  fsize(const char* name, uint64_t& size) const;\n-\n-    char* allocate_string(const char* str) const;\n-    void  get_exe_name();\n-    char* get_exe_path();\n-    char* get_cmdline();\n-\n-    int current(SystemProcess* process_info);\n-    int next_process();\n-  };\n-\n-  ProcessIterator* _iterator;\n+  private:\n+  char* allocate_string(const char* str) const;\n+\n+  public:\n@@ -609,2 +446,0 @@\n-\n-  \/\/information about system processes\n@@ -614,69 +449,1 @@\n-bool SystemProcessInterface::SystemProcesses::ProcessIterator::is_dir(const char* name) const {\n-  struct stat mystat;\n-  int ret_val = 0;\n-\n-  ret_val = stat(name, &mystat);\n-  if (ret_val < 0) {\n-    return false;\n-  }\n-  ret_val = S_ISDIR(mystat.st_mode);\n-  return ret_val > 0;\n-}\n-\n-int SystemProcessInterface::SystemProcesses::ProcessIterator::fsize(const char* name, uint64_t& size) const {\n-  assert(name != NULL, \"name pointer is NULL!\");\n-  size = 0;\n-  struct stat fbuf;\n-\n-  if (stat(name, &fbuf) < 0) {\n-    return OS_ERR;\n-  }\n-  size = fbuf.st_size;\n-  return OS_OK;\n-}\n-\n-\/\/ if it has a numeric name, is a directory and has a 'stat' file in it\n-bool SystemProcessInterface::SystemProcesses::ProcessIterator::is_valid_entry(struct dirent* entry) const {\n-  char buffer[PATH_MAX];\n-  uint64_t size = 0;\n-\n-  if (atoi(entry->d_name) != 0) {\n-    jio_snprintf(buffer, PATH_MAX, \"\/proc\/%s\", entry->d_name);\n-    buffer[PATH_MAX - 1] = '\\0';\n-\n-    if (is_dir(buffer)) {\n-      jio_snprintf(buffer, PATH_MAX, \"\/proc\/%s\/stat\", entry->d_name);\n-      buffer[PATH_MAX - 1] = '\\0';\n-      if (fsize(buffer, size) != OS_ERR) {\n-        return true;\n-      }\n-    }\n-  }\n-  return false;\n-}\n-\n-\/\/ get exe-name from \/proc\/<pid>\/stat\n-void SystemProcessInterface::SystemProcesses::ProcessIterator::get_exe_name() {\n-  FILE* fp;\n-  char  buffer[PATH_MAX];\n-\n-  jio_snprintf(buffer, PATH_MAX, \"\/proc\/%s\/stat\", _entry->d_name);\n-  buffer[PATH_MAX - 1] = '\\0';\n-  if ((fp = os::fopen(buffer, \"r\")) != NULL) {\n-    if (fgets(buffer, PATH_MAX, fp) != NULL) {\n-      char* start, *end;\n-      \/\/ exe-name is between the first pair of ( and )\n-      start = strchr(buffer, '(');\n-      if (start != NULL && start[1] != '\\0') {\n-        start++;\n-        end = strrchr(start, ')');\n-        if (end != NULL) {\n-          size_t len;\n-          len = MIN2<size_t>(end - start, sizeof(_exeName) - 1);\n-          memcpy(_exeName, start, len);\n-          _exeName[len] = '\\0';\n-        }\n-      }\n-    }\n-    fclose(fp);\n-  }\n+SystemProcessInterface::SystemProcesses::SystemProcesses() {\n@@ -685,35 +452,2 @@\n-\/\/ get command line from \/proc\/<pid>\/cmdline\n-char* SystemProcessInterface::SystemProcesses::ProcessIterator::get_cmdline() {\n-  FILE* fp;\n-  char  buffer[PATH_MAX];\n-  char* cmdline = NULL;\n-\n-  jio_snprintf(buffer, PATH_MAX, \"\/proc\/%s\/cmdline\", _entry->d_name);\n-  buffer[PATH_MAX - 1] = '\\0';\n-  if ((fp = os::fopen(buffer, \"r\")) != NULL) {\n-    size_t size = 0;\n-    char   dummy;\n-\n-    \/\/ find out how long the file is (stat always returns 0)\n-    while (fread(&dummy, 1, 1, fp) == 1) {\n-      size++;\n-    }\n-    if (size > 0) {\n-      cmdline = NEW_C_HEAP_ARRAY(char, size + 1, mtInternal);\n-      cmdline[0] = '\\0';\n-      if (fseek(fp, 0, SEEK_SET) == 0) {\n-        if (fread(cmdline, 1, size, fp) == size) {\n-          \/\/ the file has the arguments separated by '\\0',\n-          \/\/ so we translate '\\0' to ' '\n-          for (size_t i = 0; i < size; i++) {\n-            if (cmdline[i] == '\\0') {\n-              cmdline[i] = ' ';\n-            }\n-          }\n-          cmdline[size] = '\\0';\n-        }\n-      }\n-    }\n-    fclose(fp);\n-  }\n-  return cmdline;\n+bool SystemProcessInterface::SystemProcesses::initialize() {\n+  return initialize_libperfstat();\n@@ -722,7 +456,1 @@\n-\/\/ get full path to exe from \/proc\/<pid>\/exe symlink\n-char* SystemProcessInterface::SystemProcesses::ProcessIterator::get_exe_path() {\n-  char buffer[PATH_MAX];\n-\n-  jio_snprintf(buffer, PATH_MAX, \"\/proc\/%s\/exe\", _entry->d_name);\n-  buffer[PATH_MAX - 1] = '\\0';\n-  return realpath(buffer, _exePath);\n+SystemProcessInterface::SystemProcesses::~SystemProcesses() {\n@@ -731,1 +459,1 @@\n-char* SystemProcessInterface::SystemProcesses::ProcessIterator::allocate_string(const char* str) const {\n+char* SystemProcessInterface::SystemProcesses::allocate_string(const char* str) const {\n@@ -738,4 +466,5 @@\n-int SystemProcessInterface::SystemProcesses::ProcessIterator::current(SystemProcess* process_info) {\n-  if (!is_valid()) {\n-    return OS_ERR;\n-  }\n+int SystemProcessInterface::SystemProcesses::system_processes(SystemProcess** system_processes, int* nprocs) const {\n+  perfstat_process_t* proc_stats;\n+  SystemProcess* head;\n+  perfstat_id_t name_holder;\n+  int records_allocated = 0;\n@@ -743,1 +472,1 @@\n-  process_info->set_pid(atoi(_entry->d_name));\n+  assert(nprocs != NULL, \"system_processes counter pointers is NULL!\");\n@@ -745,2 +474,3 @@\n-  get_exe_name();\n-  process_info->set_name(allocate_string(_exeName));\n+  head = NULL;\n+  *nprocs = 0;\n+  strncpy(name_holder.name, \"\", IDENTIFIER_LENGTH);\n@@ -748,16 +478,4 @@\n-  if (get_exe_path() != NULL) {\n-     process_info->set_path(allocate_string(_exePath));\n-  }\n-\n-  char* cmdline = NULL;\n-  cmdline = get_cmdline();\n-  if (cmdline != NULL) {\n-    process_info->set_command_line(allocate_string(cmdline));\n-    FREE_C_HEAP_ARRAY(char, cmdline);\n-  }\n-\n-  return OS_OK;\n-}\n-\n-int SystemProcessInterface::SystemProcesses::ProcessIterator::next_process() {\n-  if (!is_valid()) {\n+  \/\/ calling perfstat_<subsystem>(NULL, NULL, _, 0) returns number of available records\n+  *nprocs = libperfstat::perfstat_process(NULL, NULL, sizeof(perfstat_process_t), 0);\n+  if(*nprocs < 1) {\n+    \/\/ expect at least 1 process\n@@ -767,18 +485,2 @@\n-  do {\n-    _entry = os::readdir(_dir);\n-    if (_entry == NULL) {\n-      \/\/ Error or reached end.  Could use errno to distinguish those cases.\n-      _valid = false;\n-      return OS_ERR;\n-    }\n-  } while(!is_valid_entry(_entry));\n-\n-  _valid = true;\n-  return OS_OK;\n-}\n-\n-SystemProcessInterface::SystemProcesses::ProcessIterator::ProcessIterator() {\n-  _dir = NULL;\n-  _entry = NULL;\n-  _valid = false;\n-}\n+  records_allocated = *nprocs;\n+  proc_stats = NEW_RESOURCE_ARRAY(perfstat_process_t, records_allocated);\n@@ -786,4 +488,3 @@\n-bool SystemProcessInterface::SystemProcesses::ProcessIterator::initialize() {\n-  \/\/ Not yet implemented.\n-  return false;\n-}\n+  \/\/ populate stats && set the actual number of procs that have been populated\n+  \/\/ should never be higher than requested, but may be lower due to process death\n+  *nprocs = libperfstat::perfstat_process(&name_holder, proc_stats, sizeof(perfstat_process_t), records_allocated);\n@@ -791,5 +492,5 @@\n-SystemProcessInterface::SystemProcesses::ProcessIterator::~ProcessIterator() {\n-  if (_dir != NULL) {\n-    os::closedir(_dir);\n-  }\n-}\n+  for (int n = 0; n < *nprocs; n++) {\n+    psinfo_t psinfo;\n+    char* name     = NEW_C_HEAP_ARRAY(char, IDENTIFIER_LENGTH, mtInternal);\n+    char* exe_name = NEW_C_HEAP_ARRAY(char, PRFNSZ, mtInternal);\n+    char* cmd_line = NEW_C_HEAP_ARRAY(char, PRARGSZ, mtInternal);\n@@ -797,3 +498,1 @@\n-SystemProcessInterface::SystemProcesses::SystemProcesses() {\n-  _iterator = NULL;\n-}\n+    strncpy(name, proc_stats[n].proc_name, IDENTIFIER_LENGTH);\n@@ -801,4 +500,4 @@\n-bool SystemProcessInterface::SystemProcesses::initialize() {\n-  _iterator = new SystemProcessInterface::SystemProcesses::ProcessIterator();\n-  return _iterator->initialize();\n-}\n+    if (read_psinfo(proc_stats[n].pid, psinfo)) {\n+      strncpy(exe_name, psinfo.pr_fname, PRFNSZ);\n+      strncpy(cmd_line, psinfo.pr_psargs, PRARGSZ);\n+    }\n@@ -806,3 +505,8 @@\n-SystemProcessInterface::SystemProcesses::~SystemProcesses() {\n-  if (_iterator != NULL) {\n-    delete _iterator;\n+    \/\/ create a new SystemProcess with next pointing to current head.\n+    SystemProcess* sp = new SystemProcess(proc_stats[n].pid,\n+                                          name,\n+                                          exe_name,\n+                                          cmd_line,\n+                                          head);\n+    \/\/ update head.\n+    head = sp;\n@@ -810,10 +514,0 @@\n-}\n-\n-int SystemProcessInterface::SystemProcesses::system_processes(SystemProcess** system_processes, int* no_of_sys_processes) const {\n-  assert(system_processes != NULL, \"system_processes pointer is NULL!\");\n-  assert(no_of_sys_processes != NULL, \"system_processes counter pointers is NULL!\");\n-  assert(_iterator != NULL, \"iterator is NULL!\");\n-\n-  \/\/ initialize pointers\n-  *no_of_sys_processes = 0;\n-  *system_processes = NULL;\n@@ -821,3 +515,1 @@\n-  while (_iterator->is_valid()) {\n-    SystemProcess* tmp = new SystemProcess();\n-    _iterator->current(tmp);\n+  FREE_RESOURCE_ARRAY(perfstat_process_t, proc_stats, records_allocated);\n@@ -825,12 +517,1 @@\n-    \/\/if already existing head\n-    if (*system_processes != NULL) {\n-      \/\/move \"first to second\"\n-      tmp->set_next(*system_processes);\n-    }\n-    \/\/ new head\n-    *system_processes = tmp;\n-    \/\/ increment\n-    (*no_of_sys_processes)++;\n-    \/\/ step forward\n-    _iterator->next_process();\n-  }\n+  *system_processes = head;\n@@ -900,1 +581,2 @@\n-  friend class NetworkPerformanceInterface;\n+  NONCOPYABLE(NetworkPerformance);\n+\n@@ -902,0 +584,3 @@\n+  char* allocate_string(const char* str) const;\n+\n+  public:\n@@ -903,1 +588,0 @@\n-  NONCOPYABLE(NetworkPerformance);\n@@ -909,3 +593,1 @@\n-NetworkPerformanceInterface::NetworkPerformance::NetworkPerformance() {\n-\n-}\n+NetworkPerformanceInterface::NetworkPerformance::NetworkPerformance() {}\n@@ -914,1 +596,1 @@\n-  return true;\n+  return initialize_libperfstat();\n@@ -917,2 +599,1 @@\n-NetworkPerformanceInterface::NetworkPerformance::~NetworkPerformance() {\n-}\n+NetworkPerformanceInterface::NetworkPerformance::~NetworkPerformance() {}\n@@ -922,1 +603,37 @@\n-  return FUNCTIONALITY_NOT_IMPLEMENTED;\n+  int n_records = 0;\n+  perfstat_netinterface_t* net_stats;\n+  perfstat_id_t name_holder;\n+  int records_allocated = 0;\n+\n+  assert(network_interfaces != NULL, \"network_interfaces is NULL\");\n+\n+  *network_interfaces = NULL;\n+  strncpy(name_holder.name , FIRST_NETINTERFACE, IDENTIFIER_LENGTH);\n+\n+  \/\/ calling perfstat_<subsystem>(NULL, NULL, _, 0) returns number of available records\n+  if ((n_records = libperfstat::perfstat_netinterface(NULL, NULL, sizeof(perfstat_netinterface_t), 0)) <= 0) {\n+    return OS_ERR;\n+  }\n+\n+  records_allocated = n_records;\n+  net_stats = NEW_RESOURCE_ARRAY(perfstat_netinterface_t, records_allocated);\n+\n+  \/\/ populate net_stats && update the number of records that have been populated\n+  n_records = libperfstat::perfstat_netinterface(&name_holder, net_stats, sizeof(perfstat_netinterface_t), n_records);\n+\n+  \/\/ check for error\n+  if (n_records < 0) {\n+    return OS_ERR;\n+  }\n+\n+  for (int i = 0; i < n_records; i++) {\n+    \/\/ Create new Network interface *with current head as next node*\n+    NetworkInterface* new_interface = new NetworkInterface(net_stats[i].name,\n+                                                           net_stats[i].ibytes,\n+                                                           net_stats[i].obytes,\n+                                                           *network_interfaces);\n+    *network_interfaces = new_interface;\n+  }\n+\n+  FREE_RESOURCE_ARRAY(perfstat_netinterface_t, net_stats, records_allocated);\n+  return OS_OK;\n","filename":"src\/hotspot\/os\/aix\/os_perf_aix.cpp","additions":362,"deletions":645,"binary":false,"changes":1007,"status":"modified"},{"patch":"@@ -824,1 +824,1 @@\n-jdk\/jfr\/event\/runtime\/TestNetworkUtilizationEvent.java          8228990 generic-all\n+jdk\/jfr\/event\/runtime\/TestNetworkUtilizationEvent.java          8228990 macoss-all,linux-all,windows-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,0 +80,2 @@\n+        } else if (Platform.isAix()) {\n+            libTemplate = \"lib%s.so\";\n@@ -81,0 +83,1 @@\n+\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestNativeLibrariesEvent.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}