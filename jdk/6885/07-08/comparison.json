{"files":[{"patch":"@@ -415,0 +415,7 @@\n+\n+    if test \"x$TOOLCHAIN_TYPE\" = xxlc; then\n+      # We need '-qminimaltoc' or '-qpic=large -bbigtoc' if the TOC overflows.\n+      # Hotspot now overflows its 64K TOC (currently only for debug),\n+      # so for debug we build with '-qpic=large -bbigtoc'.\n+      DEBUG_CFLAGS_JVM=\"-qpic=large\"\n+    fi\n","filename":"make\/autoconf\/flags-cflags.m4","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,0 +33,3 @@\n+typedef int (*fun_perfstat_cpu_t) (perfstat_id_t *name, PERFSTAT_CPU_T_LATEST* userbuff,\n+                                   int sizeof_userbuff, int desired_number);\n+\n@@ -39,0 +42,7 @@\n+typedef int (*fun_perfstat_netinterface_t) (perfstat_id_t *name, perfstat_netinterface_t* userbuff,\n+                                            int sizeof_userbuff, int desired_number);\n+\n+typedef int (*fun_perfstat_process_t) (perfstat_id_t *name,\n+                                       PERFSTAT_PROCESS_T_LATEST* userbuff, int sizeof_userbuff,\n+                                       int desired_number);\n+\n@@ -51,2 +61,4 @@\n-static fun_perfstat_cpu_total_t     g_fun_perfstat_cpu_total = NULL;\n-static fun_perfstat_memory_total_t  g_fun_perfstat_memory_total = NULL;\n+static fun_perfstat_cpu_total_t       g_fun_perfstat_cpu_total       = NULL;\n+static fun_perfstat_cpu_t             g_fun_perfstat_cpu             = NULL;\n+static fun_perfstat_memory_total_t    g_fun_perfstat_memory_total    = NULL;\n+static fun_perfstat_netinterface_t    g_fun_perfstat_netinterface    = NULL;\n@@ -54,3 +66,4 @@\n-static fun_perfstat_wpar_total_t    g_fun_perfstat_wpar_total = NULL;\n-static fun_perfstat_reset_t         g_fun_perfstat_reset = NULL;\n-static fun_wpar_getcid_t            g_fun_wpar_getcid = NULL;\n+static fun_perfstat_process_t         g_fun_perfstat_process         = NULL;\n+static fun_perfstat_wpar_total_t      g_fun_perfstat_wpar_total      = NULL;\n+static fun_perfstat_reset_t           g_fun_perfstat_reset           = NULL;\n+static fun_wpar_getcid_t              g_fun_wpar_getcid              = NULL;\n@@ -87,0 +100,1 @@\n+  RESOLVE_FUN(perfstat_cpu);\n@@ -88,0 +102,2 @@\n+  RESOLVE_FUN(perfstat_netinterface);\n+  RESOLVE_FUN(perfstat_process);\n@@ -111,0 +127,16 @@\n+int libperfstat::perfstat_cpu_total(perfstat_id_t *name, PERFSTAT_CPU_TOTAL_T_LATEST* userbuff,\n+                                    int sizeof_userbuff, int desired_number) {\n+  if (g_fun_perfstat_cpu_total == NULL) {\n+    return -1;\n+  }\n+  return g_fun_perfstat_cpu_total(name, userbuff, sizeof_userbuff, desired_number);\n+}\n+\n+int libperfstat::perfstat_cpu(perfstat_id_t *name, PERFSTAT_CPU_T_LATEST* userbuff,\n+                              int sizeof_userbuff, int desired_number) {\n+  if (g_fun_perfstat_cpu == NULL) {\n+    return -1;\n+  }\n+  return g_fun_perfstat_cpu(name, userbuff, sizeof_userbuff, desired_number);\n+}\n+\n@@ -120,3 +152,4 @@\n-int libperfstat::perfstat_cpu_total(perfstat_id_t *name, PERFSTAT_CPU_TOTAL_T_LATEST* userbuff,\n-                                    int sizeof_userbuff, int desired_number) {\n-  if (g_fun_perfstat_cpu_total == NULL) {\n+int libperfstat::perfstat_netinterface(perfstat_id_t *name,\n+                                       perfstat_netinterface_t* userbuff,\n+                                       int sizeof_userbuff, int desired_number) {\n+  if (g_fun_perfstat_netinterface == NULL) {\n@@ -125,1 +158,1 @@\n-  return g_fun_perfstat_cpu_total(name, userbuff, sizeof_userbuff, desired_number);\n+  return g_fun_perfstat_netinterface(name, userbuff, sizeof_userbuff, desired_number);\n@@ -136,0 +169,8 @@\n+int libperfstat::perfstat_process(perfstat_id_t *name, perfstat_process_t* userbuff,\n+                                  int sizeof_userbuff, int desired_number) {\n+  if (g_fun_perfstat_process == NULL) {\n+    return -1;\n+  }\n+  return g_fun_perfstat_process(name, userbuff, sizeof_userbuff, desired_number);\n+}\n+\n","filename":"src\/hotspot\/os\/aix\/libperfstat_aix.cpp","additions":50,"deletions":9,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -50,1 +50,3 @@\n-#define IDENTIFIER_LENGTH 64    \/* length of strings included in the structures *\/\n+#define IDENTIFIER_LENGTH  64    \/* length of strings included in the structures *\/\n+#define FIRST_CPU          \"\"    \/* pseudo-name for fist CPU *\/\n+#define FIRST_NETINTERFACE \"\"    \/* pseudo-name for first NETINTERFACE *\/\n@@ -442,0 +444,96 @@\n+typedef struct { \/* component perfstat_cpu_t from AIX 7.2 documentation *\/\n+  char name [IDENTIFIER_LENGTH];            \/* Logical processor name (processor0, processor1,.). *\/\n+  ulong_t state;                            \/* Specifies whether the CPU is offline or online.\n+                                             * (NOTE: The type of 'state' is not specified in the documentation, but\n+                                             * ulong_t is the correct length) *\/\n+  u_longlong_t user;                        \/* Raw number of clock ticks spent in user mode. *\/\n+  u_longlong_t sys;                         \/* Raw number of clock ticks spent in system mode. *\/\n+  u_longlong_t idle;                        \/* Raw number of clock ticks spent idle. *\/\n+  u_longlong_t wait;                        \/* Raw number of clock ticks spent waiting for I\/O. *\/\n+  u_longlong_t pswitch;                     \/* Number of context switches (changes of currently running process). *\/\n+  u_longlong_t syscall;                     \/* Number of system calls executed. *\/\n+  u_longlong_t sysread;                     \/* Number of read system calls executed. *\/\n+  u_longlong_t syswrite;                    \/* Number of write system calls executed. *\/\n+  u_longlong_t sysfork;                     \/* Number of fork system call executed. *\/\n+  u_longlong_t sysexec;                     \/* Number of exec system call executed. *\/\n+  u_longlong_t readch;                      \/* Number of characters transferred with read system call. *\/\n+  u_longlong_t writech;                     \/* Number of characters transferred with write system call. *\/\n+  u_longlong_t bread;                       \/* Number of block reads. *\/\n+  u_longlong_t bwrite;                      \/* Number of block writes. *\/\n+  u_longlong_t lread;                       \/* Number of logical read requests. *\/\n+  u_longlong_t lwrite;                      \/* Number of logical write requests. *\/\n+  u_longlong_t phread;                      \/* Number of physical reads (reads on raw device). *\/\n+  u_longlong_t phwrite;                     \/* Number of physical writes (writes on raw device). *\/\n+  u_longlong_t iget;                        \/* Number of inode lookups. *\/\n+  u_longlong_t namei;                       \/* Number of vnode lookup from a path name. *\/\n+  u_longlong_t dirblk;                      \/* Number of 512-byte blocks reads by the directory search routine to locate an entry for a file. *\/\n+  u_longlong_t msg;                         \/* Number of interprocess communication (IPC) message operations. *\/\n+  u_longlong_t sema;                        \/* Number of IPC semaphore operations. *\/\n+  u_longlong_t minfaults;                   \/* Number of page faults with no I\/O. *\/\n+  u_longlong_t majfaults;                   \/* Number of page faults with disk I\/O. *\/\n+  u_longlong_t puser;                       \/* Raw number of physical processor ticks in user mode. *\/\n+  u_longlong_t psys;                        \/* Raw number of physical processor ticks in system mode. *\/\n+  u_longlong_t pidle;                       \/* Raw number of physical processor ticks idle. *\/\n+  u_longlong_t pwait;                       \/* Raw number of physical processor ticks waiting for I\/O. *\/\n+  u_longlong_t redisp_sd0;                  \/* Number of thread redispatches within the scheduler affinity domain 0. *\/\n+  u_longlong_t redisp_sd1;                  \/* Number of thread redispatches within the scheduler affinity domain 1. *\/\n+  u_longlong_t redisp_sd2;                  \/* Number of thread redispatches within the scheduler affinity domain 2. *\/\n+  u_longlong_t redisp_sd3;                  \/* Number of thread redispatches within the scheduler affinity domain 3. *\/\n+  u_longlong_t redisp_sd4;                  \/* Number of thread redispatches within the scheduler affinity domain 4. *\/\n+  u_longlong_t redisp_sd5;                  \/* Number of thread redispatches within the scheduler affinity domain 5. *\/\n+  u_longlong_t migration_push;              \/* Number of thread migrations from the local runque to another queue due to starvation load balancing. *\/\n+  u_longlong_t migration_S3grq;             \/* Number of thread migrations from the global runque to the local runque resulting in a move across scheduling domain 3. *\/\n+  u_longlong_t migration_S3pull;            \/* Number of thread migrations from another processor's runque resulting in a move across scheduling domain 3. *\/\n+  u_longlong_t invol_cswitch;               \/* Number of involuntary thread context switches. *\/\n+  u_longlong_t vol_cswitch;                 \/* Number of voluntary thread context switches. *\/\n+  u_longlong_t runque;                      \/* Number of threads on the runque. *\/\n+  u_longlong_t bound;                       \/* Number of bound threads. *\/\n+  u_longlong_t decrintrs;                   \/* Number of decrementer interrupts. *\/\n+  u_longlong_t mpcrintrs;                   \/* Number of received interrupts for MPC. *\/\n+  u_longlong_t mpcsintrs;                   \/* Number of sent interrupts for MPC. *\/\n+  u_longlong_t devintrs;                    \/* Number of device interrupts. *\/\n+  u_longlong_t softintrs;                   \/* Number of offlevel handlers called. *\/\n+  u_longlong_t phantintrs;                  \/* Number of phantom interrupts. *\/\n+  u_longlong_t idle_donated_purr;           \/* Number of idle cycles donated by a dedicated partition enabled for donation. *\/\n+  u_longlong_t idle_donated_spurr;          \/* Number of idle spurr cycles donated by a dedicated partition enabled for donation. *\/\n+  u_longlong_t busy_donated_purr;           \/* Number of busy cycles donated by a dedicated partition enabled for donation. *\/\n+  u_longlong_t busy_donated_spurr;          \/* Number of busy spurr cycles donated by a dedicated partition enabled for donation. *\/\n+  u_longlong_t idle_stolen_purr;            \/* Number of idle cycles stolen by the hypervisor from a dedicated partition. *\/\n+  u_longlong_t idle_stolen_spurr;           \/* Number of idle spurr cycles stolen by the hypervisor from a dedicated partition. *\/\n+  u_longlong_t busy_stolen_purr;            \/* Number of busy cycles stolen by the hypervisor from a dedicated partition. *\/\n+  u_longlong_t busy_stolen_spurr;           \/* Number of busy spurr cycles stolen by the hypervisor from a dedicated partition.*\/\n+  u_longlong_t shcpus_in_sys;               \/* Number of physical processors allocated for shared processor use, across all shared processors pools. *\/\n+  u_longlong_t entitled_pool_capacity;      \/* Entitled processor capacity of partition’s pool. *\/\n+  u_longlong_t pool_max_time;               \/* Summation of maximum time that can be consumed by the pool (nanoseconds). *\/\n+  u_longlong_t pool_busy_time;              \/* Summation of busy (nonidle) time accumulated across all partitions in the pool (nanoseconds). *\/\n+  u_longlong_t pool_scaled_busy_time;       \/* Scaled summation of busy (nonidle) time accumulated across all partitions in the pool (nanoseconds). *\/\n+  u_longlong_t shcpu_tot_time;              \/* Summation of total time across all physical processors allocated for shared processor use (nanoseconds). *\/\n+  u_longlong_t shcpu_busy_time;             \/* Summation of busy (nonidle) time accumulated across all shared processor partitions (nanoseconds). *\/\n+  u_longlong_t shcpu_scaled_busy_time;      \/* Scaled summation of busy time accumulated across all shared processor partitions (nanoseconds). *\/\n+  int ams_pool_id;                          \/* AMS pool ID of the pool the LPAR belongs to. *\/\n+  int var_mem_weight;                       \/* Variable memory capacity weight. *\/\n+  u_longlong_t iome;                        \/* I\/O memory entitlement of the partition in bytes. *\/\n+  u_longlong_t pmem;                        \/* Physical memory currently backing the partition's logical memory in bytes. *\/\n+  u_longlong_t hpi;                         \/* Number of hypervisor page-ins. *\/\n+  u_longlong_t hpit;                        \/* Time spent in hypervisor page-ins (in nanoseconds). *\/\n+  u_longlong_t hypv_pagesize;               \/* Hypervisor page size in KB. *\/\n+  uint online_lcpus;                        \/* Number of online logical processors. *\/\n+  uint smt_thrds;                           \/* Number of SMT threads. *\/\n+} perfstat_cpu_t;\n+\n+typedef struct {\n+  char name[IDENTIFIER_LENGTH];             \/* Name of the interface. *\/\n+  char description[IDENTIFIER_LENGTH];      \/* Interface description (from ODM, similar to lscfg output). *\/\n+  uchar type;                               \/* Ethernet, token ring, and so on. Interpretation can be done using the \/usr\/include\/net\/if_types.h file. *\/\n+  u_longlong_t mtu;                         \/* Network frame size. *\/\n+  u_longlong_t ipacets;                     \/* Number of packets received on interface. *\/\n+  u_longlong_t ibytes;                      \/* Number of bytes received on interface. *\/\n+  u_longlong_t ierrors;                     \/* Number of input errors on interface. *\/\n+  u_longlong_t opackets;                    \/* Number of packets sent on interface. *\/\n+  u_longlong_t obytes;                      \/* Number of bytes sent on interface. *\/\n+  u_longlong_t oerrors;                     \/* Number of output errors on interface. *\/\n+  u_longlong_t collisions;                  \/* Number of collisions on csma interface. *\/\n+  u_longlong_t bitrate;                     \/* Adapter rating in bit per second. *\/\n+  u_longlong_t if_iqdrops;                  \/* Dropped on input, this interface. *\/\n+  u_longlong_t if_arpdrops;                 \/* Dropped because no arp response. *\/\n+} perfstat_netinterface_t;\n@@ -800,0 +898,32 @@\n+typedef struct {\n+        u_longlong_t version;                 \/* Version number of the data structure. *\/\n+        u_longlong_t pid;                     \/* Process ID. *\/\n+        char proc_name[64];                   \/* Name of the process. *\/\n+        int proc_priority;                    \/* Process priority. *\/\n+        u_longlong_t num_threads;             \/* Thread count. *\/\n+        u_longlong_t proc_uid;                \/* Owner information. *\/\n+        u_longlong_t proc_classid;            \/* WLM class name. *\/\n+        u_longlong_t proc_size;               \/* Virtual size of the process (exclusive usage, leaving all shared library text & shared file pages, shared memory, and memory mapped). *\/\n+        u_longlong_t proc_real_mem_data;      \/* Real memory used for data in KB. *\/\n+        u_longlong_t proc_real_mem_text;      \/* Real memory used for text in KB. *\/\n+        u_longlong_t proc_virt_mem_data;      \/* Virtual memory used for data in KB. *\/\n+        u_longlong_t proc_virt_mem_text;      \/* Virtual memory used for text in KB. *\/\n+        u_longlong_t shared_lib_data_size;    \/* Data size from shared library in KB. *\/\n+        u_longlong_t heap_size;               \/* Heap size in KB. *\/\n+        u_longlong_t real_inuse;              \/* The Real memory (in KB) in use by the process including all kind of segments (excluding system segments). This includes text, data, shared library text, shared library data, file pages, shared memory, and memory mapped. *\/\n+        u_longlong_t virt_inuse;              \/* The virtual memory (in KB) in use by the process including all kind of segments (excluding system segments). This includes text, data, shared library text, shared library data, file pages, shared memory, and memory mapped. *\/\n+        u_longlong_t pinned;                  \/* Pinned memory (in KB) for this process inclusive of all segments. *\/\n+        u_longlong_t pgsp_inuse;              \/* Paging space used (in KB) inclusive of all segments. *\/\n+        u_longlong_t filepages;               \/* File pages used (in KB) including shared pages. *\/\n+        u_longlong_t real_inuse_map;          \/* Real memory used (in KB) for shared memory and memory mapped regions *\/\n+        u_longlong_t virt_inuse_map;          \/* Virtual memory used (in KB) for shared memory and memory mapped regions. *\/\n+        u_longlong_t pinned_inuse_map;        \/* Pinned memory used (in KB) for shared memory and memory mapped regions. *\/\n+        double ucpu_time;                     \/* User mode CPU time is in percentage or milliseconds, which is based on, whether it is filled by perfstat_process_util or perfstat_process respectively. *\/\n+        double scpu_time;                     \/* System mode CPU time is in percentage or milliseconds, which is based on whether it is filled by perfstat_process_util or perfstat_process respectively. *\/\n+        u_longlong_t last_timebase;           \/* Timebase counter. *\/\n+        u_longlong_t inBytes;                 \/* Bytes written to disk. *\/\n+        u_longlong_t outBytes;                \/* Bytes read from disk. *\/\n+        u_longlong_t inOps;                   \/* In operations from disk. *\/\n+        u_longlong_t outOps;                  \/* Out operations from disk *\/\n+} perfstat_process_t;\n+\n@@ -857,3 +987,8 @@\n-#define PERFSTAT_PARTITON_TOTAL_T_LATEST perfstat_partition_total_t_71_1\/* latest perfstat_partition_total_t structure *\/\n-#define PERFSTAT_CPU_TOTAL_T_LATEST perfstat_cpu_total_t_72             \/* latest perfstat_cpu_total_t structure *\/\n-#define PERFSTAT_WPAR_TOTAL_T_LATEST perfstat_wpar_total_t_71           \/* latest perfstat_wpar_total_t structure *\/\n+#define PERFSTAT_PARTITON_TOTAL_T_LATEST perfstat_partition_total_t_71_1 \/* latest perfstat_partition_total_t structure *\/\n+#define PERFSTAT_PROCESS_T_LATEST perfstat_process_t                     \/* latest perfstat_process_t structure *\/\n+#define PERFSTAT_CPU_TOTAL_T_LATEST perfstat_cpu_total_t_72              \/* latest perfstat_cpu_total_t structure *\/\n+#define PERFSTAT_CPU_T_LATEST perfstat_cpu_t                             \/* latest perfstat_cpu_t structure *\/\n+#define PERFSTAT_NETINTERFACE_T_LATEST perfstat_netinterface_t           \/* latest perfstat_netinterface_t structure *\/\n+#define PERFSTAT_WPAR_TOTAL_T_LATEST perfstat_wpar_total_t_71            \/* latest perfstat_wpar_total_t structure *\/\n+\n+typedef PERFSTAT_CPU_TOTAL_T_LATEST perfstat_cpu_total_t;\n@@ -889,0 +1024,8 @@\n+  static int perfstat_cpu(perfstat_id_t *name, PERFSTAT_CPU_T_LATEST* userbuff,\n+                          int sizeof_userbuff, int desired_number);\n+\n+  static int perfstat_process(perfstat_id_t *name, PERFSTAT_PROCESS_T_LATEST* userbuff,\n+                              int sizeof_userbuff, int desired_number);\n+\n+  static int perfstat_netinterface(perfstat_id_t *name, PERFSTAT_NETINTERFACE_T_LATEST* userbuff,\n+                                   int sizeof_userbuff, int desired_number);\n","filename":"src\/hotspot\/os\/aix\/libperfstat_aix.hpp","additions":147,"deletions":4,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -307,0 +307,9 @@\n+static bool copy_list_internal(LoadedModuleList** head) {\n+  *head = nullptr;\n+\n+  for (entry_t* e = g_first; e; e = e->next) {\n+    *head = new LoadedModuleList(e->info, *head);\n+  }\n+\n+  return true;\n+}\n@@ -366,0 +375,14 @@\n+bool LoadedLibraries::copy_list(LoadedModuleList** head) {\n+  MiscUtils::AutoCritSect lck(&g_cs);\n+\n+  if (!g_first) {\n+    if (!reload_table()) {\n+      \/\/ If the table is not loaded and cannot be initialized,\n+      \/\/ then we must quit.\n+      return false;\n+    }\n+  }\n+\n+  return copy_list_internal(head);\n+}\n+\n","filename":"src\/hotspot\/os\/aix\/loadlib_aix.cpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+#include \"misc_aix.hpp\"\n+\n@@ -71,0 +73,31 @@\n+\/\/ A linked-list storage container for loaded modules\n+class LoadedModuleList {\n+\n+  private:\n+    const loaded_module_t _module;\n+    const LoadedModuleList* _next;\n+\n+  public:\n+    LoadedModuleList(loaded_module_t module, LoadedModuleList* next) :\n+      _module(module),\n+      _next(next)\n+    {}\n+    ~LoadedModuleList() {\n+      if (_next) {\n+        delete _next;\n+      }\n+    }\n+    const LoadedModuleList* next() const {\n+      return _next;\n+    }\n+    const char* get_shortname() const {\n+      return _module.shortname;\n+    }\n+    const uintptr_t get_text_area_base() const {\n+      return (uintptr_t) _module.text;\n+    }\n+    const uintptr_t get_text_area_top() const {\n+      return (uintptr_t) _module.text + _module.text_len;\n+    }\n+};\n+\n@@ -102,0 +135,3 @@\n+    \/\/ Copy information from the current list into a list starting from the given head.\n+    static bool copy_list(LoadedModuleList**);\n+\n","filename":"src\/hotspot\/os\/aix\/loadlib_aix.hpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+#include <sys\/ldr.h>\n@@ -1134,2 +1135,20 @@\n-  \/\/ Not yet implemented.\n-  return 0;\n+  LoadedModuleList* head = nullptr;\n+\n+  if (!LoadedLibraries::copy_list(&head)) {\n+    return -1;\n+  }\n+\n+  for (const LoadedModuleList* entry = head; entry; entry = entry->next()) {\n+    \/\/ TODO: Populate base and top addr\n+    \/\/ const char* name -> address base -> address top -> void* param -> int\n+    callback(entry->get_shortname(),\n+             (address) entry->get_text_area_base(),\n+             (address) entry->get_text_area_top(),\n+             param);\n+  }\n+\n+  \/\/ TODO: does callback keep reference to any of these items?\n+  if (!head) {\n+    delete head;\n+  }\n+  return 0; \/\/ What value indicates success (>= 0)?\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"precompiled.hpp\"\n@@ -27,0 +26,1 @@\n+#include \"libperfstat_aix.hpp\"\n@@ -29,0 +29,1 @@\n+#include \"precompiled.hpp\"\n@@ -34,3 +35,2 @@\n-#include <stdio.h>\n-#include <stdarg.h>\n-#include <unistd.h>\n+#include <dirent.h>\n+#include <dlfcn.h>\n@@ -38,0 +38,4 @@\n+#include <limits.h>\n+#include <pthread.h>\n+#include <stdarg.h>\n+#include <stdio.h>\n@@ -39,0 +43,1 @@\n+#include <sys\/procfs.h>\n@@ -40,1 +45,0 @@\n-#include <sys\/types.h>\n@@ -42,1 +46,1 @@\n-#include <dirent.h>\n+#include <sys\/types.h>\n@@ -44,5 +48,1 @@\n-#include <dlfcn.h>\n-#include <pthread.h>\n-#include <limits.h>\n-#include <libperfstat.h>\n-#include <sys\/procfs.h>\n+#include <unistd.h>\n@@ -69,0 +69,37 @@\n+static bool initialize_libperfstat() {\n+  static bool is_libperfstat_loaded = false;\n+\n+  if (!is_libperfstat_loaded) {\n+    is_libperfstat_loaded = libperfstat::init();\n+  }\n+\n+  \/\/ If library is still not initialized, assume error.\n+  if (!is_libperfstat_loaded) {\n+    printf(\"Error: failed to load libperfstat (%s)\", dlerror());\n+  }\n+\n+  return is_libperfstat_loaded;\n+}\n+\n+\/**\n+ * Get info for requested PID from \/proc\/<pid>\/psinfo file\n+ *\/\n+static bool read_psinfo(const u_longlong_t& pid, psinfo_t& psinfo) {\n+  static size_t BUF_LENGTH = 32 + sizeof(u_longlong_t);\n+\n+  FILE* fp;\n+  char buf[BUF_LENGTH];\n+  int len;\n+\n+  memset(buf, 0, BUF_LENGTH);\n+  snprintf(buf, BUF_LENGTH, \"\/proc\/%llu\/psinfo\", pid);\n+  fp = fopen(buf, \"r\");\n+\n+  if (!fp) {\n+    return false;\n+  }\n+\n+  len = fread(&psinfo, sizeof(char), sizeof(psinfo_t), fp);\n+  return len == sizeof(psinfo_t);\n+}\n+\n@@ -80,1 +117,1 @@\n-  if (perfstat_cpu(lcpu_name, &lcpu_stats, sizeof(perfstat_cpu_t), 1) < 1) {\n+  if (libperfstat::perfstat_cpu(lcpu_name, &lcpu_stats, sizeof(perfstat_cpu_t), 1) < 1) {\n@@ -107,0 +144,2 @@\n+  assert(initialize_libperfstat(), \"perfstat lib not available\");\n+\n@@ -108,1 +147,1 @@\n-  if (perfstat_process(&name_holder, &jvm_stats, sizeof(perfstat_process_t), 1) < 1) {\n+  if (libperfstat::perfstat_process(&name_holder, &jvm_stats, sizeof(perfstat_process_t), 1) < 1) {\n@@ -161,1 +200,1 @@\n-static void populate_lcpu_names(int ncpus, perfstat_id_t* lcpu_names) {\n+bool populate_lcpu_names(int ncpus, perfstat_id_t* lcpu_names) {\n@@ -167,0 +206,1 @@\n+  assert(initialize_libperfstat(), \"perfstat lib not available\");\n@@ -170,1 +210,1 @@\n-  all_lcpu_stats = (perfstat_cpu_t*) NEW_RESOURCE_ARRAY(perfstat_cpu_t, ncpus);\n+  all_lcpu_stats = NEW_RESOURCE_ARRAY(perfstat_cpu_t, ncpus);\n@@ -173,1 +213,1 @@\n-  if (ncpus > perfstat_cpu(&name_holder, all_lcpu_stats, sizeof(perfstat_cpu_t), ncpus)) {\n+  if (ncpus != libperfstat::perfstat_cpu(&name_holder, all_lcpu_stats, sizeof(perfstat_cpu_t), ncpus)) {\n@@ -175,2 +215,1 @@\n-    lcpu_names = NULL;\n-    return;\n+    return false;\n@@ -179,1 +218,1 @@\n-  for (int n=0; n < ncpus; n++) {\n+  for (int n = 0; n < ncpus; n++) {\n@@ -184,0 +223,1 @@\n+  return true;\n@@ -196,1 +236,3 @@\n-   if (perfstat_cpu_total(NULL, &cpu_stats, sizeof(perfstat_cpu_total_t), 1) < 0) {\n+  assert(initialize_libperfstat(), \"perfstat lib not available\");\n+\n+   if (libperfstat::perfstat_cpu_total(NULL, &cpu_stats, sizeof(perfstat_cpu_total_t), 1) < 0) {\n@@ -231,2 +273,8 @@\n-   if (perfstat_cpu_total(NULL, &cpu_stats, sizeof(perfstat_cpu_total_t), 1) < 0) {\n-     return false;\n+  if (!initialize_libperfstat()) {\n+    return false;\n+  }\n+  if (libperfstat::perfstat_cpu_total(NULL, &cpu_stats, sizeof(perfstat_cpu_total_t), 1) < 0) {\n+    return false;\n+  }\n+  if (cpu_stats.ncpus <= 0) {\n+    return false;\n@@ -236,1 +284,0 @@\n-\n@@ -238,1 +285,0 @@\n-  populate_lcpu_names(_ncpus, _lcpu_names);\n@@ -240,1 +286,1 @@\n-  _prev_ticks = NEW_C_HEAP_ARRAY(CPUPerfTicks,  _ncpus, mtInternal);\n+  _prev_ticks = NEW_C_HEAP_ARRAY(CPUPerfTicks, _ncpus, mtInternal);\n@@ -242,6 +288,4 @@\n-  \/\/ memset(_prev_ticks, 0, _ncpus*sizeof(CPUPerfTicks));\n-  for (int n = 0; n < _ncpus; n++) {\n-    _prev_ticks[n].user = 0;\n-    _prev_ticks[n].sys  = 0;\n-    _prev_ticks[n].idle = 0;\n-    _prev_ticks[n].wait = 0;\n+  memset(_prev_ticks, 0, _ncpus*sizeof(CPUPerfTicks));\n+\n+  if (!populate_lcpu_names(_ncpus, _lcpu_names)) {\n+    return false;\n@@ -250,1 +294,1 @@\n-  return _lcpu_names != NULL;\n+  return true;\n@@ -257,0 +301,3 @@\n+  if (_prev_ticks) {\n+    FREE_C_HEAP_ARRAY(CPUPerfTicks, _prev_ticks);\n+  }\n@@ -303,1 +350,0 @@\n-      printf(\"Error: Could not calculate load for lcpu %s\\n\", _lcpu_names[lcpu].name);\n@@ -407,1 +453,1 @@\n-  return true;\n+  return initialize_libperfstat();\n@@ -424,1 +470,1 @@\n-  int records_requested;\n+  int records_allocated = 0;\n@@ -426,1 +472,0 @@\n-  assert(system_processes != NULL, \"system_processes pointer is NULL!\");\n@@ -434,1 +479,1 @@\n-  *nprocs = perfstat_process(NULL, NULL, sizeof(perfstat_process_t), 0);\n+  *nprocs = libperfstat::perfstat_process(NULL, NULL, sizeof(perfstat_process_t), 0);\n@@ -440,2 +485,2 @@\n-  records_requested = *nprocs;\n-  proc_stats = (perfstat_process_t*) NEW_RESOURCE_ARRAY(perfstat_process_t, records_requested);\n+  records_allocated = *nprocs;\n+  proc_stats = NEW_RESOURCE_ARRAY(perfstat_process_t, records_allocated);\n@@ -445,1 +490,1 @@\n-  *nprocs = perfstat_process(&name_holder, proc_stats, sizeof(perfstat_process_t), records_requested);\n+  *nprocs = libperfstat::perfstat_process(&name_holder, proc_stats, sizeof(perfstat_process_t), records_allocated);\n@@ -448,0 +493,1 @@\n+    psinfo_t psinfo;\n@@ -449,2 +495,2 @@\n-    char* path     = NEW_C_HEAP_ARRAY(char, IDENTIFIER_LENGTH, mtInternal);\n-    char* cmd_line = NEW_C_HEAP_ARRAY(char, IDENTIFIER_LENGTH, mtInternal);\n+    char* exe_name = NEW_C_HEAP_ARRAY(char, PRFNSZ, mtInternal);\n+    char* cmd_line = NEW_C_HEAP_ARRAY(char, PRARGSZ, mtInternal);\n@@ -453,3 +499,5 @@\n-    \/\/ TODO: Read \/proc\/<pid>\/psinfo for additional data to populate the fields below\n-    strncpy(path,     \"\", IDENTIFIER_LENGTH);\n-    strncpy(cmd_line, \"\", IDENTIFIER_LENGTH);\n+\n+    if (read_psinfo(proc_stats[n].pid, psinfo)) {\n+      strncpy(exe_name, psinfo.pr_fname, PRFNSZ);\n+      strncpy(cmd_line, psinfo.pr_psargs, PRARGSZ);\n+    }\n@@ -460,1 +508,1 @@\n-                                          path,\n+                                          exe_name,\n@@ -467,1 +515,1 @@\n-  FREE_RESOURCE_ARRAY(perfstat_process_t, proc_stats, records_requested);\n+  FREE_RESOURCE_ARRAY(perfstat_process_t, proc_stats, records_allocated);\n@@ -547,1 +595,3 @@\n-bool NetworkPerformanceInterface::NetworkPerformance::initialize() { return true; }\n+bool NetworkPerformanceInterface::NetworkPerformance::initialize() {\n+  return initialize_libperfstat();\n+}\n@@ -556,0 +606,1 @@\n+  int records_allocated = 0;\n@@ -563,2 +614,1 @@\n-  n_records = perfstat_netinterface(NULL, NULL, sizeof(perfstat_netinterface_t), 0);\n-  if (n_records < 0) {\n+  if ((n_records = libperfstat::perfstat_netinterface(NULL, NULL, sizeof(perfstat_netinterface_t), 0)) <= 0) {\n@@ -568,1 +618,5 @@\n-  net_stats = NEW_RESOURCE_ARRAY(perfstat_netinterface_t, n_records);\n+  records_allocated = n_records;\n+  net_stats = NEW_RESOURCE_ARRAY(perfstat_netinterface_t, records_allocated);\n+\n+  \/\/ populate net_stats && update the number of records that have been populated\n+  n_records = libperfstat::perfstat_netinterface(&name_holder, net_stats, sizeof(perfstat_netinterface_t), n_records);\n@@ -570,3 +624,2 @@\n-  \/\/ populate net_stats && check that the expected number of records have been populated\n-  if (n_records > (perfstat_netinterface(&name_holder, net_stats, sizeof(perfstat_netinterface_t), n_records))) {\n-    FREE_RESOURCE_ARRAY(perfstat_netinterface_t, net_stats, n_records);\n+  \/\/ check for error\n+  if (n_records < 0) {\n@@ -585,1 +638,1 @@\n-  FREE_RESOURCE_ARRAY(perfstat_netinterface_t, net_stats, n_records);\n+  FREE_RESOURCE_ARRAY(perfstat_netinterface_t, net_stats, records_allocated);\n","filename":"src\/hotspot\/os\/aix\/os_perf_aix.cpp","additions":108,"deletions":55,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -180,0 +180,1 @@\n+  assert(system_processes != NULL, \"system_processes pointer is NULL!\");\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}