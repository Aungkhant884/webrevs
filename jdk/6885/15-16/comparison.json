{"files":[{"patch":"@@ -113,5 +113,0 @@\n-\/\/ struct entry_t {\n-\/\/   entry_t* next;\n-\/\/   loaded_module_t info;\n-\/\/ };\n-\n@@ -324,12 +319,0 @@\n-\/\/ Helper for copying loaded module info to external callers.\n-\/\/ To avoid dangling pointers 'next' is set to null\n-static bool copy_lm_to_external(const loaded_module_t* const from, loaded_module_t* to) {\n-  if (!to || !from) {\n-    return false;\n-  }\n-\n-  memcpy(to, from, sizeof(loaded_module_t));\n-  to->next = nullptr;\n-  return true;\n-}\n-\n@@ -365,0 +348,1 @@\n+\n@@ -366,3 +350,2 @@\n-  if (lm) {\n-    copy_lm_to_external(lm, info);\n-    return true;\n+  if (!lm) {\n+    return false;\n@@ -370,1 +353,6 @@\n-  return false;\n+\n+  if (info) {\n+    memcpy(info, lm, sizeof(loaded_module_t));\n+    info->next = nullptr;\n+  }\n+  return true;\n@@ -382,0 +370,1 @@\n+\n@@ -383,3 +372,7 @@\n-  if (lm) {\n-    copy_lm_to_external(lm, info);\n-    return true;\n+  if (!lm) {\n+    return false;\n+  }\n+\n+  if (info) {\n+    memcpy(info, lm, sizeof(loaded_module_t));\n+    info->next = nullptr;\n@@ -387,1 +380,1 @@\n-  return false;\n+  return true;\n","filename":"src\/hotspot\/os\/aix\/loadlib_aix.cpp","additions":18,"deletions":25,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"utilities\/debug.hpp\"\n+#include \"precompiled.hpp\"\n@@ -31,1 +31,0 @@\n-#include \"precompiled.hpp\"\n@@ -35,0 +34,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -57,1 +57,1 @@\n-} CPUPerfTicks;\n+} cpu_tick_store_t;\n@@ -62,1 +62,1 @@\n-} JVMTime;\n+} jvm_time_store_t;\n@@ -71,15 +71,0 @@\n-static bool initialize_libperfstat() {\n-  static bool is_libperfstat_loaded = false;\n-\n-  if (!is_libperfstat_loaded) {\n-    is_libperfstat_loaded = libperfstat::init();\n-  }\n-\n-  \/\/ If library is still not initialized, assume error.\n-  if (!is_libperfstat_loaded) {\n-    printf(\"Error: failed to load libperfstat (%s)\", dlerror());\n-  }\n-\n-  return is_libperfstat_loaded;\n-}\n-\n@@ -110,1 +95,1 @@\n-static OSReturn get_lcpu_ticks(perfstat_id_t* lcpu_name, CPUPerfTicks* pticks) {\n+static OSReturn get_lcpu_ticks(perfstat_id_t* lcpu_name, cpu_tick_store_t* pticks) {\n@@ -119,1 +104,1 @@\n-    memset(pticks, 0, sizeof(CPUPerfTicks));\n+    memset(pticks, 0, sizeof(cpu_tick_store_t));\n@@ -142,2 +127,0 @@\n-  assert(initialize_libperfstat(), \"perfstat lib not available\");\n-\n@@ -163,1 +146,1 @@\n-static void update_prev_time(JVMTime* from, JVMTime* to) {\n+static void update_prev_time(jvm_time_store_t* from, jvm_time_store_t* to) {\n@@ -165,2 +148,1 @@\n-    to->utime = from->utime;\n-    to->stime = from->stime;\n+    memcpy(to, from, sizeof(jvm_time_store_t));\n@@ -170,1 +152,1 @@\n-static void update_prev_ticks(CPUPerfTicks* from, CPUPerfTicks* to) {\n+static void update_prev_ticks(cpu_tick_store_t* from, cpu_tick_store_t* to) {\n@@ -172,4 +154,1 @@\n-    to->user = from->user;\n-    to->sys  = from->sys;\n-    to->idle = from->idle;\n-    to->wait = from->wait;\n+    memcpy(to, from, sizeof(cpu_tick_store_t));\n@@ -182,2 +161,2 @@\n-static void calculate_updated_load(CPUPerfTicks* update, CPUPerfTicks* prev, double* load) {\n-  CPUPerfTicks diff;\n+static void calculate_updated_load(cpu_tick_store_t* update, cpu_tick_store_t* prev, double* load) {\n+  cpu_tick_store_t diff;\n@@ -205,1 +184,0 @@\n-  assert(initialize_libperfstat(), \"perfstat lib not available\");\n@@ -211,1 +189,1 @@\n-  \/\/ populate cpu_stats && check that the expected number of records have been populated\n+  \/\/ If perfstat_cpu does not return the expected number of names, signal error to caller\n@@ -233,2 +211,0 @@\n-  assert(initialize_libperfstat(), \"perfstat lib not available\");\n-\n@@ -249,1 +225,1 @@\n-  CPUPerfTicks* _prev_ticks;\n+  cpu_tick_store_t* _prev_ticks;\n@@ -270,3 +246,0 @@\n-  if (!initialize_libperfstat()) {\n-    return false;\n-  }\n@@ -283,1 +256,1 @@\n-  _prev_ticks = NEW_C_HEAP_ARRAY(CPUPerfTicks, _ncpus, mtInternal);\n+  _prev_ticks = NEW_C_HEAP_ARRAY(cpu_tick_store_t, _ncpus, mtInternal);\n@@ -285,1 +258,1 @@\n-  memset(_prev_ticks, 0, _ncpus*sizeof(CPUPerfTicks));\n+  memset(_prev_ticks, 0, _ncpus*sizeof(cpu_tick_store_t));\n@@ -299,1 +272,1 @@\n-    FREE_C_HEAP_ARRAY(CPUPerfTicks, _prev_ticks);\n+    FREE_C_HEAP_ARRAY(cpu_tick_store_t, _prev_ticks);\n@@ -307,1 +280,1 @@\n-  CPUPerfTicks ticks;\n+  cpu_tick_store_t ticks;\n@@ -327,2 +300,2 @@\n-  CPUPerfTicks total_ticks;\n-  CPUPerfTicks prev_total_ticks;\n+  cpu_tick_store_t total_ticks;\n+  cpu_tick_store_t prev_total_ticks;\n@@ -332,9 +305,2 @@\n-  total_ticks.user = 0;\n-  total_ticks.sys  = 0;\n-  total_ticks.idle = 0;\n-  total_ticks.wait = 0;\n-\n-  prev_total_ticks.user = 0;\n-  prev_total_ticks.sys  = 0;\n-  prev_total_ticks.idle = 0;\n-  prev_total_ticks.wait = 0;\n+  memset(&total_ticks, 0, sizeof(cpu_tick_store_t));\n+  memset(&prev_total_ticks, 0, sizeof(cpu_tick_store_t));\n@@ -343,1 +309,1 @@\n-    CPUPerfTicks lcpu_ticks;\n+    cpu_tick_store_t lcpu_ticks;\n@@ -450,2 +416,1 @@\n-  return initialize_libperfstat();\n-\n+  return true;\n@@ -493,0 +458,1 @@\n+    \/\/ Note: SystemProcess with free these in its dtor.\n@@ -593,1 +559,1 @@\n-  return initialize_libperfstat();\n+  return true;\n@@ -599,1 +565,0 @@\n-  ResourceMark rm;\n@@ -611,1 +576,1 @@\n-  if ((n_records = libperfstat::perfstat_netinterface(NULL, NULL, sizeof(perfstat_netinterface_t), 0)) <= 0) {\n+  if ((n_records = libperfstat::perfstat_netinterface(NULL, NULL, sizeof(perfstat_netinterface_t), 0)) < 0) {\n@@ -616,1 +581,1 @@\n-  net_stats = NEW_RESOURCE_ARRAY(perfstat_netinterface_t, records_allocated);\n+  net_stats = NEW_C_HEAP_ARRAY(perfstat_netinterface_t, records_allocated, mtInternal);\n@@ -618,1 +583,0 @@\n-  \/\/ populate net_stats && update the number of records that have been populated\n@@ -623,0 +587,1 @@\n+    FREE_C_HEAP_ARRAY(perfstat_netinterface_t, net_stats);\n@@ -628,0 +593,4 @@\n+    \/\/ Note: NetworkInterface makes copies of these string values into RA memory\n+    \/\/ this means:\n+    \/\/ (1) we are free to clean our values upon exiting this proc\n+    \/\/ (2) we avoid using RA-alloced memory here (ie. do not use NEW_RESOURCE_ARRAY)\n@@ -635,0 +604,1 @@\n+  FREE_C_HEAP_ARRAY(perfstat_netinterface_t, net_stats);\n","filename":"src\/hotspot\/os\/aix\/os_perf_aix.cpp","additions":34,"deletions":64,"binary":false,"changes":98,"status":"modified"}]}