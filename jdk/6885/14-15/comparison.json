{"files":[{"patch":"@@ -113,4 +113,4 @@\n-struct entry_t {\n-  entry_t* next;\n-  loaded_module_t info;\n-};\n+\/\/ struct entry_t {\n+\/\/   entry_t* next;\n+\/\/   loaded_module_t info;\n+\/\/ };\n@@ -118,2 +118,1 @@\n-static void print_entry(const entry_t* e, outputStream* os) {\n-  const loaded_module_t* const lm = &(e->info);\n+static void print_entry(const loaded_module_t* lm, outputStream* os) {\n@@ -132,1 +131,1 @@\n-static entry_t* g_first = NULL;\n+static loaded_module_t* g_first = NULL;\n@@ -134,5 +133,5 @@\n-static entry_t* find_entry_for_text_address(const void* p) {\n-  for (entry_t* e = g_first; e; e = e->next) {\n-    if ((uintptr_t)p >= (uintptr_t)e->info.text &&\n-        (uintptr_t)p < ((uintptr_t)e->info.text + e->info.text_len)) {\n-      return e;\n+static loaded_module_t* find_entry_for_text_address(const void* p) {\n+  for (loaded_module_t* lm = g_first; lm; lm = lm->next) {\n+    if ((uintptr_t)p >= (uintptr_t)lm->text &&\n+        (uintptr_t)p < ((uintptr_t)lm->text + lm->text_len)) {\n+      return lm;\n@@ -144,5 +143,5 @@\n-static entry_t* find_entry_for_data_address(const void* p) {\n-  for (entry_t* e = g_first; e; e = e->next) {\n-    if ((uintptr_t)p >= (uintptr_t)e->info.data &&\n-        (uintptr_t)p < ((uintptr_t)e->info.data + e->info.data_len)) {\n-      return e;\n+static loaded_module_t* find_entry_for_data_address(const void* p) {\n+  for (loaded_module_t* lm = g_first; lm; lm = lm->next) {\n+    if ((uintptr_t)p >= (uintptr_t)lm->data &&\n+        (uintptr_t)p < ((uintptr_t)lm->data + lm->data_len)) {\n+      return lm;\n@@ -155,6 +154,6 @@\n-static void add_entry_to_list(entry_t* e, entry_t** start) {\n-  entry_t* last = NULL;\n-  entry_t* e2 = *start;\n-  while (e2 && e2->info.text < e->info.text) {\n-    last = e2;\n-    e2 = e2->next;\n+static void add_entry_to_list(loaded_module_t* lm, loaded_module_t** start) {\n+  loaded_module_t* last = NULL;\n+  loaded_module_t* lm2 = *start;\n+  while (lm2 && lm2->text < lm->text) {\n+    last = lm2;\n+    lm2 = lm2->next;\n@@ -163,1 +162,1 @@\n-    last->next = e;\n+    last->next = lm;\n@@ -165,1 +164,1 @@\n-    *start = e;\n+    *start = lm;\n@@ -167,1 +166,1 @@\n-  e->next = e2;\n+  lm->next = lm2;\n@@ -170,6 +169,6 @@\n-static void free_entry_list(entry_t** start) {\n-  entry_t* e = *start;\n-  while (e) {\n-    entry_t* const e2 = e->next;\n-    ::free(e);\n-    e = e2;\n+static void free_entry_list(loaded_module_t** start) {\n+  loaded_module_t* lm = *start;\n+  while (lm) {\n+    loaded_module_t* const lm2 = lm->next;\n+    ::free(lm);\n+    lm = lm2;\n@@ -189,1 +188,1 @@\n-  entry_t* new_list = NULL;\n+  loaded_module_t* new_list = NULL;\n@@ -217,2 +216,2 @@\n-    entry_t* e = (entry_t*) ::malloc(sizeof(entry_t));\n-    if (!e) {\n+    loaded_module_t* lm = (loaded_module_t*) ::malloc(sizeof(loaded_module_t));\n+    if (!lm) {\n@@ -223,1 +222,1 @@\n-    memset(e, 0, sizeof(entry_t));\n+    memset(lm, 0, sizeof(loaded_module_t));\n@@ -225,4 +224,4 @@\n-    e->info.text = ldi->ldinfo_textorg;\n-    e->info.text_len = ldi->ldinfo_textsize;\n-    e->info.data = ldi->ldinfo_dataorg;\n-    e->info.data_len = ldi->ldinfo_datasize;\n+    lm->text     = ldi->ldinfo_textorg;\n+    lm->text_len = ldi->ldinfo_textsize;\n+    lm->data     = ldi->ldinfo_dataorg;\n+    lm->data_len = ldi->ldinfo_datasize;\n@@ -230,2 +229,2 @@\n-    e->info.path = g_stringlist.add(ldi->ldinfo_filename);\n-    if (!e->info.path) {\n+    lm->path = g_stringlist.add(ldi->ldinfo_filename);\n+    if (!lm->path) {\n@@ -238,1 +237,1 @@\n-      const char* p = strrchr(e->info.path, '\/');\n+      const char* p = strrchr(lm->path, '\/');\n@@ -241,1 +240,1 @@\n-        e->info.shortname = p;\n+        lm->shortname = p;\n@@ -243,1 +242,1 @@\n-        e->info.shortname = e->info.path;\n+        lm->shortname = lm->path;\n@@ -251,2 +250,2 @@\n-      e->info.member = g_stringlist.add(p_mbr_name);\n-      if (!e->info.member) {\n+      lm->member = g_stringlist.add(p_mbr_name);\n+      if (!lm->member) {\n@@ -257,1 +256,1 @@\n-      e->info.member = NULL;\n+      lm->member = NULL;\n@@ -260,1 +259,1 @@\n-    if (strcmp(e->info.shortname, \"libjvm.so\") == 0) {\n+    if (strcmp(lm->shortname, \"libjvm.so\") == 0) {\n@@ -264,1 +263,1 @@\n-      e->info.is_in_vm = true;\n+      lm->is_in_vm = true;\n@@ -268,5 +267,5 @@\n-      e->info.text, e->info.text_len,\n-      e->info.data, e->info.data_len,\n-      e->info.path, e->info.shortname,\n-      (e->info.member ? e->info.member : \"NULL\"),\n-      e->info.is_in_vm\n+      lm->text, lm->text_len,\n+      lm->data, lm->data_len,\n+      lm->path, lm->shortname,\n+      (lm->member ? lm->member : \"NULL\"),\n+      lm->is_in_vm\n@@ -276,1 +275,1 @@\n-    add_entry_to_list(e, &new_list);\n+    add_entry_to_list(lm, &new_list);\n@@ -307,2 +306,14 @@\n-static bool copy_list_internal(LoadedModuleList** head) {\n-  *head = nullptr;\n+\/\/ Callback for loaded module information (from os.hpp)\n+\/\/ Input parameters:\n+\/\/    char*     module_file_name,\n+\/\/    address   module_base_addr,\n+\/\/    address   module_top_addr,\n+\/\/    void*     param\n+static bool for_each_internal(os::LoadedModulesCallbackFunc cb, void* param) {\n+\n+  for (const loaded_module_t* lm = g_first; lm; lm = lm->next) {\n+    (*cb)(lm->shortname,\n+          (address) lm->text,\n+          (address) lm->text + lm->text_len,\n+          param);\n+  }\n@@ -310,2 +321,8 @@\n-  for (entry_t* e = g_first; e; e = e->next) {\n-    *head = new LoadedModuleList(e->info, *head);\n+  return true;\n+}\n+\n+\/\/ Helper for copying loaded module info to external callers.\n+\/\/ To avoid dangling pointers 'next' is set to null\n+static bool copy_lm_to_external(const loaded_module_t* const from, loaded_module_t* to) {\n+  if (!to || !from) {\n+    return false;\n@@ -314,0 +331,2 @@\n+  memcpy(to, from, sizeof(loaded_module_t));\n+  to->next = nullptr;\n@@ -334,2 +353,2 @@\n-  for (entry_t* e = g_first; e; e = e->next) {\n-    print_entry(e, os);\n+  for (loaded_module_t* lm = g_first; lm; lm = lm->next) {\n+    print_entry(lm, os);\n@@ -346,5 +365,3 @@\n-  const entry_t* const e = find_entry_for_text_address(p);\n-  if (e) {\n-    if (info) {\n-      *info = e->info;\n-    }\n+  const loaded_module_t* const lm = find_entry_for_text_address(p);\n+  if (lm) {\n+    copy_lm_to_external(lm, info);\n@@ -365,5 +382,3 @@\n-  const entry_t* const e = find_entry_for_data_address(p);\n-  if (e) {\n-    if (info) {\n-      *info = e->info;\n-    }\n+  const loaded_module_t* const lm = find_entry_for_data_address(p);\n+  if (lm) {\n+    copy_lm_to_external(lm, info);\n@@ -375,1 +390,1 @@\n-bool LoadedLibraries::copy_list(LoadedModuleList** head) {\n+bool LoadedLibraries::for_each(os::LoadedModulesCallbackFunc cb, void* param) {\n@@ -386,1 +401,1 @@\n-  return copy_list_internal(head);\n+  return for_each_internal(cb, param);\n","filename":"src\/hotspot\/os\/aix\/loadlib_aix.cpp","additions":89,"deletions":74,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -72,8 +73,2 @@\n-};\n-\n-\/\/ A linked-list storage container for loaded modules\n-class LoadedModuleList {\n-\n-  private:\n-    const loaded_module_t _module;\n-    const LoadedModuleList* _next;\n+  \/\/ Next item in the list, or NULL if no such item exits\n+  loaded_module_t* next;\n@@ -81,22 +76,0 @@\n-  public:\n-    LoadedModuleList(loaded_module_t module, LoadedModuleList* next) :\n-      _module(module),\n-      _next(next)\n-    {}\n-    ~LoadedModuleList() {\n-      if (_next) {\n-        delete _next;\n-      }\n-    }\n-    const LoadedModuleList* next() const {\n-      return _next;\n-    }\n-    const char* get_shortname() const {\n-      return _module.shortname;\n-    }\n-    const uintptr_t get_text_area_base() const {\n-      return (uintptr_t) _module.text;\n-    }\n-    const uintptr_t get_text_area_top() const {\n-      return (uintptr_t) _module.text + _module.text_len;\n-    }\n@@ -136,2 +109,3 @@\n-    \/\/ Copy information from the current list into a list starting from the given head.\n-    static bool copy_list(LoadedModuleList**);\n+    \/\/ Apply the callback to each loaded_module_t in the list\n+    \/\/ Return false if module table is empty and cannot be loaded.\n+    static bool for_each(os::LoadedModulesCallbackFunc cb, void* param);\n@@ -141,0 +115,1 @@\n+\n","filename":"src\/hotspot\/os\/aix\/loadlib_aix.hpp","additions":7,"deletions":32,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1134,1 +1134,0 @@\n-  LoadedModuleList* head = nullptr;\n@@ -1136,1 +1135,1 @@\n-  if (!LoadedLibraries::copy_list(&head)) {\n+  if (!LoadedLibraries::for_each(callback, param)) {\n@@ -1140,12 +1139,1 @@\n-  for (const LoadedModuleList* entry = head; entry; entry = entry->next()) {\n-    \/\/ const char* name -> address base -> address top -> void* param -> int\n-    callback(entry->get_shortname(),\n-             (address) entry->get_text_area_base(),\n-             (address) entry->get_text_area_top(),\n-             param);\n-  }\n-\n-  if (!head) {\n-    delete head;\n-  }\n-  return 0; \/\/ What value indicates success (>= 0)?\n+  return 0;\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -28,0 +29,1 @@\n+#include \"memory\/resourceArea.hpp\"\n@@ -94,2 +96,1 @@\n-  memset(buf, 0, BUF_LENGTH);\n-  snprintf(buf, BUF_LENGTH, \"\/proc\/%llu\/psinfo\", pid);\n+  jio_snprintf(buf, BUF_LENGTH, \"\/proc\/%llu\/psinfo\", pid);\n@@ -102,1 +103,1 @@\n-  len = fread(&psinfo, sizeof(char), sizeof(psinfo_t), fp);\n+  len = fread(&psinfo, 1, sizeof(psinfo_t), fp);\n@@ -118,4 +119,1 @@\n-    pticks->user = 0;\n-    pticks->sys  = 0;\n-    pticks->idle = 0;\n-    pticks->wait = 0;\n+    memset(pticks, 0, sizeof(CPUPerfTicks));\n@@ -146,1 +144,1 @@\n-  snprintf(name_holder.name, IDENTIFIER_LENGTH, \"%d\", getpid());\n+  jio_snprintf(name_holder.name, IDENTIFIER_LENGTH, \"%d\", getpid());\n@@ -201,0 +199,1 @@\n+  ResourceMark rm;\n@@ -214,1 +213,0 @@\n-    FREE_RESOURCE_ARRAY(perfstat_cpu_t, all_lcpu_stats, ncpus);\n@@ -222,1 +220,0 @@\n-  FREE_RESOURCE_ARRAY(perfstat_cpu_t, all_lcpu_stats, ncpus);\n@@ -468,0 +465,1 @@\n+  ResourceMark rm;\n@@ -516,2 +514,0 @@\n-  FREE_RESOURCE_ARRAY(perfstat_process_t, proc_stats, records_allocated);\n-\n@@ -602,2 +598,2 @@\n-int NetworkPerformanceInterface::NetworkPerformance::network_utilization(NetworkInterface** network_interfaces) const\n-{\n+int NetworkPerformanceInterface::NetworkPerformance::network_utilization(NetworkInterface** network_interfaces) const {\n+  ResourceMark rm;\n@@ -639,1 +635,0 @@\n-  FREE_RESOURCE_ARRAY(perfstat_netinterface_t, net_stats, records_allocated);\n","filename":"src\/hotspot\/os\/aix\/os_perf_aix.cpp","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -823,1 +823,1 @@\n-jdk\/jfr\/event\/runtime\/TestNetworkUtilizationEvent.java          8228990 macoss-all,linux-all,windows-all\n+jdk\/jfr\/event\/runtime\/TestNetworkUtilizationEvent.java          8228990 macosx-all,linux-all,windows-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}