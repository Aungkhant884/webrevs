{"files":[{"patch":"@@ -575,3 +575,12 @@\n-    \/\/ Wrapper function around AES-GCM interleaved intrinsic that splits\n-    \/\/ large chunks of data into 1MB sized chunks. This is to place\n-    \/\/ an upper limit on the number of blocks encrypted in the intrinsic.\n+    \/**\n+     * Wrapper method around Combined AES-GCM intrinsic that splits\n+     * large chunks of data into 1MB sized chunks. This is to place\n+     * an upper limit on the number of blocks encrypted in the intrinsic.\n+     *\n+     * For decrypting in-place byte[], calling methods must ct must set to null\n+     * to avoid combined intrinsic, call GHASH directly before GCTR to avoid\n+     * a bad tag exception. This check is not performed here because it would\n+     * impose a check every operation which is less efficient.\n+     *\n+     * The value of ctOfs is irrelevant if ct is null.\n+     *\/\n@@ -583,1 +592,2 @@\n-        if (inLen > SPLIT_LEN) {\n+        if (inLen > SPLIT_LEN && ct != null) {\n+            int partlen;\n@@ -585,1 +595,1 @@\n-                int partlen = implGCMCrypt0(in, inOfs + len, SPLIT_LEN, ct,\n+                partlen = implGCMCrypt0(in, inOfs + len, SPLIT_LEN, ct,\n@@ -591,0 +601,1 @@\n+\n@@ -592,2 +603,7 @@\n-            len += implGCMCrypt0(in, inOfs + len, inLen, ct,\n-                   ctOfs + len, out, outOfs + len, gctr, ghash);\n+            if (ct == null) {\n+                ghash.update(in, inOfs + len, inLen);\n+                len += gctr.update(in, inOfs + len, inLen, out, outOfs);\n+            } else {\n+                len += implGCMCrypt0(in, inOfs + len, inLen, ct,\n+                    ctOfs + len, out, outOfs + len, gctr, ghash);\n+            }\n@@ -597,0 +613,1 @@\n+\n@@ -598,3 +615,2 @@\n-     * Intrinsic for Vector AES Galois Counter Mode implementation.\n-     * AES and GHASH operations are interleaved in the intrinsic implementation.\n-     * return - number of processed bytes\n+     * Intrinsic for the combined AES Galois Counter Mode implementation.\n+     * AES and GHASH operations are combined in the intrinsic implementation.\n@@ -605,0 +621,7 @@\n+     *\n+     * Note:\n+     * Only Intel processors with AVX512 that support vaes, vpclmulqdq,\n+     * avx512dq, and avx512vl trigger this intrinsic.\n+     * Other processors will always use GHASH and GCTR which may have their own\n+     * intrinsic support\n+     *\n@@ -613,1 +636,1 @@\n-     * @param ghash object for the ghash operation\n+     * @param ghash object for the GHASH operation\n@@ -669,0 +692,5 @@\n+        \/\/ True if op is in-place array decryption with the input & output\n+        \/\/ offset the same or the input greater.  This is to avoid the combined\n+        \/\/ intrinsic.\n+        boolean inPlaceArray = false;\n+\n@@ -732,6 +760,25 @@\n-                ByteBuffer ct = (encryption ? dst : src);\n-                len = GaloisCounterMode.implGCMCrypt(src.array(),\n-                    src.arrayOffset() + src.position(), srcLen,\n-                    ct.array(), ct.arrayOffset() + ct.position(),\n-                    dst.array(), dst.arrayOffset() + dst.position(),\n-                    gctr, ghash);\n+                byte[] array;\n+                if (encryption) {\n+                    array = dst.array();\n+                    int ofs = dst.arrayOffset() + dst.position();\n+                    len = GaloisCounterMode.implGCMCrypt(src.array(),\n+                        src.arrayOffset() + src.position(), srcLen,\n+                        array, ofs, array, ofs, gctr, ghash);\n+                } else {\n+                    array = src.array();\n+                    \/\/ Don't use 'inPlaceArray' here as the src maybe ibuffer\n+                    \/\/ eventhough doFinal() may have been given in-place heap\n+                    \/\/ bytebuffers\n+                    if (array == dst.array()) {\n+                        len = GaloisCounterMode.implGCMCrypt(array,\n+                            src.arrayOffset() + src.position(), srcLen,\n+                            null, 0, array, dst.arrayOffset() + dst.position(),\n+                            gctr, ghash);\n+                    } else {\n+                        int ofs = src.arrayOffset() + src.position();\n+                        len = GaloisCounterMode.implGCMCrypt(array, ofs, srcLen,\n+                            array, ofs, dst.array(),\n+                            dst.arrayOffset() + dst.position(), gctr, ghash);\n+                    }\n+                }\n+\n@@ -945,0 +992,2 @@\n+                \/\/ NOTE: inPlaceArray does not apply here as direct buffers run\n+                \/\/ through a byte[] to get to the combined intrinsic\n@@ -962,3 +1011,5 @@\n-                    \/\/ used.  But during decryption always create a new\n-                    \/\/ buffer in case of a bad auth tag.\n-                    if (encryption && src.position() + src.arrayOffset() >=\n+                    \/\/ used.\n+                    \/\/ Set 'inPlaceArray' true for decryption operations to\n+                    \/\/ avoid the combined intrinsic.  Creating a temp buffer to\n+                    \/\/ use with the combined intrinsic degrades performance.\n+                    if (src.position() + src.arrayOffset() >=\n@@ -966,0 +1017,1 @@\n+                        inPlaceArray = (!encryption);\n@@ -987,1 +1039,1 @@\n-         * This is used for both overlap detection for the data or  decryption\n+         * This is used for both overlap detection for the data or decryption\n@@ -995,4 +1047,7 @@\n-            if (in == out && (!encryption || inOfs < outOfs)) {\n-                originalOut = out;\n-                originalOutOfs = outOfs;\n-                return new byte[out.length];\n+            if (in == out) {\n+                if (inOfs < outOfs) {\n+                    originalOut = out;\n+                    originalOutOfs = outOfs;\n+                    return new byte[out.length];\n+                }\n+                inPlaceArray = (!encryption);\n@@ -1499,2 +1554,5 @@\n-                \/\/ Clear output data\n-                Arrays.fill(out, outOfs, outOfs + len, (byte) 0);\n+                \/\/ If this is an in-place array, don't zero the input\n+                if (!inPlaceArray) {\n+                    \/\/ Clear output data\n+                    Arrays.fill(out, outOfs, outOfs + len, (byte) 0);\n+                }\n@@ -1584,6 +1642,9 @@\n-                if (dst.hasArray()) {\n-                    int ofs = dst.arrayOffset() + dst.position();\n-                    Arrays.fill(dst.array(), ofs , ofs + len, (byte)0);\n-                } else {\n-                    Unsafe.getUnsafe().setMemory(((DirectBuffer)dst).address(),\n-                        len + dst.position(), (byte)0);\n+                \/\/ If this is no an in-place array, zero the dst buffer\n+                if (!inPlaceArray) {\n+                    if (dst.hasArray()) {\n+                        int ofs = dst.arrayOffset() + dst.position();\n+                        Arrays.fill(dst.array(), ofs, ofs + len, (byte) 0);\n+                    } else {\n+                        Unsafe.getUnsafe().setMemory(((DirectBuffer) dst).address(),\n+                            len + dst.position(), (byte) 0);\n+                    }\n@@ -1800,2 +1861,5 @@\n-                len += implGCMCrypt(in, inOfs, inLen, in, inOfs, out, outOfs,\n-                    gctr, ghash);\n+                \/\/ Since GCMDecrypt.inPlaceArray cannot be accessed, check that\n+                \/\/ 'in' and 'out' are the same.  All other in-place situations\n+                \/\/ have been resolved by overlapDetection()\n+                len += implGCMCrypt(in, inOfs, inLen, (in == out ? null : in),\n+                    inOfs, out, outOfs, gctr, ghash);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":99,"deletions":35,"binary":false,"changes":134,"status":"modified"}]}