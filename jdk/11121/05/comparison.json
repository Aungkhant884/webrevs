{"files":[{"patch":"@@ -579,3 +579,9 @@\n-    \/\/ Wrapper function around AES-GCM interleaved intrinsic that splits\n-    \/\/ large chunks of data into 1MB sized chunks. This is to place\n-    \/\/ an upper limit on the number of blocks encrypted in the intrinsic.\n+    \/**\n+     * Wrapper function around Combined AES-GCM intrinsic method that splits\n+     * large chunks of data into 1MB sized chunks. This is to place\n+     * an upper limit on the number of blocks encrypted in the intrinsic.\n+     *\n+     * The combined intrinsic is not used when decrypting in-place heap\n+     * bytebuffers because 'ct' will be the same as 'in' and overwritten by\n+     * GCTR before GHASH calculates the encrypted tag.\n+     *\/\n@@ -587,1 +593,3 @@\n-        if (inLen > SPLIT_LEN) {\n+        \/\/ Loop if input length is greater than the SPLIT_LEN\n+        if (inLen > SPLIT_LEN && ct != null) {\n+            int partlen;\n@@ -589,1 +597,1 @@\n-                int partlen = implGCMCrypt0(in, inOfs + len, SPLIT_LEN, ct,\n+                partlen = implGCMCrypt0(in, inOfs + len, SPLIT_LEN, ct,\n@@ -595,0 +603,2 @@\n+\n+        \/\/ Finish any remaining data\n@@ -596,2 +606,7 @@\n-            len += implGCMCrypt0(in, inOfs + len, inLen, ct,\n-                   ctOfs + len, out, outOfs + len, gctr, ghash);\n+            if (ct == null) {\n+                ghash.update(in, inOfs + len, inLen);\n+                len += gctr.update(in, inOfs + len, inLen, out, outOfs);\n+            } else {\n+                len += implGCMCrypt0(in, inOfs + len, inLen, ct,\n+                    ctOfs + len, out, outOfs + len, gctr, ghash);\n+            }\n@@ -601,0 +616,1 @@\n+\n@@ -602,3 +618,2 @@\n-     * Intrinsic for Vector AES Galois Counter Mode implementation.\n-     * AES and GHASH operations are interleaved in the intrinsic implementation.\n-     * return - number of processed bytes\n+     * Intrinsic for the combined AES Galois Counter Mode implementation.\n+     * AES and GHASH operations are combined in the intrinsic implementation.\n@@ -609,0 +624,7 @@\n+     *\n+     * Note:\n+     * Only Intel processors with AVX512 that support vaes, vpclmulqdq,\n+     * avx512dq, and avx512vl trigger this intrinsic.\n+     * Other processors will always use GHASH and GCTR which may have their own\n+     * intrinsic support\n+     *\n@@ -617,1 +639,1 @@\n-     * @param ghash object for the ghash operation\n+     * @param ghash object for the GHASH operation\n@@ -673,0 +695,5 @@\n+        \/\/ True if ops is an in-place array decryption with the offset between\n+        \/\/ input & output the same or the input greater.  This is to\n+        \/\/ avoid the AVX512 intrinsic.\n+        boolean inPlaceArray = false;\n+\n@@ -739,1 +766,2 @@\n-                    ct.array(), ct.arrayOffset() + ct.position(),\n+                    inPlaceArray ? null : ct.array(),\n+                    ct.arrayOffset() + ct.position(),\n@@ -951,0 +979,2 @@\n+                \/\/ NOTE: inPlaceArray does not apply here as direct buffers run\n+                \/\/ through a byte[] to get to the combined intrinsic\n@@ -967,3 +997,4 @@\n-                    \/\/ used.  But during decryption always create a new\n-                    \/\/ buffer in case of a bad auth tag.\n-                    if (encryption && src.position() + src.arrayOffset() >=\n+                    \/\/ used.\n+                    \/\/ Set 'inPlaceArray' true for decryption operations to\n+                    \/\/ avoid the AVX512 combined intrinsic\n+                    if (src.position() + src.arrayOffset() >=\n@@ -971,0 +1002,1 @@\n+                        inPlaceArray = (!encryption);\n@@ -992,1 +1024,1 @@\n-         * This is used for both overlap detection for the data or  decryption\n+         * This is used for both overlap detection for the data or decryption\n@@ -1000,4 +1032,7 @@\n-            if (in == out && (!encryption || inOfs < outOfs)) {\n-                originalOut = out;\n-                originalOutOfs = outOfs;\n-                return new byte[out.length];\n+            if (in == out) {\n+                if (inOfs < outOfs) {\n+                    originalOut = out;\n+                    originalOutOfs = outOfs;\n+                    return new byte[out.length];\n+                }\n+                inPlaceArray = (!encryption);\n@@ -1504,2 +1539,5 @@\n-                \/\/ Clear output data\n-                Arrays.fill(out, outOfs, outOfs + len, (byte) 0);\n+                \/\/ If this is an in-place array, don't zero the input\n+                if (!inPlaceArray) {\n+                    \/\/ Clear output data\n+                    Arrays.fill(out, outOfs, outOfs + len, (byte) 0);\n+                }\n@@ -1588,8 +1626,11 @@\n-                dst.reset();\n-                if (dst.hasArray()) {\n-                    int ofs = dst.arrayOffset() + dst.position();\n-                    Arrays.fill(dst.array(), ofs , ofs + len, (byte)0);\n-                } else {\n-                    NIO_ACCESS.acquireSession(dst);\n-                    try {\n-                        Unsafe.getUnsafe().setMemory(((DirectBuffer)dst).address(),\n+                dst.reset();             \n+                \/\/ If this is an in-place array, don't zero the src\n+                if (!inPlaceArray) {\n+                    if (dst.hasArray()) {\n+                        int ofs = dst.arrayOffset() + dst.position();\n+                        Arrays.fill(dst.array(), ofs, ofs + len, (byte) 0);\n+                    } else {\n+                        NIO_ACCESS.acquireSession(dst);\n+                        try {\n+                            Unsafe.getUnsafe().setMemory(\n+                                ((DirectBuffer) dst).address(),\n@@ -1597,2 +1638,3 @@\n-                    } finally {\n-                        NIO_ACCESS.releaseSession(dst);\n+                        } finally {\n+                            NIO_ACCESS.releaseSession(dst);\n+                        }\n@@ -1810,2 +1852,5 @@\n-                len += implGCMCrypt(in, inOfs, inLen, in, inOfs, out, outOfs,\n-                    gctr, ghash);\n+                \/\/ Since GCMDecrypt.inPlaceArray cannot be accessed, check that\n+                \/\/ 'in' and 'out' are the same.  All other in-place situations\n+                \/\/ have been resolved by overlapDetection()\n+                len += implGCMCrypt(in, inOfs, inLen, (in == out ? null : in),\n+                    inOfs, out, outOfs, gctr, ghash);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":79,"deletions":34,"binary":false,"changes":113,"status":"modified"}]}