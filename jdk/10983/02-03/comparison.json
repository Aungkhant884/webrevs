{"files":[{"patch":"@@ -275,2 +275,11 @@\n-  \/\/ Max number of deletes in one bucket chain during bulk delete.\n-  static const size_t BULK_DELETE_LIMIT = 256;\n+  \/\/ When doing deletes, we need to store the pointers until the next\n+  \/\/ visible epoch.  In the normal case (good hash function and\n+  \/\/ reasonable sizing), we can save these pointers on the stack\n+  \/\/ (there should not be more than a few entries per bucket). But if\n+  \/\/ the hash function is bad and\/or the sizing of the table is bad,\n+  \/\/ we can not use a fixed size stack buffer alone. We will use a\n+  \/\/ heap buffer as fall-back when the stack is not enough, and then\n+  \/\/ we have to pay for a dynamic allocation.  `StackBufferSize` tells\n+  \/\/ the size of optimistic stack buffer that will almost always be\n+  \/\/ used.\n+  static const size_t StackBufferSize = 256;\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.hpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-static const void* POISON_PTR = (void*)UCONST64(0xfbadbadbadbadbac);\n+static void* const POISON_PTR = (void*)UCONST64(0xfbadbadbadbadbac);\n@@ -54,1 +54,1 @@\n-static const void* POISON_PTR = (void*)0xffbadbac;\n+static void* const POISON_PTR = (void*)0xffbadbac;\n@@ -490,1 +490,1 @@\n-  Node* ndel_stack[BULK_DELETE_LIMIT];\n+  Node* ndel_stack[StackBufferSize];\n@@ -515,2 +515,2 @@\n-    GrowableArrayCHeap<Node*, F> extra(0);\n-    size_t nd = delete_check_nodes(bucket, eval_f, BULK_DELETE_LIMIT, ndel_stack, extra);\n+    GrowableArrayCHeap<Node*, F> extra(0); \/\/ use this buffer if StackBufferSize is not enough\n+    size_t nd = delete_check_nodes(bucket, eval_f, StackBufferSize, ndel_stack, extra);\n@@ -524,1 +524,1 @@\n-      Node* ndel = node_it < BULK_DELETE_LIMIT ? ndel_stack[node_it] : extra.at(node_it - BULK_DELETE_LIMIT);\n+      Node*& ndel = node_it < StackBufferSize ? ndel_stack[node_it] : extra.at(node_it - StackBufferSize);\n@@ -528,1 +528,1 @@\n-      DEBUG_ONLY(ndel = (Node*)POISON_PTR;)\n+      DEBUG_ONLY(ndel = static_cast<Node*>(POISON_PTR);)\n@@ -543,1 +543,1 @@\n-  Node* ndel[BULK_DELETE_LIMIT];\n+  Node* ndel[StackBufferSize];\n@@ -554,1 +554,1 @@\n-      if (dels == BULK_DELETE_LIMIT) {\n+      if (dels == StackBufferSize) {\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"}]}