{"files":[{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -274,2 +275,11 @@\n-  \/\/ Max number of deletes in one bucket chain during bulk delete.\n-  static const size_t BULK_DELETE_LIMIT = 256;\n+  \/\/ When doing deletes, we need to store the pointers until the next\n+  \/\/ visible epoch.  In the normal case (good hash function and\n+  \/\/ reasonable sizing), we can save these pointers on the stack\n+  \/\/ (there should not be more than a few entries per bucket). But if\n+  \/\/ the hash function is bad and\/or the sizing of the table is bad,\n+  \/\/ we can not use a fixed size stack buffer alone. We will use a\n+  \/\/ heap buffer as fall-back when the stack is not enough, and then\n+  \/\/ we have to pay for a dynamic allocation.  `StackBufferSize` tells\n+  \/\/ the size of optimistic stack buffer that will almost always be\n+  \/\/ used.\n+  static const size_t StackBufferSize = 256;\n@@ -352,1 +362,1 @@\n-                            size_t num_del, Node** ndel);\n+                            size_t num_del, Node** ndel, GrowableArrayCHeap<Node*, F>& ndel_heap);\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.hpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -50,1 +51,1 @@\n-static const void* POISON_PTR = (void*)UCONST64(0xfbadbadbadbadbac);\n+static void* const POISON_PTR = (void*)UCONST64(0xfbadbadbadbadbac);\n@@ -53,1 +54,1 @@\n-static const void* POISON_PTR = (void*)0xffbadbac;\n+static void* const POISON_PTR = (void*)0xffbadbac;\n@@ -489,1 +490,1 @@\n-  Node* ndel[BULK_DELETE_LIMIT];\n+  Node* ndel_stack[StackBufferSize];\n@@ -514,1 +515,2 @@\n-    size_t nd = delete_check_nodes(bucket, eval_f, BULK_DELETE_LIMIT, ndel);\n+    GrowableArrayCHeap<Node*, F> extra(0); \/\/ use this buffer if StackBufferSize is not enough\n+    size_t nd = delete_check_nodes(bucket, eval_f, StackBufferSize, ndel_stack, extra);\n@@ -522,2 +524,3 @@\n-      del_f(ndel[node_it]->value());\n-      Node::destroy_node(_context, ndel[node_it]);\n+      Node*& ndel = node_it < StackBufferSize ? ndel_stack[node_it] : extra.at(static_cast<int>(node_it - StackBufferSize));\n+      del_f(ndel->value());\n+      Node::destroy_node(_context, ndel);\n@@ -525,1 +528,1 @@\n-      DEBUG_ONLY(ndel[node_it] = (Node*)POISON_PTR;)\n+      DEBUG_ONLY(ndel = static_cast<Node*>(POISON_PTR);)\n@@ -540,1 +543,1 @@\n-  Node* ndel[BULK_DELETE_LIMIT];\n+  Node* ndel[StackBufferSize];\n@@ -551,1 +554,1 @@\n-      if (dels == BULK_DELETE_LIMIT) {\n+      if (dels == StackBufferSize) {\n@@ -985,1 +988,1 @@\n-                     size_t num_del, Node** ndel)\n+                     size_t num_del, Node** ndel, GrowableArrayCHeap<Node*, F>& extra)\n@@ -990,1 +993,1 @@\n-  while (rem_n != NULL) {\n+  while (rem_n != nullptr) {\n@@ -992,1 +995,8 @@\n-      ndel[dels++] = rem_n;\n+      if (dels < num_del) {\n+        ndel[dels] = rem_n;\n+      } else {\n+        guarantee(dels < std::numeric_limits<int>::max(),\n+                  \"Growable array size is limited by a (signed) int, something is seriously bad if we reach this point, better exit\");\n+        extra.append(rem_n);\n+      }\n+      ++dels;\n@@ -996,3 +1006,0 @@\n-      if (dels == num_del) {\n-        break;\n-      }\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":22,"deletions":15,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -215,30 +215,56 @@\n-  uintptr_t val1 = 1;\n-  uintptr_t val2 = 2;\n-  uintptr_t val3 = 3;\n-  SimpleTestLookup stl1(val1), stl2(val2), stl3(val3);\n-\n-  SimpleTestTable* cht = new SimpleTestTable();\n-  cht_getinsert_bulkdelete_insert_verified(thr, cht, val1, false, true);\n-  cht_getinsert_bulkdelete_insert_verified(thr, cht, val2, false, true);\n-  cht_getinsert_bulkdelete_insert_verified(thr, cht, val3, false, true);\n-\n-  EXPECT_TRUE(cht->remove(thr, stl2)) << \"Remove did not find value.\";\n-\n-  cht_getinsert_bulkdelete_insert_verified(thr, cht, val1, true, false); \/\/ val1 should be present\n-  cht_getinsert_bulkdelete_insert_verified(thr, cht, val2, false, true); \/\/ val2 should be inserted\n-  cht_getinsert_bulkdelete_insert_verified(thr, cht, val3, true, false); \/\/ val3 should be present\n-\n-  EXPECT_EQ(cht_get_copy(cht, thr, stl1), val1) << \"Get did not find value.\";\n-  EXPECT_EQ(cht_get_copy(cht, thr, stl2), val2) << \"Get did not find value.\";\n-  EXPECT_EQ(cht_get_copy(cht, thr, stl3), val3) << \"Get did not find value.\";\n-\n-  \/\/ Removes all odd values.\n-  cht->bulk_delete(thr, getinsert_bulkdelete_eval, getinsert_bulkdelete_del);\n-\n-  EXPECT_EQ(cht_get_copy(cht, thr, stl1), (uintptr_t)0) << \"Odd value should not exist.\";\n-  EXPECT_FALSE(cht->remove(thr, stl1)) << \"Odd value should not exist.\";\n-  EXPECT_EQ(cht_get_copy(cht, thr, stl2), val2) << \"Even value should not have been removed.\";\n-  EXPECT_EQ(cht_get_copy(cht, thr, stl3), (uintptr_t)0) << \"Add value should not exists.\";\n-  EXPECT_FALSE(cht->remove(thr, stl3)) << \"Odd value should not exists.\";\n-\n-  delete cht;\n+  SimpleTestTable a[] = {SimpleTestTable(), SimpleTestTable(2, 2, 14) \/* force long lists in the buckets*\/ };\n+  const unsigned iter = 1000;\n+  for (auto& table: a) {\n+    for (unsigned i = 0; i < iter; ++i) {\n+      uintptr_t val1 = i * 10 + 1;\n+      uintptr_t val2 = i * 10 + 2;\n+      uintptr_t val3 = i * 10 + 3;\n+      SimpleTestLookup stl1(val1), stl2(val2), stl3(val3);\n+      cht_getinsert_bulkdelete_insert_verified(thr, &table, val1, false, true);\n+      cht_getinsert_bulkdelete_insert_verified(thr, &table, val2, false, true);\n+      cht_getinsert_bulkdelete_insert_verified(thr, &table, val3, false, true);\n+\n+      EXPECT_TRUE(table.remove(thr, stl2)) << \"Remove did not find value.\";\n+\n+      cht_getinsert_bulkdelete_insert_verified(thr, &table, val1, true, false); \/\/ val1 should be present\n+      cht_getinsert_bulkdelete_insert_verified(thr, &table, val2, false, true); \/\/ val2 should be inserted\n+      cht_getinsert_bulkdelete_insert_verified(thr, &table, val3, true, false); \/\/ val3 should be present\n+\n+      EXPECT_EQ(cht_get_copy(&table, thr, stl1), val1) << \"Get did not find value.\";\n+      EXPECT_EQ(cht_get_copy(&table, thr, stl2), val2) << \"Get did not find value.\";\n+      EXPECT_EQ(cht_get_copy(&table, thr, stl3), val3) << \"Get did not find value.\";\n+    }\n+\n+    unsigned delete_count = 0;\n+    unsigned scan_count = 0;\n+    auto eval_odd_f = [](uintptr_t* val)                  { return *val & 0x1; };\n+    auto eval_true_f = [](uintptr_t* val)                 { return true; };\n+    auto scan_count_f = [&scan_count](uintptr_t* val)     { scan_count++; return true; };\n+    auto delete_count_f = [&delete_count](uintptr_t* val) { delete_count++; };\n+    table.bulk_delete(thr, eval_odd_f, delete_count_f);\n+    EXPECT_EQ(iter*2, delete_count) << \"All odd values should have been deleted\";\n+    table.do_scan(thr, scan_count_f);\n+    EXPECT_EQ(iter, scan_count) << \"All odd values should have been deleted\";\n+\n+    for (unsigned i = 0; i < iter; ++i) {\n+      uintptr_t val1 = i * 10 + 1;\n+      uintptr_t val2 = i * 10 + 2;\n+      uintptr_t val3 = i * 10 + 3;\n+      SimpleTestLookup stl1(val1), stl2(val2), stl3(val3);\n+      EXPECT_EQ(cht_get_copy(&table, thr, stl1), (uintptr_t)0) << \"Odd value should not exist.\";\n+      EXPECT_FALSE(table.remove(thr, stl1)) << \"Odd value should not exist.\";\n+      EXPECT_EQ(cht_get_copy(&table, thr, stl2), val2) << \"Even value should not have been removed.\";\n+      EXPECT_EQ(cht_get_copy(&table, thr, stl3), (uintptr_t)0) << \"Add value should not exists.\";\n+      EXPECT_FALSE(table.remove(thr, stl3)) << \"Odd value should not exists.\";\n+    }\n+\n+    scan_count = 0;\n+    table.do_scan(thr, scan_count_f);\n+    EXPECT_EQ(iter, scan_count) << \"All values should have been deleted\";\n+    delete_count = 0;\n+    table.bulk_delete(thr, eval_true_f, delete_count_f);\n+    EXPECT_EQ(iter, delete_count) << \"All odd values should have been deleted\";\n+    scan_count = 0;\n+    table.do_scan(thr, scan_count_f);\n+    EXPECT_EQ(0u, scan_count) << \"All values should have been deleted\";\n+  }\n","filename":"test\/hotspot\/gtest\/utilities\/test_concurrentHashtable.cpp","additions":56,"deletions":30,"binary":false,"changes":86,"status":"modified"}]}