{"files":[{"patch":"@@ -500,3 +500,4 @@\n-    Bucket* bucket = table->get_bucket(bucket_it);\n-    Bucket* prefetch_bucket = (bucket_it+1) < stop_idx ?\n-                              table->get_bucket(bucket_it+1) : NULL;\n+    for (;;) {\n+      Bucket* bucket = table->get_bucket(bucket_it);\n+      Bucket* prefetch_bucket = (bucket_it+1) < stop_idx ?\n+                                table->get_bucket(bucket_it+1) : NULL;\n@@ -504,1 +505,1 @@\n-    if (!HaveDeletables<IsPointer<VALUE>::value, EVALUATE_FUNC>::\n+      if (!HaveDeletables<IsPointer<VALUE>::value, EVALUATE_FUNC>::\n@@ -507,1 +508,21 @@\n-        continue;\n+        break;\n+      }\n+\n+      GlobalCounter::critical_section_end(thread, cs_context);\n+      \/\/ We left critical section but the bucket cannot be removed while we hold\n+      \/\/ the _resize_lock.\n+      bucket->lock();\n+      size_t nd = delete_check_nodes(bucket, eval_f, BULK_DELETE_LIMIT, ndel);\n+      bucket->unlock();\n+      if (is_mt) {\n+        GlobalCounter::write_synchronize();\n+      } else {\n+        write_synchonize_on_visible_epoch(thread);\n+      }\n+      for (size_t node_it = 0; node_it < nd; node_it++) {\n+        del_f(ndel[node_it]->value());\n+        Node::destroy_node(_context, ndel[node_it]);\n+        JFR_ONLY(safe_stats_remove();)\n+        DEBUG_ONLY(ndel[node_it] = (Node*)POISON_PTR;)\n+      }\n+      cs_context = GlobalCounter::critical_section_begin(thread);\n@@ -509,19 +530,0 @@\n-\n-    GlobalCounter::critical_section_end(thread, cs_context);\n-    \/\/ We left critical section but the bucket cannot be removed while we hold\n-    \/\/ the _resize_lock.\n-    bucket->lock();\n-    size_t nd = delete_check_nodes(bucket, eval_f, BULK_DELETE_LIMIT, ndel);\n-    bucket->unlock();\n-    if (is_mt) {\n-      GlobalCounter::write_synchronize();\n-    } else {\n-      write_synchonize_on_visible_epoch(thread);\n-    }\n-    for (size_t node_it = 0; node_it < nd; node_it++) {\n-      del_f(ndel[node_it]->value());\n-      Node::destroy_node(_context, ndel[node_it]);\n-      JFR_ONLY(safe_stats_remove();)\n-      DEBUG_ONLY(ndel[node_it] = (Node*)POISON_PTR;)\n-    }\n-    cs_context = GlobalCounter::critical_section_begin(thread);\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":26,"deletions":24,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -215,30 +215,56 @@\n-  uintptr_t val1 = 1;\n-  uintptr_t val2 = 2;\n-  uintptr_t val3 = 3;\n-  SimpleTestLookup stl1(val1), stl2(val2), stl3(val3);\n-\n-  SimpleTestTable* cht = new SimpleTestTable();\n-  cht_getinsert_bulkdelete_insert_verified(thr, cht, val1, false, true);\n-  cht_getinsert_bulkdelete_insert_verified(thr, cht, val2, false, true);\n-  cht_getinsert_bulkdelete_insert_verified(thr, cht, val3, false, true);\n-\n-  EXPECT_TRUE(cht->remove(thr, stl2)) << \"Remove did not find value.\";\n-\n-  cht_getinsert_bulkdelete_insert_verified(thr, cht, val1, true, false); \/\/ val1 should be present\n-  cht_getinsert_bulkdelete_insert_verified(thr, cht, val2, false, true); \/\/ val2 should be inserted\n-  cht_getinsert_bulkdelete_insert_verified(thr, cht, val3, true, false); \/\/ val3 should be present\n-\n-  EXPECT_EQ(cht_get_copy(cht, thr, stl1), val1) << \"Get did not find value.\";\n-  EXPECT_EQ(cht_get_copy(cht, thr, stl2), val2) << \"Get did not find value.\";\n-  EXPECT_EQ(cht_get_copy(cht, thr, stl3), val3) << \"Get did not find value.\";\n-\n-  \/\/ Removes all odd values.\n-  cht->bulk_delete(thr, getinsert_bulkdelete_eval, getinsert_bulkdelete_del);\n-\n-  EXPECT_EQ(cht_get_copy(cht, thr, stl1), (uintptr_t)0) << \"Odd value should not exist.\";\n-  EXPECT_FALSE(cht->remove(thr, stl1)) << \"Odd value should not exist.\";\n-  EXPECT_EQ(cht_get_copy(cht, thr, stl2), val2) << \"Even value should not have been removed.\";\n-  EXPECT_EQ(cht_get_copy(cht, thr, stl3), (uintptr_t)0) << \"Add value should not exists.\";\n-  EXPECT_FALSE(cht->remove(thr, stl3)) << \"Odd value should not exists.\";\n-\n-  delete cht;\n+  SimpleTestTable a[] = {SimpleTestTable(), SimpleTestTable(2, 2, 14) \/* force long lists in the buckets*\/ };\n+  const unsigned iter = 1000;\n+  for (auto& table: a) {\n+    for (unsigned i = 0; i < iter; ++i) {\n+      uintptr_t val1 = i * 10 + 1;\n+      uintptr_t val2 = i * 10 + 2;\n+      uintptr_t val3 = i * 10 + 3;\n+      SimpleTestLookup stl1(val1), stl2(val2), stl3(val3);\n+      cht_getinsert_bulkdelete_insert_verified(thr, &table, val1, false, true);\n+      cht_getinsert_bulkdelete_insert_verified(thr, &table, val2, false, true);\n+      cht_getinsert_bulkdelete_insert_verified(thr, &table, val3, false, true);\n+\n+      EXPECT_TRUE(table.remove(thr, stl2)) << \"Remove did not find value.\";\n+\n+      cht_getinsert_bulkdelete_insert_verified(thr, &table, val1, true, false); \/\/ val1 should be present\n+      cht_getinsert_bulkdelete_insert_verified(thr, &table, val2, false, true); \/\/ val2 should be inserted\n+      cht_getinsert_bulkdelete_insert_verified(thr, &table, val3, true, false); \/\/ val3 should be present\n+\n+      EXPECT_EQ(cht_get_copy(&table, thr, stl1), val1) << \"Get did not find value.\";\n+      EXPECT_EQ(cht_get_copy(&table, thr, stl2), val2) << \"Get did not find value.\";\n+      EXPECT_EQ(cht_get_copy(&table, thr, stl3), val3) << \"Get did not find value.\";\n+    }\n+\n+    unsigned delete_count = 0;\n+    unsigned scan_count = 0;\n+    auto eval_odd_f = [](uintptr_t* val)                  { return *val & 0x1; };\n+    auto eval_true_f = [](uintptr_t* val)                 { return true; };\n+    auto scan_count_f = [&scan_count](uintptr_t* val)     { scan_count++; return true; };\n+    auto delete_count_f = [&delete_count](uintptr_t* val) { delete_count++; };\n+    table.bulk_delete(thr, eval_odd_f, delete_count_f);\n+    EXPECT_EQ(iter*2, delete_count) << \"All odd values should have been deleted\";\n+    table.do_scan(thr, scan_count_f);\n+    EXPECT_EQ(iter, scan_count) << \"All odd values should have been deleted\";\n+\n+    for (unsigned i = 0; i < iter; ++i) {\n+      uintptr_t val1 = i * 10 + 1;\n+      uintptr_t val2 = i * 10 + 2;\n+      uintptr_t val3 = i * 10 + 3;\n+      SimpleTestLookup stl1(val1), stl2(val2), stl3(val3);\n+      EXPECT_EQ(cht_get_copy(&table, thr, stl1), (uintptr_t)0) << \"Odd value should not exist.\";\n+      EXPECT_FALSE(table.remove(thr, stl1)) << \"Odd value should not exist.\";\n+      EXPECT_EQ(cht_get_copy(&table, thr, stl2), val2) << \"Even value should not have been removed.\";\n+      EXPECT_EQ(cht_get_copy(&table, thr, stl3), (uintptr_t)0) << \"Add value should not exists.\";\n+      EXPECT_FALSE(table.remove(thr, stl3)) << \"Odd value should not exists.\";\n+    }\n+\n+    scan_count = 0;\n+    table.do_scan(thr, scan_count_f);\n+    EXPECT_EQ(iter, scan_count) << \"All values should have been deleted\";\n+    delete_count = 0;\n+    table.bulk_delete(thr, eval_true_f, delete_count_f);\n+    EXPECT_EQ(iter, delete_count) << \"All odd values should have been deleted\";\n+    scan_count = 0;\n+    table.do_scan(thr, scan_count_f);\n+    EXPECT_EQ(0u, scan_count) << \"All values should have been deleted\";\n+  }\n","filename":"test\/hotspot\/gtest\/utilities\/test_concurrentHashtable.cpp","additions":56,"deletions":30,"binary":false,"changes":86,"status":"modified"}]}