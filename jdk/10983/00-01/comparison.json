{"files":[{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -352,1 +353,1 @@\n-                            size_t num_del, Node** ndel);\n+                            size_t num_del, Node** ndel, GrowableArrayCHeap<Node*, F>& ndel_heap);\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -489,1 +490,1 @@\n-  Node* ndel[BULK_DELETE_LIMIT];\n+  Node* ndel_stack[BULK_DELETE_LIMIT];\n@@ -500,4 +501,3 @@\n-    for (;;) {\n-      Bucket* bucket = table->get_bucket(bucket_it);\n-      Bucket* prefetch_bucket = (bucket_it+1) < stop_idx ?\n-                                table->get_bucket(bucket_it+1) : NULL;\n+    Bucket* bucket = table->get_bucket(bucket_it);\n+    Bucket* prefetch_bucket = (bucket_it+1) < stop_idx ?\n+                              table->get_bucket(bucket_it+1) : NULL;\n@@ -505,1 +505,1 @@\n-      if (!HaveDeletables<IsPointer<VALUE>::value, EVALUATE_FUNC>::\n+    if (!HaveDeletables<IsPointer<VALUE>::value, EVALUATE_FUNC>::\n@@ -508,2 +508,2 @@\n-        break;\n-      }\n+        continue;\n+    }\n@@ -511,18 +511,18 @@\n-      GlobalCounter::critical_section_end(thread, cs_context);\n-      \/\/ We left critical section but the bucket cannot be removed while we hold\n-      \/\/ the _resize_lock.\n-      bucket->lock();\n-      size_t nd = delete_check_nodes(bucket, eval_f, BULK_DELETE_LIMIT, ndel);\n-      bucket->unlock();\n-      if (is_mt) {\n-        GlobalCounter::write_synchronize();\n-      } else {\n-        write_synchonize_on_visible_epoch(thread);\n-      }\n-      for (size_t node_it = 0; node_it < nd; node_it++) {\n-        del_f(ndel[node_it]->value());\n-        Node::destroy_node(_context, ndel[node_it]);\n-        JFR_ONLY(safe_stats_remove();)\n-        DEBUG_ONLY(ndel[node_it] = (Node*)POISON_PTR;)\n-      }\n-      cs_context = GlobalCounter::critical_section_begin(thread);\n+    GlobalCounter::critical_section_end(thread, cs_context);\n+    \/\/ We left critical section but the bucket cannot be removed while we hold\n+    \/\/ the _resize_lock.\n+    bucket->lock();\n+    GrowableArrayCHeap<Node*, F> extra(0);\n+    size_t nd = delete_check_nodes(bucket, eval_f, BULK_DELETE_LIMIT, ndel_stack, extra);\n+    bucket->unlock();\n+    if (is_mt) {\n+      GlobalCounter::write_synchronize();\n+    } else {\n+      write_synchonize_on_visible_epoch(thread);\n+    }\n+    for (size_t node_it = 0; node_it < nd; node_it++) {\n+      Node* ndel = node_it < BULK_DELETE_LIMIT ? ndel_stack[node_it] : extra.at(node_it - BULK_DELETE_LIMIT);\n+      del_f(ndel->value());\n+      Node::destroy_node(_context, ndel);\n+      JFR_ONLY(safe_stats_remove();)\n+      DEBUG_ONLY(ndel = (Node*)POISON_PTR;)\n@@ -530,0 +530,1 @@\n+    cs_context = GlobalCounter::critical_section_begin(thread);\n@@ -987,1 +988,1 @@\n-                     size_t num_del, Node** ndel)\n+                     size_t num_del, Node** ndel, GrowableArrayCHeap<Node*, F>& extra)\n@@ -992,1 +993,1 @@\n-  while (rem_n != NULL) {\n+  for (dels = 0; rem_n != nullptr; ++dels) {\n@@ -994,1 +995,5 @@\n-      ndel[dels++] = rem_n;\n+      if (dels < num_del) {\n+        ndel[dels] = rem_n;\n+      } else {\n+        extra.append(rem_n);\n+      }\n@@ -998,3 +1003,0 @@\n-      if (dels == num_del) {\n-        break;\n-      }\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":34,"deletions":32,"binary":false,"changes":66,"status":"modified"}]}