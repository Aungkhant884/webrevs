{"files":[{"patch":"@@ -47,3 +47,0 @@\n-  product(bool, UseHugeTLBFS, false,                                    \\\n-          \"Use MAP_HUGETLB for large pages\")                            \\\n-                                                                        \\\n@@ -56,3 +53,0 @@\n-  product(bool, UseSHM, false,                                          \\\n-          \"Use SYSV shared memory for large pages\")                     \\\n-                                                                        \\\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -113,1 +113,0 @@\n-# include <sys\/shm.h>\n@@ -3609,1 +3608,1 @@\n-int os::Linux::hugetlbfs_page_size_flag(size_t page_size) {\n+static int hugetlbfs_page_size_flag(size_t page_size) {\n@@ -3616,1 +3615,4 @@\n-bool os::Linux::hugetlbfs_sanity_check(bool warn, size_t page_size) {\n+static bool hugetlbfs_sanity_check(size_t page_size) {\n+  const os::PageSizes page_sizes = HugePages::static_info().pagesizes();\n+  assert(page_sizes.contains(page_size), \"Invalid page sizes passed\");\n+\n@@ -3630,3 +3632,3 @@\n-      for (size_t page_size_ = _page_sizes.next_smaller(page_size);\n-          page_size_ != os::vm_page_size();\n-          page_size_ = _page_sizes.next_smaller(page_size_)) {\n+      for (size_t page_size_ = page_sizes.next_smaller(page_size);\n+          page_size_ > os::vm_page_size();\n+          page_size_ = page_sizes.next_smaller(page_size_)) {\n@@ -3646,4 +3648,0 @@\n-  if (warn) {\n-    warning(\"HugeTLBFS is not configured or not supported by the operating system.\");\n-  }\n-\n@@ -3653,24 +3651,0 @@\n-bool os::Linux::shm_hugetlbfs_sanity_check(bool warn, size_t page_size) {\n-  \/\/ Try to create a large shared memory segment.\n-  int shmid = shmget(IPC_PRIVATE, page_size, SHM_HUGETLB|IPC_CREAT|SHM_R|SHM_W);\n-  if (shmid == -1) {\n-    \/\/ Possible reasons for shmget failure:\n-    \/\/ 1. shmmax is too small for the request.\n-    \/\/    > check shmmax value: cat \/proc\/sys\/kernel\/shmmax\n-    \/\/    > increase shmmax value: echo \"new_value\" > \/proc\/sys\/kernel\/shmmax\n-    \/\/ 2. not enough large page memory.\n-    \/\/    > check available large pages: cat \/proc\/meminfo\n-    \/\/    > increase amount of large pages:\n-    \/\/          sysctl -w vm.nr_hugepages=new_value\n-    \/\/    > For more information regarding large pages please refer to:\n-    \/\/      https:\/\/www.kernel.org\/doc\/Documentation\/vm\/hugetlbpage.txt\n-    if (warn) {\n-      warning(\"Large pages using UseSHM are not configured on this system.\");\n-    }\n-    return false;\n-  }\n-  \/\/ Managed to create a segment, now delete it.\n-  shmctl(shmid, IPC_RMID, nullptr);\n-  return true;\n-}\n-\n@@ -3724,42 +3698,0 @@\n-bool os::Linux::setup_large_page_type(size_t page_size) {\n-  if (FLAG_IS_DEFAULT(UseHugeTLBFS) &&\n-      FLAG_IS_DEFAULT(UseSHM) &&\n-      FLAG_IS_DEFAULT(UseTransparentHugePages)) {\n-\n-    \/\/ The type of large pages has not been specified by the user.\n-\n-    \/\/ Try UseHugeTLBFS and then UseSHM.\n-    UseHugeTLBFS = UseSHM = true;\n-\n-    \/\/ Don't try UseTransparentHugePages since there are known\n-    \/\/ performance issues with it turned on. This might change in the future.\n-    UseTransparentHugePages = false;\n-  }\n-\n-  if (UseTransparentHugePages) {\n-    UseHugeTLBFS = false;\n-    UseSHM = false;\n-    return true;\n-  }\n-\n-  if (UseHugeTLBFS) {\n-    bool warn_on_failure = !FLAG_IS_DEFAULT(UseHugeTLBFS);\n-    if (hugetlbfs_sanity_check(warn_on_failure, page_size)) {\n-      UseSHM = false;\n-      return true;\n-    }\n-    UseHugeTLBFS = false;\n-  }\n-\n-  if (UseSHM) {\n-    bool warn_on_failure = !FLAG_IS_DEFAULT(UseSHM);\n-    if (shm_hugetlbfs_sanity_check(warn_on_failure, page_size)) {\n-      return true;\n-    }\n-    UseSHM = false;\n-  }\n-\n-  warn_no_large_pages_configured();\n-  return false;\n-}\n-\n@@ -3772,2 +3704,1 @@\n-        ls.print_cr(\"UseLargePages=1, UseTransparentHugePages=%d, UseHugeTLBFS=%d, UseSHM=%d\",\n-                    UseTransparentHugePages, UseHugeTLBFS, UseSHM);\n+        ls.print_cr(\"UseLargePages=1, UseTransparentHugePages=%d\", UseTransparentHugePages);\n@@ -3807,3 +3738,1 @@\n-      !UseTransparentHugePages &&\n-      !UseHugeTLBFS &&\n-      !UseSHM) {\n+      !UseTransparentHugePages) {\n@@ -3816,1 +3745,0 @@\n-    \/\/ Ignore the rest of the large pages flags.\n@@ -3818,2 +3746,0 @@\n-    UseHugeTLBFS = false;\n-    UseSHM = false;\n@@ -3828,1 +3754,1 @@\n-    UseLargePages = UseTransparentHugePages = UseHugeTLBFS = UseSHM = false;\n+    UseLargePages = UseTransparentHugePages = false;\n@@ -3833,1 +3759,1 @@\n-    UseLargePages = UseTransparentHugePages = UseHugeTLBFS = UseSHM = false;\n+    UseLargePages = UseTransparentHugePages = false;\n@@ -3857,0 +3783,2 @@\n+    size_t large_page_size = 0;\n+\n@@ -3864,1 +3792,1 @@\n-      _large_page_size = default_large_page_size;\n+      large_page_size = default_large_page_size;\n@@ -3866,2 +3794,2 @@\n-                         byte_size_in_exact_unit(_large_page_size),\n-                         exact_unit_for_byte_size(_large_page_size));\n+                         byte_size_in_exact_unit(large_page_size),\n+                         exact_unit_for_byte_size(large_page_size));\n@@ -3870,1 +3798,1 @@\n-        _large_page_size = LargePageSizeInBytes;\n+        large_page_size = LargePageSizeInBytes;\n@@ -3875,2 +3803,2 @@\n-                           byte_size_in_exact_unit(_large_page_size),\n-                           exact_unit_for_byte_size(_large_page_size));\n+                           byte_size_in_exact_unit(large_page_size),\n+                           exact_unit_for_byte_size(large_page_size));\n@@ -3878,1 +3806,1 @@\n-        _large_page_size = default_large_page_size;\n+        large_page_size = default_large_page_size;\n@@ -3883,2 +3811,2 @@\n-                           byte_size_in_exact_unit(_large_page_size),\n-                           exact_unit_for_byte_size(_large_page_size));\n+                           byte_size_in_exact_unit(large_page_size),\n+                           exact_unit_for_byte_size(large_page_size));\n@@ -3888,0 +3816,10 @@\n+    \/\/ Do an additional sanity check to see if we can use the desired large page size\n+    if (!hugetlbfs_sanity_check(large_page_size)) {\n+      warn_no_large_pages_configured();\n+      UseLargePages = false;\n+      UseTransparentHugePages = false;\n+      return;\n+    }\n+\n+    _large_page_size = large_page_size;\n+\n@@ -3896,3 +3834,0 @@\n-  \/\/ Now determine the type of large pages to use:\n-  UseLargePages = os::Linux::setup_large_page_type(_large_page_size);\n-\n@@ -3902,144 +3837,0 @@\n-#ifndef SHM_HUGETLB\n-  #define SHM_HUGETLB 04000\n-#endif\n-\n-#define shm_warning_format(format, ...)              \\\n-  do {                                               \\\n-    if (UseLargePages &&                             \\\n-        (!FLAG_IS_DEFAULT(UseLargePages) ||          \\\n-         !FLAG_IS_DEFAULT(UseSHM) ||                 \\\n-         !FLAG_IS_DEFAULT(LargePageSizeInBytes))) {  \\\n-      warning(format, __VA_ARGS__);                  \\\n-    }                                                \\\n-  } while (0)\n-\n-#define shm_warning(str) shm_warning_format(\"%s\", str)\n-\n-#define shm_warning_with_errno(str)                \\\n-  do {                                             \\\n-    int err = errno;                               \\\n-    shm_warning_format(str \" (error = %d)\", err);  \\\n-  } while (0)\n-\n-static char* shmat_with_alignment(int shmid, size_t bytes, size_t alignment) {\n-  assert(is_aligned(bytes, alignment), \"Must be divisible by the alignment\");\n-\n-  if (!is_aligned(alignment, SHMLBA)) {\n-    assert(false, \"Code below assumes that alignment is at least SHMLBA aligned\");\n-    return nullptr;\n-  }\n-\n-  \/\/ To ensure that we get 'alignment' aligned memory from shmat,\n-  \/\/ we pre-reserve aligned virtual memory and then attach to that.\n-\n-  char* pre_reserved_addr = anon_mmap_aligned(nullptr \/* req_addr *\/, bytes, alignment);\n-  if (pre_reserved_addr == nullptr) {\n-    \/\/ Couldn't pre-reserve aligned memory.\n-    shm_warning(\"Failed to pre-reserve aligned memory for shmat.\");\n-    return nullptr;\n-  }\n-\n-  \/\/ SHM_REMAP is needed to allow shmat to map over an existing mapping.\n-  char* addr = (char*)shmat(shmid, pre_reserved_addr, SHM_REMAP);\n-\n-  if ((intptr_t)addr == -1) {\n-    int err = errno;\n-    shm_warning_with_errno(\"Failed to attach shared memory.\");\n-\n-    assert(err != EACCES, \"Unexpected error\");\n-    assert(err != EIDRM,  \"Unexpected error\");\n-    assert(err != EINVAL, \"Unexpected error\");\n-\n-    \/\/ Since we don't know if the kernel unmapped the pre-reserved memory area\n-    \/\/ we can't unmap it, since that would potentially unmap memory that was\n-    \/\/ mapped from other threads.\n-    return nullptr;\n-  }\n-\n-  return addr;\n-}\n-\n-static char* shmat_at_address(int shmid, char* req_addr) {\n-  if (!is_aligned(req_addr, SHMLBA)) {\n-    assert(false, \"Requested address needs to be SHMLBA aligned\");\n-    return nullptr;\n-  }\n-\n-  char* addr = (char*)shmat(shmid, req_addr, 0);\n-\n-  if ((intptr_t)addr == -1) {\n-    shm_warning_with_errno(\"Failed to attach shared memory.\");\n-    return nullptr;\n-  }\n-\n-  return addr;\n-}\n-\n-static char* shmat_large_pages(int shmid, size_t bytes, size_t alignment, char* req_addr) {\n-  \/\/ If a req_addr has been provided, we assume that the caller has already aligned the address.\n-  if (req_addr != nullptr) {\n-    assert(is_aligned(req_addr, os::large_page_size()), \"Must be divisible by the large page size\");\n-    assert(is_aligned(req_addr, alignment), \"Must be divisible by given alignment\");\n-    return shmat_at_address(shmid, req_addr);\n-  }\n-\n-  \/\/ Since shmid has been setup with SHM_HUGETLB, shmat will automatically\n-  \/\/ return large page size aligned memory addresses when req_addr == nullptr.\n-  \/\/ However, if the alignment is larger than the large page size, we have\n-  \/\/ to manually ensure that the memory returned is 'alignment' aligned.\n-  if (alignment > os::large_page_size()) {\n-    assert(is_aligned(alignment, os::large_page_size()), \"Must be divisible by the large page size\");\n-    return shmat_with_alignment(shmid, bytes, alignment);\n-  } else {\n-    return shmat_at_address(shmid, nullptr);\n-  }\n-}\n-\n-char* os::Linux::reserve_memory_special_shm(size_t bytes, size_t alignment,\n-                                            char* req_addr, bool exec) {\n-  \/\/ \"exec\" is passed in but not used.  Creating the shared image for\n-  \/\/ the code cache doesn't have an SHM_X executable permission to check.\n-  assert(UseLargePages && UseSHM, \"only for SHM large pages\");\n-  assert(is_aligned(req_addr, os::large_page_size()), \"Unaligned address\");\n-  assert(is_aligned(req_addr, alignment), \"Unaligned address\");\n-\n-  if (!is_aligned(bytes, os::large_page_size())) {\n-    return nullptr; \/\/ Fallback to small pages.\n-  }\n-\n-  \/\/ Create a large shared memory region to attach to based on size.\n-  \/\/ Currently, size is the total size of the heap.\n-  int shmid = shmget(IPC_PRIVATE, bytes, SHM_HUGETLB|IPC_CREAT|SHM_R|SHM_W);\n-  if (shmid == -1) {\n-    \/\/ Possible reasons for shmget failure:\n-    \/\/ 1. shmmax is too small for the request.\n-    \/\/    > check shmmax value: cat \/proc\/sys\/kernel\/shmmax\n-    \/\/    > increase shmmax value: echo \"new_value\" > \/proc\/sys\/kernel\/shmmax\n-    \/\/ 2. not enough large page memory.\n-    \/\/    > check available large pages: cat \/proc\/meminfo\n-    \/\/    > increase amount of large pages:\n-    \/\/          sysctl -w vm.nr_hugepages=new_value\n-    \/\/    > For more information regarding large pages please refer to:\n-    \/\/      https:\/\/www.kernel.org\/doc\/Documentation\/vm\/hugetlbpage.txt\n-    \/\/      Note 1: different Linux may use different name for this property,\n-    \/\/            e.g. on Redhat AS-3 it is \"hugetlb_pool\".\n-    \/\/      Note 2: it's possible there's enough physical memory available but\n-    \/\/            they are so fragmented after a long run that they can't\n-    \/\/            coalesce into large pages. Try to reserve large pages when\n-    \/\/            the system is still \"fresh\".\n-    shm_warning_with_errno(\"Failed to reserve shared memory.\");\n-    return nullptr;\n-  }\n-\n-  \/\/ Attach to the region.\n-  char* addr = shmat_large_pages(shmid, bytes, alignment, req_addr);\n-\n-  \/\/ Remove shmid. If shmat() is successful, the actual shared memory segment\n-  \/\/ will be deleted when it's detached by shmdt() or when the process\n-  \/\/ terminates. If shmat() is not successful this will remove the shared\n-  \/\/ segment immediately.\n-  shmctl(shmid, IPC_RMID, nullptr);\n-\n-  return addr;\n-}\n-\n@@ -4056,1 +3847,1 @@\n-bool os::Linux::commit_memory_special(size_t bytes,\n+static bool commit_memory_special(size_t bytes,\n@@ -4060,1 +3851,1 @@\n-  assert(UseLargePages && UseHugeTLBFS, \"Should only get here when HugeTLBFS large pages are used\");\n+  assert(UseLargePages && !UseTransparentHugePages, \"Should only get here for static hugepage mode (+UseLargePages)\");\n@@ -4089,6 +3880,7 @@\n-char* os::Linux::reserve_memory_special_huge_tlbfs(size_t bytes,\n-                                                   size_t alignment,\n-                                                   size_t page_size,\n-                                                   char* req_addr,\n-                                                   bool exec) {\n-  assert(UseLargePages && UseHugeTLBFS, \"only for Huge TLBFS large pages\");\n+static char* reserve_memory_special_huge_tlbfs(size_t bytes,\n+                                               size_t alignment,\n+                                               size_t page_size,\n+                                               char* req_addr,\n+                                               bool exec) {\n+  const os::PageSizes page_sizes = HugePages::static_info().pagesizes();\n+  assert(UseLargePages, \"only for Huge TLBFS large pages\");\n@@ -4098,1 +3890,1 @@\n-  assert(_page_sizes.contains(page_size), \"Must be a valid page size\");\n+  assert(page_sizes.contains(page_size), \"Must be a valid page size\");\n@@ -4151,8 +3943,1 @@\n-  char* addr;\n-  if (UseSHM) {\n-    \/\/ No support for using specific page sizes with SHM.\n-    addr = os::Linux::reserve_memory_special_shm(bytes, alignment, req_addr, exec);\n-  } else {\n-    assert(UseHugeTLBFS, \"must be\");\n-    addr = os::Linux::reserve_memory_special_huge_tlbfs(bytes, alignment, page_size, req_addr, exec);\n-  }\n+  char* const addr = reserve_memory_special_huge_tlbfs(bytes, alignment, page_size, req_addr, exec);\n@@ -4169,9 +3954,0 @@\n-bool os::Linux::release_memory_special_shm(char* base, size_t bytes) {\n-  \/\/ detaching the SHM segment will also delete it, see reserve_memory_special_shm()\n-  return shmdt(base) == 0;\n-}\n-\n-bool os::Linux::release_memory_special_huge_tlbfs(char* base, size_t bytes) {\n-  return pd_release_memory(base, bytes);\n-}\n-\n@@ -4180,9 +3956,2 @@\n-  bool res;\n-\n-  if (UseSHM) {\n-    res = os::Linux::release_memory_special_shm(base, bytes);\n-  } else {\n-    assert(UseHugeTLBFS, \"must be\");\n-    res = os::Linux::release_memory_special_huge_tlbfs(base, bytes);\n-  }\n-  return res;\n+  \/\/ Plain munmap is sufficient\n+  return pd_release_memory(base, bytes);\n@@ -4195,4 +3964,3 @@\n-\/\/ With SysV SHM the entire memory region must be allocated as shared\n-\/\/ memory.\n-\/\/ HugeTLBFS allows application to commit large page memory on demand.\n-\/\/ However, when committing memory with HugeTLBFS fails, the region\n+\/\/ static hugepages (hugetlbfs) allow application to commit large page memory\n+\/\/ on demand.\n+\/\/ However, when committing memory with hugepages fails, the region\n@@ -4201,1 +3969,2 @@\n-\/\/ behavior we can't commit HugeTLBFS memory.\n+\/\/ behavior we can't commit hugetlbfs memory. Instead, we commit that\n+\/\/ memory at reservation.\n@@ -4207,1 +3976,1 @@\n-  return UseTransparentHugePages || UseHugeTLBFS;\n+  return UseTransparentHugePages;\n@@ -4553,1 +4322,1 @@\n-    \/\/ With SHM and HugeTLBFS large pages we cannot uncommit a page, so there's no way\n+    \/\/ With static large pages we cannot uncommit a page, so there's no way\n@@ -4555,2 +4324,1 @@\n-    \/\/ UseNUMA and UseLargePages (or UseSHM\/UseHugeTLBFS) on the command line - warn\n-    \/\/ and disable adaptive resizing.\n+    \/\/ UseNUMA and UseLargePages on the command line - warn and disable adaptive resizing.\n@@ -4558,1 +4326,1 @@\n-      warning(\"UseNUMA is not fully compatible with SHM\/HugeTLBFS large pages, \"\n+      warning(\"UseNUMA is not fully compatible with +UseLargePages, \"\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":55,"deletions":287,"binary":false,"changes":342,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-  friend class TestReserveMemorySpecial;\n@@ -78,14 +77,0 @@\n-  static bool setup_large_page_type(size_t page_size);\n-  static bool hugetlbfs_sanity_check(bool warn, size_t page_size);\n-  static bool shm_hugetlbfs_sanity_check(bool warn, size_t page_size);\n-\n-  static int hugetlbfs_page_size_flag(size_t page_size);\n-\n-  static char* reserve_memory_special_shm(size_t bytes, size_t alignment, char* req_addr, bool exec);\n-  static char* reserve_memory_special_huge_tlbfs(size_t bytes, size_t alignment, size_t page_size, char* req_addr, bool exec);\n-  static bool commit_memory_special(size_t bytes, size_t page_size, char* req_addr, bool exec);\n-\n-  static bool release_memory_special_impl(char* base, size_t bytes);\n-  static bool release_memory_special_shm(char* base, size_t bytes);\n-  static bool release_memory_special_huge_tlbfs(char* base, size_t bytes);\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -528,0 +528,5 @@\n+#ifdef LINUX\n+  { \"UseHugeTLBFS\",                 JDK_Version::undefined(), JDK_Version::jdk(22), JDK_Version::jdk(23) },\n+  { \"UseSHM\",                       JDK_Version::undefined(), JDK_Version::jdk(22), JDK_Version::jdk(23) },\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1815,13 +1815,0 @@\n-\\f[V]-XX:+UseHugeTLBFS\\f[R]\n-\\f[B]Linux only:\\f[R] This option is the equivalent of specifying\n-\\f[V]-XX:+UseLargePages\\f[R].\n-This option is disabled by default.\n-This option pre-allocates all large pages up-front, when memory is\n-reserved; consequently the JVM can\\[aq]t dynamically grow or shrink\n-large pages memory areas; see \\f[V]-XX:UseTransparentHugePages\\f[R] if\n-you want this behavior.\n-.RS\n-.PP\n-See \\f[B]Large Pages\\f[R].\n-.RE\n-.TP\n@@ -3658,8 +3645,0 @@\n-\\f[V]-XX:+UseSHM\\f[R]\n-\\f[B]Linux only:\\f[R] Enables the JVM to use shared memory to set up\n-large pages.\n-.RS\n-.PP\n-See \\f[B]Large Pages\\f[R] for setting up large pages.\n-.RE\n-.TP\n@@ -4918,14 +4897,0 @@\n-.PP\n-When using the option \\f[V]-XX:+UseSHM\\f[R] to enable large pages you\n-also need to make sure the \\f[V]SHMMAX\\f[R] parameter is configured to\n-allow large enough shared memory segments to be allocated.\n-To allow a maximum shared segment of 8 GB, login as \\f[V]root\\f[R] and\n-run:\n-.RS\n-.PP\n-\\f[V]# echo 8589934592 > \/proc\/sys\/kernel\/shmmax\\f[R]\n-.RE\n-.PP\n-In some environments this is not needed since the default value is large\n-enough, but it is important to make sure the value is large enough to\n-fit the amount of memory intended to be backed by large pages.\n","filename":"src\/java.base\/share\/man\/java.1","additions":0,"deletions":35,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+static bool using_static_hugepages()  { return UseLargePages && !UseTransparentHugePages; }\n@@ -56,1 +57,1 @@\n-      return os::Linux::reserve_memory_special_huge_tlbfs(bytes, alignment, page_size, req_addr, exec);\n+      return os::reserve_memory_special(bytes, alignment, page_size, req_addr, exec);\n@@ -61,1 +62,1 @@\n-        os::Linux::release_memory_special_huge_tlbfs(_ptr, _size);\n+        os::release_memory_special(_ptr, _size);\n@@ -66,13 +67,0 @@\n-  class ShmMemory : private ::os::Linux {\n-    char* const _ptr;\n-    const size_t _size;\n-   public:\n-    static char* reserve_memory_special_shm(size_t bytes, size_t alignment, char* req_addr, bool exec) {\n-      return os::Linux::reserve_memory_special_shm(bytes, alignment, req_addr, exec);\n-    }\n-    ShmMemory(char* const ptr, size_t size) : _ptr(ptr), _size(size) { }\n-    ~ShmMemory() {\n-      os::Linux::release_memory_special_shm(_ptr, _size);\n-    }\n-  };\n-\n@@ -87,12 +75,0 @@\n-\n-  static void test_reserve_memory_special_shm(size_t size, size_t alignment) {\n-    ASSERT_TRUE(UseSHM) << \"must be used only when UseSHM is true\";\n-    char* addr = ShmMemory::reserve_memory_special_shm(size, alignment, NULL, false);\n-    if (addr != NULL) {\n-      ShmMemory mr(addr, size);\n-      EXPECT_PRED2(is_ptr_aligned, addr, alignment);\n-      EXPECT_PRED2(is_ptr_aligned, addr, os::large_page_size());\n-\n-      small_page_write(addr, size);\n-    }\n-  }\n@@ -102,1 +78,1 @@\n-  if (!UseHugeTLBFS) {\n+  if (!using_static_hugepages()) {\n@@ -118,1 +94,1 @@\n-  if (!UseHugeTLBFS) {\n+  if (!using_static_hugepages()) {\n@@ -145,1 +121,1 @@\n-  if (!UseHugeTLBFS) {\n+  if (!using_static_hugepages()) {\n@@ -186,1 +162,1 @@\n-  if (!UseHugeTLBFS) {\n+  if (!using_static_hugepages()) {\n@@ -236,14 +212,0 @@\n-TEST_VM(os_linux, reserve_memory_special_shm) {\n-  if (!UseSHM) {\n-    return;\n-  }\n-  size_t lp = os::large_page_size();\n-  size_t ag = os::vm_allocation_granularity();\n-\n-  for (size_t size = ag; size < lp * 3; size += ag) {\n-    for (size_t alignment = ag; is_size_aligned(size, alignment); alignment *= 2) {\n-      EXPECT_NO_FATAL_FAILURE(test_reserve_memory_special_shm(size, alignment));\n-    }\n-  }\n-}\n-\n@@ -262,1 +224,1 @@\n-    if (!UseHugeTLBFS) {\n+    if (!using_static_hugepages()) {\n@@ -265,3 +227,1 @@\n-\n-    char* addr = os::Linux::reserve_memory_special_huge_tlbfs(size, alignment, page_size, NULL, false);\n-\n+    char* addr = os::reserve_memory_special(size, alignment, page_size, NULL, false);\n@@ -270,2 +230,1 @@\n-\n-      os::Linux::release_memory_special_huge_tlbfs(addr, size);\n+      os::release_memory_special(addr, size);\n@@ -276,1 +235,1 @@\n-    if (!UseHugeTLBFS) {\n+    if (!using_static_hugepages()) {\n@@ -279,1 +238,0 @@\n-\n@@ -281,1 +239,0 @@\n-\n@@ -327,1 +284,1 @@\n-        char* p = os::Linux::reserve_memory_special_huge_tlbfs(size, alignment, lp, NULL, false);\n+        char* p = os::reserve_memory_special(size, alignment, lp, NULL, false);\n@@ -331,1 +288,1 @@\n-          os::Linux::release_memory_special_huge_tlbfs(p, size);\n+          os::release_memory_special(p, size);\n@@ -342,1 +299,1 @@\n-        char* p = os::Linux::reserve_memory_special_huge_tlbfs(size, alignment, lp, req_addr, false);\n+        char* p = os::reserve_memory_special(size, alignment, lp, req_addr, false);\n@@ -346,1 +303,1 @@\n-          os::Linux::release_memory_special_huge_tlbfs(p, size);\n+          os::release_memory_special(p, size);\n@@ -357,1 +314,1 @@\n-        char* p = os::Linux::reserve_memory_special_huge_tlbfs(size, alignment, lp, req_addr, false);\n+        char* p = os::reserve_memory_special(size, alignment, lp, req_addr, false);\n@@ -368,2 +325,2 @@\n-  static void test_reserve_memory_special_huge_tlbfs() {\n-    if (!UseHugeTLBFS) {\n+  static void test() {\n+    if (!using_static_hugepages()) {\n@@ -372,1 +329,0 @@\n-\n@@ -376,33 +332,0 @@\n-\n-  static void test_reserve_memory_special_shm(size_t size, size_t alignment) {\n-    if (!UseSHM) {\n-      return;\n-    }\n-\n-    char* addr = os::Linux::reserve_memory_special_shm(size, alignment, NULL, false);\n-\n-    if (addr != NULL) {\n-      EXPECT_TRUE(is_aligned(addr, alignment));\n-      EXPECT_TRUE(is_aligned(addr, os::large_page_size()));\n-\n-      small_page_write(addr, size);\n-\n-      os::Linux::release_memory_special_shm(addr, size);\n-    }\n-  }\n-\n-  static void test_reserve_memory_special_shm() {\n-    size_t lp = os::large_page_size();\n-    size_t ag = os::vm_allocation_granularity();\n-\n-    for (size_t size = ag; size < lp * 3; size += ag) {\n-      for (size_t alignment = ag; is_aligned(size, alignment); alignment *= 2) {\n-        test_reserve_memory_special_shm(size, alignment);\n-      }\n-    }\n-  }\n-\n-  static void test() {\n-    test_reserve_memory_special_huge_tlbfs();\n-    test_reserve_memory_special_shm();\n-  }\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux.cpp","additions":18,"deletions":95,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UseHugeTLBFS -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.arguments.TestSmallInitialHeapWithLargePageAndNUMA\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.arguments.TestSmallInitialHeapWithLargePageAndNUMA\n@@ -68,1 +68,0 @@\n-        \"-XX:+UseHugeTLBFS\",\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestSmallInitialHeapWithLargePageAndNUMA.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -58,10 +58,0 @@\n-\n-\/* @test id=use-large-pages-sysV\n- * @summary Run metaspace-related gtests for reclaim policy none (with verifications)\n- * @requires os.family == \"linux\"\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.xml\n- * @requires vm.flagless\n- * @run main\/native GTestWrapper --gtest_filter=os* -XX:-PrintWarnings -XX:+UseLargePages -XX:+UseSHM\n- *\/\n","filename":"test\/hotspot\/jtreg\/gtest\/LargePageGtests.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,3 +46,0 @@\n-    testUseHugeTLBFS();\n-    testUseSHM();\n-    testCombinations();\n@@ -63,3 +60,1 @@\n-           UseTransparentHugePages(false),\n-           UseHugeTLBFS(false),\n-           UseSHM(false));\n+           UseTransparentHugePages(false));\n@@ -72,3 +67,1 @@\n-           UseTransparentHugePages(true),\n-           UseHugeTLBFS(false),\n-           UseSHM(false));\n+           UseTransparentHugePages(true));\n@@ -81,3 +74,1 @@\n-           UseTransparentHugePages(true),\n-           UseHugeTLBFS(false),\n-           UseSHM(false));\n+           UseTransparentHugePages(true));\n@@ -92,3 +83,1 @@\n-           UseTransparentHugePages(false),\n-           UseHugeTLBFS(false),\n-           UseSHM(false));\n+           UseTransparentHugePages(false));\n@@ -104,186 +93,0 @@\n-  public static void testUseHugeTLBFS() throws Exception {\n-    if (!canUse(UseHugeTLBFS(true))) {\n-      System.out.println(\"Skipping testUseHugeTLBFS\");\n-      return;\n-    }\n-\n-    \/\/ -XX:-UseLargePages overrides all other flags.\n-    new FlagTester()\n-      .use(UseLargePages(false),\n-           UseHugeTLBFS(true))\n-      .expect(\n-           UseLargePages(false),\n-           UseTransparentHugePages(false),\n-           UseHugeTLBFS(false),\n-           UseSHM(false));\n-\n-    \/\/ Explicitly turn on UseHugeTLBFS.\n-    new FlagTester()\n-      .use(UseHugeTLBFS(true))\n-      .expect(\n-           UseLargePages(true),\n-           UseTransparentHugePages(false),\n-           UseHugeTLBFS(true),\n-           UseSHM(false));\n-\n-    new FlagTester()\n-      .use(UseLargePages(true),\n-           UseHugeTLBFS(true))\n-      .expect(\n-           UseLargePages(true),\n-           UseTransparentHugePages(false),\n-           UseHugeTLBFS(true),\n-           UseSHM(false));\n-\n-    \/\/ Setting a specific large pages flag will turn\n-    \/\/ off heuristics to choose large pages type.\n-    new FlagTester()\n-      .use(UseLargePages(true),\n-           UseHugeTLBFS(false))\n-      .expect(\n-           UseLargePages(false),\n-           UseTransparentHugePages(false),\n-           UseHugeTLBFS(false),\n-           UseSHM(false));\n-\n-    \/\/ Using UseLargePages will default to UseHugeTLBFS large pages.\n-    new FlagTester()\n-      .use(UseLargePages(true))\n-      .expect(\n-           UseLargePages(true),\n-           UseTransparentHugePages(false),\n-           UseHugeTLBFS(true),\n-           UseSHM(false));\n-  }\n-\n-  public static void testUseSHM() throws Exception {\n-    if (!canUse(UseSHM(true))) {\n-      System.out.println(\"Skipping testUseSHM\");\n-      return;\n-    }\n-\n-    \/\/ -XX:-UseLargePages overrides all other flags.\n-    new FlagTester()\n-      .use(UseLargePages(false),\n-           UseSHM(true))\n-      .expect(\n-           UseLargePages(false),\n-           UseTransparentHugePages(false),\n-           UseHugeTLBFS(false),\n-           UseSHM(false));\n-\n-    \/\/ Explicitly turn on UseSHM.\n-    new FlagTester()\n-      .use(UseSHM(true))\n-      .expect(\n-           UseLargePages(true),\n-           UseTransparentHugePages(false),\n-           UseHugeTLBFS(false),\n-           UseSHM(true)) ;\n-\n-    new FlagTester()\n-      .use(UseLargePages(true),\n-           UseSHM(true))\n-      .expect(\n-           UseLargePages(true),\n-           UseTransparentHugePages(false),\n-           UseHugeTLBFS(false),\n-           UseSHM(true)) ;\n-\n-    \/\/ Setting a specific large pages flag will turn\n-    \/\/ off heuristics to choose large pages type.\n-    new FlagTester()\n-      .use(UseLargePages(true),\n-           UseSHM(false))\n-      .expect(\n-           UseLargePages(false),\n-           UseTransparentHugePages(false),\n-           UseHugeTLBFS(false),\n-           UseSHM(false));\n-\n-    \/\/ Setting UseLargePages can allow the system to choose\n-    \/\/ UseHugeTLBFS instead of UseSHM, but never UseTransparentHugePages.\n-    new FlagTester()\n-      .use(UseLargePages(true))\n-      .expect(\n-           UseLargePages(true),\n-           UseTransparentHugePages(false));\n-  }\n-\n-  public static void testCombinations() throws Exception {\n-    if (!canUse(UseSHM(true)) || !canUse(UseHugeTLBFS(true))) {\n-      System.out.println(\"Skipping testUseHugeTLBFSAndUseSHMCombination\");\n-      return;\n-    }\n-\n-    \/\/ UseHugeTLBFS takes precedence over SHM.\n-\n-    new FlagTester()\n-      .use(UseLargePages(true),\n-           UseHugeTLBFS(true),\n-           UseSHM(true))\n-      .expect(\n-           UseLargePages(true),\n-           UseTransparentHugePages(false),\n-           UseHugeTLBFS(true),\n-           UseSHM(false));\n-\n-    new FlagTester()\n-      .use(UseLargePages(true),\n-           UseHugeTLBFS(false),\n-           UseSHM(true))\n-      .expect(\n-           UseLargePages(true),\n-           UseTransparentHugePages(false),\n-           UseHugeTLBFS(false),\n-           UseSHM(true));\n-\n-    new FlagTester()\n-      .use(UseLargePages(true),\n-           UseHugeTLBFS(true),\n-           UseSHM(false))\n-      .expect(\n-           UseLargePages(true),\n-           UseTransparentHugePages(false),\n-           UseHugeTLBFS(true),\n-           UseSHM(false));\n-\n-    new FlagTester()\n-      .use(UseLargePages(true),\n-           UseHugeTLBFS(false),\n-           UseSHM(false))\n-      .expect(\n-           UseLargePages(false),\n-           UseTransparentHugePages(false),\n-           UseHugeTLBFS(false),\n-           UseSHM(false));\n-\n-\n-    if (!canUse(UseTransparentHugePages(true))) {\n-      return;\n-    }\n-\n-    \/\/ UseTransparentHugePages takes precedence.\n-\n-    new FlagTester()\n-      .use(UseLargePages(true),\n-           UseTransparentHugePages(true),\n-           UseHugeTLBFS(true),\n-           UseSHM(true))\n-      .expect(\n-           UseLargePages(true),\n-           UseTransparentHugePages(true),\n-           UseHugeTLBFS(false),\n-           UseSHM(false));\n-\n-    new FlagTester()\n-      .use(UseTransparentHugePages(true),\n-           UseHugeTLBFS(true),\n-           UseSHM(true))\n-      .expect(\n-           UseLargePages(true),\n-           UseTransparentHugePages(true),\n-           UseHugeTLBFS(false),\n-           UseSHM(false));\n-  }\n-\n@@ -307,0 +110,1 @@\n+      output.reportDiagnosticSummary();\n@@ -332,1 +136,1 @@\n-    args.add(\"-XX:+PrintFlagsFinal\");\n+    args.add(\"-Xlog:pagesize\");\n@@ -360,8 +164,0 @@\n-  private static Flag UseHugeTLBFS(boolean value) {\n-    return new BooleanFlag(\"UseHugeTLBFS\", value);\n-  }\n-\n-  private static Flag UseSHM(boolean value) {\n-    return new BooleanFlag(\"UseSHM\", value);\n-  }\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/memory\/LargePages\/TestLargePagesFlags.java","additions":6,"deletions":210,"binary":false,"changes":216,"status":"modified"}]}