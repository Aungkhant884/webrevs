{"files":[{"patch":"@@ -914,1 +914,0 @@\n-        @SuppressWarnings(\"try\")\n@@ -1594,2 +1593,3 @@\n-                    try (var guard = NIO_ACCESS.acquireScope(dst)) {\n-                        Unsafe.getUnsafe().setMemory(guard.address(),\n+                    var scope = NIO_ACCESS.acquireScopeOrNull(dst);\n+                    try {\n+                        Unsafe.getUnsafe().setMemory(((DirectBuffer)dst).address(),\n@@ -1597,0 +1597,2 @@\n+                    } finally {\n+                        NIO_ACCESS.releaseScope(dst, scope);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.lang.ref.Reference;\n@@ -827,1 +828,1 @@\n-                public Runnable acquireSessionOrNull(Buffer buffer, boolean async) {\n+                public Runnable acquireScopeOrNull(Buffer buffer, boolean async) {\n@@ -840,1 +841,1 @@\n-                public ScopeAcquisition acquireScope(Buffer buffer) {\n+                public MemorySessionImpl acquireScopeOrNull(Buffer buffer) {\n@@ -843,1 +844,1 @@\n-                        return ScopeAcquisition.create(buffer);\n+                        return null;\n@@ -846,1 +847,13 @@\n-                    return ScopeAcquisition.create(buffer, scope);\n+                    return scope;\n+                }\n+\n+                @Override\n+                public void releaseScope(Buffer buffer, MemorySessionImpl scope) {\n+                    assert buffer.session() == scope;\n+                    try {\n+                        if (scope != null) {\n+                            scope.release0();\n+                        }\n+                    } finally {\n+                        Reference.reachabilityFence(buffer);\n+                    }\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import sun.nio.ch.DirectBuffer;\n@@ -100,2 +101,5 @@\n-            try (var guard = NIO_ACCESS.acquireScope(buffer)) {\n-                adler = updateByteBuffer(adler, guard.address(), pos, rem);\n+            var scope = NIO_ACCESS.acquireScopeOrNull(buffer);\n+            try {\n+                adler = updateByteBuffer(adler, ((DirectBuffer)buffer).address(), pos, rem);\n+            } finally {\n+                NIO_ACCESS.releaseScope(buffer, scope);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Adler32.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import sun.nio.ch.DirectBuffer;\n@@ -99,2 +100,5 @@\n-            try (var guard = NIO_ACCESS.acquireScope(buffer)) {\n-                crc = updateByteBuffer(crc, guard.address(), pos, rem);\n+            var scope = NIO_ACCESS.acquireScopeOrNull(buffer);\n+            try {\n+                crc = updateByteBuffer(crc, ((DirectBuffer)buffer).address(), pos, rem);\n+            } finally {\n+                NIO_ACCESS.releaseScope(buffer, scope);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/CRC32.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import sun.nio.ch.DirectBuffer;\n@@ -174,2 +175,3 @@\n-            try (var guard = NIO_ACCESS.acquireScope(buffer)) {\n-                crc = updateDirectByteBuffer(crc, guard.address(),\n+            var scope = NIO_ACCESS.acquireScopeOrNull(buffer);\n+            try {\n+                crc = updateDirectByteBuffer(crc, ((DirectBuffer)buffer).address(),\n@@ -177,0 +179,2 @@\n+            } finally {\n+                NIO_ACCESS.releaseScope(buffer, scope);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/CRC32C.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import sun.nio.ch.DirectBuffer;\n@@ -340,2 +341,5 @@\n-                try (var guard = NIO_ACCESS.acquireScope(dictionary)) {\n-                    setDictionaryBuffer(zsRef.address(), guard.address() + position, remaining);\n+                var scope = NIO_ACCESS.acquireScopeOrNull(dictionary);\n+                try {\n+                    setDictionaryBuffer(zsRef.address(), ((DirectBuffer)dictionary).address() + position, remaining);\n+                } finally {\n+                    NIO_ACCESS.releaseScope(dictionary, scope);\n@@ -587,1 +591,2 @@\n-                    try (var guard = NIO_ACCESS.acquireScope(input)) {\n+                    var scope = NIO_ACCESS.acquireScopeOrNull(input);\n+                    try {\n@@ -589,1 +594,1 @@\n-                            guard.address() + inputPos, inputRem,\n+                                ((DirectBuffer)input).address() + inputPos, inputRem,\n@@ -592,0 +597,2 @@\n+                    } finally {\n+                        NIO_ACCESS.releaseScope(input, scope);\n@@ -706,1 +713,2 @@\n-                    try (var guard = NIO_ACCESS.acquireScope(output)) {\n+                    var outScope = NIO_ACCESS.acquireScopeOrNull(output);\n+                    try {\n@@ -709,1 +717,1 @@\n-                                guard.address() + outputPos, outputRem,\n+                                ((DirectBuffer)output).address() + outputPos, outputRem,\n@@ -711,0 +719,2 @@\n+                    } finally {\n+                        NIO_ACCESS.releaseScope(output, outScope);\n@@ -724,1 +734,2 @@\n-                    try (var inGuard = NIO_ACCESS.acquireScope(input)) {\n+                    var inScope = NIO_ACCESS.acquireScopeOrNull(input);\n+                    try {\n@@ -726,1 +737,2 @@\n-                            try (var outGuard = NIO_ACCESS.acquireScope(output)) {\n+                            var outScope = NIO_ACCESS.acquireScopeOrNull(output);\n+                            try {\n@@ -728,2 +740,2 @@\n-                                    inGuard.address() + inputPos, inputRem,\n-                                    outGuard.address(), outputRem,\n+                                    ((DirectBuffer)input).address() + inputPos, inputRem,\n+                                    ((DirectBuffer)output).address(), outputRem,\n@@ -731,0 +743,2 @@\n+                            } finally {\n+                                NIO_ACCESS.releaseScope(output, outScope);\n@@ -736,1 +750,1 @@\n-                                inGuard.address() + inputPos, inputRem,\n+                                    ((DirectBuffer)input).address() + inputPos, inputRem,\n@@ -740,0 +754,2 @@\n+                    } finally {\n+                        NIO_ACCESS.releaseScope(input, inScope);\n@@ -745,1 +761,2 @@\n-                        try (var guard = NIO_ACCESS.acquireScope(output)) {\n+                        var outScope = NIO_ACCESS.acquireScopeOrNull(output);\n+                        try {\n@@ -748,1 +765,1 @@\n-                                guard.address()+ outputPos, outputRem,\n+                                ((DirectBuffer)output).address()+ outputPos, outputRem,\n@@ -750,0 +767,2 @@\n+                        } finally {\n+                            NIO_ACCESS.releaseScope(output, outScope);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Deflater.java","additions":32,"deletions":13,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import sun.nio.ch.DirectBuffer;\n@@ -262,2 +263,5 @@\n-                try (var guard = NIO_ACCESS.acquireScope(dictionary)) {\n-                    setDictionaryBuffer(zsRef.address(), guard.address() + position, remaining);\n+                var scope = NIO_ACCESS.acquireScopeOrNull(dictionary);\n+                try {\n+                    setDictionaryBuffer(zsRef.address(), ((DirectBuffer)dictionary).address() + position, remaining);\n+                } finally {\n+                    NIO_ACCESS.releaseScope(dictionary, scope);\n@@ -383,1 +387,2 @@\n-                            try (var guard = NIO_ACCESS.acquireScope(input)) {\n+                            var inScope = NIO_ACCESS.acquireScopeOrNull(input);\n+                            try {\n@@ -385,1 +390,1 @@\n-                                    guard.address() + inputPos, inputRem,\n+                                    ((DirectBuffer)input).address() + inputPos, inputRem,\n@@ -387,0 +392,2 @@\n+                            } finally {\n+                                NIO_ACCESS.releaseScope(input, inScope);\n@@ -514,1 +521,2 @@\n-                            try (var guard = NIO_ACCESS.acquireScope(output)) {\n+                            var outScope = NIO_ACCESS.acquireScopeOrNull(output);\n+                            try {\n@@ -517,1 +525,3 @@\n-                                    guard.address() + outputPos, outputRem);\n+                                    ((DirectBuffer)output).address() + outputPos, outputRem);\n+                            } finally {\n+                                NIO_ACCESS.releaseScope(output, outScope);\n@@ -535,1 +545,2 @@\n-                            try (var inGuard = NIO_ACCESS.acquireScope(input)) {\n+                            var inScope = NIO_ACCESS.acquireScopeOrNull(input);\n+                            try {\n@@ -537,1 +548,2 @@\n-                                    try (var outGuard = NIO_ACCESS.acquireScope(output)) {\n+                                    var outScope = NIO_ACCESS.acquireScopeOrNull(output);\n+                                    try {\n@@ -539,2 +551,4 @@\n-                                            inGuard.address() + inputPos, inputRem,\n-                                            outGuard.address() + outputPos, outputRem);\n+                                            ((DirectBuffer)input).address() + inputPos, inputRem,\n+                                            ((DirectBuffer)output).address() + outputPos, outputRem);\n+                                    } finally {\n+                                        NIO_ACCESS.releaseScope(output, outScope);\n@@ -546,1 +560,1 @@\n-                                        inGuard.address() + inputPos, inputRem,\n+                                        ((DirectBuffer)input).address() + inputPos, inputRem,\n@@ -549,0 +563,2 @@\n+                            } finally {\n+                                NIO_ACCESS.releaseScope(input, inScope);\n@@ -554,1 +570,2 @@\n-                                try (var guard = NIO_ACCESS.acquireScope(output)) {\n+                                var outScope = NIO_ACCESS.acquireScopeOrNull(output);\n+                                try {\n@@ -557,1 +574,3 @@\n-                                        guard.address() + outputPos, outputRem);\n+                                        ((DirectBuffer)output).address() + outputPos, outputRem);\n+                                } finally {\n+                                    NIO_ACCESS.releaseScope(output, outScope);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Inflater.java","additions":32,"deletions":13,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -97,1 +98,1 @@\n-     * var handler = acquireSessionOrNull(buffer, async);\n+     * var handler = acquireScopeOrNull(buffer, async);\n@@ -106,2 +107,0 @@\n-     *\n-     * @see #acquireScope(Buffer)\n@@ -109,1 +108,1 @@\n-    Runnable acquireSessionOrNull(Buffer buffer, boolean async);\n+    Runnable acquireScopeOrNull(Buffer buffer, boolean async);\n@@ -114,2 +113,1 @@\n-     * A valid close handler is always returned (if the buffer has no scope, or acquiring is not\n-     * required to guarantee safety, a noop close handler is returned).\n+     * The buffers scope is returned if it has one, otherwise {@code null} is returned.\n@@ -117,1 +115,2 @@\n-     * try (var guard = acquireScope(buffer)) {\n+     * var guard = acquireScopeOrNull(buffer);\n+     * try {\n@@ -119,0 +118,2 @@\n+     * } finally {\n+     *     releaseScope(buffer, guard);\n@@ -122,1 +123,1 @@\n-     * @see #acquireSessionOrNull(Buffer, boolean)\n+     * @see #releaseScope(Buffer, MemorySessionImpl)\n@@ -124,1 +125,3 @@\n-    ScopeAcquisition acquireScope(Buffer buffer);\n+    MemorySessionImpl acquireScopeOrNull(Buffer buffer);\n+\n+    void releaseScope(Buffer buffer, MemorySessionImpl scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioAccess.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -787,1 +787,2 @@\n-        try (var guard = NIO_ACCESS.acquireScope(bb)) {\n+        var scope = NIO_ACCESS.acquireScopeOrNull(bb);\n+        try {\n@@ -789,1 +790,1 @@\n-                    guard.address() + pos, rem,\n+                    ((DirectBuffer)bb).address() + pos, rem,\n@@ -795,0 +796,2 @@\n+        } finally {\n+            NIO_ACCESS.releaseScope(bb, scope);\n@@ -939,1 +942,2 @@\n-        try (var guard = NIO_ACCESS.acquireScope(bb)) {\n+        var scope = NIO_ACCESS.acquireScopeOrNull(bb);\n+        try {\n@@ -941,1 +945,1 @@\n-            written = send0(fd, guard.address() + pos, rem,\n+            written = send0(fd, ((DirectBuffer)bb).address() + pos, rem,\n@@ -947,0 +951,2 @@\n+        } finally {\n+            NIO_ACCESS.releaseScope(bb, scope);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -478,1 +478,1 @@\n-        return NIO_ACCESS.acquireSessionOrNull(bb, async);\n+        return NIO_ACCESS.acquireScopeOrNull(bb, async);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOUtil.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -181,3 +181,4 @@\n-        if (dst instanceof sun.nio.ch.DirectBuffer) {\n-            try (var guard = NIO_ACCESS.acquireScope(dst)) {\n-                long address = guard.address() + pos;\n+        if (dst instanceof sun.nio.ch.DirectBuffer ddst) {\n+            var scope = NIO_ACCESS.acquireScopeOrNull(dst);\n+            try {\n+                long address = ddst.address() + pos;\n@@ -187,0 +188,2 @@\n+            } finally {\n+                NIO_ACCESS.releaseScope(dst, scope);\n@@ -241,3 +244,4 @@\n-        if (src instanceof sun.nio.ch.DirectBuffer) {\n-            try (var guard = NIO_ACCESS.acquireScope(src)) {\n-                long address = guard.address() + pos;\n+        if (src instanceof sun.nio.ch.DirectBuffer dsrc) {\n+            var scope = NIO_ACCESS.acquireScopeOrNull(src);\n+            try {\n+                long address = dsrc.address() + pos;\n@@ -247,0 +251,2 @@\n+            } finally {\n+                NIO_ACCESS.releaseScope(src, scope);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUserDefinedFileAttributeView.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -741,24 +741,19 @@\n-        try (var inGuard = NIO_ACCESS.acquireScope(inBuffer);\n-             var outGuard = NIO_ACCESS.acquireScope(outBuffer)) {\n-            ensureInitialized();\n-\n-            long inAddr = 0;\n-            byte[] in = null;\n-            int inOfs = 0;\n-            if (dataBuffer.size() > 0) {\n-                if (inLen > 0) {\n-                    byte[] temp = new byte[inLen];\n-                    inBuffer.get(temp);\n-                    dataBuffer.write(temp, 0, temp.length);\n-                }\n-                in = dataBuffer.toByteArray();\n-                inOfs = 0;\n-                inLen = in.length;\n-            } else {\n-                if (inBuffer instanceof DirectBuffer) {\n-                    inAddr = inGuard.address();\n-                    inOfs = inBuffer.position();\n-                } else {\n-                    if (inBuffer.hasArray()) {\n-                        in = inBuffer.array();\n-                        inOfs = inBuffer.position() + inBuffer.arrayOffset();\n+        var inScope = NIO_ACCESS.acquireScopeOrNull(inBuffer);\n+        try {\n+            var outScope = NIO_ACCESS.acquireScopeOrNull(outBuffer);\n+            try {\n+                try {\n+                    ensureInitialized();\n+\n+                    long inAddr = 0;\n+                    byte[] in = null;\n+                    int inOfs = 0;\n+                    if (dataBuffer.size() > 0) {\n+                        if (inLen > 0) {\n+                            byte[] temp = new byte[inLen];\n+                            inBuffer.get(temp);\n+                            dataBuffer.write(temp, 0, temp.length);\n+                        }\n+                        in = dataBuffer.toByteArray();\n+                        inOfs = 0;\n+                        inLen = in.length;\n@@ -766,2 +761,26 @@\n-                        in = new byte[inLen];\n-                        inBuffer.get(in);\n+                        if (inBuffer instanceof DirectBuffer dInBuffer) {\n+                            inAddr = dInBuffer.address();\n+                            inOfs = inBuffer.position();\n+                        } else {\n+                            if (inBuffer.hasArray()) {\n+                                in = inBuffer.array();\n+                                inOfs = inBuffer.position() + inBuffer.arrayOffset();\n+                            } else {\n+                                in = new byte[inLen];\n+                                inBuffer.get(in);\n+                            }\n+                        }\n+                    }\n+                    long outAddr = 0;\n+                    byte[] outArray = null;\n+                    int outOfs = 0;\n+                    if (outBuffer instanceof DirectBuffer dOutBuffer) {\n+                        outAddr = dOutBuffer.address();\n+                        outOfs = outBuffer.position();\n+                    } else {\n+                        if (outBuffer.hasArray()) {\n+                            outArray = outBuffer.array();\n+                            outOfs = outBuffer.position() + outBuffer.arrayOffset();\n+                        } else {\n+                            outArray = new byte[outLen];\n+                        }\n@@ -769,16 +788,0 @@\n-                }\n-            }\n-            long outAddr = 0;\n-            byte[] outArray = null;\n-            int outOfs = 0;\n-            if (outBuffer instanceof DirectBuffer) {\n-                outAddr = outGuard.address();\n-                outOfs = outBuffer.position();\n-            } else {\n-                if (outBuffer.hasArray()) {\n-                    outArray = outBuffer.array();\n-                    outOfs = outBuffer.position() + outBuffer.arrayOffset();\n-                } else {\n-                    outArray = new byte[outLen];\n-                }\n-            }\n@@ -786,9 +789,34 @@\n-            int k = 0;\n-            if (encrypt) {\n-                k = token.p11.C_Encrypt(session.id(), inAddr, in, inOfs, inLen,\n-                        outAddr, outArray, outOfs, outLen);\n-                doCancel = false;\n-            } else {\n-                \/\/ Special handling to match SunJCE provider behavior\n-                if (inLen == 0) {\n-                    return 0;\n+                    int k = 0;\n+                    if (encrypt) {\n+                        k = token.p11.C_Encrypt(session.id(), inAddr, in, inOfs, inLen,\n+                                outAddr, outArray, outOfs, outLen);\n+                        doCancel = false;\n+                    } else {\n+                        \/\/ Special handling to match SunJCE provider behavior\n+                        if (inLen == 0) {\n+                            return 0;\n+                        }\n+                        k = token.p11.C_Decrypt(session.id(), inAddr, in, inOfs, inLen,\n+                                outAddr, outArray, outOfs, outLen);\n+                        doCancel = false;\n+                    }\n+                    inBuffer.position(inBuffer.limit());\n+                    outBuffer.position(outBuffer.position() + k);\n+                    return k;\n+                } catch (PKCS11Exception e) {\n+                    \/\/ As per the PKCS#11 standard, C_Encrypt and C_Decrypt may only\n+                    \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n+                    \/\/ successful calls to determine the output length. However,\n+                    \/\/ these cases are not expected here because the output length\n+                    \/\/ is checked in the OpenJDK side before making the PKCS#11 call.\n+                    \/\/ Thus, doCancel can safely be 'false'.\n+                    doCancel = false;\n+                    handleException(e);\n+                    throw new ProviderException(\"doFinal() failed\", e);\n+                } finally {\n+                    if (encrypt) {\n+                        lastEncKey = this.p11Key;\n+                        lastEncIv = this.iv;\n+                        requireReinit = true;\n+                    }\n+                    reset(doCancel);\n@@ -796,3 +824,2 @@\n-                k = token.p11.C_Decrypt(session.id(), inAddr, in, inOfs, inLen,\n-                        outAddr, outArray, outOfs, outLen);\n-                doCancel = false;\n+            } finally {\n+                NIO_ACCESS.releaseScope(outBuffer, outScope);\n@@ -800,13 +827,0 @@\n-            inBuffer.position(inBuffer.limit());\n-            outBuffer.position(outBuffer.position() + k);\n-            return k;\n-        } catch (PKCS11Exception e) {\n-            \/\/ As per the PKCS#11 standard, C_Encrypt and C_Decrypt may only\n-            \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n-            \/\/ successful calls to determine the output length. However,\n-            \/\/ these cases are not expected here because the output length\n-            \/\/ is checked in the OpenJDK side before making the PKCS#11 call.\n-            \/\/ Thus, doCancel can safely be 'false'.\n-            doCancel = false;\n-            handleException(e);\n-            throw new ProviderException(\"doFinal() failed\", e);\n@@ -814,6 +828,1 @@\n-            if (encrypt) {\n-                lastEncKey = this.p11Key;\n-                lastEncIv = this.iv;\n-                requireReinit = true;\n-            }\n-            reset(doCancel);\n+            NIO_ACCESS.releaseScope(inBuffer, inScope);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":82,"deletions":73,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -694,15 +694,17 @@\n-        try (var inGuard = NIO_ACCESS.acquireScope(inBuffer);\n-             var outGuard = NIO_ACCESS.acquireScope(outBuffer)) {\n-            ensureInitialized();\n-\n-            long inAddr = 0;\n-            int inOfs = 0;\n-            byte[] inArray = null;\n-\n-            if (inBuffer instanceof DirectBuffer) {\n-                inAddr = inGuard.address();\n-                inOfs = origPos;\n-            } else if (inBuffer.hasArray()) {\n-                inArray = inBuffer.array();\n-                inOfs = (origPos + inBuffer.arrayOffset());\n-            }\n+        var inScope = NIO_ACCESS.acquireScopeOrNull(inBuffer);\n+        try {\n+            var outScope = NIO_ACCESS.acquireScopeOrNull(outBuffer);\n+            try {\n+                ensureInitialized();\n+\n+                long inAddr = 0;\n+                int inOfs = 0;\n+                byte[] inArray = null;\n+\n+                if (inBuffer instanceof DirectBuffer dInBuffer) {\n+                    inAddr = dInBuffer.address();\n+                    inOfs = origPos;\n+                } else if (inBuffer.hasArray()) {\n+                    inArray = inBuffer.array();\n+                    inOfs = (origPos + inBuffer.arrayOffset());\n+                }\n@@ -710,10 +712,6 @@\n-            long outAddr = 0;\n-            int outOfs = 0;\n-            byte[] outArray = null;\n-            if (outBuffer instanceof DirectBuffer) {\n-                outAddr = outGuard.address();\n-                outOfs = outBuffer.position();\n-            } else {\n-                if (outBuffer.hasArray()) {\n-                    outArray = outBuffer.array();\n-                    outOfs = (outBuffer.position() + outBuffer.arrayOffset());\n+                long outAddr = 0;\n+                int outOfs = 0;\n+                byte[] outArray = null;\n+                if (outBuffer instanceof DirectBuffer dOutBuffer) {\n+                    outAddr = dOutBuffer.address();\n+                    outOfs = outBuffer.position();\n@@ -721,1 +719,6 @@\n-                    outArray = new byte[outLen];\n+                    if (outBuffer.hasArray()) {\n+                        outArray = outBuffer.array();\n+                        outOfs = (outBuffer.position() + outBuffer.arrayOffset());\n+                    } else {\n+                        outArray = new byte[outLen];\n+                    }\n@@ -723,1 +726,0 @@\n-            }\n@@ -725,10 +727,19 @@\n-            int k = 0;\n-            int newPadBufferLen = 0;\n-            if (paddingObj != null  && (!encrypt || reqBlockUpdates)) {\n-                if (padBufferLen != 0) {\n-                    if (padBufferLen != padBuffer.length) {\n-                        int bufCapacity = padBuffer.length - padBufferLen;\n-                        if (inLen > bufCapacity) {\n-                            bufferInputBytes(inBuffer, bufCapacity);\n-                            inOfs += bufCapacity;\n-                            inLen -= bufCapacity;\n+                int k = 0;\n+                int newPadBufferLen = 0;\n+                if (paddingObj != null && (!encrypt || reqBlockUpdates)) {\n+                    if (padBufferLen != 0) {\n+                        if (padBufferLen != padBuffer.length) {\n+                            int bufCapacity = padBuffer.length - padBufferLen;\n+                            if (inLen > bufCapacity) {\n+                                bufferInputBytes(inBuffer, bufCapacity);\n+                                inOfs += bufCapacity;\n+                                inLen -= bufCapacity;\n+                            } else {\n+                                bufferInputBytes(inBuffer, inLen);\n+                                return 0;\n+                            }\n+                        }\n+                        if (encrypt) {\n+                            k = token.p11.C_EncryptUpdate(session.id(), 0,\n+                                    padBuffer, 0, padBufferLen, outAddr, outArray,\n+                                    outOfs, outLen);\n@@ -736,2 +747,3 @@\n-                            bufferInputBytes(inBuffer, inLen);\n-                            return 0;\n+                            k = token.p11.C_DecryptUpdate(session.id(), 0,\n+                                    padBuffer, 0, padBufferLen, outAddr, outArray,\n+                                    outOfs, outLen);\n@@ -739,0 +751,19 @@\n+                        padBufferLen = 0;\n+                    }\n+                    newPadBufferLen = inLen & (blockSize - 1);\n+                    if (!encrypt && newPadBufferLen == 0) {\n+                        \/\/ While decrypting with implUpdate, the last encrypted block\n+                        \/\/ is always held in a buffer. If it's the final one (unknown\n+                        \/\/ at this point), it may contain padding bytes and need further\n+                        \/\/ processing. In implDoFinal (where we know it's the final one)\n+                        \/\/ the buffer is decrypted, unpadded and returned.\n+                        newPadBufferLen = padBuffer.length;\n+                    }\n+                    inLen -= newPadBufferLen;\n+                }\n+                if (inLen > 0) {\n+                    if (inAddr == 0 && inArray == null) {\n+                        inArray = new byte[inLen];\n+                        inBuffer.get(inArray);\n+                    } else {\n+                        inBuffer.position(inBuffer.position() + inLen);\n@@ -741,3 +772,3 @@\n-                        k = token.p11.C_EncryptUpdate(session.id(), 0,\n-                                padBuffer, 0, padBufferLen, outAddr, outArray,\n-                                outOfs, outLen);\n+                        k += token.p11.C_EncryptUpdate(session.id(), inAddr,\n+                                inArray, inOfs, inLen, outAddr, outArray,\n+                                (outOfs + k), (outLen - k));\n@@ -745,3 +776,3 @@\n-                        k = token.p11.C_DecryptUpdate(session.id(), 0,\n-                                padBuffer, 0, padBufferLen, outAddr, outArray,\n-                                outOfs, outLen);\n+                        k += token.p11.C_DecryptUpdate(session.id(), inAddr,\n+                                inArray, inOfs, inLen, outAddr, outArray,\n+                                (outOfs + k), (outLen - k));\n@@ -749,1 +780,0 @@\n-                    padBufferLen = 0;\n@@ -751,8 +781,3 @@\n-                newPadBufferLen = inLen & (blockSize - 1);\n-                if (!encrypt && newPadBufferLen == 0) {\n-                    \/\/ While decrypting with implUpdate, the last encrypted block\n-                    \/\/ is always held in a buffer. If it's the final one (unknown\n-                    \/\/ at this point), it may contain padding bytes and need further\n-                    \/\/ processing. In implDoFinal (where we know it's the final one)\n-                    \/\/ the buffer is decrypted, unpadded and returned.\n-                    newPadBufferLen = padBuffer.length;\n+                \/\/ update 'padBuffer' if using our own padding impl.\n+                if (paddingObj != null && newPadBufferLen > 0) {\n+                    bufferInputBytes(inBuffer, newPadBufferLen);\n@@ -760,6 +785,4 @@\n-                inLen -= newPadBufferLen;\n-            }\n-            if (inLen > 0) {\n-                if (inAddr == 0 && inArray == null) {\n-                    inArray = new byte[inLen];\n-                    inBuffer.get(inArray);\n+                bytesBuffered += (inLen - k);\n+                if (!(outBuffer instanceof DirectBuffer) &&\n+                        !outBuffer.hasArray()) {\n+                    outBuffer.put(outArray, outOfs, k);\n@@ -767,1 +790,1 @@\n-                    inBuffer.position(inBuffer.position() + inLen);\n+                    outBuffer.position(outBuffer.position() + k);\n@@ -769,8 +792,7 @@\n-                if (encrypt) {\n-                    k += token.p11.C_EncryptUpdate(session.id(), inAddr,\n-                            inArray, inOfs, inLen, outAddr, outArray,\n-                            (outOfs + k), (outLen - k));\n-                } else {\n-                    k += token.p11.C_DecryptUpdate(session.id(), inAddr,\n-                            inArray, inOfs, inLen, outAddr, outArray,\n-                            (outOfs + k), (outLen - k));\n+                return k;\n+            } catch (PKCS11Exception e) {\n+                \/\/ Reset input buffer to its original position for\n+                inBuffer.position(origPos);\n+                if (e.match(CKR_BUFFER_TOO_SMALL)) {\n+                    throw (ShortBufferException)\n+                            (new ShortBufferException().initCause(e));\n@@ -778,0 +800,8 @@\n+                \/\/ Some implementations such as the NSS Software Token do not\n+                \/\/ cancel the operation upon a C_EncryptUpdate\/C_DecryptUpdate\n+                \/\/ failure (as required by the PKCS#11 standard). See JDK-8258833\n+                \/\/ for further information.\n+                reset(true);\n+                throw new ProviderException(\"update() failed\", e);\n+            } finally {\n+                NIO_ACCESS.releaseScope(outBuffer, outScope);\n@@ -779,25 +809,2 @@\n-            \/\/ update 'padBuffer' if using our own padding impl.\n-            if (paddingObj != null && newPadBufferLen > 0) {\n-                bufferInputBytes(inBuffer, newPadBufferLen);\n-            }\n-            bytesBuffered += (inLen - k);\n-            if (!(outBuffer instanceof DirectBuffer) &&\n-                    !outBuffer.hasArray()) {\n-                outBuffer.put(outArray, outOfs, k);\n-            } else {\n-                outBuffer.position(outBuffer.position() + k);\n-            }\n-            return k;\n-        } catch (PKCS11Exception e) {\n-            \/\/ Reset input buffer to its original position for\n-            inBuffer.position(origPos);\n-            if (e.match(CKR_BUFFER_TOO_SMALL)) {\n-                throw (ShortBufferException)\n-                        (new ShortBufferException().initCause(e));\n-            }\n-            \/\/ Some implementations such as the NSS Software Token do not\n-            \/\/ cancel the operation upon a C_EncryptUpdate\/C_DecryptUpdate\n-            \/\/ failure (as required by the PKCS#11 standard). See JDK-8258833\n-            \/\/ for further information.\n-            reset(true);\n-            throw new ProviderException(\"update() failed\", e);\n+        } finally {\n+            NIO_ACCESS.releaseScope(inBuffer, inScope);\n@@ -894,13 +901,11 @@\n-        try (var outGuard = NIO_ACCESS.acquireScope(outBuffer)) {\n-            ensureInitialized();\n-\n-            long outAddr = 0;\n-            byte[] outArray = null;\n-            int outOfs = 0;\n-            if (outBuffer instanceof DirectBuffer) {\n-                outAddr = outGuard.address();\n-                outOfs = outBuffer.position();\n-            } else {\n-                if (outBuffer.hasArray()) {\n-                    outArray = outBuffer.array();\n-                    outOfs = outBuffer.position() + outBuffer.arrayOffset();\n+        var scope = NIO_ACCESS.acquireScopeOrNull(outBuffer);\n+        try {\n+            try {\n+                ensureInitialized();\n+\n+                long outAddr = 0;\n+                byte[] outArray = null;\n+                int outOfs = 0;\n+                if (outBuffer instanceof DirectBuffer dOutBuffer) {\n+                    outAddr = dOutBuffer.address();\n+                    outOfs = outBuffer.position();\n@@ -908,1 +913,6 @@\n-                    outArray = new byte[outLen];\n+                    if (outBuffer.hasArray()) {\n+                        outArray = outBuffer.array();\n+                        outOfs = outBuffer.position() + outBuffer.arrayOffset();\n+                    } else {\n+                        outArray = new byte[outLen];\n+                    }\n@@ -910,1 +920,0 @@\n-            }\n@@ -912,1 +921,1 @@\n-            int k = 0;\n+                int k = 0;\n@@ -914,12 +923,13 @@\n-            if (encrypt) {\n-                if (paddingObj != null) {\n-                    int startOff = 0;\n-                    if (reqBlockUpdates) {\n-                        \/\/ call C_EncryptUpdate first if the padBuffer is full\n-                        \/\/ to make room for padding bytes\n-                        if (padBufferLen == padBuffer.length) {\n-                            k = token.p11.C_EncryptUpdate(session.id(),\n-                                0, padBuffer, 0, padBufferLen,\n-                                outAddr, outArray, outOfs, outLen);\n-                        } else {\n-                            startOff = padBufferLen;\n+                if (encrypt) {\n+                    if (paddingObj != null) {\n+                        int startOff = 0;\n+                        if (reqBlockUpdates) {\n+                            \/\/ call C_EncryptUpdate first if the padBuffer is full\n+                            \/\/ to make room for padding bytes\n+                            if (padBufferLen == padBuffer.length) {\n+                                k = token.p11.C_EncryptUpdate(session.id(),\n+                                        0, padBuffer, 0, padBufferLen,\n+                                        outAddr, outArray, outOfs, outLen);\n+                            } else {\n+                                startOff = padBufferLen;\n+                            }\n@@ -927,27 +937,5 @@\n-                    }\n-                    int actualPadLen = paddingObj.setPaddingBytes(padBuffer,\n-                            startOff, requiredOutLen - bytesBuffered);\n-                    k += token.p11.C_EncryptUpdate(session.id(),\n-                            0, padBuffer, 0, startOff + actualPadLen,\n-                            outAddr, outArray, outOfs + k, outLen - k);\n-                }\n-                \/\/ Some implementations such as the NSS Software Token do not\n-                \/\/ cancel the operation upon a C_EncryptUpdate failure (as\n-                \/\/ required by the PKCS#11 standard). Cancel is not needed\n-                \/\/ only after this point. See JDK-8258833 for further\n-                \/\/ information.\n-                doCancel = false;\n-                k += token.p11.C_EncryptFinal(session.id(),\n-                        outAddr, outArray, (outOfs + k), (outLen - k));\n-            } else {\n-                \/\/ Special handling to match SunJCE provider behavior\n-                if (bytesBuffered == 0 && padBufferLen == 0) {\n-                    return 0;\n-                }\n-\n-                if (paddingObj != null) {\n-                    if (padBufferLen != 0) {\n-                        k = token.p11.C_DecryptUpdate(session.id(),\n-                                0, padBuffer, 0, padBufferLen,\n-                                0, padBuffer, 0, padBuffer.length);\n-                        padBufferLen = 0;\n+                        int actualPadLen = paddingObj.setPaddingBytes(padBuffer,\n+                                startOff, requiredOutLen - bytesBuffered);\n+                        k += token.p11.C_EncryptUpdate(session.id(),\n+                                0, padBuffer, 0, startOff + actualPadLen,\n+                                outAddr, outArray, outOfs + k, outLen - k);\n@@ -956,1 +944,1 @@\n-                    \/\/ cancel the operation upon a C_DecryptUpdate failure (as\n+                    \/\/ cancel the operation upon a C_EncryptUpdate failure (as\n@@ -961,2 +949,7 @@\n-                    k += token.p11.C_DecryptFinal(session.id(),\n-                            0, padBuffer, k, padBuffer.length - k);\n+                    k += token.p11.C_EncryptFinal(session.id(),\n+                            outAddr, outArray, (outOfs + k), (outLen - k));\n+                } else {\n+                    \/\/ Special handling to match SunJCE provider behavior\n+                    if (bytesBuffered == 0 && padBufferLen == 0) {\n+                        return 0;\n+                    }\n@@ -964,4 +957,30 @@\n-                    int actualPadLen = paddingObj.unpad(padBuffer, k);\n-                    k -= actualPadLen;\n-                    outArray = padBuffer;\n-                    outOfs = 0;\n+                    if (paddingObj != null) {\n+                        if (padBufferLen != 0) {\n+                            k = token.p11.C_DecryptUpdate(session.id(),\n+                                    0, padBuffer, 0, padBufferLen,\n+                                    0, padBuffer, 0, padBuffer.length);\n+                            padBufferLen = 0;\n+                        }\n+                        \/\/ Some implementations such as the NSS Software Token do not\n+                        \/\/ cancel the operation upon a C_DecryptUpdate failure (as\n+                        \/\/ required by the PKCS#11 standard). Cancel is not needed\n+                        \/\/ only after this point. See JDK-8258833 for further\n+                        \/\/ information.\n+                        doCancel = false;\n+                        k += token.p11.C_DecryptFinal(session.id(),\n+                                0, padBuffer, k, padBuffer.length - k);\n+\n+                        int actualPadLen = paddingObj.unpad(padBuffer, k);\n+                        k -= actualPadLen;\n+                        outArray = padBuffer;\n+                        outOfs = 0;\n+                    } else {\n+                        doCancel = false;\n+                        k = token.p11.C_DecryptFinal(session.id(),\n+                                outAddr, outArray, outOfs, outLen);\n+                    }\n+                }\n+                if ((!encrypt && paddingObj != null) ||\n+                        (!(outBuffer instanceof DirectBuffer) &&\n+                                !outBuffer.hasArray())) {\n+                    outBuffer.put(outArray, outOfs, k);\n@@ -969,3 +988,1 @@\n-                    doCancel = false;\n-                    k = token.p11.C_DecryptFinal(session.id(),\n-                            outAddr, outArray, outOfs, outLen);\n+                    outBuffer.position(outBuffer.position() + k);\n@@ -973,0 +990,6 @@\n+                return k;\n+            } catch (PKCS11Exception e) {\n+                handleException(e);\n+                throw new ProviderException(\"doFinal() failed\", e);\n+            } finally {\n+                reset(doCancel);\n@@ -974,11 +997,0 @@\n-            if ((!encrypt && paddingObj != null) ||\n-                    (!(outBuffer instanceof DirectBuffer) &&\n-                    !outBuffer.hasArray())) {\n-                outBuffer.put(outArray, outOfs, k);\n-            } else {\n-                outBuffer.position(outBuffer.position() + k);\n-            }\n-            return k;\n-        } catch (PKCS11Exception e) {\n-            handleException(e);\n-            throw new ProviderException(\"doFinal() failed\", e);\n@@ -986,1 +998,1 @@\n-            reset(doCancel);\n+            NIO_ACCESS.releaseScope(outBuffer, scope);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":183,"deletions":171,"binary":false,"changes":354,"status":"modified"},{"patch":"@@ -311,2 +311,5 @@\n-            try (var guard = NIO_ACCESS.acquireScope(byteBuffer)) {\n-                token.p11.C_DigestUpdate(session.id(), guard.address() + ofs, null, 0, len);\n+            var scope = NIO_ACCESS.acquireScopeOrNull(byteBuffer);\n+            try {\n+                token.p11.C_DigestUpdate(session.id(), ((DirectBuffer)byteBuffer).address() + ofs, null, 0, len);\n+            } finally {\n+                NIO_ACCESS.releaseScope(byteBuffer, scope);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Digest.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -562,26 +562,21 @@\n-        try (var inGuard = NIO_ACCESS.acquireScope(inBuffer);\n-             var outGuard = NIO_ACCESS.acquireScope(outBuffer)) {\n-            ensureInitialized();\n-\n-            long inAddr = 0;\n-            byte[] in = null;\n-            int inOfs = 0;\n-\n-            if (dataBuffer.size() > 0) {\n-                if (inBuffer != null && inLen > 0) {\n-                    byte[] temp = new byte[inLen];\n-                    inBuffer.get(temp);\n-                    dataBuffer.write(temp, 0, temp.length);\n-                }\n-\n-                in = dataBuffer.toByteArray();\n-                inOfs = 0;\n-                inLen = in.length;\n-            } else {\n-                if (inBuffer instanceof DirectBuffer) {\n-                    inAddr = inGuard.address();\n-                    inOfs = inBuffer.position();\n-                } else {\n-                    if (inBuffer.hasArray()) {\n-                        in = inBuffer.array();\n-                        inOfs = inBuffer.position() + inBuffer.arrayOffset();\n+        var inScope = NIO_ACCESS.acquireScopeOrNull(inBuffer);\n+        try {\n+            var outScope = NIO_ACCESS.acquireScopeOrNull(outBuffer);\n+            try {\n+                try {\n+                    ensureInitialized();\n+\n+                    long inAddr = 0;\n+                    byte[] in = null;\n+                    int inOfs = 0;\n+\n+                    if (dataBuffer.size() > 0) {\n+                        if (inBuffer != null && inLen > 0) {\n+                            byte[] temp = new byte[inLen];\n+                            inBuffer.get(temp);\n+                            dataBuffer.write(temp, 0, temp.length);\n+                        }\n+\n+                        in = dataBuffer.toByteArray();\n+                        inOfs = 0;\n+                        inLen = in.length;\n@@ -589,2 +584,26 @@\n-                        in = new byte[inLen];\n-                        inBuffer.get(in);\n+                        if (inBuffer instanceof DirectBuffer dInBuffer) {\n+                            inAddr = dInBuffer.address();\n+                            inOfs = inBuffer.position();\n+                        } else {\n+                            if (inBuffer.hasArray()) {\n+                                in = inBuffer.array();\n+                                inOfs = inBuffer.position() + inBuffer.arrayOffset();\n+                            } else {\n+                                in = new byte[inLen];\n+                                inBuffer.get(in);\n+                            }\n+                        }\n+                    }\n+                    long outAddr = 0;\n+                    byte[] outArray = null;\n+                    int outOfs = 0;\n+                    if (outBuffer instanceof DirectBuffer dOutBuffer) {\n+                        outAddr = dOutBuffer.address();\n+                        outOfs = outBuffer.position();\n+                    } else {\n+                        if (outBuffer.hasArray()) {\n+                            outArray = outBuffer.array();\n+                            outOfs = outBuffer.position() + outBuffer.arrayOffset();\n+                        } else {\n+                            outArray = new byte[outLen];\n+                        }\n@@ -592,16 +611,0 @@\n-                }\n-            }\n-            long outAddr = 0;\n-            byte[] outArray = null;\n-            int outOfs = 0;\n-            if (outBuffer instanceof DirectBuffer) {\n-                outAddr = outGuard.address();\n-                outOfs = outBuffer.position();\n-            } else {\n-                if (outBuffer.hasArray()) {\n-                    outArray = outBuffer.array();\n-                    outOfs = outBuffer.position() + outBuffer.arrayOffset();\n-                } else {\n-                    outArray = new byte[outLen];\n-                }\n-            }\n@@ -609,8 +612,26 @@\n-            if (opmode == Cipher.ENCRYPT_MODE) {\n-                k = token.p11.C_Encrypt(session.id(), inAddr, in, inOfs, inLen,\n-                        outAddr, outArray, outOfs, outLen);\n-                doCancel = false;\n-            } else {\n-                \/\/ Special handling to match SunJCE provider behavior\n-                if (inLen == 0) {\n-                    return 0;\n+                    if (opmode == Cipher.ENCRYPT_MODE) {\n+                        k = token.p11.C_Encrypt(session.id(), inAddr, in, inOfs, inLen,\n+                                outAddr, outArray, outOfs, outLen);\n+                        doCancel = false;\n+                    } else {\n+                        \/\/ Special handling to match SunJCE provider behavior\n+                        if (inLen == 0) {\n+                            return 0;\n+                        }\n+                        k = token.p11.C_Decrypt(session.id(), inAddr, in, inOfs, inLen,\n+                                outAddr, outArray, outOfs, outLen);\n+                        doCancel = false;\n+                    }\n+                    inBuffer.position(inBuffer.limit());\n+                    outBuffer.position(outBuffer.position() + k);\n+                } catch (PKCS11Exception e) {\n+                    \/\/ As per the PKCS#11 standard, C_Encrypt and C_Decrypt may only\n+                    \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n+                    \/\/ successful calls to determine the output length. However,\n+                    \/\/ these cases are not expected here because the output length\n+                    \/\/ is checked in the OpenJDK side before making the PKCS#11 call.\n+                    \/\/ Thus, doCancel can safely be 'false'.\n+                    doCancel = false;\n+                    handleEncException(\"doFinal() failed\", e);\n+                } finally {\n+                    reset(doCancel);\n@@ -618,3 +639,2 @@\n-                k = token.p11.C_Decrypt(session.id(), inAddr, in, inOfs, inLen,\n-                        outAddr, outArray, outOfs, outLen);\n-                doCancel = false;\n+            } finally {\n+                NIO_ACCESS.releaseScope(outBuffer, outScope);\n@@ -622,11 +642,0 @@\n-            inBuffer.position(inBuffer.limit());\n-            outBuffer.position(outBuffer.position() + k);\n-        } catch (PKCS11Exception e) {\n-            \/\/ As per the PKCS#11 standard, C_Encrypt and C_Decrypt may only\n-            \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n-            \/\/ successful calls to determine the output length. However,\n-            \/\/ these cases are not expected here because the output length\n-            \/\/ is checked in the OpenJDK side before making the PKCS#11 call.\n-            \/\/ Thus, doCancel can safely be 'false'.\n-            doCancel = false;\n-            handleEncException(\"doFinal() failed\", e);\n@@ -634,1 +643,1 @@\n-            reset(doCancel);\n+            NIO_ACCESS.releaseScope(inBuffer, inScope);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyWrapCipher.java","additions":76,"deletions":67,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -272,1 +272,1 @@\n-            if (byteBuffer instanceof DirectBuffer == false) {\n+            if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n@@ -277,2 +277,5 @@\n-            try (var guard = NIO_ACCESS.acquireScope(byteBuffer)) {\n-                token.p11.C_SignUpdate(session.id(), guard.address() + ofs, null, 0, len);\n+            var scope = NIO_ACCESS.acquireScopeOrNull(byteBuffer);\n+            try  {\n+                token.p11.C_SignUpdate(session.id(), dByteBuffer.address() + ofs, null, 0, len);\n+            } finally {\n+                NIO_ACCESS.releaseScope(byteBuffer, scope);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Mac.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -621,1 +621,1 @@\n-            if (byteBuffer instanceof DirectBuffer == false) {\n+            if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n@@ -627,1 +627,2 @@\n-            try (var guard = NIO_ACCESS.acquireScope(byteBuffer)) {\n+            var scope = NIO_ACCESS.acquireScopeOrNull(byteBuffer);\n+            try {\n@@ -631,1 +632,1 @@\n-                        (session.id(), guard.address() + ofs, null, 0, len);\n+                        (session.id(), dByteBuffer.address() + ofs, null, 0, len);\n@@ -635,1 +636,1 @@\n-                        (session.id(), guard.address() + ofs, null, 0, len);\n+                        (session.id(), dByteBuffer.address() + ofs, null, 0, len);\n@@ -642,0 +643,2 @@\n+            } finally {\n+                NIO_ACCESS.releaseScope(byteBuffer, scope);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11PSSSignature.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -588,1 +588,1 @@\n-            if (byteBuffer instanceof DirectBuffer == false) {\n+            if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n@@ -594,1 +594,2 @@\n-            try (var guard = NIO_ACCESS.acquireScope(byteBuffer)) {\n+            var scope = NIO_ACCESS.acquireScopeOrNull(byteBuffer);\n+            try {\n@@ -597,1 +598,1 @@\n-                        (session.id(), guard.address() + ofs, null, 0, len);\n+                        (session.id(), dByteBuffer.address() + ofs, null, 0, len);\n@@ -600,1 +601,1 @@\n-                        (session.id(), guard.address() + ofs, null, 0, len);\n+                        (session.id(), dByteBuffer.address() + ofs, null, 0, len);\n@@ -607,0 +608,2 @@\n+            } finally {\n+                NIO_ACCESS.releaseScope(byteBuffer, scope);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Signature.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -847,2 +847,3 @@\n-        try (var guard = NIO_ACCESS.acquireScope(bb)) {\n-            int n = receive0(fd, resultContainer, guard.address() + pos, rem, peek);\n+        var scope = NIO_ACCESS.acquireScopeOrNull(bb);\n+        try {\n+            int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem, peek);\n@@ -853,0 +854,2 @@\n+        } finally {\n+            NIO_ACCESS.releaseScope(bb, scope);\n@@ -1038,2 +1041,3 @@\n-        try (var guard = NIO_ACCESS.acquireScope(bb)) {\n-            int written = send0(fd, guard.address() + pos, rem, addr,\n+        var scope = NIO_ACCESS.acquireScopeOrNull(bb);\n+        try {\n+            int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,\n@@ -1044,0 +1048,2 @@\n+        } finally {\n+            NIO_ACCESS.releaseScope(bb, scope);\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -590,2 +590,3 @@\n-        try (var guard = NIO_ACCESS.acquireScope(bb)) {\n-            int n = receive0(fd, resultContainer, guard.address() + pos, rem);\n+        var scope = NIO_ACCESS.acquireScopeOrNull(bb);\n+        try {\n+            int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem);\n@@ -595,0 +596,2 @@\n+        } finally {\n+            NIO_ACCESS.releaseScope(bb, scope);\n@@ -917,2 +920,3 @@\n-        try (var guard = NIO_ACCESS.acquireScope(bb)) {\n-            int written = send0(fd, guard.address() + pos, rem, addr,\n+        var scope = NIO_ACCESS.acquireScopeOrNull(bb);\n+        try {\n+            int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,\n@@ -923,0 +927,2 @@\n+        } finally {\n+            NIO_ACCESS.releaseScope(bb, scope);\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpMultiChannelImpl.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"}]}