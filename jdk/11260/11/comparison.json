{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -95,0 +97,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -912,0 +916,2 @@\n+                \/\/ The use of DirectBuffer::address below need not be guarded as\n+                \/\/ no access is made to actual memory.\n@@ -949,1 +955,0 @@\n-\n@@ -1588,2 +1593,7 @@\n-                    Unsafe.getUnsafe().setMemory(((DirectBuffer)dst).address(),\n-                        len + dst.position(), (byte)0);\n+                    var scope = NIO_ACCESS.acquireScopeOrNull(dst);\n+                    try {\n+                        Unsafe.getUnsafe().setMemory(((DirectBuffer)dst).address(),\n+                                len + dst.position(), (byte) 0);\n+                    } finally {\n+                        NIO_ACCESS.releaseScope(dst, scope);\n+                    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.lang.ref.Reference;\n@@ -781,0 +782,1 @@\n+\n@@ -838,0 +840,22 @@\n+                @Override\n+                public MemorySessionImpl acquireScopeOrNull(Buffer buffer) {\n+                    var scope = buffer.session();\n+                    if (scope == null) {\n+                        return null;\n+                    }\n+                    scope.acquire0();\n+                    return scope;\n+                }\n+\n+                @Override\n+                public void releaseScope(Buffer buffer, MemorySessionImpl scope) {\n+                    assert buffer.session() == scope;\n+                    try {\n+                        if (scope != null) {\n+                            scope.release0();\n+                        }\n+                    } finally {\n+                        Reference.reachabilityFence(buffer);\n+                    }\n+                }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.ref.Reference;\n@@ -30,1 +29,1 @@\n-import sun.nio.ch.DirectBuffer;\n+\n@@ -33,0 +32,3 @@\n+import sun.nio.ch.DirectBuffer;\n+\n+import static java.util.zip.ZipUtils.NIO_ACCESS;\n@@ -99,0 +101,1 @@\n+            var scope = NIO_ACCESS.acquireScopeOrNull(buffer);\n@@ -102,1 +105,1 @@\n-                Reference.reachabilityFence(buffer);\n+                NIO_ACCESS.releaseScope(buffer, scope);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Adler32.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.ref.Reference;\n@@ -36,0 +35,2 @@\n+import static java.util.zip.ZipUtils.NIO_ACCESS;\n+\n@@ -99,0 +100,1 @@\n+            var scope = NIO_ACCESS.acquireScopeOrNull(buffer);\n@@ -102,1 +104,1 @@\n-                Reference.reachabilityFence(buffer);\n+                NIO_ACCESS.releaseScope(buffer, scope);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/CRC32.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.ref.Reference;\n@@ -36,0 +35,2 @@\n+import static java.util.zip.ZipUtils.NIO_ACCESS;\n+\n@@ -174,0 +175,1 @@\n+            var scope = NIO_ACCESS.acquireScopeOrNull(buffer);\n@@ -175,1 +177,1 @@\n-                crc = updateDirectByteBuffer(crc, ((DirectBuffer) buffer).address(),\n+                crc = updateDirectByteBuffer(crc, ((DirectBuffer)buffer).address(),\n@@ -178,1 +180,1 @@\n-                Reference.reachabilityFence(buffer);\n+                NIO_ACCESS.releaseScope(buffer, scope);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/CRC32C.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.ref.Reference;\n@@ -38,0 +37,2 @@\n+import static java.util.zip.ZipUtils.NIO_ACCESS;\n+\n@@ -340,1 +341,1 @@\n-                long address = ((DirectBuffer) dictionary).address();\n+                var scope = NIO_ACCESS.acquireScopeOrNull(dictionary);\n@@ -342,1 +343,1 @@\n-                    setDictionaryBuffer(zsRef.address(), address + position, remaining);\n+                    setDictionaryBuffer(zsRef.address(), ((DirectBuffer) dictionary).address() + position, remaining);\n@@ -344,1 +345,1 @@\n-                    Reference.reachabilityFence(dictionary);\n+                    NIO_ACCESS.releaseScope(dictionary, scope);\n@@ -590,0 +591,1 @@\n+                    var scope = NIO_ACCESS.acquireScopeOrNull(input);\n@@ -591,1 +593,0 @@\n-                        long inputAddress = ((DirectBuffer) input).address();\n@@ -593,1 +594,1 @@\n-                            inputAddress + inputPos, inputRem,\n+                                ((DirectBuffer) input).address() + inputPos, inputRem,\n@@ -597,1 +598,1 @@\n-                        Reference.reachabilityFence(input);\n+                        NIO_ACCESS.releaseScope(input, scope);\n@@ -712,1 +713,1 @@\n-                    long outputAddress = ((DirectBuffer) output).address();\n+                    var outScope = NIO_ACCESS.acquireScopeOrNull(output);\n@@ -716,1 +717,1 @@\n-                            outputAddress + outputPos, outputRem,\n+                                ((DirectBuffer) output).address() + outputPos, outputRem,\n@@ -719,1 +720,1 @@\n-                        Reference.reachabilityFence(output);\n+                        NIO_ACCESS.releaseScope(output, outScope);\n@@ -733,1 +734,1 @@\n-                    long inputAddress = ((DirectBuffer) input).address();\n+                    var inScope = NIO_ACCESS.acquireScopeOrNull(input);\n@@ -736,1 +737,1 @@\n-                            long outputAddress = outputPos + ((DirectBuffer) output).address();\n+                            var outScope = NIO_ACCESS.acquireScopeOrNull(output);\n@@ -739,2 +740,2 @@\n-                                    inputAddress + inputPos, inputRem,\n-                                    outputAddress, outputRem,\n+                                    ((DirectBuffer) input).address() + inputPos, inputRem,\n+                                    ((DirectBuffer) output).address(), outputRem,\n@@ -743,1 +744,1 @@\n-                                Reference.reachabilityFence(output);\n+                                NIO_ACCESS.releaseScope(output, outScope);\n@@ -749,1 +750,1 @@\n-                                inputAddress + inputPos, inputRem,\n+                                    ((DirectBuffer) input).address() + inputPos, inputRem,\n@@ -754,1 +755,1 @@\n-                        Reference.reachabilityFence(input);\n+                        NIO_ACCESS.releaseScope(input, inScope);\n@@ -760,1 +761,1 @@\n-                        long outputAddress = ((DirectBuffer) output).address();\n+                        var outScope = NIO_ACCESS.acquireScopeOrNull(output);\n@@ -764,1 +765,1 @@\n-                                outputAddress + outputPos, outputRem,\n+                                ((DirectBuffer) output).address()+ outputPos, outputRem,\n@@ -767,1 +768,1 @@\n-                            Reference.reachabilityFence(output);\n+                            NIO_ACCESS.releaseScope(output, outScope);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Deflater.java","additions":21,"deletions":20,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.ref.Reference;\n@@ -38,0 +37,2 @@\n+import static java.util.zip.ZipUtils.NIO_ACCESS;\n+\n@@ -262,1 +263,1 @@\n-                long address = ((DirectBuffer) dictionary).address();\n+                var scope = NIO_ACCESS.acquireScopeOrNull(dictionary);\n@@ -264,1 +265,1 @@\n-                    setDictionaryBuffer(zsRef.address(), address + position, remaining);\n+                    setDictionaryBuffer(zsRef.address(), ((DirectBuffer) dictionary).address() + position, remaining);\n@@ -266,1 +267,1 @@\n-                    Reference.reachabilityFence(dictionary);\n+                    NIO_ACCESS.releaseScope(dictionary, scope);\n@@ -386,0 +387,1 @@\n+                            var inScope = NIO_ACCESS.acquireScopeOrNull(input);\n@@ -387,1 +389,0 @@\n-                                long inputAddress = ((DirectBuffer) input).address();\n@@ -389,1 +390,1 @@\n-                                    inputAddress + inputPos, inputRem,\n+                                    ((DirectBuffer) input).address() + inputPos, inputRem,\n@@ -392,1 +393,1 @@\n-                                Reference.reachabilityFence(input);\n+                                NIO_ACCESS.releaseScope(input, inScope);\n@@ -520,1 +521,1 @@\n-                            long outputAddress = ((DirectBuffer) output).address();\n+                            var outScope = NIO_ACCESS.acquireScopeOrNull(output);\n@@ -524,1 +525,1 @@\n-                                    outputAddress + outputPos, outputRem);\n+                                    ((DirectBuffer)output).address() + outputPos, outputRem);\n@@ -526,1 +527,1 @@\n-                                Reference.reachabilityFence(output);\n+                                NIO_ACCESS.releaseScope(output, outScope);\n@@ -544,1 +545,1 @@\n-                            long inputAddress = ((DirectBuffer) input).address();\n+                            var inScope = NIO_ACCESS.acquireScopeOrNull(input);\n@@ -547,1 +548,1 @@\n-                                    long outputAddress = ((DirectBuffer) output).address();\n+                                    var outScope = NIO_ACCESS.acquireScopeOrNull(output);\n@@ -550,2 +551,2 @@\n-                                            inputAddress + inputPos, inputRem,\n-                                            outputAddress + outputPos, outputRem);\n+                                            ((DirectBuffer) input).address() + inputPos, inputRem,\n+                                            ((DirectBuffer) output).address() + outputPos, outputRem);\n@@ -553,1 +554,1 @@\n-                                        Reference.reachabilityFence(output);\n+                                        NIO_ACCESS.releaseScope(output, outScope);\n@@ -559,1 +560,1 @@\n-                                        inputAddress + inputPos, inputRem,\n+                                        ((DirectBuffer)input).address() + inputPos, inputRem,\n@@ -563,1 +564,1 @@\n-                                Reference.reachabilityFence(input);\n+                                NIO_ACCESS.releaseScope(input, inScope);\n@@ -569,1 +570,1 @@\n-                                long outputAddress = ((DirectBuffer) output).address();\n+                                var outScope = NIO_ACCESS.acquireScopeOrNull(output);\n@@ -573,1 +574,1 @@\n-                                        outputAddress + outputPos, outputRem);\n+                                        ((DirectBuffer) output).address() + outputPos, outputRem);\n@@ -575,1 +576,1 @@\n-                                    Reference.reachabilityFence(output);\n+                                    NIO_ACCESS.releaseScope(output, outScope);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Inflater.java","additions":21,"deletions":20,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -43,0 +45,2 @@\n+    static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipUtils.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -30,0 +31,1 @@\n+import sun.nio.ch.DirectBuffer;\n@@ -33,0 +35,2 @@\n+import java.lang.foreign.MemorySession;\n+import java.lang.ref.Reference;\n@@ -93,0 +97,10 @@\n+     * {@snippet lang = java:\n+     * var handler = acquireSession(buffer, async);\n+     * try {\n+     *     performOperation(buffer);\n+     * } finally {\n+     *     if (handler != null) {\n+     *         handler.run();\n+     *     }\n+     * }\n+     *}\n@@ -96,0 +110,19 @@\n+    \/**\n+     * Used by operations to make a buffer's session non-closeable\n+     * (for the duration of the operation) by acquiring the session.\n+     * The buffers scope is returned if it has one, otherwise {@code null} is returned.\n+     * {@snippet lang = java:\n+     * var guard = acquireScopeOrNull(buffer);\n+     * try {\n+     *     performOperation(buffer);\n+     * } finally {\n+     *     releaseScope(buffer, guard);\n+     * }\n+     *}\n+     *\n+     * @see #releaseScope(Buffer, MemorySessionImpl)\n+     *\/\n+    MemorySessionImpl acquireScopeOrNull(Buffer buffer);\n+\n+    void releaseScope(Buffer buffer, MemorySessionImpl scope);\n+\n@@ -130,0 +163,69 @@\n+\n+    sealed interface ScopeAcquisition extends AutoCloseable {\n+\n+        \/**\n+         * {@return the address of the underlying Buffer}.\n+         * @throws ClassCastException if the underlying Buffer is not a DirectBuffer\n+         *\/\n+        long address();\n+\n+        @Override\n+        void close();\n+\n+        static ScopeAcquisition create(Buffer buffer, MemorySession session) {\n+            return new ClosingScopeAcquisition(buffer, session);\n+        }\n+\n+        static ScopeAcquisition create(Buffer buffer) {\n+            return new NoOpScopeAcquisition(buffer);\n+        }\n+\n+        final class NoOpScopeAcquisition extends AbstractScopeAcquisition implements ScopeAcquisition {\n+\n+            NoOpScopeAcquisition(Buffer buffer) {\n+                super(buffer);\n+            }\n+\n+            @Override\n+            public void close() {\n+                Reference.reachabilityFence(buffer);\n+            }\n+        }\n+\n+        final class ClosingScopeAcquisition extends AbstractScopeAcquisition implements ScopeAcquisition {\n+\n+            private final MemorySession scope;\n+\n+            ClosingScopeAcquisition(Buffer buffer,\n+                                    MemorySession scope) {\n+                super(buffer);\n+                this.scope = scope;\n+            }\n+\n+            @Override\n+            public void close() {\n+                try {\n+                    scope.close();\n+                } finally {\n+                    Reference.reachabilityFence(buffer);\n+                }\n+            }\n+        }\n+\n+        abstract sealed class AbstractScopeAcquisition implements ScopeAcquisition {\n+\n+            final Buffer buffer;\n+\n+            AbstractScopeAcquisition(Buffer buffer) {\n+                this.buffer = buffer;\n+            }\n+\n+            @Override\n+            public final long address() {\n+                return ((DirectBuffer) buffer).address();\n+            }\n+\n+        }\n+\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioAccess.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -169,1 +169,3 @@\n-        jdk.net;\n+        jdk.net,\n+        jdk.sctp,\n+        jdk.crypto.cryptoki;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -90,0 +92,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -783,7 +787,12 @@\n-        int n = receive0(fd,\n-                         ((DirectBuffer)bb).address() + pos, rem,\n-                         sourceSockAddr.address(),\n-                         connected);\n-        if (n > 0)\n-            bb.position(pos + n);\n-        return n;\n+        var scope = NIO_ACCESS.acquireScopeOrNull(bb);\n+        try {\n+            int n = receive0(fd,\n+                    ((DirectBuffer)bb).address() + pos, rem,\n+                    sourceSockAddr.address(),\n+                    connected);\n+            if (n > 0)\n+                bb.position(pos + n);\n+            return n;\n+        } finally {\n+            NIO_ACCESS.releaseScope(bb, scope);\n+        }\n@@ -933,0 +942,1 @@\n+        var scope = NIO_ACCESS.acquireScopeOrNull(bb);\n@@ -941,0 +951,2 @@\n+        } finally {\n+            NIO_ACCESS.releaseScope(bb, scope);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -33,0 +33,7 @@\n+    \/\/ Use of the returned address must be guarded if this DirectBuffer\n+    \/\/ is backed by a memory session that is explicitly closeable.\n+    \/\/\n+    \/\/ Failure to do this means the outcome is undefined including\n+    \/\/ silent unrelated memory mutation and JVM crashes.\n+    \/\/\n+    \/\/ Guards are available in the JavaNioAccess class.\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DirectBuffer.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -137,0 +137,1 @@\n+    permission java.lang.RuntimePermission \"accessClassInPackage.jdk.internal.access\";\n","filename":"src\/java.base\/share\/lib\/security\/default.policy","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.ref.Reference;\n@@ -33,0 +32,3 @@\n+\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -46,0 +48,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -177,1 +181,2 @@\n-        if (dst instanceof sun.nio.ch.DirectBuffer buf) {\n+        if (dst instanceof sun.nio.ch.DirectBuffer ddst) {\n+            var scope = NIO_ACCESS.acquireScopeOrNull(dst);\n@@ -179,1 +184,1 @@\n-                long address = buf.address() + pos;\n+                long address = ddst.address() + pos;\n@@ -184,1 +189,1 @@\n-                Reference.reachabilityFence(buf);\n+                NIO_ACCESS.releaseScope(dst, scope);\n@@ -240,0 +245,1 @@\n+            var scope = NIO_ACCESS.acquireScopeOrNull(src);\n@@ -246,1 +252,1 @@\n-                Reference.reachabilityFence(buf);\n+                NIO_ACCESS.releaseScope(src, scope);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUserDefinedFileAttributeView.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -58,0 +60,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -737,0 +741,1 @@\n+        var inScope = NIO_ACCESS.acquireScopeOrNull(inBuffer);\n@@ -738,22 +743,17 @@\n-            ensureInitialized();\n-\n-            long inAddr = 0;\n-            byte[] in = null;\n-            int inOfs = 0;\n-            if (dataBuffer.size() > 0) {\n-                if (inLen > 0) {\n-                    byte[] temp = new byte[inLen];\n-                    inBuffer.get(temp);\n-                    dataBuffer.write(temp, 0, temp.length);\n-                }\n-                in = dataBuffer.toByteArray();\n-                inOfs = 0;\n-                inLen = in.length;\n-            } else {\n-                if (inBuffer instanceof DirectBuffer) {\n-                    inAddr = ((DirectBuffer) inBuffer).address();\n-                    inOfs = inBuffer.position();\n-                } else {\n-                    if (inBuffer.hasArray()) {\n-                        in = inBuffer.array();\n-                        inOfs = inBuffer.position() + inBuffer.arrayOffset();\n+            var outScope = NIO_ACCESS.acquireScopeOrNull(outBuffer);\n+            try {\n+                try {\n+                    ensureInitialized();\n+\n+                    long inAddr = 0;\n+                    byte[] in = null;\n+                    int inOfs = 0;\n+                    if (dataBuffer.size() > 0) {\n+                        if (inLen > 0) {\n+                            byte[] temp = new byte[inLen];\n+                            inBuffer.get(temp);\n+                            dataBuffer.write(temp, 0, temp.length);\n+                        }\n+                        in = dataBuffer.toByteArray();\n+                        inOfs = 0;\n+                        inLen = in.length;\n@@ -761,2 +761,26 @@\n-                        in = new byte[inLen];\n-                        inBuffer.get(in);\n+                        if (inBuffer instanceof DirectBuffer dInBuffer) {\n+                            inAddr = dInBuffer.address();\n+                            inOfs = inBuffer.position();\n+                        } else {\n+                            if (inBuffer.hasArray()) {\n+                                in = inBuffer.array();\n+                                inOfs = inBuffer.position() + inBuffer.arrayOffset();\n+                            } else {\n+                                in = new byte[inLen];\n+                                inBuffer.get(in);\n+                            }\n+                        }\n+                    }\n+                    long outAddr = 0;\n+                    byte[] outArray = null;\n+                    int outOfs = 0;\n+                    if (outBuffer instanceof DirectBuffer dOutBuffer) {\n+                        outAddr = dOutBuffer.address();\n+                        outOfs = outBuffer.position();\n+                    } else {\n+                        if (outBuffer.hasArray()) {\n+                            outArray = outBuffer.array();\n+                            outOfs = outBuffer.position() + outBuffer.arrayOffset();\n+                        } else {\n+                            outArray = new byte[outLen];\n+                        }\n@@ -764,16 +788,0 @@\n-                }\n-            }\n-            long outAddr = 0;\n-            byte[] outArray = null;\n-            int outOfs = 0;\n-            if (outBuffer instanceof DirectBuffer) {\n-                outAddr = ((DirectBuffer) outBuffer).address();\n-                outOfs = outBuffer.position();\n-            } else {\n-                if (outBuffer.hasArray()) {\n-                    outArray = outBuffer.array();\n-                    outOfs = outBuffer.position() + outBuffer.arrayOffset();\n-                } else {\n-                    outArray = new byte[outLen];\n-                }\n-            }\n@@ -781,9 +789,34 @@\n-            int k = 0;\n-            if (encrypt) {\n-                k = token.p11.C_Encrypt(session.id(), inAddr, in, inOfs, inLen,\n-                        outAddr, outArray, outOfs, outLen);\n-                doCancel = false;\n-            } else {\n-                \/\/ Special handling to match SunJCE provider behavior\n-                if (inLen == 0) {\n-                    return 0;\n+                    int k = 0;\n+                    if (encrypt) {\n+                        k = token.p11.C_Encrypt(session.id(), inAddr, in, inOfs, inLen,\n+                                outAddr, outArray, outOfs, outLen);\n+                        doCancel = false;\n+                    } else {\n+                        \/\/ Special handling to match SunJCE provider behavior\n+                        if (inLen == 0) {\n+                            return 0;\n+                        }\n+                        k = token.p11.C_Decrypt(session.id(), inAddr, in, inOfs, inLen,\n+                                outAddr, outArray, outOfs, outLen);\n+                        doCancel = false;\n+                    }\n+                    inBuffer.position(inBuffer.limit());\n+                    outBuffer.position(outBuffer.position() + k);\n+                    return k;\n+                } catch (PKCS11Exception e) {\n+                    \/\/ As per the PKCS#11 standard, C_Encrypt and C_Decrypt may only\n+                    \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n+                    \/\/ successful calls to determine the output length. However,\n+                    \/\/ these cases are not expected here because the output length\n+                    \/\/ is checked in the OpenJDK side before making the PKCS#11 call.\n+                    \/\/ Thus, doCancel can safely be 'false'.\n+                    doCancel = false;\n+                    handleException(e);\n+                    throw new ProviderException(\"doFinal() failed\", e);\n+                } finally {\n+                    if (encrypt) {\n+                        lastEncKey = this.p11Key;\n+                        lastEncIv = this.iv;\n+                        requireReinit = true;\n+                    }\n+                    reset(doCancel);\n@@ -791,3 +824,2 @@\n-                k = token.p11.C_Decrypt(session.id(), inAddr, in, inOfs, inLen,\n-                        outAddr, outArray, outOfs, outLen);\n-                doCancel = false;\n+            } finally {\n+                NIO_ACCESS.releaseScope(outBuffer, outScope);\n@@ -795,13 +827,0 @@\n-            inBuffer.position(inBuffer.limit());\n-            outBuffer.position(outBuffer.position() + k);\n-            return k;\n-        } catch (PKCS11Exception e) {\n-            \/\/ As per the PKCS#11 standard, C_Encrypt and C_Decrypt may only\n-            \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n-            \/\/ successful calls to determine the output length. However,\n-            \/\/ these cases are not expected here because the output length\n-            \/\/ is checked in the OpenJDK side before making the PKCS#11 call.\n-            \/\/ Thus, doCancel can safely be 'false'.\n-            doCancel = false;\n-            handleException(e);\n-            throw new ProviderException(\"doFinal() failed\", e);\n@@ -809,6 +828,1 @@\n-            if (encrypt) {\n-                lastEncKey = this.p11Key;\n-                lastEncIv = this.iv;\n-                requireReinit = true;\n-            }\n-            reset(doCancel);\n+            NIO_ACCESS.releaseScope(inBuffer, inScope);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":85,"deletions":71,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -59,0 +61,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -690,0 +694,1 @@\n+        var inScope = NIO_ACCESS.acquireScopeOrNull(inBuffer);\n@@ -691,13 +696,15 @@\n-            ensureInitialized();\n-\n-            long inAddr = 0;\n-            int inOfs = 0;\n-            byte[] inArray = null;\n-\n-            if (inBuffer instanceof DirectBuffer) {\n-                inAddr = ((DirectBuffer) inBuffer).address();\n-                inOfs = origPos;\n-            } else if (inBuffer.hasArray()) {\n-                inArray = inBuffer.array();\n-                inOfs = (origPos + inBuffer.arrayOffset());\n-            }\n+            var outScope = NIO_ACCESS.acquireScopeOrNull(outBuffer);\n+            try {\n+                ensureInitialized();\n+\n+                long inAddr = 0;\n+                int inOfs = 0;\n+                byte[] inArray = null;\n+\n+                if (inBuffer instanceof DirectBuffer dInBuffer) {\n+                    inAddr = dInBuffer.address();\n+                    inOfs = origPos;\n+                } else if (inBuffer.hasArray()) {\n+                    inArray = inBuffer.array();\n+                    inOfs = (origPos + inBuffer.arrayOffset());\n+                }\n@@ -705,10 +712,6 @@\n-            long outAddr = 0;\n-            int outOfs = 0;\n-            byte[] outArray = null;\n-            if (outBuffer instanceof DirectBuffer) {\n-                outAddr = ((DirectBuffer) outBuffer).address();\n-                outOfs = outBuffer.position();\n-            } else {\n-                if (outBuffer.hasArray()) {\n-                    outArray = outBuffer.array();\n-                    outOfs = (outBuffer.position() + outBuffer.arrayOffset());\n+                long outAddr = 0;\n+                int outOfs = 0;\n+                byte[] outArray = null;\n+                if (outBuffer instanceof DirectBuffer dOutBuffer) {\n+                    outAddr = dOutBuffer.address();\n+                    outOfs = outBuffer.position();\n@@ -716,1 +719,6 @@\n-                    outArray = new byte[outLen];\n+                    if (outBuffer.hasArray()) {\n+                        outArray = outBuffer.array();\n+                        outOfs = (outBuffer.position() + outBuffer.arrayOffset());\n+                    } else {\n+                        outArray = new byte[outLen];\n+                    }\n@@ -718,1 +726,0 @@\n-            }\n@@ -720,10 +727,19 @@\n-            int k = 0;\n-            int newPadBufferLen = 0;\n-            if (paddingObj != null  && (!encrypt || reqBlockUpdates)) {\n-                if (padBufferLen != 0) {\n-                    if (padBufferLen != padBuffer.length) {\n-                        int bufCapacity = padBuffer.length - padBufferLen;\n-                        if (inLen > bufCapacity) {\n-                            bufferInputBytes(inBuffer, bufCapacity);\n-                            inOfs += bufCapacity;\n-                            inLen -= bufCapacity;\n+                int k = 0;\n+                int newPadBufferLen = 0;\n+                if (paddingObj != null && (!encrypt || reqBlockUpdates)) {\n+                    if (padBufferLen != 0) {\n+                        if (padBufferLen != padBuffer.length) {\n+                            int bufCapacity = padBuffer.length - padBufferLen;\n+                            if (inLen > bufCapacity) {\n+                                bufferInputBytes(inBuffer, bufCapacity);\n+                                inOfs += bufCapacity;\n+                                inLen -= bufCapacity;\n+                            } else {\n+                                bufferInputBytes(inBuffer, inLen);\n+                                return 0;\n+                            }\n+                        }\n+                        if (encrypt) {\n+                            k = token.p11.C_EncryptUpdate(session.id(), 0,\n+                                    padBuffer, 0, padBufferLen, outAddr, outArray,\n+                                    outOfs, outLen);\n@@ -731,2 +747,3 @@\n-                            bufferInputBytes(inBuffer, inLen);\n-                            return 0;\n+                            k = token.p11.C_DecryptUpdate(session.id(), 0,\n+                                    padBuffer, 0, padBufferLen, outAddr, outArray,\n+                                    outOfs, outLen);\n@@ -734,0 +751,19 @@\n+                        padBufferLen = 0;\n+                    }\n+                    newPadBufferLen = inLen & (blockSize - 1);\n+                    if (!encrypt && newPadBufferLen == 0) {\n+                        \/\/ While decrypting with implUpdate, the last encrypted block\n+                        \/\/ is always held in a buffer. If it's the final one (unknown\n+                        \/\/ at this point), it may contain padding bytes and need further\n+                        \/\/ processing. In implDoFinal (where we know it's the final one)\n+                        \/\/ the buffer is decrypted, unpadded and returned.\n+                        newPadBufferLen = padBuffer.length;\n+                    }\n+                    inLen -= newPadBufferLen;\n+                }\n+                if (inLen > 0) {\n+                    if (inAddr == 0 && inArray == null) {\n+                        inArray = new byte[inLen];\n+                        inBuffer.get(inArray);\n+                    } else {\n+                        inBuffer.position(inBuffer.position() + inLen);\n@@ -736,3 +772,3 @@\n-                        k = token.p11.C_EncryptUpdate(session.id(), 0,\n-                                padBuffer, 0, padBufferLen, outAddr, outArray,\n-                                outOfs, outLen);\n+                        k += token.p11.C_EncryptUpdate(session.id(), inAddr,\n+                                inArray, inOfs, inLen, outAddr, outArray,\n+                                (outOfs + k), (outLen - k));\n@@ -740,3 +776,3 @@\n-                        k = token.p11.C_DecryptUpdate(session.id(), 0,\n-                                padBuffer, 0, padBufferLen, outAddr, outArray,\n-                                outOfs, outLen);\n+                        k += token.p11.C_DecryptUpdate(session.id(), inAddr,\n+                                inArray, inOfs, inLen, outAddr, outArray,\n+                                (outOfs + k), (outLen - k));\n@@ -744,1 +780,0 @@\n-                    padBufferLen = 0;\n@@ -746,8 +781,3 @@\n-                newPadBufferLen = inLen & (blockSize - 1);\n-                if (!encrypt && newPadBufferLen == 0) {\n-                    \/\/ While decrypting with implUpdate, the last encrypted block\n-                    \/\/ is always held in a buffer. If it's the final one (unknown\n-                    \/\/ at this point), it may contain padding bytes and need further\n-                    \/\/ processing. In implDoFinal (where we know it's the final one)\n-                    \/\/ the buffer is decrypted, unpadded and returned.\n-                    newPadBufferLen = padBuffer.length;\n+                \/\/ update 'padBuffer' if using our own padding impl.\n+                if (paddingObj != null && newPadBufferLen > 0) {\n+                    bufferInputBytes(inBuffer, newPadBufferLen);\n@@ -755,6 +785,4 @@\n-                inLen -= newPadBufferLen;\n-            }\n-            if (inLen > 0) {\n-                if (inAddr == 0 && inArray == null) {\n-                    inArray = new byte[inLen];\n-                    inBuffer.get(inArray);\n+                bytesBuffered += (inLen - k);\n+                if (!(outBuffer instanceof DirectBuffer) &&\n+                        !outBuffer.hasArray()) {\n+                    outBuffer.put(outArray, outOfs, k);\n@@ -762,1 +790,1 @@\n-                    inBuffer.position(inBuffer.position() + inLen);\n+                    outBuffer.position(outBuffer.position() + k);\n@@ -764,8 +792,7 @@\n-                if (encrypt) {\n-                    k += token.p11.C_EncryptUpdate(session.id(), inAddr,\n-                            inArray, inOfs, inLen, outAddr, outArray,\n-                            (outOfs + k), (outLen - k));\n-                } else {\n-                    k += token.p11.C_DecryptUpdate(session.id(), inAddr,\n-                            inArray, inOfs, inLen, outAddr, outArray,\n-                            (outOfs + k), (outLen - k));\n+                return k;\n+            } catch (PKCS11Exception e) {\n+                \/\/ Reset input buffer to its original position for\n+                inBuffer.position(origPos);\n+                if (e.match(CKR_BUFFER_TOO_SMALL)) {\n+                    throw (ShortBufferException)\n+                            (new ShortBufferException().initCause(e));\n@@ -773,0 +800,8 @@\n+                \/\/ Some implementations such as the NSS Software Token do not\n+                \/\/ cancel the operation upon a C_EncryptUpdate\/C_DecryptUpdate\n+                \/\/ failure (as required by the PKCS#11 standard). See JDK-8258833\n+                \/\/ for further information.\n+                reset(true);\n+                throw new ProviderException(\"update() failed\", e);\n+            } finally {\n+                NIO_ACCESS.releaseScope(outBuffer, outScope);\n@@ -774,25 +809,2 @@\n-            \/\/ update 'padBuffer' if using our own padding impl.\n-            if (paddingObj != null && newPadBufferLen > 0) {\n-                bufferInputBytes(inBuffer, newPadBufferLen);\n-            }\n-            bytesBuffered += (inLen - k);\n-            if (!(outBuffer instanceof DirectBuffer) &&\n-                    !outBuffer.hasArray()) {\n-                outBuffer.put(outArray, outOfs, k);\n-            } else {\n-                outBuffer.position(outBuffer.position() + k);\n-            }\n-            return k;\n-        } catch (PKCS11Exception e) {\n-            \/\/ Reset input buffer to its original position for\n-            inBuffer.position(origPos);\n-            if (e.match(CKR_BUFFER_TOO_SMALL)) {\n-                throw (ShortBufferException)\n-                        (new ShortBufferException().initCause(e));\n-            }\n-            \/\/ Some implementations such as the NSS Software Token do not\n-            \/\/ cancel the operation upon a C_EncryptUpdate\/C_DecryptUpdate\n-            \/\/ failure (as required by the PKCS#11 standard). See JDK-8258833\n-            \/\/ for further information.\n-            reset(true);\n-            throw new ProviderException(\"update() failed\", e);\n+        } finally {\n+            NIO_ACCESS.releaseScope(inBuffer, inScope);\n@@ -889,0 +901,1 @@\n+        var scope = NIO_ACCESS.acquireScopeOrNull(outBuffer);\n@@ -890,12 +903,9 @@\n-            ensureInitialized();\n-\n-            long outAddr = 0;\n-            byte[] outArray = null;\n-            int outOfs = 0;\n-            if (outBuffer instanceof DirectBuffer) {\n-                outAddr = ((DirectBuffer) outBuffer).address();\n-                outOfs = outBuffer.position();\n-            } else {\n-                if (outBuffer.hasArray()) {\n-                    outArray = outBuffer.array();\n-                    outOfs = outBuffer.position() + outBuffer.arrayOffset();\n+            try {\n+                ensureInitialized();\n+\n+                long outAddr = 0;\n+                byte[] outArray = null;\n+                int outOfs = 0;\n+                if (outBuffer instanceof DirectBuffer dOutBuffer) {\n+                    outAddr = dOutBuffer.address();\n+                    outOfs = outBuffer.position();\n@@ -903,1 +913,6 @@\n-                    outArray = new byte[outLen];\n+                    if (outBuffer.hasArray()) {\n+                        outArray = outBuffer.array();\n+                        outOfs = outBuffer.position() + outBuffer.arrayOffset();\n+                    } else {\n+                        outArray = new byte[outLen];\n+                    }\n@@ -905,1 +920,0 @@\n-            }\n@@ -907,1 +921,1 @@\n-            int k = 0;\n+                int k = 0;\n@@ -909,12 +923,13 @@\n-            if (encrypt) {\n-                if (paddingObj != null) {\n-                    int startOff = 0;\n-                    if (reqBlockUpdates) {\n-                        \/\/ call C_EncryptUpdate first if the padBuffer is full\n-                        \/\/ to make room for padding bytes\n-                        if (padBufferLen == padBuffer.length) {\n-                            k = token.p11.C_EncryptUpdate(session.id(),\n-                                0, padBuffer, 0, padBufferLen,\n-                                outAddr, outArray, outOfs, outLen);\n-                        } else {\n-                            startOff = padBufferLen;\n+                if (encrypt) {\n+                    if (paddingObj != null) {\n+                        int startOff = 0;\n+                        if (reqBlockUpdates) {\n+                            \/\/ call C_EncryptUpdate first if the padBuffer is full\n+                            \/\/ to make room for padding bytes\n+                            if (padBufferLen == padBuffer.length) {\n+                                k = token.p11.C_EncryptUpdate(session.id(),\n+                                        0, padBuffer, 0, padBufferLen,\n+                                        outAddr, outArray, outOfs, outLen);\n+                            } else {\n+                                startOff = padBufferLen;\n+                            }\n@@ -922,27 +937,5 @@\n-                    }\n-                    int actualPadLen = paddingObj.setPaddingBytes(padBuffer,\n-                            startOff, requiredOutLen - bytesBuffered);\n-                    k += token.p11.C_EncryptUpdate(session.id(),\n-                            0, padBuffer, 0, startOff + actualPadLen,\n-                            outAddr, outArray, outOfs + k, outLen - k);\n-                }\n-                \/\/ Some implementations such as the NSS Software Token do not\n-                \/\/ cancel the operation upon a C_EncryptUpdate failure (as\n-                \/\/ required by the PKCS#11 standard). Cancel is not needed\n-                \/\/ only after this point. See JDK-8258833 for further\n-                \/\/ information.\n-                doCancel = false;\n-                k += token.p11.C_EncryptFinal(session.id(),\n-                        outAddr, outArray, (outOfs + k), (outLen - k));\n-            } else {\n-                \/\/ Special handling to match SunJCE provider behavior\n-                if (bytesBuffered == 0 && padBufferLen == 0) {\n-                    return 0;\n-                }\n-\n-                if (paddingObj != null) {\n-                    if (padBufferLen != 0) {\n-                        k = token.p11.C_DecryptUpdate(session.id(),\n-                                0, padBuffer, 0, padBufferLen,\n-                                0, padBuffer, 0, padBuffer.length);\n-                        padBufferLen = 0;\n+                        int actualPadLen = paddingObj.setPaddingBytes(padBuffer,\n+                                startOff, requiredOutLen - bytesBuffered);\n+                        k += token.p11.C_EncryptUpdate(session.id(),\n+                                0, padBuffer, 0, startOff + actualPadLen,\n+                                outAddr, outArray, outOfs + k, outLen - k);\n@@ -951,1 +944,1 @@\n-                    \/\/ cancel the operation upon a C_DecryptUpdate failure (as\n+                    \/\/ cancel the operation upon a C_EncryptUpdate failure (as\n@@ -956,2 +949,7 @@\n-                    k += token.p11.C_DecryptFinal(session.id(),\n-                            0, padBuffer, k, padBuffer.length - k);\n+                    k += token.p11.C_EncryptFinal(session.id(),\n+                            outAddr, outArray, (outOfs + k), (outLen - k));\n+                } else {\n+                    \/\/ Special handling to match SunJCE provider behavior\n+                    if (bytesBuffered == 0 && padBufferLen == 0) {\n+                        return 0;\n+                    }\n@@ -959,4 +957,30 @@\n-                    int actualPadLen = paddingObj.unpad(padBuffer, k);\n-                    k -= actualPadLen;\n-                    outArray = padBuffer;\n-                    outOfs = 0;\n+                    if (paddingObj != null) {\n+                        if (padBufferLen != 0) {\n+                            k = token.p11.C_DecryptUpdate(session.id(),\n+                                    0, padBuffer, 0, padBufferLen,\n+                                    0, padBuffer, 0, padBuffer.length);\n+                            padBufferLen = 0;\n+                        }\n+                        \/\/ Some implementations such as the NSS Software Token do not\n+                        \/\/ cancel the operation upon a C_DecryptUpdate failure (as\n+                        \/\/ required by the PKCS#11 standard). Cancel is not needed\n+                        \/\/ only after this point. See JDK-8258833 for further\n+                        \/\/ information.\n+                        doCancel = false;\n+                        k += token.p11.C_DecryptFinal(session.id(),\n+                                0, padBuffer, k, padBuffer.length - k);\n+\n+                        int actualPadLen = paddingObj.unpad(padBuffer, k);\n+                        k -= actualPadLen;\n+                        outArray = padBuffer;\n+                        outOfs = 0;\n+                    } else {\n+                        doCancel = false;\n+                        k = token.p11.C_DecryptFinal(session.id(),\n+                                outAddr, outArray, outOfs, outLen);\n+                    }\n+                }\n+                if ((!encrypt && paddingObj != null) ||\n+                        (!(outBuffer instanceof DirectBuffer) &&\n+                                !outBuffer.hasArray())) {\n+                    outBuffer.put(outArray, outOfs, k);\n@@ -964,3 +988,1 @@\n-                    doCancel = false;\n-                    k = token.p11.C_DecryptFinal(session.id(),\n-                            outAddr, outArray, outOfs, outLen);\n+                    outBuffer.position(outBuffer.position() + k);\n@@ -968,0 +990,6 @@\n+                return k;\n+            } catch (PKCS11Exception e) {\n+                handleException(e);\n+                throw new ProviderException(\"doFinal() failed\", e);\n+            } finally {\n+                reset(doCancel);\n@@ -969,11 +997,0 @@\n-            if ((!encrypt && paddingObj != null) ||\n-                    (!(outBuffer instanceof DirectBuffer) &&\n-                    !outBuffer.hasArray())) {\n-                outBuffer.put(outArray, outOfs, k);\n-            } else {\n-                outBuffer.position(outBuffer.position() + k);\n-            }\n-            return k;\n-        } catch (PKCS11Exception e) {\n-            handleException(e);\n-            throw new ProviderException(\"doFinal() failed\", e);\n@@ -981,1 +998,1 @@\n-            reset(doCancel);\n+            NIO_ACCESS.releaseScope(outBuffer, scope);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":185,"deletions":168,"binary":false,"changes":353,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.*;\n@@ -35,0 +34,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -58,0 +59,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -292,1 +295,1 @@\n-        if (byteBuffer instanceof DirectBuffer == false) {\n+        if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n@@ -298,1 +301,0 @@\n-        long addr = ((DirectBuffer)byteBuffer).address();\n@@ -309,1 +311,6 @@\n-            token.p11.C_DigestUpdate(session.id(), addr + ofs, null, 0, len);\n+            var scope = NIO_ACCESS.acquireScopeOrNull(byteBuffer);\n+            try {\n+                token.p11.C_DigestUpdate(session.id(), dByteBuffer.address() + ofs, null, 0, len);\n+            } finally {\n+                NIO_ACCESS.releaseScope(byteBuffer, scope);\n+            }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Digest.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -46,1 +48,0 @@\n-import static sun.security.pkcs11.P11Cipher.*;\n@@ -61,0 +62,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -559,0 +562,1 @@\n+        var inScope = NIO_ACCESS.acquireScopeOrNull(inBuffer);\n@@ -560,24 +564,19 @@\n-            ensureInitialized();\n-\n-            long inAddr = 0;\n-            byte[] in = null;\n-            int inOfs = 0;\n-\n-            if (dataBuffer.size() > 0) {\n-                if (inBuffer != null && inLen > 0) {\n-                    byte[] temp = new byte[inLen];\n-                    inBuffer.get(temp);\n-                    dataBuffer.write(temp, 0, temp.length);\n-                }\n-\n-                in = dataBuffer.toByteArray();\n-                inOfs = 0;\n-                inLen = in.length;\n-            } else {\n-                if (inBuffer instanceof DirectBuffer) {\n-                    inAddr = ((DirectBuffer) inBuffer).address();\n-                    inOfs = inBuffer.position();\n-                } else {\n-                    if (inBuffer.hasArray()) {\n-                        in = inBuffer.array();\n-                        inOfs = inBuffer.position() + inBuffer.arrayOffset();\n+            var outScope = NIO_ACCESS.acquireScopeOrNull(outBuffer);\n+            try {\n+                try {\n+                    ensureInitialized();\n+\n+                    long inAddr = 0;\n+                    byte[] in = null;\n+                    int inOfs = 0;\n+\n+                    if (dataBuffer.size() > 0) {\n+                        if (inBuffer != null && inLen > 0) {\n+                            byte[] temp = new byte[inLen];\n+                            inBuffer.get(temp);\n+                            dataBuffer.write(temp, 0, temp.length);\n+                        }\n+\n+                        in = dataBuffer.toByteArray();\n+                        inOfs = 0;\n+                        inLen = in.length;\n@@ -585,2 +584,26 @@\n-                        in = new byte[inLen];\n-                        inBuffer.get(in);\n+                        if (inBuffer instanceof DirectBuffer dInBuffer) {\n+                            inAddr = dInBuffer.address();\n+                            inOfs = inBuffer.position();\n+                        } else {\n+                            if (inBuffer.hasArray()) {\n+                                in = inBuffer.array();\n+                                inOfs = inBuffer.position() + inBuffer.arrayOffset();\n+                            } else {\n+                                in = new byte[inLen];\n+                                inBuffer.get(in);\n+                            }\n+                        }\n+                    }\n+                    long outAddr = 0;\n+                    byte[] outArray = null;\n+                    int outOfs = 0;\n+                    if (outBuffer instanceof DirectBuffer dOutBuffer) {\n+                        outAddr = dOutBuffer.address();\n+                        outOfs = outBuffer.position();\n+                    } else {\n+                        if (outBuffer.hasArray()) {\n+                            outArray = outBuffer.array();\n+                            outOfs = outBuffer.position() + outBuffer.arrayOffset();\n+                        } else {\n+                            outArray = new byte[outLen];\n+                        }\n@@ -588,16 +611,0 @@\n-                }\n-            }\n-            long outAddr = 0;\n-            byte[] outArray = null;\n-            int outOfs = 0;\n-            if (outBuffer instanceof DirectBuffer) {\n-                outAddr = ((DirectBuffer) outBuffer).address();\n-                outOfs = outBuffer.position();\n-            } else {\n-                if (outBuffer.hasArray()) {\n-                    outArray = outBuffer.array();\n-                    outOfs = outBuffer.position() + outBuffer.arrayOffset();\n-                } else {\n-                    outArray = new byte[outLen];\n-                }\n-            }\n@@ -605,8 +612,26 @@\n-            if (opmode == Cipher.ENCRYPT_MODE) {\n-                k = token.p11.C_Encrypt(session.id(), inAddr, in, inOfs, inLen,\n-                        outAddr, outArray, outOfs, outLen);\n-                doCancel = false;\n-            } else {\n-                \/\/ Special handling to match SunJCE provider behavior\n-                if (inLen == 0) {\n-                    return 0;\n+                    if (opmode == Cipher.ENCRYPT_MODE) {\n+                        k = token.p11.C_Encrypt(session.id(), inAddr, in, inOfs, inLen,\n+                                outAddr, outArray, outOfs, outLen);\n+                        doCancel = false;\n+                    } else {\n+                        \/\/ Special handling to match SunJCE provider behavior\n+                        if (inLen == 0) {\n+                            return 0;\n+                        }\n+                        k = token.p11.C_Decrypt(session.id(), inAddr, in, inOfs, inLen,\n+                                outAddr, outArray, outOfs, outLen);\n+                        doCancel = false;\n+                    }\n+                    inBuffer.position(inBuffer.limit());\n+                    outBuffer.position(outBuffer.position() + k);\n+                } catch (PKCS11Exception e) {\n+                    \/\/ As per the PKCS#11 standard, C_Encrypt and C_Decrypt may only\n+                    \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n+                    \/\/ successful calls to determine the output length. However,\n+                    \/\/ these cases are not expected here because the output length\n+                    \/\/ is checked in the OpenJDK side before making the PKCS#11 call.\n+                    \/\/ Thus, doCancel can safely be 'false'.\n+                    doCancel = false;\n+                    handleEncException(\"doFinal() failed\", e);\n+                } finally {\n+                    reset(doCancel);\n@@ -614,3 +639,2 @@\n-                k = token.p11.C_Decrypt(session.id(), inAddr, in, inOfs, inLen,\n-                        outAddr, outArray, outOfs, outLen);\n-                doCancel = false;\n+            } finally {\n+                NIO_ACCESS.releaseScope(outBuffer, outScope);\n@@ -618,11 +642,0 @@\n-            inBuffer.position(inBuffer.limit());\n-            outBuffer.position(outBuffer.position() + k);\n-        } catch (PKCS11Exception e) {\n-            \/\/ As per the PKCS#11 standard, C_Encrypt and C_Decrypt may only\n-            \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n-            \/\/ successful calls to determine the output length. However,\n-            \/\/ these cases are not expected here because the output length\n-            \/\/ is checked in the OpenJDK side before making the PKCS#11 call.\n-            \/\/ Thus, doCancel can safely be 'false'.\n-            doCancel = false;\n-            handleEncException(\"doFinal() failed\", e);\n@@ -630,1 +643,1 @@\n-            reset(doCancel);\n+            NIO_ACCESS.releaseScope(inBuffer, inScope);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyWrapCipher.java","additions":79,"deletions":66,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -58,0 +60,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -268,1 +272,1 @@\n-            if (byteBuffer instanceof DirectBuffer == false) {\n+            if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n@@ -272,1 +276,0 @@\n-            long addr = ((DirectBuffer)byteBuffer).address();\n@@ -274,1 +277,6 @@\n-            token.p11.C_SignUpdate(session.id(), addr + ofs, null, 0, len);\n+            var scope = NIO_ACCESS.acquireScopeOrNull(byteBuffer);\n+            try  {\n+                token.p11.C_SignUpdate(session.id(), dByteBuffer.address() + ofs, null, 0, len);\n+            } finally {\n+                NIO_ACCESS.releaseScope(byteBuffer, scope);\n+            }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Mac.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n@@ -31,0 +29,3 @@\n+\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -34,1 +35,0 @@\n-import java.util.Arrays;\n@@ -71,0 +71,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -619,1 +621,1 @@\n-            if (byteBuffer instanceof DirectBuffer == false) {\n+            if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n@@ -624,1 +626,0 @@\n-            long addr = ((DirectBuffer)byteBuffer).address();\n@@ -626,0 +627,1 @@\n+            var scope = NIO_ACCESS.acquireScopeOrNull(byteBuffer);\n@@ -630,1 +632,1 @@\n-                        (session.id(), addr + ofs, null, 0, len);\n+                        (session.id(), dByteBuffer.address() + ofs, null, 0, len);\n@@ -634,1 +636,1 @@\n-                        (session.id(), addr + ofs, null, 0, len);\n+                        (session.id(), dByteBuffer.address() + ofs, null, 0, len);\n@@ -641,0 +643,2 @@\n+            } finally {\n+                NIO_ACCESS.releaseScope(byteBuffer, scope);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11PSSSignature.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -38,1 +41,0 @@\n-import sun.security.x509.AlgorithmId;\n@@ -101,0 +103,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -584,1 +588,1 @@\n-            if (byteBuffer instanceof DirectBuffer == false) {\n+            if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n@@ -589,1 +593,0 @@\n-            long addr = ((DirectBuffer)byteBuffer).address();\n@@ -591,0 +594,1 @@\n+            var scope = NIO_ACCESS.acquireScopeOrNull(byteBuffer);\n@@ -594,1 +598,1 @@\n-                        (session.id(), addr + ofs, null, 0, len);\n+                        (session.id(), dByteBuffer.address() + ofs, null, 0, len);\n@@ -597,1 +601,1 @@\n-                        (session.id(), addr + ofs, null, 0, len);\n+                        (session.id(), dByteBuffer.address() + ofs, null, 0, len);\n@@ -604,0 +608,2 @@\n+            } finally {\n+                NIO_ACCESS.releaseScope(byteBuffer, scope);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Signature.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -77,0 +79,3 @@\n+\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -842,1 +847,3 @@\n-        int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem, peek);\n+        var scope = NIO_ACCESS.acquireScopeOrNull(bb);\n+        try {\n+            int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem, peek);\n@@ -844,3 +851,6 @@\n-        if (n > 0)\n-            bb.position(pos + n);\n-        return n;\n+            if (n > 0)\n+                bb.position(pos + n);\n+            return n;\n+        } finally {\n+            NIO_ACCESS.releaseScope(bb, scope);\n+        }\n@@ -1031,5 +1041,10 @@\n-        int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,\n-                            port, -1 \/*121*\/, streamNumber, unordered, ppid);\n-        if (written > 0)\n-            bb.position(pos + written);\n-        return written;\n+        var scope = NIO_ACCESS.acquireScopeOrNull(bb);\n+        try {\n+            int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,\n+                    port, -1 \/*121*\/, streamNumber, unordered, ppid);\n+            if (written > 0)\n+                bb.position(pos + written);\n+            return written;\n+        } finally {\n+            NIO_ACCESS.releaseScope(bb, scope);\n+        }\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":24,"deletions":9,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -74,0 +76,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -586,4 +590,9 @@\n-        int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem);\n-        if (n > 0)\n-            bb.position(pos + n);\n-        return n;\n+        var scope = NIO_ACCESS.acquireScopeOrNull(bb);\n+        try {\n+            int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem);\n+            if (n > 0)\n+                bb.position(pos + n);\n+            return n;\n+        } finally {\n+            NIO_ACCESS.releaseScope(bb, scope);\n+        }\n@@ -911,5 +920,10 @@\n-        int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,\n-                            port, assocId, streamNumber, unordered, ppid);\n-        if (written > 0)\n-            bb.position(pos + written);\n-        return written;\n+        var scope = NIO_ACCESS.acquireScopeOrNull(bb);\n+        try {\n+            int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,\n+                    port, assocId, streamNumber, unordered, ppid);\n+            if (written > 0)\n+                bb.position(pos + written);\n+            return written;\n+        } finally {\n+            NIO_ACCESS.releaseScope(bb, scope);\n+        }\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpMultiChannelImpl.java","additions":23,"deletions":9,"binary":false,"changes":32,"status":"modified"}]}