{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -95,0 +97,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -912,0 +916,2 @@\n+                \/\/ The use of DirectBuffer::address below need not be guarded as\n+                \/\/ no access is made to actual memory.\n@@ -949,1 +955,0 @@\n-\n@@ -1588,2 +1593,7 @@\n-                    Unsafe.getUnsafe().setMemory(((DirectBuffer)dst).address(),\n-                        len + dst.position(), (byte)0);\n+                    var scope = NIO_ACCESS.acquireSession(dst);\n+                    try {\n+                        Unsafe.getUnsafe().setMemory(((DirectBuffer)dst).address(),\n+                                len + dst.position(), (byte) 0);\n+                    } finally {\n+                        NIO_ACCESS.releaseSession(dst, scope);\n+                    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.lang.ref.Reference;\n@@ -781,0 +782,1 @@\n+\n@@ -826,3 +828,3 @@\n-                public Runnable acquireSession(Buffer buffer, boolean async) {\n-                    var session = buffer.session();\n-                    if (session == null) {\n+                public MemorySessionImpl acquireSession(Buffer buffer) {\n+                    var scope = buffer.session();\n+                    if (scope == null) {\n@@ -831,2 +833,13 @@\n-                    if (async && session.ownerThread() != null) {\n-                        throw new IllegalStateException(\"Confined session not supported\");\n+                    scope.acquire0();\n+                    return scope;\n+                }\n+\n+                @Override\n+                public void releaseSession(Buffer buffer, MemorySessionImpl scope) {\n+                    assert buffer.session() == scope;\n+                    try {\n+                        if (scope != null) {\n+                            scope.release0();\n+                        }\n+                    } finally {\n+                        Reference.reachabilityFence(buffer);\n@@ -834,2 +847,6 @@\n-                    session.acquire0();\n-                    return session::release0;\n+                }\n+\n+                @Override\n+                public boolean isThreadConfined(Buffer buffer) {\n+                    var scope = buffer.session();\n+                    return scope != null && scope.ownerThread() != null;\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.ref.Reference;\n@@ -30,1 +29,1 @@\n-import sun.nio.ch.DirectBuffer;\n+\n@@ -33,0 +32,3 @@\n+import sun.nio.ch.DirectBuffer;\n+\n+import static java.util.zip.ZipUtils.NIO_ACCESS;\n@@ -99,0 +101,1 @@\n+            var scope = NIO_ACCESS.acquireSession(buffer);\n@@ -102,1 +105,1 @@\n-                Reference.reachabilityFence(buffer);\n+                NIO_ACCESS.releaseSession(buffer, scope);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Adler32.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.ref.Reference;\n@@ -36,0 +35,2 @@\n+import static java.util.zip.ZipUtils.NIO_ACCESS;\n+\n@@ -99,0 +100,1 @@\n+            var scope = NIO_ACCESS.acquireSession(buffer);\n@@ -102,1 +104,1 @@\n-                Reference.reachabilityFence(buffer);\n+                NIO_ACCESS.releaseSession(buffer, scope);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/CRC32.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.ref.Reference;\n@@ -36,0 +35,2 @@\n+import static java.util.zip.ZipUtils.NIO_ACCESS;\n+\n@@ -174,0 +175,1 @@\n+            var scope = NIO_ACCESS.acquireSession(buffer);\n@@ -175,1 +177,1 @@\n-                crc = updateDirectByteBuffer(crc, ((DirectBuffer) buffer).address(),\n+                crc = updateDirectByteBuffer(crc, ((DirectBuffer)buffer).address(),\n@@ -178,1 +180,1 @@\n-                Reference.reachabilityFence(buffer);\n+                NIO_ACCESS.releaseSession(buffer, scope);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/CRC32C.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.ref.Reference;\n@@ -38,0 +37,2 @@\n+import static java.util.zip.ZipUtils.NIO_ACCESS;\n+\n@@ -340,1 +341,1 @@\n-                long address = ((DirectBuffer) dictionary).address();\n+                var scope = NIO_ACCESS.acquireSession(dictionary);\n@@ -342,1 +343,1 @@\n-                    setDictionaryBuffer(zsRef.address(), address + position, remaining);\n+                    setDictionaryBuffer(zsRef.address(), ((DirectBuffer) dictionary).address() + position, remaining);\n@@ -344,1 +345,1 @@\n-                    Reference.reachabilityFence(dictionary);\n+                    NIO_ACCESS.releaseSession(dictionary, scope);\n@@ -590,0 +591,1 @@\n+                    var scope = NIO_ACCESS.acquireSession(input);\n@@ -597,1 +599,1 @@\n-                        Reference.reachabilityFence(input);\n+                        NIO_ACCESS.releaseSession(input, scope);\n@@ -712,1 +714,1 @@\n-                    long outputAddress = ((DirectBuffer) output).address();\n+                    var outScope = NIO_ACCESS.acquireSession(output);\n@@ -714,0 +716,1 @@\n+                        long outputAddress = ((DirectBuffer) output).address();\n@@ -719,1 +722,1 @@\n-                        Reference.reachabilityFence(output);\n+                        NIO_ACCESS.releaseSession(output, outScope);\n@@ -733,1 +736,1 @@\n-                    long inputAddress = ((DirectBuffer) input).address();\n+                    var inScope = NIO_ACCESS.acquireSession(input);\n@@ -735,0 +738,1 @@\n+                        long inputAddress = ((DirectBuffer) input).address();\n@@ -736,1 +740,1 @@\n-                            long outputAddress = outputPos + ((DirectBuffer) output).address();\n+                            var outScope = NIO_ACCESS.acquireSession(output);\n@@ -738,0 +742,1 @@\n+                                long outputAddress = outputPos + ((DirectBuffer) output).address();\n@@ -743,1 +748,1 @@\n-                                Reference.reachabilityFence(output);\n+                                NIO_ACCESS.releaseSession(output, outScope);\n@@ -754,1 +759,1 @@\n-                        Reference.reachabilityFence(input);\n+                        NIO_ACCESS.releaseSession(input, inScope);\n@@ -760,1 +765,1 @@\n-                        long outputAddress = ((DirectBuffer) output).address();\n+                        var outScope = NIO_ACCESS.acquireSession(output);\n@@ -762,0 +767,1 @@\n+                            long outputAddress = ((DirectBuffer) output).address();\n@@ -767,1 +773,1 @@\n-                            Reference.reachabilityFence(output);\n+                            NIO_ACCESS.releaseSession(output, outScope);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Deflater.java","additions":19,"deletions":13,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.ref.Reference;\n@@ -38,0 +37,2 @@\n+import static java.util.zip.ZipUtils.NIO_ACCESS;\n+\n@@ -262,1 +263,1 @@\n-                long address = ((DirectBuffer) dictionary).address();\n+                var scope = NIO_ACCESS.acquireSession(dictionary);\n@@ -264,0 +265,1 @@\n+                    long address = ((DirectBuffer) dictionary).address();\n@@ -266,1 +268,1 @@\n-                    Reference.reachabilityFence(dictionary);\n+                    NIO_ACCESS.releaseSession(dictionary, scope);\n@@ -386,0 +388,1 @@\n+                            var inScope = NIO_ACCESS.acquireSession(input);\n@@ -392,1 +395,1 @@\n-                                Reference.reachabilityFence(input);\n+                                NIO_ACCESS.releaseSession(input, inScope);\n@@ -520,1 +523,1 @@\n-                            long outputAddress = ((DirectBuffer) output).address();\n+                            var outScope = NIO_ACCESS.acquireSession(output);\n@@ -522,0 +525,1 @@\n+                                long outputAddress = ((DirectBuffer) output).address();\n@@ -526,1 +530,1 @@\n-                                Reference.reachabilityFence(output);\n+                                NIO_ACCESS.releaseSession(output, outScope);\n@@ -544,1 +548,1 @@\n-                            long inputAddress = ((DirectBuffer) input).address();\n+                            var inScope = NIO_ACCESS.acquireSession(input);\n@@ -546,0 +550,1 @@\n+                                long inputAddress = ((DirectBuffer) input).address();\n@@ -547,1 +552,1 @@\n-                                    long outputAddress = ((DirectBuffer) output).address();\n+                                    var outScope = NIO_ACCESS.acquireSession(output);\n@@ -549,0 +554,1 @@\n+                                        long outputAddress = ((DirectBuffer) output).address();\n@@ -553,1 +559,1 @@\n-                                        Reference.reachabilityFence(output);\n+                                        NIO_ACCESS.releaseSession(output, outScope);\n@@ -563,1 +569,1 @@\n-                                Reference.reachabilityFence(input);\n+                                NIO_ACCESS.releaseSession(input, inScope);\n@@ -569,1 +575,1 @@\n-                                long outputAddress = ((DirectBuffer) output).address();\n+                                var outScope = NIO_ACCESS.acquireSession(output);\n@@ -571,0 +577,1 @@\n+                                    long outputAddress = ((DirectBuffer) output).address();\n@@ -575,1 +582,1 @@\n-                                    Reference.reachabilityFence(output);\n+                                    NIO_ACCESS.releaseSession(output, outScope);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Inflater.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -43,0 +45,2 @@\n+    static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipUtils.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -89,4 +90,13 @@\n-     * Used by I\/O operations to make a buffer's session non-closeable\n-     * (for the duration of the I\/O operation) by acquiring the session.\n-     * Null is returned if the buffer has no scope, or acquiring is not\n-     * required to guarantee safety.\n+     * Used by operations to make a buffer's session non-closeable\n+     * (for the duration of the operation) by acquiring the session.\n+     * The buffers scope is returned if it has one, otherwise {@code null} is returned.\n+     * {@snippet lang = java:\n+     * var guard = acquireSession(buffer);\n+     * try {\n+     *     performOperation(buffer);\n+     * } finally {\n+     *     releaseSession(buffer, guard);\n+     * }\n+     *}\n+     *\n+     * @see #releaseSession(Buffer, MemorySessionImpl)\n@@ -94,1 +104,5 @@\n-    Runnable acquireSession(Buffer buffer, boolean async);\n+    MemorySessionImpl acquireSession(Buffer buffer);\n+\n+    void releaseSession(Buffer buffer, MemorySessionImpl scope);\n+\n+    boolean isThreadConfined(Buffer buffer);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioAccess.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -169,1 +169,3 @@\n-        jdk.net;\n+        jdk.net,\n+        jdk.sctp,\n+        jdk.crypto.cryptoki;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -90,0 +92,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -783,7 +787,12 @@\n-        int n = receive0(fd,\n-                         ((DirectBuffer)bb).address() + pos, rem,\n-                         sourceSockAddr.address(),\n-                         connected);\n-        if (n > 0)\n-            bb.position(pos + n);\n-        return n;\n+        var scope = NIO_ACCESS.acquireSession(bb);\n+        try {\n+            int n = receive0(fd,\n+                            ((DirectBuffer)bb).address() + pos, rem,\n+                            sourceSockAddr.address(),\n+                            connected);\n+            if (n > 0)\n+                bb.position(pos + n);\n+            return n;\n+        } finally {\n+            NIO_ACCESS.releaseSession(bb, scope);\n+        }\n@@ -933,0 +942,1 @@\n+        var scope = NIO_ACCESS.acquireSession(bb);\n@@ -941,0 +951,2 @@\n+        } finally {\n+            NIO_ACCESS.releaseSession(bb, scope);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -33,0 +33,7 @@\n+    \/\/ Use of the returned address must be guarded if this DirectBuffer\n+    \/\/ is backed by a memory session that is explicitly closeable.\n+    \/\/\n+    \/\/ Failure to do this means the outcome is undefined including\n+    \/\/ silent unrelated memory mutation and JVM crashes.\n+    \/\/\n+    \/\/ See JavaNioAccess for methods to safely acquire\/release resources.\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DirectBuffer.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -139,1 +140,1 @@\n-            releaseScope(handle);\n+            releaseScope(bb, handle);\n@@ -186,1 +187,1 @@\n-                    handleReleasers = LinkedRunnable.of(Releaser.of(h), handleReleasers);\n+                    handleReleasers = LinkedRunnable.of(Releaser.of(buf, h), handleReleasers);\n@@ -334,1 +335,1 @@\n-        var handle = acquireScope(bb, async);\n+        var scope = acquireScope(bb, async);\n@@ -342,1 +343,1 @@\n-            releaseScope(handle);\n+            releaseScope(bb, scope);\n@@ -398,1 +399,1 @@\n-                    handleReleasers = LinkedRunnable.of(Releaser.of(h), handleReleasers);\n+                    handleReleasers = LinkedRunnable.of(Releaser.of(buf, h), handleReleasers);\n@@ -477,2 +478,5 @@\n-    static Runnable acquireScope(ByteBuffer bb, boolean async) {\n-        return NIO_ACCESS.acquireSession(bb, async);\n+    static MemorySessionImpl acquireScope(ByteBuffer bb, boolean async) {\n+        if (async && NIO_ACCESS.isThreadConfined(bb)) {\n+            throw new IllegalStateException(\"Confined session not supported\");\n+        }\n+        return NIO_ACCESS.acquireSession(bb);\n@@ -481,3 +485,1 @@\n-    private static void releaseScope(Runnable handle) {\n-        if (handle == null)\n-            return;\n+    private static void releaseScope(ByteBuffer bb, MemorySessionImpl session) {\n@@ -485,1 +487,1 @@\n-            handle.run();\n+            NIO_ACCESS.releaseSession(bb, session);\n@@ -498,1 +500,1 @@\n-            return IOUtil.Releaser.ofNullable(IOUtil.acquireScope(buf, true));\n+            return IOUtil.Releaser.ofNullable(buf, IOUtil.acquireScope(buf, true));\n@@ -505,1 +507,1 @@\n-                    handleReleasers = IOUtil.LinkedRunnable.of(IOUtil.Releaser.of(h), handleReleasers);\n+                    handleReleasers = IOUtil.LinkedRunnable.of(IOUtil.Releaser.of(b, h), handleReleasers);\n@@ -517,3 +519,1 @@\n-    static record LinkedRunnable(Runnable node, Runnable next)\n-        implements Runnable\n-    {\n+    record LinkedRunnable(Runnable node, Runnable next) implements Runnable {\n@@ -523,0 +523,1 @@\n+\n@@ -532,0 +533,1 @@\n+\n@@ -537,8 +539,19 @@\n-    static record Releaser(Runnable handle) implements Runnable {\n-        Releaser { Objects.requireNonNull(handle) ; }\n-        @Override public void run() { releaseScope(handle); }\n-        static Runnable of(Runnable handle) { return new Releaser(handle); }\n-        static Runnable ofNullable(Runnable handle) {\n-            if (handle == null)\n-                return () -> { };\n-            return new Releaser(handle);\n+    record Releaser(ByteBuffer bb, MemorySessionImpl session) implements Runnable {\n+        Releaser {\n+            Objects.requireNonNull(bb);\n+            Objects.requireNonNull(session);\n+        }\n+\n+        @Override\n+        public void run() {\n+            releaseScope(bb, session);\n+        }\n+\n+        static Runnable of(ByteBuffer bb, MemorySessionImpl session) {\n+            return new Releaser(bb, session);\n+        }\n+\n+        static Runnable ofNullable(ByteBuffer bb, MemorySessionImpl session) {\n+            return session == null\n+                    ? () -> {}\n+                    : new Releaser(bb, session);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOUtil.java","additions":37,"deletions":24,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -137,0 +137,1 @@\n+    permission java.lang.RuntimePermission \"accessClassInPackage.jdk.internal.access\";\n","filename":"src\/java.base\/share\/lib\/security\/default.policy","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.ref.Reference;\n@@ -33,0 +32,3 @@\n+\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -46,0 +48,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -177,1 +181,2 @@\n-        if (dst instanceof sun.nio.ch.DirectBuffer buf) {\n+        if (dst instanceof sun.nio.ch.DirectBuffer ddst) {\n+            var scope = NIO_ACCESS.acquireSession(dst);\n@@ -179,1 +184,1 @@\n-                long address = buf.address() + pos;\n+                long address = ddst.address() + pos;\n@@ -184,1 +189,1 @@\n-                Reference.reachabilityFence(buf);\n+                NIO_ACCESS.releaseSession(dst, scope);\n@@ -240,0 +245,1 @@\n+            var scope = NIO_ACCESS.acquireSession(src);\n@@ -246,1 +252,1 @@\n-                Reference.reachabilityFence(buf);\n+                NIO_ACCESS.releaseSession(src, scope);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUserDefinedFileAttributeView.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -58,0 +60,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -737,0 +741,1 @@\n+        var inScope = NIO_ACCESS.acquireSession(inBuffer);\n@@ -738,22 +743,17 @@\n-            ensureInitialized();\n-\n-            long inAddr = 0;\n-            byte[] in = null;\n-            int inOfs = 0;\n-            if (dataBuffer.size() > 0) {\n-                if (inLen > 0) {\n-                    byte[] temp = new byte[inLen];\n-                    inBuffer.get(temp);\n-                    dataBuffer.write(temp, 0, temp.length);\n-                }\n-                in = dataBuffer.toByteArray();\n-                inOfs = 0;\n-                inLen = in.length;\n-            } else {\n-                if (inBuffer instanceof DirectBuffer) {\n-                    inAddr = ((DirectBuffer) inBuffer).address();\n-                    inOfs = inBuffer.position();\n-                } else {\n-                    if (inBuffer.hasArray()) {\n-                        in = inBuffer.array();\n-                        inOfs = inBuffer.position() + inBuffer.arrayOffset();\n+            var outScope = NIO_ACCESS.acquireSession(outBuffer);\n+            try {\n+                try {\n+                    ensureInitialized();\n+\n+                    long inAddr = 0;\n+                    byte[] in = null;\n+                    int inOfs = 0;\n+                    if (dataBuffer.size() > 0) {\n+                        if (inLen > 0) {\n+                            byte[] temp = new byte[inLen];\n+                            inBuffer.get(temp);\n+                            dataBuffer.write(temp, 0, temp.length);\n+                        }\n+                        in = dataBuffer.toByteArray();\n+                        inOfs = 0;\n+                        inLen = in.length;\n@@ -761,2 +761,26 @@\n-                        in = new byte[inLen];\n-                        inBuffer.get(in);\n+                        if (inBuffer instanceof DirectBuffer dInBuffer) {\n+                            inAddr = dInBuffer.address();\n+                            inOfs = inBuffer.position();\n+                        } else {\n+                            if (inBuffer.hasArray()) {\n+                                in = inBuffer.array();\n+                                inOfs = inBuffer.position() + inBuffer.arrayOffset();\n+                            } else {\n+                                in = new byte[inLen];\n+                                inBuffer.get(in);\n+                            }\n+                        }\n+                    }\n+                    long outAddr = 0;\n+                    byte[] outArray = null;\n+                    int outOfs = 0;\n+                    if (outBuffer instanceof DirectBuffer dOutBuffer) {\n+                        outAddr = dOutBuffer.address();\n+                        outOfs = outBuffer.position();\n+                    } else {\n+                        if (outBuffer.hasArray()) {\n+                            outArray = outBuffer.array();\n+                            outOfs = outBuffer.position() + outBuffer.arrayOffset();\n+                        } else {\n+                            outArray = new byte[outLen];\n+                        }\n@@ -764,16 +788,0 @@\n-                }\n-            }\n-            long outAddr = 0;\n-            byte[] outArray = null;\n-            int outOfs = 0;\n-            if (outBuffer instanceof DirectBuffer) {\n-                outAddr = ((DirectBuffer) outBuffer).address();\n-                outOfs = outBuffer.position();\n-            } else {\n-                if (outBuffer.hasArray()) {\n-                    outArray = outBuffer.array();\n-                    outOfs = outBuffer.position() + outBuffer.arrayOffset();\n-                } else {\n-                    outArray = new byte[outLen];\n-                }\n-            }\n@@ -781,9 +789,34 @@\n-            int k = 0;\n-            if (encrypt) {\n-                k = token.p11.C_Encrypt(session.id(), inAddr, in, inOfs, inLen,\n-                        outAddr, outArray, outOfs, outLen);\n-                doCancel = false;\n-            } else {\n-                \/\/ Special handling to match SunJCE provider behavior\n-                if (inLen == 0) {\n-                    return 0;\n+                    int k = 0;\n+                    if (encrypt) {\n+                        k = token.p11.C_Encrypt(session.id(), inAddr, in, inOfs, inLen,\n+                                outAddr, outArray, outOfs, outLen);\n+                        doCancel = false;\n+                    } else {\n+                        \/\/ Special handling to match SunJCE provider behavior\n+                        if (inLen == 0) {\n+                            return 0;\n+                        }\n+                        k = token.p11.C_Decrypt(session.id(), inAddr, in, inOfs, inLen,\n+                                outAddr, outArray, outOfs, outLen);\n+                        doCancel = false;\n+                    }\n+                    inBuffer.position(inBuffer.limit());\n+                    outBuffer.position(outBuffer.position() + k);\n+                    return k;\n+                } catch (PKCS11Exception e) {\n+                    \/\/ As per the PKCS#11 standard, C_Encrypt and C_Decrypt may only\n+                    \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n+                    \/\/ successful calls to determine the output length. However,\n+                    \/\/ these cases are not expected here because the output length\n+                    \/\/ is checked in the OpenJDK side before making the PKCS#11 call.\n+                    \/\/ Thus, doCancel can safely be 'false'.\n+                    doCancel = false;\n+                    handleException(e);\n+                    throw new ProviderException(\"doFinal() failed\", e);\n+                } finally {\n+                    if (encrypt) {\n+                        lastEncKey = this.p11Key;\n+                        lastEncIv = this.iv;\n+                        requireReinit = true;\n+                    }\n+                    reset(doCancel);\n@@ -791,3 +824,2 @@\n-                k = token.p11.C_Decrypt(session.id(), inAddr, in, inOfs, inLen,\n-                        outAddr, outArray, outOfs, outLen);\n-                doCancel = false;\n+            } finally {\n+                NIO_ACCESS.releaseSession(outBuffer, outScope);\n@@ -795,13 +827,0 @@\n-            inBuffer.position(inBuffer.limit());\n-            outBuffer.position(outBuffer.position() + k);\n-            return k;\n-        } catch (PKCS11Exception e) {\n-            \/\/ As per the PKCS#11 standard, C_Encrypt and C_Decrypt may only\n-            \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n-            \/\/ successful calls to determine the output length. However,\n-            \/\/ these cases are not expected here because the output length\n-            \/\/ is checked in the OpenJDK side before making the PKCS#11 call.\n-            \/\/ Thus, doCancel can safely be 'false'.\n-            doCancel = false;\n-            handleException(e);\n-            throw new ProviderException(\"doFinal() failed\", e);\n@@ -809,6 +828,1 @@\n-            if (encrypt) {\n-                lastEncKey = this.p11Key;\n-                lastEncIv = this.iv;\n-                requireReinit = true;\n-            }\n-            reset(doCancel);\n+            NIO_ACCESS.releaseSession(inBuffer, inScope);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":85,"deletions":71,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -59,0 +61,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -690,0 +694,1 @@\n+        var inScope = NIO_ACCESS.acquireSession(inBuffer);\n@@ -691,13 +696,15 @@\n-            ensureInitialized();\n-\n-            long inAddr = 0;\n-            int inOfs = 0;\n-            byte[] inArray = null;\n-\n-            if (inBuffer instanceof DirectBuffer) {\n-                inAddr = ((DirectBuffer) inBuffer).address();\n-                inOfs = origPos;\n-            } else if (inBuffer.hasArray()) {\n-                inArray = inBuffer.array();\n-                inOfs = (origPos + inBuffer.arrayOffset());\n-            }\n+            var outScope = NIO_ACCESS.acquireSession(outBuffer);\n+            try {\n+                ensureInitialized();\n+\n+                long inAddr = 0;\n+                int inOfs = 0;\n+                byte[] inArray = null;\n+\n+                if (inBuffer instanceof DirectBuffer dInBuffer) {\n+                    inAddr = dInBuffer.address();\n+                    inOfs = origPos;\n+                } else if (inBuffer.hasArray()) {\n+                    inArray = inBuffer.array();\n+                    inOfs = (origPos + inBuffer.arrayOffset());\n+                }\n@@ -705,10 +712,6 @@\n-            long outAddr = 0;\n-            int outOfs = 0;\n-            byte[] outArray = null;\n-            if (outBuffer instanceof DirectBuffer) {\n-                outAddr = ((DirectBuffer) outBuffer).address();\n-                outOfs = outBuffer.position();\n-            } else {\n-                if (outBuffer.hasArray()) {\n-                    outArray = outBuffer.array();\n-                    outOfs = (outBuffer.position() + outBuffer.arrayOffset());\n+                long outAddr = 0;\n+                int outOfs = 0;\n+                byte[] outArray = null;\n+                if (outBuffer instanceof DirectBuffer dOutBuffer) {\n+                    outAddr = dOutBuffer.address();\n+                    outOfs = outBuffer.position();\n@@ -716,1 +719,6 @@\n-                    outArray = new byte[outLen];\n+                    if (outBuffer.hasArray()) {\n+                        outArray = outBuffer.array();\n+                        outOfs = (outBuffer.position() + outBuffer.arrayOffset());\n+                    } else {\n+                        outArray = new byte[outLen];\n+                    }\n@@ -718,1 +726,0 @@\n-            }\n@@ -720,10 +727,19 @@\n-            int k = 0;\n-            int newPadBufferLen = 0;\n-            if (paddingObj != null  && (!encrypt || reqBlockUpdates)) {\n-                if (padBufferLen != 0) {\n-                    if (padBufferLen != padBuffer.length) {\n-                        int bufCapacity = padBuffer.length - padBufferLen;\n-                        if (inLen > bufCapacity) {\n-                            bufferInputBytes(inBuffer, bufCapacity);\n-                            inOfs += bufCapacity;\n-                            inLen -= bufCapacity;\n+                int k = 0;\n+                int newPadBufferLen = 0;\n+                if (paddingObj != null && (!encrypt || reqBlockUpdates)) {\n+                    if (padBufferLen != 0) {\n+                        if (padBufferLen != padBuffer.length) {\n+                            int bufCapacity = padBuffer.length - padBufferLen;\n+                            if (inLen > bufCapacity) {\n+                                bufferInputBytes(inBuffer, bufCapacity);\n+                                inOfs += bufCapacity;\n+                                inLen -= bufCapacity;\n+                            } else {\n+                                bufferInputBytes(inBuffer, inLen);\n+                                return 0;\n+                            }\n+                        }\n+                        if (encrypt) {\n+                            k = token.p11.C_EncryptUpdate(session.id(), 0,\n+                                    padBuffer, 0, padBufferLen, outAddr, outArray,\n+                                    outOfs, outLen);\n@@ -731,2 +747,3 @@\n-                            bufferInputBytes(inBuffer, inLen);\n-                            return 0;\n+                            k = token.p11.C_DecryptUpdate(session.id(), 0,\n+                                    padBuffer, 0, padBufferLen, outAddr, outArray,\n+                                    outOfs, outLen);\n@@ -734,0 +751,19 @@\n+                        padBufferLen = 0;\n+                    }\n+                    newPadBufferLen = inLen & (blockSize - 1);\n+                    if (!encrypt && newPadBufferLen == 0) {\n+                        \/\/ While decrypting with implUpdate, the last encrypted block\n+                        \/\/ is always held in a buffer. If it's the final one (unknown\n+                        \/\/ at this point), it may contain padding bytes and need further\n+                        \/\/ processing. In implDoFinal (where we know it's the final one)\n+                        \/\/ the buffer is decrypted, unpadded and returned.\n+                        newPadBufferLen = padBuffer.length;\n+                    }\n+                    inLen -= newPadBufferLen;\n+                }\n+                if (inLen > 0) {\n+                    if (inAddr == 0 && inArray == null) {\n+                        inArray = new byte[inLen];\n+                        inBuffer.get(inArray);\n+                    } else {\n+                        inBuffer.position(inBuffer.position() + inLen);\n@@ -736,3 +772,3 @@\n-                        k = token.p11.C_EncryptUpdate(session.id(), 0,\n-                                padBuffer, 0, padBufferLen, outAddr, outArray,\n-                                outOfs, outLen);\n+                        k += token.p11.C_EncryptUpdate(session.id(), inAddr,\n+                                inArray, inOfs, inLen, outAddr, outArray,\n+                                (outOfs + k), (outLen - k));\n@@ -740,3 +776,3 @@\n-                        k = token.p11.C_DecryptUpdate(session.id(), 0,\n-                                padBuffer, 0, padBufferLen, outAddr, outArray,\n-                                outOfs, outLen);\n+                        k += token.p11.C_DecryptUpdate(session.id(), inAddr,\n+                                inArray, inOfs, inLen, outAddr, outArray,\n+                                (outOfs + k), (outLen - k));\n@@ -744,1 +780,0 @@\n-                    padBufferLen = 0;\n@@ -746,8 +781,3 @@\n-                newPadBufferLen = inLen & (blockSize - 1);\n-                if (!encrypt && newPadBufferLen == 0) {\n-                    \/\/ While decrypting with implUpdate, the last encrypted block\n-                    \/\/ is always held in a buffer. If it's the final one (unknown\n-                    \/\/ at this point), it may contain padding bytes and need further\n-                    \/\/ processing. In implDoFinal (where we know it's the final one)\n-                    \/\/ the buffer is decrypted, unpadded and returned.\n-                    newPadBufferLen = padBuffer.length;\n+                \/\/ update 'padBuffer' if using our own padding impl.\n+                if (paddingObj != null && newPadBufferLen > 0) {\n+                    bufferInputBytes(inBuffer, newPadBufferLen);\n@@ -755,6 +785,4 @@\n-                inLen -= newPadBufferLen;\n-            }\n-            if (inLen > 0) {\n-                if (inAddr == 0 && inArray == null) {\n-                    inArray = new byte[inLen];\n-                    inBuffer.get(inArray);\n+                bytesBuffered += (inLen - k);\n+                if (!(outBuffer instanceof DirectBuffer) &&\n+                        !outBuffer.hasArray()) {\n+                    outBuffer.put(outArray, outOfs, k);\n@@ -762,1 +790,1 @@\n-                    inBuffer.position(inBuffer.position() + inLen);\n+                    outBuffer.position(outBuffer.position() + k);\n@@ -764,8 +792,7 @@\n-                if (encrypt) {\n-                    k += token.p11.C_EncryptUpdate(session.id(), inAddr,\n-                            inArray, inOfs, inLen, outAddr, outArray,\n-                            (outOfs + k), (outLen - k));\n-                } else {\n-                    k += token.p11.C_DecryptUpdate(session.id(), inAddr,\n-                            inArray, inOfs, inLen, outAddr, outArray,\n-                            (outOfs + k), (outLen - k));\n+                return k;\n+            } catch (PKCS11Exception e) {\n+                \/\/ Reset input buffer to its original position for\n+                inBuffer.position(origPos);\n+                if (e.match(CKR_BUFFER_TOO_SMALL)) {\n+                    throw (ShortBufferException)\n+                            (new ShortBufferException().initCause(e));\n@@ -773,0 +800,8 @@\n+                \/\/ Some implementations such as the NSS Software Token do not\n+                \/\/ cancel the operation upon a C_EncryptUpdate\/C_DecryptUpdate\n+                \/\/ failure (as required by the PKCS#11 standard). See JDK-8258833\n+                \/\/ for further information.\n+                reset(true);\n+                throw new ProviderException(\"update() failed\", e);\n+            } finally {\n+                NIO_ACCESS.releaseSession(outBuffer, outScope);\n@@ -774,25 +809,2 @@\n-            \/\/ update 'padBuffer' if using our own padding impl.\n-            if (paddingObj != null && newPadBufferLen > 0) {\n-                bufferInputBytes(inBuffer, newPadBufferLen);\n-            }\n-            bytesBuffered += (inLen - k);\n-            if (!(outBuffer instanceof DirectBuffer) &&\n-                    !outBuffer.hasArray()) {\n-                outBuffer.put(outArray, outOfs, k);\n-            } else {\n-                outBuffer.position(outBuffer.position() + k);\n-            }\n-            return k;\n-        } catch (PKCS11Exception e) {\n-            \/\/ Reset input buffer to its original position for\n-            inBuffer.position(origPos);\n-            if (e.match(CKR_BUFFER_TOO_SMALL)) {\n-                throw (ShortBufferException)\n-                        (new ShortBufferException().initCause(e));\n-            }\n-            \/\/ Some implementations such as the NSS Software Token do not\n-            \/\/ cancel the operation upon a C_EncryptUpdate\/C_DecryptUpdate\n-            \/\/ failure (as required by the PKCS#11 standard). See JDK-8258833\n-            \/\/ for further information.\n-            reset(true);\n-            throw new ProviderException(\"update() failed\", e);\n+        } finally {\n+            NIO_ACCESS.releaseSession(inBuffer, inScope);\n@@ -889,0 +901,1 @@\n+        var scope = NIO_ACCESS.acquireSession(outBuffer);\n@@ -890,12 +903,9 @@\n-            ensureInitialized();\n-\n-            long outAddr = 0;\n-            byte[] outArray = null;\n-            int outOfs = 0;\n-            if (outBuffer instanceof DirectBuffer) {\n-                outAddr = ((DirectBuffer) outBuffer).address();\n-                outOfs = outBuffer.position();\n-            } else {\n-                if (outBuffer.hasArray()) {\n-                    outArray = outBuffer.array();\n-                    outOfs = outBuffer.position() + outBuffer.arrayOffset();\n+            try {\n+                ensureInitialized();\n+\n+                long outAddr = 0;\n+                byte[] outArray = null;\n+                int outOfs = 0;\n+                if (outBuffer instanceof DirectBuffer dOutBuffer) {\n+                    outAddr = dOutBuffer.address();\n+                    outOfs = outBuffer.position();\n@@ -903,1 +913,6 @@\n-                    outArray = new byte[outLen];\n+                    if (outBuffer.hasArray()) {\n+                        outArray = outBuffer.array();\n+                        outOfs = outBuffer.position() + outBuffer.arrayOffset();\n+                    } else {\n+                        outArray = new byte[outLen];\n+                    }\n@@ -905,1 +920,0 @@\n-            }\n@@ -907,1 +921,1 @@\n-            int k = 0;\n+                int k = 0;\n@@ -909,12 +923,13 @@\n-            if (encrypt) {\n-                if (paddingObj != null) {\n-                    int startOff = 0;\n-                    if (reqBlockUpdates) {\n-                        \/\/ call C_EncryptUpdate first if the padBuffer is full\n-                        \/\/ to make room for padding bytes\n-                        if (padBufferLen == padBuffer.length) {\n-                            k = token.p11.C_EncryptUpdate(session.id(),\n-                                0, padBuffer, 0, padBufferLen,\n-                                outAddr, outArray, outOfs, outLen);\n-                        } else {\n-                            startOff = padBufferLen;\n+                if (encrypt) {\n+                    if (paddingObj != null) {\n+                        int startOff = 0;\n+                        if (reqBlockUpdates) {\n+                            \/\/ call C_EncryptUpdate first if the padBuffer is full\n+                            \/\/ to make room for padding bytes\n+                            if (padBufferLen == padBuffer.length) {\n+                                k = token.p11.C_EncryptUpdate(session.id(),\n+                                        0, padBuffer, 0, padBufferLen,\n+                                        outAddr, outArray, outOfs, outLen);\n+                            } else {\n+                                startOff = padBufferLen;\n+                            }\n@@ -922,27 +937,5 @@\n-                    }\n-                    int actualPadLen = paddingObj.setPaddingBytes(padBuffer,\n-                            startOff, requiredOutLen - bytesBuffered);\n-                    k += token.p11.C_EncryptUpdate(session.id(),\n-                            0, padBuffer, 0, startOff + actualPadLen,\n-                            outAddr, outArray, outOfs + k, outLen - k);\n-                }\n-                \/\/ Some implementations such as the NSS Software Token do not\n-                \/\/ cancel the operation upon a C_EncryptUpdate failure (as\n-                \/\/ required by the PKCS#11 standard). Cancel is not needed\n-                \/\/ only after this point. See JDK-8258833 for further\n-                \/\/ information.\n-                doCancel = false;\n-                k += token.p11.C_EncryptFinal(session.id(),\n-                        outAddr, outArray, (outOfs + k), (outLen - k));\n-            } else {\n-                \/\/ Special handling to match SunJCE provider behavior\n-                if (bytesBuffered == 0 && padBufferLen == 0) {\n-                    return 0;\n-                }\n-\n-                if (paddingObj != null) {\n-                    if (padBufferLen != 0) {\n-                        k = token.p11.C_DecryptUpdate(session.id(),\n-                                0, padBuffer, 0, padBufferLen,\n-                                0, padBuffer, 0, padBuffer.length);\n-                        padBufferLen = 0;\n+                        int actualPadLen = paddingObj.setPaddingBytes(padBuffer,\n+                                startOff, requiredOutLen - bytesBuffered);\n+                        k += token.p11.C_EncryptUpdate(session.id(),\n+                                0, padBuffer, 0, startOff + actualPadLen,\n+                                outAddr, outArray, outOfs + k, outLen - k);\n@@ -951,1 +944,1 @@\n-                    \/\/ cancel the operation upon a C_DecryptUpdate failure (as\n+                    \/\/ cancel the operation upon a C_EncryptUpdate failure (as\n@@ -956,2 +949,7 @@\n-                    k += token.p11.C_DecryptFinal(session.id(),\n-                            0, padBuffer, k, padBuffer.length - k);\n+                    k += token.p11.C_EncryptFinal(session.id(),\n+                            outAddr, outArray, (outOfs + k), (outLen - k));\n+                } else {\n+                    \/\/ Special handling to match SunJCE provider behavior\n+                    if (bytesBuffered == 0 && padBufferLen == 0) {\n+                        return 0;\n+                    }\n@@ -959,4 +957,30 @@\n-                    int actualPadLen = paddingObj.unpad(padBuffer, k);\n-                    k -= actualPadLen;\n-                    outArray = padBuffer;\n-                    outOfs = 0;\n+                    if (paddingObj != null) {\n+                        if (padBufferLen != 0) {\n+                            k = token.p11.C_DecryptUpdate(session.id(),\n+                                    0, padBuffer, 0, padBufferLen,\n+                                    0, padBuffer, 0, padBuffer.length);\n+                            padBufferLen = 0;\n+                        }\n+                        \/\/ Some implementations such as the NSS Software Token do not\n+                        \/\/ cancel the operation upon a C_DecryptUpdate failure (as\n+                        \/\/ required by the PKCS#11 standard). Cancel is not needed\n+                        \/\/ only after this point. See JDK-8258833 for further\n+                        \/\/ information.\n+                        doCancel = false;\n+                        k += token.p11.C_DecryptFinal(session.id(),\n+                                0, padBuffer, k, padBuffer.length - k);\n+\n+                        int actualPadLen = paddingObj.unpad(padBuffer, k);\n+                        k -= actualPadLen;\n+                        outArray = padBuffer;\n+                        outOfs = 0;\n+                    } else {\n+                        doCancel = false;\n+                        k = token.p11.C_DecryptFinal(session.id(),\n+                                outAddr, outArray, outOfs, outLen);\n+                    }\n+                }\n+                if ((!encrypt && paddingObj != null) ||\n+                        (!(outBuffer instanceof DirectBuffer) &&\n+                                !outBuffer.hasArray())) {\n+                    outBuffer.put(outArray, outOfs, k);\n@@ -964,3 +988,1 @@\n-                    doCancel = false;\n-                    k = token.p11.C_DecryptFinal(session.id(),\n-                            outAddr, outArray, outOfs, outLen);\n+                    outBuffer.position(outBuffer.position() + k);\n@@ -968,0 +990,6 @@\n+                return k;\n+            } catch (PKCS11Exception e) {\n+                handleException(e);\n+                throw new ProviderException(\"doFinal() failed\", e);\n+            } finally {\n+                reset(doCancel);\n@@ -969,11 +997,0 @@\n-            if ((!encrypt && paddingObj != null) ||\n-                    (!(outBuffer instanceof DirectBuffer) &&\n-                    !outBuffer.hasArray())) {\n-                outBuffer.put(outArray, outOfs, k);\n-            } else {\n-                outBuffer.position(outBuffer.position() + k);\n-            }\n-            return k;\n-        } catch (PKCS11Exception e) {\n-            handleException(e);\n-            throw new ProviderException(\"doFinal() failed\", e);\n@@ -981,1 +998,1 @@\n-            reset(doCancel);\n+            NIO_ACCESS.releaseSession(outBuffer, scope);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":185,"deletions":168,"binary":false,"changes":353,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.*;\n@@ -35,0 +34,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -58,0 +59,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -292,1 +295,1 @@\n-        if (byteBuffer instanceof DirectBuffer == false) {\n+        if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n@@ -298,1 +301,0 @@\n-        long addr = ((DirectBuffer)byteBuffer).address();\n@@ -309,1 +311,6 @@\n-            token.p11.C_DigestUpdate(session.id(), addr + ofs, null, 0, len);\n+            var scope = NIO_ACCESS.acquireSession(byteBuffer);\n+            try {\n+                token.p11.C_DigestUpdate(session.id(), dByteBuffer.address() + ofs, null, 0, len);\n+            } finally {\n+                NIO_ACCESS.releaseSession(byteBuffer, scope);\n+            }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Digest.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -46,1 +48,0 @@\n-import static sun.security.pkcs11.P11Cipher.*;\n@@ -61,0 +62,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -559,0 +562,1 @@\n+        var inScope = NIO_ACCESS.acquireSession(inBuffer);\n@@ -560,24 +564,19 @@\n-            ensureInitialized();\n-\n-            long inAddr = 0;\n-            byte[] in = null;\n-            int inOfs = 0;\n-\n-            if (dataBuffer.size() > 0) {\n-                if (inBuffer != null && inLen > 0) {\n-                    byte[] temp = new byte[inLen];\n-                    inBuffer.get(temp);\n-                    dataBuffer.write(temp, 0, temp.length);\n-                }\n-\n-                in = dataBuffer.toByteArray();\n-                inOfs = 0;\n-                inLen = in.length;\n-            } else {\n-                if (inBuffer instanceof DirectBuffer) {\n-                    inAddr = ((DirectBuffer) inBuffer).address();\n-                    inOfs = inBuffer.position();\n-                } else {\n-                    if (inBuffer.hasArray()) {\n-                        in = inBuffer.array();\n-                        inOfs = inBuffer.position() + inBuffer.arrayOffset();\n+            var outScope = NIO_ACCESS.acquireSession(outBuffer);\n+            try {\n+                try {\n+                    ensureInitialized();\n+\n+                    long inAddr = 0;\n+                    byte[] in = null;\n+                    int inOfs = 0;\n+\n+                    if (dataBuffer.size() > 0) {\n+                        if (inBuffer != null && inLen > 0) {\n+                            byte[] temp = new byte[inLen];\n+                            inBuffer.get(temp);\n+                            dataBuffer.write(temp, 0, temp.length);\n+                        }\n+\n+                        in = dataBuffer.toByteArray();\n+                        inOfs = 0;\n+                        inLen = in.length;\n@@ -585,2 +584,26 @@\n-                        in = new byte[inLen];\n-                        inBuffer.get(in);\n+                        if (inBuffer instanceof DirectBuffer dInBuffer) {\n+                            inAddr = dInBuffer.address();\n+                            inOfs = inBuffer.position();\n+                        } else {\n+                            if (inBuffer.hasArray()) {\n+                                in = inBuffer.array();\n+                                inOfs = inBuffer.position() + inBuffer.arrayOffset();\n+                            } else {\n+                                in = new byte[inLen];\n+                                inBuffer.get(in);\n+                            }\n+                        }\n+                    }\n+                    long outAddr = 0;\n+                    byte[] outArray = null;\n+                    int outOfs = 0;\n+                    if (outBuffer instanceof DirectBuffer dOutBuffer) {\n+                        outAddr = dOutBuffer.address();\n+                        outOfs = outBuffer.position();\n+                    } else {\n+                        if (outBuffer.hasArray()) {\n+                            outArray = outBuffer.array();\n+                            outOfs = outBuffer.position() + outBuffer.arrayOffset();\n+                        } else {\n+                            outArray = new byte[outLen];\n+                        }\n@@ -588,16 +611,0 @@\n-                }\n-            }\n-            long outAddr = 0;\n-            byte[] outArray = null;\n-            int outOfs = 0;\n-            if (outBuffer instanceof DirectBuffer) {\n-                outAddr = ((DirectBuffer) outBuffer).address();\n-                outOfs = outBuffer.position();\n-            } else {\n-                if (outBuffer.hasArray()) {\n-                    outArray = outBuffer.array();\n-                    outOfs = outBuffer.position() + outBuffer.arrayOffset();\n-                } else {\n-                    outArray = new byte[outLen];\n-                }\n-            }\n@@ -605,8 +612,26 @@\n-            if (opmode == Cipher.ENCRYPT_MODE) {\n-                k = token.p11.C_Encrypt(session.id(), inAddr, in, inOfs, inLen,\n-                        outAddr, outArray, outOfs, outLen);\n-                doCancel = false;\n-            } else {\n-                \/\/ Special handling to match SunJCE provider behavior\n-                if (inLen == 0) {\n-                    return 0;\n+                    if (opmode == Cipher.ENCRYPT_MODE) {\n+                        k = token.p11.C_Encrypt(session.id(), inAddr, in, inOfs, inLen,\n+                                outAddr, outArray, outOfs, outLen);\n+                        doCancel = false;\n+                    } else {\n+                        \/\/ Special handling to match SunJCE provider behavior\n+                        if (inLen == 0) {\n+                            return 0;\n+                        }\n+                        k = token.p11.C_Decrypt(session.id(), inAddr, in, inOfs, inLen,\n+                                outAddr, outArray, outOfs, outLen);\n+                        doCancel = false;\n+                    }\n+                    inBuffer.position(inBuffer.limit());\n+                    outBuffer.position(outBuffer.position() + k);\n+                } catch (PKCS11Exception e) {\n+                    \/\/ As per the PKCS#11 standard, C_Encrypt and C_Decrypt may only\n+                    \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n+                    \/\/ successful calls to determine the output length. However,\n+                    \/\/ these cases are not expected here because the output length\n+                    \/\/ is checked in the OpenJDK side before making the PKCS#11 call.\n+                    \/\/ Thus, doCancel can safely be 'false'.\n+                    doCancel = false;\n+                    handleEncException(\"doFinal() failed\", e);\n+                } finally {\n+                    reset(doCancel);\n@@ -614,3 +639,2 @@\n-                k = token.p11.C_Decrypt(session.id(), inAddr, in, inOfs, inLen,\n-                        outAddr, outArray, outOfs, outLen);\n-                doCancel = false;\n+            } finally {\n+                NIO_ACCESS.releaseSession(outBuffer, outScope);\n@@ -618,11 +642,0 @@\n-            inBuffer.position(inBuffer.limit());\n-            outBuffer.position(outBuffer.position() + k);\n-        } catch (PKCS11Exception e) {\n-            \/\/ As per the PKCS#11 standard, C_Encrypt and C_Decrypt may only\n-            \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n-            \/\/ successful calls to determine the output length. However,\n-            \/\/ these cases are not expected here because the output length\n-            \/\/ is checked in the OpenJDK side before making the PKCS#11 call.\n-            \/\/ Thus, doCancel can safely be 'false'.\n-            doCancel = false;\n-            handleEncException(\"doFinal() failed\", e);\n@@ -630,1 +643,1 @@\n-            reset(doCancel);\n+            NIO_ACCESS.releaseSession(inBuffer, inScope);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyWrapCipher.java","additions":79,"deletions":66,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -58,0 +60,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -268,1 +272,1 @@\n-            if (byteBuffer instanceof DirectBuffer == false) {\n+            if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n@@ -272,1 +276,0 @@\n-            long addr = ((DirectBuffer)byteBuffer).address();\n@@ -274,1 +277,6 @@\n-            token.p11.C_SignUpdate(session.id(), addr + ofs, null, 0, len);\n+            var scope = NIO_ACCESS.acquireSession(byteBuffer);\n+            try  {\n+                token.p11.C_SignUpdate(session.id(), dByteBuffer.address() + ofs, null, 0, len);\n+            } finally {\n+                NIO_ACCESS.releaseSession(byteBuffer, scope);\n+            }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Mac.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n@@ -31,0 +29,3 @@\n+\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -34,1 +35,0 @@\n-import java.util.Arrays;\n@@ -71,0 +71,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -619,1 +621,1 @@\n-            if (byteBuffer instanceof DirectBuffer == false) {\n+            if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n@@ -624,1 +626,0 @@\n-            long addr = ((DirectBuffer)byteBuffer).address();\n@@ -626,0 +627,1 @@\n+            var scope = NIO_ACCESS.acquireSession(byteBuffer);\n@@ -630,1 +632,1 @@\n-                        (session.id(), addr + ofs, null, 0, len);\n+                        (session.id(), dByteBuffer.address() + ofs, null, 0, len);\n@@ -634,1 +636,1 @@\n-                        (session.id(), addr + ofs, null, 0, len);\n+                        (session.id(), dByteBuffer.address() + ofs, null, 0, len);\n@@ -641,0 +643,2 @@\n+            } finally {\n+                NIO_ACCESS.releaseSession(byteBuffer, scope);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11PSSSignature.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -38,1 +41,0 @@\n-import sun.security.x509.AlgorithmId;\n@@ -101,0 +103,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -584,1 +588,1 @@\n-            if (byteBuffer instanceof DirectBuffer == false) {\n+            if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n@@ -589,1 +593,0 @@\n-            long addr = ((DirectBuffer)byteBuffer).address();\n@@ -591,0 +594,1 @@\n+            var scope = NIO_ACCESS.acquireSession(byteBuffer);\n@@ -594,1 +598,1 @@\n-                        (session.id(), addr + ofs, null, 0, len);\n+                        (session.id(), dByteBuffer.address() + ofs, null, 0, len);\n@@ -597,1 +601,1 @@\n-                        (session.id(), addr + ofs, null, 0, len);\n+                        (session.id(), dByteBuffer.address() + ofs, null, 0, len);\n@@ -604,0 +608,2 @@\n+            } finally {\n+                NIO_ACCESS.releaseSession(byteBuffer, scope);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Signature.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -77,0 +79,3 @@\n+\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -842,1 +847,3 @@\n-        int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem, peek);\n+        var scope = NIO_ACCESS.acquireSession(bb);\n+        try {\n+            int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem, peek);\n@@ -844,3 +851,6 @@\n-        if (n > 0)\n-            bb.position(pos + n);\n-        return n;\n+            if (n > 0)\n+                bb.position(pos + n);\n+            return n;\n+        } finally {\n+            NIO_ACCESS.releaseSession(bb, scope);\n+        }\n@@ -1031,5 +1041,10 @@\n-        int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,\n-                            port, -1 \/*121*\/, streamNumber, unordered, ppid);\n-        if (written > 0)\n-            bb.position(pos + written);\n-        return written;\n+        var scope = NIO_ACCESS.acquireSession(bb);\n+        try {\n+            int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,\n+                    port, -1 \/*121*\/, streamNumber, unordered, ppid);\n+            if (written > 0)\n+                bb.position(pos + written);\n+            return written;\n+        } finally {\n+            NIO_ACCESS.releaseSession(bb, scope);\n+        }\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":24,"deletions":9,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -74,0 +76,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -586,4 +590,9 @@\n-        int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem);\n-        if (n > 0)\n-            bb.position(pos + n);\n-        return n;\n+        var scope = NIO_ACCESS.acquireSession(bb);\n+        try {\n+            int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem);\n+            if (n > 0)\n+                bb.position(pos + n);\n+            return n;\n+        } finally {\n+            NIO_ACCESS.releaseSession(bb, scope);\n+        }\n@@ -911,5 +920,10 @@\n-        int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,\n-                            port, assocId, streamNumber, unordered, ppid);\n-        if (written > 0)\n-            bb.position(pos + written);\n-        return written;\n+        var scope = NIO_ACCESS.acquireSession(bb);\n+        try {\n+            int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,\n+                    port, assocId, streamNumber, unordered, ppid);\n+            if (written > 0)\n+                bb.position(pos + written);\n+            return written;\n+        } finally {\n+            NIO_ACCESS.releaseSession(bb, scope);\n+        }\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpMultiChannelImpl.java","additions":23,"deletions":9,"binary":false,"changes":32,"status":"modified"}]}