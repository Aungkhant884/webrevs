{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -95,0 +97,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -912,0 +916,2 @@\n+                \/\/ The use of DirectBuffer::address below need not be guarded as\n+                \/\/ no access is made to actual memory.\n@@ -949,1 +955,0 @@\n-\n@@ -1588,2 +1593,7 @@\n-                    Unsafe.getUnsafe().setMemory(((DirectBuffer)dst).address(),\n-                        len + dst.position(), (byte)0);\n+                    NIO_ACCESS.acquireSession(dst);\n+                    try {\n+                        Unsafe.getUnsafe().setMemory(((DirectBuffer)dst).address(),\n+                                len + dst.position(), (byte) 0);\n+                    } finally {\n+                        NIO_ACCESS.releaseSession(dst);\n+                    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.lang.ref.Reference;\n@@ -782,0 +783,1 @@\n+\n@@ -827,4 +829,4 @@\n-                public Runnable acquireSession(Buffer buffer, boolean async) {\n-                    var session = buffer.session();\n-                    if (session == null) {\n-                        return null;\n+                public void acquireSession(Buffer buffer) {\n+                    var scope = buffer.session();\n+                    if (scope != null) {\n+                        scope.acquire0();\n@@ -832,2 +834,11 @@\n-                    if (async && session.ownerThread() != null) {\n-                        throw new IllegalStateException(\"Confined session not supported\");\n+                }\n+\n+                @Override\n+                public void releaseSession(Buffer buffer) {\n+                    try {\n+                        var scope = buffer.session();\n+                        if (scope != null) {\n+                            scope.release0();\n+                        }\n+                    } finally {\n+                        Reference.reachabilityFence(buffer);\n@@ -835,2 +846,11 @@\n-                    session.acquire0();\n-                    return session::release0;\n+                }\n+\n+                @Override\n+                public boolean isThreadConfined(Buffer buffer) {\n+                    var scope = buffer.session();\n+                    return scope != null && scope.ownerThread() != null;\n+                }\n+\n+                @Override\n+                public boolean hasSession(Buffer buffer) {\n+                    return buffer.session() != null;\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.ref.Reference;\n@@ -30,1 +29,1 @@\n-import sun.nio.ch.DirectBuffer;\n+\n@@ -33,0 +32,3 @@\n+import sun.nio.ch.DirectBuffer;\n+\n+import static java.util.zip.ZipUtils.NIO_ACCESS;\n@@ -99,0 +101,1 @@\n+            NIO_ACCESS.acquireSession(buffer);\n@@ -102,1 +105,1 @@\n-                Reference.reachabilityFence(buffer);\n+                NIO_ACCESS.releaseSession(buffer);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Adler32.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.ref.Reference;\n@@ -36,0 +35,2 @@\n+import static java.util.zip.ZipUtils.NIO_ACCESS;\n+\n@@ -99,0 +100,1 @@\n+            NIO_ACCESS.acquireSession(buffer);\n@@ -102,1 +104,1 @@\n-                Reference.reachabilityFence(buffer);\n+                NIO_ACCESS.releaseSession(buffer);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/CRC32.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.ref.Reference;\n@@ -36,0 +35,2 @@\n+import static java.util.zip.ZipUtils.NIO_ACCESS;\n+\n@@ -174,0 +175,1 @@\n+            NIO_ACCESS.acquireSession(buffer);\n@@ -175,1 +177,1 @@\n-                crc = updateDirectByteBuffer(crc, ((DirectBuffer) buffer).address(),\n+                crc = updateDirectByteBuffer(crc, ((DirectBuffer)buffer).address(),\n@@ -178,1 +180,1 @@\n-                Reference.reachabilityFence(buffer);\n+                NIO_ACCESS.releaseSession(buffer);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/CRC32C.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.ref.Reference;\n@@ -38,0 +37,2 @@\n+import static java.util.zip.ZipUtils.NIO_ACCESS;\n+\n@@ -340,1 +341,1 @@\n-                long address = ((DirectBuffer) dictionary).address();\n+                NIO_ACCESS.acquireSession(dictionary);\n@@ -342,0 +343,1 @@\n+                    long address = ((DirectBuffer) dictionary).address();\n@@ -344,1 +346,1 @@\n-                    Reference.reachabilityFence(dictionary);\n+                    NIO_ACCESS.releaseSession(dictionary);\n@@ -590,0 +592,1 @@\n+                    NIO_ACCESS.acquireSession(input);\n@@ -597,1 +600,1 @@\n-                        Reference.reachabilityFence(input);\n+                        NIO_ACCESS.releaseSession(input);\n@@ -712,1 +715,1 @@\n-                    long outputAddress = ((DirectBuffer) output).address();\n+                    NIO_ACCESS.acquireSession(output);\n@@ -714,0 +717,1 @@\n+                        long outputAddress = ((DirectBuffer) output).address();\n@@ -719,1 +723,1 @@\n-                        Reference.reachabilityFence(output);\n+                        NIO_ACCESS.releaseSession(output);\n@@ -733,1 +737,1 @@\n-                    long inputAddress = ((DirectBuffer) input).address();\n+                    NIO_ACCESS.acquireSession(input);\n@@ -735,0 +739,1 @@\n+                        long inputAddress = ((DirectBuffer) input).address();\n@@ -736,1 +741,1 @@\n-                            long outputAddress = outputPos + ((DirectBuffer) output).address();\n+                            NIO_ACCESS.acquireSession(output);\n@@ -738,0 +743,1 @@\n+                                long outputAddress = outputPos + ((DirectBuffer) output).address();\n@@ -743,1 +749,1 @@\n-                                Reference.reachabilityFence(output);\n+                                NIO_ACCESS.releaseSession(output);\n@@ -754,1 +760,1 @@\n-                        Reference.reachabilityFence(input);\n+                        NIO_ACCESS.releaseSession(input);\n@@ -760,1 +766,1 @@\n-                        long outputAddress = ((DirectBuffer) output).address();\n+                        NIO_ACCESS.acquireSession(output);\n@@ -762,0 +768,1 @@\n+                            long outputAddress = ((DirectBuffer) output).address();\n@@ -767,1 +774,1 @@\n-                            Reference.reachabilityFence(output);\n+                            NIO_ACCESS.releaseSession(output);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Deflater.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.ref.Reference;\n@@ -38,0 +37,2 @@\n+import static java.util.zip.ZipUtils.NIO_ACCESS;\n+\n@@ -262,1 +263,1 @@\n-                long address = ((DirectBuffer) dictionary).address();\n+                NIO_ACCESS.acquireSession(dictionary);\n@@ -264,0 +265,1 @@\n+                    long address = ((DirectBuffer) dictionary).address();\n@@ -266,1 +268,1 @@\n-                    Reference.reachabilityFence(dictionary);\n+                    NIO_ACCESS.releaseSession(dictionary);\n@@ -386,0 +388,1 @@\n+                            NIO_ACCESS.acquireSession(input);\n@@ -392,1 +395,1 @@\n-                                Reference.reachabilityFence(input);\n+                                NIO_ACCESS.releaseSession(input);\n@@ -520,1 +523,1 @@\n-                            long outputAddress = ((DirectBuffer) output).address();\n+                            NIO_ACCESS.acquireSession(output);\n@@ -522,0 +525,1 @@\n+                                long outputAddress = ((DirectBuffer) output).address();\n@@ -526,1 +530,1 @@\n-                                Reference.reachabilityFence(output);\n+                                NIO_ACCESS.releaseSession(output);\n@@ -544,1 +548,1 @@\n-                            long inputAddress = ((DirectBuffer) input).address();\n+                            NIO_ACCESS.acquireSession(input);\n@@ -546,0 +550,1 @@\n+                                long inputAddress = ((DirectBuffer) input).address();\n@@ -547,1 +552,1 @@\n-                                    long outputAddress = ((DirectBuffer) output).address();\n+                                    NIO_ACCESS.acquireSession(output);\n@@ -549,0 +554,1 @@\n+                                        long outputAddress = ((DirectBuffer) output).address();\n@@ -553,1 +559,1 @@\n-                                        Reference.reachabilityFence(output);\n+                                        NIO_ACCESS.releaseSession(output);\n@@ -563,1 +569,1 @@\n-                                Reference.reachabilityFence(input);\n+                                NIO_ACCESS.releaseSession(input);\n@@ -569,1 +575,1 @@\n-                                long outputAddress = ((DirectBuffer) output).address();\n+                                NIO_ACCESS.acquireSession(output);\n@@ -571,0 +577,1 @@\n+                                    long outputAddress = ((DirectBuffer) output).address();\n@@ -575,1 +582,1 @@\n-                                    Reference.reachabilityFence(output);\n+                                    NIO_ACCESS.releaseSession(output);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Inflater.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -43,0 +45,2 @@\n+    static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipUtils.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -89,4 +89,12 @@\n-     * Used by I\/O operations to make a buffer's session non-closeable\n-     * (for the duration of the I\/O operation) by acquiring the session.\n-     * Null is returned if the buffer has no scope, or acquiring is not\n-     * required to guarantee safety.\n+     * Used by operations to make a buffer's session non-closeable\n+     * (for the duration of the operation) by acquiring the session.\n+     * {@snippet lang = java:\n+     * acquireSession(buffer);\n+     * try {\n+     *     performOperation(buffer);\n+     * } finally {\n+     *     releaseSession(buffer);\n+     * }\n+     *}\n+     *\n+     * @see #releaseSession(Buffer)\n@@ -94,1 +102,7 @@\n-    Runnable acquireSession(Buffer buffer, boolean async);\n+    void acquireSession(Buffer buffer);\n+\n+    void releaseSession(Buffer buffer);\n+\n+    boolean isThreadConfined(Buffer buffer);\n+\n+    boolean hasSession(Buffer buffer);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioAccess.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -169,1 +169,3 @@\n-        jdk.net;\n+        jdk.net,\n+        jdk.sctp,\n+        jdk.crypto.cryptoki;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -90,0 +92,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -783,7 +787,12 @@\n-        int n = receive0(fd,\n-                         ((DirectBuffer)bb).address() + pos, rem,\n-                         sourceSockAddr.address(),\n-                         connected);\n-        if (n > 0)\n-            bb.position(pos + n);\n-        return n;\n+        NIO_ACCESS.acquireSession(bb);\n+        try {\n+            int n = receive0(fd,\n+                            ((DirectBuffer)bb).address() + pos, rem,\n+                            sourceSockAddr.address(),\n+                            connected);\n+            if (n > 0)\n+                bb.position(pos + n);\n+            return n;\n+        } finally {\n+            NIO_ACCESS.releaseSession(bb);\n+        }\n@@ -933,0 +942,1 @@\n+        NIO_ACCESS.acquireSession(bb);\n@@ -941,0 +951,2 @@\n+        } finally {\n+            NIO_ACCESS.releaseSession(bb);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -33,0 +33,7 @@\n+    \/\/ Use of the returned address must be guarded if this DirectBuffer\n+    \/\/ is backed by a memory session that is explicitly closeable.\n+    \/\/\n+    \/\/ Failure to do this means the outcome is undefined including\n+    \/\/ silent unrelated memory mutation and JVM crashes.\n+    \/\/\n+    \/\/ See JavaNioAccess for methods to safely acquire\/release resources.\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DirectBuffer.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -39,1 +40,1 @@\n-public class IOUtil {\n+public final class IOUtil {\n@@ -131,1 +132,1 @@\n-        var handle = acquireScope(bb, async);\n+        acquireScope(bb, async);\n@@ -139,1 +140,1 @@\n-            releaseScope(handle);\n+            releaseScope(bb);\n@@ -184,3 +185,3 @@\n-                var h = acquireScope(buf, async);\n-                if (h != null) {\n-                    handleReleasers = LinkedRunnable.of(Releaser.of(h), handleReleasers);\n+                acquireScope(buf, async);\n+                if (NIO_ACCESS.hasSession(buf)) {\n+                    handleReleasers = LinkedRunnable.of(Releaser.of(buf), handleReleasers);\n@@ -334,1 +335,1 @@\n-        var handle = acquireScope(bb, async);\n+        acquireScope(bb, async);\n@@ -342,1 +343,1 @@\n-            releaseScope(handle);\n+            releaseScope(bb);\n@@ -396,3 +397,3 @@\n-                var h = acquireScope(buf, async);\n-                if (h != null) {\n-                    handleReleasers = LinkedRunnable.of(Releaser.of(h), handleReleasers);\n+                acquireScope(buf, async);\n+                if (NIO_ACCESS.hasSession(buf)) {\n+                    handleReleasers = LinkedRunnable.of(Releaser.of(buf), handleReleasers);\n@@ -477,2 +478,5 @@\n-    static Runnable acquireScope(ByteBuffer bb, boolean async) {\n-        return NIO_ACCESS.acquireSession(bb, async);\n+    static void acquireScope(ByteBuffer bb, boolean async) {\n+        if (async && NIO_ACCESS.isThreadConfined(bb)) {\n+            throw new IllegalStateException(\"Confined session not supported\");\n+        }\n+        NIO_ACCESS.acquireSession(bb);\n@@ -481,3 +485,1 @@\n-    private static void releaseScope(Runnable handle) {\n-        if (handle == null)\n-            return;\n+    private static void releaseScope(ByteBuffer bb) {\n@@ -485,1 +487,1 @@\n-            handle.run();\n+            NIO_ACCESS.releaseSession(bb);\n@@ -498,1 +500,2 @@\n-            return IOUtil.Releaser.ofNullable(IOUtil.acquireScope(buf, true));\n+            IOUtil.acquireScope(buf, true);\n+            return IOUtil.Releaser.of(buf);\n@@ -503,4 +506,2 @@\n-                var h = IOUtil.acquireScope(b, true);\n-                if (h != null) {\n-                    handleReleasers = IOUtil.LinkedRunnable.of(IOUtil.Releaser.of(h), handleReleasers);\n-                }\n+                IOUtil.acquireScope(b, true);\n+                handleReleasers = IOUtil.LinkedRunnable.of(IOUtil.Releaser.of(b), handleReleasers);\n@@ -517,3 +518,1 @@\n-    static record LinkedRunnable(Runnable node, Runnable next)\n-        implements Runnable\n-    {\n+    record LinkedRunnable(Runnable node, Runnable next) implements Runnable {\n@@ -523,0 +522,1 @@\n+\n@@ -532,0 +532,1 @@\n+\n@@ -537,8 +538,14 @@\n-    static record Releaser(Runnable handle) implements Runnable {\n-        Releaser { Objects.requireNonNull(handle) ; }\n-        @Override public void run() { releaseScope(handle); }\n-        static Runnable of(Runnable handle) { return new Releaser(handle); }\n-        static Runnable ofNullable(Runnable handle) {\n-            if (handle == null)\n-                return () -> { };\n-            return new Releaser(handle);\n+    record Releaser(ByteBuffer bb) implements Runnable {\n+        Releaser {\n+            Objects.requireNonNull(bb);\n+        }\n+\n+        @Override\n+        public void run() {\n+            releaseScope(bb);\n+        }\n+\n+        static Runnable of(ByteBuffer bb) {\n+            return NIO_ACCESS.hasSession(bb)\n+                    ? new Releaser(bb)\n+                    : () -> {};\n@@ -546,0 +553,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOUtil.java","additions":41,"deletions":33,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -137,0 +137,1 @@\n+    permission java.lang.RuntimePermission \"accessClassInPackage.jdk.internal.access\";\n","filename":"src\/java.base\/share\/lib\/security\/default.policy","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.ref.Reference;\n@@ -33,0 +32,3 @@\n+\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -46,0 +48,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -177,1 +181,2 @@\n-        if (dst instanceof sun.nio.ch.DirectBuffer buf) {\n+        if (dst instanceof sun.nio.ch.DirectBuffer ddst) {\n+            NIO_ACCESS.acquireSession(dst);\n@@ -179,1 +184,1 @@\n-                long address = buf.address() + pos;\n+                long address = ddst.address() + pos;\n@@ -184,1 +189,1 @@\n-                Reference.reachabilityFence(buf);\n+                NIO_ACCESS.releaseSession(dst);\n@@ -240,0 +245,1 @@\n+            NIO_ACCESS.acquireSession(src);\n@@ -246,1 +252,1 @@\n-                Reference.reachabilityFence(buf);\n+                NIO_ACCESS.releaseSession(src);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUserDefinedFileAttributeView.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -58,0 +60,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -708,0 +712,1 @@\n+        NIO_ACCESS.acquireSession(inBuffer);\n@@ -709,22 +714,17 @@\n-            ensureInitialized();\n-\n-            long inAddr = 0;\n-            byte[] in = null;\n-            int inOfs = 0;\n-            if (dataBuffer.size() > 0) {\n-                if (inLen > 0) {\n-                    byte[] temp = new byte[inLen];\n-                    inBuffer.get(temp);\n-                    dataBuffer.write(temp, 0, temp.length);\n-                }\n-                in = dataBuffer.toByteArray();\n-                inOfs = 0;\n-                inLen = in.length;\n-            } else {\n-                if (inBuffer instanceof DirectBuffer) {\n-                    inAddr = ((DirectBuffer) inBuffer).address();\n-                    inOfs = inBuffer.position();\n-                } else {\n-                    if (inBuffer.hasArray()) {\n-                        in = inBuffer.array();\n-                        inOfs = inBuffer.position() + inBuffer.arrayOffset();\n+            NIO_ACCESS.acquireSession(outBuffer);\n+            try {\n+                try {\n+                    ensureInitialized();\n+\n+                    long inAddr = 0;\n+                    byte[] in = null;\n+                    int inOfs = 0;\n+                    if (dataBuffer.size() > 0) {\n+                        if (inLen > 0) {\n+                            byte[] temp = new byte[inLen];\n+                            inBuffer.get(temp);\n+                            dataBuffer.write(temp, 0, temp.length);\n+                        }\n+                        in = dataBuffer.toByteArray();\n+                        inOfs = 0;\n+                        inLen = in.length;\n@@ -732,2 +732,26 @@\n-                        in = new byte[inLen];\n-                        inBuffer.get(in);\n+                        if (inBuffer instanceof DirectBuffer dInBuffer) {\n+                            inAddr = dInBuffer.address();\n+                            inOfs = inBuffer.position();\n+                        } else {\n+                            if (inBuffer.hasArray()) {\n+                                in = inBuffer.array();\n+                                inOfs = inBuffer.position() + inBuffer.arrayOffset();\n+                            } else {\n+                                in = new byte[inLen];\n+                                inBuffer.get(in);\n+                            }\n+                        }\n+                    }\n+                    long outAddr = 0;\n+                    byte[] outArray = null;\n+                    int outOfs = 0;\n+                    if (outBuffer instanceof DirectBuffer dOutBuffer) {\n+                        outAddr = dOutBuffer.address();\n+                        outOfs = outBuffer.position();\n+                    } else {\n+                        if (outBuffer.hasArray()) {\n+                            outArray = outBuffer.array();\n+                            outOfs = outBuffer.position() + outBuffer.arrayOffset();\n+                        } else {\n+                            outArray = new byte[outLen];\n+                        }\n@@ -735,16 +759,0 @@\n-                }\n-            }\n-            long outAddr = 0;\n-            byte[] outArray = null;\n-            int outOfs = 0;\n-            if (outBuffer instanceof DirectBuffer) {\n-                outAddr = ((DirectBuffer) outBuffer).address();\n-                outOfs = outBuffer.position();\n-            } else {\n-                if (outBuffer.hasArray()) {\n-                    outArray = outBuffer.array();\n-                    outOfs = outBuffer.position() + outBuffer.arrayOffset();\n-                } else {\n-                    outArray = new byte[outLen];\n-                }\n-            }\n@@ -752,9 +760,34 @@\n-            int k = 0;\n-            if (encrypt) {\n-                k = token.p11.C_Encrypt(session.id(), inAddr, in, inOfs, inLen,\n-                        outAddr, outArray, outOfs, outLen);\n-                doCancel = false;\n-            } else {\n-                \/\/ Special handling to match SunJCE provider behavior\n-                if (inLen == 0) {\n-                    return 0;\n+                    int k = 0;\n+                    if (encrypt) {\n+                        k = token.p11.C_Encrypt(session.id(), inAddr, in, inOfs, inLen,\n+                                outAddr, outArray, outOfs, outLen);\n+                        doCancel = false;\n+                    } else {\n+                        \/\/ Special handling to match SunJCE provider behavior\n+                        if (inLen == 0) {\n+                            return 0;\n+                        }\n+                        k = token.p11.C_Decrypt(session.id(), inAddr, in, inOfs, inLen,\n+                                outAddr, outArray, outOfs, outLen);\n+                        doCancel = false;\n+                    }\n+                    inBuffer.position(inBuffer.limit());\n+                    outBuffer.position(outBuffer.position() + k);\n+                    return k;\n+                } catch (PKCS11Exception e) {\n+                    \/\/ As per the PKCS#11 standard, C_Encrypt and C_Decrypt may only\n+                    \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n+                    \/\/ successful calls to determine the output length. However,\n+                    \/\/ these cases are not expected here because the output length\n+                    \/\/ is checked in the OpenJDK side before making the PKCS#11 call.\n+                    \/\/ Thus, doCancel can safely be 'false'.\n+                    doCancel = false;\n+                    handleException(e);\n+                    throw new ProviderException(\"doFinal() failed\", e);\n+                } finally {\n+                    if (encrypt) {\n+                        lastEncKey = this.p11Key;\n+                        lastEncIv = this.iv;\n+                        requireReinit = true;\n+                    }\n+                    reset(doCancel);\n@@ -762,3 +795,2 @@\n-                k = token.p11.C_Decrypt(session.id(), inAddr, in, inOfs, inLen,\n-                        outAddr, outArray, outOfs, outLen);\n-                doCancel = false;\n+            } finally {\n+                NIO_ACCESS.releaseSession(outBuffer);\n@@ -766,13 +798,0 @@\n-            inBuffer.position(inBuffer.limit());\n-            outBuffer.position(outBuffer.position() + k);\n-            return k;\n-        } catch (PKCS11Exception e) {\n-            \/\/ As per the PKCS#11 standard, C_Encrypt and C_Decrypt may only\n-            \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n-            \/\/ successful calls to determine the output length. However,\n-            \/\/ these cases are not expected here because the output length\n-            \/\/ is checked in the OpenJDK side before making the PKCS#11 call.\n-            \/\/ Thus, doCancel can safely be 'false'.\n-            doCancel = false;\n-            handleException(e);\n-            throw new ProviderException(\"doFinal() failed\", e);\n@@ -780,6 +799,1 @@\n-            if (encrypt) {\n-                lastEncKey = this.p11Key;\n-                lastEncIv = this.iv;\n-                requireReinit = true;\n-            }\n-            reset(doCancel);\n+            NIO_ACCESS.releaseSession(inBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":85,"deletions":71,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -59,0 +61,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -681,0 +685,1 @@\n+        NIO_ACCESS.acquireSession(inBuffer);\n@@ -682,13 +687,15 @@\n-            ensureInitialized();\n-\n-            long inAddr = 0;\n-            int inOfs = 0;\n-            byte[] inArray = null;\n-\n-            if (inBuffer instanceof DirectBuffer) {\n-                inAddr = ((DirectBuffer) inBuffer).address();\n-                inOfs = origPos;\n-            } else if (inBuffer.hasArray()) {\n-                inArray = inBuffer.array();\n-                inOfs = (origPos + inBuffer.arrayOffset());\n-            }\n+            NIO_ACCESS.acquireSession(outBuffer);\n+            try {\n+                ensureInitialized();\n+\n+                long inAddr = 0;\n+                int inOfs = 0;\n+                byte[] inArray = null;\n+\n+                if (inBuffer instanceof DirectBuffer dInBuffer) {\n+                    inAddr = dInBuffer.address();\n+                    inOfs = origPos;\n+                } else if (inBuffer.hasArray()) {\n+                    inArray = inBuffer.array();\n+                    inOfs = (origPos + inBuffer.arrayOffset());\n+                }\n@@ -696,10 +703,6 @@\n-            long outAddr = 0;\n-            int outOfs = 0;\n-            byte[] outArray = null;\n-            if (outBuffer instanceof DirectBuffer) {\n-                outAddr = ((DirectBuffer) outBuffer).address();\n-                outOfs = outBuffer.position();\n-            } else {\n-                if (outBuffer.hasArray()) {\n-                    outArray = outBuffer.array();\n-                    outOfs = (outBuffer.position() + outBuffer.arrayOffset());\n+                long outAddr = 0;\n+                int outOfs = 0;\n+                byte[] outArray = null;\n+                if (outBuffer instanceof DirectBuffer dOutBuffer) {\n+                    outAddr = dOutBuffer.address();\n+                    outOfs = outBuffer.position();\n@@ -707,1 +710,6 @@\n-                    outArray = new byte[outLen];\n+                    if (outBuffer.hasArray()) {\n+                        outArray = outBuffer.array();\n+                        outOfs = (outBuffer.position() + outBuffer.arrayOffset());\n+                    } else {\n+                        outArray = new byte[outLen];\n+                    }\n@@ -709,1 +717,0 @@\n-            }\n@@ -711,10 +718,19 @@\n-            int k = 0;\n-            int newPadBufferLen = 0;\n-            if (paddingObj != null  && (!encrypt || reqBlockUpdates)) {\n-                if (padBufferLen != 0) {\n-                    if (padBufferLen != padBuffer.length) {\n-                        int bufCapacity = padBuffer.length - padBufferLen;\n-                        if (inLen > bufCapacity) {\n-                            bufferInputBytes(inBuffer, bufCapacity);\n-                            inOfs += bufCapacity;\n-                            inLen -= bufCapacity;\n+                int k = 0;\n+                int newPadBufferLen = 0;\n+                if (paddingObj != null && (!encrypt || reqBlockUpdates)) {\n+                    if (padBufferLen != 0) {\n+                        if (padBufferLen != padBuffer.length) {\n+                            int bufCapacity = padBuffer.length - padBufferLen;\n+                            if (inLen > bufCapacity) {\n+                                bufferInputBytes(inBuffer, bufCapacity);\n+                                inOfs += bufCapacity;\n+                                inLen -= bufCapacity;\n+                            } else {\n+                                bufferInputBytes(inBuffer, inLen);\n+                                return 0;\n+                            }\n+                        }\n+                        if (encrypt) {\n+                            k = token.p11.C_EncryptUpdate(session.id(), 0,\n+                                    padBuffer, 0, padBufferLen, outAddr, outArray,\n+                                    outOfs, outLen);\n@@ -722,2 +738,3 @@\n-                            bufferInputBytes(inBuffer, inLen);\n-                            return 0;\n+                            k = token.p11.C_DecryptUpdate(session.id(), 0,\n+                                    padBuffer, 0, padBufferLen, outAddr, outArray,\n+                                    outOfs, outLen);\n@@ -725,0 +742,19 @@\n+                        padBufferLen = 0;\n+                    }\n+                    newPadBufferLen = inLen & (blockSize - 1);\n+                    if (!encrypt && newPadBufferLen == 0) {\n+                        \/\/ While decrypting with implUpdate, the last encrypted block\n+                        \/\/ is always held in a buffer. If it's the final one (unknown\n+                        \/\/ at this point), it may contain padding bytes and need further\n+                        \/\/ processing. In implDoFinal (where we know it's the final one)\n+                        \/\/ the buffer is decrypted, unpadded and returned.\n+                        newPadBufferLen = padBuffer.length;\n+                    }\n+                    inLen -= newPadBufferLen;\n+                }\n+                if (inLen > 0) {\n+                    if (inAddr == 0 && inArray == null) {\n+                        inArray = new byte[inLen];\n+                        inBuffer.get(inArray);\n+                    } else {\n+                        inBuffer.position(inBuffer.position() + inLen);\n@@ -727,3 +763,3 @@\n-                        k = token.p11.C_EncryptUpdate(session.id(), 0,\n-                                padBuffer, 0, padBufferLen, outAddr, outArray,\n-                                outOfs, outLen);\n+                        k += token.p11.C_EncryptUpdate(session.id(), inAddr,\n+                                inArray, inOfs, inLen, outAddr, outArray,\n+                                (outOfs + k), (outLen - k));\n@@ -731,3 +767,3 @@\n-                        k = token.p11.C_DecryptUpdate(session.id(), 0,\n-                                padBuffer, 0, padBufferLen, outAddr, outArray,\n-                                outOfs, outLen);\n+                        k += token.p11.C_DecryptUpdate(session.id(), inAddr,\n+                                inArray, inOfs, inLen, outAddr, outArray,\n+                                (outOfs + k), (outLen - k));\n@@ -735,1 +771,0 @@\n-                    padBufferLen = 0;\n@@ -737,8 +772,3 @@\n-                newPadBufferLen = inLen & (blockSize - 1);\n-                if (!encrypt && newPadBufferLen == 0) {\n-                    \/\/ While decrypting with implUpdate, the last encrypted block\n-                    \/\/ is always held in a buffer. If it's the final one (unknown\n-                    \/\/ at this point), it may contain padding bytes and need further\n-                    \/\/ processing. In implDoFinal (where we know it's the final one)\n-                    \/\/ the buffer is decrypted, unpadded and returned.\n-                    newPadBufferLen = padBuffer.length;\n+                \/\/ update 'padBuffer' if using our own padding impl.\n+                if (paddingObj != null && newPadBufferLen > 0) {\n+                    bufferInputBytes(inBuffer, newPadBufferLen);\n@@ -746,6 +776,4 @@\n-                inLen -= newPadBufferLen;\n-            }\n-            if (inLen > 0) {\n-                if (inAddr == 0 && inArray == null) {\n-                    inArray = new byte[inLen];\n-                    inBuffer.get(inArray);\n+                bytesBuffered += (inLen - k);\n+                if (!(outBuffer instanceof DirectBuffer) &&\n+                        !outBuffer.hasArray()) {\n+                    outBuffer.put(outArray, outOfs, k);\n@@ -753,1 +781,1 @@\n-                    inBuffer.position(inBuffer.position() + inLen);\n+                    outBuffer.position(outBuffer.position() + k);\n@@ -755,8 +783,7 @@\n-                if (encrypt) {\n-                    k += token.p11.C_EncryptUpdate(session.id(), inAddr,\n-                            inArray, inOfs, inLen, outAddr, outArray,\n-                            (outOfs + k), (outLen - k));\n-                } else {\n-                    k += token.p11.C_DecryptUpdate(session.id(), inAddr,\n-                            inArray, inOfs, inLen, outAddr, outArray,\n-                            (outOfs + k), (outLen - k));\n+                return k;\n+            } catch (PKCS11Exception e) {\n+                \/\/ Reset input buffer to its original position for\n+                inBuffer.position(origPos);\n+                if (e.match(CKR_BUFFER_TOO_SMALL)) {\n+                    throw (ShortBufferException)\n+                            (new ShortBufferException().initCause(e));\n@@ -764,0 +791,8 @@\n+                \/\/ Some implementations such as the NSS Software Token do not\n+                \/\/ cancel the operation upon a C_EncryptUpdate\/C_DecryptUpdate\n+                \/\/ failure (as required by the PKCS#11 standard). See JDK-8258833\n+                \/\/ for further information.\n+                reset(true);\n+                throw new ProviderException(\"update() failed\", e);\n+            } finally {\n+                NIO_ACCESS.releaseSession(outBuffer);\n@@ -765,25 +800,2 @@\n-            \/\/ update 'padBuffer' if using our own padding impl.\n-            if (paddingObj != null && newPadBufferLen > 0) {\n-                bufferInputBytes(inBuffer, newPadBufferLen);\n-            }\n-            bytesBuffered += (inLen - k);\n-            if (!(outBuffer instanceof DirectBuffer) &&\n-                    !outBuffer.hasArray()) {\n-                outBuffer.put(outArray, outOfs, k);\n-            } else {\n-                outBuffer.position(outBuffer.position() + k);\n-            }\n-            return k;\n-        } catch (PKCS11Exception e) {\n-            \/\/ Reset input buffer to its original position for\n-            inBuffer.position(origPos);\n-            if (e.match(CKR_BUFFER_TOO_SMALL)) {\n-                throw (ShortBufferException)\n-                        (new ShortBufferException().initCause(e));\n-            }\n-            \/\/ Some implementations such as the NSS Software Token do not\n-            \/\/ cancel the operation upon a C_EncryptUpdate\/C_DecryptUpdate\n-            \/\/ failure (as required by the PKCS#11 standard). See JDK-8258833\n-            \/\/ for further information.\n-            reset(true);\n-            throw new ProviderException(\"update() failed\", e);\n+        } finally {\n+            NIO_ACCESS.releaseSession(inBuffer);\n@@ -880,0 +892,1 @@\n+        NIO_ACCESS.acquireSession(outBuffer);\n@@ -881,12 +894,9 @@\n-            ensureInitialized();\n-\n-            long outAddr = 0;\n-            byte[] outArray = null;\n-            int outOfs = 0;\n-            if (outBuffer instanceof DirectBuffer) {\n-                outAddr = ((DirectBuffer) outBuffer).address();\n-                outOfs = outBuffer.position();\n-            } else {\n-                if (outBuffer.hasArray()) {\n-                    outArray = outBuffer.array();\n-                    outOfs = outBuffer.position() + outBuffer.arrayOffset();\n+            try {\n+                ensureInitialized();\n+\n+                long outAddr = 0;\n+                byte[] outArray = null;\n+                int outOfs = 0;\n+                if (outBuffer instanceof DirectBuffer dOutBuffer) {\n+                    outAddr = dOutBuffer.address();\n+                    outOfs = outBuffer.position();\n@@ -894,1 +904,6 @@\n-                    outArray = new byte[outLen];\n+                    if (outBuffer.hasArray()) {\n+                        outArray = outBuffer.array();\n+                        outOfs = outBuffer.position() + outBuffer.arrayOffset();\n+                    } else {\n+                        outArray = new byte[outLen];\n+                    }\n@@ -896,1 +911,0 @@\n-            }\n@@ -898,1 +912,1 @@\n-            int k = 0;\n+                int k = 0;\n@@ -900,12 +914,13 @@\n-            if (encrypt) {\n-                if (paddingObj != null) {\n-                    int startOff = 0;\n-                    if (reqBlockUpdates) {\n-                        \/\/ call C_EncryptUpdate first if the padBuffer is full\n-                        \/\/ to make room for padding bytes\n-                        if (padBufferLen == padBuffer.length) {\n-                            k = token.p11.C_EncryptUpdate(session.id(),\n-                                0, padBuffer, 0, padBufferLen,\n-                                outAddr, outArray, outOfs, outLen);\n-                        } else {\n-                            startOff = padBufferLen;\n+                if (encrypt) {\n+                    if (paddingObj != null) {\n+                        int startOff = 0;\n+                        if (reqBlockUpdates) {\n+                            \/\/ call C_EncryptUpdate first if the padBuffer is full\n+                            \/\/ to make room for padding bytes\n+                            if (padBufferLen == padBuffer.length) {\n+                                k = token.p11.C_EncryptUpdate(session.id(),\n+                                        0, padBuffer, 0, padBufferLen,\n+                                        outAddr, outArray, outOfs, outLen);\n+                            } else {\n+                                startOff = padBufferLen;\n+                            }\n@@ -913,27 +928,5 @@\n-                    }\n-                    int actualPadLen = paddingObj.setPaddingBytes(padBuffer,\n-                            startOff, requiredOutLen - bytesBuffered);\n-                    k += token.p11.C_EncryptUpdate(session.id(),\n-                            0, padBuffer, 0, startOff + actualPadLen,\n-                            outAddr, outArray, outOfs + k, outLen - k);\n-                }\n-                \/\/ Some implementations such as the NSS Software Token do not\n-                \/\/ cancel the operation upon a C_EncryptUpdate failure (as\n-                \/\/ required by the PKCS#11 standard). Cancel is not needed\n-                \/\/ only after this point. See JDK-8258833 for further\n-                \/\/ information.\n-                doCancel = false;\n-                k += token.p11.C_EncryptFinal(session.id(),\n-                        outAddr, outArray, (outOfs + k), (outLen - k));\n-            } else {\n-                \/\/ Special handling to match SunJCE provider behavior\n-                if (bytesBuffered == 0 && padBufferLen == 0) {\n-                    return 0;\n-                }\n-\n-                if (paddingObj != null) {\n-                    if (padBufferLen != 0) {\n-                        k = token.p11.C_DecryptUpdate(session.id(),\n-                                0, padBuffer, 0, padBufferLen,\n-                                0, padBuffer, 0, padBuffer.length);\n-                        padBufferLen = 0;\n+                        int actualPadLen = paddingObj.setPaddingBytes(padBuffer,\n+                                startOff, requiredOutLen - bytesBuffered);\n+                        k += token.p11.C_EncryptUpdate(session.id(),\n+                                0, padBuffer, 0, startOff + actualPadLen,\n+                                outAddr, outArray, outOfs + k, outLen - k);\n@@ -942,1 +935,1 @@\n-                    \/\/ cancel the operation upon a C_DecryptUpdate failure (as\n+                    \/\/ cancel the operation upon a C_EncryptUpdate failure (as\n@@ -947,2 +940,7 @@\n-                    k += token.p11.C_DecryptFinal(session.id(),\n-                            0, padBuffer, k, padBuffer.length - k);\n+                    k += token.p11.C_EncryptFinal(session.id(),\n+                            outAddr, outArray, (outOfs + k), (outLen - k));\n+                } else {\n+                    \/\/ Special handling to match SunJCE provider behavior\n+                    if (bytesBuffered == 0 && padBufferLen == 0) {\n+                        return 0;\n+                    }\n@@ -950,4 +948,30 @@\n-                    int actualPadLen = paddingObj.unpad(padBuffer, k);\n-                    k -= actualPadLen;\n-                    outArray = padBuffer;\n-                    outOfs = 0;\n+                    if (paddingObj != null) {\n+                        if (padBufferLen != 0) {\n+                            k = token.p11.C_DecryptUpdate(session.id(),\n+                                    0, padBuffer, 0, padBufferLen,\n+                                    0, padBuffer, 0, padBuffer.length);\n+                            padBufferLen = 0;\n+                        }\n+                        \/\/ Some implementations such as the NSS Software Token do not\n+                        \/\/ cancel the operation upon a C_DecryptUpdate failure (as\n+                        \/\/ required by the PKCS#11 standard). Cancel is not needed\n+                        \/\/ only after this point. See JDK-8258833 for further\n+                        \/\/ information.\n+                        doCancel = false;\n+                        k += token.p11.C_DecryptFinal(session.id(),\n+                                0, padBuffer, k, padBuffer.length - k);\n+\n+                        int actualPadLen = paddingObj.unpad(padBuffer, k);\n+                        k -= actualPadLen;\n+                        outArray = padBuffer;\n+                        outOfs = 0;\n+                    } else {\n+                        doCancel = false;\n+                        k = token.p11.C_DecryptFinal(session.id(),\n+                                outAddr, outArray, outOfs, outLen);\n+                    }\n+                }\n+                if ((!encrypt && paddingObj != null) ||\n+                        (!(outBuffer instanceof DirectBuffer) &&\n+                                !outBuffer.hasArray())) {\n+                    outBuffer.put(outArray, outOfs, k);\n@@ -955,3 +979,1 @@\n-                    doCancel = false;\n-                    k = token.p11.C_DecryptFinal(session.id(),\n-                            outAddr, outArray, outOfs, outLen);\n+                    outBuffer.position(outBuffer.position() + k);\n@@ -959,0 +981,6 @@\n+                return k;\n+            } catch (PKCS11Exception e) {\n+                handleException(e);\n+                throw new ProviderException(\"doFinal() failed\", e);\n+            } finally {\n+                reset(doCancel);\n@@ -960,11 +988,0 @@\n-            if ((!encrypt && paddingObj != null) ||\n-                    (!(outBuffer instanceof DirectBuffer) &&\n-                    !outBuffer.hasArray())) {\n-                outBuffer.put(outArray, outOfs, k);\n-            } else {\n-                outBuffer.position(outBuffer.position() + k);\n-            }\n-            return k;\n-        } catch (PKCS11Exception e) {\n-            handleException(e);\n-            throw new ProviderException(\"doFinal() failed\", e);\n@@ -972,1 +989,1 @@\n-            reset(doCancel);\n+            NIO_ACCESS.releaseSession(outBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":185,"deletions":168,"binary":false,"changes":353,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.*;\n@@ -35,0 +34,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -58,0 +59,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -271,1 +274,1 @@\n-        if (!(byteBuffer instanceof DirectBuffer)) {\n+        if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n@@ -277,1 +280,0 @@\n-        long addr = ((DirectBuffer)byteBuffer).address();\n@@ -288,1 +290,6 @@\n-            token.p11.C_DigestUpdate(session.id(), addr + ofs, null, 0, len);\n+            NIO_ACCESS.acquireSession(byteBuffer);\n+            try {\n+                token.p11.C_DigestUpdate(session.id(), dByteBuffer.address() + ofs, null, 0, len);\n+            } finally {\n+                NIO_ACCESS.releaseSession(byteBuffer);\n+            }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Digest.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -46,1 +48,0 @@\n-import static sun.security.pkcs11.P11Cipher.*;\n@@ -61,0 +62,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -555,0 +558,1 @@\n+        NIO_ACCESS.acquireSession(inBuffer);\n@@ -556,24 +560,19 @@\n-            ensureInitialized();\n-\n-            long inAddr = 0;\n-            byte[] in = null;\n-            int inOfs = 0;\n-\n-            if (dataBuffer.size() > 0) {\n-                if (inBuffer != null && inLen > 0) {\n-                    byte[] temp = new byte[inLen];\n-                    inBuffer.get(temp);\n-                    dataBuffer.write(temp, 0, temp.length);\n-                }\n-\n-                in = dataBuffer.toByteArray();\n-                inOfs = 0;\n-                inLen = in.length;\n-            } else {\n-                if (inBuffer instanceof DirectBuffer) {\n-                    inAddr = ((DirectBuffer) inBuffer).address();\n-                    inOfs = inBuffer.position();\n-                } else {\n-                    if (inBuffer.hasArray()) {\n-                        in = inBuffer.array();\n-                        inOfs = inBuffer.position() + inBuffer.arrayOffset();\n+            NIO_ACCESS.acquireSession(outBuffer);\n+            try {\n+                try {\n+                    ensureInitialized();\n+\n+                    long inAddr = 0;\n+                    byte[] in = null;\n+                    int inOfs = 0;\n+\n+                    if (dataBuffer.size() > 0) {\n+                        if (inBuffer != null && inLen > 0) {\n+                            byte[] temp = new byte[inLen];\n+                            inBuffer.get(temp);\n+                            dataBuffer.write(temp, 0, temp.length);\n+                        }\n+\n+                        in = dataBuffer.toByteArray();\n+                        inOfs = 0;\n+                        inLen = in.length;\n@@ -581,2 +580,26 @@\n-                        in = new byte[inLen];\n-                        inBuffer.get(in);\n+                        if (inBuffer instanceof DirectBuffer dInBuffer) {\n+                            inAddr = dInBuffer.address();\n+                            inOfs = inBuffer.position();\n+                        } else {\n+                            if (inBuffer.hasArray()) {\n+                                in = inBuffer.array();\n+                                inOfs = inBuffer.position() + inBuffer.arrayOffset();\n+                            } else {\n+                                in = new byte[inLen];\n+                                inBuffer.get(in);\n+                            }\n+                        }\n+                    }\n+                    long outAddr = 0;\n+                    byte[] outArray = null;\n+                    int outOfs = 0;\n+                    if (outBuffer instanceof DirectBuffer dOutBuffer) {\n+                        outAddr = dOutBuffer.address();\n+                        outOfs = outBuffer.position();\n+                    } else {\n+                        if (outBuffer.hasArray()) {\n+                            outArray = outBuffer.array();\n+                            outOfs = outBuffer.position() + outBuffer.arrayOffset();\n+                        } else {\n+                            outArray = new byte[outLen];\n+                        }\n@@ -584,16 +607,0 @@\n-                }\n-            }\n-            long outAddr = 0;\n-            byte[] outArray = null;\n-            int outOfs = 0;\n-            if (outBuffer instanceof DirectBuffer) {\n-                outAddr = ((DirectBuffer) outBuffer).address();\n-                outOfs = outBuffer.position();\n-            } else {\n-                if (outBuffer.hasArray()) {\n-                    outArray = outBuffer.array();\n-                    outOfs = outBuffer.position() + outBuffer.arrayOffset();\n-                } else {\n-                    outArray = new byte[outLen];\n-                }\n-            }\n@@ -601,8 +608,26 @@\n-            if (opmode == Cipher.ENCRYPT_MODE) {\n-                k = token.p11.C_Encrypt(session.id(), inAddr, in, inOfs, inLen,\n-                        outAddr, outArray, outOfs, outLen);\n-                doCancel = false;\n-            } else {\n-                \/\/ Special handling to match SunJCE provider behavior\n-                if (inLen == 0) {\n-                    return 0;\n+                    if (opmode == Cipher.ENCRYPT_MODE) {\n+                        k = token.p11.C_Encrypt(session.id(), inAddr, in, inOfs, inLen,\n+                                outAddr, outArray, outOfs, outLen);\n+                        doCancel = false;\n+                    } else {\n+                        \/\/ Special handling to match SunJCE provider behavior\n+                        if (inLen == 0) {\n+                            return 0;\n+                        }\n+                        k = token.p11.C_Decrypt(session.id(), inAddr, in, inOfs, inLen,\n+                                outAddr, outArray, outOfs, outLen);\n+                        doCancel = false;\n+                    }\n+                    inBuffer.position(inBuffer.limit());\n+                    outBuffer.position(outBuffer.position() + k);\n+                } catch (PKCS11Exception e) {\n+                    \/\/ As per the PKCS#11 standard, C_Encrypt and C_Decrypt may only\n+                    \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n+                    \/\/ successful calls to determine the output length. However,\n+                    \/\/ these cases are not expected here because the output length\n+                    \/\/ is checked in the OpenJDK side before making the PKCS#11 call.\n+                    \/\/ Thus, doCancel can safely be 'false'.\n+                    doCancel = false;\n+                    handleEncException(\"doFinal() failed\", e);\n+                } finally {\n+                    reset(doCancel);\n@@ -610,3 +635,2 @@\n-                k = token.p11.C_Decrypt(session.id(), inAddr, in, inOfs, inLen,\n-                        outAddr, outArray, outOfs, outLen);\n-                doCancel = false;\n+            } finally {\n+                NIO_ACCESS.releaseSession(outBuffer);\n@@ -614,11 +638,0 @@\n-            inBuffer.position(inBuffer.limit());\n-            outBuffer.position(outBuffer.position() + k);\n-        } catch (PKCS11Exception e) {\n-            \/\/ As per the PKCS#11 standard, C_Encrypt and C_Decrypt may only\n-            \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n-            \/\/ successful calls to determine the output length. However,\n-            \/\/ these cases are not expected here because the output length\n-            \/\/ is checked in the OpenJDK side before making the PKCS#11 call.\n-            \/\/ Thus, doCancel can safely be 'false'.\n-            doCancel = false;\n-            handleEncException(\"doFinal() failed\", e);\n@@ -626,1 +639,1 @@\n-            reset(doCancel);\n+            NIO_ACCESS.releaseSession(inBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyWrapCipher.java","additions":79,"deletions":66,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -58,0 +60,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -249,1 +253,1 @@\n-            if (!(byteBuffer instanceof DirectBuffer directBuffer)) {\n+            if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n@@ -253,1 +257,0 @@\n-            long addr = directBuffer.address();\n@@ -255,1 +258,6 @@\n-            token.p11.C_SignUpdate(session.id(), addr + ofs, null, 0, len);\n+            NIO_ACCESS.acquireSession(byteBuffer);\n+            try  {\n+                token.p11.C_SignUpdate(session.id(), dByteBuffer.address() + ofs, null, 0, len);\n+            } finally {\n+                NIO_ACCESS.releaseSession(byteBuffer);\n+            }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Mac.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n@@ -31,0 +29,3 @@\n+\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -34,1 +35,0 @@\n-import java.util.Arrays;\n@@ -71,0 +71,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -616,1 +618,1 @@\n-                if (byteBuffer instanceof DirectBuffer == false) {\n+                if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n@@ -621,1 +623,0 @@\n-                long addr = ((DirectBuffer) byteBuffer).address();\n@@ -623,0 +624,1 @@\n+                NIO_ACCESS.acquireSession(byteBuffer);\n@@ -624,0 +626,1 @@\n+                    long addr = dByteBuffer.address();\n@@ -638,0 +641,2 @@\n+                } finally {\n+                    NIO_ACCESS.releaseSession(byteBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11PSSSignature.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -38,1 +41,0 @@\n-import sun.security.x509.AlgorithmId;\n@@ -101,0 +103,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -578,1 +582,1 @@\n-                if (!(byteBuffer instanceof DirectBuffer)) {\n+                if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n@@ -583,1 +587,0 @@\n-                long addr = ((DirectBuffer) byteBuffer).address();\n@@ -585,0 +588,1 @@\n+                NIO_ACCESS.acquireSession(byteBuffer);\n@@ -586,0 +590,1 @@\n+                    long addr = dByteBuffer.address();\n@@ -598,0 +603,2 @@\n+                } finally {\n+                    NIO_ACCESS.releaseSession(byteBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Signature.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -77,0 +79,3 @@\n+\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -842,1 +847,3 @@\n-        int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem, peek);\n+        NIO_ACCESS.acquireSession(bb);\n+        try {\n+            int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem, peek);\n@@ -844,3 +851,6 @@\n-        if (n > 0)\n-            bb.position(pos + n);\n-        return n;\n+            if (n > 0)\n+                bb.position(pos + n);\n+            return n;\n+        } finally {\n+            NIO_ACCESS.releaseSession(bb);\n+        }\n@@ -1031,5 +1041,10 @@\n-        int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,\n-                            port, -1 \/*121*\/, streamNumber, unordered, ppid);\n-        if (written > 0)\n-            bb.position(pos + written);\n-        return written;\n+        NIO_ACCESS.acquireSession(bb);\n+        try {\n+            int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,\n+                    port, -1 \/*121*\/, streamNumber, unordered, ppid);\n+            if (written > 0)\n+                bb.position(pos + written);\n+            return written;\n+        } finally {\n+            NIO_ACCESS.releaseSession(bb);\n+        }\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":24,"deletions":9,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -74,0 +76,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -586,4 +590,9 @@\n-        int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem);\n-        if (n > 0)\n-            bb.position(pos + n);\n-        return n;\n+        NIO_ACCESS.acquireSession(bb);\n+        try {\n+            int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem);\n+            if (n > 0)\n+                bb.position(pos + n);\n+            return n;\n+        } finally {\n+            NIO_ACCESS.releaseSession(bb);\n+        }\n@@ -911,5 +920,10 @@\n-        int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,\n-                            port, assocId, streamNumber, unordered, ppid);\n-        if (written > 0)\n-            bb.position(pos + written);\n-        return written;\n+        NIO_ACCESS.acquireSession(bb);\n+        try {\n+            int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,\n+                    port, assocId, streamNumber, unordered, ppid);\n+            if (written > 0)\n+                bb.position(pos + written);\n+            return written;\n+        } finally {\n+            NIO_ACCESS.releaseSession(bb);\n+        }\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpMultiChannelImpl.java","additions":23,"deletions":9,"binary":false,"changes":32,"status":"modified"}]}