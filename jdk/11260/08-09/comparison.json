{"files":[{"patch":"@@ -917,0 +917,2 @@\n+                \/\/ The use of DirectBuffer::address below need not be guarded as\n+                \/\/ no access is made to actual memory.\n@@ -920,2 +922,3 @@\n-                try (var srcGuard = NIO_ACCESS.acquireScope(src);\n-                     var dstGuard = NIO_ACCESS.acquireScope(dst)) {\n+                \/\/ Get the current memory address for the given ByteBuffers\n+                long srcaddr = dsrc.address();\n+                long dstaddr = ddst.address();\n@@ -923,17 +926,6 @@\n-                    \/\/ Get the current memory address for the given ByteBuffers\n-                    long srcaddr = dsrc.address();\n-                    long dstaddr = ddst.address();\n-\n-                    \/\/ Find the lowest attachment that is the base memory address\n-                    \/\/ of the shared memory for the src object\n-                    while (dsrc.attachment() != null) {\n-                        srcaddr = ((DirectBuffer) dsrc.attachment()).address();\n-                        dsrc = (DirectBuffer) dsrc.attachment();\n-                    }\n-\n-                    \/\/ Find the lowest attachment that is the base memory address\n-                    \/\/ of the shared memory for the dst object\n-                    while (ddst.attachment() != null) {\n-                        dstaddr = ((DirectBuffer) ddst.attachment()).address();\n-                        ddst = (DirectBuffer) ddst.attachment();\n-                    }\n+                \/\/ Find the lowest attachment that is the base memory address\n+                \/\/ of the shared memory for the src object\n+                while (dsrc.attachment() != null) {\n+                    srcaddr = ((DirectBuffer) dsrc.attachment()).address();\n+                    dsrc = (DirectBuffer) dsrc.attachment();\n+                }\n@@ -941,16 +933,5 @@\n-                    \/\/ If the base addresses are not the same, there is no overlap\n-                    if (srcaddr != dstaddr) {\n-                        return dst;\n-                    }\n-                    \/\/ At this point we know these objects share the same memory.\n-                    \/\/ This checks the starting position of the src and dst address\n-                    \/\/ for overlap.\n-                    \/\/ It uses the base address minus the passed object's address to\n-                    \/\/ get the offset from the base address, then add the position()\n-                    \/\/ from the passed object.  That gives up the true offset from\n-                    \/\/ the base address.  As long as the src side is >= the dst\n-                    \/\/ side, we are not in overlap.\n-                    if (((DirectBuffer) src).address() - srcaddr + src.position() >=\n-                            ((DirectBuffer) dst).address() - dstaddr + dst.position()) {\n-                        return dst;\n-                    }\n+                \/\/ Find the lowest attachment that is the base memory address\n+                \/\/ of the shared memory for the dst object\n+                while (ddst.attachment() != null) {\n+                    dstaddr = ((DirectBuffer) ddst.attachment()).address();\n+                    ddst = (DirectBuffer) ddst.attachment();\n@@ -959,0 +940,16 @@\n+                \/\/ If the base addresses are not the same, there is no overlap\n+                if (srcaddr != dstaddr) {\n+                    return dst;\n+                }\n+                \/\/ At this point we know these objects share the same memory.\n+                \/\/ This checks the starting position of the src and dst address\n+                \/\/ for overlap.\n+                \/\/ It uses the base address minus the passed object's address to\n+                \/\/ get the offset from the base address, then add the position()\n+                \/\/ from the passed object.  That gives up the true offset from\n+                \/\/ the base address.  As long as the src side is >= the dst\n+                \/\/ side, we are not in overlap.\n+                if (((DirectBuffer) src).address() - srcaddr + src.position() >=\n+                        ((DirectBuffer) dst).address() - dstaddr + dst.position()) {\n+                    return dst;\n+                }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -39,5 +39,1 @@\n-    \/\/ An example of a guarded use of a memory address is shown here:\n-    \/\/\n-    \/\/ try (var guard = NIO_ACCESS.acquireSession(bb)) {\n-    \/\/     performOperation(bb.address());\n-    \/\/ }\n+    \/\/ Guards are available in the JavaNioAccess class.\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DirectBuffer.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"}]}