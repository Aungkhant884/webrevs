{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.util.NullableKeyValueHolder;\n+\n@@ -151,1 +153,1 @@\n-        return it.hasNext() ? Map.Entry.copyOf(it.next()) : null;\n+        return it.hasNext() ? new NullableKeyValueHolder<>(it.next()) : null;\n@@ -168,1 +170,1 @@\n-        return it.hasNext() ? Map.Entry.copyOf(it.next()) : null;\n+        return it.hasNext() ? new NullableKeyValueHolder<>(it.next()) : null;\n@@ -188,1 +190,1 @@\n-            var entry = Map.Entry.copyOf(it.next());\n+            var entry = new NullableKeyValueHolder<>(it.next());\n@@ -213,1 +215,1 @@\n-            var entry = Map.Entry.copyOf(it.next());\n+            var entry = new NullableKeyValueHolder<>(it.next());\n","filename":"src\/java.base\/share\/classes\/java\/util\/SequencedMap.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.util;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+\n+\/**\n+ * An immutable container for a key and a value, both of which are nullable.\n+ *\n+ * <p>This is a <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>\n+ * class; programmers should treat instances that are\n+ * {@linkplain #equals(Object) equal} as interchangeable and should not\n+ * use instances for synchronization, or unpredictable behavior may\n+ * occur. For example, in a future release, synchronization may fail.\n+ *\n+ * @apiNote\n+ * This class is not exported. Instances are created by various Map implementations\n+ * when they need a Map.Entry that isn't connected to the Map.\n+ *\n+ * <p>This class differs from AbstractMap.SimpleImmutableEntry in that it is not\n+ * serializable and that it is final. This class differs from java.util.KeyValueHolder\n+ * in that the key and value are nullable.\n+ *\n+ * <p>In principle this class could be a variation on KeyValueHolder. However,\n+ * making that class selectively support nullable keys and values is quite intricate.\n+ * Various specifications (such as Map.ofEntries and Map.entry) specify non-nullability\n+ * of the key and the value. Map.Entry.copyOf also requires non-null keys and values;\n+ * but it simply passes through KeyValueHolder instances, assuming their keys and values\n+ * are non-nullable. If a KVH with nullable keys and values were introduced, some way\n+ * to distinguish it would be necessary. This could be done by introducing a subclass\n+ * (requiring KVH to be made non-final) or by introducing some kind of \"mode\" field\n+ * (potentially increasing the size of every KVH instance, though another field could\n+ * probably fit into the object's padding in most JVMs.) More critically, a mode field\n+ * would have to be checked in all the right places to get the right behavior.\n+ *\n+ * <p>A longer range possibility is to selectively relax the restrictions against nulls in\n+ * Map.entry and Map.Entry.copyOf. This would also require some intricate specification\n+ * changes and corresponding implementation changes (e.g., the implementations backing\n+ * Map.of might still need to reject nulls, and so would Map.ofEntries) but allowing\n+ * a Map.Entry itself to contain nulls seems beneficial in general. If this is done,\n+ * merging KeyValueHolder and NullableKeyValueHolder should be reconsidered.\n+ *\n+ * @param <K> the key type\n+ * @param <V> the value type\n+ *\/\n+@jdk.internal.ValueBased\n+public final class NullableKeyValueHolder<K,V> implements Map.Entry<K,V> {\n+    final K key;\n+    final V value;\n+\n+    \/**\n+     * Constructs a NullableKeyValueHolder.\n+     *\n+     * @param k the key, may be null\n+     * @param v the value, may be null\n+     *\/\n+    public NullableKeyValueHolder(K k, V v) {\n+        key = k;\n+        value = v;\n+    }\n+\n+    \/**\n+     * Constructs a NullableKeyValueHolder from a Map.Entry. No need for an\n+     * idempotent copy at this time.\n+     *\n+     * @param entry the entry, must not be null\n+     *\/\n+    public NullableKeyValueHolder(Map.Entry<K,V> entry) {\n+        Objects.requireNonNull(entry);\n+        key = entry.getKey();\n+        value = entry.getValue();\n+    }\n+\n+    \/**\n+     * Gets the key from this holder.\n+     *\n+     * @return the key, may be null\n+     *\/\n+    @Override\n+    public K getKey() {\n+        return key;\n+    }\n+\n+    \/**\n+     * Gets the value from this holder.\n+     *\n+     * @return the value, may be null\n+     *\/\n+    @Override\n+    public V getValue() {\n+        return value;\n+    }\n+\n+    \/**\n+     * Throws {@link UnsupportedOperationException}.\n+     *\n+     * @param value ignored\n+     * @return never returns normally\n+     *\/\n+    @Override\n+    public V setValue(V value) {\n+        throw new UnsupportedOperationException(\"not supported\");\n+    }\n+\n+    \/**\n+     * Compares the specified object with this entry for equality.\n+     * Returns {@code true} if the given object is also a map entry and\n+     * the two entries' keys and values are equal.\n+     *\/\n+    @Override\n+    public boolean equals(Object o) {\n+        return o instanceof Map.Entry<?, ?> e\n+                && Objects.equals(key, e.getKey())\n+                && Objects.equals(value, e.getValue());\n+    }\n+\n+    private int hash(Object obj) {\n+        return (obj == null) ? 0 : obj.hashCode();\n+    }\n+\n+    \/**\n+     * Returns the hash code value for this map entry. The hash code\n+     * is {@code key.hashCode() ^ value.hashCode()}.\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return hash(key) ^ hash(value);\n+    }\n+\n+    \/**\n+     * Returns a String representation of this map entry.  This\n+     * implementation returns the string representation of this\n+     * entry's key followed by the equals character (\"{@code =}\")\n+     * followed by the string representation of this entry's value.\n+     *\n+     * @return a String representation of this map entry\n+     *\/\n+    @Override\n+    public String toString() {\n+        return key + \"=\" + value;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/NullableKeyValueHolder.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -26,2 +26,3 @@\n- * @bug 4904074 6328220 6330389\n- * @summary Basic tests for SimpleEntry, SimpleImmutableEntry\n+ * @bug 4904074 6328220 6330389 8308167\n+ * @modules java.base\/jdk.internal.util\n+ * @summary Basic tests for several Map.Entry implementations\n@@ -32,0 +33,1 @@\n+import jdk.internal.util.NullableKeyValueHolder;\n@@ -43,0 +45,3 @@\n+        testEntry(Map.entry(k,v));\n+        testEntry(Map.Entry.copyOf(Map.entry(k,v)));\n+        testEntry(new NullableKeyValueHolder(k,v));\n@@ -45,0 +50,1 @@\n+        testNullEntry(new NullableKeyValueHolder(null,null));\n@@ -55,0 +61,1 @@\n+        check(e.hashCode() == 101575); \/\/ hash(\"foo\") ^ hash(1L)\n@@ -73,0 +80,1 @@\n+        check(e.hashCode() == 0);\n","filename":"test\/jdk\/java\/util\/AbstractMap\/SimpleEntries.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -261,0 +261,10 @@\n+    @DataProvider(name=\"nullableEntries\")\n+    public Iterator<Object[]> nullableEntries() {\n+        return Arrays.asList(\n+            new Object[] { \"firstEntry\" },\n+            new Object[] { \"lastEntry\" },\n+            new Object[] { \"pollFirstEntry\" },\n+            new Object[] { \"pollLastEntry\" }\n+        ).iterator();\n+    }\n+\n@@ -522,0 +532,5 @@\n+    public void checkEntry(Map.Entry<String, Integer> entry, String key, Integer value) {\n+        assertEquals(entry.getKey(), key);\n+        assertEquals(entry.getValue(), value);\n+    }\n+\n@@ -892,0 +907,17 @@\n+\n+    @Test(dataProvider=\"nullableEntries\")\n+    public void testNullableKeyValue(String mode) {\n+        \/\/ TODO this relies on LHM to inherit SequencedMap default\n+        \/\/ methods which are actually being tested here.\n+        SequencedMap<String, Integer> map = new LinkedHashMap<>();\n+        map.put(null, 1);\n+        map.put(\"two\", null);\n+\n+        switch (mode) {\n+            case \"firstEntry\"     -> checkEntry(map.firstEntry(), null, 1);\n+            case \"lastEntry\"      -> checkEntry(map.lastEntry(), \"two\", null);\n+            case \"pollFirstEntry\" -> checkEntry(map.pollFirstEntry(), null, 1);\n+            case \"pollLastEntry\"  -> checkEntry(map.pollLastEntry(), \"two\", null);\n+            default               -> throw new AssertionError(\"illegal mode \" + mode);\n+        }\n+    }\n","filename":"test\/jdk\/java\/util\/SequencedCollection\/BasicMap.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"}]}