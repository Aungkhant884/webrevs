{"files":[{"patch":"@@ -285,0 +285,1 @@\n+                    tagLen = type.defTagLen;\n@@ -491,0 +492,2 @@\n+            \/\/ In earlier NSS versions, AES_GCM would report\n+            \/\/ CKR_BUFFER_TOO_SMALL error if minus tagLen\n@@ -492,1 +495,0 @@\n-            \/\/ PKCS11Exception: CKR_BUFFER_TOO_SMALL\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,2 +77,1 @@\n-            if ((direction != Cipher.ENCRYPT_MODE) &&\n-                    (direction != Cipher.DECRYPT_MODE)) {\n+            if (direction != Cipher.ENCRYPT_MODE) {\n@@ -80,1 +79,1 @@\n-                        \"Direction must be ENCRYPT_MODE or DECRYPT_MODE\");\n+                        \"Direction must be ENCRYPT_MODE\");\n@@ -113,23 +112,0 @@\n-        add(new TestData(\"RFC 7539 A.5 Sample Decryption\",\n-            \"1c9240a5eb55d38af333888604f6b5f0473917c1402b80099dca5cbc207075c0\",\n-            \"000000000102030405060708\",\n-            1, Cipher.DECRYPT_MODE,\n-            \"64a0861575861af460f062c79be643bd5e805cfd345cf389f108670ac76c8cb2\" +\n-            \"4c6cfc18755d43eea09ee94e382d26b0bdb7b73c321b0100d4f03b7f355894cf\" +\n-            \"332f830e710b97ce98c8a84abd0b948114ad176e008d33bd60f982b1ff37c855\" +\n-            \"9797a06ef4f0ef61c186324e2b3506383606907b6a7c02b0f9f6157b53c867e4\" +\n-            \"b9166c767b804d46a59b5216cde7a4e99040c5a40433225ee282a1b0a06c523e\" +\n-            \"af4534d7f83fa1155b0047718cbc546a0d072b04b3564eea1b422273f548271a\" +\n-            \"0bb2316053fa76991955ebd63159434ecebb4e466dae5a1073a6727627097a10\" +\n-            \"49e617d91d361094fa68f0ff77987130305beaba2eda04df997b714d6c6f2c29\" +\n-            \"a6ad5cb4022b02709beead9d67890cbb22392336fea1851f38\",\n-            \"f33388860000000000004e91\",\n-            \"496e7465726e65742d4472616674732061726520647261667420646f63756d65\" +\n-            \"6e74732076616c696420666f722061206d6178696d756d206f6620736978206d\" +\n-            \"6f6e74687320616e64206d617920626520757064617465642c207265706c6163\" +\n-            \"65642c206f72206f62736f6c65746564206279206f7468657220646f63756d65\" +\n-            \"6e747320617420616e792074696d652e20497420697320696e617070726f7072\" +\n-            \"6961746520746f2075736520496e7465726e65742d4472616674732061732072\" +\n-            \"65666572656e6365206d6174657269616c206f7220746f206369746520746865\" +\n-            \"6d206f74686572207468616e206173202fe2809c776f726b20696e2070726f67\" +\n-            \"726573732e2fe2809d\"));\n@@ -214,96 +190,0 @@\n-    \/**\n-     * Attempt to run two full decryption operations without an init in\n-     * between.\n-     *\/\n-    public static final TestMethod decTwiceNoInit = new TestMethod() {\n-\n-        @Override\n-        public boolean run(Provider p) {\n-            System.out.println(\"----- Decrypt 2nd time without init -----\");\n-            try {\n-                AlgorithmParameterSpec spec;\n-                Cipher cipher = Cipher.getInstance(CIPHER_ALGO, p);\n-                TestData testData = aeadTestList.get(1);\n-                spec = new IvParameterSpec(testData.nonce);\n-                SecretKey key = new SecretKeySpec(testData.key, KEY_ALGO);\n-\n-                \/\/ Initialize and encrypt\n-                cipher.init(testData.direction, key, spec);\n-                cipher.updateAAD(testData.aad);\n-                cipher.doFinal(testData.input);\n-                System.out.println(\"First decryption complete\");\n-\n-                \/\/ Now attempt to encrypt again without changing the key\/IV\n-                \/\/ This should fail.\n-                try {\n-                    cipher.updateAAD(testData.aad);\n-                } catch (IllegalStateException ise) {\n-                    \/\/ Do nothing, this is what we expected to happen\n-                }\n-                try {\n-                    cipher.doFinal(testData.input);\n-                    throw new RuntimeException(\n-                            \"Expected IllegalStateException not thrown\");\n-                } catch (IllegalStateException ise) {\n-                    \/\/ Do nothing, this is what we expected to happen\n-                }\n-            } catch (Exception exc) {\n-                System.out.println(\"Unexpected exception: \" + exc);\n-                exc.printStackTrace();\n-                return false;\n-            }\n-\n-            return true;\n-        }\n-    };\n-\n-    \/**\n-     * Perform an AEAD decryption with corrupted data so the tag does not\n-     * match.  Then attempt to reuse the cipher without initialization.\n-     *\/\n-    public static final TestMethod decFailNoInit = new TestMethod() {\n-        @Override\n-        public boolean run(Provider p) {\n-            System.out.println(\n-                    \"----- Fail decryption, try again with no init -----\");\n-            try {\n-                TestData testData = aeadTestList.get(1);\n-                AlgorithmParameterSpec spec =\n-                        new IvParameterSpec(testData.nonce);\n-                byte[] corruptInput = testData.input.clone();\n-                corruptInput[0]++;      \/\/ Corrupt the ciphertext\n-                SecretKey key = new SecretKeySpec(testData.key, KEY_ALGO);\n-                Cipher cipher = Cipher.getInstance(CIPHER_ALGO, p);\n-\n-                try {\n-                    \/\/ Initialize and encrypt\n-                    cipher.init(testData.direction, key, spec);\n-                    cipher.updateAAD(testData.aad);\n-                    cipher.doFinal(corruptInput);\n-                    throw new RuntimeException(\n-                            \"Expected AEADBadTagException not thrown\");\n-                } catch (AEADBadTagException abte) {\n-                    System.out.println(\"Expected decryption failure occurred\");\n-                }\n-\n-                \/\/ Make sure that despite the exception, the Cipher object is\n-                \/\/ not in a state that would leave it initialized and able\n-                \/\/ to process future decryption operations without init.\n-                try {\n-                    cipher.updateAAD(testData.aad);\n-                    cipher.doFinal(testData.input);\n-                    throw new RuntimeException(\n-                            \"Expected IllegalStateException not thrown\");\n-                } catch (IllegalStateException ise) {\n-                    \/\/ Do nothing, this is what we expected to happen\n-                }\n-            } catch (Exception exc) {\n-                System.out.println(\"Unexpected exception: \" + exc);\n-                exc.printStackTrace();\n-                return false;\n-            }\n-\n-            return true;\n-        }\n-    };\n-\n@@ -352,42 +232,0 @@\n-    \/**\n-     * Decrypt once successfully, then attempt to init with the same\n-     * key and nonce.\n-     *\/\n-    public static final TestMethod decTwiceInitSameParams = new TestMethod() {\n-        @Override\n-        public boolean run(Provider p) {\n-            System.out.println(\"----- Decrypt, then init with same params \" +\n-                    \"-----\");\n-            try {\n-                AlgorithmParameterSpec spec;\n-                Cipher cipher = Cipher.getInstance(CIPHER_ALGO, p);\n-                TestData testData = aeadTestList.get(1);\n-                spec = new IvParameterSpec(testData.nonce);\n-                SecretKey key = new SecretKeySpec(testData.key, KEY_ALGO);\n-\n-                \/\/ Initialize then decrypt\n-                cipher.init(testData.direction, key, spec);\n-                cipher.updateAAD(testData.aad);\n-                cipher.doFinal(testData.input);\n-                System.out.println(\"First decryption complete\");\n-\n-                \/\/ Initializing after the completed decryption with\n-                \/\/ the same key and nonce should fail.\n-                try {\n-                    cipher.init(testData.direction, key, spec);\n-                    throw new RuntimeException(\n-                            \"Expected IKE or IAPE not thrown\");\n-                } catch (InvalidKeyException |\n-                        InvalidAlgorithmParameterException e) {\n-                    \/\/ Do nothing, this is what we expected to happen\n-                }\n-            } catch (Exception exc) {\n-                System.out.println(\"Unexpected exception: \" + exc);\n-                exc.printStackTrace();\n-                return false;\n-            }\n-\n-            return true;\n-        }\n-    };\n-\n@@ -395,3 +233,1 @@\n-            Arrays.asList(noInitTest, encTwiceNoInit,\n-                    decTwiceNoInit, decFailNoInit, encTwiceInitSameParams,\n-                    decTwiceInitSameParams);\n+            Arrays.asList(noInitTest, encTwiceNoInit, encTwiceInitSameParams);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPolyNoReuse.java","additions":3,"deletions":167,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255410\n+ * @summary test the general SecretKeyFactory functionality\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ * @run main\/othervm TestGeneral\n+ *\/\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Provider;\n+import java.security.SecureRandom;\n+import java.util.Arrays;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+public class TestGeneral extends PKCS11Test {\n+\n+    private enum TestResult {\n+        PASS,\n+        FAIL,\n+        TBD \/\/ unused for now\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestGeneral(), args);\n+    }\n+\n+    private void test(String algorithm, SecretKey key, Provider p,\n+            TestResult expected) throws RuntimeException {\n+        System.out.println(\"Testing \" + algorithm + \" SKF from \" + p.getName());\n+        SecretKeyFactory skf;\n+        try {\n+            skf = SecretKeyFactory.getInstance(algorithm, p);\n+        } catch (NoSuchAlgorithmException e) {\n+            System.out.println(\"Not supported, skipping: \" + e);\n+            return;\n+        }\n+        try {\n+            SecretKey key2 = skf.translateKey(key);\n+            if (expected == TestResult.FAIL) {\n+                throw new RuntimeException(\"translateKey() should FAIL\");\n+            }\n+            System.out.println(\"=> translated key\");\n+            if (!key2.getAlgorithm().equalsIgnoreCase(algorithm)) {\n+                throw new RuntimeException(\"translated key algorithm mismatch\");\n+            }\n+            System.out.println(\"=> checked key algorithm\");\n+\n+            \/\/ proceed to check encodings if format match\n+            if (key2.getFormat().equalsIgnoreCase(key.getFormat())) {\n+                if (key2.getEncoded() != null &&\n+                        !Arrays.equals(key.getEncoded(), key2.getEncoded())) {\n+                    throw new RuntimeException(\n+                            \"translated key encoding mismatch\");\n+                }\n+                System.out.println(\"=> checked key format and encoding\");\n+            }\n+        } catch (Exception e) {\n+            if (expected == TestResult.PASS) {\n+                e.printStackTrace();\n+                throw new RuntimeException(\"translateKey() should pass\", e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+\n+        byte[] rawBytes = new byte[32];\n+        new SecureRandom().nextBytes(rawBytes);\n+\n+        SecretKey aes_128Key = new SecretKeySpec(rawBytes, 0, 16, \"AES\");\n+        SecretKey aes_256Key = new SecretKeySpec(rawBytes, 0, 32, \"AES\");\n+        SecretKey bf_128Key = new SecretKeySpec(rawBytes, 0, 16, \"Blowfish\");\n+        SecretKey cc20Key = new SecretKeySpec(rawBytes, 0, 32, \"ChaCha20\");\n+\n+        \/\/ fixed key length\n+        test(\"AES\", aes_128Key, p, TestResult.PASS);\n+        test(\"AES\", aes_256Key, p, TestResult.PASS);\n+        test(\"AES\", cc20Key, p, TestResult.FAIL);\n+\n+        test(\"ChaCha20\", aes_128Key, p, TestResult.FAIL);\n+        test(\"ChaCha20\", aes_256Key, p, TestResult.FAIL);\n+        test(\"ChaCha20\", cc20Key, p, TestResult.PASS);\n+\n+        \/\/ variable key length\n+        \/\/ Different PKCS11 impls may have different ranges\n+        \/\/ of supported key sizes for variable-key-length\n+        \/\/ algorithms.\n+        test(\"Blowfish\", aes_128Key, p, TestResult.FAIL);\n+        test(\"Blowfish\", cc20Key, p, TestResult.FAIL);\n+        test(\"Blowfish\", bf_128Key, p, TestResult.PASS);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/SecretKeyFactory\/TestGeneral.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"}]}