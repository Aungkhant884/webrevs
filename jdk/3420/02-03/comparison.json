{"files":[{"patch":"@@ -208,1 +208,1 @@\n-        AlgorithmParameterSpec spec;\n+        AlgorithmParameterSpec spec = null;\n@@ -217,1 +217,3 @@\n-                spec = new GCMParameterSpec(tagLen << 3, iv);\n+                if (iv != null) {\n+                    spec = new GCMParameterSpec(tagLen << 3, iv);\n+                }\n@@ -225,1 +227,3 @@\n-                spec = new IvParameterSpec(iv);\n+                if (iv != null) {\n+                    spec = new IvParameterSpec(iv);\n+                }\n@@ -230,9 +234,11 @@\n-        try {\n-            AlgorithmParameters params =\n-                AlgorithmParameters.getInstance(apAlgo);\n-            params.init(spec);\n-            return params;\n-        } catch (GeneralSecurityException e) {\n-            \/\/ NoSuchAlgorithmException, NoSuchProviderException\n-            \/\/ InvalidParameterSpecException\n-            throw new ProviderException(\"Could not encode parameters\", e);\n+        if (spec != null) {\n+            try {\n+                AlgorithmParameters params =\n+                    AlgorithmParameters.getInstance(apAlgo);\n+                params.init(spec);\n+                return params;\n+            } catch (GeneralSecurityException e) {\n+                \/\/ NoSuchAlgorithmException, NoSuchProviderException\n+                \/\/ InvalidParameterSpecException\n+                throw new ProviderException(\"Could not encode parameters\", e);\n+            }\n@@ -240,0 +246,1 @@\n+        return null;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.security.GeneralSecurityException;\n@@ -39,0 +40,1 @@\n+import java.security.spec.InvalidParameterSpecException;\n@@ -62,0 +64,1 @@\n+    private static final SecureRandom RAND = new SecureRandom();\n@@ -78,0 +81,2 @@\n+        testGetIV();\n+        testInterop(\"SunJCE\");\n@@ -117,5 +122,0 @@\n-        AlgorithmParameters algorithmParameters =\n-                AlgorithmParameters.getInstance(ALGO);\n-        algorithmParameters.init(\n-                new byte[] { 4, 12, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8 });\n-\n@@ -125,2 +125,5 @@\n-        Cipher.getInstance(ALGO, p).init(opMode, KEY, IV_PARAM_SPEC,\n-                new SecureRandom());\n+        Cipher c = Cipher.getInstance(ALGO, p);\n+        c.init(opMode, KEY, IV_PARAM_SPEC, RAND);\n+        AlgorithmParameters params = c.getParameters();\n+        Cipher.getInstance(ALGO, p).init(opMode, KEY, params, RAND);\n+\n@@ -134,2 +137,0 @@\n-        Cipher.getInstance(ALGO, p).init(opMode, KEY, algorithmParameters,\n-            new SecureRandom());\n@@ -188,2 +189,2 @@\n-        Cipher ccp = Cipher.getInstance(ALGO, p);\n-        if (ccp.getBlockSize() != 0) {\n+        Cipher c = Cipher.getInstance(ALGO, p);\n+        if (c.getBlockSize() != 0) {\n@@ -194,0 +195,104 @@\n+    private static void testGetIV() throws Exception {\n+        testGetIV(Cipher.ENCRYPT_MODE);\n+        testGetIV(Cipher.DECRYPT_MODE);\n+    }\n+\n+    private static void testGetIV(int opMode) throws Exception {\n+        System.out.println(\"== getIv (\" + getOpModeName(opMode) + \") ==\");\n+\n+        try {\n+            Cipher.getInstance(ALGO, p).getIV();\n+            Cipher.getInstance(ALGO, p).getParameters();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Should not throw ex\", e);\n+        }\n+        \/\/ first init w\/ key only\n+        AlgorithmParameters params = null;\n+        for (int i = 0; i < 6; i++) {\n+            System.out.println(\"IV test# \" + i);\n+            Cipher c = Cipher.getInstance(ALGO, p);\n+            byte[] expectedIV = NONCE;\n+            try {\n+                switch (i) {\n+                case 0 -> {\n+                    c.init(opMode, KEY);\n+                    expectedIV = null; \/\/ randomly-generated\n+                }\n+                case 1 -> {\n+                    c.init(opMode, KEY, RAND);\n+                    expectedIV = null; \/\/ randomly-generated\n+                }\n+                case 2 -> {\n+                    c.init(opMode, KEY, IV_PARAM_SPEC);\n+                    params = c.getParameters();\n+                    if (params == null) {\n+                        throw new RuntimeException(\"Params should not be null\");\n+                    }\n+                }\n+                case 3 -> c.init(opMode, KEY, IV_PARAM_SPEC, RAND);\n+                case 4 -> c.init(opMode, KEY, params);\n+                case 5 -> c.init(opMode, KEY, params, RAND);\n+                }\n+                checkIV(c, expectedIV);\n+                System.out.println(\"=> Passed\");\n+            } catch (GeneralSecurityException e) {\n+                if (opMode == Cipher.DECRYPT_MODE && i < 2) {\n+                    System.out.println(\"=> Passed: Expected Ex thrown\");\n+                } else {\n+                    throw new RuntimeException(\"Should not throw ex\", e);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void checkIV(Cipher c, byte[] expectedIv) {\n+        \/\/ the specified cipher has been initialized; the returned IV and\n+        \/\/ AlgorithmParameters object should be non-null\n+        byte[] iv = c.getIV();\n+        AlgorithmParameters params = c.getParameters();\n+        \/\/ fail if either is null\n+        if (iv == null || params == null) {\n+            throw new RuntimeException(\"getIV()\/getParameters() should \" +\n+                    \"not return null\");\n+        }\n+\n+        \/\/ check iv matches if not null\n+        if (expectedIv != null && !Arrays.equals(expectedIv, iv)) {\n+            throw new RuntimeException(\"IV should match expected value\");\n+        }\n+\n+        try {\n+            byte[] iv2 = params.getParameterSpec(IvParameterSpec.class).getIV();\n+            if (!Arrays.equals(iv, iv2)) {\n+                throw new RuntimeException(\"IV values should be consistent\");\n+            }\n+        } catch (InvalidParameterSpecException ipe) {\n+            \/\/ should never happen\n+            throw new AssertionError();\n+        }\n+    }\n+\n+    private static void testInterop(String interopProv) throws Exception {\n+        testInterop(Cipher.getInstance(ALGO, p),\n+                Cipher.getInstance(ALGO, interopProv));\n+        testInterop(Cipher.getInstance(ALGO, interopProv),\n+                Cipher.getInstance(ALGO, p));\n+    }\n+\n+    private static void testInterop(Cipher encCipher, Cipher decCipher)\n+            throws Exception {\n+        System.out.println(\"Interop: \" + encCipher.getProvider().getName() +\n+                \" -> \" + encCipher.getProvider().getName());\n+        byte[] pt = HexFormat.of().parseHex(\"012345678901234567890123456789\");\n+        encCipher.init(Cipher.ENCRYPT_MODE, KEY);\n+        byte[] ct = encCipher.doFinal(pt);\n+        decCipher.init(Cipher.DECRYPT_MODE, KEY, encCipher.getParameters());\n+        byte[] pt2 = decCipher.doFinal(ct);\n+        if (!Arrays.equals(pt, pt2)) {\n+            System.out.println(\"HexDump\/pt: \" + HexFormat.of().formatHex(pt));\n+            System.out.println(\"HexDump\/pt2: \" + HexFormat.of().formatHex(pt2));\n+            throw new RuntimeException(\"Recovered data should match\");\n+        }\n+        System.out.println(\"=> Passed\");\n+    }\n+\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPoly.java","additions":116,"deletions":11,"binary":false,"changes":127,"status":"modified"}]}