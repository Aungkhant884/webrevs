{"files":[{"patch":"@@ -45,1 +45,1 @@\n- * AES with GCM mode.\n+ * AES cipher in GCM mode and CHACHA20-POLY1305 cipher.\n@@ -48,6 +48,4 @@\n- * its own padding impl. In addition, NSS CKM_AES_GCM only supports single-part\n- * encryption\/decryption, thus the current impl uses PKCS#11 C_Encrypt\/C_Decrypt\n- * calls and buffers data until doFinal is called.\n- *\n- * Note that PKCS#11 standard currently only supports GCM and CCM AEAD modes.\n- * There are no provisions for other AEAD modes yet.\n+ * its own padding impl. In addition, some vendors such as NSS may not support\n+ * multi-part encryption\/decryption for AEAD cipher algorithms, thus the\n+ * current impl uses PKCS#11 C_Encrypt\/C_Decrypt calls and buffers data until\n+ * doFinal is called.\n@@ -59,2 +57,4 @@\n-    \/\/ mode constant for GCM mode\n-    private static final int MODE_GCM = 10;\n+    \/\/ supported AEAD algorithms\/transformations\n+    private enum Transformation {\n+        AES_GCM(\"AES\", \"GCM\", \"NOPADDING\", 16, 16),\n+        CHACHA20_POLY1305(\"CHACHA20\", \"NONE\", \"NOPADDING\", 12, 16);\n@@ -62,3 +62,5 @@\n-    \/\/ default constants for GCM\n-    private static final int GCM_DEFAULT_TAG_LEN = 16;\n-    private static final int GCM_DEFAULT_IV_LEN = 16;\n+        final String keyAlgo;\n+        final String mode;\n+        final String padding;\n+        final int defIvLen; \/\/ in bytes\n+        final int defTagLen; \/\/ in bytes\n@@ -66,1 +68,9 @@\n-    private static final String ALGO = \"AES\";\n+        Transformation(String keyAlgo, String mode, String padding,\n+                int defIvLen, int defTagLen) {\n+            this.keyAlgo = keyAlgo;\n+            this.mode = mode;\n+            this.padding = padding;\n+            this.defIvLen = defIvLen;\n+            this.defTagLen = defTagLen;\n+        }\n+    }\n@@ -74,2 +84,2 @@\n-    \/\/ mode, one of MODE_* above\n-    private final int blockMode;\n+    \/\/ type of this AEAD cipher, one of Transformation enum above\n+    private final Transformation type;\n@@ -77,1 +87,1 @@\n-    \/\/ acceptable key size, -1 if more than 1 key sizes are accepted\n+    \/\/ acceptable key size in bytes, -1 if more than 1 key sizes are accepted\n@@ -114,11 +124,38 @@\n-        if (algoParts.length != 3) {\n-            throw new ProviderException(\"Unsupported Transformation format: \" +\n-                    algorithm);\n-        }\n-        if (!algoParts[0].startsWith(\"AES\")) {\n-            throw new ProviderException(\"Only support AES for AEAD cipher mode\");\n-        }\n-        int index = algoParts[0].indexOf('_');\n-        if (index != -1) {\n-            \/\/ should be well-formed since we specify what we support\n-            fixedKeySize = Integer.parseInt(algoParts[0].substring(index+1)) >> 3;\n+        if (algoParts[0].startsWith(\"AES\")) {\n+            \/\/ for AES_GCM, need 3 parts\n+            if (algoParts.length != 3) {\n+                throw new AssertionError(\"Invalid Transformation format: \" +\n+                        algorithm);\n+            }\n+            int index = algoParts[0].indexOf('_');\n+            if (index != -1) {\n+                \/\/ should be well-formed since we specify what we support\n+                fixedKeySize = Integer.parseInt(algoParts[0].substring(index+1)) >> 3;\n+            } else {\n+                fixedKeySize = -1;\n+            }\n+            this.type = Transformation.AES_GCM;\n+            engineSetMode(algoParts[1]);\n+            try {\n+                engineSetPadding(algoParts[2]);\n+            } catch (NoSuchPaddingException e) {\n+                throw new NoSuchAlgorithmException();\n+            }\n+        } else if (algoParts[0].equals(\"ChaCha20-Poly1305\")) {\n+            fixedKeySize = 32;\n+            this.type = Transformation.CHACHA20_POLY1305;\n+            if (algoParts.length > 3) {\n+                throw new AssertionError(\n+                        \"Invalid Transformation format: \" + algorithm);\n+            } else {\n+                if (algoParts.length > 1) {\n+                    engineSetMode(algoParts[1]);\n+                }\n+                try {\n+                    if (algoParts.length > 2) {\n+                        engineSetPadding(algoParts[2]);\n+                    }\n+                } catch (NoSuchPaddingException e) {\n+                    throw new NoSuchAlgorithmException();\n+                }\n+            }\n@@ -126,5 +163,1 @@\n-            fixedKeySize = -1;\n-        }\n-        this.blockMode = parseMode(algoParts[1]);\n-        if (!algoParts[2].equals(\"NoPadding\")) {\n-            throw new ProviderException(\"Only NoPadding is supported for AEAD cipher mode\");\n+            throw new AssertionError(\"Unsupported transformation \" + algorithm);\n@@ -134,0 +167,1 @@\n+    @Override\n@@ -135,11 +169,1 @@\n-        \/\/ Disallow change of mode for now since currently it's explicitly\n-        \/\/ defined in transformation strings\n-        throw new NoSuchAlgorithmException(\"Unsupported mode \" + mode);\n-    }\n-\n-    private int parseMode(String mode) throws NoSuchAlgorithmException {\n-        mode = mode.toUpperCase(Locale.ENGLISH);\n-        int result;\n-        if (mode.equals(\"GCM\")) {\n-            result = MODE_GCM;\n-        } else {\n+        if (!mode.toUpperCase(Locale.ENGLISH).equals(type.mode)) {\n@@ -148,1 +172,0 @@\n-        return result;\n@@ -152,0 +175,1 @@\n+    @Override\n@@ -154,3 +178,3 @@\n-        \/\/ Disallow change of padding for now since currently it's explicitly\n-        \/\/ defined in transformation strings\n-        throw new NoSuchPaddingException(\"Unsupported padding \" + padding);\n+        if (!padding.toUpperCase(Locale.ENGLISH).equals(type.padding)) {\n+            throw new NoSuchPaddingException(\"Unsupported padding \" + padding);\n+        }\n@@ -160,0 +184,1 @@\n+    @Override\n@@ -161,1 +186,5 @@\n-        return 16; \/\/ constant; only AES is supported\n+        return switch (type) {\n+            case AES_GCM -> 16;\n+            case CHACHA20_POLY1305 -> 0;\n+            default -> throw new AssertionError(\"Unsupported type \" + type);\n+        };\n@@ -165,0 +194,1 @@\n+    @Override\n@@ -170,0 +200,1 @@\n+    @Override\n@@ -176,10 +207,22 @@\n-        if (encrypt && iv == null && tagLen == -1) {\n-            switch (blockMode) {\n-                case MODE_GCM:\n-                    iv = new byte[GCM_DEFAULT_IV_LEN];\n-                    tagLen = GCM_DEFAULT_TAG_LEN;\n-                    break;\n-                default:\n-                    throw new ProviderException(\"Unsupported mode\");\n-            }\n-            random.nextBytes(iv);\n+        String apAlgo;\n+        AlgorithmParameterSpec spec;\n+        switch (type) {\n+            case AES_GCM:\n+                apAlgo = \"GCM\";\n+                if (encrypt && iv == null && tagLen == -1) {\n+                    iv = new byte[type.defIvLen];\n+                    tagLen = type.defTagLen;\n+                    random.nextBytes(iv);\n+                }\n+                spec = new GCMParameterSpec(tagLen << 3, iv);\n+            break;\n+            case CHACHA20_POLY1305:\n+                if (encrypt && iv == null) {\n+                    iv = new byte[type.defIvLen];\n+                    random.nextBytes(iv);\n+                }\n+                apAlgo = \"ChaCha20-Poly1305\";\n+                spec = new IvParameterSpec(iv);\n+            break;\n+            default:\n+                throw new AssertionError(\"Unsupported type \" + type);\n@@ -188,10 +231,0 @@\n-            AlgorithmParameterSpec spec;\n-            String apAlgo;\n-            switch (blockMode) {\n-                case MODE_GCM:\n-                    apAlgo = \"GCM\";\n-                    spec = new GCMParameterSpec(tagLen << 3, iv);\n-                    break;\n-                default:\n-                    throw new ProviderException(\"Unsupported mode\");\n-            }\n@@ -234,6 +267,18 @@\n-        if (params != null) {\n-            switch (blockMode) {\n-            case MODE_GCM:\n-                if (!(params instanceof GCMParameterSpec)) {\n-                    throw new InvalidAlgorithmParameterException\n-                        (\"Only GCMParameterSpec is supported\");\n+        switch (type) {\n+            case AES_GCM:\n+                if (params != null) {\n+                    if (!(params instanceof GCMParameterSpec)) {\n+                        throw new InvalidAlgorithmParameterException\n+                                (\"Only GCMParameterSpec is supported\");\n+                    }\n+                    ivValue = ((GCMParameterSpec) params).getIV();\n+                    tagLen = ((GCMParameterSpec) params).getTLen() >> 3;\n+                }\n+            break;\n+            case CHACHA20_POLY1305:\n+                if (params != null) {\n+                    if (!(params instanceof IvParameterSpec)) {\n+                        throw new InvalidAlgorithmParameterException\n+                                (\"Only IvParameterSpec is supported\");\n+                    }\n+                    ivValue = ((IvParameterSpec) params).getIV();\n@@ -241,2 +286,0 @@\n-                ivValue = ((GCMParameterSpec) params).getIV();\n-                tagLen = ((GCMParameterSpec) params).getTLen() >> 3;\n@@ -245,3 +288,2 @@\n-                throw new ProviderException(\"Unsupported mode\");\n-            }\n-        }\n+                throw new AssertionError(\"Unsupported type \" + type);\n+        };\n@@ -263,2 +305,2 @@\n-                switch (blockMode) {\n-                    case MODE_GCM:\n+                switch (type) {\n+                    case AES_GCM:\n@@ -268,0 +310,4 @@\n+                    case CHACHA20_POLY1305:\n+                        paramSpec =\n+                            params.getParameterSpec(IvParameterSpec.class);\n+                        break;\n@@ -269,1 +315,1 @@\n-                        throw new ProviderException(\"Unsupported mode\");\n+                        throw new AssertionError(\"Unsupported type \" + type);\n@@ -288,1 +334,2 @@\n-        P11Key newKey = P11SecretKeyFactory.convertKey(token, key, ALGO);\n+        P11Key newKey = P11SecretKeyFactory.convertKey(token, key,\n+                type.keyAlgo);\n@@ -295,2 +342,2 @@\n-                    throw new InvalidAlgorithmParameterException\n-                        (\"Cannot reuse iv for GCM encryption\");\n+                    throw new InvalidAlgorithmParameterException(\n+                            \"Cannot reuse the same key and iv pair\");\n@@ -312,0 +359,1 @@\n+\n@@ -314,3 +362,3 @@\n-            switch (blockMode) {\n-                case MODE_GCM:\n-                    iv = new byte[GCM_DEFAULT_IV_LEN];\n+            switch (type) {\n+                case AES_GCM:\n+                    iv = new byte[type.defIvLen];\n@@ -318,1 +366,6 @@\n-                    tagLen = GCM_DEFAULT_TAG_LEN;\n+                    tagLen = type.defTagLen;\n+                    break;\n+                case CHACHA20_POLY1305:\n+                    iv = new byte[type.defIvLen];\n+                    this.random.nextBytes(iv);\n+                    tagLen = type.defTagLen;\n@@ -321,1 +374,1 @@\n-                    throw new ProviderException(\"Unsupported mode\");\n+                    throw new AssertionError(\"Unsupported type \" + type);\n@@ -385,1 +438,1 @@\n-                (\"Must use either different key or iv for GCM encryption\");\n+                (\"Must use either different key or iv\");\n@@ -395,2 +448,2 @@\n-            switch (blockMode) {\n-                case MODE_GCM:\n+            switch (type) {\n+                case AES_GCM:\n@@ -400,0 +453,4 @@\n+                case CHACHA20_POLY1305:\n+                    mechWithParams = new CK_MECHANISM(mechanism,\n+                        new CK_SALSA20_CHACHA20_POLY1305_PARAMS(iv, aad));\n+                    break;\n@@ -401,1 +458,1 @@\n-                    throw new ProviderException(\"Unsupported mode: \" + blockMode);\n+                    throw new AssertionError(\"Unsupported type: \" + type);\n@@ -434,0 +491,1 @@\n+            if (type == Transformation.CHACHA20_POLY1305) {\n@@ -435,1 +493,2 @@\n-            \/\/result -= tagLen;\n+                result -= tagLen;\n+            }\n@@ -437,1 +496,1 @@\n-        return result;\n+        return (result > 0? result : 0);\n@@ -495,1 +554,1 @@\n-                (\"Must use either different key or iv for GCM encryption\");\n+                (\"Must use either different key or iv for encryption\");\n@@ -598,0 +657,1 @@\n+\n@@ -715,0 +775,1 @@\n+            inBuffer.position(inBuffer.limit());\n@@ -751,2 +812,2 @@\n-            throw (BadPaddingException)\n-                    (new BadPaddingException(e.toString()).initCause(e));\n+            throw (AEADBadTagException)\n+                    (new AEADBadTagException(e.toString()).initCause(e));\n@@ -775,1 +836,1 @@\n-                (token, key, ALGO).length();\n+                (token, key, type.keyAlgo).length();\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":161,"deletions":100,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -239,0 +239,4 @@\n+        case (int)CKM_CHACHA20_KEY_GEN:\n+            keySize = 256;\n+            keyType = CKK_CHACHA20;\n+            break;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyGenerator.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+        addKeyType(\"ChaCha20\", CKK_CHACHA20);\n@@ -240,0 +241,4 @@\n+                case (int)CKK_CHACHA20:\n+                    keyLength = P11KeyGenerator.checkKeySize(\n+                        CKM_CHACHA20_KEY_GEN, n, token);\n+                    break;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11SecretKeyFactory.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,2 @@\n+import com.sun.crypto.provider.ChaCha20Poly1305Parameters;\n+\n@@ -609,0 +611,2 @@\n+        d(KG,  \"ChaCha20\",      P11KeyGenerator,\n+                m(CKM_CHACHA20_KEY_GEN));\n@@ -658,0 +662,4 @@\n+        dA(AGP, \"ChaCha20-Poly1305\",\n+                \"com.sun.crypto.provider.ChaCha20Poly1305Parameters\",\n+                m(CKM_CHACHA20_POLY1305));\n+\n@@ -674,0 +682,2 @@\n+        d(SKF, \"ChaCha20\",      P11SecretKeyFactory,\n+                m(CKM_CHACHA20, CKM_CHACHA20_POLY1305));\n@@ -735,0 +745,3 @@\n+        dA(CIP, \"ChaCha20-Poly1305\",            P11AEADCipher,\n+                m(CKM_CHACHA20_POLY1305));\n+\n@@ -1159,1 +1172,2 @@\n-                } else if (algorithm.endsWith(\"GCM\/NoPadding\")) {\n+                } else if (algorithm.endsWith(\"GCM\/NoPadding\") ||\n+                           algorithm.startsWith(\"ChaCha20-Poly1305\")) {\n@@ -1212,0 +1226,2 @@\n+                } else if (algorithm == \"ChaCha20-Poly1305\") {\n+                    return new ChaCha20Poly1305Parameters(); \/\/ from SunJCE\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,0 +158,5 @@\n+    public CK_MECHANISM(long mechanism,\n+            CK_SALSA20_CHACHA20_POLY1305_PARAMS params) {\n+        init(mechanism, params);\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_MECHANISM.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.pkcs11.wrapper;\n+\n+import java.util.HexFormat;\n+\n+\/**\n+ * This class represents the necessary parameters required by the\n+ * CKM_CHACHA20_POLY1305 and CKM_SALSA20_POLY1305 mechanisms as defined in\n+ * CK_SALSA20_CHACHA20_POLY1305_PARAMS structure.<p>\n+ * <B>PKCS#11 structure:<\/B>\n+ * <PRE>\n+ * typedef struct CK_SALSA20_CHACHA20_POLY1305_PARAMS {\n+ *   CK_BYTE_PTR  pNonce;\n+ *   CK_ULONG     ulNonceLen;\n+ *   CK_BYTE_PTR  pAAD;\n+ *   CK_ULONG     ulAADLen;\n+ * } CK_SALSA20_CHACHA20_POLY1305_PARAMS;\n+ * <\/PRE>\n+ *\n+ * @since   17\n+ *\/\n+public class CK_SALSA20_CHACHA20_POLY1305_PARAMS {\n+\n+    private final byte[] nonce;\n+    private final byte[] aad;\n+\n+    public CK_SALSA20_CHACHA20_POLY1305_PARAMS(byte[] nonce, byte[] aad) {\n+        this.nonce = nonce;\n+        this.aad = aad;\n+    }\n+\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"Nonce: \");\n+        sb.append((nonce == null? \"null\" :\n+            \"0x\" + HexFormat.of().formatHex(nonce)));\n+        sb.append(Constants.NEWLINE);\n+        sb.append(Constants.INDENT);\n+        sb.append(\"AAD: \");\n+        sb.append((aad == null? \"null\" : \"0x\" + HexFormat.of().formatHex(aad)));\n+        return sb.toString();\n+    }\n+}\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_SALSA20_CHACHA20_POLY1305_PARAMS.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1162,0 +1162,67 @@\n+\/*\n+ * converts the Java CK_SALSA20_CHACHA20_POLY1305_PARAMS object to a\n+ * CK_SALSA20_CHACHA20_POLY1305_PARAMS pointer\n+ *\n+ * @param env - used to call JNI functions to get the Java classes and objects\n+ * @param jParam - the Java CK_SALSA20_CHACHA20_POLY1305_PARAMS object to\n+ *         convert\n+ * @param pLength - length of the allocated memory of the returned pointer\n+ * @return pointer to the new CK_SALSA20_CHACHA20_POLY1305_PARAMS structure\n+ *\/\n+CK_SALSA20_CHACHA20_POLY1305_PARAMS_PTR\n+jSalsaChaChaPolyParamsToCKSalsaChaChaPolyParamPtr(\n+        JNIEnv *env, jobject jParam, CK_ULONG *pLength)\n+{\n+    CK_SALSA20_CHACHA20_POLY1305_PARAMS_PTR ckParamPtr;\n+    jclass jParamsClass;\n+    jfieldID fieldID;\n+    jobject jNonce, jAad;\n+\n+    if (pLength != NULL) {\n+        *pLength = 0;\n+    }\n+\n+    \/\/ retrieve java values\n+    jParamsClass = (*env)->FindClass(env,\n+            CLASS_SALSA20_CHACHA20_POLY1305_PARAMS);\n+    if (jParamsClass == NULL) { return NULL; }\n+    if (!(*env)->IsInstanceOf(env, jParam, jParamsClass)) {\n+        return NULL;\n+    }\n+    fieldID = (*env)->GetFieldID(env, jParamsClass, \"nonce\", \"[B\");\n+    if (fieldID == NULL) { return NULL; }\n+    jNonce = (*env)->GetObjectField(env, jParam, fieldID);\n+    fieldID = (*env)->GetFieldID(env, jParamsClass, \"aad\", \"[B\");\n+    if (fieldID == NULL) { return NULL; }\n+    jAad = (*env)->GetObjectField(env, jParam, fieldID);\n+    \/\/ allocate memory for CK_SALSA20_CHACHA20_POLY1305_PARAMS pointer\n+    ckParamPtr = calloc(1, sizeof(CK_SALSA20_CHACHA20_POLY1305_PARAMS));\n+    if (ckParamPtr == NULL) {\n+        throwOutOfMemoryError(env, 0);\n+        return NULL;\n+    }\n+\n+    \/\/ populate using java values\n+    jByteArrayToCKByteArray(env, jNonce, &(ckParamPtr->pNonce),\n+            &(ckParamPtr->ulNonceLen));\n+    if ((*env)->ExceptionCheck(env)) {\n+        goto cleanup;\n+    }\n+\n+    jByteArrayToCKByteArray(env, jAad, &(ckParamPtr->pAAD),\n+            &(ckParamPtr->ulAADLen));\n+    if ((*env)->ExceptionCheck(env)) {\n+        goto cleanup;\n+    }\n+\n+    if (pLength != NULL) {\n+        *pLength = sizeof(CK_SALSA20_CHACHA20_POLY1305_PARAMS);\n+    }\n+    return ckParamPtr;\n+cleanup:\n+    free(ckParamPtr->pNonce);\n+    free(ckParamPtr->pAAD);\n+    free(ckParamPtr);\n+    return NULL;\n+}\n+\n@@ -1440,0 +1507,5 @@\n+       case CKM_CHACHA20_POLY1305:\n+            ckpParamPtr =\n+                    jSalsaChaChaPolyParamsToCKSalsaChaChaPolyParamPtr(env,\n+                    jParam, ckpLength);\n+            break;\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_convert.c","additions":73,"deletions":1,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -326,0 +326,5 @@\n+                 case CKM_CHACHA20_POLY1305:\n+                     TRACE0(\"[ CK_SALSA20_CHACHA20_POLY1305_PARAMS ]\\n\");\n+                     free(((CK_SALSA20_CHACHA20_POLY1305_PARAMS*)tmp)->pNonce);\n+                     free(((CK_SALSA20_CHACHA20_POLY1305_PARAMS*)tmp)->pAAD);\n+                     break;\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_util.c","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -259,0 +259,2 @@\n+#define CLASS_SALSA20_CHACHA20_POLY1305_PARAMS \\\n+        \"sun\/security\/pkcs11\/wrapper\/CK_SALSA20_CHACHA20_POLY1305_PARAMS\"\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/pkcs11wrapper.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255410\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ * @run main\/othervm TestChaChaPoly\n+ * @summary test for PKCS#11 ChaCha20-Poly1305 Cipher.\n+ *\/\n+\n+import java.nio.ByteBuffer;\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Provider;\n+import java.security.SecureRandom;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.ChaCha20ParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.NoSuchPaddingException;\n+\n+import jdk.test.lib.Utils;\n+\n+public class TestChaChaPoly extends PKCS11Test {\n+\n+    private static final byte[] NONCE\n+            = HexFormat.of().parseHex(\"012345670123456701234567\");\n+    private static final SecretKeySpec KEY = new SecretKeySpec(\n+            HexFormat.of().parseHex(\"0123456701234567012345670123456701234567012345670123456701234567\"),\n+            \"ChaCha20\");\n+    private static final ChaCha20ParameterSpec CHACHA20_PARAM_SPEC\n+            = new ChaCha20ParameterSpec(NONCE, 0);\n+    private static final IvParameterSpec IV_PARAM_SPEC\n+            = new IvParameterSpec(NONCE);\n+    private static final String ALGO = \"ChaCha20-Poly1305\";\n+    private static Provider p;\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        System.out.println(\"Testing \" + p.getName());\n+        try {\n+            Cipher.getInstance(ALGO, p);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            System.out.println(\"Skip; no support for \" + ALGO);\n+            return;\n+        }\n+        this.p = p;\n+        testTransformations();\n+        testInit();\n+        testAEAD();\n+        testGetBlockSize();\n+    }\n+\n+    private static void testTransformations() throws Exception {\n+        System.out.println(\"== transformations ==\");\n+\n+        checkTransformation(p, ALGO, true);\n+        checkTransformation(p, ALGO + \"\/None\/NoPadding\", true);\n+        checkTransformation(p, ALGO + \"\/ECB\/NoPadding\", false);\n+        checkTransformation(p, ALGO + \"\/None\/PKCS5Padding\", false);\n+    }\n+\n+    private static void checkTransformation(Provider p, String t,\n+            boolean expected) throws Exception {\n+        try {\n+            Cipher.getInstance(t, p);\n+            if (!expected) {\n+                throw new RuntimeException( \"Should reject transformation: \" +\n+                        t);\n+            } else {\n+                System.out.println(\"Accepted transformation: \" + t);\n+            }\n+        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {\n+            if (!expected) {\n+                System.out.println(\"Rejected transformation: \" + t);\n+            } else {\n+                throw new RuntimeException(\"Should accept transformation: \" +\n+                        t, e);\n+            }\n+        }\n+    }\n+\n+    private static void testInit() throws Exception {\n+        testInitOnCrypt(Cipher.ENCRYPT_MODE);\n+        testInitOnCrypt(Cipher.DECRYPT_MODE);\n+    }\n+\n+    private static void testInitOnCrypt(int opMode) throws Exception {\n+        System.out.println(\"== init (\" + getOpModeName(opMode) + \") ==\");\n+\n+        AlgorithmParameters algorithmParameters =\n+                AlgorithmParameters.getInstance(ALGO);\n+        algorithmParameters.init(\n+                new byte[] { 4, 12, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8 });\n+\n+        \/\/ Need to acquire new Cipher object as ChaCha20-Poly1305 cipher\n+        \/\/ disallow reusing the same key and iv pair\n+        Cipher.getInstance(ALGO, p).init(opMode, KEY, IV_PARAM_SPEC);\n+        Cipher.getInstance(ALGO, p).init(opMode, KEY, IV_PARAM_SPEC,\n+                new SecureRandom());\n+        try {\n+            \/\/ try with invalid param\n+            Cipher.getInstance(ALGO, p).init(opMode, KEY, CHACHA20_PARAM_SPEC);\n+            throw new RuntimeException(\"Should reject non-IvparameterSpec\");\n+        } catch (InvalidAlgorithmParameterException e) {\n+            System.out.println(\"Expected IAPE - \" + e);\n+        }\n+        Cipher.getInstance(ALGO, p).init(opMode, KEY, algorithmParameters,\n+            new SecureRandom());\n+    }\n+\n+    private static void testAEAD() throws Exception {\n+        byte[] expectedPt = HexFormat.of().parseHex(\"01234567\");\n+        byte[] ct = testUpdateAAD(Cipher.ENCRYPT_MODE, expectedPt);\n+        byte[] pt = testUpdateAAD(Cipher.DECRYPT_MODE, ct);\n+        if (pt != null && !Arrays.equals(pt, expectedPt)) {\n+            System.out.println(\"ciphertext: \" + Arrays.toString(ct));\n+            System.out.println(\"plaintext: \" + Arrays.toString(pt));\n+            throw new RuntimeException(\"AEAD failed\");\n+        }\n+    }\n+\n+    private static byte[] testUpdateAAD(int opMode, byte[] input)\n+            throws Exception {\n+        String opModeName = getOpModeName(opMode);\n+        System.out.println(\"== updateAAD (\" + opModeName + \") ==\");\n+\n+        byte[] aad = HexFormat.of().parseHex(\"0000\");\n+        ByteBuffer aadBuf = ByteBuffer.wrap(aad);\n+\n+        Cipher ccp = Cipher.getInstance(ALGO, p);\n+        try {\n+            ccp.updateAAD(aadBuf);\n+            throw new RuntimeException(\n+                    \"Should throw ISE for setting AAD on uninit'ed Cipher\");\n+        } catch (IllegalStateException e) {\n+            System.out.println(\"Expected ISE - \" + e);\n+        }\n+\n+        ccp.init(opMode, KEY, IV_PARAM_SPEC);\n+        ccp.update(input);\n+        try {\n+            ccp.updateAAD(aad);\n+            throw new RuntimeException(\n+                    \"Should throw ISE for setting AAD after update\");\n+        } catch (IllegalStateException e) {\n+            System.out.println(\"Expected ISE - \" + e);\n+        }\n+\n+        ccp.init(opMode, KEY, IV_PARAM_SPEC);\n+        ccp.updateAAD(aadBuf);\n+        return ccp.doFinal(input);\n+    }\n+\n+    private static void testGetBlockSize() throws Exception {\n+        testGetBlockSize(Cipher.ENCRYPT_MODE);\n+        testGetBlockSize(Cipher.DECRYPT_MODE);\n+    }\n+\n+    private static void testGetBlockSize(int opMode) throws Exception {\n+        System.out.println(\"== getBlockSize (\" + getOpModeName(opMode) + \") ==\");\n+        Cipher ccp = Cipher.getInstance(ALGO, p);\n+        if (ccp.getBlockSize() != 0) {\n+            throw new RuntimeException(\"Block size must be 0\");\n+        }\n+    }\n+\n+    private static String getOpModeName(int opMode) {\n+        switch (opMode) {\n+        case Cipher.ENCRYPT_MODE:\n+            return \"ENCRYPT\";\n+\n+        case Cipher.DECRYPT_MODE:\n+            return \"DECRYPT\";\n+\n+        case Cipher.WRAP_MODE:\n+            return \"WRAP\";\n+\n+        case Cipher.UNWRAP_MODE:\n+            return \"UNWRAP\";\n+\n+        default:\n+            return \"\";\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestChaChaPoly(), args);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPoly.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8255410\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ * @build jdk.test.lib.Convert\n+ * @run main\/othervm TestChaChaPolyKAT\n+ * @summary ChaCha20-Poly1305 Cipher Implementation (KAT)\n+ *\/\n+\n+import java.util.*;\n+import java.security.GeneralSecurityException;\n+import java.security.Provider;\n+import java.security.NoSuchAlgorithmException;\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.ChaCha20ParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.AEADBadTagException;\n+import java.nio.ByteBuffer;\n+import jdk.test.lib.Convert;\n+\n+public class TestChaChaPolyKAT extends PKCS11Test {\n+    public static class TestData {\n+        public TestData(String name, String keyStr, String nonceStr, int ctr,\n+                int dir, String inputStr, String aadStr, String outStr) {\n+            testName = Objects.requireNonNull(name);\n+            HexFormat hex = HexFormat.of();\n+            key = hex.parseHex(Objects.requireNonNull(keyStr));\n+            nonce = hex.parseHex(Objects.requireNonNull(nonceStr));\n+            if ((counter = ctr) < 0) {\n+                throw new IllegalArgumentException(\n+                        \"counter must be 0 or greater\");\n+            }\n+            direction = dir;\n+            if ((direction != Cipher.ENCRYPT_MODE) &&\n+                    (direction != Cipher.DECRYPT_MODE)) {\n+                throw new IllegalArgumentException(\n+                        \"Direction must be ENCRYPT_MODE or DECRYPT_MODE\");\n+            }\n+            input = hex.parseHex(Objects.requireNonNull(inputStr));\n+            aad = (aadStr != null) ? hex.parseHex(aadStr) : null;\n+            expOutput = hex.parseHex(Objects.requireNonNull(outStr));\n+        }\n+\n+        public final String testName;\n+        public final byte[] key;\n+        public final byte[] nonce;\n+        public final int counter;\n+        public final int direction;\n+        public final byte[] input;\n+        public final byte[] aad;\n+        public final byte[] expOutput;\n+    }\n+\n+    private static final String ALGO = \"ChaCha20-Poly1305\";\n+\n+    public static final List<TestData> aeadTestList =\n+            new LinkedList<TestData>() {{\n+        add(new TestData(\"RFC 7539 Sample AEAD Test Vector\",\n+            \"808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f\",\n+            \"070000004041424344454647\",\n+            1, Cipher.ENCRYPT_MODE,\n+            \"4c616469657320616e642047656e746c656d656e206f662074686520636c6173\" +\n+            \"73206f66202739393a204966204920636f756c64206f6666657220796f75206f\" +\n+            \"6e6c79206f6e652074697020666f7220746865206675747572652c2073756e73\" +\n+            \"637265656e20776f756c642062652069742e\",\n+            \"50515253c0c1c2c3c4c5c6c7\",\n+            \"d31a8d34648e60db7b86afbc53ef7ec2a4aded51296e08fea9e2b5a736ee62d6\" +\n+            \"3dbea45e8ca9671282fafb69da92728b1a71de0a9e060b2905d6a5b67ecd3b36\" +\n+            \"92ddbd7f2d778b8c9803aee328091b58fab324e4fad675945585808b4831d7bc\" +\n+            \"3ff4def08e4b7a9de576d26586cec64b61161ae10b594f09e26a7e902ecbd060\" +\n+            \"0691\"));\n+        add(new TestData(\"RFC 7539 A.5 Sample Decryption\",\n+            \"1c9240a5eb55d38af333888604f6b5f0473917c1402b80099dca5cbc207075c0\",\n+            \"000000000102030405060708\",\n+            1, Cipher.DECRYPT_MODE,\n+            \"64a0861575861af460f062c79be643bd5e805cfd345cf389f108670ac76c8cb2\" +\n+            \"4c6cfc18755d43eea09ee94e382d26b0bdb7b73c321b0100d4f03b7f355894cf\" +\n+            \"332f830e710b97ce98c8a84abd0b948114ad176e008d33bd60f982b1ff37c855\" +\n+            \"9797a06ef4f0ef61c186324e2b3506383606907b6a7c02b0f9f6157b53c867e4\" +\n+            \"b9166c767b804d46a59b5216cde7a4e99040c5a40433225ee282a1b0a06c523e\" +\n+            \"af4534d7f83fa1155b0047718cbc546a0d072b04b3564eea1b422273f548271a\" +\n+            \"0bb2316053fa76991955ebd63159434ecebb4e466dae5a1073a6727627097a10\" +\n+            \"49e617d91d361094fa68f0ff77987130305beaba2eda04df997b714d6c6f2c29\" +\n+            \"a6ad5cb4022b02709beead9d67890cbb22392336fea1851f38\",\n+            \"f33388860000000000004e91\",\n+            \"496e7465726e65742d4472616674732061726520647261667420646f63756d65\" +\n+            \"6e74732076616c696420666f722061206d6178696d756d206f6620736978206d\" +\n+            \"6f6e74687320616e64206d617920626520757064617465642c207265706c6163\" +\n+            \"65642c206f72206f62736f6c65746564206279206f7468657220646f63756d65\" +\n+            \"6e747320617420616e792074696d652e20497420697320696e617070726f7072\" +\n+            \"6961746520746f2075736520496e7465726e65742d4472616674732061732072\" +\n+            \"65666572656e6365206d6174657269616c206f7220746f206369746520746865\" +\n+            \"6d206f74686572207468616e206173202fe2809c776f726b20696e2070726f67\" +\n+            \"726573732e2fe2809d\"));\n+    }};\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        System.out.println(\"Testing \" + p.getName());\n+\n+        try {\n+            Cipher.getInstance(ALGO, p);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            System.out.println(\"Skip; no support for \" + ALGO);\n+            return;\n+        }\n+\n+        int testsPassed = 0;\n+        int testNumber = 0;\n+\n+        System.out.println(\"----- AEAD Tests -----\");\n+        for (TestData test : aeadTestList) {\n+            System.out.println(\"*** Test \" + ++testNumber + \": \" +\n+                    test.testName);\n+            if (runAEADTest(p, test)) {\n+                testsPassed++;\n+            }\n+        }\n+        System.out.println();\n+\n+        System.out.println(\"Total tests: \" + testNumber +\n+                \", Passed: \" + testsPassed + \", Failed: \" +\n+                (testNumber - testsPassed));\n+        if (testsPassed != testNumber) {\n+            throw new RuntimeException(\"One or more tests failed.  \" +\n+                    \"Check output for details\");\n+        }\n+    }\n+\n+    private static boolean runAEADTest(Provider p, TestData testData)\n+            throws GeneralSecurityException {\n+        boolean result = false;\n+\n+        Cipher mambo = Cipher.getInstance(ALGO, p);\n+        SecretKeySpec mamboKey = new SecretKeySpec(testData.key, \"ChaCha20\");\n+        IvParameterSpec mamboSpec = new IvParameterSpec(testData.nonce);\n+\n+        mambo.init(testData.direction, mamboKey, mamboSpec);\n+\n+        byte[] out = new byte[mambo.getOutputSize(testData.input.length)];\n+        int outOff = 0;\n+        try {\n+            mambo.updateAAD(testData.aad);\n+            outOff += mambo.update(testData.input, 0, testData.input.length,\n+                    out, outOff);\n+            outOff += mambo.doFinal(out, outOff);\n+        } catch (AEADBadTagException abte) {\n+            \/\/ If we get a bad tag or derive a tag mismatch, log it\n+            \/\/ and register it as a failure\n+            System.out.println(\"FAIL: \" + abte);\n+            return false;\n+        }\n+\n+        if (!Arrays.equals(out, 0, outOff, testData.expOutput, 0, outOff)) {\n+            System.out.println(\"ERROR - Output Mismatch!\");\n+            System.out.println(\"Expected:\\n\" +\n+                    dumpHexBytes(testData.expOutput, 16, \"\\n\", \" \"));\n+            System.out.println(\"Actual:\\n\" +\n+                    dumpHexBytes(out, 16, \"\\n\", \" \"));\n+            System.out.println();\n+        } else {\n+            result = true;\n+        }\n+\n+        return result;\n+    }\n+\n+    \/**\n+     * Dump the hex bytes of a buffer into string form.\n+     *\n+     * @param data The array of bytes to dump to stdout.\n+     * @param itemsPerLine The number of bytes to display per line\n+     *      if the {@code lineDelim} character is blank then all bytes\n+     *      will be printed on a single line.\n+     * @param lineDelim The delimiter between lines\n+     * @param itemDelim The delimiter between bytes\n+     *\n+     * @return The hexdump of the byte array\n+     *\/\n+    private static String dumpHexBytes(byte[] data, int itemsPerLine,\n+            String lineDelim, String itemDelim) {\n+        return dumpHexBytes(ByteBuffer.wrap(data), itemsPerLine, lineDelim,\n+                itemDelim);\n+    }\n+\n+    private static String dumpHexBytes(ByteBuffer data, int itemsPerLine,\n+            String lineDelim, String itemDelim) {\n+        StringBuilder sb = new StringBuilder();\n+        if (data != null) {\n+            data.mark();\n+            int i = 0;\n+            while (data.remaining() > 0) {\n+                if (i % itemsPerLine == 0 && i != 0) {\n+                    sb.append(lineDelim);\n+                }\n+                sb.append(String.format(\"%02X\", data.get())).append(itemDelim);\n+                i++;\n+            }\n+            data.reset();\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestChaChaPolyKAT(), args);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPolyKAT.java","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -0,0 +1,432 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8255410\n+ * @library \/test\/lib ..\n+ * @run main\/othervm TestChaChaPolyNoReuse\n+ * @summary Test PKCS#11 ChaCha20-Poly1305 Cipher Implementation\n+ * (key\/nonce reuse check)\n+ *\/\n+\n+import java.util.*;\n+import javax.crypto.Cipher;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.Provider;\n+import java.security.NoSuchAlgorithmException;\n+import javax.crypto.spec.ChaCha20ParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.AEADBadTagException;\n+import javax.crypto.SecretKey;\n+import java.security.InvalidKeyException;\n+import java.security.InvalidAlgorithmParameterException;\n+\n+public class TestChaChaPolyNoReuse extends PKCS11Test {\n+\n+    private static final String KEY_ALGO = \"ChaCha20\";\n+    private static final String CIPHER_ALGO = \"ChaCha20-Poly1305\";\n+\n+    \/**\n+     * Basic TestMethod interface definition\n+     *\/\n+    public interface TestMethod {\n+        \/**\n+         * Runs the actual test case\n+         *\n+         * @param provider the provider to provide the requested Cipher obj.\n+         *\n+         * @return true if the test passes, false otherwise.\n+         *\/\n+        boolean run(Provider p);\n+    }\n+\n+    public static class TestData {\n+        public TestData(String name, String keyStr, String nonceStr, int ctr,\n+                int dir, String inputStr, String aadStr, String outStr) {\n+            testName = Objects.requireNonNull(name);\n+            HexFormat hex = HexFormat.of();\n+            key = hex.parseHex(keyStr);\n+            nonce = hex.parseHex(nonceStr);\n+            if ((counter = ctr) < 0) {\n+                throw new IllegalArgumentException(\n+                        \"counter must be 0 or greater\");\n+            }\n+            direction = dir;\n+            if ((direction != Cipher.ENCRYPT_MODE) &&\n+                    (direction != Cipher.DECRYPT_MODE)) {\n+                throw new IllegalArgumentException(\n+                        \"Direction must be ENCRYPT_MODE or DECRYPT_MODE\");\n+            }\n+            input = hex.parseHex(inputStr);\n+            aad = (aadStr != null) ? hex.parseHex(aadStr) : null;\n+            expOutput = hex.parseHex(outStr);\n+        }\n+\n+        public final String testName;\n+        public final byte[] key;\n+        public final byte[] nonce;\n+        public final int counter;\n+        public final int direction;\n+        public final byte[] input;\n+        public final byte[] aad;\n+        public final byte[] expOutput;\n+    }\n+\n+    public static final List<TestData> aeadTestList =\n+            new LinkedList<TestData>() {{\n+        add(new TestData(\"RFC 7539 Sample AEAD Test Vector\",\n+            \"808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f\",\n+            \"070000004041424344454647\",\n+            1, Cipher.ENCRYPT_MODE,\n+            \"4c616469657320616e642047656e746c656d656e206f662074686520636c6173\" +\n+            \"73206f66202739393a204966204920636f756c64206f6666657220796f75206f\" +\n+            \"6e6c79206f6e652074697020666f7220746865206675747572652c2073756e73\" +\n+            \"637265656e20776f756c642062652069742e\",\n+            \"50515253c0c1c2c3c4c5c6c7\",\n+            \"d31a8d34648e60db7b86afbc53ef7ec2a4aded51296e08fea9e2b5a736ee62d6\" +\n+            \"3dbea45e8ca9671282fafb69da92728b1a71de0a9e060b2905d6a5b67ecd3b36\" +\n+            \"92ddbd7f2d778b8c9803aee328091b58fab324e4fad675945585808b4831d7bc\" +\n+            \"3ff4def08e4b7a9de576d26586cec64b61161ae10b594f09e26a7e902ecbd060\" +\n+            \"0691\"));\n+        add(new TestData(\"RFC 7539 A.5 Sample Decryption\",\n+            \"1c9240a5eb55d38af333888604f6b5f0473917c1402b80099dca5cbc207075c0\",\n+            \"000000000102030405060708\",\n+            1, Cipher.DECRYPT_MODE,\n+            \"64a0861575861af460f062c79be643bd5e805cfd345cf389f108670ac76c8cb2\" +\n+            \"4c6cfc18755d43eea09ee94e382d26b0bdb7b73c321b0100d4f03b7f355894cf\" +\n+            \"332f830e710b97ce98c8a84abd0b948114ad176e008d33bd60f982b1ff37c855\" +\n+            \"9797a06ef4f0ef61c186324e2b3506383606907b6a7c02b0f9f6157b53c867e4\" +\n+            \"b9166c767b804d46a59b5216cde7a4e99040c5a40433225ee282a1b0a06c523e\" +\n+            \"af4534d7f83fa1155b0047718cbc546a0d072b04b3564eea1b422273f548271a\" +\n+            \"0bb2316053fa76991955ebd63159434ecebb4e466dae5a1073a6727627097a10\" +\n+            \"49e617d91d361094fa68f0ff77987130305beaba2eda04df997b714d6c6f2c29\" +\n+            \"a6ad5cb4022b02709beead9d67890cbb22392336fea1851f38\",\n+            \"f33388860000000000004e91\",\n+            \"496e7465726e65742d4472616674732061726520647261667420646f63756d65\" +\n+            \"6e74732076616c696420666f722061206d6178696d756d206f6620736978206d\" +\n+            \"6f6e74687320616e64206d617920626520757064617465642c207265706c6163\" +\n+            \"65642c206f72206f62736f6c65746564206279206f7468657220646f63756d65\" +\n+            \"6e747320617420616e792074696d652e20497420697320696e617070726f7072\" +\n+            \"6961746520746f2075736520496e7465726e65742d4472616674732061732072\" +\n+            \"65666572656e6365206d6174657269616c206f7220746f206369746520746865\" +\n+            \"6d206f74686572207468616e206173202fe2809c776f726b20696e2070726f67\" +\n+            \"726573732e2fe2809d\"));\n+    }};\n+\n+    \/**\n+     * Make sure we do not use this Cipher object without initializing it\n+     * at all\n+     *\/\n+    public static final TestMethod noInitTest = new TestMethod() {\n+        @Override\n+        public boolean run(Provider p) {\n+            System.out.println(\"----- No Init Test -----\");\n+            try {\n+                Cipher cipher = Cipher.getInstance(CIPHER_ALGO, p);\n+                TestData testData = aeadTestList.get(0);\n+\n+                \/\/ Attempting to use the cipher without initializing it\n+                \/\/ should throw an IllegalStateException\n+                try {\n+                    cipher.updateAAD(testData.aad);\n+                    throw new RuntimeException(\n+                            \"Expected IllegalStateException not thrown\");\n+                } catch (IllegalStateException ise) {\n+                    \/\/ Do nothing, this is what we expected to happen\n+                }\n+            } catch (Exception exc) {\n+                System.out.println(\"Unexpected exception: \" + exc);\n+                exc.printStackTrace();\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+    };\n+\n+    \/**\n+     * Attempt to run two full encryption operations without an init in\n+     * between.\n+     *\/\n+    public static final TestMethod encTwiceNoInit = new TestMethod() {\n+        @Override\n+        public boolean run(Provider p) {\n+            System.out.println(\"----- Encrypt 2nd time without init -----\");\n+            try {\n+                AlgorithmParameterSpec spec;\n+                Cipher cipher = Cipher.getInstance(CIPHER_ALGO, p);\n+                TestData testData = aeadTestList.get(0);\n+                spec = new IvParameterSpec(testData.nonce);\n+                SecretKey key = new SecretKeySpec(testData.key, KEY_ALGO);\n+\n+                \/\/ Initialize and encrypt\n+                cipher.init(testData.direction, key, spec);\n+                cipher.updateAAD(testData.aad);\n+                cipher.doFinal(testData.input);\n+                System.out.println(\"First encryption complete\");\n+\n+                \/\/ Now attempt to encrypt again without changing the key\/IV\n+                \/\/ This should fail.\n+                try {\n+                    cipher.updateAAD(testData.aad);\n+                } catch (IllegalStateException ise) {\n+                    \/\/ Do nothing, this is what we expected to happen\n+                }\n+                try {\n+                    cipher.doFinal(testData.input);\n+                    throw new RuntimeException(\n+                            \"Expected IllegalStateException not thrown\");\n+                } catch (IllegalStateException ise) {\n+                    \/\/ Do nothing, this is what we expected to happen\n+                }\n+            } catch (Exception exc) {\n+                System.out.println(\"Unexpected exception: \" + exc);\n+                exc.printStackTrace();\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+    };\n+\n+    \/**\n+     * Attempt to run two full decryption operations without an init in\n+     * between.\n+     *\/\n+    public static final TestMethod decTwiceNoInit = new TestMethod() {\n+\n+        @Override\n+        public boolean run(Provider p) {\n+            System.out.println(\"----- Decrypt 2nd time without init -----\");\n+            try {\n+                AlgorithmParameterSpec spec;\n+                Cipher cipher = Cipher.getInstance(CIPHER_ALGO, p);\n+                TestData testData = aeadTestList.get(1);\n+                spec = new IvParameterSpec(testData.nonce);\n+                SecretKey key = new SecretKeySpec(testData.key, KEY_ALGO);\n+\n+                \/\/ Initialize and encrypt\n+                cipher.init(testData.direction, key, spec);\n+                cipher.updateAAD(testData.aad);\n+                cipher.doFinal(testData.input);\n+                System.out.println(\"First decryption complete\");\n+\n+                \/\/ Now attempt to encrypt again without changing the key\/IV\n+                \/\/ This should fail.\n+                try {\n+                    cipher.updateAAD(testData.aad);\n+                } catch (IllegalStateException ise) {\n+                    \/\/ Do nothing, this is what we expected to happen\n+                }\n+                try {\n+                    cipher.doFinal(testData.input);\n+                    throw new RuntimeException(\n+                            \"Expected IllegalStateException not thrown\");\n+                } catch (IllegalStateException ise) {\n+                    \/\/ Do nothing, this is what we expected to happen\n+                }\n+            } catch (Exception exc) {\n+                System.out.println(\"Unexpected exception: \" + exc);\n+                exc.printStackTrace();\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+    };\n+\n+    \/**\n+     * Perform an AEAD decryption with corrupted data so the tag does not\n+     * match.  Then attempt to reuse the cipher without initialization.\n+     *\/\n+    public static final TestMethod decFailNoInit = new TestMethod() {\n+        @Override\n+        public boolean run(Provider p) {\n+            System.out.println(\n+                    \"----- Fail decryption, try again with no init -----\");\n+            try {\n+                TestData testData = aeadTestList.get(1);\n+                AlgorithmParameterSpec spec =\n+                        new IvParameterSpec(testData.nonce);\n+                byte[] corruptInput = testData.input.clone();\n+                corruptInput[0]++;      \/\/ Corrupt the ciphertext\n+                SecretKey key = new SecretKeySpec(testData.key, KEY_ALGO);\n+                Cipher cipher = Cipher.getInstance(CIPHER_ALGO, p);\n+\n+                try {\n+                    \/\/ Initialize and encrypt\n+                    cipher.init(testData.direction, key, spec);\n+                    cipher.updateAAD(testData.aad);\n+                    cipher.doFinal(corruptInput);\n+                    throw new RuntimeException(\n+                            \"Expected AEADBadTagException not thrown\");\n+                } catch (AEADBadTagException abte) {\n+                    System.out.println(\"Expected decryption failure occurred\");\n+                }\n+\n+                \/\/ Make sure that despite the exception, the Cipher object is\n+                \/\/ not in a state that would leave it initialized and able\n+                \/\/ to process future decryption operations without init.\n+                try {\n+                    cipher.updateAAD(testData.aad);\n+                    cipher.doFinal(testData.input);\n+                    throw new RuntimeException(\n+                            \"Expected IllegalStateException not thrown\");\n+                } catch (IllegalStateException ise) {\n+                    \/\/ Do nothing, this is what we expected to happen\n+                }\n+            } catch (Exception exc) {\n+                System.out.println(\"Unexpected exception: \" + exc);\n+                exc.printStackTrace();\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+    };\n+\n+    \/**\n+     * Encrypt once successfully, then attempt to init with the same\n+     * key and nonce.\n+     *\/\n+    public static final TestMethod encTwiceInitSameParams = new TestMethod() {\n+        @Override\n+        public boolean run(Provider p) {\n+            System.out.println(\"----- Encrypt, then init with same params \" +\n+                     \"-----\");\n+            try {\n+                AlgorithmParameterSpec spec;\n+                Cipher cipher = Cipher.getInstance(CIPHER_ALGO, p);\n+                TestData testData = aeadTestList.get(0);\n+                spec = new IvParameterSpec(testData.nonce);\n+                SecretKey key = new SecretKeySpec(testData.key, KEY_ALGO);\n+\n+                \/\/ Initialize then encrypt\n+                cipher.init(testData.direction, key, spec);\n+                cipher.updateAAD(testData.aad);\n+                cipher.doFinal(testData.input);\n+                System.out.println(\"First encryption complete\");\n+\n+                \/\/ Initializing after the completed encryption with\n+                \/\/ the same key and nonce should fail.\n+                try {\n+                    cipher.init(testData.direction, key, spec);\n+                    throw new RuntimeException(\n+                            \"Expected IKE or IAPE not thrown\");\n+                } catch (InvalidKeyException |\n+                        InvalidAlgorithmParameterException e) {\n+                    \/\/ Do nothing, this is what we expected to happen\n+                }\n+            } catch (Exception exc) {\n+                System.out.println(\"Unexpected exception: \" + exc);\n+                exc.printStackTrace();\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+    };\n+\n+    \/**\n+     * Decrypt once successfully, then attempt to init with the same\n+     * key and nonce.\n+     *\/\n+    public static final TestMethod decTwiceInitSameParams = new TestMethod() {\n+        @Override\n+        public boolean run(Provider p) {\n+            System.out.println(\"----- Decrypt, then init with same params \" +\n+                    \"-----\");\n+            try {\n+                AlgorithmParameterSpec spec;\n+                Cipher cipher = Cipher.getInstance(CIPHER_ALGO, p);\n+                TestData testData = aeadTestList.get(1);\n+                spec = new IvParameterSpec(testData.nonce);\n+                SecretKey key = new SecretKeySpec(testData.key, KEY_ALGO);\n+\n+                \/\/ Initialize then decrypt\n+                cipher.init(testData.direction, key, spec);\n+                cipher.updateAAD(testData.aad);\n+                cipher.doFinal(testData.input);\n+                System.out.println(\"First decryption complete\");\n+\n+                \/\/ Initializing after the completed decryption with\n+                \/\/ the same key and nonce should fail.\n+                try {\n+                    cipher.init(testData.direction, key, spec);\n+                    throw new RuntimeException(\n+                            \"Expected IKE or IAPE not thrown\");\n+                } catch (InvalidKeyException |\n+                        InvalidAlgorithmParameterException e) {\n+                    \/\/ Do nothing, this is what we expected to happen\n+                }\n+            } catch (Exception exc) {\n+                System.out.println(\"Unexpected exception: \" + exc);\n+                exc.printStackTrace();\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+    };\n+\n+    public static final List<TestMethod> testMethodList =\n+            Arrays.asList(noInitTest, encTwiceNoInit,\n+                    decTwiceNoInit, decFailNoInit, encTwiceInitSameParams,\n+                    decTwiceInitSameParams);\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        System.out.println(\"Testing \" + p.getName());\n+        try {\n+            Cipher.getInstance(CIPHER_ALGO, p);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            System.out.println(\"Skip; no support for \" + CIPHER_ALGO);\n+            return;\n+        }\n+\n+        int testsPassed = 0;\n+        int testNumber = 0;\n+\n+        for (TestMethod tm : testMethodList) {\n+            testNumber++;\n+            boolean result = tm.run(p);\n+            System.out.println(\"Result: \" + (result ? \"PASS\" : \"FAIL\"));\n+            if (result) {\n+                testsPassed++;\n+            }\n+        }\n+\n+        System.out.println(\"Total Tests: \" + testNumber +\n+                \", Tests passed: \" + testsPassed);\n+        if (testsPassed < testNumber) {\n+            throw new RuntimeException(\n+                    \"Not all tests passed.  See output for failure info\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestChaChaPolyNoReuse(), args);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPolyNoReuse.java","additions":432,"deletions":0,"binary":false,"changes":432,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8255410\n+ * @summary Check ChaCha20-Poly1305 cipher output size\n+ * @library \/test\/lib ..\n+ * @build jdk.test.lib.Convert\n+ * @run main TestChaChaPolyOutputSize\n+ *\/\n+\n+import java.nio.ByteBuffer;\n+import java.security.GeneralSecurityException;\n+import java.security.Key;\n+import java.security.SecureRandom;\n+import java.security.Provider;\n+import java.security.NoSuchAlgorithmException;\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.ChaCha20ParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+public class TestChaChaPolyOutputSize extends PKCS11Test {\n+\n+    private static final SecureRandom SR = new SecureRandom();\n+\n+    private static final SecretKeySpec KEY = new SecretKeySpec(new byte[32],\n+            \"ChaCha20\");\n+\n+    private static final String ALGO = \"ChaCha20-Poly1305\";\n+\n+    public static void main(String args[]) throws Exception {\n+        main(new TestChaChaPolyOutputSize(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws GeneralSecurityException {\n+        System.out.println(\"Testing \" + p.getName());\n+        try {\n+            Cipher.getInstance(ALGO, p);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            System.out.println(\"Skip; no support for \" + ALGO);\n+            return;\n+        }\n+        testGetOutSize(p);\n+        testMultiPartAEADDec(p);\n+    }\n+\n+    private static void testGetOutSize(Provider p)\n+            throws GeneralSecurityException {\n+\n+        Cipher ccp = Cipher.getInstance(ALGO, p);\n+        ccp.init(Cipher.ENCRYPT_MODE, KEY,\n+                new IvParameterSpec(getRandBuf(12)));\n+\n+        \/\/ Encryption lengths are calculated as the input length plus the tag\n+        \/\/ length (16).\n+        testOutLen(ccp, 0, 16);\n+        testOutLen(ccp, 5, 21);\n+        testOutLen(ccp, 5120, 5136);\n+        \/\/ perform an update, then test with a final block\n+        byte[] input = new byte[5120];\n+        SR.nextBytes(input);\n+        byte[] updateOut = ccp.update(input);\n+        testOutLen(ccp, 1024, 1040 +\n+                (5120 - (updateOut == null? 0 : updateOut.length)));\n+\n+        \/\/ Decryption lengths are handled differently for AEAD mode.  The length\n+        \/\/ should be zero for anything up to and including the first 16 bytes\n+        \/\/ (since that's the tag).  Anything above that should be the input\n+        \/\/ length plus any unprocessed input (via update calls), minus the\n+        \/\/ 16 byte tag.\n+        ccp.init(Cipher.DECRYPT_MODE, KEY, new IvParameterSpec(getRandBuf(12)));\n+        testOutLen(ccp, 0, 0);\n+        testOutLen(ccp, 5, 0);\n+        testOutLen(ccp, 16, 0);\n+        testOutLen(ccp, 5120, 5104);\n+        \/\/ Perform an update, then test with the length of a final chunk\n+        \/\/ of data.\n+        updateOut = ccp.update(input);\n+        testOutLen(ccp, 1024, 6128 - (updateOut == null? 0 : updateOut.length));\n+    }\n+\n+    private static void testMultiPartAEADDec(Provider p)\n+            throws GeneralSecurityException {\n+        IvParameterSpec ivps = new IvParameterSpec(getRandBuf(12));\n+\n+        \/\/ Encrypt some data so we can test decryption.\n+        byte[] pText = getRandBuf(2048);\n+        ByteBuffer pTextBase = ByteBuffer.wrap(pText);\n+\n+        Cipher enc = Cipher.getInstance(ALGO, p);\n+        enc.init(Cipher.ENCRYPT_MODE, KEY, ivps);\n+        ByteBuffer ctBuf = ByteBuffer.allocateDirect(\n+                enc.getOutputSize(pText.length));\n+        enc.doFinal(pTextBase, ctBuf);\n+\n+        \/\/ Create a new direct plain text ByteBuffer which will catch the\n+        \/\/ decrypted data.\n+        ByteBuffer ptBuf = ByteBuffer.allocateDirect(pText.length);\n+\n+        \/\/ Set the cipher text buffer limit to roughly half the data so we can\n+        \/\/ do an update\/final sequence.\n+        ctBuf.position(0).limit(1024);\n+\n+        Cipher dec = Cipher.getInstance(ALGO, p);\n+        dec.init(Cipher.DECRYPT_MODE, KEY, ivps);\n+        dec.update(ctBuf, ptBuf);\n+        System.out.println(\"CTBuf: \" + ctBuf);\n+        System.out.println(\"PTBuf: \" + ptBuf);\n+        ctBuf.limit(ctBuf.capacity());\n+        dec.doFinal(ctBuf, ptBuf);\n+\n+        \/\/ NOTE: do not use flip() which will set limit based on current\n+        \/\/ position. ptBuf curr pos = 2048 vs pTextBase pos = 0\n+        ptBuf.flip();\n+        pTextBase.flip();\n+        System.out.println(\"PT Base:\" + pTextBase);\n+        System.out.println(\"PT Actual:\" + ptBuf);\n+\n+        if (pTextBase.compareTo(ptBuf) != 0) {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"Plaintext mismatch: Original: \").\n+                    append(pTextBase.toString()).append(\"\\nActual :\").\n+                    append(ptBuf);\n+            throw new RuntimeException(sb.toString());\n+        }\n+    }\n+\n+    private static void testOutLen(Cipher c, int inLen, int expOut) {\n+        int actualOut = c.getOutputSize(inLen);\n+        if (actualOut != expOut) {\n+            throw new RuntimeException(\"Cipher \" + c + \", in: \" + inLen +\n+                    \", expOut: \" + expOut + \", actual: \" + actualOut);\n+        }\n+    }\n+\n+    private static byte[] getRandBuf(int len) {\n+        byte[] buf = new byte[len];\n+        SR.nextBytes(buf);\n+        return buf;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPolyOutputSize.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255410\n+ * @modules jdk.crypto.cryptoki\n+ * @summary Check ChaCha20 key generator.\n+ * @library \/test\/lib ..\n+ * @run main\/othervm TestChaCha20\n+ *\/\n+import java.security.Provider;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidParameterException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.HexFormat;\n+\n+import javax.crypto.KeyGenerator;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.ChaCha20ParameterSpec;\n+\n+public class TestChaCha20 extends PKCS11Test {\n+\n+    private static final String ALGO = \"ChaCha20\";\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestChaCha20(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        System.out.println(\"Testing \" + p.getName());\n+        KeyGenerator kg;\n+        try {\n+            kg = KeyGenerator.getInstance(ALGO, p);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            System.out.println(\"Skip; no support for \" + ALGO);\n+            return;\n+        }\n+\n+        try {\n+            kg.init(new ChaCha20ParameterSpec(new byte[12], 0));\n+            throw new RuntimeException(\n+                    \"ChaCha20 key generation should not need any paramSpec\");\n+        } catch (InvalidAlgorithmParameterException e) {\n+            System.out.println(\"Expected IAPE: \" + e.getMessage());\n+        }\n+\n+        for (int keySize : new int[] { 32, 64, 128, 256, 512, 1024 }) {\n+            try {\n+                kg.init(keySize);\n+                if (keySize != 256) {\n+                    throw new RuntimeException(keySize + \" is invalid keysize\");\n+                }\n+            } catch (InvalidParameterException e) {\n+                if (keySize == 256) {\n+                    throw new RuntimeException(\"IPE thrown for valid keySize\");\n+                } else {\n+                    System.out.println(\"Expected IPE thrown for \" + keySize);\n+                }\n+            }\n+        }\n+\n+        \/\/kg.init(256);\n+        SecretKey key = kg.generateKey();\n+        byte[] keyValue = key.getEncoded();\n+        System.out.println(\"Key: \" + HexFormat.of().formatHex(keyValue));\n+        if (keyValue.length != 32) {\n+            throw new RuntimeException(\"The size of generated key must be 256\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyGenerator\/TestChaCha20.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"}]}