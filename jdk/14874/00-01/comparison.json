{"files":[{"patch":"@@ -29,0 +29,6 @@\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -38,1 +44,1 @@\n-public class CombinationsTargetTest3 {\n+public class CombinationsTargetTest3 extends ClassfileTestHelper {\n@@ -543,28 +549,0 @@\n-    \/************ Migrated from original ClassfileTestHelper ******************\/\n-    int expected_tinvisibles = 0;\n-    int expected_tvisibles = 0;\n-    int expected_invisibles = 0;\n-    int expected_visibles = 0;\n-\n-    \/\/Makes debugging much easier. Set to 'false' for less output.\n-    public Boolean verbose = true;\n-    void println(String msg) { if (verbose) System.err.println(msg); }\n-    void print(String msg) { if (verbose) System.err.print(msg); }\n-\n-    File writeTestFile(String fname, String source) throws IOException {\n-      File f = new File(fname);\n-        PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(f)));\n-        out.println(source);\n-        out.close();\n-        return f;\n-    }\n-\n-    File compile(File f) {\n-        List<String> options = new ArrayList<>(List.of(\"-g\", f.getPath()));\n-        int rc = com.sun.tools.javac.Main.compile(options.toArray(new String[0]));\n-        if (rc != 0)\n-            throw new Error(\"compilation failed. rc=\" + rc);\n-        String path = f.getPath();\n-        return new File(path.substring(0, path.length() - 5) + \".class\");\n-    }\n-\n@@ -705,40 +683,1 @@\n-\n-    void countAnnotations() {\n-        errors=0;\n-        int expected_allt = expected_tvisibles + expected_tinvisibles;\n-        int expected_all = expected_visibles + expected_invisibles;\n-        if (expected_allt != allt) {\n-            errors++;\n-            System.err.println(\"Failure: expected \" + expected_allt +\n-                    \" type annotations but found \" + allt);\n-        }\n-        if (expected_all != all) {\n-            errors++;\n-            System.err.println(\"Failure: expected \" + expected_all +\n-                    \" annotations but found \" + all);\n-        }\n-        if (expected_tvisibles != tvisibles) {\n-            errors++;\n-            System.err.println(\"Failure: expected \" + expected_tvisibles +\n-                    \" typevisible annotations but found \" + tvisibles);\n-        }\n-        if (expected_tinvisibles != tinvisibles) {\n-            errors++;\n-            System.err.println(\"Failure: expected \" + expected_tinvisibles +\n-                    \" typeinvisible annotations but found \" + tinvisibles);\n-        }\n-        allt=0;\n-        tvisibles=0;\n-        tinvisibles=0;\n-        all=0;\n-        visibles=0;\n-        invisibles=0;\n-    }\n-    int errors;\n-    int allt;\n-    int tvisibles;\n-    int tinvisibles;\n-    int all;\n-    int visibles;\n-    int invisibles;\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/CombinationsTargetTest3.java","additions":8,"deletions":69,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/Scopes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,28 +24,16 @@\n-import jdk.internal.classfile.*;\n-import jdk.internal.classfile.attribute.SignatureAttribute;\n-import jdk.internal.classfile.impl.BoundAttribute;\n-\n-import java.io.File;\n-import java.io.FilenameFilter;\n-import java.lang.constant.ClassDesc;\n-import java.lang.reflect.*;\n-import java.util.*;\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import java.lang.reflect.AccessFlag;\n-\n-\/**\n- * The main class of Signature tests.\n- * Driver reads golden data of each class member that must have a Signature attribute,\n- * after that the class compares expected data with actual one.\n- *\n- * Example of usage Driver:\n- * java Driver Test\n- *\n- * Each member of the class Test should have @ExpectedSignature annotations\n- * if it must have the Signature attribute. Anonymous class cannot be annotated.\n- * So its enclosing class should be annotated and method isAnonymous\n- * of ExpectedSignature must return true.\n+\/*\n+ * @test\n+ * @bug 8049238\n+ * @summary Checks Signature attribute for enum.\n+ * @library \/tools\/lib \/tools\/javac\/lib ..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n+ * @build toolbox.ToolBox InMemoryFileManager TestResult TestBase\n+ * @build EnumTest Driver ExpectedSignature ExpectedSignatureContainer\n+ * @run main Driver EnumTest\n@@ -53,179 +41,0 @@\n-public class Driver extends TestResult {\n-    private final String topLevelClassName;\n-    private final File[] files;\n-\n-    public Driver(String topLevelClassName) {\n-        this.topLevelClassName = topLevelClassName;\n-        \/\/ Get top level class and all inner classes.\n-        FilenameFilter filter = (dir, file) ->\n-                file.equals(topLevelClassName + \".class\")\n-                        || file.matches(topLevelClassName + \"\\\\$.*\\\\.class\");\n-        files = getClassDir().listFiles(filter);\n-    }\n-\n-    private boolean isAnonymous(String className) {\n-        return className.matches(\".*\\\\$\\\\d+$\");\n-    }\n-\n-    private Class<?> getEnclosingClass(String className) throws ClassNotFoundException {\n-        return Class.forName(className.replaceFirst(\"\\\\$\\\\d+$\", \"\"));\n-    }\n-\n-    private ExpectedSignature getExpectedClassSignature(String className, Class<?> clazz)\n-            throws ClassNotFoundException {\n-        \/\/ anonymous class cannot be annotated, so information about anonymous class\n-        \/\/ is located in its enclosing class.\n-        boolean isAnonymous = isAnonymous(className);\n-        clazz = isAnonymous ? getEnclosingClass(className) : clazz;\n-        return Arrays.stream(clazz.getAnnotationsByType(ExpectedSignature.class))\n-                .filter(s -> s.isAnonymous() == isAnonymous)\n-                .collect(Collectors.toMap(ExpectedSignature::descriptor, Function.identity()))\n-                .get(className);\n-    }\n-\n-    \/\/ Class.getName() cannot be used here, because the method can rely on signature attribute.\n-    private Map<String, ExpectedSignature> getClassExpectedSignature(String className, Class<?> clazz)\n-            throws ClassNotFoundException {\n-        Map<String, ExpectedSignature> classSignatures = new HashMap<>();\n-        ExpectedSignature classSignature = getExpectedClassSignature(className, clazz);\n-        if (classSignature != null) {\n-            classSignatures.put(className, classSignature);\n-        }\n-        return classSignatures;\n-    }\n-\n-    private Map<String, ExpectedSignature> getExpectedExecutableSignatures(Executable[] executables,\n-                                                                           Predicate<Executable> filterBridge) {\n-        return Arrays.stream(executables)\n-                .filter(filterBridge)\n-                .map(e -> e.getAnnotation(ExpectedSignature.class))\n-                .filter(Objects::nonNull)\n-                .collect(Collectors.toMap(ExpectedSignature::descriptor, Function.identity()));\n-    }\n-\n-    private Map<String, ExpectedSignature> getExpectedMethodSignatures(Class<?> clazz) {\n-        Map<String, ExpectedSignature> methodSignatures =\n-                getExpectedExecutableSignatures(clazz.getDeclaredMethods(),\n-                        m -> !((java.lang.reflect.Method) m).isBridge());\n-        methodSignatures.putAll(\n-                getExpectedExecutableSignatures(clazz.getDeclaredConstructors(),\n-                        m -> true));\n-        return methodSignatures;\n-    }\n-\n-    private Map<String, ExpectedSignature> getExpectedFieldSignatures(Class<?> clazz) {\n-        return Arrays.stream(clazz.getDeclaredFields())\n-                .map(f -> f.getAnnotation(ExpectedSignature.class))\n-                .filter(Objects::nonNull)\n-                .collect(Collectors.toMap(ExpectedSignature::descriptor, Function.identity()));\n-    }\n-\n-    public void test() throws TestFailedException {\n-        try {\n-            addTestCase(\"Source is \" + topLevelClassName + \".java\");\n-            assertTrue(files.length > 0, \"No class files found\");\n-            for (File file : files) {\n-                try {\n-                    String className = file.getName().replace(\".class\", \"\");\n-                    Class<?> clazz = Class.forName(className);\n-                    printf(\"Testing class %s\\n\", className);\n-                    ClassModel classFile = readClassFile(file);\n-\n-                    \/\/ test class signature\n-                    testAttribute(\n-                            className,\n-                            () -> classFile.findAttribute(Attributes.SIGNATURE).orElse(null),\n-                            getClassExpectedSignature(className, clazz).get(className));\n-\n-                    testFields(getExpectedFieldSignatures(clazz), classFile);\n-\n-                    testMethods(getExpectedMethodSignatures(clazz), classFile);\n-                } catch (Exception e) {\n-                    addFailure(e);\n-                }\n-            }\n-        } catch (Exception e) {\n-            addFailure(e);\n-        } finally {\n-            checkStatus();\n-        }\n-    }\n-\n-    private void checkAllMembersFound(Set<String> found, Map<String, ExpectedSignature> signatures, String message) {\n-        if (signatures != null) {\n-            checkContains(found,\n-                    signatures.values().stream()\n-                            .map(ExpectedSignature::descriptor)\n-                            .collect(Collectors.toSet()),\n-                    message);\n-        }\n-    }\n-\n-    private void testMethods(Map<String, ExpectedSignature> expectedSignatures, ClassModel classFile) {\n-        String className = classFile.thisClass().name().stringValue();\n-        Set<String> foundMethods = new HashSet<>();\n-        for (MethodModel method : classFile.methods()) {\n-            String methodName = getMethodName(method);\n-            printf(\"Testing method %s\\n\", methodName);\n-            if (method.flags().has(AccessFlag.BRIDGE)) {\n-                printf(\"Bridge method is skipped : %s\\n\", methodName);\n-                continue;\n-            }\n-            testAttribute(\n-                    methodName,\n-                    () -> method.findAttribute(Attributes.SIGNATURE).orElse(null),\n-                    expectedSignatures.get(methodName));\n-            foundMethods.add(methodName);\n-        }\n-        checkAllMembersFound(foundMethods, expectedSignatures,\n-                \"Checking that all methods of class \" + className + \" with Signature attribute found\");\n-    }\n-\n-    private String getMethodName(MethodModel method) {\n-        StringBuilder methodName = new StringBuilder(method.methodName().stringValue() + \"(\");\n-        List<ClassDesc> paras = method.methodTypeSymbol().parameterList();\n-        for (int i = 0; i < method.methodTypeSymbol().parameterCount(); ++i) {\n-            if (i != 0) {\n-                methodName.append(\", \");\n-            }\n-            ClassDesc para = paras.get(i);\n-            String prefix = para.componentType() == null? para.packageName(): para.componentType().packageName();\n-            methodName.append(prefix).append(Objects.equals(prefix, \"\") ? \"\":\".\").append(para.displayName());\n-        }\n-        methodName.append(\")\");\n-        return methodName.toString();\n-    }\n-\n-    private void testFields(Map<String, ExpectedSignature> expectedSignatures, ClassModel classFile) {\n-        String className = classFile.thisClass().name().stringValue();\n-        Set<String> foundFields = new HashSet<>();\n-        for (FieldModel field : classFile.fields()) {\n-            String fieldName = field.fieldName().stringValue();\n-            printf(\"Testing field %s\\n\", fieldName);\n-            testAttribute(\n-                    fieldName,\n-                    () -> field.findAttribute(Attributes.SIGNATURE).orElse(null),\n-                    expectedSignatures.get(fieldName));\n-            foundFields.add(fieldName);\n-        }\n-        checkAllMembersFound(foundFields, expectedSignatures,\n-                \"Checking that all fields of class \" + className + \" with Signature attribute found\");\n-    }\n-\n-    private void testAttribute(\n-            String memberName,\n-            Supplier<SignatureAttribute> sup,\n-            ExpectedSignature expectedSignature) {\n-\n-        SignatureAttribute attribute = sup.get();\n-        if (expectedSignature != null && checkNotNull(attribute, memberName + \" must have attribute\")) {\n-            checkEquals(attribute.attributeName(),\n-                    \"Signature\", \"Attribute's name : \" + memberName);\n-            checkEquals(((BoundAttribute<?>)attribute).payloadLen(), 2, \"Attribute's length : \" + memberName);\n-            checkEquals(attribute.signature().stringValue(),\n-                    expectedSignature.signature(),\n-                    \"Testing signature of : \" + memberName);\n-        } else {\n-            checkNull(attribute, memberName + \" must not have attribute\");\n-        }\n-    }\n@@ -233,7 +42,6 @@\n-    public static void main(String[] args) throws TestFailedException {\n-        if (args.length != 1) {\n-            throw new IllegalArgumentException(\"Usage: Driver <class-name>\");\n-        }\n-        new Driver(args[0]).test();\n-    }\n-}\n\\ No newline at end of file\n+@ExpectedSignature(descriptor = \"EnumTest\", signature = \"Ljava\/lang\/Enum<LEnumTest;>;\")\n+public enum EnumTest {;\n+    \/\/ see 8026480\n+    @ExpectedSignature(descriptor = \"<init>(java.lang.String, int)\", signature = \"()V\")\n+    private EnumTest() {}\n+}\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/Signature\/EnumTest.java","additions":23,"deletions":215,"binary":false,"changes":238,"status":"modified"}]}