{"files":[{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.security;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.math.BigInteger;\n+import java.security.*;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+\/**\n+ * Tests various algorithm settings for PKCS12 keystores.\n+ *\/\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 2)\n+@Measurement(iterations = 10)\n+@BenchmarkMode(Mode.AverageTime)\n+@Fork(jvmArgsAppend = {\"-Xms1024m\", \"-Xmx1024m\", \"-Xmn768m\", \"-XX:+UseParallelGC\"}, value = 5)\n+public class PKCS12KeyStores {\n+\n+    private static final char[] PASS = \"changeit\".toCharArray();\n+\n+    private Key pk;\n+    private Certificate[] certs;\n+\n+    \/\/ Several pkcs12 keystores in byte arrays\n+    private byte[] bw2048;\n+    private byte[] bw50000;     \/\/ Default old\n+    private byte[] bs50000;\n+    private byte[] bs10000;     \/\/ Default new\n+    private byte[] bs2048;\n+\n+    \/\/ Decodes HEX string to byte array\n+    private static byte[] xeh(String in) {\n+        return new BigInteger(in, 16).toByteArray();\n+    }\n+\n+    @Setup\n+    public void setup() throws Exception {\n+        \/\/ Just generate a keypair and dump getEncoded() of key and cert.\n+        byte[] x1 = xeh(\"3041020100301306072A8648CE3D020106082A8648CE3D03\" +\n+                \"0107042730250201010420B561D1FBE150488508BBE8FF4540F09057\" +\n+                \"58712F5D2D3CC80F9A15BA5D481117\");\n+        byte[] x2 = xeh(\"3082012D3081D5A00302010202084EE6ECC5585640A7300A\" +\n+                \"06082A8648CE3D040302300C310A30080603550403130161301E170D\" +\n+                \"3230313131373230343730355A170D3233303831343230343730355A\" +\n+                \"300C310A300806035504031301613059301306072A8648CE3D020106\" +\n+                \"082A8648CE3D030107034200041E761F511841602E272B40A021995D\" +\n+                \"1BD828DDC7F71412D6A66CC0CB858C856D32C58273E494676D1D2B05\" +\n+                \"B8E9B08207A122265C2AA5FCBDCE19E5E88CA7A1B6A321301F301D06\" +\n+                \"03551D0E04160414173F278D77096E5C8EA182D12F147694587B5D9A\" +\n+                \"300A06082A8648CE3D04030203470030440220760CEAF1FA7041CB8C\" +\n+                \"1CA80AF60E4F9C9D5136D96B2AF0AAA9440F79561C44E502205D5C72\" +\n+                \"886C92B95A681C4393C67AAEC8DA9FD7910FF9BF2BCB721AE71D1B6F88\");\n+        KeyFactory kf = KeyFactory.getInstance(\"EC\");\n+        pk = kf.generatePrivate(new PKCS8EncodedKeySpec(x1));\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+        certs = new Certificate[]{cf.generateCertificate(new ByteArrayInputStream(x2))};\n+\n+        bw2048 = outweak2048();\n+        bw50000 = outweak50000_Old();\n+        bs50000 = outstrong50000();\n+        bs10000 = outstrong10000_New();\n+        bs2048 = outstrong2048();\n+    }\n+\n+    \/\/ Reads in a pkcs12 keystore\n+    private KeyStore in(byte[] b) throws Exception {\n+        KeyStore ks = KeyStore.getInstance(\"pkcs12\");\n+        ks.load(new ByteArrayInputStream(b), PASS);\n+        if (!ks.getCertificate(\"a\").getPublicKey().getAlgorithm().equals(\n+                ks.getKey(\"a\", PASS).getAlgorithm())) {\n+            throw new RuntimeException(\"Not same alg\");\n+        }\n+        return ks;\n+    }\n+\n+    \/\/ Generates a pkcs12 keystore with the specified algorithm\/ic\n+    private byte[] out(String cAlg, String cIc, String kAlg, String kIc,\n+                      String mAlg, String mIc) throws Exception {\n+        System.setProperty(\"keystore.pkcs12.certProtectionAlgorithm\", cAlg);\n+        System.setProperty(\"keystore.pkcs12.certPbeIterationCount\", cIc);\n+        System.setProperty(\"keystore.pkcs12.keyProtectionAlgorithm\", kAlg);\n+        System.setProperty(\"keystore.pkcs12.keyPbeIterationCount\", kIc);\n+        System.setProperty(\"keystore.pkcs12.macAlgorithm\", mAlg);\n+        System.setProperty(\"keystore.pkcs12.macIterationCount\", mIc);\n+        KeyStore ks = KeyStore.getInstance(\"pkcs12\");\n+        ks.load(null, null);\n+        ks.setKeyEntry(\"a\", pk, PASS, certs);\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        ks.store(bout, PASS);\n+        return bout.toByteArray();\n+    }\n+\n+    \/\/ Benchmark methods start here:\n+\n+    \/\/ Reading a keystore\n+    @Benchmark\n+    public KeyStore inweak2048() throws Exception {\n+        return in(bw2048);\n+    }\n+\n+    @Benchmark\n+    public KeyStore inweak50000_Old() throws Exception {\n+        return in(bw50000);\n+    }\n+\n+    @Benchmark\n+    public KeyStore instrong50000() throws Exception {\n+        return in(bs50000);\n+    }\n+\n+    @Benchmark\n+    public KeyStore instrong10000_New() throws Exception {\n+        return in(bs10000);\n+    }\n+\n+    @Benchmark\n+    public KeyStore instrong2048() throws Exception {\n+        return in(bs2048);\n+    }\n+\n+    \/\/ Writing a keystore\n+    @Benchmark\n+    public byte[] outweak2048() throws Exception {\n+        return out(\"PBEWithSHA1AndRC2_40\", \"2048\",\n+                \"PBEWithSHA1AndDESede\", \"2048\",\n+                \"HmacPBESHA1\", \"2048\");\n+    }\n+\n+    @Benchmark\n+    public byte[] outweak50000_Old() throws Exception {\n+        return out(\"PBEWithSHA1AndRC2_40\", \"50000\",\n+                \"PBEWithSHA1AndDESede\", \"50000\",\n+                \"HmacPBESHA1\", \"100000\");\n+                \/\/ Attention: 100000 is old default Mac ic\n+    }\n+\n+    @Benchmark\n+    public byte[] outstrong50000() throws Exception {\n+        return out(\"PBEWithHmacSHA256AndAES_256\", \"50000\",\n+                \"PBEWithHmacSHA256AndAES_256\", \"50000\",\n+                \"HmacPBESHA256\", \"100000\");\n+                \/\/ Attention: 100000 is old default Mac ic\n+    }\n+\n+    @Benchmark\n+    public byte[] outstrong10000_New() throws Exception {\n+        return out(\"PBEWithHmacSHA256AndAES_256\", \"10000\",\n+                \"PBEWithHmacSHA256AndAES_256\", \"10000\",\n+                \"HmacPBESHA256\", \"10000\");\n+    }\n+\n+    @Benchmark\n+    public byte[] outstrong2048() throws Exception {\n+        return out(\"PBEWithHmacSHA256AndAES_256\", \"2048\",\n+                \"PBEWithHmacSHA256AndAES_256\", \"2048\",\n+                \"HmacPBESHA256\", \"2048\");\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/PKCS12KeyStores.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"}]}