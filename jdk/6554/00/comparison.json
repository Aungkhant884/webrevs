{"files":[{"patch":"@@ -546,1 +546,1 @@\n-  product(ccstr, NativeMemoryTracking, \"off\",                               \\\n+  product(ccstr, NativeMemoryTracking, DEBUG_ONLY(\"summary\") NOT_DEBUG(\"off\"), \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-#include \"memory\/guardedMemory.hpp\"\n@@ -86,7 +85,0 @@\n-#ifndef PRODUCT\n-julong os::num_mallocs = 0;         \/\/ # of calls to malloc\/realloc\n-julong os::alloc_bytes = 0;         \/\/ # of bytes allocated\n-julong os::num_frees = 0;           \/\/ # of calls to free\n-julong os::free_bytes = 0;          \/\/ # of bytes freed\n-#endif\n-\n@@ -606,20 +598,0 @@\n-\n-#define paranoid                 0  \/* only set to 1 if you suspect checking code has bug *\/\n-\n-#ifdef ASSERT\n-\n-static void verify_memory(void* ptr) {\n-  GuardedMemory guarded(ptr);\n-  if (!guarded.verify_guards()) {\n-    LogTarget(Warning, malloc, free) lt;\n-    ResourceMark rm;\n-    LogStream ls(lt);\n-    ls.print_cr(\"## nof_mallocs = \" UINT64_FORMAT \", nof_frees = \" UINT64_FORMAT, os::num_mallocs, os::num_frees);\n-    ls.print_cr(\"## memory stomp:\");\n-    guarded.print_on(&ls);\n-    fatal(\"memory stomping error\");\n-  }\n-}\n-\n-#endif\n-\n@@ -630,0 +602,1 @@\n+\n@@ -642,0 +615,13 @@\n+#ifdef ASSERT\n+static void check_crash_protection() {\n+  assert(!os::ThreadCrashProtection::is_crash_protected(Thread::current_or_null()),\n+         \"not allowed when crash protection is set\");\n+}\n+static void break_if_ptr_caught(void* ptr) {\n+  if (p2i(ptr) == (intptr_t)MallocCatchPtr) {\n+    log_warning(malloc, free)(\"ptr caught: \" PTR_FORMAT, p2i(ptr));\n+    breakpoint();\n+  }\n+}\n+#endif \/\/ ASSERT\n+\n@@ -647,2 +633,0 @@\n-  NOT_PRODUCT(inc_stat_counter(&num_mallocs, 1));\n-  NOT_PRODUCT(inc_stat_counter(&alloc_bytes, size));\n@@ -659,4 +643,1 @@\n-  \/\/ Since os::malloc can be called when the libjvm.{dll,so} is\n-  \/\/ first loaded and we don't have a thread yet we must accept NULL also here.\n-  assert(!os::ThreadCrashProtection::is_crash_protected(Thread::current_or_null()),\n-         \"malloc() not allowed when crash protection is set\");\n+  DEBUG_ONLY(check_crash_protection());\n@@ -664,19 +645,4 @@\n-  if (size == 0) {\n-    \/\/ return a valid pointer if size is zero\n-    \/\/ if NULL is returned the calling functions assume out of memory.\n-    size = 1;\n-  }\n-\n-  \/\/ NMT support\n-  NMT_TrackingLevel level = MemTracker::tracking_level();\n-  const size_t nmt_overhead =\n-      MemTracker::malloc_header_size(level) + MemTracker::malloc_footer_size(level);\n-\n-#ifndef ASSERT\n-  const size_t alloc_size = size + nmt_overhead;\n-#else\n-  const size_t alloc_size = GuardedMemory::get_total_size(size + nmt_overhead);\n-  if (size + nmt_overhead > alloc_size) { \/\/ Check for rollover.\n-    return NULL;\n-  }\n-#endif\n+  \/\/ On malloc(0), implementators of malloc(3) have the choice to return either\n+  \/\/ NULL or a unique non-NULL pointer. To unify libc behavior across our platforms\n+  \/\/ we chose the latter.\n+  size = MAX2((size_t)1, size);\n@@ -689,2 +655,5 @@\n-  u_char* ptr;\n-  ptr = (u_char*)::malloc(alloc_size);\n+  const NMT_TrackingLevel level = MemTracker::tracking_level();\n+  const size_t nmt_overhead =\n+      MemTracker::malloc_header_size(level) + MemTracker::malloc_footer_size(level);\n+\n+  const size_t outer_size = size + nmt_overhead;\n@@ -692,2 +661,2 @@\n-#ifdef ASSERT\n-  if (ptr == NULL) {\n+  void* const outer_ptr = (u_char*)::malloc(outer_size);\n+  if (outer_ptr == NULL) {\n@@ -696,3 +665,0 @@\n-  \/\/ Wrap memory with guard\n-  GuardedMemory guarded(ptr, size + nmt_overhead);\n-  ptr = guarded.get_user_ptr();\n@@ -700,8 +666,3 @@\n-  if ((intptr_t)ptr == (intptr_t)MallocCatchPtr) {\n-    log_warning(malloc, free)(\"os::malloc caught, \" SIZE_FORMAT \" bytes --> \" PTR_FORMAT, size, p2i(ptr));\n-    breakpoint();\n-  }\n-  if (paranoid) {\n-    verify_memory(ptr);\n-  }\n-#endif\n+  void* inner_ptr = MemTracker::record_malloc((address)outer_ptr, size, memflags, stack, level);\n+\n+  DEBUG_ONLY(break_if_ptr_caught(inner_ptr);)\n@@ -709,2 +670,1 @@\n-  \/\/ we do not track guard memory\n-  return MemTracker::record_malloc((address)ptr, size, memflags, stack, level);\n+  return inner_ptr;\n@@ -728,0 +688,11 @@\n+  if (memblock == NULL) {\n+    return os::malloc(size, memflags, stack);\n+  }\n+\n+  DEBUG_ONLY(check_crash_protection());\n+\n+  \/\/ On realloc(p, 0), implementators of realloc(3) have the choice to return either\n+  \/\/ NULL or a unique non-NULL pointer. To unify libc behavior across our platforms\n+  \/\/ we chose the latter.\n+  size = MAX2((size_t)1, size);\n+\n@@ -733,12 +704,1 @@\n-  if (size == 0) {\n-    \/\/ return a valid pointer if size is zero\n-    \/\/ if NULL is returned the calling functions assume out of memory.\n-    size = 1;\n-  }\n-\n-#ifndef ASSERT\n-  NOT_PRODUCT(inc_stat_counter(&num_mallocs, 1));\n-  NOT_PRODUCT(inc_stat_counter(&alloc_bytes, size));\n-   \/\/ NMT support\n-  NMT_TrackingLevel level = MemTracker::tracking_level();\n-  void* membase = MemTracker::record_free(memblock, level);\n+  const NMT_TrackingLevel level = MemTracker::tracking_level();\n@@ -747,31 +707,14 @@\n-  void* ptr = ::realloc(membase, size + nmt_overhead);\n-  return MemTracker::record_malloc(ptr, size, memflags, stack, level);\n-#else\n-  if (memblock == NULL) {\n-    return os::malloc(size, memflags, stack);\n-  }\n-  if ((intptr_t)memblock == (intptr_t)MallocCatchPtr) {\n-    log_warning(malloc, free)(\"os::realloc caught \" PTR_FORMAT, p2i(memblock));\n-    breakpoint();\n-  }\n-  \/\/ NMT support\n-  void* membase = MemTracker::malloc_base(memblock);\n-  verify_memory(membase);\n-  \/\/ always move the block\n-  void* ptr = os::malloc(size, memflags, stack);\n-  \/\/ Copy to new memory if malloc didn't fail\n-  if (ptr != NULL ) {\n-    GuardedMemory guarded(MemTracker::malloc_base(memblock));\n-    \/\/ Guard's user data contains NMT header\n-    NMT_TrackingLevel level = MemTracker::tracking_level();\n-    const size_t nmt_overhead =\n-        MemTracker::malloc_header_size(level) + MemTracker::malloc_footer_size(level);\n-    size_t memblock_size = guarded.get_user_size() - nmt_overhead;\n-    memcpy(ptr, memblock, MIN2(size, memblock_size));\n-    if (paranoid) {\n-      verify_memory(MemTracker::malloc_base(ptr));\n-    }\n-    os::free(memblock);\n-  }\n-  return ptr;\n-#endif\n+\n+  const size_t new_outer_size = size + nmt_overhead;\n+\n+  \/\/ If NMT is enabled, this checks for heap overwrites, then de-accounts the old block.\n+  void* const old_outer_ptr = MemTracker::record_free(memblock, level);\n+\n+  void* const new_outer_ptr = ::realloc(old_outer_ptr, new_outer_size);\n+\n+  \/\/ If NMT is enabled, this checks for heap overwrites, then de-accounts the old block.\n+  void* const new_inner_ptr = MemTracker::record_malloc(new_outer_ptr, size, memflags, stack, level);\n+\n+  DEBUG_ONLY(break_if_ptr_caught(new_inner_ptr);)\n+\n+  return new_inner_ptr;\n@@ -780,1 +723,0 @@\n-\/\/ handles NULL pointers\n@@ -789,6 +731,2 @@\n-  NOT_PRODUCT(inc_stat_counter(&num_frees, 1));\n-#ifdef ASSERT\n-  if (memblock == NULL) return;\n-  if ((intptr_t)memblock == (intptr_t)MallocCatchPtr) {\n-    log_warning(malloc, free)(\"os::free caught \" PTR_FORMAT, p2i(memblock));\n-    breakpoint();\n+  if (memblock == NULL) {\n+    return;\n@@ -796,12 +734,8 @@\n-  void* membase = MemTracker::record_free(memblock, MemTracker::tracking_level());\n-  verify_memory(membase);\n-\n-  GuardedMemory guarded(membase);\n-  size_t size = guarded.get_user_size();\n-  inc_stat_counter(&free_bytes, size);\n-  membase = guarded.release_for_freeing();\n-  ::free(membase);\n-#else\n-  void* membase = MemTracker::record_free(memblock, MemTracker::tracking_level());\n-  ::free(membase);\n-#endif\n+\n+  DEBUG_ONLY(break_if_ptr_caught(memblock);)\n+\n+  const NMT_TrackingLevel level = MemTracker::tracking_level();\n+\n+  \/\/ If NMT is enabled, this checks for heap overwrites, then de-accounts the old block.\n+  void* const old_outer_ptr = MemTracker::record_free(memblock, level);\n+  ::free(old_outer_ptr);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":66,"deletions":132,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -787,7 +787,0 @@\n-#ifndef PRODUCT\n-  static julong num_mallocs;         \/\/ # of calls to malloc\/realloc\n-  static julong alloc_bytes;         \/\/ # of bytes allocated\n-  static julong num_frees;           \/\/ # of calls to free\n-  static julong free_bytes;          \/\/ # of bytes freed\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,4 +27,9 @@\n- * This tests NMT by running gtests with NMT enabled.\n- *\n- * To save time, we just run them for debug builds (where we would catch assertions) and only a selection of tests\n- * (namely, NMT tests themselves, and - for the detail statistics - os tests, since those reserve a lot and stress NMT)\n+ * This tests NMT by running gtests with NMT enabled (only those which are relevant for NMT)\n+ *\/\n+\n+\/* @test id=nmt-off\n+ * @summary Run NMT-related gtests with NMT switched off\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=NMT*:os* -XX:NativeMemoryTracking=off\n@@ -38,2 +43,1 @@\n- * @requires vm.debug\n- * @run main\/native GTestWrapper --gtest_filter=NMT* -XX:NativeMemoryTracking=summary\n+ * @run main\/native GTestWrapper --gtest_filter=NMT*:os* -XX:NativeMemoryTracking=summary\n@@ -47,1 +51,0 @@\n- * @requires vm.debug\n","filename":"test\/hotspot\/jtreg\/gtest\/NMTGtests.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.test.lib.Platform;\n@@ -50,4 +51,6 @@\n-      \/\/ First run without enabling NMT\n-      pb = ProcessTools.createJavaProcessBuilder(\"-Dtest.jdk=\" + testjdkPath, \"JcmdWithNMTDisabled\");\n-      output = new OutputAnalyzer(pb.start());\n-      output.shouldHaveExitValue(0);\n+      \/\/ First run without enabling NMT (not in debug, where NMT is by default on)\n+      if (!Platform.isDebugBuild()) {\n+        pb = ProcessTools.createJavaProcessBuilder(\"-Dtest.jdk=\" + testjdkPath, \"JcmdWithNMTDisabled\");\n+        output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+      }\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/JcmdWithNMTDisabled.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-      \"-XX:+PrintNMTStatistics\",\n+      \"-XX:+PrintNMTStatistics\", \"-XX:NativeMemoryTracking=off\",\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/PrintNMTStatisticsWithNMTDisabled.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}