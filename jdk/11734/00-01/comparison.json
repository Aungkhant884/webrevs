{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,10 +39,1 @@\n-        \/\/ If cgroups is not configured, report success.\n-        Metrics metrics = Metrics.systemMetrics();\n-        if (metrics == null) {\n-            System.out.println(\"TEST PASSED!!!\");\n-            return;\n-        }\n-\n-        MetricsTester metricsTester = new MetricsTester();\n-        metricsTester.testAll(metrics);\n-        System.out.println(\"TEST PASSED!!!\");\n+        MetricsTester.main(args);\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestCgroupMetrics.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+            opts.addClassOptions(\"-incontainer\");\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestSystemMetrics.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+    public void testMemoryUsage() throws Exception;\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/CgroupMetricsTester.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Red Hat Inc.\n+ * Copyright (c) 2020, 2022, Red Hat Inc.\n@@ -55,1 +55,1 @@\n-    public void testAll(Metrics m) throws Exception {\n+    private void testAll(Metrics m, boolean inContainer) throws Exception {\n@@ -61,1 +61,10 @@\n-        tester.testMemorySubsystem();\n+        if (!inContainer) {\n+          \/\/ If not running in a container, these test cases query the memory usage.\n+          \/\/ of all processes in the entire system (or those belonging to the current\n+          \/\/ Linux user). They cannot produce predictable results due to interference\n+          \/\/ from unrelated processes.\n+          System.out.println(\"testMemorySubsystem and testMemoryUsage skipped\");\n+        } else {\n+          tester.testMemorySubsystem();\n+          tester.testMemoryUsage();\n+        }\n@@ -73,0 +82,6 @@\n+        boolean inContainer = false;\n+        if (args.length > 0 && \"-incontainer\".equals(args[0])) {\n+          inContainer = true;\n+        }\n+        System.out.println(\"inContainer = \" + inContainer);\n+\n@@ -74,1 +89,1 @@\n-        metricsTester.testAll(m);\n+        metricsTester.testAll(m, inContainer);\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTester.java","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -530,0 +530,29 @@\n+    public void testMemoryUsage() throws Exception {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        long memoryMaxUsage = metrics.getMemoryMaxUsage();\n+        long memoryUsage = metrics.getMemoryUsage();\n+        long newMemoryMaxUsage = 0, newMemoryUsage = 0;\n+\n+        \/\/ allocate memory in a loop and check more than once for new values\n+        \/\/ otherwise we might see seldom the effect of decreasing new memory values\n+        \/\/ e.g. because the system could free up memory\n+        byte[][] bytes = new byte[32][];\n+        for (int i = 0; i < 32; i++) {\n+            bytes[i] = new byte[8*1024*1024];\n+            newMemoryUsage = metrics.getMemoryUsage();\n+            if (newMemoryUsage > memoryUsage) {\n+                break;\n+            }\n+        }\n+        newMemoryMaxUsage = metrics.getMemoryMaxUsage();\n+\n+        if (newMemoryMaxUsage < memoryMaxUsage) {\n+            fail(Controller.MEMORY, \"getMemoryMaxUsage\", memoryMaxUsage,\n+                    newMemoryMaxUsage);\n+        }\n+\n+        if (newMemoryUsage < memoryUsage) {\n+            fail(Controller.MEMORY, \"getMemoryUsage\", memoryUsage, newMemoryUsage);\n+        }\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTesterCgroupV1.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -418,0 +418,23 @@\n+    @Override\n+    public void testMemoryUsage() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        long memoryUsage = metrics.getMemoryUsage();\n+        long newMemoryUsage = 0;\n+\n+        \/\/ allocate memory in a loop and check more than once for new values\n+        \/\/ otherwise we might occasionally see the effect of decreasing new memory\n+        \/\/ values. For example because the system could free up memory\n+        byte[][] bytes = new byte[32][];\n+        for (int i = 0; i < 32; i++) {\n+            bytes[i] = new byte[8*1024*1024];\n+            newMemoryUsage = metrics.getMemoryUsage();\n+            if (newMemoryUsage > memoryUsage) {\n+                break;\n+            }\n+        }\n+\n+        if (newMemoryUsage < memoryUsage) {\n+            fail(\"getMemoryUsage\", memoryUsage, newMemoryUsage);\n+        }\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTesterCgroupV2.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"}]}