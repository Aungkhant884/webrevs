{"files":[{"patch":"@@ -386,1 +386,1 @@\n-        freq.print(\"%.8f\", block->_freq \/ max_freq);\n+        freq.print(\"%.8f\", block->_freq \/ _max_freq);\n@@ -395,18 +395,18 @@\n-    case Type::CATEGORY::CatData:\n-      print_prop(\"category\", \"data\");\n-      break;\n-    case Type::CATEGORY::CatMemory:\n-      print_prop(\"category\", \"memory\");\n-      break;\n-    case Type::CATEGORY::CatMixed:\n-      print_prop(\"category\", \"mixed\");\n-      break;\n-    case Type::CATEGORY::CatControl:\n-      print_prop(\"category\", \"control\");\n-      break;\n-    case Type::CATEGORY::CatOther:\n-      print_prop(\"category\", \"other\");\n-      break;\n-    case Type::CATEGORY::CatUndef:\n-      print_prop(\"category\", \"undef\");\n-      break;\n+      case Type::Category::Data:\n+        print_prop(\"category\", \"data\");\n+        break;\n+      case Type::Category::Memory:\n+        print_prop(\"category\", \"memory\");\n+        break;\n+      case Type::Category::Mixed:\n+        print_prop(\"category\", \"mixed\");\n+        break;\n+      case Type::Category::Control:\n+        print_prop(\"category\", \"control\");\n+        break;\n+      case Type::Category::Other:\n+        print_prop(\"category\", \"other\");\n+        break;\n+      case Type::Category::Undef:\n+        print_prop(\"category\", \"undef\");\n+        break;\n@@ -685,1 +685,1 @@\n-    max_freq = 1.0e-6;\n+    _max_freq = 1.0e-6;\n@@ -688,2 +688,2 @@\n-      if (block->_freq > max_freq) {\n-        max_freq = block->_freq;\n+      if (block->_freq > _max_freq) {\n+        _max_freq = block->_freq;\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-  double max_freq;\n+  double _max_freq;\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1118,1 +1118,1 @@\n-Type::CATEGORY Type::category() const {\n+Type::Category Type::category() const {\n@@ -1121,51 +1121,52 @@\n-  case Type::Int:\n-  case Type::Long:\n-  case Type::Half:\n-  case Type::NarrowOop:\n-  case Type::NarrowKlass:\n-  case Type::Array:\n-  case Type::VectorA:\n-  case Type::VectorS:\n-  case Type::VectorD:\n-  case Type::VectorX:\n-  case Type::VectorY:\n-  case Type::VectorZ:\n-  case Type::AnyPtr:\n-  case Type::RawPtr:\n-  case Type::OopPtr:\n-  case Type::InstPtr:\n-  case Type::AryPtr:\n-  case Type::MetadataPtr:\n-  case Type::KlassPtr:\n-  case Type::Function:\n-  case Type::Return_Address:\n-  case Type::FloatTop:\n-  case Type::FloatCon:\n-  case Type::FloatBot:\n-  case Type::DoubleTop:\n-  case Type::DoubleCon:\n-  case Type::DoubleBot:\n-    return CatData;\n-  case Type::Memory:\n-    return CatMemory;\n-  case Type::Control:\n-    return CatControl;\n-  case Type::Top:\n-  case Type::Abio:\n-  case Type::Bottom:\n-    return CatOther;\n-  case Type::Bad:\n-  case Type::lastype:\n-    return CatUndef;\n-  case Type::Tuple:\n-    \/\/ Recursive case. Return CatMixed if the tuple contains types of different\n-    \/\/ categories (e.g. CallStaticJavaNode's type), or the specific category if\n-    \/\/ all types are of the same category (e.g. IfNode's type).\n-    tuple = is_tuple();\n-    if (tuple->cnt() == 0) {\n-      return CatUndef;\n-    } else {\n-      CATEGORY first = tuple->field_at(0)->category();\n-      for (uint i = 1; i < tuple->cnt(); i++) {\n-        if (tuple->field_at(i)->category() != first) {\n-          return CatMixed;\n+    case Type::Int:\n+    case Type::Long:\n+    case Type::Half:\n+    case Type::NarrowOop:\n+    case Type::NarrowKlass:\n+    case Type::Array:\n+    case Type::VectorA:\n+    case Type::VectorS:\n+    case Type::VectorD:\n+    case Type::VectorX:\n+    case Type::VectorY:\n+    case Type::VectorZ:\n+    case Type::AnyPtr:\n+    case Type::RawPtr:\n+    case Type::OopPtr:\n+    case Type::InstPtr:\n+    case Type::AryPtr:\n+    case Type::MetadataPtr:\n+    case Type::KlassPtr:\n+    case Type::Function:\n+    case Type::Return_Address:\n+    case Type::FloatTop:\n+    case Type::FloatCon:\n+    case Type::FloatBot:\n+    case Type::DoubleTop:\n+    case Type::DoubleCon:\n+    case Type::DoubleBot:\n+      return Category::Data;\n+    case Type::Memory:\n+      return Category::Memory;\n+    case Type::Control:\n+      return Category::Control;\n+    case Type::Top:\n+    case Type::Abio:\n+    case Type::Bottom:\n+      return Category::Other;\n+    case Type::Bad:\n+    case Type::lastype:\n+      return Category::Undef;\n+    case Type::Tuple:\n+      \/\/ Recursive case. Return CatMixed if the tuple contains types of\n+      \/\/ different categories (e.g. CallStaticJavaNode's type), or the specific\n+      \/\/ category if all types are of the same category (e.g. IfNode's type).\n+      tuple = is_tuple();\n+      if (tuple->cnt() == 0) {\n+        return Category::Undef;\n+      } else {\n+        Category first = tuple->field_at(0)->category();\n+        for (uint i = 1; i < tuple->cnt(); i++) {\n+          if (tuple->field_at(i)->category() != first) {\n+            return Category::Mixed;\n+          }\n@@ -1173,0 +1174,1 @@\n+        return first;\n@@ -1174,2 +1176,2 @@\n-      return first;\n-    }\n+    default:\n+      assert(false, \"unmatched base type: all base types must be categorized\");\n@@ -1177,2 +1179,1 @@\n-  assert(false, \"unmatched base type\");\n-  return CatUndef;\n+  return Category::Undef;\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":57,"deletions":56,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -368,7 +368,7 @@\n-  enum CATEGORY {\n-    CatData,\n-    CatMemory,\n-    CatMixed,   \/\/ Tuples with types of different categories.\n-    CatControl,\n-    CatOther,   \/\/ {Type::Top, Type::Abio, Type::Bottom}.\n-    CatUndef    \/\/ {Type::Bad, Type::lastype}, for completeness.\n+  enum class Category {\n+    Data,\n+    Memory,\n+    Mixed,   \/\/ Tuples with types of different categories.\n+    Control,\n+    Other,   \/\/ {Type::Top, Type::Abio, Type::Bottom}.\n+    Undef    \/\/ {Type::Bad, Type::lastype}, for completeness.\n@@ -377,1 +377,1 @@\n-  CATEGORY category() const;\n+  Category category() const;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,3 @@\n+\/\/ Remove all nodes except control, mixed, and nodes of 'bottom' type that are\n+\/\/ successors of control nodes (typically 'Halt', 'Return', etc.).\n+\n@@ -6,1 +9,4 @@\n-        new OrSelector(\n+        new MatcherSelector(\n+          new Properties.RegexpPropertyMatcher(\"category\", \"control|mixed\")\n+        ),\n+        new AndSelector(\n@@ -9,1 +15,1 @@\n-              new Properties.StringPropertyMatcher(\"type\", \"control\")\n+              new Properties.RegexpPropertyMatcher(\"type\", \"control\")\n@@ -12,2 +18,2 @@\n-\t  new MatcherSelector(\n-            new Properties.StringPropertyMatcher(\"type\", \"control\")\n+          new MatcherSelector(\n+            new Properties.RegexpPropertyMatcher(\"type\", \"bottom\")\n@@ -15,3 +21,0 @@\n-        ),\n-\tnew MatcherSelector(\n-          new Properties.StringPropertyMatcher(\"name\", \"Start\")\n@@ -20,1 +23,2 @@\n-    ), false\n+    ),\n+    false\n@@ -23,1 +27,0 @@\n-f.addRule(new RemoveFilter.RemoveRule(new MatcherSelector(new Properties.RegexpPropertyMatcher(\"name\", \"Phi|CreateEx|Cast.*|Load.|Store.\"))));\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/onlyControlFlow.filter","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"}]}