{"files":[{"patch":"@@ -525,2 +525,74 @@\n-                indent();\n-                writer.println(annotationMirror);\n+                \/\/ Handle compiler-generated container annotations specially\n+                if (!printedContainerAnnotation(e, annotationMirror)) {\n+                    indent();\n+                    writer.println(annotationMirror);\n+                }\n+            }\n+        }\n+\n+        private boolean printedContainerAnnotation(Element e,\n+                                                   AnnotationMirror annotationMirror) {\n+            \/*\n+             * If the annotation mirror is marked as mandated and\n+             * looks like a container annotation, elide printing the\n+             * container and just print the wrapped contents.\n+             *\/\n+            if (elementUtils.getOrigin(e, annotationMirror) == Elements.Origin.MANDATED) {\n+                \/\/ From JLS Chapter 9, an annotation interface AC is a\n+                \/\/ containing annotation interface of A if AC declares\n+                \/\/ a value() method whose return type is A[] and any\n+                \/\/ methods declared by AC other than value() have a\n+                \/\/ default value. As an implementation choice, if more\n+                \/\/ than one annotation element is found on the outer\n+                \/\/ annotation, in other words, something besides a\n+                \/\/ \"value\" method, the annotation will not be treated\n+                \/\/ as a wrapper for the purposes of printing. These\n+                \/\/ checks are intended to preserve correctness in the\n+                \/\/ face of some other kind of annotation being marked\n+                \/\/ as mandated.\n+\n+                var entries = annotationMirror.getElementValues().entrySet();\n+                if (entries.size() == 1) {\n+                    var annotationType = annotationMirror.getAnnotationType();\n+                    var annotationTypeAsElement = annotationType.asElement();\n+\n+                    var entry = entries.iterator().next();\n+                    var annotationElements = entry.getValue();\n+\n+                    \/\/ Check that the annotation type declaration has\n+                    \/\/ a single method named \"value\" and that it\n+                    \/\/ returns an array. A stricter check would be\n+                    \/\/ that it is an array of an annotation type and\n+                    \/\/ that annotation type in turn was repeatable.\n+                    if (annotationTypeAsElement.getKind() == ElementKind.ANNOTATION_TYPE) {\n+                        var annotationMethods =\n+                            ElementFilter.methodsIn(annotationTypeAsElement.getEnclosedElements());\n+                        if (annotationMethods.size() == 1) {\n+                            var valueMethod = annotationMethods.get(0);\n+                            var returnType = valueMethod.getReturnType();\n+\n+                            if (\"value\".equals(valueMethod.getSimpleName().toString()) &&\n+                                returnType.getKind() == TypeKind.ARRAY) {\n+                                \/\/ Use annotation value visitor that\n+                                \/\/ returns a boolean if it prints out\n+                                \/\/ contained annotations as expected\n+                                \/\/ and false otherwise\n+\n+                                return (new SimpleAnnotationValueVisitor14<Boolean, Void>(false) {\n+                                    @Override\n+                                    public Boolean visitArray(List<? extends AnnotationValue> vals, Void p) {\n+                                        if (vals.size() < 2) {\n+                                            return false;\n+                                        } else {\n+                                            for (var annotValue: vals) {\n+                                                indent();\n+                                                writer.println(annotValue.toString());\n+                                            }\n+                                            return true;\n+                                        }\n+                                    }\n+                                }).visit(annotationElements);\n+                            }\n+                        }\n+                    }\n+                }\n@@ -528,0 +600,1 @@\n+            return false;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/PrintingProcessor.java","additions":75,"deletions":2,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8005295\n+ * @summary Verify repeating annotations are printed as expected\n+ * @compile\/ref=XprintRepeatingAnnotations.out -Xprint  XprintRepeatingAnnotations.java\n+ *\/\n+\n+import java.lang.annotation.*;\n+import static java.lang.annotation.RetentionPolicy.*;\n+\n+@Foo(1)\n+@Foo(2)\n+@Bar(3)\n+@Bar(4)\n+public class XprintRepeatingAnnotations {\n+}\n+\n+@Retention(RUNTIME)\n+@Documented\n+@Repeatable(Foos.class)\n+@interface Foo {\n+    int value();\n+}\n+\n+@Retention(RUNTIME)\n+@Documented\n+@interface Foos {\n+    Foo[] value();\n+}\n+\n+@Retention(RUNTIME)\n+@Documented\n+@Repeatable(Bars.class)\n+@interface Bar {\n+    int value();\n+}\n+\n+@Retention(RUNTIME)\n+@Documented\n+@interface Bars {\n+    Bar[] value();\n+    int quux() default 1;\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/options\/XprintRepeatingAnnotations.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\n+@Foo(1)\n+@Foo(2)\n+@Bars({@Bar(3), @Bar(4)})\n+public class XprintRepeatingAnnotations {\n+\n+  public XprintRepeatingAnnotations();\n+}\n+\n+@java.lang.annotation.Retention(RUNTIME)\n+@java.lang.annotation.Documented\n+@java.lang.annotation.Repeatable(Foos.class)\n+@interface Foo {\n+\n+  int value();\n+}\n+\n+@java.lang.annotation.Retention(RUNTIME)\n+@java.lang.annotation.Documented\n+@interface Foos {\n+\n+  Foo[] value();\n+}\n+\n+@java.lang.annotation.Retention(RUNTIME)\n+@java.lang.annotation.Documented\n+@java.lang.annotation.Repeatable(Bars.class)\n+@interface Bar {\n+\n+  int value();\n+}\n+\n+@java.lang.annotation.Retention(RUNTIME)\n+@java.lang.annotation.Documented\n+@interface Bars {\n+\n+  Bar[] value();\n+\n+  int quux() default 1;\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/options\/XprintRepeatingAnnotations.out","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"}]}