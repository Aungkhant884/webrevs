{"files":[{"patch":"@@ -33,1 +33,1 @@\n- * {@code MatchException} may be thrown when an exhaustive pattern matching language construct\n+ * <p>{@code MatchException} may be thrown when an exhaustive pattern matching language construct\n@@ -35,5 +35,27 @@\n- * patterns at runtime. This can currently arise for separate compilation anomalies,\n- * where a sealed interface has a different set of permitted subtypes at runtime than\n- * it had at compilation time, an enum has a different set of constants at runtime than\n- * it had at compilation time, or the type hierarchy has changed in incompatible ways between\n- * compile time and run time.\n+ * patterns at runtime. This can arise from a number of cases:\n+ * <ul>\n+ *    <li>Separate compilation anomalies, where a sealed interface has a different set of permitted\n+ *        subtypes at runtime than it had at compilation time, an enum has a different set of\n+ *        constants at runtime than it had at compilation time, or the type hierarchy has changed\n+ *        in incompatible ways between compile time and run time.<\/li>\n+ *    <li>{@code null} values and nested patterns using sealed types. If an interface or abstract\n+ *        class {@code C} is sealed to permit {@code A} and {@code B}, then the set of record\n+ *        patterns {@code R(A a)} and {@code R(B b)} are exhaustive on a record {@code R} whose\n+ *        sole component is of type {@code C}, but neither of these patterns will match\n+ *        {@code new R(null)}.<\/li>\n+ *    <li>Null targets and nested record patterns. Given a record type {@code R} whose sole\n+ *        component is {@code S}, which in turn is a record whose sole component is {@code String},\n+ *        then the nested record pattern {@code R(S(String s))} will not match {@code new R(null)}.<\/li>\n+ * <\/ul>\n+ *\n+ * <p>Match failures arising from unexpected inputs will generally throw {@code MatchException} only\n+ * after all patterns have been tried; even if {@code R(S(String s))} does not match\n+ * {@code new R(null)}, a later pattern (such as {@code R r}) may still match the target.\n+ *\n+ * <p>MatchException may also be thrown when operations performed as part of pattern matching throw\n+ * an unexpected exception. For example, pattern matching may cause methods such as record component\n+ * accessors to be implicitly invoked in order to extract pattern bindings. If these methods throw\n+ * an exception, execution of the pattern matching construct may fail with {@code MatchException}.\n+ * The original exception will be set as a {@link Throwable#getCause() cause} of\n+ * the {@code MatchException}. No {@link Throwable#addSuppressed(java.lang.Throwable) suppressed}\n+ * exceptions will be recorded.\n@@ -45,1 +67,1 @@\n- * @since   19\n+ * @since 19\n","filename":"src\/java.base\/share\/classes\/java\/lang\/MatchException.java","additions":29,"deletions":7,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+        RECORD_PATTERNS,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.source.tree;\n+\n+import java.util.List;\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A deconstruction pattern tree.\n+ *\n+ * @since 19\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n+public interface DeconstructionPatternTree extends PatternTree {\n+\n+    \/**\n+     * Returns the deconstructed type.\n+     * @return the deconstructed type\n+     *\/\n+    ExpressionTree getDeconstructor();\n+\n+    \/**\n+     * Returns the nested patterns.\n+     * @return the nested patterns.\n+     *\/\n+    List<? extends PatternTree> getNestedPatterns();\n+\n+    \/**\n+     * Returns the binding variable.\n+     * @return the binding variable\n+     *\/\n+    VariableTree getVariable();\n+\n+}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/DeconstructionPatternTree.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -247,0 +247,8 @@\n+        \/**\n+         * Used for instances of {@link DeconstructionPatternTree}.\n+         *\n+         * @since 19\n+         *\/\n+        @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n+        DECONSTRUCTION_PATTERN(DeconstructionPatternTree.class),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -281,0 +281,10 @@\n+    \/**\n+     * Visits a {@code DeconstructionPatternTree} node.\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     * @since 19\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n+    R visitDeconstructionPattern(DeconstructionPatternTree node, P p);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -670,0 +670,14 @@\n+     * @since 19\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n+    public R visitDeconstructionPattern(DeconstructionPatternTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -803,0 +803,18 @@\n+     * @since 19\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n+    public R visitDeconstructionPattern(DeconstructionPatternTree node, P p) {\n+        R r = scan(node.getDeconstructor(), p);\n+        r = scanAndReduce(node.getNestedPatterns(), p, r);\n+        r = scanAndReduce(node.getVariable(), p, r);\n+        r = scanAndReduce(node.getGuard(), p, r);\n+        return r;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -190,0 +190,1 @@\n+            case RECORD_PATTERNS -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -243,0 +243,1 @@\n+        RECORD_PATTERNS(JDK19, Fragments.FeatureDeconstructionPatterns, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.stream.Stream;\n@@ -1798,1 +1799,1 @@\n-                        boolean unconditional = TreeInfo.unrefinedCaseLabel(pat);\n+                        boolean unconditional = TreeInfo.unrefinedCaseLabel(pat) && !pat.hasTag(RECORDPATTERN);\n@@ -4112,1 +4113,2 @@\n-           tree.pattern.getTag() == PARENTHESIZEDPATTERN) {\n+            tree.pattern.getTag() == PARENTHESIZEDPATTERN ||\n+            tree.pattern.getTag() == RECORDPATTERN) {\n@@ -4116,1 +4118,2 @@\n-                !exprtype.isErroneous() && !clazztype.isErroneous()) {\n+                !exprtype.isErroneous() && !clazztype.isErroneous() &&\n+                tree.pattern.getTag() != RECORDPATTERN) {\n@@ -4123,1 +4126,1 @@\n-            typeTree = TreeInfo.primaryPatternTree((JCPattern) tree.pattern).var.vartype;\n+            typeTree = TreeInfo.primaryPatternTypeTree((JCPattern) tree.pattern);\n@@ -4157,1 +4160,4 @@\n-        } else if (exprType.isPrimitive() ^ pattType.isPrimitive()) {\n+        } else if ((exprType.isPrimitive() || pattType.isPrimitive()) &&\n+                   (!exprType.isPrimitive() ||\n+                    !pattType.isPrimitive() ||\n+                    !types.isSameType(exprType, pattType))) {\n@@ -4171,3 +4177,9 @@\n-        ResultInfo varInfo = new ResultInfo(KindSelector.TYP, resultInfo.pt, resultInfo.checkContext);\n-        tree.type = tree.var.type = attribTree(tree.var.vartype, env, varInfo);\n-        BindingSymbol v = new BindingSymbol(tree.var.mods.flags, tree.var.name, tree.var.vartype.type, env.info.scope.owner);\n+        Type type;\n+        if (tree.var.vartype != null) {\n+            ResultInfo varInfo = new ResultInfo(KindSelector.TYP, resultInfo.pt, resultInfo.checkContext);\n+            type = attribTree(tree.var.vartype, env, varInfo);\n+        } else {\n+            type = resultInfo.pt;\n+        }\n+        tree.type = tree.var.type = type;\n+        BindingSymbol v = new BindingSymbol(tree.var.mods.flags, tree.var.name, type, env.info.scope.owner);\n@@ -4179,3 +4191,5 @@\n-        annotate.annotateLater(tree.var.mods.annotations, env, v, tree.pos());\n-        annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, env, v, tree.var.pos());\n-        annotate.flush();\n+        if (tree.var.vartype != null) {\n+            annotate.annotateLater(tree.var.mods.annotations, env, v, tree.pos());\n+            annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, env, v, tree.var.pos());\n+            annotate.flush();\n+        }\n@@ -4188,0 +4202,69 @@\n+    public void visitRecordPattern(JCRecordPattern tree) {\n+        tree.type = attribType(tree.deconstructor, env);\n+        Type site = types.removeWildcards(tree.type);\n+        List<Type> expectedRecordTypes;\n+        if (site.tsym.kind == Kind.TYP && ((ClassSymbol) site.tsym).isRecord()) {\n+            ClassSymbol record = (ClassSymbol) site.tsym;\n+            if (record.type.getTypeArguments().nonEmpty() && tree.type.isRaw()) {\n+                log.error(tree.pos(),Errors.RawDeconstructionPattern);\n+            }\n+            expectedRecordTypes = record.getRecordComponents()\n+                                        .stream()\n+                                        .map(rc -> types.memberType(site, rc)).collect(List.collector());\n+            tree.record = record;\n+        } else {\n+            log.error(tree.pos(), Errors.DeconstructionPatternOnlyRecords(site.tsym));\n+            expectedRecordTypes = Stream.generate(() -> Type.noType)\n+                                .limit(tree.nested.size())\n+                                .collect(List.collector());\n+        }\n+        ListBuffer<BindingSymbol> outBindings = new ListBuffer<>();\n+        List<Type> recordTypes = expectedRecordTypes;\n+        List<JCPattern> nestedPatterns = tree.nested;\n+        Env<AttrContext> localEnv = env.dup(tree, env.info.dup(env.info.scope.dup()));\n+        try {\n+            while (recordTypes.nonEmpty() && nestedPatterns.nonEmpty()) {\n+                boolean nestedIsVarPattern = false;\n+                nestedIsVarPattern |= nestedPatterns.head.hasTag(BINDINGPATTERN) &&\n+                                      ((JCBindingPattern) nestedPatterns.head).var.vartype == null;\n+                attribExpr(nestedPatterns.head, localEnv, nestedIsVarPattern ? recordTypes.head : Type.noType);\n+                checkCastablePattern(nestedPatterns.head.pos(), recordTypes.head, nestedPatterns.head.type);\n+                outBindings.addAll(matchBindings.bindingsWhenTrue);\n+                matchBindings.bindingsWhenTrue.forEach(localEnv.info.scope::enter);\n+                nestedPatterns = nestedPatterns.tail;\n+                recordTypes = recordTypes.tail;\n+            }\n+            if (recordTypes.nonEmpty() || nestedPatterns.nonEmpty()) {\n+                while (nestedPatterns.nonEmpty()) {\n+                    attribExpr(nestedPatterns.head, localEnv, Type.noType);\n+                    nestedPatterns = nestedPatterns.tail;\n+                }\n+                List<Type> nestedTypes =\n+                        tree.nested.stream().map(p -> p.type).collect(List.collector());\n+                log.error(tree.pos(),\n+                          Errors.IncorrectNumberOfNestedPatterns(expectedRecordTypes,\n+                                                                 nestedTypes));\n+            }\n+            if (tree.var != null) {\n+                BindingSymbol v = new BindingSymbol(tree.var.mods.flags, tree.var.name, tree.type,\n+                                                    localEnv.info.scope.owner);\n+                v.pos = tree.pos;\n+                tree.var.sym = v;\n+                if (chk.checkUnique(tree.var.pos(), v, localEnv.info.scope)) {\n+                    chk.checkTransparentVar(tree.var.pos(), v, localEnv.info.scope);\n+                }\n+                if (tree.var.vartype != null) {\n+                    annotate.annotateLater(tree.var.mods.annotations, localEnv, v, tree.pos());\n+                    annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, localEnv, v, tree.var.pos());\n+                    annotate.flush();\n+                }\n+                outBindings.add(v);\n+            }\n+        } finally {\n+            localEnv.info.scope.leave();\n+        }\n+        chk.validate(tree.deconstructor, env, true);\n+        result = tree.type;\n+        matchBindings = new MatchBindings(outBindings.toList(), List.nil());\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":94,"deletions":11,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import java.util.Map;\n+import java.util.Map.Entry;\n@@ -33,0 +35,1 @@\n+import java.util.stream.Collectors;\n@@ -56,0 +59,1 @@\n+import static com.sun.tools.javac.code.TypeTag.NONE;\n@@ -668,1 +672,0 @@\n-            Set<Symbol> constants = exhaustiveSwitch ? new HashSet<>() : null;\n@@ -674,3 +677,0 @@\n-                    if (TreeInfo.unrefinedCaseLabel(pat)) {\n-                        handleConstantCaseLabel(constants, pat);\n-                    }\n@@ -694,1 +694,2 @@\n-                tree.isExhaustive |= isExhaustive(tree.selector.pos(), tree.selector.type, constants);\n+                Set<Symbol> coveredSymbols = coveredSymbolsForCases(tree.pos(), tree.selector, tree.cases);\n+                tree.isExhaustive |= isExhaustive(tree.selector.pos(), tree.selector.type, coveredSymbols);\n@@ -710,1 +711,0 @@\n-            Set<Symbol> constants = new HashSet<>();\n@@ -717,3 +717,0 @@\n-                    if (TreeInfo.unrefinedCaseLabel(pat)) {\n-                        handleConstantCaseLabel(constants, pat);\n-                    }\n@@ -732,0 +729,1 @@\n+            Set<Symbol> coveredSymbols = coveredSymbolsForCases(tree.pos(), tree.selector, tree.cases);\n@@ -734,1 +732,1 @@\n-                                isExhaustive(tree.selector.pos(), tree.selector.type, constants);\n+                                isExhaustive(tree.selector.pos(), tree.selector.type, coveredSymbols);\n@@ -742,8 +740,117 @@\n-        private void handleConstantCaseLabel(Set<Symbol> constants, JCCaseLabel pat) {\n-            if (constants != null) {\n-                if (pat.isExpression()) {\n-                    JCExpression expr = (JCExpression) pat;\n-                    if (expr.hasTag(IDENT) && ((JCIdent) expr).sym.isEnum())\n-                        constants.add(((JCIdent) expr).sym);\n-                } else if (pat.isPattern()) {\n-                    PatternPrimaryType patternType = TreeInfo.primaryPatternType(pat);\n+        private Set<Symbol> coveredSymbolsForCases(DiagnosticPosition pos,\n+                                                   JCExpression selector, List<JCCase> cases) {\n+            HashSet<JCCaseLabel> labels = cases.stream()\n+                                               .flatMap(c -> c.labels.stream())\n+                                               .filter(TreeInfo::unrefinedCaseLabel)\n+                                               .collect(Collectors.toCollection(HashSet::new));\n+            return coveredSymbols(pos, selector.type, labels);\n+        }\n+\n+        private Set<Symbol> coveredSymbols(DiagnosticPosition pos, Type targetType,\n+                                           Iterable<? extends JCCaseLabel> labels) {\n+            Set<Symbol> coveredSymbols = new HashSet<>();\n+            Map<Symbol, List<JCRecordPattern>> deconstructionPatternsBySymbol = new HashMap<>();\n+\n+            for (JCCaseLabel label : labels) {\n+                switch (label.getTag()) {\n+                    case BINDINGPATTERN, PARENTHESIZEDPATTERN -> {\n+                        PatternPrimaryType primaryPatternType = TreeInfo.primaryPatternType((JCPattern) label);\n+                        if (!primaryPatternType.type().hasTag(NONE)) {\n+                            coveredSymbols.add(primaryPatternType.type().tsym);\n+                        }\n+                    }\n+                    case RECORDPATTERN -> {\n+                        JCRecordPattern dpat = (JCRecordPattern) label;\n+                        Symbol type = dpat.record;\n+                        List<JCRecordPattern> augmentedPatterns =\n+                                deconstructionPatternsBySymbol.getOrDefault(type, List.nil())\n+                                                                 .prepend(dpat);\n+\n+                        deconstructionPatternsBySymbol.put(type, augmentedPatterns);\n+                    }\n+\n+\n+                    case DEFAULTCASELABEL -> {}\n+                    default -> {\n+                        if (label.isExpression()) {\n+                            JCExpression expr = (JCExpression) label;\n+                            if (expr.hasTag(IDENT) && ((JCIdent) expr).sym.isEnum())\n+                                coveredSymbols.add(((JCIdent) expr).sym);\n+                        } else {\n+                            throw new AssertionError(label.getTag());\n+                        }\n+                    }\n+                }\n+            }\n+            for (Entry<Symbol, List<JCRecordPattern>> e : deconstructionPatternsBySymbol.entrySet()) {\n+                if (coversDeconstructionFromComponent(pos, targetType, e.getValue(), 0)) {\n+                    coveredSymbols.add(e.getKey());\n+                }\n+            }\n+            return coveredSymbols;\n+        }\n+\n+        private boolean coversDeconstructionFromComponent(DiagnosticPosition pos,\n+                                                          Type targetType,\n+                                                          List<JCRecordPattern> deconstructionPatterns,\n+                                                          int component) {\n+            \/\/Given a set of record patterns for the same record, and a starting component,\n+            \/\/this method checks, whether the nested patterns for the components are exhaustive,\n+            \/\/i.e. represent all possible combinations.\n+            \/\/This is done by categorizing the patterns based on the type covered by the given\n+            \/\/starting component.\n+            \/\/For each such category, it is then checked if the nested patterns starting at the next\n+            \/\/component are exhaustive, by recursivelly invoking this method. If these nested patterns\n+            \/\/are exhaustive, the given covered type is accepted.\n+            \/\/All such covered types are then checked whether they cover the declared type of\n+            \/\/the starting component's declaration. If yes, the given set of patterns starting at\n+            \/\/the given component cover the given record exhaustivelly, and true is returned.\n+            List<? extends RecordComponent> components =\n+                    deconstructionPatterns.head.record.getRecordComponents();\n+\n+            if (components.size() == component) {\n+                \/\/no components remain to be checked:\n+                return true;\n+            }\n+\n+            \/\/for the first tested component, gather symbols covered by the nested patterns:\n+            Type instantiatedComponentType = types.memberType(targetType, components.get(component));\n+            List<JCPattern> nestedComponentPatterns = deconstructionPatterns.map(d -> d.nested.get(component));\n+            Set<Symbol> coveredSymbolsForComponent = coveredSymbols(pos, instantiatedComponentType,\n+                                                                    nestedComponentPatterns);\n+\n+            \/\/for each of the symbols covered by the starting component, find all deconstruction patterns\n+            \/\/that have the given type, or its supertype, as a type of the starting nested pattern:\n+            Map<Symbol, List<JCRecordPattern>> coveredSymbol2Patterns = new HashMap<>();\n+\n+            for (JCRecordPattern deconstructionPattern : deconstructionPatterns) {\n+                JCPattern nestedPattern = deconstructionPattern.nested.get(component);\n+                Symbol componentPatternType;\n+                switch (nestedPattern.getTag()) {\n+                    case BINDINGPATTERN, PARENTHESIZEDPATTERN -> {\n+                        PatternPrimaryType primaryPatternType =\n+                                TreeInfo.primaryPatternType(nestedPattern);\n+                        componentPatternType = primaryPatternType.type().tsym;\n+                    }\n+                    case RECORDPATTERN -> {\n+                        componentPatternType = ((JCRecordPattern) nestedPattern).record;\n+                    }\n+                    default -> {\n+                        throw Assert.error(\"Unexpected tree kind: \" + nestedPattern.getTag());\n+                    }\n+                }\n+                for (Symbol currentType : coveredSymbolsForComponent) {\n+                    if (types.isSubtype(types.erasure(currentType.type),\n+                                        types.erasure(componentPatternType.type))) {\n+                        coveredSymbol2Patterns.put(currentType,\n+                                                   coveredSymbol2Patterns.getOrDefault(currentType,\n+                                                                                       List.nil())\n+                                              .prepend(deconstructionPattern));\n+                    }\n+                }\n+            }\n+\n+            \/\/Check the components following the starting component, for each of the covered symbol,\n+            \/\/if they are exhaustive. If yes, the given covered symbol should be part of the following\n+            \/\/exhaustiveness check:\n+            Set<Symbol> covered = new HashSet<>();\n@@ -751,1 +858,3 @@\n-                    constants.add(patternType.type().tsym);\n+            for (Entry<Symbol, List<JCRecordPattern>> e : coveredSymbol2Patterns.entrySet()) {\n+                if (coversDeconstructionFromComponent(pos, targetType, e.getValue(), component + 1)) {\n+                    covered.add(e.getKey());\n@@ -754,0 +863,3 @@\n+\n+            \/\/verify whether the filtered symbols cover the given record's declared type:\n+            return isExhaustive(pos, instantiatedComponentType, covered);\n@@ -821,1 +933,3 @@\n-                    yield covered.contains(seltype.tsym);\n+                    yield covered.stream()\n+                                 .anyMatch(coveredType -> types.isSubtype(types.erasure(seltype),\n+                                                                          types.erasure(coveredType.type)));\n@@ -824,1 +938,3 @@\n-                default -> false;\n+                default -> {\n+                    yield covered.contains(seltype.tsym);\n+                }\n@@ -2861,0 +2977,8 @@\n+        @Override\n+        public void visitRecordPattern(JCRecordPattern tree) {\n+            super.visitRecordPattern(tree);\n+            if (tree.var != null) {\n+                initParam(tree.var);\n+            }\n+        }\n+\n@@ -3040,0 +3164,13 @@\n+            try {\n+                currentTree = tree;\n+                scan(tree.guard);\n+            } finally {\n+                currentTree = prevTree;\n+            }\n+        }\n+\n+        @Override\n+        public void visitRecordPattern(JCRecordPattern tree) {\n+            scan(tree.deconstructor);\n+            scan(tree.nested);\n+            JCTree prevTree = currentTree;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":158,"deletions":21,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -145,2 +145,2 @@\n-            case PARENTHESIZEDPATTERN:\n-            case PARENS: case TYPETEST:\n+            case PARENTHESIZEDPATTERN: case TYPETEST:\n+            case PARENS: case RECORDPATTERN:\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MatchBindingsComputer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import com.sun.tools.javac.code.Symbol.DynamicVarSymbol;\n@@ -41,1 +40,3 @@\n-import com.sun.tools.javac.code.Type;\n+import com.sun.tools.javac.code.Type.ClassType;\n+import com.sun.tools.javac.code.Type.MethodType;\n+import com.sun.tools.javac.code.Type.WildcardType;\n@@ -66,2 +67,1 @@\n-import java.util.Collection;\n-import java.util.LinkedHashMap;\n+import java.util.HashMap;\n@@ -70,0 +70,1 @@\n+import java.util.LinkedHashMap;\n@@ -72,4 +73,2 @@\n-import com.sun.tools.javac.code.Type.ClassType;\n-import com.sun.tools.javac.code.Type.MethodType;\n-import com.sun.tools.javac.code.Type.WildcardType;\n-import com.sun.tools.javac.code.TypeTag;\n+import com.sun.tools.javac.code.Symbol.RecordComponent;\n+import com.sun.tools.javac.code.Type;\n@@ -89,0 +88,2 @@\n+import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;\n+import com.sun.tools.javac.tree.JCTree.JCNewClass;\n@@ -91,0 +92,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCRecordPattern;\n@@ -97,1 +99,0 @@\n-import java.util.Iterator;\n@@ -167,0 +168,2 @@\n+    private JCClassDecl currentClassTree = null;\n+    private ListBuffer<JCTree> pendingMethods = null;\n@@ -169,0 +172,1 @@\n+    private Map<RecordComponent, MethodSymbol> component2Proxy = null;\n@@ -257,0 +261,125 @@\n+    @Override\n+    public void visitRecordPattern(JCRecordPattern tree) {\n+        \/\/type test already done, finish handling of deconstruction patterns (\"T(PATT1, PATT2, ...)\")\n+        \/\/=>\n+        \/\/<PATT1-handling> && <PATT2-handling> && ...\n+        List<? extends RecordComponent> components = tree.record.getRecordComponents();\n+        List<? extends Type> nestedFullComponentTypes = tree.fullComponentTypes;\n+        List<? extends JCPattern> nestedPatterns = tree.nested;\n+        JCExpression test = null;\n+        while (components.nonEmpty() && nestedFullComponentTypes.nonEmpty() && nestedPatterns.nonEmpty()) {\n+            \/\/PATTn for record component COMPn of type Tn;\n+            \/\/PATTn is a type test pattern or a deconstruction pattern:\n+            \/\/=>\n+            \/\/(let Tn $c$COMPn = ((T) N$temp).COMPn(); <PATTn extractor>)\n+            \/\/or\n+            \/\/(let Tn $c$COMPn = ((T) N$temp).COMPn(); $c$COMPn != null && <PATTn extractor>)\n+            \/\/or\n+            \/\/(let Tn $c$COMPn = ((T) N$temp).COMPn(); $c$COMPn instanceof T' && <PATTn extractor>)\n+            RecordComponent component = components.head;\n+            JCPattern nested = nestedPatterns.head;\n+            VarSymbol nestedTemp = new VarSymbol(Flags.SYNTHETIC,\n+                names.fromString(target.syntheticNameChar() + \"c\" + target.syntheticNameChar() + component.name),\n+                                 component.erasure(types),\n+                                 currentMethodSym);\n+            Symbol accessor = getAccessor(component);\n+            JCVariableDecl nestedTempVar =\n+                    make.VarDef(nestedTemp,\n+                                make.App(make.QualIdent(accessor),\n+                                         List.of(convert(make.Ident(currentValue), tree.type))));\n+            JCExpression extracted;\n+            VarSymbol prevCurrentValue = currentValue;\n+            try {\n+                currentValue = nestedTemp;\n+                extracted = (JCExpression) this.<JCTree>translate(nested);\n+            } finally {\n+                currentValue = prevCurrentValue;\n+            }\n+            JCExpression extraTest = null;\n+            if (!types.isAssignable(nestedTemp.type, nested.type)) {\n+                if (!types.isAssignable(nestedFullComponentTypes.head, nested.type)) {\n+                    extraTest = makeTypeTest(make.Ident(nestedTemp),\n+                                             make.Type(nested.type));\n+                }\n+            } else if (nested.type.isReference() && nested.hasTag(Tag.RECORDPATTERN)) {\n+                extraTest = makeBinary(Tag.NE, make.Ident(nestedTemp), makeNull());\n+            }\n+            if (extraTest != null) {\n+                extracted = makeBinary(Tag.AND, extraTest, extracted);\n+            }\n+            LetExpr getAndRun = make.LetExpr(nestedTempVar, extracted);\n+            getAndRun.needsCond = true;\n+            getAndRun.setType(syms.booleanType);\n+            if (test == null) {\n+                test = getAndRun;\n+            } else {\n+                test = makeBinary(Tag.AND, test, getAndRun);\n+            }\n+            components = components.tail;\n+            nestedFullComponentTypes = nestedFullComponentTypes.tail;\n+            nestedPatterns = nestedPatterns.tail;\n+        }\n+\n+        if (tree.var != null) {\n+            BindingSymbol binding = (BindingSymbol) tree.var.sym;\n+            Type castTargetType = principalType(tree);\n+            VarSymbol bindingVar = bindingContext.bindingDeclared(binding);\n+\n+            JCAssign fakeInit =\n+                    (JCAssign) make.at(TreeInfo.getStartPos(tree))\n+                                   .Assign(make.Ident(bindingVar),\n+                                           convert(make.Ident(currentValue), castTargetType))\n+                                   .setType(bindingVar.erasure(types));\n+            LetExpr nestedLE = make.LetExpr(List.of(make.Exec(fakeInit)),\n+                                            make.Literal(true));\n+            nestedLE.needsCond = true;\n+            nestedLE.setType(syms.booleanType);\n+            test = test != null ? makeBinary(Tag.AND, test, nestedLE) : nestedLE;\n+        }\n+\n+        Assert.check(components.isEmpty() == nestedPatterns.isEmpty());\n+        Assert.check(components.isEmpty() == nestedFullComponentTypes.isEmpty());\n+        result = test != null ? test : makeLit(syms.booleanType, 1);\n+    }\n+\n+    private MethodSymbol getAccessor(RecordComponent component) {\n+        return component2Proxy.computeIfAbsent(component, c -> {\n+            MethodSymbol realAccessor = (MethodSymbol) component.owner\n+                                                 .members()\n+                                                 .findFirst(component.name, s -> s.kind == Kind.MTH &&\n+                                                                                 ((MethodSymbol) s).params.isEmpty());\n+            MethodType type = new MethodType(List.of(component.owner.erasure(types)),\n+                                             types.erasure(component.type),\n+                                             List.nil(),\n+                                             syms.methodClass);\n+            MethodSymbol proxy = new MethodSymbol(Flags.STATIC | Flags.SYNTHETIC,\n+                                                  names.fromString(\"$proxy$\" + component.name),\n+                                                  type,\n+                                                  currentClass);\n+            JCStatement accessorStatement =\n+                    make.Return(make.App(make.Select(make.Ident(proxy.params().head), realAccessor)));\n+            VarSymbol ctch = new VarSymbol(Flags.SYNTHETIC,\n+                    names.fromString(\"catch\" + currentClassTree.pos + target.syntheticNameChar()),\n+                    syms.throwableType,\n+                    currentMethodSym);\n+            JCNewClass newException = makeNewClass(syms.matchExceptionType,\n+                                                   List.of(makeApply(make.Ident(ctch),\n+                                                                     names.toString,\n+                                                                     List.nil()),\n+                                                           make.Ident(ctch)));\n+            JCTree.JCCatch catchClause = make.Catch(make.VarDef(ctch, null),\n+                                                    make.Block(0, List.of(make.Throw(newException))));\n+            JCStatement tryCatchAll = make.Try(make.Block(0, List.of(accessorStatement)),\n+                                               List.of(catchClause),\n+                                               null);\n+            JCMethodDecl md = make.MethodDef(proxy,\n+                                             proxy.externalType(types),\n+                                             make.Block(0, List.of(tryCatchAll)));\n+\n+            pendingMethods.append(md);\n+            currentClass.members().enter(proxy);\n+\n+            return proxy;\n+        });\n+    }\n+\n@@ -480,0 +609,19 @@\n+    JCMethodInvocation makeApply(JCExpression selector, Name name, List<JCExpression> args) {\n+        MethodSymbol method = rs.resolveInternalMethod(\n+                currentClassTree.pos(), env,\n+                selector.type, name,\n+                TreeInfo.types(args), List.nil());\n+        JCMethodInvocation tree = make.App( make.Select(selector, method), args)\n+                                      .setType(types.erasure(method.getReturnType()));\n+        return tree;\n+    }\n+\n+    JCNewClass makeNewClass(Type ctype, List<JCExpression> args) {\n+        JCNewClass tree = make.NewClass(null,\n+            null, make.QualIdent(ctype.tsym), args, null);\n+        tree.constructor = rs.resolveConstructor(\n+            currentClassTree.pos(), this.env, ctype, TreeInfo.types(args), List.nil());\n+        tree.type = ctype;\n+        return tree;\n+    }\n+\n@@ -659,0 +807,2 @@\n+        JCClassDecl prevCurrentClassTree = currentClassTree;\n+        ListBuffer<JCTree> prevPendingMethods = pendingMethods;\n@@ -660,0 +810,1 @@\n+        Map<RecordComponent, MethodSymbol> prevAccessor2Proxy = component2Proxy;\n@@ -662,0 +813,2 @@\n+            currentClassTree = tree;\n+            pendingMethods = new ListBuffer<>();\n@@ -663,0 +816,1 @@\n+            component2Proxy = new HashMap<>();\n@@ -664,0 +818,1 @@\n+            tree.defs = tree.defs.prependList(pendingMethods.toList());\n@@ -666,0 +821,2 @@\n+            currentClassTree = prevCurrentClassTree;\n+            pendingMethods = prevPendingMethods;\n@@ -667,0 +824,1 @@\n+            component2Proxy = prevAccessor2Proxy;\n@@ -862,0 +1020,6 @@\n+\n+    \/** Make an attributed tree representing null.\n+     *\/\n+    JCExpression makeNull() {\n+        return makeLit(syms.botType, null);\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":173,"deletions":9,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -590,0 +590,8 @@\n+    public void visitRecordPattern(JCRecordPattern tree) {\n+        tree.fullComponentTypes = tree.record.getRecordComponents()\n+                                             .map(rc -> types.memberType(tree.type, rc));\n+        tree.deconstructor = translate(tree.deconstructor, null);\n+        tree.nested = translate(tree.nested, null);\n+        result = tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCRecordPattern;\n@@ -267,0 +268,8 @@\n+    @Override\n+    public void visitRecordPattern(JCTree.JCRecordPattern tree) {\n+        JCRecordPattern that = (JCRecordPattern) parameter;\n+        result =\n+                scan(tree.deconstructor, that.deconstructor)\n+                        && scan(tree.nested, that.nested);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TreeDiffer.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -762,1 +762,0 @@\n-\n@@ -766,1 +765,2 @@\n-    public JCPattern parsePattern(int pos, JCModifiers mods, JCExpression parsedType) {\n+    public JCPattern parsePattern(int pos, JCModifiers mods, JCExpression parsedType,\n+                                  boolean allowVar, boolean checkGuard) {\n@@ -769,0 +769,1 @@\n+            \/\/parenthesized pattern:\n@@ -771,1 +772,1 @@\n-            JCPattern p = parsePattern(token.pos, null, null);\n+            JCPattern p = parsePattern(token.pos, null, null, true, false);\n@@ -776,3 +777,41 @@\n-            JCExpression e = parsedType == null ? term(TYPE | NOLAMBDA) : parsedType;\n-            JCVariableDecl var = toP(F.at(token.pos).VarDef(mods, ident(), e, null));\n-            pattern = toP(F.at(pos).BindingPattern(var));\n+            JCExpression e;\n+            if (parsedType == null) {\n+                boolean var = token.kind == IDENTIFIER && token.name() == names.var;\n+                e = unannotatedType(allowVar, TYPE | NOLAMBDA);\n+                if (var) {\n+                    e = null;\n+                }\n+            } else {\n+                e = parsedType;\n+            }\n+            if (token.kind == LPAREN) {\n+                \/\/deconstruction pattern:\n+                checkSourceLevel(Feature.RECORD_PATTERNS);\n+                ListBuffer<JCPattern> nested = new ListBuffer<>();\n+                if (!peekToken(RPAREN)) {\n+                    do {\n+                        nextToken();\n+                        JCPattern nestedPattern = parsePattern(token.pos, null, null, true, false);\n+                        nested.append(nestedPattern);\n+                    } while (token.kind == COMMA);\n+                } else {\n+                    nextToken();\n+                }\n+                accept(RPAREN);\n+                JCVariableDecl var;\n+                if (token.kind == IDENTIFIER) {\n+                    if (!checkGuard || token.name() != names.when) {\n+                        var = to(F.at(token.pos).VarDef(F.Modifiers(0), token.name(), e, null));\n+                        nextToken();\n+                    } else {\n+                        var = null;\n+                    }\n+                } else {\n+                    var = null;\n+                }\n+                pattern = toP(F.at(pos).RecordPattern(e, nested.toList(), var));\n+            } else {\n+                \/\/type test pattern:\n+                JCVariableDecl var = toP(F.at(token.pos).VarDef(mods, ident(), e, null));\n+                pattern = toP(F.at(pos).BindingPattern(var));\n+            }\n@@ -783,0 +822,1 @@\n+\n@@ -815,1 +855,5 @@\n-        JCExpression result = term(TYPE);\n+        return unannotatedType(allowVar, TYPE);\n+    }\n+\n+    public JCExpression unannotatedType(boolean allowVar, int newmode) {\n+        JCExpression result = term(newmode);\n@@ -964,1 +1008,1 @@\n-                    pattern = parsePattern(token.pos, null, null);\n+                    pattern = parsePattern(token.pos, null, null, false, false);\n@@ -972,1 +1016,3 @@\n-                        pattern = parsePattern(patternPos, mods, type);\n+                        pattern = parsePattern(patternPos, mods, type, false, false);\n+                    } else if (token.kind == LPAREN) {\n+                        pattern = parsePattern(patternPos, mods, type, false, false);\n@@ -3073,1 +3119,1 @@\n-                JCPattern p = parsePattern(patternPos, mods, null);\n+                JCPattern p = parsePattern(patternPos, mods, null, false, true);\n@@ -3089,1 +3135,3 @@\n-        int depth = 0;\n+        int typeDepth = 0;\n+        int parenDepth = 0;\n+        PatternResult pendingResult = PatternResult.EXPRESSION;\n@@ -3096,1 +3144,7 @@\n-                    if (depth == 0 && peekToken(lookahead, LAX_IDENTIFIER)) return PatternResult.PATTERN;\n+                    if (typeDepth == 0 && peekToken(lookahead, LAX_IDENTIFIER)) {\n+                        if (parenDepth == 0) {\n+                            return PatternResult.PATTERN;\n+                        } else {\n+                            pendingResult = PatternResult.PATTERN;\n+                        }\n+                    }\n@@ -3099,3 +3153,3 @@\n-                case LT: depth++; break;\n-                case GTGTGT: depth--;\n-                case GTGT: depth--;\n+                case LT: typeDepth++; break;\n+                case GTGTGT: typeDepth--;\n+                case GTGT: typeDepth--;\n@@ -3103,5 +3157,6 @@\n-                    depth--;\n-                    if (depth == 0) {\n-                         return peekToken(lookahead, LAX_IDENTIFIER) ? PatternResult.PATTERN\n-                                                          : PatternResult.EXPRESSION;\n-                    } else if (depth < 0) return PatternResult.EXPRESSION;\n+                    typeDepth--;\n+                    if (typeDepth == 0) {\n+                         return peekToken(lookahead, LAX_IDENTIFIER) ||\n+                                peekToken(lookahead, tk -> tk == LPAREN) ? PatternResult.PATTERN\n+                                                                         : PatternResult.EXPRESSION;\n+                    } else if (typeDepth < 0) return PatternResult.EXPRESSION;\n@@ -3121,1 +3176,11 @@\n-                default: return PatternResult.EXPRESSION;\n+                case LPAREN:\n+                    if (S.token(lookahead + 1).kind == RPAREN) {\n+                        return parenDepth != 0 && S.token(lookahead + 2).kind == ARROW\n+                                ? PatternResult.EXPRESSION\n+                                : PatternResult.PATTERN;\n+                    }\n+                    parenDepth++; break;\n+                case RPAREN: parenDepth--; break;\n+                case ARROW: return parenDepth > 0 ? PatternResult.EXPRESSION\n+                                                   : pendingResult;\n+                default: return pendingResult;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":86,"deletions":21,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -3077,0 +3077,3 @@\n+compiler.misc.feature.deconstruction.patterns=\\\n+    deconstruction patterns\n+\n@@ -3916,0 +3919,13 @@\n+# 0: symbol\n+compiler.err.deconstruction.pattern.only.records=\\\n+    deconstruction patterns can only be applied to records, {0} is not a record\n+\n+# 0: list of type, 1: list of type\n+compiler.err.incorrect.number.of.nested.patterns=\\\n+    incorrect number of nested patterns\\n\\\n+    required: {0}\\n\\\n+    found: {1}\n+\n+compiler.err.raw.deconstruction.pattern=\\\n+    raw deconstruction patterns are not allowed\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -246,0 +246,2 @@\n+        RECORDPATTERN,\n+\n@@ -2371,0 +2373,58 @@\n+    public static class JCRecordPattern extends JCPattern\n+            implements DeconstructionPatternTree {\n+        public JCExpression deconstructor;\n+        public List<JCPattern> nested;\n+        public JCVariableDecl var;\n+        public ClassSymbol record;\n+        public List<Type> fullComponentTypes;\n+\n+        protected JCRecordPattern(JCExpression deconstructor, List<JCPattern> nested,\n+                                  JCVariableDecl var) {\n+            this.deconstructor = deconstructor;\n+            this.nested = nested;\n+            this.var = var;\n+        }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Name getBinding() {\n+            return null;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public ExpressionTree getDeconstructor() {\n+            return deconstructor;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public List<? extends JCPattern> getNestedPatterns() {\n+            return nested;\n+        }\n+\n+        @Override\n+        public void accept(Visitor v) {\n+            v.visitRecordPattern(this);\n+        }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() {\n+            return Kind.DECONSTRUCTION_PATTERN;\n+        }\n+\n+        @Override\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public <R, D> R accept(TreeVisitor<R, D> v, D d) {\n+            return v.visitDeconstructionPattern(this, d);\n+        }\n+\n+        @Override\n+        public Tag getTag() {\n+            return RECORDPATTERN;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public VariableTree getVariable() {\n+            return var;\n+        }\n+\n+    }\n+\n@@ -3413,0 +3473,1 @@\n+        public void visitRecordPattern(JCRecordPattern that) { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -924,0 +924,20 @@\n+        }\n+    }\n+\n+    @Override\n+    public void visitRecordPattern(JCRecordPattern tree) {\n+        try {\n+            printExpr(tree.deconstructor);\n+            print(\"(\");\n+            printExprs(tree.nested);\n+            print(\")\");\n+            if (tree.var != null) {\n+                print(\" \");\n+                print(tree.var.name);\n+            }\n+            if (tree.guard != null) {\n+                print(\" when \");\n+                printExpr(tree.guard);\n+            }\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -519,0 +519,9 @@\n+    @DefinedBy(Api.COMPILER_TREE)\n+    public JCTree visitDeconstructionPattern(DeconstructionPatternTree node, P p) {\n+        JCRecordPattern t = (JCRecordPattern) node;\n+        JCExpression deconstructor = copy(t.deconstructor, p);\n+        List<JCPattern> nested = copy(t.nested, p);\n+        JCVariableDecl var = copy(t.var, p);\n+        return M.at(t.pos).RecordPattern(deconstructor, nested, var);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1313,0 +1313,1 @@\n+            case RECORDPATTERN -> new PatternPrimaryType(((JCRecordPattern) pat).type);\n@@ -1317,1 +1318,1 @@\n-    public static JCBindingPattern primaryPatternTree(JCTree pat) {\n+    public static JCTree primaryPatternTypeTree(JCTree pat) {\n@@ -1319,2 +1320,3 @@\n-            case BINDINGPATTERN -> (JCBindingPattern) pat;\n-            case PARENTHESIZEDPATTERN -> primaryPatternTree(((JCParenthesizedPattern) pat).pattern);\n+            case BINDINGPATTERN -> ((JCBindingPattern) pat).var.vartype;\n+            case PARENTHESIZEDPATTERN -> primaryPatternTypeTree(((JCParenthesizedPattern) pat).pattern);\n+            case RECORDPATTERN -> ((JCRecordPattern) pat).deconstructor;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -503,0 +503,7 @@\n+    public JCRecordPattern RecordPattern(JCExpression deconstructor, List<JCPattern> nested,\n+                                         JCVariableDecl var) {\n+        JCRecordPattern tree = new JCRecordPattern(deconstructor, nested, var);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -321,0 +321,10 @@\n+    @Override\n+    public void visitRecordPattern(JCRecordPattern that) {\n+        scan(that.deconstructor);\n+        scan(that.nested);\n+        if (that.var != null) {\n+            scan(that.var);\n+        }\n+        scan(that.guard);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -473,0 +473,7 @@\n+    @Override\n+    public void visitRecordPattern(JCRecordPattern tree) {\n+        tree.deconstructor = translate(tree.deconstructor);\n+        tree.nested = translate(tree.nested);\n+        result = tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,1 +154,1 @@\n-    public static void error() {\n+    public static Error error() {\n@@ -161,1 +161,1 @@\n-    public static void error(String msg) {\n+    public static Error error(String msg) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Assert.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,2 @@\n- * @run main Patterns\n+ * @compile --enable-preview -source ${jdk.version} Patterns.java\n+ * @run main\/othervm --enable-preview Patterns\n@@ -35,0 +36,1 @@\n+import java.util.List;\n@@ -48,1 +50,2 @@\n-        new Patterns().run();\n+        new Patterns().runBinding();\n+        new Patterns().runDeconstruction();\n@@ -51,1 +54,1 @@\n-    public void run() throws Exception {\n+    public void runBinding() throws Exception {\n@@ -164,0 +167,126 @@\n+    public void runDeconstruction() throws Exception {\n+        List<String> outLines = new JavapTask(tb)\n+                .options(\"-private\",\n+                         \"-verbose\")\n+                .classpath(System.getProperty(\"test.classes\"))\n+                .classes(\"Patterns$DeconstructionPattern\")\n+                .run()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        String out = clearCodeAttribute(outLines);\n+        String constantPool = out.substring(0, out.indexOf('{'));\n+\n+        out = out.substring(out.indexOf('{'));\n+        out = out.substring(0, out.lastIndexOf('}') + 1);\n+\n+        String A = snipCPNumber(constantPool, \"LPatterns$DeconstructionPattern$A;\");\n+        String CA = snipCPNumber(constantPool, \"LPatterns$DeconstructionPattern$CA;\");\n+        String value = snipCPNumber(constantPool, \"value\");\n+\n+        String expected = \"\"\"\n+                          {\n+                            private static final java.lang.Object o;\n+                              descriptor: Ljava\/lang\/Object;\n+                              flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL\n+\n+                            private static final boolean B1s;\n+                              descriptor: Z\n+                              flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL\n+\n+                            private static final boolean B1m;\n+                              descriptor: Z\n+                              flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL\n+\n+                            private final boolean B2s;\n+                              descriptor: Z\n+                              flags: (0x0012) ACC_PRIVATE, ACC_FINAL\n+\n+                            private final boolean B2m;\n+                              descriptor: Z\n+                              flags: (0x0012) ACC_PRIVATE, ACC_FINAL\n+\n+                            public Patterns$DeconstructionPattern();\n+                              descriptor: ()V\n+                              flags: (0x0001) ACC_PUBLIC\n+                                RuntimeInvisibleTypeAnnotations:\n+                                  0: #_A_(): LOCAL_VARIABLE, {start_pc=251, length=11, index=2}\n+                                    Patterns$DeconstructionPattern$A\n+                                  1: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=290, length=11, index=3}\n+                                    Patterns$DeconstructionPattern$CA(\n+                                      value=[@Patterns$DeconstructionPattern$A,@Patterns$DeconstructionPattern$A]\n+                                    )\n+                                  2: #_A_(): LOCAL_VARIABLE, {start_pc=26, length=11, index=1}\n+                                    Patterns$DeconstructionPattern$A\n+                                  3: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=63, length=11, index=1}\n+                                    Patterns$DeconstructionPattern$CA(\n+                                      value=[@Patterns$DeconstructionPattern$A,@Patterns$DeconstructionPattern$A]\n+                                    )\n+                                  4: #_A_(): LOCAL_VARIABLE, {start_pc=101, length=11, index=2}\n+                                    Patterns$DeconstructionPattern$A\n+                                  5: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=140, length=11, index=3}\n+                                    Patterns$DeconstructionPattern$CA(\n+                                      value=[@Patterns$DeconstructionPattern$A,@Patterns$DeconstructionPattern$A]\n+                                    )\n+                                  6: #_A_(): LOCAL_VARIABLE, {start_pc=176, length=11, index=2}\n+                                    Patterns$DeconstructionPattern$A\n+                                  7: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=215, length=11, index=3}\n+                                    Patterns$DeconstructionPattern$CA(\n+                                      value=[@Patterns$DeconstructionPattern$A,@Patterns$DeconstructionPattern$A]\n+                                    )\n+\n+                            void testPatterns();\n+                              descriptor: ()V\n+                              flags: (0x0000)\n+                                RuntimeInvisibleTypeAnnotations:\n+                                  0: #_A_(): LOCAL_VARIABLE, {start_pc=23, length=11, index=2}\n+                                    Patterns$DeconstructionPattern$A\n+                                  1: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=62, length=11, index=3}\n+                                    Patterns$DeconstructionPattern$CA(\n+                                      value=[@Patterns$DeconstructionPattern$A,@Patterns$DeconstructionPattern$A]\n+                                    )\n+\n+                            static java.lang.String $proxy$s(Patterns$DeconstructionPattern$R);\n+                              descriptor: (LPatterns$DeconstructionPattern$R;)Ljava\/lang\/String;\n+                              flags: (0x1008) ACC_STATIC, ACC_SYNTHETIC\n+\n+                            static {};\n+                              descriptor: ()V\n+                              flags: (0x0008) ACC_STATIC\n+                                RuntimeInvisibleTypeAnnotations:\n+                                  0: #_A_(): LOCAL_VARIABLE, {start_pc=26, length=11, index=0}\n+                                    Patterns$DeconstructionPattern$A\n+                                  1: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=62, length=11, index=0}\n+                                    Patterns$DeconstructionPattern$CA(\n+                                      value=[@Patterns$DeconstructionPattern$A,@Patterns$DeconstructionPattern$A]\n+                                    )\n+                                  2: #_A_(): LOCAL_VARIABLE, {start_pc=98, length=11, index=1}\n+                                    Patterns$DeconstructionPattern$A\n+                                  3: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=134, length=11, index=2}\n+                                    Patterns$DeconstructionPattern$CA(\n+                                      value=[@Patterns$DeconstructionPattern$A,@Patterns$DeconstructionPattern$A]\n+                                    )\n+                          }\"\"\".replace(\"_A_\", A).replace(\"_CA_\", CA).replace(\"_value_\", value);\n+\n+        if (!expected.equals(out)) {\n+            throw new AssertionError(\"Unexpected output:\\n\" + out + \"\\nexpected:\\n\" + expected);\n+        }\n+    }\n+\n+    private String clearCodeAttribute(List<String> out) {\n+        StringBuilder result = new StringBuilder();\n+        boolean codeSeen = false;\n+\n+        for (String line : out) {\n+            if (line.contains(\"    Code:\")) {\n+                codeSeen = true;\n+            } else if (codeSeen && line.startsWith(\"      \") &&\n+                       !line.contains(\"RuntimeInvisibleTypeAnnotations\")) {\n+                \/\/ignore\n+            } else {\n+                result.append(line).append(\"\\n\");\n+                codeSeen = false;\n+            }\n+        }\n+\n+        return result.toString();\n+    }\n@@ -221,0 +350,43 @@\n+\n+    static class DeconstructionPattern {\n+        @Target(ElementType.TYPE_USE)\n+        @Repeatable(CA.class)\n+        @interface A {}\n+        @Target(ElementType.TYPE_USE)\n+        @interface CA {\n+            public A[] value();\n+        }\n+\n+        private static final Object o = \"\";\n+        private static final boolean B1s = o instanceof R(@A String s) && s.isEmpty();\n+        private static final boolean B1m = o instanceof R(@A @A String s) && s.isEmpty();\n+        private final boolean B2s = o instanceof R(@A String s) && s.isEmpty();\n+        private final boolean B2m = o instanceof R(@A @A String s) && s.isEmpty();\n+\n+        static {\n+            boolean B3s = o instanceof R(@A String s) && s.isEmpty();\n+            boolean B3m = o instanceof R(@A @A String s) && s.isEmpty();\n+        }\n+\n+        {\n+            boolean B4s = o instanceof R(@A String s) && s.isEmpty();\n+            boolean B4m = o instanceof R(@A @A String s) && s.isEmpty();\n+        }\n+\n+        {\n+            boolean B5s = o instanceof R(@A String s) && s.isEmpty();\n+            boolean B5m = o instanceof R(@A @A String s) && s.isEmpty();\n+        }\n+\n+        public DeconstructionPattern() {\n+            boolean B6s = o instanceof R(@A String s) && s.isEmpty();\n+            boolean B6m = o instanceof R(@A @A String s) && s.isEmpty();\n+        }\n+\n+        void testPatterns() {\n+            boolean B7s = o instanceof R(@A String s) && s.isEmpty();\n+            boolean B7m = o instanceof R(@A @A String s) && s.isEmpty();\n+        }\n+\n+        record R(String s) {}\n+    }\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/Patterns.java","additions":176,"deletions":4,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.deconstruction.pattern.only.records\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ key: compiler.misc.feature.deconstruction.patterns\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class DeconstructionpatternOnlyRecords {\n+    public boolean deconstruction(Object o) {\n+        return o instanceof String(var content);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/DeconstructionPatternOnlyRecords.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.incorrect.number.of.nested.patterns\n+\/\/ key: compiler.misc.feature.deconstruction.patterns\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class IncorrectNumberOfNestedPatterns {\n+    private boolean t(Object o) {\n+        return o instanceof R(var i);\n+    }\n+    record R(int i, int j) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/IncorrectNumberOfNestedPatterns.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.raw.deconstruction.pattern\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview -source ${jdk.version}\n+\n+class RawDeconstructionPattern {\n+    boolean test(Object o) {\n+        return o instanceof R(String s);\n+    }\n+\n+    record R<T>(T t) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/RawDeconstructionPattern.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -169,0 +169,6 @@\n+\n+        group((Function<Object, Integer>) x -> x instanceof R(var i1, var i2) ? i1 : -1,\n+              (Function<Object, Integer>) x -> x instanceof R(var i1, var i2) ? i1 : -1 );\n+\n+        group((Function<Object, Integer>) x -> x instanceof R(Integer i1, int i2) ? i2 : -1,\n+              (Function<Object, Integer>) x -> x instanceof R(Integer i1, int i2) ? i2 : -1 );\n@@ -177,0 +183,2 @@\n+\n+    record R(Integer i1, int i2) {}\n","filename":"test\/langtools\/tools\/javac\/lambda\/deduplication\/Deduplication.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -98,1 +98,3 @@\n-                                \"-XDdebug.dumpLambdaToMethodStats\"),\n+                                \"-XDdebug.dumpLambdaToMethodStats\",\n+                                \"--enable-preview\",\n+                                \"-source\", System.getProperty(\"java.specification.version\")),\n@@ -137,0 +139,3 @@\n+            if (cf.getName().equals(\"com\/sun\/tools\/javac\/comp\/Deduplication$R\")) {\n+                continue;\n+            }\n","filename":"test\/langtools\/tools\/javac\/lambda\/deduplication\/DeduplicationTest.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @summary Verify error reports for erroneous deconstruction patterns are sensible\n+ * @compile\/fail\/ref=DeconstructionPatternErrors.out --enable-preview -source ${jdk.version} -XDrawDiagnostics -XDshould-stop.at=FLOW -XDdev DeconstructionPatternErrors.java\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class DeconstructionPatternErrors {\n+\n+    public static void main(String... args) throws Throwable {\n+        Object p;\n+        p = new P(42);\n+        if (p instanceof P(_));\n+        if (p instanceof P3(ArrayList<Integer> l));\n+        if (p instanceof P4(ArrayList<Integer> l));\n+        if (p instanceof P5(int i));\n+        if (p instanceof P(String s));\n+        if (p instanceof P5(P(var v)));\n+        if (p instanceof P2(var v1)); \/\/too few nested patterns\n+        if (p instanceof P2(Runnable v1)); \/\/too few nested patterns\n+        if (p instanceof P(var v1, var v2)); \/\/too many nested patterns\n+        if (p instanceof P(int v1, int v2)); \/\/too many nested patterns\n+        if (p instanceof P(int v1, Unresolvable v2)); \/\/too many nested patterns\n+        if (p instanceof GenRecord<String>(var v)); \/\/incorrect generic type\n+        if (p instanceof P4(GenRecord<String>(var v))); \/\/incorrect generic type\n+        if (p instanceof GenRecord<String>(Integer v)); \/\/inconsistency in types\n+        if (p instanceof P2(var v, var v) v); \/\/duplicated variables\n+        if (p instanceof P6(P2(var v1, var v2) v1, P2(var v1, var v2) v2) v1); \/\/duplicated variables\n+        if (p instanceof P7(byte b)); \/\/incorrect pattern type\n+        if (p instanceof P7(long l)); \/\/incorrect pattern type\n+        switch (p) {\n+            case P7(byte b) -> {} \/\/incorrect pattern type - no exception should occur\n+            case P7(long l) -> {} \/\/incorrect pattern type - no exception should occur\n+            default -> {}\n+        }\n+        GenRecord<String> r1 = null;\n+        if (r1 instanceof GenRecord(String s)) {}\n+        switch (r1) {\n+            case GenRecord(String s) -> {}\n+        }\n+        if (r1 instanceof GenRecord<>(String s)) {}\n+        switch (r1) {\n+            case GenRecord<>(String s) -> {}\n+        }\n+    }\n+\n+    public record P(int i) {\n+    }\n+\n+    public record P2(Runnable r1, Runnable r2) {}\n+    public record P3(List<String> l) {}\n+    public record P4(Object o) {}\n+    public record P5(String s) {}\n+    public record P6(Object o1, Object o2) {}\n+    public record P7(int i) {}\n+    public record GenRecord<T>(T s) {}\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+DeconstructionPatternErrors.java:15:28: compiler.err.underscore.as.identifier\n+DeconstructionPatternErrors.java:15:29: compiler.err.expected: token.identifier\n+DeconstructionPatternErrors.java:43:37: compiler.err.illegal.start.of.type\n+DeconstructionPatternErrors.java:45:28: compiler.err.illegal.start.of.type\n+DeconstructionPatternErrors.java:16:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<java.lang.String>, java.util.ArrayList<java.lang.Integer>)\n+DeconstructionPatternErrors.java:17:29: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, java.util.ArrayList<java.lang.Integer>\n+DeconstructionPatternErrors.java:18:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, int)\n+DeconstructionPatternErrors.java:19:28: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.String)\n+DeconstructionPatternErrors.java:20:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, DeconstructionPatternErrors.P)\n+DeconstructionPatternErrors.java:21:26: compiler.err.incorrect.number.of.nested.patterns: java.lang.Runnable,java.lang.Runnable, java.lang.Runnable\n+DeconstructionPatternErrors.java:22:26: compiler.err.incorrect.number.of.nested.patterns: java.lang.Runnable,java.lang.Runnable, java.lang.Runnable\n+DeconstructionPatternErrors.java:23:26: compiler.err.incorrect.number.of.nested.patterns: int, int,compiler.misc.type.none\n+DeconstructionPatternErrors.java:24:26: compiler.err.incorrect.number.of.nested.patterns: int, int,int\n+DeconstructionPatternErrors.java:25:36: compiler.err.cant.resolve.location: kindname.class, Unresolvable, , , (compiler.misc.location: kindname.class, DeconstructionPatternErrors, null)\n+DeconstructionPatternErrors.java:25:26: compiler.err.incorrect.number.of.nested.patterns: int, int,Unresolvable\n+DeconstructionPatternErrors.java:26:13: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n+DeconstructionPatternErrors.java:27:29: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n+DeconstructionPatternErrors.java:28:44: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, java.lang.Integer)\n+DeconstructionPatternErrors.java:28:13: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n+DeconstructionPatternErrors.java:29:40: compiler.err.match.binding.exists\n+DeconstructionPatternErrors.java:29:43: compiler.err.match.binding.exists\n+DeconstructionPatternErrors.java:30:48: compiler.err.match.binding.exists\n+DeconstructionPatternErrors.java:30:59: compiler.err.already.defined: kindname.variable, v1, kindname.method, main(java.lang.String...)\n+DeconstructionPatternErrors.java:30:67: compiler.err.already.defined: kindname.variable, v2, kindname.method, main(java.lang.String...)\n+DeconstructionPatternErrors.java:30:71: compiler.err.match.binding.exists\n+DeconstructionPatternErrors.java:30:75: compiler.err.match.binding.exists\n+DeconstructionPatternErrors.java:31:29: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, byte)\n+DeconstructionPatternErrors.java:32:29: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, long)\n+DeconstructionPatternErrors.java:34:21: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, byte)\n+DeconstructionPatternErrors.java:35:21: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, long)\n+DeconstructionPatternErrors.java:39:27: compiler.err.raw.deconstruction.pattern\n+DeconstructionPatternErrors.java:41:18: compiler.err.raw.deconstruction.pattern\n+- compiler.note.preview.filename: DeconstructionPatternErrors.java, DEFAULT\n+- compiler.note.preview.recompile\n+32 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.out","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @compile --enable-preview -source ${jdk.version} EmptyRecordClass.java\n+ *\/\n+\n+public class EmptyRecordClass {\n+    record X() {}\n+\n+    void test(X w) {\n+        switch (w) {\n+            case X(): break;\n+        }\n+    }\n+\n+\n+    sealed interface W permits W.X1 {\n+        record X1() implements W {}\n+    }\n+\n+    public int test2(W w) {\n+        return switch (w) {\n+            case W.X1() -> 1;\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/EmptyRecordClass.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -683,0 +683,99 @@\n+    public void testX(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public record R(S a, S b) {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(R r) {\n+                       return switch (r) {\n+                           case R(A a, A b) -> 0;\n+                           case R(A a, B b) -> 0;\n+                           case R(B a, A b) -> 0;\n+                           case R(B a, B b) -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public record B(Object o) implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public record R(S a, S b) {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(R r) {\n+                       return switch (r) {\n+                           case R(A a, A b) -> 0;\n+                           case R(A a, B b) -> 0;\n+                           case R(B a, A b) -> 0;\n+                           case R(B a, B(String s)) -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:5:16: compiler.err.not.exhaustive\",\n+               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+               \"- compiler.note.preview.recompile\",\n+               \"1 error\");\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public record B(Object o) implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public record R(S a, S b) {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(R r) {\n+                       return switch (r) {\n+                           case R(A a, A b) -> 0;\n+                           case R(A a, B b) -> 0;\n+                           case R(B a, A b) -> 0;\n+                           case R(B a, B(var o)) -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n@@ -870,0 +969,43 @@\n+    @Test\n+    public void testSuperTypesInPattern(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public record R(S a, S b) {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private void testStatement(R obj) {\n+                       switch (obj) {\n+                           case R(A a, A b): break;\n+                           case R(A a, B b): break;\n+                           case R(B a, A b): break;\n+                           case R(B a, B b): break;\n+                       }\n+                       switch (obj) {\n+                           case R(S a, A b): break;\n+                           case R(S a, B b): break;\n+                       }\n+                       switch (obj) {\n+                           case R(Object a, A b): break;\n+                           case R(Object a, B b): break;\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @compile --enable-preview -source ${jdk.version} GenericRecordDeconstructionPattern.java\n+ * @run main\/othervm --enable-preview GenericRecordDeconstructionPattern\n+ *\/\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+public class GenericRecordDeconstructionPattern {\n+\n+    public static void main(String... args) throws Throwable {\n+        new GenericRecordDeconstructionPattern().run();\n+    }\n+\n+    void run() {\n+        runTest(this::runIf);\n+        runTest(this::runSwitch);\n+        runTest(this::runSwitchExpression);\n+    }\n+\n+    void runTest(Function<Box<String>, Integer> test) {\n+        Box<String> b = new Box<>(null);\n+        assertEquals(1, test.apply(b));\n+    }\n+\n+    int runIf(Box<String> b) {\n+        if (b instanceof Box<String>(String s)) return 1;\n+        return -1;\n+    }\n+\n+    int runSwitch(Box<String> b) {\n+        switch (b) {\n+            case Box<String>(String s): return 1;\n+            default: return -1;\n+        }\n+    }\n+\n+    int runSwitchExpression(Box<String> b) {\n+        return switch (b) {\n+            case Box<String>(String s) -> 1;\n+            default -> -1;\n+        };\n+    }\n+\n+    record Box<V>(V v) {\n+    }\n+\n+    void assertEquals(Object expected, Object actual) {\n+        if (!Objects.equals(expected, actual)) {\n+            throw new AssertionError(\"Expected: \" + expected + \",\" +\n+                                     \"got: \" + actual);\n+        }\n+    }\n+\n+    void fail(String message) {\n+        throw new AssertionError(message);\n+    }\n+\n+    public static class TestPatternFailed extends AssertionError {\n+\n+        public TestPatternFailed(String message) {\n+            super(message);\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/GenericRecordDeconstructionPattern.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -59,0 +59,1 @@\n+        assertEquals(\"box with empty\", convert.apply(new Box(\"\")));\n@@ -73,0 +74,1 @@\n+            case Box(String s) when s.isEmpty(): return \"box with empty\";\n@@ -82,0 +84,1 @@\n+            case Box(String s) when s.isEmpty() -> \"box with empty\";\n@@ -92,0 +95,1 @@\n+            case Box(String s) when s.isEmpty() -> {x = \"box with empty\"; yield true; }\n@@ -182,0 +186,2 @@\n+    record Box(Object o) {}\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Guards.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @compile --enable-preview -source ${jdk.version} NestedDeconstructionPattern.java\n+ * @run main\/othervm --enable-preview NestedDeconstructionPattern\n+ *\/\n+\n+import java.util.Objects;\n+\n+public class NestedDeconstructionPattern {\n+\n+    public static void main(String... args) throws Throwable {\n+        new NestedDeconstructionPattern().doTestR();\n+        new NestedDeconstructionPattern().doTestP();\n+    }\n+\n+    void doTestR() {\n+        assertEquals(\"AA\", switchR1(new R(new A(), new A())));\n+        assertEquals(\"AB\", switchR1(new R(new A(), new B())));\n+        assertEquals(\"BA\", switchR1(new R(new B(), new A())));\n+        assertEquals(\"BB\", switchR1(new R(new B(), new B())));\n+        try {\n+            switchR1(null);\n+            throw new AssertionError(\"Didn't get a NPE.\");\n+        } catch (NullPointerException ex) {\n+            \/\/OK\n+        }\n+        assertEquals(\"AA\", switchR2(new R(new A(), new A())));\n+        assertEquals(\"AB\", switchR2(new R(new A(), new B())));\n+        assertEquals(\"BA\", switchR2(new R(new B(), new A())));\n+        assertEquals(\"BB\", switchR2(new R(new B(), new B())));\n+        assertEquals(\"other\", switchR2(\"\"));\n+        try {\n+            switchR2(null);\n+            throw new AssertionError(\"Didn't get a NPE.\");\n+        } catch (NullPointerException ex) {\n+            \/\/OK\n+        }\n+    }\n+\n+    String switchR1(R r) {\n+        return switch (r) {\n+            case R(A a, A b) -> a.name() + b.name();\n+            case R(A a, B b) -> a.name() + b.name();\n+            case R(B a, A b) -> a.name() + b.name();\n+            case R(B a, B b) -> a.name() + b.name();\n+        };\n+    }\n+\n+    String switchR2(Object o) {\n+        return switch (o) {\n+            case R(A a, A b) -> a.name() + b.name();\n+            case R(A a, B b) -> a.name() + b.name();\n+            case R(B a, A b) -> a.name() + b.name();\n+            case R(B a, B b) -> a.name() + b.name();\n+            default -> \"other\";\n+        };\n+    }\n+\n+    void doTestP() {\n+        assertEquals(\"AAAA\", switchP1(new P(new R(new A(), new A()), new R(new A(), new A()))));\n+    }\n+\n+    String switchP1(P p) {\n+        return switch (p) {\n+            case P(R(A a1, A b1), R(A a2, A b2)) -> a1.name() + b1.name()+a2.name() + b2.name();\n+            case P(R(A a1, A b1), R(A a2, B b2)) -> a1.name() + b1.name()+a2.name() + b2.name();\n+            case P(R(A a1, A b1), R(B a2, A b2)) -> a1.name() + b1.name()+a2.name() + b2.name();\n+            case P(R(A a1, A b1), R(B a2, B b2)) -> a1.name() + b1.name()+a2.name() + b2.name();\n+            case P(R(A a1, B b1), R(A a2, A b2)) -> a1.name() + b1.name()+a2.name() + b2.name();\n+            case P(R(A a1, B b1), R(A a2, B b2)) -> a1.name() + b1.name()+a2.name() + b2.name();\n+            case P(R(A a1, B b1), R(B a2, A b2)) -> a1.name() + b1.name()+a2.name() + b2.name();\n+            case P(R(A a1, B b1), R(B a2, B b2)) -> a1.name() + b1.name()+a2.name() + b2.name();\n+            case P(R(B a1, A b1), R(A a2, A b2)) -> a1.name() + b1.name()+a2.name() + b2.name();\n+            case P(R(B a1, A b1), R(A a2, B b2)) -> a1.name() + b1.name()+a2.name() + b2.name();\n+            case P(R(B a1, A b1), R(B a2, A b2)) -> a1.name() + b1.name()+a2.name() + b2.name();\n+            case P(R(B a1, A b1), R(B a2, B b2)) -> a1.name() + b1.name()+a2.name() + b2.name();\n+            case P(R(B a1, B b1), R(A a2, A b2)) -> a1.name() + b1.name()+a2.name() + b2.name();\n+            case P(R(B a1, B b1), R(A a2, B b2)) -> a1.name() + b1.name()+a2.name() + b2.name();\n+            case P(R(B a1, B b1), R(B a2, A b2)) -> a1.name() + b1.name()+a2.name() + b2.name();\n+            case P(R(B a1, B b1), R(B a2, B b2)) -> a1.name() + b1.name()+a2.name() + b2.name();\n+            case P(N a, N b) -> \"other\";\n+        };\n+    }\n+\n+    public sealed interface I {}\n+    public final class A implements I {\n+        public String name() { return \"A\"; }\n+    }\n+    public final class B implements I {\n+        public String name() { return \"B\"; }\n+    }\n+\n+    public record R(I a, I b) implements N {}\n+\n+    public sealed interface N {}\n+    public final class C implements N {\n+        public String name() { return \"B\"; }\n+    }\n+\n+    public record P(N a, N b) {\n+    }\n+\n+    private void assertEquals(String expected, String actual) {\n+        if (!Objects.equals(expected, actual)) {\n+            throw new AssertionError(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/NestedDeconstructionPattern.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @compile --enable-preview -source ${jdk.version} NestedPrimitiveDeconstructionPattern.java\n+ * @run main\/othervm --enable-preview NestedPrimitiveDeconstructionPattern\n+ *\/\n+\n+import java.util.Objects;\n+\n+public class NestedPrimitiveDeconstructionPattern {\n+\n+    public static void main(String... args) throws Throwable {\n+        new NestedPrimitiveDeconstructionPattern().doTestR();\n+    }\n+\n+    void doTestR() {\n+        assertEquals(\"OK\", switchR1(new R(3, 42d)));\n+        assertEquals(\"OK\", switchR1_int_double(new R_i(3, 42d)));\n+    }\n+\n+    record R(Integer x, Double y) {}\n+\n+    String switchR1(R r) {\n+        return switch (r) {\n+            case R(Integer x, Double y) -> \"OK\";\n+        };\n+    }\n+\n+    record R_i(int x, double y) {}\n+\n+    String switchR1_int_double(R_i r) {\n+        return switch (r) {\n+            case R_i(int x, double y) -> \"OK\";\n+        };\n+    }\n+\n+    private void assertEquals(String expected, String actual) {\n+        if (!Objects.equals(expected, actual)) {\n+            throw new AssertionError(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/NestedPrimitiveDeconstructionPattern.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -69,0 +69,22 @@\n+\n+        \/\/ record classes and null\n+        assertEquals(1, matchingSwitch14(new R(null)));\n+        assertEquals(2, matchingSwitch15(new R(null)));\n+    }\n+\n+    class Super {}\n+    class Sub extends Super {}\n+    record R(Super s) {}\n+\n+    private int matchingSwitch14(R r) {\n+        return switch(r) {\n+            case R(Super s) -> 1;\n+            default -> 2;\n+        };\n+    }\n+\n+    private int matchingSwitch15(R r) {\n+        return switch(r) {\n+            case R(Sub s) -> 1;\n+            default -> 2;\n+        };\n","filename":"test\/langtools\/tools\/javac\/patterns\/NullSwitch.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary Testing record patterns against the null constant (14.30.2 Pattern Matching)\n+ * @compile --enable-preview -source ${jdk.version} NullsInDeconstructionPatterns.java\n+ * @run main\/othervm --enable-preview NullsInDeconstructionPatterns\n+ *\/\n+\n+public class NullsInDeconstructionPatterns {\n+\n+    class Super {}\n+    class Sub extends Super {}\n+    record R(Super s) {}\n+\n+    public static void main(String[] args) {\n+\n+        R r = new R(null);\n+\n+        if (r instanceof R(Super s1)) {\n+            System.out.println(\"R(Super s1) is resolved to the R(any pattern) and does match\");\n+        } else {\n+            throw new AssertionError(\"broken\");\n+        }\n+\n+        if (r instanceof R(Object o)) {\n+            System.out.println(\"R(Object) is resolved to the R(any pattern) and does match\");\n+        } else {\n+            throw new AssertionError(\"broken\");\n+        }\n+\n+        if (r instanceof R(Sub s2)) {\n+            throw new AssertionError(\"broken\");\n+        } else {\n+            System.out.println(\"R(Sub s2) is resolved to the pattern R(Sub s) and does not match\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/NullsInDeconstructionPatterns.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"","filename":"test\/langtools\/tools\/javac\/patterns\/NullsInDeconstructionPatterns.out","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/tools\/javac\/patterns\/NullsInPatterns.out","status":"copied"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test behavior of Pretty\n+ * @modules jdk.compiler\n+ * @compile --enable-preview -source ${jdk.version} PrettyTest.java\n+ * @run main\/othervm --enable-preview PrettyTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.tools.*;\n+\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.util.JavacTask;\n+\n+public class PrettyTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        new PrettyTest().run();\n+    }\n+\n+    void run() throws Exception {\n+        String code = \"class Test {\\n\" +\n+                      \"    boolean t(Object o) {\\n\" +\n+                      \"         boolean b;\\n\" +\n+                      \"         b = o instanceof String s;\\n\" +\n+                      \"         b = o instanceof R(String s);\\n\" +\n+                      \"         b = o instanceof R(var s);\\n\" +\n+                      \"         b = o instanceof R2(R(var s), String t);\\n\" +\n+                      \"         b = o instanceof R2(R(var s), var t);\\n\" +\n+                      \"         b = o instanceof R(String s) r;\\n\" +\n+                      \"    }\\n\" +\n+                      \"    record R(String s) {}\\n\" +\n+                      \"    record R2(R r, String s) {}\\n\" +\n+                      \"}\\n\";\n+        String pretty = parse(code).toString().replaceAll(\"\\\\R\", \"\\n\");\n+        String expected = \"\"\"\n+                          \\n\\\n+                          class Test {\n+                              \\n\\\n+                              boolean t(Object o) {\n+                                  boolean b;\n+                                  b = o instanceof String s;\n+                                  b = o instanceof R(String s);\n+                                  b = o instanceof R(\/*missing*\/ s);\n+                                  b = o instanceof R2(R(\/*missing*\/ s), String t);\n+                                  b = o instanceof R2(R(\/*missing*\/ s), \/*missing*\/ t);\n+                                  b = o instanceof R(String s) r;\n+                              }\n+                              \\n\\\n+                              class R {\n+                                  private final String s;\n+                              }\n+                              \\n\\\n+                              class R2 {\n+                                  private final R r;\n+                                  private final String s;\n+                              }\n+                          }\"\"\";\n+        if (!expected.equals(pretty)) {\n+            throw new AssertionError(\"Actual prettified source: \" + pretty);\n+        }\n+    }\n+\n+    private CompilationUnitTree parse(String code) throws IOException {\n+        final JavaCompiler tool = ToolProvider.getSystemJavaCompiler();\n+        assert tool != null;\n+        DiagnosticListener<JavaFileObject> noErrors = d -> {};\n+\n+        StringWriter out = new StringWriter();\n+        JavacTask ct = (JavacTask) tool.getTask(out, null, noErrors,\n+            List.of(\"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature())), null,\n+            Arrays.asList(new MyFileObject(code)));\n+        return ct.parse().iterator().next();\n+    }\n+\n+    static class MyFileObject extends SimpleJavaFileObject {\n+        private String text;\n+\n+        public MyFileObject(String text) {\n+            super(URI.create(\"myfo:\/Test.java\"), JavaFileObject.Kind.SOURCE);\n+            this.text = text;\n+        }\n+\n+        @Override\n+        public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+            return text;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrettyTest.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,213 @@\n+\/**\n+ * @test\n+ * @compile\/fail\/ref=SimpleDeconstructionPatternNoPreview.out -XDrawDiagnostics SimpleDeconstructionPattern.java\n+ * @compile --enable-preview -source ${jdk.version} SimpleDeconstructionPattern.java\n+ * @run main\/othervm --enable-preview SimpleDeconstructionPattern\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public class SimpleDeconstructionPattern {\n+\n+    public static void main(String... args) throws Throwable {\n+        if (!test2(new P(42))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test2(new P(41))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!test2a(new P(42))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test2a(new P(41))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!test4(new P2(new P(42), \"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test4(new P2(new P(41), \"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test4(new P2(new P(42), \"a\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!test5(new P(42))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test5(new P(41))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!test7(new P3(\"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test7(new P3(\"a\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!test7a(new P3(\"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test7a(new P3(\"a\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test8(new P4(\"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!test8(new P4(new P3(\"\")))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!test8a(new P4(new P3(\"\")))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test8(new P4(new P3(\"a\")))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test8a(new P4(new P3(\"a\")))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!test9(new P5(new ArrayList<String>(Arrays.asList(\"\"))))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test9(new P5(new LinkedList<String>(Arrays.asList(\"\"))))) {\n+            throw new IllegalStateException();\n+        }\n+        if (testA(new P6(null))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!testA(new P6(new P3(null)))) {\n+            throw new IllegalStateException();\n+        }\n+        if (testB(new P6(null))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!testB(new P6(new P3(null)))) {\n+            throw new IllegalStateException();\n+        }\n+        if (testC(new P6(null))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!testC(new P6(new P3(\"\")))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!testD(new P4(\"test\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!testE(new P6(new P3(null)))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!testF(new P7(0, (short) 0))) {\n+            throw new IllegalStateException();\n+        }\n+        if (testF(new P7(0, (short) 1))) {\n+            throw new IllegalStateException();\n+        }\n+        if (testGen3(new GenRecord1<>(3L, \"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!testGen3(new GenRecord1<>(3, \"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!testGen3(new GenRecord1<>(3, \"\"))) {\n+            throw new IllegalStateException();\n+        }\n+    }\n+\n+    private static void exp(Object o) throws Throwable {\n+        if (o instanceof P(var i)) {\n+            System.err.println(\"i=\" + i);\n+        }\n+    }\n+\n+    private static boolean test2(Object o) throws Throwable {\n+        return o instanceof P(var i) && i == 42;\n+    }\n+\n+    private static boolean test2a(Object o) throws Throwable {\n+        return o instanceof P(int i) && i == 42;\n+    }\n+\n+    private static boolean test4(Object o) throws Throwable {\n+        return o instanceof P2(P(var i), var s) && i == 42 && \"\".equals(s);\n+    }\n+\n+    private static boolean test5(Object o) throws Throwable {\n+        return o instanceof P(var i) && i == 42;\n+    }\n+\n+    private static boolean test7(Object o) throws Throwable {\n+        return o instanceof P3(var s) && \"\".equals(s);\n+    }\n+\n+    private static boolean test7a(Object o) throws Throwable {\n+        return o instanceof P3(String s) && \"\".equals(s);\n+    }\n+\n+    private static boolean test8(Object o) throws Throwable {\n+        return o instanceof P4(P3(var s)) && \"\".equals(s);\n+    }\n+\n+    private static boolean test8a(Object o) throws Throwable {\n+        return o instanceof P4(P3(String s)) && \"\".equals(s);\n+    }\n+\n+    private static boolean test9(Object o) throws Throwable {\n+        return o instanceof P5(ArrayList<String> l) && !l.isEmpty();\n+    }\n+\n+    private static boolean testA(Object o) throws Throwable {\n+        return o instanceof P6(P3(var s));\n+    }\n+\n+    private static boolean testB(Object o) throws Throwable {\n+        return o instanceof P6(P3(String s));\n+    }\n+\n+    private static boolean testC(Object o) throws Throwable {\n+        return o instanceof P6(P3(String s)) && s.isEmpty();\n+    }\n+\n+    private static boolean testD(Object o) throws Throwable {\n+        return o instanceof P4(String s) p && (s.isEmpty() || \"test\".equals(p.o()));\n+    }\n+\n+    private static boolean testE(Object o) throws Throwable {\n+        return o instanceof P6(P3(String s)) && s == null;\n+    }\n+\n+    private static boolean testF(Object o) throws Throwable {\n+        return o instanceof P7(int i, short s) && i == s;\n+    }\n+\n+    private static boolean testGen3(Object o) throws Throwable {\n+        return o instanceof GenRecord1<?, ?>(Integer i, var s) && i.intValue() == 3 && s.length() == 0;\n+    }\n+\n+    private static boolean testGen4(GenBase<Integer, String> o) throws Throwable {\n+        return o instanceof GenRecord1<Integer, String>(var i, var s) && i.intValue() == 3 && s.length() == 0;\n+    }\n+\n+    public record P(int i) {\n+    }\n+\n+    public record P2(P p, String s) {\n+    }\n+\n+    public record P3(String s) {\n+    }\n+\n+    public record P4(Object o) {}\n+\n+    public record P5(List<String> l) {}\n+    public record P6(P3 p) {}\n+\n+    public record P7(int i, short s) {}\n+\n+    public interface Base {}\n+    public record BaseUse(Base b) {}\n+    public record BaseSubclass(int i) implements Base {}\n+\n+    public interface GenBase<T1, T2 extends CharSequence> {}\n+    public record GenRecord1<T1, T2 extends CharSequence> (T1 i, T2 s) implements GenBase<T1, T2> {}\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/SimpleDeconstructionPattern.java","additions":213,"deletions":0,"binary":false,"changes":213,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+SimpleDeconstructionPattern.java:118:27: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.deconstruction.patterns)\n+1 error\n","filename":"test\/langtools\/tools\/javac\/patterns\/SimpleDeconstructionPatternNoPreview.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -91,0 +91,6 @@\n+        assertEquals(\"a\", deconstructStatement(new R(\"a\")));\n+        assertEquals(\"1\", deconstructStatement(new R(1)));\n+        assertEquals(\"other\", deconstructStatement(\"\"));\n+        assertEquals(\"a\", deconstructExpression(new R(\"a\")));\n+        assertEquals(\"1\", deconstructExpression(new R(1)));\n+        assertEquals(\"other\", deconstructExpression(\"\"));\n@@ -614,0 +620,16 @@\n+    String deconstructStatement(Object o) {\n+        switch (o) {\n+            case R(String s) -> {return s;}\n+            case R(Integer i) r -> {return r.o().toString();}\n+            case Object x -> {return \"other\";}\n+        }\n+    }\n+\n+    String deconstructExpression(Object o) {\n+        return switch (o) {\n+            case R(String s) -> s;\n+            case R(Integer i) r -> r.o().toString();\n+            case Object x -> \"other\";\n+        };\n+    }\n+\n@@ -653,0 +675,2 @@\n+\n+    record R(Object o) {}\n","filename":"test\/langtools\/tools\/javac\/patterns\/Switches.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @compile --enable-preview -source ${jdk.version} TypedDeconstructionPatternExc.java\n+ * @run main\/othervm --enable-preview TypedDeconstructionPatternExc\n+ *\/\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+public class TypedDeconstructionPatternExc {\n+\n+    public static void main(String... args) throws Throwable {\n+        new TypedDeconstructionPatternExc().run();\n+    }\n+\n+    void run() {\n+        run(this::testExpr);\n+        run(this::testExprCond);\n+    }\n+\n+    void run(Function<Pair<String, Integer>, Integer> tested) {\n+        assertEquals(2, tested.apply(new Pair<>(\"1\", 1)));\n+        try {\n+            tested.apply((Pair<String, Integer>) (Object) new Pair<Integer, Integer>(1, 1));\n+            fail(\"Expected an exception, but none happened!\");\n+        } catch (ClassCastException ex) {\n+            System.err.println(\"expected exception:\");\n+            ex.printStackTrace();\n+        }\n+        try {\n+            tested.apply(new Pair<String, Integer>(\"fail\", 1));\n+            fail(\"Expected an exception, but none happened!\");\n+        } catch (MatchException ex) {\n+            assertEquals(TestPatternFailed.class.getName() + \": \" + EXCEPTION_MESSAGE,\n+                         ex.getMessage());\n+            if (ex.getCause() instanceof TestPatternFailed ex2) {\n+                System.err.println(\"expected exception:\");\n+                ex2.printStackTrace();\n+            } else {\n+                fail(\"Not the correct exception.\");\n+            }\n+        }\n+    }\n+\n+    int testExpr(Pair<String, Integer> p) {\n+        return switch (p) {\n+            case Pair<String, Integer>(String s, Integer i) -> s.length() + i;\n+            case Object o -> -1;\n+        };\n+    }\n+\n+    int testExprCond(Pair<String, Integer> p) {\n+        if (switch (p) {\n+            case Pair<String, Integer>(String s, Integer i) -> true;\n+            case Object o -> false;\n+        }) {\n+            return p.l().length() + p.r();\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n+    static final String EXCEPTION_MESSAGE = \"exception-message\";\n+\n+    record Pair<L, R>(L l, R r) {\n+        public L l() {\n+            if (\"fail\".equals(l)) {\n+                throw new TestPatternFailed(EXCEPTION_MESSAGE);\n+            }\n+            return l;\n+        }\n+        public R r() {\n+            return r;\n+        }\n+    }\n+\n+    void assertEquals(Object expected, Object actual) {\n+        if (!Objects.equals(expected, actual)) {\n+            throw new AssertionError(\"Expected: \" + expected + \",\" +\n+                                     \"got: \" + actual);\n+        }\n+    }\n+\n+    void fail(String message) {\n+        throw new AssertionError(message);\n+    }\n+\n+    public static class TestPatternFailed extends AssertionError {\n+\n+        public TestPatternFailed(String message) {\n+            super(message);\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/TypedDeconstructionPatternExc.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,20 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary Verify errors related to var patterns\n+ * @compile\/fail\/ref=VarErrors.out --enable-preview -source ${jdk.version} -XDrawDiagnostics -XDshould-stop.at=FLOW -XDdev VarErrors.java\n+ *\/\n+public class VarErrors {\n+    void testIf(CharSequence cs) {\n+        if (cs instanceof var v) {}\n+    }\n+    void testSwitchStatement(CharSequence cs) {\n+        switch (cs) {\n+            case var v -> {}\n+        }\n+    }\n+    void testSwitchExpression(CharSequence cs) {\n+        int i = switch (cs) {\n+            case var v -> 0;\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/VarErrors.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+VarErrors.java:8:27: compiler.err.restricted.type.not.allowed.here: var\n+VarErrors.java:12:18: compiler.err.restricted.type.not.allowed.here: var\n+VarErrors.java:17:18: compiler.err.restricted.type.not.allowed.here: var\n+- compiler.note.preview.filename: VarErrors.java, DEFAULT\n+- compiler.note.preview.recompile\n+3 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/VarErrors.out","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import java.util.Locale;\n@@ -96,0 +95,1 @@\n+        String version = System.getProperty(\"java.specification.version\");\n@@ -98,1 +98,1 @@\n-            List.of(), null,\n+            List.of(\"--enable-preview\", \"-source\", version), null,\n","filename":"test\/langtools\/tools\/javac\/switchextra\/RuleParsingTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}