{"files":[{"patch":"@@ -41,4 +41,5 @@\n- *    <li>Null targets and sealed types. If an interface or abstract class {@code C} is sealed\n- *        to permit {@code A} and {@code B}, then the set of record patterns {@code R(A a)} and\n- *        {@code R(B b)} are exhaustive on a record {@code R} whose sole component is of\n- *        type {@code C}, but neither of these patterns will match {@code new R(null)}.<\/li>\n+ *    <li>{@code null} values and nested patterns using sealed types. If an interface or abstract\n+ *        class {@code C} is sealed to permit {@code A} and {@code B}, then the set of record\n+ *        patterns {@code R(A a)} and {@code R(B b)} are exhaustive on a record {@code R} whose\n+ *        sole component is of type {@code C}, but neither of these patterns will match\n+ *        {@code new R(null)}.<\/li>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/MatchException.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    Tree getDeconstructor();\n+    ExpressionTree getDeconstructor();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/DeconstructionPatternTree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1799,1 +1799,1 @@\n-                        boolean unconditional = TreeInfo.unrefinedCaseLabel(pat) && !pat.hasTag(DECONSTRUCTIONPATTERN);\n+                        boolean unconditional = TreeInfo.unrefinedCaseLabel(pat) && !pat.hasTag(RECORDPATTERN);\n@@ -4113,1 +4113,2 @@\n-           tree.pattern.getTag() == PARENTHESIZEDPATTERN) {\n+            tree.pattern.getTag() == PARENTHESIZEDPATTERN ||\n+            tree.pattern.getTag() == RECORDPATTERN) {\n@@ -4117,1 +4118,2 @@\n-                !exprtype.isErroneous() && !clazztype.isErroneous()) {\n+                !exprtype.isErroneous() && !clazztype.isErroneous() &&\n+                tree.pattern.getTag() != RECORDPATTERN) {\n@@ -4124,1 +4126,1 @@\n-            typeTree = TreeInfo.primaryPatternTree((JCPattern) tree.pattern).var.vartype;\n+            typeTree = TreeInfo.primaryPatternTypeTree((JCPattern) tree.pattern);\n@@ -4200,1 +4202,1 @@\n-    public void visitDeconstructionPattern(JCDeconstructionPattern tree) {\n+    public void visitRecordPattern(JCRecordPattern tree) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+import static com.sun.tools.javac.code.TypeTag.NONE;\n@@ -693,2 +694,2 @@\n-                Set<Symbol> constants = coveredSymbolsForCases(tree.pos(), tree.selector, tree.cases);\n-                tree.isExhaustive |= isExhaustive(tree.selector.pos(), tree.selector.type, constants);\n+                Set<Symbol> coveredSymbols = coveredSymbolsForCases(tree.pos(), tree.selector, tree.cases);\n+                tree.isExhaustive |= isExhaustive(tree.selector.pos(), tree.selector.type, coveredSymbols);\n@@ -728,1 +729,1 @@\n-            Set<Symbol> constants = coveredSymbolsForCases(tree.pos(), tree.selector, tree.cases);\n+            Set<Symbol> coveredSymbols = coveredSymbolsForCases(tree.pos(), tree.selector, tree.cases);\n@@ -731,1 +732,1 @@\n-                                isExhaustive(tree.selector.pos(), tree.selector.type, constants);\n+                                isExhaustive(tree.selector.pos(), tree.selector.type, coveredSymbols);\n@@ -750,2 +751,2 @@\n-            Set<Symbol> constants = new HashSet<>();\n-            Map<Symbol, List<JCDeconstructionPattern>> categorizedDeconstructionPatterns = new HashMap<>();\n+            Set<Symbol> coveredSymbols = new HashSet<>();\n+            Map<Symbol, List<JCRecordPattern>> deconstructionPatternsBySymbol = new HashMap<>();\n@@ -757,1 +758,3 @@\n-                        constants.add(primaryPatternType.type().tsym);\n+                        if (!primaryPatternType.type().hasTag(NONE)) {\n+                            coveredSymbols.add(primaryPatternType.type().tsym);\n+                        }\n@@ -759,2 +762,2 @@\n-                    case DECONSTRUCTIONPATTERN -> {\n-                        JCDeconstructionPattern dpat = (JCDeconstructionPattern) label;\n+                    case RECORDPATTERN -> {\n+                        JCRecordPattern dpat = (JCRecordPattern) label;\n@@ -762,2 +765,2 @@\n-                        List<JCDeconstructionPattern> augmentedPatterns =\n-                                categorizedDeconstructionPatterns.getOrDefault(type, List.nil())\n+                        List<JCRecordPattern> augmentedPatterns =\n+                                deconstructionPatternsBySymbol.getOrDefault(type, List.nil())\n@@ -766,1 +769,1 @@\n-                        categorizedDeconstructionPatterns.put(type, augmentedPatterns);\n+                        deconstructionPatternsBySymbol.put(type, augmentedPatterns);\n@@ -775,1 +778,1 @@\n-                                constants.add(((JCIdent) expr).sym);\n+                                coveredSymbols.add(((JCIdent) expr).sym);\n@@ -782,3 +785,3 @@\n-            for (Entry<Symbol, List<JCDeconstructionPattern>> e : categorizedDeconstructionPatterns.entrySet()) {\n-                if (coversDeconstructionStartingFromComponent(pos, targetType, e.getValue(), 0)) {\n-                    constants.add(e.getKey());\n+            for (Entry<Symbol, List<JCRecordPattern>> e : deconstructionPatternsBySymbol.entrySet()) {\n+                if (coversDeconstructionFromComponent(pos, targetType, e.getValue(), 0)) {\n+                    coveredSymbols.add(e.getKey());\n@@ -787,1 +790,1 @@\n-            return constants;\n+            return coveredSymbols;\n@@ -790,5 +793,17 @@\n-        private boolean coversDeconstructionStartingFromComponent(DiagnosticPosition pos,\n-                                                                  Type targetType,\n-                                                                  List<JCDeconstructionPattern> patterns,\n-                                                                  int component) {\n-            List<? extends RecordComponent> components = patterns.head.record.getRecordComponents();\n+        private boolean coversDeconstructionFromComponent(DiagnosticPosition pos,\n+                                                          Type targetType,\n+                                                          List<JCRecordPattern> deconstructionPatterns,\n+                                                          int component) {\n+            \/\/Given a set of record patterns for the same record, and a starting component,\n+            \/\/this method checks, whether the nested patterns for the components are exhaustive,\n+            \/\/i.e. represent all possible combinations.\n+            \/\/This is done by categorizing the patterns based on the type covered by the given\n+            \/\/starting component.\n+            \/\/For each such category, it is then checked if the nested patterns starting at the next\n+            \/\/component are exhaustive, by recursivelly invoking this method. If these nested patterns\n+            \/\/are exhaustive, the given covered type is accepted.\n+            \/\/All such covered types are then checked whether they cover the declared type of\n+            \/\/the starting component's declaration. If yes, the given set of patterns starting at\n+            \/\/the given component cover the given record exhaustivelly, and true is returned.\n+            List<? extends RecordComponent> components =\n+                    deconstructionPatterns.head.record.getRecordComponents();\n@@ -797,0 +812,1 @@\n+                \/\/no components remain to be checked:\n@@ -800,6 +816,9 @@\n-            Type parameterizedComponentType = types.memberType(targetType, components.get(component));\n-            List<JCPattern> nestedComponentPatterns = patterns.map(d -> d.nested.get(component));\n-            Set<Symbol> nestedCovered = coveredSymbols(pos, parameterizedComponentType,\n-                                                       nestedComponentPatterns);\n-            Map<Symbol, List<JCDeconstructionPattern>> componentType2Patterns = new HashMap<>();\n-            Set<Symbol> covered = new HashSet<>();\n+            \/\/for the first tested component, gather symbols covered by the nested patterns:\n+            Type instantiatedComponentType = types.memberType(targetType, components.get(component));\n+            List<JCPattern> nestedComponentPatterns = deconstructionPatterns.map(d -> d.nested.get(component));\n+            Set<Symbol> coveredSymbolsForComponent = coveredSymbols(pos, instantiatedComponentType,\n+                                                                    nestedComponentPatterns);\n+\n+            \/\/for each of the symbols covered by the starting component, find all deconstruction patterns\n+            \/\/that have the given type, or its supertype, as a type of the starting nested pattern:\n+            Map<Symbol, List<JCRecordPattern>> coveredSymbol2Patterns = new HashMap<>();\n@@ -807,3 +826,3 @@\n-            for (JCDeconstructionPattern subTypeCandidate : patterns) {\n-                JCPattern nestedPattern = subTypeCandidate.nested.get(component);\n-                Symbol currentPatternType;\n+            for (JCRecordPattern deconstructionPattern : deconstructionPatterns) {\n+                JCPattern nestedPattern = deconstructionPattern.nested.get(component);\n+                Symbol componentPatternType;\n@@ -814,1 +833,1 @@\n-                        currentPatternType = primaryPatternType.type().tsym;\n+                        componentPatternType = primaryPatternType.type().tsym;\n@@ -816,2 +835,2 @@\n-                    case DECONSTRUCTIONPATTERN -> {\n-                        currentPatternType = ((JCDeconstructionPattern) nestedPattern).record;\n+                    case RECORDPATTERN -> {\n+                        componentPatternType = ((JCRecordPattern) nestedPattern).record;\n@@ -823,1 +842,1 @@\n-                for (Symbol currentType : nestedCovered) {\n+                for (Symbol currentType : coveredSymbolsForComponent) {\n@@ -825,3 +844,3 @@\n-                                        types.erasure(currentPatternType.type))) {\n-                        componentType2Patterns.put(currentType,\n-                                                   componentType2Patterns.getOrDefault(currentType,\n+                                        types.erasure(componentPatternType.type))) {\n+                        coveredSymbol2Patterns.put(currentType,\n+                                                   coveredSymbol2Patterns.getOrDefault(currentType,\n@@ -829,1 +848,1 @@\n-                                              .prepend(subTypeCandidate));\n+                                              .prepend(deconstructionPattern));\n@@ -834,2 +853,7 @@\n-            for (Entry<Symbol, List<JCDeconstructionPattern>> e : componentType2Patterns.entrySet()) {\n-                if (coversDeconstructionStartingFromComponent(pos, targetType, e.getValue(), component + 1)) {\n+            \/\/Check the components following the starting component, for each of the covered symbol,\n+            \/\/if they are exhaustive. If yes, the given covered symbol should be part of the following\n+            \/\/exhaustiveness check:\n+            Set<Symbol> covered = new HashSet<>();\n+\n+            for (Entry<Symbol, List<JCRecordPattern>> e : coveredSymbol2Patterns.entrySet()) {\n+                if (coversDeconstructionFromComponent(pos, targetType, e.getValue(), component + 1)) {\n@@ -840,1 +864,2 @@\n-            return isExhaustive(pos, parameterizedComponentType, covered);\n+            \/\/verify whether the filtered symbols cover the given record's declared type:\n+            return isExhaustive(pos, instantiatedComponentType, covered);\n@@ -2951,2 +2976,2 @@\n-        public void visitDeconstructionPattern(JCDeconstructionPattern tree) {\n-            super.visitDeconstructionPattern(tree);\n+        public void visitRecordPattern(JCRecordPattern tree) {\n+            super.visitRecordPattern(tree);\n@@ -3146,1 +3171,1 @@\n-        public void visitDeconstructionPattern(JCDeconstructionPattern tree) {\n+        public void visitRecordPattern(JCRecordPattern tree) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":70,"deletions":45,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-            case PARENS: case DECONSTRUCTIONPATTERN:\n+            case PARENS: case RECORDPATTERN:\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MatchBindingsComputer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,0 @@\n-import com.sun.tools.javac.tree.JCTree.JCDeconstructionPattern;\n@@ -93,0 +92,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCRecordPattern;\n@@ -262,1 +262,1 @@\n-    public void visitDeconstructionPattern(JCDeconstructionPattern tree) {\n+    public void visitRecordPattern(JCRecordPattern tree) {\n@@ -306,1 +306,1 @@\n-            } else if (nested.type.isReference() && nested.hasTag(Tag.DECONSTRUCTIONPATTERN)) {\n+            } else if (nested.type.isReference() && nested.hasTag(Tag.RECORDPATTERN)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -590,2 +590,3 @@\n-    public void visitDeconstructionPattern(JCDeconstructionPattern tree) {\n-        tree.fullComponentTypes = tree.record.getRecordComponents().map(rc -> types.memberType(tree.type, rc));\n+    public void visitRecordPattern(JCRecordPattern tree) {\n+        tree.fullComponentTypes = tree.record.getRecordComponents()\n+                                             .map(rc -> types.memberType(tree.type, rc));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import com.sun.tools.javac.tree.JCTree.JCDeconstructionPattern;\n@@ -75,0 +74,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCRecordPattern;\n@@ -269,2 +269,2 @@\n-    public void visitDeconstructionPattern(JCTree.JCDeconstructionPattern tree) {\n-        JCDeconstructionPattern that = (JCDeconstructionPattern) parameter;\n+    public void visitRecordPattern(JCTree.JCRecordPattern tree) {\n+        JCRecordPattern that = (JCRecordPattern) parameter;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TreeDiffer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -765,1 +765,2 @@\n-    public JCPattern parsePattern(int pos, JCModifiers mods, JCExpression parsedType) {\n+    public JCPattern parsePattern(int pos, JCModifiers mods, JCExpression parsedType,\n+                                  boolean allowVar) {\n@@ -771,1 +772,1 @@\n-            JCPattern p = parsePattern(token.pos, null, null);\n+            JCPattern p = parsePattern(token.pos, null, null, true);\n@@ -778,2 +779,3 @@\n-                if (token.kind == IDENTIFIER && token.name() == names.var) {\n-                    nextToken();\n+                boolean var = token.kind == IDENTIFIER && token.name() == names.var;\n+                e = unannotatedType(allowVar, TYPE | NOLAMBDA);\n+                if (var) {\n@@ -781,2 +783,0 @@\n-                } else {\n-                    e = term(TYPE | NOLAMBDA);\n@@ -788,0 +788,2 @@\n+                \/\/deconstruction pattern:\n+                checkSourceLevel(Feature.DECONSTRUCTION_PATTERNS);\n@@ -792,1 +794,1 @@\n-                        JCPattern nestedPattern = parsePattern(token.pos, null, null);\n+                        JCPattern nestedPattern = parsePattern(token.pos, null, null, true);\n@@ -806,1 +808,1 @@\n-                pattern = toP(F.at(pos).DeconstructionPattern(e, nested.toList(), var));\n+                pattern = toP(F.at(pos).RecordPattern(e, nested.toList(), var));\n@@ -808,0 +810,1 @@\n+                \/\/type test pattern:\n@@ -848,1 +851,5 @@\n-        JCExpression result = term(TYPE);\n+        return unannotatedType(allowVar, TYPE);\n+    }\n+\n+    public JCExpression unannotatedType(boolean allowVar, int newmode) {\n+        JCExpression result = term(newmode);\n@@ -997,1 +1004,1 @@\n-                    pattern = parsePattern(token.pos, null, null);\n+                    pattern = parsePattern(token.pos, null, null, false);\n@@ -1005,1 +1012,1 @@\n-                        pattern = parsePattern(patternPos, mods, type);\n+                        pattern = parsePattern(patternPos, mods, type, false);\n@@ -1007,16 +1014,1 @@\n-                        checkSourceLevel(Feature.DECONSTRUCTION_PATTERNS);\n-                        ListBuffer<JCPattern> nested = new ListBuffer<>();\n-                        do {\n-                            nextToken();\n-                            JCPattern nestedPattern = parsePattern(token.pos, null, null);\n-                            nested.append(nestedPattern);\n-                        } while (token.kind == COMMA);\n-                        accept(RPAREN);\n-                        JCVariableDecl var;\n-                        if (token.kind == IDENTIFIER) {\n-                            var = to(F.at(token.pos).VarDef(F.Modifiers(0), token.name(), type, null));\n-                            nextToken();\n-                        } else {\n-                            var = null;\n-                        }\n-                        pattern = toP(F.at(type).DeconstructionPattern(type, nested.toList(), var));\n+                        pattern = parsePattern(patternPos, mods, type, false);\n@@ -3123,1 +3115,1 @@\n-                JCPattern p = parsePattern(patternPos, mods, null);\n+                JCPattern p = parsePattern(patternPos, mods, null, false);\n@@ -3139,2 +3131,2 @@\n-        int depth = 0;\n-        int parentDepth = 0;\n+        int typeDepth = 0;\n+        int parenDepth = 0;\n@@ -3148,2 +3140,2 @@\n-                    if (depth == 0 && peekToken(lookahead, LAX_IDENTIFIER)) {\n-                        if (parentDepth == 0) {\n+                    if (typeDepth == 0 && peekToken(lookahead, LAX_IDENTIFIER)) {\n+                        if (parenDepth == 0) {\n@@ -3157,3 +3149,3 @@\n-                case LT: depth++; break;\n-                case GTGTGT: depth--;\n-                case GTGT: depth--;\n+                case LT: typeDepth++; break;\n+                case GTGTGT: typeDepth--;\n+                case GTGT: typeDepth--;\n@@ -3161,2 +3153,2 @@\n-                    depth--;\n-                    if (depth == 0) {\n+                    typeDepth--;\n+                    if (typeDepth == 0) {\n@@ -3166,1 +3158,1 @@\n-                    } else if (depth < 0) return PatternResult.EXPRESSION;\n+                    } else if (typeDepth < 0) return PatternResult.EXPRESSION;\n@@ -3182,1 +3174,1 @@\n-                        return parentDepth != 0 && S.token(lookahead + 2).kind == ARROW\n+                        return parenDepth != 0 && S.token(lookahead + 2).kind == ARROW\n@@ -3186,3 +3178,3 @@\n-                    parentDepth++; break;\n-                case RPAREN: parentDepth--; break;\n-                case ARROW: return parentDepth > 0 ? PatternResult.EXPRESSION\n+                    parenDepth++; break;\n+                case RPAREN: parenDepth--; break;\n+                case ARROW: return parenDepth > 0 ? PatternResult.EXPRESSION\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":34,"deletions":42,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -246,1 +246,1 @@\n-        DECONSTRUCTIONPATTERN,\n+        RECORDPATTERN,\n@@ -2373,1 +2373,1 @@\n-    public static class JCDeconstructionPattern extends JCPattern\n+    public static class JCRecordPattern extends JCPattern\n@@ -2381,2 +2381,2 @@\n-        protected JCDeconstructionPattern(JCExpression deconstructor, List<JCPattern> nested,\n-                                          JCVariableDecl var) {\n+        protected JCRecordPattern(JCExpression deconstructor, List<JCPattern> nested,\n+                                  JCVariableDecl var) {\n@@ -2394,1 +2394,1 @@\n-        public Tree getDeconstructor() {\n+        public ExpressionTree getDeconstructor() {\n@@ -2405,1 +2405,1 @@\n-            v.visitDeconstructionPattern(this);\n+            v.visitRecordPattern(this);\n@@ -2421,1 +2421,1 @@\n-            return DECONSTRUCTIONPATTERN;\n+            return RECORDPATTERN;\n@@ -3473,1 +3473,1 @@\n-        public void visitDeconstructionPattern(JCDeconstructionPattern that) { visitTree(that); }\n+        public void visitRecordPattern(JCRecordPattern that) { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -928,1 +928,1 @@\n-    public void visitDeconstructionPattern(JCDeconstructionPattern tree) {\n+    public void visitRecordPattern(JCRecordPattern tree) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -521,1 +521,1 @@\n-        JCDeconstructionPattern t = (JCDeconstructionPattern) node;\n+        JCRecordPattern t = (JCRecordPattern) node;\n@@ -525,1 +525,1 @@\n-        return M.at(t.pos).DeconstructionPattern(deconstructor, nested, var);\n+        return M.at(t.pos).RecordPattern(deconstructor, nested, var);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1313,1 +1313,1 @@\n-            case DECONSTRUCTIONPATTERN -> new PatternPrimaryType(((JCDeconstructionPattern) pat).type);\n+            case RECORDPATTERN -> new PatternPrimaryType(((JCRecordPattern) pat).type);\n@@ -1318,1 +1318,1 @@\n-    public static JCBindingPattern primaryPatternTree(JCTree pat) {\n+    public static JCTree primaryPatternTypeTree(JCTree pat) {\n@@ -1320,2 +1320,3 @@\n-            case BINDINGPATTERN -> (JCBindingPattern) pat;\n-            case PARENTHESIZEDPATTERN -> primaryPatternTree(((JCParenthesizedPattern) pat).pattern);\n+            case BINDINGPATTERN -> ((JCBindingPattern) pat).var.vartype;\n+            case PARENTHESIZEDPATTERN -> primaryPatternTypeTree(((JCParenthesizedPattern) pat).pattern);\n+            case RECORDPATTERN -> ((JCRecordPattern) pat).deconstructor;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -503,3 +503,3 @@\n-    public JCDeconstructionPattern DeconstructionPattern(JCExpression deconstructor, List<JCPattern> nested,\n-                                                         JCVariableDecl var) {\n-        JCDeconstructionPattern tree = new JCDeconstructionPattern(deconstructor, nested, var);\n+    public JCRecordPattern RecordPattern(JCExpression deconstructor, List<JCPattern> nested,\n+                                         JCVariableDecl var) {\n+        JCRecordPattern tree = new JCRecordPattern(deconstructor, nested, var);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -322,1 +322,1 @@\n-    public void visitDeconstructionPattern(JCDeconstructionPattern that) {\n+    public void visitRecordPattern(JCRecordPattern that) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -474,1 +474,1 @@\n-    public void visitDeconstructionPattern(JCDeconstructionPattern tree) {\n+    public void visitRecordPattern(JCRecordPattern tree) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,20 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary Verify errors related to var patterns\n+ * @compile\/fail\/ref=VarErrors.out --enable-preview -source ${jdk.version} -XDrawDiagnostics -XDshould-stop.at=FLOW -XDdev VarErrors.java\n+ *\/\n+public class VarErrors {\n+    void testIf(CharSequence cs) {\n+        if (cs instanceof var v) {}\n+    }\n+    void testSwitchStatement(CharSequence cs) {\n+        switch (cs) {\n+            case var v -> {}\n+        }\n+    }\n+    void testSwitchExpression(CharSequence cs) {\n+        int i = switch (cs) {\n+            case var v -> 0;\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/VarErrors.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+VarErrors.java:8:27: compiler.err.restricted.type.not.allowed.here: var\n+VarErrors.java:12:18: compiler.err.restricted.type.not.allowed.here: var\n+VarErrors.java:17:18: compiler.err.restricted.type.not.allowed.here: var\n+- compiler.note.preview.filename: VarErrors.java, DEFAULT\n+- compiler.note.preview.recompile\n+3 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/VarErrors.out","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"}]}