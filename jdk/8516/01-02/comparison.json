{"files":[{"patch":"@@ -4208,0 +4208,5 @@\n+            if (record.type.getTypeArguments().nonEmpty()) {\n+                if (!tree.deconstructor.hasTag(TYPEAPPLY)) {\n+                    log.error(tree.pos(),Errors.RawDeconstructionPattern);\n+                }\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -300,3 +300,1 @@\n-                if (types.isAssignable(nestedFullComponentTypes.head, nested.type)) {\n-                    extraTest = makeBinary(Tag.NE, make.Ident(nestedTemp), makeNull());\n-                } else {\n+                if (!types.isAssignable(nestedFullComponentTypes.head, nested.type)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -766,1 +766,1 @@\n-                                  boolean allowVar) {\n+                                  boolean allowVar, boolean checkGuard) {\n@@ -772,1 +772,1 @@\n-            JCPattern p = parsePattern(token.pos, null, null, true);\n+            JCPattern p = parsePattern(token.pos, null, null, true, false);\n@@ -794,1 +794,1 @@\n-                        JCPattern nestedPattern = parsePattern(token.pos, null, null, true);\n+                        JCPattern nestedPattern = parsePattern(token.pos, null, null, true, false);\n@@ -803,2 +803,6 @@\n-                    var = to(F.at(token.pos).VarDef(F.Modifiers(0), token.name(), e, null));\n-                    nextToken();\n+                    if (!checkGuard || token.name() != names.when) {\n+                        var = to(F.at(token.pos).VarDef(F.Modifiers(0), token.name(), e, null));\n+                        nextToken();\n+                    } else {\n+                        var = null;\n+                    }\n@@ -1004,1 +1008,1 @@\n-                    pattern = parsePattern(token.pos, null, null, false);\n+                    pattern = parsePattern(token.pos, null, null, false, false);\n@@ -1012,1 +1016,1 @@\n-                        pattern = parsePattern(patternPos, mods, type, false);\n+                        pattern = parsePattern(patternPos, mods, type, false, false);\n@@ -1014,1 +1018,1 @@\n-                        pattern = parsePattern(patternPos, mods, type, false);\n+                        pattern = parsePattern(patternPos, mods, type, false, false);\n@@ -3115,1 +3119,1 @@\n-                JCPattern p = parsePattern(patternPos, mods, null, false);\n+                JCPattern p = parsePattern(patternPos, mods, null, false, true);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -3929,0 +3929,3 @@\n+compiler.err.raw.deconstruction.pattern=\\\n+    raw deconstruction patterns are not allowed\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.raw.deconstruction.pattern\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview -source ${jdk.version}\n+\n+class RawDeconstructionPattern {\n+    boolean test(Object o) {\n+        return o instanceof R(String s);\n+    }\n+\n+    record R<T>(T t) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/RawDeconstructionPattern.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -38,0 +38,9 @@\n+        GenRecord<String> r1 = null;\n+        if (r1 instanceof GenRecord(String s)) {}\n+        switch (r1) {\n+            case GenRecord(String s) -> {}\n+        }\n+        if (r1 instanceof GenRecord<>(String s)) {}\n+        switch (r1) {\n+            case GenRecord<>(String s) -> {}\n+        }\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3,0 +3,2 @@\n+DeconstructionPatternErrors.java:43:37: compiler.err.illegal.start.of.type\n+DeconstructionPatternErrors.java:45:28: compiler.err.illegal.start.of.type\n@@ -29,0 +31,2 @@\n+DeconstructionPatternErrors.java:39:27: compiler.err.raw.deconstruction.pattern\n+DeconstructionPatternErrors.java:41:18: compiler.err.raw.deconstruction.pattern\n@@ -31,1 +35,1 @@\n-28 errors\n+32 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.out","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @compile --enable-preview -source ${jdk.version} GenericRecordDeconstructionPattern.java\n+ * @run main\/othervm --enable-preview GenericRecordDeconstructionPattern\n+ *\/\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+public class GenericRecordDeconstructionPattern {\n+\n+    public static void main(String... args) throws Throwable {\n+        new GenericRecordDeconstructionPattern().run();\n+    }\n+\n+    void run() {\n+        runTest(this::runIf);\n+        runTest(this::runSwitch);\n+        runTest(this::runSwitchExpression);\n+    }\n+\n+    void runTest(Function<Box<String>, Integer> test) {\n+        Box<String> b = new Box<>(null);\n+        assertEquals(1, test.apply(b));\n+    }\n+\n+    int runIf(Box<String> b) {\n+        if (b instanceof Box<String>(String s)) return 1;\n+        return -1;\n+    }\n+\n+    int runSwitch(Box<String> b) {\n+        switch (b) {\n+            case Box<String>(String s): return 1;\n+            default: return -1;\n+        }\n+    }\n+\n+    int runSwitchExpression(Box<String> b) {\n+        return switch (b) {\n+            case Box<String>(String s) -> 1;\n+            default -> -1;\n+        };\n+    }\n+\n+    record Box<V>(V v) {\n+    }\n+\n+    void assertEquals(Object expected, Object actual) {\n+        if (!Objects.equals(expected, actual)) {\n+            throw new AssertionError(\"Expected: \" + expected + \",\" +\n+                                     \"got: \" + actual);\n+        }\n+    }\n+\n+    void fail(String message) {\n+        throw new AssertionError(message);\n+    }\n+\n+    public static class TestPatternFailed extends AssertionError {\n+\n+        public TestPatternFailed(String message) {\n+            super(message);\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/GenericRecordDeconstructionPattern.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -59,0 +59,1 @@\n+        assertEquals(\"box with empty\", convert.apply(new Box(\"\")));\n@@ -73,0 +74,1 @@\n+            case Box(String s) when s.isEmpty(): return \"box with empty\";\n@@ -82,0 +84,1 @@\n+            case Box(String s) when s.isEmpty() -> \"box with empty\";\n@@ -92,0 +95,1 @@\n+            case Box(String s) when s.isEmpty() -> {x = \"box with empty\"; yield true; }\n@@ -182,0 +186,2 @@\n+    record Box(Object o) {}\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Guards.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -106,12 +106,0 @@\n-        if (!testGen1(new GenRecord1<>(1L, \"\"))) {\n-            throw new IllegalStateException();\n-        }\n-        if (testGen1(new GenRecord1<>(1L, \"a\"))) {\n-            throw new IllegalStateException();\n-        }\n-        if (testGen2(new GenRecord1<>(3L, \"\"))) {\n-            throw new IllegalStateException();\n-        }\n-        if (!testGen2(new GenRecord1<>(3, \"\"))) {\n-            throw new IllegalStateException();\n-        }\n@@ -195,8 +183,0 @@\n-    private static boolean testGen1(Object o) throws Throwable {\n-        return o instanceof GenRecord1(var i, var s) && s.length() == 0;\n-    }\n-\n-    private static boolean testGen2(Object o) throws Throwable {\n-        return o instanceof GenRecord1(Integer i, var s) && i.intValue() == 3 && s.length() == 0;\n-    }\n-\n","filename":"test\/langtools\/tools\/javac\/patterns\/SimpleDeconstructionPattern.java","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-SimpleDeconstructionPattern.java:130:27: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.deconstruction.patterns)\n+SimpleDeconstructionPattern.java:118:27: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.deconstruction.patterns)\n","filename":"test\/langtools\/tools\/javac\/patterns\/SimpleDeconstructionPatternNoPreview.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}