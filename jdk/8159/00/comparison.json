{"files":[{"patch":"@@ -64,1 +64,4 @@\n-  static  int code_size_to_size(int code_size)   { return align_up((int)sizeof(ICStub), CodeEntryAlignment) + code_size; }\n+\n+  \/\/ ICStub_from_destination_address looks up Stub* address from code entry address,\n+  \/\/ which unfortunately means the stub head should be at the same alignment as the code.\n+  static  int alignment()                        { return CodeEntryAlignment; }\n@@ -71,1 +74,1 @@\n-  address code_begin() const                     { return (address)this + align_up(sizeof(ICStub), CodeEntryAlignment); }\n+  address code_begin() const                     { return align_up((address)this + sizeof(ICStub), CodeEntryAlignment); }\n","filename":"src\/hotspot\/share\/code\/icBuffer.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -116,0 +116,6 @@\n+int StubQueue::compute_stub_size(Stub* stub, int code_size) {\n+  address stub_begin = (address) stub;\n+  address code_begin = stub_code_begin(stub);\n+  address code_end = align_up(code_begin + code_size, stub_alignment());\n+  return (int)(code_end - stub_begin);\n+}\n@@ -121,1 +127,1 @@\n-  int requested_size = align_up(stub_code_size_to_size(requested_code_size), CodeEntryAlignment);\n+  int requested_size = compute_stub_size(s, requested_code_size);\n@@ -157,1 +163,0 @@\n-  int committed_size = align_up(stub_code_size_to_size(committed_code_size), CodeEntryAlignment);\n@@ -159,0 +164,1 @@\n+  int committed_size = compute_stub_size(s, committed_code_size);\n@@ -214,4 +220,4 @@\n-  guarantee(_buffer_size  % CodeEntryAlignment == 0, \"_buffer_size  not aligned\");\n-  guarantee(_buffer_limit % CodeEntryAlignment == 0, \"_buffer_limit not aligned\");\n-  guarantee(_queue_begin  % CodeEntryAlignment == 0, \"_queue_begin  not aligned\");\n-  guarantee(_queue_end    % CodeEntryAlignment == 0, \"_queue_end    not aligned\");\n+  guarantee(_buffer_size  % stub_alignment() == 0, \"_buffer_size  not aligned\");\n+  guarantee(_buffer_limit % stub_alignment() == 0, \"_buffer_limit not aligned\");\n+  guarantee(_queue_begin  % stub_alignment() == 0, \"_queue_begin  not aligned\");\n+  guarantee(_queue_end    % stub_alignment() == 0, \"_queue_end    not aligned\");\n","filename":"src\/hotspot\/share\/code\/stubs.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -45,2 +45,3 @@\n-\/\/                ________\n-\/\/ stub       -->|        | <--+\n+\/\/\n+\/\/ stub       -->|--------| <--+       <--- aligned by alignment()\n+\/\/               |        |    |\n@@ -48,2 +49,3 @@\n-\/\/               |________|    |\n-\/\/ code_begin -->|        |    |\n+\/\/               |        |    |\n+\/\/ code_begin -->|--------|    |       <--- aligned by CodeEntryAlignment\n+\/\/               |        |    |\n@@ -53,6 +55,3 @@\n-\/\/               |________|    |\n-\/\/ code_end   -->|        |    |\n-\/\/               |  data  |    |\n-\/\/               |________|    |\n-\/\/                          <--+\n-\n+\/\/               |        |    |\n+\/\/ code_end   -->|--------| <--+\n+\/\/\n@@ -68,1 +67,0 @@\n-  static  int code_size_to_size(int code_size)   { ShouldNotCallThis(); return 0; }      \/\/ computes the size given the code size\n@@ -100,2 +98,2 @@\n-  virtual int     size(Stub* self) const                   = 0; \/\/ the total size of the stub in bytes (must be a multiple of CodeEntryAlignment)\n-  virtual int     code_size_to_size(int code_size) const   = 0; \/\/ computes the total stub size in bytes given the code size in bytes\n+  virtual int     size(Stub* self) const                   = 0; \/\/ the total size of the stub in bytes (must be a multiple of HeapWordSize)\n+  virtual int     alignment() const                        = 0; \/\/ computes the alignment\n@@ -129,1 +127,1 @@\n-    virtual int     code_size_to_size(int code_size) const { return stub::code_size_to_size(code_size); } \\\n+    virtual int     alignment() const                      { return stub::alignment(); }           \\\n@@ -156,1 +154,1 @@\n-  void  check_index(int i) const                 { assert(0 <= i && i < _buffer_limit && i % CodeEntryAlignment == 0, \"illegal index\"); }\n+  void  check_index(int i) const                 { assert(0 <= i && i < _buffer_limit && i % stub_alignment() == 0, \"illegal index\"); }\n@@ -163,1 +161,1 @@\n-  void  stub_initialize(Stub* s, int size)       { assert(size % CodeEntryAlignment == 0, \"size not aligned\"); _stub_interface->initialize(s, size); }\n+  void  stub_initialize(Stub* s, int size)       { assert(size % stub_alignment() == 0, \"size not aligned\"); _stub_interface->initialize(s, size); }\n@@ -167,1 +165,2 @@\n-  int   stub_code_size_to_size(int code_size) const { return _stub_interface->code_size_to_size(code_size); }\n+  int   stub_alignment()                   const { return _stub_interface->alignment(); }\n+  address stub_code_begin(Stub* s)         const { return _stub_interface->code_begin(s); }\n@@ -171,0 +170,3 @@\n+  \/\/ Helpers\n+  int compute_stub_size(Stub* stub, int code_size);\n+\n","filename":"src\/hotspot\/share\/code\/stubs.hpp","additions":19,"deletions":17,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  static  int code_size_to_size(int code_size)   { return align_up((int)sizeof(InterpreterCodelet), CodeEntryAlignment) + code_size; }\n+  static  int alignment()                        { return HeapWordSize; }\n@@ -65,1 +65,1 @@\n-  address code_begin() const                     { return (address)this + align_up(sizeof(InterpreterCodelet), CodeEntryAlignment); }\n+  address code_begin() const                     { return align_up((address)this + sizeof(InterpreterCodelet), CodeEntryAlignment); }\n","filename":"src\/hotspot\/share\/interpreter\/interpreter.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}