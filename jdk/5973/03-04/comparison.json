{"files":[{"patch":"@@ -500,2 +500,3 @@\n-     * of the platform's {@linkplain Runtime#version() version}, an\n-     * {@code IllegalArgumentException} is thrown.\n+     * of the {@linkplain #runtimeVersion() runtime version} of the\n+     * {@linkplain #latest() latest source version}, an {@code\n+     * IllegalArgumentException} is thrown.\n@@ -522,8 +523,3 @@\n-        int feature = rv.feature();\n-        if (feature > Runtime.version().feature()) {\n-            throw new IllegalArgumentException(\"No matching SourceVersion for \" + rv);\n-        } else {\n-            \/\/ Could also implement this as a switch where a case was\n-            \/\/ added with each new release.\n-            return valueOf(\"RELEASE_\" + feature);\n-        }\n+        \/\/ Could also implement this as a switch where a case was\n+        \/\/ added with each new release.\n+        return valueOf(\"RELEASE_\" + rv.feature());\n@@ -534,3 +530,7 @@\n-     * version} The returned runtime version has a {@linkplain\n-     * Runtime.Version#feature() feature} large enough to support this\n-     * source version and has no other elements set.\n+     * version; otherwise {@code null}} The returned runtime version\n+     * has a {@linkplain Runtime.Version#feature() feature} large\n+     * enough to support this source version and has no other elements\n+     * set.\n+     *\n+     * Source versions greater than or equal to {@link RELEASE_6}\n+     * have non-{@code null} results.\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/SourceVersion.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -153,0 +153,5 @@\n+    \/**\n+     * Test that SourceVersion.valueOf() maps a Runtime.Version to a\n+     * SourceVersion properly. The SourceVersion result is only a\n+     * function of the feature() component of a Runtime.Version.\n+     *\/\n@@ -158,6 +163,6 @@\n-                Runtime.Version rv = Runtime.Version.parse(Integer.toString(sv.ordinal()));\n-                SourceVersion  result = SourceVersion.valueOf(rv);\n-                if (result != sv) {\n-                    throw new RuntimeException(\"Unexpected result \" + result +\n-                                               \" of mapping Runtime.Version \" + rv);\n-                }\n+                \/\/ Plain mapping; e.g. \"17\" -> RELEASE_17\n+                String featureBase = Integer.toString(sv.ordinal());\n+                checkValueOfResult(sv, featureBase);\n+\n+                \/\/ More populated runtime version, N.N\n+                checkValueOfResult(sv, featureBase + \".\" + featureBase);\n@@ -166,0 +171,19 @@\n+\n+        \/\/ Out of range test\n+        try {\n+            int latestFeature = SourceVersion.latest().runtimeVersion().feature();\n+            SourceVersion.valueOf(Runtime.Version.parse(Integer.toString(latestFeature +1)));\n+            throw new RuntimeException(\"Should not reach\");\n+        } catch (IllegalArgumentException iae) {\n+            ; \/\/ Expected\n+        }\n+    }\n+\n+    private static void checkValueOfResult(SourceVersion expected, String versionString) {\n+        Runtime.Version rv = Runtime.Version.parse(versionString);\n+        SourceVersion  result = SourceVersion.valueOf(rv);\n+        if (result != expected) {\n+            throw new RuntimeException(\"Unexpected result \" + result +\n+                                       \" of mapping Runtime.Version \" + versionString +\n+                                       \" intead of \" + expected);\n+        }\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/TestSourceVersion.java","additions":30,"deletions":6,"binary":false,"changes":36,"status":"modified"}]}