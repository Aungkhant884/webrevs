{"files":[{"patch":"@@ -495,0 +495,54 @@\n+\n+    \/**\n+     * {@return the latest source version that is usable under the\n+     * runtime version argument} If the runtime version's {@linkplain\n+     * Runtime.Version#feature() feature} is greater than the feature\n+     * of the {@linkplain #runtimeVersion() runtime version} of the\n+     * {@linkplain #latest() latest source version}, an {@code\n+     * IllegalArgumentException} is thrown.\n+     *\n+     * <p>Because the source versions of the Java programming language\n+     * have so far followed a linear progression, only the feature\n+     * component of a runtime version is queried to determine the\n+     * mapping to a source version. If that linearity changes in the\n+     * future, other components of the runtime version may influence\n+     * the result.\n+     *\n+     * @apiNote\n+     * An expression to convert from a string value, for example\n+     * {@code \"17\"}, to the corresponding source version, {@code\n+     * RELEASE_17}, is:\n+     *\n+     * <pre>{@code SourceVersion.valueOf(Runtime.Version.parse(\"17\"))}<\/pre>\n+     *\n+     * @param rv runtime version to map to a source version\n+     * @throws IllegalArgumentException if the feature of version\n+     * argument is greater than the feature of the platform version.\n+     * @since 18\n+     *\/\n+    public static SourceVersion valueOf(Runtime.Version rv) {\n+        \/\/ Could also implement this as a switch where a case was\n+        \/\/ added with each new release.\n+        return valueOf(\"RELEASE_\" + rv.feature());\n+    }\n+\n+    \/**\n+     * {@return the least runtime version that supports this source\n+     * version; otherwise {@code null}} The returned runtime version\n+     * has a {@linkplain Runtime.Version#feature() feature} large\n+     * enough to support this source version and has no other elements\n+     * set.\n+     *\n+     * Source versions greater than or equal to {@link RELEASE_6}\n+     * have non-{@code null} results.\n+     * @since 18\n+     *\/\n+    public Runtime.Version runtimeVersion() {\n+        \/\/ The javax.lang.model API was added in JDK 6; for now,\n+        \/\/ limiting supported range to 6 and up.\n+        if (this.compareTo(RELEASE_6) >= 0) {\n+            return Runtime.Version.parse(Integer.toString(ordinal()));\n+        } else {\n+            return null;\n+        }\n+    }\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/SourceVersion.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7025809 8028543 6415644 8028544 8029942 8187951 8193291 8196551 8233096\n+ * @bug 7025809 8028543 6415644 8028544 8029942 8187951 8193291 8196551 8233096 8275308\n@@ -48,0 +48,2 @@\n+        testValueOfRV();\n+        testRuntimeVersion();\n@@ -150,0 +152,57 @@\n+\n+    \/**\n+     * Test that SourceVersion.valueOf() maps a Runtime.Version to a\n+     * SourceVersion properly. The SourceVersion result is only a\n+     * function of the feature() component of a Runtime.Version.\n+     *\/\n+    private static void testValueOfRV() {\n+        for (SourceVersion sv : SourceVersion.values()) {\n+            if (sv == RELEASE_0) {\n+                continue;\n+            } else {\n+                \/\/ Plain mapping; e.g. \"17\" -> RELEASE_17\n+                String featureBase = Integer.toString(sv.ordinal());\n+                checkValueOfResult(sv, featureBase);\n+\n+                \/\/ More populated runtime version, N.N\n+                checkValueOfResult(sv, featureBase + \".\" + featureBase);\n+            }\n+        }\n+\n+        \/\/ Out of range test\n+        try {\n+            int latestFeature = SourceVersion.latest().runtimeVersion().feature();\n+            SourceVersion.valueOf(Runtime.Version.parse(Integer.toString(latestFeature +1)));\n+            throw new RuntimeException(\"Should not reach\");\n+        } catch (IllegalArgumentException iae) {\n+            ; \/\/ Expected\n+        }\n+    }\n+\n+    private static void checkValueOfResult(SourceVersion expected, String versionString) {\n+        Runtime.Version rv = Runtime.Version.parse(versionString);\n+        SourceVersion  result = SourceVersion.valueOf(rv);\n+        if (result != expected) {\n+            throw new RuntimeException(\"Unexpected result \" + result +\n+                                       \" of mapping Runtime.Version \" + versionString +\n+                                       \" intead of \" + expected);\n+        }\n+    }\n+\n+    private static void testRuntimeVersion() {\n+        for (SourceVersion sv : SourceVersion.values()) {\n+            Runtime.Version result = sv.runtimeVersion();\n+            if (sv.compareTo(RELEASE_6) < 0) {\n+                if (result != null) {\n+                    throw new RuntimeException(\"Unexpected result non-null \" + result +\n+                                               \" as runtime version of  \" + sv);\n+                }\n+            } else {\n+                Runtime.Version expected = Runtime.Version.parse(Integer.toString(sv.ordinal()));\n+                if (!result.equals(expected)) {\n+                    throw new RuntimeException(\"Unexpected result \" + result +\n+                                               \" as runtime version of \" + sv);\n+                }\n+            }\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/TestSourceVersion.java","additions":61,"deletions":2,"binary":false,"changes":63,"status":"modified"}]}