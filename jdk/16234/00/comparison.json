{"files":[{"patch":"@@ -2329,1 +2329,0 @@\n-\/\/ Vector calling convention not yet implemented.\n@@ -2331,1 +2330,1 @@\n-  return false;\n+  return EnableVectorSupport && UseVectorStubs;\n@@ -2335,2 +2334,7 @@\n-  Unimplemented();\n-  return OptoRegPair(0, 0);\n+  assert(EnableVectorSupport && UseVectorStubs, \"sanity\");\n+  int lo = V0_num;\n+  int hi = V0_H_num;\n+  if (ideal_reg == Op_VecX || ideal_reg == Op_VecA) {\n+    hi = V0_K_num;\n+  }\n+  return OptoRegPair(hi, lo);\n@@ -16551,0 +16555,16 @@\n+\/\/ Call Runtime Instruction without safepoint and with vector arguments\n+instruct CallLeafDirectVector(method meth)\n+%{\n+  match(CallLeafVector);\n+\n+  effect(USE meth);\n+\n+  ins_cost(CALL_COST);\n+\n+  format %{ \"CALL, runtime leaf vector $meth\" %}\n+\n+  ins_encode(aarch64_enc_java_to_runtime(meth));\n+\n+  ins_pipe(pipe_class_call);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -130,0 +130,2 @@\n+  product(ccstr, UseSleefLib, \"libsleef.so.3\", EXPERIMENTAL,            \\\n+          \"Sleef library to use for the vector math operations\")        \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -894,1 +894,14 @@\n-  Unimplemented();\n+  \/\/ More than 8 argument inputs are not supported now.\n+  assert(total_args_passed <= Argument::n_float_register_parameters_c, \"unsupported\");\n+  assert(num_bits >= 64 && num_bits <= 2048 && is_power_of_2(num_bits), \"unsupported\");\n+\n+  static const FloatRegister VEC_ArgReg[Argument::n_float_register_parameters_c] = {\n+    v0, v1, v2, v3, v4, v5, v6, v7\n+  };\n+\n+  \/\/ On SVE, we use the same vector registers with 128-bit vector registers on NEON.\n+  int next_reg_val = num_bits == 64 ? 1 : 3;\n+  for (uint i = 0; i < total_args_passed; i++) {\n+    VMReg vmreg = VEC_ArgReg[i]->as_VMReg();\n+    regs[i].set_pair(vmreg->next(next_reg_val), vmreg);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -8491,0 +8492,70 @@\n+\n+#ifdef COMPILER2\n+    \/\/ Get sleef stub routine addresses\n+    char ebuf[1024];\n+    void* libsleef = os::dll_load(UseSleefLib, ebuf, sizeof ebuf);\n+    if (libsleef != nullptr) {\n+      \/\/ SLEEF method naming convention\n+      \/\/   All the methods are named as Sleef_<OP><T><N>_<U><suffix>\n+      \/\/   Where:\n+      \/\/     <OP>     is the operation name, e.g. sin\n+      \/\/     <T>      is optional to indicate float\/double\n+      \/\/              \"f\/d\" for vector float\/double operation\n+      \/\/     <N>      is the number of elements in the vector\n+      \/\/              \"2\/4\" for neon, and \"x\" for sve\n+      \/\/     <U>      is the precision level\n+      \/\/              \"u10\/u05\" represents 1.0\/0.5 ULP error bounds\n+      \/\/               We use \"u10\" for all operations by default\n+      \/\/               But for those functions do not have u10 support in SLEEF, we use \"u05\" instead\n+      \/\/     <suffix> indicates neon\/sve\n+      \/\/              \"sve\/advsimd\" for sve\/neon implementations\n+      \/\/     e.g. Sleef_sinfx_u10sve is the method for computing vector float sin using SVE instructions\n+      \/\/          Sleef_cosd2_u10advsimd is the method for computing 2 elements vector double cos using NEON instructions\n+      \/\/\n+      log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, JNI_LIB_PREFIX \"sleef\" JNI_LIB_SUFFIX, p2i(libsleef));\n+\n+      \/\/ Math vector stubs implemented with SVE for scalable vector size.\n+      if (UseSVE > 0) {\n+        for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n+          int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n+          \/\/ Skip \"tanh\", since there is performance regression\n+          if (vop == VectorSupport::VECTOR_OP_TANH) {\n+            continue;\n+          }\n+\n+          \/\/ SLEEF does not support u10 level of \"hypot\" yet.\n+          const char* ulf = (vop == VectorSupport::VECTOR_OP_HYPOT) ? \"u05\" : \"u10\";\n+\n+          snprintf(ebuf, sizeof(ebuf), \"Sleef_%sfx_%ssve\", VectorSupport::mathname[op], ulf);\n+          StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_SCALABLE][op] = (address)os::dll_lookup(libsleef, ebuf);\n+\n+          snprintf(ebuf, sizeof(ebuf), \"Sleef_%sdx_%ssve\", VectorSupport::mathname[op], ulf);\n+          StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_SCALABLE][op] = (address)os::dll_lookup(libsleef, ebuf);\n+        }\n+      }\n+\n+      \/\/ Math vector stubs implemented with NEON for 64\/128 bits vector size.\n+      for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n+        int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n+\n+        \/\/ SLEEF does not support u10 level of \"hypot\" yet.\n+        const char* ulf = (vop == VectorSupport::VECTOR_OP_HYPOT) ? \"u05\" : \"u10\";\n+\n+        snprintf(ebuf, sizeof(ebuf), \"Sleef_%sf4_%sadvsimd\", VectorSupport::mathname[op], ulf);\n+        StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_64][op] = (address)os::dll_lookup(libsleef, ebuf);\n+\n+        snprintf(ebuf, sizeof(ebuf), \"Sleef_%sf4_%sadvsimd\", VectorSupport::mathname[op], ulf);\n+        StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_128][op] = (address)os::dll_lookup(libsleef, ebuf);\n+\n+        snprintf(ebuf, sizeof(ebuf), \"Sleef_%sd2_%sadvsimd\", VectorSupport::mathname[op], ulf);\n+        StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_128][op] = (address)os::dll_lookup(libsleef, ebuf);\n+      }\n+    } else {\n+      if (FLAG_IS_DEFAULT(UseSleefLib)) {\n+        log_info(library)(\"Fail to load sleef library!\");\n+      } else {\n+        warning(\"Fail to load sleef library: %s. Please check the path\/name!\", UseSleefLib);\n+      }\n+    }\n+#endif \/\/ COMPILER2\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":71,"deletions":0,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -4220,2 +4220,2 @@\n-      for (int op = 0; op < VectorSupport::NUM_SVML_OP; op++) {\n-        int vop = VectorSupport::VECTOR_OP_SVML_START + op;\n+      for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n+        int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n@@ -4226,1 +4226,1 @@\n-        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf16_ha_z0\", VectorSupport::svmlname[op]);\n+        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf16_ha_z0\", VectorSupport::mathname[op]);\n@@ -4229,1 +4229,1 @@\n-        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s8_ha_z0\", VectorSupport::svmlname[op]);\n+        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s8_ha_z0\", VectorSupport::mathname[op]);\n@@ -4234,2 +4234,2 @@\n-    for (int op = 0; op < VectorSupport::NUM_SVML_OP; op++) {\n-      int vop = VectorSupport::VECTOR_OP_SVML_START + op;\n+    for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n+      int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n@@ -4239,1 +4239,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4242,1 +4242,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4245,1 +4245,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf8_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf8_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4248,1 +4248,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s1_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s1_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4251,1 +4251,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s2_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s2_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4254,1 +4254,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s4_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -758,1 +758,1 @@\n-      if(ideal_reg >= Op_VecS && ideal_reg <= Op_VecZ) {\n+      if(ideal_reg >= Op_VecA && ideal_reg <= Op_VecZ) {\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -366,1 +366,1 @@\n-  Node* gen_call_to_svml(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2);\n+  Node* gen_call_to_vector_math(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -540,1 +540,1 @@\n-    operation = gen_call_to_svml(opr->get_con(), elem_bt, num_elem, opd1, opd2);\n+    operation = gen_call_to_vector_math(opr->get_con(), elem_bt, num_elem, opd1, opd2);\n@@ -543,3 +543,3 @@\n-        tty->print_cr(\"  ** svml call failed for %s_%s_%d\",\n-                         (elem_bt == T_FLOAT)?\"float\":\"double\",\n-                         VectorSupport::svmlname[opr->get_con() - VectorSupport::VECTOR_OP_SVML_START],\n+        tty->print_cr(\"  ** Vector math call failed for %s_%s_%d\",\n+                         (elem_bt == T_FLOAT) ? \"float\" : \"double\",\n+                         VectorSupport::mathname[opr->get_con() - VectorSupport::VECTOR_OP_MATH_START],\n@@ -2159,1 +2159,1 @@\n-static address get_svml_address(int vop, int bits, BasicType bt, char* name_ptr, int name_len) {\n+static address get_vector_math_address(int vop, int bits, BasicType bt, char* name_ptr, int name_len) {\n@@ -2163,2 +2163,2 @@\n-  assert((vop >= VectorSupport::VECTOR_OP_SVML_START) && (vop <= VectorSupport::VECTOR_OP_SVML_END), \"unexpected\");\n-  int op = vop - VectorSupport::VECTOR_OP_SVML_START;\n+  assert((vop >= VectorSupport::VECTOR_OP_MATH_START) && (vop <= VectorSupport::VECTOR_OP_MATH_END), \"unexpected\");\n+  int op = vop - VectorSupport::VECTOR_OP_MATH_START;\n@@ -2172,1 +2172,1 @@\n-        snprintf(name_ptr, name_len, \"vector_%s_float%d\", VectorSupport::svmlname[op], bits);\n+        snprintf(name_ptr, name_len, \"vector_%s_float_%dbits\", VectorSupport::mathname[op], bits);\n@@ -2176,1 +2176,1 @@\n-        snprintf(name_ptr, name_len, \"vector_%s_double%d\", VectorSupport::svmlname[op], bits);\n+        snprintf(name_ptr, name_len, \"vector_%s_double_%dbits\", VectorSupport::mathname[op], bits);\n@@ -2187,0 +2187,10 @@\n+  if (addr == nullptr && Matcher::supports_scalable_vector()) {\n+    if (bt == T_FLOAT) {\n+      snprintf(name_ptr, name_len, \"vector_%s_float_%dbits\", VectorSupport::mathname[op], bits);\n+      addr = StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_SCALABLE][op];\n+    } else {\n+      assert(bt == T_DOUBLE, \"must be FP type only\");\n+      snprintf(name_ptr, name_len, \"vector_%s_double_%dbits\", VectorSupport::mathname[op], bits);\n+      addr = StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_SCALABLE][op];\n+    }\n+  }\n@@ -2190,1 +2200,1 @@\n-Node* LibraryCallKit::gen_call_to_svml(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2) {\n+Node* LibraryCallKit::gen_call_to_vector_math(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2) {\n@@ -2192,1 +2202,1 @@\n-  assert(vector_api_op_id >= VectorSupport::VECTOR_OP_SVML_START && vector_api_op_id <= VectorSupport::VECTOR_OP_SVML_END, \"need valid op id\");\n+  assert(vector_api_op_id >= VectorSupport::VECTOR_OP_MATH_START && vector_api_op_id <= VectorSupport::VECTOR_OP_MATH_END, \"need valid op id\");\n@@ -2198,2 +2208,2 @@\n-  \/\/ Get address for svml method.\n-  address addr = get_svml_address(vector_api_op_id, vt->length_in_bytes() * BitsPerByte, bt, name, 100);\n+  \/\/ Get address for vector math method.\n+  address addr = get_vector_math_address(vector_api_op_id, vt->length_in_bytes() * BitsPerByte, bt, name, 100);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":23,"deletions":13,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-const char* VectorSupport::svmlname[VectorSupport::NUM_SVML_OP] = {\n+const char* VectorSupport::mathname[VectorSupport::NUM_VECTOR_OP_MATH] = {\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,3 +124,3 @@\n-    VECTOR_OP_SVML_START = VECTOR_OP_TAN,\n-    VECTOR_OP_SVML_END   = VECTOR_OP_HYPOT,\n-    NUM_SVML_OP = VECTOR_OP_SVML_END - VECTOR_OP_SVML_START + 1\n+    VECTOR_OP_MATH_START = VECTOR_OP_TAN,\n+    VECTOR_OP_MATH_END   = VECTOR_OP_HYPOT,\n+    NUM_VECTOR_OP_MATH   = VECTOR_OP_MATH_END - VECTOR_OP_MATH_START + 1\n@@ -134,1 +134,2 @@\n-    NUM_VEC_SIZES = 4\n+    VEC_SIZE_SCALABLE = 4,\n+    NUM_VEC_SIZES = 5\n@@ -142,1 +143,1 @@\n-  static const char* svmlname[VectorSupport::NUM_SVML_OP];\n+  static const char* mathname[VectorSupport::NUM_VECTOR_OP_MATH];\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -176,2 +176,2 @@\n-address StubRoutines::_vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP] = {{nullptr}, {nullptr}};\n-address StubRoutines::_vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP] = {{nullptr}, {nullptr}};\n+address StubRoutines::_vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH] = {{nullptr}, {nullptr}};\n+address StubRoutines::_vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH] = {{nullptr}, {nullptr}};\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -269,2 +269,2 @@\n-  static address _vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP];\n-  static address _vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP];\n+  static address _vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n+  static address _vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}