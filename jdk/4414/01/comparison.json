{"files":[{"patch":"@@ -46,3 +46,0 @@\n-#ifdef _WINDOWS\n-#define JFR_FILENAME_EXAMPLE \"C:\\\\Users\\\\user\\\\My Recording.jfr\"\n-#endif\n@@ -50,7 +47,9 @@\n-#ifdef __APPLE__\n-#define JFR_FILENAME_EXAMPLE  \"\/Users\/user\/My Recording.jfr\"\n-#endif\n-\n-#ifndef JFR_FILENAME_EXAMPLE\n-#define JFR_FILENAME_EXAMPLE \"\/home\/user\/My Recording.jfr\"\n-#endif\n+bool register_jfr_dcmds() {\n+  uint32_t full_export = DCmd_Source_Internal | DCmd_Source_AttachAPI | DCmd_Source_MBean;\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrCheckFlightRecordingDCmd>(full_export, true, false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrDumpFlightRecordingDCmd>(full_export, true, false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrStartFlightRecordingDCmd>(full_export, true, false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrStopFlightRecordingDCmd>(full_export, true, false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrConfigureFlightRecorderDCmd>(full_export, true, false));\n+  return true;\n+}\n@@ -119,11 +118,0 @@\n-static bool is_recorder_instance_created(outputStream* output) {\n-  if (!JfrRecorder::is_created()) {\n-    if (output != NULL) {\n-      output->print_cr(\"No available recordings.\\n\");\n-      output->print_cr(\"Use JFR.start to start a recording.\\n\");\n-    }\n-    return false;\n-  }\n-  return true;\n-}\n-\n@@ -189,0 +177,1 @@\n+  ResourceMark rm(THREAD);\n@@ -228,34 +217,4 @@\n-JfrDumpFlightRecordingDCmd::JfrDumpFlightRecordingDCmd(outputStream* output,\n-                                                       bool heap) : DCmdWithParser(output, heap),\n-  _name(\"name\", \"Recording name, e.g. \\\\\\\"My Recording\\\\\\\"\", \"STRING\", false, NULL),\n-  _filename(\"filename\", \"Copy recording data to file, e.g. \\\\\\\"\" JFR_FILENAME_EXAMPLE \"\\\\\\\"\", \"STRING\", false),\n-  _maxage(\"maxage\", \"Maximum duration to dump, in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or 0 for no limit\", \"NANOTIME\", false, \"0\"),\n-  _maxsize(\"maxsize\", \"Maximum amount of bytes to dump, in (M)B or (G)B, e.g. 500M, or 0 for no limit\", \"MEMORY SIZE\", false, \"0\"),\n-  _begin(\"begin\", \"Point in time to dump data from, e.g. 09:00, 21:35:00, 2018-06-03T18:12:56.827Z, 2018-06-03T20:13:46.832, -10m, -3h, or -1d\", \"STRING\", false),\n-  _end(\"end\", \"Point in time to dump data to, e.g. 09:00, 21:35:00, 2018-06-03T18:12:56.827Z, 2018-06-03T20:13:46.832, -10m, -3h, or -1d\", \"STRING\", false),\n-  _path_to_gc_roots(\"path-to-gc-roots\", \"Collect path to GC roots\", \"BOOLEAN\", false, \"false\") {\n-  _dcmdparser.add_dcmd_option(&_name);\n-  _dcmdparser.add_dcmd_option(&_filename);\n-  _dcmdparser.add_dcmd_option(&_maxage);\n-  _dcmdparser.add_dcmd_option(&_maxsize);\n-  _dcmdparser.add_dcmd_option(&_begin);\n-  _dcmdparser.add_dcmd_option(&_end);\n-  _dcmdparser.add_dcmd_option(&_path_to_gc_roots);\n-};\n-\n-int JfrDumpFlightRecordingDCmd::num_arguments() {\n-  ResourceMark rm;\n-  JfrDumpFlightRecordingDCmd* dcmd = new JfrDumpFlightRecordingDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  }\n-  return 0;\n-}\n-\n-void JfrDumpFlightRecordingDCmd::execute(DCmdSource source, TRAPS) {\n-  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n-\n-  if (invalid_state(output(), THREAD) || !is_recorder_instance_created(output())) {\n-    return;\n-  }\n+void JfrDCmd::invoke(JfrJavaArguments& method, TRAPS) const {\n+  JavaValue constructor_result(T_OBJECT);\n+  JfrJavaArguments constructor_args(&constructor_result);\n+  constructor_args.set_klass(javaClass(), CHECK);\n@@ -267,3 +226,0 @@\n-  JavaValue result(T_OBJECT);\n-  JfrJavaArguments constructor_args(&result);\n-  constructor_args.set_klass(\"jdk\/jfr\/internal\/dcmd\/DCmdDump\", CHECK);\n@@ -271,0 +227,1 @@\n+\n@@ -274,53 +231,2 @@\n-  jstring name = NULL;\n-  if (_name.is_set() && _name.value()  != NULL) {\n-    name = JfrJavaSupport::new_string(_name.value(), CHECK);\n-  }\n-\n-  jstring filepath = NULL;\n-  if (_filename.is_set() && _filename.value() != NULL) {\n-    filepath = JfrJavaSupport::new_string(_filename.value(), CHECK);\n-  }\n-\n-  jobject maxage = NULL;\n-  if (_maxage.is_set()) {\n-    maxage = JfrJavaSupport::new_java_lang_Long(_maxage.value()._nanotime, CHECK);\n-  }\n-\n-  jobject maxsize = NULL;\n-  if (_maxsize.is_set()) {\n-    maxsize = JfrJavaSupport::new_java_lang_Long(_maxsize.value()._size, CHECK);\n-  }\n-\n-  jstring begin = NULL;\n-  if (_begin.is_set() && _begin.value() != NULL) {\n-    begin = JfrJavaSupport::new_string(_begin.value(), CHECK);\n-  }\n-\n-  jstring end = NULL;\n-  if (_end.is_set() && _end.value() != NULL) {\n-    end = JfrJavaSupport::new_string(_end.value(), CHECK);\n-  }\n-\n-  jobject path_to_gc_roots = NULL;\n-  if (_path_to_gc_roots.is_set()) {\n-    path_to_gc_roots = JfrJavaSupport::new_java_lang_Boolean(_path_to_gc_roots.value(), CHECK);\n-  }\n-\n-  static const char klass[] = \"jdk\/jfr\/internal\/dcmd\/DCmdDump\";\n-  static const char method[] = \"execute\";\n-  static const char signature[] = \"(Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/Long;Ljava\/lang\/Long;Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/Boolean;)[Ljava\/lang\/String;\";\n-\n-  JfrJavaArguments execute_args(&result, klass, method, signature, CHECK);\n-  execute_args.set_receiver(h_dcmd_instance);\n-\n-  \/\/ arguments\n-  execute_args.push_jobject(name);\n-  execute_args.push_jobject(filepath);\n-  execute_args.push_jobject(maxage);\n-  execute_args.push_jobject(maxsize);\n-  execute_args.push_jobject(begin);\n-  execute_args.push_jobject(end);\n-  execute_args.push_jobject(path_to_gc_roots);\n-\n-  JfrJavaSupport::call_virtual(&execute_args, THREAD);\n-  handle_dcmd_result(output(), result.get_oop(), source, THREAD);\n+  method.set_receiver(h_dcmd_instance);\n+  JfrJavaSupport::call_virtual(&method, THREAD);\n@@ -329,16 +235,6 @@\n-JfrCheckFlightRecordingDCmd::JfrCheckFlightRecordingDCmd(outputStream* output, bool heap) : DCmdWithParser(output, heap),\n-  _name(\"name\",\"Recording name, e.g. \\\\\\\"My Recording\\\\\\\" or omit to see all recordings\",\"STRING\",false, NULL),\n-  _verbose(\"verbose\",\"Print event settings for the recording(s)\",\"BOOLEAN\",\n-           false, \"false\") {\n-  _dcmdparser.add_dcmd_option(&_name);\n-  _dcmdparser.add_dcmd_option(&_verbose);\n-};\n-\n-int JfrCheckFlightRecordingDCmd::num_arguments() {\n-  ResourceMark rm;\n-  JfrCheckFlightRecordingDCmd* dcmd = new JfrCheckFlightRecordingDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  }\n-  return 0;\n+void JfrDCmd::parse(CmdLine* line, char delim, TRAPS) {\n+    _args = line->args_addr();\n+    _delimiter = delim;\n+     \/\/ Error checking done in execute.\n+     \/\/ Will not matter from DCmdFactory perspective\n+     \/\/ where parse and execute are called consecutively.\n@@ -347,2 +243,2 @@\n-void JfrCheckFlightRecordingDCmd::execute(DCmdSource source, TRAPS) {\n-  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n+void JfrDCmd::execute(DCmdSource source, TRAPS) {\n+  static const char signature[] = \"(Ljava\/lang\/String;Ljava\/lang\/String;C)[Ljava\/lang\/String;\";\n@@ -350,1 +246,1 @@\n-  if (invalid_state(output(), THREAD) || !is_recorder_instance_created(output())) {\n+  if (invalid_state(output(), THREAD)) {\n@@ -354,4 +250,0 @@\n-  ResourceMark rm(THREAD);\n-  HandleMark hm(THREAD);\n-  JNIHandleBlockManager jni_handle_management(THREAD);\n-\n@@ -359,28 +251,16 @@\n-  JfrJavaArguments constructor_args(&result);\n-  constructor_args.set_klass(\"jdk\/jfr\/internal\/dcmd\/DCmdCheck\", CHECK);\n-  const oop dcmd = construct_dcmd_instance(&constructor_args, CHECK);\n-  Handle h_dcmd_instance(THREAD, dcmd);\n-  assert(h_dcmd_instance.not_null(), \"invariant\");\n-\n-  jstring name = NULL;\n-  if (_name.is_set() && _name.value() != NULL) {\n-    name = JfrJavaSupport::new_string(_name.value(), CHECK);\n-  }\n-\n-  jobject verbose = NULL;\n-  if (_verbose.is_set()) {\n-    verbose = JfrJavaSupport::new_java_lang_Boolean(_verbose.value(), CHECK);\n-  }\n-\n-  static const char klass[] = \"jdk\/jfr\/internal\/dcmd\/DCmdCheck\";\n-  static const char method[] = \"execute\";\n-  static const char signature[] = \"(Ljava\/lang\/String;Ljava\/lang\/Boolean;)[Ljava\/lang\/String;\";\n-\n-  JfrJavaArguments execute_args(&result, klass, method, signature, CHECK);\n-  execute_args.set_receiver(h_dcmd_instance);\n-\n-  \/\/ arguments\n-  execute_args.push_jobject(name);\n-  execute_args.push_jobject(verbose);\n-\n-  JfrJavaSupport::call_virtual(&execute_args, THREAD);\n+  JfrJavaArguments execute(&result, javaClass(), \"execute\", signature, CHECK);\n+  jstring argument = JfrJavaSupport::new_string(_args, CHECK);\n+  jstring s = NULL;\n+  if (source == DCmd_Source_Internal) {\n+    s = JfrJavaSupport::new_string(\"internal\", CHECK);\n+  }\n+  if (source == DCmd_Source_MBean) {\n+    s = JfrJavaSupport::new_string(\"mbean\", CHECK);\n+  }\n+  if (source == DCmd_Source_AttachAPI) {\n+    s = JfrJavaSupport::new_string(\"attach\", CHECK);\n+  }\n+  execute.push_jobject(s);\n+  execute.push_jobject(argument);\n+  execute.push_int(_delimiter);\n+  invoke(execute, THREAD);\n@@ -390,34 +270,7 @@\n-JfrStartFlightRecordingDCmd::JfrStartFlightRecordingDCmd(outputStream* output,\n-                                                         bool heap) : DCmdWithParser(output, heap),\n-  _name(\"name\", \"Name that can be used to identify recording, e.g. \\\\\\\"My Recording\\\\\\\"\", \"STRING\", false, NULL),\n-  _settings(\"settings\", \"Settings file(s), e.g. profile or default. See JAVA_HOME\/lib\/jfr\", \"STRING SET\", false),\n-  _delay(\"delay\", \"Delay recording start with (s)econds, (m)inutes), (h)ours), or (d)ays, e.g. 5h.\", \"NANOTIME\", false, \"0\"),\n-  _duration(\"duration\", \"Duration of recording in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 300s.\", \"NANOTIME\", false, \"0\"),\n-  _disk(\"disk\", \"Recording should be persisted to disk\", \"BOOLEAN\", false),\n-  _filename(\"filename\", \"Resulting recording filename, e.g. \\\\\\\"\" JFR_FILENAME_EXAMPLE \"\\\\\\\"\", \"STRING\", false),\n-  _maxage(\"maxage\", \"Maximum time to keep recorded data (on disk) in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or 0 for no limit\", \"NANOTIME\", false, \"0\"),\n-  _maxsize(\"maxsize\", \"Maximum amount of bytes to keep (on disk) in (k)B, (M)B or (G)B, e.g. 500M, or 0 for no limit\", \"MEMORY SIZE\", false, \"0\"),\n-  _flush_interval(\"flush-interval\", \"Minimum time before flushing buffers, measured in (s)econds, e.g. 4 s, or 0 for flushing when a recording ends\", \"NANOTIME\", false, \"1s\"),\n-  _dump_on_exit(\"dumponexit\", \"Dump running recording when JVM shuts down\", \"BOOLEAN\", false),\n-  _path_to_gc_roots(\"path-to-gc-roots\", \"Collect path to GC roots\", \"BOOLEAN\", false, \"false\") {\n-  _dcmdparser.add_dcmd_option(&_name);\n-  _dcmdparser.add_dcmd_option(&_settings);\n-  _dcmdparser.add_dcmd_option(&_delay);\n-  _dcmdparser.add_dcmd_option(&_duration);\n-  _dcmdparser.add_dcmd_option(&_disk);\n-  _dcmdparser.add_dcmd_option(&_filename);\n-  _dcmdparser.add_dcmd_option(&_maxage);\n-  _dcmdparser.add_dcmd_option(&_maxsize);\n-  _dcmdparser.add_dcmd_option(&_flush_interval);\n-  _dcmdparser.add_dcmd_option(&_dump_on_exit);\n-  _dcmdparser.add_dcmd_option(&_path_to_gc_roots);\n-};\n-\n-int JfrStartFlightRecordingDCmd::num_arguments() {\n-  ResourceMark rm;\n-  JfrStartFlightRecordingDCmd* dcmd = new JfrStartFlightRecordingDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  }\n-  return 0;\n+void JfrDCmd::print_help(const char* name) const {\n+  static const char signature[] = \"()[Ljava\/lang\/String;\";\n+  JavaThread* thread = JavaThread::current();\n+  JavaValue result(T_OBJECT);\n+  JfrJavaArguments print_help(&result, javaClass(), \"printHelp\", signature, thread);\n+  invoke(print_help, thread);\n+  handle_dcmd_result(output(), result.get_oop(), DCmd_Source_MBean, thread);\n@@ -426,11 +279,1 @@\n-void JfrStartFlightRecordingDCmd::execute(DCmdSource source, TRAPS) {\n-  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n-\n-  if (invalid_state(output(), THREAD)) {\n-    return;\n-  }\n-\n-  ResourceMark rm(THREAD);\n-  HandleMark hm(THREAD);\n-  JNIHandleBlockManager jni_handle_management(THREAD);\n-\n+static const char* read_string_field(oop argument, const char* field_name, TRAPS) {\n@@ -438,103 +281,8 @@\n-  JfrJavaArguments constructor_args(&result);\n-  constructor_args.set_klass(\"jdk\/jfr\/internal\/dcmd\/DCmdStart\", THREAD);\n-  const oop dcmd = construct_dcmd_instance(&constructor_args, CHECK);\n-  Handle h_dcmd_instance(THREAD, dcmd);\n-  assert(h_dcmd_instance.not_null(), \"invariant\");\n-\n-  jstring name = NULL;\n-  if (_name.is_set() && _name.value() != NULL) {\n-    name = JfrJavaSupport::new_string(_name.value(), CHECK);\n-  }\n-\n-  jstring filename = NULL;\n-  if (_filename.is_set() && _filename.value() != NULL) {\n-    filename = JfrJavaSupport::new_string(_filename.value(), CHECK);\n-  }\n-\n-  jobject maxage = NULL;\n-  if (_maxage.is_set()) {\n-    maxage = JfrJavaSupport::new_java_lang_Long(_maxage.value()._nanotime, CHECK);\n-  }\n-\n-  jobject maxsize = NULL;\n-  if (_maxsize.is_set()) {\n-    maxsize = JfrJavaSupport::new_java_lang_Long(_maxsize.value()._size, CHECK);\n-  }\n-\n-  jobject flush_interval = NULL;\n-  if (_flush_interval.is_set()) {\n-    flush_interval = JfrJavaSupport::new_java_lang_Long(_flush_interval.value()._nanotime, CHECK);\n-  }\n-  jobject duration = NULL;\n-  if (_duration.is_set()) {\n-    duration = JfrJavaSupport::new_java_lang_Long(_duration.value()._nanotime, CHECK);\n-  }\n-\n-  jobject delay = NULL;\n-  if (_delay.is_set()) {\n-    delay = JfrJavaSupport::new_java_lang_Long(_delay.value()._nanotime, CHECK);\n-  }\n-\n-  jobject disk = NULL;\n-  if (_disk.is_set()) {\n-    disk = JfrJavaSupport::new_java_lang_Boolean(_disk.value(), CHECK);\n-  }\n-\n-  jobject dump_on_exit = NULL;\n-  if (_dump_on_exit.is_set()) {\n-    dump_on_exit = JfrJavaSupport::new_java_lang_Boolean(_dump_on_exit.value(), CHECK);\n-  }\n-\n-  jobject path_to_gc_roots = NULL;\n-  if (_path_to_gc_roots.is_set()) {\n-    path_to_gc_roots = JfrJavaSupport::new_java_lang_Boolean(_path_to_gc_roots.value(), CHECK);\n-  }\n-\n-  jobjectArray settings = NULL;\n-  if (_settings.is_set()) {\n-    int length = _settings.value()->array()->length();\n-    if (length == 1) {\n-      const char* c_str = _settings.value()->array()->at(0);\n-      if (strcmp(c_str, \"none\") == 0) {\n-        length = 0;\n-      }\n-    }\n-    settings = JfrJavaSupport::new_string_array(length, CHECK);\n-    assert(settings != NULL, \"invariant\");\n-    for (int i = 0; i < length; ++i) {\n-      jobject element = JfrJavaSupport::new_string(_settings.value()->array()->at(i), CHECK);\n-      assert(element != NULL, \"invariant\");\n-      JfrJavaSupport::set_array_element(settings, element, i, CHECK);\n-    }\n-  } else {\n-    settings = JfrJavaSupport::new_string_array(1, CHECK);\n-    assert(settings != NULL, \"invariant\");\n-    jobject element = JfrJavaSupport::new_string(\"default\", CHECK);\n-    assert(element != NULL, \"invariant\");\n-    JfrJavaSupport::set_array_element(settings, element, 0, CHECK);\n-  }\n-\n-  static const char klass[] = \"jdk\/jfr\/internal\/dcmd\/DCmdStart\";\n-  static const char method[] = \"execute\";\n-  static const char signature[] = \"(Ljava\/lang\/String;[Ljava\/lang\/String;Ljava\/lang\/Long;\"\n-    \"Ljava\/lang\/Long;Ljava\/lang\/Boolean;Ljava\/lang\/String;\"\n-    \"Ljava\/lang\/Long;Ljava\/lang\/Long;Ljava\/lang\/Long;Ljava\/lang\/Boolean;Ljava\/lang\/Boolean;)[Ljava\/lang\/String;\";\n-\n-  JfrJavaArguments execute_args(&result, klass, method, signature, CHECK);\n-  execute_args.set_receiver(h_dcmd_instance);\n-\n-  \/\/ arguments\n-  execute_args.push_jobject(name);\n-  execute_args.push_jobject(settings);\n-  execute_args.push_jobject(delay);\n-  execute_args.push_jobject(duration);\n-  execute_args.push_jobject(disk);\n-  execute_args.push_jobject(filename);\n-  execute_args.push_jobject(maxage);\n-  execute_args.push_jobject(maxsize);\n-  execute_args.push_jobject(flush_interval);\n-  execute_args.push_jobject(dump_on_exit);\n-  execute_args.push_jobject(path_to_gc_roots);\n-\n-  JfrJavaSupport::call_virtual(&execute_args, THREAD);\n-  handle_dcmd_result(output(), result.get_oop(), source, THREAD);\n+  JfrJavaArguments args(&result);\n+  args.set_klass(argument->klass());\n+  args.set_name(field_name);\n+  args.set_signature(\"Ljava\/lang\/String;\");\n+  args.set_receiver(argument);\n+  JfrJavaSupport::get_field(&args, THREAD);\n+  const oop string_oop = result.get_oop();\n+  return string_oop != NULL ? JfrJavaSupport::c_str(string_oop, (JavaThread*)THREAD, true) : NULL;\n@@ -543,16 +291,9 @@\n-JfrStopFlightRecordingDCmd::JfrStopFlightRecordingDCmd(outputStream* output,\n-                                                       bool heap) : DCmdWithParser(output, heap),\n-  _name(\"name\", \"Recording text,.e.g \\\\\\\"My Recording\\\\\\\"\", \"STRING\", true, NULL),\n-  _filename(\"filename\", \"Copy recording data to file, e.g. \\\\\\\"\" JFR_FILENAME_EXAMPLE \"\\\\\\\"\", \"STRING\", false, NULL) {\n-  _dcmdparser.add_dcmd_option(&_name);\n-  _dcmdparser.add_dcmd_option(&_filename);\n-};\n-\n-int JfrStopFlightRecordingDCmd::num_arguments() {\n-  ResourceMark rm;\n-  JfrStopFlightRecordingDCmd* dcmd = new JfrStopFlightRecordingDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  }\n-  return 0;\n+static bool read_boolean_field(oop argument, const char* field_name, TRAPS) {\n+  JavaValue result(T_BOOLEAN);\n+  JfrJavaArguments args(&result);\n+  args.set_klass(argument->klass());\n+  args.set_name(field_name);\n+  args.set_signature(\"Z\");\n+  args.set_receiver(argument);\n+  JfrJavaSupport::get_field(&args, THREAD);\n+  return (result.get_jint() & 1) == 1;\n@@ -561,17 +302,10 @@\n-void JfrStopFlightRecordingDCmd::execute(DCmdSource source, TRAPS) {\n-  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n-\n-  if (invalid_state(output(), THREAD) || !is_recorder_instance_created(output())) {\n-    return;\n-  }\n-\n-  ResourceMark rm(THREAD);\n-  HandleMark hm(THREAD);\n-  JNIHandleBlockManager jni_handle_management(THREAD);\n-\n-  JavaValue result(T_OBJECT);\n-  JfrJavaArguments constructor_args(&result);\n-  constructor_args.set_klass(\"jdk\/jfr\/internal\/dcmd\/DCmdStop\", CHECK);\n-  const oop dcmd = construct_dcmd_instance(&constructor_args, CHECK);\n-  Handle h_dcmd_instance(THREAD, dcmd);\n-  assert(h_dcmd_instance.not_null(), \"invariant\");\n+static DCmdArgumentInfo* create_info(oop argument, TRAPS) {\n+  return new DCmdArgumentInfo(\n+    read_string_field(argument, \"name\", THREAD),\n+    read_string_field(argument, \"description\", THREAD),\n+    read_string_field(argument, \"type\", THREAD),\n+    read_string_field(argument, \"defaultValue\", THREAD),\n+    read_boolean_field(argument, \"mandatory\", THREAD),\n+    true, \/\/ a DcmdFramework \"option\"\n+    read_boolean_field(argument, \"allowMultiple\", THREAD));\n+}\n@@ -579,4 +313,3 @@\n-  jstring name = NULL;\n-  if (_name.is_set() && _name.value()  != NULL) {\n-    name = JfrJavaSupport::new_string(_name.value(), CHECK);\n-  }\n+GrowableArray<DCmdArgumentInfo*>* JfrDCmd::argument_info_array() const {\n+  return new GrowableArray<DCmdArgumentInfo*>();\n+}\n@@ -584,3 +317,5 @@\n-  jstring filepath = NULL;\n-  if (_filename.is_set() && _filename.value() != NULL) {\n-    filepath = JfrJavaSupport::new_string(_filename.value(), CHECK);\n+GrowableArray<const char*>* JfrDCmd::argument_name_array() const {\n+  GrowableArray<DCmdArgumentInfo*>* argument_infos = argument_info_array();\n+  GrowableArray<const char*>* array = new GrowableArray<const char*>(argument_infos->length());\n+  for (int i = 0; i < argument_infos->length(); i++) {\n+    array->append(argument_infos->at(i)->name());\n@@ -588,14 +323,1 @@\n-\n-  static const char klass[] = \"jdk\/jfr\/internal\/dcmd\/DCmdStop\";\n-  static const char method[] = \"execute\";\n-  static const char signature[] = \"(Ljava\/lang\/String;Ljava\/lang\/String;)[Ljava\/lang\/String;\";\n-\n-  JfrJavaArguments execute_args(&result, klass, method, signature, CHECK);\n-  execute_args.set_receiver(h_dcmd_instance);\n-\n-  \/\/ arguments\n-  execute_args.push_jobject(name);\n-  execute_args.push_jobject(filepath);\n-\n-  JfrJavaSupport::call_virtual(&execute_args, THREAD);\n-  handle_dcmd_result(output(), result.get_oop(), source, THREAD);\n+  return array;\n@@ -627,0 +349,58 @@\n+void JfrConfigureFlightRecorderDCmd::print_help(const char* name) const {\n+  outputStream* out = output();\n+              \/\/ 0123456789001234567890012345678900123456789001234567890012345678900123456789001234567890\n+  out->print_cr(\"Options:\");\n+  out->print_cr(\"\");\n+  out->print_cr(\"  globalbuffercount  (Optional) Number of global buffers. This option is a legacy\");\n+  out->print_cr(\"                     option: change the memorysize parameter to alter the number of\");\n+  out->print_cr(\"                     global buffers. This value cannot be changed once JFR has been\");\n+  out->print_cr(\"                     initalized. (STRING, default determined by the value for\");\n+  out->print_cr(\"                     memorysize)\");\n+  out->print_cr(\"\");\n+  out->print_cr(\"  globalbuffersize   (Optional) Size of the global buffers, in bytes. This option is a\");\n+  out->print_cr(\"                     legacy option: change the memorysize parameter to alter the size\");\n+  out->print_cr(\"                     of the global buffers. This value cannot be changed once JFR has\");\n+  out->print_cr(\"                     been initalized. (STRING, default determined by the value for\");\n+  out->print_cr(\"                     memorysize)\");\n+  out->print_cr(\"\");\n+  out->print_cr(\"   maxchunksize      (Optional) Maximum size of an individual data chunk in bytes if\");\n+  out->print_cr(\"                     one of the following suffixes is not used: 'm' or 'M' for\");\n+  out->print_cr(\"                     megabytes OR 'g' or 'G' for gigabytes. This value cannot be\");\n+  out->print_cr(\"                     changed once JFR has been initialized. (STRING, 12M)\");\n+  out->print_cr(\"\");\n+  out->print_cr(\"   memorysize        (Optional) Overall memory size, in bytes if one of the following\");\n+  out->print_cr(\"                     suffixes is not used: 'm' or 'M' for megabytes OR 'g' or 'G' for\");\n+  out->print_cr(\"                     gigabytes. This value cannot be changed once JFR has been\");\n+  out->print_cr(\"                     initialized. (STRING, 10M)\");\n+  out->print_cr(\"\");\n+  out->print_cr(\"  repositorypath     (Optional) Path to the location where recordings are stored until\");\n+  out->print_cr(\"                     they are written to a permanent file. (STRING, The default\");\n+  out->print_cr(\"                     location is the temporary directory for the operating system. On\");\n+  out->print_cr(\"                     Linux operating systems, the temporary directory is \/tmp. On\");\n+  out->print_cr(\"                     Windows, the temporary directory is specified by the TMP\");\n+  out->print_cr(\"                     environment variable.)\");\n+  out->print_cr(\"\");\n+  out->print_cr(\"  stackdepth         (Optional) Stack depth for stack traces. Setting this value\");\n+  out->print_cr(\"                     greater than the default of 64 may cause a performance\");\n+  out->print_cr(\"                     degradation. This value cannot be changed once JFR has been\");\n+  out->print_cr(\"                     initialized. (LONG, 64)\");\n+  out->print_cr(\"\");\n+  out->print_cr(\"  thread_buffer_size (Optional) Local buffer size for each thread in bytes if one of\");\n+  out->print_cr(\"                     the following suffixes is not used: 'k' or 'K' for kilobytes or\");\n+  out->print_cr(\"                     'm' or 'M' for megabytes. Overriding this parameter could reduce\");\n+  out->print_cr(\"                     performance and is not recommended. This value cannot be changed\");\n+  out->print_cr(\"                     once JFR has been initialized. (STRING, 8k)\");\n+  out->print_cr(\"\");\n+  out->print_cr(\"  samplethreads      (Optional) Flag for activating thread sampling. (BOOLEAN, true)\");\n+  out->print_cr(\"\");\n+  out->print_cr(\"Options must be specified using the <key> or <key>=<value> syntax.\");\n+  out->print_cr(\"\");\n+  out->print_cr(\"Example usage:\");\n+  out->print_cr(\"\");\n+  out->print_cr(\" $ jcmd <pid> JFR.configure\");\n+  out->print_cr(\" $ jcmd <pid> JFR.configure repositorypath=\/temporary\");\n+  out->print_cr(\" $ jcmd <pid> JFR.configure stackdepth=256\");\n+  out->print_cr(\" $ jcmd <pid> JFR.configure memorysize=100M\");\n+  out->print_cr(\"\");\n+}\n+\n@@ -724,10 +504,0 @@\n-\n-bool register_jfr_dcmds() {\n-  uint32_t full_export = DCmd_Source_Internal | DCmd_Source_AttachAPI | DCmd_Source_MBean;\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrCheckFlightRecordingDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrDumpFlightRecordingDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrStartFlightRecordingDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrStopFlightRecordingDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrConfigureFlightRecorderDCmd>(full_export, true, false));\n-  return true;\n-}\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.cpp","additions":144,"deletions":374,"binary":false,"changes":518,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+class JfrJavaArguments;\n@@ -30,1 +31,12 @@\n-class JfrDumpFlightRecordingDCmd : public DCmdWithParser {\n+class JfrDCmd : public DCmd {\n+ private:\n+  const char* _args;\n+  char _delimiter;\n+ public:\n+  JfrDCmd(outputStream* output, bool heap) : DCmd(output,heap), _args(NULL), _delimiter('\\0')  {}\n+\n+  virtual void execute(DCmdSource source, TRAPS);\n+  virtual void print_help(const char* name) const;\n+  virtual GrowableArray<const char*>* argument_name_array() const;\n+  virtual GrowableArray<DCmdArgumentInfo*>* argument_info_array() const;\n+  virtual void parse(CmdLine* line, char delim, TRAPS);\n@@ -32,7 +44,3 @@\n-  DCmdArgument<char*> _name;\n-  DCmdArgument<char*> _filename;\n-  DCmdArgument<NanoTimeArgument> _maxage;\n-  DCmdArgument<MemorySizeArgument> _maxsize;\n-  DCmdArgument<char*> _begin;\n-  DCmdArgument<char*> _end;\n-  DCmdArgument<bool>  _path_to_gc_roots;\n+  virtual const char* javaClass() const = 0;\n+  void invoke(JfrJavaArguments& method, TRAPS) const;\n+};\n@@ -40,0 +48,1 @@\n+class JfrStartFlightRecordingDCmd : public JfrDCmd {\n@@ -41,1 +50,2 @@\n-  JfrDumpFlightRecordingDCmd(outputStream* output, bool heap);\n+  JfrStartFlightRecordingDCmd(outputStream* output, bool heap) : JfrDCmd(output, heap) {}\n+\n@@ -43,1 +53,1 @@\n-    return \"JFR.dump\";\n+    return \"JFR.start\";\n@@ -46,1 +56,1 @@\n-    return \"Copies contents of a JFR recording to file. Either the name or the recording id must be specified.\";\n+    return \"Starts a new JFR recording\";\n@@ -49,1 +59,1 @@\n-    return \"Low\";\n+    return \"Medium: Depending on the settings for a recording, the impact can range from low to high.\";\n@@ -55,2 +65,3 @@\n-  static int num_arguments();\n-  virtual void execute(DCmdSource source, TRAPS);\n+  virtual const char* javaClass() const {\n+    return \"jdk\/jfr\/internal\/dcmd\/DCmdStart\";\n+  }\n@@ -59,5 +70,1 @@\n-class JfrCheckFlightRecordingDCmd : public DCmdWithParser {\n- protected:\n-  DCmdArgument<char*> _name;\n-  DCmdArgument<bool>  _verbose;\n-\n+class JfrDumpFlightRecordingDCmd : public JfrDCmd {\n@@ -65,1 +72,2 @@\n-  JfrCheckFlightRecordingDCmd(outputStream* output, bool heap);\n+  JfrDumpFlightRecordingDCmd(outputStream* output, bool heap) : JfrDCmd(output, heap) {}\n+\n@@ -67,1 +75,1 @@\n-    return \"JFR.check\";\n+    return \"JFR.dump\";\n@@ -70,1 +78,1 @@\n-    return \"Checks running JFR recording(s)\";\n+    return \"Copies contents of a JFR recording to file. Either the name or the recording id must be specified.\";\n@@ -79,2 +87,3 @@\n-  static int num_arguments();\n-  virtual void execute(DCmdSource source, TRAPS);\n+  virtual const char* javaClass() const {\n+    return \"jdk\/jfr\/internal\/dcmd\/DCmdDump\";\n+  }\n@@ -83,14 +92,1 @@\n-class JfrStartFlightRecordingDCmd : public DCmdWithParser {\n- protected:\n-  DCmdArgument<char*> _name;\n-  DCmdArgument<StringArrayArgument*> _settings;\n-  DCmdArgument<NanoTimeArgument> _delay;\n-  DCmdArgument<NanoTimeArgument> _duration;\n-  DCmdArgument<bool> _disk;\n-  DCmdArgument<char*> _filename;\n-  DCmdArgument<NanoTimeArgument> _maxage;\n-  DCmdArgument<MemorySizeArgument> _maxsize;\n-  DCmdArgument<NanoTimeArgument> _flush_interval;\n-  DCmdArgument<bool> _dump_on_exit;\n-  DCmdArgument<bool> _path_to_gc_roots;\n-\n+class JfrCheckFlightRecordingDCmd : public JfrDCmd {\n@@ -98,1 +94,2 @@\n-  JfrStartFlightRecordingDCmd(outputStream* output, bool heap);\n+  JfrCheckFlightRecordingDCmd(outputStream* output, bool heap) : JfrDCmd(output, heap) {}\n+\n@@ -100,1 +97,1 @@\n-    return \"JFR.start\";\n+    return \"JFR.check\";\n@@ -103,1 +100,1 @@\n-    return \"Starts a new JFR recording\";\n+    return \"Checks running JFR recording(s)\";\n@@ -106,1 +103,1 @@\n-    return \"Medium: Depending on the settings for a recording, the impact can range from low to high.\";\n+    return \"Low\";\n@@ -112,2 +109,3 @@\n-  static int num_arguments();\n-  virtual void execute(DCmdSource source, TRAPS);\n+  virtual const char* javaClass() const {\n+    return \"jdk\/jfr\/internal\/dcmd\/DCmdCheck\";\n+  }\n@@ -116,5 +114,1 @@\n-class JfrStopFlightRecordingDCmd : public DCmdWithParser {\n- protected:\n-  DCmdArgument<char*> _name;\n-  DCmdArgument<char*> _filename;\n-\n+class JfrStopFlightRecordingDCmd : public JfrDCmd {\n@@ -122,1 +116,2 @@\n-  JfrStopFlightRecordingDCmd(outputStream* output, bool heap);\n+  JfrStopFlightRecordingDCmd(outputStream* output, bool heap) : JfrDCmd(output, heap) {}\n+\n@@ -136,2 +131,3 @@\n-  static int num_arguments();\n-  virtual void execute(DCmdSource source, TRAPS);\n+  virtual const char* javaClass() const {\n+    return \"jdk\/jfr\/internal\/dcmd\/DCmdStop\";\n+  }\n@@ -140,2 +136,0 @@\n-class JfrRuntimeOptions;\n-\n@@ -176,0 +170,1 @@\n+  virtual void print_help(const char* name) const;\n@@ -178,0 +173,1 @@\n+\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.hpp","additions":50,"deletions":54,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -490,2 +490,6 @@\n-\/\/ caller needs ResourceMark\n-const char* JfrJavaSupport::c_str(oop string, JavaThread* t) {\n+static char* allocate_string(bool c_heap, int length, JavaThread* jt) {\n+  return c_heap ? NEW_C_HEAP_ARRAY(char, length, mtTracing) :\n+                  NEW_RESOURCE_ARRAY_IN_THREAD(jt, char, length);\n+}\n+\n+const char* JfrJavaSupport::c_str(oop string, JavaThread* t, bool c_heap \/* false *\/) {\n@@ -493,1 +497,1 @@\n-  char* resource_copy = NULL;\n+  char* str = NULL;\n@@ -497,3 +501,3 @@\n-    resource_copy = NEW_RESOURCE_ARRAY_IN_THREAD(t, char, (length + 1));\n-    if (resource_copy == NULL) {\n-      JfrJavaSupport::throw_out_of_memory_error(\"Unable to allocate thread local native memory\", t);\n+    str = allocate_string(c_heap, length + 1, t);\n+    if (str == NULL) {\n+      JfrJavaSupport::throw_out_of_memory_error(\"Unable to allocate native memory\", t);\n@@ -502,2 +506,1 @@\n-    assert(resource_copy != NULL, \"invariant\");\n-    java_lang_String::as_utf8_string(string, value, resource_copy, length + 1);\n+    java_lang_String::as_utf8_string(string, value, str, length + 1);\n@@ -505,1 +508,1 @@\n-  return resource_copy;\n+  return str;\n@@ -509,1 +512,1 @@\n-const char* JfrJavaSupport::c_str(jstring string, JavaThread* t) {\n+const char* JfrJavaSupport::c_str(jstring string, JavaThread* t, bool c_heap \/* false *\/) {\n@@ -511,1 +514,1 @@\n-  return string != NULL ? c_str(resolve_non_null(string), t) : NULL;\n+  return string != NULL ? c_str(resolve_non_null(string), t, c_heap) : NULL;\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -78,3 +78,2 @@\n-  \/\/ caller needs ResourceMark\n-  static const char* c_str(jstring string, JavaThread* jt);\n-  static const char* c_str(oop string, JavaThread* t);\n+  static const char* c_str(jstring string, JavaThread* jt, bool c_heap = false);\n+  static const char* c_str(oop string, JavaThread* jt, bool c_heap = false);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,2 @@\n-  JFR_LOG_TAG(jfr, dcmd)\n+  JFR_LOG_TAG(jfr, dcmd) \\\n+  JFR_LOG_TAG(jfr, start)\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrLogTagSets.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1759,0 +1759,16 @@\n+.PP\n+Event settings and .jfc options can also be specified using the following\n+syntax:\n+.TP\n+.B \\f[CB]option=\\f[R]\\f[I]value\\f[R]\n+Specifies the option value to modify. To list available options, use the \n+JAVA_HOME\/bin\/jfr tool.\n+.TP\n+.B \\f[CB]event-setting=\\f[R]\\f[I]value\\f[R]\n+Specifies the event setting value to modify. Use the form:\n+<event-name>#<setting-name>=<value>\n+To add a new event setting, prefix the event name with '+'.\n+.PP\n+In case of a conflict between a parameter and a .jfc option, the parameter\n+will take precedence. The whitespace delimiter can be omitted for timespan values, i.e. 20ms. For\n+more information about the settings syntax, see Javadoc of the jdk.jfr package.\n","filename":"src\/java.base\/share\/man\/java.1","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -565,0 +565,16 @@\n+.PP\n+Event settings and .jfc options can also be specified using the following\n+syntax:\n+.TP\n+.B \\f[CB]option=\\f[R]\\f[I]value\\f[R]\n+Specifies the option value to modify. To list available options, use the\n+JAVA_HOME\/bin\/jfr tool.\n+.TP\n+.B \\f[CB]event-setting=\\f[R]\\f[I]value\\f[R]\n+Specifies the event setting value to modify. Use the form:\n+<event-name>#<setting-name>=<value>\n+To add a new event setting, prefix the event name with '+'.\n+.PP\n+In case of a conflict between a parameter and a .jfc option, the parameter\n+will take precedence. The whitespace delimiter can be omitted for timespan values, i.e. 20ms. For\n+more information about the settings syntax, see Javadoc of the jdk.jfr package.\n","filename":"src\/jdk.jcmd\/share\/man\/jcmd.1","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,5 @@\n-    JFR_DCMD(12);\n+    JFR_DCMD(12),\n+    \/**\n+     * -XX:StartFlightRecording\n+     *\/\n+    JFR_START(13);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/LogTag.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,3 @@\n+import jdk.jfr.internal.LogLevel;\n+import jdk.jfr.internal.LogTag;\n+import jdk.jfr.internal.Logger;\n@@ -53,0 +56,39 @@\n+    private String source;\n+\n+    \/\/ Called by native\n+    public abstract String[] printHelp();\n+\n+    \/\/ Called by native\n+    public abstract Argument[] getArgumentInfos();\n+\n+    \/\/ Called by native\n+    protected abstract void execute(ArgumentParser parser) throws DCmdException;\n+\n+\n+    \/\/ Called by native\n+    public final String[] execute(String source, String arg, char delimiter) throws DCmdException {\n+        this.source = source;\n+        try {\n+            boolean log = Logger.shouldLog(LogTag.JFR_DCMD, LogLevel.DEBUG);\n+            if (log) {\n+                System.out.println(arg);\n+                Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG, \"Executing \" + this.getClass().getSimpleName() + \": \" + arg);\n+            }\n+            ArgumentParser parser = new ArgumentParser(getArgumentInfos(), arg, delimiter);\n+            parser.parse();\n+            if (log) {\n+                Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG, \"DCMD options: \" + parser.getOptions());\n+                if (parser.hasExtendedOptions()) {\n+                    Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG, \"JFC options: \" + parser.getExtendedOptions());\n+                }\n+            }\n+            execute(parser);\n+            return getResult();\n+       }\n+       catch (IllegalArgumentException iae) {\n+            DCmdException e = new DCmdException(iae.getMessage());\n+            e.addSuppressed(iae);\n+            throw e;\n+        }\n+    }\n+\n@@ -58,1 +100,1 @@\n-    public final String[] getResult() {\n+    protected final String[] getResult() {\n@@ -62,0 +104,8 @@\n+    protected void logWarning(String message) {\n+        if (source.equals(\"internal\")) { \/\/ -XX:StartFlightRecording\n+            Logger.log(LogTag.JFR_START, LogLevel.WARN, message);\n+        } else { \/\/ DiagnosticMXBean or JCMD\n+            println(\"Warning! \" + message);\n+        }\n+    }\n+\n@@ -195,0 +245,24 @@\n+\n+    protected final String exampleRepository() {\n+        if (\"\\r\\n\".equals(System.lineSeparator())) {\n+            return \"C:\\\\Repositories\";\n+        } else {\n+            return \"\/Repositories\";\n+        }\n+    }\n+\n+    protected final String exampleFilename() {\n+        if (\"\\r\\n\".equals(System.lineSeparator())) {\n+            return \"C:\\\\Users\\\\user\\\\recording.jfr\";\n+        } else {\n+            return \"\/recordings\/recording.jfr\";\n+        }\n+    }\n+\n+    protected final String exampleDirectory() {\n+        if (\"\\r\\n\".equals(System.lineSeparator())) {\n+            return \"C:\\\\Directory\\\\recordings\";\n+        } else {\n+            return \"\/directory\/recordings\";\n+        }\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/AbstractDCmd.java","additions":76,"deletions":2,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.dcmd;\n+\n+record Argument(\n+    String name,\n+    String description,\n+    String type,\n+    boolean mandatory,\n+    String defaultValue,\n+    boolean allowMultiple\n+) { }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/Argument.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,337 @@\n+package jdk.jfr.internal.dcmd;\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+final class ArgumentParser {\n+    private final Map<String, Object> options = new HashMap<>();\n+    private final Map<String, Object> extendedOptions = new HashMap<>();\n+    private final StringBuilder builder = new StringBuilder();\n+    private final String text;\n+    private final char delimiter;\n+    private final String keyValueDelimiter;\n+    private final String valueDelimiter;\n+    private final Argument[] arguments;\n+    private int position;\n+\n+    ArgumentParser(Argument[] arguments, String text, char delimiter) {\n+        this.text = text;\n+        this.delimiter = delimiter;\n+        this.arguments = arguments;\n+        this.keyValueDelimiter = \"=\" + delimiter;\n+        this.valueDelimiter = Character.toString(delimiter);\n+    }\n+\n+    public Map<String, Object> parse() {\n+        eatDelimiter();\n+        while (!atEnd()) {\n+            String key = readText(keyValueDelimiter);\n+            String value = null;\n+            if (accept('=')) {\n+                value = readText(valueDelimiter);\n+            }\n+            if (!atEnd() && !accept(delimiter)) { \/\/ must be followed by delimiter\n+                throw new IllegalArgumentException(\"Expected delimiter, but found \" + currentChar());\n+            }\n+            addOption(key, value);\n+            eatDelimiter();\n+        }\n+        checkMandatory();\n+        return options;\n+    }\n+\n+    private void checkMandatory() {\n+        for (Argument arg : arguments) {\n+            if (!options.containsKey(arg.name())) {\n+                if (arg.mandatory()) {\n+                    throw new IllegalArgumentException(\"The argument '\" + arg.name() + \"' is mandatory\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+    private void addOption(String key, String value) {\n+        boolean found = false;\n+        for (Argument arg : arguments) {\n+            if (arg.name().equals(key)) {\n+                found = true;\n+                Object v = value(key, arg.type(), value);\n+                if (arg.allowMultiple()) {\n+                    var list = (List<Object>) options.computeIfAbsent(key, x -> new ArrayList<>());\n+                    if (v instanceof List l) {\n+                        list.addAll(l);\n+                    } else {\n+                        list.add(v);\n+                    }\n+                } else {\n+                    if (options.containsKey(key)) {\n+                        throw new IllegalArgumentException(\"Duplicates in diagnostic command arguments\");\n+                    }\n+                    options.put(key, v);\n+                }\n+            }\n+        }\n+        if (!found) {\n+            extendedOptions.put(key, value);\n+        }\n+    }\n+\n+    private char currentChar() {\n+        return text.charAt(position);\n+    }\n+\n+    private char lastChar() {\n+        return text.charAt(position -1);\n+    }\n+\n+    private boolean atEnd() {\n+        return !(position < text.length());\n+    }\n+\n+    private void eatDelimiter() {\n+        while (!atEnd() && currentChar() == delimiter) {\n+            position++;\n+        }\n+    }\n+\n+    private boolean accept(char c) {\n+        if (!atEnd() && currentChar() == c) {\n+            position++;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    \/\/ Mostly copied from native DCmdParser\n+    private String readText(String abortChars) {\n+        builder.setLength(0);\n+        boolean quoted = false; ;\n+        while (position <= text.length() - 1 && abortChars.indexOf(currentChar()) == -1) {\n+          if (currentChar() == '\\\"' || currentChar() == '\\'') {\n+            char quote =currentChar();\n+            quoted = true;\n+            while (position < text.length() - 1) {\n+              position++;\n+              if (currentChar() == quote && lastChar() != '\\\\') {\n+                break;\n+              }\n+              builder.append(currentChar());\n+            }\n+            if (currentChar() != quote) {\n+              throw new IllegalArgumentException(\"Format error in diagnostic command arguments\");\n+            }\n+            break;\n+          }\n+          builder.append(currentChar());\n+          position++;\n+        }\n+        if (quoted) {\n+            position++;\n+        }\n+        return builder.toString();\n+    }\n+\n+    private Object value(String name, String type, String text) {\n+        return switch (type) {\n+            case \"STRING\", \"STRING SET\" -> text == null ? \"\" : text;\n+            case \"BOOLEAN\" -> parseBoolean(name, text);\n+            case \"NANOTIME\" -> parseNanotime(name, text);\n+            case \"MEMORY SIZE\" -> parseMemorySize(name, text);\n+            default -> throw new InternalError(\"Unknown type: \" + type);\n+        };\n+    }\n+\n+    private Boolean parseBoolean(String name, String text) {\n+        if (\"true\".equals(text)) {\n+            return Boolean.TRUE;\n+        }\n+        if (\"false\".equals(text)) {\n+            return Boolean.FALSE;\n+        }\n+        String msg = \"Boolean parsing error in command argument '\" + name + \"'. Could not parse: \" + text + \".\";\n+        throw new IllegalArgumentException(msg);\n+    }\n+\n+    private Object parseMemorySize(String name, String text) {\n+        if (text == null) {\n+            throw new IllegalArgumentException(\"Parsing error memory size value: syntax error, value is null\");\n+        }\n+        int index = indexOfUnit(text);\n+        String textValue = text.substring(0, index);\n+        String unit = text.substring(index);\n+        long bytes;\n+        try {\n+            bytes = Long.parseLong(textValue);\n+        } catch (NumberFormatException nfe) {\n+            throw new IllegalArgumentException(\"Parsing error memory size value: invalid value\");\n+        }\n+        if (bytes < 0) {\n+            throw new IllegalArgumentException(\"Parsing error memory size value: negative values not allowed\");\n+        }\n+        if (unit.isEmpty()) {\n+            return bytes;\n+        }\n+        return switch(unit.toLowerCase()) {\n+            case \"k\", \"kb\" -> bytes * 1024;\n+            case \"m\", \"mb\"-> bytes * 1024 * 1024;\n+            case \"g\", \"gb\" -> bytes * 1024 * 1024 * 1024;\n+            default -> throw new IllegalArgumentException(\"Parsing error memory size value: invalid value\");\n+        };\n+    }\n+\n+    private Object parseNanotime(String name, String text) {\n+        if (text == null) {\n+            throw new IllegalArgumentException(\"Integer parsing error nanotime value: syntax error, value is null\");\n+        }\n+        int index = indexOfUnit(text);\n+        String textValue = text.substring(0, index);\n+        String unit = text.substring(index);\n+        long time;\n+        try {\n+            time = Long.parseLong(textValue);\n+        } catch (NumberFormatException nfe) {\n+            throw new IllegalArgumentException(\"Integer parsing error nanotime value: syntax error\");\n+        }\n+        if (unit.isEmpty()) {\n+            if (time == 0) {\n+                return Long.valueOf(0);\n+            }\n+            throw new IllegalArgumentException(\"Integer parsing error nanotime value: unit required\");\n+        }\n+        return switch(unit) {\n+            case \"ns\" -> time;\n+            case \"us\" -> time * 1000;\n+            case \"ms\" -> time * 1000 * 1000;\n+            case \"s\" -> time * 1000 * 1000 * 1000;\n+            case \"m\" -> time * 60 * 1000 * 1000 * 1000;\n+            case \"h\" -> time * 60 * 60* 1000 * 1000 * 1000;\n+            case \"d\" -> time * 24 * 60 * 60 * 1000 * 1000 * 1000;\n+            default -> throw new IllegalArgumentException(\"Integer parsing error nanotime value: illegal unit\");\n+        };\n+    }\n+\n+    int indexOfUnit(String text) {\n+        for (int i = 0; i< text.length(); i++) {\n+            char c = text.charAt(i);\n+            if (i == 0 && c == '-') { \/\/ Accept negative values.\n+                continue;\n+            }\n+            if (!Character.isDigit(c)) {\n+                return i;\n+            }\n+        }\n+        return text.length();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    <T> T getOption(String name) {\n+        return (T) options.get(name);\n+    }\n+\n+    Map<String, Object> getOptions() {\n+        return options;\n+    }\n+\n+    void checkUnknownArguments() {\n+        if (!extendedOptions.isEmpty()) {\n+            String name = extendedOptions.keySet().iterator().next();\n+            throw new IllegalArgumentException(\"Unknown argument '\"  + name + \"' in diagnostic command.\");\n+        }\n+    }\n+\n+    Map<String, Object> getExtendedOptions() {\n+        return extendedOptions;\n+    }\n+\n+    boolean hasExtendedOptions() {\n+        return !extendedOptions.isEmpty();\n+    }\n+\n+    void checkSpelling(Set<String> excludeSet) {\n+        for (String name : extendedOptions.keySet()) {\n+            if (!excludeSet.contains(name)) { \/\/ ignore names specified in .jfc\n+                checkSpellingError(name);\n+            }\n+        }\n+    }\n+\n+    private void checkSpellingError(String name) {\n+        for (Argument a : arguments) {\n+            String expected = a.name();\n+            String s = name.toLowerCase();\n+            int lengthDifference = expected.length() - s.length();\n+            boolean spellingError = false;\n+            if (lengthDifference == 0) {\n+                if (expected.equals(s)) {\n+                    spellingError = true; \/\/ incorrect case, or we wouldn't be here\n+                } else {\n+                    if (s.length() < 6) {\n+                        spellingError = diff(expected, s) < 2; \/\/ one incorrect letter\n+                    } else {\n+                        spellingError = diff(expected, s) < 3; \/\/ two incorrect letter\n+                    }\n+                }\n+            }\n+            if (lengthDifference == 1) {\n+                spellingError = inSequence(expected, s); \/\/ missing letter\n+            }\n+            if (lengthDifference == -1) {\n+                spellingError = inSequence(s, expected); \/\/ additional letter\n+            }\n+            if (spellingError) {\n+                throw new IllegalArgumentException(\"Error! Did you mean '\" + expected + \"' instead of '\" + name + \"'?\");\n+            }\n+        }\n+    }\n+\n+    private int diff(String a, String b) {\n+        int count = a.length();\n+        for (int i = 0; i < a.length(); i++) {\n+            if (a.charAt(i) == b.charAt(i)) {\n+                count--;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    private boolean inSequence(String longer, String shorter) {\n+        int l = 0;\n+        int s = 0;\n+        while (l < longer.length() && s < shorter.length()) {\n+            if (longer.charAt(l) == shorter.charAt(s)) {\n+                s++;\n+            }\n+            l++;\n+        }\n+        return shorter.length() == s; \/\/ if 0, all letters in longer found in shorter\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/ArgumentParser.java","additions":337,"deletions":0,"binary":false,"changes":337,"status":"added"},{"patch":"@@ -39,3 +39,0 @@\n-import jdk.jfr.internal.LogLevel;\n-import jdk.jfr.internal.LogTag;\n-import jdk.jfr.internal.Logger;\n@@ -49,16 +46,0 @@\n-    \/**\n-     * Execute JFR.check\n-     *\n-     * @param recordingText name or id of the recording to check, or\n-     *        {@code null} to show a list of all recordings.\n-     *\n-     * @param verbose if event settings should be included.\n-     *\n-     * @return result output\n-     *\n-     * @throws DCmdException if the check could not be completed.\n-     *\/\n-    public String[] execute(String recordingText, Boolean verbose) throws DCmdException {\n-        executeInternal(recordingText, verbose);\n-        return getResult();\n-    }\n@@ -66,4 +47,5 @@\n-    private void executeInternal(String name, Boolean verbose) throws DCmdException {\n-        if (Logger.shouldLog(LogTag.JFR_DCMD, LogLevel.DEBUG)) {\n-            Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG, \"Executing DCmdCheck: name=\" + name + \", verbose=\" + verbose);\n-        }\n+    @Override\n+    protected void execute(ArgumentParser parser) throws DCmdException {\n+        parser.checkUnknownArguments();\n+        Boolean verbose = parser.getOption(\"verbose\");\n+        String name = parser.getOption(\"name\");\n@@ -164,0 +146,38 @@\n+\n+    @Override\n+    public String[] printHelp() {\n+            \/\/ 0123456789001234567890012345678900123456789001234567890012345678900123456789001234567890\n+        return \"\"\"\n+               Syntax : JFR.check [options]\n+\n+               Options:\n+\n+                 name     (Optional) Name of the flight recording. (STRING, no default value)\n+\n+                 verbose  (Optional) Flag for printing the event settings for the recording\n+                          (BOOLEAN, false)\n+\n+               Options must be specified using the <key> or <key>=<value> syntax.\n+\n+               Example usage:\n+\n+                $ jcmd <pid> JFR.check\n+                $ jcmd <pid> JFR.check verbose=true\n+                $ jcmd <pid> JFR.check name=1\n+                $ jcmd <pid> JFR.check name=benchmark\n+                $ jcmd <pid> JFR.check name=2 verbose=true\n+\n+               \"\"\".lines().toArray(String[]::new);\n+    }\n+\n+    @Override\n+    public Argument[] getArgumentInfos() {\n+        return new Argument[] {\n+            new Argument(\"name\",\n+                \"Recording name, e.g. \\\\\\\"My Recording\\\\\\\" or omit to see all recordings\",\n+                \"STRING\", false, null, false),\n+            new Argument(\"verbose\",\n+                \"Print event settings for the recording(s)\",\"BOOLEAN\",\n+                false, \"false\", false)\n+        };\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdCheck.java","additions":43,"deletions":23,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -244,0 +244,15 @@\n+\n+    @Override\n+    public String[] printHelp() {\n+        throw new InternalError(\"Should not reach here!\");\n+    }\n+\n+    @Override\n+    public Argument[] getArgumentInfos() {\n+        throw new InternalError(\"Should not reach here!\");\n+    }\n+\n+    @Override\n+    protected void execute(ArgumentParser parser) throws DCmdException {\n+        throw new InternalError(\"Should not reach here!\");\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdConfigure.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,3 +40,0 @@\n-import jdk.jfr.internal.LogLevel;\n-import jdk.jfr.internal.LogTag;\n-import jdk.jfr.internal.Logger;\n@@ -56,27 +53,11 @@\n-    \/**\n-     * Execute JFR.dump.\n-     *\n-     * @param name name or id of the recording to dump, or {@code null} to dump everything\n-     *\n-     * @param filename file path where recording should be written, not null\n-     * @param maxAge how far back in time to dump, may be null\n-     * @param maxSize how far back in size to dump data from, may be null\n-     * @param begin point in time to dump data from, may be null\n-     * @param end point in time to dump data to, may be null\n-     * @param pathToGcRoots if Java heap should be swept for reference chains\n-     *\n-     * @return result output\n-     *\n-     * @throws DCmdException if the dump could not be completed\n-     *\/\n-    public String[] execute(String name, String filename, Long maxAge, Long maxSize, String begin, String end, Boolean pathToGcRoots) throws DCmdException {\n-        if (Logger.shouldLog(LogTag.JFR_DCMD, LogLevel.DEBUG)) {\n-            Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG,\n-                    \"Executing DCmdDump: name=\" + name +\n-                    \", filename=\" + filename +\n-                    \", maxage=\" + maxAge +\n-                    \", maxsize=\" + maxSize +\n-                    \", begin=\" + begin +\n-                    \", end=\" + end +\n-                    \", path-to-gc-roots=\" + pathToGcRoots);\n-        }\n+\n+    @Override\n+    public void execute(ArgumentParser parser) throws DCmdException {\n+        parser.checkUnknownArguments();\n+        String name = parser.getOption(\"name\");\n+        String filename = parser.getOption(\"filename\");\n+        Long maxAge = parser.getOption(\"maxage\");\n+        Long maxSize = parser.getOption(\"maxsize\");\n+        String begin = parser.getOption(\"begin\");\n+        String end = parser.getOption(\"end\");\n+        Boolean pathToGcRoots = parser.getOption(\"path-to-gc-roots\");\n@@ -137,1 +118,0 @@\n-        return getResult();\n@@ -216,0 +196,104 @@\n+    @Override\n+    public String[] printHelp() {\n+            \/\/ 0123456789001234567890012345678900123456789001234567890012345678900123456789001234567890\n+        return \"\"\"\n+               Syntax : JFR.dump [options]\n+\n+               Options:\n+\n+                 begin           (Optional) Specify the time from which recording data will be included\n+                                 in the dump file. The format is specified as local time.\n+                                 (STRING, no default value)\n+\n+                 end             (Optional) Specify the time to which recording data will be included\n+                                 in the dump file. The format is specified as local time.\n+                                 (STRING, no default value)\n+\n+                                 Note: For both begin and end, the time must be in a format that can\n+                                 be read by any of these methods:\n+\n+                                  java.time.LocalTime::parse(String),\n+                                  java.time.LocalDateTime::parse(String)\n+                                  java.time.Instant::parse(String)\n+\n+                                 For example, \"13:20:15\", \"2020-03-17T09:00:00\" or\n+                                 \"2020-03-17T09:00:00Z\".\n+\n+                                 Note: begin and end times correspond to the timestamps found within\n+                                 the recorded information in the flight recording data.\n+\n+                                 Another option is to use a time relative to the current time that is\n+                                 specified by a negative integer followed by \"s\", \"m\" or \"h\".\n+                                 For example, \"-12h\", \"-15m\" or \"-30s\"\n+\n+                 filename        (Optional) Name of the file to which the flight recording data is\n+                                 dumped. If no filename is given, a filename is generated from the PID\n+                                 and the current date. The filename may also be a directory in which\n+                                 case, the filename is generated from the PID and the current date in\n+                                 the specified directory. (STRING, no default value)\n+\n+                 maxage          (Optional) Length of time for dumping the flight recording data to a\n+                                 file. (INTEGER followed by 's' for seconds 'm' for minutes or 'h' for\n+                                 hours, no default value)\n+\n+                 maxsize         (Optional) Maximum size for the amount of data to dump from a flight\n+                                 recording in bytes if one of the following suffixes is not used:\n+                                 'm' or 'M' for megabytes OR 'g' or 'G' for gigabytes.\n+                                 (STRING, no default value)\n+\n+                 name            (Optional) Name of the recording. If no name is given, data from all\n+                                 recordings is dumped. (STRING, no default value)\n+\n+                 path-to-gc-root (Optional) Flag for saving the path to garbage collection (GC) roots\n+                                 at the time the recording data is dumped. The path information is\n+                                 useful for finding memory leaks but collecting it can cause the\n+                                 application to pause for a short period of time. Turn on this flag\n+                                 only when you have an application that you suspect has a memory\n+                                 leak. (BOOLEAN, false)\n+\n+               Options must be specified using the <key> or <key>=<value> syntax.\n+\n+               Example usage:\n+\n+                $ jcmd <pid> JFR.dump\n+                $ jcmd <pid> JFR.dump filename=recording.jfr\n+                $ jcmd <pid> JFR.dump filename=%s\n+                $ jcmd <pid> JFR.dump name=1 filename=%s\n+                $ jcmd <pid> JFR.dump maxage=1h\n+                $ jcmd <pid> JFR.dump maxage=1h maxsize=50M\n+                $ jcmd <pid> JFR.dump fillename=leaks.jfr path-to-gc-root=true\n+                $ jcmd <pid> JFR.dump begin=13:15\n+                $ jcmd <pid> JFR.dump begin=13:15 end=21:30:00\n+                $ jcmd <pid> JFR.dump end=18:00 maxage=10m\n+                $ jcmd <pid> JFR.dump begin=2021-09-15T09:00:00 end=2021-09-15T10:00:00\n+                $ jcmd <pid> JFR.dump begin=-1h\n+                $ jcmd <pid> JFR.dump begin=-15m end=-5m\n+\n+               \"\"\".formatted(exampleDirectory(), exampleFilename()).lines().toArray(String[]::new);\n+    }\n+\n+    @Override\n+    public Argument[] getArgumentInfos() {\n+        return new Argument[] {\n+           new Argument(\"name\",\n+               \"Recording name, e.g. \\\\\\\"My Recording\\\\\\\"\",\n+               \"STRING\", false, null, false),\n+           new Argument(\"filename\",\n+               \"Copy recording data to file, e.g. \\\\\\\"\" + exampleFilename() + \"\\\\\\\"\",\n+               \"STRING\", false, null, false),\n+           new Argument(\"maxage\",\n+               \"Maximum duration to dump, in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or 0 for no limit\",\n+               \"NANOTIME\", false, null, false),\n+           new Argument(\"maxsize\", \"Maximum amount of bytes to dump, in (M)B or (G)B, e.g. 500M, or 0 for no limit\",\n+               \"MEMORY SIZE\", false, \"hotspot-pid-xxxxx-id-y-YYYY_MM_dd_HH_mm_ss.jfr\", false),\n+           new Argument(\"begin\",\n+               \"Point in time to dump data from, e.g. 09:00, 21:35:00, 2018-06-03T18:12:56.827Z, 2018-06-03T20:13:46.832, -10m, -3h, or -1d\",\n+               \"STRING\", false, null, false),\n+           new Argument(\"end\",\n+               \"Point in time to dump data to, e.g. 09:00, 21:35:00, 2018-06-03T18:12:56.827Z, 2018-06-03T20:13:46.832, -10m, -3h, or -1d\",\n+               \"STRING\", false, null, false),\n+           new Argument(\"path-to-gc-roots\",\n+               \"Collect path to GC roots\",\n+               \"BOOLEAN\", false, \"false\", false)\n+        };\n+    }\n@@ -217,0 +301,1 @@\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdDump.java","additions":117,"deletions":32,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,4 @@\n-import java.util.Arrays;\n-import java.util.HashMap;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n@@ -38,0 +40,1 @@\n+import java.util.Set;\n@@ -42,3 +45,0 @@\n-import jdk.jfr.internal.LogLevel;\n-import jdk.jfr.internal.LogTag;\n-import jdk.jfr.internal.Logger;\n@@ -51,0 +51,2 @@\n+import jdk.jfr.internal.jfc.model.JFCModel;\n+import jdk.jfr.internal.jfc.model.XmlInput;\n@@ -59,39 +61,11 @@\n-    \/**\n-     * Execute JFR.start.\n-     *\n-     * @param name optional name that can be used to identify recording.\n-     * @param settings names of settings files to use, i.e. \"default\" or\n-     *        \"default.jfc\".\n-     * @param delay delay before recording is started, in nanoseconds. Must be\n-     *        at least 1 second.\n-     * @param duration duration of the recording, in nanoseconds. Must be at\n-     *        least 1 second.\n-     * @param disk if recording should be persisted to disk\n-     * @param path file path where recording data should be written\n-     * @param maxAge how long recording data should be kept in the disk\n-     *        repository, or {@code 0} if no limit should be set.\n-     *\n-     * @param maxSize the minimum amount data to keep in the disk repository\n-     *        before it is discarded, or {@code 0} if no limit should be\n-     *        set.\n-     *\n-     * @param dumpOnExit if recording should dump on exit\n-     *\n-     * @return result output\n-     *\n-     * @throws DCmdException if recording could not be started\n-     *\/\n-    @SuppressWarnings(\"resource\")\n-    public String[] execute(String name, String[] settings, Long delay, Long duration, Boolean disk, String path, Long maxAge, Long maxSize, Long flush, Boolean dumpOnExit, Boolean pathToGcRoots) throws DCmdException {\n-        if (Logger.shouldLog(LogTag.JFR_DCMD, LogLevel.DEBUG)) {\n-            Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG, \"Executing DCmdStart: name=\" + name +\n-                    \", settings=\" + Arrays.asList(settings) +\n-                    \", delay=\" + delay +\n-                    \", duration=\" + duration +\n-                    \", disk=\" + disk+\n-                    \", filename=\" + path +\n-                    \", maxage=\" + maxAge +\n-                    \", flush-interval=\" + flush +\n-                    \", maxsize=\" + maxSize +\n-                    \", dumponexit=\" + dumpOnExit +\n-                    \", path-to-gc-roots=\" + pathToGcRoots);\n+    private Object source;\n+\n+    @Override\n+    public void execute(ArgumentParser parser) throws DCmdException {\n+        String name = parser.getOption(\"name\");\n+        List<String> list = parser.getOption(\"settings\");\n+        String[] settings = null;\n+        if (list == null) {\n+            settings = new String[] {\"default.jfc\"};\n+        } else {\n+            settings = list.toArray(new String[0]);\n@@ -99,0 +73,13 @@\n+        if (settings.length == 1 && \"none\".equals(settings[0])) {\n+            settings = new String[0];\n+        }\n+        Long delay = parser.getOption(\"delay\");\n+        Long duration = parser.getOption(\"duration\");\n+        Boolean disk = parser.getOption(\"disk\");\n+        String path = parser.getOption(\"filename\");\n+        Long maxAge = parser.getOption(\"maxage\");\n+        Long maxSize = parser.getOption(\"maxsize\");\n+        Long flush = parser.getOption(\"flush-interval\");\n+        Boolean dumpOnExit = parser.getOption(\"dumponexit\");\n+        Boolean pathToGcRoots = parser.getOption(\"path-to-gc-roots\");\n+\n@@ -114,9 +101,6 @@\n-        Map<String, String> s = new HashMap<>();\n-        for (String configName : settings) {\n-            try {\n-                s.putAll(JFC.createKnown(configName).getSettings());\n-            } catch(FileNotFoundException e) {\n-                throw new DCmdException(\"Could not find settings file'\" + configName + \"'\", e);\n-            } catch (IOException | ParseException e) {\n-                throw new DCmdException(\"Could not parse settings file '\" + settings[0] + \"'\", e);\n-            }\n+\n+        LinkedHashMap<String, String> s;\n+        if (parser.hasExtendedOptions()) {\n+           s = configureExtended(settings, parser);\n+        } else {\n+           s = configureStandard(settings);\n@@ -239,0 +223,1 @@\n+    }\n@@ -240,1 +225,12 @@\n-        return getResult();\n+    private LinkedHashMap<String, String> configureStandard(String[] settings) throws DCmdException {\n+        LinkedHashMap<String, String> s = new LinkedHashMap<>();\n+        for (String configName : settings) {\n+            try {\n+                s.putAll(JFC.createKnown(configName).getSettings());\n+            } catch(FileNotFoundException e) {\n+                throw new DCmdException(\"Could not find settings file'\" + configName + \"'\", e);\n+            } catch (IOException | ParseException e) {\n+                throw new DCmdException(\"Could not parse settings file '\" + settings[0] + \"'\", e);\n+            }\n+        }\n+        return s;\n@@ -243,0 +239,36 @@\n+    private LinkedHashMap<String, String> configureExtended(String[] settings, ArgumentParser parser) throws DCmdException {\n+        List<SafePath> paths = new ArrayList<>();\n+        for (String setting : settings) {\n+            paths.add(JFC.createSafePath(setting));\n+        }\n+        try {\n+            JFCModel model = new JFCModel(paths);\n+            Set<String> jfcOptions = new HashSet<>();\n+            for (XmlInput input : model.getInputs()) {\n+                jfcOptions.add(input.getName());\n+            }\n+            parser.checkSpelling(jfcOptions);\n+            Map<String, String> jfcSettings = model.getSettings();\n+            for (var entry : parser.getExtendedOptions().entrySet()) {\n+                String value = (String)entry.getValue();\n+                String optionName = entry.getKey();\n+                boolean added = optionName.startsWith(\"+\");\n+                if (!added && !jfcOptions.contains(optionName) && !jfcSettings.containsKey(optionName)) {\n+                    \/\/ Option\/setting doesn't exist and it is not a spelling error.\n+                    \/\/ By not throwing an exception, and instead print a warning,\n+                    \/\/ it is easier migrate to a newer JDK version without\n+                    \/\/ breaking startup scripts\n+                     logWarning(\"The .jfc option\/setting '\" + optionName + \"' doesn't exist.\");\n+                } else {\n+                    model.configure(entry.getKey(), value);\n+                }\n+            }\n+            return model.getSettings();\n+         } catch (IllegalArgumentException iae) {\n+             throw new DCmdException(iae.getMessage()); \/\/ spelling error, invalid value\n+         } catch (FileNotFoundException ioe) {\n+             throw new DCmdException(\"Could not find settings file'\" + settings[0] + \"'\", ioe);\n+         } catch (IOException | ParseException e) {\n+             throw new DCmdException(\"Could not parse settings file '\" + settings[0] + \"'\", e);\n+         }\n+    }\n@@ -274,0 +306,150 @@\n+\n+    @Override\n+    public String[] printHelp() {\n+        \/\/ 0123456789001234567890012345678900123456789001234567890012345678900123456789001234567890\n+        return \"\"\"\n+               Syntax : JFR.start [options]\n+\n+               Options:\n+\n+                 delay           (Optional) Length of time to wait before starting to record\n+                                 (INTEGER followed by 's' for seconds 'm' for minutes or h' for\n+                                 hours, 0s)\n+\n+                 disk            (Optional) Flag for also writing the data to disk while recording\n+                                 (BOOLEAN, true)\n+\n+                 dumponexit      (Optional) Flag for writing the recording to disk when the Java\n+                                 Virtual Machine (JVM) shuts down. If set to 'true' and no value\n+                                 is given for filename, the recording is written to a file in the\n+                                 directory where the process was started. The file name is a\n+                                 system-generated name that contains the process ID, the recording\n+                                 ID and the current time stamp. (For example:\n+                                 id-1-2021_09_14_09_00.jfr) (BOOLEAN, false)\n+\n+                 duration        (Optional) Length of time to record. Note that 0s means forever\n+                                 (INTEGER followed by 's' for seconds 'm' for minutes or 'h' for\n+                                 hours, 0s)\n+\n+                 filename        (Optional) Name of the file to which the flight recording data is\n+                                 written when the recording is stopped. If no filename is given, a\n+                                 filename is generated from the PID and the current date and is\n+                                 placed in the directory where the process was started. The\n+                                 filename may also be a directory in which case, the filename is\n+                                 generated from the PID and the current date in the specified\n+                                 directory. (STRING, no default value)\n+\n+                 maxage          (Optional) Maximum time to keep the recorded data on disk. This\n+                                 parameter is valid only when the disk parameter is set to true.\n+                                 Note 0s means forever. (INTEGER followed by 's' for seconds 'm'\n+                                 for minutes or 'h' for hours, 0s)\n+\n+                 maxsize         (Optional) Maximum size of the data to keep on disk in bytes if\n+                                 one of the following suffixes is not used: 'm' or 'M' for\n+                                 megabytes OR 'g' or 'G' for gigabytes. This parameter is valid\n+                                 only when the disk parameter is set to 'true'. The value must not\n+                                 be less than the value for the maxchunksize parameter set with\n+                                 the JFR.configure command. (STRING, 0 (no max size))\n+\n+                 name            (Optional) Name of the recording. If no name is provided, a name\n+                                 is generated. Make note of the generated name that is shown in\n+                                 the response to the command so that you can use it with other\n+                                 commands. (STRING, system-generated default name)\n+\n+                 path-to-gc-root (Optional) Flag for saving the path to garbage collection (GC)\n+                                 roots at the end of a recording. The path information is useful\n+                                 for finding memory leaks but collecting it is time consuming.\n+                                 Turn on this flag only when you have an application that you\n+                                 suspect has a memory leak. If the settings parameter is set to\n+                                 'profile', then the information collected includes the stack\n+                                 trace from where the potential leaking object wasallocated.\n+                                 (BOOLEAN, false)\n+\n+                 settings        (Optional) Name of the settings file that identifies which events\n+                                 to record. To specify more than one file, use the settings\n+                                 parameter repeatedly. Include the path if the file is not in\n+                                 JAVA-HOME\/lib\/jfr. The following profiles are included with the\n+                                 JDK in the JAVA-HOME\/lib\/jfr directory: 'default.jfc': collects a\n+                                 predefined set of information with low overhead, so it has minimal\n+                                 impact on performance and can be used with recordings that run\n+                                 continuously; 'profile.jfc': Provides more data than the\n+                                 'default.jfc' profile, but with more overhead and impact on\n+                                 performance. Use this configuration for short periods of time\n+                                 when more information is needed. Use none to start a recording\n+                                 without a predefined configuration file. (STRING,\n+                                 JAVA-HOME\/lib\/jfr\/default.jfc)\n+\n+               Event settings and .jfc options can also be specified using the following syntax:\n+\n+                 jfc-option=value    (Optional) The option value to modify. To see available\n+                                     options for a .jfc file, use the 'jfr configure' command.\n+\n+                 event-setting=value (Optional) The event setting value to modify. Use the form:\n+                                     <event-name>#<setting-name>=<value>\n+                                     To add a new event setting, prefix the event name with '+'.\n+\n+               In case of a conflict between a parameter and a .jfc option, the parameter will\n+               take  precedence. The whitespace character can be omitted for timespan values,\n+               i.e. 20s. For more information about the settings syntax, see Javadoc of the\n+               jdk.jfr package.\n+\n+               Options must be specified using the <key> or <key>=<value> syntax.\n+\n+               Example usage:\n+\n+                $ jcmd <pid> JFR.start\n+                $ jcmd <pid> JFR.start filename=dump.jfr\n+                $ jcmd <pid> JFR.start filename=%s\n+                $ jcmd <pid> JFR.start dumponexit=true\n+                $ jcmd <pid> JFR.start maxage=1h,maxsize=1000M\n+                $ jcmd <pid> JFR.start settings=profile\n+                $ jcmd <pid> JFR.start delay=5m,settings=my.jfc\n+                $ jcmd <pid> JFR.start gc=high method-profiling=high\n+                $ jcmd <pid> JFR.start jdk.JavaMonitorEnter#threshold=1ms\n+                $ jcmd <pid> JFR.start +HelloWorld#enabled=true +HelloWorld#stackTrace=true\n+                $ jcmd <pid> JFR.start settings=user.jfc com.example.UserDefined#enabled=true\n+                $ jcmd <pid> JFR.start settings=none +Hello#enabled=true\n+\n+               Note, if the default event settings are modified, overhead may exceed 1%%.\n+\n+               \"\"\".formatted(exampleDirectory()).lines().toArray(String[]::new);\n+    }\n+\n+    @Override\n+    public Argument[] getArgumentInfos() {\n+        return new Argument[] {\n+            new Argument(\"name\",\n+                \"Name that can be used to identify recording, e.g. \\\\\\\"My Recording\\\\\\\"\",\n+                \"STRING\", false, null, false),\n+            new Argument(\"settings\",\n+                \"Settings file(s), e.g. profile or default. See JAVA_HOME\/lib\/jfr\",\n+                \"STRING SET\", false, \"deafult.jfc\", true),\n+            new Argument(\"delay\",\n+                \"Delay recording start with (s)econds, (m)inutes), (h)ours), or (d)ays, e.g. 5h.\",\n+                \"NANOTIME\", false, \"0s\", false),\n+            new Argument(\"duration\",\n+                \"Duration of recording in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 300s.\",\n+                \"NANOTIME\", false, null, false),\n+            new Argument(\"disk\",\n+                \"Recording should be persisted to disk\",\n+                \"BOOLEAN\", false, \"true\", false),\n+            new Argument(\"filename\",\n+                \"Resulting recording filename, e.g. \\\\\\\"\" + exampleFilename() +  \"\\\\\\\"\",\n+                \"STRING\", false, \"hotspot-pid-xxxxx-id-y-YYYY_MM_dd_HH_mm_ss.jfr\", false),\n+            new Argument(\"maxage\",\n+                \"Maximum time to keep recorded data (on disk) in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or 0 for no limit\",\n+                \"NANOTIME\", false, \"0\", false),\n+            new Argument(\"maxsize\",\n+                \"Maximum amount of bytes to keep (on disk) in (k)B, (M)B or (G)B, e.g. 500M, or 0 for no limit\",\n+                \"MEMORY SIZE\", false, \"250M\", false),\n+            new Argument(\"flush-interval\",\n+                \"Dump running recording when JVM shuts down\",\n+                \"NANOTIME\", false, \"1s\", false),\n+            new Argument(\"dumponexit\",\n+                \"Minimum time before flushing buffers, measured in (s)econds, e.g. 4 s, or 0 for flushing when a recording ends\",\n+                \"BOOLEAN\", false, \"false\", false),\n+            new Argument(\"path-to-gc-roots\",\n+                \"Collect path to GC roots\",\n+                \"BOOLEAN\", false, \"false\", false)\n+        };\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdStart.java","additions":237,"deletions":55,"binary":false,"changes":292,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,0 @@\n-import jdk.jfr.internal.LogLevel;\n-import jdk.jfr.internal.LogTag;\n-import jdk.jfr.internal.Logger;\n@@ -44,19 +41,5 @@\n-    \/**\n-     * Execute JFR.stop\n-     *\n-     * Requires that either {@code name} or {@code id} is set.\n-     *\n-     * @param name name or id of the recording to stop.\n-     *\n-     * @param filename file path where data should be written after recording has\n-     *        been stopped, or {@code null} if recording shouldn't be written\n-     *        to disk.\n-     * @return result text\n-     *\n-     * @throws DCmdException if recording could not be stopped\n-     *\/\n-    public String[] execute(String name, String filename) throws DCmdException {\n-        if (Logger.shouldLog(LogTag.JFR_DCMD, LogLevel.DEBUG)) {\n-            Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG, \"Executing DCmdStart: name=\" + name + \", filename=\" + filename);\n-        }\n-\n+    @Override\n+    protected void execute(ArgumentParser parser)  throws DCmdException {\n+        parser.checkUnknownArguments();\n+        String name = parser.getOption(\"name\");\n+        String filename = parser.getOption(\"filename\");\n@@ -79,1 +62,0 @@\n-            return getResult();\n@@ -87,0 +69,38 @@\n+\n+    @Override\n+    public String[] printHelp() {\n+            \/\/ 0123456789001234567890012345678900123456789001234567890012345678900123456789001234567890\n+        return \"\"\"\n+               Syntax : JFR.stop [options]\n+\n+               Options:\n+\n+                 filename  (Optional) Name of the file to which the recording is written when the\n+                           recording is stopped. If no path is provided, the data from the recording\n+                           is discarded. (STRING, no default value)\n+\n+                 name      Name of the recording (STRING, no default value)\n+\n+               Options must be specified using the <key> or <key>=<value> syntax.\n+\n+               Example usage:\n+\n+                $ jcmd <pid> JFR.stop name=1\n+                $ jcmd <pid> JFR.stop name=benchmark filename=%s\n+                $ jcmd <pid> JFR.stop name=5 filename=recording.jfr\n+\n+               \"\"\".formatted(exampleDirectory()).\n+               lines().toArray(String[]::new);\n+    }\n+\n+    @Override\n+    public Argument[] getArgumentInfos() {\n+        return new Argument[] {\n+            new Argument(\"name\",\n+                \"Recording text,.e.g \\\\\\\"My Recording\\\\\\\"\",\n+                \"STRING\", true, null, false),\n+            new Argument(\"filename\",\n+                \"Copy recording data to file, e.g. \\\\\\\"\" + exampleFilename() +  \"\\\\\\\"\",\n+                \"STRING\", false, null, false)\n+        };\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdStop.java","additions":44,"deletions":24,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -120,0 +120,26 @@\n+    \/**\n+     * Create a path to a .jfc file.\n+     * <p>\n+     * If the name is predefined name,\n+     * i.e. \"default\" or \"profile.jfc\", it will return the path for\n+     * the predefined path in the JDK.\n+     *\n+     * @param path textual representation of the path\n+     *\n+     * @return a safe path, not null\n+     *\/\n+    public static SafePath createSafePath(String path) {\n+        for (SafePath predefined : SecuritySupport.getPredefinedJFCFiles()) {\n+            try {\n+                String name = JFC.nameFromPath(predefined.toPath());\n+                if (name.equals(path) || (name + \".jfc\").equals(path)) {\n+                    return predefined;\n+                }\n+            } catch (IOException e) {\n+                throw new InternalError(\"Error in predefined .jfc file\", e);\n+            }\n+        }\n+        return new SafePath(path);\n+    }\n+\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/jfc\/JFC.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -123,0 +123,10 @@\n+    public LinkedHashMap<String, String> getSettings() {\n+        LinkedHashMap<String, String> result = new LinkedHashMap<>();\n+        for (XmlEvent event : configuration.getEvents()) {\n+            for (XmlSetting setting : event.getSettings()) {\n+                result.put(event.getName() + \"#\" + setting.getName(), setting.getContent());\n+            }\n+        }\n+        return result;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/jfc\/model\/JFCModel.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-            paths.add(makeSafePath(name));\n+            paths.add(JFC.createSafePath(name));\n@@ -244,13 +244,0 @@\n-    private SafePath makeSafePath(String path) {\n-        for (SafePath predefined : SecuritySupport.getPredefinedJFCFiles()) {\n-            try {\n-                String name = JFC.nameFromPath(predefined.toPath());\n-                if (name.equals(path) || (name + \".jfc\").equals(path)) {\n-                    return predefined;\n-                }\n-            } catch (IOException e) {\n-                throw new InternalError(\"Error in predefined .jfc file\", e);\n-            }\n-        }\n-        return new SafePath(path);\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Configure.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -96,2 +96,1 @@\n-            \"duration=2000mss\",\n-            \"maxage=-1000\");\n+            \"duration=2000mss\");\n@@ -100,1 +99,2 @@\n-            \"maxage=1\");\n+            \"maxage=1\",\n+            \"maxage=-1000\");\n@@ -171,6 +171,0 @@\n-\n-        \/\/ Not existing options\n-        test(START_FLIGHT_RECORDING, \"Unknown argument 'dumponexitt' in diagnostic command.\",\n-            \"dumponexitt=true\");\n-        test(FLIGHT_RECORDER_OPTIONS, \"Unknown argument 'notexistoption' in diagnostic command.\",\n-            \"notexistoption\");\n","filename":"test\/jdk\/jdk\/jfr\/startupargs\/TestBadOptionValues.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.startupargs;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.Recording;\n+\n+\/**\n+ * @test\n+ * @summary Start a recording with custom settings\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @modules jdk.jfr\/jdk.jfr.internal\n+ *\n+ * @run main\/othervm -XX:StartFlightRecording:jdk.JVMInformation#enabled=false\n+ *      jdk.jfr.startupargs.TestEventSettings knownSetting\n+ *\n+ * @run main\/othervm -XX:StartFlightRecording:com.example.Hello#stackTrace=true\n+ *      jdk.jfr.startupargs.TestEventSettings unknownSetting\n+ *\n+ * @run main\/othervm -XX:StartFlightRecording:+HelloWorld#enabled=true\n+ *      jdk.jfr.startupargs.TestEventSettings addedUnknownSetting\n+ *\n+ * @run main\/othervm\n+ *      -XX:StartFlightRecording:+A.B#enabled=true,+C.D#enabled=false\n+ *      jdk.jfr.startupargs.TestEventSettings multipleSettings\n+ *\n+ * @run main\/othervm\n+ *      -XX:StartFlightRecording:class-loading=true,socket-threshold=100ms\n+ *      jdk.jfr.startupargs.TestEventSettings jfcOptions\n+ *\/\n+public class TestEventSettings {\n+\n+    public static void main(String... args) throws Exception {\n+        String subTest = args[0];\n+        System.out.println(subTest);\n+\n+        switch (subTest) {\n+        case \"knownSetting\" -> assertSetting(\"jdk.JVMInformation#enabled\",\"false\");\n+        case \"unknownSetting\" -> assertSetting(\"com.example.Hello#stackTrace\", null);\n+        case \"addedUnknownSetting\" -> assertSetting(\"HelloWorld#enabled\", \"true\");\n+        case \"multipleSettings\" -> {\n+            assertSetting(\"A.B#enabled\", \"true\");\n+            assertSetting(\"C.D#enabled\", \"false\");\n+        }\n+        case \"jfcOptions\" -> {\n+            assertSetting(\"jdk.ClassDefine#enabled\",\"true\");\n+            assertSetting(\"jdk.SocketRead#threshold\", \"100 ms\");\n+        }\n+        default -> throw new Exception(\"Uknown tes \" + subTest);\n+        }\n+    }\n+\n+    private static void assertSetting(String key, String value) throws Exception {\n+        List<Recording> rs = FlightRecorder.getFlightRecorder().getRecordings();\n+        if (rs.isEmpty()) {\n+            throw new Exception(\"No recording started\");\n+        }\n+        if (rs.size() != 1) {\n+            throw new Exception(\"Expected only one recording\");\n+        }\n+        Map<String, String> currentSettings = rs.get(0).getSettings();\n+        String s = currentSettings.get(key);\n+        if (!Objects.equals(s, value)) {\n+            System.out.println(\"Key:\" + key);\n+            System.out.println(\"Value:\" + value);\n+            System.out.println(\"Result: \" + s);\n+            System.out.println(\"All Setting:\");\n+            for (var entry : currentSettings.entrySet()) {\n+                System.out.println(entry.getKey() + \"=\" + entry.getValue());\n+            }\n+            throw new Exception(\"Expected: \" + value + \" for \" + key + \" , got: \" + s);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/startupargs\/TestEventSettings.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.startupargs;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/**\n+ * @test\n+ * @summary Start a recording with custom settings\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @modules jdk.jfr\/jdk.jfr.internal\n+ *\n+ * @run main\/othervm jdk.jfr.startupargs.TestJFCWarnings\n+ *\/\n+public class TestJFCWarnings {\n+\n+    public static void main(String... args) throws Exception {\n+        testUnknownOption();\n+        testSpellingError();\n+    }\n+\n+    private static void testSpellingError() throws Exception {\n+        \/\/ One character spelling error\n+        launch(\"-XX:StartFlightRecording:disc=false\",\n+             \"Did you mean 'disk' instead of 'disc'?\");\n+        \/\/ One missing character\n+        launch(\"-XX:StartFlightRecording:setting=my.jfc\",\n+             \"Did you mean 'settings' instead of 'setting'?\");\n+        \/\/ One additional character\n+        launch(\"-XX:StartFlightRecording:disk=false,paths-to-gc-roots=true,name=test\",\n+             \"Did you mean 'path-to-gc-roots' instead of 'paths-to-gc-roots'?\");\n+        \/\/ Incorrect case\n+        launch(\"-XX:StartFlightRecording:fileName=recording.jfr,disk=false\",\n+             \"Did you mean 'filename' instead of 'fileName'?\");\n+        \/\/ Two character spelling error in option with more than 6 characters\n+        launch(\"-XX:StartFlightRecording:name=wrong,filenaim=recording.jfr\",\n+             \"Did you mean 'filename' instead of 'filenaim'?\");\n+    }\n+\n+    private static void testUnknownOption() throws Exception {\n+        \/\/ Unknown .jfc option\n+        launch(\"-XX:StartFlightRecording:zebra=high\",\n+               \"The .jfc option\/setting 'zebra' doesn't exist.\");\n+        \/\/ Unknown event setting\n+        launch(\"-XX:StartFlightRecording:com.example.Hello#enabled=true\",\n+               \"The .jfc option\/setting 'com.example.Hello#enabled' doesn't exist.\");\n+    }\n+\n+    private static void launch(String commandLine, String expectedOutput) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(commandLine, \"-version\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldContain(expectedOutput);\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/jfr\/startupargs\/TestJFCWarnings.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"}]}