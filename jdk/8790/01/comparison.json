{"files":[{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -40,0 +41,2 @@\n+uint G1CardSet::_split_card_shift = 0;\n+size_t G1CardSet::_split_card_mask = 0;\n@@ -336,0 +339,24 @@\n+void G1CardSet::initialize(MemRegion reserved) {\n+  const uint BitsInUint = sizeof(uint) * BitsPerByte;\n+  const uint CardBitsWithinCardRegion = MIN2((uint)HeapRegion::LogCardsPerRegion, G1CardSetContainer::LogCardsPerRegionLimit);\n+\n+  \/\/ Check if the number of cards within a region fits an uint.\n+  if (CardBitsWithinCardRegion > BitsInUint) {\n+    vm_exit_during_initialization(\"Can not represent all cards in a card region within uint.\");\n+  }\n+\n+  _split_card_shift = CardBitsWithinCardRegion;\n+  _split_card_mask = ((size_t)1 << _split_card_shift) - 1;\n+\n+  \/\/ Check if the card region\/region within cards combination can cover the heap.\n+  const uint HeapSizeBits = log2i_exact(round_up_power_of_2(reserved.byte_size()));\n+  if (HeapSizeBits > (BitsInUint + _split_card_shift + G1CardTable::card_shift())) {\n+    FormatBuffer<> fmt(\"Can not represent all cards in the heap with card region\/card within region. \"\n+                       \"Heap %zuB (%u bits) Card set only covers %u bits.\",\n+                       reserved.byte_size(),\n+                       HeapSizeBits,\n+                       BitsInUint + _split_card_shift + G1CardTable::card_shift());\n+    vm_exit_during_initialization(fmt, \"Decrease heap size.\");\n+  }\n+}\n+\n@@ -676,0 +703,22 @@\n+void G1CardSet::split_card(uintptr_t card, uint& card_region, uint& card_within_region) const {\n+  card_region = (uint)(card >> _split_card_shift);\n+  card_within_region = (uint)(card & _split_card_mask);\n+  assert(card_within_region < _config->max_cards_in_region(), \"must be\");\n+}\n+\n+G1AddCardResult G1CardSet::add_card(uintptr_t card) {\n+  uint card_region;\n+  uint card_within_region;\n+  split_card(card, card_region, card_within_region);\n+\n+  return add_card(card_region, card_within_region, true \/* increment_total *\/);\n+}\n+\n+bool G1CardSet::contains_card(uintptr_t card) {\n+  uint card_region;\n+  uint card_within_region;\n+  split_card(card, card_region, card_within_region);\n+\n+  return contains_card(card_region, card_within_region);\n+}\n+\n@@ -754,1 +803,6 @@\n-void G1CardSet::print_info(outputStream* st, uint card_region, uint card_in_region) {\n+void G1CardSet::print_info(outputStream* st, uintptr_t card) {\n+  uint card_region;\n+  uint card_in_region;\n+\n+  split_card(card, card_region, card_in_region);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/memRegion.hpp\"\n@@ -186,0 +187,1 @@\n+  friend class G1CheckCardClosure;\n@@ -191,0 +193,7 @@\n+  \/\/ When splitting addresses into region and card within that region, the logical\n+  \/\/ shift value to get the region.\n+  static uint _split_card_shift;\n+  \/\/ When splitting addresses into region and card within that region, the mask\n+  \/\/ to get the offset within the region.\n+  static size_t _split_card_mask;\n+\n@@ -295,0 +304,14 @@\n+  void split_card(uintptr_t card, uint& card_region, uint& card_within_region) const;\n+\n+  G1AddCardResult add_card(uint card_region, uint card_in_region, bool increment_total = true);\n+\n+  bool contains_card(uint card_region, uint card_in_region);\n+\n+  \/\/ Testing API\n+  class CardClosure {\n+  public:\n+    virtual void do_card(uint region_idx, uint card_idx) = 0;\n+  };\n+\n+  void iterate_cards(CardClosure& cl);\n+\n@@ -302,0 +325,2 @@\n+  static void initialize(MemRegion reserved);\n+\n@@ -304,1 +329,1 @@\n-  G1AddCardResult add_card(uint card_region, uint card_in_region, bool increment_total = true);\n+  G1AddCardResult add_card(uintptr_t card);\n@@ -306,1 +331,1 @@\n-  bool contains_card(uint card_region, uint card_in_region);\n+  bool contains_card(uintptr_t card);\n@@ -308,1 +333,1 @@\n-  void print_info(outputStream* st, uint card_region, uint card_in_region);\n+  void print_info(outputStream* st, uintptr_t card);\n@@ -353,1 +378,1 @@\n-    virtual void do_containerptr(uint region_idx, size_t num_occupied, ContainerPtr container) = 0;\n+    virtual void do_containerptr(uint card_region_idx, size_t num_occupied, ContainerPtr container) = 0;\n@@ -357,7 +382,0 @@\n-\n-  class CardClosure {\n-  public:\n-    virtual void do_card(uint region_idx, uint card_idx) = 0;\n-  };\n-\n-  void iterate_cards(CardClosure& cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.hpp","additions":29,"deletions":11,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-uint HeapRegionRemSet::_split_card_shift = 0;\n-size_t HeapRegionRemSet::_split_card_mask = 0;\n@@ -55,22 +53,1 @@\n-  const uint BitsInUint = sizeof(uint) * BitsPerByte;\n-  const uint CardBitsWithinCardRegion = MIN2((uint)HeapRegion::LogCardsPerRegion, G1CardSetContainer::LogCardsPerRegionLimit);\n-\n-  \/\/ Check if the number of cards within a region fits an uint.\n-  if (CardBitsWithinCardRegion > BitsInUint) {\n-    vm_exit_during_initialization(\"Can not represent all cards in a card region within uint.\");\n-  }\n-\n-  _split_card_shift = CardBitsWithinCardRegion + CardTable::card_shift();\n-  _split_card_mask = ((size_t)1 << _split_card_shift) - 1;\n-\n-  \/\/ Check if the card region\/region within cards combination can cover the heap.\n-  const uint HeapSizeBits = log2i_exact(round_up_power_of_2(reserved.byte_size()));\n-  if (HeapSizeBits > (BitsInUint + _split_card_shift)) {\n-    FormatBuffer<> fmt(\"Can not represent all cards in the heap with card region\/card within region. \"\n-                       \"Heap %zuB (%u bits) Remembered set covers %u bits.\",\n-                       reserved.byte_size(),\n-                       HeapSizeBits,\n-                       BitsInUint + _split_card_shift);\n-    vm_exit_during_initialization(fmt, \"Decrease heap size.\");\n-  }\n-\n+  G1CardSet::initialize(reserved);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.cpp","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -54,6 +54,0 @@\n-  \/\/ When splitting addresses into region and card within that region, the logical\n-  \/\/ shift value to get the region.\n-  static uint _split_card_shift;\n-  \/\/ When splitting addresses into region and card within that region, the mask\n-  \/\/ to get the offset within the region.\n-  static size_t _split_card_mask;\n@@ -98,0 +92,2 @@\n+  inline uintptr_t to_card(OopOrNarrowOopStar from) const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -118,5 +118,2 @@\n-void HeapRegionRemSet::split_card(OopOrNarrowOopStar from, uint& card_region, uint& card_within_region) const {\n-  size_t offset = pointer_delta(from, _heap_base_address, 1);\n-  card_region = (uint)(offset >> _split_card_shift);\n-  card_within_region = (uint)((offset & _split_card_mask) >> CardTable::card_shift());\n-  assert(card_within_region < ((uint)1 << G1CardSetContainer::LogCardsPerRegionLimit), \"must be\");\n+uintptr_t HeapRegionRemSet::to_card(OopOrNarrowOopStar from) const {\n+  return pointer_delta(from, _heap_base_address, 1) >> CardTable::card_shift();\n@@ -138,6 +135,1 @@\n-  uint card_region;\n-  uint card_within_region;\n-\n-  split_card(from, card_region, card_within_region);\n-\n-  _card_set.add_card(card_region, card_within_region);\n+  _card_set.add_card(to_card(from));\n@@ -147,6 +139,1 @@\n-  uint card_region;\n-  uint card_within_region;\n-\n-  split_card(from, card_region, card_within_region);\n-\n-  return _card_set.contains_card(card_region, card_within_region);\n+  return _card_set.contains_card(to_card(from));\n@@ -156,6 +143,1 @@\n-  uint card_region;\n-  uint card_within_region;\n-\n-  split_card(from, card_region, card_within_region);\n-\n-  _card_set.print_info(st, card_region, card_within_region);\n+  _card_set.print_info(st, to_card(from));\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.inline.hpp","additions":5,"deletions":23,"binary":false,"changes":28,"status":"modified"}]}