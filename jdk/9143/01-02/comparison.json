{"files":[{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.annotation.*;\n+import java.lang.annotation.Annotation;\n@@ -33,1 +33,0 @@\n-import java.util.stream.Stream;\n@@ -37,0 +36,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -410,12 +410,2 @@\n-        \/\/ Use tmp to avoid multiple writes to a volatile.\n-        Parameter[] tmp = parameters;\n-\n-        if (tmp == null) {\n-\n-            \/\/ Otherwise, go to the JVM to get them\n-            try {\n-                tmp = getParameters0();\n-            } catch(IllegalArgumentException e) {\n-                \/\/ Rethrow ClassFormatErrors\n-                throw new MalformedParametersException(\"Invalid constant pool index\");\n-            }\n+        return parameterData().parameters;\n+    }\n@@ -423,8 +413,3 @@\n-            \/\/ If we get back nothing, then synthesize parameters\n-            if (tmp == null) {\n-                hasRealParameterData = false;\n-                tmp = synthesizeAllParams();\n-            } else {\n-                hasRealParameterData = true;\n-                verifyParameters(tmp);\n-            }\n+    boolean hasRealParameterData() {\n+        return parameterData().real;\n+    }\n@@ -432,4 +417,4 @@\n-            \/\/ writing to volatile field acts as a releasing store\n-            \/\/ and this must be strictly after assignment\n-            \/\/ of hasRealParameterData\n-            parameters = tmp;\n+    private ParameterData parameterData() {\n+        ParameterData parameterData = this.parameterData;\n+        if (parameterData != null){\n+            return parameterData;\n@@ -438,2 +423,8 @@\n-        return tmp;\n-    }\n+        Parameter[] tmp;\n+        \/\/ Go to the JVM to get them\n+        try {\n+            tmp = getParameters0();\n+        } catch (IllegalArgumentException e) {\n+            \/\/ Rethrow ClassFormatErrors\n+            throw new MalformedParametersException(\"Invalid constant pool index\");\n+        }\n@@ -441,7 +432,7 @@\n-    boolean hasRealParameterData() {\n-        \/\/ If this somehow gets called before parameters gets\n-        \/\/ initialized, force it into existence.\n-        \/\/ This is an acquiring read and must be strictly\n-        \/\/ before assignment of hasRealParameterData\n-        if (parameters == null) {\n-            privateGetParameters();\n+        \/\/ If we get back nothing, then synthesize parameters\n+        if (tmp == null) {\n+            tmp = synthesizeAllParams();\n+            parameterData = new ParameterData(tmp, false);\n+        } else {\n+            verifyParameters(tmp);\n+            parameterData = new ParameterData(tmp, true);\n@@ -449,1 +440,1 @@\n-        return hasRealParameterData;\n+        return this.parameterData = parameterData;\n@@ -452,2 +443,1 @@\n-    private transient boolean hasRealParameterData;\n-    private transient volatile Parameter[] parameters;\n+    private transient @Stable ParameterData parameterData;\n@@ -786,0 +776,3 @@\n+\n+    record ParameterData(Parameter[] parameters, boolean real) {}\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":31,"deletions":38,"binary":false,"changes":69,"status":"modified"}]}