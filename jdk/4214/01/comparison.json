{"files":[{"patch":"@@ -1991,2 +1991,1 @@\n-      if (singleton != NULL &&\n-          (!target->is_default_method() || target->is_overpass()) \/* CHA doesn't support default methods yet. *\/ ) {\n+      if (singleton != NULL) {\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -678,1 +678,1 @@\n-  ciMethod* root_m = resolve_invoke(caller, actual_recv, check_access);\n+  ciMethod* root_m = resolve_invoke(caller, actual_recv, check_access, true \/* allow_abstract *\/);\n@@ -683,1 +683,0 @@\n-  assert(!root_m->is_abstract(), \"resolve_invoke promise\");\n@@ -689,0 +688,1 @@\n+    assert(!root_m->is_abstract(), \"sanity\");\n@@ -695,0 +695,3 @@\n+    if (root_m->is_abstract()) {\n+      return NULL;\n+    }\n@@ -708,5 +711,0 @@\n-  \/\/ Disable CHA for default methods for now\n-  if (root_m->is_default_method()) {\n-    return NULL;\n-  }\n-\n@@ -723,0 +721,3 @@\n+      if (root_m->is_abstract()) {\n+        return NULL; \/\/ not supported\n+      }\n@@ -756,1 +757,0 @@\n-  assert(!target()->is_abstract(), \"not allowed\");\n@@ -773,43 +773,41 @@\n-ciMethod* ciMethod::resolve_invoke(ciKlass* caller, ciKlass* exact_receiver, bool check_access) {\n-   check_is_loaded();\n-   VM_ENTRY_MARK;\n-\n-   Klass* caller_klass = caller->get_Klass();\n-   Klass* recv         = exact_receiver->get_Klass();\n-   Klass* resolved     = holder()->get_Klass();\n-   Symbol* h_name      = name()->get_symbol();\n-   Symbol* h_signature = signature()->get_symbol();\n-\n-   LinkInfo link_info(resolved, h_name, h_signature, caller_klass,\n-                      check_access ? LinkInfo::AccessCheck::required : LinkInfo::AccessCheck::skip,\n-                      check_access ? LinkInfo::LoaderConstraintCheck::required : LinkInfo::LoaderConstraintCheck::skip);\n-   Method* m = NULL;\n-   \/\/ Only do exact lookup if receiver klass has been linked.  Otherwise,\n-   \/\/ the vtable has not been setup, and the LinkResolver will fail.\n-   if (recv->is_array_klass()\n-        ||\n-       (InstanceKlass::cast(recv)->is_linked() && !exact_receiver->is_interface())) {\n-     if (holder()->is_interface()) {\n-       m = LinkResolver::resolve_interface_call_or_null(recv, link_info);\n-     } else {\n-       m = LinkResolver::resolve_virtual_call_or_null(recv, link_info);\n-     }\n-   }\n-\n-   if (m == NULL) {\n-     \/\/ Return NULL only if there was a problem with lookup (uninitialized class, etc.)\n-     return NULL;\n-   }\n-\n-   ciMethod* result = this;\n-   if (m != get_Method()) {\n-     result = CURRENT_THREAD_ENV->get_method(m);\n-   }\n-\n-   \/\/ Don't return abstract methods because they aren't\n-   \/\/ optimizable or interesting.\n-   if (result->is_abstract()) {\n-     return NULL;\n-   } else {\n-     return result;\n-   }\n+ciMethod* ciMethod::resolve_invoke(ciKlass* caller, ciKlass* exact_receiver, bool check_access, bool allow_abstract) {\n+  check_is_loaded();\n+  VM_ENTRY_MARK;\n+\n+  Klass* caller_klass = caller->get_Klass();\n+  Klass* recv         = exact_receiver->get_Klass();\n+  Klass* resolved     = holder()->get_Klass();\n+  Symbol* h_name      = name()->get_symbol();\n+  Symbol* h_signature = signature()->get_symbol();\n+\n+  LinkInfo link_info(resolved, h_name, h_signature, caller_klass,\n+                     check_access ? LinkInfo::AccessCheck::required : LinkInfo::AccessCheck::skip,\n+                     check_access ? LinkInfo::LoaderConstraintCheck::required : LinkInfo::LoaderConstraintCheck::skip);\n+  Method* m = NULL;\n+  \/\/ Only do exact lookup if receiver klass has been linked.  Otherwise,\n+  \/\/ the vtable has not been setup, and the LinkResolver will fail.\n+  if (recv->is_array_klass()\n+       ||\n+      (InstanceKlass::cast(recv)->is_linked() && !exact_receiver->is_interface())) {\n+    if (holder()->is_interface()) {\n+      m = LinkResolver::resolve_interface_call_or_null(recv, link_info);\n+    } else {\n+      m = LinkResolver::resolve_virtual_call_or_null(recv, link_info);\n+    }\n+  }\n+\n+  if (m == NULL) {\n+    \/\/ Return NULL only if there was a problem with lookup (uninitialized class, etc.)\n+    return NULL;\n+  }\n+\n+  ciMethod* result = this;\n+  if (m != get_Method()) {\n+    result = CURRENT_THREAD_ENV->get_method(m);\n+  }\n+\n+  if (result->is_abstract() && !allow_abstract) {\n+    \/\/ Don't return abstract methods because they aren't optimizable or interesting.\n+    return NULL;\n+  }\n+  return result;\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":49,"deletions":51,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -303,1 +303,1 @@\n-  ciMethod* resolve_invoke(ciKlass* caller, ciKlass* exact_receiver, bool check_access = true);\n+  ciMethod* resolve_invoke(ciKlass* caller, ciKlass* exact_receiver, bool check_access = true, bool allow_abstract = false);\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1778,0 +1778,3 @@\n+  if (m->is_default_method()) {\n+    return NULL; \/\/ not supported\n+  }\n@@ -1884,0 +1887,1 @@\n+  \/\/ Also, abstract root method case is not fully supported.\n@@ -1888,0 +1892,1 @@\n+         m->is_abstract() ||\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -306,2 +306,1 @@\n-      if (singleton != NULL &&\n-          (!callee->is_default_method() || callee->is_overpass()) \/* CHA doesn't support default methods yet *\/) {\n+      if (singleton != NULL) {\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,197 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires !vm.graal.enabled & vm.opt.final.UseVtableBasedCHA == true\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ *          java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @compile Utils.java\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+PrintCompilation -XX:+PrintInlining -XX:+TraceDependencies -verbose:class -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*::m\n+ *                   -XX:CompileCommand=compileonly,*::test -XX:CompileCommand=dontinline,*::test\n+ *                   -Xbatch -Xmixed -XX:+WhiteBoxAPI\n+ *                   -XX:-TieredCompilation\n+ *                      compiler.cha.AbstractRootMethod\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+PrintCompilation -XX:+PrintInlining -XX:+TraceDependencies -verbose:class -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*::m\n+ *                   -XX:CompileCommand=compileonly,*::test -XX:CompileCommand=dontinline,*::test\n+ *                   -Xbatch -Xmixed -XX:+WhiteBoxAPI\n+ *                   -XX:+TieredCompilation -XX:TieredStopAtLevel=1\n+ *                      compiler.cha.AbstractRootMethod\n+ *\/\n+package compiler.cha;\n+\n+import static compiler.cha.Utils.*;\n+\n+public class AbstractRootMethod {\n+    public static void main(String[] args) {\n+        run(AbstractClass.class);\n+        run(AbstractInterface.class);\n+    }\n+\n+    public static class AbstractClass extends ATest<AbstractClass.C> {\n+        public AbstractClass() {\n+            super(C.class, D.class);\n+        }\n+\n+        interface I1 { Object m(); }\n+        interface I2 { default Object m() { return \"I2.m\"; } }\n+\n+        static abstract class C            { public abstract Object m(); }\n+\n+        static abstract class D  extends C {\n+            final Object ret = CORRECT;\n+            public Object m() {\n+                return ret;\n+            }\n+        }\n+\n+        static abstract class E1 extends C { \/* empty *\/ }\n+        static abstract class E2 extends C { public abstract Object m(); }\n+        static abstract class E3 extends C { public Object m() { return \"E3.m\"; } }\n+\n+        static abstract class F1 extends C implements I1 { }\n+        static abstract class F2 extends C implements I2 { }\n+\n+        static          class G  extends C { public Object m() { return CORRECT; } }\n+\n+        @Override\n+        public Object test(C obj) {\n+            return obj.m(); \/\/ invokevirtual C.m()\n+        }\n+\n+        @Override\n+        public void checkInvalidReceiver() {\n+            \/\/ nothing to do: concrete class types are enforced by the verifier\n+        }\n+\n+        @TestCase\n+        public void test() {\n+            \/\/ 0. Trigger compilation of a megamorphic call site\n+            compile(megamorphic()); \/\/ Dn <: D.m <: C.m ABSTRACT\n+            assertCompiled();\n+\n+            \/\/ Dependency: type = unique_concrete_method, context = C, method = D.m\n+\n+            \/\/ 1. No invalidation: abstract classes don't participate in CHA.\n+            initialize(E1.class,  \/\/ ABSTRACT E1            <: C.m ABSTRACT\n+                       E2.class,  \/\/ ABSTRACT E2.m ABSTRACT <: C.m ABSTRACT\n+                       E3.class,  \/\/ ABSTRACT E3.m          <: C.m ABSTRACT\n+                       F1.class,  \/\/ ABSTRACT F1            <: C.m ABSTRACT, I1.m ABSTRACT\n+                       F2.class); \/\/ ABSTRACT F2            <: C.m ABSTRACT, I2.m DEFAULT\n+            assertCompiled();\n+\n+            \/\/ 2. Dependency invalidation: G.m <: C.m ABSTRACT\n+            load(G.class);\n+            assertCompiled();\n+\n+            \/\/ 3. Dependency invalidation: G.m <: C.m ABSTRACT\n+            initialize(G.class);\n+            assertNotCompiled();\n+\n+            \/\/ 4. Recompilation: no inlining, no dependencies\n+            compile(megamorphic());\n+            call(new C() { public Object m() { return CORRECT; } }); \/\/  Cn.m <: C.m ABSTRACT\n+            call(new G() { public Object m() { return CORRECT; } }); \/\/  Gn <: G.m <: C.m ABSTRACT\n+            assertCompiled();\n+        }\n+    }\n+    public static class AbstractInterface extends ATest<AbstractInterface.C> {\n+        public AbstractInterface() {\n+            super(C.class, D.class);\n+        }\n+\n+        interface I1 { Object m(); }\n+        interface I2 extends I { default Object m() { return \"I2.m\"; } }\n+\n+        interface I { Object m(); }\n+\n+        static abstract class C implements I { \/* inherited from I *\/}\n+\n+        static abstract class D  extends C {\n+            final Object ret = CORRECT;\n+            public Object m() {\n+                return ret;\n+            }\n+        }\n+\n+        static abstract class E1 extends C { \/* empty *\/ }\n+        static abstract class E2 extends C { public abstract Object m(); }\n+        static abstract class E3 extends C { public Object m() { return \"E3.m\"; } }\n+\n+        static abstract class F1 extends C implements I1 { }\n+        static abstract class F2 extends C implements I2 { }\n+\n+        static          class G  extends C { public Object m() { return CORRECT; } }\n+\n+        @Override\n+        public Object test(C obj) {\n+            return obj.m(); \/\/ invokevirtual C.m()\n+        }\n+\n+        @Override\n+        public void checkInvalidReceiver() {\n+            \/\/ nothing to do: concrete class types are enforced by the verifier\n+        }\n+\n+        @TestCase\n+        public void test() {\n+            \/\/ 0. Trigger compilation of a megamorphic call site\n+            compile(megamorphic()); \/\/ Dn <: D.m <: C <: I.m ABSTRACT\n+            assertCompiled();\n+\n+            \/\/ Dependency: type = unique_concrete_method, context = C, method = D.m\n+\n+            \/\/ 1. No invalidation: abstract classes don't participate in CHA.\n+            initialize(E1.class,  \/\/ ABSTRACT E1            <: C <: I.m ABSTRACT\n+                       E2.class,  \/\/ ABSTRACT E2.m ABSTRACT <: C <: I.m ABSTRACT\n+                       E3.class,  \/\/ ABSTRACT E3.m          <: C <: I.m ABSTRACT\n+                       F1.class,  \/\/ ABSTRACT F1            <: C <: I.m ABSTRACT, I1.m ABSTRACT\n+                       F2.class); \/\/ ABSTRACT F2            <: C <: I.m ABSTRACT, I2.m DEFAULT\n+            assertCompiled();\n+\n+            \/\/ 2. Dependency invalidation: G.m <: C <: I.m ABSTRACT\n+            load(G.class);\n+            assertCompiled();\n+\n+            \/\/ 3. Dependency invalidation: G.m <: C <: I.m ABSTRACT\n+            initialize(G.class);\n+            assertNotCompiled();\n+\n+            \/\/ 4. Recompilation: no inlining, no dependencies\n+            compile(megamorphic());\n+            call(new C() { public Object m() { return CORRECT; } }); \/\/  Cn.m <: C <: I.m ABSTRACT\n+            call(new G() { public Object m() { return CORRECT; } }); \/\/  Gn <: G.m <: C <: I.m ABSTRACT\n+            assertCompiled();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/AbstractRootMethod.java","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires !vm.graal.enabled & vm.opt.final.UseVtableBasedCHA == true\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ *          java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @compile Utils.java\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+PrintCompilation -XX:+PrintInlining -XX:+TraceDependencies -verbose:class -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*::m\n+ *                   -XX:CompileCommand=compileonly,*::test -XX:CompileCommand=dontinline,*::test\n+ *                   -Xbatch -Xmixed -XX:+WhiteBoxAPI\n+ *                   -XX:-TieredCompilation\n+ *                      compiler.cha.DefaultRootMethod\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+PrintCompilation -XX:+PrintInlining -XX:+TraceDependencies -verbose:class -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*::m\n+ *                   -XX:CompileCommand=compileonly,*::test -XX:CompileCommand=dontinline,*::test\n+ *                   -Xbatch -Xmixed -XX:+WhiteBoxAPI\n+ *                   -XX:+TieredCompilation -XX:TieredStopAtLevel=1\n+ *                      compiler.cha.DefaultRootMethod\n+ *\/\n+package compiler.cha;\n+\n+import static compiler.cha.Utils.*;\n+\n+public class DefaultRootMethod {\n+    public static void main(String[] args) {\n+        run(DefaultRoot.class);\n+        run(InheritedDefault.class);\n+        System.out.println(\"TEST PASSED\");\n+    }\n+\n+    public static class DefaultRoot extends ATest<DefaultRoot.C> {\n+        public DefaultRoot() {\n+            super(C.class, D.class);\n+        }\n+\n+        interface I { default Object m() { return CORRECT; } }\n+\n+        static class C implements I { \/* inherited I.m *\/}\n+\n+        static class D extends C { \/* inherited I.m *\/ }\n+\n+        static abstract class E1 extends C { \/* empty *\/ }\n+        static abstract class E2 extends C { public abstract Object m(); }\n+        static abstract class E3 extends C { public Object m() { return \"E3.m\"; } }\n+\n+        interface I1 extends I { Object m(); }\n+        interface I2 extends I { default Object m() { return \"I2.m\"; } }\n+\n+        static abstract class F1 extends C implements I1 { }\n+        static abstract class F2 extends C implements I2 { }\n+\n+        static          class G  extends C { public Object m() { return CORRECT; } }\n+\n+        @Override\n+        public Object test(C obj) {\n+            return obj.m(); \/\/ invokevirtual C.m()\n+        }\n+\n+        @Override\n+        public void checkInvalidReceiver() {\n+            \/\/ nothing to do: concrete class types are enforced by the verifier\n+        }\n+\n+        @TestCase\n+        public void test() {\n+            \/\/ 0. Trigger compilation of a megamorphic call site\n+            compile(megamorphic()); \/\/ Dn <: D.m <: C <: I.m DEFAULT\n+            assertCompiled();\n+\n+            \/\/ Dependency: type = unique_concrete_method, context = C, method = D.m\n+\n+            \/\/ 1. No invalidation: abstract classes don't participate in CHA.\n+            initialize(E1.class,  \/\/ ABSTRACT E1            <: C <: I.m DEFAULT\n+                       E2.class,  \/\/ ABSTRACT E2.m ABSTRACT <: C <: I.m DEFAULT\n+                       E3.class,  \/\/ ABSTRACT E3.m          <: C <: I.m DEFAULT\n+                       F1.class,  \/\/ ABSTRACT F1            <: C <: I.m DEFAULT, I1.m ABSTRACT\n+                       F2.class); \/\/ ABSTRACT F2            <: C <: I.m DEFAULT, I2.m DEFAULT\n+            assertCompiled();\n+\n+            \/\/ 2. Dependency invalidation: G.m <: C <: I.m DEFAULT\n+            load(G.class);\n+            assertCompiled();\n+\n+            \/\/ 3. Dependency invalidation: G.m <: C <: I.m DEFAULT\n+            initialize(G.class);\n+            assertNotCompiled();\n+\n+            \/\/ 4. Recompilation: no inlining, no dependencies\n+            compile(megamorphic());\n+            call(new C() { public Object m() { return CORRECT; } }); \/\/  Cn.m <: C <: I.m DEFAULT\n+            call(new G() { public Object m() { return CORRECT; } }); \/\/  Gn <: G.m <: C <: I.m DEFAULT\n+            assertCompiled();\n+        }\n+    }\n+\n+    public static class InheritedDefault extends ATest<InheritedDefault.C> {\n+        public InheritedDefault() {\n+            super(C.class, D.class);\n+        }\n+\n+        interface I           { Object m(); }\n+        interface J extends I { default Object m() { return CORRECT; } }\n+\n+        static abstract class C implements I { \/* inherits I.m ABSTRACT *\/}\n+\n+        \/\/ NB! The class is marked abstract to avoid abstract_with_unique_concrete_subtype dependency\n+        static abstract class D extends C implements J { \/* inherits J.m DEFAULT*\/ }\n+\n+        static abstract class E1 extends C { \/* empty *\/ }\n+        static abstract class E2 extends C { public abstract Object m(); }\n+        static abstract class E3 extends C { public Object m() { return \"E3.m\"; } }\n+\n+        interface I1 extends I { Object m(); }\n+        interface I2 extends I { default Object m() { return \"I2.m\"; } }\n+\n+        static abstract class F1 extends C implements I1 { }\n+        static abstract class F2 extends C implements I2 { }\n+\n+        interface K extends I { default Object m() { return CORRECT; } }\n+        static class G extends C implements K { \/* inherits K.m DEFAULT *\/ }\n+\n+        @Override\n+        public Object test(C obj) {\n+            return obj.m(); \/\/ invokevirtual C.m()\n+        }\n+\n+        @Override\n+        public void checkInvalidReceiver() {\n+            \/\/ nothing to do: concrete class types are enforced by the verifier\n+        }\n+\n+        @TestCase\n+        public void test() {\n+            \/\/ 0. Trigger compilation of a megamorphic call site\n+            compile(megamorphic()); \/\/ Dn <: D.m <: C <: I.m ABSTRACT, J.m DEFAULT\n+            assertCompiled();\n+\n+            \/\/ Dependency: type = unique_concrete_method, context = C, method = D.m\n+\n+            \/\/ 1. No invalidation: abstract classes don't participate in CHA.\n+            initialize(E1.class,  \/\/ ABSTRACT E1            <: C <: I.m ABSTRACT\n+                       E2.class,  \/\/ ABSTRACT E2.m ABSTRACT <: C <: I.m ABSTRACT\n+                       E3.class,  \/\/ ABSTRACT E3.m          <: C <: I.m ABSTRACT\n+                       F1.class,  \/\/ ABSTRACT F1            <: C <: I.m ABSTRACT, I1.m ABSTRACT\n+                       F2.class); \/\/ ABSTRACT F2            <: C <: I.m ABSTRACT, I2.m DEFAULT\n+            assertCompiled();\n+\n+            \/\/ 2. No invalidation: not yet linked classes don't participate in CHA.\n+            load(G.class);\n+            assertCompiled();\n+\n+            \/\/ 3. Dependency invalidation: G.m <: C <: I.m DEFAULT\n+            initialize(G.class);\n+            assertNotCompiled();\n+\n+            \/\/ 4. Recompilation: no inlining, no dependencies\n+            compile(megamorphic());\n+            call(new C() { public Object m() { return CORRECT; } }); \/\/  Cn.m <: C <: I.m DEFAULT\n+            call(new G() { public Object m() { return CORRECT; } }); \/\/  Gn <: G.m <: C <: I.m DEFAULT\n+            assertCompiled();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/DefaultRootMethod.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+ * @compile Utils.java\n@@ -36,2 +37,4 @@\n- *                   -XX:CompileCommand=compileonly,*::test -XX:CompileCommand=compileonly,*::m -XX:CompileCommand=dontinline,*::test\n- *                   -Xbatch -XX:+WhiteBoxAPI -Xmixed\n+ *                   -XX:CompileCommand=compileonly,*::m\n+ *                   -XX:CompileCommand=compileonly,*::test -XX:CompileCommand=dontinline,*::test\n+ *                   -XX:CompileCommand=compileonly,*::testHelper -XX:CompileCommand=inline,*::testHelper\n+ *                   -Xbatch -Xmixed -XX:+WhiteBoxAPI\n@@ -43,2 +46,4 @@\n- *                   -XX:CompileCommand=compileonly,*::test -XX:CompileCommand=compileonly,*::m -XX:CompileCommand=dontinline,*::test\n- *                   -Xbatch -XX:+WhiteBoxAPI -Xmixed\n+ *                   -XX:CompileCommand=compileonly,*::m\n+ *                   -XX:CompileCommand=compileonly,*::test -XX:CompileCommand=dontinline,*::test\n+ *                   -XX:CompileCommand=compileonly,*::testHelper -XX:CompileCommand=inline,*::testHelper\n+ *                   -Xbatch -Xmixed -XX:+WhiteBoxAPI\n@@ -50,3 +55,0 @@\n-import jdk.internal.misc.Unsafe;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n@@ -54,15 +56,2 @@\n-import sun.hotspot.WhiteBox;\n-import sun.hotspot.code.NMethod;\n-\n-import java.io.IOException;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.util.HashMap;\n-import java.util.concurrent.Callable;\n-\n-import static jdk.test.lib.Asserts.*;\n-import static jdk.internal.org.objectweb.asm.ClassWriter.*;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+\n+import static compiler.cha.Utils.*;\n@@ -79,0 +68,1 @@\n+        System.out.println(\"TEST PASSED\");\n@@ -99,1 +89,1 @@\n-        public Object test(I i) { return ObjectToStringHelper.test(i); \/* invokeinterface I.toString() *\/ }\n+        public Object test(I i) { return ObjectToStringHelper.testHelper(i); \/* invokeinterface I.toString() *\/ }\n@@ -188,1 +178,1 @@\n-            return ObjectHashCodeHelper.test(i); \/* invokeinterface I.hashCode() *\/\n+            return ObjectHashCodeHelper.testHelper(i); \/* invokeinterface I.hashCode() *\/\n@@ -622,1 +612,1 @@\n-        interface K3 extends I { default Object m() { return WRONG; }}\n+        interface K3 extends J { default Object m() { return WRONG; }}\n@@ -626,0 +616,1 @@\n+        static class DK3 implements K3 {}\n@@ -629,1 +620,1 @@\n-            return i.m(); \/\/ no inlining since J.m is a default method\n+            return i.m();\n@@ -638,1 +629,1 @@\n-            \/\/ Dependency: none\n+            \/\/ Dependency: type = unique_concrete_method, context = I, method = C.m\n@@ -646,5 +637,5 @@\n-            \/\/ 2. No dependency and no inlining\n-            initialize(DJ.class,  \/\/      DJ.m                    <: intf J.m ABSTRACT\n-                       DI.class,  \/\/      DI.m          <: intf I <: intf J.m ABSTRACT\n-                       K1.class,  \/\/ intf K1            <: intf I <: intf J.m ABSTRACT\n-                       K2.class); \/\/ intf K2.m ABSTRACT <: intf I <: intf J.m ABSTRACT\n+            \/\/ 2. No dependency invalidation\n+            initialize(DJ.class,    \/\/      DJ.m                               <: intf J.m ABSTRACT\n+                       K1.class,   \/\/ intf  K1            <: intf I            <: intf J.m ABSTRACT\n+                       K2.class,   \/\/ intf  K2.m ABSTRACT <: intf I            <: intf J.m ABSTRACT\n+                       DK3.class); \/\/      DK3.m          <: intf K3.m DEFAULT <: intf J.m ABSTRACT\n@@ -652,0 +643,9 @@\n+\n+            \/\/ 3. Dependency invalidation\n+            initialize(DI.class); \/\/ DI.m <: intf I <: intf J.m ABSTRACT\n+            assertNotCompiled();\n+\n+            \/\/ 4. Recompilation w\/o a dependency\n+            compile(megamorphic());\n+            call(new C() { public Object m() { return CORRECT; }});\n+            assertCompiled(); \/\/ no inlining\n@@ -689,1 +689,1 @@\n-            return i.m(); \/\/ no inlining since J.m is a default method\n+            return i.m();\n@@ -698,1 +698,1 @@\n-            \/\/ Dependency: none\n+            \/\/ Dependency: type = unique_concrete_method, context = I, method = C.m\n@@ -706,2 +706,1 @@\n-            \/\/ 2. No dependency, no inlining\n-            \/\/ CHA doesn't support default methods yet.\n+            \/\/ 2. No dependency invalidation\n@@ -710,1 +709,0 @@\n-                       DI.class,\n@@ -715,0 +713,9 @@\n+\n+            \/\/ 3. Dependency invalidation\n+            initialize(DI.class); \/\/ DI.m <: intf I <: intf J.m ABSTRACT\n+            assertNotCompiled();\n+\n+            \/\/ 4. Recompilation w\/o a dependency\n+            compile(megamorphic());\n+            call(new C() { public Object m() { return CORRECT; }});\n+            assertCompiled(); \/\/ no inlining\n@@ -738,287 +745,0 @@\n-\n-    \/* =========================================================== *\/\n-\n-    interface Action {\n-        int run();\n-    }\n-\n-    public static final Unsafe U = Unsafe.getUnsafe();\n-\n-    interface Test<T> {\n-        void call(T o);\n-        T receiver(int id);\n-\n-        default Runnable monomophic() {\n-            return () -> {\n-                call(receiver(0)); \/\/ 100%\n-            };\n-        }\n-\n-        default Runnable bimorphic() {\n-            return () -> {\n-                call(receiver(0)); \/\/ 50%\n-                call(receiver(1)); \/\/ 50%\n-            };\n-        }\n-\n-        default Runnable polymorphic() {\n-            return () -> {\n-                for (int i = 0; i < 23; i++) {\n-                    call(receiver(0)); \/\/ 92%\n-                }\n-                call(receiver(1)); \/\/ 4%\n-                call(receiver(2)); \/\/ 4%\n-            };\n-        }\n-\n-        default Runnable megamorphic() {\n-            return () -> {\n-                call(receiver(0)); \/\/ 33%\n-                call(receiver(1)); \/\/ 33%\n-                call(receiver(2)); \/\/ 33%\n-            };\n-        }\n-\n-        default void initialize(Class<?>... cs) {\n-            for (Class<?> c : cs) {\n-                U.ensureClassInitialized(c);\n-            }\n-        }\n-\n-        default void repeat(int cnt, Runnable r) {\n-            for (int i = 0; i < cnt; i++) {\n-                r.run();\n-            }\n-        }\n-    }\n-\n-    public static abstract class ATest<T> implements Test<T> {\n-        public static final WhiteBox WB = WhiteBox.getWhiteBox();\n-\n-        public static final Object CORRECT = new Object();\n-        public static final Object WRONG   = new Object();\n-\n-        final Method TEST;\n-        private final Class<T> declared;\n-        private final Class<?> receiver;\n-\n-        private final HashMap<Integer, T> receivers = new HashMap<>();\n-\n-        public ATest(Class<T> declared, Class<?> receiver) {\n-            this.declared = declared;\n-            this.receiver = receiver;\n-            TEST = compute(() -> this.getClass().getDeclaredMethod(\"test\", declared));\n-        }\n-\n-        @DontInline\n-        public abstract Object test(T i);\n-\n-        public abstract void checkInvalidReceiver();\n-\n-        public T receiver(int id) {\n-            return receivers.computeIfAbsent(id, (i -> {\n-                try {\n-                    MyClassLoader cl = (MyClassLoader) receiver.getClassLoader();\n-                    Class<?> sub = cl.subclass(receiver, i);\n-                    return (T)sub.getDeclaredConstructor().newInstance();\n-                } catch (Exception e) {\n-                    throw new Error(e);\n-                }\n-            }));\n-        }\n-\n-\n-        public void compile(Runnable r) {\n-            while (!WB.isMethodCompiled(TEST)) {\n-                for (int i = 0; i < 100; i++) {\n-                    r.run();\n-                }\n-            }\n-            assertCompiled(); \/\/ record nmethod info\n-        }\n-\n-        private NMethod prevNM = null;\n-\n-        public void assertNotCompiled() {\n-            NMethod curNM = NMethod.get(TEST, false);\n-            assertTrue(prevNM != null); \/\/ was previously compiled\n-            assertTrue(curNM == null || prevNM.compile_id != curNM.compile_id); \/\/ either no nmethod present or recompiled\n-            prevNM = curNM; \/\/ update nmethod info\n-        }\n-\n-        public void assertCompiled() {\n-            NMethod curNM = NMethod.get(TEST, false);\n-            assertTrue(curNM != null); \/\/ nmethod is present\n-            assertTrue(prevNM == null || prevNM.compile_id == curNM.compile_id); \/\/ no recompilations if nmethod present\n-            prevNM = curNM; \/\/ update nmethod info\n-        }\n-\n-        @Override\n-        public void call(T i) {\n-            assertTrue(test(i) != WRONG);\n-        }\n-    }\n-\n-    @Retention(value = RetentionPolicy.RUNTIME)\n-    public @interface TestCase {}\n-\n-    static void run(Class<?> test) {\n-        try {\n-            for (Method m : test.getDeclaredMethods()) {\n-                if (m.isAnnotationPresent(TestCase.class)) {\n-                    System.out.println(m.toString());\n-                    ClassLoader cl = new MyClassLoader(test);\n-                    Class<?> c = cl.loadClass(test.getName());\n-                    c.getMethod(m.getName()).invoke(c.getDeclaredConstructor().newInstance());\n-                }\n-            }\n-        } catch (Exception e) {\n-            throw new Error(e);\n-        }\n-    }\n-\n-    static class ObjectToStringHelper {\n-        static Object test(Object o) {\n-            throw new Error(\"not used\");\n-        }\n-    }\n-    static class ObjectHashCodeHelper {\n-        static int test(Object o) {\n-        throw new Error(\"not used\");\n-    }\n-    }\n-\n-    static final class MyClassLoader extends ClassLoader {\n-        private final Class<?> test;\n-\n-        MyClassLoader(Class<?> test) {\n-            this.test = test;\n-        }\n-\n-        static String intl(String s) {\n-            return s.replace('.', '\/');\n-        }\n-\n-        Class<?> subclass(Class<?> c, int id) {\n-            String name = c.getName() + id;\n-            Class<?> sub = findLoadedClass(name);\n-            if (sub == null) {\n-                ClassWriter cw = new ClassWriter(COMPUTE_MAXS | COMPUTE_FRAMES);\n-                cw.visit(52, ACC_PUBLIC | ACC_SUPER, intl(name), null, intl(c.getName()), null);\n-\n-                { \/\/ Default constructor: <init>()V\n-                    MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-                    mv.visitCode();\n-                    mv.visitVarInsn(ALOAD, 0);\n-                    mv.visitMethodInsn(INVOKESPECIAL, intl(c.getName()), \"<init>\", \"()V\", false);\n-                    mv.visitInsn(RETURN);\n-                    mv.visitMaxs(0, 0);\n-                    mv.visitEnd();\n-                }\n-\n-                byte[] classFile = cw.toByteArray();\n-                return defineClass(name, classFile, 0, classFile.length);\n-            }\n-            return sub;\n-        }\n-\n-        protected Class<?> loadClass(String name, boolean resolve)\n-                throws ClassNotFoundException\n-        {\n-            \/\/ First, check if the class has already been loaded\n-            Class<?> c = findLoadedClass(name);\n-            if (c == null) {\n-                try {\n-                    c = getParent().loadClass(name);\n-                    if (name.endsWith(\"ObjectToStringHelper\")) {\n-                        ClassWriter cw = new ClassWriter(COMPUTE_MAXS | COMPUTE_FRAMES);\n-                        cw.visit(52, ACC_PUBLIC | ACC_SUPER, intl(name), null, \"java\/lang\/Object\", null);\n-\n-                        {\n-                            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"test\", \"(Ljava\/lang\/Object;)Ljava\/lang\/Object;\", null, null);\n-                            mv.visitCode();\n-                            mv.visitVarInsn(ALOAD, 0);\n-                            mv.visitMethodInsn(INVOKEINTERFACE, intl(test.getName()) + \"$I\", \"toString\", \"()Ljava\/lang\/String;\", true);\n-                            mv.visitInsn(ARETURN);\n-                            mv.visitMaxs(0, 0);\n-                            mv.visitEnd();\n-                        }\n-\n-                        byte[] classFile = cw.toByteArray();\n-                        return defineClass(name, classFile, 0, classFile.length);\n-                    } else if (name.endsWith(\"ObjectHashCodeHelper\")) {\n-                        ClassWriter cw = new ClassWriter(COMPUTE_MAXS | COMPUTE_FRAMES);\n-                        cw.visit(52, ACC_PUBLIC | ACC_SUPER, intl(name), null, \"java\/lang\/Object\", null);\n-\n-                        {\n-                            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"test\", \"(Ljava\/lang\/Object;)I\", null, null);\n-                            mv.visitCode();\n-                            mv.visitVarInsn(ALOAD, 0);\n-                            mv.visitMethodInsn(INVOKEINTERFACE, intl(test.getName()) + \"$I\", \"hashCode\", \"()I\", true);\n-                            mv.visitInsn(IRETURN);\n-                            mv.visitMaxs(0, 0);\n-                            mv.visitEnd();\n-                        }\n-\n-                        byte[] classFile = cw.toByteArray();\n-                        return defineClass(name, classFile, 0, classFile.length);\n-                    } else if (c == test || name.startsWith(test.getName())) {\n-                        try {\n-                            String path = name.replace('.', '\/') + \".class\";\n-                            byte[] classFile = getParent().getResourceAsStream(path).readAllBytes();\n-                            return defineClass(name, classFile, 0, classFile.length);\n-                        } catch (IOException e) {\n-                            throw new Error(e);\n-                        }\n-                    }\n-                } catch (ClassNotFoundException e) {\n-                    \/\/ ClassNotFoundException thrown if class not found\n-                    \/\/ from the non-null parent class loader\n-                }\n-\n-                if (c == null) {\n-                    \/\/ If still not found, then invoke findClass in order\n-                    \/\/ to find the class.\n-                    c = findClass(name);\n-                }\n-            }\n-            if (resolve) {\n-                resolveClass(c);\n-            }\n-            return c;\n-        }\n-    }\n-\n-    public interface RunnableWithException {\n-        void run() throws Throwable;\n-    }\n-\n-    public static void shouldThrow(Class<? extends Throwable> expectedException, RunnableWithException r) {\n-        try {\n-            r.run();\n-            throw new AssertionError(\"Exception not thrown: \" + expectedException.getName());\n-        } catch(Throwable e) {\n-            if (expectedException == e.getClass()) {\n-                \/\/ success: proper exception is thrown\n-            } else {\n-                throw new Error(expectedException.getName() + \" is expected\", e);\n-            }\n-        }\n-    }\n-\n-    public static MethodHandle unsafeCastMH(Class<?> cls) {\n-        try {\n-            MethodHandle mh = MethodHandles.identity(Object.class);\n-            return MethodHandles.explicitCastArguments(mh, mh.type().changeReturnType(cls));\n-        } catch (Throwable e) {\n-            throw new Error(e);\n-        }\n-    }\n-\n-    static <T> T compute(Callable<T> c) {\n-        try {\n-            return c.call();\n-        } catch (Exception e) {\n-            throw new Error(e);\n-        }\n-    }\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/StrengthReduceInterfaceCall.java","additions":44,"deletions":324,"binary":false,"changes":368,"status":"modified"},{"patch":"@@ -0,0 +1,331 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.cha;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.vm.annotation.DontInline;\n+import sun.hotspot.WhiteBox;\n+import sun.hotspot.code.NMethod;\n+\n+import java.io.IOException;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.concurrent.Callable;\n+\n+import static jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES;\n+import static jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+public class Utils {\n+    public static final Unsafe U = Unsafe.getUnsafe();\n+\n+    interface Test<T> {\n+        void call(T o);\n+        T receiver(int id);\n+\n+        default Runnable monomophic() {\n+            return () -> {\n+                call(receiver(0)); \/\/ 100%\n+            };\n+        }\n+\n+        default Runnable bimorphic() {\n+            return () -> {\n+                call(receiver(0)); \/\/ 50%\n+                call(receiver(1)); \/\/ 50%\n+            };\n+        }\n+\n+        default Runnable polymorphic() {\n+            return () -> {\n+                for (int i = 0; i < 23; i++) {\n+                    call(receiver(0)); \/\/ 92%\n+                }\n+                call(receiver(1)); \/\/ 4%\n+                call(receiver(2)); \/\/ 4%\n+            };\n+        }\n+\n+        default Runnable megamorphic() {\n+            return () -> {\n+                call(receiver(0)); \/\/ 33%\n+                call(receiver(1)); \/\/ 33%\n+                call(receiver(2)); \/\/ 33%\n+            };\n+        }\n+\n+        default void load(Class<?>... cs) {\n+            \/\/ nothing to do\n+        }\n+\n+        default void initialize(Class<?>... cs) {\n+            for (Class<?> c : cs) {\n+                U.ensureClassInitialized(c);\n+            }\n+        }\n+\n+        default void repeat(int cnt, Runnable r) {\n+            for (int i = 0; i < cnt; i++) {\n+                r.run();\n+            }\n+        }\n+    }\n+\n+    public static abstract class ATest<T> implements Test<T> {\n+        public static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+        public static final Object CORRECT = new Object();\n+        public static final Object WRONG   = new Object();\n+\n+        final Method TEST;\n+        private final Class<T> declared;\n+        private final Class<?> receiver;\n+\n+        private final HashMap<Integer, T> receivers = new HashMap<>();\n+\n+        public ATest(Class<T> declared, Class<?> receiver) {\n+            this.declared = declared;\n+            this.receiver = receiver;\n+            TEST = compute(() -> this.getClass().getDeclaredMethod(\"test\", declared));\n+        }\n+\n+        @DontInline\n+        public abstract Object test(T i);\n+\n+        public abstract void checkInvalidReceiver();\n+\n+        public T receiver(int id) {\n+            return receivers.computeIfAbsent(id, (i -> {\n+                try {\n+                    MyClassLoader cl = (MyClassLoader) receiver.getClassLoader();\n+                    Class<?> sub = cl.subclass(receiver, i);\n+                    return (T)sub.getDeclaredConstructor().newInstance();\n+                } catch (Exception e) {\n+                    throw new Error(e);\n+                }\n+            }));\n+        }\n+\n+\n+        public void compile(Runnable r) {\n+            while (!WB.isMethodCompiled(TEST)) {\n+                for (int i = 0; i < 100; i++) {\n+                    r.run();\n+                }\n+            }\n+            assertCompiled(); \/\/ record nmethod info\n+        }\n+\n+        private NMethod prevNM = null;\n+\n+        public void assertNotCompiled() {\n+            NMethod curNM = NMethod.get(TEST, false);\n+            assertTrue(prevNM != null); \/\/ was previously compiled\n+            assertTrue(curNM == null || prevNM.compile_id != curNM.compile_id); \/\/ either no nmethod present or recompiled\n+            prevNM = curNM; \/\/ update nmethod info\n+        }\n+\n+        public void assertCompiled() {\n+            NMethod curNM = NMethod.get(TEST, false);\n+            assertTrue(curNM != null); \/\/ nmethod is present\n+            assertTrue(prevNM == null || prevNM.compile_id == curNM.compile_id); \/\/ no recompilations if nmethod present\n+            prevNM = curNM; \/\/ update nmethod info\n+        }\n+\n+        @Override\n+        public void call(T i) {\n+            assertTrue(test(i) != WRONG);\n+        }\n+    }\n+\n+    @Retention(value = RetentionPolicy.RUNTIME)\n+    public @interface TestCase {}\n+\n+    static void run(Class<?> test) {\n+        try {\n+            for (Method m : test.getDeclaredMethods()) {\n+                if (m.isAnnotationPresent(TestCase.class)) {\n+                    System.out.println(m.toString());\n+                    ClassLoader cl = new MyClassLoader(test);\n+                    Class<?> c = cl.loadClass(test.getName());\n+                    c.getMethod(m.getName()).invoke(c.getDeclaredConstructor().newInstance());\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new Error(e);\n+        }\n+    }\n+\n+    static class ObjectToStringHelper {\n+        static Object testHelper(Object o) {\n+            throw new Error(\"not used\");\n+        }\n+    }\n+    static class ObjectHashCodeHelper {\n+        static int testHelper(Object o) {\n+            throw new Error(\"not used\");\n+        }\n+    }\n+\n+    static final class MyClassLoader extends ClassLoader {\n+        private final Class<?> test;\n+\n+        MyClassLoader(Class<?> test) {\n+            this.test = test;\n+        }\n+\n+        static String intl(String s) {\n+            return s.replace('.', '\/');\n+        }\n+\n+        Class<?> subclass(Class<?> c, int id) {\n+            String name = c.getName() + id;\n+            Class<?> sub = findLoadedClass(name);\n+            if (sub == null) {\n+                ClassWriter cw = new ClassWriter(COMPUTE_MAXS | COMPUTE_FRAMES);\n+                cw.visit(52, ACC_PUBLIC | ACC_SUPER, intl(name), null, intl(c.getName()), null);\n+\n+                { \/\/ Default constructor: <init>()V\n+                    MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n+                    mv.visitCode();\n+                    mv.visitVarInsn(ALOAD, 0);\n+                    mv.visitMethodInsn(INVOKESPECIAL, intl(c.getName()), \"<init>\", \"()V\", false);\n+                    mv.visitInsn(RETURN);\n+                    mv.visitMaxs(0, 0);\n+                    mv.visitEnd();\n+                }\n+\n+                byte[] classFile = cw.toByteArray();\n+                return defineClass(name, classFile, 0, classFile.length);\n+            }\n+            return sub;\n+        }\n+\n+        protected Class<?> loadClass(String name, boolean resolve)\n+                throws ClassNotFoundException\n+        {\n+            \/\/ First, check if the class has already been loaded\n+            Class<?> c = findLoadedClass(name);\n+            if (c == null) {\n+                try {\n+                    c = getParent().loadClass(name);\n+                    if (name.endsWith(\"ObjectToStringHelper\")) {\n+                        ClassWriter cw = new ClassWriter(COMPUTE_MAXS | COMPUTE_FRAMES);\n+                        cw.visit(52, ACC_PUBLIC | ACC_SUPER, intl(name), null, \"java\/lang\/Object\", null);\n+\n+                        {\n+                            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"testHelper\", \"(Ljava\/lang\/Object;)Ljava\/lang\/Object;\", null, null);\n+                            mv.visitCode();\n+                            mv.visitVarInsn(ALOAD, 0);\n+                            mv.visitMethodInsn(INVOKEINTERFACE, intl(test.getName()) + \"$I\", \"toString\", \"()Ljava\/lang\/String;\", true);\n+                            mv.visitInsn(ARETURN);\n+                            mv.visitMaxs(0, 0);\n+                            mv.visitEnd();\n+                        }\n+\n+                        byte[] classFile = cw.toByteArray();\n+                        return defineClass(name, classFile, 0, classFile.length);\n+                    } else if (name.endsWith(\"ObjectHashCodeHelper\")) {\n+                        ClassWriter cw = new ClassWriter(COMPUTE_MAXS | COMPUTE_FRAMES);\n+                        cw.visit(52, ACC_PUBLIC | ACC_SUPER, intl(name), null, \"java\/lang\/Object\", null);\n+\n+                        {\n+                            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"testHelper\", \"(Ljava\/lang\/Object;)I\", null, null);\n+                            mv.visitCode();\n+                            mv.visitVarInsn(ALOAD, 0);\n+                            mv.visitMethodInsn(INVOKEINTERFACE, intl(test.getName()) + \"$I\", \"hashCode\", \"()I\", true);\n+                            mv.visitInsn(IRETURN);\n+                            mv.visitMaxs(0, 0);\n+                            mv.visitEnd();\n+                        }\n+\n+                        byte[] classFile = cw.toByteArray();\n+                        return defineClass(name, classFile, 0, classFile.length);\n+                    } else if (c == test || name.startsWith(test.getName())) {\n+                        try {\n+                            String path = name.replace('.', '\/') + \".class\";\n+                            byte[] classFile = getParent().getResourceAsStream(path).readAllBytes();\n+                            return defineClass(name, classFile, 0, classFile.length);\n+                        } catch (IOException e) {\n+                            throw new Error(e);\n+                        }\n+                    }\n+                } catch (ClassNotFoundException e) {\n+                    \/\/ ClassNotFoundException thrown if class not found\n+                    \/\/ from the non-null parent class loader\n+                }\n+\n+                if (c == null) {\n+                    \/\/ If still not found, then invoke findClass in order\n+                    \/\/ to find the class.\n+                    c = findClass(name);\n+                }\n+            }\n+            if (resolve) {\n+                resolveClass(c);\n+            }\n+            return c;\n+        }\n+    }\n+\n+    public interface RunnableWithException {\n+        void run() throws Throwable;\n+    }\n+\n+    public static void shouldThrow(Class<? extends Throwable> expectedException, RunnableWithException r) {\n+        try {\n+            r.run();\n+            throw new AssertionError(\"Exception not thrown: \" + expectedException.getName());\n+        } catch(Throwable e) {\n+            if (expectedException == e.getClass()) {\n+                \/\/ success: proper exception is thrown\n+            } else {\n+                throw new Error(expectedException.getName() + \" is expected\", e);\n+            }\n+        }\n+    }\n+\n+    public static MethodHandle unsafeCastMH(Class<?> cls) {\n+        try {\n+            MethodHandle mh = MethodHandles.identity(Object.class);\n+            return MethodHandles.explicitCastArguments(mh, mh.type().changeReturnType(cls));\n+        } catch (Throwable e) {\n+            throw new Error(e);\n+        }\n+    }\n+\n+    static <T> T compute(Callable<T> c) {\n+        try {\n+            return c.call();\n+        } catch (Exception e) {\n+            throw new Error(e);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/Utils.java","additions":331,"deletions":0,"binary":false,"changes":331,"status":"added"}]}