{"files":[{"patch":"@@ -1991,2 +1991,1 @@\n-      if (singleton != NULL &&\n-          (!target->is_default_method() || target->is_overpass()) \/* CHA doesn't support default methods yet. *\/ ) {\n+      if (singleton != NULL) {\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -711,5 +711,0 @@\n-  \/\/ Disable CHA for default methods for now\n-  if (root_m->is_default_method()) {\n-    return NULL;\n-  }\n-\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1778,0 +1778,3 @@\n+  if (m->is_default_method()) {\n+    return NULL; \/\/ not supported\n+  }\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -306,2 +306,1 @@\n-      if (singleton != NULL &&\n-          (!callee->is_default_method() || callee->is_overpass()) \/* CHA doesn't support default methods yet *\/) {\n+      if (singleton != NULL) {\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires !vm.graal.enabled & vm.opt.final.UseVtableBasedCHA == true\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ *          java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @compile Utils.java\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+PrintCompilation -XX:+PrintInlining -XX:+TraceDependencies -verbose:class -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*::m\n+ *                   -XX:CompileCommand=compileonly,*::test -XX:CompileCommand=dontinline,*::test\n+ *                   -Xbatch -Xmixed -XX:+WhiteBoxAPI\n+ *                   -XX:-TieredCompilation\n+ *                      compiler.cha.DefaultRootMethod\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+PrintCompilation -XX:+PrintInlining -XX:+TraceDependencies -verbose:class -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*::m\n+ *                   -XX:CompileCommand=compileonly,*::test -XX:CompileCommand=dontinline,*::test\n+ *                   -Xbatch -Xmixed -XX:+WhiteBoxAPI\n+ *                   -XX:+TieredCompilation -XX:TieredStopAtLevel=1\n+ *                      compiler.cha.DefaultRootMethod\n+ *\/\n+package compiler.cha;\n+\n+import static compiler.cha.Utils.*;\n+\n+public class DefaultRootMethod {\n+    public static void main(String[] args) {\n+        run(DefaultRoot.class);\n+        run(InheritedDefault.class);\n+        System.out.println(\"TEST PASSED\");\n+    }\n+\n+    public static class DefaultRoot extends ATest<DefaultRoot.C> {\n+        public DefaultRoot() {\n+            super(C.class, D.class);\n+        }\n+\n+        interface I { default Object m() { return CORRECT; } }\n+\n+        static class C implements I { \/* inherited I.m *\/}\n+\n+        static class D extends C { \/* inherited I.m *\/ }\n+\n+        static abstract class E1 extends C { \/* empty *\/ }\n+        static abstract class E2 extends C { public abstract Object m(); }\n+        static abstract class E3 extends C { public Object m() { return \"E3.m\"; } }\n+\n+        interface I1 extends I { Object m(); }\n+        interface I2 extends I { default Object m() { return \"I2.m\"; } }\n+\n+        static abstract class F1 extends C implements I1 { }\n+        static abstract class F2 extends C implements I2 { }\n+\n+        static          class G  extends C { public Object m() { return CORRECT; } }\n+\n+        @Override\n+        public Object test(C obj) {\n+            return obj.m(); \/\/ invokevirtual C.m()\n+        }\n+\n+        @Override\n+        public void checkInvalidReceiver() {\n+            \/\/ nothing to do: concrete class types are enforced by the verifier\n+        }\n+\n+        @TestCase\n+        public void test() {\n+            \/\/ 0. Trigger compilation of a megamorphic call site\n+            compile(megamorphic()); \/\/ Dn <: D.m <: C <: I.m DEFAULT\n+            assertCompiled();\n+\n+            \/\/ Dependency: type = unique_concrete_method, context = C, method = D.m\n+\n+            \/\/ 1. No invalidation: abstract classes don't participate in CHA.\n+            initialize(E1.class,  \/\/ ABSTRACT E1            <: C <: I.m DEFAULT\n+                       E2.class,  \/\/ ABSTRACT E2.m ABSTRACT <: C <: I.m DEFAULT\n+                       E3.class,  \/\/ ABSTRACT E3.m          <: C <: I.m DEFAULT\n+                       F1.class,  \/\/ ABSTRACT F1            <: C <: I.m DEFAULT, I1.m ABSTRACT\n+                       F2.class); \/\/ ABSTRACT F2            <: C <: I.m DEFAULT, I2.m DEFAULT\n+            assertCompiled();\n+\n+            \/\/ 2. Dependency invalidation: G.m <: C <: I.m DEFAULT\n+            load(G.class);\n+            assertCompiled();\n+\n+            \/\/ 3. Dependency invalidation: G.m <: C <: I.m DEFAULT\n+            initialize(G.class);\n+            assertNotCompiled();\n+\n+            \/\/ 4. Recompilation: no inlining, no dependencies\n+            compile(megamorphic());\n+            call(new C() { public Object m() { return CORRECT; } }); \/\/  Cn.m <: C <: I.m DEFAULT\n+            call(new G() { public Object m() { return CORRECT; } }); \/\/  Gn <: G.m <: C <: I.m DEFAULT\n+            assertCompiled();\n+        }\n+    }\n+\n+    public static class InheritedDefault extends ATest<InheritedDefault.C> {\n+        public InheritedDefault() {\n+            super(C.class, D.class);\n+        }\n+\n+        interface I           { Object m(); }\n+        interface J extends I { default Object m() { return CORRECT; } }\n+\n+        static abstract class C implements I { \/* inherits I.m ABSTRACT *\/}\n+\n+        \/\/ NB! The class is marked abstract to avoid abstract_with_unique_concrete_subtype dependency\n+        static abstract class D extends C implements J { \/* inherits J.m DEFAULT*\/ }\n+\n+        static abstract class E1 extends C { \/* empty *\/ }\n+        static abstract class E2 extends C { public abstract Object m(); }\n+        static abstract class E3 extends C { public Object m() { return \"E3.m\"; } }\n+\n+        interface I1 extends I { Object m(); }\n+        interface I2 extends I { default Object m() { return \"I2.m\"; } }\n+\n+        static abstract class F1 extends C implements I1 { }\n+        static abstract class F2 extends C implements I2 { }\n+\n+        interface K extends I { default Object m() { return CORRECT; } }\n+        static class G extends C implements K { \/* inherits K.m DEFAULT *\/ }\n+\n+        @Override\n+        public Object test(C obj) {\n+            return obj.m(); \/\/ invokevirtual C.m()\n+        }\n+\n+        @Override\n+        public void checkInvalidReceiver() {\n+            \/\/ nothing to do: concrete class types are enforced by the verifier\n+        }\n+\n+        @TestCase\n+        public void test() {\n+            \/\/ 0. Trigger compilation of a megamorphic call site\n+            compile(megamorphic()); \/\/ Dn <: D.m <: C <: I.m ABSTRACT, J.m DEFAULT\n+            assertCompiled();\n+\n+            \/\/ Dependency: type = unique_concrete_method, context = C, method = D.m\n+\n+            \/\/ 1. No invalidation: abstract classes don't participate in CHA.\n+            initialize(E1.class,  \/\/ ABSTRACT E1            <: C <: I.m ABSTRACT\n+                       E2.class,  \/\/ ABSTRACT E2.m ABSTRACT <: C <: I.m ABSTRACT\n+                       E3.class,  \/\/ ABSTRACT E3.m          <: C <: I.m ABSTRACT\n+                       F1.class,  \/\/ ABSTRACT F1            <: C <: I.m ABSTRACT, I1.m ABSTRACT\n+                       F2.class); \/\/ ABSTRACT F2            <: C <: I.m ABSTRACT, I2.m DEFAULT\n+            assertCompiled();\n+\n+            \/\/ 2. No invalidation: not yet linked classes don't participate in CHA.\n+            load(G.class);\n+            assertCompiled();\n+\n+            \/\/ 3. Dependency invalidation: G.m <: C <: I.m DEFAULT\n+            initialize(G.class);\n+            assertNotCompiled();\n+\n+            \/\/ 4. Recompilation: no inlining, no dependencies\n+            compile(megamorphic());\n+            call(new C() { public Object m() { return CORRECT; } }); \/\/  Cn.m <: C <: I.m DEFAULT\n+            call(new G() { public Object m() { return CORRECT; } }); \/\/  Gn <: G.m <: C <: I.m DEFAULT\n+            assertCompiled();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/DefaultRootMethod.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -612,1 +612,1 @@\n-        interface K3 extends I { default Object m() { return WRONG; }}\n+        interface K3 extends J { default Object m() { return WRONG; }}\n@@ -616,0 +616,1 @@\n+        static class DK3 implements K3 {}\n@@ -619,1 +620,1 @@\n-            return i.m(); \/\/ no inlining since J.m is a default method\n+            return i.m();\n@@ -628,1 +629,1 @@\n-            \/\/ Dependency: none\n+            \/\/ Dependency: type = unique_concrete_method, context = I, method = C.m\n@@ -636,5 +637,5 @@\n-            \/\/ 2. No dependency and no inlining\n-            initialize(DJ.class,  \/\/      DJ.m                    <: intf J.m ABSTRACT\n-                       DI.class,  \/\/      DI.m          <: intf I <: intf J.m ABSTRACT\n-                       K1.class,  \/\/ intf K1            <: intf I <: intf J.m ABSTRACT\n-                       K2.class); \/\/ intf K2.m ABSTRACT <: intf I <: intf J.m ABSTRACT\n+            \/\/ 2. No dependency invalidation\n+            initialize(DJ.class,    \/\/      DJ.m                               <: intf J.m ABSTRACT\n+                       K1.class,   \/\/ intf  K1            <: intf I            <: intf J.m ABSTRACT\n+                       K2.class,   \/\/ intf  K2.m ABSTRACT <: intf I            <: intf J.m ABSTRACT\n+                       DK3.class); \/\/      DK3.m          <: intf K3.m DEFAULT <: intf J.m ABSTRACT\n@@ -642,0 +643,9 @@\n+\n+            \/\/ 3. Dependency invalidation\n+            initialize(DI.class); \/\/ DI.m <: intf I <: intf J.m ABSTRACT\n+            assertNotCompiled();\n+\n+            \/\/ 4. Recompilation w\/o a dependency\n+            compile(megamorphic());\n+            call(new C() { public Object m() { return CORRECT; }});\n+            assertCompiled(); \/\/ no inlining\n@@ -679,1 +689,1 @@\n-            return i.m(); \/\/ no inlining since J.m is a default method\n+            return i.m();\n@@ -688,1 +698,1 @@\n-            \/\/ Dependency: none\n+            \/\/ Dependency: type = unique_concrete_method, context = I, method = C.m\n@@ -696,2 +706,1 @@\n-            \/\/ 2. No dependency, no inlining\n-            \/\/ CHA doesn't support default methods yet.\n+            \/\/ 2. No dependency invalidation\n@@ -700,1 +709,0 @@\n-                       DI.class,\n@@ -705,0 +713,9 @@\n+\n+            \/\/ 3. Dependency invalidation\n+            initialize(DI.class); \/\/ DI.m <: intf I <: intf J.m ABSTRACT\n+            assertNotCompiled();\n+\n+            \/\/ 4. Recompilation w\/o a dependency\n+            compile(megamorphic());\n+            call(new C() { public Object m() { return CORRECT; }});\n+            assertCompiled(); \/\/ no inlining\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/StrengthReduceInterfaceCall.java","additions":30,"deletions":13,"binary":false,"changes":43,"status":"modified"}]}