{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include <atomic>\n@@ -70,0 +71,2 @@\n+\/* lock to access classCount *\/\n+static jrawMonitorID classLoadLock = NULL;\n@@ -99,1 +102,1 @@\n-    if (name != NULL && classCount < max_classes &&\n+    if (name != NULL &&\n@@ -103,3 +106,1 @@\n-        NSK_DISPLAY1(\"ClassFileLoadHook: %s\\n\", name);\n-        name_len = (jint) strlen(name) + 1;\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->Allocate(name_len, (unsigned char**) &names[classCount]))) {\n+        if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorEnter(classLoadLock))) {\n@@ -109,3 +110,21 @@\n-        memcpy(names[classCount], name, name_len);\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->Allocate(class_data_len, (unsigned char**)\n-                &old_class_def[classCount].class_bytes))) {\n+        \/\/ use while instead of if to exit the block on error\n+        while (classCount < max_classes) {\n+            NSK_DISPLAY1(\"ClassFileLoadHook: %s\\n\", name);\n+            name_len = (jint)strlen(name) + 1;\n+            if (!NSK_JVMTI_VERIFY(jvmti_env->Allocate(name_len, (unsigned char**)& names[classCount]))) {\n+                nsk_jvmti_setFailStatus();\n+                break;\n+            }\n+            memcpy(names[classCount], name, name_len);\n+            if (!NSK_JVMTI_VERIFY(jvmti_env->Allocate(class_data_len, (unsigned char**)\n+                    & old_class_def[classCount].class_bytes))) {\n+                nsk_jvmti_setFailStatus();\n+                break;\n+            }\n+            memcpy((unsigned char*)old_class_def[classCount].class_bytes,\n+                class_data, class_data_len);\n+            old_class_def[classCount].class_byte_count = class_data_len;\n+            classCount++;\n+            break;\n+        }\n+        if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorExit(classLoadLock))) {\n@@ -113,1 +132,0 @@\n-            return;\n@@ -115,4 +133,0 @@\n-        memcpy((unsigned char*) old_class_def[classCount].class_bytes,\n-            class_data, class_data_len);\n-        old_class_def[classCount].class_byte_count = class_data_len;\n-        classCount++;\n@@ -122,1 +136,1 @@\n-static int CompiledMethodLoadEventsCount = 0;\n+static std::atomic<int> CompiledMethodLoadEventsCount(0);\n@@ -145,1 +159,1 @@\n-static int SingleStepEventsCount = 0;\n+static std::atomic<int> SingleStepEventsCount(0);\n@@ -154,1 +168,1 @@\n-static int ExceptionEventsCount = 0;\n+static std::atomic<int> ExceptionEventsCount(0);\n@@ -176,1 +190,1 @@\n-                ExceptionEventsCount, signature);\n+                ExceptionEventsCount.load(), signature);\n@@ -185,1 +199,1 @@\n-        NSK_DISPLAY1(\"SingleStepEventsCount: %d\\n\", SingleStepEventsCount);\n+        NSK_DISPLAY1(\"SingleStepEventsCount: %d\\n\", SingleStepEventsCount.load());\n@@ -318,1 +332,1 @@\n-            NSK_DISPLAY1(\"SingleStepEventsCount: %d\\n\", SingleStepEventsCount);\n+            NSK_DISPLAY1(\"SingleStepEventsCount: %d\\n\", SingleStepEventsCount.load());\n@@ -437,0 +451,3 @@\n+    if (!NSK_JVMTI_VERIFY(jvmti->CreateRawMonitor(\"classLoadLock\", &classLoadLock)))\n+        return JNI_ERR;\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti\/hotswap\/HotSwap.cpp","additions":36,"deletions":19,"binary":false,"changes":55,"status":"modified"}]}