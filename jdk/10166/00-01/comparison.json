{"files":[{"patch":"@@ -47,6 +47,0 @@\n-    private static volatile boolean allStop = false;\n-\n-    public static void stopCheck() {\n-        if (allStop) throw new ThreadDeath();\n-    }\n-\n@@ -83,1 +77,1 @@\n-        var writer = new ClassWriter(reader, 0);\n+        var writer = new ClassWriter(reader, ClassWriter.COMPUTE_FRAMES);\n@@ -90,1 +84,8 @@\n-                        visitMethodInsn(Opcodes.INVOKESTATIC, \"jdk\/jshell\/execution\/LocalExecutionControl\", \"stopCheck\", \"()V\", false);\n+                        visitMethodInsn(Opcodes.INVOKESTATIC, \"java\/lang\/Thread\", \"interrupted\", \"()Z\", false);\n+                        var skip = new Label();\n+                        super.visitJumpInsn(Opcodes.IFEQ, skip);\n+                        visitTypeInsn(Opcodes.NEW, \"java\/lang\/ThreadDeath\");\n+                        visitInsn(Opcodes.DUP);\n+                        visitMethodInsn(Opcodes.INVOKESPECIAL, \"java\/lang\/ThreadDeath\", \"<init>\", \"()V\", false);\n+                        visitInsn(Opcodes.ATHROW);\n+                        visitLabel(skip);\n@@ -174,1 +175,11 @@\n-            allStop = true;\n+\n+            Thread[] threads;\n+            int len, threadCount;\n+            do {\n+                len = execThreadGroup.activeCount() + 4;\n+                threads = new Thread[len];\n+                threadCount = execThreadGroup.enumerate(threads);\n+            } while (threadCount == len);\n+            for (int i = 0; i < threadCount; i++) {\n+                threads[i].interrupt();\n+            }\n@@ -182,1 +193,0 @@\n-            allStop = false;\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/LocalExecutionControl.java","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"}]}