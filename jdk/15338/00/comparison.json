{"files":[{"patch":"@@ -0,0 +1,185 @@\n+\/\/\n+\/\/ Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.Random;\n+\n+import jdk.incubator.vector.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\", \"-XX:-TieredCompilation\"})\n+public class MatrixMultiplicationBenchmark {\n+\n+    private static final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_PREFERRED;\n+\n+    private static final int BLOCK_SIZE = 16;\n+    @Param({\"32\", \"1024\"})\n+    private int size;\n+    private float[] left;\n+    private float[] right;\n+\n+    private float[] result;\n+\n+    @Setup\n+    public void setup() {\n+        this.left = MatrixMultiplicationBenchmark.newFloatRowMatrix(size * size);\n+        this.right = MatrixMultiplicationBenchmark.newFloatRowMatrix(size * size);\n+        this.result = new float[size * size];\n+    }\n+\n+    @Benchmark\n+    public float[] mmulBaseline() {\n+        return baseline(left, right, result, size);\n+    }\n+\n+    @Benchmark\n+    public float[] mmulBlocked() {\n+        return blocked(left, right, result, size, BLOCK_SIZE);\n+    }\n+\n+    @Benchmark\n+    public float[] mmulSimpleFMA() {\n+        return simpleFMA(left, right, result, size);\n+    }\n+\n+    @Benchmark\n+    public float[] mmulSimpleVector() {\n+        return simpleVector(left, right, result, size);\n+    }\n+\n+    @Benchmark\n+    public float[] mmulBlockedVectorAuto() {\n+        return blockedVector(left, right, result, size);\n+    }\n+\n+\n+    private float[] baseline(float[] a, float[] b, float[] result, int n) {\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < n; j++) {\n+                float sum = 0.0f;\n+                for (int k = 0; k < n; k++) {\n+                    sum += a[i * n + k] * b[k * n + j];\n+                }\n+                result[i * n + j] = sum;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private float[] blocked(float[] a, float[] b, float[] result, int n, int blocksize) {\n+        for (int kk = 0; kk < n; kk += blocksize) {\n+            for (int jj = 0; jj < n; jj += blocksize) {\n+                for (int i = 0; i < n; i++) {\n+                    for (int j = jj; j < jj + blocksize; ++j) {\n+                        float sum = result[i * n + j];\n+                        for (int k = kk; k < kk + blocksize; ++k) {\n+                            sum += a[i * n + k] * b[k * n + j];\n+                        }\n+                        result[i * n + j] = sum;\n+                    }\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private float[] simpleFMA(float[] a, float[] b, float[] result, int n) {\n+        int in = 0;\n+        for (int i = 0; i < n; ++i) {\n+            int kn = 0;\n+            for (int k = 0; k < n; ++k) {\n+                float aik = a[in + k];\n+                for (int j = 0; j < n; ++j) {\n+                    result[in + j] = Math.fma(aik, b[kn + j], result[in + j]);\n+                }\n+                kn += n;\n+            }\n+            in += n;\n+        }\n+        return result;\n+    }\n+\n+    private float[] simpleVector(float[] a, float[] b, float[] result, int n) {\n+        final int upperBound = SPECIES.loopBound(n);\n+\n+        int in = 0;\n+        for (int i = 0; i < n; i++) {\n+            int kn = 0;\n+            for (int k = 0; k < n; k++) {\n+                float aik = a[in + k];\n+                FloatVector vaik = FloatVector.broadcast(SPECIES, aik);\n+\n+                for (int j = 0; j < upperBound; j += SPECIES.length()) {\n+                    \/\/ FloatVector va, vb, vc\n+                    var vb = FloatVector.fromArray(SPECIES, b, kn + j);\n+                    var vResult = FloatVector.fromArray(SPECIES, result, in + j);\n+                    vResult = vaik.fma(vb, vResult);\n+                    vResult.intoArray(result, in + j);\n+                }\n+                kn += n;\n+            }\n+            in += n;\n+        }\n+        return result;\n+    }\n+\n+    private float[] blockedVector(float[] a, float[] b, float[] result, int n) {\n+        int blockWidth = n >= 256 ? 512 : 256;\n+        int blockHeight = n >= 512 ? 8 : n >= 256 ? 16 : 32;\n+\n+        for (int rowOffset = 0; rowOffset < n; rowOffset += blockHeight) {\n+            for (int columnOffset = 0; columnOffset < n; columnOffset += blockWidth) {\n+                for (int i = 0; i < n; i++) {\n+                    for (int j = columnOffset; j < columnOffset + blockWidth && j < n; j += SPECIES.length()) {\n+                        var sum = FloatVector.fromArray(SPECIES, result, i * n + j);\n+                        for (int k = rowOffset; k < rowOffset + blockHeight && k < n; k++) {\n+                            var multiplier = FloatVector.broadcast(SPECIES, a[i * n + k]);\n+                            sum = multiplier.fma(FloatVector.fromArray(SPECIES, b, k * n + j), sum);\n+                        }\n+                        sum.intoArray(result, i * n + j);\n+                    }\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private static float[] newFloatRowMatrix(int size) {\n+        Random rand = new Random();\n+        float[] matrix = new float[size];\n+        for (int i = 0; i < matrix.length; ++i) {\n+            matrix[i] = rand.nextFloat();\n+        }\n+        return matrix;\n+    }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MatrixMultiplicationBenchmark.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"}]}