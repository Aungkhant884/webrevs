{"files":[{"patch":"@@ -28,1 +28,0 @@\n-import java.util.ArrayList;\n@@ -31,1 +30,0 @@\n-import java.util.concurrent.atomic.AtomicInteger;\n@@ -33,1 +31,0 @@\n-import java.util.stream.Collectors;\n@@ -1385,3 +1382,1 @@\n-                         * but it won't if the type annotation is applied to `String`, at this point all types will be represented\n-                         * in its fully unfolded form so we need to go back to the short form if type annotations are present for a\n-                         * given parameter\n+                         * but it won't if the type annotation is applied to `String`\n@@ -1389,5 +1384,2 @@\n-                        if (!param.getRawTypeAttributes().isEmpty()) {\n-                            params.append(make.VarDef(param, make.Ident(param.type.tsym), null));\n-                        } else {\n-                            params.append(make.VarDef(param,null));\n-                        }\n+                        JCExpression typeDec = reduceTypeDecl(make.Type(param.type));\n+                        params.append(make.VarDef(param, typeDec, null));\n@@ -1401,1 +1393,1 @@\n-                final AtomicInteger paramIndex = new AtomicInteger(0);\n+                int[] paramIndex = new int[]{0};\n@@ -1405,1 +1397,1 @@\n-                                    .filter(anno -> anno.position.type == TargetType.METHOD_TYPE_PARAMETER && anno.position.parameter_index == paramIndex.get())\n+                                    .filter(anno -> anno.position.type == TargetType.METHOD_TYPE_PARAMETER && anno.position.parameter_index == paramIndex[0])\n@@ -1408,1 +1400,1 @@\n-                    paramIndex.incrementAndGet();\n+                    paramIndex[0]++;\n@@ -1413,0 +1405,16 @@\n+            JCExpression reduceTypeDecl(JCExpression typeDecl) {\n+                if (typeDecl.hasTag(SELECT)) {\n+                    JCFieldAccess fa = (JCFieldAccess)typeDecl;\n+                    JCIdent result = make.Ident(fa.name);\n+                    result.type = fa.type;\n+                    result.sym = fa.sym;\n+                    result.pos = fa.pos;\n+                    return result;\n+                } else if (typeDecl.hasTag(TYPEAPPLY)) {\n+                    ((JCTypeApply) typeDecl).clazz = reduceTypeDecl(((JCTypeApply) typeDecl).clazz);\n+                } else if (typeDecl.hasTag(TYPEARRAY)) {\n+                    ((JCArrayTypeTree) typeDecl).elemtype = reduceTypeDecl(((JCArrayTypeTree) typeDecl).elemtype);\n+                }\n+                return typeDecl;\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n-1 error\n+Neg22.java:19:48: compiler.err.improperly.formed.type.inner.raw.param\n+2 errors\n","filename":"test\/langtools\/tools\/javac\/generics\/diamond\/neg\/Neg22.out","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}