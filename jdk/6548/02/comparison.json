{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -1260,0 +1261,1 @@\n+       default JCMethodDecl methodDecl() { return null; }\n@@ -1318,0 +1320,1 @@\n+        JCMethodDecl methodDecl;\n@@ -1340,12 +1343,14 @@\n-            MethodSymbol csym = super.constructorSymbol();\n-            csym.flags_field |= ANONCONSTR | (constr.flags() & VARARGS);\n-            csym.flags_field |= based ? ANONCONSTR_BASED : 0;\n-            ListBuffer<VarSymbol> params = new ListBuffer<>();\n-            List<Type> argtypes = constructorType().getParameterTypes();\n-            if (!enclosingType().hasTag(NONE)) {\n-                argtypes = argtypes.tail;\n-                params = params.prepend(new VarSymbol(PARAMETER, make.paramName(0), enclosingType(), csym));\n-            }\n-            if (constr.params != null) {\n-                for (VarSymbol p : constr.params) {\n-                    params.add(new VarSymbol(PARAMETER | p.flags(), p.name, argtypes.head, csym));\n+            \/\/ we should do this only once\n+            if (constructorSymbol == null) {\n+                MethodSymbol csym = super.constructorSymbol();\n+                csym.flags_field |= ANONCONSTR | (constr.flags() & VARARGS);\n+                csym.flags_field |= based ? ANONCONSTR_BASED : 0;\n+\n+                csym.appendAttributes(constr.getRawAttributes());\n+                csym.appendUniqueTypeAttributes(constr.getRawTypeAttributes().stream()\n+                        .filter(anno -> anno.position.type == TargetType.METHOD_RETURN)\n+                        .collect(List.collector()));\n+\n+                ListBuffer<VarSymbol> params = new ListBuffer<>();\n+                List<Type> argtypes = constructorType().getParameterTypes();\n+                if (!enclosingType().hasTag(NONE)) {\n@@ -1353,0 +1358,10 @@\n+                    params = params.prepend(new VarSymbol(PARAMETER, make.paramName(0), enclosingType(), csym));\n+                }\n+                if (constr.params != null) {\n+                    for (VarSymbol p : constr.params) {\n+                        VarSymbol param = new VarSymbol(PARAMETER | p.flags(), p.name, argtypes.head, csym);\n+                        param.appendAttributes(p.getRawAttributes());\n+                        param.appendUniqueTypeAttributes(p.getRawTypeAttributes());\n+                        params.add(param);\n+                        argtypes = argtypes.tail;\n+                    }\n@@ -1354,0 +1369,6 @@\n+                csym.params = params.toList();\n+\n+                \/\/ now lets create the tree to make sure that it is created according to our needs\n+                methodDecl = make.MethodDef(constrParams(csym),\n+                        typeParams(csym.type.getTypeArguments()), csym, csym.type, null);\n+                return csym;\n@@ -1355,2 +1376,1 @@\n-            csym.params = params.toList();\n-            return csym;\n+            return constructorSymbol;\n@@ -1359,0 +1379,34 @@\n+        \/\/ helper methods\n+            private List<JCVariableDecl> constrParams(MethodSymbol csym) {\n+                ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n+                if (csym.params != null) {\n+                    for (VarSymbol param : csym.params) {\n+                        \/* the compiler will issue an error if a type annotation is applied to, for example, `java.lang.String`\n+                         * but it won't if the type annotation is applied to `String`, at this point all types will be represented\n+                         * in its fully unfolded form so we need to go back to the short form if type annotations are present for a\n+                         * given parameter\n+                         *\/\n+                        if (!param.getRawTypeAttributes().isEmpty()) {\n+                            params.append(make.VarDef(param, make.Ident(param.type.tsym), null));\n+                        } else {\n+                            params.append(make.VarDef(param,null));\n+                        }\n+                    }\n+                }\n+                return params.toList();\n+            }\n+\n+            private List<JCTypeParameter> typeParams(List<Type> typarams) {\n+                ListBuffer<JCTypeParameter> tparams = new ListBuffer<>();\n+                final AtomicInteger paramIndex = new AtomicInteger(0);\n+                for (List<Type> l = typarams; l.nonEmpty(); l = l.tail) {\n+                    tparams.append(make.TypeParam(l.head.tsym.name, (TypeVar) l.head,\n+                            constr.getRawTypeAttributes().stream()\n+                                    .filter(anno -> anno.position.type == TargetType.METHOD_TYPE_PARAMETER && anno.position.parameter_index == paramIndex.get())\n+                                    .map(anno -> make.TypeAnnotation(anno))\n+                                    .collect(List.collector())));\n+                    paramIndex.incrementAndGet();\n+                }\n+                return tparams.toList();\n+            }\n+\n@@ -1372,0 +1426,5 @@\n+\n+        @Override\n+        public JCMethodDecl methodDecl() {\n+            return methodDecl;\n+        }\n@@ -1439,0 +1498,1 @@\n+        JCMethodDecl result = helper.methodDecl();\n@@ -1452,1 +1512,6 @@\n-        JCMethodDecl result = make.MethodDef(initSym, make.Block(0, stats.toList()));\n+        if (result == null) {\n+            result = make.MethodDef(initSym, make.Block(0, stats.toList()));\n+        } else {\n+            result.body = make.Block(0, stats.toList());\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":80,"deletions":15,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -887,0 +887,11 @@\n+    \/\/ this version also copies the type annotations from the var symbol\n+    public JCVariableDecl VarDef(VarSymbol v, JCExpression typeDec, JCExpression init) {\n+        return (JCVariableDecl)\n+                new JCVariableDecl(\n+                        Modifiers(v.flags(), Annotations(v.getRawAttributes()).appendList(TypeAnnotations(v.getRawTypeAttributes()))),\n+                        v.name,\n+                        typeDec,\n+                        init,\n+                        v).setPos(pos).setType(v.type);\n+    }\n+\n@@ -899,0 +910,10 @@\n+    public List<JCAnnotation> TypeAnnotations(List<Attribute.TypeCompound> attributes) {\n+        if (attributes == null) return List.nil();\n+        ListBuffer<JCAnnotation> result = new ListBuffer<>();\n+        for (List<Attribute.TypeCompound> i = attributes; i.nonEmpty(); i=i.tail) {\n+            Attribute a = i.head;\n+            result.append(TypeAnnotation(a));\n+        }\n+        return result.toList();\n+    }\n+\n@@ -1033,0 +1054,16 @@\n+    \/\/ this version also copies the type annotations from the method symbol\n+    public JCMethodDecl MethodDef(List<JCVariableDecl> params, List<JCTypeParameter> typeParameters, MethodSymbol m, Type mtype, JCBlock body) {\n+        return (JCMethodDecl)\n+                new JCMethodDecl(\n+                        Modifiers(m.flags(), Annotations(m.getRawAttributes()).appendList(TypeAnnotations(m.getRawTypeAttributes()))),\n+                        m.name,\n+                        m.name != names.init ? Type(mtype.getReturnType()) : null,\n+                        typeParameters,\n+                        null, \/\/ receiver type\n+                        params,\n+                        Types(mtype.getThrownTypes()),\n+                        body,\n+                        null,\n+                        m).setPos(pos).setType(mtype);\n+    }\n+\n@@ -1036,2 +1073,8 @@\n-        return (JCTypeParameter)\n-            TypeParameter(name, Types(types.getBounds(tvar))).setPos(pos).setType(tvar);\n+        return TypeParam(name, tvar, null);\n+    }\n+\n+    public JCTypeParameter TypeParam(Name name, TypeVar tvar, List<JCAnnotation> annotations) {\n+        JCTypeParameter typeParameter = (JCTypeParameter)\n+                TypeParameter(name, Types(types.getBounds(tvar))).setPos(pos).setType(tvar);\n+        typeParameter.annotations = annotations;\n+        return typeParameter;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":45,"deletions":2,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8274617\n+ * @summary constructor and parameter annotations are not copied to the anonymous class constructor\n+ * @modules jdk.jdeps\/com.sun.tools.classfile\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @run main AnnosNotCopiedToAnonymousCtrTest\n+ *\/\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Target;\n+import java.io.BufferedInputStream;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import com.sun.tools.classfile.*;\n+import com.sun.tools.javac.util.Assert;\n+\n+public class AnnosNotCopiedToAnonymousCtrTest {\n+\n+    String[] typeAnnosInfo = new String[] {\n+        \"@AnnosNotCopiedToAnonymousCtrTest$TypeAnnoForTypeParams; pos: [METHOD_TYPE_PARAMETER, param_index = 0, pos = -1]\",\n+        \"@AnnosNotCopiedToAnonymousCtrTest$TypeAnnoForTypeParams2; pos: [METHOD_TYPE_PARAMETER, param_index = 1, pos = -1]\",\n+        \"@AnnosNotCopiedToAnonymousCtrTest$TypeAnno; pos: [METHOD_RETURN, location = ([INNER_TYPE, INNER_TYPE]), pos = -1]\",\n+        \"@AnnosNotCopiedToAnonymousCtrTest$TypeAnno; pos: [METHOD_FORMAL_PARAMETER, param_index = 1, pos = -1]\"\n+    };\n+\n+    public static void main(String[] args) throws Throwable {\n+        new AnnosNotCopiedToAnonymousCtrTest().run();\n+    }\n+\n+    void run() throws Throwable {\n+        checkClassFile(Paths.get(System.getProperty(\"test.classes\"),\n+                this.getClass().getSimpleName() + \"$Test$1.class\"));\n+    }\n+\n+    record DeclAnnoData(String attributeName, String annoName, int positionOfAnnotatedParam) {}\n+\n+    void checkClassFile(final Path cfilePath) throws Throwable {\n+        ClassFile classFile = ClassFile.read(\n+                new BufferedInputStream(Files.newInputStream(cfilePath)));\n+        for (Method method : classFile.methods) {\n+            if (method.getName(classFile.constant_pool).equals(\"<init>\")) {\n+                checkForDeclAnnos(classFile,\n+                        method.attributes,\n+                        \"Annotations hasn't been propagated\",\n+                        new DeclAnnoData(Attribute.RuntimeInvisibleAnnotations, \"LAnnosNotCopiedToAnonymousCtrTest$CtrAnnotation;\", -1),\n+                        new DeclAnnoData(Attribute.RuntimeInvisibleParameterAnnotations, \"LAnnosNotCopiedToAnonymousCtrTest$ParamAnnotation;\", 2) );\n+\n+                checkForTypeAnnos(method.attributes, typeAnnosInfo);\n+            }\n+        }\n+    }\n+\n+    void checkForDeclAnnos(ClassFile classFile, Attributes attrs, String errorMsg, DeclAnnoData... attrAndParamPos)\n+            throws Throwable {\n+        for (DeclAnnoData attrAndPos : attrAndParamPos) {\n+            Assert.checkNonNull(attrs.get(attrAndPos.attributeName()), errorMsg);\n+            boolean isParamAnno = attrs.get(attrAndPos.attributeName()) instanceof RuntimeParameterAnnotations_attribute;\n+            if (isParamAnno) {\n+                RuntimeParameterAnnotations_attribute paramAnnotation =\n+                        (RuntimeParameterAnnotations_attribute)attrs.get(attrAndPos.attributeName());\n+                for (int i = 0; i < paramAnnotation.parameter_annotations.length; i++) {\n+                    Annotation[] annos = paramAnnotation.parameter_annotations[i];\n+                    if (i != attrAndPos.positionOfAnnotatedParam()) {\n+                        Assert.check(annos.length == 0);\n+                    } else {\n+                        Assert.check(annos.length == 1);\n+                        Assert.check(classFile.constant_pool.getUTF8Value(annos[0].type_index).equals(attrAndPos.annoName()));\n+                    }\n+                }\n+            } else {\n+                RuntimeAnnotations_attribute ctrAnnotation = (RuntimeAnnotations_attribute)attrs.get(attrAndPos.attributeName());\n+                Assert.check(ctrAnnotation.annotations.length == 1);\n+                Assert.check(classFile.constant_pool.getUTF8Value(ctrAnnotation.annotations[0].type_index).equals(attrAndPos.annoName()));\n+            }\n+        }\n+    }\n+\n+    void checkForTypeAnnos(Attributes attrs, String... expectedInfo)\n+            throws Throwable {\n+        RuntimeTypeAnnotations_attribute typeAnnosAttr =\n+                (RuntimeTypeAnnotations_attribute) attrs.get(Attribute.RuntimeInvisibleTypeAnnotations);\n+        TypeAnnotation[] annos = typeAnnosAttr.annotations;\n+        Assert.check(annos.length == expectedInfo.length);\n+        for (int i = 0; i < expectedInfo.length; i++) {\n+            Assert.check(annos[i].toString().equals(expectedInfo[i]));\n+        }\n+    }\n+\n+    @Target(value = {ElementType.PARAMETER})\n+    @interface ParamAnnotation {}\n+\n+    @Target(value = {ElementType.CONSTRUCTOR})\n+    @interface CtrAnnotation {}\n+\n+    @Target({ElementType.TYPE_USE})\n+    @interface TypeAnno {}\n+\n+    @Target({ElementType.TYPE_PARAMETER})\n+    @interface TypeAnnoForTypeParams {}\n+\n+    @Target({ElementType.TYPE_PARAMETER})\n+    @interface TypeAnnoForTypeParams2 {}\n+\n+    class Test {\n+        @CtrAnnotation\n+        @TypeAnno\n+        <@TypeAnnoForTypeParams T, @TypeAnnoForTypeParams2 X> Test(String firstParam, @TypeAnno String secondParam, @ParamAnnotation String thirdParam) {}\n+\n+        public void m() {\n+            \/\/ let's create an anonymous inner class\n+            new Test(\"\", \"\", \"\") {};\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/annos_not_copied_anonymous_ctr\/AnnosNotCopiedToAnonymousCtrTest.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -98,0 +98,1 @@\n+                                \"java.base\/jdk.internal.vm.annotation\",\n","filename":"test\/langtools\/tools\/jdeps\/listdeps\/ListModuleDeps.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}