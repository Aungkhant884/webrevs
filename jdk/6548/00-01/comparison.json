{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -1260,0 +1261,1 @@\n+       default JCMethodDecl methodDecl() { return null; }\n@@ -1318,0 +1320,1 @@\n+        JCMethodDecl methodDecl;\n@@ -1341,4 +1344,4 @@\n-            boolean copyConstAnnos = constructorSymbol == null;\n-            MethodSymbol csym = super.constructorSymbol();\n-            csym.flags_field |= ANONCONSTR | (constr.flags() & VARARGS);\n-            csym.flags_field |= based ? ANONCONSTR_BASED : 0;\n+            if (constructorSymbol == null) {\n+                MethodSymbol csym = super.constructorSymbol();\n+                csym.flags_field |= ANONCONSTR | (constr.flags() & VARARGS);\n+                csym.flags_field |= based ? ANONCONSTR_BASED : 0;\n@@ -1346,2 +1349,0 @@\n-            ListBuffer<Attribute.Compound> paramAttrs;\n-            if (copyConstAnnos) {\n@@ -1349,1 +1350,3 @@\n-            }\n+                csym.appendUniqueTypeAttributes(constr.getRawTypeAttributes().stream()\n+                        .filter(anno -> anno.position.type == TargetType.METHOD_RETURN)\n+                        .collect(List.collector()));\n@@ -1351,11 +1354,3 @@\n-            ListBuffer<VarSymbol> params = new ListBuffer<>();\n-            List<Type> argtypes = constructorType().getParameterTypes();\n-            if (!enclosingType().hasTag(NONE)) {\n-                argtypes = argtypes.tail;\n-                params = params.prepend(new VarSymbol(PARAMETER, make.paramName(0), enclosingType(), csym));\n-            }\n-            if (constr.params != null) {\n-                for (VarSymbol p : constr.params) {\n-                    VarSymbol param = new VarSymbol(PARAMETER | p.flags(), p.name, argtypes.head, csym);\n-                    param.appendAttributes(p.getRawAttributes());\n-                    params.add(param);\n+                ListBuffer<VarSymbol> params = new ListBuffer<>();\n+                List<Type> argtypes = constructorType().getParameterTypes();\n+                if (!enclosingType().hasTag(NONE)) {\n@@ -1363,0 +1358,1 @@\n+                    params = params.prepend(new VarSymbol(PARAMETER, make.paramName(0), enclosingType(), csym));\n@@ -1364,0 +1360,15 @@\n+                if (constr.params != null) {\n+                    for (VarSymbol p : constr.params) {\n+                        VarSymbol param = new VarSymbol(PARAMETER | p.flags(), p.name, argtypes.head, csym);\n+                        param.appendAttributes(p.getRawAttributes());\n+                        param.appendUniqueTypeAttributes(p.getRawTypeAttributes());\n+                        params.add(param);\n+                        argtypes = argtypes.tail;\n+                    }\n+                }\n+                csym.params = params.toList();\n+\n+                \/\/ now lets create the tree to make sure that it is created according to our needs\n+                methodDecl = make.MethodDef(constrParams(csym),\n+                        typeParams(csym.type.getTypeArguments()), csym, csym.type, null);\n+                return csym;\n@@ -1365,2 +1376,1 @@\n-            csym.params = params.toList();\n-            return csym;\n+            return constructorSymbol;\n@@ -1369,0 +1379,34 @@\n+        \/\/ helper methods\n+            private List<JCVariableDecl> constrParams(MethodSymbol csym) {\n+                ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n+                if (csym.params != null) {\n+                    for (VarSymbol param : csym.params) {\n+                        \/* the compiler will issue an error if a type annotation is applied to, for example, `java.lang.String`\n+                         * but it won't if the type annotation is applied to `String`, at this point all types will be represented\n+                         * in its fully unfolded form so we need to go back to the short form if type annotations are present for a\n+                         * given parameter\n+                         *\/\n+                        if (!param.getRawTypeAttributes().isEmpty()) {\n+                            params.append(make.VarDef(param, make.Ident(param.type.tsym), null));\n+                        } else {\n+                            params.append(make.VarDef(param,null));\n+                        }\n+                    }\n+                }\n+                return params.toList();\n+            }\n+\n+            private List<JCTypeParameter> typeParams(List<Type> typarams) {\n+                ListBuffer<JCTypeParameter> tparams = new ListBuffer<>();\n+                final AtomicInteger paramIndex = new AtomicInteger(0);\n+                for (List<Type> l = typarams; l.nonEmpty(); l = l.tail) {\n+                    tparams.append(make.TypeParam(l.head.tsym.name, (TypeVar) l.head,\n+                            constr.getRawTypeAttributes().stream()\n+                                    .filter(anno -> anno.position.type == TargetType.METHOD_TYPE_PARAMETER && anno.position.parameter_index == paramIndex.get())\n+                                    .map(anno -> make.TypeAnnotation(anno))\n+                                    .collect(List.collector())));\n+                    paramIndex.incrementAndGet();\n+                }\n+                return tparams.toList();\n+            }\n+\n@@ -1382,0 +1426,5 @@\n+\n+        @Override\n+        public JCMethodDecl methodDecl() {\n+            return methodDecl;\n+        }\n@@ -1449,0 +1498,1 @@\n+        JCMethodDecl result = helper.methodDecl();\n@@ -1462,1 +1512,6 @@\n-        JCMethodDecl result = make.MethodDef(initSym, make.Block(0, stats.toList()));\n+        if (result == null) {\n+            result = make.MethodDef(initSym, make.Block(0, stats.toList()));\n+        } else {\n+            result.body = make.Block(0, stats.toList());\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":76,"deletions":21,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -887,0 +887,11 @@\n+    \/\/ this version also copies the type annotations from the var symbol\n+    public JCVariableDecl VarDef(VarSymbol v, JCExpression typeDec, JCExpression init) {\n+        return (JCVariableDecl)\n+                new JCVariableDecl(\n+                        Modifiers(v.flags(), Annotations(v.getRawAttributes()).appendList(TypeAnnotations(v.getRawTypeAttributes()))),\n+                        v.name,\n+                        typeDec,\n+                        init,\n+                        v).setPos(pos).setType(v.type);\n+    }\n+\n@@ -899,0 +910,10 @@\n+    public List<JCAnnotation> TypeAnnotations(List<Attribute.TypeCompound> attributes) {\n+        if (attributes == null) return List.nil();\n+        ListBuffer<JCAnnotation> result = new ListBuffer<>();\n+        for (List<Attribute.TypeCompound> i = attributes; i.nonEmpty(); i=i.tail) {\n+            Attribute a = i.head;\n+            result.append(TypeAnnotation(a));\n+        }\n+        return result.toList();\n+    }\n+\n@@ -1033,0 +1054,16 @@\n+    \/\/ this version also copies the type annotations from the method symbol\n+    public JCMethodDecl MethodDef(List<JCVariableDecl> params, List<JCTypeParameter> typeParameters, MethodSymbol m, Type mtype, JCBlock body) {\n+        return (JCMethodDecl)\n+                new JCMethodDecl(\n+                        Modifiers(m.flags(), Annotations(m.getRawAttributes()).appendList(TypeAnnotations(m.getRawTypeAttributes()))),\n+                        m.name,\n+                        m.name != names.init ? Type(mtype.getReturnType()) : null,\n+                        typeParameters,\n+                        null, \/\/ receiver type\n+                        params,\n+                        Types(mtype.getThrownTypes()),\n+                        body,\n+                        null,\n+                        m).setPos(pos).setType(mtype);\n+    }\n+\n@@ -1036,2 +1073,8 @@\n-        return (JCTypeParameter)\n-            TypeParameter(name, Types(types.getBounds(tvar))).setPos(pos).setType(tvar);\n+        return TypeParam(name, tvar, null);\n+    }\n+\n+    public JCTypeParameter TypeParam(Name name, TypeVar tvar, List<JCAnnotation> annotations) {\n+        JCTypeParameter typeParameter = (JCTypeParameter)\n+                TypeParameter(name, Types(types.getBounds(tvar))).setPos(pos).setType(tvar);\n+        typeParameter.annotations = annotations;\n+        return typeParameter;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":45,"deletions":2,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -47,0 +47,7 @@\n+    String[] typeAnnosInfo = new String[] {\n+        \"@AnnosNotCopiedToAnonymousCtrTest$TypeAnnoForTypeParams; pos: [METHOD_TYPE_PARAMETER, param_index = 0, pos = -1]\",\n+        \"@AnnosNotCopiedToAnonymousCtrTest$TypeAnnoForTypeParams2; pos: [METHOD_TYPE_PARAMETER, param_index = 1, pos = -1]\",\n+        \"@AnnosNotCopiedToAnonymousCtrTest$TypeAnno; pos: [METHOD_RETURN, location = ([INNER_TYPE, INNER_TYPE]), pos = -1]\",\n+        \"@AnnosNotCopiedToAnonymousCtrTest$TypeAnno; pos: [METHOD_FORMAL_PARAMETER, param_index = 1, pos = -1]\"\n+    };\n+\n@@ -56,1 +63,1 @@\n-    record AnnoData(String attributeName, String annoName, int positionOfAnnotatedParam) {}\n+    record DeclAnnoData(String attributeName, String annoName, int positionOfAnnotatedParam) {}\n@@ -63,1 +70,1 @@\n-                checkForAttr(classFile,\n+                checkForDeclAnnos(classFile,\n@@ -66,4 +73,4 @@\n-                        new AnnoData(Attribute.RuntimeVisibleAnnotations, \"LAnnosNotCopiedToAnonymousCtrTest$VisibleCtrAnnotation;\", -1),\n-                        new AnnoData(Attribute.RuntimeInvisibleAnnotations, \"LAnnosNotCopiedToAnonymousCtrTest$InvisibleCtrAnnotation;\", -1),\n-                        new AnnoData(Attribute.RuntimeVisibleParameterAnnotations, \"LAnnosNotCopiedToAnonymousCtrTest$VisibleParamAnnotation;\", 1),\n-                        new AnnoData(Attribute.RuntimeInvisibleParameterAnnotations, \"LAnnosNotCopiedToAnonymousCtrTest$InvisibleParamAnnotation;\", 2) );\n+                        new DeclAnnoData(Attribute.RuntimeInvisibleAnnotations, \"LAnnosNotCopiedToAnonymousCtrTest$CtrAnnotation;\", -1),\n+                        new DeclAnnoData(Attribute.RuntimeInvisibleParameterAnnotations, \"LAnnosNotCopiedToAnonymousCtrTest$ParamAnnotation;\", 2) );\n+\n+                checkForTypeAnnos(method.attributes, typeAnnosInfo);\n@@ -74,1 +81,1 @@\n-    void checkForAttr(ClassFile classFile, Attributes attrs, String errorMsg, AnnoData... attrAndParamPos)\n+    void checkForDeclAnnos(ClassFile classFile, Attributes attrs, String errorMsg, DeclAnnoData... attrAndParamPos)\n@@ -76,1 +83,1 @@\n-        for (AnnoData attrAndPos : attrAndParamPos) {\n+        for (DeclAnnoData attrAndPos : attrAndParamPos) {\n@@ -99,3 +106,10 @@\n-    @Target(value = {ElementType.PARAMETER})\n-    @Retention(RetentionPolicy.RUNTIME)\n-    @interface VisibleParamAnnotation {}\n+    void checkForTypeAnnos(Attributes attrs, String... expectedInfo)\n+            throws Throwable {\n+        RuntimeTypeAnnotations_attribute typeAnnosAttr =\n+                (RuntimeTypeAnnotations_attribute) attrs.get(Attribute.RuntimeInvisibleTypeAnnotations);\n+        TypeAnnotation[] annos = typeAnnosAttr.annotations;\n+        Assert.check(annos.length == expectedInfo.length);\n+        for (int i = 0; i < expectedInfo.length; i++) {\n+            Assert.check(annos[i].toString().equals(expectedInfo[i]));\n+        }\n+    }\n@@ -104,1 +118,1 @@\n-    @interface InvisibleParamAnnotation {}\n+    @interface ParamAnnotation {}\n@@ -107,2 +121,1 @@\n-    @Retention(RetentionPolicy.RUNTIME)\n-    @interface VisibleCtrAnnotation {}\n+    @interface CtrAnnotation {}\n@@ -110,2 +123,8 @@\n-    @Target(value = {ElementType.CONSTRUCTOR})\n-    @interface InvisibleCtrAnnotation {}\n+    @Target({ElementType.TYPE_USE})\n+    @interface TypeAnno {}\n+\n+    @Target({ElementType.TYPE_PARAMETER})\n+    @interface TypeAnnoForTypeParams {}\n+\n+    @Target({ElementType.TYPE_PARAMETER})\n+    @interface TypeAnnoForTypeParams2 {}\n@@ -113,4 +132,4 @@\n-    public class Test {\n-        @VisibleCtrAnnotation\n-        @InvisibleCtrAnnotation\n-        public Test(String firstParam, @VisibleParamAnnotation String secondParam, @InvisibleParamAnnotation String thirdParam) {}\n+    class Test {\n+        @CtrAnnotation\n+        @TypeAnno\n+        <@TypeAnnoForTypeParams T, @TypeAnnoForTypeParams2 X> Test(String firstParam, @TypeAnno String secondParam, @ParamAnnotation String thirdParam) {}\n","filename":"test\/langtools\/tools\/javac\/annos_not_copied_anonymous_ctr\/AnnosNotCopiedToAnonymousCtrTest.java","additions":39,"deletions":20,"binary":false,"changes":59,"status":"modified"}]}