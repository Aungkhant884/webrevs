{"files":[{"patch":"@@ -2008,1 +2008,3 @@\n-    if (CanUseSafeFetch32()) {\n+    const bool read_protected =\n+      (SafeFetch32((int*)addr, 0x12345678) == 0x12345678 &&\n+       SafeFetch32((int*)addr, 0x76543210) == 0x76543210) ? true : false;\n@@ -2010,9 +2012,5 @@\n-      const bool read_protected =\n-        (SafeFetch32((int*)addr, 0x12345678) == 0x12345678 &&\n-         SafeFetch32((int*)addr, 0x76543210) == 0x76543210) ? true : false;\n-\n-      if (prot & PROT_READ) {\n-        rc = !read_protected;\n-      } else {\n-        rc = read_protected;\n-      }\n+    if (prot & PROT_READ) {\n+      rc = !read_protected;\n+    } else {\n+      rc = read_protected;\n+    }\n@@ -2020,18 +2018,17 @@\n-      if (!rc) {\n-        if (os::Aix::on_pase()) {\n-          \/\/ There is an issue on older PASE systems where mprotect() will return success but the\n-          \/\/ memory will not be protected.\n-          \/\/ This has nothing to do with the problem of using mproect() on SPEC1170 incompatible\n-          \/\/ machines; we only see it rarely, when using mprotect() to protect the guard page of\n-          \/\/ a stack. It is an OS error.\n-          \/\/\n-          \/\/ A valid strategy is just to try again. This usually works. :-\/\n-\n-          ::usleep(1000);\n-          Events::log(NULL, \"Protecting memory [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] with protection modes %x\", p2i(addr), p2i(addr+size), prot);\n-          if (::mprotect(addr, size, prot) == 0) {\n-            const bool read_protected_2 =\n-              (SafeFetch32((int*)addr, 0x12345678) == 0x12345678 &&\n-              SafeFetch32((int*)addr, 0x76543210) == 0x76543210) ? true : false;\n-            rc = true;\n-          }\n+    if (!rc) {\n+      if (os::Aix::on_pase()) {\n+        \/\/ There is an issue on older PASE systems where mprotect() will return success but the\n+        \/\/ memory will not be protected.\n+        \/\/ This has nothing to do with the problem of using mproect() on SPEC1170 incompatible\n+        \/\/ machines; we only see it rarely, when using mprotect() to protect the guard page of\n+        \/\/ a stack. It is an OS error.\n+        \/\/\n+        \/\/ A valid strategy is just to try again. This usually works. :-\/\n+\n+        ::usleep(1000);\n+        Events::log(NULL, \"Protecting memory [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] with protection modes %x\", p2i(addr), p2i(addr+size), prot);\n+        if (::mprotect(addr, size, prot) == 0) {\n+          const bool read_protected_2 =\n+            (SafeFetch32((int*)addr, 0x12345678) == 0x12345678 &&\n+            SafeFetch32((int*)addr, 0x76543210) == 0x76543210) ? true : false;\n+          rc = true;\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":25,"deletions":28,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-\/\/ (Note: We would prefer compiler level TLS but for some reason __thread does not\n-\/\/  work here; this needs investigation. For we now stick with POSIX TLS)\n@@ -56,0 +54,3 @@\n+    \/\/ Note signal safety: pthread_getspecific is not safe for signal handler\n+    \/\/ usage, but in practice it works and we have done this in the JVM for many\n+    \/\/ years (via Thread::current_or_null_safe()).\n@@ -58,2 +59,0 @@\n-      \/\/ Reset TLS slot and jump back\n-      pthread_setspecific(g_jmpbuf_key, NULL);\n@@ -76,1 +75,2 @@\n-    \/\/ We faulted.\n+    \/\/ We faulted. Reset TLS slot, then return.\n+    pthread_setspecific(g_jmpbuf_key, NULL);\n@@ -88,3 +88,1 @@\n-  *result = n;\n-\n-  \/\/ Reset the TLS slot\n+  \/\/ Reset TLS slot, then return result.\n@@ -92,0 +90,1 @@\n+  *result = n;\n","filename":"src\/hotspot\/os\/posix\/safefetch_sigjmp.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n-#ifndef CPU_POSIX_SAFEFETCH_SIGJMP_HPP\n-#define CPU_POSIX_SAFEFETCH_SIGJMP_HPP\n+#ifndef OS_POSIX_SAFEFETCH_SIGJMP_HPP\n+#define OS_POSIX_SAFEFETCH_SIGJMP_HPP\n@@ -39,3 +39,0 @@\n-inline bool CanUseSafeFetch32() { return true; }\n-inline bool CanUseSafeFetchN()  { return true; }\n-\n@@ -47,1 +44,1 @@\n-#endif \/\/ CPU_POSIX_SAFEFETCH_SIGJMP_HPP\n+#endif \/\/ OS_POSIX_SAFEFETCH_SIGJMP_HPP\n","filename":"src\/hotspot\/os\/posix\/safefetch_sigjmp.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"","filename":"src\/hotspot\/os\/posix\/safefetch_static_posix.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/hotspot\/share\/runtime\/safefetch_static.cpp","status":"renamed"},{"patch":"@@ -614,1 +614,0 @@\n-#if defined(SAFEFETCH_METHOD_STATIC_ASSEMBLY) || defined(SAFEFETCH_METHOD_SIGSETJMP)\n@@ -618,1 +617,0 @@\n-#endif \/\/ SAFEFETCH_xxx handling\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,2 +78,1 @@\n-#if defined(SAFEFETCH_METHOD_STATIC_ASSEMBLY) || defined(SAFEFETCH_METHOD_SIGSETJMP)\n-  \/\/ Handle safefetch here too, to be able to use SafeFetc() inside the error handler\n+  \/\/ Handle safefetch here too, to be able to use SafeFetch() inside the error handler\n@@ -83,1 +82,0 @@\n-#endif \/\/ SAFEFETCH_xxx handling\n","filename":"src\/hotspot\/os\/posix\/vmError_posix.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,2 +45,3 @@\n-inline int SafeFetch32(const int* adr, int errValue)                { return SafeFetchXX<int>(adr, errValue); }\n-inline intptr_t SafeFetchN(const intptr_t* adr, intptr_t errValue)  { return SafeFetchXX<intptr_t>(adr, errValue); }\n+inline int SafeFetch32(const int* adr, int errValue) {\n+  return SafeFetchXX<int>(adr, errValue);\n+}\n@@ -48,2 +49,3 @@\n-inline bool CanUseSafeFetch32() { return true; }\n-inline bool CanUseSafeFetchN()  { return true; }\n+inline intptr_t SafeFetchN(const intptr_t* adr, intptr_t errValue) {\n+  return SafeFetchXX<intptr_t>(adr, errValue);\n+}\n","filename":"src\/hotspot\/os\/windows\/safefetch_windows.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -52,1 +52,2 @@\n-    ldr      w1, [x0]\n+    ldr      w0, [x0]\n+    ret\n@@ -66,1 +67,2 @@\n-    ldr      x1, [x0]\n+    ldr      x0, [x0]\n+    ret\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/safefetch_bsd_aarch64.S","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,1 +39,2 @@\n-    ldr      w1, [x0]\n+    ldr      w0, [x0]\n+    ret\n@@ -50,1 +51,2 @@\n-    ldr      x1, [x0]\n+    ldr      x0, [x0]\n+    ret\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/safefetch_linux_aarch64.S","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n-    ldr      r1, [r0]\n+    ldr      r0, [r0]\n+    bx       lr\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/safefetch_linux_arm.S","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,2 @@\n-    lwa      %r4, 0(%r3)\n+    lwa      %r3, 0(%r3)\n+    blr\n@@ -52,1 +53,2 @@\n-    ld     %r4, 0(%r3)\n+    ld     %r3, 0(%r3)\n+    blr\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/safefetch_linux_ppc.S","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,3 +35,3 @@\n-    #  x10 : address\n-    #  x11 : defaultval\n-    #  x10 : retval\n+    #  x10 (a0) : address\n+    #  x11 (a1) : defaultval\n+    #  x10 (a0) : retval\n@@ -40,1 +40,2 @@\n-    lw       x11, 0(x10)\n+    lw       a0, 0(a0)\n+    ret\n@@ -42,1 +43,1 @@\n-    mv       x10, x11\n+    mv       a0, a1\n@@ -47,3 +48,3 @@\n-    #  x10 : address\n-    #  x11 : defaultval\n-    #  x10 : retval\n+    #  x10 (a0) : address\n+    #  x11 (a1) : defaultval\n+    #  x10 (a0) : retval\n@@ -52,1 +53,2 @@\n-    ld       x11, 0(x10)\n+    ld       a0, 0(a0)\n+    ret\n@@ -54,1 +56,1 @@\n-    mv       x10, x11\n+    mv       a0, a1\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/safefetch_linux_riscv.S","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -40,1 +40,2 @@\n-    lgf      %r3, 0(%r2)\n+    lgf      %r2, 0(%r2)\n+    br       %r14\n@@ -52,1 +53,2 @@\n-    lg       %r3, 0(%r2)\n+    lg       %r2, 0(%r2)\n+    br       %r14\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/safefetch_linux_s390.S","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -303,1 +303,0 @@\n-  assert(CanUseSafeFetchN(), \"precondition\");\n@@ -369,1 +368,0 @@\n-  assert(CanUseSafeFetchN(), \"precondition\");\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1050,3 +1050,0 @@\n-  if (!CanUseSafeFetch32()) {\n-    return SAFEFETCH_DEFAULT;\n-  }\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -299,4 +299,0 @@\n-  \/\/ The largest possible standard page size (sysconf(_SC_PAGESIZE)) across all our\n-  \/\/ platforms, usable as a compile-time constant.\n-  static const size_t max_page_size_crossplatform = 64 * K; \/\/ ppc has 64 K pages.\n-\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"utilities\/macros.hpp\"\n+\n@@ -32,1 +34,0 @@\n-  #define SAFEFETCH_METHOD_SEH\n","filename":"src\/hotspot\/share\/runtime\/safefetch.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-inline bool CanUseSafeFetch32() { return true; }\n-inline bool CanUseSafeFetchN()  { return true; }\n","filename":"src\/hotspot\/share\/runtime\/safefetch_static.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -296,1 +296,1 @@\n-  if (CanUseSafeFetch32() && os::is_readable_pointer(p)) {\n+  if (os::is_readable_pointer(p)) {\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -589,10 +589,6 @@\n-      if (CanUseSafeFetch32()) {\n-        int* const invalid_pointer = (int*)segfault_address;\n-        const int x = 0x76543210;\n-        int i1 = SafeFetch32(invalid_pointer, x);\n-        int i2 = SafeFetch32(invalid_pointer, x);\n-        if (i1 == x && i2 == x) {\n-          st->print_cr(\"SafeFetch OK.\"); \/\/ Correctly deflected and returned default pattern\n-        } else {\n-          st->print_cr(\"??\");\n-        }\n+      int* const invalid_pointer = (int*)segfault_address;\n+      const int x = 0x76543210;\n+      int i1 = SafeFetch32(invalid_pointer, x);\n+      int i2 = SafeFetch32(invalid_pointer, x);\n+      if (i1 == x && i2 == x) {\n+        st->print_cr(\"SafeFetch OK.\"); \/\/ Correctly deflected and returned default pattern\n@@ -600,1 +596,1 @@\n-        st->print_cr(\"not possible; skipped.\");\n+        st->print_cr(\"??\");\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"}]}