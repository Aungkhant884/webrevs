{"files":[{"patch":"@@ -3989,40 +3989,0 @@\n-  \/\/ Safefetch stubs.\n-  void generate_safefetch(const char* name, int size, address* entry,\n-                          address* fault_pc, address* continuation_pc) {\n-    \/\/ safefetch signatures:\n-    \/\/   int      SafeFetch32(int*      adr, int      errValue);\n-    \/\/   intptr_t SafeFetchN (intptr_t* adr, intptr_t errValue);\n-    \/\/\n-    \/\/ arguments:\n-    \/\/   c_rarg0 = adr\n-    \/\/   c_rarg1 = errValue\n-    \/\/\n-    \/\/ result:\n-    \/\/   PPC_RET  = *adr or errValue\n-\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n-\n-    \/\/ Entry point, pc or function descriptor.\n-    *entry = __ pc();\n-\n-    \/\/ Load *adr into c_rarg1, may fault.\n-    *fault_pc = __ pc();\n-    switch (size) {\n-      case 4:\n-        \/\/ int32_t\n-        __ ldrw(c_rarg1, Address(c_rarg0, 0));\n-        break;\n-      case 8:\n-        \/\/ int64_t\n-        __ ldr(c_rarg1, Address(c_rarg0, 0));\n-        break;\n-      default:\n-        ShouldNotReachHere();\n-    }\n-\n-    \/\/ return errValue or *adr\n-    *continuation_pc = __ pc();\n-    __ mov(r0, c_rarg1);\n-    __ ret(lr);\n-  }\n-\n@@ -7491,8 +7451,0 @@\n-\n-    \/\/ Safefetch stubs.\n-    generate_safefetch(\"SafeFetch32\", sizeof(int),     &StubRoutines::_safefetch32_entry,\n-                                                       &StubRoutines::_safefetch32_fault_pc,\n-                                                       &StubRoutines::_safefetch32_continuation_pc);\n-    generate_safefetch(\"SafeFetchN\", sizeof(intptr_t), &StubRoutines::_safefetchN_entry,\n-                                                       &StubRoutines::_safefetchN_fault_pc,\n-                                                       &StubRoutines::_safefetchN_continuation_pc);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":0,"deletions":48,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2840,40 +2840,0 @@\n-  \/\/ Safefetch stubs.\n-  void generate_safefetch(const char* name, int size, address* entry, address* fault_pc, address* continuation_pc) {\n-    \/\/ safefetch signatures:\n-    \/\/   int      SafeFetch32(int*      adr, int      errValue);\n-    \/\/   intptr_t SafeFetchN (intptr_t* adr, intptr_t errValue);\n-    \/\/\n-    \/\/ arguments:\n-    \/\/   R0 = adr\n-    \/\/   R1 = errValue\n-    \/\/\n-    \/\/ result:\n-    \/\/   R0  = *adr or errValue\n-\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n-\n-    \/\/ Entry point, pc or function descriptor.\n-    *entry = __ pc();\n-\n-    \/\/ Load *adr into c_rarg2, may fault.\n-    *fault_pc = __ pc();\n-\n-    switch (size) {\n-      case 4: \/\/ int32_t\n-        __ ldr_s32(R1, Address(R0));\n-        break;\n-\n-      case 8: \/\/ int64_t\n-        Unimplemented();\n-        break;\n-\n-      default:\n-        ShouldNotReachHere();\n-    }\n-\n-    \/\/ return errValue or *adr\n-    *continuation_pc = __ pc();\n-    __ mov(R0, R1);\n-    __ ret();\n-  }\n-\n@@ -3032,8 +2992,0 @@\n-    \/\/ Safefetch stubs.\n-    generate_safefetch(\"SafeFetch32\", sizeof(int), &StubRoutines::_safefetch32_entry,\n-                                                   &StubRoutines::_safefetch32_fault_pc,\n-                                                   &StubRoutines::_safefetch32_continuation_pc);\n-    assert (sizeof(int) == wordSize, \"32-bit architecture\");\n-    StubRoutines::_safefetchN_entry           = StubRoutines::_safefetch32_entry;\n-    StubRoutines::_safefetchN_fault_pc        = StubRoutines::_safefetch32_fault_pc;\n-    StubRoutines::_safefetchN_continuation_pc = StubRoutines::_safefetch32_continuation_pc;\n@@ -3042,0 +2994,1 @@\n+\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":1,"deletions":48,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -3162,39 +3162,0 @@\n-  \/\/ Safefetch stubs.\n-  void generate_safefetch(const char* name, int size, address* entry, address* fault_pc, address* continuation_pc) {\n-    \/\/ safefetch signatures:\n-    \/\/   int      SafeFetch32(int*      adr, int      errValue);\n-    \/\/   intptr_t SafeFetchN (intptr_t* adr, intptr_t errValue);\n-    \/\/\n-    \/\/ arguments:\n-    \/\/   R3_ARG1 = adr\n-    \/\/   R4_ARG2 = errValue\n-    \/\/\n-    \/\/ result:\n-    \/\/   R3_RET  = *adr or errValue\n-\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n-\n-    \/\/ Entry point, pc or function descriptor.\n-    *entry = __ function_entry();\n-\n-    \/\/ Load *adr into R4_ARG2, may fault.\n-    *fault_pc = __ pc();\n-    switch (size) {\n-      case 4:\n-        \/\/ int32_t, signed extended\n-        __ lwa(R4_ARG2, 0, R3_ARG1);\n-        break;\n-      case 8:\n-        \/\/ int64_t\n-        __ ld(R4_ARG2, 0, R3_ARG1);\n-        break;\n-      default:\n-        ShouldNotReachHere();\n-    }\n-\n-    \/\/ return errValue or *adr\n-    *continuation_pc = __ pc();\n-    __ mr(R3_RET, R4_ARG2);\n-    __ blr();\n-  }\n-\n@@ -4576,8 +4537,0 @@\n-\n-    \/\/ Safefetch stubs.\n-    generate_safefetch(\"SafeFetch32\", sizeof(int),     &StubRoutines::_safefetch32_entry,\n-                                                       &StubRoutines::_safefetch32_fault_pc,\n-                                                       &StubRoutines::_safefetch32_continuation_pc);\n-    generate_safefetch(\"SafeFetchN\", sizeof(intptr_t), &StubRoutines::_safefetchN_entry,\n-                                                       &StubRoutines::_safefetchN_fault_pc,\n-                                                       &StubRoutines::_safefetchN_continuation_pc);\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":0,"deletions":47,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2199,40 +2199,0 @@\n-  \/\/ Safefetch stubs.\n-  void generate_safefetch(const char* name, int size, address* entry,\n-                          address* fault_pc, address* continuation_pc) {\n-    \/\/ safefetch signatures:\n-    \/\/   int      SafeFetch32(int*      adr, int      errValue)\n-    \/\/   intptr_t SafeFetchN (intptr_t* adr, intptr_t errValue)\n-    \/\/\n-    \/\/ arguments:\n-    \/\/   c_rarg0 = adr\n-    \/\/   c_rarg1 = errValue\n-    \/\/\n-    \/\/ result:\n-    \/\/   PPC_RET  = *adr or errValue\n-    assert_cond(entry != NULL && fault_pc != NULL && continuation_pc != NULL);\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n-\n-    \/\/ Entry point, pc or function descriptor.\n-    *entry = __ pc();\n-\n-    \/\/ Load *adr into c_rarg1, may fault.\n-    *fault_pc = __ pc();\n-    switch (size) {\n-      case 4:\n-        \/\/ int32_t\n-        __ lw(c_rarg1, Address(c_rarg0, 0));\n-        break;\n-      case 8:\n-        \/\/ int64_t\n-        __ ld(c_rarg1, Address(c_rarg0, 0));\n-        break;\n-      default:\n-        ShouldNotReachHere();\n-    }\n-\n-    \/\/ return errValue or *adr\n-    *continuation_pc = __ pc();\n-    __ mv(x10, c_rarg1);\n-    __ ret();\n-  }\n-\n@@ -3770,7 +3730,0 @@\n-    \/\/ Safefetch stubs.\n-    generate_safefetch(\"SafeFetch32\", sizeof(int),     &StubRoutines::_safefetch32_entry,\n-                                                       &StubRoutines::_safefetch32_fault_pc,\n-                                                       &StubRoutines::_safefetch32_continuation_pc);\n-    generate_safefetch(\"SafeFetchN\", sizeof(intptr_t), &StubRoutines::_safefetchN_entry,\n-                                                       &StubRoutines::_safefetchN_fault_pc,\n-                                                       &StubRoutines::_safefetchN_continuation_pc);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":0,"deletions":47,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -1461,38 +1461,0 @@\n-  void generate_safefetch(const char* name, int size, address* entry, address* fault_pc, address* continuation_pc) {\n-\n-    \/\/ safefetch signatures:\n-    \/\/   int      SafeFetch32(int*      adr, int      errValue);\n-    \/\/   intptr_t SafeFetchN (intptr_t* adr, intptr_t errValue);\n-    \/\/\n-    \/\/ arguments:\n-    \/\/   Z_ARG1 = adr\n-    \/\/   Z_ARG2 = errValue\n-    \/\/\n-    \/\/ result:\n-    \/\/   Z_RET  = *adr or errValue\n-\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n-\n-    \/\/ entry point\n-    \/\/ Load *adr into Z_ARG2, may fault.\n-    *entry = *fault_pc = __ pc();\n-    switch (size) {\n-      case 4:\n-        \/\/ Sign extended int32_t.\n-        __ z_lgf(Z_ARG2, 0, Z_ARG1);\n-        break;\n-      case 8:\n-        \/\/ int64_t\n-        __ z_lg(Z_ARG2, 0, Z_ARG1);\n-        break;\n-      default:\n-        ShouldNotReachHere();\n-    }\n-\n-    \/\/ Return errValue or *adr.\n-    *continuation_pc = __ pc();\n-    __ z_lgr(Z_RET, Z_ARG2);\n-    __ z_br(Z_R14);\n-\n-  }\n-\n@@ -2341,4 +2303,0 @@\n-\n-    \/\/ safefetch stubs\n-    generate_safefetch(\"SafeFetch32\", sizeof(int),      &StubRoutines::_safefetch32_entry, &StubRoutines::_safefetch32_fault_pc, &StubRoutines::_safefetch32_continuation_pc);\n-    generate_safefetch(\"SafeFetchN\",  sizeof(intptr_t), &StubRoutines::_safefetchN_entry,  &StubRoutines::_safefetchN_fault_pc,  &StubRoutines::_safefetchN_continuation_pc);\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -3656,34 +3656,0 @@\n-  \/\/ Safefetch stubs.\n-  void generate_safefetch(const char* name, int size, address* entry,\n-                          address* fault_pc, address* continuation_pc) {\n-    \/\/ safefetch signatures:\n-    \/\/   int      SafeFetch32(int*      adr, int      errValue);\n-    \/\/   intptr_t SafeFetchN (intptr_t* adr, intptr_t errValue);\n-\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n-\n-    \/\/ Entry point, pc or function descriptor.\n-    *entry = __ pc();\n-\n-    __ movl(rax, Address(rsp, 0x8));\n-    __ movl(rcx, Address(rsp, 0x4));\n-    \/\/ Load *adr into eax, may fault.\n-    *fault_pc = __ pc();\n-    switch (size) {\n-      case 4:\n-        \/\/ int32_t\n-        __ movl(rax, Address(rcx, 0));\n-        break;\n-      case 8:\n-        \/\/ int64_t\n-        Unimplemented();\n-        break;\n-      default:\n-        ShouldNotReachHere();\n-    }\n-\n-    \/\/ Return errValue or *adr.\n-    *continuation_pc = __ pc();\n-    __ ret(0);\n-  }\n-\n@@ -3988,8 +3954,0 @@\n-\n-    \/\/ Safefetch stubs.\n-    generate_safefetch(\"SafeFetch32\", sizeof(int), &StubRoutines::_safefetch32_entry,\n-                                                   &StubRoutines::_safefetch32_fault_pc,\n-                                                   &StubRoutines::_safefetch32_continuation_pc);\n-    StubRoutines::_safefetchN_entry           = StubRoutines::_safefetch32_entry;\n-    StubRoutines::_safefetchN_fault_pc        = StubRoutines::_safefetch32_fault_pc;\n-    StubRoutines::_safefetchN_continuation_pc = StubRoutines::_safefetch32_continuation_pc;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -3839,40 +3839,0 @@\n-  \/\/ Safefetch stubs.\n-  void generate_safefetch(const char* name, int size, address* entry,\n-                          address* fault_pc, address* continuation_pc) {\n-    \/\/ safefetch signatures:\n-    \/\/   int      SafeFetch32(int*      adr, int      errValue);\n-    \/\/   intptr_t SafeFetchN (intptr_t* adr, intptr_t errValue);\n-    \/\/\n-    \/\/ arguments:\n-    \/\/   c_rarg0 = adr\n-    \/\/   c_rarg1 = errValue\n-    \/\/\n-    \/\/ result:\n-    \/\/   PPC_RET  = *adr or errValue\n-\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n-\n-    \/\/ Entry point, pc or function descriptor.\n-    *entry = __ pc();\n-\n-    \/\/ Load *adr into c_rarg1, may fault.\n-    *fault_pc = __ pc();\n-    switch (size) {\n-      case 4:\n-        \/\/ int32_t\n-        __ movl(c_rarg1, Address(c_rarg0, 0));\n-        break;\n-      case 8:\n-        \/\/ int64_t\n-        __ movq(c_rarg1, Address(c_rarg0, 0));\n-        break;\n-      default:\n-        ShouldNotReachHere();\n-    }\n-\n-    \/\/ return errValue or *adr\n-    *continuation_pc = __ pc();\n-    __ movq(rax, c_rarg1);\n-    __ ret(0);\n-  }\n-\n@@ -7675,8 +7635,0 @@\n-\n-    \/\/ Safefetch stubs.\n-    generate_safefetch(\"SafeFetch32\", sizeof(int),     &StubRoutines::_safefetch32_entry,\n-                                                       &StubRoutines::_safefetch32_fault_pc,\n-                                                       &StubRoutines::_safefetch32_continuation_pc);\n-    generate_safefetch(\"SafeFetchN\", sizeof(intptr_t), &StubRoutines::_safefetchN_entry,\n-                                                       &StubRoutines::_safefetchN_fault_pc,\n-                                                       &StubRoutines::_safefetchN_continuation_pc);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":0,"deletions":48,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -46,12 +46,0 @@\n-\/\/ For SafeFetch we need POSIX tls and setjmp\n-#include <setjmp.h>\n-#include <pthread.h>\n-static pthread_key_t g_jmpbuf_key;\n-\n-\/\/ return the currently active jump buffer for this thread\n-\/\/  - if there is any, NULL otherwise. Called from\n-\/\/    zero signal handlers.\n-extern sigjmp_buf* get_jmp_buf_for_continuation() {\n-  return (sigjmp_buf*) pthread_getspecific(g_jmpbuf_key);\n-}\n-\n@@ -191,51 +179,0 @@\n-  static int SafeFetch32(int *adr, int errValue) {\n-\n-    \/\/ set up a jump buffer; anchor the pointer to the jump buffer in tls; then\n-    \/\/ do the pointer access. If pointer is invalid, we crash; in signal\n-    \/\/ handler, we retrieve pointer to jmp buffer from tls, and jump back.\n-    \/\/\n-    \/\/ Note: the jump buffer itself - which can get pretty large depending on\n-    \/\/ the architecture - lives on the stack and that is fine, because we will\n-    \/\/ not rewind the stack: either we crash, in which case signal handler\n-    \/\/ frame is below us, or we don't crash, in which case it does not matter.\n-    sigjmp_buf jb;\n-    if (sigsetjmp(jb, 1)) {\n-      \/\/ we crashed. clean up tls and return default value.\n-      pthread_setspecific(g_jmpbuf_key, NULL);\n-      return errValue;\n-    } else {\n-      \/\/ preparation phase\n-      pthread_setspecific(g_jmpbuf_key, &jb);\n-    }\n-\n-    int value = errValue;\n-    value = *adr;\n-\n-    \/\/ all went well. clean tls.\n-    pthread_setspecific(g_jmpbuf_key, NULL);\n-\n-    return value;\n-  }\n-\n-  static intptr_t SafeFetchN(intptr_t *adr, intptr_t errValue) {\n-\n-    sigjmp_buf jb;\n-    if (sigsetjmp(jb, 1)) {\n-      \/\/ we crashed. clean up tls and return default value.\n-      pthread_setspecific(g_jmpbuf_key, NULL);\n-      return errValue;\n-    } else {\n-      \/\/ preparation phase\n-      pthread_setspecific(g_jmpbuf_key, &jb);\n-    }\n-\n-    intptr_t value = errValue;\n-    value = *adr;\n-\n-    \/\/ all went well. clean tls.\n-    pthread_setspecific(g_jmpbuf_key, NULL);\n-\n-    return value;\n-\n-  }\n-\n@@ -288,9 +225,0 @@\n-    \/\/ Safefetch stubs.\n-    pthread_key_create(&g_jmpbuf_key, NULL);\n-    StubRoutines::_safefetch32_entry = CAST_FROM_FN_PTR(address, StubGenerator::SafeFetch32);\n-    StubRoutines::_safefetch32_fault_pc = NULL;\n-    StubRoutines::_safefetch32_continuation_pc = NULL;\n-\n-    StubRoutines::_safefetchN_entry = CAST_FROM_FN_PTR(address, StubGenerator::SafeFetchN);\n-    StubRoutines::_safefetchN_fault_pc = NULL;\n-    StubRoutines::_safefetchN_continuation_pc = NULL;\n","filename":"src\/hotspot\/cpu\/zero\/stubGenerator_zero.cpp","additions":0,"deletions":72,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-#include \"runtime\/safefetch.inline.hpp\"\n+#include \"runtime\/safefetch.hpp\"\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"runtime\/safefetch.inline.hpp\"\n+#include \"runtime\/safefetch.hpp\"\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zPhysicalMemoryBacking_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"runtime\/safefetch.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#ifdef SAFEFETCH_METHOD_SIGSETJMP\n+\n+\/\/ For SafeFetch we need POSIX TLS and sigsetjmp\/longjmp.\n+\/\/ (Note: We would prefer compiler level TLS but for some reason __thread does not\n+\/\/  work here; this needs investigation. For we now stick with POSIX TLS)\n+#include <setjmp.h>\n+#include <pthread.h>\n+static pthread_key_t g_jmpbuf_key;\n+\n+struct InitTLSKey { InitTLSKey() { pthread_key_create(&g_jmpbuf_key, NULL); } };\n+static InitTLSKey g_init_tly_key;\n+\n+\/\/ Handle safefetch, sigsetjmp style:\n+\/\/\n+\/\/ If a safefetch jump had been established and the sig qualifies, we\n+\/\/ jump back to the established jump point (and hence out of signal handling).\n+\/\/\n+\/\/ Note that this function will never return for safefetch faults. We just\n+\/\/ keep the prototype the same as other handle_safefetch() versions to keep\n+\/\/ caller sites simple.\n+bool handle_safefetch(int sig, address ignored1, void* ignored2) {\n+  if (sig == SIGSEGV || sig == SIGBUS) {\n+    \/\/ Retrieve jump buffer pointer from TLS. If not NULL, it means we set the\n+    \/\/ jump buffer and this is indeed a SafeFetch fault.\n+    sigjmp_buf* const jb = (sigjmp_buf*) pthread_getspecific(g_jmpbuf_key);\n+    if (jb) {\n+      \/\/ Reset TLS slot and jump back\n+      pthread_setspecific(g_jmpbuf_key, NULL);\n+      siglongjmp(*jb, 1);\n+    }\n+  }\n+  return false;\n+}\n+\n+template <class T>\n+static bool _SafeFetchXX_internal(const T *adr, T* result) {\n+\n+  T n = 0;\n+\n+  \/\/ Set up a jump buffer. Anchor its pointer in TLS. Then read from the unsafe address.\n+  \/\/ If that address was invalid, we fault, and in the signal handler we will jump back\n+  \/\/ to the jump point.\n+  sigjmp_buf jb;\n+  if (sigsetjmp(jb, 1) != 0) {\n+    \/\/ We faulted.\n+    *result = 0;\n+    return false;\n+  }\n+\n+  \/\/ Anchor jump buffer in TLS\n+  pthread_setspecific(g_jmpbuf_key, &jb);\n+\n+  \/\/ unsafe access\n+  n = *adr;\n+\n+  \/\/ Still here... All went well, adr was valid.\n+  *result = n;\n+\n+  \/\/ Reset the TLS slot\n+  pthread_setspecific(g_jmpbuf_key, NULL);\n+\n+  return true;\n+\n+}\n+\n+int SafeFetch32(int *adr, int errValue) {\n+  int result;\n+  return _SafeFetchXX_internal<int>(adr, &result) ? result : errValue;\n+}\n+\n+intptr_t SafeFetchN(intptr_t *adr, intptr_t errValue) {\n+  intptr_t result;\n+  return _SafeFetchXX_internal<intptr_t>(adr, &result) ? result : errValue;\n+}\n+\n+#endif \/\/ SAFEFETCH_METHOD_SIGSETJMP\n","filename":"src\/hotspot\/os\/posix\/safefetch_sigjmp.cpp","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_POSIX_SAFEFETCH_SIGJMP_HPP\n+#define CPU_POSIX_SAFEFETCH_SIGJMP_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ On Posix platforms that don't do anything better - or cannot, like Zero -\n+\/\/ SafeFetch is implemented using setjmp\/longjmp. That is reliable and portable,\n+\/\/ but slower than other methods, and needs more thread stack (the sigjmp buffer\n+\/\/ lives on the thread stack).\n+\n+int SafeFetch32(int* adr, int errValue);\n+intptr_t SafeFetchN(intptr_t* adr, intptr_t errValue);\n+\n+inline bool CanUseSafeFetch32() { return true; }\n+inline bool CanUseSafeFetchN()  { return true; }\n+\n+\/\/ Handle safefetch, sigsetjmp style. Only call from signal handler.\n+\/\/ If a safefetch jump had been established and the sig qualifies, we\n+\/\/ jump back to the established jump point (and hence out of signal handling).\n+bool handle_safefetch(int sig, address pc, void* context);\n+\n+#endif \/\/ CPU_POSIX_SAFEFETCH_SIGJMP_HPP\n","filename":"src\/hotspot\/os\/posix\/safefetch_sigjmp.hpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/safefetch.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"runtime\/stubRoutines.hpp\"\n@@ -43,6 +43,0 @@\n-#ifdef ZERO\n-\/\/ See stubGenerator_zero.cpp\n-#include <setjmp.h>\n-extern sigjmp_buf* get_jmp_buf_for_continuation();\n-#endif\n-\n@@ -602,17 +596,15 @@\n-  if (!signal_was_handled) {\n-    \/\/ Handle SafeFetch access.\n-#ifndef ZERO\n-    if (uc != NULL) {\n-      address pc = os::Posix::ucontext_get_pc(uc);\n-      if (StubRoutines::is_safefetch_fault(pc)) {\n-        os::Posix::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));\n-        signal_was_handled = true;\n-      }\n-    }\n-#else\n-    \/\/ See JDK-8076185\n-    if (sig == SIGSEGV || sig == SIGBUS) {\n-      sigjmp_buf* const pjb = get_jmp_buf_for_continuation();\n-      if (pjb) {\n-        siglongjmp(*pjb, 1);\n-      }\n+  \/\/ Extract pc from context. Note that for certain signals and certain\n+  \/\/ architectures the pc in ucontext_t will point *after* the offending\n+  \/\/ instruction. In those cases, use siginfo si_addr instead.\n+  address pc = NULL;\n+  if (uc != NULL) {\n+    if (S390_ONLY(sig == SIGILL || sig == SIGFPE) NOT_S390(false)) {\n+      pc = (address)info->si_addr;\n+    } else if (ZERO_ONLY(true) NOT_ZERO(false)) {\n+      \/\/ Non-arch-specific Zero code does not really know the pc.\n+      \/\/ This can be alleviated by making arch-specific os::Posix::ucontext_get_pc\n+      \/\/ available for Zero for known architectures. But for generic Zero\n+      \/\/ code, it would still remain unknown.\n+      pc = NULL;\n+    } else {\n+      pc = os::Posix::ucontext_get_pc(uc);\n@@ -620,1 +612,0 @@\n-#endif \/\/ ZERO\n@@ -623,0 +614,6 @@\n+#if defined(SAFEFETCH_METHOD_STATIC_ASSEMBLY) || defined(SAFEFETCH_METHOD_SIGSETJMP)\n+  if (!signal_was_handled) {\n+    signal_was_handled = handle_safefetch(sig, pc, uc);\n+  }\n+#endif \/\/ SAFEFETCH_xxx handling\n+\n@@ -645,16 +642,0 @@\n-    \/\/ Extract pc from context for the error handler to display.\n-    address pc = NULL;\n-    if (uc != NULL) {\n-      \/\/ prepare fault pc address for error reporting.\n-      if (S390_ONLY(sig == SIGILL || sig == SIGFPE) NOT_S390(false)) {\n-        pc = (address)info->si_addr;\n-      } else if (ZERO_ONLY(true) NOT_ZERO(false)) {\n-        \/\/ Non-arch-specific Zero code does not really know the pc.\n-        \/\/ This can be alleviated by making arch-specific os::Posix::ucontext_get_pc\n-        \/\/ available for Zero for known architectures. But for generic Zero\n-        \/\/ code, it would still remain unknown.\n-        pc = NULL;\n-      } else {\n-        pc = os::Posix::ucontext_get_pc(uc);\n-      }\n-    }\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":22,"deletions":41,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/safefetch.hpp\"\n@@ -70,1 +70,0 @@\n-  \/\/ support safefetch faults in error handling\n@@ -79,3 +78,3 @@\n-  \/\/ Needed to make it possible to call SafeFetch.. APIs in error handling.\n-  if (uc && pc && StubRoutines::is_safefetch_fault(pc)) {\n-    os::Posix::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));\n+#if defined(SAFEFETCH_METHOD_STATIC_ASSEMBLY) || defined(SAFEFETCH_METHOD_SIGSETJMP)\n+  \/\/ Handle safefetch here too, to be able to use SafeFetc() inside the error handler\n+  if (handle_safefetch(sig, pc, uc)) {\n@@ -84,0 +83,1 @@\n+#endif \/\/ SAFEFETCH_xxx handling\n","filename":"src\/hotspot\/os\/posix\/vmError_posix.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-#include \"runtime\/safefetch.inline.hpp\"\n+#include \"runtime\/safefetch.hpp\"\n@@ -64,0 +64,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -2497,5 +2498,0 @@\n-  \/\/ Handle SafeFetch32 and SafeFetchN exceptions.\n-  if (StubRoutines::is_safefetch_fault(pc)) {\n-    return Handle_Exception(exceptionInfo, StubRoutines::continuation_for_safefetch_fault(pc));\n-  }\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_WINDOWS_SAFEFETCH_WINDOWS_HPP\n+#define OS_WINDOWS_SAFEFETCH_WINDOWS_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ On windows, we use structured exception handling to implement SafeFetch\n+\n+template <class T>\n+inline T SafeFetchXX(const T* adr, T errValue) {\n+  T v = 0;\n+  __try {\n+    v = *adr;\n+  }\n+  __except(EXCEPTION_EXECUTE_HANDLER) {\n+    v = errValue;\n+  }\n+  return v;\n+}\n+\n+inline int SafeFetch32(const int* adr, int errValue)                { return SafeFetchXX<int>(adr, errValue); }\n+inline intptr_t SafeFetchN(const intptr_t* adr, intptr_t errValue)  { return SafeFetchXX<intptr_t>(adr, errValue); }\n+\n+inline bool CanUseSafeFetch32() { return true; }\n+inline bool CanUseSafeFetchN()  { return true; }\n+\n+#endif\n","filename":"src\/hotspot\/os\/windows\/safefetch_windows.hpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifdef __APPLE__\n+# Darwin uses _ prefixed global symbols\n+#define SYMBOL(s) _ ## s\n+#define ELF_TYPE(name, description)\n+#else\n+#define SYMBOL(s) s\n+#define ELF_TYPE(name, description) .type name,description\n+#endif\n+\n+    .global SYMBOL(SafeFetchN)\n+    .global SYMBOL(_SafeFetchN_fault)\n+    .global SYMBOL(_SafeFetchN_continuation)\n+    .global SYMBOL(SafeFetch32)\n+    .global SYMBOL(_SafeFetch32_fault)\n+    .global SYMBOL(_SafeFetch32_continuation)\n+\n+    # Support for int SafeFetch32(int* address, int defaultval);\n+    #\n+    #  x0 : address\n+    #  w1 : defaultval\n+\n+\t# needed to align function start to 4 byte\n+    .align  6\n+    ELF_TYPE(SafeFetch32,@function)\n+SYMBOL(SafeFetch32):\n+SYMBOL(_SafeFetch32_fault):\n+    ldr      w1, [x0]\n+SYMBOL(_SafeFetch32_continuation):\n+    mov      x0, x1\n+    ret\n+\n+    # Support for intptr_t SafeFetchN(intptr_t* address, intptr_t defaultval);\n+    #\n+    #  x1 : address\n+    #  x0 : defaultval\n+\n+    .align  6\n+    ELF_TYPE(SafeFetchN,@function)\n+SYMBOL(SafeFetchN):\n+SYMBOL(_SafeFetchN_fault):\n+    ldr      x1, [x0]\n+SYMBOL(_SafeFetchN_continuation):\n+    mov      x0, x1\n+    ret\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/safefetch_bsd_aarch64.S","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+#\n+# Copyright (c) 2022 SAP SE. All rights reserved.\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+#ifdef __APPLE__\n+# Darwin uses _ prefixed global symbols\n+#define SYMBOL(s) _ ## s\n+#define ELF_TYPE(name, description)\n+#else\n+#define SYMBOL(s) s\n+#define ELF_TYPE(name, description) .type name,description\n+#endif\n+\n+    .globl SYMBOL(SafeFetch32)\n+    .globl SYMBOL(SafeFetchN)\n+    .globl SYMBOL(_SafeFetch32_fault)\n+    .globl SYMBOL(_SafeFetchN_fault)\n+    .globl SYMBOL(_SafeFetch32_continuation)\n+    .globl SYMBOL(_SafeFetchN_continuation)\n+\n+    .text\n+\n+    # Support for int SafeFetch32(int* address, int defaultval);\n+    #\n+    #  %rdi : address\n+    #  %esi : defaultval\n+\tELF_TYPE(SafeFetch32,@function)\n+SYMBOL(SafeFetch32:)\n+SYMBOL(_SafeFetch32_fault:)\n+    movl (%rdi), %eax\n+    ret\n+SYMBOL(_SafeFetch32_continuation:)\n+    movl %esi, %eax\n+    ret\n+\n+    # Support for intptr_t SafeFetchN(intptr_t* address, intptr_t defaultval);\n+    #\n+    #  %rdi : address\n+    #  %rsi : defaultval\n+    ELF_TYPE(SafeFetchN,@function)\n+SYMBOL(SafeFetchN:)\n+SYMBOL(_SafeFetchN_fault:)\n+    movq (%rdi), %rax\n+    ret\n+SYMBOL(_SafeFetchN_continuation:)\n+    movq %rsi, %rax\n+    ret\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/safefetch_bsd_x86_64.S","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+    .globl SafeFetchN\n+    .globl _SafeFetchN_fault\n+    .globl _SafeFetchN_continuation\n+    .globl SafeFetch32\n+    .globl _SafeFetch32_fault\n+    .globl _SafeFetch32_continuation\n+\n+    # Support for int SafeFetch32(int* address, int defaultval);\n+    #\n+    #  x0 : address\n+    #  x1 : defaultval\n+SafeFetch32:\n+_SafeFetch32_fault:\n+    ldr      w1, [x0]\n+_SafeFetch32_continuation:\n+    mov      x0, x1\n+    ret\n+\n+    # Support for intptr_t SafeFetchN(intptr_t* address, intptr_t defaultval);\n+    #\n+    #  x1 : address\n+    #  x0 : defaultval\n+SafeFetchN:\n+_SafeFetchN_fault:\n+    ldr      x1, [x0]\n+_SafeFetchN_continuation:\n+    mov      x0, x1\n+    ret\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/safefetch_linux_aarch64.S","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+    .globl SafeFetch32\n+    .globl _SafeFetch32_fault\n+    .globl _SafeFetch32_continuation\n+\n+    # Support for int SafeFetch32(int* address, int defaultval);\n+    #\n+    #  r0 : address\n+    #  r1 : defaultval\n+SafeFetch32:\n+_SafeFetch32_fault:\n+    ldr      r1, [r0]\n+_SafeFetch32_continuation:\n+    mov      r0, r1\n+    bx       lr\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/safefetch_linux_arm.S","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+    .globl SafeFetchN\n+    .globl _SafeFetchN_fault\n+    .globl _SafeFetchN_continuation\n+    .globl SafeFetch32\n+    .globl _SafeFetch32_fault\n+    .globl _SafeFetch32_continuation\n+\n+    # Support for int SafeFetch32(int* address, int defaultval);\n+    #\n+    #  r3 : address\n+    #  r4 : defaultval\n+    #  r3 : retval\n+SafeFetch32:\n+_SafeFetch32_fault:\n+    lwa      %r4, 0(%r3)\n+_SafeFetch32_continuation:\n+    mr       %r3, %r4\n+    blr\n+\n+    # Support for intptr_t SafeFetchN(intptr_t* address, intptr_t defaultval);\n+    #\n+    #  r3 : address\n+    #  r4 : defaultval\n+    #  r3 : retval\n+SafeFetchN:\n+_SafeFetchN_fault:\n+    ld     %r4, 0(%r3)\n+_SafeFetchN_continuation:\n+    mr     %r3, %r4\n+    blr\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/safefetch_linux_ppc.S","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+    .globl SafeFetchN\n+    .globl _SafeFetchN_fault\n+    .globl _SafeFetchN_continuation\n+    .globl SafeFetch32\n+    .globl _SafeFetch32_fault\n+    .globl _SafeFetch32_continuation\n+\n+    # Support for int SafeFetch32(int* address, int defaultval);\n+    #\n+    #  x10 : address\n+    #  x11 : defaultval\n+    #  x10 : retval\n+SafeFetch32:\n+_SafeFetch32_fault:\n+    lw       x11, 0(x10)\n+_SafeFetch32_continuation:\n+    mv       x10, x11\n+    ret\n+\n+    # Support for intptr_t SafeFetchN(intptr_t* address, intptr_t defaultval);\n+    #\n+    #  x10 : address\n+    #  x11 : defaultval\n+    #  x10 : retval\n+SafeFetchN:\n+_SafeFetchN_fault:\n+    ld       x11, 0(x10)\n+_SafeFetchN_continuation:\n+    mv       x10, x11\n+    ret\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/safefetch_linux_riscv.S","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+    .globl SafeFetchN\n+    .globl _SafeFetchN_fault\n+    .globl _SafeFetchN_continuation\n+    .globl SafeFetch32\n+    .globl _SafeFetch32_fault\n+    .globl _SafeFetch32_continuation\n+\n+    # Support for int SafeFetch32(int* address, int defaultval);\n+    #\n+    #  r2 : address\n+    #  r3 : defaultval\n+    #  r2 : retval\n+SafeFetch32:\n+_SafeFetch32_fault:\n+    lgf      %r3, 0(%r2)\n+_SafeFetch32_continuation:\n+    lgr      %r2, %r3\n+    br       %r14\n+\n+    # Support for intptr_t SafeFetchN(intptr_t* address, intptr_t defaultval);\n+    #\n+    #  r2 : address\n+    #  r3 : defaultval\n+    #  r2 : retval\n+SafeFetchN:\n+_SafeFetchN_fault:\n+    lg       %r3, 0(%r2)\n+_SafeFetchN_continuation:\n+    lgr      %r2, %r3\n+    br       %r14\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/safefetch_linux_s390.S","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+#\n+# Copyright (c) 2022 SAP SE. All rights reserved.\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+    .globl SafeFetch32\n+    .globl _SafeFetch32_fault\n+    .globl _SafeFetch32_continuation\n+\n+\t.text\n+\n+    # Support for int SafeFetch32(int* address, int defaultval);\n+    #\n+    #  8(%esp) : default value\n+    #  4(%esp) : crash address\n+\t#  0(%esp) : return pc\n+    .type _SafeFetch32,@function\n+SafeFetch32:\n+    movl 4(%esp),%ecx         # load address from stack\n+_SafeFetch32_fault:\n+    movl (%ecx), %eax         # load target value, may fault\n+    ret\n+_SafeFetch32_continuation:\n+    movl 8(%esp),%eax         # load default value from stack\n+    ret\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/safefetch_linux_x86_32.S","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+#\n+# Copyright (c) 2022 SAP SE. All rights reserved.\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+    .globl SafeFetch32\n+    .globl SafeFetchN\n+    .globl _SafeFetch32_fault\n+    .globl _SafeFetchN_fault\n+    .globl _SafeFetch32_continuation\n+    .globl _SafeFetchN_continuation\n+\n+\t.text\n+\n+\n+    # Support for int SafeFetch32(int* address, int defaultval);\n+    #\n+    #  %rdi : address\n+    #  %esi : defaultval\n+\t.type    SafeFetch32,@function\n+SafeFetch32:\n+_SafeFetch32_fault:\n+    movl (%rdi), %eax       # load target value, may fault\n+    ret\n+_SafeFetch32_continuation:\n+    movl %esi, %eax         # return default\n+    ret\n+\n+    # Support for intptr_t SafeFetchN(intptr_t* address, intptr_t defaultval);\n+    #\n+    #  %rdi : address\n+    #  %rsi : defaultval\n+\t.type    SafeFetchN,@function\n+SafeFetchN:\n+_SafeFetchN_fault:\n+    movq (%rdi), %rax       # load target value, may fault\n+    ret\n+_SafeFetchN_continuation:\n+    movq %rsi, %rax         # return default\n+    ret\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/safefetch_linux_x86_64.S","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -39,1 +39,1 @@\n-#include \"runtime\/safefetch.inline.hpp\"\n+#include \"runtime\/safefetch.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-#include \"runtime\/safefetch.inline.hpp\"\n+#include \"runtime\/safefetch.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-#include \"runtime\/safefetch.inline.hpp\"\n+#include \"runtime\/safefetch.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -299,0 +299,4 @@\n+  \/\/ The largest possible standard page size (sysconf(_SC_PAGESIZE)) across all our\n+  \/\/ platforms, usable as a compile-time constant.\n+  static const size_t max_page_size_crossplatform = 64 * K; \/\/ ppc has 64 K pages.\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_SAFEFETCH_HPP\n+#define SHARE_RUNTIME_SAFEFETCH_HPP\n+\n+#ifdef _WIN32\n+  \/\/ Windows uses Structured Exception Handling\n+  #include \"safefetch_windows.hpp\"\n+  #define SAFEFETCH_METHOD_SEH\n+#elif defined(ZERO) || defined (_AIX)\n+  \/\/ These platforms implement safefetch via Posix sigsetjmp\/longjmp.\n+  \/\/ This is slower than the other methods and uses more thread stack,\n+  \/\/ but its safe and portable.\n+  #include \"safefetch_sigjmp.hpp\"\n+  #define SAFEFETCH_METHOD_SIGSETJMP\n+#else\n+  \/\/ All other platforms use static assembly\n+  #include \"safefetch_static.hpp\"\n+  #define SAFEFETCH_METHOD_STATIC_ASSEMBLY\n+#endif\n+\n+#endif \/\/ SHARE_RUNTIME_SAFEFETCH_HPP\n","filename":"src\/hotspot\/share\/runtime\/safefetch.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_RUNTIME_SAFEFETCH_INLINE_HPP\n-#define SHARE_RUNTIME_SAFEFETCH_INLINE_HPP\n-\n-\/\/ No safefetch.hpp\n-\n-#include \"runtime\/stubRoutines.hpp\"\n-#include \"runtime\/threadWXSetters.inline.hpp\"\n-\n-\/\/ Safefetch allows to load a value from a location that's not known\n-\/\/ to be valid. If the load causes a fault, the error value is returned.\n-inline int SafeFetch32(int* adr, int errValue) {\n-  assert(StubRoutines::SafeFetch32_stub(), \"stub not yet generated\");\n-#if defined(__APPLE__) && defined(AARCH64)\n-  Thread* thread = Thread::current_or_null_safe();\n-  assert(thread != NULL, \"required for W^X management\");\n-  ThreadWXEnable wx(WXExec, thread);\n-#endif \/\/ __APPLE__ && AARCH64\n-  return StubRoutines::SafeFetch32_stub()(adr, errValue);\n-}\n-\n-inline intptr_t SafeFetchN(intptr_t* adr, intptr_t errValue) {\n-  assert(StubRoutines::SafeFetchN_stub(), \"stub not yet generated\");\n-#if defined(__APPLE__) && defined(AARCH64)\n-  Thread* thread = Thread::current_or_null_safe();\n-  assert(thread != NULL, \"required for W^X management\");\n-  ThreadWXEnable wx(WXExec, thread);\n-#endif \/\/ __APPLE__ && AARCH64\n-  return StubRoutines::SafeFetchN_stub()(adr, errValue);\n-}\n-\n-\/\/ returns true if SafeFetch32 and SafeFetchN can be used safely (stubroutines are already generated)\n-inline bool CanUseSafeFetch32() {\n-#if defined (__APPLE__) && defined(AARCH64)\n-  if (Thread::current_or_null_safe() == NULL) { \/\/ workaround for JDK-8282475\n-    return false;\n-  }\n-#endif \/\/ __APPLE__ && AARCH64\n-  return StubRoutines::SafeFetch32_stub() ? true : false;\n-}\n-\n-inline bool CanUseSafeFetchN() {\n-#if defined (__APPLE__) && defined(AARCH64)\n-  if (Thread::current_or_null_safe() == NULL) {\n-    return false;\n-  }\n-#endif \/\/ __APPLE__ && AARCH64\n-  return StubRoutines::SafeFetchN_stub() ? true : false;\n-}\n-\n-#endif \/\/ SHARE_RUNTIME_SAFEFETCH_INLINE_HPP\n","filename":"src\/hotspot\/share\/runtime\/safefetch.inline.hpp","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/safefetch.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#ifdef SAFEFETCH_METHOD_STATIC_ASSEMBLY\n+\n+\/\/ SafeFetch handling, static assembly style:\n+\/\/\n+\/\/ SafeFetch32 and SafeFetchN are implemented via static assembly\n+\/\/ and live in os_cpu\/xx_xx\/safefetch_xx_xx.S\n+\n+extern \"C\" char _SafeFetch32_continuation[] __attribute__ ((visibility (\"hidden\")));\n+extern \"C\" char _SafeFetch32_fault[] __attribute__ ((visibility (\"hidden\")));\n+\n+#ifdef _LP64\n+extern \"C\" char _SafeFetchN_continuation[] __attribute__ ((visibility (\"hidden\")));\n+extern \"C\" char _SafeFetchN_fault[] __attribute__ ((visibility (\"hidden\")));\n+#endif \/\/ _LP64\n+\n+bool handle_safefetch(int sig, address pc, void* context) {\n+  ucontext_t* uc = (ucontext_t*)context;\n+  if ((sig == SIGSEGV || sig == SIGBUS) && uc != NULL) {\n+    address pc = os::Posix::ucontext_get_pc(uc);\n+    if (pc == (address)_SafeFetch32_fault) {\n+      os::Posix::ucontext_set_pc(uc, (address)_SafeFetch32_continuation);\n+      return true;\n+    }\n+#ifdef _LP64\n+    if (pc == (address)_SafeFetchN_fault) {\n+      os::Posix::ucontext_set_pc(uc, (address)_SafeFetchN_continuation);\n+      return true;\n+    }\n+#endif\n+  }\n+  return false;\n+}\n+\n+#endif \/\/ SAFEFETCH_METHOD_STATIC_ASSEMBLY\n","filename":"src\/hotspot\/share\/runtime\/safefetch_static.cpp","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_SAFEFETCH_STATIC_HPP\n+#define SHARE_RUNTIME_SAFEFETCH_STATIC_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+extern \"C\" int SafeFetch32(int* adr, int errValue);\n+\n+#ifdef _LP64\n+extern \"C\" intptr_t SafeFetchN(intptr_t* adr, intptr_t errValue);\n+#else\n+inline intptr_t SafeFetchN(intptr_t* adr, intptr_t errValue) {\n+  return SafeFetch32(adr, errValue);\n+}\n+#endif \/\/ _LP64\n+\n+inline bool CanUseSafeFetch32() { return true; }\n+inline bool CanUseSafeFetchN()  { return true; }\n+bool handle_safefetch(int sig, address pc, void* context);\n+\n+#endif \/\/ SHARE_RUNTIME_SAFEFETCH_STATIC_HPP\n","filename":"src\/hotspot\/share\/runtime\/safefetch_static.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"runtime\/safefetch.inline.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -171,7 +171,0 @@\n-address StubRoutines::_safefetch32_entry                 = NULL;\n-address StubRoutines::_safefetch32_fault_pc              = NULL;\n-address StubRoutines::_safefetch32_continuation_pc       = NULL;\n-address StubRoutines::_safefetchN_entry                  = NULL;\n-address StubRoutines::_safefetchN_fault_pc               = NULL;\n-address StubRoutines::_safefetchN_continuation_pc        = NULL;\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -253,8 +253,0 @@\n-  \/\/ Safefetch stubs.\n-  static address _safefetch32_entry;\n-  static address _safefetch32_fault_pc;\n-  static address _safefetch32_continuation_pc;\n-  static address _safefetchN_entry;\n-  static address _safefetchN_fault_pc;\n-  static address _safefetchN_continuation_pc;\n-\n@@ -431,28 +423,0 @@\n-  \/\/\n-  \/\/ Safefetch stub support\n-  \/\/\n-\n-  typedef int      (*SafeFetch32Stub)(int*      adr, int      errValue);\n-  typedef intptr_t (*SafeFetchNStub) (intptr_t* adr, intptr_t errValue);\n-\n-  static SafeFetch32Stub SafeFetch32_stub() { return CAST_TO_FN_PTR(SafeFetch32Stub, _safefetch32_entry); }\n-  static SafeFetchNStub  SafeFetchN_stub()  { return CAST_TO_FN_PTR(SafeFetchNStub,  _safefetchN_entry); }\n-\n-  static bool is_safefetch_fault(address pc) {\n-    return pc != NULL &&\n-          (pc == _safefetch32_fault_pc ||\n-           pc == _safefetchN_fault_pc);\n-  }\n-\n-  static address continuation_for_safefetch_fault(address pc) {\n-    assert(_safefetch32_continuation_pc != NULL &&\n-           _safefetchN_continuation_pc  != NULL,\n-           \"not initialized\");\n-\n-    if (pc == _safefetch32_fault_pc) return _safefetch32_continuation_pc;\n-    if (pc == _safefetchN_fault_pc)  return _safefetchN_continuation_pc;\n-\n-    ShouldNotReachHere();\n-    return NULL;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/safefetch.inline.hpp\"\n+#include \"runtime\/safefetch.hpp\"\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-#include \"runtime\/safefetch.inline.hpp\"\n+#include \"runtime\/safefetch.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/safefetch.inline.hpp\"\n+#include \"runtime\/safefetch.hpp\"\n@@ -33,0 +33,1 @@\n+#include \"testutils.hpp\"\n@@ -34,2 +35,2 @@\n-static const intptr_t pattern = LP64_ONLY(0xABCDABCDABCDABCDULL) NOT_LP64(0xABCDABCD);\n-static intptr_t* invalid_address = (intptr_t*)VMError::segfault_address;\n+\/\/ Note: beyond these tests, there exist additional tests testing that safefetch in error handling\n+\/\/ (in the context of signal handling) works, see runtime\/ErrorHandling\n@@ -37,4 +38,89 @@\n-TEST_VM(os, safefetch_can_use) {\n-  \/\/ Once VM initialization is through,\n-  \/\/ safefetch should work on every platform.\n-  ASSERT_TRUE(CanUseSafeFetch32());\n+static const intptr_t patternN = LP64_ONLY(0xABCDABCDABCDABCDULL) NOT_LP64(0xABCDABCD);\n+static const int pattern32 = 0xABCDABCD;\n+\n+static intptr_t* const  bad_addressN = (intptr_t*) VMError::segfault_address;\n+static int* const       bad_address32 = (int*) VMError::segfault_address;\n+\n+static intptr_t dataN[3] =  { 0, patternN, 0 };\n+static int data32[3] = { 0, pattern32, 0 };\n+static intptr_t* const  good_addressN = dataN + 1;\n+static int* const       good_address32 = data32 + 1;\n+\n+\n+void test_safefetchN_positive() {\n+  intptr_t a = SafeFetchN(good_addressN, 1);\n+  ASSERT_EQ(patternN, a);\n+}\n+\n+static void test_safefetch32_positive() {\n+  uint64_t a = SafeFetch32(good_address32, 1);\n+  ASSERT_EQ((uint64_t)pattern32, a);\n+}\n+\n+static void test_safefetchN_negative() {\n+  intptr_t a = SafeFetchN(bad_addressN, 0);\n+  ASSERT_EQ(0, a);\n+  a = SafeFetchN(bad_addressN, ~patternN);\n+  ASSERT_EQ(~patternN, a);\n+  \/\/ Also test NULL, but not on AIX, where NULL is readable\n+#ifndef AIX\n+  a = SafeFetchN(NULL, 0);\n+  ASSERT_EQ(0, a);\n+  a = SafeFetchN(NULL, ~patternN);\n+  ASSERT_EQ(~patternN, a);\n+#endif\n+}\n+\n+static void test_safefetch32_negative() {\n+  int a = SafeFetch32(bad_address32, 0);\n+  ASSERT_EQ(0, a);\n+  a = SafeFetch32(bad_address32, ~pattern32);\n+  ASSERT_EQ(~pattern32, a);\n+  \/\/ Also test NULL, but not on AIX, where NULL is readable\n+#ifndef AIX\n+  a = SafeFetch32(NULL, 0);\n+  ASSERT_EQ(0, a);\n+  a = SafeFetch32(NULL, ~pattern32);\n+  ASSERT_EQ(~pattern32, a);\n+#endif\n+}\n+\n+TEST_VM(os, safefetchN_positive) {\n+  test_safefetchN_positive();\n+}\n+\n+TEST_VM(os, safefetch32_positive) {\n+  test_safefetch32_positive();\n+}\n+\n+TEST_VM(os, safefetchN_negative) {\n+  test_safefetchN_negative();\n+}\n+\n+TEST_VM(os, safefetch32_negative) {\n+  test_safefetch32_negative();\n+}\n+\n+\/\/ Try with Thread::current being NULL. SafeFetch should work then too.\n+\/\/ See JDK-8282475\n+\n+class ThreadCurrentNullMark : public StackObj {\n+  Thread* _saved;\n+public:\n+  ThreadCurrentNullMark() {\n+    _saved = Thread::current();\n+    Thread::clear_thread_current();\n+  }\n+  ~ThreadCurrentNullMark() {\n+    _saved->initialize_thread_current();\n+  }\n+};\n+\n+TEST_VM(os, safefetchN_positive_current_null) {\n+  ThreadCurrentNullMark tcnmark;\n+  test_safefetchN_positive();\n+}\n+\n+TEST_VM(os, safefetch32_positive_current_null) {\n+  ThreadCurrentNullMark tcnmark;\n+  test_safefetch32_positive();\n@@ -43,4 +129,3 @@\n-TEST_VM(os, safefetch_positive) {\n-  intptr_t v = pattern;\n-  intptr_t a = SafeFetchN(&v, 1);\n-  ASSERT_EQ(v, a);\n+TEST_VM(os, safefetchN_negative_current_null) {\n+  ThreadCurrentNullMark tcnmark;\n+  test_safefetchN_negative();\n@@ -49,5 +134,3 @@\n-TEST_VM(os, safefetch_negative) {\n-  intptr_t a = SafeFetchN(invalid_address, pattern);\n-  ASSERT_EQ(pattern, a);\n-  a = SafeFetchN(invalid_address, ~pattern);\n-  ASSERT_EQ(~pattern, a);\n+TEST_VM(os, safefetch32_negative_current_null) {\n+  ThreadCurrentNullMark tcnmark;\n+  test_safefetch32_negative();\n@@ -61,4 +144,1 @@\n-    intptr_t a = SafeFetchN(invalid_address, pattern);\n-    ASSERT_EQ(pattern, a);\n-    a = SafeFetchN(invalid_address, ~pattern);\n-    ASSERT_EQ(~pattern, a);\n+    test_safefetchN_negative();\n","filename":"test\/hotspot\/gtest\/runtime\/test_safefetch.cpp","additions":100,"deletions":20,"binary":false,"changes":120,"status":"modified"}]}