{"files":[{"patch":"@@ -32,11 +32,9 @@\n-PretouchTask::PretouchTask(const char* task_name,\n-                           char* start_address,\n-                           char* end_address,\n-                           size_t page_size,\n-                           size_t chunk_size) :\n-    AbstractGangTask(task_name),\n-    _cur_addr(start_address),\n-    _start_addr(start_address),\n-    _end_addr(end_address),\n-    _page_size(page_size),\n-    _chunk_size(chunk_size) {\n+static size_t adjusted_page_size(size_t page_size) {\n+  \/\/ When using THP we need to always touch using small pages as the OS will\n+  \/\/ initially always use small pages.\n+  if (LINUX_ONLY(UseTransparentHugePages ||) false) {\n+    return os::vm_page_size();\n+  } else {\n+    return page_size;\n+  }\n+}\n@@ -44,3 +42,4 @@\n-  assert(chunk_size >= page_size,\n-         \"Chunk size \" SIZE_FORMAT \" is smaller than page size \" SIZE_FORMAT,\n-         chunk_size, page_size);\n+static size_t adjusted_chunk_size(size_t page_size) {\n+  \/\/ Chunk size should be at least page size to avoid having multiple\n+  \/\/ threads touching a single page.\n+  return MAX2(PreTouchParallelChunkSize, page_size);\n@@ -49,2 +48,12 @@\n-size_t PretouchTask::chunk_size() {\n-  return PreTouchParallelChunkSize;\n+BasicTouchTask::BasicTouchTask(const char* name,\n+                               void* start,\n+                               void* end,\n+                               size_t page_size) :\n+  AbstractGangTask(name),\n+  _cur(reinterpret_cast<char*>(start)),\n+  _end(end),\n+  _page_size(adjusted_page_size(page_size)),\n+  _chunk_size(adjusted_chunk_size(_page_size))\n+{\n+  assert(start <= end,\n+         \"Invalid range: \" PTR_FORMAT \" -> \" PTR_FORMAT, p2i(start), p2i(end));\n@@ -53,1 +62,1 @@\n-void PretouchTask::work(uint worker_id) {\n+void BasicTouchTask::work(uint worker_id) {\n@@ -55,2 +64,3 @@\n-    char* touch_addr = Atomic::fetch_and_add(&_cur_addr, _chunk_size);\n-    if (touch_addr < _start_addr || touch_addr >= _end_addr) {\n+    char* cur_start = Atomic::load(&_cur);\n+    char* cur_end = cur_start + MIN2(_chunk_size, pointer_delta(_end, cur_start, 1));\n+    if (cur_start >= cur_end) {\n@@ -58,5 +68,3 @@\n-    }\n-\n-    char* end_addr = touch_addr + MIN2(_chunk_size, pointer_delta(_end_addr, touch_addr, sizeof(char)));\n-\n-    os::pretouch_memory(touch_addr, end_addr, _page_size);\n+    } else if (cur_start == Atomic::cmpxchg(&_cur, cur_start, cur_end)) {\n+      do_touch(cur_start, cur_end, _page_size);\n+    } \/\/ Else chunk claim failed, so try again.\n@@ -66,10 +74,14 @@\n-void PretouchTask::pretouch(const char* task_name, char* start_address, char* end_address,\n-                            size_t page_size, WorkGang* pretouch_gang) {\n-  \/\/ Chunk size should be at least (unmodified) page size as using multiple threads\n-  \/\/ pretouch on a single page can decrease performance.\n-  size_t chunk_size = MAX2(PretouchTask::chunk_size(), page_size);\n-#ifdef LINUX\n-  \/\/ When using THP we need to always pre-touch using small pages as the OS will\n-  \/\/ initially always use small pages.\n-  page_size = UseTransparentHugePages ? (size_t)os::vm_page_size() : page_size;\n-#endif\n+void BasicTouchTask::touch_impl(WorkGang* gang) {\n+  size_t total_bytes = pointer_delta(_end, Atomic::load(&_cur), 1);\n+  if ((gang == nullptr) || (total_bytes <= _chunk_size)) {\n+    log_debug(gc, heap)(\"Running %s pre-touching %zuB\", name(), total_bytes);\n+    work(0);\n+  } else {\n+    assert(total_bytes > 0, \"invariant\");\n+    size_t num_chunks = ((total_bytes - 1) \/ _chunk_size) + 1;\n+    uint num_workers = (uint)MIN2(num_chunks, (size_t)gang->total_workers());\n+    log_debug(gc, heap)(\"Running %s with %u workers for %zu chunks touching %zuB\",\n+                        name(), num_workers, num_chunks, total_bytes);\n+    gang->run_task(this, num_workers);\n+  }\n+}\n@@ -77,2 +89,6 @@\n-  PretouchTask task(task_name, start_address, end_address, page_size, chunk_size);\n-  size_t total_bytes = pointer_delta(end_address, start_address, sizeof(char));\n+PretouchTask::PretouchTask(const char* task_name,\n+                           void* start,\n+                           void* end,\n+                           size_t page_size) :\n+  BasicTouchTask(task_name, start, end, page_size)\n+{}\n@@ -80,3 +96,3 @@\n-  if (total_bytes == 0) {\n-    return;\n-  }\n+void PretouchTask::do_touch(void* start, void* end, size_t page_size) {\n+  os::pretouch_memory(start, end, page_size);\n+}\n@@ -84,2 +100,8 @@\n-  if (pretouch_gang != NULL) {\n-    size_t num_chunks = (total_bytes + chunk_size - 1) \/ chunk_size;\n+void PretouchTask::pretouch(const char* task_name,\n+                            void* start,\n+                            void* end,\n+                            size_t page_size,\n+                            WorkGang* pretouch_gang) {\n+  PretouchTask task{task_name, start, end, page_size};\n+  task.touch_impl(pretouch_gang);\n+}\n@@ -87,3 +109,6 @@\n-    uint num_workers = (uint)MIN2(num_chunks, (size_t)pretouch_gang->total_workers());\n-    log_debug(gc, heap)(\"Running %s with %u workers for \" SIZE_FORMAT \" work units pre-touching \" SIZE_FORMAT \"B.\",\n-                        task.name(), num_workers, num_chunks, total_bytes);\n+TouchTask::TouchTask(const char* task_name,\n+                     void* start,\n+                     void* end,\n+                     size_t page_size) :\n+  BasicTouchTask(task_name, start, end, page_size)\n+{}\n@@ -91,6 +116,2 @@\n-    pretouch_gang->run_task(&task, num_workers);\n-  } else {\n-    log_debug(gc, heap)(\"Running %s pre-touching \" SIZE_FORMAT \"B.\",\n-                        task.name(), total_bytes);\n-    task.work(0);\n-  }\n+void TouchTask::do_touch(void* start, void* end, size_t page_size) {\n+  os::touch_memory(start, end, page_size);\n@@ -99,0 +120,8 @@\n+void TouchTask::touch(const char* task_name,\n+                      void* start,\n+                      void* end,\n+                      size_t page_size,\n+                      WorkGang* touch_gang) {\n+  TouchTask task{task_name, start, end, page_size};\n+  task.touch_impl(touch_gang);\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.cpp","additions":79,"deletions":50,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -30,6 +31,15 @@\n-class PretouchTask : public AbstractGangTask {\n-  char* volatile _cur_addr;\n-  char* const _start_addr;\n-  char* const _end_addr;\n-  size_t _page_size;\n-  size_t _chunk_size;\n+class BasicTouchTask : public AbstractGangTask {\n+  char* volatile _cur;\n+  void* const _end;\n+  size_t const _page_size;\n+  size_t const _chunk_size;\n+\n+  NONCOPYABLE(BasicTouchTask);\n+\n+protected:\n+  BasicTouchTask(const char* name, void* start, void* end, size_t page_size);\n+  ~BasicTouchTask() = default;\n+\n+  virtual void do_touch(void* start, void* end, size_t page_size) = 0;\n+\n+  void touch_impl(WorkGang* gang);\n@@ -38,1 +48,2 @@\n-  PretouchTask(const char* task_name, char* start_address, char* end_address, size_t page_size, size_t chunk_size);\n+  void work(uint worker_id) override;\n+};\n@@ -40,1 +51,2 @@\n-  virtual void work(uint worker_id);\n+class PretouchTask : public BasicTouchTask {\n+  PretouchTask(const char* name, void* start, void* end, size_t page_size);\n@@ -42,1 +54,1 @@\n-  static size_t chunk_size();\n+  void do_touch(void* start, void* end, size_t page_size) override;\n@@ -44,2 +56,10 @@\n-  static void pretouch(const char* task_name, char* start_address, char* end_address,\n-                       size_t page_size, WorkGang* pretouch_gang);\n+public:\n+  static void pretouch(const char* task_name,\n+                       void* start,\n+                       void* end,\n+                       size_t page_size,\n+                       WorkGang* pretouch_gang);\n+};\n+\n+class TouchTask : public BasicTouchTask {\n+  TouchTask(const char* name, void* start, void* end, size_t page_size);\n@@ -47,0 +67,8 @@\n+  void do_touch(void* start, void* end, size_t page_size) override;\n+\n+public:\n+  static void touch(const char* task_name,\n+                    void* start,\n+                    void* end,\n+                    size_t page_size,\n+                    WorkGang* touch_gang);\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.hpp","additions":40,"deletions":12,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -1826,0 +1826,37 @@\n+static inline void check_touch_memory_args(void* start, void* end, size_t page_size) {\n+  assert(is_power_of_2(page_size), \"Invalid page size %zu\", page_size);\n+  assert(start <= end, \"Invalid range \" PTR_FORMAT \" -> \" PTR_FORMAT, p2i(start), p2i(end));\n+}\n+\n+\/\/ Touching a page must perform a store.  On many OSes a load from freshly\n+\/\/ committed memory will be satisfied from a single mapped page containing\n+\/\/ all zeros.  We need to store something to a page to ensure it is backed\n+\/\/ by its own memory.\n+\n+static inline void touch_memory_at(volatile void* p, bool allow_concurrent_access) {\n+  if (allow_concurrent_access) {\n+    assert(is_aligned(p, sizeof(int)), \"precondition\");\n+    \/\/ For a touch while other threads may be using the memory, an atomic add\n+    \/\/ of zero is used to perform a write operation without affecting the\n+    \/\/ value in memory.\n+    Atomic::add(reinterpret_cast<volatile int*>(p), 0, memory_order_relaxed);\n+  } else {\n+    \/\/ When pretouching (concurrent access disallowed), writing a zero value\n+    \/\/ is sufficient.\n+    *reinterpret_cast<volatile char*>(p) = 0;\n+  }\n+}\n+\n+static inline void touch_memory_impl(void* start, void* end, size_t page_size,\n+                                     bool allow_concurrent_access) {\n+  if (start < end) {\n+    \/\/ Touch up to the last page, ensuring final increment won't overflow.\n+    void* last_page = align_down(reinterpret_cast<char*>(end) - 1, page_size);\n+    for (char* p = reinterpret_cast<char*>(start); p < last_page; p += page_size) {\n+      touch_memory_at(p, allow_concurrent_access);\n+    }\n+    \/\/ Touch the last (possibly partial) page, which might also be the first.\n+    touch_memory_at(MAX2(start, last_page), allow_concurrent_access);\n+  }\n+}\n+\n@@ -1827,6 +1864,17 @@\n-  for (volatile char *p = (char*)start; p < (char*)end; p += page_size) {\n-    \/\/ Note: this must be a store, not a load. On many OSes loads from fresh\n-    \/\/ memory would be satisfied from a single mapped page containing all zeros.\n-    \/\/ We need to store something to each page to get them backed by their own\n-    \/\/ memory, which is the effect we want here.\n-    *p = 0;\n+  check_touch_memory_args(start, end, page_size);\n+  touch_memory_impl(start, end, page_size, false \/* allow_concurrent_access *\/);\n+}\n+\n+void os::touch_memory(void* start, void* end, size_t page_size) {\n+  check_touch_memory_args(start, end, page_size);\n+  \/\/ We need to ensure the touched addresses are int-aligned because we're\n+  \/\/ using \"nop\" atomic RMW operations to touch the pages.  This means there\n+  \/\/ are a few edge cases with unaligned addresses where we won't touch some\n+  \/\/ pages that overlap the original region.  Touching is a performance\n+  \/\/ heuristic rather than a correctness issue, so covering every corner\n+  \/\/ case isn't essential.  Requiring aligned arguments might add complexity\n+  \/\/ to some callers without any significant benefit.\n+  end = align_down(end, sizeof(int));\n+  if (start < end) {\n+    start = align_up(start, sizeof(int)); \/\/ Can't exceed end.\n+    touch_memory_impl(start, end, page_size, true \/* allow_concurrent_access *\/);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":54,"deletions":6,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -369,4 +369,8 @@\n-  \/\/ to make the OS back the memory range with actual memory.\n-  \/\/ Current implementation may not touch the last page if unaligned addresses\n-  \/\/ are passed.\n-  static void   pretouch_memory(void* start, void* end, size_t page_size = vm_page_size());\n+  \/\/ to make the OS back the memory range with actual memory. pretouch_memory\n+  \/\/ requires exclusive use of the memory range by the caller.  touch_memory\n+  \/\/ permits concurrent use of the memory range by other threads, but may be\n+  \/\/ slower than pretouch_memory.\n+  \/\/ precondition: page_size is a power of 2.\n+  \/\/ precondition: start <= end.\n+  static void pretouch_memory(void* start, void* end, size_t page_size = vm_page_size());\n+  static void touch_memory(void* start, void* end, size_t page_size = vm_page_size());\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"}]}