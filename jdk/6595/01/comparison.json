{"files":[{"patch":"@@ -7033,1 +7033,1 @@\n-void MacroAssembler::kernel_crc32_avx512_256B(Register crc, Register buf, Register len, Register key, Register pos,\n+void MacroAssembler::kernel_crc32_avx512_256B(Register crc, Register buf, Register len, Register table, Register pos,\n@@ -7046,1 +7046,1 @@\n-  movdqu(xmm10, Address(key, 1 * 16));    \/\/rk1 and rk2 in xmm10\n+  movdqu(xmm10, Address(table, 1 * 16));    \/\/rk1 and rk2 in xmm10\n@@ -7073,1 +7073,1 @@\n-  movdqu(xmm10, Address(key, 1 * 16));    \/\/ rk1 and rk2 in xmm10\n+  movdqu(xmm10, Address(table, 1 * 16));    \/\/ rk1 and rk2 in xmm10\n@@ -7193,0 +7193,1 @@\n+* param table address of crc or crc32c table\n@@ -7196,0 +7197,4 @@\n+*\n+* This routine is identical for crc32c with the exception of the precomputed constant\n+* table which will be passed as the table argument.  The calculation steps are\n+* the same for both variants.\n@@ -7197,2 +7202,2 @@\n-void MacroAssembler::kernel_crc32_avx512(Register crc, Register buf, Register len, Register key, Register tmp1, Register tmp2) {\n-  assert_different_registers(crc, buf, len, key, tmp1, tmp2, rax);\n+void MacroAssembler::kernel_crc32_avx512(Register crc, Register buf, Register len, Register table, Register tmp1, Register tmp2) {\n+  assert_different_registers(crc, buf, len, table, tmp1, tmp2, rax, r12);\n@@ -7213,1 +7218,0 @@\n-  lea(key, ExternalAddress(StubRoutines::x86::crc_table_avx512_addr()));\n@@ -7228,1 +7232,1 @@\n-  evbroadcasti32x4(xmm10, Address(key, 2 * 16), Assembler::AVX_512bit); \/\/zmm10 has rk3 and rk4\n+  evbroadcasti32x4(xmm10, Address(table, 2 * 16), Assembler::AVX_512bit); \/\/zmm10 has rk3 and rk4\n@@ -7236,1 +7240,1 @@\n-  evbroadcasti32x4(xmm16, Address(key, 0 * 16), Assembler::AVX_512bit); \/\/zmm16 has rk-1 and rk-2\n+  evbroadcasti32x4(xmm16, Address(table, 0 * 16), Assembler::AVX_512bit); \/\/zmm16 has rk-1 and rk-2\n@@ -7282,2 +7286,2 @@\n-  evmovdquq(xmm16, Address(key, 5 * 16), Assembler::AVX_512bit); \/\/ multiply by rk9-rk16\n-  evmovdquq(xmm11, Address(key, 9 * 16), Assembler::AVX_512bit); \/\/ multiply by rk17-rk20, rk1,rk2, 0,0\n+  evmovdquq(xmm16, Address(table, 5 * 16), Assembler::AVX_512bit); \/\/ multiply by rk9-rk16\n+  evmovdquq(xmm11, Address(table, 9 * 16), Assembler::AVX_512bit); \/\/ multiply by rk17-rk20, rk1,rk2, 0,0\n@@ -7292,1 +7296,1 @@\n-  movdqu(xmm10, Address(key, 1 * 16));\n+  movdqu(xmm10, Address(table, 1 * 16));\n@@ -7308,1 +7312,1 @@\n-  vpclmulqdq(xmm8, xmm7, xmm10, 0x1);\n+  vpclmulqdq(xmm8, xmm7, xmm10, 0x01);\n@@ -7339,1 +7343,1 @@\n-  vpclmulqdq(xmm8, xmm7, xmm10, 0x1);\n+  vpclmulqdq(xmm8, xmm7, xmm10, 0x01);\n@@ -7346,1 +7350,1 @@\n-  movdqu(xmm10, Address(key, 3 * 16));\n+  movdqu(xmm10, Address(table, 3 * 16));\n@@ -7362,1 +7366,1 @@\n-  kernel_crc32_avx512_256B(crc, buf, len, key, pos, tmp1, tmp2, L_barrett, L_16B_reduction_loop, L_get_last_two_xmms, L_128_done, L_cleanup);\n+  kernel_crc32_avx512_256B(crc, buf, len, table, pos, tmp1, tmp2, L_barrett, L_16B_reduction_loop, L_get_last_two_xmms, L_128_done, L_cleanup);\n@@ -7369,1 +7373,1 @@\n-  movdqu(xmm10, Address(key, 4 * 16));\n+  movdqu(xmm10, Address(table, 4 * 16));\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -6531,0 +6531,1 @@\n+      __ lea(table, ExternalAddress(StubRoutines::x86::crc_table_avx512_addr()));\n@@ -6572,0 +6573,1 @@\n+      const Register table = r14;\n@@ -6579,1 +6581,1 @@\n-      assert_different_registers(crc, buf, len, a, j, k, l, y, z);\n+      assert_different_registers(crc, buf, len, a, j, k, l, y, z, table);\n@@ -6587,5 +6589,19 @@\n-      __ crc32c_ipl_alg2_alt2(crc, buf, len,\n-                              a, j, k,\n-                              l, y, z,\n-                              c_farg0, c_farg1, c_farg2,\n-                              is_pclmulqdq_supported);\n+      if (VM_Version::supports_sse4_1() && VM_Version::supports_avx512_vpclmulqdq() &&\n+          VM_Version::supports_avx512bw() &&\n+          VM_Version::supports_avx512vl()) {\n+        \/\/ The constants used in the CRC32 algorithm requires the 1's compliment of the initial crc value.\n+        \/\/ However, the constant table for CRC32-C assumes the original crc value.  Account for this\n+        \/\/ difference before calling and after returning.\n+        __ push(table);\n+        __ lea(table, ExternalAddress(StubRoutines::x86::crc32c_table_avx512_addr()));\n+        __ notl(crc);\n+        __ kernel_crc32_avx512(crc, buf, len, table, l, k);\n+        __ notl(crc);\n+        __ pop(table);\n+      } else {\n+        __ crc32c_ipl_alg2_alt2(crc, buf, len,\n+                                a, j, k,\n+                                l, y, z,\n+                                c_farg0, c_farg1, c_farg2,\n+                                is_pclmulqdq_supported);\n+      }\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":22,"deletions":6,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -224,0 +224,17 @@\n+juint StubRoutines::x86::_crc32c_table_avx512[] =\n+{\n+    0xb9e02b86UL, 0x00000000UL, 0xdcb17aa4UL, 0x00000000UL,\n+    0x493c7d27UL, 0x00000000UL, 0xc1068c50UL, 0x0000000eUL,\n+    0x06e38d70UL, 0x00000002UL, 0x6992cea2UL, 0x00000000UL,\n+    0x493c7d27UL, 0x00000000UL, 0xdd45aab8UL, 0x00000000UL,\n+    0xdea713f0UL, 0x00000000UL, 0x05ec76f0UL, 0x00000001UL,\n+    0x47db8317UL, 0x00000000UL, 0x2ad91c30UL, 0x00000000UL,\n+    0x0715ce53UL, 0x00000000UL, 0xc49f4f67UL, 0x00000000UL,\n+    0x39d3b296UL, 0x00000000UL, 0x083a6eecUL, 0x00000000UL,\n+    0x9e4addf8UL, 0x00000000UL, 0x740eef02UL, 0x00000000UL,\n+    0xddc0152bUL, 0x00000000UL, 0x1c291d04UL, 0x00000000UL,\n+    0xba4fc28eUL, 0x00000000UL, 0x3da6d0cbUL, 0x00000000UL,\n+    0x493c7d27UL, 0x00000000UL, 0xc1068c50UL, 0x0000000eUL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL\n+};\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -140,0 +140,1 @@\n+  static juint    _crc32c_table_avx512[];\n@@ -259,0 +260,1 @@\n+  static address crc32c_table_avx512_addr()  { return (address)_crc32c_table_avx512; }\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.zip.CRC32C;\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 2)\n+@Warmup(iterations = 2, time = 30, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 60, timeUnit = TimeUnit.SECONDS)\n+\n+public class TestCRC32C {\n+\n+    private CRC32C crc32c;\n+    private Random random;\n+    private byte[] bytes;\n+\n+    @Param({\"64\", \"128\", \"256\", \"512\", \"1024\", \"2048\", \"4096\", \"8192\", \"16384\", \"32768\", \"65536\"})\n+    private int count;\n+\n+    public TestCRC32C() {\n+        crc32c = new CRC32C();\n+        random = new Random(2147483648L);\n+        bytes = new byte[1000000];\n+        random.nextBytes(bytes);\n+    }\n+\n+    @Setup(Level.Iteration)\n+    public void setupBytes() {\n+        crc32c.reset();\n+    }\n+\n+    @Benchmark\n+    public void testCRC32CUpdate() {\n+        crc32c.update(bytes, 0, count);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/TestCRC32C.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"}]}