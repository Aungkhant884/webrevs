{"files":[{"patch":"@@ -271,1 +271,0 @@\n-macro(Opaque2)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3164,1 +3164,0 @@\n-  case Op_Opaque2:              \/\/ Remove Opaque Nodes before matching\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2290,12 +2290,1 @@\n-      if (loop_head->unrolled_count() == 1) { \/\/ only for first unroll\n-        \/\/ Separate limit by Opaque node in case it is an incremented\n-        \/\/ variable from previous loop to avoid using pre-incremented\n-        \/\/ value which could increase register pressure.\n-        \/\/ Otherwise reorg_offsets() optimization will create a separate\n-        \/\/ Opaque node for each use of trip-counter and as result\n-        \/\/ zero trip guard limit will be different from loop limit.\n-        assert(has_ctrl(opaq), \"should have it\");\n-        Node* opaq_ctrl = get_ctrl(opaq);\n-        limit = new Opaque2Node(C, limit);\n-        register_new_node(limit, opaq_ctrl);\n-      }\n+      assert(loop_head->unrolled_count() != 1 || has_ctrl(opaq), \"should have opaque for first unroll\");\n@@ -2349,14 +2338,0 @@\n-      if (loop_head->unrolled_count() == 1) {\n-        \/\/ The Opaque2 node created above (in the case of the first unrolling) hides the type of the loop limit.\n-        \/\/ As a result, if the iv Phi constant folds (because it captured the iteration range), the exit test won't\n-        \/\/ constant fold and the graph contains a broken counted loop.\n-        const Type* new_limit_t;\n-        if (stride_con > 0) {\n-          new_limit_t = TypeInt::make(min_jint, limit_type->_hi, limit_type->_widen);\n-        } else {\n-          assert(stride_con < 0, \"stride can't be 0\");\n-          new_limit_t = TypeInt::make(limit_type->_lo, max_jint, limit_type->_widen);\n-        }\n-        new_limit = new CastIINode(new_limit, new_limit_t);\n-        register_new_node(new_limit, ctrl);\n-      }\n@@ -3943,4 +3918,0 @@\n-  \/\/ Minor offset re-organization to remove loop-fallout uses of\n-  \/\/ trip counter when there was no major reshaping.\n-  phase->reorg_offsets(this);\n-\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":1,"deletions":30,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1525,6 +1525,0 @@\n-  \/\/ Reorganize offset computations to lower register pressure.\n-  \/\/ Mostly prevent loop-fallout uses of the pre-incremented trip counter\n-  \/\/ (which are then alive with the post-incremented trip counter\n-  \/\/ forcing an extra register move)\n-  void reorg_offsets( IdealLoopTree *loop );\n-\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1026,2 +1026,1 @@\n-  if (n->is_Opaque1() ||     \/\/ Opaque nodes cannot be mod'd\n-      n_op == Op_Opaque2) {\n+  if (n->is_Opaque1()) { \/\/ Opaque nodes cannot be mod'd\n@@ -1429,8 +1428,0 @@\n-\n-  \/\/ Check for Opaque2's who's loop has disappeared - who's input is in the\n-  \/\/ same loop nest as their output.  Remove 'em, they are no longer useful.\n-  if( n_op == Op_Opaque2 &&\n-      n->in(1) != NULL &&\n-      get_loop(get_ctrl(n)) == get_loop(get_ctrl(n->in(1))) ) {\n-    _igvn.replace_node( n, n->in(1) );\n-  }\n@@ -4109,86 +4100,0 @@\n-\n-\/\/------------------------------reorg_offsets----------------------------------\n-\/\/ Reorganize offset computations to lower register pressure.  Mostly\n-\/\/ prevent loop-fallout uses of the pre-incremented trip counter (which are\n-\/\/ then alive with the post-incremented trip counter forcing an extra\n-\/\/ register move):\n-\/\/\n-\/\/     iv Phi            iv Phi\n-\/\/       |                 |\n-\/\/       |                AddI (+stride)\n-\/\/       |                 |\n-\/\/       |              Opaque2  # Blocks IGVN from folding these nodes until loop opts are over.\n-\/\/       |     ====>       |\n-\/\/       |                AddI (-stride)\n-\/\/       |                 |\n-\/\/       |               CastII  # Preserve type of iv Phi\n-\/\/       |                 |\n-\/\/   Outside Use       Outside Use\n-\/\/\n-void PhaseIdealLoop::reorg_offsets(IdealLoopTree *loop) {\n-  \/\/ Perform it only for canonical counted loops.\n-  \/\/ Loop's shape could be messed up by iteration_split_impl.\n-  if (!loop->_head->is_CountedLoop())\n-    return;\n-  if (!loop->_head->as_Loop()->is_valid_counted_loop(T_INT))\n-    return;\n-\n-  CountedLoopNode *cl = loop->_head->as_CountedLoop();\n-  CountedLoopEndNode *cle = cl->loopexit();\n-  Node *exit = cle->proj_out(false);\n-  Node *phi = cl->phi();\n-\n-  \/\/ Check for the special case when using the pre-incremented trip-counter on\n-  \/\/ the fall-out  path (forces the pre-incremented  and post-incremented trip\n-  \/\/ counter to be live  at the same time).  Fix this by  adjusting to use the\n-  \/\/ post-increment trip counter.\n-\n-  bool progress = true;\n-  while (progress) {\n-    progress = false;\n-    for (DUIterator_Fast imax, i = phi->fast_outs(imax); i < imax; i++) {\n-      Node* use = phi->fast_out(i);   \/\/ User of trip-counter\n-      if (!has_ctrl(use))  continue;\n-      Node *u_ctrl = get_ctrl(use);\n-      if (use->is_Phi()) {\n-        u_ctrl = NULL;\n-        for (uint j = 1; j < use->req(); j++)\n-          if (use->in(j) == phi)\n-            u_ctrl = dom_lca(u_ctrl, use->in(0)->in(j));\n-      }\n-      IdealLoopTree *u_loop = get_loop(u_ctrl);\n-      \/\/ Look for loop-invariant use\n-      if (u_loop == loop) continue;\n-      if (loop->is_member(u_loop)) continue;\n-      \/\/ Check that use is live out the bottom.  Assuming the trip-counter\n-      \/\/ update is right at the bottom, uses of of the loop middle are ok.\n-      if (dom_lca(exit, u_ctrl) != exit) continue;\n-      \/\/ Hit!  Refactor use to use the post-incremented tripcounter.\n-      \/\/ Compute a post-increment tripcounter.\n-      Node* c = exit;\n-      if (cl->is_strip_mined()) {\n-        IdealLoopTree* outer_loop = get_loop(cl->outer_loop());\n-        if (!outer_loop->is_member(u_loop)) {\n-          c = cl->outer_loop_exit();\n-        }\n-      }\n-      Node *opaq = new Opaque2Node(C, cle->incr());\n-      register_new_node(opaq, c);\n-      Node *neg_stride = _igvn.intcon(-cle->stride_con());\n-      set_ctrl(neg_stride, C->root());\n-      Node *post = new AddINode(opaq, neg_stride);\n-      register_new_node(post, c);\n-      post = new CastIINode(post, phi->bottom_type()); \/\/ preserve the iv phi's type\n-      register_new_node(post, c);\n-      _igvn.rehash_node_delayed(use);\n-      for (uint j = 1; j < use->req(); j++) {\n-        if (use->in(j) == phi)\n-          use->set_req(j, post);\n-      }\n-      \/\/ Since DU info changed, rerun loop\n-      progress = true;\n-      break;\n-    }\n-  }\n-\n-}\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":1,"deletions":96,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -2374,1 +2374,0 @@\n-               n->Opcode() == Op_Opaque2   ||\n@@ -2417,1 +2416,1 @@\n-      } else if (n->is_Opaque1() || n->Opcode() == Op_Opaque2) {\n+      } else if (n->is_Opaque1()) {\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,14 +47,2 @@\n-\/\/=============================================================================\n-\/\/ A node to prevent unwanted optimizations.  Allows constant folding.  Stops\n-\/\/ value-numbering, most Ideal calls or Identity functions.  This Node is\n-\/\/ specifically designed to prevent the pre-increment value of a loop trip\n-\/\/ counter from being live out of the bottom of the loop (hence causing the\n-\/\/ pre- and post-increment values both being live and thus requiring an extra\n-\/\/ temp register and an extra move).  If we \"accidentally\" optimize through\n-\/\/ this kind of a Node, we'll get slightly pessimal, but correct, code.  Thus\n-\/\/ it's OK to be slightly sloppy on optimizations here.\n-\n-\/\/ Do NOT remove the opaque node until no more loop opts can happen. Opaque1\n-\/\/ and Opaque2 nodes are removed together in order to optimize loops away\n-\/\/ before macro expansion.\n-Node* Opaque2Node::Identity(PhaseGVN* phase) {\n+\/\/ Do NOT remove the opaque node until no more loop opts can happen.\n+Node* Opaque3Node::Identity(PhaseGVN* phase) {\n@@ -70,2 +58,2 @@\n-uint Opaque2Node::hash() const { return NO_HASH; }\n-bool Opaque2Node::cmp( const Node &n ) const {\n+uint Opaque3Node::hash() const { return NO_HASH; }\n+bool Opaque3Node::cmp(const Node &n) const {\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -73,12 +73,7 @@\n-\/\/------------------------------Opaque2Node------------------------------------\n-\/\/ A node to prevent unwanted optimizations.  Allows constant folding.  Stops\n-\/\/ value-numbering, most Ideal calls or Identity functions.  This Node is\n-\/\/ specifically designed to prevent the pre-increment value of a loop trip\n-\/\/ counter from being live out of the bottom of the loop (hence causing the\n-\/\/ pre- and post-increment values both being live and thus requiring an extra\n-\/\/ temp register and an extra move).  If we \"accidentally\" optimize through\n-\/\/ this kind of a Node, we'll get slightly pessimal, but correct, code.  Thus\n-\/\/ it's OK to be slightly sloppy on optimizations here.\n-class Opaque2Node : public Node {\n-  virtual uint hash() const ;                  \/\/ { return NO_HASH; }\n-  virtual bool cmp( const Node &n ) const;\n+\/\/------------------------------Opaque3Node------------------------------------\n+\/\/ A node to prevent unwanted optimizations. Will be optimized only during\n+\/\/ macro nodes expansion.\n+class Opaque3Node : public Node {\n+  int _opt; \/\/ what optimization it was used for\n+  virtual uint hash() const;\n+  virtual bool cmp(const Node &n) const;\n@@ -86,1 +81,2 @@\n-  Opaque2Node( Compile* C, Node *n ) : Node(0,n) {\n+  enum { RTM_OPT };\n+  Opaque3Node(Compile* C, Node* n, int opt) : Node(0, n), _opt(opt) {\n@@ -94,11 +90,0 @@\n-};\n-\n-\/\/------------------------------Opaque3Node------------------------------------\n-\/\/ A node to prevent unwanted optimizations. Will be optimized only during\n-\/\/ macro nodes expansion.\n-class Opaque3Node : public Opaque2Node {\n-  int _opt; \/\/ what optimization it was used for\n-  public:\n-  enum { RTM_OPT };\n-  Opaque3Node(Compile* C, Node *n, int opt) : Opaque2Node(C, n), _opt(opt) {}\n-  virtual int Opcode() const;\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":9,"deletions":24,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2102,1 +2102,0 @@\n-  case Op_Opaque2:\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -72,9 +72,0 @@\n-\n-    \/\/ Also catch: \"(X + Opaque2(Y)) - Y\".  In this case, 'Y' is a loop-varying\n-    \/\/ trip counter and X is likely to be loop-invariant (that's how O2 Nodes\n-    \/\/ are originally used, although the optimizer sometimes jiggers things).\n-    \/\/ This folding through an O2 removes a loop-exit use of a loop-varying\n-    \/\/ value and generally lowers register pressure in and around the loop.\n-    if (in(1)->in(2)->Opcode() == Op_Opaque2 && in(1)->in(2)->in(1) == in(2)) {\n-      return in(1)->in(1);\n-    }\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1573,1 +1573,0 @@\n-  declare_c2_type(Opaque2Node, Node)                                      \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}