{"files":[{"patch":"@@ -7139,1 +7139,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n@@ -7508,1 +7508,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n@@ -8181,1 +8181,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n@@ -8372,1 +8372,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n@@ -8579,1 +8579,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3681,11 +3681,0 @@\n-operand no_rax_RegL()\n-%{\n-  constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));\n-  match(RegL);\n-  match(rRegL);\n-  match(rdx_RegL);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -7670,1 +7659,1 @@\n-  ins_cost(125); \/\/ XXX\n+  ins_cost(150); \/\/ XXX\n@@ -7840,1 +7829,1 @@\n-  ins_cost(125); \/\/ XXX\n+  ins_cost(150); \/\/ XXX\n@@ -8516,12 +8505,0 @@\n-instruct subI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)\n-%{\n-  match(Set dst (SubI dst src));\n-  effect(KILL cr);\n-\n-  format %{ \"subl    $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ subl($dst$$Register, $src$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n@@ -8533,1 +8510,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n@@ -8554,13 +8531,0 @@\n-instruct subI_mem_imm(memory dst, immI src, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreI dst (SubI (LoadI dst) src)));\n-  effect(KILL cr);\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"subl    $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ subl($dst$$Address, $src$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n@@ -8579,12 +8543,0 @@\n-instruct subL_rReg_imm(rRegI dst, immL32 src, rFlagsReg cr)\n-%{\n-  match(Set dst (SubL dst src));\n-  effect(KILL cr);\n-\n-  format %{ \"subq    $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ subq($dst$$Register, $src$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n@@ -8596,1 +8548,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n@@ -8617,13 +8569,0 @@\n-instruct subL_mem_imm(memory dst, immL32 src, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreL dst (SubL (LoadL dst) src)));\n-  effect(KILL cr);\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"subq    $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ subq($dst$$Address, $src$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n@@ -8833,1 +8772,1 @@\n-instruct mulHiL_rReg(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)\n+instruct mulHiL_rReg(rdx_RegL dst, rRegL src, rax_RegL rax, rFlagsReg cr)\n@@ -8846,1 +8785,1 @@\n-instruct umulHiL_rReg(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)\n+instruct umulHiL_rReg(rdx_RegL dst, rRegL src, rax_RegL rax, rFlagsReg cr)\n@@ -8999,65 +8938,0 @@\n-\n-\/\/----------- DivL-By-Constant-Expansions--------------------------------------\n-\/\/ DivI cases are handled by the compiler\n-\n-\/\/ Magic constant, reciprocal of 10\n-instruct loadConL_0x6666666666666667(rRegL dst)\n-%{\n-  effect(DEF dst);\n-\n-  format %{ \"movq    $dst, #0x666666666666667\\t# Used in div-by-10\" %}\n-  ins_encode(load_immL(dst, 0x6666666666666667));\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct mul_hi(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)\n-%{\n-  effect(DEF dst, USE src, USE_KILL rax, KILL cr);\n-\n-  format %{ \"imulq   rdx:rax, rax, $src\\t# Used in div-by-10\" %}\n-  ins_encode %{\n-    __ imulq($src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n-instruct sarL_rReg_63(rRegL dst, rFlagsReg cr)\n-%{\n-  effect(USE_DEF dst, KILL cr);\n-\n-  format %{ \"sarq    $dst, #63\\t# Used in div-by-10\" %}\n-  ins_encode %{\n-    __ sarq($dst$$Register, 63);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct sarL_rReg_2(rRegL dst, rFlagsReg cr)\n-%{\n-  effect(USE_DEF dst, KILL cr);\n-\n-  format %{ \"sarq    $dst, #2\\t# Used in div-by-10\" %}\n-  ins_encode %{\n-    __ sarq($dst$$Register, 2);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct divL_10(rdx_RegL dst, no_rax_RegL src, immL10 div)\n-%{\n-  match(Set dst (DivL src div));\n-\n-  ins_cost((5+8)*100);\n-  expand %{\n-    rax_RegL rax;                     \/\/ Killed temp\n-    rFlagsReg cr;                     \/\/ Killed\n-    loadConL_0x6666666666666667(rax); \/\/ movq  rax, 0x6666666666666667\n-    mul_hi(dst, src, rax, cr);        \/\/ mulq  rdx:rax <= rax * $src\n-    sarL_rReg_63(src, cr);            \/\/ sarq  src, 63\n-    sarL_rReg_2(dst, cr);             \/\/ sarq  rdx, 2\n-    subL_rReg(dst, src, cr);          \/\/ subl  rdx, src\n-  %}\n-%}\n-\n-\/\/-----------------------------------------------------------------------------\n-\n@@ -9130,26 +9004,0 @@\n-\/\/ Shift Left by one\n-instruct salI_rReg_1(rRegI dst, immI_1 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (LShiftI dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"sall    $dst, $shift\" %}\n-  ins_encode %{\n-    __ sall($dst$$Register, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Shift Left by one\n-instruct salI_mem_1(memory dst, immI_1 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));\n-  effect(KILL cr);\n-\n-  format %{ \"sall    $dst, $shift\\t\" %}\n-  ins_encode %{\n-    __ sall($dst$$Address, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n@@ -9234,26 +9082,0 @@\n-\/\/ Arithmetic shift right by one\n-instruct sarI_rReg_1(rRegI dst, immI_1 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (RShiftI dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"sarl    $dst, $shift\" %}\n-  ins_encode %{\n-    __ sarl($dst$$Register, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Arithmetic shift right by one\n-instruct sarI_mem_1(memory dst, immI_1 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));\n-  effect(KILL cr);\n-\n-  format %{ \"sarl    $dst, $shift\" %}\n-  ins_encode %{\n-    __ sarl($dst$$Address, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n@@ -9337,26 +9159,0 @@\n-\/\/ Logical shift right by one\n-instruct shrI_rReg_1(rRegI dst, immI_1 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (URShiftI dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"shrl    $dst, $shift\" %}\n-  ins_encode %{\n-    __ shrl($dst$$Register, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Logical shift right by one\n-instruct shrI_mem_1(memory dst, immI_1 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));\n-  effect(KILL cr);\n-\n-  format %{ \"shrl    $dst, $shift\" %}\n-  ins_encode %{\n-    __ shrl($dst$$Address, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n@@ -9442,26 +9238,0 @@\n-\/\/ Shift Left by one\n-instruct salL_rReg_1(rRegL dst, immI_1 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (LShiftL dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"salq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ salq($dst$$Register, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Shift Left by one\n-instruct salL_mem_1(memory dst, immI_1 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));\n-  effect(KILL cr);\n-\n-  format %{ \"salq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ salq($dst$$Address, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n@@ -9546,26 +9316,0 @@\n-\/\/ Arithmetic shift right by one\n-instruct sarL_rReg_1(rRegL dst, immI_1 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (RShiftL dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"sarq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ sarq($dst$$Register, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Arithmetic shift right by one\n-instruct sarL_mem_1(memory dst, immI_1 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));\n-  effect(KILL cr);\n-\n-  format %{ \"sarq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ sarq($dst$$Address, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n@@ -9650,26 +9394,0 @@\n-\/\/ Logical shift right by one\n-instruct shrL_rReg_1(rRegL dst, immI_1 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (URShiftL dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"shrq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ shrq($dst$$Register, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Logical shift right by one\n-instruct shrL_mem_1(memory dst, immI_1 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));\n-  effect(KILL cr);\n-\n-  format %{ \"shrq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ shrq($dst$$Address, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n@@ -10046,1 +9764,1 @@\n-instruct andI_rReg_imm255(rRegI dst, immI_255 src)\n+instruct andI_rReg_imm255(rRegI dst, rRegI src, immI_255 mask)\n@@ -10048,1 +9766,1 @@\n-  match(Set dst (AndI dst src));\n+  match(Set dst (AndI src mask));\n@@ -10050,1 +9768,1 @@\n-  format %{ \"movzbl  $dst, $dst\\t# int & 0xFF\" %}\n+  format %{ \"movzbl  $dst, $src\\t# int & 0xFF\" %}\n@@ -10052,1 +9770,1 @@\n-    __ movzbl($dst$$Register, $dst$$Register);\n+    __ movzbl($dst$$Register, $src$$Register);\n@@ -10070,1 +9788,1 @@\n-instruct andI_rReg_imm65535(rRegI dst, immI_65535 src)\n+instruct andI_rReg_imm65535(rRegI dst, rRegI src, immI_65535 mask)\n@@ -10072,1 +9790,1 @@\n-  match(Set dst (AndI dst src));\n+  match(Set dst (AndI src mask));\n@@ -10074,1 +9792,1 @@\n-  format %{ \"movzwl  $dst, $dst\\t# int & 0xFFFF\" %}\n+  format %{ \"movzwl  $dst, $src\\t# int & 0xFFFF\" %}\n@@ -10076,1 +9794,1 @@\n-    __ movzwl($dst$$Register, $dst$$Register);\n+    __ movzwl($dst$$Register, $src$$Register);\n@@ -10127,1 +9845,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n@@ -10325,1 +10043,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n@@ -10418,1 +10136,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n@@ -10485,1 +10203,1 @@\n-instruct andL_rReg_imm255(rRegL dst, immL_255 src)\n+instruct andL_rReg_imm255(rRegL dst, rRegL src, immL_255 mask)\n@@ -10487,1 +10205,1 @@\n-  match(Set dst (AndL dst src));\n+  match(Set dst (AndL src mask));\n@@ -10489,1 +10207,1 @@\n-  format %{ \"movzbq  $dst, $dst\\t# long & 0xFF\" %}\n+  format %{ \"movzbl  $dst, $src\\t# long & 0xFF\" %}\n@@ -10491,1 +10209,2 @@\n-    __ movzbq($dst$$Register, $dst$$Register);\n+    \/\/ movzbl zeroes out the upper 32-bit and does not need REX.W\n+    __ movzbl($dst$$Register, $src$$Register);\n@@ -10497,1 +10216,1 @@\n-instruct andL_rReg_imm65535(rRegL dst, immL_65535 src)\n+instruct andL_rReg_imm65535(rRegL dst, rRegL src, immL_65535 mask)\n@@ -10499,1 +10218,1 @@\n-  match(Set dst (AndL dst src));\n+  match(Set dst (AndL src mask));\n@@ -10501,1 +10220,1 @@\n-  format %{ \"movzwq  $dst, $dst\\t# long & 0xFFFF\" %}\n+  format %{ \"movzwl  $dst, $src\\t# long & 0xFFFF\" %}\n@@ -10503,1 +10222,2 @@\n-    __ movzwq($dst$$Register, $dst$$Register);\n+    \/\/ movzwl zeroes out the upper 32-bit and does not need REX.W\n+    __ movzwl($dst$$Register, $src$$Register);\n@@ -10527,1 +10247,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n@@ -10742,1 +10462,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n@@ -10839,1 +10559,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":30,"deletions":310,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler.x86;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 3, jvmArgsAppend = \"-XX:-UseSuperWord\")\n+@Warmup(time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(time = 1, timeUnit = TimeUnit.SECONDS)\n+public class BasicRules {\n+    static final int[] INT_ARRAY = new int[1024];\n+    static final long[] LONG_ARRAY = new long[1024];\n+\n+    @Benchmark\n+    public void andL_rReg_imm255(Blackhole bh) {\n+        for (int i = 0; i < LONG_ARRAY.length; i++) {\n+            long v = LONG_ARRAY[i];\n+            bh.consume(v);\n+            bh.consume(v & 0xFFL);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void andL_rReg_imm65535(Blackhole bh) {\n+        for (int i = 0; i < LONG_ARRAY.length; i++) {\n+            long v = LONG_ARRAY[i];\n+            bh.consume(v);\n+            bh.consume(v & 0xFFFFL);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void add_mem_con(Blackhole bh) {\n+        for (int i = 0; i < INT_ARRAY.length; i++) {\n+            bh.consume(INT_ARRAY[i] + 100);\n+        }\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/x86\/BasicRules.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -23,1 +23,1 @@\n-package org.openjdk.bench.vm.compiler;\n+package org.openjdk.bench.vm.compiler.x86;\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/x86\/LeaInstruction.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/LeaInstruction.java","status":"renamed"}]}