{"files":[{"patch":"@@ -3280,0 +3280,1 @@\n+      register_new_survivor_region_with_region_attr(new_alloc_region);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -608,0 +608,1 @@\n+  inline void register_new_survivor_region_with_region_attr(HeapRegion* r);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -187,0 +187,4 @@\n+void G1CollectedHeap::register_new_survivor_region_with_region_attr(HeapRegion* r) {\n+  _region_attr.set_new_survivor_region(r->hrm_index());\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"gc\/g1\/g1RedirtyCardsQueue.hpp\"\n@@ -41,39 +40,0 @@\n-class UpdateLogBuffersDeferred : public BasicOopIterateClosure {\n-private:\n-  G1CollectedHeap* _g1h;\n-  G1RedirtyCardsLocalQueueSet* _rdc_local_qset;\n-  G1CardTable*    _ct;\n-\n-  \/\/ Remember the last enqueued card to avoid enqueuing the same card over and over;\n-  \/\/ since we only ever handle a card once, this is sufficient.\n-  size_t _last_enqueued_card;\n-\n-public:\n-  UpdateLogBuffersDeferred(G1RedirtyCardsLocalQueueSet* rdc_local_qset) :\n-    _g1h(G1CollectedHeap::heap()),\n-    _rdc_local_qset(rdc_local_qset),\n-    _ct(_g1h->card_table()),\n-    _last_enqueued_card(SIZE_MAX) {}\n-\n-  virtual void do_oop(narrowOop* p) { do_oop_work(p); }\n-  virtual void do_oop(      oop* p) { do_oop_work(p); }\n-  template <class T> void do_oop_work(T* p) {\n-    assert(_g1h->heap_region_containing(p)->is_in_reserved(p), \"paranoia\");\n-    assert(!_g1h->heap_region_containing(p)->is_survivor(), \"Unexpected evac failure in survivor region\");\n-\n-    T const o = RawAccess<>::oop_load(p);\n-    if (CompressedOops::is_null(o)) {\n-      return;\n-    }\n-\n-    if (HeapRegion::is_in_same_region(p, CompressedOops::decode(o))) {\n-      return;\n-    }\n-    size_t card_index = _ct->index_for(p);\n-    if (card_index != _last_enqueued_card) {\n-      _rdc_local_qset->enqueue(_ct->byte_for_index(card_index));\n-      _last_enqueued_card = card_index;\n-    }\n-  }\n-};\n-\n@@ -85,1 +45,0 @@\n-  UpdateLogBuffersDeferred* _log_buffer_cl;\n@@ -92,1 +51,0 @@\n-                                 UpdateLogBuffersDeferred* log_buffer_cl,\n@@ -99,1 +57,0 @@\n-    _log_buffer_cl(log_buffer_cl),\n@@ -144,14 +101,0 @@\n-      \/\/ While we were processing RSet buffers during the collection,\n-      \/\/ we actually didn't scan any cards on the collection set,\n-      \/\/ since we didn't want to update remembered sets with entries\n-      \/\/ that point into the collection set, given that live objects\n-      \/\/ from the collection set are about to move and such entries\n-      \/\/ will be stale very soon.\n-      \/\/ This change also dealt with a reliability issue which\n-      \/\/ involved scanning a card in the collection set and coming\n-      \/\/ across an array that was being chunked and looking malformed.\n-      \/\/ The problem is that, if evacuation fails, we might have\n-      \/\/ remembered set entries missing given that we skipped cards on\n-      \/\/ the collection set. So, we'll recreate such entries now.\n-      obj->oop_iterate(_log_buffer_cl);\n-\n@@ -206,3 +149,0 @@\n-  G1RedirtyCardsLocalQueueSet _rdc_local_qset;\n-  UpdateLogBuffersDeferred _log_buffer_cl;\n-\n@@ -213,2 +153,1 @@\n-  RemoveSelfForwardPtrHRClosure(G1RedirtyCardsQueueSet* rdcqs,\n-                                uint worker_id,\n+  RemoveSelfForwardPtrHRClosure(uint worker_id,\n@@ -219,2 +158,0 @@\n-    _rdc_local_qset(rdcqs),\n-    _log_buffer_cl(&_rdc_local_qset),\n@@ -225,4 +162,0 @@\n-  ~RemoveSelfForwardPtrHRClosure() {\n-    _rdc_local_qset.flush();\n-  }\n-\n@@ -232,1 +165,0 @@\n-                                        &_log_buffer_cl,\n@@ -271,2 +203,1 @@\n-G1ParRemoveSelfForwardPtrsTask::G1ParRemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs,\n-                                                               G1EvacFailureRegions* evac_failure_regions) :\n+G1ParRemoveSelfForwardPtrsTask::G1ParRemoveSelfForwardPtrsTask(G1EvacFailureRegions* evac_failure_regions) :\n@@ -275,1 +206,0 @@\n-  _rdcqs(rdcqs),\n@@ -281,1 +211,1 @@\n-  RemoveSelfForwardPtrHRClosure rsfp_cl(_rdcqs, worker_id, &_num_failed_regions, _evac_failure_regions);\n+  RemoveSelfForwardPtrHRClosure rsfp_cl(worker_id, &_num_failed_regions, _evac_failure_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":3,"deletions":73,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-class G1RedirtyCardsQueueSet;\n@@ -42,1 +41,0 @@\n-  G1RedirtyCardsQueueSet* _rdcqs;\n@@ -49,1 +47,1 @@\n-  G1ParRemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs, G1EvacFailureRegions* evac_failure_regions);\n+  G1ParRemoveSelfForwardPtrsTask(G1EvacFailureRegions* evac_failure_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,2 +60,3 @@\n-  static const region_type_t Optional     =  -3;    \/\/ The region is optional not in the current collection set.\n-  static const region_type_t Humongous    =  -2;    \/\/ The region is a humongous candidate not in the current collection set.\n+  static const region_type_t Optional     =  -4;    \/\/ The region is optional not in the current collection set.\n+  static const region_type_t Humongous    =  -3;    \/\/ The region is a humongous candidate not in the current collection set.\n+  static const region_type_t NewSurvivor  =  -2;    \/\/ The region is a new (ly allocated) survivor region.\n@@ -79,0 +80,1 @@\n+      case NewSurvivor: return \"NewSurvivor\";\n@@ -88,0 +90,1 @@\n+  void set_new_survivor()              { _type = NewSurvivor; }\n@@ -99,0 +102,1 @@\n+  bool is_new_survivor() const         { return type() == NewSurvivor; }\n@@ -131,0 +135,6 @@\n+  void set_new_survivor_region(uintptr_t index) {\n+    assert(get_by_index(index).is_default(),\n+           \"Region attributes at index \" INTPTR_FORMAT \" should be default but is %s\", index, get_by_index(index).get_type_str());\n+    get_ref_by_index(index)->set_new_survivor();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionAttr.hpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-  G1SkipCardEnqueueSetter(G1ScanEvacuatedObjClosure* closure, bool new_value) : _closure(closure) {\n+  G1SkipCardEnqueueSetter(G1ScanEvacuatedObjClosure* closure, bool skip_card_enqueue) : _closure(closure) {\n@@ -121,1 +121,1 @@\n-    _closure->_skip_card_enqueue = new_value ? G1ScanEvacuatedObjClosure::True : G1ScanEvacuatedObjClosure::False;\n+    _closure->_skip_card_enqueue = skip_card_enqueue ? G1ScanEvacuatedObjClosure::True : G1ScanEvacuatedObjClosure::False;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -238,2 +238,2 @@\n-  HeapRegion* hr = _g1h->heap_region_containing(to_array);\n-  G1SkipCardEnqueueSetter x(&_scanner, hr->is_young());\n+  G1HeapRegionAttr dest_attr = _g1h->region_attr(to_array);\n+  G1SkipCardEnqueueSetter x(&_scanner, dest_attr.is_new_survivor());\n@@ -271,0 +271,5 @@\n+  \/\/ Skip the card enqueue iff the object (to_array) is in survivor region.\n+  \/\/ However, HeapRegion::is_survivor() is too expensive here.\n+  \/\/ Instead, we use dest_attr.is_young() because the two values are always\n+  \/\/ equal: successfully allocated young regions must be survivor regions.\n+  assert(dest_attr.is_young() == _g1h->heap_region_containing(to_array)->is_survivor(), \"must be\");\n@@ -522,0 +527,5 @@\n+    \/\/ Skip the card enqueue iff the object (obj) is in survivor region.\n+    \/\/ However, HeapRegion::is_survivor() is too expensive here.\n+    \/\/ Instead, we use dest_attr.is_young() because the two values are always\n+    \/\/ equal: successfully allocated young regions must be survivor regions.\n+    assert(dest_attr.is_young() == _g1h->heap_region_containing(obj)->is_survivor(), \"must be\");\n@@ -608,1 +618,8 @@\n-    G1SkipCardEnqueueSetter x(&_scanner, r->is_young());\n+    \/\/ For iterating objects that failed evacuation currently we can reuse the\n+    \/\/ existing closure to scan evacuated objects because:\n+    \/\/ - for objects referring into the collection set we do not need to gather\n+    \/\/ cards at this time. The regions they are in will be unconditionally turned\n+    \/\/ to old regions without remembered sets.\n+    \/\/ - since we are iterating from a collection set region (i.e. never a Survivor\n+    \/\/ region), we always need to gather cards for this case.\n+    G1SkipCardEnqueueSetter x(&_scanner, false \/* skip_card_enqueue *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-  \/\/ p and q are in the same region, p is in survivor)\n+  \/\/ p and q are in the same region, p is in survivor, p is in collection set)\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-  assert(obj != NULL, \"Must be\");\n+  assert(obj != nullptr, \"Must be\");\n@@ -104,3 +104,14 @@\n-  HeapRegion* from = _g1h->heap_region_containing(p);\n-  if (!from->is_young()) {\n-    enqueue_card_if_tracked(_g1h->region_attr(obj), p, obj);\n+  G1HeapRegionAttr from_attr = _g1h->region_attr(p);\n+  \/\/ If this is a reference from (current) survivor regions, we do not need\n+  \/\/ to track references from it.\n+  if (from_attr.is_new_survivor()) {\n+    return;\n+  }\n+  G1HeapRegionAttr dest_attr = _g1h->region_attr(obj);\n+  \/\/ References to the current collection set are references to objects that failed\n+  \/\/ evacuation. Currently these regions are always relabelled as old without\n+  \/\/ remembered sets, so skip them.\n+  assert(dest_attr.is_in_cset() == (obj->forwardee() == obj),\n+         \"Only evac-failed objects must be in the collection set here but \" PTR_FORMAT \" is not\", p2i(obj));\n+  if (dest_attr.is_in_cset()) {\n+    return;\n@@ -108,0 +119,1 @@\n+  enqueue_card_if_tracked(dest_attr, p, obj);\n@@ -112,1 +124,4 @@\n-  assert(!_g1h->heap_region_containing(p)->is_young(), \"Should have filtered out from-young references already.\");\n+  assert(!_g1h->heap_region_containing(p)->is_survivor(), \"Should have filtered out from-newly allocated survivor references already.\");\n+  \/\/ We relabel all regions that failed evacuation as old gen without remembered,\n+  \/\/ and so pre-filter them out in the caller.\n+  assert(!_g1h->heap_region_containing(o)->in_collection_set(), \"Should not try to enqueue reference into collection set region\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.inline.hpp","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/javaClasses.inline.hpp\"\n@@ -914,0 +915,25 @@\n+  \/\/ Special closure for enqueuing discovered fields: during enqueue the card table\n+  \/\/ may not be in shape to properly handle normal barrier calls (e.g. card marks\n+  \/\/ in regions that failed evacuation, scribbling of various values by card table\n+  \/\/ scan code). Additionally the regular barrier enqueues into the \"global\"\n+  \/\/ DCQS, but during GC we need these to-be-refined entries in the GC local queue\n+  \/\/ so that after clearing the card table, the redirty cards phase will properly\n+  \/\/ mark all dirty cards to be picked up by refinement.\n+  class G1EnqueueDiscoveredFieldClosure : public EnqueueDiscoveredFieldClosure {\n+    G1CollectedHeap* _g1h;\n+    G1ParScanThreadState* _pss;\n+\n+  public:\n+    G1EnqueueDiscoveredFieldClosure(G1CollectedHeap* g1h, G1ParScanThreadState* pss) : _g1h(g1h), _pss(pss) { }\n+\n+    void enqueue(HeapWord* discovered_field_addr, oop value) override {\n+      assert(_g1h->is_in(discovered_field_addr), PTR_FORMAT \" is not in heap \", p2i(discovered_field_addr));\n+      \/\/ Store the value first, whatever it is.\n+      RawAccess<>::oop_store(discovered_field_addr, value);\n+      if (value == nullptr) {\n+        return;\n+      }\n+      _pss->write_ref_field_post(discovered_field_addr, value);\n+    }\n+  };\n+\n@@ -931,1 +957,1 @@\n-    BarrierEnqueueDiscoveredFieldClosure enqueue;\n+    G1EnqueueDiscoveredFieldClosure enqueue(&_g1h, pss);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -145,1 +145,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-  RemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs, G1EvacFailureRegions* evac_failure_regions) :\n+  RemoveSelfForwardPtrsTask(G1EvacFailureRegions* evac_failure_regions) :\n@@ -107,1 +107,1 @@\n-    _task(rdcqs, evac_failure_regions),\n+    _task(evac_failure_regions),\n@@ -138,1 +138,1 @@\n-    add_parallel_task(new RemoveSelfForwardPtrsTask(per_thread_states->rdcqs(), evac_failure_regions));\n+    add_parallel_task(new RemoveSelfForwardPtrsTask(evac_failure_regions));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-class G1RedirtyCardsQueueSet;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -221,4 +222,4 @@\n-void BarrierEnqueueDiscoveredFieldClosure::enqueue(oop reference, oop value) {\n-  HeapAccess<AS_NO_KEEPALIVE>::oop_store_at(reference,\n-                                            java_lang_ref_Reference::discovered_offset(),\n-                                            value);\n+void BarrierEnqueueDiscoveredFieldClosure::enqueue(HeapWord* discovered_field_addr, oop value) {\n+  assert(Universe::heap()->is_in(discovered_field_addr), PTR_FORMAT \" not in heap\", p2i(discovered_field_addr));\n+  HeapAccess<AS_NO_KEEPALIVE>::oop_store(discovered_field_addr,\n+                                         value);\n@@ -258,3 +259,2 @@\n-  \/\/ Remove Reference object from discovered list. Note that G1 does not need a\n-  \/\/ pre-barrier here because we know the Reference has already been found\/marked,\n-  \/\/ that's how it ended up in the discovered list in the first place.\n+  \/\/ Remove Reference object from discovered list. We do not need barriers here,\n+  \/\/ as we only remove. We will do the barrier when we actually advance the cursor.\n@@ -280,1 +280,5 @@\n-  _enqueue->enqueue(_current_discovered, _next_discovered);\n+  if (_prev_discovered_addr != _refs_list.adr_head()) {\n+    _enqueue->enqueue(_prev_discovered_addr, _current_discovered);\n+  } else {\n+    RawAccess<>::oop_store(_prev_discovered_addr, _current_discovered);\n+  }\n@@ -289,1 +293,1 @@\n-    _enqueue->enqueue(_prev_discovered, old);\n+    _enqueue->enqueue(java_lang_ref_Reference::discovered_addr_raw(_prev_discovered), old);\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -50,2 +50,3 @@\n-  \/\/ For the given j.l.ref.Reference reference, set the discovered field to value.\n-  virtual void enqueue(oop reference, oop value) = 0;\n+  \/\/ For the given j.l.ref.Reference discovered field address, set the discovered\n+  \/\/ field to value and apply any barriers to it.\n+  virtual void enqueue(HeapWord* discovered_field_addr, oop value) = 0;\n@@ -55,1 +56,1 @@\n-\/\/ field of the j.l.ref.Reference reference with the given value.\n+\/\/ field of the j.l.ref.Reference with the given value.\n@@ -58,1 +59,1 @@\n-  void enqueue(oop reference, oop value) override;\n+  void enqueue(HeapWord* discovered_field_addr, oop value) override;\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"}]}