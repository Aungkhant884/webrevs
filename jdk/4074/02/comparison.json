{"files":[{"patch":"@@ -63,0 +63,1 @@\n+import com.sun.tools.javac.util.Options;\n@@ -539,0 +540,17 @@\n+    \/**\n+     * Returns whether or not to permit dynamically loaded components to access\n+     * part of the javadoc internal API. The flag is the same (hidden) compiler\n+     * option that allows javac plugins and annotation processors to access\n+     * javac internal API.\n+     *\n+     * As with all workarounds, it is better to consider updating the public API,\n+     * rather than relying on undocumented features like this, that may be withdrawn\n+     * at any time, without notice.\n+     *\n+     * @return true if access is permitted to internal API\n+     *\/\n+    public boolean accessInternalAPI() {\n+        Options compilerOptions = Options.instance(toolEnv.context);\n+        return compilerOptions.isSet(\"accessInternalAPI\");\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/WorkArounds.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -188,0 +188,2 @@\n+    private final BaseConfiguration configuration;\n+\n@@ -200,0 +202,1 @@\n+        this.configuration = configuration;\n@@ -226,2 +229,1 @@\n-        if (fileManager instanceof StandardJavaFileManager) {\n-            StandardJavaFileManager sfm = (StandardJavaFileManager)fileManager;\n+        if (fileManager instanceof StandardJavaFileManager sfm) {\n@@ -254,0 +256,9 @@\n+            if (configuration.workArounds.accessInternalAPI()) {\n+                Module thisModule = getClass().getModule();\n+                Module tagletLoaderUnnamedModule = tagClassLoader.getUnnamedModule();\n+                List<String> pkgs = List.of(\n+                        \"jdk.javadoc.doclet\",\n+                        \"jdk.javadoc.internal.doclets.toolkit\",\n+                        \"jdk.javadoc.internal.doclets.formats.html\");\n+                pkgs.forEach(p -> thisModule.addOpens(p, tagletLoaderUnnamedModule));\n+            }\n@@ -556,2 +567,1 @@\n-                if (e instanceof DocletElement) {\n-                    DocletElement de = (DocletElement) e;\n+                if (e instanceof DocletElement de) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/TagletManager.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+import com.sun.source.doctree.BlockTagTree;\n@@ -2634,4 +2635,4 @@\n-            if (taglet instanceof BaseTaglet) {\n-                return ((BaseTaglet) taglet).accepts(t);\n-            } else if (t instanceof UnknownBlockTagTree) {\n-                return ((UnknownBlockTagTree) t).getTagName().equals(taglet.getName());\n+            if (taglet instanceof BaseTaglet baseTaglet) {\n+                return baseTaglet.accepts(t);\n+            } else if (t instanceof BlockTagTree blockTagTree) {\n+                return blockTagTree.getTagName().equals(taglet.getName());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -570,1 +570,1 @@\n-                        messager.printWarning(dep, \"main.module_source_not_found\", dep.getQualifiedName());\n+                        messager.printWarningUsingKey(dep, \"main.module_source_not_found\", dep.getQualifiedName());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/ElementsTable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-\n@@ -30,0 +29,4 @@\n+import java.lang.ref.Reference;\n+import java.lang.ref.SoftReference;\n+import java.util.EnumSet;\n+import java.util.LinkedHashMap;\n@@ -31,0 +34,1 @@\n+import java.util.Map;\n@@ -32,0 +36,1 @@\n+import java.util.Set;\n@@ -34,0 +39,1 @@\n+import javax.tools.Diagnostic;\n@@ -35,0 +41,1 @@\n+import javax.tools.JavaFileObject;\n@@ -36,1 +43,0 @@\n-import com.sun.tools.javac.util.Context.Factory;\n@@ -38,0 +44,4 @@\n+\n+import com.sun.tools.javac.tree.EndPosTable;\n+import com.sun.tools.javac.util.Context.Factory;\n+import com.sun.tools.javac.util.DiagnosticSource;\n@@ -42,1 +52,0 @@\n-import com.sun.tools.javac.api.JavacTrees;\n@@ -46,0 +55,2 @@\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n@@ -51,3 +62,50 @@\n- * Utility for integrating with javadoc tools and for localization.\n- * Handle resources, access to error and warning counts and\n- * message formatting.\n+ * Class for reporting diagnostics and other messages.\n+ *\n+ * The class leverages the javac support for reporting diagnostics, for stylistic consistency\n+ * of diagnostic messages and to avoid code duplication.\n+ *\n+ * The class is a subtype of javac's Log, and is primarily an adapter between\n+ * javadoc method signatures and the underlying javac methods. Within this class,\n+ * the methods call down to a core {@code report} method which hands off to\n+ * a similar method in the superclass ({@code Log.report}, which takes care\n+ * of reporting the diagnostic (unless it has been suppressed), displaying\n+ * the source line and a caret to indicate the position of the issue (if appropriate),\n+ * counting errors and warnings, and so on.\n+ *\n+ * In general, the underlying javac layer is more powerful, whereas the javadoc methods are\n+ * constrained by the public {@link jdk.javadoc.doclet.Doclet} API.\n+ *\n+ * In the underlying javac layer, the following abstractions are used:\n+ * <ul>\n+ *     <li>{@code DiagnosticType} -- error, warning, note, etc.\n+ *     <li>{@code DiagnosticSource} -- a file object and a cache of its content\n+ *     <li>{@code DiagnosticPosition} -- a tuple of values (start, pos, end) for the position of a diagnostic\n+ *     <li>{@code DiagnosticFlag} -- additional flags related to the diagnostic\n+ * <\/ul>\n+ *\n+ * The javadoc layer is defined by the methods on {@code Doclet.Reporter}, and by\n+ * assorted methods defined in this class for use by the javadoc tool.\n+ * The primary data types are:\n+ * <ul>\n+ *     <li>{@code Diagnostic.Kind} -- maps to {@code DiagnosticType} and {@code Set<DiagnosticFlag>}\n+ *     <li>{@code Element} -- maps to {@code DiagnosticSource} and {@code DiagnosticPosition}\n+ *     <li>{@code DocTreePath} -- maps to {@code DiagnosticSource} and {@code DiagnosticPosition}\n+ * <\/ul>\n+ *\n+ * The reporting methods in the javac layer primarily take pre-localized (key, args) pairs,\n+ * while the methods in the javadoc layer, especially the {@code Reporter} interface, take\n+ * localized strings. To accommodate this, \"wrapper\" resources are used, whose value is {@code {0}},\n+ * to pass the localized string down to javac. A side-effect is that clients using a\n+ * {@code DiagnosticListener} with a {@code DocumentationTask} cannot access the original resource\n+ * key for the localized message.\n+ * Given the limitations of the API, it is not possible to do any better.\n+ * The javac Annotation Processing API has the same problem.\n+ *\n+ * There is a slight disparity between javac's use of streams and javadoc's use of streams.\n+ * javac reports <b>all<\/b> diagnostics to the \"error\" stream, and provides a separate\n+ * \"output\" stream for expected output, such as command-line help or the output from options\n+ * like {@code -Xprint}. javadoc API, and {@code Reporter} in particular, does not specify\n+ * the use of streams, and provides no support for identifying or specifying streams. JDK-8267204.\n+ * The current implementation\/workaround is to write errors and warnings to the \"error\"\n+ * stream and notes to the \"output\" stream.\n+ *\n@@ -64,1 +122,13 @@\n-    final Context context;\n+    \/** The overall context for the documentation run. *\/\n+    private final Context context;\n+\n+    \/** The tool environment, providing access to the tool's utility classes and tables. *\/\n+    private ToolEnvironment toolEnv;\n+\n+    \/** The utility class to access the positions of items in doc comments. *\/\n+    private DocSourcePositions sourcePositions;\n+\n+    \/**\n+     * A memory-sensitive cache of recently used {@code DiagnosticSource} objects.\n+     *\/\n+    private final LinkedHashMap<JavaFileObject, SoftReference<DiagnosticSource>> diagSourceCache;\n@@ -69,1 +139,1 @@\n-        if (instance == null || !(instance instanceof Messager))\n+        if (!(instance instanceof Messager))\n@@ -84,50 +154,0 @@\n-    @Override\n-    public void print(Kind kind, String msg) {\n-        switch (kind) {\n-            case ERROR:\n-                printError(msg);\n-                return;\n-            case WARNING:\n-            case MANDATORY_WARNING:\n-                printWarning(msg);\n-                return;\n-            default:\n-                printNotice(msg);\n-                return;\n-        }\n-    }\n-\n-    @Override\n-    public void print(Kind kind, DocTreePath path, String msg) {\n-        switch (kind) {\n-            case ERROR:\n-                printError(path, msg);\n-                return;\n-            case WARNING:\n-            case MANDATORY_WARNING:\n-                printWarning(path, msg);\n-                return;\n-            default:\n-                printWarning(path, msg);\n-                return;\n-        }\n-    }\n-\n-    @Override\n-    public void print(Kind kind, Element e, String msg) {\n-                switch (kind) {\n-            case ERROR:\n-                printError(e, msg);\n-                return;\n-            case WARNING:\n-            case MANDATORY_WARNING:\n-                printWarning(e, msg);\n-                return;\n-            case NOTE:\n-                printNotice(e, msg);\n-                return;\n-            default:\n-                throw new IllegalArgumentException(String.format(\"unexpected option %s\", kind));\n-        }\n-    }\n-\n@@ -140,4 +160,4 @@\n-    \/** The default writer for diagnostics\n-     *\/\n-    static final PrintWriter defaultOutWriter = new PrintWriter(System.out);\n-    static final PrintWriter defaultErrWriter = new PrintWriter(System.err);\n+    \/** The default writer for notes. *\/\n+    private static final PrintWriter defaultOutWriter = new PrintWriter(System.out);\n+    \/** The default writer for errors and warnings. *\/\n+    private static final PrintWriter defaultErrWriter = new PrintWriter(System.err);\n@@ -169,0 +189,9 @@\n+\n+        diagSourceCache = new LinkedHashMap<>() {\n+            private static final int MAX_ENTRIES = 5;\n+\n+            @Override\n+            protected boolean removeEldestEntry(Map.Entry<JavaFileObject, SoftReference<DiagnosticSource>> eldest) {\n+                return size() > MAX_ENTRIES;\n+            }\n+        };\n@@ -176,1 +205,1 @@\n-     * get and format message string from resource\n+     * Returns the localized string from the tool's resource bundles.\n@@ -178,2 +207,2 @@\n-     * @param key selects message from resource\n-     * @param args arguments for the message\n+     * @param key the resource key\n+     * @param args arguments for the resource\n@@ -185,31 +214,21 @@\n-    private String getDiagSource(DocTreePath path) {\n-        if (path == null || path.getTreePath() == null) {\n-            return programName;\n-        }\n-        JavacTrees trees = JavacTrees.instance(context);\n-        DocSourcePositions sourcePositions = trees.getSourcePositions();\n-        CompilationUnitTree cu = path.getTreePath().getCompilationUnit();\n-        long spos = sourcePositions.getStartPosition(cu, path.getDocComment(), path.getLeaf());\n-        long lineNumber = cu.getLineMap().getLineNumber(spos);\n-        String fname = cu.getSourceFile().getName();\n-        String posString = fname + \":\" + lineNumber;\n-        return posString;\n-    }\n-\n-    private String getDiagSource(Element e) {\n-        if (e == null) {\n-            return programName;\n-        }\n-        JavacTrees trees = JavacTrees.instance(context);\n-        TreePath path = trees.getPath(e);\n-        if (path == null) {\n-            return programName;\n-        }\n-        DocSourcePositions sourcePositions = trees.getSourcePositions();\n-        JCTree tree = trees.getTree(e);\n-        CompilationUnitTree cu = path.getCompilationUnit();\n-        long spos = sourcePositions.getStartPosition(cu, tree);\n-        long lineNumber = cu.getLineMap().getLineNumber(spos);\n-        String fname = cu.getSourceFile().getName();\n-        String posString = fname + \":\" + lineNumber;\n-        return posString;\n+    @Override \/\/ Reporter\n+    public void print(Kind kind, String message) {\n+        report(kind, null, null, message);\n+    }\n+\n+    @Override \/\/ Reporter\n+    public void print(Diagnostic.Kind kind, DocTreePath path, String message) {\n+        DiagnosticType dt = getDiagnosticType(kind);\n+        Set<DiagnosticFlag> flags = getDiagnosticFlags(kind);\n+        DiagnosticSource ds = getDiagnosticSource(path);\n+        DiagnosticPosition dp = getDiagnosticPosition(path);\n+        report(dt, flags, ds, dp, message);\n+    }\n+\n+    @Override  \/\/ Reporter\n+    public void print(Kind kind, Element element, String message) {\n+        DiagnosticType dt = getDiagnosticType(kind);\n+        Set<DiagnosticFlag> flags = getDiagnosticFlags(kind);\n+        DiagnosticSource ds = getDiagnosticSource(element);\n+        DiagnosticPosition dp = getDiagnosticPosition(element);\n+        report(dt, flags, ds, dp, message);\n@@ -219,2 +238,1 @@\n-     * Print error message, increment error count.\n-     * Part of DocErrorReporter.\n+     * Prints an error message.\n@@ -222,1 +240,1 @@\n-     * @param msg message to print\n+     * @param message the message\n@@ -224,2 +242,2 @@\n-    public void printError(String msg) {\n-        printError((DocTreePath)null, msg);\n+    public void printError(String message) {\n+        report(DiagnosticType.ERROR,null, null, message);\n@@ -228,7 +246,10 @@\n-    public void printError(DocTreePath path, String msg) {\n-        String prefix = getDiagSource(path);\n-        if (diagListener != null) {\n-            report(DiagnosticType.ERROR, prefix, msg);\n-            return;\n-        }\n-        printError(prefix, msg);\n+    \/**\n+     * Prints an error message for a given documentation tree node.\n+     *\n+     * @param path    the path for the documentation tree node\n+     * @param message the message\n+     *\/\n+    public void printError(DocTreePath path, String message) {\n+        DiagnosticSource ds = getDiagnosticSource(path);\n+        DiagnosticPosition dp = getDiagnosticPosition(path);\n+        report(DiagnosticType.ERROR, EnumSet.noneOf(DiagnosticFlag.class), ds, dp, message);\n@@ -237,7 +258,10 @@\n-    public void printError(Element e, String msg) {\n-        String prefix = getDiagSource(e);\n-        if (diagListener != null) {\n-            report(DiagnosticType.ERROR, prefix, msg);\n-            return;\n-        }\n-        printError(prefix, msg);\n+    \/**\n+     * Prints an error message for a given element.\n+     *\n+     * @param element the element\n+     * @param message the message\n+     *\/\n+    public void printError(Element element, String message) {\n+        DiagnosticSource ds = getDiagnosticSource(element);\n+        DiagnosticPosition dp = getDiagnosticPosition(element);\n+        report(DiagnosticType.ERROR, EnumSet.noneOf(DiagnosticFlag.class), ds, dp, message);\n@@ -246,0 +270,6 @@\n+    \/**\n+     * Prints an error message.\n+     *\n+     * @param key the resource key for the message\n+     * @param args the arguments for the message\n+     *\/\n@@ -247,1 +277,1 @@\n-        printError((Element)null, getText(key, args));\n+        printError(getText(key, args));\n@@ -250,9 +280,7 @@\n-    \/\/ print the error and increment count\n-    private void printError(String prefix, String msg) {\n-        if (nerrors < MaxErrors) {\n-            PrintWriter errWriter = getWriter(WriterKind.ERROR);\n-            printRawLines(errWriter, prefix + \": \" + getText(\"javadoc.error\") + \" - \" + msg);\n-            errWriter.flush();\n-            prompt();\n-            nerrors++;\n-        }\n+    \/**\n+     * Prints a warning message.\n+     *\n+     * @param message the message\n+     *\/\n+    public void printWarning(String message) {\n+        report(DiagnosticType.WARNING, null, null, message);\n@@ -262,2 +290,1 @@\n-     * Print warning message, increment warning count.\n-     * Part of DocErrorReporter.\n+     * Prints a warning message for a given documentation tree node.\n@@ -265,1 +292,2 @@\n-     * @param msg message to print\n+     * @param path    the path for the documentation tree node\n+     * @param message the message\n@@ -267,2 +295,4 @@\n-    public void printWarning(String msg) {\n-        printWarning((DocTreePath)null, msg);\n+    public void printWarning(DocTreePath path, String message) {\n+        DiagnosticSource ds = getDiagnosticSource(path);\n+        DiagnosticPosition dp = getDiagnosticPosition(path);\n+        report(DiagnosticType.WARNING, EnumSet.noneOf(DiagnosticFlag.class), ds, dp, message);\n@@ -271,2 +301,10 @@\n-    public void printWarningUsingKey(String key, Object... args) {\n-        printWarning((Element)null, getText(key, args));\n+    \/**\n+     * Prints a warning message for a given element.\n+     *\n+     * @param element the element\n+     * @param message the message\n+     *\/\n+    public void printWarning(Element element, String message) {\n+        DiagnosticSource ds = getDiagnosticSource(element);\n+        DiagnosticPosition dp = getDiagnosticPosition(element);\n+        report(DiagnosticType.WARNING, EnumSet.noneOf(DiagnosticFlag.class), ds, dp, message);\n@@ -275,1 +313,7 @@\n-    public void printWarning(Element e, String key, Object... args) {\n+    \/**\n+     * Prints a warning message.\n+     *\n+     * @param key the resource key for the message\n+     * @param args the arguments for the message\n+     *\/\n+    public void printWarningUsingKey(String key, Object... args) {\n@@ -279,26 +323,9 @@\n-    public void printWarning(DocTreePath path, String msg) {\n-        String prefix = getDiagSource(path);\n-        if (diagListener != null) {\n-            report(DiagnosticType.WARNING, prefix, msg);\n-            return;\n-        }\n-        printWarning(prefix, msg);\n-    }\n-\n-    public void printWarning(Element e, String msg) {\n-        String prefix = getDiagSource(e);\n-        if (diagListener != null) {\n-            report(DiagnosticType.WARNING, prefix, msg);\n-            return;\n-        }\n-        printWarning(prefix, msg);\n-    }\n-\n-    \/\/ print the warning and increment count\n-    private void printWarning(String prefix, String msg) {\n-        if (nwarnings < MaxWarnings) {\n-            PrintWriter warnWriter = getWriter(WriterKind.WARNING);\n-            printRawLines(warnWriter, prefix + \": \" + getText(\"javadoc.warning\") + \" - \" + msg);\n-            warnWriter.flush();\n-            nwarnings++;\n-        }\n+    \/**\n+     * Prints a warning message for an element.\n+     *\n+     * @param element the element\n+     * @param key     the resource key for the message\n+     * @param args    the arguments for the message\n+     *\/\n+    public void printWarningUsingKey(Element element, String key, Object... args) {\n+        printWarning(element, getText(key, args));\n@@ -308,2 +335,1 @@\n-     * Print a message.\n-     * Part of DocErrorReporter.\n+     * Prints a \"notice\" message.\n@@ -311,1 +337,1 @@\n-     * @param msg message to print\n+     * @param message the message\n@@ -313,2 +339,2 @@\n-    public void printNotice(String msg) {\n-        printNotice((DocTreePath)null, msg);\n+    public void printNotice(String message) {\n+        report(DiagnosticType.NOTE, null, null, message);\n@@ -317,14 +343,10 @@\n-    public void printNotice(DocTreePath path, String msg) {\n-        String prefix = getDiagSource(path);\n-        if (diagListener != null) {\n-            report(DiagnosticType.NOTE, null, prefix + \": \" + msg);\n-            return;\n-        }\n-\n-        PrintWriter noticeWriter = getWriter(WriterKind.NOTICE);\n-        if (path == null) {\n-            printRawLines(noticeWriter, msg);\n-        } else {\n-            printRawLines(noticeWriter, prefix + \": \" + msg);\n-        }\n-        noticeWriter.flush();\n+    \/**\n+     * Prints a \"notice\" message for a given documentation tree node.\n+     *\n+     * @param path    the path for the documentation tree node\n+     * @param message the message\n+     *\/\n+    public void printNotice(DocTreePath path, String message) {\n+        DiagnosticSource ds = getDiagnosticSource(path);\n+        DiagnosticPosition dp = getDiagnosticPosition(path);\n+        report(DiagnosticType.NOTE, EnumSet.noneOf(DiagnosticFlag.class), ds, dp, message);\n@@ -333,14 +355,10 @@\n-    public void printNotice(Element e, String msg) {\n-        String pos = getDiagSource(e);\n-        if (diagListener != null) {\n-            report(DiagnosticType.NOTE, pos, msg);\n-            return;\n-        }\n-\n-        PrintWriter noticeWriter = getWriter(WriterKind.NOTICE);\n-        if (e == null) {\n-            printRawLines(noticeWriter, msg);\n-        } else {\n-            printRawLines(noticeWriter, pos + \": \" + msg);\n-        }\n-        noticeWriter.flush();\n+    \/**\n+     * Prints a \"notice\" message for a given element.\n+     *\n+     * @param element the element\n+     * @param message the message\n+     *\/\n+    public void printNotice(Element element, String message) {\n+        DiagnosticSource ds = getDiagnosticSource(element);\n+        DiagnosticPosition dp = getDiagnosticPosition(element);\n+        report(DiagnosticType.NOTE, EnumSet.noneOf(DiagnosticFlag.class), ds, dp, message);\n@@ -350,1 +368,1 @@\n-     * Print a message.\n+     * Prints a \"notice\" message.\n@@ -352,1 +370,2 @@\n-     * @param key selects message from resource\n+     * @param key  the resource key for the message\n+     * @param args the arguments for the message\n@@ -373,1 +392,1 @@\n-     * Print exit message.\n+     * Prints the error and warning counts, if any.\n@@ -386,7 +405,161 @@\n-    private void report(DiagnosticType type, String pos, String msg) {\n-        switch (type) {\n-            case ERROR:\n-            case WARNING:\n-                Object prefix = (pos == null) ? programName : pos;\n-                report(javadocDiags.create(type, null, null, \"msg\", prefix, msg));\n-                break;\n+    \/**\n+     * Reports a diagnostic message.\n+     *\n+     * @param kind    the kind of diagnostic\n+     * @param ds      the diagnostic source\n+     * @param dp      the diagnostic position\n+     * @param message the message\n+     *\/\n+    private void report(Diagnostic.Kind kind, DiagnosticSource ds, DiagnosticPosition dp, String message) {\n+        report(getDiagnosticType(kind), getDiagnosticFlags(kind), ds, dp, message);\n+    }\n+\n+    \/**\n+     * Reports a diagnostic message.\n+     *\n+     * @param dt      the diagnostic type\n+     * @param ds      the diagnostic source\n+     * @param dp      the diagnostic position\n+     * @param message the message\n+     *\/\n+    private void report(DiagnosticType dt, DiagnosticSource ds, DiagnosticPosition dp, String message) {\n+        report(dt, EnumSet.noneOf(DiagnosticFlag.class), ds, dp, message);\n+    }\n+\n+    \/**\n+     * Reports a diagnostic message, with diagnostic flags.\n+     * For javadoc, the only flag that is used is {@code MANDATORY_WARNING}, and only\n+     * because in principle the public API supports it via {@code Kind.MANDATORY_WARNING}.\n+     * javadoc itself does generate mandatory warnings.\n+     *\n+     * This is the primary low-level wrapper around the underlying {@code Log.report}.\n+     * Because we already have a localized message, we use wrapper resources (just {@code {0}})\n+     * to wrap the string. The current behavior is one wrapper per diagnostic type.\n+     * We could improve this by subtyping {@code DiagnosticInfo} to modify the resource key used.\n+     *\n+     * {@code Log} reports all diagnostics to the corresponding writer, which defaults\n+     * to the \"error\" stream, when using the two-stream constructor. That doesn't work\n+     * for javadoc, which has historically written notes to the \"output\" stream, because\n+     * the public API used by doclets does not provide for more detailed control.\n+     * Therefore, for now, javadoc continues to use the (deprecated) three-stream\n+     * constructor, with the {@code NOTE} stream set to the \"output\" stream.\n+     *\n+     * {@code Log} reports all notes with a \"Note:\" prefix. That's not good for the\n+     * standard doclet, which uses notes to report the various \"progress\" messages,\n+     * such as  \"Generating class ...\".  Therefore, for now, we detect and report those\n+     * messages directly. (A better solution would be to expose access to the output\n+     * and error streams via {@code Reporter}).\n+     *\n+     * Note: there is an intentional difference in behavior between the diagnostic source\n+     * being set to {@code null} (no source intended) and {@code NO_SOURCE} (no source available).\n+     *\n+     * @param dt      the diagnostic type\n+     * @param ds      the diagnostic source\n+     * @param dp      the diagnostic position\n+     * @param message the message\n+     *\/\n+    private void report(DiagnosticType dt, Set<DiagnosticFlag> flags, DiagnosticSource ds, DiagnosticPosition dp, String message) {\n+        if (dt == DiagnosticType.NOTE && ds == null && !hasDiagnosticListener()) {\n+            printRawLines(WriterKind.STDOUT, message);\n+            getWriter(WriterKind.STDOUT).flush();\n+        } else {\n+            report(javadocDiags.create(dt, null, flags, ds, dp, \"message\", message));\n+        }\n+    }\n+\n+    \/**\n+     * Returns a diagnostic position for a documentation tree node.\n+     *\n+     * @param path the path for the documentation tree node\n+     * @return the diagnostic position\n+     *\/\n+    private DiagnosticPosition getDiagnosticPosition(DocTreePath path) {\n+        DocSourcePositions posns = getSourcePositions();\n+        CompilationUnitTree compUnit = path.getTreePath().getCompilationUnit();\n+        int start = (int) posns.getStartPosition(compUnit, path.getDocComment(), path.getLeaf());\n+        int end = (int) posns.getEndPosition(compUnit, path.getDocComment(), path.getLeaf());\n+        return createDiagnosticPosition(null, start, start, end);\n+    }\n+\n+    \/**\n+     * Returns a diagnostic position for an element, or {@code null} if the source\n+     * file is not available.\n+     *\n+     * @param element the element\n+     * @return the diagnostic position\n+     *\/\n+    private DiagnosticPosition getDiagnosticPosition(Element element) {\n+        ToolEnvironment toolEnv = getToolEnv();\n+        DocSourcePositions posns = getSourcePositions();\n+        TreePath tp = toolEnv.elementToTreePath.get(element);\n+        if (tp == null) {\n+            return null;\n+        }\n+        CompilationUnitTree compUnit = tp.getCompilationUnit();\n+        JCTree tree = (JCTree) tp.getLeaf();\n+        int start = (int) posns.getStartPosition(compUnit, tree);\n+        int pos = tree.getPreferredPosition();\n+        int end = (int) posns.getEndPosition(compUnit, tree);\n+        return createDiagnosticPosition(tree, start, pos, end);\n+    }\n+\n+    \/**\n+     * Creates a diagnostic position.\n+     *\n+     * @param tree the tree node, or null if no tree is applicable\n+     * @param start the start position\n+     * @param pos   the \"preferred\" position: this is used to position the caret in messages\n+     * @param end   the end position\n+     * @return the diagnostic position\n+     *\/\n+    private DiagnosticPosition createDiagnosticPosition(JCTree tree, int start, int pos, int end) {\n+        return new DiagnosticPosition() {\n+            @Override\n+            public JCTree getTree() {\n+                return tree;\n+            }\n+\n+            @Override\n+            public int getStartPosition() {\n+                return start;\n+            }\n+\n+            @Override\n+            public int getPreferredPosition() {\n+                return pos;\n+            }\n+\n+            @Override\n+            public int getEndPosition(EndPosTable endPosTable) {\n+                return end;\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Returns the diagnostic type for a diagnostic kind.\n+     *\n+     * @param kind the diagnostic kind\n+     * @return the diagnostic type\n+     *\/\n+    private DiagnosticType getDiagnosticType(Diagnostic.Kind kind) {\n+        return switch (kind) {\n+            case ERROR -> DiagnosticType.ERROR;\n+            case WARNING, MANDATORY_WARNING -> DiagnosticType.WARNING;\n+            case NOTE -> DiagnosticType.NOTE;\n+            case OTHER -> DiagnosticType.FRAGMENT;\n+        };\n+    }\n+\n+    \/**\n+     * Returns the diagnostic flags for a diagnostic kind.\n+     * A diagnostic kind of {@code MANDATORY_WARNING} requires the {@code MANDATORY} flag.\n+     *\n+     * @param kind the diagnostic kind\n+     * @return the flags\n+     *\/\n+    private Set<DiagnosticFlag> getDiagnosticFlags(Diagnostic.Kind kind) {\n+        return kind == Kind.MANDATORY_WARNING\n+                ? EnumSet.of(DiagnosticFlag.MANDATORY)\n+                : EnumSet.noneOf(DiagnosticFlag.class);\n+    }\n@@ -394,4 +567,9 @@\n-            case NOTE:\n-                String key = (pos == null) ? \"msg\" : \"pos.msg\";\n-                report(javadocDiags.create(type, null, null, key, pos, msg));\n-                break;\n+    \/**\n+     * Returns the diagnostic source for an documentation tree node.\n+     *\n+     * @param path the path for the documentation tree node\n+     * @return the diagnostic source\n+     *\/\n+    private DiagnosticSource getDiagnosticSource(DocTreePath path) {\n+        return getDiagnosticSource(path.getTreePath().getCompilationUnit().getSourceFile());\n+    }\n@@ -399,2 +577,58 @@\n-            default:\n-                throw new IllegalArgumentException(type.toString());\n+    \/**\n+     * Returns the diagnostic source for an element, or {@code NO_SOURCE} if the\n+     * source file is not known (for example, if the element was read from a class file).\n+     *\n+     * @param element the element\n+     * @return the diagnostic source\n+     *\/\n+    private DiagnosticSource getDiagnosticSource(Element element) {\n+        TreePath tp = getToolEnv().elementToTreePath.get(element);\n+        return tp == null ? DiagnosticSource.NO_SOURCE\n+                : getDiagnosticSource(tp.getCompilationUnit().getSourceFile());\n+    }\n+\n+    \/**\n+     * Returns the diagnostic source for a file object.\n+     *\n+     * {@code DiagnosticSource} objects are moderately expensive because they maintain\n+     * an internal copy of the content, to provide the line map.\n+     * Therefore, we keep a small memory-sensitive cache of recently used objects.\n+     *\n+     * @param fo the file object\n+     * @return the diagnostic source\n+     *\/\n+    private DiagnosticSource getDiagnosticSource(JavaFileObject fo) {\n+        Reference<DiagnosticSource> ref = diagSourceCache.get(fo);\n+        DiagnosticSource ds = ref == null ? null : ref.get();\n+        if (ds == null) {\n+            ds = new DiagnosticSource(fo, this);\n+            diagSourceCache.put(fo, new SoftReference<>(ds));\n+        }\n+        return ds;\n+    }\n+\n+    \/**\n+     * Returns the object for computing source positions.\n+     *\n+     * The value is determined lazily because the tool environment is computed lazily.\n+     *\n+     * @return the object for computing source positions\n+     *\/\n+    private DocSourcePositions getSourcePositions() {\n+        if (sourcePositions == null) {\n+            sourcePositions = getToolEnv().docTrees.getSourcePositions();\n+        }\n+        return sourcePositions;\n+    }\n+\n+    \/**\n+     * Returns the tool environment.\n+     *\n+     * The value is determined lazily, because creating it eagerly disrupts\n+     * the overall initialization of objects in the context.\n+     *\n+     * @return the tool environment\n+     *\/\n+    private ToolEnvironment getToolEnv() {\n+        if (toolEnv == null) {\n+            toolEnv = ToolEnvironment.instance(context);\n@@ -402,0 +636,1 @@\n+        return toolEnv;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/Messager.java","additions":444,"deletions":209,"binary":false,"changes":653,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -330,7 +330,1 @@\n-     * Main program - external wrapper. In order to maintain backward\n-     * CLI compatibility, the execution is dispatched to the appropriate\n-     * Start mechanism, depending on the doclet variant.\n-     *\n-     * The doclet tests are performed in the begin method, further on,\n-     * this is to minimize argument processing and most importantly the impact\n-     * of class loader creation, needed to detect the doclet class variants.\n+     * Main program - external wrapper.\n@@ -401,1 +395,6 @@\n-            messager.printError(e.getMessage());\n+            \/\/ The detail message from javac already includes a localized \"error: \" prefix,\n+            \/\/ so print the message directly.\n+            \/\/ It would be even better to rethrow this as IllegalArgumentException\n+            \/\/ when invoked via the API.\n+            \/\/ See javac Arguments.error(InvalidValueException) for an example\n+            messager.printRawLines(e.getMessage());\n@@ -406,0 +405,3 @@\n+            \/\/ It would be even better to rethrow this as IllegalArgumentException\n+            \/\/ when invoked via the API.\n+            \/\/ See javac Arguments.error(InvalidValueException) for an example\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/Start.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-    \/** Referenced directly in RootDocImpl. *\/\n+    \/** JavaDoc's subtype of the compiler's class finder *\/\n@@ -94,1 +94,1 @@\n-    \/** Javadoc's own version of the compiler's enter phase. *\/\n+    \/** Javadoc's subtype of the compiler's enter phase. *\/\n@@ -100,2 +100,0 @@\n-    final Symbol externalizableSym;\n-\n@@ -147,1 +145,0 @@\n-        externalizableSym = syms.enterClass(syms.java_base, names.fromString(\"java.io.Externalizable\"));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/ToolEnvironment.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -312,0 +312,1 @@\n+\n@@ -313,2 +314,1 @@\n-javadoc.error=error\n-javadoc.warning=warning\n+\n@@ -321,0 +321,4 @@\n+\n+javadoc.err.message={0}\n+javadoc.warn.message={0}\n+javadoc.note.message={0}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/resources\/javadoc.properties","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n-                \"javadoc: error - Option -charset conflicts with -docencoding\");\n+                \"error: Option -charset conflicts with -docencoding\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testCharsetDocencodingOptions\/TestCharsetDocencodingOptions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+import javax.lang.model.element.Element;\n+import javax.tools.Diagnostic;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.EntityTree;\n+import com.sun.source.util.DocTreePath;\n+import com.sun.source.util.DocTreePathScanner;\n+import com.sun.source.util.DocTrees;\n+import com.sun.source.util.TreePath;\n+import jdk.javadoc.doclet.Doclet;\n+import jdk.javadoc.doclet.DocletEnvironment;\n+import jdk.javadoc.doclet.Reporter;\n+import jdk.javadoc.doclet.StandardDoclet;\n+import jdk.javadoc.doclet.Taglet;\n+\n+\/**\n+ * A taglet that writes messages to the doclet's reporter.\n+ *\/\n+public class MyTaglet implements Taglet {\n+    private DocletEnvironment docEnv;\n+    private Reporter reporter;\n+\n+    @Override\n+    public void init(DocletEnvironment env, Doclet doclet) {\n+        Taglet.super.init(env, doclet);\n+        docEnv = env;\n+\n+        \/\/ The following should be as simple as\n+        \/\/      reporter = ((StandardDoclet) doclet).getReporter();\n+        \/\/ JDK-8267176\n+        try {\n+            StandardDoclet sd = (StandardDoclet) doclet;\n+            Field htmlDocletField = sd.getClass().getDeclaredField(\"htmlDoclet\");\n+            htmlDocletField.setAccessible(true);\n+            Object htmlDoclet = htmlDocletField.get(sd);\n+            Method getConfigurationMethod = htmlDoclet.getClass().getDeclaredMethod(\"getConfiguration\");\n+            Object config = getConfigurationMethod.invoke(htmlDoclet);\n+            Method getReporterMethod = config.getClass().getMethod((\"getReporter\"));\n+            reporter = (Reporter) getReporterMethod.invoke(config);\n+        } catch (ReflectiveOperationException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    @Override\n+    public Set<Location> getAllowedLocations() {\n+        return EnumSet.allOf(Location.class);\n+    }\n+\n+    @Override\n+    public boolean isInlineTag() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isBlockTag() {\n+        return true;\n+    }\n+\n+    \/**\n+     * Refines an existing tag ({@code @since} that provides a {@code List<DocTree>},\n+     * so that we can better test positions within the tree node. The alternative,\n+     * defining a new tag, would use {@code UnknownBlockTagTree} which just provides\n+     * a single {@code Doc Tree}.\n+     *\n+     * @return the name of the tag supported by this taglet\n+     *\/\n+    @Override\n+    public String getName() {\n+        return \"since\";\n+    }\n+\n+    @Override\n+    public String toString(List<? extends DocTree> tags, Element element) {\n+        List<Diagnostic.Kind> kinds = Arrays.stream(Diagnostic.Kind.values())\n+                .filter(k -> k != Diagnostic.Kind.OTHER)\n+                .toList();\n+\n+        for (Diagnostic.Kind k : kinds) {\n+            String message = \"This is a \" + k.toString().toLowerCase(Locale.ROOT);\n+            reporter.print(k, message);\n+        }\n+\n+        for (Diagnostic.Kind k : kinds) {\n+            String message = \"This is a \" + k.toString().toLowerCase(Locale.ROOT) + \" for \" + element;\n+            reporter.print(k, element, message);\n+        }\n+\n+        DocTreePathScanner<Void, Diagnostic.Kind> s = new DocTreePathScanner<>() {\n+            @Override\n+            public Void scan(DocTree tree, Diagnostic.Kind k) {\n+                return super.scan(tree, k);\n+            }\n+\n+            @Override\n+            public Void visitEntity(EntityTree node, Diagnostic.Kind k) {\n+                if (node.getName().contentEquals(\"#x1f955\")) {\n+                    String message = \"This is a \" + k.toString().toLowerCase(Locale.ROOT)\n+                            + \": this is not a caret\";\n+                    reporter.print(k, getCurrentPath(), message);\n+                }\n+                return super.visitEntity(node, k);\n+            }\n+        };\n+\n+        DocTrees trees = docEnv.getDocTrees();\n+        TreePath tp = trees.getPath(element);\n+        DocTreePath root = new DocTreePath(tp, trees.getDocCommentTree(element));\n+\n+        for (Diagnostic.Kind k : kinds) {\n+            tags.forEach(t -> s.scan(new DocTreePath(root, t), k));\n+        }\n+        return \"<b>mytaglet output<\/b>\";\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDiagsLineCaret\/MyTaglet.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8267126\n+ * @summary  javadoc should show \"line and caret\" for diagnostics\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    javadoc.tester.* MyTaglet\n+ * @run main TestDiagsLineCaret\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestDiagsLineCaret extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        TestDiagsLineCaret tester = new TestDiagsLineCaret();\n+        tester.runTests();\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void testDiags() throws IOException {\n+        tb.writeJavaFiles(Path.of(\".\"), \"\"\"\n+                \/**\n+                 * First sentence.\n+                 * @since def &#x1f955; ghi\n+                 *\/\n+                public class MyClass { }\n+                \"\"\");\n+\n+        String testClasses = System.getProperty(\"test.classes\");\n+\n+        javadoc(\"-d\", \"out\",\n+                \"-XDaccessInternalAPI\",\n+                \"-tagletpath\", testClasses,\n+                \"-taglet\", \"MyTaglet\",\n+                \"MyClass.java\");\n+        checkExit(Exit.ERROR);\n+\n+        checkOutput(Output.OUT, true,\n+                \"\"\"\n+                    error: This is a error\n+                    warning: This is a warning\n+                    warning: This is a mandatory_warning\n+                    This is a note\n+                    MyClass.java:5: error: This is a error for MyClass\n+                    public class MyClass { }\n+                           ^\n+                    MyClass.java:5: warning: This is a warning for MyClass\n+                    public class MyClass { }\n+                           ^\n+                    MyClass.java:5: warning: This is a mandatory_warning for MyClass\n+                    public class MyClass { }\n+                           ^\n+                    MyClass.java:5: Note: This is a note for MyClass\n+                    public class MyClass { }\n+                           ^\n+                    MyClass.java:3: error: This is a error: this is not a caret\n+                     * @since def &#x1f955; ghi\n+                                  ^\n+                    MyClass.java:3: warning: This is a warning: this is not a caret\n+                     * @since def &#x1f955; ghi\n+                                  ^\n+                    MyClass.java:3: warning: This is a mandatory_warning: this is not a caret\n+                     * @since def &#x1f955; ghi\n+                                  ^\n+                    MyClass.java:3: Note: This is a note: this is not a caret\n+                     * @since def &#x1f955; ghi\n+                                  ^\n+                    \"\"\",\n+                \"\"\"\n+                    3 errors\n+                    6 warnings\n+                    \"\"\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDiagsLineCaret\/TestDiagsLineCaret.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,1 +174,1 @@\n-                        \"warning - File \" + f + \" not copied: invalid name\");\n+                        \"warning: File \" + f + \" not copied: invalid name\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDocFiles\/TestDocFiles.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -377,1 +377,1 @@\n-        checkOutput(Output.OUT, true, \"C.java:0: warning - invalid usage of tag <\");\n+        checkOutput(Output.OUT, true, \"C.java:31: warning: invalid usage of tag <\");\n@@ -422,0 +422,1 @@\n+                \"--no-platform-links\",\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testJavaFX\/TestJavaFX.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -250,1 +250,1 @@\n-                    \"javadoc: warning - URL \" + oldURL + \"\/element-list was redirected to \" + newURL + \"\/element-list\");\n+                    \"warning: URL \" + oldURL + \"\/element-list was redirected to \" + newURL + \"\/element-list\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testLinkOption\/TestRedirectLinks.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,0 +115,1 @@\n+                \"--no-platform-links\",\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMissingComment\/TestMissingComment.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -199,1 +199,1 @@\n-                    warning - @param argument \"<BadClassTypeParam>\" is not the name of a type parameter.\"\"\",\n+                    warning: @param argument \"<BadClassTypeParam>\" is not the name of a type parameter.\"\"\",\n@@ -201,1 +201,1 @@\n-                    warning - @param argument \"<BadMethodTypeParam>\" is not the name of a type parameter.\"\"\");\n+                    warning: @param argument \"<BadMethodTypeParam>\" is not the name of a type parameter.\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNewLanguageFeatures\/TestNewLanguageFeatures.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,2 +62,2 @@\n-                    javadoc: warning - The --no-frames option is no longer required and may be removed\n-                    in a future release.\"\"\");\n+                    warning: The --no-frames option is no longer required and may be removed\n+                      in a future release.\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNoFrames\/TestNoFrames.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-                \"javadoc: error - File not found:\",\n+                \"error: File not found:\",\n@@ -177,1 +177,1 @@\n-                \"javadoc: error - File not found:\",\n+                \"error: File not found:\",\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOptions\/TestOptions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-            \"warning - @return tag cannot be used in method with void return type.\");\n+            \"warning: @return tag cannot be used in method with void return type.\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testReturnTag\/TestReturnTag.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -676,4 +676,4 @@\n-                \"AnotherClass.java:29: warning - invalid usage of tag {@index\",\n-                \"AnotherClass.java:39: warning - invalid usage of tag {@index\",\n-                \"AnotherClass.java:34: warning - invalid usage of tag {@index\",\n-                \"AnotherClass.java:68: warning - invalid usage of tag {@index\");\n+                \"AnotherClass.java:29: warning: invalid usage of tag {@index\",\n+                \"AnotherClass.java:39: warning: invalid usage of tag {@index\",\n+                \"AnotherClass.java:34: warning: invalid usage of tag {@index\",\n+                \"AnotherClass.java:68: warning: invalid usage of tag {@index\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSearch\/TestSearch.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-                \"warning - @inheritDoc used but testBadInheritDocTag() \"\n+                \"warning: @inheritDoc used but testBadInheritDocTag() \"\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTagInheritence\/TestTagInheritence.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,4 +55,4 @@\n-                \"warning - Tag @param cannot be used in field documentation.\",\n-                \"warning - Tag @throws cannot be used in field documentation.\",\n-                \"warning - Tag @return cannot be used in constructor documentation.\"\n-                \/* DCerroneous, \"warning - Tag @throws cannot be used in inline documentation.\"*\/);\n+                \"warning: Tag @param cannot be used in field documentation.\",\n+                \"warning: Tag @throws cannot be used in field documentation.\",\n+                \"warning: Tag @return cannot be used in constructor documentation.\"\n+                \/* DCerroneous, \"warning: Tag @throws cannot be used in inline documentation.\"*\/);\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTagMisuse\/TestTagMisuse.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,1 +155,1 @@\n-                \"warning - @value tag (which references nonConstant) \"\n+                \"warning: @value tag (which references nonConstant) \"\n@@ -157,1 +157,1 @@\n-                \"warning - @value tag (which references NULL) \"\n+                \"warning: @value tag (which references NULL) \"\n@@ -159,1 +159,1 @@\n-                \"warning - @value tag (which references TEST_12_ERROR) \"\n+                \"warning: @value tag (which references TEST_12_ERROR) \"\n@@ -162,1 +162,1 @@\n-                \"warning - {@value UnknownClass#unknownConstant}\"\n+                \"warning: {@value UnknownClass#unknownConstant}\"\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testValueTag\/TestValueTag.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-                    warning - @param argument \"int\" is not a parameter name.\"\"\",\n+                    warning: @param argument \"int\" is not a parameter name.\"\"\",\n@@ -55,1 +55,1 @@\n-                    warning - @param argument \"IDontExist\" is not a parameter name.\"\"\",\n+                    warning: @param argument \"IDontExist\" is not a parameter name.\"\"\",\n@@ -57,1 +57,1 @@\n-                    warning - Parameter \"arg\" is documented more than once.\"\"\");\n+                    warning: Parameter \"arg\" is documented more than once.\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testWarnBadParamNames\/TestWarnBadParamNames.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,1 @@\n-        check(errOut, \" warning \", expectWarns); \/\/ requires -locale en_US\n+        check(errOut, \" warning: \", expectWarns); \/\/ requires -locale en_US\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/6958836\/Test.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-                if (line.contains(\"DoesNotExist\"))\n+                if (line.contains(\"TestStdDoclet.java\") && line.contains(\"DoesNotExist\")) {\n@@ -78,1 +78,2 @@\n-                if (line.matches(\"[0-9]+ warning(s)?\"))\n+                }\n+                if (line.matches(\"[0-9]+ warning(s)?\")) {\n@@ -82,0 +83,1 @@\n+            }\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/6964914\/TestStdDoclet.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -178,1 +178,1 @@\n-        checkOutput(Output.OUT, sumErrors != 0 || !success, \"error - \");\n+        checkOutput(Output.OUT, sumErrors != 0 || !success, \"error: \");\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/8224613\/OptionProcessingFailureTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-                \"javadoc: error - error: no value for --add-modules option\");\n+                \"error: no value for --add-modules option\");\n@@ -107,1 +107,1 @@\n-                \"javadoc: error - error: no value for --add-exports option\");\n+                \"error: no value for --add-exports option\");\n@@ -119,1 +119,1 @@\n-                \"javadoc: error - error: bad value for --add-exports option: 'm\/p'\");\n+                \"error: bad value for --add-exports option: 'm\/p'\");\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/BadOptionsTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -236,0 +236,4 @@\n+            results.add(\"javadoc.err.message\");\n+            results.add(\"javadoc.warn.message\");\n+            results.add(\"javadoc.note.message\");\n+\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/CheckResourceKeys.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-        String[] args = { \"-Xdoclint:none\", \"-d\", \"api\", f.getPath() };\n+        String[] args = { \"-Xdoclint:none\", \"--no-platform-links\", \"-d\", \"api\", f.getPath() };\n@@ -87,1 +87,1 @@\n-            warning - @param argument \"i[0-9]+\" is not a parameter name\"\"\");\n+            warning: @param argument \"i[0-9]+\" is not a parameter name\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/MaxWarns.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-                    System.err.println(d);\n+                    System.err.println(\"[\" + d.getCode() + \"]: \" + d);\n@@ -80,1 +80,1 @@\n-                        \"javadoc.note.msg\",         \/\/ Loading source file\n+                        \"javadoc.note.message\",     \/\/ Loading source file\n@@ -82,1 +82,1 @@\n-                        \"javadoc.note.msg\");        \/\/ 1 error\n+                        \"javadoc.note.message\");    \/\/ 1 error\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/api\/basic\/GetTask_DiagListenerTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,2 +119,2 @@\n-        JD_WRN10(WARNING, \"Test.java:10: warning - Tag @see: reference not found: DoesNotExist\"),\n-        JD_WRN13(WARNING, \"Test.java:13: warning - @return tag has no arguments.\"),\n+        JD_WRN10(WARNING, \"Test.java:10: warning: Tag @see: reference not found: DoesNotExist\"),\n+        JD_WRN13(WARNING, \"Test.java:13: warning: @return tag has no arguments.\"),\n@@ -123,3 +123,3 @@\n-        OPT_BADARG(ERROR, \"javadoc: error - Invalid argument for -Xdoclint option\"),\n-        OPT_BADQUAL(ERROR, \"javadoc: error - Access qualifiers not permitted for -Xdoclint arguments\"),\n-        OPT_BADPACKAGEARG(ERROR, \"javadoc: error - Invalid argument for -Xdoclint\/package option\");\n+        OPT_BADARG(ERROR, \"error: Invalid argument for -Xdoclint option\"),\n+        OPT_BADQUAL(ERROR, \"error: Access qualifiers not permitted for -Xdoclint arguments\"),\n+        OPT_BADPACKAGEARG(ERROR, \"error: Invalid argument for -Xdoclint\/package option\");\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/doclint\/DocLintTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,1 @@\n-        assertPresent(\"javadoc: error - \" + errString, tr.getOutputLines(Task.OutputKind.DIRECT));\n+        assertPresent(\"error: \" + errString, tr.getOutputLines(Task.OutputKind.DIRECT));\n@@ -105,1 +105,1 @@\n-        assertPresent(\"javadoc: error - Cannot find doclet class NonExistentDoclet\",\n+        assertPresent(\"error: Cannot find doclet class NonExistentDoclet\",\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/exceptionHandling\/TestExceptionHandling.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,1 +115,1 @@\n-        assertMessageNotPresent(\"error - fatal error encountered\");\n+        assertMessageNotPresent(\"error: fatal error encountered\");\n@@ -537,1 +537,1 @@\n-        assertMessagePresent(\"javadoc: error - module MIA not found\");\n+        assertMessagePresent(\"error: module MIA not found\");\n@@ -559,1 +559,1 @@\n-        assertMessagePresent(\"javadoc: error - module MIA not found\");\n+        assertMessagePresent(\"error: module MIA not found\");\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/modules\/Modules.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,1 +183,1 @@\n-        assertMessagePresent(\"javadoc: error - No source files for package pro\");\n+        assertMessagePresent(\"error: No source files for package pro\");\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/modules\/PackageOptions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,4 +73,4 @@\n-        checkOutput(Output.OUT, true,\n-                \"javadoc: error - Class \" + Doclet_CLASS_NAME + \"\"\"\n-                     is not a valid doclet.\n-                    Note: As of JDK 13, the com.sun.javadoc API is no longer supported.\"\"\");\n+        checkOutput(Output.OUT, true, String.format(\"\"\"\n+                error: Class %s is not a valid doclet.\n+                  Note: As of JDK 13, the com.sun.javadoc API is no longer supported.\"\"\",\n+                Doclet_CLASS_NAME));\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/removeOldDoclet\/RemoveOldDoclet.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-                \"javadoc: error - warnings found and -Werror specified\");\n+                \"error: warnings found and -Werror specified\");\n@@ -77,1 +77,1 @@\n-                \"C.java:6: warning - @return tag cannot be used in method with void return type.\",\n+                \"C.java:6: warning: @return tag cannot be used in method with void return type.\",\n@@ -79,1 +79,1 @@\n-                    javadoc: error - warnings found and -Werror specified\n+                    error: warnings found and -Werror specified\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/testWErrorOption\/TestWErrorOption.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}