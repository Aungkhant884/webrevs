{"files":[{"patch":"@@ -2987,3 +2987,4 @@\n-  if (collector_state()->in_concurrent_start_gc()) {\n-    _cm->add_to_liveness(worker_id, obj, obj_size);\n-  }\n+  \/\/ We track liveness for all evacuation failed regions at all times - we need that\n+  \/\/ information for deciding whether to retain that region later when we have not\n+  \/\/ updated the information in the HeapRegion yet.\n+  _cm->add_to_liveness(worker_id, obj, obj_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-static size_t zap_dead_objects(HeapRegion* hr, HeapWord* start, HeapWord* end) {\n+static void zap_dead_objects(HeapRegion* hr, HeapWord* start, HeapWord* end) {\n@@ -96,1 +96,1 @@\n-    return 0;\n+    return;\n@@ -100,7 +100,0 @@\n-  return pointer_delta(end, start);\n-}\n-\n-static void update_garbage_words_in_hr(HeapRegion* hr, size_t garbage_words) {\n-  if (garbage_words != 0) {\n-    hr->note_self_forward_chunk_done(garbage_words * HeapWordSize);\n-  }\n@@ -133,2 +126,0 @@\n-  size_t garbage_words = 0;\n-\n@@ -136,0 +127,1 @@\n+    hr->note_evacuation_failure_live_bytes(_cm->live_bytes(hr->hrm_index()));\n@@ -137,1 +129,1 @@\n-    garbage_words += zap_dead_objects(hr, hr_bottom, first_marked_addr);\n+    zap_dead_objects(hr, hr_bottom, first_marked_addr);\n@@ -142,1 +134,0 @@\n-    update_garbage_words_in_hr(hr, garbage_words);\n@@ -178,1 +169,1 @@\n-    garbage_words += zap_dead_objects(hr, obj_end_addr, next_marked_obj_addr);\n+    zap_dead_objects(hr, obj_end_addr, next_marked_obj_addr);\n@@ -185,2 +176,0 @@\n-\n-  update_garbage_words_in_hr(hr, garbage_words);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -173,0 +173,1 @@\n+  _merge_evac_failure_liveness_time_ms = 0.0;\n@@ -481,0 +482,1 @@\n+                        _merge_evac_failure_liveness_time_ms +\n@@ -495,0 +497,4 @@\n+  if (evacuation_failed) {\n+    debug_time(\"Merge Evacuation Failure Liveness\", _merge_evac_failure_liveness_time_ms);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -179,0 +179,2 @@\n+  double _merge_evac_failure_liveness_time_ms;\n+\n@@ -328,0 +330,4 @@\n+  void record_merge_evac_failure_liveness_time(double time_ms) {\n+    _merge_evac_failure_liveness_time_ms = time_ms;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1105,4 +1105,5 @@\n-      \/\/ old regions are only in the collection set after the concurrent cycle completed,\n-      \/\/ so their bitmaps must also be clear except when the pause occurs during the\n-      \/\/ Concurrent Cleanup for Next Mark phase. Only at that point the region's bitmap may\n-      \/\/ contain marks while being in the collection set at the same time.\n+      \/\/ old regions that are currently being marked through are only in the collection set\n+      \/\/ after the concurrent cycle completed, so their bitmaps must also be clear except when\n+      \/\/ the pause occurs during the Concurrent Cleanup for Next Mark phase.\n+      \/\/ Only at that point the region's bitmap may contain marks while being in the collection\n+      \/\/ set at the same time.\n@@ -1133,0 +1134,1 @@\n+      _g1h->concurrent_mark()->clear_statistics(hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -971,0 +971,8 @@\n+  if (evacuation_failed()) {\n+    \/\/ After any evacuation finished, merge liveness information gathered during\n+    \/\/ evacuation failure. This information is required in the next phase.\n+    Ticks start = Ticks::now();\n+    _g1h->concurrent_mark()->flush_all_task_caches();\n+    phase_times()->record_merge_evac_failure_liveness_time((Ticks::now() - start).seconds() * 1000.0);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -347,1 +347,3 @@\n-      G1CollectedHeap::heap()->clear_bitmap_for_region(r);\n+      G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+      g1h->clear_bitmap_for_region(r);\n+      g1h->concurrent_mark()->clear_statistics(r);\n@@ -624,1 +626,1 @@\n-  G1EvacInfo* _evacuation_info;\n+  G1EvacInfo*       _evacuation_info;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -285,2 +285,2 @@\n-void HeapRegion::note_self_forward_chunk_done(size_t garbage_bytes) {\n-  Atomic::add(&_garbage_bytes, garbage_bytes, memory_order_relaxed);\n+void HeapRegion::note_evacuation_failure_live_bytes(size_t live_bytes) {\n+  _garbage_bytes = used() - live_bytes;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -492,3 +492,2 @@\n-  \/\/ Notify the region that we have partially finished processing self-forwarded\n-  \/\/ objects during evacuation failure handling.\n-  void note_self_forward_chunk_done(size_t garbage_bytes);\n+  \/\/ Notify the region with the amount of live bytes for evacuation failed regions.\n+  void note_evacuation_failure_live_bytes(size_t garbage_bytes);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -268,0 +268,1 @@\n+        new LogMessageWithLevel(\"Merge Evacuation Failure Liveness\", Level.DEBUG),\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}