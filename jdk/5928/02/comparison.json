{"files":[{"patch":"@@ -77,1 +77,1 @@\n-    private final PublicKey trustedPubKey;\n+    private PublicKey trustedPubKey;\n@@ -93,4 +93,0 @@\n-    private static final DisabledAlgorithmConstraints\n-        certPathDefaultConstraints =\n-            DisabledAlgorithmConstraints.certPathConstraints();\n-\n@@ -107,1 +103,1 @@\n-        this(anchor, certPathDefaultConstraints, null, variant);\n+        this(anchor, null, null, variant);\n@@ -155,2 +151,2 @@\n-        this.constraints = (constraints == null ? certPathDefaultConstraints :\n-                constraints);\n+        this.constraints = constraints == null ?\n+            DisabledAlgorithmConstraints.certPathConstraints() : constraints;\n@@ -175,1 +171,1 @@\n-        this(anchor, certPathDefaultConstraints, date, variant);\n+        this(anchor, null, date, variant);\n@@ -210,2 +206,2 @@\n-        if (!(cert instanceof X509Certificate) || constraints == null) {\n-            \/\/ ignore the check for non-x.509 certificate or null constraints\n+        if (!(cert instanceof X509Certificate)) {\n+            \/\/ ignore the check for non-x.509 certificate\n@@ -236,29 +232,10 @@\n-        \/\/ Check the signature algorithm and parameters against constraints.\n-        if (!constraints.permits(SIGNATURE_PRIMITIVE_SET, currSigAlg,\n-                currSigAlgParams)) {\n-            throw new CertPathValidatorException(\n-                    \"Algorithm constraints check failed on signature \" +\n-                            \"algorithm: \" + currSigAlg, null, null, -1,\n-                    BasicReason.ALGORITHM_CONSTRAINED);\n-        }\n-\n-        \/\/ Assume all key usage bits are set if key usage is not present\n-        Set<CryptoPrimitive> primitives = KU_PRIMITIVE_SET;\n-\n-        if (keyUsage != null) {\n-                primitives = EnumSet.noneOf(CryptoPrimitive.class);\n-\n-            if (keyUsage[0] || keyUsage[1] || keyUsage[5] || keyUsage[6]) {\n-                \/\/ keyUsage[0]: KeyUsage.digitalSignature\n-                \/\/ keyUsage[1]: KeyUsage.nonRepudiation\n-                \/\/ keyUsage[5]: KeyUsage.keyCertSign\n-                \/\/ keyUsage[6]: KeyUsage.cRLSign\n-                primitives.add(CryptoPrimitive.SIGNATURE);\n-            }\n-\n-            if (keyUsage[2]) {      \/\/ KeyUsage.keyEncipherment\n-                primitives.add(CryptoPrimitive.KEY_ENCAPSULATION);\n-            }\n-\n-            if (keyUsage[3]) {      \/\/ KeyUsage.dataEncipherment\n-                primitives.add(CryptoPrimitive.PUBLIC_KEY_ENCRYPTION);\n+        if (constraints instanceof DisabledAlgorithmConstraints) {\n+            DisabledAlgorithmConstraints dac =\n+                (DisabledAlgorithmConstraints)constraints;\n+            if (prevPubKey != null && prevPubKey == trustedPubKey) {\n+                \/\/ check constraints of trusted public key (make sure\n+                \/\/ algorithm and size is not restricted)\n+                CertPathConstraintsParameters cp =\n+                    new CertPathConstraintsParameters(trustedPubKey, variant,\n+                        anchor, date);\n+                dac.permits(trustedPubKey.getAlgorithm(), cp);\n@@ -266,3 +243,25 @@\n-\n-            if (keyUsage[4]) {      \/\/ KeyUsage.keyAgreement\n-                primitives.add(CryptoPrimitive.KEY_AGREEMENT);\n+            \/\/ Check the signature algorithm and parameters against constraints\n+            CertPathConstraintsParameters cp =\n+                new CertPathConstraintsParameters(x509Cert, variant,\n+                    anchor, date);\n+            dac.permits(currSigAlg, currSigAlgParams, cp);\n+        } else {\n+            if (prevPubKey != null) {\n+                if (!constraints.permits(SIGNATURE_PRIMITIVE_SET,\n+                    currSigAlg, prevPubKey, currSigAlgParams)) {\n+                    throw new CertPathValidatorException(\n+                        \"Algorithm constraints check failed on \" +\n+                            currSigAlg + \"signature and \" +\n+                            currPubKey.getAlgorithm() + \" key with size of \" +\n+                            sun.security.util.KeyUtil.getKeySize(currPubKey) +\n+                            \"bits\",\n+                        null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);\n+                }\n+            } else {\n+                if (!constraints.permits(SIGNATURE_PRIMITIVE_SET,\n+                    currSigAlg, currSigAlgParams)) {\n+                    throw new CertPathValidatorException(\n+                        \"Algorithm constraints check failed on \" +\n+                            \"signature algorithm: \" + currSigAlg,\n+                        null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);\n+                }\n@@ -270,0 +269,2 @@\n+            \/\/ Assume all key usage bits are set if key usage is not present\n+            Set<CryptoPrimitive> primitives = KU_PRIMITIVE_SET;\n@@ -271,2 +272,2 @@\n-            \/\/ KeyUsage.encipherOnly and KeyUsage.decipherOnly are\n-            \/\/ undefined in the absence of the keyAgreement bit.\n+            if (keyUsage != null) {\n+                primitives = EnumSet.noneOf(CryptoPrimitive.class);\n@@ -274,4 +275,28 @@\n-            if (primitives.isEmpty()) {\n-                throw new CertPathValidatorException(\n-                    \"incorrect KeyUsage extension bits\",\n-                    null, null, -1, PKIXReason.INVALID_KEY_USAGE);\n+                if (keyUsage[0] || keyUsage[1] || keyUsage[5] || keyUsage[6]) {\n+                    \/\/ keyUsage[0]: KeyUsage.digitalSignature\n+                    \/\/ keyUsage[1]: KeyUsage.nonRepudiation\n+                    \/\/ keyUsage[5]: KeyUsage.keyCertSign\n+                    \/\/ keyUsage[6]: KeyUsage.cRLSign\n+                    primitives.add(CryptoPrimitive.SIGNATURE);\n+                }\n+\n+                if (keyUsage[2]) {      \/\/ KeyUsage.keyEncipherment\n+                    primitives.add(CryptoPrimitive.KEY_ENCAPSULATION);\n+                }\n+\n+                if (keyUsage[3]) {      \/\/ KeyUsage.dataEncipherment\n+                    primitives.add(CryptoPrimitive.PUBLIC_KEY_ENCRYPTION);\n+                }\n+\n+                if (keyUsage[4]) {      \/\/ KeyUsage.keyAgreement\n+                    primitives.add(CryptoPrimitive.KEY_AGREEMENT);\n+                }\n+\n+                \/\/ KeyUsage.encipherOnly and KeyUsage.decipherOnly are\n+                \/\/ undefined in the absence of the keyAgreement bit.\n+\n+                if (primitives.isEmpty()) {\n+                    throw new CertPathValidatorException(\n+                        \"incorrect KeyUsage extension bits\",\n+                        null, null, -1, PKIXReason.INVALID_KEY_USAGE);\n+                }\n@@ -279,17 +304,0 @@\n-        }\n-\n-        ConstraintsParameters cp =\n-            new CertPathConstraintsParameters(x509Cert, variant,\n-                    anchor, date);\n-\n-        \/\/ Check against local constraints if it is DisabledAlgorithmConstraints\n-        if (constraints instanceof DisabledAlgorithmConstraints) {\n-            ((DisabledAlgorithmConstraints)constraints).permits(currSigAlg,\n-                currSigAlgParams, cp);\n-            \/\/ DisabledAlgorithmsConstraints does not check primitives, so key\n-            \/\/ additional key check.\n-\n-        } else {\n-            \/\/ Perform the default constraints checking anyway.\n-            certPathDefaultConstraints.permits(currSigAlg, currSigAlgParams, cp);\n-            \/\/ Call locally set constraints to check key with primitives.\n@@ -298,5 +306,5 @@\n-                        \"Algorithm constraints check failed on key \" +\n-                                currPubKey.getAlgorithm() + \" with size of \" +\n-                                sun.security.util.KeyUtil.getKeySize(currPubKey) +\n-                                \"bits\",\n-                        null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);\n+                    \"Algorithm constraints check failed on \" +\n+                        currPubKey.getAlgorithm() + \" key with size of \" +\n+                        sun.security.util.KeyUtil.getKeySize(currPubKey) +\n+                        \"bits\",\n+                    null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);\n@@ -312,10 +320,0 @@\n-        \/\/ Check with previous cert for signature algorithm and public key\n-        if (!constraints.permits(\n-                SIGNATURE_PRIMITIVE_SET,\n-                currSigAlg, prevPubKey, currSigAlgParams)) {\n-            throw new CertPathValidatorException(\n-                    \"Algorithm constraints check failed on \" +\n-                            \"signature algorithm: \" + currSigAlg,\n-                    null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);\n-        }\n-\n@@ -363,2 +361,2 @@\n-        \/\/ specified.\n-        if (prevPubKey == null) {\n+        \/\/ been specified.\n+        if (this.prevPubKey == null) {\n@@ -370,1 +368,0 @@\n-            \/\/ Don't bother to change the trustedPubKey.\n@@ -372,1 +369,1 @@\n-                prevPubKey = anchor.getTrustedCert().getPublicKey();\n+                this.trustedPubKey = anchor.getTrustedCert().getPublicKey();\n@@ -374,1 +371,1 @@\n-                prevPubKey = anchor.getCAPublicKey();\n+                this.trustedPubKey = anchor.getCAPublicKey();\n@@ -376,0 +373,1 @@\n+            this.prevPubKey = this.trustedPubKey;\n@@ -415,3 +413,3 @@\n-        certPathDefaultConstraints.permits(algorithmId.getName(),\n-            algorithmId.getParameters(),\n-            new CertPathConstraintsParameters(key, variant, anchor));\n+        DisabledAlgorithmConstraints.certPathConstraints().permits(\n+            algorithmId.getName(), algorithmId.getParameters(),\n+            new CertPathConstraintsParameters(key, variant, anchor, null));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/AlgorithmChecker.java","additions":87,"deletions":89,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -53,2 +53,2 @@\n-    \/\/ The certificate being checked (may be null if a CRL or OCSPResponse is\n-    \/\/ being checked)\n+    \/\/ The certificate being checked (may be null if a raw public key, a CRL\n+    \/\/ or an OCSPResponse is being checked)\n@@ -63,2 +63,2 @@\n-            TrustAnchor anchor) {\n-        this(key, variant, anchor, null, null);\n+            TrustAnchor anchor, Date date) {\n+        this(key, variant, anchor, date, null);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/CertPathConstraintsParameters.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -179,2 +179,2 @@\n-        certPathCheckers.add(new AlgorithmChecker(anchor, null,\n-                params.timestamp(), params.variant()));\n+        certPathCheckers.add(new AlgorithmChecker(anchor, params.timestamp(),\n+                params.variant()));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/PKIXCertPathValidator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.util.Map;\n+import java.util.Map.Entry;\n@@ -43,0 +45,8 @@\n+    \/\/ A map of standard message digest algorithm names to decomposed names\n+    \/\/ so that a constraint can match for example, \"SHA-1\" and also\n+    \/\/ \"SHA1withRSA\".\n+    private static final Map<String, String> DECOMPOSED_DIGEST_NAMES =\n+        Map.of(\"SHA-1\", \"SHA1\", \"SHA-224\", \"SHA224\", \"SHA-256\", \"SHA256\",\n+               \"SHA-384\", \"SHA384\", \"SHA-512\", \"SHA512\", \"SHA-512\/224\",\n+               \"SHA512\/224\", \"SHA-512\/256\", \"SHA512\/256\");\n+\n@@ -96,6 +106,3 @@\n-        \/\/ handle special name: SHA-1 and SHA1\n-        if (elements.contains(\"SHA1\") && !elements.contains(\"SHA-1\")) {\n-            elements.add(\"SHA-1\");\n-        }\n-        if (elements.contains(\"SHA-1\") && !elements.contains(\"SHA1\")) {\n-            elements.add(\"SHA1\");\n+        \/\/ no need to check further if algorithm doesn't contain \"SHA\"\n+        if (!algorithm.contains(\"SHA\")) {\n+            return elements;\n@@ -104,30 +111,8 @@\n-        \/\/ handle special name: SHA-224 and SHA224\n-        if (elements.contains(\"SHA224\") && !elements.contains(\"SHA-224\")) {\n-            elements.add(\"SHA-224\");\n-        }\n-        if (elements.contains(\"SHA-224\") && !elements.contains(\"SHA224\")) {\n-            elements.add(\"SHA224\");\n-        }\n-\n-        \/\/ handle special name: SHA-256 and SHA256\n-        if (elements.contains(\"SHA256\") && !elements.contains(\"SHA-256\")) {\n-            elements.add(\"SHA-256\");\n-        }\n-        if (elements.contains(\"SHA-256\") && !elements.contains(\"SHA256\")) {\n-            elements.add(\"SHA256\");\n-        }\n-\n-        \/\/ handle special name: SHA-384 and SHA384\n-        if (elements.contains(\"SHA384\") && !elements.contains(\"SHA-384\")) {\n-            elements.add(\"SHA-384\");\n-        }\n-        if (elements.contains(\"SHA-384\") && !elements.contains(\"SHA384\")) {\n-            elements.add(\"SHA384\");\n-        }\n-\n-        \/\/ handle special name: SHA-512 and SHA512\n-        if (elements.contains(\"SHA512\") && !elements.contains(\"SHA-512\")) {\n-            elements.add(\"SHA-512\");\n-        }\n-        if (elements.contains(\"SHA-512\") && !elements.contains(\"SHA512\")) {\n-            elements.add(\"SHA512\");\n+        for (Map.Entry<String, String> e : DECOMPOSED_DIGEST_NAMES.entrySet()) {\n+            if (elements.contains(e.getValue()) &&\n+                    !elements.contains(e.getKey())) {\n+                elements.add(e.getKey());\n+            } else if (elements.contains(e.getKey()) &&\n+                    !elements.contains(e.getValue())) {\n+                elements.add(e.getValue());\n+            }\n@@ -156,12 +141,4 @@\n-    private static void hasLoop(Set<String> elements, String find, String replace) {\n-        if (elements.contains(find)) {\n-            if (!elements.contains(replace)) {\n-                elements.add(replace);\n-            }\n-            elements.remove(find);\n-        }\n-    }\n-\n-    \/*\n-     * This decomposes a standard name into sub-elements with a consistent\n-     * message digest algorithm name to avoid overly complicated checking.\n+    \/**\n+     * Decomposes a standard algorithm name into sub-elements and uses a\n+     * consistent message digest algorithm name to avoid overly complicated\n+     * checking.\n@@ -169,1 +146,1 @@\n-    public static Set<String> decomposeOneHash(String algorithm) {\n+    static Set<String> decomposeName(String algorithm) {\n@@ -176,5 +153,13 @@\n-        hasLoop(elements, \"SHA-1\", \"SHA1\");\n-        hasLoop(elements, \"SHA-224\", \"SHA224\");\n-        hasLoop(elements, \"SHA-256\", \"SHA256\");\n-        hasLoop(elements, \"SHA-384\", \"SHA384\");\n-        hasLoop(elements, \"SHA-512\", \"SHA512\");\n+        \/\/ no need to check further if algorithm doesn't contain \"SHA\"\n+        if (!algorithm.contains(\"SHA\")) {\n+            return elements;\n+        }\n+\n+        for (Map.Entry<String, String> e : DECOMPOSED_DIGEST_NAMES.entrySet()) {\n+            if (elements.contains(e.getKey())) {\n+                if (!elements.contains(e.getValue())) {\n+                    elements.add(e.getValue());\n+                }\n+                elements.remove(e.getKey());\n+            }\n+        }\n@@ -185,3 +170,7 @@\n-    \/*\n-     * The provided message digest algorithm name will return a consistent\n-     * naming scheme.\n+    \/**\n+     * Decomposes a standard message digest algorithm name into a consistent\n+     * name for matching purposes.\n+     *\n+     * @param algorithm the name to be decomposed\n+     * @return the decomposed name, or the passed in algorithm name if\n+     *     it is not a digest algorithm or does not need to be decomposed\n@@ -189,2 +178,2 @@\n-    public static String hashName(String algorithm) {\n-        return algorithm.replace(\"-\", \"\");\n+    static String decomposeDigestName(String algorithm) {\n+        return DECOMPOSED_DIGEST_NAMES.getOrDefault(algorithm, algorithm);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/AlgorithmDecomposer.java","additions":49,"deletions":60,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -307,4 +307,0 @@\n-     * The complete disabling of an algorithm is not handled by Constraints or\n-     * Constraint classes.  That is addressed with\n-     *   permit(Set<CryptoPrimitive>, String, AlgorithmParameters)\n-     *\n@@ -321,1 +317,0 @@\n-\n@@ -344,3 +339,3 @@\n-                String algorithm = AlgorithmDecomposer.hashName(\n-                        ((space > 0 ? constraintEntry.substring(0, space) :\n-                                constraintEntry)));\n+                String algorithm = AlgorithmDecomposer.decomposeDigestName(\n+                        space > 0 ? constraintEntry.substring(0, space) :\n+                                constraintEntry);\n@@ -500,1 +495,1 @@\n-                algorithms.addAll(AlgorithmDecomposer.decomposeOneHash(algorithm));\n+                algorithms.addAll(AlgorithmDecomposer.decomposeName(algorithm));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DisabledAlgorithmConstraints.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-                if (t == null || !t.toString().contains(\"MD5withRSA\")) {\n+                if (t == null || !t.toString().contains(\"MD5\")) {\n@@ -164,1 +164,1 @@\n-                        \"Expected to see MD5withRSA in exception output\", t);\n+                        \"Expected to see MD5 in exception output\", t);\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLContextImpl\/TrustTrustedCert.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-                .shouldContain(\"Invalid certificate chain: Algorithm constraints check failed on signature algorithm: MD5withRSA\")\n+                .shouldContain(\"Invalid certificate chain: Algorithm constraints check failed on disabled algorithm: MD5 used with certificate: CN=EE\")\n@@ -142,1 +142,1 @@\n-                .shouldContain(\"Invalid certificate chain: Algorithm constraints check failed on signature algorithm: MD5withRSA\")\n+                .shouldContain(\"Invalid certificate chain: Algorithm constraints check failed on disabled algorithm: MD5 used with certificate: CN=EE\")\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/CheckSignerCertChain.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @bug 8024302 8026037 8130132\n+ * @bug 8024302 8026037 8130132 8243585\n@@ -86,1 +86,1 @@\n-                .shouldMatch(\"chain is invalid. Reason:.*MD5withRSA\");\n+                .shouldMatch(\"chain is invalid. Reason:.*MD5.*\");\n@@ -178,0 +178,12 @@\n+\n+        \/\/ Sign jar with Trust Anchor that has a 512 bit key. Make sure\n+        \/\/ the error message indicates the key size is restricted.\n+        recreateJar();\n+        run(\"keytool\", \"-delete -alias ca\");\n+        newCert(\"ca\", \"-keysize 512\", \"-validity 365000\", \"-ext bc:c\");\n+        newCert(\"d\");\n+        issueCert(\"d\");\n+        run(\"jarsigner\", \"a.jar d\")\n+                .shouldContain(\"chain is invalid. \" +\n+                        \"Reason: Algorithm constraints check failed on \" +\n+                        \"keysize limits: RSA 512 bit key.\");\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/Warning.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"}]}