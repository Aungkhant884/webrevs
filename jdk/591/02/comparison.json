{"files":[{"patch":"@@ -116,1 +116,2 @@\n-  _stats->bucket_bytes    = _compact_buckets->size() * BytesPerWord;\n+  _stats->bucket_bytes    = align_up(_compact_buckets->size() * BytesPerWord,\n+                                     SharedSpaceObjectAlignment);\n@@ -118,1 +119,2 @@\n-  _stats->hashentry_bytes = _compact_entries->size() * BytesPerWord;\n+  _stats->hashentry_bytes = align_up(_compact_entries->size() * BytesPerWord,\n+                                     SharedSpaceObjectAlignment);\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"memory\/metaspaceShared.hpp\"\n@@ -1863,1 +1864,1 @@\n-      _shared_class_info_size += align_up(byte_size, BytesPerWord);\n+      _shared_class_info_size += align_up(byte_size, SharedSpaceObjectAlignment);\n@@ -1880,0 +1881,1 @@\n+    size_t bytesize = align_up(sizeof(RunTimeLambdaProxyClassInfo), SharedSpaceObjectAlignment);\n@@ -1881,1 +1883,1 @@\n-      (sizeof(RunTimeLambdaProxyClassInfo) * _dumptime_lambda_proxy_class_dictionary->_count) +\n+      (bytesize * _dumptime_lambda_proxy_class_dictionary->_count) +\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-  _estimated_metsapceobj_bytes = 0;\n+  _estimated_metaspaceobj_bytes = 0;\n@@ -208,1 +208,2 @@\n-    _estimated_metsapceobj_bytes += BytesPerWord; \/\/ See RunTimeSharedClassInfo::get_for()\n+    \/\/ See RunTimeSharedClassInfo::get_for()\n+    _estimated_metaspaceobj_bytes += align_up(BytesPerWord, SharedSpaceObjectAlignment);\n@@ -217,1 +218,1 @@\n-  _estimated_metsapceobj_bytes += bytes;\n+  _estimated_metaspaceobj_bytes += align_up(bytes, SharedSpaceObjectAlignment);\n@@ -241,2 +242,2 @@\n-    \/\/ we iterate the MetsapceObjs in a deterministic order. It doesn't matter where\n-    \/\/ the MetsapceObjs are located originally, as they are copied sequentially into\n+    \/\/ we iterate the MetaspaceObjs in a deterministic order. It doesn't matter where\n+    \/\/ the MetaspaceObjs are located originally, as they are copied sequentially into\n@@ -486,1 +487,1 @@\n-  intptr_t* archived_vtable = CppVtables::get_archived_cpp_vtable(ref->msotype(), (address)dest);\n+  intptr_t* archived_vtable = CppVtables::get_archived_vtable(ref->msotype(), (address)dest);\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -201,1 +201,1 @@\n-  size_t _estimated_metsapceobj_bytes;   \/\/ all archived MetsapceObj's.\n+  size_t _estimated_metaspaceobj_bytes;   \/\/ all archived MetaspaceObj's.\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,4 +40,0 @@\n-\/\/ Metaspace::allocate() requires that all blocks must be aligned with KlassAlignmentInBytes.\n-\/\/ We enforce the same alignment rule in blocks allocated from the shared space.\n-const int SharedSpaceObjectAlignment = KlassAlignmentInBytes;\n-\n","filename":"src\/hotspot\/share\/memory\/archiveUtils.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-\/\/ Currently, the archive contain ONLY the following types of objects that have C++ vtables.\n-#define CPP_VTABLE_PATCH_TYPES_DO(f) \\\n+\/\/ Currently, the archive contains ONLY the following types of objects that have C++ vtables.\n+#define CPP_VTABLE_TYPES_DO(f) \\\n@@ -81,1 +81,1 @@\n-static inline intptr_t* vtable_of(Metadata* m) {\n+static inline intptr_t* vtable_of(const Metadata* m) {\n@@ -85,7 +85,1 @@\n-static inline DumpRegion* mc_region() {\n-  return MetaspaceShared::misc_code_dump_space();\n-}\n-\n-template <class T> class CppVtableCloner : public T {\n-  static CppVtableInfo* _info;\n-\n+template <class T> class CppVtableCloner {\n@@ -95,2 +89,3 @@\n-  \/\/ Allocate and initialize the C++ vtable, starting from top, but do not go past end.\n-  static intptr_t* allocate(const char* name);\n+  \/\/ Allocate a clone of the vtable of T from the shared metaspace;\n+  \/\/ Initialize the contents of this clone.\n+  static CppVtableInfo* allocate_and_initialize(const char* name);\n@@ -98,12 +93,2 @@\n-  \/\/ Clone the vtable to ...\n-  static intptr_t* clone_vtable(const char* name, CppVtableInfo* info);\n-\n-  static void zero_vtable_clone() {\n-    assert(DumpSharedSpaces, \"dump-time only\");\n-    _info->zero();\n-  }\n-\n-  static bool is_valid_shared_object(const T* obj) {\n-    intptr_t* vptr = *(intptr_t**)obj;\n-    return vptr == _info->cloned_vtable();\n-  }\n+  \/\/ Copy the contents of the vtable of T into info->_cloned_vtable;\n+  static void initialize(const char* name, CppVtableInfo* info);\n@@ -114,2 +99,0 @@\n-template <class T> CppVtableInfo* CppVtableCloner<T>::_info = NULL;\n-\n@@ -117,2 +100,1 @@\n-intptr_t* CppVtableCloner<T>::allocate(const char* name) {\n-  assert(is_aligned(mc_region()->top(), sizeof(intptr_t)), \"bad alignment\");\n+CppVtableInfo* CppVtableCloner<T>::allocate_and_initialize(const char* name) {\n@@ -120,7 +102,5 @@\n-  _info = (CppVtableInfo*)mc_region()->allocate(CppVtableInfo::byte_size(n));\n-  _info->set_vtable_size(n);\n-\n-  intptr_t* p = clone_vtable(name, _info);\n-  assert((char*)p == mc_region()->top(), \"must be\");\n-\n-  return _info->cloned_vtable();\n+  CppVtableInfo* info =\n+      (CppVtableInfo*)MetaspaceShared::misc_code_dump_space()->allocate(CppVtableInfo::byte_size(n));\n+  info->set_vtable_size(n);\n+  initialize(name, info);\n+  return info;\n@@ -130,5 +110,1 @@\n-intptr_t* CppVtableCloner<T>::clone_vtable(const char* name, CppVtableInfo* info) {\n-  if (!DumpSharedSpaces) {\n-    assert(_info == 0, \"_info is initialized only at dump time\");\n-    _info = info; \/\/ Remember it -- it will be used by MetaspaceShared::is_valid_shared_method()\n-  }\n+void CppVtableCloner<T>::initialize(const char* name, CppVtableInfo* info) {\n@@ -144,1 +120,0 @@\n-  return dstvtable + n;\n@@ -198,3 +173,3 @@\n-#define ALLOC_CPP_VTABLE_CLONE(c) \\\n-  _cloned_cpp_vtptrs[c##_Kind] = CppVtableCloner<c>::allocate(#c); \\\n-  ArchivePtrMarker::mark_pointer(&_cloned_cpp_vtptrs[c##_Kind]);\n+#define ALLOCATE_AND_INITIALIZE_VTABLE(c) \\\n+  _index[c##_Kind] = CppVtableCloner<c>::allocate_and_initialize(#c); \\\n+  ArchivePtrMarker::mark_pointer(&_index[c##_Kind]);\n@@ -202,5 +177,2 @@\n-#define CLONE_CPP_VTABLE(c) \\\n-  p = CppVtableCloner<c>::clone_vtable(#c, (CppVtableInfo*)p);\n-\n-#define ZERO_CPP_VTABLE(c) \\\n- CppVtableCloner<c>::zero_vtable_clone();\n+#define INITIALIZE_VTABLE(c) \\\n+  CppVtableCloner<c>::initialize(#c, _index[c##_Kind]);\n@@ -215,1 +187,1 @@\n-  CPP_VTABLE_PATCH_TYPES_DO(DECLARE_CLONED_VTABLE_KIND)\n+  CPP_VTABLE_TYPES_DO(DECLARE_CLONED_VTABLE_KIND)\n@@ -238,3 +210,3 @@\n-\/\/     _cloned_cpp_vtptrs[ConstantPool_Kind]  == ((intptr_t**)cp)[0]\n-\/\/     _cloned_cpp_vtptrs[InstanceKlass_Kind] == ((intptr_t**)ik)[0]\n-static intptr_t** _cloned_cpp_vtptrs = NULL;\n+\/\/     _index[ConstantPool_Kind]->cloned_vtable()  == ((intptr_t**)cp)[0]\n+\/\/     _index[InstanceKlass_Kind]->cloned_vtable() == ((intptr_t**)ik)[0]\n+CppVtableInfo** CppVtables::_index = NULL;\n@@ -242,1 +214,1 @@\n-void CppVtables::allocate_cloned_cpp_vtptrs() {\n+char* CppVtables::dumptime_init() {\n@@ -244,2 +216,6 @@\n-  size_t vtptrs_bytes = _num_cloned_vtable_kinds * sizeof(intptr_t*);\n-  _cloned_cpp_vtptrs = (intptr_t**)mc_region()->allocate(vtptrs_bytes);\n+  size_t vtptrs_bytes = _num_cloned_vtable_kinds * sizeof(CppVtableInfo*);\n+  _index = (CppVtableInfo**)MetaspaceShared::misc_code_dump_space()->allocate(vtptrs_bytes);\n+\n+  CPP_VTABLE_TYPES_DO(ALLOCATE_AND_INITIALIZE_VTABLE);\n+\n+  return (char*)_index;\n@@ -248,2 +224,5 @@\n-void CppVtables::serialize_cloned_cpp_vtptrs(SerializeClosure* soc) {\n-  soc->do_ptr((void**)&_cloned_cpp_vtptrs);\n+void CppVtables::serialize(SerializeClosure* soc) {\n+  soc->do_ptr((void**)&_index);\n+  if (soc->reading()) {\n+    CPP_VTABLE_TYPES_DO(INITIALIZE_VTABLE);\n+  }\n@@ -252,1 +231,1 @@\n-intptr_t* CppVtables::get_archived_cpp_vtable(MetaspaceObj::Type msotype, address obj) {\n+intptr_t* CppVtables::get_archived_vtable(MetaspaceObj::Type msotype, address obj) {\n@@ -254,1 +233,1 @@\n-    CPP_VTABLE_PATCH_TYPES_DO(INIT_ORIG_CPP_VTPTRS);\n+    CPP_VTABLE_TYPES_DO(INIT_ORIG_CPP_VTPTRS);\n@@ -286,1 +265,1 @@\n-            \" a new subtype of Klass or MetaData without updating CPP_VTABLE_PATCH_TYPES_DO\",\n+            \" a new subtype of Klass or MetaData without updating CPP_VTABLE_TYPES_DO\",\n@@ -293,1 +272,1 @@\n-    return _cloned_cpp_vtptrs[kind];\n+    return _index[kind]->cloned_vtable();\n@@ -299,9 +278,1 @@\n-\/\/ This can be called at both dump time and run time:\n-\/\/ - clone the contents of the c++ vtables into the space\n-\/\/   allocated by allocate_cpp_vtable_clones()\n-void CppVtables::clone_cpp_vtables(intptr_t* p) {\n-  assert(DumpSharedSpaces || UseSharedSpaces, \"sanity\");\n-  CPP_VTABLE_PATCH_TYPES_DO(CLONE_CPP_VTABLE);\n-}\n-\n-void CppVtables::zero_cpp_vtable_clones_for_writing() {\n+void CppVtables::zero_archived_vtables() {\n@@ -309,18 +280,3 @@\n-  CPP_VTABLE_PATCH_TYPES_DO(ZERO_CPP_VTABLE);\n-}\n-\n-\/\/ Allocate and initialize the C++ vtables, starting from top, but do not go past end.\n-char* CppVtables::allocate_cpp_vtable_clones() {\n-  char* cloned_vtables = mc_region()->top(); \/\/ This is the beginning of all the cloned vtables\n-\n-  assert(DumpSharedSpaces, \"dump-time only\");\n-  \/\/ Layout (each slot is a intptr_t):\n-  \/\/   [number of slots in the first vtable = n1]\n-  \/\/   [ <n1> slots for the first vtable]\n-  \/\/   [number of slots in the first second = n2]\n-  \/\/   [ <n2> slots for the second vtable]\n-  \/\/   ...\n-  \/\/ The order of the vtables is the same as the CPP_VTAB_PATCH_TYPES_DO macro.\n-  CPP_VTABLE_PATCH_TYPES_DO(ALLOC_CPP_VTABLE_CLONE);\n-\n-  return cloned_vtables;\n+  for (int kind = 0; kind < _num_cloned_vtable_kinds; kind ++) {\n+    _index[kind]->zero();\n+  }\n@@ -331,1 +287,1 @@\n-  return CppVtableCloner<Method>::is_valid_shared_object(m);\n+  return vtable_of(m) == _index[Method_Kind]->cloned_vtable();\n","filename":"src\/hotspot\/share\/memory\/cppVtables.cpp","additions":46,"deletions":90,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+class CppVtableInfo;\n@@ -37,1 +38,1 @@\n-  static void patch_cpp_vtable_pointers();\n+  static CppVtableInfo** _index;\n@@ -39,6 +40,4 @@\n-  static char* allocate_cpp_vtable_clones();\n-  static void allocate_cloned_cpp_vtptrs();\n-  static void clone_cpp_vtables(intptr_t* p);\n-  static void zero_cpp_vtable_clones_for_writing();\n-  static intptr_t* get_archived_cpp_vtable(MetaspaceObj::Type msotype, address obj);\n-  static void serialize_cloned_cpp_vtptrs(SerializeClosure* sc);\n+  static char* dumptime_init();\n+  static void zero_archived_vtables();\n+  static intptr_t* get_archived_vtable(MetaspaceObj::Type msotype, address obj);\n+  static void serialize(SerializeClosure* sc);\n","filename":"src\/hotspot\/share\/memory\/cppVtables.hpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-    verify_estimate_size(_estimated_metsapceobj_bytes, \"MetaspaceObjs\");\n+    verify_estimate_size(_estimated_metaspaceobj_bytes, \"MetaspaceObjs\");\n@@ -253,3 +253,3 @@\n-  _estimated_hashtable_bytes = 0;\n-  _estimated_hashtable_bytes += SymbolTable::estimate_size_for_archive();\n-  _estimated_hashtable_bytes += SystemDictionaryShared::estimate_size_for_archive();\n+  size_t symbol_table_est = SymbolTable::estimate_size_for_archive();\n+  size_t dictionary_est = SystemDictionaryShared::estimate_size_for_archive();\n+  _estimated_hashtable_bytes = symbol_table_est + dictionary_est;\n@@ -261,1 +261,1 @@\n-  total += _estimated_metsapceobj_bytes;\n+  total += _estimated_metaspaceobj_bytes;\n@@ -268,0 +268,6 @@\n+  log_info(cds, dynamic)(\"_estimated_hashtable_bytes = \" SIZE_FORMAT \" + \" SIZE_FORMAT \" = \" SIZE_FORMAT,\n+                         symbol_table_est, dictionary_est, _estimated_hashtable_bytes);\n+  log_info(cds, dynamic)(\"_estimated_metaspaceobj_bytes = \" SIZE_FORMAT, _estimated_metaspaceobj_bytes);\n+  log_info(cds, dynamic)(\"_estimated_trampoline_bytes = \" SIZE_FORMAT, _estimated_trampoline_bytes);\n+  log_info(cds, dynamic)(\"total estimate bytes = \" SIZE_FORMAT, total);\n+\n@@ -351,1 +357,1 @@\n-  return total;\n+  return align_up(total, SharedSpaceObjectAlignment);\n","filename":"src\/hotspot\/share\/memory\/dynamicArchive.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -504,1 +504,1 @@\n-  CppVtables::serialize_cloned_cpp_vtptrs(soc);\n+  CppVtables::serialize(soc);\n@@ -735,3 +735,1 @@\n-  CppVtables::allocate_cloned_cpp_vtptrs();\n-  char* cloned_vtables = _mc_region.top();\n-  CppVtables::allocate_cpp_vtable_clones();\n+  char* cloned_vtables = CppVtables::dumptime_init();\n@@ -783,1 +781,1 @@\n-  CppVtables::zero_cpp_vtable_clones_for_writing();\n+  CppVtables::zero_archived_vtables();\n@@ -1710,2 +1708,0 @@\n-  char* buffer = static_mapinfo->cloned_vtables();\n-  CppVtables::clone_cpp_vtables((intptr_t*)buffer);\n@@ -1715,1 +1711,1 @@\n-  buffer = static_mapinfo->serialized_data();\n+  char* buffer = static_mapinfo->serialized_data();\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -38,0 +38,4 @@\n+\/\/ Metaspace::allocate() requires that all blocks must be aligned with KlassAlignmentInBytes.\n+\/\/ We enforce the same alignment rule in blocks allocated from the shared space.\n+const int SharedSpaceObjectAlignment = KlassAlignmentInBytes;\n+\n@@ -233,1 +237,1 @@\n-    return align_up(byte_size, BytesPerWord);\n+    return align_up(byte_size, SharedSpaceObjectAlignment);\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  private static Address vtablesStartAddress;\n+  private static Address vtablesIndex;\n@@ -98,1 +98,1 @@\n-    \/\/ char* vtablesStartAddress = mapped_base_address + cloned_vtable_offset;\n+    \/\/ CppVtableInfo** vtablesIndex = mapped_base_address + cloned_vtable_offset;\n@@ -101,1 +101,1 @@\n-    vtablesStartAddress = mapped_base_address.addOffsetTo(cloned_vtable_offset);\n+    vtablesIndex = mapped_base_address.addOffsetTo(cloned_vtable_offset);\n@@ -166,1 +166,0 @@\n-      long metadataVTableSize = 0;\n@@ -169,5 +168,13 @@\n-      Address copiedVtableAddress = vtablesStartAddress;\n-      for (int i=0; i < metadataTypeArray.length; i++) {\n-        \/\/ The first entry denotes the vtable size.\n-        metadataVTableSize = copiedVtableAddress.getAddressAt(0).asLongValue();\n-        vTableTypeMap.put(copiedVtableAddress.addOffsetTo(addressSize), metadataTypeArray[i]);\n+      \/\/ vtablesIndex points to this:\n+      \/\/     class CppVtableInfo {\n+      \/\/         intptr_t _vtable_size;\n+      \/\/         intptr_t _cloned_vtable[1];\n+      \/\/         ...\n+      \/\/     };\n+      \/\/     CppVtableInfo** CppVtables::_index;\n+      \/\/ This is the index of all the cloned vtables. E.g., for\n+      \/\/     ConstantPool* cp = ....; \/\/ an archived constant pool\n+      \/\/     InstanceKlass* ik = ....;\/\/ an archived class\n+      \/\/ the following holds true:\n+      \/\/     &_index[ConstantPool_Kind]->_cloned_vtable[0]  == ((intptr_t**)cp)[0]\n+      \/\/     &_index[InstanceKlass_Kind]->_cloned_vtable[0] == ((intptr_t**)ik)[0]\n@@ -175,3 +182,4 @@\n-        \/\/ The '+ 1' below is to skip the entry containing the size of this metadata's vtable.\n-        copiedVtableAddress =\n-          copiedVtableAddress.addOffsetTo((metadataVTableSize + 1) * addressSize);\n+      for (int i=0; i < metadataTypeArray.length; i++) {\n+        Address vtableInfoAddress = vtablesIndex.getAddressAt(i * addressSize); \/\/ = _index[i]\n+        Address vtableAddress = vtableInfoAddress.addOffsetTo(addressSize); \/\/ = &_index[i]->_cloned_vtable[0]\n+        vTableTypeMap.put(vtableAddress, metadataTypeArray[i]);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/memory\/FileMapInfo.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"}]}