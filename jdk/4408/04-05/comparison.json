{"files":[{"patch":"@@ -44,1 +44,1 @@\n-  if (_buffer.size() >= _buffer_max_size)  {\n+  if (_buffer.size() >= _buffer_max_size) {\n@@ -52,1 +52,0 @@\n-  assert(_buffer.size() < _buffer_max_size, \"_buffer is over-sized.\");\n@@ -58,1 +57,1 @@\n-  AsyncLogMessage m(output, decorations, os::strdup(msg));\n+  AsyncLogMessage m(&output, decorations, os::strdup(msg));\n@@ -72,1 +71,1 @@\n-    AsyncLogMessage m(output, msg_iterator.decorations(), os::strdup(msg_iterator.message()));\n+    AsyncLogMessage m(&output, msg_iterator.decorations(), os::strdup(msg_iterator.message()));\n@@ -78,1 +77,1 @@\n-  : _lock(1), _sem(0), _io_sem(1),\n+  : _lock(1), _sem(0), _flush_sem(0),\n@@ -103,1 +102,1 @@\n-      AsyncLogMessage msg(*output, decorations, ss.as_string(true \/*c_heap*\/));\n+      AsyncLogMessage msg(output, decorations, ss.as_string(true \/*c_heap*\/));\n@@ -120,1 +119,0 @@\n-  bool own_io = false;\n@@ -129,1 +127,0 @@\n-    own_io = _io_sem.trywait();\n@@ -133,3 +130,0 @@\n-  if (!own_io) {\n-    _io_sem.wait();\n-  }\n@@ -137,0 +131,1 @@\n+  int req = 0;\n@@ -144,0 +139,4 @@\n+    } else if (e->output() == nullptr) {\n+      \/\/ encounter a flush token. take a record for the time being\n+      \/\/ and notify flush() after the loop.\n+      req++;\n@@ -146,1 +145,5 @@\n-  _io_sem.signal();\n+\n+  if (req > 0) {\n+    assert(req == 1, \"AsyncLogWriter::flush() is NOT MT-safe!\");\n+    _flush_sem.signal(req);\n+  }\n@@ -183,2 +186,1 @@\n-\/\/ write() acquires and releases _io_sem even _buffer is empty.\n-\/\/ This guarantees all logging I\/O of dequeued messages are done when it returns.\n+\/\/ NOT MT-safe! see the comments in the header file.\n@@ -187,1 +189,12 @@\n-    _instance->write();\n+    {\n+      using none = LogTagSetMapping<LogTag::__NO_TAG>;\n+      AsyncLogLocker locker;\n+      LogDecorations d(LogLevel::Off, none::tagset(), LogDecorators::None);\n+      AsyncLogMessage token(nullptr, d, nullptr);\n+\n+      \/\/ not disposable\n+      _instance->_buffer.push_back(token);\n+      _instance->_sem.signal();\n+    }\n+\n+    _instance->_flush_sem.wait();\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":28,"deletions":15,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-  LogFileOutput& _output;\n+  LogFileOutput* _output;\n@@ -99,1 +99,1 @@\n-  AsyncLogMessage(LogFileOutput& output, const LogDecorations& decorations, char* msg)\n+  AsyncLogMessage(LogFileOutput* output, const LogDecorations& decorations, char* msg)\n@@ -105,1 +105,1 @@\n-  LogFileOutput* output() const { return &_output; }\n+  LogFileOutput* output() const { return _output; }\n@@ -127,1 +127,1 @@\n-\/\/ The basic operation of AsyncLogWriter is enqueue(). 2 overloading versions of it are provided to match LogOutput::write().\n+\/\/ enqueue() is the basic operation of AsyncLogWriter. 2 overloading versions of it are provided to match LogOutput::write().\n@@ -131,4 +131,3 @@\n-\/\/ The static member function flush() is designated to flush out all pending messages when JVM is terminating.\n-\/\/ In normal JVM termination, flush() is invoked in LogConfiguration::finalize(). flush() is MT-safe and can be invoked arbitrary\n-\/\/ times. It is no-op if async logging is not established.\n-\/\/\n+\/\/ flush() is designated to flush out all pending messages. MT-safety is not provided. It is no-op if async logging is not in use.\n+\/\/ In normal JVM termination, flush() is invoked in LogConfiguration::finalize(). When the users change logging configurrations\n+\/\/ via jcmd, LogConfiguration::configure_output() invokes it with the protection of ConfigurationLock.\n@@ -144,2 +143,1 @@\n-  \/\/ A lock of IO\n-  Semaphore _io_sem;\n+  Semaphore _flush_sem;\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -267,3 +267,4 @@\n-  \/\/ LogDecorators is a set of decorators represented in a uint. We use Atomic::load\/store to ensure atomicity and\n-  \/\/ memory orders. ts->update_decorators(decorators) above is a union of the current decorators and new_decorators.\n-  \/\/ It's safe to do output->set_decorators(decorators) below because new_decorators is a subset of relevant\n+  \/\/ LogDecorator is a set of decorators represented in a uint. sizeof(uint) is not greater than a machine word,\n+  \/\/ so store of it is atomic on the mainstream processors. I.e. readers see either its older value or new value.\n+  \/\/ ts->update_decorators(decorators) above is a union operation of the existing decorators at different levels.\n+  \/\/ It's safe to do output->set_decorators(decorators) below because the new decorators is a subset of relevant\n@@ -285,0 +286,2 @@\n+  OrderAccess::storestore();\n+\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -39,3 +39,0 @@\n-#ifdef ASSERT\n-  friend class LogFileStreamOutput; \/\/ just for debug purpose.\n-#endif\n","filename":"src\/hotspot\/share\/logging\/logDecorations.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"metaprogramming\/primitiveConversions.hpp\"\n@@ -63,5 +62,0 @@\n-  friend struct PrimitiveConversions::Translate<LogDecorators>;\n-\n- #ifdef ASSERT\n-  friend class LogFileStreamOutput;\n- #endif\n@@ -125,10 +119,0 @@\n-\/\/ to support Atomic::store\n-template<>\n-struct PrimitiveConversions::Translate<LogDecorators> : public std::true_type {\n-  typedef LogDecorators Value;\n-  typedef uint Decayed;\n-\n-  static Decayed decay(Value x) { return x._decorators; }\n-  static Value recover(Decayed x) { return Value(x); }\n-};\n-\n","filename":"src\/hotspot\/share\/logging\/logDecorators.hpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-  LogDecorators decorators = Atomic::load_acquire(&_decorators);\n@@ -61,1 +60,1 @@\n-    if (!decorators.is_decorator(decorator)) {\n+    if (!_decorators.is_decorator(decorator)) {\n@@ -127,8 +126,0 @@\n-#ifdef ASSERT\n-    \/\/ sanity check, it will emit more information if assertion fails\n-    \/\/ LogOutput::_decorators must always be subset of LogDecorations::_decorators.\n-    uint bitmask = (_decorators._decorators) & (decorations._decorators._decorators);\n-    vmassert(bitmask == _decorators._decorators, \"LogOutput: \" UINT32_FORMAT \" decorations: \" UINT32_FORMAT \" message = %s\",\n-            _decorators._decorators, decorations._decorators._decorators, msg);\n-#endif\n-\n","filename":"src\/hotspot\/share\/logging\/logFileStreamOutput.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"runtime\/atomic.hpp\"\n@@ -40,4 +39,0 @@\n-void LogOutput::set_decorators(const LogDecorators& decorators) {\n-  Atomic::release_store_fence(&_decorators, decorators);\n-}\n-\n","filename":"src\/hotspot\/share\/logging\/logOutput.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,3 @@\n-  void set_decorators(const LogDecorators& decorators);\n+  void set_decorators(const LogDecorators &decorators) {\n+    _decorators = decorators;\n+  }\n","filename":"src\/hotspot\/share\/logging\/logOutput.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"runtime\/atomic.hpp\"\n@@ -64,1 +63,1 @@\n-  Atomic::release_store(&_decorators, new_decorators);\n+  _decorators = new_decorators;\n@@ -83,2 +82,1 @@\n-  LogDecorators decorators = Atomic::load_acquire(&_decorators);\n-  LogDecorations decorations(level, *this, decorators);\n+  LogDecorations decorations(level, *this, _decorators);\n@@ -93,2 +91,1 @@\n-  LogDecorators decorators = Atomic::load_acquire(&_decorators);\n-  LogDecorations decorations(LogLevel::Invalid, *this, decorators);\n+  LogDecorations decorations(LogLevel::Invalid, *this, _decorators);\n","filename":"src\/hotspot\/share\/logging\/logTagSet.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"runtime\/atomic.hpp\"\n@@ -226,34 +225,0 @@\n-\n-TEST(LogDecorators, atomic_store_logDecorators) {\n-  typedef PrimitiveConversions::Translate<LogDecorators> translate;\n-  LogDecorators lhs = LogDecorators::None;\n-  LogDecorators rhs; \/\/ default bitmask\n-  uint bitmask = 0;\n-\n-  for (int i = 0; i < LogDecorators::Count; i++) {\n-    LogDecorators::Decorator decorator = static_cast<LogDecorators::Decorator>(i);\n-    if (rhs.is_decorator(decorator)) {\n-      bitmask |= 1 << i;\n-    }\n-  }\n-\n-  EXPECT_TRUE(translate::value);\n-  EXPECT_EQ((uint)0, translate::decay(lhs));\n-  EXPECT_EQ(bitmask, translate::decay(rhs));\n-\n-  Atomic::store(&lhs, rhs); \/\/ lhs = rhs in atomic.\n-  EXPECT_EQ(bitmask, translate::decay(rhs));\n-\n-  rhs = translate::recover(bitmask);\n-  for (int i = 0; i < LogDecorators::Count; i++) {\n-    LogDecorators::Decorator decorator = static_cast<LogDecorators::Decorator>(i);\n-    if (rhs.is_decorator(decorator)) {\n-      EXPECT_TRUE((bitmask & (1 << i)) != 0);\n-    } else {\n-      EXPECT_TRUE((bitmask & (1 << i)) == 0);\n-    }\n-  }\n-\n-  Atomic::store(&lhs, LogDecorators::None);\n-  EXPECT_EQ((uint)0, translate::decay(lhs));\n-}\n","filename":"test\/hotspot\/gtest\/logging\/test_logDecorators.cpp","additions":0,"deletions":35,"binary":false,"changes":35,"status":"modified"}]}