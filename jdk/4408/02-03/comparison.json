{"files":[{"patch":"@@ -267,4 +267,3 @@\n-  \/\/ LogDecorator is a set of decorators represented in a uint. sizeof(uint) is not greater than a machine word,\n-  \/\/ so store of it is atomic on the mainstream processors. I.e. readers see either its older value or new value.\n-  \/\/ ts->update_decorators(decorators) above is a union operation of the existing decorators at different levels.\n-  \/\/ It's safe to do output->set_decorators(decorators) below because the new decorators is a subset of relevant\n+  \/\/ LogDecorators is a set of decorators represented in a uint. We use Atomic::load\/store to ensure atomicity and\n+  \/\/ memory orders. ts->update_decorators(decorators) above is a union of the current decorators and new_decorators.\n+  \/\/ It's safe to do output->set_decorators(decorators) below because new_decorators is a subset of relevant\n@@ -286,2 +285,0 @@\n-  OrderAccess::storestore();\n-\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+#ifdef ASSERT\n+  friend class LogFileStreamOutput; \/\/ just for debug purpose.\n+#endif\n","filename":"src\/hotspot\/share\/logging\/logDecorations.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"metaprogramming\/primitiveConversions.hpp\"\n@@ -62,0 +63,5 @@\n+  friend class PrimitiveConversions::Translate<LogDecorators>;\n+\n+ #ifdef ASSERT\n+  friend class LogFileStreamOutput;\n+ #endif\n@@ -119,0 +125,10 @@\n+\/\/ to support Atomic::store\n+template<>\n+struct PrimitiveConversions::Translate<LogDecorators> : public std::true_type {\n+  typedef LogDecorators Value;\n+  typedef uint Decayed;\n+\n+  static Decayed decay(Value x) { return x._decorators; }\n+  static Value recover(Decayed x) { return Value(x); }\n+};\n+\n","filename":"src\/hotspot\/share\/logging\/logDecorators.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+  LogDecorators decorators = Atomic::load_acquire(&_decorators);\n@@ -60,1 +61,1 @@\n-    if (!_decorators.is_decorator(decorator)) {\n+    if (!decorators.is_decorator(decorator)) {\n@@ -126,0 +127,8 @@\n+#ifdef ASSERT\n+    \/\/ sanity check, it will emit more information if assertion fails\n+    \/\/ LogOutput::_decorators must always be subset of LogDecorations::_decorators.\n+    uint bitmask = (_decorators._decorators) & (decorations._decorators._decorators);\n+    vmassert(bitmask == _decorators._decorators, \"LogOutput: \" UINT32_FORMAT \" decorations: \" UINT32_FORMAT \" message = %s\",\n+            _decorators._decorators, decorations._decorators._decorators, msg);\n+#endif\n+\n","filename":"src\/hotspot\/share\/logging\/logFileStreamOutput.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -39,0 +40,4 @@\n+void LogOutput::set_decorators(const LogDecorators& decorators) {\n+  Atomic::release_store_fence(&_decorators, decorators);\n+}\n+\n","filename":"src\/hotspot\/share\/logging\/logOutput.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,3 +69,1 @@\n-  void set_decorators(const LogDecorators &decorators) {\n-    _decorators = decorators;\n-  }\n+  void set_decorators(const LogDecorators& decorators);\n","filename":"src\/hotspot\/share\/logging\/logOutput.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -63,1 +64,1 @@\n-  _decorators = new_decorators;\n+  Atomic::release_store(&_decorators, new_decorators);\n@@ -82,1 +83,2 @@\n-  LogDecorations decorations(level, *this, _decorators);\n+  LogDecorators decorators = Atomic::load_acquire(&_decorators);\n+  LogDecorations decorations(level, *this, decorators);\n@@ -91,1 +93,2 @@\n-  LogDecorations decorations(LogLevel::Invalid, *this, _decorators);\n+  LogDecorators decorators = Atomic::load_acquire(&_decorators);\n+  LogDecorations decorations(LogLevel::Invalid, *this, decorators);\n","filename":"src\/hotspot\/share\/logging\/logTagSet.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -225,0 +226,34 @@\n+\n+TEST(LogDecorators, atomic_store_logDecorators) {\n+  typedef PrimitiveConversions::Translate<LogDecorators> translate;\n+  LogDecorators lhs = LogDecorators::None;\n+  LogDecorators rhs; \/\/ default bitmask\n+  uint bitmask = 0;\n+\n+  for (int i = 0; i < LogDecorators::Count; i++) {\n+    LogDecorators::Decorator decorator = static_cast<LogDecorators::Decorator>(i);\n+    if (rhs.is_decorator(decorator)) {\n+      bitmask |= 1 << i;\n+    }\n+  }\n+\n+  EXPECT_TRUE(translate::value);\n+  EXPECT_EQ((uint)0, translate::decay(lhs));\n+  EXPECT_EQ(bitmask, translate::decay(rhs));\n+\n+  Atomic::store(&lhs, rhs); \/\/ lhs = rhs in atomic.\n+  EXPECT_EQ(bitmask, translate::decay(rhs));\n+\n+  rhs = translate::recover(bitmask);\n+  for (int i = 0; i < LogDecorators::Count; i++) {\n+    LogDecorators::Decorator decorator = static_cast<LogDecorators::Decorator>(i);\n+    if (rhs.is_decorator(decorator)) {\n+      EXPECT_TRUE((bitmask & (1 << i)) != 0);\n+    } else {\n+      EXPECT_TRUE((bitmask & (1 << i)) == 0);\n+    }\n+  }\n+\n+  Atomic::store(&lhs, LogDecorators::None);\n+  EXPECT_EQ((uint)0, translate::decay(lhs));\n+}\n","filename":"test\/hotspot\/gtest\/logging\/test_logDecorators.cpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"}]}