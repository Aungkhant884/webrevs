{"files":[{"patch":"@@ -105,1 +105,1 @@\n-      LogDecorations decorations(LogLevel::Warning, none::tagset(), output->decorators());\n+      LogDecorations decorations(LogLevel::Warning, none::tagset(), LogDecorators::All);\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -256,0 +256,26 @@\n+  \/\/ MT-SAFETY\n+  \/\/\n+  \/\/ ConfigurationLock can only guarantee that only one thread is doing reconfiguration. This function still needs\n+  \/\/ to be MT-safe because logsites in other threads may be executing in parallel. Reconfiguration means unified\n+  \/\/ logging allows users to dynamically change tags and decorators of a log output via DCMD.\n+  \/\/\n+  \/\/ A RCU-style synchronization 'wait_until_no_readers()' is imposed inside of 'ts->set_output_level(output, level)'\n+  \/\/ above if setting has changed. It guarantees that all logs either synchronous writing or enqueuing to the async\n+  \/\/ buffer see the new tags and decorators. It's worth noting that the synchronization happens even level does not\n+  \/\/ change.\n+  \/\/\n+  \/\/ LogDecorators is a set of decorators represented in a uint. We use Atomic::load\/store to ensure atomicity and\n+  \/\/ memory orders. ts->update_decorators(decorators) above is a union of the current decorators and new_decorators.\n+  \/\/ It's safe to do output->set_decorators(decorators) below because new_decorators is a subset of relevant\n+  \/\/ tagsets decorators. After updating output's decorators, it is still safe to shrink all decorators of tagsets.\n+  \/\/\n+  \/\/ Async logging is treated as an extention of synchronous log. Enqueuing instead of writing is still under\n+  \/\/ protection of the synchronization `wait_until_no_readers()`. There are 2 hazards in async logging as follows.\n+  \/\/ A flush operation guarantees to all pending messages in buffer are written before returning. Therefore, the two\n+  \/\/ hadards won't appear after it. It's a nop if async logging is not set.\n+  \/\/ 1. asynclog buffer may be holding some log messages with previous decorators.\n+  \/\/ 2. asynclog buffer may be holding some log messages targeting to the output 'idx'. It has been disabled by new\n+  \/\/ setting, eg. all=off and is about to be purged in delete_output(idx).\n+  \/\/\n+  AsyncLogWriter::flush();\n+\n@@ -265,4 +291,0 @@\n-    \/\/ User may disable a logOuput like this:\n-    \/\/ LogConfiguration::parse_log_arguments(filename, \"all=off\", \"\", \"\", &stream);\n-    \/\/ Just be conservative. Flush them all before deleting idx.\n-    AsyncLogWriter::flush();\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+#ifdef ASSERT\n+  friend class LogFileStreamOutput; \/\/ just for debug purpose.\n+#endif\n","filename":"src\/hotspot\/share\/logging\/logDecorations.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,11 @@\n+template <LogDecorators::Decorator d>\n+struct AllBitmask {\n+  \/\/ Use recursive template deduction to calculate the bitmask of all decorations.\n+  static const uint _value = (1 << d) | AllBitmask<static_cast<LogDecorators::Decorator>(d + 1)>::_value;\n+};\n+\n+template<>\n+struct AllBitmask<LogDecorators::Count> {\n+  static const uint _value = 0;\n+};\n+\n@@ -29,0 +40,1 @@\n+const LogDecorators LogDecorators::All  = LogDecorators(AllBitmask<time_decorator>::_value);\n","filename":"src\/hotspot\/share\/logging\/logDecorators.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"metaprogramming\/primitiveConversions.hpp\"\n@@ -62,0 +63,5 @@\n+  friend class PrimitiveConversions::Translate<LogDecorators>;\n+\n+ #ifdef ASSERT\n+  friend class LogFileStreamOutput;\n+ #endif\n@@ -85,0 +91,1 @@\n+  static const LogDecorators All;\n@@ -118,0 +125,10 @@\n+\/\/ to support Atomic::store\n+template<>\n+struct PrimitiveConversions::Translate<LogDecorators> : public std::true_type {\n+  typedef LogDecorators Value;\n+  typedef uint Decayed;\n+\n+  static Decayed decay(Value x) { return x._decorators; }\n+  static Value recover(Decayed x) { return Value(x); }\n+};\n+\n","filename":"src\/hotspot\/share\/logging\/logDecorators.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+  LogDecorators decorators = Atomic::load_acquire(&_decorators);\n@@ -60,1 +61,1 @@\n-    if (!_decorators.is_decorator(decorator)) {\n+    if (!decorators.is_decorator(decorator)) {\n@@ -126,0 +127,8 @@\n+#ifdef ASSERT\n+    \/\/ sanity check, it will emit more information if assertion fails\n+    \/\/ LogOutput::_decorators must always be subset of LogDecorations::_decorators.\n+    uint bitmask = (_decorators._decorators) & (decorations._decorators._decorators);\n+    vmassert(bitmask == _decorators._decorators, \"LogOutput: \" UINT32_FORMAT \" decorations: \" UINT32_FORMAT \" message = %s\",\n+            _decorators._decorators, decorations._decorators._decorators, msg);\n+#endif\n+\n","filename":"src\/hotspot\/share\/logging\/logFileStreamOutput.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -39,0 +40,4 @@\n+void LogOutput::set_decorators(const LogDecorators& decorators) {\n+  Atomic::release_store_fence(&_decorators, decorators);\n+}\n+\n","filename":"src\/hotspot\/share\/logging\/logOutput.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,3 +69,1 @@\n-  void set_decorators(const LogDecorators &decorators) {\n-    _decorators = decorators;\n-  }\n+  void set_decorators(const LogDecorators& decorators);\n","filename":"src\/hotspot\/share\/logging\/logOutput.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -63,1 +64,1 @@\n-  _decorators = new_decorators;\n+  Atomic::release_store(&_decorators, new_decorators);\n@@ -76,2 +77,10 @@\n-  LogDecorations decorations(level, *this, _decorators);\n-  for (LogOutputList::Iterator it = _output_list.iterator(level); it != _output_list.end(); it++) {\n+  \/\/ Increasing the atomic reader counter in iterator(level) must\n+  \/\/ happen before the creation of LogDecorations instance so\n+  \/\/ wait_until_no_readers() in LogConfiguration::configure_output()\n+  \/\/ synchronizes _decorations as well. The order is guaranteed by\n+  \/\/ the implied memory order of Atomic::add().\n+  LogOutputList::Iterator it = _output_list.iterator(level);\n+  LogDecorators decorators = Atomic::load_acquire(&_decorators);\n+  LogDecorations decorations(level, *this, decorators);\n+\n+  for (; it != _output_list.end(); it++) {\n@@ -83,2 +92,5 @@\n-  LogDecorations decorations(LogLevel::Invalid, *this, _decorators);\n-  for (LogOutputList::Iterator it = _output_list.iterator(msg.least_detailed_level()); it != _output_list.end(); it++) {\n+  LogOutputList::Iterator it = _output_list.iterator(msg.least_detailed_level());\n+  LogDecorators decorators = Atomic::load_acquire(&_decorators);\n+  LogDecorations decorations(LogLevel::Invalid, *this, decorators);\n+\n+  for (; it != _output_list.end(); it++) {\n","filename":"src\/hotspot\/share\/logging\/logTagSet.cpp","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-  AsyncLogWriter::flush();\n","filename":"test\/hotspot\/gtest\/logging\/logTestFixture.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"concurrentTestRunner.inline.hpp\"\n@@ -231,0 +232,85 @@\n+class ConcurrentLogsite : public TestRunnable {\n+  int _id;\n+\n+ public:\n+  ConcurrentLogsite(int id) : _id(id) {}\n+  void runUnitTest() const override {\n+    log_debug(logging)(\"ConcurrentLogsite %d emits a log\", _id);\n+  }\n+};\n+\n+\/\/ Dynamically change decorators while loggings are emitting.\n+TEST_VM_F(LogConfigurationTest, reconfigure_decorators_MT) {\n+  const int nrOfThreads = 2;\n+  ConcurrentLogsite logsites[nrOfThreads] = {0, 1};\n+  Semaphore done(0);\n+  const long testDurationMillis = 1000;\n+  UnitTestThread* t[nrOfThreads];\n+\n+  set_log_config(TestLogFileName, \"logging=debug\", \"none\", \"filecount=0\");\n+  set_log_config(\"stdout\", \"all=off\", \"none\");\n+  set_log_config(\"stderr\", \"all=off\", \"none\");\n+  for (int i = 0; i < nrOfThreads; ++i) {\n+    t[i] = new UnitTestThread(&logsites[i], &done, testDurationMillis);\n+  }\n+\n+  for (int i = 0; i < nrOfThreads; i++) {\n+    t[i]->doit();\n+  }\n+\n+  jlong time_start = os::elapsed_counter();\n+  while (true) {\n+    jlong elapsed = (jlong)TimeHelper::counter_to_millis(os::elapsed_counter() - time_start);\n+    if (elapsed > testDurationMillis) {\n+      break;\n+    }\n+\n+    \/\/ Take turn logging with different decorators, either None or All.\n+    set_log_config(TestLogFileName, \"logging=debug\", \"none\");\n+    set_log_config(TestLogFileName, \"logging=debug\", _all_decorators);\n+  }\n+\n+  for (int i = 0; i < nrOfThreads; ++i) {\n+    done.wait();\n+  }\n+}\n+\n+\/\/ Dynamically change tags while loggings are emitting.\n+TEST_VM_F(LogConfigurationTest, reconfigure_tags_MT) {\n+  const int nrOfThreads = 4;\n+  ConcurrentLogsite logsites[nrOfThreads] = {0, 1, 2, 3};\n+  Semaphore done(0);\n+  const long testDurationMillis = 1000;\n+  UnitTestThread* t[nrOfThreads];\n+\n+  set_log_config(TestLogFileName, \"logging=debug\", \"\", \"filecount=0\");\n+  set_log_config(\"stdout\", \"all=off\", \"none\");\n+  set_log_config(\"stderr\", \"all=off\", \"none\");\n+\n+  for (int i = 0; i < nrOfThreads; ++i) {\n+    t[i] = new UnitTestThread(&logsites[i], &done, testDurationMillis);\n+  }\n+\n+  for (int i = 0; i < nrOfThreads; i++) {\n+    t[i]->doit();\n+  }\n+\n+  jlong time_start = os::elapsed_counter();\n+  while (true) {\n+    jlong elapsed = (jlong)TimeHelper::counter_to_millis(os::elapsed_counter() - time_start);\n+    if (elapsed > testDurationMillis) {\n+      break;\n+    }\n+\n+    \/\/ turn on\/off the tagset 'logging'.\n+    set_log_config(TestLogFileName, \"logging=off\");\n+    set_log_config(TestLogFileName, \"logging=debug\", \"\", \"filecount=0\");\n+    \/\/ sleep a prime number milliseconds to allow concurrent logsites to write logs\n+    os::naked_short_nanosleep(137);\n+  }\n+\n+  for (int i = 0; i < nrOfThreads; ++i) {\n+    done.wait();\n+  }\n+}\n+\n","filename":"test\/hotspot\/gtest\/logging\/test_logConfiguration.cpp","additions":87,"deletions":1,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -213,0 +214,7 @@\n+TEST(LogDecorators, all) {\n+  LogDecorators dec = LogDecorators::All;\n+  for (size_t i = 0; i < LogDecorators::Count; i++) {\n+    EXPECT_TRUE(dec.is_decorator(decorator_array[i]));\n+  }\n+}\n+\n@@ -218,0 +226,34 @@\n+\n+TEST(LogDecorators, atomic_store_logDecorators) {\n+  typedef PrimitiveConversions::Translate<LogDecorators> translate;\n+  LogDecorators lhs = LogDecorators::None;\n+  LogDecorators rhs; \/\/ default bitmask\n+  uint bitmask = 0;\n+\n+  for (int i = 0; i < LogDecorators::Count; i++) {\n+    LogDecorators::Decorator decorator = static_cast<LogDecorators::Decorator>(i);\n+    if (rhs.is_decorator(decorator)) {\n+      bitmask |= 1 << i;\n+    }\n+  }\n+\n+  EXPECT_TRUE(translate::value);\n+  EXPECT_EQ((uint)0, translate::decay(lhs));\n+  EXPECT_EQ(bitmask, translate::decay(rhs));\n+\n+  Atomic::store(&lhs, rhs); \/\/ lhs = rhs in atomic.\n+  EXPECT_EQ(bitmask, translate::decay(rhs));\n+\n+  rhs = translate::recover(bitmask);\n+  for (int i = 0; i < LogDecorators::Count; i++) {\n+    LogDecorators::Decorator decorator = static_cast<LogDecorators::Decorator>(i);\n+    if (rhs.is_decorator(decorator)) {\n+      EXPECT_TRUE((bitmask & (1 << i)) != 0);\n+    } else {\n+      EXPECT_TRUE((bitmask & (1 << i)) == 0);\n+    }\n+  }\n+\n+  Atomic::store(&lhs, LogDecorators::None);\n+  EXPECT_EQ((uint)0, translate::decay(lhs));\n+}\n","filename":"test\/hotspot\/gtest\/logging\/test_logDecorators.cpp","additions":43,"deletions":1,"binary":false,"changes":44,"status":"modified"}]}