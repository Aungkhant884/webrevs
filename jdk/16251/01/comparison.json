{"files":[{"patch":"@@ -113,0 +113,17 @@\n+     * {@link #emit(long, long, long, SocketAddress, long)}\n+     *\n+     * @param start  the start time\n+     * @param nbytes  how many bytes were transferred\n+     * @param remote  the address of the remote socket\n+     * @param timeout  maximum time to wait\n+     *\/\n+    public static void offer(long start, long nbytes, SocketAddress remote, long timeout) {\n+        long duration = timestamp() - start;\n+        if (shouldCommit(duration)) {\n+            emit(start, duration, nbytes, remote, timeout);\n+        }\n+    }\n+\n+    \/**\n+     * Helper method to perform a common task of getting event data ready and\n+     * then emitting the event by calling\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/SocketReadEvent.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -108,0 +108,16 @@\n+     * {@link #emit(long, long, long, SocketAddress)}.\n+     *\n+     * @param start  the start time\n+     * @param bytesWritten  how many bytes were sent\n+     * @param remote  the address of the remote socket being written to\n+     *\/\n+    public static void offer(long start, long bytesWritten, SocketAddress remote) {\n+        long duration = timestamp() - start;\n+        if (shouldCommit(duration)) {\n+            emit(start, duration, bytesWritten, remote);\n+        }\n+    }\n+\n+    \/**\n+     * Helper method to perform a common task of getting event data ready and\n+     * then emitting the event by calling\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/SocketWriteEvent.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -497,4 +497,1 @@\n-        long duration = SocketReadEvent.timestamp() - start;\n-        if (SocketReadEvent.shouldCommit(duration)) {\n-            SocketReadEvent.emit(start, duration, nbytes, remoteAddress(), 0);\n-        }\n+        SocketReadEvent.offer(start, nbytes, remoteAddress(), 0);\n@@ -514,4 +511,1 @@\n-        long duration = SocketReadEvent.timestamp() - start;\n-        if (SocketReadEvent.shouldCommit(duration)) {\n-            SocketReadEvent.emit(start, duration, nbytes, remoteAddress(), 0);\n-        }\n+        SocketReadEvent.offer(start, nbytes, remoteAddress(), 0);\n@@ -628,4 +622,1 @@\n-        long duration = SocketWriteEvent.timestamp() - start;\n-        if (SocketWriteEvent.shouldCommit(duration)) {\n-            SocketWriteEvent.emit(start, duration, nbytes, remoteAddress());\n-        }\n+        SocketWriteEvent.offer(start, nbytes, remoteAddress());\n@@ -644,4 +635,1 @@\n-        long duration = SocketWriteEvent.timestamp() - start;\n-        if (SocketWriteEvent.shouldCommit(duration)) {\n-            SocketWriteEvent.emit(start, duration, nbytes, remoteAddress());\n-        }\n+        SocketWriteEvent.offer(start, nbytes, remoteAddress());\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022,2023 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import jdk.internal.event.SocketReadEvent;\n+\n@@ -63,2 +65,1 @@\n-    @Override\n-    public int read(byte[] b, int off, int len) throws IOException {\n+    private int implRead(byte[] b, int off, int len) throws IOException {\n@@ -74,0 +75,11 @@\n+    @Override\n+    public int read(byte[] b, int off, int len) throws IOException {\n+        if (!SocketReadEvent.enabled()) {\n+            return implRead(b, off, len);\n+        }\n+        long start = SocketReadEvent.timestamp();\n+        int n = implRead(b, off, len);\n+        SocketReadEvent.offer(start, n, sc.remoteAddress(), timeoutSupplier.getAsInt());\n+        return n;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketInputStream.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022,2023 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import jdk.internal.event.SocketWriteEvent;\n+\n@@ -58,0 +60,5 @@\n+        if (!SocketWriteEvent.enabled()) {\n+            sc.blockingWriteFully(b, off, len);\n+            return;\n+        }\n+        long start = SocketWriteEvent.timestamp();\n@@ -59,0 +66,1 @@\n+        SocketWriteEvent.offer(start, len, sc.remoteAddress());\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketOutputStream.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.io;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.thread.TestThread;\n+import jdk.test.lib.thread.XRun;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.event.io.TestSocketAdapterEvents\n+ *\/\n+public class TestSocketAdapterEvents {\n+    private static final int writeInt = 'A';\n+    private static final byte[] writeBuf = { 'B', 'C', 'D', 'E' };\n+\n+    private List<IOEvent> expectedEvents = new ArrayList<>();\n+\n+    private synchronized void addExpectedEvent(IOEvent event) {\n+        expectedEvents.add(event);\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        new TestSocketAdapterEvents().test();\n+    }\n+\n+    public void test() throws Throwable {\n+        try (Recording recording = new Recording()) {\n+            try (ServerSocketChannel ss = ServerSocketChannel.open()) {\n+                recording.enable(IOEvent.EVENT_SOCKET_READ).withThreshold(Duration.ofMillis(0));\n+                recording.enable(IOEvent.EVENT_SOCKET_WRITE).withThreshold(Duration.ofMillis(0));\n+                recording.start();\n+\n+                ss.socket().setReuseAddress(true);\n+                ss.socket().bind(null);\n+\n+                TestThread readerThread = new TestThread(new XRun() {\n+                    @Override\n+                    public void xrun() throws IOException {\n+                        byte[] bs = new byte[4];\n+                        try (SocketChannel sc = ss.accept(); Socket s = sc.socket(); InputStream is = s.getInputStream()) {\n+                            int readInt = is.read();\n+                            assertEquals(readInt, writeInt, \"Wrong readInt\");\n+                            addExpectedEvent(IOEvent.createSocketReadEvent(1, s));\n+\n+                            int bytesRead = is.read(bs, 0, 3);\n+                            assertEquals(bytesRead, 3, \"Wrong bytesRead partial buffer\");\n+                            addExpectedEvent(IOEvent.createSocketReadEvent(bytesRead, s));\n+\n+                            bytesRead = is.read(bs);\n+                            assertEquals(bytesRead, writeBuf.length, \"Wrong bytesRead full buffer\");\n+                            addExpectedEvent(IOEvent.createSocketReadEvent(bytesRead, s));\n+\n+                            \/\/ Try to read more, but writer have closed. Should\n+                            \/\/ get EOF.\n+                            readInt = is.read();\n+                            assertEquals(readInt, -1, \"Wrong readInt at EOF\");\n+                            addExpectedEvent(IOEvent.createSocketReadEvent(-1, s));\n+                        }\n+                    }\n+                });\n+                readerThread.start();\n+\n+                try (SocketChannel sc = SocketChannel.open(ss.socket().getLocalSocketAddress()); Socket s = sc.socket(); OutputStream os = s.getOutputStream()) {\n+                    os.write(writeInt);\n+                    addExpectedEvent(IOEvent.createSocketWriteEvent(1, s));\n+                    os.write(writeBuf, 0, 3);\n+                    addExpectedEvent(IOEvent.createSocketWriteEvent(3, s));\n+                    os.write(writeBuf);\n+                    addExpectedEvent(IOEvent.createSocketWriteEvent(writeBuf.length, s));\n+                }\n+\n+                readerThread.joinAndThrow();\n+                recording.stop();\n+                List<RecordedEvent> events = Events.fromRecording(recording);\n+                IOHelper.verifyEquals(events, expectedEvents);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestSocketAdapterEvents.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"}]}