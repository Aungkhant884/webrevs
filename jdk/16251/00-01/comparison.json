{"files":[{"patch":"@@ -113,0 +113,17 @@\n+     * {@link #emit(long, long, long, SocketAddress, long)}\n+     *\n+     * @param start  the start time\n+     * @param nbytes  how many bytes were transferred\n+     * @param remote  the address of the remote socket\n+     * @param timeout  maximum time to wait\n+     *\/\n+    public static void offer(long start, long nbytes, SocketAddress remote, long timeout) {\n+        long duration = timestamp() - start;\n+        if (shouldCommit(duration)) {\n+            emit(start, duration, nbytes, remote, timeout);\n+        }\n+    }\n+\n+    \/**\n+     * Helper method to perform a common task of getting event data ready and\n+     * then emitting the event by calling\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/SocketReadEvent.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -108,0 +108,16 @@\n+     * {@link #emit(long, long, long, SocketAddress)}.\n+     *\n+     * @param start  the start time\n+     * @param bytesWritten  how many bytes were sent\n+     * @param remote  the address of the remote socket being written to\n+     *\/\n+    public static void offer(long start, long bytesWritten, SocketAddress remote) {\n+        long duration = timestamp() - start;\n+        if (shouldCommit(duration)) {\n+            emit(start, duration, bytesWritten, remote);\n+        }\n+    }\n+\n+    \/**\n+     * Helper method to perform a common task of getting event data ready and\n+     * then emitting the event by calling\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/SocketWriteEvent.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -497,4 +497,1 @@\n-        long duration = SocketReadEvent.timestamp() - start;\n-        if (SocketReadEvent.shouldCommit(duration)) {\n-            SocketReadEvent.emit(start, duration, nbytes, remoteAddress(), 0);\n-        }\n+        SocketReadEvent.offer(start, nbytes, remoteAddress(), 0);\n@@ -514,4 +511,1 @@\n-        long duration = SocketReadEvent.timestamp() - start;\n-        if (SocketReadEvent.shouldCommit(duration)) {\n-            SocketReadEvent.emit(start, duration, nbytes, remoteAddress(), 0);\n-        }\n+        SocketReadEvent.offer(start, nbytes, remoteAddress(), 0);\n@@ -628,4 +622,1 @@\n-        long duration = SocketWriteEvent.timestamp() - start;\n-        if (SocketWriteEvent.shouldCommit(duration)) {\n-            SocketWriteEvent.emit(start, duration, nbytes, remoteAddress());\n-        }\n+        SocketWriteEvent.offer(start, nbytes, remoteAddress());\n@@ -644,4 +635,1 @@\n-        long duration = SocketWriteEvent.timestamp() - start;\n-        if (SocketWriteEvent.shouldCommit(duration)) {\n-            SocketWriteEvent.emit(start, duration, nbytes, remoteAddress());\n-        }\n+        SocketWriteEvent.offer(start, nbytes, remoteAddress());\n@@ -1388,1 +1376,9 @@\n-    private int implBlockingRead(byte[] b, int off, int len, long nanos) throws IOException {\n+    \/**\n+     * Reads bytes from the socket into the given byte array.\n+     *\n+     * @apiNote This method is for use by the socket adaptor.\n+     *\n+     * @throws IllegalBlockingModeException if the channel is non-blocking\n+     * @throws SocketTimeoutException if the read timeout elapses\n+     *\/\n+    int blockingRead(byte[] b, int off, int len, long nanos) throws IOException {\n@@ -1448,21 +1444,0 @@\n-    \/**\n-     * Reads bytes from the socket into the given byte array.\n-     *\n-     * @apiNote This method is for use by the socket adaptor.\n-     *\n-     * @throws IllegalBlockingModeException if the channel is non-blocking\n-     * @throws SocketTimeoutException if the read timeout elapses\n-     *\/\n-    int blockingRead(byte[] b, int off, int len, long nanos) throws IOException {\n-        if (!SocketReadEvent.enabled()) {\n-            return implBlockingRead(b, off, len, nanos);\n-        }\n-        long start = SocketReadEvent.timestamp();\n-        int nbytes = implBlockingRead(b, off, len, nanos);\n-        long duration = SocketReadEvent.timestamp() - start;\n-        if (SocketReadEvent.shouldCommit(duration)) {\n-            SocketReadEvent.emit(start, duration, nbytes, remoteAddress(), 0);\n-        }\n-        return nbytes;\n-    }\n-\n@@ -1489,1 +1464,1 @@\n-    private void implBlockingWriteFully(byte[] b, int off, int len) throws IOException {\n+    void blockingWriteFully(byte[] b, int off, int len) throws IOException {\n@@ -1529,18 +1504,0 @@\n-    \/**\n-     * Writes a sequence of bytes to the socket from the given byte array.\n-     *\n-     * @apiNote This method is for use by the socket adaptor.\n-     *\/\n-    void blockingWriteFully(byte[] b, int off, int len) throws IOException {\n-        if (!SocketWriteEvent.enabled()) {\n-            implBlockingWriteFully(b, off, len);\n-            return;\n-        }\n-        long start = SocketWriteEvent.timestamp();\n-        implBlockingWriteFully(b, off, len);\n-        long duration = SocketWriteEvent.timestamp() - start;\n-        if (SocketWriteEvent.shouldCommit(duration)) {\n-            SocketWriteEvent.emit(start, duration, len, remoteAddress());\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":14,"deletions":57,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022,2023 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import jdk.internal.event.SocketReadEvent;\n+\n@@ -63,2 +65,1 @@\n-    @Override\n-    public int read(byte[] b, int off, int len) throws IOException {\n+    private int implRead(byte[] b, int off, int len) throws IOException {\n@@ -74,0 +75,11 @@\n+    @Override\n+    public int read(byte[] b, int off, int len) throws IOException {\n+        if (!SocketReadEvent.enabled()) {\n+            return implRead(b, off, len);\n+        }\n+        long start = SocketReadEvent.timestamp();\n+        int n = implRead(b, off, len);\n+        SocketReadEvent.offer(start, n, sc.remoteAddress(), timeoutSupplier.getAsInt());\n+        return n;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketInputStream.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022,2023 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import jdk.internal.event.SocketWriteEvent;\n+\n@@ -58,0 +60,5 @@\n+        if (!SocketWriteEvent.enabled()) {\n+            sc.blockingWriteFully(b, off, len);\n+            return;\n+        }\n+        long start = SocketWriteEvent.timestamp();\n@@ -59,0 +66,1 @@\n+        SocketWriteEvent.offer(start, len, sc.remoteAddress());\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketOutputStream.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"}]}