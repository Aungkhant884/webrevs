{"files":[{"patch":"@@ -1388,9 +1388,1 @@\n-    \/**\n-     * Reads bytes from the socket into the given byte array.\n-     *\n-     * @apiNote This method is for use by the socket adaptor.\n-     *\n-     * @throws IllegalBlockingModeException if the channel is non-blocking\n-     * @throws SocketTimeoutException if the read timeout elapses\n-     *\/\n-    int blockingRead(byte[] b, int off, int len, long nanos) throws IOException {\n+    private int implBlockingRead(byte[] b, int off, int len, long nanos) throws IOException {\n@@ -1456,0 +1448,21 @@\n+    \/**\n+     * Reads bytes from the socket into the given byte array.\n+     *\n+     * @apiNote This method is for use by the socket adaptor.\n+     *\n+     * @throws IllegalBlockingModeException if the channel is non-blocking\n+     * @throws SocketTimeoutException if the read timeout elapses\n+     *\/\n+    int blockingRead(byte[] b, int off, int len, long nanos) throws IOException {\n+        if (!SocketReadEvent.enabled()) {\n+            return implBlockingRead(b, off, len, nanos);\n+        }\n+        long start = SocketReadEvent.timestamp();\n+        int nbytes = implBlockingRead(b, off, len, nanos);\n+        long duration = SocketReadEvent.timestamp() - start;\n+        if (SocketReadEvent.shouldCommit(duration)) {\n+            SocketReadEvent.emit(start, duration, nbytes, remoteAddress(), 0);\n+        }\n+        return nbytes;\n+    }\n+\n@@ -1476,1 +1489,1 @@\n-    void blockingWriteFully(byte[] b, int off, int len) throws IOException {\n+    private void implBlockingWriteFully(byte[] b, int off, int len) throws IOException {\n@@ -1516,0 +1529,18 @@\n+    \/**\n+     * Writes a sequence of bytes to the socket from the given byte array.\n+     *\n+     * @apiNote This method is for use by the socket adaptor.\n+     *\/\n+    void blockingWriteFully(byte[] b, int off, int len) throws IOException {\n+        if (!SocketWriteEvent.enabled()) {\n+            implBlockingWriteFully(b, off, len);\n+            return;\n+        }\n+        long start = SocketWriteEvent.timestamp();\n+        implBlockingWriteFully(b, off, len);\n+        long duration = SocketWriteEvent.timestamp() - start;\n+        if (SocketWriteEvent.shouldCommit(duration)) {\n+            SocketWriteEvent.emit(start, duration, len, remoteAddress());\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":41,"deletions":10,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.io;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.thread.TestThread;\n+import jdk.test.lib.thread.XRun;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.event.io.TestSocketAdapterEvents\n+ *\/\n+public class TestSocketAdapterEvents {\n+    private static final int writeInt = 'A';\n+    private static final byte[] writeBuf = { 'B', 'C', 'D', 'E' };\n+\n+    private List<IOEvent> expectedEvents = new ArrayList<>();\n+\n+    private synchronized void addExpectedEvent(IOEvent event) {\n+        expectedEvents.add(event);\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        new TestSocketAdapterEvents().test();\n+    }\n+\n+    public void test() throws Throwable {\n+        try (Recording recording = new Recording()) {\n+            try (ServerSocketChannel ss = ServerSocketChannel.open()) {\n+                recording.enable(IOEvent.EVENT_SOCKET_READ).withThreshold(Duration.ofMillis(0));\n+                recording.enable(IOEvent.EVENT_SOCKET_WRITE).withThreshold(Duration.ofMillis(0));\n+                recording.start();\n+\n+                ss.socket().setReuseAddress(true);\n+                ss.socket().bind(null);\n+\n+                TestThread readerThread = new TestThread(new XRun() {\n+                    @Override\n+                    public void xrun() throws IOException {\n+                        byte[] bs = new byte[4];\n+                        try (SocketChannel sc = ss.accept(); Socket s = sc.socket(); InputStream is = s.getInputStream()) {\n+                            int readInt = is.read();\n+                            assertEquals(readInt, writeInt, \"Wrong readInt\");\n+                            addExpectedEvent(IOEvent.createSocketReadEvent(1, s));\n+\n+                            int bytesRead = is.read(bs, 0, 3);\n+                            assertEquals(bytesRead, 3, \"Wrong bytesRead partial buffer\");\n+                            addExpectedEvent(IOEvent.createSocketReadEvent(bytesRead, s));\n+\n+                            bytesRead = is.read(bs);\n+                            assertEquals(bytesRead, writeBuf.length, \"Wrong bytesRead full buffer\");\n+                            addExpectedEvent(IOEvent.createSocketReadEvent(bytesRead, s));\n+\n+                            \/\/ Try to read more, but writer have closed. Should\n+                            \/\/ get EOF.\n+                            readInt = is.read();\n+                            assertEquals(readInt, -1, \"Wrong readInt at EOF\");\n+                            addExpectedEvent(IOEvent.createSocketReadEvent(-1, s));\n+                        }\n+                    }\n+                });\n+                readerThread.start();\n+\n+                try (SocketChannel sc = SocketChannel.open(ss.socket().getLocalSocketAddress()); Socket s = sc.socket(); OutputStream os = s.getOutputStream()) {\n+                    os.write(writeInt);\n+                    addExpectedEvent(IOEvent.createSocketWriteEvent(1, s));\n+                    os.write(writeBuf, 0, 3);\n+                    addExpectedEvent(IOEvent.createSocketWriteEvent(3, s));\n+                    os.write(writeBuf);\n+                    addExpectedEvent(IOEvent.createSocketWriteEvent(writeBuf.length, s));\n+                }\n+\n+                readerThread.joinAndThrow();\n+                recording.stop();\n+                List<RecordedEvent> events = Events.fromRecording(recording);\n+                IOHelper.verifyEquals(events, expectedEvents);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestSocketAdapterEvents.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"}]}