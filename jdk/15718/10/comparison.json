{"files":[{"patch":"@@ -81,0 +81,2 @@\n+define_pd_global(uint, SecondarySuperMissBackoff, 1000);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1534,2 +1534,18 @@\n-  \/\/ Success.  Cache the super we found and proceed in triumph.\n-  str(super_klass, super_cache_addr);\n+  \/\/ Success. Try to cache the super we found and proceed in triumph.\n+\n+  uint32_t super_cache_backoff = checked_cast<uint32_t>(SecondarySuperMissBackoff);\n+  if (super_cache_backoff > 0) {\n+    Label L_skip;\n+\n+    ldrw(rscratch1, Address(rthread, JavaThread::backoff_secondary_super_miss_offset()));\n+    subw(rscratch1, rscratch1, 1);\n+    tbz(rscratch1, 31, L_skip);\n+\n+    str(super_klass, super_cache_addr);\n+    movw(rscratch1, super_cache_backoff);\n+\n+    bind(L_skip);\n+    strw(rscratch1, Address(rthread, JavaThread::backoff_secondary_super_miss_offset()));\n+  } else {\n+    str(super_klass, super_cache_addr);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -76,0 +76,3 @@\n+\/\/ Not implemented yet\n+define_pd_global(uint, SecondarySuperMissBackoff, 0);\n+\n","filename":"src\/hotspot\/cpu\/arm\/globals_arm.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -80,0 +80,2 @@\n+define_pd_global(uint, SecondarySuperMissBackoff, 1000);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2024,1 +2024,22 @@\n-  std(super_klass, target_offset, sub_klass); \/\/ save result to cache\n+  \/\/ Success. Try to cache the super we found and proceed in triumph.\n+  uint32_t super_cache_backoff = checked_cast<uint32_t>(SecondarySuperMissBackoff);\n+  if (super_cache_backoff > 0) {\n+    Label L_skip;\n+\n+    lwz(temp, in_bytes(JavaThread::backoff_secondary_super_miss_offset()), R16_thread);\n+    addic_(temp, temp, -1);\n+    stw(temp, in_bytes(JavaThread::backoff_secondary_super_miss_offset()), R16_thread);\n+    bgt(CCR0, L_skip);\n+\n+    load_const_optimized(temp, super_cache_backoff);\n+    stw(temp, in_bytes(JavaThread::backoff_secondary_super_miss_offset()), R16_thread);\n+\n+    std(super_klass, target_offset, sub_klass); \/\/ save result to cache\n+\n+    bind(L_skip);\n+    if (L_success == nullptr && result_reg == noreg) {\n+      crorc(CCR0, Assembler::equal, CCR0, Assembler::equal); \/\/ Restore CCR0 EQ\n+    }\n+  } else {\n+    std(super_klass, target_offset, sub_klass); \/\/ save result to cache\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -79,0 +79,3 @@\n+\/\/ Not implemented yet\n+define_pd_global(uint, SecondarySuperMissBackoff, 0);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -81,0 +81,2 @@\n+define_pd_global(uint, SecondarySuperMissBackoff, 1000);\n+\n","filename":"src\/hotspot\/cpu\/s390\/globals_s390.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3030,1 +3030,2 @@\n-  assert_different_registers(Z_R1, Rsubklass, Rsuperklass, Rarray_ptr, Rlength);\n+  const Register temp = Z_R1_scratch;\n+  assert_different_registers(temp, Rsubklass, Rsuperklass, Rarray_ptr, Rlength);\n@@ -3039,0 +3040,1 @@\n+  const int sm_offset = in_bytes(JavaThread::backoff_secondary_super_miss_offset());\n@@ -3063,1 +3065,1 @@\n-  z_llill(Z_R1, BytesPerWord);               \/\/ Set increment\/end index.\n+  z_llill(temp, BytesPerWord);               \/\/ Set increment\/end index.\n@@ -3072,1 +3074,1 @@\n-  z_brxlg(Rlength, Z_R1, loop_iterate);\n+  z_brxlg(Rlength, temp, loop_iterate);\n@@ -3082,1 +3084,16 @@\n-  z_stg(Rsuperklass, sc_offset, Rsubklass); \/\/ Save result to cache.\n+  \/\/ Success. Try to cache the super we found and proceed in triumph.\n+  uint32_t super_cache_backoff = checked_cast<uint32_t>(SecondarySuperMissBackoff);\n+  if (super_cache_backoff > 0 && VM_Version::has_MemWithImmALUOps()) {\n+    NearLabel L_skip;\n+    z_asi(Address(Z_thread, sm_offset), -1);\n+    branch_optimized(Assembler::bcondNotLow, L_skip);\n+\n+    load_const_optimized(temp, super_cache_backoff);\n+    z_st(temp, sm_offset, Z_thread);\n+\n+    z_stg(Rsuperklass, sc_offset, Rsubklass); \/\/ Save result to cache.\n+\n+    bind(L_skip);\n+  } else {\n+    z_stg(Rsuperklass, sc_offset, Rsubklass); \/\/ Save result to cache.\n+  }\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -99,0 +99,2 @@\n+define_pd_global(uint, SecondarySuperMissBackoff, 1000);\n+\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4618,2 +4618,23 @@\n-  \/\/ Success.  Cache the super we found and proceed in triumph.\n-  movptr(super_cache_addr, super_klass);\n+  \/\/ Success. Try to cache the super we found and proceed in triumph.\n+\n+#ifdef _LP64\n+  uint32_t super_cache_backoff = checked_cast<uint32_t>(SecondarySuperMissBackoff);\n+  if (super_cache_backoff > 0) {\n+    Label L_skip;\n+\n+    subl(Address(r15_thread, JavaThread::backoff_secondary_super_miss_offset()), 1);\n+    jccb(Assembler::greaterEqual, L_skip);\n+\n+    movptr(super_cache_addr, super_klass);\n+    movl(Address(r15_thread, JavaThread::backoff_secondary_super_miss_offset()), super_cache_backoff);\n+\n+    bind(L_skip);\n+\n+    \/\/ The operations above destroy condition codes set by scan.\n+    \/\/ This is the success path, restore them ourselves.\n+    cmpptr(rax, rax); \/\/ set ZF=1\n+  } else\n+#endif\n+  {\n+    movptr(super_cache_addr, super_klass);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -52,0 +52,3 @@\n+\/\/ not used\n+define_pd_global(uint, SecondarySuperMissBackoff, 0);\n+\n","filename":"src\/hotspot\/cpu\/zero\/globals_zero.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1994,0 +1994,7 @@\n+                                                                            \\\n+  product_pd(uint, SecondarySuperMissBackoff, DIAGNOSTIC,                   \\\n+          \"How many misses to accept before updating the secondary super \"  \\\n+          \"cache slot. This mitigates cache slot contention in \"            \\\n+          \"pathological cases. Use 0 to disable.\")                          \\\n+          range(0, UINT32_MAX)                                              \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -417,0 +417,2 @@\n+  _backoff_secondary_super_miss(SecondarySuperMissBackoff),\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -145,0 +145,3 @@\n+  \/\/ Used to back off on secondary super cache updates to mitigate contention on it.\n+  uint32_t       _backoff_secondary_super_miss;\n+\n@@ -743,0 +746,3 @@\n+  \/\/ Backoff counters support\n+  static ByteSize backoff_secondary_super_miss_offset() { return byte_offset_of(JavaThread, _backoff_secondary_super_miss); }\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Warmup(iterations = 5, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = \"-XX:TieredStopAtLevel=1\")\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Threads(Threads.MAX)\n+@State(Scope.Benchmark)\n+public class SecondarySuperCache {\n+\n+    \/\/ This test targets C1 specifically, to enter the interesting code path\n+    \/\/ without heavily optimizing compiler like C2 optimizing based on profiles,\n+    \/\/ or folding the instanceof checks.\n+\n+    interface IA {}\n+    interface IB {}\n+    interface I extends IA, IB {}\n+    public class C1 implements I {}\n+    public class C2 implements I {}\n+\n+    I c1, c2;\n+\n+    @Setup\n+    public void setup() {\n+        c1 = new C1();\n+        c2 = new C2();\n+    }\n+\n+    @Benchmark\n+    public void contended(Blackhole bh) {\n+        bh.consume(c1 instanceof IA);\n+        bh.consume(c2 instanceof IA);\n+        bh.consume(c1 instanceof IB);\n+        bh.consume(c2 instanceof IB);\n+    }\n+\n+    @Benchmark\n+    public void uncontended(Blackhole bh) {\n+        bh.consume(c1 instanceof IA);\n+        bh.consume(c1 instanceof IA);\n+        bh.consume(c2 instanceof IB);\n+        bh.consume(c2 instanceof IB);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/SecondarySuperCache.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"}]}