{"files":[{"patch":"@@ -1534,2 +1534,26 @@\n-  \/\/ Success.  Cache the super we found and proceed in triumph.\n-  str(super_klass, super_cache_addr);\n+  \/\/ Success. Try to cache the super we found and proceed in triumph.\n+\n+  uint32_t super_cache_backoff = checked_cast<uint32_t>(SecondarySuperMissBackoff);\n+  if (super_cache_backoff > 0) {\n+    Label L_skip;\n+\n+    ldr(rscratch1, Address(rthread, JavaThread::backoff_secondary_super_miss_offset()));\n+    sub(rscratch1, rscratch1, 1);\n+    str(rscratch1, Address(rthread, JavaThread::backoff_secondary_super_miss_offset()));\n+\n+    cmp(rscratch1, (u1) 0);\n+    br(Assembler::GT, L_skip);\n+\n+    mov_immediate32(rscratch1, super_cache_backoff);\n+    str(rscratch1, Address(rthread, JavaThread::backoff_secondary_super_miss_offset()));\n+\n+    str(super_klass, super_cache_addr);\n+\n+    bind(L_skip);\n+\n+    \/\/ The operations above destroy condition codes set by scan.\n+    \/\/ This is the success path, restore them ourselves.\n+    cmp(zr, zr); \/\/ Set Z flag\n+  } else {\n+    str(super_klass, super_cache_addr);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -4618,2 +4618,23 @@\n-  \/\/ Success.  Cache the super we found and proceed in triumph.\n-  movptr(super_cache_addr, super_klass);\n+  \/\/ Success. Try to cache the super we found and proceed in triumph.\n+\n+#ifdef _LP64\n+  uint32_t super_cache_backoff = checked_cast<uint32_t>(SecondarySuperMissBackoff);\n+  if (super_cache_backoff > 0) {\n+    Label L_skip;\n+\n+    subl(Address(r15_thread, JavaThread::backoff_secondary_super_miss_offset()), 1);\n+    jccb(Assembler::greaterEqual, L_skip);\n+    movl(Address(r15_thread, JavaThread::backoff_secondary_super_miss_offset()), super_cache_backoff);\n+\n+    movptr(super_cache_addr, super_klass);\n+\n+    bind(L_skip);\n+\n+    \/\/ The operations above destroy condition codes set by scan.\n+    \/\/ This is the success path, restore them ourselves.\n+    cmpptr(rax, rax); \/\/ set ZF=1\n+  } else\n+#endif\n+  {\n+    movptr(super_cache_addr, super_klass);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2002,0 +2002,7 @@\n+                                                                            \\\n+  product(uint, SecondarySuperMissBackoff, 1000, EXPERIMENTAL,              \\\n+          \"How many misses to accept before updating the secondary super \"  \\\n+          \"cache slot. This mitigates cache slot contention in \"            \\\n+          \"pathological cases. Use 0 to disable.\")                          \\\n+          range(0, UINT32_MAX)                                              \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -417,0 +417,2 @@\n+  _backoff_secondary_super_miss(0),\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -145,0 +145,3 @@\n+  \/\/ Used to back off on secondary super cache updates to mitigate contention on it.\n+  uint32_t       _backoff_secondary_super_miss;\n+\n@@ -743,0 +746,3 @@\n+  \/\/ Backoff counters support\n+  static ByteSize backoff_secondary_super_miss_offset() { return byte_offset_of(JavaThread, _backoff_secondary_super_miss); }\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+package org.openjdk;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Warmup(iterations = 5, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = \"-XX:TieredStopAtLevel=1\")\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Threads(Threads.MAX)\n+@State(Scope.Benchmark)\n+public class SecondarySuperCache {\n+\n+    \/\/ This test targets C1 specifically, to enter the interesting code path\n+    \/\/ without heavily optimizing compiler like C2 optimizing based on profiles,\n+    \/\/ or folding the instanceof checks.\n+\n+    interface IA {}\n+    interface IB {}\n+    interface I extends IA, IB {}\n+    public class C1 implements I {}\n+    public class C2 implements I {}\n+\n+    I c1, c2;\n+\n+    @Setup\n+    public void setup() {\n+        c1 = new C1();\n+        c2 = new C2();\n+    }\n+\n+    @Benchmark\n+    public void contended(Blackhole bh) {\n+        bh.consume(c1 instanceof IA);\n+        bh.consume(c2 instanceof IA);\n+        bh.consume(c1 instanceof IB);\n+        bh.consume(c2 instanceof IB);\n+    }\n+\n+    @Benchmark\n+    public void uncontended(Blackhole bh) {\n+        bh.consume(c1 instanceof IA);\n+        bh.consume(c1 instanceof IA);\n+        bh.consume(c2 instanceof IB);\n+        bh.consume(c2 instanceof IB);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/SecondarySuperCache.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"}]}