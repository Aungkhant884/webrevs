{"files":[{"patch":"@@ -524,1 +524,4 @@\n-     * termination.\n+     * termination. To conform to ExecutorService invoke, invokeAll,\n+     * and invokeAny specs, we must track pool status while waiting,\n+     * and interrupt interruptable callers on termination (see\n+     * ForkJoinTask.joinForPoolInvoke etc).\n@@ -634,0 +637,7 @@\n+     * Guarantees for common pool parallelism zero are limited to\n+     * tasks that are joined by their callers in a tree-structured\n+     * fashion or use CountedCompleters (as is true for jdk\n+     * parallelStreams). Support infiltrates several methods,\n+     * including those that retry helping steps until we are sure that\n+     * none apply if there are no workers.\n+     *\n@@ -896,1 +906,1 @@\n-            return QA.weakCompareAndSet(a, i, c, null);\n+            return QA.compareAndSet(a, i, c, null);\n@@ -1049,7 +1059,16 @@\n-            int s = top, cap, k; ForkJoinTask<?>[] a;\n-            if ((a = array) != null && (cap = a.length) > 0 &&\n-                a[k = (cap - 1) & (s - 1)] == task && tryLock()) {\n-                if (top == s && array == a &&\n-                    (taken = casSlotToNull(a, k, task)))\n-                    top = s - 1;\n-                source = 0; \/\/ release lock\n+            for (;;) {\n+                int s = top, cap, k; ForkJoinTask<?>[] a;\n+                if ((a = array) == null || (cap = a.length) <= 0 ||\n+                    a[k = (cap - 1) & (s - 1)] != task)\n+                    break;\n+                if (tryLock()) {\n+                    if (top == s && array == a) {\n+                        if (taken = casSlotToNull(a, k, task)) {\n+                            top = s - 1;\n+                            source = 0;\n+                            break;\n+                        }\n+                    }\n+                    source = 0; \/\/ release lock for retry\n+                }\n+                Thread.yield(); \/\/ trylock failure\n@@ -1197,0 +1216,4 @@\n+                        if (taken)\n+                            t.doExec();\n+                        else if (!owned)\n+                            Thread.yield(); \/\/ tryLock failure\n@@ -1202,4 +1225,1 @@\n-                if (!taken)\n-                    break;\n-                t.doExec();\n-                if (limit != 0 && --limit == 0)\n+                if (taken && limit != 0 && --limit == 0)\n@@ -1589,1 +1609,1 @@\n-        if (w != null) {                        \/\/ skip on failed init\n+        if (mode >= 0 && w != null) {           \/\/ skip on failed init\n@@ -1713,16 +1733,0 @@\n-    \/**\n-     * Returns true if all workers are busy, possibly creating one if allowed\n-     *\/\n-    final boolean isSaturated() {\n-        int maxTotal = bounds >>> SWIDTH;\n-        for (long c;;) {\n-            if (((int)(c = ctl) & ~UNSIGNALLED) != 0)\n-                return false;\n-            if ((short)(c >>> TC_SHIFT) >= maxTotal)\n-                return true;\n-            long nc = ((c + TC_UNIT) & TC_MASK) | (c & ~TC_MASK);\n-            if (compareAndSetCtl(c, nc))\n-                return !createWorker();\n-        }\n-    }\n-\n@@ -1768,1 +1772,2 @@\n-        int b = bounds; \/\/ counts are signed; centered at parallelism level == 0\n+        int md = mode, b = bounds;\n+        \/\/ counts are signed; centered at parallelism level == 0\n@@ -1774,1 +1779,3 @@\n-        if (total >= 0) {\n+        if ((md & SMASK) == 0)\n+            return 0;                  \/\/ cannot compensate if parallelism zero\n+        else if (total >= 0) {\n@@ -1822,0 +1829,1 @@\n+     * @param canHelp if false, compensate only\n@@ -1824,1 +1832,1 @@\n-    final int helpJoin(ForkJoinTask<?> task, WorkQueue w) {\n+    final int helpJoin(ForkJoinTask<?> task, WorkQueue w, boolean canHelp) {\n@@ -1839,1 +1847,1 @@\n-                else {                            \/\/ scan for subtasks\n+                else if (canHelp) {               \/\/ scan for subtasks\n@@ -2197,0 +2205,10 @@\n+    \/**\n+     * Returns queue for an external thread, if one exists\n+     *\/\n+    final WorkQueue externalQueue() {\n+        WorkQueue[] qs;\n+        int r = ThreadLocalRandom.getProbe(), n;\n+        return ((qs = queues) != null && (n = qs.length) > 0 && r != 0) ?\n+            qs[(n - 1) & (r << 1)] : null;\n+    }\n+\n@@ -2208,2 +2226,2 @@\n-        else if (e == common)\n-            w = commonQueue();\n+        else if (e instanceof ForkJoinPool)\n+            w = ((ForkJoinPool)e).externalQueue();\n@@ -2295,2 +2313,4 @@\n-        for (int k = 0; k < 2; ++k) { \/\/ twice in case of lagging qs updates\n-            for (ForkJoinTask<?> t; (t = pollScan(false)) != null; )\n+        for (boolean rescan = true;;) { \/\/ repeat until no changes\n+            boolean changed = false;\n+            for (ForkJoinTask<?> t; (t = pollScan(false)) != null; ) {\n+                changed = true;\n@@ -2298,0 +2318,1 @@\n+            }\n@@ -2303,0 +2324,1 @@\n+                        changed = true;\n@@ -2320,0 +2342,6 @@\n+            if (changed)\n+                rescan = true;\n+            else if (rescan)\n+                rescan = false;\n+            else\n+                break;\n@@ -2542,4 +2570,0 @@\n-        int p = this.mode = Math.min(Math.max(parallelism, 0), MAX_CAP);\n-        int size = 1 << (33 - Integer.numberOfLeadingZeros(p > 0 ? p - 1 : 1));\n-        this.factory = (fac != null) ? fac :\n-            new DefaultCommonPoolForkJoinWorkerThreadFactory();\n@@ -2550,3 +2574,13 @@\n-        this.bounds = ((1 - p) & SMASK) | (COMMON_MAX_SPARES << SWIDTH);\n-        this.ctl = ((((long)(-p) << TC_SHIFT) & TC_MASK) |\n-                    (((long)(-p) << RC_SHIFT) & RC_MASK));\n+        int p = Math.min(Math.max(parallelism, 0), MAX_CAP), size;\n+        if (p > 0) {\n+            size = 1 << (33 - Integer.numberOfLeadingZeros(p - 1));\n+            this.bounds = ((1 - p) & SMASK) | (COMMON_MAX_SPARES << SWIDTH);\n+            this.ctl = ((((long)(-p) << TC_SHIFT) & TC_MASK) |\n+                        (((long)(-p) << RC_SHIFT) & RC_MASK));\n+        } else {  \/\/ zero min, max, spare counts, 1 slot\n+            size = 1;\n+            this.bounds = 0;\n+            this.ctl = 0L;\n+        }\n+        this.factory = (fac != null) ? fac :\n+            new DefaultCommonPoolForkJoinWorkerThreadFactory();\n@@ -2596,1 +2630,1 @@\n-        return task.join();\n+        return task.joinForPoolInvoke(this);\n@@ -2688,1 +2722,1 @@\n-                ((ForkJoinTask<?>)futures.get(i)).quietlyJoin();\n+                ((ForkJoinTask<?>)futures.get(i)).awaitPoolInvoke(this);\n@@ -2718,5 +2752,1 @@\n-                        try {\n-                            f.get(ns, TimeUnit.NANOSECONDS);\n-                        } catch (CancellationException | TimeoutException |\n-                                 ExecutionException ok) {\n-                        }\n+                        ((ForkJoinTask<T>)f).awaitPoolInvoke(this, ns);\n@@ -2749,3 +2779,7 @@\n-            boolean failed = (c == null || isCancelled() ||\n-                              (pool != null && pool.mode < 0));\n-            if (!failed && !isDone()) {\n+            boolean failed;\n+            if (c == null || Thread.interrupted() ||\n+                (pool != null && pool.mode < 0))\n+                failed = true;\n+            else if (isDone())\n+                failed = false;\n+            else {\n@@ -2754,0 +2788,1 @@\n+                    failed = false;\n@@ -2820,1 +2855,1 @@\n-            return root.get();\n+            return root.getForPoolInvoke(this);\n@@ -2847,1 +2882,1 @@\n-            return root.get(nanos, TimeUnit.NANOSECONDS);\n+            return root.getForPoolInvoke(this, nanos);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":92,"deletions":57,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -279,1 +279,1 @@\n-        return STATUS.weakCompareAndSet(this, c, v);\n+        return STATUS.compareAndSet(this, c, v);\n@@ -298,78 +298,0 @@\n-    \/**\n-     * Possibly blocks until task is done or interrupted or timed out.\n-     *\n-     * @param interruptible true if wait can be cancelled by interrupt\n-     * @param deadline if non-zero use timed waits and possibly timeout\n-     * @param pool if nonnull pool to uncompensate after unblocking\n-     * @return status on exit, or ABNORMAL if interrupted while waiting\n-     *\/\n-    private int awaitDone(boolean interruptible, long deadline,\n-                          ForkJoinPool pool) {\n-        int s;\n-        boolean interrupted = false, queued = false, parked = false;\n-        Aux node = null;\n-        while ((s = status) >= 0) {\n-            Aux a; long ns;\n-            if (parked && Thread.interrupted()) {\n-                if (interruptible) {\n-                    s = ABNORMAL;\n-                    break;\n-                }\n-                interrupted = true;\n-            }\n-            else if (queued) {\n-                if (deadline != 0L) {\n-                    if ((ns = deadline - System.nanoTime()) <= 0L)\n-                        break;\n-                    LockSupport.parkNanos(ns);\n-                }\n-                else\n-                    LockSupport.park();\n-                parked = true;\n-            }\n-            else if (node != null) {\n-                if ((a = aux) != null && a.ex != null)\n-                    Thread.onSpinWait();     \/\/ exception in progress\n-                else if (queued = casAux(node.next = a, node))\n-                    LockSupport.setCurrentBlocker(this);\n-            }\n-            else {\n-                try {\n-                    node = new Aux(Thread.currentThread(), null);\n-                } catch (Throwable ex) {     \/\/ try to cancel if cannot create\n-                    casStatus(s, s | (DONE | ABNORMAL));\n-                }\n-            }\n-        }\n-        if (pool != null)\n-            pool.uncompensate();\n-\n-        if (queued) {\n-            LockSupport.setCurrentBlocker(null);\n-            if (s >= 0) { \/\/ cancellation similar to AbstractQueuedSynchronizer\n-                outer: for (Aux a; (a = aux) != null && a.ex == null; ) {\n-                    for (Aux trail = null;;) {\n-                        Aux next = a.next;\n-                        if (a == node) {\n-                            if (trail != null)\n-                                trail.casNext(trail, next);\n-                            else if (casAux(a, next))\n-                                break outer; \/\/ cannot be re-encountered\n-                            break;           \/\/ restart\n-                        } else {\n-                            trail = a;\n-                            if ((a = next) == null)\n-                                break outer;\n-                        }\n-                    }\n-                }\n-            }\n-            else {\n-                signalWaiters();             \/\/ help clean or signal\n-                if (interrupted)\n-                    Thread.currentThread().interrupt();\n-            }\n-        }\n-        return s;\n-    }\n-\n@@ -466,0 +388,1 @@\n+     * @param pool if nonnull, known submitted pool, else assumes current pool\n@@ -472,1 +395,2 @@\n-    private int awaitJoin(boolean ran, boolean interruptible, boolean timed,\n+    private int awaitDone(ForkJoinPool pool, boolean ran,\n+                          boolean interruptible, boolean timed,\n@@ -474,6 +398,9 @@\n-        boolean internal; ForkJoinPool p; ForkJoinPool.WorkQueue q; int s;\n-        Thread t; ForkJoinWorkerThread wt;\n-        if (internal = ((t = Thread.currentThread())\n-                        instanceof ForkJoinWorkerThread)) {\n-            p = (wt = (ForkJoinWorkerThread)t).pool;\n-            q = wt.workQueue;\n+        ForkJoinPool p; boolean internal; int s; Thread t;\n+        ForkJoinPool.WorkQueue q = null;\n+        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) {\n+            ForkJoinWorkerThread wt = (ForkJoinWorkerThread)t;\n+            p = wt.pool;\n+            if (pool == null)\n+                pool = p;\n+            if (internal = (pool == p))\n+                q = wt.workQueue;\n@@ -482,0 +409,1 @@\n+            internal = false;\n@@ -483,3 +411,4 @@\n-            q = ForkJoinPool.commonQueue();\n-            if (interruptible && Thread.interrupted())\n-                return ABNORMAL;\n+            if (pool == null)\n+                pool = p;\n+            if (pool == p && p != null)\n+                q = p.externalQueue();\n@@ -487,0 +416,2 @@\n+        if (interruptible && Thread.interrupted())\n+            return ABNORMAL;\n@@ -496,7 +427,12 @@\n-        ForkJoinPool uncompensate = null;\n-        if (q != null && p != null) {            \/\/ try helping\n-            if ((!timed || p.isSaturated()) &&\n-                ((this instanceof CountedCompleter) ?\n-                 (s = p.helpComplete(this, q, internal)) < 0 :\n-                 (q.tryRemove(this, internal) && (s = doExec()) < 0)))\n-                return s;\n+        boolean uncompensate = false;\n+        if (q != null && p != null) {  \/\/ try helping\n+            \/\/ help even in timed mode if pool has no parallelism\n+            boolean canHelp = !timed || (p.mode & SMASK) == 0;\n+            if (canHelp) {\n+                if ((this instanceof CountedCompleter) &&\n+                    (s = p.helpComplete(this, q, internal)) < 0)\n+                    return s;\n+                if (!ran && ((!internal && q.externalTryUnpush(this)) ||\n+                             q.tryRemove(this, internal)) && (s = doExec()) < 0)\n+                    return s;\n+            }\n@@ -504,1 +440,1 @@\n-                if ((s = p.helpJoin(this, q)) < 0)\n+                if ((s = p.helpJoin(this, q, canHelp)) < 0)\n@@ -507,2 +443,1 @@\n-                    uncompensate = p;\n-                interruptible = false;\n+                    uncompensate = true;\n@@ -511,1 +446,69 @@\n-        return awaitDone(interruptible, deadline, uncompensate);\n+        \/\/ block until done or cancelled wait\n+        boolean interrupted = false, queued = false;\n+        boolean parked = false, fail = false;\n+        Aux node = null;\n+        while ((s = status) >= 0) {\n+            Aux a; long ns;\n+            if (fail || (fail = (pool != null && pool.mode < 0)))\n+                casStatus(s, s | (DONE | ABNORMAL)); \/\/ try to cancel\n+            else if (parked && Thread.interrupted()) {\n+                if (interruptible) {\n+                    s = ABNORMAL;\n+                    break;\n+                }\n+                interrupted = true;\n+            }\n+            else if (queued) {\n+                if (deadline != 0L) {\n+                    if ((ns = deadline - System.nanoTime()) <= 0L)\n+                        break;\n+                    LockSupport.parkNanos(ns);\n+                }\n+                else\n+                    LockSupport.park();\n+                parked = true;\n+            }\n+            else if (node != null) {\n+                if ((a = aux) != null && a.ex != null)\n+                    Thread.onSpinWait();     \/\/ exception in progress\n+                else if (queued = casAux(node.next = a, node))\n+                    LockSupport.setCurrentBlocker(this);\n+            }\n+            else {\n+                try {\n+                    node = new Aux(Thread.currentThread(), null);\n+                } catch (Throwable ex) {     \/\/ cannot create\n+                    fail = true;\n+                }\n+            }\n+        }\n+        if (pool != null && uncompensate)\n+            pool.uncompensate();\n+\n+        if (queued) {\n+            LockSupport.setCurrentBlocker(null);\n+            if (s >= 0) { \/\/ cancellation similar to AbstractQueuedSynchronizer\n+                outer: for (Aux a; (a = aux) != null && a.ex == null; ) {\n+                    for (Aux trail = null;;) {\n+                        Aux next = a.next;\n+                        if (a == node) {\n+                            if (trail != null)\n+                                trail.casNext(trail, next);\n+                            else if (casAux(a, next))\n+                                break outer; \/\/ cannot be re-encountered\n+                            break;           \/\/ restart\n+                        } else {\n+                            trail = a;\n+                            if ((a = next) == null)\n+                                break outer;\n+                        }\n+                    }\n+                }\n+            }\n+            else {\n+                signalWaiters();             \/\/ help clean or signal\n+                if (interrupted)\n+                    Thread.currentThread().interrupt();\n+            }\n+        }\n+        return s;\n@@ -667,1 +670,1 @@\n-            s = awaitJoin(false, false, false, 0L);\n+            s = awaitDone(null, false, false, false, 0L);\n@@ -684,1 +687,1 @@\n-            s = awaitJoin(true, false, false, 0L);\n+            s = awaitDone(null, true, false, false, 0L);\n@@ -713,1 +716,1 @@\n-            s1 = t1.awaitJoin(true, false, false, 0L);\n+            s1 = t1.awaitDone(null, true, false, false, 0L);\n@@ -718,1 +721,1 @@\n-        else if (((s2 = t2.awaitJoin(false, false, false, 0L)) & ABNORMAL) != 0)\n+        else if (((s2 = t2.awaitDone(null, false, false, false, 0L)) & ABNORMAL) != 0)\n@@ -749,1 +752,1 @@\n-                    s = t.awaitJoin(true, false, false, 0L);\n+                    s = t.awaitDone(null, true, false, false, 0L);\n@@ -762,1 +765,1 @@\n-                        s = t.awaitJoin(false, false, false, 0L);\n+                        s = t.awaitDone(null, false, false, false, 0L);\n@@ -812,1 +815,1 @@\n-                    s = t.awaitJoin(true, false, false, 0L);\n+                    s = t.awaitDone(null, true, false, false, 0L);\n@@ -825,1 +828,1 @@\n-                        s = t.awaitJoin(false, false, false, 0L);\n+                        s = t.awaitDone(null, false, false, false, 0L);\n@@ -976,2 +979,2 @@\n-        int s;\n-        if (((s = awaitJoin(false, true, false, 0L)) & ABNORMAL) != 0)\n+        int s = awaitDone(null, false, true, false, 0L);\n+        if ((s & ABNORMAL) != 0)\n@@ -998,3 +1001,3 @@\n-        int s;\n-        if ((s = awaitJoin(false, true, true, unit.toNanos(timeout))) >= 0 ||\n-            (s & ABNORMAL) != 0)\n+        long nanos = unit.toNanos(timeout);\n+        int s = awaitDone(null, false, true, true, nanos);\n+        if (s >= 0 || (s & ABNORMAL) != 0)\n@@ -1013,1 +1016,1 @@\n-            awaitJoin(false, false, false, 0L);\n+            awaitDone(null, false, false, false, 0L);\n@@ -1016,0 +1019,1 @@\n+\n@@ -1023,1 +1027,31 @@\n-            awaitJoin(true, false, false, 0L);\n+            awaitDone(null, true, false, false, 0L);\n+    }\n+\n+    \/\/ Versions of join\/get for pool.invoke* methods that use external,\n+    \/\/ possibly-non-commonPool submits\n+\n+    final void awaitPoolInvoke(ForkJoinPool pool) {\n+        awaitDone(pool, false, false, false, 0L);\n+    }\n+    final void awaitPoolInvoke(ForkJoinPool pool, long nanos) {\n+        awaitDone(pool, false, true, true, nanos);\n+    }\n+    final V joinForPoolInvoke(ForkJoinPool pool) {\n+        int s = awaitDone(pool, false, false, false, 0L);\n+        if ((s & ABNORMAL) != 0)\n+            reportException(s);\n+        return getRawResult();\n+    }\n+    final V getForPoolInvoke(ForkJoinPool pool)\n+        throws InterruptedException, ExecutionException {\n+        int s = awaitDone(pool, false, true, false, 0L);\n+        if ((s & ABNORMAL) != 0)\n+            reportExecutionException(s);\n+        return getRawResult();\n+    }\n+    final V getForPoolInvoke(ForkJoinPool pool, long nanos)\n+        throws InterruptedException, ExecutionException, TimeoutException {\n+        int s = awaitDone(pool, false, true, true, nanos);\n+        if (s >= 0 || (s & ABNORMAL) != 0)\n+            reportExecutionException(s);\n+        return getRawResult();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinTask.java","additions":149,"deletions":115,"binary":false,"changes":264,"status":"modified"}]}