{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,4 +33,3 @@\n-template <class Slot>\n-G1CardSetAllocator<Slot>::G1CardSetAllocator(const char* name,\n-                                             const G1CardSetAllocOptions* alloc_options,\n-                                             G1CardSetFreeList* free_segment_list) :\n+G1CardSetAllocator::G1CardSetAllocator(const char* name,\n+                                       const G1CardSetAllocOptions* alloc_options,\n+                                       G1CardSetFreeList* free_segment_list) :\n@@ -44,2 +43,1 @@\n-template <class Slot>\n-G1CardSetAllocator<Slot>::~G1CardSetAllocator() {\n+G1CardSetAllocator::~G1CardSetAllocator() {\n@@ -49,2 +47,1 @@\n-template <class Slot>\n-void G1CardSetAllocator<Slot>::free(Slot* slot) {\n+void G1CardSetAllocator::free(void* slot) {\n@@ -52,1 +49,0 @@\n-  slot->~Slot();\n@@ -56,2 +52,1 @@\n-template <class Slot>\n-void G1CardSetAllocator<Slot>::drop_all() {\n+void G1CardSetAllocator::drop_all() {\n@@ -62,2 +57,18 @@\n-template <class Slot>\n-void G1CardSetAllocator<Slot>::print(outputStream* os) {\n+size_t G1CardSetAllocator::mem_size() const {\n+  return sizeof(*this) +\n+         _segmented_array.num_segments() * sizeof(G1CardSetSegment) +\n+         _segmented_array.num_available_slots() * _segmented_array.slot_size();\n+}\n+\n+size_t G1CardSetAllocator::wasted_mem_size() const {\n+  uint num_wasted_slots = _segmented_array.num_available_slots() -\n+                          _segmented_array.num_allocated_slots() -\n+                          (uint)_free_slots_list.pending_count();\n+  return num_wasted_slots * _segmented_array.slot_size();\n+}\n+\n+uint G1CardSetAllocator::num_segments() const {\n+  return _segmented_array.num_segments();\n+}\n+\n+void G1CardSetAllocator::print(outputStream* os) {\n@@ -85,1 +96,1 @@\n-  _allocators = NEW_C_HEAP_ARRAY(G1CardSetAllocator<G1CardSetContainer>,\n+  _allocators = NEW_C_HEAP_ARRAY(G1CardSetAllocator,\n@@ -89,3 +100,3 @@\n-    new (&_allocators[i]) G1CardSetAllocator<G1CardSetContainer>(_config->mem_object_type_name_str(i),\n-                                                                 _config->mem_object_alloc_options(i),\n-                                                                 free_list_pool->free_list(i));\n+    new (&_allocators[i]) G1CardSetAllocator(_config->mem_object_type_name_str(i),\n+                                             _config->mem_object_alloc_options(i),\n+                                             free_list_pool->free_list(i));\n@@ -109,1 +120,1 @@\n-  _allocators[type].free((G1CardSetContainer*)value);\n+  _allocators[type].free(value);\n@@ -130,3 +141,2 @@\n-  return sizeof(*this) -\n-    (sizeof(G1CardSetAllocator<G1CardSetContainer>) * num_mem_object_types()) +\n-    result;\n+  return sizeof(*this) + result -\n+    (sizeof(G1CardSetAllocator) * num_mem_object_types());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.cpp","additions":32,"deletions":22,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-\/\/ Arena-like allocator for (card set) heap memory objects (Slot slots).\n+\/\/ Arena-like allocator for (card set) heap memory objects.\n@@ -67,21 +67,2 @@\n-\/\/ Allocation and deallocation in the first phase on G1CardSetContainer basis\n-\/\/ may occur by multiple threads at once.\n-\/\/\n-\/\/ Allocation occurs from an internal free list of G1CardSetContainers first,\n-\/\/ only then trying to bump-allocate from the current G1CardSetSegment. If there is\n-\/\/ none, this class allocates a new G1CardSetSegment (allocated from the C heap,\n-\/\/ asking the G1CardSetAllocOptions instance about sizes etc) and uses that one.\n-\/\/\n-\/\/ The SegmentStack free list is a linked list of G1CardSetContainers\n-\/\/ within all G1CardSetSegment instances allocated so far. It uses a separate\n-\/\/ pending list and global synchronization to avoid the ABA problem when the\n-\/\/ user frees a memory object.\n-\/\/\n-\/\/ The class also manages a few counters for statistics using atomic operations.\n-\/\/ Their values are only consistent within each other with extra global\n-\/\/ synchronization.\n-\/\/\n-\/\/ Since it is expected that every CardSet (and in extension each region) has its\n-\/\/ own set of allocators, there is intentionally no padding between them to save\n-\/\/ memory.\n-template <class Slot>\n+\/\/ Allocation occurs from an internal free list of objects first. If the free list is\n+\/\/ empty then tries to allocate from the G1SegmentedArray.\n@@ -89,7 +70,1 @@\n-  \/\/ G1CardSetSegment management.\n-\n-  typedef G1SegmentedArray<Slot, mtGCCardSet> SegmentedArray;\n-  \/\/ G1CardSetContainer slot management within the G1CardSetSegments allocated\n-  \/\/ by this allocator.\n-\n-  SegmentedArray _segmented_array;\n+  G1SegmentedArray<mtGCCardSet> _segmented_array;\n@@ -104,2 +79,2 @@\n-  Slot* allocate();\n-  void free(Slot* slot);\n+  void* allocate();\n+  void free(void* slot);\n@@ -111,5 +86,1 @@\n-  size_t mem_size() const {\n-    return sizeof(*this) +\n-      _segmented_array.num_segments() * sizeof(G1CardSetSegment) +\n-      _segmented_array.num_available_slots() * _segmented_array.slot_size();\n-  }\n+  size_t mem_size() const;\n@@ -117,6 +88,1 @@\n-  size_t wasted_mem_size() const {\n-    uint num_wasted_slots = _segmented_array.num_available_slots() -\n-                            _segmented_array.num_allocated_slots() -\n-                            (uint)_free_slots_list.pending_count();\n-    return num_wasted_slots * _segmented_array.slot_size();\n-  }\n+  size_t wasted_mem_size() const;\n@@ -124,1 +90,1 @@\n-  inline uint num_segments() { return _segmented_array.num_segments(); }\n+  uint num_segments() const;\n@@ -134,1 +100,1 @@\n-  G1CardSetAllocator<G1CardSetContainer>* _allocators;\n+  G1CardSetAllocator* _allocators;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.hpp","additions":11,"deletions":45,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,4 +29,0 @@\n-#include \"gc\/g1\/g1CardSetContainers.hpp\"\n-#include \"gc\/g1\/g1SegmentedArray.inline.hpp\"\n-#include \"utilities\/ostream.hpp\"\n-\n@@ -34,0 +30,1 @@\n+#include \"gc\/g1\/g1SegmentedArray.inline.hpp\"\n@@ -35,0 +32,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -36,3 +34,2 @@\n-template <class Slot>\n-Slot* G1CardSetAllocator<Slot>::allocate() {\n-  Slot* slot = ::new (_free_slots_list.allocate()) Slot();\n+inline void* G1CardSetAllocator::allocate() {\n+  void* slot = _free_slots_list.allocate();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.inline.hpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-template <class Slot, MEMFLAGS flag>\n+template <MEMFLAGS flag>\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArray.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,2 +118,2 @@\n-template <class Slot, MEMFLAGS flag>\n-G1SegmentedArraySegment<flag>* G1SegmentedArray<Slot, flag>::create_new_segment(G1SegmentedArraySegment<flag>* const prev) {\n+template <MEMFLAGS flag>\n+G1SegmentedArraySegment<flag>* G1SegmentedArray<flag>::create_new_segment(G1SegmentedArraySegment<flag>* const prev) {\n@@ -128,1 +128,1 @@\n-           \"Mismatch %d != %d Slot %zu\", slot_size(), next->slot_size(), sizeof(Slot));\n+           \"Mismatch %d != %d\", slot_size(), next->slot_size());\n@@ -151,2 +151,2 @@\n-template <class Slot, MEMFLAGS flag>\n-uint G1SegmentedArray<Slot, flag>::slot_size() const {\n+template <MEMFLAGS flag>\n+uint G1SegmentedArray<flag>::slot_size() const {\n@@ -156,3 +156,3 @@\n-template <class Slot, MEMFLAGS flag>\n-G1SegmentedArray<Slot, flag>::G1SegmentedArray(const G1SegmentedArrayAllocOptions* alloc_options,\n-                                               G1SegmentedArrayFreeList<flag>* free_segment_list) :\n+template <MEMFLAGS flag>\n+G1SegmentedArray<flag>::G1SegmentedArray(const G1SegmentedArrayAllocOptions* alloc_options,\n+                                         G1SegmentedArrayFreeList<flag>* free_segment_list) :\n@@ -170,2 +170,2 @@\n-template <class Slot, MEMFLAGS flag>\n-G1SegmentedArray<Slot, flag>::~G1SegmentedArray() {\n+template <MEMFLAGS flag>\n+G1SegmentedArray<flag>::~G1SegmentedArray() {\n@@ -175,2 +175,2 @@\n-template <class Slot, MEMFLAGS flag>\n-void G1SegmentedArray<Slot, flag>::drop_all() {\n+template <MEMFLAGS flag>\n+void G1SegmentedArray<flag>::drop_all() {\n@@ -212,2 +212,2 @@\n-template <class Slot, MEMFLAGS flag>\n-void* G1SegmentedArray<Slot, flag>::allocate() {\n+template <MEMFLAGS flag>\n+void* G1SegmentedArray<flag>::allocate() {\n@@ -222,1 +222,1 @@\n-    Slot* slot = (Slot*)cur->get_new_slot();\n+    void* slot = cur->get_new_slot();\n@@ -235,2 +235,2 @@\n-template <class Slot, MEMFLAGS flag>\n-inline uint G1SegmentedArray<Slot, flag>::num_segments() const {\n+template <MEMFLAGS flag>\n+inline uint G1SegmentedArray<flag>::num_segments() const {\n@@ -254,2 +254,2 @@\n-template <class Slot, MEMFLAGS flag>\n-uint G1SegmentedArray<Slot, flag>::calculate_length() const {\n+template <MEMFLAGS flag>\n+uint G1SegmentedArray<flag>::calculate_length() const {\n@@ -262,1 +262,1 @@\n-template <class Slot, MEMFLAGS flag>\n+template <MEMFLAGS flag>\n@@ -264,1 +264,1 @@\n-void G1SegmentedArray<Slot, flag>::iterate_segments(SegmentClosure& closure) const {\n+void G1SegmentedArray<flag>::iterate_segments(SegmentClosure& closure) const {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArray.inline.hpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"}]}