{"files":[{"patch":"@@ -59,0 +59,1 @@\n+typedef JfrCheckpointManager::ConstBufferPtr ConstBufferPtr;\n@@ -80,2 +81,3 @@\n-  _global_mspace(NULL),\n-  _thread_local_mspace(NULL),\n+  _global_mspace(nullptr),\n+  _thread_local_mspace(nullptr),\n+  _virtual_thread_local_mspace(nullptr),\n@@ -94,2 +96,5 @@\n-static const size_t thread_local_buffer_prealloc_count = 32;\n-static const size_t thread_local_buffer_size = 4 * K;\n+static const size_t thread_local_buffer_prealloc_count = 16;\n+static const size_t thread_local_buffer_size = 256;\n+\n+static const size_t virtual_thread_local_buffer_prealloc_count = 0;\n+static const size_t virtual_thread_local_buffer_size = 4 * K;\n@@ -113,1 +118,1 @@\n-                                                                        JFR_MSPACE_UNLIMITED_CACHE_SIZE,\n+                                                                        thread_local_buffer_prealloc_count,\n@@ -117,0 +122,8 @@\n+\n+  assert(_virtual_thread_local_mspace == NULL, \"invariant\");\n+  _virtual_thread_local_mspace = new JfrThreadLocalCheckpointMspace();\n+  if (_virtual_thread_local_mspace == NULL || !_virtual_thread_local_mspace->initialize(virtual_thread_local_buffer_size,\n+                                                                                        JFR_MSPACE_UNLIMITED_CACHE_SIZE,\n+                                                                                        virtual_thread_local_buffer_prealloc_count)) {\n+    return false;\n+  }\n@@ -121,1 +134,1 @@\n-static void assert_lease(const BufferPtr buffer) {\n+static void assert_lease(ConstBufferPtr buffer) {\n@@ -127,1 +140,1 @@\n-static void assert_release(const BufferPtr buffer) {\n+static void assert_release(ConstBufferPtr buffer) {\n@@ -133,1 +146,1 @@\n-static void assert_retired(const BufferPtr buffer, Thread* thread) {\n+static void assert_retired(ConstBufferPtr buffer, Thread* thread) {\n@@ -145,1 +158,16 @@\n-BufferPtr JfrCheckpointManager::lease(Thread* thread, bool previous_epoch \/* false *\/, size_t size \/* 0 *\/) {\n+static inline bool is_global(ConstBufferPtr buffer) {\n+  assert(buffer != NULL, \"invariant\");\n+  return buffer->context() == JFR_GLOBAL;\n+}\n+\n+static inline bool is_thread_local(ConstBufferPtr buffer) {\n+  assert(buffer != NULL, \"invariant\");\n+  return buffer->context() == JFR_THREADLOCAL;\n+}\n+\n+static inline bool is_virtual_thread_local(ConstBufferPtr buffer) {\n+  assert(buffer != NULL, \"invariant\");\n+  return buffer->context() == JFR_VIRTUAL_THREADLOCAL;\n+}\n+\n+BufferPtr JfrCheckpointManager::lease_global(Thread* thread, bool previous_epoch \/* false *\/, size_t size \/* 0 *\/) {\n@@ -163,23 +191,9 @@\n-const u1 thread_local_context = 1;\n-\n-static bool is_thread_local(const JfrBuffer* buffer) {\n-  assert(buffer != NULL, \"invariant\");\n-  return buffer->context() == thread_local_context;\n-}\n-\n-static void retire(JfrBuffer* buffer) {\n-  DEBUG_ONLY(assert_release(buffer);)\n-  buffer->clear_lease();\n-  buffer->set_retired();\n-}\n-\n-\/*\n- * The buffer is effectively invalidated for the thread post-return,\n- * and the caller should take means to ensure that it is not referenced.\n- *\/\n-static void release(JfrBuffer* buffer) {\n-  DEBUG_ONLY(assert_release(buffer);)\n-  if (!is_thread_local(buffer)) {\n-    buffer->clear_lease();\n-    buffer->release();\n-  }\n+BufferPtr JfrCheckpointManager::lease_thread_local(Thread* thread, size_t size) {\n+  BufferPtr buffer = instance()._thread_local_mspace->acquire(size, thread);\n+  assert(buffer != nullptr, \"invariant\");\n+  assert(buffer->free_size() >= size, \"invariant\");\n+  buffer->set_lease();\n+  DEBUG_ONLY(assert_lease(buffer);)\n+  buffer->set_context(JFR_THREADLOCAL);\n+  assert(is_thread_local(buffer), \"invariant\");\n+  return buffer;\n@@ -188,1 +202,1 @@\n-BufferPtr JfrCheckpointManager::get_thread_local(Thread* thread) {\n+BufferPtr JfrCheckpointManager::get_virtual_thread_local(Thread* thread) {\n@@ -194,1 +208,1 @@\n-void JfrCheckpointManager::set_thread_local(Thread* thread, BufferPtr buffer) {\n+void JfrCheckpointManager::set_virtual_thread_local(Thread* thread, BufferPtr buffer) {\n@@ -203,4 +217,3 @@\n-BufferPtr JfrCheckpointManager::acquire_thread_local(size_t size, Thread* thread) {\n-  assert(thread != NULL, \"invariant\");\n-  JfrBuffer* const buffer = instance()._thread_local_mspace->acquire(size, thread);\n-  assert(buffer != NULL, \"invariant\");\n+BufferPtr JfrCheckpointManager::new_virtual_thread_local(Thread* thread, size_t size) {\n+  BufferPtr buffer = instance()._virtual_thread_local_mspace->acquire(size, thread);\n+  assert(buffer != nullptr, \"invariant\");\n@@ -208,4 +221,3 @@\n-  buffer->set_context(thread_local_context);\n-  assert(is_thread_local(buffer), \"invariant\");\n-  buffer->set_lease();\n-  set_thread_local(thread, buffer);\n+  buffer->set_context(JFR_VIRTUAL_THREADLOCAL);\n+  assert(is_virtual_thread_local(buffer), \"invariant\");\n+  set_virtual_thread_local(thread, buffer);\n@@ -215,7 +227,4 @@\n-BufferPtr JfrCheckpointManager::lease_thread_local(Thread* thread, size_t size \/* 0 *\/) {\n-  JfrBuffer* buffer = get_thread_local(thread);\n-  if (buffer == NULL) {\n-    buffer = acquire_thread_local(size, thread);\n-  } else if (buffer->free_size() < size) {\n-    retire(buffer);\n-    buffer = acquire_thread_local(size, thread);\n+BufferPtr JfrCheckpointManager::acquire_virtual_thread_local(Thread* thread, size_t size \/* 0 *\/) {\n+  BufferPtr buffer = get_virtual_thread_local(thread);\n+  if (buffer == nullptr || buffer->free_size() < size) {\n+    buffer = new_virtual_thread_local(thread, size);\n@@ -223,1 +232,1 @@\n-  DEBUG_ONLY(assert_lease(buffer);)\n+  assert(buffer->acquired_by_self(), \"invariant\");\n@@ -225,1 +234,2 @@\n-  assert(get_thread_local(thread) == buffer, \"invariant\");\n+  assert(get_virtual_thread_local(thread) == buffer, \"invariant\");\n+  assert(is_virtual_thread_local(buffer), \"invariant\");\n@@ -229,1 +239,1 @@\n-BufferPtr JfrCheckpointManager::lease(BufferPtr old, Thread* thread, size_t size) {\n+BufferPtr JfrCheckpointManager::renew(ConstBufferPtr old, Thread* thread, size_t size, JfrCheckpointBufferKind kind \/* JFR_THREADLOCAL *\/) {\n@@ -231,2 +241,42 @@\n-  return is_thread_local(old) ? acquire_thread_local(size, thread) :\n-                                lease(thread, instance()._global_mspace->in_previous_epoch_list(old), size);\n+  assert(old->acquired_by_self(), \"invariant\");\n+  if (kind == JFR_GLOBAL) {\n+    return lease_global(thread, instance()._global_mspace->in_previous_epoch_list(old), size);\n+  }\n+  return kind == JFR_THREADLOCAL ? lease_thread_local(thread, size) : acquire_virtual_thread_local(thread, size);\n+}\n+\n+BufferPtr JfrCheckpointManager::acquire(Thread* thread, JfrCheckpointBufferKind kind \/* JFR_THREADLOCAL *\/, bool previous_epoch \/* false *\/, size_t size \/* 0 *\/) {\n+  if (kind == JFR_GLOBAL) {\n+    return lease_global(thread, previous_epoch, size);\n+  }\n+  if (kind == JFR_THREADLOCAL) {\n+    return lease_thread_local(thread, size);\n+  }\n+  assert(kind == JFR_VIRTUAL_THREADLOCAL, \"invariant\");\n+  return acquire_virtual_thread_local(thread, size);\n+}\n+\n+static inline void retire(BufferPtr buffer) {\n+  assert(buffer != nullptr, \"invariant\");\n+  assert(buffer->acquired_by_self(), \"invariant\");\n+  buffer->set_retired();\n+}\n+\n+\/*\n+ * The buffer is effectively invalidated for the thread post-return,\n+ * and the caller should take means to ensure that it is not referenced.\n+ *\/\n+static inline void release(BufferPtr buffer) {\n+  DEBUG_ONLY(assert_release(buffer);)\n+  assert(!is_virtual_thread_local(buffer), \"invariant\");\n+  if (is_global(buffer)) {\n+    buffer->release();\n+    return;\n+  }\n+  assert(is_thread_local(buffer), \"invariant\");\n+  retire(buffer);\n+}\n+\n+static inline JfrCheckpointBufferKind kind(ConstBufferPtr buffer) {\n+  assert(buffer != nullptr, \"invariant\");\n+  return static_cast<JfrCheckpointBufferKind>(buffer->context());\n@@ -237,1 +287,0 @@\n-  assert(old->lease(), \"invariant\");\n@@ -240,0 +289,1 @@\n+    assert(old->lease(), \"invariant\");\n@@ -245,1 +295,1 @@\n-  BufferPtr new_buffer = lease(old, thread, used + requested);\n+  BufferPtr new_buffer = renew(old, thread, used + requested, kind(old));\n@@ -375,1 +425,1 @@\n-class ThreadLocalCheckpointWriteOp {\n+class VirtualThreadLocalCheckpointWriteOp {\n@@ -384,1 +434,1 @@\n-  ThreadLocalCheckpointWriteOp(JfrChunkWriter& cw) : _cw(cw), _begin_offset(cw.current_offset()), _elements_offset(0), _processed(0), _elements(0) {\n+  VirtualThreadLocalCheckpointWriteOp(JfrChunkWriter& cw) : _cw(cw), _begin_offset(cw.current_offset()), _elements_offset(0), _processed(0), _elements(0) {\n@@ -399,1 +449,1 @@\n-  ~ThreadLocalCheckpointWriteOp() {\n+  ~VirtualThreadLocalCheckpointWriteOp() {\n@@ -420,2 +470,1 @@\n-typedef ThreadLocalCheckpointWriteOp<JfrCheckpointManager::Buffer> ThreadLocalCheckpointOperation;\n-typedef MutexedWriteOp<ThreadLocalCheckpointOperation> ThreadLocalWriteOperation;\n+typedef MutexedWriteOp<WriteOperation> MutexedWriteOperation;\n@@ -423,2 +472,3 @@\n-typedef ExclusiveOp<WriteOperation> GlobalWriteOperation;\n-typedef CompositeOperation<GlobalWriteOperation, ReleaseOperation> GlobalWriteReleaseOperation;\n+typedef CompositeOperation<MutexedWriteOperation, ReleaseOperation> WriteReleaseOperation;\n+typedef VirtualThreadLocalCheckpointWriteOp<JfrCheckpointManager::Buffer> VirtualThreadLocalCheckpointOperation;\n+typedef MutexedWriteOp<VirtualThreadLocalCheckpointOperation> VirtualThreadLocalWriteOperation;\n@@ -441,1 +491,2 @@\n-  GlobalWriteOperation gwo(wo);\n+  MutexedWriteOperation mwo(wo);\n+  _thread_local_mspace->iterate(mwo, true); \/\/ previous epoch list\n@@ -443,8 +494,8 @@\n-  ReleaseOperation ro(_global_mspace, _global_mspace->live_list(true));\n-  GlobalWriteReleaseOperation gwro(&gwo, &ro);\n-  process_live_list(gwro, _global_mspace, true); \/\/ previous epoch list\n-  \/\/ Do thread local list after global. Careful, the tlco destructor writes to chunk.\n-  ThreadLocalCheckpointOperation tlco(_chunkwriter);\n-  ThreadLocalWriteOperation tlwo(tlco);\n-  _thread_local_mspace->iterate(tlwo, true); \/\/ previous epoch list\n-  return wo.processed() + tlco.processed();\n+  ReleaseOperation ro(_global_mspace, _global_mspace->live_list(true)); \/\/ previous epoch list\n+  WriteReleaseOperation wro(&mwo, &ro);\n+  process_live_list(wro, _global_mspace, true); \/\/ previous epoch list\n+  \/\/ Do virtual thread local list last. Careful, the vtlco destructor writes to chunk.\n+  VirtualThreadLocalCheckpointOperation vtlco(_chunkwriter);\n+  VirtualThreadLocalWriteOperation vtlwo(vtlco);\n+  _virtual_thread_local_mspace->iterate(vtlwo, true); \/\/ previous epoch list\n+  return wo.processed() + vtlco.processed();\n@@ -453,3 +504,2 @@\n-typedef DiscardOp<DefaultDiscarder<JfrCheckpointManager::Buffer> > ThreadLocalDiscardOperation;\n-typedef ExclusiveDiscardOp<DefaultDiscarder<JfrCheckpointManager::Buffer> > GlobalDiscardOperation;\n-typedef CompositeOperation<GlobalDiscardOperation, ReleaseOperation> DiscardReleaseOperation;\n+typedef DiscardOp<DefaultDiscarder<JfrCheckpointManager::Buffer> > DiscardOperation;\n+typedef CompositeOperation<DiscardOperation, ReleaseOperation> DiscardReleaseOperation;\n@@ -460,3 +510,3 @@\n-  ThreadLocalDiscardOperation tldo(mutexed); \/\/ mutexed discard mode\n-  _thread_local_mspace->iterate(tldo, true); \/\/ previous epoch list\n-  GlobalDiscardOperation gdo(mutexed); \/\/ mutexed discard mode\n+  DiscardOperation dop(mutexed); \/\/ mutexed discard mode\n+  _thread_local_mspace->iterate(dop, true); \/\/ previous epoch list\n+  _virtual_thread_local_mspace->iterate(dop, true); \/\/ previous epoch list\n@@ -464,1 +514,1 @@\n-  DiscardReleaseOperation dro(&gdo, &ro);\n+  DiscardReleaseOperation dro(&dop, &ro);\n@@ -467,1 +517,1 @@\n-  return tldo.elements() + gdo.elements();\n+  return dop.elements();\n@@ -564,0 +614,3 @@\n+    WriteOperation wo(_chunkwriter);\n+    MutexedWriteOperation mwo(wo);\n+    _thread_local_mspace->iterate(mwo); \/\/ current epoch list\n@@ -566,9 +619,5 @@\n-    WriteOperation wo(_chunkwriter);\n-    GlobalWriteOperation gwo(wo);\n-    ReleaseOperation ro(_global_mspace, _global_mspace->live_list()); \/\/ current epoch list\n-    GlobalWriteReleaseOperation gwro(&gwo, &ro);\n-    process_live_list(gwro, _global_mspace); \/\/ current epoch list\n-    \/\/ Do thread local list after global. Careful, the tlco destructor writes to chunk.\n-    ThreadLocalCheckpointOperation tlco(_chunkwriter);\n-    ThreadLocalWriteOperation tlwo(tlco);\n-    _thread_local_mspace->iterate(tlwo); \/\/ current epoch list\n+    process_live_list(mwo, _global_mspace); \/\/ current epoch list\n+    \/\/ Do virtual thread local list last. Careful, the vtlco destructor writes to chunk.\n+    VirtualThreadLocalCheckpointOperation vtlco(_chunkwriter);\n+    VirtualThreadLocalWriteOperation vtlwo(vtlco);\n+    _virtual_thread_local_mspace->iterate(vtlwo); \/\/ current epoch list\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":138,"deletions":89,"binary":false,"changes":227,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+  typedef const JfrCheckpointMspace::Node* ConstBufferPtr;\n@@ -63,0 +64,1 @@\n+  JfrThreadLocalCheckpointMspace* _virtual_thread_local_mspace;\n@@ -72,3 +74,4 @@\n-  static BufferPtr get_thread_local(Thread* thread);\n-  static void set_thread_local(Thread* thread, BufferPtr buffer);\n-  static BufferPtr acquire_thread_local(size_t size, Thread* thread);\n+  static BufferPtr get_virtual_thread_local(Thread* thread);\n+  static void set_virtual_thread_local(Thread* thread, BufferPtr buffer);\n+  static BufferPtr acquire_virtual_thread_local(Thread* thread, size_t size);\n+  static BufferPtr new_virtual_thread_local(Thread* thread, size_t size = 0);\n@@ -76,2 +79,0 @@\n-  static BufferPtr lease(Thread* thread, bool previous_epoch = false, size_t size = 0);\n-  static BufferPtr lease(BufferPtr old, Thread* thread, size_t size);\n@@ -79,0 +80,1 @@\n+  static BufferPtr lease_global(Thread* thread, bool previous_epoch = false, size_t size = 0);\n@@ -80,0 +82,2 @@\n+  static BufferPtr acquire(Thread* thread, JfrCheckpointBufferKind kind = JFR_THREADLOCAL, bool previous_epoch = false, size_t size = 0);\n+  static BufferPtr renew(ConstBufferPtr old, Thread* thread, size_t size, JfrCheckpointBufferKind kind = JFR_THREADLOCAL);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/thread.inline.hpp\"\n@@ -34,2 +35,2 @@\n-JfrCheckpointWriter::JfrCheckpointWriter(JfrCheckpointType type \/* GENERIC *\/) :\n-  JfrCheckpointWriterBase(JfrCheckpointManager::lease(Thread::current()), Thread::current()),\n+JfrCheckpointWriter::JfrCheckpointWriter(bool header \/* true *\/, JfrCheckpointType type \/* GENERIC *\/, JfrCheckpointBufferKind kind \/* JFR_GLOBAL *\/) :\n+  JfrCheckpointWriterBase(JfrCheckpointManager::acquire(Thread::current(), kind), Thread::current()),\n@@ -40,1 +41,1 @@\n-  _header(true) {\n+  _header(header) {\n@@ -48,2 +49,2 @@\n-JfrCheckpointWriter::JfrCheckpointWriter(Thread* thread, bool header \/* true *\/, JfrCheckpointType type \/* GENERIC *\/, bool global_lease \/* true *\/) :\n-  JfrCheckpointWriterBase(global_lease ? JfrCheckpointManager::lease(thread) : JfrCheckpointManager::lease_thread_local(thread), thread),\n+JfrCheckpointWriter::JfrCheckpointWriter(Thread* thread, bool header \/* true *\/, JfrCheckpointType type \/* GENERIC *\/, JfrCheckpointBufferKind kind \/* JFR_GLOBAL *\/) :\n+  JfrCheckpointWriterBase(JfrCheckpointManager::acquire(thread, kind), thread),\n@@ -63,1 +64,1 @@\n-  JfrCheckpointWriterBase(JfrCheckpointManager::lease(thread, previous_epoch), thread),\n+  JfrCheckpointWriterBase(JfrCheckpointManager::lease_global(thread, previous_epoch), thread),\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointWriter.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -73,3 +73,3 @@\n- public:\n-  JfrCheckpointWriter(JfrCheckpointType type = GENERIC);\n-  JfrCheckpointWriter(Thread* thread, bool header = true, JfrCheckpointType mode = GENERIC, bool global_lease = true);\n+public:\n+  JfrCheckpointWriter(bool header = true, JfrCheckpointType mode = GENERIC, JfrCheckpointBufferKind kind = JFR_GLOBAL);\n+  JfrCheckpointWriter(Thread* thread, bool header = true, JfrCheckpointType mode = GENERIC, JfrCheckpointBufferKind kind = JFR_GLOBAL);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointWriter.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/thread.inline.hpp\"\n@@ -107,1 +108,1 @@\n-  JfrCheckpointWriter writer(jt, true, THREADS, false); \/\/ Thread local lease for blob creation.\n+  JfrCheckpointWriter writer(jt, true, THREADS, JFR_THREADLOCAL); \/\/ Thread local lease for blob creation.\n@@ -122,1 +123,1 @@\n-  JfrCheckpointWriter writer(current, true, THREADS, !is_vthread); \/\/ Virtual Threads use thread local lease.\n+  JfrCheckpointWriter writer(current, true, THREADS, is_vthread ? JFR_VIRTUAL_THREADLOCAL : JFR_THREADLOCAL);\n@@ -205,1 +206,1 @@\n-    JfrCheckpointWriter writer(STATICS);\n+    JfrCheckpointWriter writer(Thread::current(), true, STATICS);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeManager.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-bool JfrBuffer::initialize(size_t header_size, size_t size) {\n+void JfrBuffer::initialize(size_t header_size, size_t size) {\n@@ -51,1 +51,0 @@\n-  return true;\n@@ -54,1 +53,1 @@\n-void JfrBuffer::reinitialize(bool exclusion \/* false *\/) {\n+void JfrBuffer::reinitialize() {\n@@ -176,2 +175,1 @@\n-  LEASE = 4,\n-  EXCLUDED = 8\n+  LEASE = 4\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrBuffer.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -82,2 +82,2 @@\n-  bool initialize(size_t header_size, size_t size);\n-  void reinitialize(bool exclusion = false);\n+  void initialize(size_t header_size, size_t size);\n+  void reinitialize();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrBuffer.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -221,4 +221,1 @@\n-  if (!node->initialize(sizeof(Node), aligned_size_bytes)) {\n-    JfrCHeapObj::free(node, aligned_size_bytes + sizeof(Node));\n-    return NULL;\n-  }\n+  node->initialize(sizeof(Node), aligned_size_bytes);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrMemorySpace.inline.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,0 +60,6 @@\n+enum JfrCheckpointBufferKind {\n+  JFR_GLOBAL,\n+  JFR_THREADLOCAL,\n+  JFR_VIRTUAL_THREADLOCAL\n+};\n+\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrTypes.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}