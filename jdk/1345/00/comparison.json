{"files":[{"patch":"@@ -66,1 +66,1 @@\n-  GrowableArray<ciMetadata *> _dependencies;\n+  GrowableArray<ciMetadata*> _dependencies;\n","filename":"src\/hotspot\/share\/ci\/bcEscapeAnalyzer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-  ciArray(    arrayHandle h_a) : ciObject(h_a), _length(h_a()->length()) {}\n@@ -48,2 +47,0 @@\n-  ciArray(ciKlass* klass, int len) : ciObject(klass), _length(len) {}\n-\n","filename":"src\/hotspot\/share\/ci\/ciArray.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-  ciMethod* _method[MorphismLimit + 1];    \/\/ receivers methods\n@@ -54,1 +53,0 @@\n-    _method[0]   = NULL;\n@@ -74,4 +72,0 @@\n-  ciMethod* method(int i)          {\n-    assert(i < _limit, \"out of Call Profile MorphismLimit\");\n-    return _method[i];\n-  }\n","filename":"src\/hotspot\/share\/ci\/ciCallProfile.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,10 +46,0 @@\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciCallSite::get_target\n-\/\/\n-\/\/ Return the target MethodHandle of this CallSite.\n-ciMethodHandle* ciCallSite::get_target() const {\n-  VM_ENTRY_MARK;\n-  oop method_handle_oop = java_lang_invoke_CallSite::target(get_oop());\n-  return CURRENT_ENV->get_object(method_handle_oop)->as_method_handle();\n-}\n-\n","filename":"src\/hotspot\/share\/ci\/ciCallSite.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -45,3 +45,0 @@\n-  \/\/ Return the target MethodHandle of this CallSite.\n-  ciMethodHandle* get_target() const;\n-\n","filename":"src\/hotspot\/share\/ci\/ciCallSite.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -289,1 +289,0 @@\n-    _dtrace_monitor_probes  = true;\n@@ -293,1 +292,0 @@\n-    _dtrace_monitor_probes  = DTraceMonitorProbes;\n@@ -370,15 +368,0 @@\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciEnv::array_element_offset_in_bytes\n-int ciEnv::array_element_offset_in_bytes(ciArray* a_h, ciObject* o_h) {\n-  VM_ENTRY_MARK;\n-  objArrayOop a = (objArrayOop)a_h->get_oop();\n-  assert(a->is_objArray(), \"\");\n-  int length = a->length();\n-  oop o = o_h->get_oop();\n-  for (int i = 0; i < length; i++) {\n-    if (a->obj_at(i) == o)  return i;\n-  }\n-  return -1;\n-}\n-\n-\n@@ -1130,8 +1113,0 @@\n-\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciEnv::find_system_klass\n-ciKlass* ciEnv::find_system_klass(ciSymbol* klass_name) {\n-  VM_ENTRY_MARK;\n-  return get_klass_by_name_impl(NULL, constantPoolHandle(), klass_name, false);\n-}\n-\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -81,1 +81,0 @@\n-  bool  _dtrace_monitor_probes;\n@@ -358,1 +357,0 @@\n-  bool  dtrace_monitor_probes()  const { return _dtrace_monitor_probes; }\n@@ -422,1 +420,0 @@\n-  ciKlass*  find_system_klass(ciSymbol* klass_name);\n@@ -432,4 +429,0 @@\n-  \/\/ Return the machine-level offset of o, which must be an element of a.\n-  \/\/ This may be used to form constant-loading expressions in lieu of simpler encodings.\n-  int       array_element_offset_in_bytes(ciArray* a, ciObject* o);\n-\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -75,3 +75,0 @@\n-  bool      catches(ciInstanceKlass *exc) {\n-    return is_catch_all() || exc->is_subtype_of(catch_klass());\n-  }\n","filename":"src\/hotspot\/share\/ci\/ciExceptionHandler.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,2 +48,0 @@\n-  instanceOop get_instanceOop() { return (instanceOop)get_oop(); }\n-\n@@ -64,1 +62,0 @@\n-  bool is_java_object()  { return true; }\n","filename":"src\/hotspot\/share\/ci\/ciInstance.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -125,10 +125,0 @@\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciKlass::can_be_primary_super\n-bool ciKlass::can_be_primary_super() {\n-  assert(is_loaded(), \"must be loaded\");\n-\n-  VM_ENTRY_MARK;\n-  Klass* this_klass = get_Klass();\n-  return this_klass->can_be_primary_super();\n-}\n-\n","filename":"src\/hotspot\/share\/ci\/ciKlass.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -89,1 +89,0 @@\n-  bool can_be_primary_super();\n","filename":"src\/hotspot\/share\/ci\/ciKlass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -261,9 +261,0 @@\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciMethod::compressed_linenumber_table\n-u_char* ciMethod::compressed_linenumber_table() const {\n-  check_is_loaded();\n-  VM_ENTRY_MARK;\n-  return get_Method()->compressed_linenumber_table();\n-}\n-\n-\n@@ -290,28 +281,0 @@\n-\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciMethod::native_entry\n-\/\/\n-\/\/ Get the address of this method's native code, if any.\n-address ciMethod::native_entry() {\n-  check_is_loaded();\n-  assert(flags().is_native(), \"must be native method\");\n-  VM_ENTRY_MARK;\n-  Method* method = get_Method();\n-  address entry = method->native_function();\n-  assert(entry != NULL, \"must be valid entry point\");\n-  return entry;\n-}\n-\n-\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciMethod::interpreter_entry\n-\/\/\n-\/\/ Get the entry point for running this method in the interpreter.\n-address ciMethod::interpreter_entry() {\n-  check_is_loaded();\n-  VM_ENTRY_MARK;\n-  methodHandle mh(THREAD, get_Method());\n-  return Interpreter::entry_for_method(mh);\n-}\n-\n-\n@@ -879,13 +842,0 @@\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciMethod::interpreter_call_site_count\n-int ciMethod::interpreter_call_site_count(int bci) {\n-  if (method_data() != NULL) {\n-    ResourceMark rm;\n-    ciProfileData* data = method_data()->bci_to_data(bci);\n-    if (data != NULL && data->is_CounterData()) {\n-      return scale_count(data->as_CounterData()->count());\n-    }\n-  }\n-  return -1;  \/\/ unknown\n-}\n-\n@@ -1125,31 +1075,0 @@\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciMethod::set_not_compilable\n-\/\/\n-\/\/ Tell the VM that this method cannot be compiled at all.\n-void ciMethod::set_not_compilable(const char* reason) {\n-  check_is_loaded();\n-  VM_ENTRY_MARK;\n-  ciEnv* env = CURRENT_ENV;\n-  if (is_c1_compile(env->comp_level())) {\n-    _is_c1_compilable = false;\n-  } else {\n-    _is_c2_compilable = false;\n-  }\n-  get_Method()->set_not_compilable(reason, env->comp_level());\n-}\n-\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciMethod::can_be_osr_compiled\n-\/\/\n-\/\/ Have previous compilations of this method succeeded?\n-\/\/\n-\/\/ Implementation note: the VM does not currently keep track\n-\/\/ of failed OSR compilations per bci.  The entry_bci parameter\n-\/\/ is currently unused.\n-bool ciMethod::can_be_osr_compiled(int entry_bci) {\n-  check_is_loaded();\n-  VM_ENTRY_MARK;\n-  ciEnv* env = CURRENT_ENV;\n-  return !get_Method()->is_not_osr_compilable(env->comp_level());\n-}\n-\n@@ -1162,8 +1081,0 @@\n-int ciMethod::comp_level() {\n-  check_is_loaded();\n-  VM_ENTRY_MARK;\n-  CompiledMethod* nm = get_Method()->code();\n-  if (nm != NULL) return nm->comp_level();\n-  return 0;\n-}\n-\n@@ -1309,2 +1220,0 @@\n-bool ciMethod::is_empty_method() const {         FETCH_FLAG_FROM_VM(is_empty_method); }\n-bool ciMethod::is_vanilla_constructor() const {  FETCH_FLAG_FROM_VM(is_vanilla_constructor); }\n@@ -1319,1 +1228,1 @@\n-  if (holder()->is_box_klass()) {\n+  if (intrinsic_id() != vmIntrinsics::_none && holder()->is_box_klass()) {\n@@ -1338,1 +1247,1 @@\n-  if (holder()->is_box_klass()) {\n+  if (intrinsic_id() != vmIntrinsics::_none && holder()->is_box_klass()) {\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":2,"deletions":93,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -204,1 +204,0 @@\n-  int comp_level();\n@@ -219,1 +218,0 @@\n-  u_char* compressed_linenumber_table() const;   \/\/ not preserved by gc\n@@ -225,2 +223,0 @@\n-  address       native_entry();\n-  address       interpreter_entry();\n@@ -261,1 +257,0 @@\n-  int           interpreter_call_site_count(int bci);\n@@ -305,2 +300,0 @@\n-  bool can_be_osr_compiled(int entry_bci);\n-  void set_not_compilable(const char* reason = NULL);\n@@ -343,2 +336,0 @@\n-  bool is_empty_method() const;\n-  bool is_vanilla_constructor() const;\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-typedef short ciBlockIndex;\n-\n","filename":"src\/hotspot\/share\/ci\/ciMethodBlocks.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,2 +42,0 @@\n-  ciObjArray(ciKlass* klass, int len) : ciArray(klass, len) {}\n-\n","filename":"src\/hotspot\/share\/ci\/ciObjArray.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -146,2 +146,0 @@\n-  bool has_optional_appendix() { return Bytecodes::has_optional_appendix(cur_bc_raw()); }\n-\n","filename":"src\/hotspot\/share\/ci\/ciStreams.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-\/\/\n-\/\/ Preallocated symbol variant.  Used with symbols from vmSymbols.\n@@ -41,10 +39,1 @@\n-  assert(sid_ok(), \"must be in vmSymbols\");\n-}\n-\n-\/\/ Normal case for non-famous symbols.\n-ciSymbol::ciSymbol(Symbol* s)\n-  : _symbol(s), _sid(vmSymbolID::NO_SID)\n-{\n-  assert(_symbol != NULL, \"adding null symbol\");\n-  _symbol->increment_refcount();  \/\/ increment ref count\n-  assert(sid_ok(), \"must not be in vmSymbols\");\n+  assert(sid_ok(), \"sid must be consistent with vmSymbols\");\n","filename":"src\/hotspot\/share\/ci\/ciSymbol.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -55,2 +55,1 @@\n-  ciSymbol(Symbol* s);  \/\/ normal case, for symbols not mentioned in vmSymbols\n-  ciSymbol(Symbol* s, vmSymbolID sid);   \/\/ for use with vmSymbols\n+  ciSymbol(Symbol* s, vmSymbolID sid = vmSymbolID::NO_SID);\n","filename":"src\/hotspot\/share\/ci\/ciSymbol.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -104,14 +104,0 @@\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciType::box_klass\n-\/\/\n-ciKlass* ciType::box_klass() {\n-  if (!is_primitive_type())  return this->as_klass();  \/\/ reference types are \"self boxing\"\n-\n-  \/\/ Void is \"boxed\" with a null.\n-  if (basic_type() == T_VOID)  return NULL;\n-\n-  VM_ENTRY_MARK;\n-  return CURRENT_THREAD_ENV->get_instance_klass(SystemDictionary::box_klass(basic_type()));\n-}\n-\n-\n","filename":"src\/hotspot\/share\/ci\/ciType.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -63,6 +63,0 @@\n-  \/\/ Get the class which \"boxes\" (or \"wraps\") values of this type.\n-  \/\/ Example:  short is boxed by java.lang.Short, etc.\n-  \/\/ Returns self if it is a reference type.\n-  \/\/ Returns NULL for void, since null is used in such cases.\n-  ciKlass*  box_klass();\n-\n","filename":"src\/hotspot\/share\/ci\/ciType.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,2 +42,0 @@\n-  ciTypeArray(ciKlass* klass, int len) : ciArray(klass, len) {}\n-\n","filename":"src\/hotspot\/share\/ci\/ciTypeArray.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}