{"files":[{"patch":"@@ -1045,1 +1045,1 @@\n-    if (!cl->range_checks_present() && (LoopMaxUnroll > _local_loop_unroll_factor)) {\n+    if (!range_checks_present() && (LoopMaxUnroll > _local_loop_unroll_factor)) {\n@@ -1919,1 +1919,1 @@\n-  if (!cl->is_main_loop() || cl->range_checks_present()) return;\n+  if (!cl->is_main_loop() || loop->range_checks_present()) return;\n@@ -3006,1 +3006,1 @@\n-int PhaseIdealLoop::do_range_check(IdealLoopTree *loop, Node_List &old_new) {\n+void PhaseIdealLoop::do_range_check(IdealLoopTree *loop, Node_List &old_new) {\n@@ -3019,2 +3019,0 @@\n-  \/\/ If we fail before trying to eliminate range checks, set multiversion state\n-  int closed_range_checks = 1;\n@@ -3024,1 +3022,1 @@\n-    return closed_range_checks;\n+    return;\n@@ -3036,1 +3034,1 @@\n-    return closed_range_checks;\n+    return;\n@@ -3050,1 +3048,1 @@\n-    return closed_range_checks;\n+    return;\n@@ -3059,1 +3057,1 @@\n-    return closed_range_checks;\n+    return;\n@@ -3071,1 +3069,1 @@\n-    return closed_range_checks;\n+    return;\n@@ -3084,4 +3082,0 @@\n-  \/\/ Count number of range checks and reduce by load range limits, if zero,\n-  \/\/ the loop is in canonical form to multiversion.\n-  closed_range_checks = 0;\n-\n@@ -3098,1 +3092,0 @@\n-      closed_range_checks++;\n@@ -3267,3 +3260,0 @@\n-      if (int_limit->Opcode() == Op_LoadRange) {\n-        closed_range_checks--;\n-      }\n@@ -3319,1 +3309,1 @@\n-  return closed_range_checks;\n+  return;\n@@ -3322,16 +3312,4 @@\n-\/\/------------------------------has_range_checks-------------------------------\n-\/\/ Check to see if RCE cleaned the current loop of range-checks.\n-void PhaseIdealLoop::has_range_checks(IdealLoopTree *loop) {\n-  assert(RangeCheckElimination, \"\");\n-\n-  \/\/ skip if not a counted loop\n-  if (!loop->is_counted()) return;\n-\n-  CountedLoopNode *cl = loop->_head->as_CountedLoop();\n-\n-  \/\/ skip this loop if it is already checked\n-  if (cl->has_been_range_checked()) return;\n-\n-  \/\/ Now check for existence of range checks\n-  for (uint i = 0; i < loop->_body.size(); i++) {\n-    Node *iff = loop->_body[i];\n+bool IdealLoopTree::compute_has_range_checks() const {\n+  assert(_head->is_CountedLoop(), \"\");\n+  for (uint i = 0; i < _body.size(); i++) {\n+    Node *iff = _body[i];\n@@ -3340,2 +3318,1 @@\n-      cl->mark_has_range_checks();\n-      break;\n+      return true;\n@@ -3344,1 +3321,1 @@\n-  cl->set_has_been_range_checked();\n+  return false;\n@@ -4010,7 +3987,1 @@\n-      if (phase->do_range_check(this, old_new) != 0) {\n-        cl->mark_has_range_checks();\n-      } else {\n-        cl->clear_has_range_checks();\n-      }\n-    } else if (PostLoopMultiversioning) {\n-      phase->has_range_checks(this);\n+      phase->do_range_check(this, old_new);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":16,"deletions":45,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -3945,1 +3945,1 @@\n-void IdealLoopTree::dump_head() const {\n+void IdealLoopTree::dump_head() {\n@@ -3993,1 +3993,1 @@\n-    if (cl->range_checks_present()) tty->print(\" rc \");\n+    if (range_checks_present()) tty->print(\" rc \");\n@@ -4016,1 +4016,1 @@\n-void IdealLoopTree::dump() const {\n+void IdealLoopTree::dump() {\n@@ -4603,2 +4603,1 @@\n-              has_range_checks(lpt_next);\n-              if (cl->is_post_loop() && cl->range_checks_present()) {\n+              if (cl->is_post_loop() && lpt_next->range_checks_present()) {\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -75,7 +75,6 @@\n-         HasRangeChecks      = 1<<13,\n-         IsMultiversioned    = 1<<14,\n-         StripMined          = 1<<15,\n-         SubwordLoop         = 1<<16,\n-         ProfileTripFailed   = 1<<17,\n-         LoopNestInnerLoop = 1 << 18,\n-         LoopNestLongOuterLoop = 1 << 19};\n+         IsMultiversioned    = 1<<13,\n+         StripMined          = 1<<14,\n+         SubwordLoop         = 1<<15,\n+         ProfileTripFailed   = 1<<16,\n+         LoopNestInnerLoop = 1 << 17,\n+         LoopNestLongOuterLoop = 1 << 18};\n@@ -85,1 +84,1 @@\n-  enum { LoopNotRCEChecked = 0, LoopRCEChecked = 1, RCEPostLoop = 2 };\n+  enum { RCEPostLoop = 1 };\n@@ -97,1 +96,0 @@\n-  bool range_checks_present() const { return _loop_flags & HasRangeChecks; }\n@@ -116,2 +114,0 @@\n-  void mark_has_range_checks() { _loop_flags |=  HasRangeChecks; }\n-  void clear_has_range_checks() { _loop_flags &= ~HasRangeChecks; }\n@@ -129,2 +125,0 @@\n-  int has_been_range_checked() const { return _postloop_flags & LoopRCEChecked; }\n-  void set_has_been_range_checked() { _postloop_flags |= LoopRCEChecked; }\n@@ -624,1 +618,3 @@\n-          _rce_candidate:1;     \/\/ True if candidate for range check elimination\n+          _rce_candidate:1,     \/\/ True if candidate for range check elimination\n+          _has_range_checks:1,\n+          _has_range_checks_computed:1;\n@@ -636,0 +632,1 @@\n+      _has_range_checks(0), _has_range_checks_computed(0),\n@@ -783,0 +780,11 @@\n+  bool compute_has_range_checks() const;\n+  bool range_checks_present() {\n+    if (!_has_range_checks_computed) {\n+      if (compute_has_range_checks()) {\n+        _has_range_checks = 1;\n+      }\n+      _has_range_checks_computed = 1;\n+    }\n+    return _has_range_checks;\n+  }\n+\n@@ -784,2 +792,2 @@\n-  void dump_head() const;       \/\/ Dump loop head only\n-  void dump() const;            \/\/ Dump this loop recursively\n+  void dump_head();       \/\/ Dump loop head only\n+  void dump();            \/\/ Dump this loop recursively\n@@ -1427,4 +1435,1 @@\n-  int do_range_check( IdealLoopTree *loop, Node_List &old_new );\n-\n-  \/\/ Check to see if do_range_check(...) cleaned the main loop of range-checks\n-  void has_range_checks(IdealLoopTree *loop);\n+  void do_range_check(IdealLoopTree *loop, Node_List &old_new);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":25,"deletions":20,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -183,1 +183,0 @@\n-        _phase->has_range_checks(lpt_next);\n@@ -187,1 +186,1 @@\n-        if (cl_next->is_post_loop() && !cl_next->range_checks_present() &&\n+        if (cl_next->is_post_loop() && !lpt_next->range_checks_present() &&\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+import jdk.internal.misc.Unsafe;\n+import java.util.Objects;\n+import java.util.Random;\n+\n+\/*\n+ * @test\n+ * @bug 8300256\n+ * @requires (os.simpleArch == \"x64\") | (os.simpleArch == \"aarch64\")\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestVectorizationNotRun\n+ *\/\n+\n+public class TestVectorizationNotRun {\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+    }\n+\n+    static int size = 1024;\n+    static int sizeBytes = 8 * size;\n+    static byte[] byteArray = new byte[sizeBytes];\n+    static long[] longArray = new long[size];\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR, \">=1\", IRNode.STORE_VECTOR, \">=1\" })\n+    public static void test(byte[] dest, long[] src) {\n+        for (int i = 0; i < src.length; i++) {\n+            if ((i < 0) || (8 > sizeBytes - i)) {\n+                throw new IndexOutOfBoundsException();\n+            }\n+            UNSAFE.putLongUnaligned(dest, UNSAFE.ARRAY_BYTE_BASE_OFFSET + i * 8, src[i]);\n+        }\n+    }\n+\n+    @Run(test = \"test\")\n+    public static void test_runner() {\n+        test(byteArray, longArray);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizationNotRun.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"}]}