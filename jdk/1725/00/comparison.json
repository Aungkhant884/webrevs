{"files":[{"patch":"@@ -1003,38 +1003,43 @@\n-            if (methodHandleSite != null) {\n-                methodHandleSite = null;\n-            }\n-            Method m = method(search(atts, \"method\"));\n-            if (lateInlining && scopes.size() == 0) {\n-                \/\/ re-attempting already seen call site (late inlining for MH invokes)\n-                if (m != site.getMethod()) {\n-                    if (current_bci != site.getBci()) {\n-                        System.err.println(m + \" bci: \" + current_bci);\n-                        System.err.println(site.getMethod() +  \" bci: \" + site.getBci());\n-                        reportInternalError(\"bci mismatch after late inlining\");\n-                    }\n-                    site.setMethod(m);\n-                }\n-            } else {\n-                \/\/ We're dealing with a new call site; the called method is\n-                \/\/ likely to be parsed next.\n-                site = new CallSite(current_bci, m);\n-            }\n-            site.setCount(Integer.parseInt(search(atts, \"count\", \"0\")));\n-            String receiver = atts.getValue(\"receiver\");\n-            if (receiver != null) {\n-                site.setReceiver(type(receiver));\n-                site.setReceiver_count(Integer.parseInt(search(atts, \"receiver_count\")));\n-            }\n-            int methodHandle = Integer.parseInt(search(atts, \"method_handle_intrinsic\", \"0\"));\n-            if (lateInlining && scopes.size() == 0) {\n-                \/\/ The call was already added before this round of late\n-                \/\/ inlining. Ignore.\n-            } else if (methodHandle == 0) {\n-                scopes.peek().add(site);\n-            } else {\n-                \/\/ method handle call site can be followed by another\n-                \/\/ call (in case it is inlined). If that happens we\n-                \/\/ discard the method handle call site. So we keep\n-                \/\/ track of it but don't add it to the list yet.\n-                methodHandleSite = site;\n-            }\n+          if (scopes.peek() == null) {\n+              Phase p = phaseStack.peek();\n+              assert p != null && p.getName().equals(\"optimizer\") : \"should not be in parse here\";\n+          } else {\n+              if (methodHandleSite != null) {\n+                  methodHandleSite = null;\n+              }\n+              Method m = method(search(atts, \"method\"));\n+              if (lateInlining && scopes.size() == 0) {\n+                  \/\/ re-attempting already seen call site (late inlining for MH invokes)\n+                  if (m != site.getMethod()) {\n+                      if (current_bci != site.getBci()) {\n+                          System.err.println(m + \" bci: \" + current_bci);\n+                          System.err.println(site.getMethod() +  \" bci: \" + site.getBci());\n+                          reportInternalError(\"bci mismatch after late inlining\");\n+                      }\n+                      site.setMethod(m);\n+                  }\n+              } else {\n+                  \/\/ We're dealing with a new call site; the called method is\n+                  \/\/ likely to be parsed next.\n+                  site = new CallSite(current_bci, m);\n+              }\n+              site.setCount(Integer.parseInt(search(atts, \"count\", \"0\")));\n+              String receiver = atts.getValue(\"receiver\");\n+              if (receiver != null) {\n+                  site.setReceiver(type(receiver));\n+                  site.setReceiver_count(Integer.parseInt(search(atts, \"receiver_count\")));\n+              }\n+              int methodHandle = Integer.parseInt(search(atts, \"method_handle_intrinsic\", \"0\"));\n+              if (lateInlining && scopes.size() == 0) {\n+                  \/\/ The call was already added before this round of late\n+                  \/\/ inlining. Ignore.\n+              } else if (methodHandle == 0) {\n+                  scopes.peek().add(site);\n+              } else {\n+                  \/\/ method handle call site can be followed by another\n+                  \/\/ call (in case it is inlined). If that happens we\n+                  \/\/ discard the method handle call site. So we keep\n+                  \/\/ track of it but don't add it to the list yet.\n+                  methodHandleSite = site;\n+              }\n+          }\n@@ -1052,7 +1057,3 @@\n-            if (methodHandleSite != null) {\n-                scopes.peek().add(methodHandleSite);\n-                methodHandleSite = null;\n-            }\n-            if (lateInlining && scopes.size() == 0) {\n-                site.setReason(\"fail: \" + search(atts, \"reason\"));\n-                lateInlining = false;\n+            if (scopes.peek() == null) {\n+                Phase p = phaseStack.peek();\n+                assert p != null && p.getName().equals(\"optimizer\") : \"should not be in parse here\";\n@@ -1060,1 +1061,10 @@\n-                scopes.peek().last().setReason(\"fail: \" + search(atts, \"reason\"));\n+                if (methodHandleSite != null) {\n+                    scopes.peek().add(methodHandleSite);\n+                    methodHandleSite = null;\n+                }\n+                if (lateInlining && scopes.size() == 0) {\n+                    site.setReason(\"fail: \" + search(atts, \"reason\"));\n+                    lateInlining = false;\n+                } else {\n+                    scopes.peek().last().setReason(\"fail: \" + search(atts, \"reason\"));\n+                }\n@@ -1103,0 +1113,1 @@\n+                    String currBytecode = current_bytecode >= 0 ? bytecodes[current_bytecode] : \"<unknown>\";\n@@ -1106,1 +1117,1 @@\n-                            bytecodes[current_bytecode]);\n+                            currBytecode);\n@@ -1295,1 +1306,1 @@\n-                \/\/ Don't carry a stale site to the next parse\n+                \/\/ Clear the bytecode and site from the last parse\n@@ -1297,0 +1308,1 @@\n+                current_bytecode = -1;\n","filename":"src\/utils\/LogCompilation\/src\/main\/java\/com\/sun\/hotspot\/tools\/compiler\/LogParser.java","additions":60,"deletions":48,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -121,0 +121,6 @@\n+\n+        if (compilation.getSpecial() != null) {\n+          assert compilation.getLevel() == 0 : \"Should be 0\";\n+          return;\n+        }\n+\n","filename":"src\/utils\/LogCompilation\/src\/main\/java\/com\/sun\/hotspot\/tools\/compiler\/UncommonTrapEvent.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}