{"files":[{"patch":"@@ -116,1 +116,2 @@\n-\n+\/\/#define MTL_LAYER_USE_BLIT_ENC\n+#ifdef MTL_LAYER_USE_BLIT_ENC\n@@ -125,0 +126,28 @@\n+#else\n+        id<MTLCommandBuffer> cb = [ctx createCommandBuffer];\n+        id<MTLComputeCommandEncoder> computeEncoder = [cb computeCommandEncoder];\n+        id<MTLComputePipelineState> computePipelineState = [ctx.pipelineStateStorage\n+                                                            getComputePipelineState:@\"tex2tex_opaque\"];\n+        [computeEncoder setComputePipelineState:computePipelineState];\n+\n+        NSUInteger maxTotalThreadsPerThreadgroup = computePipelineState.maxTotalThreadsPerThreadgroup;\n+        NSUInteger w = computePipelineState.threadExecutionWidth;\n+\n+        \/\/ Workaround for some OS\/device bug reporting incorrect maxTotalThreadsPerThreadgroup\n+        if (maxTotalThreadsPerThreadgroup == 0) {\n+            maxTotalThreadsPerThreadgroup = 1;\n+            w = 1;\n+        }\n+\n+        NSUInteger h = maxTotalThreadsPerThreadgroup \/ w;\n+        MTLSize threadgroupSize = MTLSizeMake(w, h, 1);\n+        MTLSize threadgroupCount;\n+\n+        threadgroupCount.width  = (buffer.width - src_x + threadgroupSize.width - 1) \/ threadgroupSize.width;\n+        threadgroupCount.height = (buffer.height - src_y + threadgroupSize.height - 1) \/ threadgroupSize.height;\n+        threadgroupCount.depth = 1;\n+\n+        [computeEncoder setTexture:buffer atIndex:0];\n+        [computeEncoder setTexture:mtlDrawable.texture atIndex:1];\n+        struct InsetsUniforms uniforms = {src_x, src_y};\n+        [computeEncoder setBytes:&uniforms length:sizeof(struct InsetsUniforms) atIndex:2];\n@@ -126,0 +155,5 @@\n+        [computeEncoder dispatchThreadgroups:threadgroupCount\n+                               threadsPerThreadgroup:threadgroupSize];\n+        [computeEncoder endEncoding];\n+        [cb commit];\n+#endif\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLLayer.m","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -164,0 +164,6 @@\n+\n+struct InsetsUniforms {\n+    int left;\n+    int top;\n+};\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/common.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -646,0 +646,10 @@\n+kernel void tex2tex_opaque(texture2d<half, access::read> inTexture [[texture(0)]],\n+    texture2d<half, access::write> outTexture [[texture(1)]],\n+    constant InsetsUniforms& uniforms [[buffer(2)]],\n+    uint2 gid [[thread_position_in_grid]])\n+{\n+    half4 inColor  = inTexture.read(uint2(gid[0] + uniforms.left, gid[1] + uniforms.top));\n+    half4 outColor = half4(inColor.rgb, 1.0);\n+    outTexture.write(outColor, gid);\n+}\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/shaders.metal","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,238 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, JetBrains s.r.o.. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key headful\n+ * @bug 8266079\n+ * @summary [macosx] window rendering alpha composite test\n+ * @author Alexey Ushakov\n+ * @run main WindowAlphaCompositeTest\n+ * @requires (os.family == \"mac\")\n+ *\/\n+\n+import java.awt.*;\n+import java.awt.image.BufferedImage;\n+import java.lang.reflect.InvocationTargetException;\n+import javax.swing.*;\n+\n+public class WindowAlphaCompositeTest\n+{\n+    interface Validate {\n+        boolean validate(int x, int y, Color c);\n+    }\n+    static Color RED128 = new Color(128, 0, 0);\n+    static Color BLUE128 = new Color(0, 0, 128);\n+    static Color PURPLE128 = new Color(128, 0, 128);\n+    static Color RED_BLUE24 = new Color(230, 0, 24);\n+    static Validate redBlackCheck = (int x, int y, Color c) -> {\n+        Color expColor = Color.RED;\n+        if (x > 24 && x < 75) {\n+            expColor = Color.BLACK;\n+        }\n+        return validateColor(c, expColor);\n+    };\n+\n+    static Validate redBlueCheck = (int x, int y, Color c) -> {\n+        Color expColor = Color.RED;\n+        if (x > 24 && x < 75) {\n+            expColor = Color.BLUE;\n+        }\n+        return validateColor(c, expColor);\n+    };\n+\n+    static Validate redCheck = (int x, int y, Color c) -> {\n+        Color expColor = Color.RED;\n+        return validateColor(c, expColor);\n+    };\n+\n+    static Validate redRed128Check = (int x, int y, Color c) -> {\n+        Color expColor = Color.RED;\n+        if (x > 24 && x < 75) {\n+            expColor = RED128;\n+        }\n+        return validateColor(c, expColor);\n+    };\n+\n+    static Validate redBlue128Check = (int x, int y, Color c) -> {\n+        Color expColor = Color.RED;\n+        if (x > 24 && x < 75) {\n+            expColor = BLUE128;\n+        }\n+        return validateColor(c, expColor);\n+    };\n+\n+    static Validate purple128Check = (int x, int y, Color c) -> {\n+        Color expColor = Color.RED;\n+        if (x > 24 && x < 75) {\n+            expColor = PURPLE128;\n+        }\n+        return validateColor(c, expColor);\n+    };\n+    static Validate redBlue24Check = (int x, int y, Color c) -> {\n+        Color expColor = Color.RED;\n+        if (x > 24 && x < 75) {\n+            expColor = RED_BLUE24;\n+        }\n+        return validateColor(c, expColor);\n+    };\n+    static Object[][] alphaComposites = {\n+            {AlphaComposite.Clear, redBlackCheck},\n+            {AlphaComposite.Dst, redCheck},\n+            {AlphaComposite.DstAtop, redCheck},\n+            {AlphaComposite.getInstance(AlphaComposite.DST_IN, 1.0f), redCheck},\n+            {AlphaComposite.getInstance(AlphaComposite.DST_IN, 0.5f), redRed128Check},\n+            {AlphaComposite.getInstance(AlphaComposite.DST_OUT, 1.0f), redBlackCheck},\n+            {AlphaComposite.getInstance(AlphaComposite.DST_OUT, 0.5f), redRed128Check},\n+            {AlphaComposite.DstOver, redCheck},\n+            {AlphaComposite.Src, redBlueCheck},\n+            {AlphaComposite.SrcAtop, redBlueCheck},\n+            {AlphaComposite.getInstance(AlphaComposite.SRC_IN, 1.0f), redBlueCheck},\n+            {AlphaComposite.getInstance(AlphaComposite.SRC_IN, 0.5f), redBlue128Check},\n+            {AlphaComposite.SrcOut, redBlackCheck},\n+            {AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f), redBlueCheck},\n+            {AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.5f), purple128Check},\n+            \/\/Uncomment after resolving issues with Xor mode on Metal\n+            \/\/{AlphaComposite.Xor, redBlackCheck},\n+            {AlphaComposite.getInstance(AlphaComposite.DST_OUT, 0.0f), redCheck},\n+            {AlphaComposite.getInstance(AlphaComposite.SRC_IN, 0.0f), redBlackCheck},\n+            {AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.01f), redCheck},\n+            {AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.099f), redBlue24Check}\n+    };\n+\n+    private static final int TD = 10;\n+    static WindowAlphaCompositeTest theTest;\n+    private final Robot robot;\n+    private JFrame frame;\n+\n+    private final static int DELAY = 1000;\n+\n+    public WindowAlphaCompositeTest() {\n+        try {\n+            robot = new Robot();\n+        } catch (AWTException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    public void performTest(final AlphaComposite ac, Validate validate) {\n+\n+        runSwing(() -> {\n+            frame = new JFrame();\n+            frame.setBounds(100, 100, 100, 150);\n+            JComponent contentPane = (JComponent) frame.getContentPane();\n+            JPanel comp = new JPanel() {\n+                @Override\n+                protected void paintComponent(Graphics g) {\n+                    super.paintComponent(g);\n+                    renderComposite((Graphics2D) g, ac, 100, 100);\n+                }\n+            };\n+            contentPane.add(comp);\n+            comp.setBackground(Color.BLACK);\n+            frame.setVisible(true);\n+        });\n+\n+        robot.delay(DELAY);\n+\n+        for (int px = 10; px <= 90; px += 20) {\n+            Color c = getTestPixel(px, 90);\n+\n+            if (!validate.validate(px, 90, c)) {\n+                throw new RuntimeException(\"Test failed. Incorrect color \" + c +\n+                        \" at (\" + px + \",\" + 90 + \") with composite rule=\" + ac.getRule() +\n+                        \" alpha=\" + ac.getAlpha());\n+            }\n+        }\n+\n+        runSwing(() -> frame.dispose());\n+\n+        frame = null;\n+    }\n+\n+    public void renderComposite(Graphics2D g, AlphaComposite ac,\n+                                int w, int h)\n+    {\n+        \/\/ draw stage\n+        \/\/ outer rect\n+        g.setComposite(AlphaComposite.SrcOver); \/\/ as default\n+        g.setPaint(Color.red);\n+        g.fillRect(0, 0, w, h);\n+\n+        \/\/ inner rect\n+        g.setComposite(ac);\n+        g.setPaint(Color.blue);\n+        g.fillRect(w\/4, h\/4, w\/2, h\/2);\n+    }\n+\n+    private Color getTestPixel(int x, int y) {\n+        Rectangle bounds = frame.getBounds();\n+        BufferedImage screenImage = robot.createScreenCapture(bounds);\n+        int rgb = screenImage.getRGB(x, y);\n+        int red = (rgb >> 16) & 0xFF;\n+        int green = (rgb >> 8) & 0xFF;\n+        int blue = rgb & 0xFF;\n+        return new Color(red, green, blue);\n+    }\n+\n+    private static boolean validateColor(Color c, Color expected) {\n+        return Math.abs(c.getRed() - expected.getRed()) <= TD &&\n+            Math.abs(c.getGreen() - expected.getGreen()) <= TD &&\n+            Math.abs(c.getBlue() - expected.getBlue()) <= TD;\n+    }\n+\n+    public void dispose() {\n+        if (frame != null) {\n+            frame.dispose();\n+            frame = null;\n+        }\n+    }\n+\n+    private static void runSwing(Runnable r) {\n+        try {\n+            SwingUtilities.invokeAndWait(r);\n+        } catch (InterruptedException | InvocationTargetException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        if (!System.getProperty(\"os.name\").contains(\"OS X\")) {\n+            System.out.println(\"This test is for MacOS only. Automatically passed on other platforms.\");\n+            return;\n+        }\n+\n+        try {\n+            for (Object[] alphaComposite : alphaComposites) {\n+                if (alphaComposite[1] == null) continue;\n+                runSwing(() -> theTest = new WindowAlphaCompositeTest());\n+                theTest.performTest((AlphaComposite) alphaComposite[0], (Validate) alphaComposite[1]);\n+            }\n+        } finally {\n+            if (theTest != null) {\n+                runSwing(() -> theTest.dispose());\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/AlphaComposite\/WindowAlphaCompositeTest.java","additions":238,"deletions":0,"binary":false,"changes":238,"status":"added"}]}