{"files":[{"patch":"@@ -624,1 +624,1 @@\n-            state.pop(1);\n+            state.pop(state.stacksize);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -863,0 +863,4 @@\n+        if (!code.isAlive()) {\n+            return items.makeStackItem(pt);\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8276836\n+ * @summary Check that switch expression with no value does not crash the compiler.\n+ * @library \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *      java.base\/jdk.internal\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.file\n+ *      jdk.compiler\/com.sun.tools.javac.main\n+ *      jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @build combo.ComboTestHelper\n+ * @compile SwitchExpressionNoValue.java\n+ * @run main\/othervm SwitchExpressionNoValue\n+ *\/\n+\n+import combo.ComboInstance;\n+import combo.ComboParameter;\n+import combo.ComboTask;\n+import combo.ComboTestHelper;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import javax.tools.Diagnostic;\n+import toolbox.ToolBox;\n+\n+import javax.tools.JavaFileObject;\n+\n+public class SwitchExpressionNoValue extends ComboInstance<SwitchExpressionNoValue> {\n+    protected ToolBox tb;\n+\n+    SwitchExpressionNoValue() {\n+        super();\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new ComboTestHelper<SwitchExpressionNoValue>()\n+                .withDimension(\"SWITCH_EXPRESSION\", (x, method) -> x.switchExpression = method, SwitchExpression.values())\n+                .withDimension(\"EXPRESSION\", (x, expression) -> x.expression = expression, Expression.values())\n+                .withDimension(\"CONTEXT\", (x, context) -> x.context = context, Context.values())\n+                .withFilter(test -> test.context.expressionType == test.expression.expressionType &&\n+                                    test.context.expressionType == test.switchExpression.expressionType)\n+                .run(SwitchExpressionNoValue::new);\n+    }\n+\n+    private SwitchExpression switchExpression;\n+    private Expression expression;\n+    private Context context;\n+\n+    private static final String MAIN_TEMPLATE =\n+            \"\"\"\n+            public class Test {\n+                public static void doTest() {\n+                    #{CONTEXT}\n+                }\n+                static int i;\n+                static int[] arr = new int[0];\n+                static void m(int i, Object o, int j) {}\n+            }\n+            \"\"\";\n+\n+    @Override\n+    protected void doWork() throws Throwable {\n+        Path base = Paths.get(\".\");\n+\n+        ComboTask task = newCompilationTask()\n+                .withSourceFromTemplate(MAIN_TEMPLATE, pname -> switch (pname) {\n+                        case \"SWITCH_EXPRESSION\" -> switchExpression;\n+                        case \"EXPRESSION\" -> expression;\n+                        case \"CONTEXT\" -> context;\n+                        default -> throw new UnsupportedOperationException(pname);\n+                    })\n+                .withOption(\"--enable-preview\")\n+                .withOption(\"-source\")\n+                .withOption(String.valueOf(Runtime.version().feature()));\n+\n+        task.generate(result -> {\n+            try {\n+                if (result.hasErrors()) {\n+                    throw new AssertionError(result.diagnosticsForKind(Diagnostic.Kind.ERROR));\n+                }\n+                Iterator<? extends JavaFileObject> filesIt = result.get().iterator();\n+                JavaFileObject file = filesIt.next();\n+                if (filesIt.hasNext()) {\n+                    throw new IllegalStateException(\"More than one classfile returned!\");\n+                }\n+                byte[] data = file.openInputStream().readAllBytes();\n+                ClassLoader inMemoryLoader = new ClassLoader() {\n+                    protected Class<?> findClass(String name) throws ClassNotFoundException {\n+                        if (\"Test\".equals(name)) {\n+                            return defineClass(name, data, 0, data.length);\n+                        }\n+                        return super.findClass(name);\n+                    }\n+                };\n+                Class<?> test = Class.forName(\"Test\", false, inMemoryLoader);\n+                try {\n+                java.lang.reflect.Method doTest = test.getDeclaredMethod(\"doTest\");\n+                    doTest.invoke(null);\n+                    throw new AssertionError(\"No expected exception!\");\n+                } catch (Throwable ex) {\n+                    while (ex instanceof InvocationTargetException) {\n+                        ex = ((InvocationTargetException) ex).getCause();\n+                    }\n+                    if (ex instanceof RuntimeException && \"test\".equals(ex.getMessage())) {\n+                        \/\/OK\n+                    } else {\n+                        throw new IllegalStateException(ex);\n+                    }\n+                }\n+            } catch (Throwable ex) {\n+                throw new IllegalStateException(ex);\n+            }\n+        });\n+    }\n+\n+    private void assertEquals(Object o1, Object o2) {\n+        if (!Objects.equals(o1, o2)) {\n+            throw new AssertionError();\n+        }\n+    }\n+\n+    public enum SwitchExpression implements ComboParameter {\n+        INT(\"switch (i) { case 0 -> throw new RuntimeException(\\\"test\\\"); default -> {if (true) throw new RuntimeException(\\\"test\\\"); else yield 0; } }\", ExpressionType.INT),\n+        BOOLEAN(\"switch (i) { case 0 -> throw new RuntimeException(\\\"test\\\"); default -> {if (true) throw new RuntimeException(\\\"test\\\"); else yield true; } }\", ExpressionType.BOOLEAN)\n+        ;\n+        private final String expression;\n+        private final ExpressionType expressionType;\n+\n+        private SwitchExpression(String expression, ExpressionType expressionType) {\n+            this.expression = expression;\n+            this.expressionType = expressionType;\n+        }\n+\n+        @Override\n+        public String expand(String optParameter) {\n+            return expression;\n+        }\n+    }\n+\n+    public enum Expression implements ComboParameter {\n+        SIMPLE(\"#{SWITCH_EXPRESSION}\", ExpressionType.INT),\n+        BINARY_SIMPLE(\"3 + #{SWITCH_EXPRESSION}\", ExpressionType.INT),\n+        BINARY_LONGER1(\"3 + #{SWITCH_EXPRESSION} + #{SWITCH_EXPRESSION} + #{SWITCH_EXPRESSION}\", ExpressionType.INT),\n+        BINARY_LONGER2(\"3 + switch (0) { default -> 0; } + #{SWITCH_EXPRESSION} + #{SWITCH_EXPRESSION}\", ExpressionType.INT),\n+        BINARY_LONGER3(\"3 + #{SWITCH_EXPRESSION} + switch (0) { default -> 0; } + #{SWITCH_EXPRESSION}\", ExpressionType.INT),\n+        BINARY_BOOLEAN(\"\\\"\\\".isEmpty() && #{SWITCH_EXPRESSION}\", ExpressionType.BOOLEAN),\n+        ;\n+        private final String expression;\n+        private final ExpressionType expressionType;\n+\n+        private Expression(String expression, ExpressionType expressionType) {\n+            this.expression = expression;\n+            this.expressionType = expressionType;\n+        }\n+\n+        @Override\n+        public String expand(String optParameter) {\n+            return expression;\n+        }\n+    }\n+\n+    public enum Context implements ComboParameter {\n+        ASSIGNMENT(\"i = #{EXPRESSION};\", ExpressionType.INT),\n+        COMPOUND_ASSIGNMENT(\"i += #{EXPRESSION};\", ExpressionType.INT),\n+        METHOD_INVOCATION(\"m(0, #{EXPRESSION}, 0);\", ExpressionType.INT),\n+        ARRAY_DEREF(\"arr[#{EXPRESSION}] = 0;\", ExpressionType.INT),\n+        IF(\"if (#{EXPRESSION});\", ExpressionType.BOOLEAN),\n+        WHILE(\"while (#{EXPRESSION});\", ExpressionType.BOOLEAN)\n+        ;\n+        private final String code;\n+        private final ExpressionType expressionType;\n+        private Context(String code, ExpressionType expressionType) {\n+            this.code = code;\n+            this.expressionType = expressionType;\n+        }\n+        @Override\n+        public String expand(String optParameter) {\n+            return code;\n+        }\n+    }\n+\n+    enum ExpressionType {\n+        INT,\n+        BOOLEAN;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/switchexpr\/SwitchExpressionNoValue.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"}]}