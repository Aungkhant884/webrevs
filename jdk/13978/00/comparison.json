{"files":[{"patch":"@@ -89,1 +89,0 @@\n-  NearLabel done;\n@@ -105,34 +104,39 @@\n-  \/\/ and mark it as unlocked.\n-  z_oill(hdr, markWord::unlocked_value);\n-  \/\/ Save unlocked object header into the displaced header location on the stack.\n-  z_stg(hdr, Address(disp_hdr, (intptr_t)0));\n-  \/\/ Test if object header is still the same (i.e. unlocked), and if so, store the\n-  \/\/ displaced header address in the object header. If it is not the same, get the\n-  \/\/ object header instead.\n-  z_csg(hdr, disp_hdr, hdr_offset, obj);\n-  \/\/ If the object header was the same, we're done.\n-  branch_optimized(Assembler::bcondEqual, done);\n-  \/\/ If the object header was not the same, it is now in the hdr register.\n-  \/\/ => Test if it is a stack pointer into the same stack (recursive locking), i.e.:\n-  \/\/\n-  \/\/ 1) (hdr & markWord::lock_mask_in_place) == 0\n-  \/\/ 2) rsp <= hdr\n-  \/\/ 3) hdr <= rsp + page_size\n-  \/\/\n-  \/\/ These 3 tests can be done by evaluating the following expression:\n-  \/\/\n-  \/\/ (hdr - Z_SP) & (~(page_size-1) | markWord::lock_mask_in_place)\n-  \/\/\n-  \/\/ assuming both the stack pointer and page_size have their least\n-  \/\/ significant 2 bits cleared and page_size is a power of 2\n-  z_sgr(hdr, Z_SP);\n-\n-  load_const_optimized(Z_R0_scratch, (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n-  z_ngr(hdr, Z_R0_scratch); \/\/ AND sets CC (result eq\/ne 0).\n-  \/\/ For recursive locking, the result is zero. => Save it in the displaced header\n-  \/\/ location (null in the displaced hdr location indicates recursive locking).\n-  z_stg(hdr, Address(disp_hdr, (intptr_t)0));\n-  \/\/ Otherwise we don't care about the result and handle locking via runtime call.\n-  branch_optimized(Assembler::bcondNotZero, slow_case);\n-  \/\/ done\n-  bind(done);\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    Unimplemented();\n+  } else if (LockingMode == LM_LEGACY) {\n+    NearLabel done;\n+    \/\/ and mark it as unlocked.\n+    z_oill(hdr, markWord::unlocked_value);\n+    \/\/ Save unlocked object header into the displaced header location on the stack.\n+    z_stg(hdr, Address(disp_hdr, (intptr_t) 0));\n+    \/\/ Test if object header is still the same (i.e. unlocked), and if so, store the\n+    \/\/ displaced header address in the object header. If it is not the same, get the\n+    \/\/ object header instead.\n+    z_csg(hdr, disp_hdr, hdr_offset, obj);\n+    \/\/ If the object header was the same, we're done.\n+    branch_optimized(Assembler::bcondEqual, done);\n+    \/\/ If the object header was not the same, it is now in the hdr register.\n+    \/\/ => Test if it is a stack pointer into the same stack (recursive locking), i.e.:\n+    \/\/\n+    \/\/ 1) (hdr & markWord::lock_mask_in_place) == 0\n+    \/\/ 2) rsp <= hdr\n+    \/\/ 3) hdr <= rsp + page_size\n+    \/\/\n+    \/\/ These 3 tests can be done by evaluating the following expression:\n+    \/\/\n+    \/\/ (hdr - Z_SP) & (~(page_size-1) | markWord::lock_mask_in_place)\n+    \/\/\n+    \/\/ assuming both the stack pointer and page_size have their least\n+    \/\/ significant 2 bits cleared and page_size is a power of 2\n+    z_sgr(hdr, Z_SP);\n+\n+    load_const_optimized(Z_R0_scratch, (~(os::vm_page_size() - 1) | markWord::lock_mask_in_place));\n+    z_ngr(hdr, Z_R0_scratch); \/\/ AND sets CC (result eq\/ne 0).\n+    \/\/ For recursive locking, the result is zero. => Save it in the displaced header\n+    \/\/ location (null in the displaced hdr location indicates recursive locking).\n+    z_stg(hdr, Address(disp_hdr, (intptr_t) 0));\n+    \/\/ Otherwise we don't care about the result and handle locking via runtime call.\n+    branch_optimized(Assembler::bcondNotZero, slow_case);\n+    \/\/ done\n+    bind(done);\n+  }\n@@ -147,4 +151,7 @@\n-  \/\/ Load displaced header.\n-  z_ltg(hdr, Address(disp_hdr, (intptr_t)0));\n-  \/\/ If the loaded hdr is null we had recursive locking, and we are done.\n-  z_bre(done);\n+  if (LockingMode != LM_LIGHTWEIGHT) {\n+    \/\/ Load displaced header.\n+    z_ltg(hdr, Address(disp_hdr, (intptr_t) 0));\n+    \/\/ If the loaded hdr is null we had recursive locking, and we are done.\n+    z_bre(done);\n+  }\n+\n@@ -154,8 +161,13 @@\n-  \/\/ Test if object header is pointing to the displaced header, and if so, restore\n-  \/\/ the displaced header in the object. If the object header is not pointing to\n-  \/\/ the displaced header, get the object header instead.\n-  z_csg(disp_hdr, hdr, hdr_offset, obj);\n-  \/\/ If the object header was not pointing to the displaced header,\n-  \/\/ we do unlocking via runtime call.\n-  branch_optimized(Assembler::bcondNotEqual, slow_case);\n-  \/\/ done\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    Unimplemented();\n+  } else {\n+    \/\/ Test if object header is pointing to the displaced header, and if so, restore\n+    \/\/ the displaced header in the object. If the object header is not pointing to\n+    \/\/ the displaced header, get the object header instead.\n+    z_csg(disp_hdr, hdr, hdr_offset, obj);\n+    \/\/ If the object header was not pointing to the displaced header,\n+    \/\/ we do unlocking via runtime call.\n+    branch_optimized(Assembler::bcondNotEqual, slow_case);\n+    \/\/ done\n+  }\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":59,"deletions":47,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -3174,2 +3174,3 @@\n-  \/\/ Set mark to markWord | markWord::unlocked_value.\n-  z_oill(displacedHeader, markWord::unlocked_value);\n+  if (LockingMode != LM_MONITOR) {\n+    \/\/ Set mark to markWord | markWord::unlocked_value.\n+    z_oill(displacedHeader, markWord::unlocked_value);\n@@ -3177,1 +3178,1 @@\n-  \/\/ Load Compare Value application register.\n+    \/\/ Load Compare Value application register.\n@@ -3179,2 +3180,2 @@\n-  \/\/ Initialize the box (must happen before we update the object mark).\n-  z_stg(displacedHeader, BasicLock::displaced_header_offset_in_bytes(), box);\n+    \/\/ Initialize the box (must happen before we update the object mark).\n+    z_stg(displacedHeader, BasicLock::displaced_header_offset_in_bytes(), box);\n@@ -3182,2 +3183,2 @@\n-  \/\/ Memory Fence (in cmpxchgd)\n-  \/\/ Compare object markWord with mark and if equal exchange scratch1 with object markWord.\n+    \/\/ Memory Fence (in cmpxchgd)\n+    \/\/ Compare object markWord with mark and if equal exchange scratch1 with object markWord.\n@@ -3185,5 +3186,9 @@\n-  \/\/ If the compare-and-swap succeeded, then we found an unlocked object and we\n-  \/\/ have now locked it.\n-  z_csg(displacedHeader, box, 0, oop);\n-  assert(currentHeader==displacedHeader, \"must be same register\"); \/\/ Identified two registers from z\/Architecture.\n-  z_bre(done);\n+    \/\/ If the compare-and-swap succeeded, then we found an unlocked object and we\n+    \/\/ have now locked it.\n+    z_csg(displacedHeader, box, 0, oop);\n+    assert(currentHeader == displacedHeader, \"must be same register\"); \/\/ Identified two registers from z\/Architecture.\n+    z_bre(done);\n+  } else {\n+    \/\/ Set NE to indicate 'failure' -> take slow-path\n+    z_ltgr(oop, oop);\n+  }\n@@ -3241,4 +3246,6 @@\n-  \/\/ Find the lock address and load the displaced header from the stack.\n-  \/\/ if the displaced header is zero, we have a recursive unlock.\n-  load_and_test_long(displacedHeader, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-  z_bre(done);\n+  if (LockingMode != LM_MONITOR) {\n+    \/\/ Find the lock address and load the displaced header from the stack.\n+    \/\/ if the displaced header is zero, we have a recursive unlock.\n+    load_and_test_long(displacedHeader, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+    z_bre(done);\n+  }\n@@ -3253,6 +3260,11 @@\n-  \/\/ Check if it is still a light weight lock, this is true if we see\n-  \/\/ the stack address of the basicLock in the markWord of the object\n-  \/\/ copy box to currentHeader such that csg does not kill it.\n-  z_lgr(currentHeader, box);\n-  z_csg(currentHeader, displacedHeader, 0, oop);\n-  z_bru(done); \/\/ Csg sets CR as desired.\n+  if (LockingMode != LM_MONITOR) {\n+    \/\/ Check if it is still a light weight lock, this is true if we see\n+    \/\/ the stack address of the basicLock in the markWord of the object\n+    \/\/ copy box to currentHeader such that csg does not kill it.\n+    z_lgr(currentHeader, box);\n+    z_csg(currentHeader, displacedHeader, 0, oop);\n+    z_bru(done); \/\/ Csg sets CR as desired.\n+  } else {\n+    \/\/ Set NE to indicate 'failure' -> take slow-path\n+    z_ltgr(oop, oop);\n+  }\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":34,"deletions":22,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -1924,1 +1924,1 @@\n-#if !defined(X86) && !defined(AARCH64) && !defined(PPC64) && !defined(RISCV64)\n+#if !defined(X86) && !defined(AARCH64) && !defined(PPC64) && !defined(RISCV64) && !defined(S390)\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -489,1 +489,1 @@\n-#if defined(X86) || defined(AARCH64) || defined(PPC64) || defined(RISCV64)\n+#if defined(X86) || defined(AARCH64) || defined(PPC64) || defined(RISCV64) || defined(S390)\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n- * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch == \"ppc64\" | os.arch == \"ppc64le\" | os.arch == \"riscv64\"\n+ * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch == \"ppc64\" | os.arch == \"ppc64le\" | os.arch == \"riscv64\" | os.arch == \"s390x\"\n","filename":"test\/jdk\/java\/util\/concurrent\/ConcurrentHashMap\/MapLoops.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}