{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -57,1 +58,1 @@\n-public final class NativeLibraries {\n+public abstract class NativeLibraries {\n@@ -59,2 +60,2 @@\n-    private final Map<String, NativeLibraryImpl> libraries = new ConcurrentHashMap<>();\n-    private final ClassLoader loader;\n+    protected final Map<String, NativeLibraryImpl> libraries = new ConcurrentHashMap<>();\n+    protected final ClassLoader loader;\n@@ -63,1 +64,1 @@\n-    private final Class<?> caller;      \/\/ may be null\n+    protected final Class<?> caller;      \/\/ may be null\n@@ -65,2 +66,0 @@\n-    \/\/ loading JNI native libraries\n-    private final boolean isJNI;\n@@ -85,1 +84,1 @@\n-        return new NativeLibraries(loader);\n+        return new JniNativeLibraries(loader);\n@@ -99,1 +98,1 @@\n-    public static NativeLibraries rawNativeLibraries(Class<?> trustedCaller,\n+    public static NativeLibraries rawNativeLibraries(MethodHandles.Lookup trustedCaller,\n@@ -101,1 +100,5 @@\n-        return new NativeLibraries(trustedCaller, searchJavaLibraryPath);\n+        if (!trustedCaller.hasFullPrivilegeAccess() ||\n+                !VM.isSystemDomainLoader(trustedCaller.lookupClass().getClassLoader())) {\n+            throw new InternalError(trustedCaller + \" does not have access to raw native library loading\");\n+        }\n+        return new RawNativeLibraries(trustedCaller.lookupClass(), searchJavaLibraryPath);\n@@ -104,3 +107,1 @@\n-    private NativeLibraries(ClassLoader loader) {\n-        \/\/ for null loader, default the caller to this class and\n-        \/\/ do not search java.library.path\n+    private NativeLibraries(ClassLoader loader, Class<?> caller, boolean searchJavaLibraryPath) {\n@@ -108,15 +109,0 @@\n-        this.caller = loader != null ? null : NativeLibraries.class;\n-        this.searchJavaLibraryPath = loader != null ? true : false;\n-        this.isJNI = true;\n-    }\n-\n-    \/*\n-     * Constructs a NativeLibraries instance of no relationship with class loaders\n-     * and disabled auto unloading.\n-     *\/\n-    private NativeLibraries(Class<?> caller, boolean searchJavaLibraryPath) {\n-        Objects.requireNonNull(caller);\n-        if (!VM.isSystemDomainLoader(caller.getClassLoader())) {\n-            throw new IllegalArgumentException(\"must be JDK trusted class\");\n-        }\n-        this.loader = caller.getClassLoader();\n@@ -125,1 +111,0 @@\n-        this.isJNI = false;\n@@ -188,73 +173,1 @@\n-    private NativeLibrary loadLibrary(Class<?> fromClass, String name, boolean isBuiltin) {\n-        ClassLoader loader = (fromClass == null) ? null : fromClass.getClassLoader();\n-        if (this.loader != loader) {\n-            throw new InternalError(fromClass.getName() + \" not allowed to load library\");\n-        }\n-\n-        acquireNativeLibraryLock(name);\n-        try {\n-            \/\/ find if this library has already been loaded and registered in this NativeLibraries\n-            NativeLibrary cached = libraries.get(name);\n-            if (cached != null) {\n-                return cached;\n-            }\n-\n-            \/\/ cannot be loaded by other class loaders\n-            if (loadedLibraryNames.contains(name)) {\n-                throw new UnsatisfiedLinkError(\"Native Library \" + name +\n-                        \" already loaded in another classloader\");\n-            }\n-\n-            \/*\n-             * When a library is being loaded, JNI_OnLoad function can cause\n-             * another loadLibrary invocation that should succeed.\n-             *\n-             * Each thread maintains its own stack to hold the list of\n-             * libraries it is loading.\n-             *\n-             * If there is a pending load operation for the library, we\n-             * immediately return success; if the pending load is from\n-             * a different class loader, we raise UnsatisfiedLinkError.\n-             *\/\n-            for (NativeLibraryImpl lib : NativeLibraryContext.current()) {\n-                if (name.equals(lib.name())) {\n-                    if (loader == lib.fromClass.getClassLoader()) {\n-                        return lib;\n-                    } else {\n-                        throw new UnsatisfiedLinkError(\"Native Library \" +\n-                                name + \" is being loaded in another classloader\");\n-                    }\n-                }\n-            }\n-\n-            NativeLibraryImpl lib = new NativeLibraryImpl(fromClass, name, isBuiltin, isJNI);\n-            \/\/ load the native library\n-            NativeLibraryContext.push(lib);\n-            try {\n-                if (!lib.open()) {\n-                    return null;    \/\/ fail to open the native library\n-                }\n-                \/\/ auto unloading is only supported for JNI native libraries\n-                \/\/ loaded by custom class loaders that can be unloaded.\n-                \/\/ built-in class loaders are never unloaded.\n-                boolean autoUnload = isJNI && !VM.isSystemDomainLoader(loader)\n-                        && loader != ClassLoaders.appClassLoader();\n-                if (autoUnload) {\n-                    \/\/ register the loaded native library for auto unloading\n-                    \/\/ when the class loader is reclaimed, all native libraries\n-                    \/\/ loaded that class loader will be unloaded.\n-                    \/\/ The entries in the libraries map are not removed since\n-                    \/\/ the entire map will be reclaimed altogether.\n-                    CleanerFactory.cleaner().register(loader, lib.unloader());\n-                }\n-            } finally {\n-                NativeLibraryContext.pop();\n-            }\n-            \/\/ register the loaded native library\n-            loadedLibraryNames.add(name);\n-            libraries.put(name, lib);\n-            return lib;\n-        } finally {\n-            releaseNativeLibraryLock(name);\n-        }\n-    }\n+    abstract NativeLibrary loadLibrary(Class<?> fromClass, String name, boolean isBuiltin);\n@@ -272,2 +185,0 @@\n-        assert caller != null;\n-\n@@ -277,0 +188,11 @@\n+    \/*\n+     * Load a native library from the given file.  Returns null if the given\n+     * library is determined to be non-loadable, which is system-dependent.\n+     *\n+     * @param file the path of the native library\n+     * @throws UnsatisfiedLinkError if any error in loading the native library\n+     *\/\n+    public NativeLibrary loadLibrary(File file) {\n+        return loadLibrary(caller, file);\n+    }\n+\n@@ -301,17 +223,1 @@\n-    public void unload(NativeLibrary lib) {\n-        if (isJNI) {\n-            throw new UnsupportedOperationException(\"explicit unloading cannot be used with auto unloading\");\n-        }\n-        Objects.requireNonNull(lib);\n-        acquireNativeLibraryLock(lib.name());\n-        try {\n-            NativeLibraryImpl nl = libraries.remove(lib.name());\n-            if (nl != lib) {\n-                throw new IllegalArgumentException(lib.name() + \" not loaded by this NativeLibraries instance\");\n-            }\n-            \/\/ unload the native library and also remove from the global name registry\n-            nl.unloader().run();\n-        } finally {\n-            releaseNativeLibraryLock(lib.name());\n-        }\n-    }\n+    abstract void unload(NativeLibrary lib);\n@@ -337,0 +243,172 @@\n+    static class JniNativeLibraries extends NativeLibraries {\n+        \/\/ All JNI native libraries we've loaded.\n+        private static final Set<String> loadedLibraryNames = ConcurrentHashMap.newKeySet();\n+\n+        private JniNativeLibraries(ClassLoader loader) {\n+            \/\/ for null loader, default the caller to this class and\n+            \/\/ do not search java.library.path\n+            super(loader, loader != null ? null : NativeLibraries.class,\n+                    loader != null ? true : false);\n+        }\n+\n+        \/**\n+         * Returns a NativeLibrary of the given name.\n+         *\n+         * @param fromClass the caller class calling System::loadLibrary\n+         * @param name      library name\n+         * @param isBuiltin built-in library\n+         * @throws UnsatisfiedLinkError if the native library has already been loaded\n+         *      and registered in another NativeLibraries\n+         *\/\n+        NativeLibrary loadLibrary(Class<?> fromClass, String name, boolean isBuiltin) {\n+            ClassLoader loader = (fromClass == null) ? null : fromClass.getClassLoader();\n+            if (this.loader != loader) {\n+                throw new InternalError(fromClass.getName() + \" not allowed to load library\");\n+            }\n+\n+            acquireNativeLibraryLock(name);\n+            try {\n+                \/\/ find if this library has already been loaded and registered in this NativeLibraries\n+                NativeLibrary cached = libraries.get(name);\n+                if (cached != null) {\n+                    return cached;\n+                }\n+\n+                \/\/ cannot be loaded by other class loaders\n+                if (loadedLibraryNames.contains(name)) {\n+                    throw new UnsatisfiedLinkError(\"Native Library \" + name +\n+                            \" already loaded in another classloader\");\n+                }\n+\n+                \/*\n+                 * When a library is being loaded, JNI_OnLoad function can cause\n+                 * another loadLibrary invocation that should succeed.\n+                 *\n+                 * Each thread maintains its own stack to hold the list of\n+                 * libraries it is loading.\n+                 *\n+                 * If there is a pending load operation for the library, we\n+                 * immediately return success; if the pending load is from\n+                 * a different class loader, we raise UnsatisfiedLinkError.\n+                 *\/\n+                for (NativeLibraryImpl lib : NativeLibraryContext.current()) {\n+                    if (name.equals(lib.name())) {\n+                        if (loader == lib.fromClass.getClassLoader()) {\n+                            return lib;\n+                        } else {\n+                            throw new UnsatisfiedLinkError(\"Native Library \" +\n+                                    name + \" is being loaded in another classloader\");\n+                        }\n+                    }\n+                }\n+\n+                NativeLibraryImpl lib = new NativeLibraryImpl(fromClass, name, isBuiltin, true);\n+                \/\/ load the native library\n+                NativeLibraryContext.push(lib);\n+                try {\n+                    if (!lib.open()) {\n+                        return null;    \/\/ fail to open the native library\n+                    }\n+                    \/\/ auto unloading is only supported for JNI native libraries\n+                    \/\/ loaded by custom class loaders that can be unloaded.\n+                    \/\/ built-in class loaders are never unloaded.\n+                    boolean autoUnload = !VM.isSystemDomainLoader(loader)\n+                            && loader != ClassLoaders.appClassLoader();\n+                    if (autoUnload) {\n+                        \/\/ register the loaded native library for auto unloading\n+                        \/\/ when the class loader is reclaimed, all native libraries\n+                        \/\/ loaded that class loader will be unloaded.\n+                        \/\/ The entries in the libraries map are not removed since\n+                        \/\/ the entire map will be reclaimed altogether.\n+                        CleanerFactory.cleaner().register(loader, lib.unloader());\n+                    }\n+                } finally {\n+                    NativeLibraryContext.pop();\n+                }\n+                \/\/ register the loaded native library\n+                loadedLibraryNames.add(name);\n+                libraries.put(name, lib);\n+                return lib;\n+            } finally {\n+                releaseNativeLibraryLock(name);\n+            }\n+        }\n+\n+        void unload(NativeLibrary lib) {\n+            throw new UnsupportedOperationException(\"explicit unloading cannot be used with auto unloading\");\n+        }\n+\n+        static boolean unregister(String name) {\n+            return loadedLibraryNames.remove(name);\n+        }\n+    }\n+\n+    \/*\n+     * A RawNativeLibraries instance has no relationship with any class loaders\n+     * and disabled auto unloading.\n+     *\/\n+    static class RawNativeLibraries extends NativeLibraries {\n+        RawNativeLibraries(Class<?> caller, boolean searchJavaLibraryPath) {\n+            super(caller.getClassLoader(), caller, searchJavaLibraryPath);\n+        }\n+\n+        \/**\n+         * Returns a NativeLibrary of the given name.\n+         *\n+         * The loaded library is not auto-unloaded.  JNI_OnLoad and JNI_OnUnload\n+         * are ignored if present.  It has no relationship with class loaders.\n+         *\n+         * This method will load the library regardless whether it has been loaded\n+         * by a classloader via System::loadLibrary.  When a class loader is\n+         * unloaded, if a library is also loaded as a raw native library,\n+         * JNI_Unload will be invoked but the native library may not get unloaded\n+         * by the underlying library loading mechanism such as dlopen\/dlclose\n+         * unless the raw native library is unloaded explicitly.\n+         *\n+         * @param fromClass the caller class\n+         * @param name      library name\n+         * @param isBuiltin built-in library\n+         *\/\n+        NativeLibrary loadLibrary(Class<?> fromClass, String name, boolean isBuiltin) {\n+            if (fromClass != caller) {\n+                throw new InternalError(\"unexpected caller: \" + fromClass + \" trusted \" + caller.getName());\n+            }\n+            acquireNativeLibraryLock(name);\n+            try {\n+                \/\/ find if this library has already been loaded and registered in this NativeLibraries\n+                NativeLibrary cached = libraries.get(name);\n+                if (cached != null) {\n+                    return cached;\n+                }\n+\n+                NativeLibraryImpl lib = new NativeLibraryImpl(fromClass, name, isBuiltin, false);\n+                if (!lib.open()) {\n+                    return null;    \/\/ fail to open the native library\n+                }\n+\n+                libraries.put(name, lib);\n+                return lib;\n+            } finally {\n+                releaseNativeLibraryLock(name);\n+            }\n+        }\n+\n+        \/*\n+         * Unloads the given native library\n+         *\/\n+        void unload(NativeLibrary lib) {\n+            Objects.requireNonNull(lib);\n+            acquireNativeLibraryLock(lib.name());\n+            try {\n+                NativeLibraryImpl nl = libraries.remove(lib.name());\n+                if (nl != lib) {\n+                    throw new IllegalArgumentException(lib.name() + \" not loaded by this NativeLibraries instance\");\n+                }\n+                \/\/ unload the native library and also remove from the global name registry\n+                nl.unloader().run();\n+            } finally {\n+                releaseNativeLibraryLock(lib.name());\n+            }\n+        }\n+    }\n+\n@@ -432,1 +510,1 @@\n-                if (!loadedLibraryNames.remove(name)) {\n+                if (isJNI && !JniNativeLibraries.unregister(name)) {\n@@ -459,4 +537,0 @@\n-    \/\/ All native libraries we've loaded.\n-    private static final Set<String> loadedLibraryNames =\n-            ConcurrentHashMap.newKeySet();\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/NativeLibraries.java","additions":199,"deletions":125,"binary":false,"changes":324,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -66,1 +67,1 @@\n-        SymbolLookup lookup = libLookup(libs -> libs.loadLibrary(null, stdLib.toFile()));\n+        SymbolLookup lookup = libLookup(libs -> libs.loadLibrary(stdLib.toFile()));\n@@ -88,1 +89,1 @@\n-        NativeLibrary lib = loader.apply(NativeLibraries.rawNativeLibraries(SystemLookup.class, false));\n+        NativeLibrary lib = loader.apply(NativeLibraries.rawNativeLibraries(MethodHandles.lookup(), false));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.internal.loader.*;\n@@ -56,4 +55,5 @@\n-        \/\/ expect NativeLibraries to fail since the library has been loaded by System::loadLibrary\n-        try {\n-            test.load(false);\n-        } catch (UnsatisfiedLinkError e) { e.printStackTrace(); }\n+        \/\/ expect NativeLibraries to succeed even the library has been loaded by System::loadLibrary\n+        test.load(true);\n+\n+        \/\/ unload the native library\n+        test.unload();\n","filename":"test\/jdk\/jdk\/internal\/loader\/NativeLibraries\/Main.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -54,1 +55,1 @@\n-        this.nativeLibraries = NativeLibraries.rawNativeLibraries(NativeLibraries.class, true);\n+        this.nativeLibraries = NativeLibraries.rawNativeLibraries(MethodHandles.lookup(), true);\n","filename":"test\/jdk\/jdk\/internal\/loader\/NativeLibraries\/java.base\/jdk\/internal\/loader\/NativeLibrariesTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}