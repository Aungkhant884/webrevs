{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2388,1 +2388,1 @@\n-    private final NativeLibraries libraries = NativeLibraries.jniNativeLibraries(this);\n+    private final NativeLibraries libraries = NativeLibraries.newInstance(this);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-        = NativeLibraries.jniNativeLibraries(null);\n+        = NativeLibraries.newInstance(null);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/BootLoader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import java.util.Objects;\n@@ -65,2 +64,0 @@\n-    \/\/ loading JNI native libraries\n-    private final boolean isJNI;\n@@ -84,2 +81,2 @@\n-    public static NativeLibraries jniNativeLibraries(ClassLoader loader) {\n-        return new NativeLibraries(loader);\n+    public static NativeLibraries newInstance(ClassLoader loader) {\n+        return new NativeLibraries(loader, loader != null ? null : NativeLibraries.class, loader != null);\n@@ -88,19 +85,1 @@\n-    \/**\n-     * Creates a raw NativeLibraries instance that has the following properties:\n-     * 1. Native libraries loaded in this raw NativeLibraries instance are\n-     *    not JNI native libraries.  Hence JNI_OnLoad and JNI_OnUnload will\n-     *    be ignored.  No support for linking of native method.\n-     * 2. Native libraries not auto-unloaded.  They may be explicitly unloaded\n-     *    via NativeLibraries::unload.\n-     * 3. No relationship with class loaders.\n-     *\n-     * This static factory method is restricted for JDK trusted class use.\n-     *\/\n-    public static NativeLibraries rawNativeLibraries(Class<?> trustedCaller,\n-                                                     boolean searchJavaLibraryPath) {\n-        return new NativeLibraries(trustedCaller, searchJavaLibraryPath);\n-    }\n-\n-    private NativeLibraries(ClassLoader loader) {\n-        \/\/ for null loader, default the caller to this class and\n-        \/\/ do not search java.library.path\n+    private NativeLibraries(ClassLoader loader, Class<?> caller, boolean searchJavaLibraryPath) {\n@@ -108,15 +87,0 @@\n-        this.caller = loader != null ? null : NativeLibraries.class;\n-        this.searchJavaLibraryPath = loader != null ? true : false;\n-        this.isJNI = true;\n-    }\n-\n-    \/*\n-     * Constructs a NativeLibraries instance of no relationship with class loaders\n-     * and disabled auto unloading.\n-     *\/\n-    private NativeLibraries(Class<?> caller, boolean searchJavaLibraryPath) {\n-        Objects.requireNonNull(caller);\n-        if (!VM.isSystemDomainLoader(caller.getClassLoader())) {\n-            throw new IllegalArgumentException(\"must be JDK trusted class\");\n-        }\n-        this.loader = caller.getClassLoader();\n@@ -125,1 +89,0 @@\n-        this.isJNI = false;\n@@ -230,1 +193,1 @@\n-            NativeLibraryImpl lib = new NativeLibraryImpl(fromClass, name, isBuiltin, isJNI);\n+            NativeLibraryImpl lib = new NativeLibraryImpl(fromClass, name, isBuiltin, true);\n@@ -240,2 +203,1 @@\n-                boolean autoUnload = isJNI && !VM.isSystemDomainLoader(loader)\n-                        && loader != ClassLoaders.appClassLoader();\n+                boolean autoUnload = !VM.isSystemDomainLoader(loader) && loader != ClassLoaders.appClassLoader();\n@@ -272,2 +234,0 @@\n-        assert caller != null;\n-\n@@ -296,23 +256,0 @@\n-    \/**\n-     * Unloads the given native library\n-     *\n-     * @param lib native library\n-     *\/\n-    public void unload(NativeLibrary lib) {\n-        if (isJNI) {\n-            throw new UnsupportedOperationException(\"explicit unloading cannot be used with auto unloading\");\n-        }\n-        Objects.requireNonNull(lib);\n-        acquireNativeLibraryLock(lib.name());\n-        try {\n-            NativeLibraryImpl nl = libraries.remove(lib.name());\n-            if (nl != lib) {\n-                throw new IllegalArgumentException(lib.name() + \" not loaded by this NativeLibraries instance\");\n-            }\n-            \/\/ unload the native library and also remove from the global name registry\n-            nl.unloader().run();\n-        } finally {\n-            releaseNativeLibraryLock(lib.name());\n-        }\n-    }\n-\n@@ -383,1 +320,5 @@\n-        Runnable unloader() {\n+        \/*\n+         * Unloader::run method is invoked to unload the native library\n+         * when this class loader becomes phantom reachable.\n+         *\/\n+        private Runnable unloader() {\n@@ -397,0 +338,7 @@\n+\n+        \/*\n+         * Close this native library.\n+         *\/\n+        void close() {\n+            unload(name, isBuiltin, isJNI, handle);\n+        }\n@@ -432,1 +380,1 @@\n-                if (!loadedLibraryNames.remove(name)) {\n+                if (isJNI && !loadedLibraryNames.remove(name)) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/NativeLibraries.java","additions":19,"deletions":71,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.loader;\n+\n+import jdk.internal.misc.VM;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.nio.file.Path;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static jdk.internal.loader.NativeLibraries.*;\n+\n+\n+\/**\n+ * RawNativeLibraries has the following properties:\n+ * 1. Native libraries loaded in this RawNativeLibraries instance are\n+ *    not JNI native libraries.  Hence JNI_OnLoad and JNI_OnUnload will\n+ *    be ignored.  No support for linking of native method.\n+ * 2. Native libraries not auto-unloaded.  They may be explicitly unloaded\n+ *    via NativeLibraries::unload.\n+ * 3. No relationship with class loaders.\n+ *\/\n+public final class RawNativeLibraries {\n+    final Map<String, NativeLibraryImpl> libraries = new ConcurrentHashMap<>();\n+    final Class<?> caller;\n+\n+    private RawNativeLibraries(MethodHandles.Lookup trustedCaller) {\n+        this.caller = trustedCaller.lookupClass();\n+    }\n+\n+    \/**\n+     * Creates a RawNativeLibraries instance that has no relationship with\n+     * any class loaders and disabled auto unloading.\n+     *\n+     * This static factory method is restricted for JDK trusted class use.\n+     *\/\n+    public static RawNativeLibraries newInstance(MethodHandles.Lookup trustedCaller) {\n+        if (!trustedCaller.hasFullPrivilegeAccess() ||\n+                !VM.isSystemDomainLoader(trustedCaller.lookupClass().getClassLoader())) {\n+            throw new InternalError(trustedCaller + \" does not have access to raw native library loading\");\n+        }\n+        return new RawNativeLibraries(trustedCaller);\n+    }\n+\n+    \/*\n+     * Load a native library from the given path.  Returns null if the given\n+     * library is determined to be non-loadable, which is system-dependent.\n+     *\n+     * @param path the path of the native library\n+     *\/\n+    @SuppressWarnings(\"removal\")\n+    public NativeLibrary load(Path path) {\n+        String name = AccessController.doPrivileged(new PrivilegedAction<>() {\n+            public String run() {\n+                try {\n+                    return path.toRealPath().toString();\n+                } catch (IOException e) {\n+                    return null;\n+                }\n+            }\n+        });\n+        if (name == null) {\n+            return null;\n+        }\n+        return load(name);\n+    }\n+\n+    \/**\n+     * Load a native library of the given pathname, which is platform-specific.\n+     * Returns null if it fails to load the given pathname.\n+     *\n+     * If the given pathname does not contain a name-separator character,\n+     * for example on Unix a slash character, the library search strategy\n+     * is system-dependent for example on Unix, see dlopen.\n+     *\n+     * @apiNote\n+     * The {@code pathname} argument is platform-specific.\n+     * {@link System#mapLibraryName} can be used to convert a name to\n+     * a platform-specific pathname:\n+     * {@snippet\n+     *     RawNativeLibraries libs = RawNativeLibraries.newInstance(MethodHandles.lookup());\n+     *     NativeLibrary lib = libs.load(System.mapLibraryName(\"blas\"));\n+     * }\n+     *\n+     * @param pathname the pathname of the native library\n+     * @see System#mapLibraryName(String)\n+     *\/\n+    public NativeLibrary load(String pathname) {\n+         return libraries.computeIfAbsent(pathname, this::get);\n+    }\n+\n+    private NativeLibraryImpl get(String pathname) {\n+        NativeLibraryImpl lib = new NativeLibraryImpl(caller, pathname, false, false);\n+        if (!lib.open()) {\n+            return null;    \/\/ fail to open the native library\n+        }\n+        return lib;\n+    }\n+\n+    \/*\n+     * Unloads the given native library.\n+     *\/\n+    public void unload(NativeLibrary lib) {\n+        Objects.requireNonNull(lib);\n+        if (!libraries.remove(lib.name(), lib)) {\n+            throw new IllegalArgumentException(lib.name() + \" not loaded by this RawNativeLibraries instance\");\n+        }\n+        NativeLibraryImpl nl = (NativeLibraryImpl)lib;\n+        nl.close();\n+    }\n+}\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/RawNativeLibraries.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import jdk.internal.loader.NativeLibraries;\n@@ -35,0 +34,1 @@\n+import jdk.internal.loader.RawNativeLibraries;\n@@ -36,0 +36,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -42,0 +43,2 @@\n+import sun.security.action.GetPropertyAction;\n+\n@@ -55,1 +58,1 @@\n-        case SysV, LinuxAArch64, MacOsAArch64 -> libLookup(libs -> libs.loadLibrary(\"syslookup\"));\n+        case SysV, LinuxAArch64, MacOsAArch64 -> libLookup(libs -> libs.load(jdkLibraryPath(\"syslookup\")));\n@@ -66,1 +69,1 @@\n-        SymbolLookup lookup = libLookup(libs -> libs.loadLibrary(null, stdLib.toFile()));\n+        SymbolLookup lookup = libLookup(libs -> libs.load(stdLib));\n@@ -70,2 +73,1 @@\n-\n-            SymbolLookup fallbackLibLookup = libLookup(libs -> libs.loadLibrary(\"WinFallbackLookup\"));\n+            SymbolLookup fallbackLibLookup = libLookup(libs -> libs.load(jdkLibraryPath(\"WinFallbackLookup\")));\n@@ -87,2 +89,2 @@\n-    private static SymbolLookup libLookup(Function<NativeLibraries, NativeLibrary> loader) {\n-        NativeLibrary lib = loader.apply(NativeLibraries.rawNativeLibraries(SystemLookup.class, false));\n+    private static SymbolLookup libLookup(Function<RawNativeLibraries, NativeLibrary> loader) {\n+        NativeLibrary lib = loader.apply(RawNativeLibraries.newInstance(MethodHandles.lookup()));\n@@ -102,0 +104,13 @@\n+    \/*\n+     * Returns the path of the given library name from JDK\n+     *\/\n+    private static Path jdkLibraryPath(String name) {\n+        Path javahome = Path.of(GetPropertyAction.privilegedGetProperty(\"java.home\"));\n+        String lib = switch (CABI.current()) {\n+            case SysV, LinuxAArch64, MacOsAArch64 -> \"lib\";\n+            case Win64 -> \"bin\";\n+        };\n+        String libname = System.mapLibraryName(name);\n+        return javahome.resolve(lib).resolve(libname);\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":23,"deletions":8,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8240975\n+ * @bug 8240975 8281335\n@@ -33,1 +33,0 @@\n-import jdk.internal.loader.*;\n@@ -45,0 +44,1 @@\n+        \/\/ Verify a native library from test.nativepath\n@@ -56,4 +56,5 @@\n-        \/\/ expect NativeLibraries to fail since the library has been loaded by System::loadLibrary\n-        try {\n-            test.load(false);\n-        } catch (UnsatisfiedLinkError e) { e.printStackTrace(); }\n+        \/\/ expect NativeLibraries to succeed even the library has been loaded by System::loadLibrary\n+        test.load(true);\n+\n+        \/\/ load zip library from JDK\n+        test.load(System.mapLibraryName(\"zip\"));\n","filename":"test\/jdk\/jdk\/internal\/loader\/NativeLibraries\/Main.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -30,0 +31,1 @@\n+import java.nio.file.Path;\n@@ -52,1 +54,2 @@\n-    private final NativeLibraries nativeLibraries;\n+    private final RawNativeLibraries nativeLibraries;\n+\n@@ -54,1 +57,1 @@\n-        this.nativeLibraries = NativeLibraries.rawNativeLibraries(NativeLibraries.class, true);\n+        this.nativeLibraries = RawNativeLibraries.newInstance(MethodHandles.lookup());\n@@ -64,0 +67,5 @@\n+    static Path libraryPath() {\n+        Path lib = Path.of(System.getProperty(\"test.nativepath\"));\n+        return lib.resolve(System.mapLibraryName(LIB_NAME));\n+    }\n+\n@@ -65,2 +73,3 @@\n-        NativeLibrary nl1 = nativeLibraries.loadLibrary(LIB_NAME);\n-        NativeLibrary nl2 = nativeLibraries.loadLibrary(LIB_NAME);\n+        Path lib = libraryPath();\n+        NativeLibrary nl1 = nativeLibraries.load(lib);\n+        NativeLibrary nl2 = nativeLibraries.load(lib);\n@@ -80,1 +89,1 @@\n-        NativeLibrary nl3 = nativeLibraries.loadLibrary(LIB_NAME);\n+        NativeLibrary nl3 = nativeLibraries.load(lib);\n@@ -89,1 +98,1 @@\n-        NativeLibrary nl = nativeLibraries.loadLibrary(LIB_NAME);\n+        NativeLibrary nl = nativeLibraries.load(libraryPath());\n@@ -96,1 +105,1 @@\n-        NativeLibrary nl = nativeLibraries.loadLibrary(LIB_NAME);\n+        NativeLibrary nl = nativeLibraries.load(libraryPath());\n@@ -104,0 +113,5 @@\n+    public void load(String pathname) {\n+        NativeLibrary nl = nativeLibraries.load(pathname);\n+        assertTrue(nl != null, \"fail to load zip library\");\n+    }\n+\n","filename":"test\/jdk\/jdk\/internal\/loader\/NativeLibraries\/java.base\/jdk\/internal\/loader\/NativeLibrariesTest.java","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"}]}