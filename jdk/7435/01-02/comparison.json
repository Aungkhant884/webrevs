{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2388,1 +2388,1 @@\n-    private final NativeLibraries libraries = NativeLibraries.jniNativeLibraries(this);\n+    private final NativeLibraries libraries = NativeLibraries.newInstance(this);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-        = NativeLibraries.jniNativeLibraries(null);\n+        = NativeLibraries.newInstance(null);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/BootLoader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -40,1 +39,0 @@\n-import java.util.Objects;\n@@ -58,1 +56,1 @@\n-public abstract class NativeLibraries {\n+public final class NativeLibraries {\n@@ -60,2 +58,2 @@\n-    protected final Map<String, NativeLibraryImpl> libraries = new ConcurrentHashMap<>();\n-    protected final ClassLoader loader;\n+    private final Map<String, NativeLibraryImpl> libraries = new ConcurrentHashMap<>();\n+    private final ClassLoader loader;\n@@ -64,1 +62,1 @@\n-    protected final Class<?> caller;      \/\/ may be null\n+    private final Class<?> caller;      \/\/ may be null\n@@ -83,22 +81,2 @@\n-    public static NativeLibraries jniNativeLibraries(ClassLoader loader) {\n-        return new JniNativeLibraries(loader);\n-    }\n-\n-    \/**\n-     * Creates a raw NativeLibraries instance that has the following properties:\n-     * 1. Native libraries loaded in this raw NativeLibraries instance are\n-     *    not JNI native libraries.  Hence JNI_OnLoad and JNI_OnUnload will\n-     *    be ignored.  No support for linking of native method.\n-     * 2. Native libraries not auto-unloaded.  They may be explicitly unloaded\n-     *    via NativeLibraries::unload.\n-     * 3. No relationship with class loaders.\n-     *\n-     * This static factory method is restricted for JDK trusted class use.\n-     *\/\n-    public static NativeLibraries rawNativeLibraries(MethodHandles.Lookup trustedCaller,\n-                                                     boolean searchJavaLibraryPath) {\n-        if (!trustedCaller.hasFullPrivilegeAccess() ||\n-                !VM.isSystemDomainLoader(trustedCaller.lookupClass().getClassLoader())) {\n-            throw new InternalError(trustedCaller + \" does not have access to raw native library loading\");\n-        }\n-        return new RawNativeLibraries(trustedCaller.lookupClass(), searchJavaLibraryPath);\n+    public static NativeLibraries newInstance(ClassLoader loader) {\n+        return new NativeLibraries(loader, loader != null ? null : NativeLibraries.class, loader != null);\n@@ -173,1 +151,72 @@\n-    abstract NativeLibrary loadLibrary(Class<?> fromClass, String name, boolean isBuiltin);\n+    private NativeLibrary loadLibrary(Class<?> fromClass, String name, boolean isBuiltin) {\n+        ClassLoader loader = (fromClass == null) ? null : fromClass.getClassLoader();\n+        if (this.loader != loader) {\n+            throw new InternalError(fromClass.getName() + \" not allowed to load library\");\n+        }\n+\n+        acquireNativeLibraryLock(name);\n+        try {\n+            \/\/ find if this library has already been loaded and registered in this NativeLibraries\n+            NativeLibrary cached = libraries.get(name);\n+            if (cached != null) {\n+                return cached;\n+            }\n+\n+            \/\/ cannot be loaded by other class loaders\n+            if (loadedLibraryNames.contains(name)) {\n+                throw new UnsatisfiedLinkError(\"Native Library \" + name +\n+                        \" already loaded in another classloader\");\n+            }\n+\n+            \/*\n+             * When a library is being loaded, JNI_OnLoad function can cause\n+             * another loadLibrary invocation that should succeed.\n+             *\n+             * Each thread maintains its own stack to hold the list of\n+             * libraries it is loading.\n+             *\n+             * If there is a pending load operation for the library, we\n+             * immediately return success; if the pending load is from\n+             * a different class loader, we raise UnsatisfiedLinkError.\n+             *\/\n+            for (NativeLibraryImpl lib : NativeLibraryContext.current()) {\n+                if (name.equals(lib.name())) {\n+                    if (loader == lib.fromClass.getClassLoader()) {\n+                        return lib;\n+                    } else {\n+                        throw new UnsatisfiedLinkError(\"Native Library \" +\n+                                name + \" is being loaded in another classloader\");\n+                    }\n+                }\n+            }\n+\n+            NativeLibraryImpl lib = new NativeLibraryImpl(fromClass, name, isBuiltin, true);\n+            \/\/ load the native library\n+            NativeLibraryContext.push(lib);\n+            try {\n+                if (!lib.open()) {\n+                    return null;    \/\/ fail to open the native library\n+                }\n+                \/\/ auto unloading is only supported for JNI native libraries\n+                \/\/ loaded by custom class loaders that can be unloaded.\n+                \/\/ built-in class loaders are never unloaded.\n+                boolean autoUnload = !VM.isSystemDomainLoader(loader) && loader != ClassLoaders.appClassLoader();\n+                if (autoUnload) {\n+                    \/\/ register the loaded native library for auto unloading\n+                    \/\/ when the class loader is reclaimed, all native libraries\n+                    \/\/ loaded that class loader will be unloaded.\n+                    \/\/ The entries in the libraries map are not removed since\n+                    \/\/ the entire map will be reclaimed altogether.\n+                    CleanerFactory.cleaner().register(loader, lib.unloader());\n+                }\n+            } finally {\n+                NativeLibraryContext.pop();\n+            }\n+            \/\/ register the loaded native library\n+            loadedLibraryNames.add(name);\n+            libraries.put(name, lib);\n+            return lib;\n+        } finally {\n+            releaseNativeLibraryLock(name);\n+        }\n+    }\n@@ -188,11 +237,0 @@\n-    \/*\n-     * Load a native library from the given file.  Returns null if the given\n-     * library is determined to be non-loadable, which is system-dependent.\n-     *\n-     * @param file the path of the native library\n-     * @throws UnsatisfiedLinkError if any error in loading the native library\n-     *\/\n-    public NativeLibrary loadLibrary(File file) {\n-        return loadLibrary(caller, file);\n-    }\n-\n@@ -218,7 +256,0 @@\n-    \/**\n-     * Unloads the given native library\n-     *\n-     * @param lib native library\n-     *\/\n-    abstract void unload(NativeLibrary lib);\n-\n@@ -243,171 +274,0 @@\n-    static class JniNativeLibraries extends NativeLibraries {\n-        \/\/ All JNI native libraries we've loaded.\n-        private static final Set<String> loadedLibraryNames = ConcurrentHashMap.newKeySet();\n-\n-        private JniNativeLibraries(ClassLoader loader) {\n-            \/\/ for null loader, default the caller to this class and\n-            \/\/ do not search java.library.path\n-            super(loader, loader != null ? null : NativeLibraries.class, loader != null);\n-        }\n-\n-        \/**\n-         * Returns a NativeLibrary of the given name.\n-         *\n-         * @param fromClass the caller class calling System::loadLibrary\n-         * @param name      library name\n-         * @param isBuiltin built-in library\n-         * @throws UnsatisfiedLinkError if the native library has already been loaded\n-         *      and registered in another NativeLibraries\n-         *\/\n-        NativeLibrary loadLibrary(Class<?> fromClass, String name, boolean isBuiltin) {\n-            ClassLoader loader = (fromClass == null) ? null : fromClass.getClassLoader();\n-            if (this.loader != loader) {\n-                throw new InternalError(fromClass.getName() + \" not allowed to load library\");\n-            }\n-\n-            acquireNativeLibraryLock(name);\n-            try {\n-                \/\/ find if this library has already been loaded and registered in this NativeLibraries\n-                NativeLibrary cached = libraries.get(name);\n-                if (cached != null) {\n-                    return cached;\n-                }\n-\n-                \/\/ cannot be loaded by other class loaders\n-                if (loadedLibraryNames.contains(name)) {\n-                    throw new UnsatisfiedLinkError(\"Native Library \" + name +\n-                            \" already loaded in another classloader\");\n-                }\n-\n-                \/*\n-                 * When a library is being loaded, JNI_OnLoad function can cause\n-                 * another loadLibrary invocation that should succeed.\n-                 *\n-                 * Each thread maintains its own stack to hold the list of\n-                 * libraries it is loading.\n-                 *\n-                 * If there is a pending load operation for the library, we\n-                 * immediately return success; if the pending load is from\n-                 * a different class loader, we raise UnsatisfiedLinkError.\n-                 *\/\n-                for (NativeLibraryImpl lib : NativeLibraryContext.current()) {\n-                    if (name.equals(lib.name())) {\n-                        if (loader == lib.fromClass.getClassLoader()) {\n-                            return lib;\n-                        } else {\n-                            throw new UnsatisfiedLinkError(\"Native Library \" +\n-                                    name + \" is being loaded in another classloader\");\n-                        }\n-                    }\n-                }\n-\n-                NativeLibraryImpl lib = new NativeLibraryImpl(fromClass, name, isBuiltin, true);\n-                \/\/ load the native library\n-                NativeLibraryContext.push(lib);\n-                try {\n-                    if (!lib.open()) {\n-                        return null;    \/\/ fail to open the native library\n-                    }\n-                    \/\/ auto unloading is only supported for JNI native libraries\n-                    \/\/ loaded by custom class loaders that can be unloaded.\n-                    \/\/ built-in class loaders are never unloaded.\n-                    boolean autoUnload = !VM.isSystemDomainLoader(loader)\n-                            && loader != ClassLoaders.appClassLoader();\n-                    if (autoUnload) {\n-                        \/\/ register the loaded native library for auto unloading\n-                        \/\/ when the class loader is reclaimed, all native libraries\n-                        \/\/ loaded that class loader will be unloaded.\n-                        \/\/ The entries in the libraries map are not removed since\n-                        \/\/ the entire map will be reclaimed altogether.\n-                        CleanerFactory.cleaner().register(loader, lib.unloader());\n-                    }\n-                } finally {\n-                    NativeLibraryContext.pop();\n-                }\n-                \/\/ register the loaded native library\n-                loadedLibraryNames.add(name);\n-                libraries.put(name, lib);\n-                return lib;\n-            } finally {\n-                releaseNativeLibraryLock(name);\n-            }\n-        }\n-\n-        void unload(NativeLibrary lib) {\n-            throw new UnsupportedOperationException(\"explicit unloading cannot be used with auto unloading\");\n-        }\n-\n-        static boolean unregister(String name) {\n-            return loadedLibraryNames.remove(name);\n-        }\n-    }\n-\n-    \/*\n-     * A RawNativeLibraries instance has no relationship with any class loaders\n-     * and disabled auto unloading.\n-     *\/\n-    static class RawNativeLibraries extends NativeLibraries {\n-        RawNativeLibraries(Class<?> caller, boolean searchJavaLibraryPath) {\n-            super(caller.getClassLoader(), caller, searchJavaLibraryPath);\n-        }\n-\n-        \/**\n-         * Returns a NativeLibrary of the given name.\n-         *\n-         * The loaded library is not auto-unloaded.  JNI_OnLoad and JNI_OnUnload\n-         * are ignored if present.  It has no relationship with class loaders.\n-         *\n-         * This method will load the library regardless whether it has been loaded\n-         * by a classloader via System::loadLibrary.  When a class loader is\n-         * unloaded, if a library is also loaded as a raw native library,\n-         * JNI_Unload will be invoked but the native library may not get unloaded\n-         * by the underlying library loading mechanism such as dlopen\/dlclose\n-         * unless the raw native library is unloaded explicitly.\n-         *\n-         * @param fromClass the caller class\n-         * @param name      library name\n-         * @param isBuiltin built-in library\n-         *\/\n-        NativeLibrary loadLibrary(Class<?> fromClass, String name, boolean isBuiltin) {\n-            if (fromClass != caller) {\n-                throw new InternalError(\"unexpected caller: \" + fromClass + \" trusted \" + caller.getName());\n-            }\n-            acquireNativeLibraryLock(name);\n-            try {\n-                \/\/ find if this library has already been loaded and registered in this NativeLibraries\n-                NativeLibrary cached = libraries.get(name);\n-                if (cached != null) {\n-                    return cached;\n-                }\n-\n-                NativeLibraryImpl lib = new NativeLibraryImpl(fromClass, name, isBuiltin, false);\n-                if (!lib.open()) {\n-                    return null;    \/\/ fail to open the native library\n-                }\n-\n-                libraries.put(name, lib);\n-                return lib;\n-            } finally {\n-                releaseNativeLibraryLock(name);\n-            }\n-        }\n-\n-        \/*\n-         * Unloads the given native library\n-         *\/\n-        void unload(NativeLibrary lib) {\n-            Objects.requireNonNull(lib);\n-            acquireNativeLibraryLock(lib.name());\n-            try {\n-                NativeLibraryImpl nl = libraries.remove(lib.name());\n-                if (nl != lib) {\n-                    throw new IllegalArgumentException(lib.name() + \" not loaded by this NativeLibraries instance\");\n-                }\n-                \/\/ unload the native library and also remove from the global name registry\n-                nl.unloader().run();\n-            } finally {\n-                releaseNativeLibraryLock(lib.name());\n-            }\n-        }\n-    }\n-\n@@ -509,1 +369,1 @@\n-                if (isJNI && !JniNativeLibraries.unregister(name)) {\n+                if (isJNI && !loadedLibraryNames.remove(name)) {\n@@ -536,0 +396,4 @@\n+    \/\/ All native libraries we've loaded.\n+    private static final Set<String> loadedLibraryNames =\n+            ConcurrentHashMap.newKeySet();\n+\n@@ -563,1 +427,1 @@\n-    private static void acquireNativeLibraryLock(String libraryName) {\n+    static void acquireNativeLibraryLock(String libraryName) {\n@@ -578,1 +442,1 @@\n-    private static void releaseNativeLibraryLock(String libraryName) {\n+    static void releaseNativeLibraryLock(String libraryName) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/NativeLibraries.java","additions":86,"deletions":222,"binary":false,"changes":308,"status":"modified"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.loader;\n+\n+import jdk.internal.misc.VM;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.nio.file.Path;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static jdk.internal.loader.NativeLibraries.*;\n+\n+\n+\/**\n+ * RawNativeLibraries has the following properties:\n+ * 1. Native libraries loaded in this RawNativeLibraries instance are\n+ *    not JNI native libraries.  Hence JNI_OnLoad and JNI_OnUnload will\n+ *    be ignored.  No support for linking of native method.\n+ * 2. Native libraries not auto-unloaded.  They may be explicitly unloaded\n+ *    via NativeLibraries::unload.\n+ * 3. No relationship with class loaders.\n+ *\/\n+public final class RawNativeLibraries {\n+    final Map<String, NativeLibraryImpl> libraries = new ConcurrentHashMap<>();\n+    final Class<?> caller;\n+\n+    private RawNativeLibraries(MethodHandles.Lookup trustedCaller) {\n+        this.caller = trustedCaller.lookupClass();\n+    }\n+\n+    \/**\n+     * Creates a RawNativeLibraries instance that has no relationship with\n+     * any class loaders and disabled auto unloading.\n+     *\n+     * This static factory method is restricted for JDK trusted class use.\n+     *\/\n+    public static RawNativeLibraries newInstance(MethodHandles.Lookup trustedCaller) {\n+        if (!trustedCaller.hasFullPrivilegeAccess() ||\n+                !VM.isSystemDomainLoader(trustedCaller.lookupClass().getClassLoader())) {\n+            throw new InternalError(trustedCaller + \" does not have access to raw native library loading\");\n+        }\n+        return new RawNativeLibraries(trustedCaller);\n+    }\n+\n+    \/*\n+     * Load a native library from the given path.  Returns null if the given\n+     * library is determined to be non-loadable, which is system-dependent.\n+     *\n+     * @param path the path of the native library\n+     *\/\n+    @SuppressWarnings(\"removal\")\n+    public NativeLibrary load(Path path) {\n+        String name = AccessController.doPrivileged(new PrivilegedAction<>() {\n+            public String run() {\n+                try {\n+                    return path.toRealPath().toString();\n+                } catch (IOException e) {\n+                    return null;\n+                }\n+            }\n+        });\n+        if (name == null) {\n+            return null;\n+        }\n+        return load(name);\n+    }\n+\n+    \/**\n+     * Load a native library of the given pathname, which is platform-specific.\n+     * Returns null if it fails to load the given pathname.\n+     *\n+     * If the given pathname does not contain a name-separator character,\n+     * for example on Unix a slash character, the library search strategy\n+     * is system-dependent for example on Unix, see dlopen.\n+     *\n+     * @apiNote\n+     * The {@code pathname} argument is platform-specific.\n+     * {@link System#mapLibraryName} can be used to convert a name to\n+     * a platform-specific pathname:\n+     * {@snipplet\n+     *     RawNativeLibraries libs = RawNativeLibraries.newInstance(MethodHandles.lookup());\n+     *     NativeLibrary lib = libs.load(System.mapLibraryName(\"blas\"));\n+     * }\n+     *\n+     * @param pathname the pathname of the native library\n+     * @see System#mapLibraryName(String)\n+     *\/\n+    public NativeLibrary load(String pathname) {\n+        acquireNativeLibraryLock(pathname);\n+        try {\n+            \/\/ find if this library has already been loaded and registered\n+            NativeLibrary cached = libraries.get(pathname);\n+            if (cached != null) {\n+                return cached;\n+            }\n+\n+            NativeLibraryImpl lib = new NativeLibraryImpl(caller, pathname, false, false);\n+            if (!lib.open()) {\n+                return null;    \/\/ fail to open the native library\n+            }\n+\n+            libraries.put(pathname, lib);\n+            return lib;\n+        } finally {\n+            releaseNativeLibraryLock(pathname);\n+        }\n+    }\n+\n+    \/*\n+     * Unloads the given native library\n+     *\/\n+    public void unload(NativeLibrary lib) {\n+        Objects.requireNonNull(lib);\n+        acquireNativeLibraryLock(lib.name());\n+        try {\n+            NativeLibraryImpl nl = libraries.remove(lib.name());\n+            if (nl != lib) {\n+                throw new IllegalArgumentException(lib.name() + \" not loaded by this RawNativeLibraries instance\");\n+            }\n+            \/\/ unload the native library and also remove from the global name registry\n+            nl.unloader().run();\n+        } finally {\n+            releaseNativeLibraryLock(lib.name());\n+        }\n+    }\n+}\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/RawNativeLibraries.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import jdk.internal.loader.NativeLibraries;\n@@ -35,0 +34,1 @@\n+import jdk.internal.loader.RawNativeLibraries;\n@@ -43,0 +43,2 @@\n+import sun.security.action.GetPropertyAction;\n+\n@@ -56,1 +58,1 @@\n-        case SysV, LinuxAArch64, MacOsAArch64 -> libLookup(libs -> libs.loadLibrary(\"syslookup\"));\n+        case SysV, LinuxAArch64, MacOsAArch64 -> libLookup(libs -> libs.load(jdkLibraryPath(\"syslookup\")));\n@@ -67,1 +69,1 @@\n-        SymbolLookup lookup = libLookup(libs -> libs.loadLibrary(stdLib.toFile()));\n+        SymbolLookup lookup = libLookup(libs -> libs.load(stdLib));\n@@ -71,2 +73,1 @@\n-\n-            SymbolLookup fallbackLibLookup = libLookup(libs -> libs.loadLibrary(\"WinFallbackLookup\"));\n+            SymbolLookup fallbackLibLookup = libLookup(libs -> libs.load(jdkLibraryPath(\"WinFallbackLookup\")));\n@@ -88,2 +89,2 @@\n-    private static SymbolLookup libLookup(Function<NativeLibraries, NativeLibrary> loader) {\n-        NativeLibrary lib = loader.apply(NativeLibraries.rawNativeLibraries(MethodHandles.lookup(), false));\n+    private static SymbolLookup libLookup(Function<RawNativeLibraries, NativeLibrary> loader) {\n+        NativeLibrary lib = loader.apply(RawNativeLibraries.newInstance(MethodHandles.lookup()));\n@@ -103,0 +104,13 @@\n+    \/*\n+     * Returns the path of the given library name from JDK\n+     *\/\n+    private static Path jdkLibraryPath(String name) {\n+        Path javahome = Path.of(GetPropertyAction.privilegedGetProperty(\"java.home\"));\n+        String lib = switch (CABI.current()) {\n+            case SysV, LinuxAArch64, MacOsAArch64 -> \"lib\";\n+            case Win64 -> \"bin\";\n+        };\n+        String libname = System.mapLibraryName(name);\n+        return javahome.resolve(lib).resolve(libname);\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8240975\n+ * @bug 8240975 8281335\n@@ -44,0 +44,1 @@\n+        \/\/ Verify a native library from test.nativepath\n@@ -58,2 +59,2 @@\n-        \/\/ unload the native library\n-        test.unload();\n+        \/\/ load zip library from JDK\n+        test.load(System.mapLibraryName(\"zip\"));\n","filename":"test\/jdk\/jdk\/internal\/loader\/NativeLibraries\/Main.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.nio.file.Path;\n@@ -53,1 +54,2 @@\n-    private final NativeLibraries nativeLibraries;\n+    private final RawNativeLibraries nativeLibraries;\n+\n@@ -55,1 +57,1 @@\n-        this.nativeLibraries = NativeLibraries.rawNativeLibraries(MethodHandles.lookup(), true);\n+        this.nativeLibraries = RawNativeLibraries.newInstance(MethodHandles.lookup());\n@@ -65,0 +67,5 @@\n+    static Path libraryPath() {\n+        Path lib = Path.of(System.getProperty(\"test.nativepath\"));\n+        return lib.resolve(System.mapLibraryName(LIB_NAME));\n+    }\n+\n@@ -66,2 +73,3 @@\n-        NativeLibrary nl1 = nativeLibraries.loadLibrary(LIB_NAME);\n-        NativeLibrary nl2 = nativeLibraries.loadLibrary(LIB_NAME);\n+        Path lib = libraryPath();\n+        NativeLibrary nl1 = nativeLibraries.load(lib);\n+        NativeLibrary nl2 = nativeLibraries.load(lib);\n@@ -81,1 +89,1 @@\n-        NativeLibrary nl3 = nativeLibraries.loadLibrary(LIB_NAME);\n+        NativeLibrary nl3 = nativeLibraries.load(lib);\n@@ -90,1 +98,1 @@\n-        NativeLibrary nl = nativeLibraries.loadLibrary(LIB_NAME);\n+        NativeLibrary nl = nativeLibraries.load(libraryPath());\n@@ -97,1 +105,1 @@\n-        NativeLibrary nl = nativeLibraries.loadLibrary(LIB_NAME);\n+        NativeLibrary nl = nativeLibraries.load(libraryPath());\n@@ -105,0 +113,5 @@\n+    public void load(String pathname) {\n+        NativeLibrary nl = nativeLibraries.load(pathname);\n+        assertTrue(nl != null, \"fail to load zip library\");\n+    }\n+\n","filename":"test\/jdk\/jdk\/internal\/loader\/NativeLibraries\/java.base\/jdk\/internal\/loader\/NativeLibrariesTest.java","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"}]}