{"files":[{"patch":"@@ -52,11 +52,4 @@\n-  if (top_obj != NULL) {\n-    if (_sp->block_is_obj(top_obj)) {\n-      if (cast_to_oop(top_obj)->is_objArray() || cast_to_oop(top_obj)->is_typeArray()) {\n-        \/\/ An arrayOop is starting on the dirty card - since we do exact\n-        \/\/ store checks for objArrays we are done.\n-      } else {\n-        \/\/ Otherwise, it is possible that the object starting on the dirty\n-        \/\/ card spans the entire card, and that the store happened on a\n-        \/\/ later card.  Figure out where the object ends.\n-        top = top_obj + cast_to_oop(top_obj)->size();\n-      }\n+  if (top_obj != NULL && top_obj < (_sp->toContiguousSpace())->top()) {\n+    if (cast_to_oop(top_obj)->is_objArray() || cast_to_oop(top_obj)->is_typeArray()) {\n+      \/\/ An arrayOop is starting on the dirty card - since we do exact\n+      \/\/ store checks for objArrays we are done.\n@@ -64,1 +57,6 @@\n-      top = top_obj;\n+      \/\/ Otherwise, it is possible that the object starting on the dirty\n+      \/\/ card spans the entire card, and that the store happened on a\n+      \/\/ later card.  Figure out where the object ends.\n+      assert(_sp->block_size(top_obj) == cast_to_oop(top_obj)->size(),\n+             \"Block size and object size mismatch\");\n+      top = top_obj + cast_to_oop(top_obj)->size();\n@@ -67,1 +65,1 @@\n-    assert(top == _sp->end(), \"only case where top_obj == NULL\");\n+    top = (_sp->toContiguousSpace())->top();\n@@ -75,19 +73,15 @@\n-  \/\/ 1. Blocks may or may not be objects.\n-  \/\/ 2. Even when a block_is_obj(), it may not entirely\n-  \/\/    occupy the block if the block quantum is larger than\n-  \/\/    the object size.\n-  \/\/ We can and should try to optimize by calling the non-MemRegion\n-  \/\/ version of oop_iterate() for all but the extremal objects\n-  \/\/ (for which we need to call the MemRegion version of\n-  \/\/ oop_iterate()) To be done post-beta XXX\n-  for (; bottom < top; bottom += _sp->block_size(bottom)) {\n-    \/\/ As in the case of contiguous space above, we'd like to\n-    \/\/ just use the value returned by oop_iterate to increment the\n-    \/\/ current pointer; unfortunately, that won't work in CMS because\n-    \/\/ we'd need an interface change (it seems) to have the space\n-    \/\/ \"adjust the object size\" (for instance pad it up to its\n-    \/\/ block alignment or minimum block size restrictions. XXX\n-    if (_sp->block_is_obj(bottom) &&\n-        !_sp->obj_allocated_since_save_marks(cast_to_oop(bottom))) {\n-      cast_to_oop(bottom)->oop_iterate(_cl, mr);\n-    }\n+  \/\/ Note that this assumption won't hold if we have a concurrent\n+  \/\/ collector in this space, which may have freed up objects after\n+  \/\/ they were dirtied and before the stop-the-world GC that is\n+  \/\/ examining cards here.\n+  assert(bottom < top, \"ought to be at least one obj on a dirty card.\");\n+\n+  if (_boundary != NULL) {\n+    \/\/ We have a boundary outside of which we don't want to look\n+    \/\/ at objects, so create a filtering closure around the\n+    \/\/ oop closure before walking the region.\n+    FilteringClosure filter(_boundary, _cl);\n+    walk_mem_region_with_cl(mr, bottom, top, &filter);\n+  } else {\n+    \/\/ No boundary, simply walk the heap with the oop closure.\n+    walk_mem_region_with_cl(mr, bottom, top, _cl);\n@@ -149,42 +143,0 @@\n-HeapWord* ContiguousSpaceDCTOC::get_actual_top(HeapWord* top,\n-                                               HeapWord* top_obj) {\n-  if (top_obj != NULL && top_obj < (_sp->toContiguousSpace())->top()) {\n-    if (cast_to_oop(top_obj)->is_objArray() || cast_to_oop(top_obj)->is_typeArray()) {\n-      \/\/ An arrayOop is starting on the dirty card - since we do exact\n-      \/\/ store checks for objArrays we are done.\n-    } else {\n-      \/\/ Otherwise, it is possible that the object starting on the dirty\n-      \/\/ card spans the entire card, and that the store happened on a\n-      \/\/ later card.  Figure out where the object ends.\n-      assert(_sp->block_size(top_obj) == cast_to_oop(top_obj)->size(),\n-        \"Block size and object size mismatch\");\n-      top = top_obj + cast_to_oop(top_obj)->size();\n-    }\n-  } else {\n-    top = (_sp->toContiguousSpace())->top();\n-  }\n-  return top;\n-}\n-\n-void ContiguousSpaceDCTOC::walk_mem_region(MemRegion mr,\n-                                           HeapWord* bottom,\n-                                           HeapWord* top) {\n-  \/\/ Note that this assumption won't hold if we have a concurrent\n-  \/\/ collector in this space, which may have freed up objects after\n-  \/\/ they were dirtied and before the stop-the-world GC that is\n-  \/\/ examining cards here.\n-  assert(bottom < top, \"ought to be at least one obj on a dirty card.\");\n-\n-  if (_boundary != NULL) {\n-    \/\/ We have a boundary outside of which we don't want to look\n-    \/\/ at objects, so create a filtering closure around the\n-    \/\/ oop closure before walking the region.\n-    FilteringClosure filter(_boundary, _cl);\n-    walk_mem_region_with_cl(mr, bottom, top, &filter);\n-  } else {\n-    \/\/ No boundary, simply walk the heap with the oop closure.\n-    walk_mem_region_with_cl(mr, bottom, top, _cl);\n-  }\n-\n-}\n-\n@@ -193,18 +145,18 @@\n-#define ContiguousSpaceDCTOC__walk_mem_region_with_cl_DEFN(ClosureType) \\\n-void ContiguousSpaceDCTOC::walk_mem_region_with_cl(MemRegion mr,        \\\n-                                                   HeapWord* bottom,    \\\n-                                                   HeapWord* top,       \\\n-                                                   ClosureType* cl) {   \\\n-  bottom += cast_to_oop(bottom)->oop_iterate_size(cl, mr);              \\\n-  if (bottom < top) {                                                   \\\n-    HeapWord* next_obj = bottom + cast_to_oop(bottom)->size();          \\\n-    while (next_obj < top) {                                            \\\n-      \/* Bottom lies entirely below top, so we can call the *\/          \\\n-      \/* non-memRegion version of oop_iterate below. *\/                 \\\n-      cast_to_oop(bottom)->oop_iterate(cl);                             \\\n-      bottom = next_obj;                                                \\\n-      next_obj = bottom + cast_to_oop(bottom)->size();                  \\\n-    }                                                                   \\\n-    \/* Last object. *\/                                                  \\\n-    cast_to_oop(bottom)->oop_iterate(cl, mr);                           \\\n-  }                                                                     \\\n+#define DirtyCardToOopClosure__walk_mem_region_with_cl_DEFN(ClosureType) \\\n+void DirtyCardToOopClosure::walk_mem_region_with_cl(MemRegion mr,        \\\n+                                                    HeapWord* bottom,    \\\n+                                                    HeapWord* top,       \\\n+                                                    ClosureType* cl) {   \\\n+  bottom += cast_to_oop(bottom)->oop_iterate_size(cl, mr);               \\\n+  if (bottom < top) {                                                    \\\n+    HeapWord* next_obj = bottom + cast_to_oop(bottom)->size();           \\\n+    while (next_obj < top) {                                             \\\n+      \/* Bottom lies entirely below top, so we can call the *\/           \\\n+      \/* non-memRegion version of oop_iterate below. *\/                  \\\n+      cast_to_oop(bottom)->oop_iterate(cl);                              \\\n+      bottom = next_obj;                                                 \\\n+      next_obj = bottom + cast_to_oop(bottom)->size();                   \\\n+    }                                                                    \\\n+    \/* Last object. *\/                                                   \\\n+    cast_to_oop(bottom)->oop_iterate(cl, mr);                            \\\n+  }                                                                      \\\n@@ -216,2 +168,2 @@\n-ContiguousSpaceDCTOC__walk_mem_region_with_cl_DEFN(OopIterateClosure)\n-ContiguousSpaceDCTOC__walk_mem_region_with_cl_DEFN(FilteringClosure)\n+DirtyCardToOopClosure__walk_mem_region_with_cl_DEFN(OopIterateClosure)\n+DirtyCardToOopClosure__walk_mem_region_with_cl_DEFN(FilteringClosure)\n@@ -222,1 +174,1 @@\n-  return new ContiguousSpaceDCTOC(this, cl, boundary);\n+  return new DirtyCardToOopClosure(this, cl, boundary);\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":47,"deletions":95,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -229,9 +229,12 @@\n-\/\/ A MemRegionClosure (ResourceObj) whose \"do_MemRegion\" function applies an\n-\/\/ OopClosure to (the addresses of) all the ref-containing fields that could\n-\/\/ be modified by virtue of the given MemRegion being dirty. (Note that\n-\/\/ because of the imprecise nature of the write barrier, this may iterate\n-\/\/ over oops beyond the region.)\n-\/\/ This base type for dirty card to oop closures handles memory regions\n-\/\/ in non-contiguous spaces with no boundaries, and should be sub-classed\n-\/\/ to support other space types. See ContiguousDCTOC for a sub-class\n-\/\/ that works with ContiguousSpaces.\n+\/\/ A dirty card to oop closure for contiguous spaces (ContiguousSpace and\n+\/\/ sub-classes). It knows how to filter out objects that are outside of the\n+\/\/ _boundary.\n+\/\/ (Note that because of the imprecise nature of the write barrier, this may\n+\/\/ iterate over oops beyond the region.)\n+\/\/\n+\/\/ Assumptions:\n+\/\/ 1. That the actual top of any area in a memory region\n+\/\/    contained by the space is bounded by the end of the contiguous\n+\/\/    region of the space.\n+\/\/ 2. That the space is really made up of objects and not just\n+\/\/    blocks.\n@@ -258,1 +261,1 @@\n-  virtual HeapWord* get_actual_top(HeapWord* top, HeapWord* top_obj);\n+  HeapWord* get_actual_top(HeapWord* top, HeapWord* top_obj);\n@@ -266,1 +269,15 @@\n-  virtual void walk_mem_region(MemRegion mr, HeapWord* bottom, HeapWord* top);\n+  void walk_mem_region(MemRegion mr, HeapWord* bottom, HeapWord* top);\n+\n+  \/\/ Walk the given memory region, from bottom to top, applying\n+  \/\/ the given oop closure to (possibly) all objects found. The\n+  \/\/ given oop closure may or may not be the same as the oop\n+  \/\/ closure with which this closure was created, as it may\n+  \/\/ be a filtering closure which makes use of the _boundary.\n+  \/\/ We offer two signatures, so the FilteringClosure static type is\n+  \/\/ apparent.\n+  void walk_mem_region_with_cl(MemRegion mr,\n+                               HeapWord* bottom, HeapWord* top,\n+                               OopIterateClosure* cl);\n+  void walk_mem_region_with_cl(MemRegion mr,\n+                               HeapWord* bottom, HeapWord* top,\n+                               FilteringClosure* cl);\n@@ -511,39 +528,0 @@\n-\/\/ A dirty card to oop closure for contiguous spaces (ContiguousSpace and\n-\/\/ sub-classes). It knows how to filter out objects that are outside of the\n-\/\/ _boundary.\n-\/\/\n-\/\/ Assumptions:\n-\/\/ 1. That the actual top of any area in a memory region\n-\/\/    contained by the space is bounded by the end of the contiguous\n-\/\/    region of the space.\n-\/\/ 2. That the space is really made up of objects and not just\n-\/\/    blocks.\n-class ContiguousSpaceDCTOC : public DirtyCardToOopClosure {\n-  \/\/ Overrides.\n-  void walk_mem_region(MemRegion mr,\n-                       HeapWord* bottom, HeapWord* top) override;\n-\n-  HeapWord* get_actual_top(HeapWord* top, HeapWord* top_obj) override;\n-\n-  \/\/ Walk the given memory region, from bottom to top, applying\n-  \/\/ the given oop closure to (possibly) all objects found. The\n-  \/\/ given oop closure may or may not be the same as the oop\n-  \/\/ closure with which this closure was created, as it may\n-  \/\/ be a filtering closure which makes use of the _boundary.\n-  \/\/ We offer two signatures, so the FilteringClosure static type is\n-  \/\/ apparent.\n-  void walk_mem_region_with_cl(MemRegion mr,\n-                               HeapWord* bottom, HeapWord* top,\n-                               OopIterateClosure* cl);\n-  void walk_mem_region_with_cl(MemRegion mr,\n-                               HeapWord* bottom, HeapWord* top,\n-                               FilteringClosure* cl);\n-\n-public:\n-  ContiguousSpaceDCTOC(ContiguousSpace* sp, OopIterateClosure* cl,\n-                       HeapWord* boundary) :\n-    DirtyCardToOopClosure(sp, cl, boundary)\n-  {}\n-};\n-\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":28,"deletions":50,"binary":false,"changes":78,"status":"modified"}]}