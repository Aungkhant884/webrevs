{"files":[{"patch":"@@ -4160,1 +4160,1 @@\n-        if (padToWidth > cols) {\n+        if (padToWidth > cols && padToWidth > 0) {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/LineReaderImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.function.Consumer;\n@@ -106,2 +107,2 @@\n-    ConsoleIOContext(JShellTool repl, InputStream cmdin, PrintStream cmdout) throws Exception {\n-        this.allowIncompleteInputs = Boolean.getBoolean(\"jshell.test.allow.incomplete.inputs\");\n+    ConsoleIOContext(JShellTool repl, InputStream cmdin, PrintStream cmdout,\n+                     boolean interactive) throws Exception {\n@@ -119,0 +120,2 @@\n+        boolean allowIncompleteInputs = Boolean.getBoolean(\"jshell.test.allow.incomplete.inputs\");\n+        Consumer<LineReaderImpl> setupReader = r -> {};\n@@ -120,1 +123,11 @@\n-            terminal = new NonSystemInTerminal(nonBlockingInput, cmdout);\n+            if (System.getProperty(\"test.jdk\") != null) {\n+                terminal = new TestTerminal(nonBlockingInput, cmdout);\n+            } else {\n+                Size size = null;\n+                terminal = new ProgrammaticInTerminal(nonBlockingInput, cmdout, interactive,\n+                                                      size);\n+                if (!interactive) {\n+                    setupReader = r -> r.unsetOpt(Option.BRACKETED_PASTE);\n+                    allowIncompleteInputs = true;\n+                }\n+            }\n@@ -128,0 +141,1 @@\n+        this.allowIncompleteInputs = allowIncompleteInputs;\n@@ -182,0 +196,1 @@\n+        setupReader.accept(reader);\n@@ -185,1 +200,1 @@\n-            if (!allowIncompleteInputs && !repl.isComplete(line)) {\n+            if (!ConsoleIOContext.this.allowIncompleteInputs && !repl.isComplete(line)) {\n@@ -233,1 +248,1 @@\n-            return in.readLine(firstLinePrompt);\n+            return in.readLine(firstLine ? firstLinePrompt : continuationPrompt);\n@@ -1255,1 +1270,1 @@\n-    private static final class NonSystemInTerminal extends LineDisciplineTerminal {\n+    private static class ProgrammaticInTerminal extends LineDisciplineTerminal {\n@@ -1257,1 +1272,1 @@\n-        private static final int DEFAULT_HEIGHT = 24;\n+        protected static final int DEFAULT_HEIGHT = 24;\n@@ -1260,0 +1275,10 @@\n+        private final Size bufferSize;\n+\n+        public ProgrammaticInTerminal(InputStream input, OutputStream output,\n+                                       boolean interactive, Size size) throws Exception {\n+            this(input, output, interactive ? \"ansi\" : \"dumb\",\n+                 size != null ? size : new Size(80, DEFAULT_HEIGHT),\n+                 size != null ? size\n+                              : interactive ? new Size(80, DEFAULT_HEIGHT)\n+                                            : new Size(Integer.MAX_VALUE - 1, DEFAULT_HEIGHT));\n+        }\n@@ -1261,2 +1286,3 @@\n-        public NonSystemInTerminal(InputStream input, OutputStream output) throws Exception {\n-            super(\"non-system-in\", \"ansi\", output, Charset.forName(\"UTF-8\"));\n+        protected ProgrammaticInTerminal(InputStream input, OutputStream output,\n+                                         String terminal, Size size, Size bufferSize) throws Exception {\n+            super(\"non-system-in\", terminal, output, Charset.forName(\"UTF-8\"));\n@@ -1267,10 +1293,2 @@\n-            int h = DEFAULT_HEIGHT;\n-            try {\n-                String hp = System.getProperty(\"test.terminal.height\");\n-                if (hp != null && !hp.isEmpty() && System.getProperty(\"test.jdk\") != null) {\n-                    h = Integer.parseInt(hp);\n-                }\n-            } catch (Throwable ex) {\n-                \/\/ ignore\n-            }\n-            setSize(new Size(80, h));\n+            setSize(size);\n+            this.bufferSize = bufferSize;\n@@ -1291,0 +1309,25 @@\n+        @Override\n+        public Size getBufferSize() {\n+            return bufferSize;\n+        }\n+    }\n+\n+    private static final class TestTerminal extends ProgrammaticInTerminal {\n+        private static Size computeSize() {\n+            int h = DEFAULT_HEIGHT;\n+            try {\n+                String hp = System.getProperty(\"test.terminal.height\");\n+                if (hp != null && !hp.isEmpty() && System.getProperty(\"test.jdk\") != null) {\n+                    h = Integer.parseInt(hp);\n+                }\n+            } catch (Throwable ex) {\n+                \/\/ ignore\n+            }\n+            return new Size(80, h);\n+        }\n+        public TestTerminal(InputStream input, OutputStream output) throws Exception {\n+            this(input, output, computeSize());\n+        }\n+        private TestTerminal(InputStream input, OutputStream output, Size size) throws Exception {\n+            super(input, output, \"ansi\", size, size);\n+        }\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/ConsoleIOContext.java","additions":62,"deletions":19,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -141,0 +141,2 @@\n+    private static String PROMPT = \"\\u0005\";\n+    private static String CONTINUATION_PROMPT = \"\\u0006\";\n@@ -161,0 +163,1 @@\n+    final boolean interactiveTerminal;\n@@ -180,1 +183,2 @@\n-            PersistentStorage prefs, Map<String, String> envvars, Locale locale) {\n+            PersistentStorage prefs, Map<String, String> envvars, Locale locale,\n+            boolean interactiveTerminal) {\n@@ -196,0 +200,1 @@\n+        this.interactiveTerminal = interactiveTerminal;\n@@ -977,1 +982,1 @@\n-            try (IOContext in = new ConsoleIOContext(this, cmdin, console)) {\n+            try (IOContext in = new ConsoleIOContext(this, cmdin, console, interactiveTerminal)) {\n@@ -1259,1 +1264,1 @@\n-                    ? testPrompt ? \" \\005\"\n+                    ? testPrompt ? PROMPT\n@@ -1264,1 +1269,1 @@\n-                    ? testPrompt ? \" \\006\"\n+                    ? testPrompt ? CONTINUATION_PROMPT\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/JShellTool.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+    private boolean interactiveTerminal;\n@@ -211,0 +212,6 @@\n+    @Override\n+    public JavaShellToolBuilder interactiveTerminal(boolean terminal) {\n+        this.interactiveTerminal = terminal;\n+        return this;\n+    }\n+\n@@ -224,1 +231,1 @@\n-                userOut, userErr, prefs, vars, locale);\n+                userOut, userErr, prefs, vars, locale, interactiveTerminal);\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/JShellToolBuilder.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -186,0 +186,25 @@\n+    \/**\n+     * Set to true to specify the inputs and outputs are connected to an interactive terminal\n+     * that can interpret the ANSI escape codes. The characters sent to the output streams are\n+     * assumed to be interpreted by a terminal and shown to the user, and the exact order and nature\n+     * of characters sent to the outputs are unspecified.\n+     *\n+     * Set to false to specify a legacy simpler behavior whose output can be parsed by automatic\n+     * tools.\n+     *\n+     * When the input stream for this Java Shell is {@code System.in}, this value is ignored,\n+     * and the behavior is similar to specifying {@code true} in this method, but is more closely\n+     * following the specific terminal connected to {@code System.in}.\n+     *\n+     * @implSpec If this method is not called, the behavior should be\n+     * equivalent to calling {@code interactiveTerminal(false)}.\n+     *\n+     * @param terminal if {@code true}, an terminal that can interpret the ANSI escape codes is\n+     *                 assumed to interpret the output. If {@code false}, a simpler output is selected.\n+     * @return the {@code JavaShellToolBuilder} instance\n+     * @since 17\n+     *\/\n+    default JavaShellToolBuilder interactiveTerminal(boolean terminal) {\n+        return this;\n+    }\n+\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/tool\/JavaShellToolBuilder.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import java.util.Arrays;\n+import java.util.List;\n@@ -51,1 +53,28 @@\n-            byte[] cmdInputData = \"System.out.println(\\\"read: \\\" + System.in.read());\\n\/exit\\n\".getBytes();\n+            doTest(\"System.out.println(\\\"read: \\\" + System.in.read());\",\n+                   \"\\u0005System.out.println(\\\"read: \\\" + System.in.read());\",\n+                   \"read: 97\",\n+                   \"\\u0005\/exit\");\n+            doTest(\"1 + 1\", \"\\u00051 + 1\", \"$1 ==> 2\", \"\\u0005\/exit\");\n+            doTest(\"for (int i = 0; i < 100; i++) {\\nSystem.err.println(i);\\n}\\n\",\n+                   \"\\u0005for (int i = 0; i < 100; i++) {\",\n+                   \"\\u0006System.err.println(i);\", \"\\u0006}\",\n+                   \"\\u0005\/exit\");\n+            StringBuilder longInput = new StringBuilder();\n+            String constant = \"1_______________1\";\n+            longInput.append(constant);\n+            for (int i = 0; i < 100; i++) {\n+                longInput.append(\" + \");\n+                longInput.append(constant);\n+            }\n+            doTest(longInput.toString(), \"\\u0005\" + longInput);\n+        } finally {\n+            System.setProperty(TEST_JDK, testJdk);\n+        }\n+    }\n+\n+    private void doTest(String code, String... expectedLines) throws Exception {\n+        doTest(false, code, expectedLines);\n+    }\n+\n+    private void doTest(boolean interactiveTerminal, String code, String... expectedLines) throws Exception {\n+            byte[] cmdInputData = (code + \"\\n\/exit\\n\").getBytes();\n@@ -59,1 +88,2 @@\n-                    .out(printOut, new PrintStream(new ByteArrayOutputStream()), printOut)\n+                    .out(printOut, printOut, printOut)\n+                    .interactiveTerminal(interactiveTerminal)\n@@ -63,1 +93,0 @@\n-            String expected = \"read: 97\";\n@@ -65,0 +94,1 @@\n+            List<String> actualLines = Arrays.asList(actual.split(\"\\\\R\"));\n@@ -66,2 +96,23 @@\n-            assertTrue(actual.contains(expected),\n-                        \"actual:\\n\" + actual + \"\\n, expected:\\n\" + expected);\n+            for (String expectedLine : expectedLines) {\n+                assertTrue(actualLines.contains(expectedLine),\n+                            \"actual:\\n\" + actualLines + \"\\n, expected:\\n\" + expectedLine);\n+            }\n+    }\n+\n+    public void checkInteractiveTerminal() throws Exception {\n+        String testJdk = System.getProperty(TEST_JDK);\n+        try {\n+            System.clearProperty(TEST_JDK);\n+\n+            \/\/note the exact format of the output is not specified here, and the test mostly validates\n+            \/\/the current behavior, and shows the output changes based on the interactiveTerminal setting:\n+            doTest(true,\n+                   \"System.out.println(\\\"read: \\\" + System.in.read());\",\n+                   \"\\u001b[?2004h\\u0005System.out.println(\\\"read: \\\" + System.in.read()\\u001b[2D\\u001b[2C)\\u001b[29D\\u001b[29C;\",\n+                   \"\\u001b[?2004lread: 97\",\n+                   \"\\u001b[?2004h\\u0005\/exit\");\n+            doTest(true,\n+                   \"1 + 1\",\n+                   \"\\u001b[?2004h\\u00051 + 1\",\n+                   \"\\u001b[?2004l$1 ==> 2\",\n+                   \"\\u001b[?2004h\\u0005\/exit\");\n@@ -72,1 +123,0 @@\n-\n@@ -74,1 +124,0 @@\n-\n","filename":"test\/langtools\/jdk\/jshell\/CustomInputToolBuilder.java","additions":56,"deletions":7,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ *     jdk.jshell\/jdk.internal.jshell.tool:open\n","filename":"test\/langtools\/jdk\/jshell\/HistoryUITest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ *     jdk.jshell\/jdk.internal.jshell.tool:open\n","filename":"test\/langtools\/jdk\/jshell\/IndentUITest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ *     jdk.jshell\/jdk.internal.jshell.tool:open\n","filename":"test\/langtools\/jdk\/jshell\/PasteAndMeasurementsUITest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ *     jdk.jshell\/jdk.internal.jshell.tool:open\n","filename":"test\/langtools\/jdk\/jshell\/ToolMultilineSnippetHistoryTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ *     jdk.jshell\/jdk.internal.jshell.tool:open\n","filename":"test\/langtools\/jdk\/jshell\/ToolShiftTabTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ *     jdk.jshell\/jdk.internal.jshell.tool:open\n","filename":"test\/langtools\/jdk\/jshell\/ToolTabCommandTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- *     jdk.jshell\/jdk.internal.jshell.tool\n+ *     jdk.jshell\/jdk.internal.jshell.tool:+open\n","filename":"test\/langtools\/jdk\/jshell\/ToolTabSnippetTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.lang.reflect.Field;\n@@ -111,0 +112,7 @@\n+            Class<?> jshellToolClass = Class.forName(\"jdk.internal.jshell.tool.JShellTool\");\n+            Field promptField = jshellToolClass.getDeclaredField(\"PROMPT\");\n+            promptField.setAccessible(true);\n+            promptField.set(null, PROMPT);\n+            Field continuationPromptField = jshellToolClass.getDeclaredField(\"CONTINUATION_PROMPT\");\n+            continuationPromptField.setAccessible(true);\n+            continuationPromptField.set(null, CONTINUATION_PROMPT);\n","filename":"test\/langtools\/jdk\/jshell\/UITesting.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"}]}