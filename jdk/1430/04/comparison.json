{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -31,0 +33,1 @@\n+import org.openjdk.jmh.annotations.Setup;\n@@ -32,2 +35,2 @@\n-\n-import java.nio.ByteBuffer;\n+import org.openjdk.jmh.annotations.Warmup;\n+import java.nio.*;\n@@ -35,0 +38,1 @@\n+import static java.nio.ByteOrder.*;\n@@ -37,1 +41,11 @@\n- * Benchmark operations on java.nio.Buffer.\n+ * Benchmark for memory access operations on java.nio.Buffer ( and its views )\n+ *\n+ * A large number of variants are covered. The individual benchmarks conform to\n+ * the following convention:\n+ *   test(Direct|Heap)(Bulk|Loop)(Get|Put)(Byte|Char|Short|Int|Long|Float|Double)(Swap)?(RO)?\n+ *\n+ * This allows to easily run a subset of particular interest. For example:\n+ *   Direct only :- \"org.openjdk.bench.java.nio.ByteBuffers.testDirect.*\"\n+ *   Bulk only   :- \"org.openjdk.bench.java.nio.ByteBuffers.test.*Bulk.*\"\n+ *   Loop Put Swapped Views: -\n+ *      test(Direct|Heap)(Loop)(Put)Byte(View)+(Swap)+\"\n@@ -40,0 +54,2 @@\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n@@ -42,0 +58,1 @@\n+@Fork(3)\n@@ -44,1 +61,3 @@\n-    @Param({\"10\", \"1000\", \"100000\"})\n+    static final int CARRIER_BYTE_WIDTH = 1;\n+\n+    @Param({\"16\", \"1024\", \"131072\"})\n@@ -47,7 +66,322 @@\n-    public byte dummyByte;\n-    public char dummyChar;\n-    public short dummyShort;\n-    public int dummyInt;\n-    public long dummyLong;\n-    public float dummyFloat;\n-    public double dummyDouble;\n+    public byte byteValue;\n+    public char charValue;\n+    public short shortValue;\n+    public int intValue;\n+    public long longValue;\n+    public float floatValue;\n+    public double doubleValue;\n+    public byte[] byteArray;\n+\n+    public ByteBuffer heapByteBuffer;\n+    public ByteBuffer heapByteBufferRO;\n+    public ByteBuffer directByteBuffer;\n+    public ByteBuffer directByteBufferRO;\n+    public ByteBuffer heapByteBufferSwap;\n+    public ByteBuffer heapByteBufferSwapRO;\n+    public ByteBuffer directByteBufferSwap;\n+    public ByteBuffer directByteBufferSwapRO;\n+\n+    @Setup\n+    public void setup() {\n+        byteArray = new byte[size \/ CARRIER_BYTE_WIDTH];\n+\n+        \/\/ explicitly allocated heap carrier buffer\n+        heapByteBuffer = ByteBuffer.allocate(size \/ CARRIER_BYTE_WIDTH);\n+        heapByteBufferRO = ByteBuffer.allocate(size \/ CARRIER_BYTE_WIDTH).asReadOnlyBuffer();\n+\n+        heapByteBufferSwap     = ByteBuffer.allocate(size \/ CARRIER_BYTE_WIDTH).order(LITTLE_ENDIAN);\n+        heapByteBufferSwapRO   = ByteBuffer.allocate(size \/ CARRIER_BYTE_WIDTH).order(LITTLE_ENDIAN).asReadOnlyBuffer();\n+        directByteBuffer       = ByteBuffer.allocateDirect(size \/ CARRIER_BYTE_WIDTH);\n+        directByteBufferRO     = ByteBuffer.allocateDirect(size \/ CARRIER_BYTE_WIDTH).asReadOnlyBuffer();\n+        directByteBufferSwap   = ByteBuffer.allocateDirect(size \/ CARRIER_BYTE_WIDTH).order(LITTLE_ENDIAN);\n+        directByteBufferSwapRO = ByteBuffer.allocateDirect(size \/ CARRIER_BYTE_WIDTH).order(LITTLE_ENDIAN).asReadOnlyBuffer();\n+    }\n+\n+\n+    \/\/ -- Heap   \n+\n+    @Benchmark\n+    public byte[] testHeapBulkPutByte() {\n+        heapByteBuffer.put(0, byteArray);\n+        return byteArray;\n+    }\n+\n+    @Benchmark\n+    public byte[] testHeapBulkGetByte() {\n+        heapByteBuffer.get(0, byteArray);\n+        return byteArray;\n+    }\n+\n+    \/\/ -- Heap Byte Swap RO\n+\n+    @Benchmark\n+    public int testHeapLoopGetByteSwapRO() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBufferSwapRO.capacity(); i+=1) {\n+            r += heapByteBufferSwapRO.get(i);\n+        }\n+        return r;\n+    }\n+\n+    \/\/ -- Heap Byte Swap \n+\n+    @Benchmark\n+    public void testHeapLoopPutByteSwap() {\n+        for (int i = 0; i < heapByteBufferSwap.capacity(); i+=1) {\n+            heapByteBufferSwap.put(i, byteValue);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetByteSwap() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBufferSwap.capacity(); i+=1) {\n+            r += heapByteBufferSwap.get(i);\n+        }\n+        return r;\n+    }\n+\n+    \/\/ -- Heap Byte  RO\n+\n+    @Benchmark\n+    public int testHeapLoopGetByteRO() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBufferRO.capacity(); i+=1) {\n+            r += heapByteBufferRO.get(i);\n+        }\n+        return r;\n+    }\n+\n+    \/\/ -- Heap Byte  \n+\n+    @Benchmark\n+    public void testHeapLoopPutByte() {\n+        for (int i = 0; i < heapByteBuffer.capacity(); i+=1) {\n+            heapByteBuffer.put(i, byteValue);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetByte() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBuffer.capacity(); i+=1) {\n+            r += heapByteBuffer.get(i);\n+        }\n+        return r;\n+    }\n+\n+    \/\/ -- Direct Byte Swap RO\n+\n+    @Benchmark\n+    public int testDirectLoopGetByteSwapRO() {\n+        int r = 0;\n+        for (int i = 0; i < directByteBufferSwapRO.capacity(); i+=1) {\n+            r += directByteBufferSwapRO.get(i);\n+        }\n+        return r;\n+    }\n+\n+    \/\/ -- Direct Byte Swap \n+\n+    @Benchmark\n+    public void testDirectLoopPutByteSwap() {\n+        for (int i = 0; i < directByteBufferSwap.capacity(); i+=1) {\n+            directByteBufferSwap.put(i, byteValue);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetByteSwap() {\n+        int r = 0;\n+        for (int i = 0; i < directByteBufferSwap.capacity(); i+=1) {\n+            r += directByteBufferSwap.get(i);\n+        }\n+        return r;\n+    }\n+\n+    \/\/ -- Direct Byte  RO\n+\n+    @Benchmark\n+    public int testDirectLoopGetByteRO() {\n+        int r = 0;\n+        for (int i = 0; i < directByteBufferRO.capacity(); i+=1) {\n+            r += directByteBufferRO.get(i);\n+        }\n+        return r;\n+    }\n+\n+    \/\/ -- Direct Byte  \n+\n+    @Benchmark\n+    public void testDirectLoopPutByte() {\n+        for (int i = 0; i < directByteBuffer.capacity(); i+=1) {\n+            directByteBuffer.put(i, byteValue);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetByte() {\n+        int r = 0;\n+        for (int i = 0; i < directByteBuffer.capacity(); i+=1) {\n+            r += directByteBuffer.get(i);\n+        }\n+        return r;\n+    }\n+\n+    \/\/ -- Heap Char Swap RO\n+\n+    @Benchmark\n+    public int testHeapLoopGetCharSwapRO() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBufferSwapRO.capacity(); i+=2) {\n+            r += heapByteBufferSwapRO.getChar(i);\n+        }\n+        return r;\n+    }\n+\n+    \/\/ -- Heap Char Swap \n+\n+    @Benchmark\n+    public void testHeapLoopPutCharSwap() {\n+        for (int i = 0; i < heapByteBufferSwap.capacity(); i+=2) {\n+            heapByteBufferSwap.putChar(i, charValue);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetCharSwap() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBufferSwap.capacity(); i+=2) {\n+            r += heapByteBufferSwap.getChar(i);\n+        }\n+        return r;\n+    }\n+\n+    \/\/ -- Heap Char  RO\n+\n+    @Benchmark\n+    public int testHeapLoopGetCharRO() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBufferRO.capacity(); i+=2) {\n+            r += heapByteBufferRO.getChar(i);\n+        }\n+        return r;\n+    }\n+\n+    \/\/ -- Heap Char  \n+\n+    @Benchmark\n+    public void testHeapLoopPutChar() {\n+        for (int i = 0; i < heapByteBuffer.capacity(); i+=2) {\n+            heapByteBuffer.putChar(i, charValue);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetChar() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBuffer.capacity(); i+=2) {\n+            r += heapByteBuffer.getChar(i);\n+        }\n+        return r;\n+    }\n+\n+    \/\/ -- Direct Char Swap RO\n+\n+    @Benchmark\n+    public int testDirectLoopGetCharSwapRO() {\n+        int r = 0;\n+        for (int i = 0; i < directByteBufferSwapRO.capacity(); i+=2) {\n+            r += directByteBufferSwapRO.getChar(i);\n+        }\n+        return r;\n+    }\n+\n+    \/\/ -- Direct Char Swap \n+\n+    @Benchmark\n+    public void testDirectLoopPutCharSwap() {\n+        for (int i = 0; i < directByteBufferSwap.capacity(); i+=2) {\n+            directByteBufferSwap.putChar(i, charValue);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetCharSwap() {\n+        int r = 0;\n+        for (int i = 0; i < directByteBufferSwap.capacity(); i+=2) {\n+            r += directByteBufferSwap.getChar(i);\n+        }\n+        return r;\n+    }\n+\n+    \/\/ -- Direct Char  RO\n+\n+    @Benchmark\n+    public int testDirectLoopGetCharRO() {\n+        int r = 0;\n+        for (int i = 0; i < directByteBufferRO.capacity(); i+=2) {\n+            r += directByteBufferRO.getChar(i);\n+        }\n+        return r;\n+    }\n+\n+    \/\/ -- Direct Char  \n+\n+    @Benchmark\n+    public void testDirectLoopPutChar() {\n+        for (int i = 0; i < directByteBuffer.capacity(); i+=2) {\n+            directByteBuffer.putChar(i, charValue);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetChar() {\n+        int r = 0;\n+        for (int i = 0; i < directByteBuffer.capacity(); i+=2) {\n+            r += directByteBuffer.getChar(i);\n+        }\n+        return r;\n+    }\n+\n+    \/\/ -- Heap Short Swap RO\n+\n+    @Benchmark\n+    public int testHeapLoopGetShortSwapRO() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBufferSwapRO.capacity(); i+=2) {\n+            r += heapByteBufferSwapRO.getShort(i);\n+        }\n+        return r;\n+    }\n+\n+    \/\/ -- Heap Short Swap \n+\n+    @Benchmark\n+    public void testHeapLoopPutShortSwap() {\n+        for (int i = 0; i < heapByteBufferSwap.capacity(); i+=2) {\n+            heapByteBufferSwap.putShort(i, shortValue);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetShortSwap() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBufferSwap.capacity(); i+=2) {\n+            r += heapByteBufferSwap.getShort(i);\n+        }\n+        return r;\n+    }\n+\n+    \/\/ -- Heap Short  RO\n+\n+    @Benchmark\n+    public int testHeapLoopGetShortRO() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBufferRO.capacity(); i+=2) {\n+            r += heapByteBufferRO.getShort(i);\n+        }\n+        return r;\n+    }\n+\n+    \/\/ -- Heap Short  \n@@ -55,1 +389,6 @@\n-    \/\/ ---------------- BULK GET TESTS\n+    @Benchmark\n+    public void testHeapLoopPutShort() {\n+        for (int i = 0; i < heapByteBuffer.capacity(); i+=2) {\n+            heapByteBuffer.putShort(i, shortValue);\n+        }\n+    }\n@@ -58,2 +397,6 @@\n-    public byte[] testBulkGet() {\n-        return innerBufferBulkGet(ByteBuffer.allocate(size));\n+    public int testHeapLoopGetShort() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBuffer.capacity(); i+=2) {\n+            r += heapByteBuffer.getShort(i);\n+        }\n+        return r;\n@@ -62,0 +405,2 @@\n+    \/\/ -- Direct Short Swap RO\n+\n@@ -63,2 +408,6 @@\n-    public byte[] testDirectBulkGet() {\n-        return innerBufferBulkGet(ByteBuffer.allocateDirect(size));\n+    public int testDirectLoopGetShortSwapRO() {\n+        int r = 0;\n+        for (int i = 0; i < directByteBufferSwapRO.capacity(); i+=2) {\n+            r += directByteBufferSwapRO.getShort(i);\n+        }\n+        return r;\n@@ -67,1 +416,1 @@\n-    \/\/ ---------------- BULK PUT TESTS\n+    \/\/ -- Direct Short Swap \n@@ -70,2 +419,4 @@\n-    public byte[] testBulkPut() {\n-        return innerBufferBulkPut(ByteBuffer.allocate(size));\n+    public void testDirectLoopPutShortSwap() {\n+        for (int i = 0; i < directByteBufferSwap.capacity(); i+=2) {\n+            directByteBufferSwap.putShort(i, shortValue);\n+        }\n@@ -75,2 +426,6 @@\n-    public byte[] testDirectBulkPut() {\n-        return innerBufferBulkPut(ByteBuffer.allocateDirect(size));\n+    public int testDirectLoopGetShortSwap() {\n+        int r = 0;\n+        for (int i = 0; i < directByteBufferSwap.capacity(); i+=2) {\n+            r += directByteBufferSwap.getShort(i);\n+        }\n+        return r;\n@@ -79,1 +434,1 @@\n-    \/\/ ---------------- SINGLE GET TESTS\n+    \/\/ -- Direct Short  RO\n@@ -82,2 +437,6 @@\n-    public int testSingleGetByte() {\n-        return innerSingleGetByte(ByteBuffer.allocate(1000));\n+    public int testDirectLoopGetShortRO() {\n+        int r = 0;\n+        for (int i = 0; i < directByteBufferRO.capacity(); i+=2) {\n+            r += directByteBufferRO.getShort(i);\n+        }\n+        return r;\n@@ -86,0 +445,2 @@\n+    \/\/ -- Direct Short  \n+\n@@ -87,2 +448,4 @@\n-    public int testSingleGetChar() {\n-        return innerSingleGetChar(ByteBuffer.allocate(1000));\n+    public void testDirectLoopPutShort() {\n+        for (int i = 0; i < directByteBuffer.capacity(); i+=2) {\n+            directByteBuffer.putShort(i, shortValue);\n+        }\n@@ -92,2 +455,6 @@\n-    public int testSingleGetShort() {\n-        return innerSingleGetShort(ByteBuffer.allocate(1000));\n+    public int testDirectLoopGetShort() {\n+        int r = 0;\n+        for (int i = 0; i < directByteBuffer.capacity(); i+=2) {\n+            r += directByteBuffer.getShort(i);\n+        }\n+        return r;\n@@ -96,0 +463,2 @@\n+    \/\/ -- Heap Int Swap RO\n+\n@@ -97,2 +466,6 @@\n-    public int testSingleGetInt() {\n-        return innerSingleGetInt(ByteBuffer.allocate(1000));\n+    public int testHeapLoopGetIntSwapRO() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBufferSwapRO.capacity(); i+=4) {\n+            r += heapByteBufferSwapRO.getInt(i);\n+        }\n+        return r;\n@@ -101,0 +474,2 @@\n+    \/\/ -- Heap Int Swap \n+\n@@ -102,2 +477,4 @@\n-    public long testSingleGetLong() {\n-        return innerSingleGetLong(ByteBuffer.allocate(1000));\n+    public void testHeapLoopPutIntSwap() {\n+        for (int i = 0; i < heapByteBufferSwap.capacity(); i+=4) {\n+            heapByteBufferSwap.putInt(i, intValue);\n+        }\n@@ -107,2 +484,6 @@\n-    public float testSingleGetFloat() {\n-        return innerSingleGetFloat(ByteBuffer.allocate(1000));\n+    public int testHeapLoopGetIntSwap() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBufferSwap.capacity(); i+=4) {\n+            r += heapByteBufferSwap.getInt(i);\n+        }\n+        return r;\n@@ -111,0 +492,2 @@\n+    \/\/ -- Heap Int  RO\n+\n@@ -112,2 +495,6 @@\n-    public double testSingleGetDouble() {\n-        return innerSingleGetDouble(ByteBuffer.allocate(1000));\n+    public int testHeapLoopGetIntRO() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBufferRO.capacity(); i+=4) {\n+            r += heapByteBufferRO.getInt(i);\n+        }\n+        return r;\n@@ -116,0 +503,2 @@\n+    \/\/ -- Heap Int  \n+\n@@ -117,2 +506,4 @@\n-    public int testDirectSingleGetByte() {\n-        return innerSingleGetByte(ByteBuffer.allocateDirect(1000));\n+    public void testHeapLoopPutInt() {\n+        for (int i = 0; i < heapByteBuffer.capacity(); i+=4) {\n+            heapByteBuffer.putInt(i, intValue);\n+        }\n@@ -122,2 +513,6 @@\n-    public int testDirectSingleGetChar() {\n-        return innerSingleGetChar(ByteBuffer.allocateDirect(1000));\n+    public int testHeapLoopGetInt() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBuffer.capacity(); i+=4) {\n+            r += heapByteBuffer.getInt(i);\n+        }\n+        return r;\n@@ -126,0 +521,2 @@\n+    \/\/ -- Direct Int Swap RO\n+\n@@ -127,2 +524,6 @@\n-    public int testDirectSingleGetShort() {\n-        return innerSingleGetShort(ByteBuffer.allocateDirect(1000));\n+    public int testDirectLoopGetIntSwapRO() {\n+        int r = 0;\n+        for (int i = 0; i < directByteBufferSwapRO.capacity(); i+=4) {\n+            r += directByteBufferSwapRO.getInt(i);\n+        }\n+        return r;\n@@ -131,0 +532,2 @@\n+    \/\/ -- Direct Int Swap \n+\n@@ -132,2 +535,4 @@\n-    public int testDirectSingleGetInt() {\n-        return innerSingleGetInt(ByteBuffer.allocateDirect(1000));\n+    public void testDirectLoopPutIntSwap() {\n+        for (int i = 0; i < directByteBufferSwap.capacity(); i+=4) {\n+            directByteBufferSwap.putInt(i, intValue);\n+        }\n@@ -137,2 +542,6 @@\n-    public long testDirectSingleGetLong() {\n-        return innerSingleGetLong(ByteBuffer.allocateDirect(1000));\n+    public int testDirectLoopGetIntSwap() {\n+        int r = 0;\n+        for (int i = 0; i < directByteBufferSwap.capacity(); i+=4) {\n+            r += directByteBufferSwap.getInt(i);\n+        }\n+        return r;\n@@ -141,0 +550,2 @@\n+    \/\/ -- Direct Int  RO\n+\n@@ -142,2 +553,15 @@\n-    public float testDirectSingleGetFloat() {\n-        return innerSingleGetFloat(ByteBuffer.allocateDirect(1000));\n+    public int testDirectLoopGetIntRO() {\n+        int r = 0;\n+        for (int i = 0; i < directByteBufferRO.capacity(); i+=4) {\n+            r += directByteBufferRO.getInt(i);\n+        }\n+        return r;\n+    }\n+\n+    \/\/ -- Direct Int  \n+\n+    @Benchmark\n+    public void testDirectLoopPutInt() {\n+        for (int i = 0; i < directByteBuffer.capacity(); i+=4) {\n+            directByteBuffer.putInt(i, intValue);\n+        }\n@@ -147,2 +571,46 @@\n-    public double testDirectSingleGetDouble() {\n-        return innerSingleGetDouble(ByteBuffer.allocateDirect(1000));\n+    public int testDirectLoopGetInt() {\n+        int r = 0;\n+        for (int i = 0; i < directByteBuffer.capacity(); i+=4) {\n+            r += directByteBuffer.getInt(i);\n+        }\n+        return r;\n+    }\n+\n+    \/\/ -- Heap Long Swap RO\n+\n+    @Benchmark\n+    public int testHeapLoopGetLongSwapRO() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBufferSwapRO.capacity(); i+=8) {\n+            r += heapByteBufferSwapRO.getLong(i);\n+        }\n+        return r;\n+    }\n+\n+    \/\/ -- Heap Long Swap \n+\n+    @Benchmark\n+    public void testHeapLoopPutLongSwap() {\n+        for (int i = 0; i < heapByteBufferSwap.capacity(); i+=8) {\n+            heapByteBufferSwap.putLong(i, longValue);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetLongSwap() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBufferSwap.capacity(); i+=8) {\n+            r += heapByteBufferSwap.getLong(i);\n+        }\n+        return r;\n+    }\n+\n+    \/\/ -- Heap Long  RO\n+\n+    @Benchmark\n+    public int testHeapLoopGetLongRO() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBufferRO.capacity(); i+=8) {\n+            r += heapByteBufferRO.getLong(i);\n+        }\n+        return r;\n@@ -151,1 +619,1 @@\n-    \/\/ ---------------- SINGLE PUT TESTS\n+    \/\/ -- Heap Long  \n@@ -154,2 +622,4 @@\n-    public void testSinglePutByte() {\n-        innerSinglePutByte(ByteBuffer.allocate(1000));\n+    public void testHeapLoopPutLong() {\n+        for (int i = 0; i < heapByteBuffer.capacity(); i+=8) {\n+            heapByteBuffer.putLong(i, longValue);\n+        }\n@@ -159,2 +629,6 @@\n-    public void testSinglePutChar() {\n-        innerSinglePutChar(ByteBuffer.allocate(1000));\n+    public int testHeapLoopGetLong() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBuffer.capacity(); i+=8) {\n+            r += heapByteBuffer.getLong(i);\n+        }\n+        return r;\n@@ -163,0 +637,2 @@\n+    \/\/ -- Direct Long Swap RO\n+\n@@ -164,2 +640,6 @@\n-    public void testSinglePutShort() {\n-        innerSinglePutShort(ByteBuffer.allocate(1000));\n+    public int testDirectLoopGetLongSwapRO() {\n+        int r = 0;\n+        for (int i = 0; i < directByteBufferSwapRO.capacity(); i+=8) {\n+            r += directByteBufferSwapRO.getLong(i);\n+        }\n+        return r;\n@@ -168,0 +648,2 @@\n+    \/\/ -- Direct Long Swap \n+\n@@ -169,2 +651,4 @@\n-    public void testSinglePutInt() {\n-        innerSinglePutInt(ByteBuffer.allocate(1000));\n+    public void testDirectLoopPutLongSwap() {\n+        for (int i = 0; i < directByteBufferSwap.capacity(); i+=8) {\n+            directByteBufferSwap.putLong(i, longValue);\n+        }\n@@ -174,2 +658,6 @@\n-    public void testSinglePutLong() {\n-        innerSinglePutLong(ByteBuffer.allocate(1000));\n+    public int testDirectLoopGetLongSwap() {\n+        int r = 0;\n+        for (int i = 0; i < directByteBufferSwap.capacity(); i+=8) {\n+            r += directByteBufferSwap.getLong(i);\n+        }\n+        return r;\n@@ -178,0 +666,2 @@\n+    \/\/ -- Direct Long  RO\n+\n@@ -179,2 +669,6 @@\n-    public void testSinglePutFloat() {\n-        innerSinglePutFloat(ByteBuffer.allocate(1000));\n+    public int testDirectLoopGetLongRO() {\n+        int r = 0;\n+        for (int i = 0; i < directByteBufferRO.capacity(); i+=8) {\n+            r += directByteBufferRO.getLong(i);\n+        }\n+        return r;\n@@ -183,0 +677,2 @@\n+    \/\/ -- Direct Long  \n+\n@@ -184,2 +680,4 @@\n-    public void testSinglePutDouble() {\n-        innerSinglePutDouble(ByteBuffer.allocate(1000));\n+    public void testDirectLoopPutLong() {\n+        for (int i = 0; i < directByteBuffer.capacity(); i+=8) {\n+            directByteBuffer.putLong(i, longValue);\n+        }\n@@ -189,2 +687,6 @@\n-    public void testDirectSinglePutByte() {\n-        innerSinglePutByte(ByteBuffer.allocateDirect(1000));\n+    public int testDirectLoopGetLong() {\n+        int r = 0;\n+        for (int i = 0; i < directByteBuffer.capacity(); i+=8) {\n+            r += directByteBuffer.getLong(i);\n+        }\n+        return r;\n@@ -193,0 +695,2 @@\n+    \/\/ -- Heap Float Swap RO\n+\n@@ -194,2 +698,6 @@\n-    public void testDirectSinglePutChar() {\n-        innerSinglePutChar(ByteBuffer.allocateDirect(1000));\n+    public int testHeapLoopGetFloatSwapRO() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBufferSwapRO.capacity(); i+=4) {\n+            r += heapByteBufferSwapRO.getFloat(i);\n+        }\n+        return r;\n@@ -198,0 +706,2 @@\n+    \/\/ -- Heap Float Swap \n+\n@@ -199,2 +709,4 @@\n-    public void testDirectSinglePutShort() {\n-        innerSinglePutShort(ByteBuffer.allocateDirect(1000));\n+    public void testHeapLoopPutFloatSwap() {\n+        for (int i = 0; i < heapByteBufferSwap.capacity(); i+=4) {\n+            heapByteBufferSwap.putFloat(i, floatValue);\n+        }\n@@ -204,2 +716,6 @@\n-    public void testDirectSinglePutInt() {\n-        innerSinglePutInt(ByteBuffer.allocateDirect(1000));\n+    public int testHeapLoopGetFloatSwap() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBufferSwap.capacity(); i+=4) {\n+            r += heapByteBufferSwap.getFloat(i);\n+        }\n+        return r;\n@@ -208,0 +724,2 @@\n+    \/\/ -- Heap Float  RO\n+\n@@ -209,2 +727,6 @@\n-    public void testDirectSinglePutLong() {\n-        innerSinglePutLong(ByteBuffer.allocateDirect(1000));\n+    public int testHeapLoopGetFloatRO() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBufferRO.capacity(); i+=4) {\n+            r += heapByteBufferRO.getFloat(i);\n+        }\n+        return r;\n@@ -213,0 +735,2 @@\n+    \/\/ -- Heap Float  \n+\n@@ -214,2 +738,4 @@\n-    public void testDirectSinglePutFloat() {\n-        innerSinglePutFloat(ByteBuffer.allocateDirect(1000));\n+    public void testHeapLoopPutFloat() {\n+        for (int i = 0; i < heapByteBuffer.capacity(); i+=4) {\n+            heapByteBuffer.putFloat(i, floatValue);\n+        }\n@@ -219,2 +745,6 @@\n-    public void testDirectSinglePutDouble() {\n-        innerSinglePutDouble(ByteBuffer.allocateDirect(1000));\n+    public int testHeapLoopGetFloat() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBuffer.capacity(); i+=4) {\n+            r += heapByteBuffer.getFloat(i);\n+        }\n+        return r;\n@@ -223,1 +753,1 @@\n-    \/\/ ---------------- HELPER METHODS\n+    \/\/ -- Direct Float Swap RO\n@@ -225,5 +755,7 @@\n-    private byte[] innerBufferBulkGet(ByteBuffer bb) {\n-        byte[] dummyByteArray = new byte[bb.capacity()];\n-        bb.get(dummyByteArray);\n-        bb.flip();\n-        return dummyByteArray;\n+    @Benchmark\n+    public int testDirectLoopGetFloatSwapRO() {\n+        int r = 0;\n+        for (int i = 0; i < directByteBufferSwapRO.capacity(); i+=4) {\n+            r += directByteBufferSwapRO.getFloat(i);\n+        }\n+        return r;\n@@ -232,5 +764,7 @@\n-    private byte[] innerBufferBulkPut(ByteBuffer bb) {\n-        byte[] dummyByteArray = new byte[bb.capacity()];\n-        bb.put(dummyByteArray);\n-        bb.flip();\n-        return dummyByteArray;\n+    \/\/ -- Direct Float Swap \n+\n+    @Benchmark\n+    public void testDirectLoopPutFloatSwap() {\n+        for (int i = 0; i < directByteBufferSwap.capacity(); i+=4) {\n+            directByteBufferSwap.putFloat(i, floatValue);\n+        }\n@@ -239,1 +773,2 @@\n-    private int innerSingleGetByte(ByteBuffer bb) {\n+    @Benchmark\n+    public int testDirectLoopGetFloatSwap() {\n@@ -241,2 +776,2 @@\n-        for (int i = 0; i < bb.capacity(); i++) {\n-            r += bb.get(i);\n+        for (int i = 0; i < directByteBufferSwap.capacity(); i+=4) {\n+            r += directByteBufferSwap.getFloat(i);\n@@ -247,1 +782,4 @@\n-    private int innerSingleGetChar(ByteBuffer bb) {\n+    \/\/ -- Direct Float  RO\n+\n+    @Benchmark\n+    public int testDirectLoopGetFloatRO() {\n@@ -249,2 +787,2 @@\n-        for (int i = 0; i < bb.capacity(); i += 2) {\n-            r += bb.getChar(i);\n+        for (int i = 0; i < directByteBufferRO.capacity(); i+=4) {\n+            r += directByteBufferRO.getFloat(i);\n@@ -255,1 +793,11 @@\n-    private int innerSingleGetShort(ByteBuffer bb) {\n+    \/\/ -- Direct Float  \n+\n+    @Benchmark\n+    public void testDirectLoopPutFloat() {\n+        for (int i = 0; i < directByteBuffer.capacity(); i+=4) {\n+            directByteBuffer.putFloat(i, floatValue);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetFloat() {\n@@ -257,2 +805,2 @@\n-        for (int i = 0; i < bb.capacity(); i += 2) {\n-            r += bb.getShort(i);\n+        for (int i = 0; i < directByteBuffer.capacity(); i+=4) {\n+            r += directByteBuffer.getFloat(i);\n@@ -263,1 +811,4 @@\n-    private int innerSingleGetInt(ByteBuffer bb) {\n+    \/\/ -- Heap Double Swap RO\n+\n+    @Benchmark\n+    public int testHeapLoopGetDoubleSwapRO() {\n@@ -265,2 +816,2 @@\n-        for (int i = 0; i < bb.capacity(); i += 4) {\n-            r += bb.getInt(i);\n+        for (int i = 0; i < heapByteBufferSwapRO.capacity(); i+=8) {\n+            r += heapByteBufferSwapRO.getDouble(i);\n@@ -271,4 +822,14 @@\n-    private long innerSingleGetLong(ByteBuffer bb) {\n-        long r = 0;\n-        for (int i = 0; i < bb.capacity(); i += 8) {\n-            r += bb.getLong(i);\n+    \/\/ -- Heap Double Swap \n+\n+    @Benchmark\n+    public void testHeapLoopPutDoubleSwap() {\n+        for (int i = 0; i < heapByteBufferSwap.capacity(); i+=8) {\n+            heapByteBufferSwap.putDouble(i, doubleValue);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetDoubleSwap() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBufferSwap.capacity(); i+=8) {\n+            r += heapByteBufferSwap.getDouble(i);\n@@ -279,4 +840,7 @@\n-    private float innerSingleGetFloat(ByteBuffer bb) {\n-        float r = 0;\n-        for (int i = 0; i < bb.capacity(); i += 4) {\n-            r += bb.getFloat(i);\n+    \/\/ -- Heap Double  RO\n+\n+    @Benchmark\n+    public int testHeapLoopGetDoubleRO() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBufferRO.capacity(); i+=8) {\n+            r += heapByteBufferRO.getDouble(i);\n@@ -287,4 +851,6 @@\n-    private double innerSingleGetDouble(ByteBuffer bb) {\n-        double d = 0;\n-        for (int i = 0; i < bb.capacity(); i += 8) {\n-            d += bb.getDouble(i);\n+    \/\/ -- Heap Double  \n+\n+    @Benchmark\n+    public void testHeapLoopPutDouble() {\n+        for (int i = 0; i < heapByteBuffer.capacity(); i+=8) {\n+            heapByteBuffer.putDouble(i, doubleValue);\n@@ -292,1 +858,0 @@\n-        return d;\n@@ -295,3 +860,5 @@\n-    private void innerSinglePutByte(ByteBuffer bb) {\n-        for (int i = 0; i < bb.capacity(); i++) {\n-            bb.put(i, dummyByte);\n+    @Benchmark\n+    public int testHeapLoopGetDouble() {\n+        int r = 0;\n+        for (int i = 0; i < heapByteBuffer.capacity(); i+=8) {\n+            r += heapByteBuffer.getDouble(i);\n@@ -299,0 +866,1 @@\n+        return r;\n@@ -301,3 +869,7 @@\n-    private void innerSinglePutChar(ByteBuffer bb) {\n-        for (int i = 0; i < bb.capacity(); i += 2) {\n-            bb.putChar(i, dummyChar);\n+    \/\/ -- Direct Double Swap RO\n+\n+    @Benchmark\n+    public int testDirectLoopGetDoubleSwapRO() {\n+        int r = 0;\n+        for (int i = 0; i < directByteBufferSwapRO.capacity(); i+=8) {\n+            r += directByteBufferSwapRO.getDouble(i);\n@@ -305,0 +877,1 @@\n+        return r;\n@@ -307,3 +880,6 @@\n-    private void innerSinglePutShort(ByteBuffer bb) {\n-        for (int i = 0; i < bb.capacity(); i += 2) {\n-            bb.putShort(i, dummyShort);\n+    \/\/ -- Direct Double Swap \n+\n+    @Benchmark\n+    public void testDirectLoopPutDoubleSwap() {\n+        for (int i = 0; i < directByteBufferSwap.capacity(); i+=8) {\n+            directByteBufferSwap.putDouble(i, doubleValue);\n@@ -313,3 +889,5 @@\n-    private void innerSinglePutInt(ByteBuffer bb) {\n-        for (int i = 0; i < bb.capacity(); i += 4) {\n-            bb.putInt(i, dummyInt);\n+    @Benchmark\n+    public int testDirectLoopGetDoubleSwap() {\n+        int r = 0;\n+        for (int i = 0; i < directByteBufferSwap.capacity(); i+=8) {\n+            r += directByteBufferSwap.getDouble(i);\n@@ -317,0 +895,1 @@\n+        return r;\n@@ -319,3 +898,7 @@\n-    private void innerSinglePutLong(ByteBuffer bb) {\n-        for (int i = 0; i < bb.capacity(); i += 8) {\n-            bb.putLong(i, dummyLong);\n+    \/\/ -- Direct Double  RO\n+\n+    @Benchmark\n+    public int testDirectLoopGetDoubleRO() {\n+        int r = 0;\n+        for (int i = 0; i < directByteBufferRO.capacity(); i+=8) {\n+            r += directByteBufferRO.getDouble(i);\n@@ -323,0 +906,1 @@\n+        return r;\n@@ -325,3 +909,6 @@\n-    private void innerSinglePutFloat(ByteBuffer bb) {\n-        for (int i = 0; i < bb.capacity(); i += 4) {\n-            bb.putFloat(i, dummyFloat);\n+    \/\/ -- Direct Double  \n+\n+    @Benchmark\n+    public void testDirectLoopPutDouble() {\n+        for (int i = 0; i < directByteBuffer.capacity(); i+=8) {\n+            directByteBuffer.putDouble(i, doubleValue);\n@@ -331,3 +918,5 @@\n-    private void innerSinglePutDouble(ByteBuffer bb) {\n-        for (int i = 0; i < bb.capacity(); i += 8) {\n-            bb.putDouble(i, dummyDouble);\n+    @Benchmark\n+    public int testDirectLoopGetDouble() {\n+        int r = 0;\n+        for (int i = 0; i < directByteBuffer.capacity(); i+=8) {\n+            r += directByteBuffer.getDouble(i);\n@@ -335,0 +924,1 @@\n+        return r;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/ByteBuffers.java","additions":727,"deletions":137,"binary":false,"changes":864,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n@@ -27,4 +25,0 @@\n-import java.nio.CharBuffer;\n-import java.util.Arrays;\n-import java.util.concurrent.TimeUnit;\n-\n@@ -33,1 +27,2 @@\n-import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -40,0 +35,4 @@\n+import org.openjdk.jmh.annotations.Warmup;\n+import java.nio.*;\n+import java.util.concurrent.TimeUnit;\n+import static java.nio.ByteOrder.*;\n@@ -41,0 +40,13 @@\n+\/**\n+ * Benchmark for memory access operations on java.nio.Buffer ( and its views )\n+ *\n+ * A large number of variants are covered. The individual benchmarks conform to\n+ * the following convention:\n+ *   test(Direct|Heap)(Bulk|Loop)(Get|Put)Char(View)?(Swap)?(RO)?\n+ *\n+ * This allows to easily run a subset of particular interest. For example:\n+ *   Direct only :- \"org.openjdk.bench.java.nio.CharBuffers.testDirect.*\"\n+ *   Bulk only   :- \"org.openjdk.bench.java.nio.CharBuffers.test.*Bulk.*\"\n+ *   Loop Put Swapped Views: -\n+ *      test(Direct|Heap)(Loop)(Put)Char(View)+(Swap)+\"\n+ *\/\n@@ -42,0 +54,2 @@\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n@@ -44,0 +58,1 @@\n+@Fork(3)\n@@ -46,2 +61,40 @@\n-    @Param({\"2\", \"256\", \"16384\"})\n-    public int numChars;\n+    static final int CARRIER_BYTE_WIDTH = 2;\n+\n+    @Param({\"16\", \"1024\", \"131072\"})\n+    private int size;\n+\n+    public char charValue;\n+    public char[] charArray;\n+\n+    public CharBuffer heapCharBuffer;\n+    public CharBuffer heapCharBufferRO;\n+    public CharBuffer heapByteBufferAsCharBufferView;\n+    public CharBuffer heapByteBufferAsCharBufferViewRO;\n+    public CharBuffer heapByteBufferAsCharBufferViewSwap;\n+    public CharBuffer heapByteBufferAsCharBufferViewSwapRO;\n+    public CharBuffer directByteBufferAsCharBufferView;\n+    public CharBuffer directByteBufferAsCharBufferViewRO;\n+    public CharBuffer directByteBufferAsCharBufferViewSwap;\n+    public CharBuffer directByteBufferAsCharBufferViewSwapRO;\n+\n+    @Setup\n+    public void setup() {\n+        charArray = new char[size \/ CARRIER_BYTE_WIDTH];\n+\n+        \/\/ explicitly allocated heap carrier buffer\n+        heapCharBuffer = CharBuffer.allocate(size \/ CARRIER_BYTE_WIDTH);\n+        heapCharBufferRO = CharBuffer.allocate(size \/ CARRIER_BYTE_WIDTH).asReadOnlyBuffer();\n+\n+        \/\/ ByteBuffer views\n+        heapByteBufferAsCharBufferView     = ByteBuffer.allocate(size).order(nativeOrder()).asCharBuffer();\n+        heapByteBufferAsCharBufferViewRO   = ByteBuffer.allocate(size).order(nativeOrder()).asCharBuffer().asReadOnlyBuffer();\n+        directByteBufferAsCharBufferView   = ByteBuffer.allocateDirect(size).order(nativeOrder()).asCharBuffer();\n+        directByteBufferAsCharBufferViewRO = ByteBuffer.allocateDirect(size).order(nativeOrder()).asCharBuffer().asReadOnlyBuffer();\n+\n+        \/\/ endianness swapped\n+        ByteOrder nonNativeOrder = nativeOrder() == BIG_ENDIAN ? LITTLE_ENDIAN : BIG_ENDIAN;\n+        heapByteBufferAsCharBufferViewSwap     = ByteBuffer.allocate(size).order(nonNativeOrder).asCharBuffer();\n+        heapByteBufferAsCharBufferViewSwapRO   = ByteBuffer.allocate(size).order(nonNativeOrder).asCharBuffer().asReadOnlyBuffer();\n+        directByteBufferAsCharBufferViewSwap   = ByteBuffer.allocateDirect(size).order(nonNativeOrder).asCharBuffer();\n+        directByteBufferAsCharBufferViewSwapRO = ByteBuffer.allocateDirect(size).order(nonNativeOrder).asCharBuffer().asReadOnlyBuffer();\n+    }\n@@ -49,2 +102,1 @@\n-    public String str;\n-    public CharBuffer buf;\n+    \/\/ ---------------- HELPER METHODS\n@@ -52,6 +104,81 @@\n-    @Setup(Level.Iteration)\n-    public void createString() {\n-        char[] c = new char[numChars];\n-        Arrays.fill(c, 'X');\n-        str = String.valueOf(c);\n-        buf = CharBuffer.allocate(numChars);\n+    private int innerLoopGetChar(CharBuffer buf) {\n+        int r = 0;\n+        for (int i = 0; i < buf.capacity(); i++) {\n+            r += buf.get(i);\n+        }\n+        return r;\n+    }\n+\n+    private void innerLoopPutChar(CharBuffer buf) {\n+        for (int i = 0; i < buf.capacity(); i++) {\n+            buf.put(i, charValue);\n+        }\n+    }\n+\n+    \/\/ -- Heap   \n+\n+    @Benchmark\n+    public char[] testHeapBulkPutChar() {\n+        heapCharBuffer.put(0, charArray);\n+        return charArray;\n+    }\n+\n+    @Benchmark\n+    public char[] testHeapBulkGetChar() {\n+        heapCharBuffer.get(0, charArray);\n+        return charArray;\n+    }\n+\n+    @Benchmark\n+    public void testHeapLoopPutChar() {\n+        innerLoopPutChar(heapCharBuffer);\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetChar() {\n+        return innerLoopGetChar(heapCharBuffer);\n+    }\n+\n+    \/\/ -- Heap View Swap RO\n+\n+    @Benchmark\n+    public char[] testHeapBulkGetCharViewSwapRO() {\n+        heapByteBufferAsCharBufferViewSwapRO.get(0, charArray);\n+        return charArray;\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetCharViewSwapRO() {\n+        return innerLoopGetChar(heapByteBufferAsCharBufferViewSwapRO);\n+    }\n+\n+    \/\/ -- Heap View Swap \n+\n+    @Benchmark\n+    public char[] testHeapBulkPutCharViewSwap() {\n+        heapByteBufferAsCharBufferViewSwap.put(0, charArray);\n+        return charArray;\n+    }\n+\n+    @Benchmark\n+    public char[] testHeapBulkGetCharViewSwap() {\n+        heapByteBufferAsCharBufferViewSwap.get(0, charArray);\n+        return charArray;\n+    }\n+\n+    @Benchmark\n+    public void testHeapLoopPutCharViewSwap() {\n+        innerLoopPutChar(heapByteBufferAsCharBufferViewSwap);\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetCharViewSwap() {\n+        return innerLoopGetChar(heapByteBufferAsCharBufferViewSwap);\n+    }\n+\n+    \/\/ -- Heap View  RO\n+\n+    @Benchmark\n+    public char[] testHeapBulkGetCharViewRO() {\n+        heapByteBufferAsCharBufferViewRO.get(0, charArray);\n+        return charArray;\n@@ -61,3 +188,2 @@\n-    public CharBuffer putString() {\n-        buf.clear();\n-        return buf.put(str);\n+    public int testHeapLoopGetCharViewRO() {\n+        return innerLoopGetChar(heapByteBufferAsCharBufferViewRO);\n@@ -66,0 +192,97 @@\n+    \/\/ -- Heap View  \n+\n+    @Benchmark\n+    public char[] testHeapBulkPutCharView() {\n+        heapByteBufferAsCharBufferView.put(0, charArray);\n+        return charArray;\n+    }\n+\n+    @Benchmark\n+    public char[] testHeapBulkGetCharView() {\n+        heapByteBufferAsCharBufferView.get(0, charArray);\n+        return charArray;\n+    }\n+\n+    @Benchmark\n+    public void testHeapLoopPutCharView() {\n+        innerLoopPutChar(heapByteBufferAsCharBufferView);\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetCharView() {\n+        return innerLoopGetChar(heapByteBufferAsCharBufferView);\n+    }\n+\n+    \/\/ -- Direct View Swap RO\n+\n+    @Benchmark\n+    public char[] testDirectBulkGetCharViewSwapRO() {\n+        directByteBufferAsCharBufferViewSwapRO.get(0, charArray);\n+        return charArray;\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetCharViewSwapRO() {\n+        return innerLoopGetChar(directByteBufferAsCharBufferViewSwapRO);\n+    }\n+\n+    \/\/ -- Direct View Swap \n+\n+    @Benchmark\n+    public char[] testDirectBulkPutCharViewSwap() {\n+        directByteBufferAsCharBufferViewSwap.put(0, charArray);\n+        return charArray;\n+    }\n+\n+    @Benchmark\n+    public char[] testDirectBulkGetCharViewSwap() {\n+        directByteBufferAsCharBufferViewSwap.get(0, charArray);\n+        return charArray;\n+    }\n+\n+    @Benchmark\n+    public void testDirectLoopPutCharViewSwap() {\n+        innerLoopPutChar(directByteBufferAsCharBufferViewSwap);\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetCharViewSwap() {\n+        return innerLoopGetChar(directByteBufferAsCharBufferViewSwap);\n+    }\n+\n+    \/\/ -- Direct View  RO\n+\n+    @Benchmark\n+    public char[] testDirectBulkGetCharViewRO() {\n+        directByteBufferAsCharBufferViewRO.get(0, charArray);\n+        return charArray;\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetCharViewRO() {\n+        return innerLoopGetChar(directByteBufferAsCharBufferViewRO);\n+    }\n+\n+    \/\/ -- Direct View  \n+\n+    @Benchmark\n+    public char[] testDirectBulkPutCharView() {\n+        directByteBufferAsCharBufferView.put(0, charArray);\n+        return charArray;\n+    }\n+\n+    @Benchmark\n+    public char[] testDirectBulkGetCharView() {\n+        directByteBufferAsCharBufferView.get(0, charArray);\n+        return charArray;\n+    }\n+\n+    @Benchmark\n+    public void testDirectLoopPutCharView() {\n+        innerLoopPutChar(directByteBufferAsCharBufferView);\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetCharView() {\n+        return innerLoopGetChar(directByteBufferAsCharBufferView);\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/CharBuffers.java","additions":245,"deletions":22,"binary":false,"changes":267,"status":"modified"},{"patch":"@@ -0,0 +1,289 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.nio;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import java.nio.*;\n+import java.util.concurrent.TimeUnit;\n+import static java.nio.ByteOrder.*;\n+\n+\/**\n+ * Benchmark for memory access operations on java.nio.Buffer ( and its views )\n+ *\n+ * A large number of variants are covered. The individual benchmarks conform to\n+ * the following convention:\n+ *   test(Direct|Heap)(Bulk|Loop)(Get|Put)Double(View)?(Swap)?(RO)?\n+ *\n+ * This allows to easily run a subset of particular interest. For example:\n+ *   Direct only :- \"org.openjdk.bench.java.nio.DoubleBuffers.testDirect.*\"\n+ *   Bulk only   :- \"org.openjdk.bench.java.nio.DoubleBuffers.test.*Bulk.*\"\n+ *   Loop Put Swapped Views: -\n+ *      test(Direct|Heap)(Loop)(Put)Double(View)+(Swap)+\"\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Fork(3)\n+public class DoubleBuffers {\n+\n+    static final int CARRIER_BYTE_WIDTH = 8;\n+\n+    @Param({\"16\", \"1024\", \"131072\"})\n+    private int size;\n+\n+    public double doubleValue;\n+    public double[] doubleArray;\n+\n+    public DoubleBuffer heapDoubleBuffer;\n+    public DoubleBuffer heapDoubleBufferRO;\n+    public DoubleBuffer heapByteBufferAsDoubleBufferView;\n+    public DoubleBuffer heapByteBufferAsDoubleBufferViewRO;\n+    public DoubleBuffer heapByteBufferAsDoubleBufferViewSwap;\n+    public DoubleBuffer heapByteBufferAsDoubleBufferViewSwapRO;\n+    public DoubleBuffer directByteBufferAsDoubleBufferView;\n+    public DoubleBuffer directByteBufferAsDoubleBufferViewRO;\n+    public DoubleBuffer directByteBufferAsDoubleBufferViewSwap;\n+    public DoubleBuffer directByteBufferAsDoubleBufferViewSwapRO;\n+\n+    @Setup\n+    public void setup() {\n+        doubleArray = new double[size \/ CARRIER_BYTE_WIDTH];\n+\n+        \/\/ explicitly allocated heap carrier buffer\n+        heapDoubleBuffer = DoubleBuffer.allocate(size \/ CARRIER_BYTE_WIDTH);\n+        heapDoubleBufferRO = DoubleBuffer.allocate(size \/ CARRIER_BYTE_WIDTH).asReadOnlyBuffer();\n+\n+        \/\/ ByteBuffer views\n+        heapByteBufferAsDoubleBufferView     = ByteBuffer.allocate(size).order(nativeOrder()).asDoubleBuffer();\n+        heapByteBufferAsDoubleBufferViewRO   = ByteBuffer.allocate(size).order(nativeOrder()).asDoubleBuffer().asReadOnlyBuffer();\n+        directByteBufferAsDoubleBufferView   = ByteBuffer.allocateDirect(size).order(nativeOrder()).asDoubleBuffer();\n+        directByteBufferAsDoubleBufferViewRO = ByteBuffer.allocateDirect(size).order(nativeOrder()).asDoubleBuffer().asReadOnlyBuffer();\n+\n+        \/\/ endianness swapped\n+        ByteOrder nonNativeOrder = nativeOrder() == BIG_ENDIAN ? LITTLE_ENDIAN : BIG_ENDIAN;\n+        heapByteBufferAsDoubleBufferViewSwap     = ByteBuffer.allocate(size).order(nonNativeOrder).asDoubleBuffer();\n+        heapByteBufferAsDoubleBufferViewSwapRO   = ByteBuffer.allocate(size).order(nonNativeOrder).asDoubleBuffer().asReadOnlyBuffer();\n+        directByteBufferAsDoubleBufferViewSwap   = ByteBuffer.allocateDirect(size).order(nonNativeOrder).asDoubleBuffer();\n+        directByteBufferAsDoubleBufferViewSwapRO = ByteBuffer.allocateDirect(size).order(nonNativeOrder).asDoubleBuffer().asReadOnlyBuffer();\n+    }\n+\n+    \/\/ ---------------- HELPER METHODS\n+\n+    private int innerLoopGetDouble(DoubleBuffer buf) {\n+        int r = 0;\n+        for (int i = 0; i < buf.capacity(); i++) {\n+            r += buf.get(i);\n+        }\n+        return r;\n+    }\n+\n+    private void innerLoopPutDouble(DoubleBuffer buf) {\n+        for (int i = 0; i < buf.capacity(); i++) {\n+            buf.put(i, doubleValue);\n+        }\n+    }\n+\n+    \/\/ -- Heap   \n+\n+    @Benchmark\n+    public double[] testHeapBulkPutDouble() {\n+        heapDoubleBuffer.put(0, doubleArray);\n+        return doubleArray;\n+    }\n+\n+    @Benchmark\n+    public double[] testHeapBulkGetDouble() {\n+        heapDoubleBuffer.get(0, doubleArray);\n+        return doubleArray;\n+    }\n+\n+    @Benchmark\n+    public void testHeapLoopPutDouble() {\n+        innerLoopPutDouble(heapDoubleBuffer);\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetDouble() {\n+        return innerLoopGetDouble(heapDoubleBuffer);\n+    }\n+\n+    \/\/ -- Heap View Swap RO\n+\n+    @Benchmark\n+    public double[] testHeapBulkGetDoubleViewSwapRO() {\n+        heapByteBufferAsDoubleBufferViewSwapRO.get(0, doubleArray);\n+        return doubleArray;\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetDoubleViewSwapRO() {\n+        return innerLoopGetDouble(heapByteBufferAsDoubleBufferViewSwapRO);\n+    }\n+\n+    \/\/ -- Heap View Swap \n+\n+    @Benchmark\n+    public double[] testHeapBulkPutDoubleViewSwap() {\n+        heapByteBufferAsDoubleBufferViewSwap.put(0, doubleArray);\n+        return doubleArray;\n+    }\n+\n+    @Benchmark\n+    public double[] testHeapBulkGetDoubleViewSwap() {\n+        heapByteBufferAsDoubleBufferViewSwap.get(0, doubleArray);\n+        return doubleArray;\n+    }\n+\n+    @Benchmark\n+    public void testHeapLoopPutDoubleViewSwap() {\n+        innerLoopPutDouble(heapByteBufferAsDoubleBufferViewSwap);\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetDoubleViewSwap() {\n+        return innerLoopGetDouble(heapByteBufferAsDoubleBufferViewSwap);\n+    }\n+\n+    \/\/ -- Heap View  RO\n+\n+    @Benchmark\n+    public double[] testHeapBulkGetDoubleViewRO() {\n+        heapByteBufferAsDoubleBufferViewRO.get(0, doubleArray);\n+        return doubleArray;\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetDoubleViewRO() {\n+        return innerLoopGetDouble(heapByteBufferAsDoubleBufferViewRO);\n+    }\n+\n+    \/\/ -- Heap View  \n+\n+    @Benchmark\n+    public double[] testHeapBulkPutDoubleView() {\n+        heapByteBufferAsDoubleBufferView.put(0, doubleArray);\n+        return doubleArray;\n+    }\n+\n+    @Benchmark\n+    public double[] testHeapBulkGetDoubleView() {\n+        heapByteBufferAsDoubleBufferView.get(0, doubleArray);\n+        return doubleArray;\n+    }\n+\n+    @Benchmark\n+    public void testHeapLoopPutDoubleView() {\n+        innerLoopPutDouble(heapByteBufferAsDoubleBufferView);\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetDoubleView() {\n+        return innerLoopGetDouble(heapByteBufferAsDoubleBufferView);\n+    }\n+\n+    \/\/ -- Direct View Swap RO\n+\n+    @Benchmark\n+    public double[] testDirectBulkGetDoubleViewSwapRO() {\n+        directByteBufferAsDoubleBufferViewSwapRO.get(0, doubleArray);\n+        return doubleArray;\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetDoubleViewSwapRO() {\n+        return innerLoopGetDouble(directByteBufferAsDoubleBufferViewSwapRO);\n+    }\n+\n+    \/\/ -- Direct View Swap \n+\n+    @Benchmark\n+    public double[] testDirectBulkPutDoubleViewSwap() {\n+        directByteBufferAsDoubleBufferViewSwap.put(0, doubleArray);\n+        return doubleArray;\n+    }\n+\n+    @Benchmark\n+    public double[] testDirectBulkGetDoubleViewSwap() {\n+        directByteBufferAsDoubleBufferViewSwap.get(0, doubleArray);\n+        return doubleArray;\n+    }\n+\n+    @Benchmark\n+    public void testDirectLoopPutDoubleViewSwap() {\n+        innerLoopPutDouble(directByteBufferAsDoubleBufferViewSwap);\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetDoubleViewSwap() {\n+        return innerLoopGetDouble(directByteBufferAsDoubleBufferViewSwap);\n+    }\n+\n+    \/\/ -- Direct View  RO\n+\n+    @Benchmark\n+    public double[] testDirectBulkGetDoubleViewRO() {\n+        directByteBufferAsDoubleBufferViewRO.get(0, doubleArray);\n+        return doubleArray;\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetDoubleViewRO() {\n+        return innerLoopGetDouble(directByteBufferAsDoubleBufferViewRO);\n+    }\n+\n+    \/\/ -- Direct View  \n+\n+    @Benchmark\n+    public double[] testDirectBulkPutDoubleView() {\n+        directByteBufferAsDoubleBufferView.put(0, doubleArray);\n+        return doubleArray;\n+    }\n+\n+    @Benchmark\n+    public double[] testDirectBulkGetDoubleView() {\n+        directByteBufferAsDoubleBufferView.get(0, doubleArray);\n+        return doubleArray;\n+    }\n+\n+    @Benchmark\n+    public void testDirectLoopPutDoubleView() {\n+        innerLoopPutDouble(directByteBufferAsDoubleBufferView);\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetDoubleView() {\n+        return innerLoopGetDouble(directByteBufferAsDoubleBufferView);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/DoubleBuffers.java","additions":289,"deletions":0,"binary":false,"changes":289,"status":"added"},{"patch":"@@ -0,0 +1,289 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.nio;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import java.nio.*;\n+import java.util.concurrent.TimeUnit;\n+import static java.nio.ByteOrder.*;\n+\n+\/**\n+ * Benchmark for memory access operations on java.nio.Buffer ( and its views )\n+ *\n+ * A large number of variants are covered. The individual benchmarks conform to\n+ * the following convention:\n+ *   test(Direct|Heap)(Bulk|Loop)(Get|Put)Float(View)?(Swap)?(RO)?\n+ *\n+ * This allows to easily run a subset of particular interest. For example:\n+ *   Direct only :- \"org.openjdk.bench.java.nio.FloatBuffers.testDirect.*\"\n+ *   Bulk only   :- \"org.openjdk.bench.java.nio.FloatBuffers.test.*Bulk.*\"\n+ *   Loop Put Swapped Views: -\n+ *      test(Direct|Heap)(Loop)(Put)Float(View)+(Swap)+\"\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Fork(3)\n+public class FloatBuffers {\n+\n+    static final int CARRIER_BYTE_WIDTH = 4;\n+\n+    @Param({\"16\", \"1024\", \"131072\"})\n+    private int size;\n+\n+    public float floatValue;\n+    public float[] floatArray;\n+\n+    public FloatBuffer heapFloatBuffer;\n+    public FloatBuffer heapFloatBufferRO;\n+    public FloatBuffer heapByteBufferAsFloatBufferView;\n+    public FloatBuffer heapByteBufferAsFloatBufferViewRO;\n+    public FloatBuffer heapByteBufferAsFloatBufferViewSwap;\n+    public FloatBuffer heapByteBufferAsFloatBufferViewSwapRO;\n+    public FloatBuffer directByteBufferAsFloatBufferView;\n+    public FloatBuffer directByteBufferAsFloatBufferViewRO;\n+    public FloatBuffer directByteBufferAsFloatBufferViewSwap;\n+    public FloatBuffer directByteBufferAsFloatBufferViewSwapRO;\n+\n+    @Setup\n+    public void setup() {\n+        floatArray = new float[size \/ CARRIER_BYTE_WIDTH];\n+\n+        \/\/ explicitly allocated heap carrier buffer\n+        heapFloatBuffer = FloatBuffer.allocate(size \/ CARRIER_BYTE_WIDTH);\n+        heapFloatBufferRO = FloatBuffer.allocate(size \/ CARRIER_BYTE_WIDTH).asReadOnlyBuffer();\n+\n+        \/\/ ByteBuffer views\n+        heapByteBufferAsFloatBufferView     = ByteBuffer.allocate(size).order(nativeOrder()).asFloatBuffer();\n+        heapByteBufferAsFloatBufferViewRO   = ByteBuffer.allocate(size).order(nativeOrder()).asFloatBuffer().asReadOnlyBuffer();\n+        directByteBufferAsFloatBufferView   = ByteBuffer.allocateDirect(size).order(nativeOrder()).asFloatBuffer();\n+        directByteBufferAsFloatBufferViewRO = ByteBuffer.allocateDirect(size).order(nativeOrder()).asFloatBuffer().asReadOnlyBuffer();\n+\n+        \/\/ endianness swapped\n+        ByteOrder nonNativeOrder = nativeOrder() == BIG_ENDIAN ? LITTLE_ENDIAN : BIG_ENDIAN;\n+        heapByteBufferAsFloatBufferViewSwap     = ByteBuffer.allocate(size).order(nonNativeOrder).asFloatBuffer();\n+        heapByteBufferAsFloatBufferViewSwapRO   = ByteBuffer.allocate(size).order(nonNativeOrder).asFloatBuffer().asReadOnlyBuffer();\n+        directByteBufferAsFloatBufferViewSwap   = ByteBuffer.allocateDirect(size).order(nonNativeOrder).asFloatBuffer();\n+        directByteBufferAsFloatBufferViewSwapRO = ByteBuffer.allocateDirect(size).order(nonNativeOrder).asFloatBuffer().asReadOnlyBuffer();\n+    }\n+\n+    \/\/ ---------------- HELPER METHODS\n+\n+    private int innerLoopGetFloat(FloatBuffer buf) {\n+        int r = 0;\n+        for (int i = 0; i < buf.capacity(); i++) {\n+            r += buf.get(i);\n+        }\n+        return r;\n+    }\n+\n+    private void innerLoopPutFloat(FloatBuffer buf) {\n+        for (int i = 0; i < buf.capacity(); i++) {\n+            buf.put(i, floatValue);\n+        }\n+    }\n+\n+    \/\/ -- Heap   \n+\n+    @Benchmark\n+    public float[] testHeapBulkPutFloat() {\n+        heapFloatBuffer.put(0, floatArray);\n+        return floatArray;\n+    }\n+\n+    @Benchmark\n+    public float[] testHeapBulkGetFloat() {\n+        heapFloatBuffer.get(0, floatArray);\n+        return floatArray;\n+    }\n+\n+    @Benchmark\n+    public void testHeapLoopPutFloat() {\n+        innerLoopPutFloat(heapFloatBuffer);\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetFloat() {\n+        return innerLoopGetFloat(heapFloatBuffer);\n+    }\n+\n+    \/\/ -- Heap View Swap RO\n+\n+    @Benchmark\n+    public float[] testHeapBulkGetFloatViewSwapRO() {\n+        heapByteBufferAsFloatBufferViewSwapRO.get(0, floatArray);\n+        return floatArray;\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetFloatViewSwapRO() {\n+        return innerLoopGetFloat(heapByteBufferAsFloatBufferViewSwapRO);\n+    }\n+\n+    \/\/ -- Heap View Swap \n+\n+    @Benchmark\n+    public float[] testHeapBulkPutFloatViewSwap() {\n+        heapByteBufferAsFloatBufferViewSwap.put(0, floatArray);\n+        return floatArray;\n+    }\n+\n+    @Benchmark\n+    public float[] testHeapBulkGetFloatViewSwap() {\n+        heapByteBufferAsFloatBufferViewSwap.get(0, floatArray);\n+        return floatArray;\n+    }\n+\n+    @Benchmark\n+    public void testHeapLoopPutFloatViewSwap() {\n+        innerLoopPutFloat(heapByteBufferAsFloatBufferViewSwap);\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetFloatViewSwap() {\n+        return innerLoopGetFloat(heapByteBufferAsFloatBufferViewSwap);\n+    }\n+\n+    \/\/ -- Heap View  RO\n+\n+    @Benchmark\n+    public float[] testHeapBulkGetFloatViewRO() {\n+        heapByteBufferAsFloatBufferViewRO.get(0, floatArray);\n+        return floatArray;\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetFloatViewRO() {\n+        return innerLoopGetFloat(heapByteBufferAsFloatBufferViewRO);\n+    }\n+\n+    \/\/ -- Heap View  \n+\n+    @Benchmark\n+    public float[] testHeapBulkPutFloatView() {\n+        heapByteBufferAsFloatBufferView.put(0, floatArray);\n+        return floatArray;\n+    }\n+\n+    @Benchmark\n+    public float[] testHeapBulkGetFloatView() {\n+        heapByteBufferAsFloatBufferView.get(0, floatArray);\n+        return floatArray;\n+    }\n+\n+    @Benchmark\n+    public void testHeapLoopPutFloatView() {\n+        innerLoopPutFloat(heapByteBufferAsFloatBufferView);\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetFloatView() {\n+        return innerLoopGetFloat(heapByteBufferAsFloatBufferView);\n+    }\n+\n+    \/\/ -- Direct View Swap RO\n+\n+    @Benchmark\n+    public float[] testDirectBulkGetFloatViewSwapRO() {\n+        directByteBufferAsFloatBufferViewSwapRO.get(0, floatArray);\n+        return floatArray;\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetFloatViewSwapRO() {\n+        return innerLoopGetFloat(directByteBufferAsFloatBufferViewSwapRO);\n+    }\n+\n+    \/\/ -- Direct View Swap \n+\n+    @Benchmark\n+    public float[] testDirectBulkPutFloatViewSwap() {\n+        directByteBufferAsFloatBufferViewSwap.put(0, floatArray);\n+        return floatArray;\n+    }\n+\n+    @Benchmark\n+    public float[] testDirectBulkGetFloatViewSwap() {\n+        directByteBufferAsFloatBufferViewSwap.get(0, floatArray);\n+        return floatArray;\n+    }\n+\n+    @Benchmark\n+    public void testDirectLoopPutFloatViewSwap() {\n+        innerLoopPutFloat(directByteBufferAsFloatBufferViewSwap);\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetFloatViewSwap() {\n+        return innerLoopGetFloat(directByteBufferAsFloatBufferViewSwap);\n+    }\n+\n+    \/\/ -- Direct View  RO\n+\n+    @Benchmark\n+    public float[] testDirectBulkGetFloatViewRO() {\n+        directByteBufferAsFloatBufferViewRO.get(0, floatArray);\n+        return floatArray;\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetFloatViewRO() {\n+        return innerLoopGetFloat(directByteBufferAsFloatBufferViewRO);\n+    }\n+\n+    \/\/ -- Direct View  \n+\n+    @Benchmark\n+    public float[] testDirectBulkPutFloatView() {\n+        directByteBufferAsFloatBufferView.put(0, floatArray);\n+        return floatArray;\n+    }\n+\n+    @Benchmark\n+    public float[] testDirectBulkGetFloatView() {\n+        directByteBufferAsFloatBufferView.get(0, floatArray);\n+        return floatArray;\n+    }\n+\n+    @Benchmark\n+    public void testDirectLoopPutFloatView() {\n+        innerLoopPutFloat(directByteBufferAsFloatBufferView);\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetFloatView() {\n+        return innerLoopGetFloat(directByteBufferAsFloatBufferView);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/FloatBuffers.java","additions":289,"deletions":0,"binary":false,"changes":289,"status":"added"},{"patch":"@@ -0,0 +1,289 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.nio;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import java.nio.*;\n+import java.util.concurrent.TimeUnit;\n+import static java.nio.ByteOrder.*;\n+\n+\/**\n+ * Benchmark for memory access operations on java.nio.Buffer ( and its views )\n+ *\n+ * A large number of variants are covered. The individual benchmarks conform to\n+ * the following convention:\n+ *   test(Direct|Heap)(Bulk|Loop)(Get|Put)Int(View)?(Swap)?(RO)?\n+ *\n+ * This allows to easily run a subset of particular interest. For example:\n+ *   Direct only :- \"org.openjdk.bench.java.nio.IntBuffers.testDirect.*\"\n+ *   Bulk only   :- \"org.openjdk.bench.java.nio.IntBuffers.test.*Bulk.*\"\n+ *   Loop Put Swapped Views: -\n+ *      test(Direct|Heap)(Loop)(Put)Int(View)+(Swap)+\"\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Fork(3)\n+public class IntBuffers {\n+\n+    static final int CARRIER_BYTE_WIDTH = 4;\n+\n+    @Param({\"16\", \"1024\", \"131072\"})\n+    private int size;\n+\n+    public int intValue;\n+    public int[] intArray;\n+\n+    public IntBuffer heapIntBuffer;\n+    public IntBuffer heapIntBufferRO;\n+    public IntBuffer heapByteBufferAsIntBufferView;\n+    public IntBuffer heapByteBufferAsIntBufferViewRO;\n+    public IntBuffer heapByteBufferAsIntBufferViewSwap;\n+    public IntBuffer heapByteBufferAsIntBufferViewSwapRO;\n+    public IntBuffer directByteBufferAsIntBufferView;\n+    public IntBuffer directByteBufferAsIntBufferViewRO;\n+    public IntBuffer directByteBufferAsIntBufferViewSwap;\n+    public IntBuffer directByteBufferAsIntBufferViewSwapRO;\n+\n+    @Setup\n+    public void setup() {\n+        intArray = new int[size \/ CARRIER_BYTE_WIDTH];\n+\n+        \/\/ explicitly allocated heap carrier buffer\n+        heapIntBuffer = IntBuffer.allocate(size \/ CARRIER_BYTE_WIDTH);\n+        heapIntBufferRO = IntBuffer.allocate(size \/ CARRIER_BYTE_WIDTH).asReadOnlyBuffer();\n+\n+        \/\/ ByteBuffer views\n+        heapByteBufferAsIntBufferView     = ByteBuffer.allocate(size).order(nativeOrder()).asIntBuffer();\n+        heapByteBufferAsIntBufferViewRO   = ByteBuffer.allocate(size).order(nativeOrder()).asIntBuffer().asReadOnlyBuffer();\n+        directByteBufferAsIntBufferView   = ByteBuffer.allocateDirect(size).order(nativeOrder()).asIntBuffer();\n+        directByteBufferAsIntBufferViewRO = ByteBuffer.allocateDirect(size).order(nativeOrder()).asIntBuffer().asReadOnlyBuffer();\n+\n+        \/\/ endianness swapped\n+        ByteOrder nonNativeOrder = nativeOrder() == BIG_ENDIAN ? LITTLE_ENDIAN : BIG_ENDIAN;\n+        heapByteBufferAsIntBufferViewSwap     = ByteBuffer.allocate(size).order(nonNativeOrder).asIntBuffer();\n+        heapByteBufferAsIntBufferViewSwapRO   = ByteBuffer.allocate(size).order(nonNativeOrder).asIntBuffer().asReadOnlyBuffer();\n+        directByteBufferAsIntBufferViewSwap   = ByteBuffer.allocateDirect(size).order(nonNativeOrder).asIntBuffer();\n+        directByteBufferAsIntBufferViewSwapRO = ByteBuffer.allocateDirect(size).order(nonNativeOrder).asIntBuffer().asReadOnlyBuffer();\n+    }\n+\n+    \/\/ ---------------- HELPER METHODS\n+\n+    private int innerLoopGetInt(IntBuffer buf) {\n+        int r = 0;\n+        for (int i = 0; i < buf.capacity(); i++) {\n+            r += buf.get(i);\n+        }\n+        return r;\n+    }\n+\n+    private void innerLoopPutInt(IntBuffer buf) {\n+        for (int i = 0; i < buf.capacity(); i++) {\n+            buf.put(i, intValue);\n+        }\n+    }\n+\n+    \/\/ -- Heap   \n+\n+    @Benchmark\n+    public int[] testHeapBulkPutInt() {\n+        heapIntBuffer.put(0, intArray);\n+        return intArray;\n+    }\n+\n+    @Benchmark\n+    public int[] testHeapBulkGetInt() {\n+        heapIntBuffer.get(0, intArray);\n+        return intArray;\n+    }\n+\n+    @Benchmark\n+    public void testHeapLoopPutInt() {\n+        innerLoopPutInt(heapIntBuffer);\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetInt() {\n+        return innerLoopGetInt(heapIntBuffer);\n+    }\n+\n+    \/\/ -- Heap View Swap RO\n+\n+    @Benchmark\n+    public int[] testHeapBulkGetIntViewSwapRO() {\n+        heapByteBufferAsIntBufferViewSwapRO.get(0, intArray);\n+        return intArray;\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetIntViewSwapRO() {\n+        return innerLoopGetInt(heapByteBufferAsIntBufferViewSwapRO);\n+    }\n+\n+    \/\/ -- Heap View Swap \n+\n+    @Benchmark\n+    public int[] testHeapBulkPutIntViewSwap() {\n+        heapByteBufferAsIntBufferViewSwap.put(0, intArray);\n+        return intArray;\n+    }\n+\n+    @Benchmark\n+    public int[] testHeapBulkGetIntViewSwap() {\n+        heapByteBufferAsIntBufferViewSwap.get(0, intArray);\n+        return intArray;\n+    }\n+\n+    @Benchmark\n+    public void testHeapLoopPutIntViewSwap() {\n+        innerLoopPutInt(heapByteBufferAsIntBufferViewSwap);\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetIntViewSwap() {\n+        return innerLoopGetInt(heapByteBufferAsIntBufferViewSwap);\n+    }\n+\n+    \/\/ -- Heap View  RO\n+\n+    @Benchmark\n+    public int[] testHeapBulkGetIntViewRO() {\n+        heapByteBufferAsIntBufferViewRO.get(0, intArray);\n+        return intArray;\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetIntViewRO() {\n+        return innerLoopGetInt(heapByteBufferAsIntBufferViewRO);\n+    }\n+\n+    \/\/ -- Heap View  \n+\n+    @Benchmark\n+    public int[] testHeapBulkPutIntView() {\n+        heapByteBufferAsIntBufferView.put(0, intArray);\n+        return intArray;\n+    }\n+\n+    @Benchmark\n+    public int[] testHeapBulkGetIntView() {\n+        heapByteBufferAsIntBufferView.get(0, intArray);\n+        return intArray;\n+    }\n+\n+    @Benchmark\n+    public void testHeapLoopPutIntView() {\n+        innerLoopPutInt(heapByteBufferAsIntBufferView);\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetIntView() {\n+        return innerLoopGetInt(heapByteBufferAsIntBufferView);\n+    }\n+\n+    \/\/ -- Direct View Swap RO\n+\n+    @Benchmark\n+    public int[] testDirectBulkGetIntViewSwapRO() {\n+        directByteBufferAsIntBufferViewSwapRO.get(0, intArray);\n+        return intArray;\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetIntViewSwapRO() {\n+        return innerLoopGetInt(directByteBufferAsIntBufferViewSwapRO);\n+    }\n+\n+    \/\/ -- Direct View Swap \n+\n+    @Benchmark\n+    public int[] testDirectBulkPutIntViewSwap() {\n+        directByteBufferAsIntBufferViewSwap.put(0, intArray);\n+        return intArray;\n+    }\n+\n+    @Benchmark\n+    public int[] testDirectBulkGetIntViewSwap() {\n+        directByteBufferAsIntBufferViewSwap.get(0, intArray);\n+        return intArray;\n+    }\n+\n+    @Benchmark\n+    public void testDirectLoopPutIntViewSwap() {\n+        innerLoopPutInt(directByteBufferAsIntBufferViewSwap);\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetIntViewSwap() {\n+        return innerLoopGetInt(directByteBufferAsIntBufferViewSwap);\n+    }\n+\n+    \/\/ -- Direct View  RO\n+\n+    @Benchmark\n+    public int[] testDirectBulkGetIntViewRO() {\n+        directByteBufferAsIntBufferViewRO.get(0, intArray);\n+        return intArray;\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetIntViewRO() {\n+        return innerLoopGetInt(directByteBufferAsIntBufferViewRO);\n+    }\n+\n+    \/\/ -- Direct View  \n+\n+    @Benchmark\n+    public int[] testDirectBulkPutIntView() {\n+        directByteBufferAsIntBufferView.put(0, intArray);\n+        return intArray;\n+    }\n+\n+    @Benchmark\n+    public int[] testDirectBulkGetIntView() {\n+        directByteBufferAsIntBufferView.get(0, intArray);\n+        return intArray;\n+    }\n+\n+    @Benchmark\n+    public void testDirectLoopPutIntView() {\n+        innerLoopPutInt(directByteBufferAsIntBufferView);\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetIntView() {\n+        return innerLoopGetInt(directByteBufferAsIntBufferView);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/IntBuffers.java","additions":289,"deletions":0,"binary":false,"changes":289,"status":"added"},{"patch":"@@ -0,0 +1,289 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.nio;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import java.nio.*;\n+import java.util.concurrent.TimeUnit;\n+import static java.nio.ByteOrder.*;\n+\n+\/**\n+ * Benchmark for memory access operations on java.nio.Buffer ( and its views )\n+ *\n+ * A large number of variants are covered. The individual benchmarks conform to\n+ * the following convention:\n+ *   test(Direct|Heap)(Bulk|Loop)(Get|Put)Long(View)?(Swap)?(RO)?\n+ *\n+ * This allows to easily run a subset of particular interest. For example:\n+ *   Direct only :- \"org.openjdk.bench.java.nio.LongBuffers.testDirect.*\"\n+ *   Bulk only   :- \"org.openjdk.bench.java.nio.LongBuffers.test.*Bulk.*\"\n+ *   Loop Put Swapped Views: -\n+ *      test(Direct|Heap)(Loop)(Put)Long(View)+(Swap)+\"\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Fork(3)\n+public class LongBuffers {\n+\n+    static final int CARRIER_BYTE_WIDTH = 8;\n+\n+    @Param({\"16\", \"1024\", \"131072\"})\n+    private int size;\n+\n+    public long longValue;\n+    public long[] longArray;\n+\n+    public LongBuffer heapLongBuffer;\n+    public LongBuffer heapLongBufferRO;\n+    public LongBuffer heapByteBufferAsLongBufferView;\n+    public LongBuffer heapByteBufferAsLongBufferViewRO;\n+    public LongBuffer heapByteBufferAsLongBufferViewSwap;\n+    public LongBuffer heapByteBufferAsLongBufferViewSwapRO;\n+    public LongBuffer directByteBufferAsLongBufferView;\n+    public LongBuffer directByteBufferAsLongBufferViewRO;\n+    public LongBuffer directByteBufferAsLongBufferViewSwap;\n+    public LongBuffer directByteBufferAsLongBufferViewSwapRO;\n+\n+    @Setup\n+    public void setup() {\n+        longArray = new long[size \/ CARRIER_BYTE_WIDTH];\n+\n+        \/\/ explicitly allocated heap carrier buffer\n+        heapLongBuffer = LongBuffer.allocate(size \/ CARRIER_BYTE_WIDTH);\n+        heapLongBufferRO = LongBuffer.allocate(size \/ CARRIER_BYTE_WIDTH).asReadOnlyBuffer();\n+\n+        \/\/ ByteBuffer views\n+        heapByteBufferAsLongBufferView     = ByteBuffer.allocate(size).order(nativeOrder()).asLongBuffer();\n+        heapByteBufferAsLongBufferViewRO   = ByteBuffer.allocate(size).order(nativeOrder()).asLongBuffer().asReadOnlyBuffer();\n+        directByteBufferAsLongBufferView   = ByteBuffer.allocateDirect(size).order(nativeOrder()).asLongBuffer();\n+        directByteBufferAsLongBufferViewRO = ByteBuffer.allocateDirect(size).order(nativeOrder()).asLongBuffer().asReadOnlyBuffer();\n+\n+        \/\/ endianness swapped\n+        ByteOrder nonNativeOrder = nativeOrder() == BIG_ENDIAN ? LITTLE_ENDIAN : BIG_ENDIAN;\n+        heapByteBufferAsLongBufferViewSwap     = ByteBuffer.allocate(size).order(nonNativeOrder).asLongBuffer();\n+        heapByteBufferAsLongBufferViewSwapRO   = ByteBuffer.allocate(size).order(nonNativeOrder).asLongBuffer().asReadOnlyBuffer();\n+        directByteBufferAsLongBufferViewSwap   = ByteBuffer.allocateDirect(size).order(nonNativeOrder).asLongBuffer();\n+        directByteBufferAsLongBufferViewSwapRO = ByteBuffer.allocateDirect(size).order(nonNativeOrder).asLongBuffer().asReadOnlyBuffer();\n+    }\n+\n+    \/\/ ---------------- HELPER METHODS\n+\n+    private int innerLoopGetLong(LongBuffer buf) {\n+        int r = 0;\n+        for (int i = 0; i < buf.capacity(); i++) {\n+            r += buf.get(i);\n+        }\n+        return r;\n+    }\n+\n+    private void innerLoopPutLong(LongBuffer buf) {\n+        for (int i = 0; i < buf.capacity(); i++) {\n+            buf.put(i, longValue);\n+        }\n+    }\n+\n+    \/\/ -- Heap   \n+\n+    @Benchmark\n+    public long[] testHeapBulkPutLong() {\n+        heapLongBuffer.put(0, longArray);\n+        return longArray;\n+    }\n+\n+    @Benchmark\n+    public long[] testHeapBulkGetLong() {\n+        heapLongBuffer.get(0, longArray);\n+        return longArray;\n+    }\n+\n+    @Benchmark\n+    public void testHeapLoopPutLong() {\n+        innerLoopPutLong(heapLongBuffer);\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetLong() {\n+        return innerLoopGetLong(heapLongBuffer);\n+    }\n+\n+    \/\/ -- Heap View Swap RO\n+\n+    @Benchmark\n+    public long[] testHeapBulkGetLongViewSwapRO() {\n+        heapByteBufferAsLongBufferViewSwapRO.get(0, longArray);\n+        return longArray;\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetLongViewSwapRO() {\n+        return innerLoopGetLong(heapByteBufferAsLongBufferViewSwapRO);\n+    }\n+\n+    \/\/ -- Heap View Swap \n+\n+    @Benchmark\n+    public long[] testHeapBulkPutLongViewSwap() {\n+        heapByteBufferAsLongBufferViewSwap.put(0, longArray);\n+        return longArray;\n+    }\n+\n+    @Benchmark\n+    public long[] testHeapBulkGetLongViewSwap() {\n+        heapByteBufferAsLongBufferViewSwap.get(0, longArray);\n+        return longArray;\n+    }\n+\n+    @Benchmark\n+    public void testHeapLoopPutLongViewSwap() {\n+        innerLoopPutLong(heapByteBufferAsLongBufferViewSwap);\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetLongViewSwap() {\n+        return innerLoopGetLong(heapByteBufferAsLongBufferViewSwap);\n+    }\n+\n+    \/\/ -- Heap View  RO\n+\n+    @Benchmark\n+    public long[] testHeapBulkGetLongViewRO() {\n+        heapByteBufferAsLongBufferViewRO.get(0, longArray);\n+        return longArray;\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetLongViewRO() {\n+        return innerLoopGetLong(heapByteBufferAsLongBufferViewRO);\n+    }\n+\n+    \/\/ -- Heap View  \n+\n+    @Benchmark\n+    public long[] testHeapBulkPutLongView() {\n+        heapByteBufferAsLongBufferView.put(0, longArray);\n+        return longArray;\n+    }\n+\n+    @Benchmark\n+    public long[] testHeapBulkGetLongView() {\n+        heapByteBufferAsLongBufferView.get(0, longArray);\n+        return longArray;\n+    }\n+\n+    @Benchmark\n+    public void testHeapLoopPutLongView() {\n+        innerLoopPutLong(heapByteBufferAsLongBufferView);\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetLongView() {\n+        return innerLoopGetLong(heapByteBufferAsLongBufferView);\n+    }\n+\n+    \/\/ -- Direct View Swap RO\n+\n+    @Benchmark\n+    public long[] testDirectBulkGetLongViewSwapRO() {\n+        directByteBufferAsLongBufferViewSwapRO.get(0, longArray);\n+        return longArray;\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetLongViewSwapRO() {\n+        return innerLoopGetLong(directByteBufferAsLongBufferViewSwapRO);\n+    }\n+\n+    \/\/ -- Direct View Swap \n+\n+    @Benchmark\n+    public long[] testDirectBulkPutLongViewSwap() {\n+        directByteBufferAsLongBufferViewSwap.put(0, longArray);\n+        return longArray;\n+    }\n+\n+    @Benchmark\n+    public long[] testDirectBulkGetLongViewSwap() {\n+        directByteBufferAsLongBufferViewSwap.get(0, longArray);\n+        return longArray;\n+    }\n+\n+    @Benchmark\n+    public void testDirectLoopPutLongViewSwap() {\n+        innerLoopPutLong(directByteBufferAsLongBufferViewSwap);\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetLongViewSwap() {\n+        return innerLoopGetLong(directByteBufferAsLongBufferViewSwap);\n+    }\n+\n+    \/\/ -- Direct View  RO\n+\n+    @Benchmark\n+    public long[] testDirectBulkGetLongViewRO() {\n+        directByteBufferAsLongBufferViewRO.get(0, longArray);\n+        return longArray;\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetLongViewRO() {\n+        return innerLoopGetLong(directByteBufferAsLongBufferViewRO);\n+    }\n+\n+    \/\/ -- Direct View  \n+\n+    @Benchmark\n+    public long[] testDirectBulkPutLongView() {\n+        directByteBufferAsLongBufferView.put(0, longArray);\n+        return longArray;\n+    }\n+\n+    @Benchmark\n+    public long[] testDirectBulkGetLongView() {\n+        directByteBufferAsLongBufferView.get(0, longArray);\n+        return longArray;\n+    }\n+\n+    @Benchmark\n+    public void testDirectLoopPutLongView() {\n+        innerLoopPutLong(directByteBufferAsLongBufferView);\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetLongView() {\n+        return innerLoopGetLong(directByteBufferAsLongBufferView);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/LongBuffers.java","additions":289,"deletions":0,"binary":false,"changes":289,"status":"added"},{"patch":"@@ -0,0 +1,289 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.nio;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import java.nio.*;\n+import java.util.concurrent.TimeUnit;\n+import static java.nio.ByteOrder.*;\n+\n+\/**\n+ * Benchmark for memory access operations on java.nio.Buffer ( and its views )\n+ *\n+ * A large number of variants are covered. The individual benchmarks conform to\n+ * the following convention:\n+ *   test(Direct|Heap)(Bulk|Loop)(Get|Put)Short(View)?(Swap)?(RO)?\n+ *\n+ * This allows to easily run a subset of particular interest. For example:\n+ *   Direct only :- \"org.openjdk.bench.java.nio.ShortBuffers.testDirect.*\"\n+ *   Bulk only   :- \"org.openjdk.bench.java.nio.ShortBuffers.test.*Bulk.*\"\n+ *   Loop Put Swapped Views: -\n+ *      test(Direct|Heap)(Loop)(Put)Short(View)+(Swap)+\"\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Fork(3)\n+public class ShortBuffers {\n+\n+    static final int CARRIER_BYTE_WIDTH = 2;\n+\n+    @Param({\"16\", \"1024\", \"131072\"})\n+    private int size;\n+\n+    public short shortValue;\n+    public short[] shortArray;\n+\n+    public ShortBuffer heapShortBuffer;\n+    public ShortBuffer heapShortBufferRO;\n+    public ShortBuffer heapByteBufferAsShortBufferView;\n+    public ShortBuffer heapByteBufferAsShortBufferViewRO;\n+    public ShortBuffer heapByteBufferAsShortBufferViewSwap;\n+    public ShortBuffer heapByteBufferAsShortBufferViewSwapRO;\n+    public ShortBuffer directByteBufferAsShortBufferView;\n+    public ShortBuffer directByteBufferAsShortBufferViewRO;\n+    public ShortBuffer directByteBufferAsShortBufferViewSwap;\n+    public ShortBuffer directByteBufferAsShortBufferViewSwapRO;\n+\n+    @Setup\n+    public void setup() {\n+        shortArray = new short[size \/ CARRIER_BYTE_WIDTH];\n+\n+        \/\/ explicitly allocated heap carrier buffer\n+        heapShortBuffer = ShortBuffer.allocate(size \/ CARRIER_BYTE_WIDTH);\n+        heapShortBufferRO = ShortBuffer.allocate(size \/ CARRIER_BYTE_WIDTH).asReadOnlyBuffer();\n+\n+        \/\/ ByteBuffer views\n+        heapByteBufferAsShortBufferView     = ByteBuffer.allocate(size).order(nativeOrder()).asShortBuffer();\n+        heapByteBufferAsShortBufferViewRO   = ByteBuffer.allocate(size).order(nativeOrder()).asShortBuffer().asReadOnlyBuffer();\n+        directByteBufferAsShortBufferView   = ByteBuffer.allocateDirect(size).order(nativeOrder()).asShortBuffer();\n+        directByteBufferAsShortBufferViewRO = ByteBuffer.allocateDirect(size).order(nativeOrder()).asShortBuffer().asReadOnlyBuffer();\n+\n+        \/\/ endianness swapped\n+        ByteOrder nonNativeOrder = nativeOrder() == BIG_ENDIAN ? LITTLE_ENDIAN : BIG_ENDIAN;\n+        heapByteBufferAsShortBufferViewSwap     = ByteBuffer.allocate(size).order(nonNativeOrder).asShortBuffer();\n+        heapByteBufferAsShortBufferViewSwapRO   = ByteBuffer.allocate(size).order(nonNativeOrder).asShortBuffer().asReadOnlyBuffer();\n+        directByteBufferAsShortBufferViewSwap   = ByteBuffer.allocateDirect(size).order(nonNativeOrder).asShortBuffer();\n+        directByteBufferAsShortBufferViewSwapRO = ByteBuffer.allocateDirect(size).order(nonNativeOrder).asShortBuffer().asReadOnlyBuffer();\n+    }\n+\n+    \/\/ ---------------- HELPER METHODS\n+\n+    private int innerLoopGetShort(ShortBuffer buf) {\n+        int r = 0;\n+        for (int i = 0; i < buf.capacity(); i++) {\n+            r += buf.get(i);\n+        }\n+        return r;\n+    }\n+\n+    private void innerLoopPutShort(ShortBuffer buf) {\n+        for (int i = 0; i < buf.capacity(); i++) {\n+            buf.put(i, shortValue);\n+        }\n+    }\n+\n+    \/\/ -- Heap   \n+\n+    @Benchmark\n+    public short[] testHeapBulkPutShort() {\n+        heapShortBuffer.put(0, shortArray);\n+        return shortArray;\n+    }\n+\n+    @Benchmark\n+    public short[] testHeapBulkGetShort() {\n+        heapShortBuffer.get(0, shortArray);\n+        return shortArray;\n+    }\n+\n+    @Benchmark\n+    public void testHeapLoopPutShort() {\n+        innerLoopPutShort(heapShortBuffer);\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetShort() {\n+        return innerLoopGetShort(heapShortBuffer);\n+    }\n+\n+    \/\/ -- Heap View Swap RO\n+\n+    @Benchmark\n+    public short[] testHeapBulkGetShortViewSwapRO() {\n+        heapByteBufferAsShortBufferViewSwapRO.get(0, shortArray);\n+        return shortArray;\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetShortViewSwapRO() {\n+        return innerLoopGetShort(heapByteBufferAsShortBufferViewSwapRO);\n+    }\n+\n+    \/\/ -- Heap View Swap \n+\n+    @Benchmark\n+    public short[] testHeapBulkPutShortViewSwap() {\n+        heapByteBufferAsShortBufferViewSwap.put(0, shortArray);\n+        return shortArray;\n+    }\n+\n+    @Benchmark\n+    public short[] testHeapBulkGetShortViewSwap() {\n+        heapByteBufferAsShortBufferViewSwap.get(0, shortArray);\n+        return shortArray;\n+    }\n+\n+    @Benchmark\n+    public void testHeapLoopPutShortViewSwap() {\n+        innerLoopPutShort(heapByteBufferAsShortBufferViewSwap);\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetShortViewSwap() {\n+        return innerLoopGetShort(heapByteBufferAsShortBufferViewSwap);\n+    }\n+\n+    \/\/ -- Heap View  RO\n+\n+    @Benchmark\n+    public short[] testHeapBulkGetShortViewRO() {\n+        heapByteBufferAsShortBufferViewRO.get(0, shortArray);\n+        return shortArray;\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetShortViewRO() {\n+        return innerLoopGetShort(heapByteBufferAsShortBufferViewRO);\n+    }\n+\n+    \/\/ -- Heap View  \n+\n+    @Benchmark\n+    public short[] testHeapBulkPutShortView() {\n+        heapByteBufferAsShortBufferView.put(0, shortArray);\n+        return shortArray;\n+    }\n+\n+    @Benchmark\n+    public short[] testHeapBulkGetShortView() {\n+        heapByteBufferAsShortBufferView.get(0, shortArray);\n+        return shortArray;\n+    }\n+\n+    @Benchmark\n+    public void testHeapLoopPutShortView() {\n+        innerLoopPutShort(heapByteBufferAsShortBufferView);\n+    }\n+\n+    @Benchmark\n+    public int testHeapLoopGetShortView() {\n+        return innerLoopGetShort(heapByteBufferAsShortBufferView);\n+    }\n+\n+    \/\/ -- Direct View Swap RO\n+\n+    @Benchmark\n+    public short[] testDirectBulkGetShortViewSwapRO() {\n+        directByteBufferAsShortBufferViewSwapRO.get(0, shortArray);\n+        return shortArray;\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetShortViewSwapRO() {\n+        return innerLoopGetShort(directByteBufferAsShortBufferViewSwapRO);\n+    }\n+\n+    \/\/ -- Direct View Swap \n+\n+    @Benchmark\n+    public short[] testDirectBulkPutShortViewSwap() {\n+        directByteBufferAsShortBufferViewSwap.put(0, shortArray);\n+        return shortArray;\n+    }\n+\n+    @Benchmark\n+    public short[] testDirectBulkGetShortViewSwap() {\n+        directByteBufferAsShortBufferViewSwap.get(0, shortArray);\n+        return shortArray;\n+    }\n+\n+    @Benchmark\n+    public void testDirectLoopPutShortViewSwap() {\n+        innerLoopPutShort(directByteBufferAsShortBufferViewSwap);\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetShortViewSwap() {\n+        return innerLoopGetShort(directByteBufferAsShortBufferViewSwap);\n+    }\n+\n+    \/\/ -- Direct View  RO\n+\n+    @Benchmark\n+    public short[] testDirectBulkGetShortViewRO() {\n+        directByteBufferAsShortBufferViewRO.get(0, shortArray);\n+        return shortArray;\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetShortViewRO() {\n+        return innerLoopGetShort(directByteBufferAsShortBufferViewRO);\n+    }\n+\n+    \/\/ -- Direct View  \n+\n+    @Benchmark\n+    public short[] testDirectBulkPutShortView() {\n+        directByteBufferAsShortBufferView.put(0, shortArray);\n+        return shortArray;\n+    }\n+\n+    @Benchmark\n+    public short[] testDirectBulkGetShortView() {\n+        directByteBufferAsShortBufferView.get(0, shortArray);\n+        return shortArray;\n+    }\n+\n+    @Benchmark\n+    public void testDirectLoopPutShortView() {\n+        innerLoopPutShort(directByteBufferAsShortBufferView);\n+    }\n+\n+    @Benchmark\n+    public int testDirectLoopGetShortView() {\n+        return innerLoopGetShort(directByteBufferAsShortBufferView);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/ShortBuffers.java","additions":289,"deletions":0,"binary":false,"changes":289,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#warn This file is preprocessed before being compiled\n+\n+class XXX {\n+#begin\n+\n+    \/\/ -- $Ms$ {#if[view]?View} $SWAP$ $RO$\n+#if[!RO]\n+\n+    @Benchmark\n+    public $type$[] test$Ms$BulkPut$Type${#if[view]?View}$SWAP$$RO$() {\n+        $ms${#if[view]?ByteBufferAs}$Type$Buffer{#if[view]?View}$SWAP$$RO$.put(0, $type$Array);\n+        return $type$Array;\n+    }\n+#end[RO]\n+\n+    @Benchmark\n+    public $type$[] test$Ms$BulkGet$Type${#if[view]?View}$SWAP$$RO$() {\n+        $ms${#if[view]?ByteBufferAs}$Type$Buffer{#if[view]?View}$SWAP$$RO$.get(0, $type$Array);\n+        return $type$Array;\n+    }\n+#if[!byte]\n+#if[!RO]\n+\n+    @Benchmark\n+    public void test$Ms$LoopPut$Type${#if[view]?View$SWAP$}$RO$() {\n+        innerLoopPut$Type$($ms${#if[view]?ByteBufferAs}$Type$Buffer{#if[view]?View}$SWAP$$RO$);\n+    }\n+#end[RO]\n+\n+    @Benchmark\n+    public int test$Ms$LoopGet$Type${#if[view]?View}$SWAP$$RO$() {\n+        return innerLoopGet$Type$($ms${#if[view]?ByteBufferAs}$Type$Buffer{#if[view]?View}$SWAP$$RO$);\n+    }\n+#end[byte]\n+#end\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/X-Buffers-bin.java.template","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.nio;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import java.nio.*;\n+import java.util.concurrent.TimeUnit;\n+import static java.nio.ByteOrder.*;\n+\n+\/**\n+ * Benchmark for memory access operations on java.nio.Buffer ( and its views )\n+ *\n+ * A large number of variants are covered. The individual benchmarks conform to\n+ * the following convention:\n+#if[byte]\n+ *   test(Direct|Heap)(Bulk|Loop)(Get|Put)(Byte|Char|Short|Int|Long|Float|Double)(Swap)?(RO)?\n+#else[byte]\n+ *   test(Direct|Heap)(Bulk|Loop)(Get|Put)$Type$(View)?(Swap)?(RO)?\n+#end[byte]\n+ *\n+ * This allows to easily run a subset of particular interest. For example:\n+ *   Direct only :- \"org.openjdk.bench.java.nio.$Type$Buffers.testDirect.*\"\n+ *   Bulk only   :- \"org.openjdk.bench.java.nio.$Type$Buffers.test.*Bulk.*\"\n+ *   Loop Put Swapped Views: -\n+ *      test(Direct|Heap)(Loop)(Put)$Type$(View)+(Swap)+\"\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Fork(3)\n+public class $Type$Buffers {\n+\n+    static final int CARRIER_BYTE_WIDTH = $CarrierBW$;\n+\n+    @Param({\"16\", \"1024\", \"131072\"})\n+    private int size;\n+\n+    public $type$ $type$Value;\n+#if[byte]\n+    public char charValue;\n+    public short shortValue;\n+    public int intValue;\n+    public long longValue;\n+    public float floatValue;\n+    public double doubleValue;\n+#end[byte]\n+    public $type$[] $type$Array;\n+\n+    public $Type$Buffer heap$Type$Buffer;\n+    public $Type$Buffer heap$Type$BufferRO;\n+#if[byte]\n+    public ByteBuffer directByteBuffer;\n+    public ByteBuffer directByteBufferRO;\n+    public ByteBuffer heapByteBufferSwap;\n+    public ByteBuffer heapByteBufferSwapRO;\n+    public ByteBuffer directByteBufferSwap;\n+    public ByteBuffer directByteBufferSwapRO;\n+#else[byte]\n+    public $Type$Buffer heapByteBufferAs$Type$BufferView;\n+    public $Type$Buffer heapByteBufferAs$Type$BufferViewRO;\n+    public $Type$Buffer heapByteBufferAs$Type$BufferViewSwap;\n+    public $Type$Buffer heapByteBufferAs$Type$BufferViewSwapRO;\n+    public $Type$Buffer directByteBufferAs$Type$BufferView;\n+    public $Type$Buffer directByteBufferAs$Type$BufferViewRO;\n+    public $Type$Buffer directByteBufferAs$Type$BufferViewSwap;\n+    public $Type$Buffer directByteBufferAs$Type$BufferViewSwapRO;\n+#end[byte]\n+\n+    @Setup\n+    public void setup() {\n+        $type$Array = new $type$[size \/ CARRIER_BYTE_WIDTH];\n+\n+        \/\/ explicitly allocated heap carrier buffer\n+        heap$Type$Buffer = $Type$Buffer.allocate(size \/ CARRIER_BYTE_WIDTH);\n+        heap$Type$BufferRO = $Type$Buffer.allocate(size \/ CARRIER_BYTE_WIDTH).asReadOnlyBuffer();\n+#if[byte]\n+\n+        heapByteBufferSwap     = ByteBuffer.allocate(size \/ CARRIER_BYTE_WIDTH).order(LITTLE_ENDIAN);\n+        heapByteBufferSwapRO   = ByteBuffer.allocate(size \/ CARRIER_BYTE_WIDTH).order(LITTLE_ENDIAN).asReadOnlyBuffer();\n+        directByteBuffer       = ByteBuffer.allocateDirect(size \/ CARRIER_BYTE_WIDTH);\n+        directByteBufferRO     = ByteBuffer.allocateDirect(size \/ CARRIER_BYTE_WIDTH).asReadOnlyBuffer();\n+        directByteBufferSwap   = ByteBuffer.allocateDirect(size \/ CARRIER_BYTE_WIDTH).order(LITTLE_ENDIAN);\n+        directByteBufferSwapRO = ByteBuffer.allocateDirect(size \/ CARRIER_BYTE_WIDTH).order(LITTLE_ENDIAN).asReadOnlyBuffer();\n+#else[byte]\n+\n+        \/\/ ByteBuffer views\n+        heapByteBufferAs$Type$BufferView     = ByteBuffer.allocate(size).order(nativeOrder()).as$Type$Buffer();\n+        heapByteBufferAs$Type$BufferViewRO   = ByteBuffer.allocate(size).order(nativeOrder()).as$Type$Buffer().asReadOnlyBuffer();\n+        directByteBufferAs$Type$BufferView   = ByteBuffer.allocateDirect(size).order(nativeOrder()).as$Type$Buffer();\n+        directByteBufferAs$Type$BufferViewRO = ByteBuffer.allocateDirect(size).order(nativeOrder()).as$Type$Buffer().asReadOnlyBuffer();\n+\n+        \/\/ endianness swapped\n+        ByteOrder nonNativeOrder = nativeOrder() == BIG_ENDIAN ? LITTLE_ENDIAN : BIG_ENDIAN;\n+        heapByteBufferAs$Type$BufferViewSwap     = ByteBuffer.allocate(size).order(nonNativeOrder).as$Type$Buffer();\n+        heapByteBufferAs$Type$BufferViewSwapRO   = ByteBuffer.allocate(size).order(nonNativeOrder).as$Type$Buffer().asReadOnlyBuffer();\n+        directByteBufferAs$Type$BufferViewSwap   = ByteBuffer.allocateDirect(size).order(nonNativeOrder).as$Type$Buffer();\n+        directByteBufferAs$Type$BufferViewSwapRO = ByteBuffer.allocateDirect(size).order(nonNativeOrder).as$Type$Buffer().asReadOnlyBuffer();\n+#end[byte]\n+    }\n+\n+#if[!byte]\n+    \/\/ ---------------- HELPER METHODS\n+\n+    private int innerLoopGet$Type$($Type$Buffer buf) {\n+        int r = 0;\n+        for (int i = 0; i < buf.capacity(); i++) {\n+            r += buf.get(i);\n+        }\n+        return r;\n+    }\n+\n+    private void innerLoopPut$Type$($Type$Buffer buf) {\n+        for (int i = 0; i < buf.capacity(); i++) {\n+            buf.put(i, $type$Value);\n+        }\n+    }\n+#end[byte]\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/X-Buffers.java.template","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#warn This file is preprocessed before being compiled\n+\n+class XXX {\n+#begin\n+\n+    \/\/ -- $Ms$ $Type$ $SWAP$ $RO$\n+#if[!RO]\n+\n+    @Benchmark\n+    public void test$Ms$LoopPut$Type$$SWAP$$RO$() {\n+        for (int i = 0; i < $ms$ByteBuffer$SWAP$$RO$.capacity(); i+=$CarrierBW$) {\n+            $ms$ByteBuffer$SWAP$$RO$.put{#if[!byte]?$Type$}(i, $type$Value);\n+        }\n+    }\n+#end[RO]\n+\n+    @Benchmark\n+    public int test$Ms$LoopGet$Type$$SWAP$$RO$() {\n+        int r = 0;\n+        for (int i = 0; i < $ms$ByteBuffer$SWAP$$RO$.capacity(); i+=$CarrierBW$) {\n+            r += $ms$ByteBuffer$SWAP$$RO$.get{#if[!byte]?$Type$}(i);\n+        }\n+        return r;\n+    }\n+#end\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/X-ByteBuffers-bin.java.template","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+#! \/bin\/sh\n+\n+#\n+# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+javac -d . ..\/..\/..\/..\/..\/..\/..\/make\/jdk\/src\/classes\/build\/tools\/spp\/Spp.java\n+\n+genBin() {\n+  for MS in \"Heap\" \"Direct\"\n+    do\n+      for SWAP in \"Swap\" \"\"\n+      do\n+        for RO in \"RO\" \"\"\n+        do\n+        extraArgs=\"\"\n+        if [ \"$RO\" == \"RO\" ] ; then\n+          extraArgs=\"-KRO\"\n+        fi\n+        java build.tools.spp.Spp -be -nel -K$1 -Dtype=$1 -DType=$2 -DFulltype=$3 \\\n+              $extraArgs \\\n+              -Kview \\\n+              -DMs=$MS \\\n+              -Dms=`echo \"$MS\" | awk '{print tolower($0)}'` \\\n+              -DSWAP=$SWAP \\\n+              -DRO=$RO \\\n+              -DCarrierBW=$4 \\\n+              -i$5 \\\n+              -o$out\n+        done\n+      done\n+    done\n+}\n+\n+gen() {\n+    out=$2Buffers.java\n+    rm -f $out\n+    java build.tools.spp.Spp -be -nel -K$1 -Dtype=$1 -DType=$2 -DFulltype=$3 \\\n+          -DCarrierBW=$4 -iX-Buffers.java.template -o$out\n+\n+    java build.tools.spp.Spp -be -nel -K$1 -Dtype=$1 -DType=$2 -DFulltype=$3 \\\n+          -DMs=Heap -Dms=heap -DSWAP=\"\" -DRO=\"\" -iX-Buffers-bin.java.template -o$out\n+\n+    if [ \"$1\" == \"byte\" ] ; then\n+      genBin $1 $2 $3 $4 X-ByteBuffers-bin.java.template\n+      genBin char Char Character 2 X-ByteBuffers-bin.java.template\n+      genBin short Short Short 2 X-ByteBuffers-bin.java.template\n+      genBin int Int Integer 4 X-ByteBuffers-bin.java.template\n+      genBin long Long Long 8 X-ByteBuffers-bin.java.template\n+      genBin float Float Float 4 X-ByteBuffers-bin.java.template\n+      genBin double Double Double 8 X-ByteBuffers-bin.java.template\n+    else\n+      genBin $1 $2 $3 $4 X-Buffers-bin.java.template\n+    fi\n+\n+    printf \"}\\n\" >> $out\n+}\n+\n+gen byte Byte Byte 1\n+gen char Char Character 2\n+gen short Short Short 2\n+gen int Int Integer 4\n+gen long Long Long 8\n+gen float Float Float 4\n+gen double Double Double 8\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/genBuffers.sh","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"}]}