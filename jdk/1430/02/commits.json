[{"commit":{"message":"whitespace"},"files":[{"filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/ByteBuffers.java"}],"sha":"814e1819ed8ba36cf870f00e72589320902a0cb9"},{"commit":{"message":"Add additional carrier views and endianness variants.\n\nA large number of variants are now covered. The individual benchmarks conform to the following convention:\n  test(Direct|Heap)(Bulk|Single)(Get|Put)(Byte|Char|Short|Int|Long|Float|Double)(View)?(Swap)?\n\nThis allows to easily run a subset of particular interest. For example:\n  Direct only :- \"org.openjdk.bench.java.nio.ByteBuffers.testDirect.*\"\n  Char only   :- \"org.openjdk.bench.java.nio.ByteBuffers.test.*Char.*\"\n  Bulk only   :- \"org.openjdk.bench.java.nio.ByteBuffers.test.*Bulk.*\"\n  Put with Int or Long carrier :-\n     test(Direct|Heap)(Single)(Put)(Int|Long)(View)?(Swap)?\"\n\nRunning all variants together is likely not all that useful, since there will be a lot of data.\n\nThe param sizes are changed so as to better allow for wider carrier views.\n\nThere are a lot of individual benchmark methods, but their implementation is trivial, and largely mechanical.\n\nQuestion: where do folk stand on having a `main` method in a benchmark - as a standalone-run sanity? I found this useful to assert the validity of the benchmark code. It can be commented out if it could somehow affect the benchmark runs.\n\n( I omitted read-only views, since they less interesting, and we already have a lot of variants )"},"files":[{"filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/ByteBuffers.java"}],"sha":"84dabc305138ef29bb39c89ce241e363a3461c54"},{"commit":{"message":"Initial changes"},"files":[{"filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/ByteBuffers.java"}],"sha":"5e91e63efadacf1cd0c34e7da4837117876501d4"}]