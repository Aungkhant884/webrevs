{"files":[{"patch":"@@ -1698,1 +1698,0 @@\n-  G1CMKeepAliveAndDrainClosure keep_alive(this, task(0), true \/* is_serial *\/);\n@@ -1700,1 +1699,0 @@\n-  G1CMDrainMarkingStackClosure drain_mark_stack(this, task(0), true \/* is_serial *\/);\n@@ -1710,1 +1708,0 @@\n-                                     &keep_alive,\n@@ -1712,1 +1709,0 @@\n-                                     &drain_mark_stack,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1065,1 +1065,0 @@\n-                                                        OopClosure* keep_alive,\n@@ -1067,1 +1066,0 @@\n-                                                        VoidClosure* complete_gc,\n@@ -1081,1 +1079,1 @@\n-                                      keep_alive, enqueue, complete_gc, yield)) {\n+                                      enqueue, yield)) {\n@@ -1098,1 +1096,1 @@\n-                                      keep_alive, enqueue, complete_gc, yield)) {\n+                                      enqueue, yield)) {\n@@ -1115,1 +1113,1 @@\n-                                      keep_alive, enqueue, complete_gc, yield)) {\n+                                      enqueue, yield)) {\n@@ -1132,1 +1130,1 @@\n-                                      keep_alive, enqueue, complete_gc, yield)) {\n+                                      enqueue, yield)) {\n@@ -1141,9 +1139,0 @@\n-\/\/ Walk the given discovered ref list, and remove all reference objects whose\n-\/\/ referents are still alive or NULL. NOTE: When we are precleaning the\n-\/\/ ref lists, we do not disable refs discovery to honor the correct semantics of\n-\/\/ java.lang.Reference. Therefore, as we iterate over the discovered list (DL)\n-\/\/ and drop elements from it, newly discovered refs can be discovered and added\n-\/\/ to the DL. Because precleaning is implemented single-threaded today, for\n-\/\/ each per-thread DL, the insertion of refs (calling `complete_gc`) happens\n-\/\/ after the iteration. The clear separation means no special synchronization\n-\/\/ is needed.\n@@ -1152,1 +1141,0 @@\n-                                                     OopClosure*        keep_alive,\n@@ -1154,1 +1142,0 @@\n-                                                     VoidClosure*       complete_gc,\n@@ -1156,1 +1143,1 @@\n-  DiscoveredListIterator iter(refs_list, keep_alive, is_alive, enqueue);\n+  DiscoveredListIterator iter(refs_list, nullptr \/* keep_alive *\/, is_alive, enqueue);\n@@ -1168,1 +1155,0 @@\n-      \/\/ Remove Reference object from list\n@@ -1170,2 +1156,0 @@\n-      \/\/ Keep alive its cohort.\n-      iter.make_referent_alive();\n@@ -1177,2 +1161,0 @@\n-  \/\/ Close the reachable set\n-  complete_gc->do_void();\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":5,"deletions":23,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -307,9 +307,11 @@\n-  \/\/ \"Preclean\" all the discovered reference lists by removing references that\n-  \/\/ are active (e.g. due to the mutator calling enqueue()) or with NULL or\n-  \/\/ strongly reachable referents.\n-  \/\/ The first argument is a predicate on an oop that indicates\n-  \/\/ its (strong) reachability and the fourth is a closure that\n-  \/\/ may be used to incrementalize or abort the precleaning process.\n-  \/\/ The caller is responsible for taking care of potential\n-  \/\/ interference with concurrent operations on these lists\n-  \/\/ (or predicates involved) by other threads.\n+  \/\/ \"Preclean\" all the discovered reference lists by removing references whose\n+  \/\/ referents are NULL or strongly reachable (`is_alive` returns true).\n+  \/\/ Note: when a referent is strongly reachable, we assume it's already marked\n+  \/\/ through, so this method doesn't perform (and doesn't need to) any marking\n+  \/\/ work at all. Currently, this assumption holds because G1 uses SATB and the\n+  \/\/ marking status of an object is *not* updated when `Reference.get()` is\n+  \/\/ called.\n+  \/\/ `yield` is a closure that may be used to incrementalize or abort the\n+  \/\/ precleaning process. The caller is responsible for taking care of\n+  \/\/ potential interference with concurrent operations on these lists (or\n+  \/\/ predicates involved) by other threads.\n@@ -317,1 +319,0 @@\n-                                      OopClosure*        keep_alive,\n@@ -319,1 +320,0 @@\n-                                      VoidClosure*       complete_gc,\n@@ -334,1 +334,0 @@\n-                                   OopClosure*        keep_alive,\n@@ -336,1 +335,0 @@\n-                                   VoidClosure*       complete_gc,\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.hpp","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"}]}