{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n@@ -1271,4 +1270,0 @@\n-#ifndef SUPPORTS_CLOCK_MONOTONIC\n-#error \"Build platform doesn't support clock_gettime and related functionality\"\n-#endif\n-\n@@ -1303,32 +1298,0 @@\n-jlong os::javaTimeMillis() {\n-  if (os::Posix::supports_clock_gettime()) {\n-    struct timespec ts;\n-    int status = os::Posix::clock_gettime(CLOCK_REALTIME, &ts);\n-    assert_status(status == 0, status, \"gettime error\");\n-    return jlong(ts.tv_sec) * MILLIUNITS +\n-           jlong(ts.tv_nsec) \/ NANOUNITS_PER_MILLIUNIT;\n-  } else {\n-    timeval time;\n-    int status = gettimeofday(&time, NULL);\n-    assert(status != -1, \"linux error\");\n-    return jlong(time.tv_sec) * MILLIUNITS  +\n-           jlong(time.tv_usec) \/ (MICROUNITS \/ MILLIUNITS);\n-  }\n-}\n-\n-void os::javaTimeSystemUTC(jlong &seconds, jlong &nanos) {\n-  if (os::Posix::supports_clock_gettime()) {\n-    struct timespec ts;\n-    int status = os::Posix::clock_gettime(CLOCK_REALTIME, &ts);\n-    assert_status(status == 0, status, \"gettime error\");\n-    seconds = jlong(ts.tv_sec);\n-    nanos = jlong(ts.tv_nsec);\n-  } else {\n-    timeval time;\n-    int status = gettimeofday(&time, NULL);\n-    assert(status != -1, \"linux error\");\n-    seconds = jlong(time.tv_sec);\n-    nanos = jlong(time.tv_usec) * (NANOUNITS \/ MICROUNITS);\n-  }\n-}\n-\n@@ -1355,1 +1318,1 @@\n-      os::Posix::clock_getres(clockid, &tp) == 0 && tp.tv_sec == 0) {\n+      clock_getres(clockid, &tp) == 0 && tp.tv_sec == 0) {\n@@ -1361,35 +1324,0 @@\n-jlong os::javaTimeNanos() {\n-  if (os::supports_monotonic_clock()) {\n-    struct timespec tp;\n-    int status = os::Posix::clock_gettime(CLOCK_MONOTONIC, &tp);\n-    assert(status == 0, \"gettime error\");\n-    jlong result = jlong(tp.tv_sec) * (1000 * 1000 * 1000) + jlong(tp.tv_nsec);\n-    return result;\n-  } else {\n-    timeval time;\n-    int status = gettimeofday(&time, NULL);\n-    assert(status != -1, \"linux error\");\n-    jlong usecs = jlong(time.tv_sec) * (1000 * 1000) + jlong(time.tv_usec);\n-    return 1000 * usecs;\n-  }\n-}\n-\n-void os::javaTimeNanos_info(jvmtiTimerInfo *info_ptr) {\n-  if (os::supports_monotonic_clock()) {\n-    info_ptr->max_value = ALL_64_BITS;\n-\n-    \/\/ CLOCK_MONOTONIC - amount of time since some arbitrary point in the past\n-    info_ptr->may_skip_backward = false;      \/\/ not subject to resetting or drifting\n-    info_ptr->may_skip_forward = false;       \/\/ not subject to resetting or drifting\n-  } else {\n-    \/\/ gettimeofday - based on time in seconds since the Epoch thus does not wrap\n-    info_ptr->max_value = ALL_64_BITS;\n-\n-    \/\/ gettimeofday is a real time clock so it skips\n-    info_ptr->may_skip_backward = true;\n-    info_ptr->may_skip_forward = true;\n-  }\n-\n-  info_ptr->kind = JVMTI_TIMER_ELAPSED;                \/\/ elapsed not CPU time\n-}\n-\n@@ -2467,0 +2395,1 @@\n+    bool model_name_printed = false;\n@@ -2470,1 +2399,0 @@\n-        bool model_name_printed = false;\n@@ -2640,0 +2568,1 @@\n+  dli_fname[0] = '\\0';\n@@ -3275,1 +3204,1 @@\n-bool os::pd_uncommit_memory(char* addr, size_t size) {\n+bool os::pd_uncommit_memory(char* addr, size_t size, bool exec) {\n@@ -3519,1 +3448,1 @@\n-char* os::pd_reserve_memory(size_t bytes) {\n+char* os::pd_reserve_memory(size_t bytes, bool exec) {\n@@ -4200,1 +4129,1 @@\n-  char* result = pd_attempt_reserve_memory_at(requested_addr, bytes);\n+  char* result = pd_attempt_reserve_memory_at(requested_addr, bytes, !ExecMem);\n@@ -4212,1 +4141,1 @@\n-char* os::pd_attempt_reserve_memory_at(char* requested_addr, size_t bytes) {\n+char* os::pd_attempt_reserve_memory_at(char* requested_addr, size_t bytes, bool exec) {\n@@ -4346,3 +4275,2 @@\n-  int rc = os::Posix::clock_gettime(clockid, &tp);\n-  assert(rc == 0, \"clock_gettime is expected to return 0 code\");\n-\n+  int status = clock_gettime(clockid, &tp);\n+  assert(status == 0, \"clock_gettime error: %s\", os::strerror(errno));\n@@ -4352,0 +4280,31 @@\n+\/\/ Determine if the vmid is the parent pid for a child in a PID namespace.\n+\/\/ Return the namespace pid if so, otherwise -1.\n+int os::Linux::get_namespace_pid(int vmid) {\n+  char fname[24];\n+  int retpid = -1;\n+\n+  snprintf(fname, sizeof(fname), \"\/proc\/%d\/status\", vmid);\n+  FILE *fp = fopen(fname, \"r\");\n+\n+  if (fp) {\n+    int pid, nspid;\n+    int ret;\n+    while (!feof(fp) && !ferror(fp)) {\n+      ret = fscanf(fp, \"NSpid: %d %d\", &pid, &nspid);\n+      if (ret == 1) {\n+        break;\n+      }\n+      if (ret == 2) {\n+        retpid = nspid;\n+        break;\n+      }\n+      for (;;) {\n+        int ch = fgetc(fp);\n+        if (ch == EOF || ch == (int)'\\n') break;\n+      }\n+    }\n+    fclose(fp);\n+  }\n+  return retpid;\n+}\n+\n@@ -4425,6 +4384,0 @@\n-\n-  \/\/ Always warn if no monotonic clock available\n-  if (!os::Posix::supports_monotonic_clock()) {\n-    warning(\"No monotonic clock was available - timed services may \"    \\\n-            \"be adversely affected if the time-of-day clock changes\");\n-  }\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":41,"deletions":88,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -38,1 +38,8 @@\n-MutableSpace::MutableSpace(size_t alignment): ImmutableSpace(), _alignment(alignment), _top(NULL) {\n+MutableSpace::MutableSpace(size_t alignment) :\n+  _mangler(NULL),\n+  _last_setup_region(),\n+  _alignment(alignment),\n+  _bottom(NULL),\n+  _top(NULL),\n+  _end(NULL)\n+{\n@@ -180,19 +187,0 @@\n-\/\/ This version requires locking. *\/\n-HeapWord* MutableSpace::allocate(size_t size) {\n-  assert(Heap_lock->owned_by_self() ||\n-         (SafepointSynchronize::is_at_safepoint() &&\n-          Thread::current()->is_VM_thread()),\n-         \"not locked\");\n-  HeapWord* obj = top();\n-  if (pointer_delta(end(), obj) >= size) {\n-    HeapWord* new_top = obj + size;\n-    set_top(new_top);\n-    assert(is_object_aligned(obj) && is_object_aligned(new_top),\n-           \"checking alignment\");\n-    return obj;\n-  } else {\n-    return NULL;\n-  }\n-}\n-\n-\/\/ This version is lock-free.\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.cpp","additions":8,"deletions":20,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -149,19 +149,0 @@\n-\/\/ Allocation. We report all successful allocations to the size policy\n-\/\/ Note that the perm gen does not use this method, and should not!\n-HeapWord* PSOldGen::allocate(size_t word_size) {\n-  assert_locked_or_safepoint(Heap_lock);\n-  HeapWord* res = allocate_noexpand(word_size);\n-\n-  if (res == NULL) {\n-    res = expand_and_allocate(word_size);\n-  }\n-\n-  \/\/ Allocations in the old generation need to be reported\n-  if (res != NULL) {\n-    ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n-    heap->size_policy()->tenured_allocation(word_size * HeapWordSize);\n-  }\n-\n-  return res;\n-}\n-\n@@ -200,8 +181,0 @@\n-HeapWord* PSOldGen::expand_and_allocate(size_t word_size) {\n-  expand(word_size*HeapWordSize);\n-  if (GCExpandToAllocateDelayMillis > 0) {\n-    os::naked_sleep(GCExpandToAllocateDelayMillis);\n-  }\n-  return allocate_noexpand(word_size);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":0,"deletions":27,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2015, 2021, Red Hat, Inc. All rights reserved.\n@@ -48,1 +48,1 @@\n-  if ((state->enqueue_barriers_count() +\n+  if ((state->iu_barriers_count() +\n@@ -194,1 +194,1 @@\n-            if (n->Opcode() == Op_ShenandoahEnqueueBarrier) {\n+            if (n->Opcode() == Op_ShenandoahIUBarrier) {\n@@ -204,1 +204,1 @@\n-      } else if (in->Opcode() == Op_ShenandoahEnqueueBarrier) {\n+      } else if (in->Opcode() == Op_ShenandoahIUBarrier) {\n@@ -331,1 +331,1 @@\n-        if (verify && !verify_helper(n->in(MemNode::ValueIn), phis, visited, ShenandoahStoreValEnqueueBarrier ? ShenandoahOopStore : ShenandoahValue, trace, barriers_used)) {\n+        if (verify && !verify_helper(n->in(MemNode::ValueIn), phis, visited, ShenandoahIUBarrier ? ShenandoahOopStore : ShenandoahValue, trace, barriers_used)) {\n@@ -373,1 +373,1 @@\n-          !verify_helper(n->in(MemNode::ValueIn), phis, visited, ShenandoahStoreValEnqueueBarrier ? ShenandoahOopStore : ShenandoahValue, trace, barriers_used)) {\n+          !verify_helper(n->in(MemNode::ValueIn), phis, visited, ShenandoahIUBarrier ? ShenandoahOopStore : ShenandoahValue, trace, barriers_used)) {\n@@ -525,1 +525,1 @@\n-    } else if (n->Opcode() == Op_ShenandoahEnqueueBarrier || n->Opcode() == Op_ShenandoahLoadReferenceBarrier) {\n+    } else if (n->Opcode() == Op_ShenandoahIUBarrier || n->Opcode() == Op_ShenandoahLoadReferenceBarrier) {\n@@ -1113,2 +1113,2 @@\n-  for (int i = 0; i < state->enqueue_barriers_count(); i++) {\n-    Node* barrier = state->enqueue_barrier(i);\n+  for (int i = 0; i < state->iu_barriers_count(); i++) {\n+    Node* barrier = state->iu_barrier(i);\n@@ -1464,2 +1464,2 @@\n-  for (int i = state->enqueue_barriers_count() - 1; i >= 0; i--) {\n-    Node* barrier = state->enqueue_barrier(i);\n+  for (int i = state->iu_barriers_count() - 1; i >= 0; i--) {\n+    Node* barrier = state->iu_barrier(i);\n@@ -1612,1 +1612,1 @@\n-  assert(state->enqueue_barriers_count() == 0, \"all enqueue barrier nodes should have been replaced\");\n+  assert(state->iu_barriers_count() == 0, \"all enqueue barrier nodes should have been replaced\");\n@@ -1666,1 +1666,1 @@\n-    case Op_ShenandoahEnqueueBarrier:\n+    case Op_ShenandoahIUBarrier:\n@@ -1999,2 +1999,2 @@\n-ShenandoahEnqueueBarrierNode::ShenandoahEnqueueBarrierNode(Node* val) : Node(NULL, val) {\n-  ShenandoahBarrierSetC2::bsc2()->state()->add_enqueue_barrier(this);\n+ShenandoahIUBarrierNode::ShenandoahIUBarrierNode(Node* val) : Node(NULL, val) {\n+  ShenandoahBarrierSetC2::bsc2()->state()->add_iu_barrier(this);\n@@ -2003,1 +2003,1 @@\n-const Type* ShenandoahEnqueueBarrierNode::bottom_type() const {\n+const Type* ShenandoahIUBarrierNode::bottom_type() const {\n@@ -2014,1 +2014,1 @@\n-const Type* ShenandoahEnqueueBarrierNode::Value(PhaseGVN* phase) const {\n+const Type* ShenandoahIUBarrierNode::Value(PhaseGVN* phase) const {\n@@ -2028,1 +2028,1 @@\n-int ShenandoahEnqueueBarrierNode::needed(Node* n) {\n+int ShenandoahIUBarrierNode::needed(Node* n) {\n@@ -2031,1 +2031,1 @@\n-      n->Opcode() == Op_ShenandoahEnqueueBarrier ||\n+      n->Opcode() == Op_ShenandoahIUBarrier ||\n@@ -2043,1 +2043,1 @@\n-Node* ShenandoahEnqueueBarrierNode::next(Node* n) {\n+Node* ShenandoahIUBarrierNode::next(Node* n) {\n@@ -2065,1 +2065,1 @@\n-Node* ShenandoahEnqueueBarrierNode::Identity(PhaseGVN* phase) {\n+Node* ShenandoahIUBarrierNode::Identity(PhaseGVN* phase) {\n@@ -3077,1 +3077,1 @@\n-    case Op_ShenandoahEnqueueBarrier:\n+    case Op_ShenandoahIUBarrier:\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -572,1 +572,1 @@\n-                                           jvms->bci(), no_memory_effects);\n+                                           no_memory_effects);\n@@ -3536,2 +3536,1 @@\n-void PhaseIdealLoop::collect_potentially_useful_predicates(\n-                         IdealLoopTree * loop, Unique_Node_List &useful_predicates) {\n+void PhaseIdealLoop::collect_potentially_useful_predicates(IdealLoopTree* loop, Unique_Node_List &useful_predicates) {\n@@ -3548,2 +3547,3 @@\n-    Node* predicate_proj = find_predicate(entry); \/\/ loop_limit_check first\n-    if (predicate_proj != NULL) { \/\/ right pattern that can be used by loop predication\n+\n+    Node* predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);\n+    if (predicate != NULL) { \/\/ right pattern that can be used by loop predication\n@@ -3555,2 +3555,2 @@\n-      predicate_proj = find_predicate(entry); \/\/ Predicate\n-      if (predicate_proj != NULL) {\n+      predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);\n+      if (predicate != NULL) { \/\/ right pattern that can be used by loop predication\n@@ -3558,0 +3558,1 @@\n+        get_skeleton_predicates(entry, useful_predicates, true);\n@@ -3561,3 +3562,7 @@\n-    predicate_proj = find_predicate(entry); \/\/ Predicate\n-    if (predicate_proj != NULL) {\n-      useful_predicates.push(entry->in(0)->in(1)->in(1)); \/\/ good one\n+\n+    if (UseLoopPredicate) {\n+      predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);\n+      if (predicate != NULL) { \/\/ right pattern that can be used by loop predication\n+        useful_predicates.push(entry->in(0)->in(1)->in(1)); \/\/ good one\n+        get_skeleton_predicates(entry, useful_predicates, true);\n+      }\n@@ -3577,1 +3582,1 @@\n-  if (C->predicate_count() == 0)\n+  if (C->predicate_count() == 0 && C->skeleton_predicate_count() == 0) {\n@@ -3579,0 +3584,1 @@\n+  }\n@@ -3586,1 +3592,1 @@\n-     Node * n = C->predicate_opaque1_node(i-1);\n+     Node* n = C->predicate_opaque1_node(i - 1);\n@@ -3592,0 +3598,8 @@\n+\n+  for (int i = C->skeleton_predicate_count(); i > 0; i--) {\n+    Node* n = C->skeleton_predicate_opaque4_node(i - 1);\n+    assert(n->Opcode() == Op_Opaque4, \"must be\");\n+    if (!useful_predicates.member(n)) { \/\/ not in the useful list\n+      _igvn.replace_node(n, n->in(2));\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":26,"deletions":12,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -917,1 +917,2 @@\n-  bool skeleton_predicate_has_opaque(IfNode* iff);\n+  static bool skeleton_predicate_has_opaque(IfNode* iff);\n+  static void get_skeleton_predicates(Node* predicate, Unique_Node_List& list, bool get_opaque = false);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciSymbols.hpp\"\n@@ -362,2 +363,2 @@\n-  ciField* field = ciEnv::current()->vector_VectorPayload_klass()->get_field_by_name(ciSymbol::payload_name(),\n-                                                                                     ciSymbol::object_signature(),\n+  ciField* field = ciEnv::current()->vector_VectorPayload_klass()->get_field_by_name(ciSymbols::payload_name(),\n+                                                                                     ciSymbols::object_signature(),\n@@ -407,2 +408,2 @@\n-    ciField* field = ciEnv::current()->vector_VectorPayload_klass()->get_field_by_name(ciSymbol::payload_name(),\n-                                                                                       ciSymbol::object_signature(),\n+    ciField* field = ciEnv::current()->vector_VectorPayload_klass()->get_field_by_name(ciSymbols::payload_name(),\n+                                                                                       ciSymbols::object_signature(),\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"utilities\/vmError.hpp\"\n@@ -271,34 +270,1 @@\n-\n-\/\/ simple test for SafeFetch32\n-static void test_safefetch32() {\n-  if (CanUseSafeFetch32()) {\n-    int dummy = 17;\n-    int* const p_invalid = (int*) VMError::get_segfault_address();\n-    int* const p_valid = &dummy;\n-    int result_invalid = SafeFetch32(p_invalid, 0xABC);\n-    assert(result_invalid == 0xABC, \"SafeFetch32 error\");\n-    int result_valid = SafeFetch32(p_valid, 0xABC);\n-    assert(result_valid == 17, \"SafeFetch32 error\");\n-  }\n-}\n-\n-\/\/ simple test for SafeFetchN\n-static void test_safefetchN() {\n-  if (CanUseSafeFetchN()) {\n-#ifdef _LP64\n-    const intptr_t v1 = UCONST64(0xABCD00000000ABCD);\n-    const intptr_t v2 = UCONST64(0xDEFD00000000DEFD);\n-#else\n-    const intptr_t v1 = 0xABCDABCD;\n-    const intptr_t v2 = 0xDEFDDEFD;\n-#endif\n-    intptr_t dummy = v1;\n-    intptr_t* const p_invalid = (intptr_t*) VMError::get_segfault_address();\n-    intptr_t* const p_valid = &dummy;\n-    intptr_t result_invalid = SafeFetchN(p_invalid, v2);\n-    assert(result_invalid == v2, \"SafeFetchN error\");\n-    intptr_t result_valid = SafeFetchN(p_valid, v2);\n-    assert(result_valid == v1, \"SafeFetchN error\");\n-  }\n-}\n-#endif\n+#endif \/\/ ASSERT\n@@ -396,7 +362,0 @@\n-  \/\/ test safefetch routines\n-  \/\/ Not on Windows 32bit until 8074860 is fixed\n-#if ! (defined(_WIN32) && defined(_M_IX86))\n-  test_safefetch32();\n-  test_safefetchN();\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":1,"deletions":42,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,3 @@\n-import java.nio.charset.Charset;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.*;\n@@ -54,0 +56,2 @@\n+import sun.nio.cs.ArrayDecoder;\n+import sun.nio.cs.ArrayEncoder;\n@@ -55,1 +59,3 @@\n-import static java.util.function.Predicate.not;\n+import sun.nio.cs.ISO_8859_1;\n+import sun.nio.cs.US_ASCII;\n+import sun.nio.cs.UTF_8;\n@@ -478,1 +484,1 @@\n-    public String(byte bytes[], int offset, int length, String charsetName)\n+    public String(byte[] bytes, int offset, int length, String charsetName)\n@@ -480,7 +486,1 @@\n-        if (charsetName == null)\n-            throw new NullPointerException(\"charsetName\");\n-        checkBoundsOffCount(offset, length, bytes.length);\n-        StringCoding.Result ret =\n-            StringCoding.decode(charsetName, bytes, offset, length);\n-        this.value = ret.value;\n-        this.coder = ret.coder;\n+        this(bytes, offset, length, lookupCharset(charsetName));\n@@ -519,3 +519,161 @@\n-    public String(byte bytes[], int offset, int length, Charset charset) {\n-        if (charset == null)\n-            throw new NullPointerException(\"charset\");\n+    public String(byte[] bytes, int offset, int length, Charset charset) {\n+        Objects.requireNonNull(charset);\n+        checkBoundsOffCount(offset, length, bytes.length);\n+        if (length == 0) {\n+            this.value = \"\".value;\n+            this.coder = \"\".coder;\n+        } else if (charset == UTF_8.INSTANCE) {\n+            if (COMPACT_STRINGS && !StringCoding.hasNegatives(bytes, offset, length)) {\n+                this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n+                this.coder = LATIN1;\n+            } else {\n+                int sl = offset + length;\n+                int dp = 0;\n+                byte[] dst = null;\n+                if (COMPACT_STRINGS) {\n+                    dst = new byte[length];\n+                    while (offset < sl) {\n+                        int b1 = bytes[offset];\n+                        if (b1 >= 0) {\n+                            dst[dp++] = (byte)b1;\n+                            offset++;\n+                            continue;\n+                        }\n+                        if ((b1 == (byte)0xc2 || b1 == (byte)0xc3) &&\n+                                offset + 1 < sl) {\n+                            int b2 = bytes[offset + 1];\n+                            if (!isNotContinuation(b2)) {\n+                                dst[dp++] = (byte)decode2(b1, b2);\n+                                offset += 2;\n+                                continue;\n+                            }\n+                        }\n+                        \/\/ anything not a latin1, including the repl\n+                        \/\/ we have to go with the utf16\n+                        break;\n+                    }\n+                    if (offset == sl) {\n+                        if (dp != dst.length) {\n+                            dst = Arrays.copyOf(dst, dp);\n+                        }\n+                        this.value = dst;\n+                        this.coder = LATIN1;\n+                        return;\n+                    }\n+                }\n+                if (dp == 0 || dst == null) {\n+                    dst = new byte[length << 1];\n+                } else {\n+                    byte[] buf = new byte[length << 1];\n+                    StringLatin1.inflate(dst, 0, buf, 0, dp);\n+                    dst = buf;\n+                }\n+                dp = decodeUTF8_UTF16(bytes, offset, sl, dst, dp, true);\n+                if (dp != length) {\n+                    dst = Arrays.copyOf(dst, dp << 1);\n+                }\n+                this.value = dst;\n+                this.coder = UTF16;\n+            }\n+        } else if (charset == ISO_8859_1.INSTANCE) {\n+            if (COMPACT_STRINGS) {\n+                this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n+                this.coder = LATIN1;\n+            } else {\n+                this.value = StringLatin1.inflate(bytes, offset, length);\n+                this.coder = UTF16;\n+            }\n+        } else if (charset == US_ASCII.INSTANCE) {\n+            if (COMPACT_STRINGS && !StringCoding.hasNegatives(bytes, offset, length)) {\n+                this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n+                this.coder = LATIN1;\n+            } else {\n+                byte[] dst = new byte[length << 1];\n+                int dp = 0;\n+                while (dp < length) {\n+                    int b = bytes[offset++];\n+                    StringUTF16.putChar(dst, dp++, (b >= 0) ? (char) b : REPL);\n+                }\n+                this.value = dst;\n+                this.coder = UTF16;\n+            }\n+        } else {\n+            \/\/ (1)We never cache the \"external\" cs, the only benefit of creating\n+            \/\/ an additional StringDe\/Encoder object to wrap it is to share the\n+            \/\/ de\/encode() method. These SD\/E objects are short-lived, the young-gen\n+            \/\/ gc should be able to take care of them well. But the best approach\n+            \/\/ is still not to generate them if not really necessary.\n+            \/\/ (2)The defensive copy of the input byte\/char[] has a big performance\n+            \/\/ impact, as well as the outgoing result byte\/char[]. Need to do the\n+            \/\/ optimization check of (sm==null && classLoader0==null) for both.\n+            CharsetDecoder cd = charset.newDecoder();\n+            \/\/ ArrayDecoder fastpaths\n+            if (cd instanceof ArrayDecoder ad) {\n+                \/\/ ascii\n+                if (ad.isASCIICompatible() && !StringCoding.hasNegatives(bytes, offset, length)) {\n+                    if (COMPACT_STRINGS) {\n+                        this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n+                        this.coder = LATIN1;\n+                        return;\n+                    }\n+                    this.value = StringLatin1.inflate(bytes, offset, length);\n+                    this.coder = UTF16;\n+                    return;\n+                }\n+\n+                \/\/ fastpath for always Latin1 decodable single byte\n+                if (COMPACT_STRINGS && ad.isLatin1Decodable()) {\n+                    byte[] dst = new byte[length];\n+                    ad.decodeToLatin1(bytes, offset, length, dst);\n+                    this.value = dst;\n+                    this.coder = LATIN1;\n+                    return;\n+                }\n+\n+                int en = scale(length, cd.maxCharsPerByte());\n+                cd.onMalformedInput(CodingErrorAction.REPLACE)\n+                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+                char[] ca = new char[en];\n+                int clen = ad.decode(bytes, offset, length, ca);\n+                if (COMPACT_STRINGS) {\n+                    byte[] bs = StringUTF16.compress(ca, 0, clen);\n+                    if (bs != null) {\n+                        value = bs;\n+                        coder = LATIN1;\n+                        return;\n+                    }\n+                }\n+                coder = UTF16;\n+                value = StringUTF16.toBytes(ca, 0, clen);\n+                return;\n+            }\n+\n+            \/\/ decode using CharsetDecoder\n+            int en = scale(length, cd.maxCharsPerByte());\n+            cd.onMalformedInput(CodingErrorAction.REPLACE)\n+                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+            char[] ca = new char[en];\n+            if (charset.getClass().getClassLoader0() != null &&\n+                    System.getSecurityManager() != null) {\n+                bytes = Arrays.copyOfRange(bytes, offset, offset + length);\n+                offset = 0;\n+            }\n+\n+            int caLen = decodeWithDecoder(cd, ca, bytes, offset, length);\n+            if (COMPACT_STRINGS) {\n+                byte[] bs = StringUTF16.compress(ca, 0, caLen);\n+                if (bs != null) {\n+                    value = bs;\n+                    coder = LATIN1;\n+                    return;\n+                }\n+            }\n+            coder = UTF16;\n+            value = StringUTF16.toBytes(ca, 0, caLen);\n+        }\n+    }\n+\n+    \/*\n+     * Throws iae, instead of replacing, if malformed or unmappable.\n+     *\/\n+    static String newStringUTF8NoRepl(byte[] bytes, int offset, int length) {\n@@ -523,4 +681,625 @@\n-        StringCoding.Result ret =\n-            StringCoding.decode(charset, bytes, offset, length);\n-        this.value = ret.value;\n-        this.coder = ret.coder;\n+        if (length == 0) {\n+            return \"\";\n+        }\n+        if (COMPACT_STRINGS && !StringCoding.hasNegatives(bytes, offset, length)) {\n+            return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n+        } else {\n+            int sl = offset + length;\n+            int dp = 0;\n+            byte[] dst = null;\n+            if (COMPACT_STRINGS) {\n+                dst = new byte[length];\n+                while (offset < sl) {\n+                    int b1 = bytes[offset];\n+                    if (b1 >= 0) {\n+                        dst[dp++] = (byte) b1;\n+                        offset++;\n+                        continue;\n+                    }\n+                    if ((b1 == (byte) 0xc2 || b1 == (byte) 0xc3) &&\n+                            offset + 1 < sl) {\n+                        int b2 = bytes[offset + 1];\n+                        if (!isNotContinuation(b2)) {\n+                            dst[dp++] = (byte) decode2(b1, b2);\n+                            offset += 2;\n+                            continue;\n+                        }\n+                    }\n+                    \/\/ anything not a latin1, including the REPL\n+                    \/\/ we have to go with the utf16\n+                    break;\n+                }\n+                if (offset == sl) {\n+                    if (dp != dst.length) {\n+                        dst = Arrays.copyOf(dst, dp);\n+                    }\n+                    return new String(dst, LATIN1);\n+                }\n+            }\n+            if (dp == 0 || dst == null) {\n+                dst = new byte[length << 1];\n+            } else {\n+                byte[] buf = new byte[length << 1];\n+                StringLatin1.inflate(dst, 0, buf, 0, dp);\n+                dst = buf;\n+            }\n+            dp = decodeUTF8_UTF16(bytes, offset, sl, dst, dp, false);\n+            if (dp != length) {\n+                dst = Arrays.copyOf(dst, dp << 1);\n+            }\n+            return new String(dst, UTF16);\n+        }\n+    }\n+\n+    static String newStringNoRepl(byte[] src, Charset cs) throws CharacterCodingException {\n+        try {\n+            return newStringNoRepl1(src, cs);\n+        } catch (IllegalArgumentException e) {\n+            \/\/newStringNoRepl1 throws IAE with MalformedInputException or CCE as the cause\n+            Throwable cause = e.getCause();\n+            if (cause instanceof MalformedInputException mie) {\n+                throw mie;\n+            }\n+            throw (CharacterCodingException)cause;\n+        }\n+    }\n+\n+    private static String newStringNoRepl1(byte[] src, Charset cs) {\n+        int len = src.length;\n+        if (len == 0) {\n+            return \"\";\n+        }\n+        if (cs == UTF_8.INSTANCE) {\n+            return newStringUTF8NoRepl(src, 0, src.length);\n+        }\n+        if (cs == ISO_8859_1.INSTANCE) {\n+            if (COMPACT_STRINGS)\n+                return new String(src, LATIN1);\n+            return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n+        }\n+        if (cs == US_ASCII.INSTANCE) {\n+            if (!StringCoding.hasNegatives(src, 0, src.length)) {\n+                if (COMPACT_STRINGS)\n+                    return new String(src, LATIN1);\n+                return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n+            } else {\n+                throwMalformed(src);\n+            }\n+        }\n+\n+        CharsetDecoder cd = cs.newDecoder();\n+        \/\/ ascii fastpath\n+        if (cd instanceof ArrayDecoder ad &&\n+                ad.isASCIICompatible() &&\n+                !StringCoding.hasNegatives(src, 0, src.length)) {\n+            return new String(src, 0, src.length, ISO_8859_1.INSTANCE);\n+        }\n+        int en = scale(len, cd.maxCharsPerByte());\n+        char[] ca = new char[en];\n+        if (cs.getClass().getClassLoader0() != null &&\n+                System.getSecurityManager() != null) {\n+            src = Arrays.copyOf(src, len);\n+        }\n+        int caLen = decodeWithDecoder(cd, ca, src, 0, src.length);\n+        if (COMPACT_STRINGS) {\n+            byte[] bs = StringUTF16.compress(ca, 0, caLen);\n+            if (bs != null) {\n+                return new String(bs, LATIN1);\n+            }\n+        }\n+        return new String(StringUTF16.toBytes(ca, 0, caLen), UTF16);\n+    }\n+\n+    private static final char REPL = '\\ufffd';\n+\n+    \/\/ Trim the given byte array to the given length\n+    private static byte[] safeTrim(byte[] ba, int len, boolean isTrusted) {\n+        if (len == ba.length && (isTrusted || System.getSecurityManager() == null)) {\n+            return ba;\n+        } else {\n+            return Arrays.copyOf(ba, len);\n+        }\n+    }\n+\n+    private static int scale(int len, float expansionFactor) {\n+        \/\/ We need to perform double, not float, arithmetic; otherwise\n+        \/\/ we lose low order bits when len is larger than 2**24.\n+        return (int)(len * (double)expansionFactor);\n+    }\n+\n+    private static Charset lookupCharset(String csn) throws UnsupportedEncodingException {\n+        Objects.requireNonNull(csn);\n+        try {\n+            return Charset.forName(csn);\n+        } catch (UnsupportedCharsetException | IllegalCharsetNameException x) {\n+            throw new UnsupportedEncodingException(csn);\n+        }\n+    }\n+\n+    private static byte[] encode(Charset cs, byte coder, byte[] val) {\n+        if (cs == UTF_8.INSTANCE) {\n+            return encodeUTF8(coder, val, true);\n+        }\n+        if (cs == ISO_8859_1.INSTANCE) {\n+            return encode8859_1(coder, val);\n+        }\n+        if (cs == US_ASCII.INSTANCE) {\n+            return encodeASCII(coder, val);\n+        }\n+        return encodeWithEncoder(cs, coder, val, true);\n+    }\n+\n+    private static byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val, boolean doReplace) {\n+        CharsetEncoder ce = cs.newEncoder();\n+        int len = val.length >> coder;  \/\/ assume LATIN1=0\/UTF16=1;\n+        int en = scale(len, ce.maxBytesPerChar());\n+        if (ce instanceof ArrayEncoder ae) {\n+            \/\/ fastpath for ascii compatible\n+            if (coder == LATIN1 &&\n+                    ae.isASCIICompatible() &&\n+                    !StringCoding.hasNegatives(val, 0, val.length)) {\n+                return Arrays.copyOf(val, val.length);\n+            }\n+            byte[] ba = new byte[en];\n+            if (len == 0) {\n+                return ba;\n+            }\n+            if (doReplace) {\n+                ce.onMalformedInput(CodingErrorAction.REPLACE)\n+                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+            }\n+\n+            int blen = (coder == LATIN1) ? ae.encodeFromLatin1(val, 0, len, ba)\n+                    : ae.encodeFromUTF16(val, 0, len, ba);\n+            if (blen != -1) {\n+                return safeTrim(ba, blen, true);\n+            }\n+        }\n+\n+        byte[] ba = new byte[en];\n+        if (len == 0) {\n+            return ba;\n+        }\n+        if (doReplace) {\n+            ce.onMalformedInput(CodingErrorAction.REPLACE)\n+                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+        }\n+        char[] ca = (coder == LATIN1 ) ? StringLatin1.toChars(val)\n+                : StringUTF16.toChars(val);\n+        ByteBuffer bb = ByteBuffer.wrap(ba);\n+        CharBuffer cb = CharBuffer.wrap(ca, 0, len);\n+        try {\n+            CoderResult cr = ce.encode(cb, bb, true);\n+            if (!cr.isUnderflow())\n+                cr.throwException();\n+            cr = ce.flush(bb);\n+            if (!cr.isUnderflow())\n+                cr.throwException();\n+        } catch (CharacterCodingException x) {\n+            if (!doReplace) {\n+                throw new IllegalArgumentException(x);\n+            } else {\n+                throw new Error(x);\n+            }\n+        }\n+        return safeTrim(ba, bb.position(), cs.getClass().getClassLoader0() == null);\n+    }\n+\n+    \/*\n+     * Throws iae, instead of replacing, if unmappable.\n+     *\/\n+    static byte[] getBytesUTF8NoRepl(String s) {\n+        return encodeUTF8(s.coder(), s.value(), false);\n+    }\n+\n+    private static boolean isASCII(byte[] src) {\n+        return !StringCoding.hasNegatives(src, 0, src.length);\n+    }\n+\n+    \/*\n+     * Throws CCE, instead of replacing, if unmappable.\n+     *\/\n+    static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n+        try {\n+            return getBytesNoRepl1(s, cs);\n+        } catch (IllegalArgumentException e) {\n+            \/\/getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause\n+            Throwable cause = e.getCause();\n+            if (cause instanceof UnmappableCharacterException) {\n+                throw (UnmappableCharacterException)cause;\n+            }\n+            throw (CharacterCodingException)cause;\n+        }\n+    }\n+\n+    private static byte[] getBytesNoRepl1(String s, Charset cs) {\n+        byte[] val = s.value();\n+        byte coder = s.coder();\n+        if (cs == UTF_8.INSTANCE) {\n+            if (coder == LATIN1 && isASCII(val)) {\n+                return val;\n+            }\n+            return encodeUTF8(coder, val, false);\n+        }\n+        if (cs == ISO_8859_1.INSTANCE) {\n+            if (coder == LATIN1) {\n+                return val;\n+            }\n+            return encode8859_1(coder, val, false);\n+        }\n+        if (cs == US_ASCII.INSTANCE) {\n+            if (coder == LATIN1) {\n+                if (isASCII(val)) {\n+                    return val;\n+                } else {\n+                    throwUnmappable(val);\n+                }\n+            }\n+        }\n+        return encodeWithEncoder(cs, coder, val, false);\n+    }\n+\n+    private static byte[] encodeASCII(byte coder, byte[] val) {\n+        if (coder == LATIN1) {\n+            byte[] dst = Arrays.copyOf(val, val.length);\n+            for (int i = 0; i < dst.length; i++) {\n+                if (dst[i] < 0) {\n+                    dst[i] = '?';\n+                }\n+            }\n+            return dst;\n+        }\n+        int len = val.length >> 1;\n+        byte[] dst = new byte[len];\n+        int dp = 0;\n+        for (int i = 0; i < len; i++) {\n+            char c = StringUTF16.getChar(val, i);\n+            if (c < 0x80) {\n+                dst[dp++] = (byte)c;\n+                continue;\n+            }\n+            if (Character.isHighSurrogate(c) && i + 1 < len &&\n+                    Character.isLowSurrogate(StringUTF16.getChar(val, i + 1))) {\n+                i++;\n+            }\n+            dst[dp++] = '?';\n+        }\n+        if (len == dp) {\n+            return dst;\n+        }\n+        return Arrays.copyOf(dst, dp);\n+    }\n+\n+    private static byte[] encode8859_1(byte coder, byte[] val) {\n+        return encode8859_1(coder, val, true);\n+    }\n+\n+    private static byte[] encode8859_1(byte coder, byte[] val, boolean doReplace) {\n+        if (coder == LATIN1) {\n+            return Arrays.copyOf(val, val.length);\n+        }\n+        int len = val.length >> 1;\n+        byte[] dst = new byte[len];\n+        int dp = 0;\n+        int sp = 0;\n+        int sl = len;\n+        while (sp < sl) {\n+            int ret = StringCoding.implEncodeISOArray(val, sp, dst, dp, len);\n+            sp = sp + ret;\n+            dp = dp + ret;\n+            if (ret != len) {\n+                if (!doReplace) {\n+                    throwUnmappable(sp);\n+                }\n+                char c = StringUTF16.getChar(val, sp++);\n+                if (Character.isHighSurrogate(c) && sp < sl &&\n+                        Character.isLowSurrogate(StringUTF16.getChar(val, sp))) {\n+                    sp++;\n+                }\n+                dst[dp++] = '?';\n+                len = sl - sp;\n+            }\n+        }\n+        if (dp == dst.length) {\n+            return dst;\n+        }\n+        return Arrays.copyOf(dst, dp);\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ utf8 \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\n+    private static boolean isNotContinuation(int b) {\n+        return (b & 0xc0) != 0x80;\n+    }\n+\n+    private static boolean isMalformed3(int b1, int b2, int b3) {\n+        return (b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n+                (b2 & 0xc0) != 0x80 || (b3 & 0xc0) != 0x80;\n+    }\n+\n+    private static boolean isMalformed3_2(int b1, int b2) {\n+        return (b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n+                (b2 & 0xc0) != 0x80;\n+    }\n+\n+    private static boolean isMalformed4(int b2, int b3, int b4) {\n+        return (b2 & 0xc0) != 0x80 || (b3 & 0xc0) != 0x80 ||\n+                (b4 & 0xc0) != 0x80;\n+    }\n+\n+    private static boolean isMalformed4_2(int b1, int b2) {\n+        return (b1 == 0xf0 && (b2 < 0x90 || b2 > 0xbf)) ||\n+                (b1 == 0xf4 && (b2 & 0xf0) != 0x80) ||\n+                (b2 & 0xc0) != 0x80;\n+    }\n+\n+    private static boolean isMalformed4_3(int b3) {\n+        return (b3 & 0xc0) != 0x80;\n+    }\n+\n+    private static char decode2(int b1, int b2) {\n+        return (char)(((b1 << 6) ^ b2) ^\n+                (((byte) 0xC0 << 6) ^\n+                        ((byte) 0x80 << 0)));\n+    }\n+\n+    private static char decode3(int b1, int b2, int b3) {\n+        return (char)((b1 << 12) ^\n+                (b2 <<  6) ^\n+                (b3 ^\n+                        (((byte) 0xE0 << 12) ^\n+                                ((byte) 0x80 <<  6) ^\n+                                ((byte) 0x80 <<  0))));\n+    }\n+\n+    private static int decode4(int b1, int b2, int b3, int b4) {\n+        return ((b1 << 18) ^\n+                (b2 << 12) ^\n+                (b3 <<  6) ^\n+                (b4 ^\n+                        (((byte) 0xF0 << 18) ^\n+                                ((byte) 0x80 << 12) ^\n+                                ((byte) 0x80 <<  6) ^\n+                                ((byte) 0x80 <<  0))));\n+    }\n+\n+    private static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp, boolean doReplace) {\n+        while (sp < sl) {\n+            int b1 = src[sp++];\n+            if (b1 >= 0) {\n+                StringUTF16.putChar(dst, dp++, (char) b1);\n+            } else if ((b1 >> 5) == -2 && (b1 & 0x1e) != 0) {\n+                if (sp < sl) {\n+                    int b2 = src[sp++];\n+                    if (isNotContinuation(b2)) {\n+                        if (!doReplace) {\n+                            throwMalformed(sp - 1, 1);\n+                        }\n+                        StringUTF16.putChar(dst, dp++, REPL);\n+                        sp--;\n+                    } else {\n+                        StringUTF16.putChar(dst, dp++, decode2(b1, b2));\n+                    }\n+                    continue;\n+                }\n+                if (!doReplace) {\n+                    throwMalformed(sp, 1);  \/\/ underflow()\n+                }\n+                StringUTF16.putChar(dst, dp++, REPL);\n+                break;\n+            } else if ((b1 >> 4) == -2) {\n+                if (sp + 1 < sl) {\n+                    int b2 = src[sp++];\n+                    int b3 = src[sp++];\n+                    if (isMalformed3(b1, b2, b3)) {\n+                        if (!doReplace) {\n+                            throwMalformed(sp - 3, 3);\n+                        }\n+                        StringUTF16.putChar(dst, dp++, REPL);\n+                        sp -= 3;\n+                        sp += malformed3(src, sp);\n+                    } else {\n+                        char c = decode3(b1, b2, b3);\n+                        if (Character.isSurrogate(c)) {\n+                            if (!doReplace) {\n+                                throwMalformed(sp - 3, 3);\n+                            }\n+                            StringUTF16.putChar(dst, dp++, REPL);\n+                        } else {\n+                            StringUTF16.putChar(dst, dp++, c);\n+                        }\n+                    }\n+                    continue;\n+                }\n+                if (sp < sl && isMalformed3_2(b1, src[sp])) {\n+                    if (!doReplace) {\n+                        throwMalformed(sp - 1, 2);\n+                    }\n+                    StringUTF16.putChar(dst, dp++, REPL);\n+                    continue;\n+                }\n+                if (!doReplace) {\n+                    throwMalformed(sp, 1);\n+                }\n+                StringUTF16.putChar(dst, dp++, REPL);\n+                break;\n+            } else if ((b1 >> 3) == -2) {\n+                if (sp + 2 < sl) {\n+                    int b2 = src[sp++];\n+                    int b3 = src[sp++];\n+                    int b4 = src[sp++];\n+                    int uc = decode4(b1, b2, b3, b4);\n+                    if (isMalformed4(b2, b3, b4) ||\n+                            !Character.isSupplementaryCodePoint(uc)) { \/\/ shortest form check\n+                        if (!doReplace) {\n+                            throwMalformed(sp - 4, 4);\n+                        }\n+                        StringUTF16.putChar(dst, dp++, REPL);\n+                        sp -= 4;\n+                        sp += malformed4(src, sp);\n+                    } else {\n+                        StringUTF16.putChar(dst, dp++, Character.highSurrogate(uc));\n+                        StringUTF16.putChar(dst, dp++, Character.lowSurrogate(uc));\n+                    }\n+                    continue;\n+                }\n+                b1 &= 0xff;\n+                if (b1 > 0xf4 || sp < sl && isMalformed4_2(b1, src[sp] & 0xff)) {\n+                    if (!doReplace) {\n+                        throwMalformed(sp - 1, 1);  \/\/ or 2\n+                    }\n+                    StringUTF16.putChar(dst, dp++, REPL);\n+                    continue;\n+                }\n+                if (!doReplace) {\n+                    throwMalformed(sp - 1, 1);\n+                }\n+                sp++;\n+                StringUTF16.putChar(dst, dp++, REPL);\n+                if (sp < sl && isMalformed4_3(src[sp])) {\n+                    continue;\n+                }\n+                break;\n+            } else {\n+                if (!doReplace) {\n+                    throwMalformed(sp - 1, 1);\n+                }\n+                StringUTF16.putChar(dst, dp++, REPL);\n+            }\n+        }\n+        return dp;\n+    }\n+\n+    private static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length) {\n+        ByteBuffer bb = ByteBuffer.wrap(src, offset, length);\n+        CharBuffer cb = CharBuffer.wrap(dst, 0, dst.length);\n+        try {\n+            CoderResult cr = cd.decode(bb, cb, true);\n+            if (!cr.isUnderflow())\n+                cr.throwException();\n+            cr = cd.flush(cb);\n+            if (!cr.isUnderflow())\n+                cr.throwException();\n+        } catch (CharacterCodingException x) {\n+            \/\/ Substitution is always enabled,\n+            \/\/ so this shouldn't happen\n+            throw new Error(x);\n+        }\n+        return cb.position();\n+    }\n+\n+    private static int malformed3(byte[] src, int sp) {\n+        int b1 = src[sp++];\n+        int b2 = src[sp];    \/\/ no need to lookup b3\n+        return ((b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n+                isNotContinuation(b2)) ? 1 : 2;\n+    }\n+\n+    private static int malformed4(byte[] src, int sp) {\n+        \/\/ we don't care the speed here\n+        int b1 = src[sp++] & 0xff;\n+        int b2 = src[sp++] & 0xff;\n+        if (b1 > 0xf4 ||\n+                (b1 == 0xf0 && (b2 < 0x90 || b2 > 0xbf)) ||\n+                (b1 == 0xf4 && (b2 & 0xf0) != 0x80) ||\n+                isNotContinuation(b2))\n+            return 1;\n+        if (isNotContinuation(src[sp]))\n+            return 2;\n+        return 3;\n+    }\n+\n+    private static void throwMalformed(int off, int nb) {\n+        String msg = \"malformed input off : \" + off + \", length : \" + nb;\n+        throw new IllegalArgumentException(msg, new MalformedInputException(nb));\n+    }\n+\n+    private static void throwMalformed(byte[] val) {\n+        int dp = 0;\n+        while (dp < val.length && val[dp] >=0) { dp++; }\n+        throwMalformed(dp, 1);\n+    }\n+\n+    private static void throwUnmappable(int off) {\n+        String msg = \"malformed input off : \" + off + \", length : 1\";\n+        throw new IllegalArgumentException(msg, new UnmappableCharacterException(1));\n+    }\n+\n+    private static void throwUnmappable(byte[] val) {\n+        int dp = 0;\n+        while (dp < val.length && val[dp] >=0) { dp++; }\n+        throwUnmappable(dp);\n+    }\n+\n+    private static byte[] encodeUTF8(byte coder, byte[] val, boolean doReplace) {\n+        if (coder == UTF16)\n+            return encodeUTF8_UTF16(val, doReplace);\n+\n+        if (!StringCoding.hasNegatives(val, 0, val.length))\n+            return Arrays.copyOf(val, val.length);\n+\n+        int dp = 0;\n+        byte[] dst = new byte[val.length << 1];\n+        for (byte c : val) {\n+            if (c < 0) {\n+                dst[dp++] = (byte) (0xc0 | ((c & 0xff) >> 6));\n+                dst[dp++] = (byte) (0x80 | (c & 0x3f));\n+            } else {\n+                dst[dp++] = c;\n+            }\n+        }\n+        if (dp == dst.length)\n+            return dst;\n+        return Arrays.copyOf(dst, dp);\n+    }\n+\n+    private static byte[] encodeUTF8_UTF16(byte[] val, boolean doReplace) {\n+        int dp = 0;\n+        int sp = 0;\n+        int sl = val.length >> 1;\n+        byte[] dst = new byte[sl * 3];\n+        char c;\n+        while (sp < sl && (c = StringUTF16.getChar(val, sp)) < '\\u0080') {\n+            \/\/ ascii fast loop;\n+            dst[dp++] = (byte)c;\n+            sp++;\n+        }\n+        while (sp < sl) {\n+            c = StringUTF16.getChar(val, sp++);\n+            if (c < 0x80) {\n+                dst[dp++] = (byte)c;\n+            } else if (c < 0x800) {\n+                dst[dp++] = (byte)(0xc0 | (c >> 6));\n+                dst[dp++] = (byte)(0x80 | (c & 0x3f));\n+            } else if (Character.isSurrogate(c)) {\n+                int uc = -1;\n+                char c2;\n+                if (Character.isHighSurrogate(c) && sp < sl &&\n+                        Character.isLowSurrogate(c2 = StringUTF16.getChar(val, sp))) {\n+                    uc = Character.toCodePoint(c, c2);\n+                }\n+                if (uc < 0) {\n+                    if (doReplace) {\n+                        dst[dp++] = '?';\n+                    } else {\n+                        throwUnmappable(sp - 1);\n+                    }\n+                } else {\n+                    dst[dp++] = (byte)(0xf0 | ((uc >> 18)));\n+                    dst[dp++] = (byte)(0x80 | ((uc >> 12) & 0x3f));\n+                    dst[dp++] = (byte)(0x80 | ((uc >>  6) & 0x3f));\n+                    dst[dp++] = (byte)(0x80 | (uc & 0x3f));\n+                    sp++;  \/\/ 2 chars\n+                }\n+            } else {\n+                \/\/ 3 bytes, 16 bits\n+                dst[dp++] = (byte)(0xe0 | ((c >> 12)));\n+                dst[dp++] = (byte)(0x80 | ((c >>  6) & 0x3f));\n+                dst[dp++] = (byte)(0x80 | (c & 0x3f));\n+            }\n+        }\n+        if (dp == dst.length) {\n+            return dst;\n+        }\n+        return Arrays.copyOf(dst, dp);\n@@ -607,5 +1386,2 @@\n-    public String(byte bytes[], int offset, int length) {\n-        checkBoundsOffCount(offset, length, bytes.length);\n-        StringCoding.Result ret = StringCoding.decode(bytes, offset, length);\n-        this.value = ret.value;\n-        this.coder = ret.coder;\n+    public String(byte[] bytes, int offset, int length) {\n+        this(bytes, offset, length, Charset.defaultCharset());\n@@ -959,1 +1735,1 @@\n-        return StringCoding.encode(charsetName, coder(), value);\n+        return encode(lookupCharset(charsetName), coder(), value);\n@@ -982,1 +1758,1 @@\n-        return StringCoding.encode(charset, coder(), value);\n+        return encode(charset, coder(), value);\n@@ -999,1 +1775,1 @@\n-        return StringCoding.encode(coder(), value);\n+        return encode(Charset.defaultCharset(), coder(), value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":802,"deletions":26,"binary":false,"changes":828,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-.TH \"JAVA\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n+.TH \"JAVA\" \"1\" \"2021\" \"JDK 17\" \"JDK Commands\"\n@@ -184,1 +184,1 @@\n-(\\f[CB]16\\f[R]) and a limited number of previous releases, detailed in the\n+(\\f[CB]17\\f[R]) and a limited number of previous releases, detailed in the\n@@ -4018,0 +4018,10 @@\n+.PP\n+None in JDK 17.\n+.SH REMOVED JAVA OPTIONS\n+.PP\n+These \\f[CB]java\\f[R] options have been removed in JDK 17 and using them\n+results in an error of:\n+.RS\n+.PP\n+\\f[CB]Unrecognized\\ VM\\ option\\f[R] \\f[I]option\\-name\\f[R]\n+.RE\n@@ -4108,0 +4118,3 @@\n+\\f[B]Java Platform, Standard Edition Tools Reference, Release 16\\f[R]\n+[https:\/\/docs.oracle.com\/en\/java\/javase\/16\/docs\/specs\/man\/java.html]\n+.IP \\[bu] 2\n@@ -4793,0 +4806,4 @@\n+These legacy flags are no longer recognized and will cause an error if\n+used directly.\n+Use their unified logging equivalent instead.\n+.PP\n","filename":"src\/java.base\/share\/man\/java.1","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -257,1 +257,0 @@\n-java\/awt\/print\/PrinterJob\/TestPgfmtSetMPA.java 8198343 generic-all\n@@ -520,1 +519,0 @@\n-java\/awt\/Window\/MainKeyWindowTest\/TestMainKeyWindow.java 8213126 macosx-all\n@@ -673,2 +671,0 @@\n-javax\/net\/ssl\/DTLS\/PacketLossRetransmission.java                8169086 macosx-x64\n-javax\/net\/ssl\/DTLS\/RespondToRetransmit.java                     8169086 macosx-x64\n@@ -704,0 +700,2 @@\n+sun\/security\/krb5\/auto\/ReplayCacheTestProcWithMD5.java          8258855 linux-all\n+sun\/security\/krb5\/auto\/ReplayCacheTestProc.java                 8258855 linux-all\n@@ -738,3 +736,0 @@\n-javax\/swing\/JColorChooser\/Test6827032.java 8197825 windows-all\n-javax\/swing\/JTable\/4235420\/bug4235420.java     8079127 generic-all\n-javax\/swing\/JSplitPane\/4201995\/bug4201995.java 8079127 generic-all\n@@ -744,3 +739,0 @@\n-javax\/swing\/JComboBox\/6559152\/bug6559152.java 8196090 windows-all,macosx-all\n-javax\/swing\/JComboBox\/8032878\/bug8032878.java 8196092,8196439 windows-all,macosx-all,linux-all\n-javax\/swing\/JComboBox\/8072767\/bug8072767.java 8196093 windows-all,macosx-all\n@@ -749,1 +741,0 @@\n-javax\/swing\/JFrame\/8175301\/ScaledFrameBackgroundTest.java 8193942 generic-all\n@@ -752,1 +743,0 @@\n-javax\/swing\/JPopupMenu\/6675802\/bug6675802.java 8196097 windows-all\n@@ -756,1 +746,0 @@\n-javax\/swing\/plaf\/basic\/Test6984643.java 8198340 windows-all\n@@ -762,3 +751,0 @@\n-javax\/swing\/JFileChooser\/8062561\/bug8062561.java 8196466 linux-all,macosx-all\n-javax\/swing\/JInternalFrame\/8146321\/JInternalFrameIconTest.java 8225045 linux-all\n-javax\/swing\/JFileChooser\/6868611\/bug6868611.java 7059834 windows-all\n@@ -769,2 +755,0 @@\n-javax\/swing\/PopupFactory\/8048506\/bug8048506.java 8202660 windows-all\n-javax\/swing\/JPopupMenu\/8075063\/ContextMenuScrollTest.java 202880 linux-all\n@@ -774,5 +758,0 @@\n-javax\/swing\/JTree\/6263446\/bug6263446.java 8213125 macosx-all\n-javax\/swing\/JRadioButton\/ButtonGroupFocus\/ButtonGroupFocusTest.java 8233555 macosx-all\n-javax\/swing\/JRadioButton\/8075609\/bug8075609.java 8233555 macosx-all\n-javax\/swing\/JRadioButton\/8033699\/bug8033699.java 8233555 macosx-all\n-javax\/swing\/JMenuItem\/6249972\/bug6249972.java 8233640 macosx-all\n@@ -872,1 +851,0 @@\n-java\/awt\/Component\/UpdatingBootTime\/UpdatingBootTime.html 7194219 linux-all\n@@ -898,0 +876,1 @@\n+java\/awt\/FullScreen\/TranslucentWindow\/TranslucentWindow.java 8258103 linux-all\n","filename":"test\/jdk\/ProblemList.txt","additions":4,"deletions":25,"binary":false,"changes":29,"status":"modified"}]}