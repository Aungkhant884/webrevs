{"files":[{"patch":"@@ -4702,0 +4702,17 @@\n+static bool should_warn_invalid_processor_id() {\n+  if (os::processor_count() == 1) {\n+    \/\/ Don't warn if we only have one processor\n+    return false;\n+  }\n+\n+  static volatile int warn_once = 1;\n+\n+  if (Atomic::load(&warn_once) == 0 ||\n+      Atomic::xchg(&warn_once, 0) == 0) {\n+    \/\/ Don't warn more than once\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n@@ -4705,5 +4722,17 @@\n-#ifndef PRODUCT\n-  if (UseDebuggerErgo1 && id >= _processor_count) {\n-    \/\/ Some debuggers limit the processor count without limiting\n-    \/\/ the returned processor ids. Fake the processor id.\n-    return 0;\n+  if (id < processor_count()) {\n+    return (uint)id;\n+  }\n+\n+  \/\/ Some environments (e.g. openvz containers and the rr debugger) incorrectly\n+  \/\/ report a processor id that is higher than the number of processors available.\n+  \/\/ This is problematic, for example, when implementing CPU-local data structures,\n+  \/\/ where the processor id is used to index into an array of length processor_count().\n+  \/\/ If this happens we return 0 here. This is is safe since we always have at least\n+  \/\/ one processor, but it's not optimal for performance if we're actually executing\n+  \/\/ in an environment with more than one processor.\n+  if (should_warn_invalid_processor_id()) {\n+    log_warning(os)(\"Invalid processor id reported by the operating system \"\n+                    \"(got processor id %d, valid processor id range is 0-%d)\",\n+                    id, processor_count() - 1);\n+    log_warning(os)(\"Falling back to assuming processor id is 0. \"\n+                    \"This could have a negative impact on performance.\");\n@@ -4711,3 +4740,1 @@\n-#endif\n-  assert(id >= 0 && id < _processor_count, \"Invalid processor id [%d]\", id);\n-  return (uint)id;\n+  return 0;\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":35,"deletions":8,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -136,1 +136,5 @@\n-  set_end(mr.end());\n+  \/\/ When expanding concurrently with callers of cas_allocate, setting end\n+  \/\/ makes the new space available for allocation by other threads.  So this\n+  \/\/ assignment must follow all other configuration and initialization that\n+  \/\/ might be done for expansion.\n+  Atomic::release_store(end_addr(), mr.end());\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"runtime\/orderAccess.hpp\"\n@@ -357,3 +356,3 @@\n-  \/\/ Ensure the space bounds are updated and made visible to other\n-  \/\/ threads after the other data structures have been resized.\n-  OrderAccess::storestore();\n+  \/\/ The update of the space's end is done by this call.  As that\n+  \/\/ makes the new space available for concurrent allocation, this\n+  \/\/ must be the last step when expanding.\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2288,1 +2288,1 @@\n-  uint8_t max_depth = 0;\n+  uint16_t max_depth = 0;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -294,0 +294,1 @@\n+  assert(loop->_nest <= SHRT_MAX, \"sanity\");\n@@ -2617,0 +2618,1 @@\n+  assert(depth <= SHRT_MAX, \"sanity\");\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -614,1 +614,1 @@\n-  uint8_t _nest;                \/\/ Nesting depth\n+  uint16_t _nest;               \/\/ Nesting depth\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n@@ -416,9 +417,11 @@\n-    Node* vec_field_ld = LoadNode::make(gvn,\n-                                        ctrl,\n-                                        mem,\n-                                        vec_adr,\n-                                        vec_adr->bottom_type()->is_ptr(),\n-                                        TypeOopPtr::make_from_klass(field->type()->as_klass()),\n-                                        T_OBJECT,\n-                                        MemNode::unordered);\n-    vec_field_ld = gvn.transform(vec_field_ld);\n+    Node* vec_field_ld;\n+    {\n+      DecoratorSet decorators = MO_UNORDERED | IN_HEAP;\n+      C2AccessValuePtr addr(vec_adr, vec_adr->bottom_type()->is_ptr());\n+      MergeMemNode* local_mem = MergeMemNode::make(mem);\n+      gvn.record_for_igvn(local_mem);\n+      BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+      C2OptAccess access(gvn, ctrl, local_mem, decorators, T_OBJECT, obj, addr);\n+      const Type* type = TypeOopPtr::make_from_klass(field->type()->as_klass());\n+      vec_field_ld = bs->load_at(access, type);\n+    }\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -486,0 +486,1 @@\n+  case T_VOID:\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4400,1 +4400,1 @@\n-            System.arraycopy(value, srcPos, dst, dstBegin << coder, length << coder());\n+            System.arraycopy(value, srcPos << coder, dst, dstBegin << coder, length << coder);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-.TH \"JAVA\" \"1\" \"2020\" \"JDK 17\" \"JDK Commands\"\n+.TH \"JAVA\" \"1\" \"2021\" \"JDK 17\" \"JDK Commands\"\n@@ -4098,0 +4098,16 @@\n+.SH REMOVED JAVA OPTIONS\n+.PP\n+These \\f[CB]java\\f[R] options have been removed in JDK 16 and using them\n+results in an error of:\n+.RS\n+.PP\n+\\f[CB]Unrecognized\\ VM\\ option\\f[R] \\f[I]option\\-name\\f[R]\n+.RE\n+.TP\n+.B \\f[CB]\\-XX:+UseParallelOldGC\\f[R]\n+Enables the use of the parallel garbage collector for full GCs.\n+By default, this option is disabled.\n+Enabling it automatically enables the \\f[CB]\\-XX:+UseParallelGC\\f[R]\n+option.\n+.RS\n+.RE\n","filename":"src\/java.base\/share\/man\/java.1","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -831,1 +831,0 @@\n-jdk\/jfr\/jmx\/streaming\/TestRotate.java                           8257215 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}