{"files":[{"patch":"@@ -169,2 +169,0 @@\n-                    currentParser.resetCache();\n-                    \/\/ same conversion as in RecordingInfo\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-            throw new DCmdException(\"Could not open repository.\" + e.getMessage());\n+            throw new DCmdException(\"Could not open repository. \" + e.getMessage());\n@@ -96,1 +96,1 @@\n-        \/\/ 0123456789001234567890012345678900123456789001234567890012345678900123456789001234567890\n+              \/\/ 0123456789001234567890012345678900123456789001234567890012345678900123456789001234567890\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdQuery.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-            throw new DCmdException(\"Could not open repository.\" + e.getMessage());\n+            throw new DCmdException(\"Could not open repository. \" + e.getMessage());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-        Long height = parser.getOption(\"height\");\n+        Long height = parser.getOption(\"cell-height\");\n@@ -103,0 +103,1 @@\n+            list.add(currentChunk());\n@@ -110,0 +111,4 @@\n+    private RepositoryChunk currentChunk() {\n+        return PrivateAccess.getInstance().getPlatformRecorder().getCurrentChunk();\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/QueryRecording.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -173,1 +173,1 @@\n-            return t != null ? t.getFrames().get(0) : null;\n+            return t != null ? t.getFrames().getFirst() : null;\n@@ -333,1 +333,1 @@\n-        for (ValueDescriptor field : reversed(type.getFields())) {\n+        for (ValueDescriptor field : type.getFields().reversed()) {\n@@ -340,1 +340,1 @@\n-                var subFields = reversed(we.field().getFields());\n+                var subFields = we.field().getFields().reversed();\n@@ -357,1 +357,1 @@\n-            Field field = fb.build().get(0);\n+            Field field = fb.build().getFirst();\n@@ -371,6 +371,0 @@\n-    private static List<ValueDescriptor> reversed(List<ValueDescriptor> elements) {\n-        List<ValueDescriptor> result = new ArrayList<>(elements);\n-        Collections.reverse(result);\n-        return result;\n-    }\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/FieldBuilder.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-            return format(field, st.getFrames().get(0), compact);\n+            return format(field, st.getFrames().getFirst(), compact);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/FieldFormatter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        this.width = determinWidth(configuration);\n+        this.width = determineWidth(configuration);\n@@ -48,1 +48,1 @@\n-    private static int determinWidth(Configuration configuration) {\n+    private static int determineWidth(Configuration configuration) {\n@@ -72,1 +72,1 @@\n-            out.println(\"Columns to wide to fit width \" + configuration.width + \".\");\n+            out.println(\"Columns are too wide to fit width \" + configuration.width + \".\");\n@@ -91,1 +91,1 @@\n-        Row row = table.getRows().get(0);\n+        Row row = table.getRows().getFirst();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/FormRenderer.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -497,1 +497,1 @@\n-                return comparables.get(0);\n+                return comparables.getFirst();\n@@ -566,1 +566,1 @@\n-                return numbers.get(0);\n+                return numbers.getFirst();\n@@ -570,0 +570,8 @@\n+            \/\/ Use size + 1 so range is stretched out for interpolation\n+            \/\/ For example with percentile 50%\n+            \/\/ size |  valueIndex |  valueNextindex | fraction\n+            \/\/   2         0               1            0.50\n+            \/\/   3         1               2             0.0\n+            \/\/   4         1               2            0.50\n+            \/\/   5         2               3             0.0\n+            \/\/   6         2               3            0.50\n@@ -571,2 +579,6 @@\n-            if (doubleIndex < 1) {\n-                return numbers.get(0); \/\/ first\n+            int valueIndex = (int) doubleIndex - 1;\n+            int valueNextIndex = (int) doubleIndex;\n+            double fraction = doubleIndex - valueIndex;\n+\n+            if (valueIndex < 0) {\n+                return numbers.getFirst();\n@@ -574,2 +586,2 @@\n-            if (doubleIndex >= numbers.size()) {\n-                return numbers.get(size - 1); \/\/ last\n+            if (valueNextIndex >= size) {\n+                return numbers.getLast();\n@@ -577,5 +589,3 @@\n-            int index = (int) doubleIndex;\n-            double fraction = doubleIndex - index;\n-            double current = numbers.get(index).doubleValue();\n-            double next = numbers.get(index + 1).doubleValue();\n-            return current + fraction * (next - current);\n+            double a = numbers.get(valueIndex).doubleValue();\n+            double b = numbers.get(valueNextIndex).doubleValue();\n+            return a + fraction * (b - a);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/Function.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-            QueryRun task = executor.run().get(0);\n+            QueryRun task = executor.run().getFirst();\n@@ -100,1 +100,1 @@\n-                throw new UserSyntaxException(task.getSyntaxErrors().get(0));\n+                throw new UserSyntaxException(task.getSyntaxErrors().getFirst());\n@@ -103,1 +103,1 @@\n-                throw new UserDataException(task.getMetadataErrors().get(0));\n+                throw new UserDataException(task.getMetadataErrors().getFirst());\n@@ -107,1 +107,1 @@\n-                FilteredType type = table.getFields().get(0).type;\n+                FilteredType type = table.getFields().getFirst().type;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/QueryPrinter.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-        Field primary = fields.get(0);\n+        Field primary = fields.getFirst();\n@@ -351,1 +351,1 @@\n-            return message + \".\\nUse 'SHOW FIELDS \" + types.get(0).getSimpleName() + \"' to list available fields.\";\n+            return message + \".\\nUse 'SHOW FIELDS \" + types.getFirst().getSimpleName() + \"' to list available fields.\";\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/QueryResolver.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-        for (OrderElement orderer : reversed(query.orderBy)) {\n+        for (OrderElement orderer : query.orderBy.reversed()) {\n@@ -146,1 +146,1 @@\n-        sort(table.getFields().get(0), SortOrder.NONE);\n+        sort(table.getFields().getFirst(), SortOrder.NONE);\n@@ -152,6 +152,0 @@\n-\n-    private static List<OrderElement> reversed(List<OrderElement> elements) {\n-        List<OrderElement> result = new ArrayList<>(elements);\n-        Collections.reverse(result);\n-        return result;\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/TableSorter.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-                FilteredType type = table.getFields().get(0).type;\n+                FilteredType type = table.getFields().getFirst().type;\n@@ -148,1 +148,0 @@\n-            \/\/ printViewTypeRelation(views, executor.getEventTypes());\n@@ -168,1 +167,1 @@\n-                QueryRun run = executor.run().get(0);\n+                QueryRun run = executor.run().getFirst();\n@@ -184,1 +183,0 @@\n-    \/\/ Use this method to see which event types that lacks a view\n@@ -198,1 +196,1 @@\n-            if (query.from.get(0).name().equals(\"*\")) {\n+            if (query.from.getFirst().name().equals(\"*\")) {\n@@ -215,4 +213,4 @@\n-          Set<String> vs = viewMap.get(name);\n-           StringJoiner sj = new StringJoiner(\", \");\n-           vs.stream().forEach(sj::add);\n-           out.println(String.format(\"%-35s %s\", name, sj.toString()));\n+            Set<String> vs = viewMap.get(name);\n+            StringJoiner sj = new StringJoiner(\", \");\n+            vs.stream().forEach(sj::add);\n+            out.println(String.format(\"%-35s %s\", name, sj.toString()));\n@@ -224,2 +222,2 @@\n-            String s = ValueFormatter.formatTimestamp(configuration.startTime);\n-            String e = ValueFormatter.formatTimestamp(configuration.endTime);\n+            String start = ValueFormatter.formatTimestamp(configuration.startTime);\n+            String end = ValueFormatter.formatTimestamp(configuration.endTime);\n@@ -227,1 +225,1 @@\n-            out.println(\"Timespan: \" + s + \" - \" + e);\n+            out.println(\"Timespan: \" + start + \" - \" + end);\n@@ -234,1 +232,1 @@\n-            throw new UserSyntaxException(queryRun.getSyntaxErrors().get(0));\n+            throw new UserSyntaxException(queryRun.getSyntaxErrors().getFirst());\n@@ -238,1 +236,1 @@\n-            out.println(queryRun.getMetadataErrors().get(0));\n+            out.println(queryRun.getMetadataErrors().getFirst());\n@@ -243,1 +241,0 @@\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/ViewPrinter.java","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-                if (index != 0 && columns.get(0) == column) {\n+                if (index != 0 && columns.getFirst() == column) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Columnizer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-            return decodeDescriptors(name, \"\").get(0);\n+            return decodeDescriptors(name, \"\").getFirst();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/ValueFormatter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jcmd;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\/**\n+ * @test\n+ * @summary The test verifies JFR.view command\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @requires (vm.gc == \"G1\" | vm.gc == null)\n+ *           & vm.opt.ExplicitGCInvokesConcurrent != false\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm -XX:-ExplicitGCInvokesConcurrent -XX:-DisableExplicitGC\n+ *                   -XX:+UseG1GC jdk.jfr.jcmd.TestJcmdView\n+ *\/\n+public class TestJcmdView {\n+\n+    public static void main(String... args) throws Throwable {\n+        CountDownLatch jvmInformation = new CountDownLatch(1);\n+        CountDownLatch systemGC = new CountDownLatch(1);\n+        CountDownLatch gcHeapSummary = new CountDownLatch(1);\n+        CountDownLatch oldCollection = new CountDownLatch(1);\n+        CountDownLatch garbageCollection = new CountDownLatch(1);\n+\n+        try (RecordingStream rs = new RecordingStream()) {\n+            \/\/ Make sure chunks are not released after consumption\n+            rs.setMaxSize(Long.MAX_VALUE);\n+            rs.enable(\"jdk.JVMInformation\").with(\"period\", \"beginChunk\");\n+            rs.enable(\"jdk.SystemGC\");\n+            rs.enable(\"jdk.GCHeapSummary\");\n+            rs.enable(\"jdk.GarbageCollection\");\n+            rs.enable(\"jdk.OldGarbageCollection\");\n+            rs.enable(\"jdk.YoungGarbageCollection\");\n+            rs.onEvent(\"jdk.JVMInformation\", e -> {\n+                jvmInformation.countDown();\n+                System.out.println(e);\n+            });\n+            rs.onEvent(\"jdk.SystemGC\", e -> {\n+                systemGC.countDown();\n+                System.out.println(e);\n+            });\n+            rs.onEvent(\"jdk.GCHeapSummary\", e -> {\n+                gcHeapSummary.countDown();\n+                System.out.println(e);\n+            });\n+            rs.onEvent(\"jdk.OldGarbageCollection\", e -> {\n+                oldCollection.countDown();\n+                System.out.println(e);\n+            });\n+            rs.onEvent(\"jdk.GarbageCollection\", e-> {\n+                garbageCollection.countDown();\n+                System.out.println(e);\n+            });\n+            rs.startAsync();\n+            \/\/ Emit some GC events\n+            System.gc();\n+            System.gc();\n+            System.gc();\n+            \/\/ Wait for them being in the repository\n+            jvmInformation.await();\n+            systemGC.await();\n+            gcHeapSummary.await();\n+            oldCollection.countDown();\n+            \/\/ Test events that are in the current chunk\n+            testEventType();\n+            testFormView();\n+            testTableView();\n+            rs.disable(\"jdk.JVMInformation\");\n+            \/\/ Force chunk rotation\n+            rotate();\n+            \/\/ Test events that are NOT in current chunk\n+            testEventType();\n+            testFormView();\n+            testTableView();\n+        }\n+    }\n+\n+    private static void rotate() {\n+       try (Recording r = new Recording()) {\n+           r.start();\n+       }\n+    }\n+\n+    private static void testFormView() throws Throwable {\n+        OutputAnalyzer output = JcmdHelper.jcmd(\"JFR.view\", \"jvm-information\");\n+        \/\/ Verify title\n+        output.shouldContain(\"JVM Information\");\n+        \/\/ Verify field label\n+        output.shouldContain(\"VM Arguments:\");\n+        \/\/ Verify field value\n+        long pid = ProcessHandle.current().pid();\n+        String lastThreeDigits = String.valueOf(pid % 1000);\n+        output.shouldContain(lastThreeDigits);\n+    }\n+\n+    private static void testTableView() throws Throwable {\n+        OutputAnalyzer output = JcmdHelper.jcmd(\"JFR.view\", \"verbose=true\", \"gc\");\n+        \/\/ Verify heading\n+        output.shouldContain(\"Longest Pause\");\n+        \/\/ Verify verbose heading\n+        output.shouldContain(\"(longestPause)\");\n+        \/\/ Verify row contents\n+        output.shouldContain(\"Old Garbage Collection\");\n+        \/\/ Verify verbose query\n+        output.shouldContain(\"SELECT\");\n+    }\n+\n+    private static void testEventType() throws Throwable {\n+        OutputAnalyzer output = JcmdHelper.jcmd(\n+             \"JFR.view\", \"verbose=true\", \"width=300\", \"cell-height=100\", \"SystemGC\");\n+        \/\/ Verify title\n+        output.shouldContain(\"System GC\");\n+        \/\/ Verify headings\n+        output.shouldContain(\"Invoked Concurrent\");\n+        \/\/ Verify verbose headings\n+        output.shouldContain(\"invokedConcurrent\");\n+        \/\/ Verify thread value\n+        output.shouldContain(Thread.currentThread().getName());\n+        \/\/ Verify stack frame\n+        output.shouldContain(\"TestJcmdView.main\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jcmd\/TestJcmdView.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -36,0 +36,2 @@\n+ * @requires (vm.gc == \"G1\" | vm.gc == null)\n+ *           & vm.opt.ExplicitGCInvokesConcurrent != false\n@@ -37,1 +39,2 @@\n- * @run main\/othervm jdk.jfr.tool.TestView\n+ * @run main\/othervm -XX:-ExplicitGCInvokesConcurrent -XX:-DisableExplicitGC\n+ *                   -XX:+UseG1GC jdk.jfr.jcmd.TestJcmdView\n@@ -60,1 +63,1 @@\n-        output = ExecuteHelper.jfr(\"print\", \"--wrongOption\", file.toAbsolutePath().toString());\n+        output = ExecuteHelper.jfr(\"view\", \"--wrongOption\", file.toAbsolutePath().toString());\n@@ -82,1 +85,1 @@\n-        output.shouldContain(\"(longestPause\");\n+        output.shouldContain(\"(longestPause)\");\n","filename":"test\/jdk\/jdk\/jfr\/tool\/TestView.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"}]}