{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-COPY := .xsd .xml .dtd\n+COPY := .xsd .xml .dtd .ini\n","filename":"make\/modules\/jdk.jfr\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,0 +55,3 @@\n+  \/\/ JFR.query Uncomment when developing new queries for the JFR.view command\n+  \/\/ DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrQueryFlightRecordingDCmd>(full_export, true, true));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrViewFlightRecordingDCmd>(full_export, true, false));\n@@ -321,1 +324,1 @@\n-    true, \/\/ a DcmdFramework \"option\"\n+    read_boolean_field(argument, \"option\", THREAD),\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -148,0 +148,50 @@\n+class JfrViewFlightRecordingDCmd : public JfrDCmd {\n+ public:\n+  JfrViewFlightRecordingDCmd(outputStream* output, bool heap) : JfrDCmd(output, heap, num_arguments()) {}\n+\n+  static const char* name() {\n+    return \"JFR.view\";\n+  }\n+  static const char* description() {\n+    return \"Display event data in predefined views\";\n+  }\n+  static const char* impact() {\n+    return \"Medium\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\", \"monitor\", NULL};\n+    return p;\n+  }\n+  virtual const char* javaClass() const {\n+    return \"jdk\/jfr\/internal\/dcmd\/DCmdView\";\n+  }\n+  static int num_arguments() {\n+    return 7;\n+  }\n+};\n+\n+class JfrQueryFlightRecordingDCmd : public JfrDCmd {\n+ public:\n+  JfrQueryFlightRecordingDCmd(outputStream* output, bool heap) : JfrDCmd(output, heap, num_arguments()) {}\n+\n+  static const char* name() {\n+    return \"JFR.query\";\n+  }\n+  static const char* description() {\n+    return \"Query and display event data in a tabular form\";\n+  }\n+  static const char* impact() {\n+    return \"Medium\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\", \"monitor\", NULL};\n+    return p;\n+  }\n+  virtual const char* javaClass() const {\n+    return \"jdk\/jfr\/internal\/dcmd\/DCmdQuery\";\n+  }\n+  static int num_arguments() {\n+    return 5;\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.hpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-    private static void emit(long ticks) {\n+    public static void emit(long ticks) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/OldObjectSample.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -423,1 +423,1 @@\n-    private List<RepositoryChunk> makeChunkList(Instant startTime, Instant endTime) {\n+    public List<RepositoryChunk> makeChunkList(Instant startTime, Instant endTime) {\n@@ -441,1 +441,1 @@\n-        return Collections.emptyList();\n+        return new ArrayList<>();\n@@ -457,0 +457,2 @@\n+        \/\/ Decrease initial reference count\n+        chunk.release();\n@@ -662,0 +664,4 @@\n+\n+    public RepositoryChunk getCurrentChunk() {\n+        return currentChunk;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-final class RepositoryChunk {\n+public final class RepositoryChunk {\n@@ -50,1 +50,1 @@\n-    private int refCount = 0;\n+    private int refCount = 1;\n@@ -169,0 +169,8 @@\n+\n+    public long getCurrentFileSize() {\n+        try {\n+            return SecuritySupport.getFileSize(chunkFile);\n+        } catch (IOException e) {\n+            return 0L;\n+        }\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/RepositoryChunk.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+import jdk.jfr.EventType;\n@@ -862,0 +863,8 @@\n+\n+    public static String makeSimpleName(EventType type) {\n+      return makeSimpleName(type.getName());\n+    }\n+\n+    public static String makeSimpleName(String qualified) {\n+        return qualified.substring(qualified.lastIndexOf(\".\") + 1);\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Utils.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,0 +101,1 @@\n+    private long lastFlush;\n@@ -257,1 +258,1 @@\n-                    if (CheckpointType.FLUSH.is(parseCheckpointType())) {\n+                    if ((parseFlushCheckpoint())) {\n@@ -272,2 +273,2 @@\n-    private byte parseCheckpointType() throws IOException {\n-        input.readLong(); \/\/ timestamp\n+    private boolean parseFlushCheckpoint() throws IOException {\n+        long timestamp = input.readLong();\n@@ -276,1 +277,5 @@\n-        return input.readByte();\n+        if (CheckpointType.FLUSH.is(input.readByte())) {\n+            lastFlush = timeConverter.convertTimestamp(timestamp);\n+            return true;\n+        }\n+        return false;\n@@ -485,0 +490,4 @@\n+    public long getLastFlush() {\n+        return lastFlush;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ChunkParser.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,3 +169,1 @@\n-                    long endNanos = currentParser.getStartNanos() + currentParser.getChunkDuration();\n-                    \/\/ same conversion as in RecordingInfo\n-                    if (endNanos > filterEnd) {\n+                    if (currentParser.getLastFlush() > filterEnd) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,2 @@\n+import jdk.jfr.internal.util.Output.LinePrinter;\n+import jdk.jfr.internal.util.Output;\n@@ -53,3 +55,1 @@\n-\n-    private final StringBuilder currentLine = new StringBuilder(80);\n-    private final List<String> lines = new ArrayList<>();\n+    private final LinePrinter output = new LinePrinter();\n@@ -94,1 +94,1 @@\n-        }\n+       }\n@@ -97,0 +97,3 @@\n+    protected final Output getOutput() {\n+        return output;\n+    }\n@@ -103,1 +106,1 @@\n-        return lines.toArray(new String[lines.size()]);\n+        return output.getLines().toArray(new String[0]);\n@@ -184,2 +187,1 @@\n-        lines.add(currentLine.toString());\n-        currentLine.setLength(0);\n+        output.println();\n@@ -189,1 +191,1 @@\n-        currentLine.append(s);\n+        output.print(s);\n@@ -193,1 +195,1 @@\n-        currentLine.append(args.length > 0 ? String.format(s, args) : s);\n+        output.print(s, args);\n@@ -197,2 +199,1 @@\n-        print(s, args);\n-        println();\n+        output.println(s, args);\n@@ -221,0 +222,6 @@\n+    protected final void printHelpText() {\n+        for (String line : printHelp()) {\n+            println(line);\n+        }\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/AbstractDCmd.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+    boolean option,\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/Argument.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+    private final List<String> conflictedOptions = new ArrayList<>();\n@@ -45,2 +46,1 @@\n-\n-    private final List<String> conflictedOptions = new ArrayList<>();\n+    private int argumentIndex;\n@@ -63,0 +63,5 @@\n+            } else {\n+                if (hasArgumentsLeft()) {\n+                    value = key;\n+                    key = nextArgument().name();\n+                }\n@@ -75,0 +80,19 @@\n+    private boolean hasArgumentsLeft() {\n+        for (int index = argumentIndex; index < arguments.length; index++) {\n+            if (!arguments[index].option()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private Argument nextArgument() {\n+        while (argumentIndex < arguments.length) {\n+            Argument argument = arguments[argumentIndex++];\n+            if (!argument.option()) {\n+                return argument;\n+            }\n+        }\n+        return null;\n+    }\n+\n@@ -100,1 +124,1 @@\n-    private void checkMandatory() {\n+    public boolean checkMandatory() {\n@@ -104,1 +128,1 @@\n-                    throw new IllegalArgumentException(\"The argument '\" + arg.name() + \"' is mandatory\");\n+                    return false;\n@@ -108,0 +132,1 @@\n+        return true;\n@@ -197,0 +222,1 @@\n+            case \"JULONG\" -> parseLong(name, text);\n@@ -205,0 +231,16 @@\n+    private Long parseLong(String name, String text) {\n+        if (text == null) {\n+            throw new IllegalArgumentException(\"Parsing error long value: syntax error, value is null\");\n+        }\n+        try {\n+            long value = Long.parseLong(text);\n+            if (value >= 0) {\n+                return value;\n+            }\n+        } catch (NumberFormatException nfe) {\n+          \/\/ fall through\n+        }\n+        String msg = \"Integer parsing error in command argument '\" + name + \"'. Could not parse: \" + text + \".\";\n+        throw new IllegalArgumentException(msg);\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/ArgumentParser.java","additions":47,"deletions":5,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -172,1 +172,1 @@\n-                \"STRING\", false, null, false),\n+                \"STRING\", false, true, null, false),\n@@ -175,1 +175,1 @@\n-                false, \"false\", false)\n+                false, true, \"false\", false)\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdCheck.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -284,1 +284,1 @@\n-               \"STRING\", false, null, false),\n+               \"STRING\", false, true, null, false),\n@@ -287,1 +287,1 @@\n-               \"STRING\", false, null, false),\n+               \"STRING\", false, true, null, false),\n@@ -290,1 +290,1 @@\n-               \"NANOTIME\", false, null, false),\n+               \"NANOTIME\", false, true, null, false),\n@@ -292,1 +292,1 @@\n-               \"MEMORY SIZE\", false, \"hotspot-pid-xxxxx-id-y-YYYY_MM_dd_HH_mm_ss.jfr\", false),\n+               \"MEMORY SIZE\", false, true, \"hotspot-pid-xxxxx-id-y-YYYY_MM_dd_HH_mm_ss.jfr\", false),\n@@ -295,1 +295,1 @@\n-               \"STRING\", false, null, false),\n+               \"STRING\", false, true, null, false),\n@@ -298,1 +298,1 @@\n-               \"STRING\", false, null, false),\n+               \"STRING\", false, true, null, false),\n@@ -301,1 +301,1 @@\n-               \"BOOLEAN\", false, \"false\", false)\n+               \"BOOLEAN\", false, true, \"false\", false)\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdDump.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.dcmd;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.jfr.internal.query.Configuration;\n+import jdk.jfr.internal.query.QueryPrinter;\n+import jdk.jfr.internal.util.UserDataException;\n+import jdk.jfr.internal.util.UserSyntaxException;\n+\n+\/**\n+ * JFR.query\n+ *\/\n+\/\/ Instantiated by native\n+public final class DCmdQuery extends AbstractDCmd {\n+\n+    protected void execute(ArgumentParser parser) throws DCmdException {\n+        parser.checkUnknownArguments();\n+        if (!parser.checkMandatory()) {\n+            println(\"The argument 'query' is mandatory\");\n+            println();\n+            printHelpText();\n+            return;\n+        }\n+\n+        Configuration configuration = new Configuration();\n+        configuration.output = getOutput();\n+        configuration.endTime = Instant.now().minusSeconds(1);\n+        Boolean verbose = parser.getOption(\"verbose\");\n+        if (verbose != null) {\n+            configuration.verboseHeaders = verbose;\n+        }\n+        try (QueryRecording recording = new QueryRecording(configuration, parser)) {\n+            QueryPrinter printer = new QueryPrinter(configuration, recording.getStream());\n+            String query = parser.getOption(\"query\");\n+            printer.execute(stripQuotes(query));\n+        } catch (UserDataException e) {\n+            throw new DCmdException(e.getMessage());\n+        } catch (UserSyntaxException e) {\n+            throw new DCmdException(e.getMessage());\n+        } catch (IOException e) {\n+            throw new DCmdException(\"Could not open repository. \" + e.getMessage());\n+        } catch (IllegalArgumentException e) {\n+            throw new DCmdException(e.getMessage() + \". See help JFR.query\");\n+        }\n+    }\n+\n+    private String stripQuotes(String text) {\n+        if (text.startsWith(\"\\\"\")) {\n+            text = text.substring(1);\n+        }\n+        if (text.endsWith(\"\\\"\")) {\n+            text = text.substring(0, text.length() - 1);\n+        }\n+        return text;\n+    }\n+\n+    @Override\n+    public String[] printHelp() {\n+        List<String> lines = new ArrayList<>();\n+        lines.addAll(getOptions().lines().toList());\n+        lines.add(\"\");\n+        lines.addAll(QueryPrinter.getGrammarText().lines().toList());\n+        lines.add(\"\");\n+        lines.addAll(getExamples().lines().toList());\n+        return lines.toArray(String[]::new);\n+    }\n+\n+    private String getExamples() {\n+              \/\/ 0123456789001234567890012345678900123456789001234567890012345678900123456789001234567890\n+        return \"\"\"\n+                 Example usage:\n+\n+                  $ jcmd <pid> JFR.query '\"SHOW EVENTS\"'\n+\n+                  $ jcmd <pid> JFR.query '\"SHOW FIELDS ObjectAllocationSample\"'\n+\n+                  $ jcmd <pid> JFR.query '\"SELECT * FROM ObjectAllocationSample\"'\n+                                        verbose=true maxsize=10M\n+\n+                  $ jcmd <pid> JFR.query '\"SELECT pid, path FROM SystemProcess\"'\n+                                        width=100\n+\n+                  $ jcmd <pid> JFR.query '\"SELECT stackTrace.topFrame AS T, SUM(weight)\n+                                        FROM ObjectAllocationSample GROUP BY T\"'\n+                                        maxage=100s\n+\n+                  $ jcmd <pid> JFR.query '\"CAPTION 'Method', 'Percentage'\n+                                        FORMAT default, normalized;width:10\n+                                        SELECT stackTrace.topFrame AS T, COUNT(*) AS C\n+                                        GROUP BY T\n+                                        FROM ExecutionSample ORDER BY C DESC\"'\n+\n+                  $ jcmd <pid> JFR.query '\"CAPTION 'Start', 'GC ID', 'Heap Before GC',\n+                                        'Heap After GC', 'Longest Pause'\n+                                        SELECT G.startTime, G.gcId, B.heapUsed,\n+                                               A.heapUsed, longestPause\n+                                        FROM GarbageCollection AS G,\n+                                             GCHeapSummary AS B,\n+                                             GCHeapSummary AS A\n+                                        WHERE B.when = 'Before GC' AND A.when = 'After GC'\n+                                        GROUP BY gcId\n+                                        ORDER BY G.startTime\"'\"\"\";\n+    }\n+\n+    private String getOptions() {\n+             \/\/ 0123456789001234567890012345678900123456789001234567890012345678900123456789001234567890\n+        return \"\"\"\n+                Syntax : JFR.query [options]\n+\n+                Options:\n+\n+                  maxage     (Optional) Length of time for the query to span. (INTEGER followed by\n+                             's' for seconds 'm' for minutes or 'h' for hours, no default value)\n+\n+                  maxsize    (Optional) Maximum size for the query to span in bytes if one of\n+                             the following suffixes is not used: 'm' or 'M' for megabytes OR\n+                             'g' or 'G' for gigabytes. (STRING, no default value)\n+\n+                  <query>    (Mandatory) Query, for example '\"SELECT * FROM GarbageCollection\"'\n+                             See below for grammar. (STRING, no default value)\n+\n+                  verbose    (Optional) Display additional information about the query execution.\n+                             (BOOLEAN, false)\n+\n+                  width      (Optional) Maximum number of horizontal characters. (BOOLEAN, false)\"\"\";\n+    }\n+\n+    @Override\n+    public Argument[] getArgumentInfos() {\n+        return new Argument[] {\n+            new Argument(\"maxage\",\n+                    \"Length of time for the query to span, in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or 0 for no limit\",\n+                    \"NANOTIME\", false, true, \"10m\", false),\n+            new Argument(\"maxsize\",\n+                    \"Maximum size for the query to span, in (M)B or (G)B, e.g. 500M, or 0 for no limit\",\n+                    \"MEMORY SIZE\", false, true, \"100M\", false),\n+            new Argument(\"query\", \"Query, for example 'SELECT * FROM GarbageCollection'\", \"STRING\", true, false,\n+                    null, false),\n+            new Argument(\"verbose\", \"Display additional information about the query execution\", \"BOOLEAN\", false,\n+                    true, \"false\", false),\n+            new Argument(\"width\", \"Maximum number of horizontal characters\", \"JULONG\", false, true, \"100\",\n+                    false), };\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdQuery.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -459,1 +459,1 @@\n-                \"STRING\", false, null, false),\n+                \"STRING\", false, true, null, false),\n@@ -462,1 +462,1 @@\n-                \"STRING SET\", false, \"deafult.jfc\", true),\n+                \"STRING SET\", false, true, \"default.jfc\", true),\n@@ -465,1 +465,1 @@\n-                \"NANOTIME\", false, \"0s\", false),\n+                \"NANOTIME\", false, true, \"0s\", false),\n@@ -468,1 +468,1 @@\n-                \"NANOTIME\", false, null, false),\n+                \"NANOTIME\", false, true, null, false),\n@@ -471,1 +471,1 @@\n-                \"BOOLEAN\", false, \"true\", false),\n+                \"BOOLEAN\", false, true, \"true\", false),\n@@ -474,1 +474,1 @@\n-                \"STRING\", false, \"hotspot-pid-xxxxx-id-y-YYYY_MM_dd_HH_mm_ss.jfr\", false),\n+                \"STRING\", false, true, \"hotspot-pid-xxxxx-id-y-YYYY_MM_dd_HH_mm_ss.jfr\", false),\n@@ -477,1 +477,1 @@\n-                \"NANOTIME\", false, \"0\", false),\n+                \"NANOTIME\", false, true, \"0\", false),\n@@ -480,1 +480,1 @@\n-                \"MEMORY SIZE\", false, \"250M\", false),\n+                \"MEMORY SIZE\", false, true, \"250M\", false),\n@@ -483,1 +483,1 @@\n-                \"NANOTIME\", false, \"1s\", false),\n+                \"NANOTIME\", false, true, \"1s\", false),\n@@ -486,1 +486,1 @@\n-                \"BOOLEAN\", false, \"false\", false),\n+                \"BOOLEAN\", false, true, \"false\", false),\n@@ -489,1 +489,1 @@\n-                \"BOOLEAN\", false, \"false\", false)\n+                \"BOOLEAN\", false, true, \"false\", false)\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdStart.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,1 +107,1 @@\n-                \"STRING\", true, null, false),\n+                \"STRING\", true, true, null, false),\n@@ -110,1 +110,1 @@\n-                \"STRING\", false, null, false)\n+                \"STRING\", false, true, null, false)\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdStop.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.dcmd;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.jfr.internal.OldObjectSample;\n+import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.query.Configuration;\n+import jdk.jfr.internal.query.QueryPrinter;\n+import jdk.jfr.internal.query.ViewPrinter;\n+import jdk.jfr.internal.util.Columnizer;\n+import jdk.jfr.internal.util.UserDataException;\n+import jdk.jfr.internal.util.UserSyntaxException;\n+\/**\n+ * JFR.view\n+ * <p>\n+ * The implementation is also used by DCmdQuery since there\n+ * is little difference between JFR.query and JFR.view.\n+ *\/\n+\/\/ Instantiated by native\n+public class DCmdView extends AbstractDCmd {\n+\n+    protected void execute(ArgumentParser parser) throws DCmdException {\n+        parser.checkUnknownArguments();\n+        if (!parser.checkMandatory()) {\n+            println(\"The argument 'view' is mandatory\");\n+            println();\n+            printHelpText();\n+            return;\n+        }\n+        Configuration configuration = new Configuration();\n+        configuration.output = getOutput();\n+        configuration.endTime = Instant.now().minusSeconds(1);\n+        String view = parser.getOption(\"view\");\n+        if (view.startsWith(\"memory-leaks\")) {\n+            \/\/ Make sure old object sample event is part of data.\n+            OldObjectSample.emit(0);\n+            Utils.waitFlush(10_000);\n+            configuration.endTime = Instant.now();\n+        }\n+        try (QueryRecording recording = new QueryRecording(configuration, parser)) {\n+            ViewPrinter printer = new ViewPrinter(configuration, recording.getStream());\n+            printer.execute(view);\n+        } catch (UserDataException e) {\n+            throw new DCmdException(e.getMessage());\n+        } catch (UserSyntaxException e) {\n+            throw new DCmdException(e.getMessage());\n+        } catch (IOException e) {\n+            throw new DCmdException(\"Could not open repository. \" + e.getMessage());\n+        } catch (IllegalArgumentException e) {\n+            throw new DCmdException(e.getMessage() + \". See help JFR.view\");\n+        }\n+    }\n+\n+    @Override\n+    public String[] printHelp() {\n+        List<String> lines = new ArrayList<>();\n+        lines.addAll(getOptions().lines().toList());\n+        lines.add(\"\");\n+        lines.addAll(ViewPrinter.getAvailableViews());\n+        lines.add(\"\");\n+        lines.add(\" The <view> parameter can be an event type name. Use the 'JFR.view types'\");\n+        lines.add(\" to see a list. To display all views, use 'JFR.view all-views'. To display\");\n+        lines.add(\" all events, use 'JFR.view all-events'.\");\n+        lines.add(\"\");\n+        lines.addAll(getExamples().lines().toList());\n+        return lines.toArray(String[]::new);\n+    }\n+\n+    public String getOptions() {\n+        \/\/ 0123456789001234567890012345678900123456789001234567890012345678900123456789001234567890\n+        return \"\"\"\n+                Options:\n+\n+                 cell-height   (Optional) Maximum number of rows in a table cell. (INTEGER, no default value)\n+\n+                 maxage        (Optional) Length of time for the view to span. (INTEGER followed by\n+                               's' for seconds 'm' for minutes or 'h' for hours, default value is 10m)\n+\n+                 maxsize       (Optional) Maximum size for the view to span in bytes if one of\n+                               the following suffixes is not used: 'm' or 'M' for megabytes OR\n+                               'g' or 'G' for gigabytes. (STRING, default value is 32MB)\n+\n+                 truncate      (Optional) How to truncate content that exceeds space in a table cell.\n+                               Mode can be 'beginning' or 'end'. (STRING, default value 'end')\n+\n+                 verbose       (Optional) Displays the query that makes up the view.\n+                               (BOOLEAN, default value false)\n+\n+                 <view>        (Mandatory) Name of the view or event type to display.\n+                               See list below for available views. (STRING, no default value)\n+\n+                 width         (Optional) The width of the view in characters\n+                               (INTEGER, no default value)\"\"\";\n+    }\n+\n+    public String getExamples() {\n+        return \"\"\"\n+                Example usage:\n+\n+                 $ jcmd <pid> JFR.view gc\n+\n+                 $ jcmd <pid< JFR.view width=160 hot-methods\n+\n+                 $ jcmd <pid> JFR.view verbose=true allocation-by-class\n+\n+                 $ jcmd <pid> JFR.view contention-by-site\n+\n+                 $ jcmd <pid> JFR.view jdk.GarbageCollection\n+\n+                 $ jcmd <pid> JFR.view cell-height=5 ThreadStart\n+\n+                 $ jcmd <pid> JFR.view truncate=beginning SystemProcess\"\"\";\n+    }\n+\n+    @Override\n+    public Argument[] getArgumentInfos() {\n+        return new Argument[] {\n+            new Argument(\"cell-height\",\n+                \"Maximum heigth of a table cell\",\n+                \"JULONG\", false, true, \"1\", false),\n+            new Argument(\"maxage\",\n+                \"Maximum duration of data to view, in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or 0 for no limit\",\n+                \"NANOTIME\", false, true, \"10m\", false),\n+            new Argument(\"maxsize\",\n+                \"Maximum amount of bytes to view, in (M)B or (G)B, e.g. 500M, or 0 for no limit\",\n+                \"MEMORY SIZE\", false, true, \"100M\", false),\n+            new Argument(\"truncate\",\n+                \"Truncation mode if value doesn't fit in a table cell, valid values are 'beginning' and 'end'\",\n+                \"STRING\", false, true, \"end\", false),\n+            new Argument(\"verbose\",\n+                \"Display additional information about the view, such as the underlying query\",\n+                \"BOOLEAN\", false, true, \"false\", false),\n+            new Argument(\"view\",\n+                \"Name of the view, for example hot-methods\",\n+                \"STRING\", true, false, null, false),\n+            new Argument(\"width\",\n+                \"Maximum number of horizontal characters\",\n+                \"JULONG\", false, true, \"100\", false)\n+        };\n+   }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdView.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.dcmd;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.consumer.EventStream;\n+import jdk.jfr.internal.PlatformRecorder;\n+import jdk.jfr.internal.PrivateAccess;\n+import jdk.jfr.internal.RepositoryChunk;\n+import jdk.jfr.internal.query.Configuration;\n+import jdk.jfr.internal.query.QueryPrinter;\n+import jdk.jfr.internal.query.ViewPrinter;\n+import jdk.jfr.internal.query.Configuration.Truncate;\n+import jdk.jfr.internal.util.UserDataException;\n+import jdk.jfr.internal.util.UserSyntaxException;\n+import jdk.jfr.internal.util.Output;\n+\n+\/**\n+ * Helper class that holds recording chunks alive during a query. It also helps\n+ * out with configuration shared by DCmdView and DCmdQuery\n+ *\/\n+final class QueryRecording implements AutoCloseable {\n+    private final long DEFAULT_MAX_SIZE = 32 * 1024 * 1024L;\n+    private final long DEFAULT_MAX_AGE = 60 * 10;\n+\n+    private final PlatformRecorder recorder;\n+    private final List<RepositoryChunk> chunks;\n+    private final EventStream eventStream;\n+    private final Instant endTime;\n+\n+    public QueryRecording(Configuration configuration, ArgumentParser parser) throws IOException, DCmdException {\n+        if (!FlightRecorder.isInitialized()) {\n+            throw new DCmdException(\"No recording data available. Start a recording with JFR.start\");\n+        }\n+        recorder = PrivateAccess.getInstance().getPlatformRecorder();\n+        Boolean verbose = parser.getOption(\"verbose\");\n+        if (verbose != null) {\n+            configuration.verbose = verbose;\n+        }\n+        configuration.truncate = valueOf(parser.getOption(\"truncate\"));\n+        Long width = parser.getOption(\"width\");\n+        if (width != null) {\n+            configuration.width = (int) Math.min(Integer.MAX_VALUE, width.longValue());\n+        }\n+        Long height = parser.getOption(\"cell-height\");\n+        if (height != null) {\n+            if (height < 1) {\n+                throw new DCmdException(\"Height must be at least 1\");\n+            }\n+            configuration.cellHeight = (int) Math.min(Integer.MAX_VALUE, height.longValue());\n+        }\n+        Long maxAge = parser.getOption(\"maxage\");\n+\n+        Long maxSize = parser.getOption(\"maxsize\");\n+        if (maxSize == null) {\n+            maxSize = DEFAULT_MAX_SIZE;;\n+        }\n+        Instant startTime = Instant.EPOCH;\n+        endTime = configuration.endTime;\n+        if (maxAge != null) {\n+            startTime = endTime.minus(Duration.ofNanos(maxAge));\n+        } else {\n+            startTime = endTime.minus(Duration.ofSeconds(DEFAULT_MAX_AGE));\n+        }\n+        chunks = acquireChunks(startTime);\n+        Instant streamStart = determineStreamStart(maxSize, startTime);\n+        configuration.startTime = streamStart;\n+        eventStream = makeStream(streamStart);\n+    }\n+\n+    private List<RepositoryChunk> acquireChunks(Instant startTime) {\n+        synchronized (recorder) {\n+            List<RepositoryChunk> list = recorder.makeChunkList(startTime, endTime);\n+            list.add(currentChunk());\n+            for (RepositoryChunk r : list) {\n+                r.use();\n+            }\n+            return list;\n+        }\n+    }\n+\n+    private RepositoryChunk currentChunk() {\n+        return PrivateAccess.getInstance().getPlatformRecorder().getCurrentChunk();\n+    }\n+\n+    private void releaseChunks() {\n+        synchronized (recorder) {\n+            for (RepositoryChunk r : chunks) {\n+                r.release();\n+            }\n+        }\n+    }\n+\n+    private EventStream makeStream(Instant startTime) throws IOException {\n+        EventStream es = EventStream.openRepository();\n+        es.setStartTime(startTime);\n+        es.setEndTime(endTime);\n+        return es;\n+    }\n+\n+    private Instant determineStreamStart(Long maxSize, Instant startTime) {\n+        ListIterator<RepositoryChunk> iterator = chunks.listIterator(chunks.size());\n+        long size = 0;\n+        while (iterator.hasPrevious()) {\n+            RepositoryChunk r = iterator.previous();\n+            if (r.isFinished()) {\n+                size += r.getSize();\n+                if (size > maxSize) {\n+                    return r.getStartTime().isAfter(startTime) ? r.getStartTime() : startTime;\n+                }\n+            } else {\n+                size += r.getCurrentFileSize();\n+            }\n+        }\n+        return startTime;\n+    }\n+\n+    private Truncate valueOf(String truncate) throws DCmdException {\n+        if (truncate == null || truncate.equals(\"end\")) {\n+            return Truncate.END;\n+        }\n+        if (truncate.equals(\"beginning\")) {\n+            return Truncate.BEGINNING;\n+        }\n+        throw new DCmdException(\"Truncate must be 'end' or 'beginning\");\n+    }\n+\n+    public EventStream getStream() {\n+        return eventStream;\n+    }\n+\n+    @Override\n+    public void close() {\n+        eventStream.close();\n+        releaseChunks();\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/QueryRecording.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.query;\n+\n+\/**\n+ * Enum describing the different ways values can be aggregated.\n+ *\/\n+enum Aggregator {\n+    \/**\n+     * Dummy to indicate no aggregation is being used.\n+     *\/\n+    MISSING(\" \"),\n+    \/**\n+     * Calculate the average value of all finite numeric values.\n+     *\/\n+    AVERAGE(\"AVG\"),\n+    \/**\n+     * Calculate the number of elements, including {@code null}.\n+     *\/\n+    COUNT(\"COUNT\"),\n+    \/**\n+     * Calculate the difference between the last and first finite numeric value.\n+     *\/\n+    DIFFERENCE(\"DIFF\"),\n+    \/**\n+     * The first value, including {@code null}.\n+     *\/\n+    FIRST(\"FIRST\"),\n+    \/**\n+     * The last value, including {@code null}.\n+     *\/\n+    LAST(\"LAST\"),\n+    \/**\n+     * Aggregate values into a comma-separated list, including {@code null}.\n+     *\/\n+    LIST(\"LIST\"),\n+    \/**\n+     * The highest numeric value.\n+     *\/\n+    MAXIMUM(\"MAX\"),\n+    \/**\n+     * The median of all finite numeric values.\n+     *\/\n+    MEDIAN(\"MEDIAN\"),\n+    \/**\n+     * The lowest numeric value.\n+     *\/\n+    MINIMUM(\"MIN\"),\n+    \/**\n+     * Calculate the 90th percentile of all finite numeric values.\n+     *\/\n+    P90(\"P90\"),\n+    \/**\n+     * Calculate the 95th percentile of all finite numeric values.\n+     *\/\n+    P95(\"P95\"),\n+    \/**\n+     * Calculate the 99th percentile of all finite numeric values.\n+     *\/\n+    P99(\"P99\"),\n+    \/**\n+     * Calculate the 99.9th percentile of all finite numeric values.\n+     *\/\n+    P999(\"P999\"),\n+    \/**\n+     * Calculate the standard deviation of all finite numeric values.\n+     *\/\n+    STANDARD_DEVIATION(\"STDEV\"),\n+    \/**\n+     * Calculate the sum of all finite numeric values.\n+     *\/\n+    SUM(\"SUM\"),\n+    \/**\n+     * Calculates the number of distinct values determined by invoking Object.equals.\n+     *\/\n+    UNIQUE(\"UNIQUE\"),\n+    \/**\n+     * The last elements, for an event type, that all share the same end timestamp.\n+     *\/\n+    LAST_BATCH(\"LAST_BATCH\");\n+\n+    public final String name;\n+\n+    private Aggregator(String name) {\n+        this.name = name;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/Aggregator.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.query;\n+\n+import java.time.Instant;\n+\n+import jdk.jfr.internal.util.Output;\n+\n+\/**\n+ * Holds information on how a query should be rendered.\n+ *\/\n+public final class Configuration {\n+    public static final int MAX_PREFERRED_WIDTH = 120;\n+    public static final int MIN_PREFERRED_WIDTH = 40;\n+    public static final int PREFERRED_WIDTH = 80;\n+\n+    public enum Truncate {\n+        BEGINNING, END\n+    }\n+\n+    \/**\n+     * Where the rendered result should be printed.\n+     *\/\n+    public Output output;\n+\n+    \/**\n+     * The title of the table or form.\n+     * <p>\n+     * {@code null) means no title.\n+     *\/\n+    public String title;\n+\n+    \/**\n+     * Truncation mode if text overflows.\n+     * <p>\n+     * If truncate is not set, it will be determined by heuristics.\n+     *\/\n+    public Truncate truncate;\n+\n+    \/**\n+     * Height of table cells.\n+     * <p>\n+     * If cellHeight is not set, it will be determined by heuristics.\n+     *\/\n+    public int cellHeight;\n+\n+    \/**\n+     * Width of a table or form.\n+     * <p>\n+     * If width is not set, it will be determined by heuristics.\n+     *\/\n+    public int width;\n+\n+    \/**\n+     * If additional information should be printed.\n+     *\/\n+    public boolean verbose;\n+\n+    \/**\n+     * If symbolic names should be printed for table headers.\n+     *\/\n+    public boolean verboseHeaders;\n+\n+    \/**\n+     * If the title of the table or form should be printed.\n+     *\/\n+    public boolean verboseTitle;\n+\n+    \/**\n+     * The start time for the query.\n+     * <p>\n+     * {@code null) means no start time.\n+     *\/\n+    public Instant startTime;\n+\n+    \/**\n+     * The end time for the query.\n+     * <p>\n+     * {@code null) means no end time.\n+     *\/\n+    public Instant endTime;\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/Configuration.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.query;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.internal.query.Configuration.Truncate;\n+import jdk.jfr.internal.query.Query.Grouper;\n+import jdk.jfr.internal.query.Query.OrderElement;\n+\n+\/**\n+ * Field is the core class of the package.\n+ * <p>\n+ * It contains all the information related to how a field in a query should be\n+ * grouped, sorted, formatted and aggregated.\n+ * <p>\n+ * Defaults are derived from the metadata available in the event type, for\n+ * example, numeric fields are right-aligned in the output, but can also\n+ * be set using query clauses COLUMN and FORMAT.\n+ * <p>\n+ * Settings in {@Configuration} overrides any field setting.\n+ *\/\n+final class Field {\n+    \/\/ The fields to use as data sources, for example, when a\n+    \/\/ field references multiple event types. First field\n+    \/\/ is always the same as this field.\n+    \/\/ (It's confusing, but hard to come up with an another\n+    \/\/ abstraction that doesn't complicate the implementation.)\n+    final List<Field> sourceFields = new ArrayList<>();\n+\n+    \/\/ Source type\n+    final FilteredType type;\n+\n+    \/\/ Symbolic name\n+    final String name;\n+\n+    \/\/ Index in the fields list\n+    int index;\n+\n+    \/\/ Human readable name\n+    String label;\n+\n+    \/\/ Function to extract a value from an event object\n+    Function<RecordedEvent, Object> valueGetter;\n+\n+    \/\/ Set if the field is part of GROUP BY clause\n+    Grouper grouper;\n+\n+    \/\/ Set if the field is part of ORDER BY clause\n+    OrderElement orderer;\n+\n+    \/\/ Set if the field is part of an aggregation\n+    Aggregator aggregator = Aggregator.MISSING;\n+\n+    \/\/ Height of a table cell\n+    int cellHeight = 1;\n+\n+    \/\/ Truncation mode (beginning or end)\n+    Truncate truncate;\n+\n+    \/\/ If the value visible\n+    boolean visible;\n+\n+    \/\/ Should value be aligned left\n+    boolean alignLeft;\n+\n+    \/\/ Should value be normalized between 0.0 and 1.0\n+    boolean normalized;\n+\n+    \/\/ Should column be sorted textually\n+    boolean lexicalSort;\n+\n+    \/\/ A percentage value\n+    boolean percentage;\n+\n+    \/\/ A frequency value\n+    boolean frequency;\n+\n+    \/\/ A memory address\n+    boolean memoryAddress;\n+\n+    \/\/ A byte value\n+    boolean bytes;\n+\n+    \/\/ A bits value\n+    boolean bits;\n+\n+    \/\/ A fractional type (double or float)\n+    boolean fractionalType;\n+\n+    \/\/ An integral type (byte, short, int, long)\n+    boolean integralType;\n+\n+    \/\/ A java.time.Duration\n+    boolean timespan;\n+\n+    \/\/ A java.time.Instant\n+    boolean timestamp;\n+\n+    \/\/ Used by LAST_BATCH aggregator\n+    Instant last = Instant.EPOCH;\n+\n+    \/\/ The data type, for example, jdk.types.Frame or java.lang.String\n+    String dataType;\n+\n+    \/\/ Should not be given additional whitespace if available\n+    public boolean fixedWidth;\n+\n+    \/\/ Text to render if value is missing, typically used when value is null\n+    public String missingText = \"N\/A\";\n+\n+    public Field(FilteredType type, String name) {\n+        this.type = type;\n+        this.name = name;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return type.getName() + \"#\" + name;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/Field.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -0,0 +1,422 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.query;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import jdk.jfr.DataAmount;\n+import jdk.jfr.EventType;\n+import jdk.jfr.Frequency;\n+import jdk.jfr.MemoryAddress;\n+import jdk.jfr.Percentage;\n+import jdk.jfr.Timespan;\n+import jdk.jfr.Timestamp;\n+import jdk.jfr.ValueDescriptor;\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedClassLoader;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedFrame;\n+import jdk.jfr.consumer.RecordedStackTrace;\n+\n+\/**\n+ * This is a helper class to QueryResolver. It handles the creation of fields\n+ * and their default configuration.\n+ * <p>\n+ * The class applies heuristics to decide how values should be formatted,\n+ * and labeled.\n+ *\/\n+final class FieldBuilder {\n+    private static final Set<String> KNOWN_TYPES = createKnownTypes();\n+    private final List<EventType> eventTypes;\n+    private final ValueDescriptor descriptor;\n+    private final Field field;\n+    private final String fieldName;\n+\n+    public FieldBuilder(List<EventType> eventTypes, FilteredType type, String fieldName) {\n+        this.eventTypes = eventTypes;\n+        this.descriptor = type.getField(fieldName);\n+        this.field = new Field(type, fieldName);\n+        this.fieldName = fieldName;\n+    }\n+\n+    public List<Field> build() {\n+        if (configureSyntheticFields()) {\n+            field.fixedWidth = false;\n+            return List.of(field);\n+        }\n+\n+        if (descriptor != null) {\n+            field.fixedWidth = !descriptor.getTypeName().equals(\"java.lang.String\");\n+            field.dataType = descriptor.getTypeName();\n+            field.label = makeLabel(descriptor, hasDuration());\n+            field.alignLeft = true;\n+            field.valueGetter = valueGetter(field.name);\n+\n+            configureNumericTypes();\n+            configureTime();\n+            configurePercentage();\n+            configureDataAmount();\n+            configureFrequency();\n+            configureMemoryAddress();\n+            configureKnownType();\n+            return List.of(field);\n+        }\n+        return List.of();\n+    }\n+\n+    private static Function<RecordedEvent, Object> valueGetter(String name) {\n+        return event -> {\n+            try {\n+                return event.getValue(name);\n+            } catch (NullPointerException e) {\n+                \/\/ This can happen when accessing a nested structure\n+                \/\/ that is null, for example root.referrer\n+                return null;\n+            }\n+        };\n+    }\n+\n+    private boolean hasDuration() {\n+        return field.type.getField(\"duration\") != null;\n+    }\n+\n+    private boolean configureSyntheticFields() {\n+        if (fieldName.equals(\"stackTrace.topApplicationFrame\")) {\n+            configureTopApplicationFrameField();\n+            return true;\n+        }\n+        if (fieldName.equals(\"stackTrace.notInit\")) {\n+            configureNotInitFrameField();\n+            return true;\n+        }\n+\n+        if (fieldName.equals(\"stackTrace.topFrame\")) {\n+            configureTopFrameField();\n+            return true;\n+        }\n+        if (fieldName.equals(\"id\") && field.type.getName().equals(\"jdk.ActiveSetting\")) {\n+            configureEventTypeIdField();\n+            return true;\n+        }\n+        if (fieldName.equals(\"eventType.label\")) {\n+            configureEventType(e -> e.getEventType().getLabel());\n+            return true;\n+        }\n+        if (fieldName.equals(\"eventType.name\")) {\n+            configureEventType(e -> e.getEventType().getName());\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private void configureEventTypeIdField() {\n+        Map<Long, String> eventTypes = createEventTypeLookup();\n+        field.alignLeft = true;\n+        field.label = \"Event Type\";\n+        field.dataType = String.class.getName();\n+        field.valueGetter = event -> eventTypes.get(event.getLong(\"id\"));\n+        field.lexicalSort = true;\n+        field.integralType = false;\n+    }\n+\n+    private Map<Long, String> createEventTypeLookup() {\n+        Map<Long, String> map = new HashMap<>();\n+        for (EventType eventType : eventTypes) {\n+            String label = eventType.getLabel();\n+            if (label == null) {\n+                label = eventType.getName();\n+            }\n+            map.put(eventType.getId(), label);\n+        }\n+        return map;\n+    }\n+\n+    private void configureTopFrameField() {\n+        field.alignLeft = true;\n+        field.label = \"Method\";\n+        field.dataType = \"jdk.types.Method\";\n+        field.valueGetter = e -> {\n+            RecordedStackTrace t = e.getStackTrace();\n+            return t != null ? t.getFrames().getFirst() : null;\n+        };\n+        field.lexicalSort = true;\n+    }\n+\n+    private void configureCustomFrame(Predicate<RecordedFrame> condition) {\n+        field.alignLeft = true;\n+        field.dataType = \"jdk.types.Frame\";\n+        field.label = \"Method\";\n+        field.lexicalSort = true;\n+        field.valueGetter = e -> {\n+            RecordedStackTrace t = e.getStackTrace();\n+            if (t != null) {\n+                for (RecordedFrame f : t.getFrames()) {\n+                    if (f.isJavaFrame()) {\n+                        if (condition.test(f)) {\n+                            return f;\n+                        }\n+                    }\n+                }\n+            }\n+            return null;\n+        };\n+    }\n+\n+    private void configureNotInitFrameField() {\n+        configureCustomFrame(frame -> {\n+            return !frame.getMethod().getName().equals(\"<init>\");\n+        });\n+    }\n+\n+    private void configureTopApplicationFrameField() {\n+        configureCustomFrame(frame -> {\n+            RecordedClass cl = frame.getMethod().getType();\n+            RecordedClassLoader classLoader = cl.getClassLoader();\n+            return classLoader != null && !\"bootstrap\".equals(classLoader.getName());\n+        });\n+    }\n+\n+    private void configureEventType(Function<RecordedEvent, Object> retriever) {\n+        field.alignLeft = true;\n+        field.dataType = String.class.getName();\n+        field.label = \"Event Type\";\n+        field.valueGetter = retriever;\n+        field.lexicalSort = true;\n+    }\n+\n+    private static String makeLabel(ValueDescriptor v, boolean hasDuration) {\n+        String label = v.getLabel();\n+        if (label == null) {\n+            return v.getName();\n+        }\n+        String name = v.getName();\n+        if (name.equals(\"gcId\")) {\n+            return \"GC ID\";\n+        }\n+        if (name.equals(\"compilerId\")) {\n+            return \"Compiler ID\";\n+        }\n+        if (name.equals(\"startTime\") && !hasDuration) {\n+                return \"Time\";\n+        }\n+        return label;\n+    }\n+\n+    private void configureTime() {\n+        Timestamp timestamp = descriptor.getAnnotation(Timestamp.class);\n+        if (timestamp != null) {\n+            field.alignLeft = true;\n+            field.dataType = Instant.class.getName();\n+            field.timestamp = true;\n+            field.valueGetter = e -> e.getInstant(fieldName);\n+        }\n+        Timespan timespan = descriptor.getAnnotation(Timespan.class);\n+        if (timespan != null) {\n+            field.alignLeft = false;\n+            field.dataType = Duration.class.getName();\n+            field.timespan = true;\n+            field.valueGetter = e -> e.getDuration(fieldName);\n+        }\n+    }\n+\n+    private void configureNumericTypes() {\n+        switch (descriptor.getTypeName()) {\n+        case \"int\":\n+        case \"long\":\n+        case \"short\":\n+        case \"byte\":\n+            field.integralType = true;\n+            field.alignLeft = false;\n+            break;\n+        case \"float\":\n+        case \"double\":\n+            field.fractionalType = true;\n+            field.alignLeft = false;\n+            break;\n+        case \"boolean\":\n+            field.alignLeft = false;\n+            break;\n+        }\n+    }\n+\n+    private void configureKnownType() {\n+        String type = descriptor.getTypeName();\n+        if (KNOWN_TYPES.contains(type)) {\n+            field.lexicalSort = true;\n+            field.fixedWidth = false;\n+        }\n+    }\n+\n+    private void configureMemoryAddress() {\n+        MemoryAddress memoryAddress = descriptor.getAnnotation(MemoryAddress.class);\n+        if (memoryAddress != null) {\n+            field.memoryAddress = true;\n+            field.alignLeft = true;\n+        }\n+    }\n+\n+    private void configureFrequency() {\n+        if (descriptor.getAnnotation(Frequency.class) != null) {\n+            field.frequency = true;\n+        }\n+    }\n+\n+    private void configureDataAmount() {\n+        DataAmount dataAmount = descriptor.getAnnotation(DataAmount.class);\n+        if (dataAmount != null) {\n+            if (DataAmount.BITS.equals(dataAmount.value())) {\n+                field.bits = true;\n+            }\n+            if (DataAmount.BYTES.equals(dataAmount.value())) {\n+                field.bytes = true;\n+            }\n+        }\n+    }\n+\n+    private void configurePercentage() {\n+        Percentage percentage = descriptor.getAnnotation(Percentage.class);\n+        if (percentage != null) {\n+            field.percentage = true;\n+        }\n+    }\n+\n+    \/\/ Fields created with \"SELECT * FROM ...\" queries\n+    public static List<Field> createWildcardFields(List<EventType> eventTypes, List<FilteredType> types) {\n+        List<Field> result = new ArrayList<>();\n+        for (FilteredType type : types) {\n+            result.addAll(createWildcardFields(eventTypes, type));\n+        }\n+        return result;\n+    }\n+\n+    private static List<Field> createWildcardFields(List<EventType> eventTypes, FilteredType type) {\n+        record WildcardElement(String name, String label, ValueDescriptor field) {\n+        }\n+\n+        var visited = new HashSet<ValueDescriptor>();\n+        var stack = new ArrayDeque<WildcardElement>();\n+        var wildcardElements = new ArrayList<WildcardElement>();\n+\n+        for (ValueDescriptor field : type.getFields().reversed()) {\n+            stack.push(new WildcardElement(field.getName(), makeLabel(field, hasDuration(type)), field));\n+        }\n+        while (!stack.isEmpty()) {\n+            var we = stack.pop();\n+            if (!visited.contains(we.field)) {\n+                visited.add(we.field);\n+                var subFields = we.field().getFields().reversed();\n+                if (!subFields.isEmpty() && !KNOWN_TYPES.contains(we.field().getTypeName())) {\n+                    for (ValueDescriptor subField : subFields) {\n+                        String n = we.name + \".\" + subField.getName();\n+                        String l = we.label + \" : \" + makeLabel(subField, false);\n+                        if (stack.size() < 2) { \/\/ Limit depth to 2\n+                            stack.push(new WildcardElement(n, l, subField));\n+                        }\n+                    }\n+                } else {\n+                    wildcardElements.add(we);\n+                }\n+            }\n+        }\n+        List<Field> result = new ArrayList<>();\n+        for (WildcardElement we : wildcardElements) {\n+            FieldBuilder fb = new FieldBuilder(eventTypes, type, we.name());\n+            Field field = fb.build().getFirst();\n+            field.label = we.label;\n+            field.index = result.size();\n+            field.visible = true;\n+            field.sourceFields.add(field);\n+            result.add(field);\n+        }\n+        return result;\n+    }\n+\n+    private static boolean hasDuration(FilteredType type) {\n+        return type.getField(\"duration\") != null;\n+    }\n+\n+    public static void configureAggregator(Field field) {\n+        Aggregator aggregator = field.aggregator;\n+        if (aggregator == Aggregator.COUNT || aggregator == Aggregator.UNIQUE) {\n+            field.integralType = true;\n+            field.timestamp = false;\n+            field.timespan = false;\n+            field.fractionalType = false;\n+            field.bytes = false;\n+            field.bits = false;\n+            field.frequency = false;\n+            field.memoryAddress = false;\n+            field.percentage = false;\n+            field.alignLeft = false;\n+            field.lexicalSort = false;\n+        }\n+        if (aggregator == Aggregator.LIST) {\n+            field.alignLeft = true;\n+            field.lexicalSort = true;\n+        }\n+        field.label = switch (aggregator) {\n+            case COUNT -> \"Count\";\n+            case AVERAGE -> \"Avg. \" + field.label;\n+            case FIRST, LAST, LAST_BATCH -> field.label;\n+            case MAXIMUM -> \"Max. \" + field.label;\n+            case MINIMUM -> \"Min. \" + field.label;\n+            case SUM -> \"Total \" + field.label;\n+            case UNIQUE -> \"Unique Count \" + field.label;\n+            case LIST -> field.label + \"s\";\n+            case MISSING -> field.label;\n+            case DIFFERENCE -> \"Difference \" + field.label;\n+            case MEDIAN -> \"Median \" + field.label;\n+            case P90 -> \"P90 \" + field.label;\n+            case P95 -> \"P95 \" + field.label;\n+            case P99 -> \"P99 \" + field.label;\n+            case P999 -> \"P99.9 \" + field.label;\n+            case STANDARD_DEVIATION -> \"Std. Dev. \" + field.label;\n+        };\n+    }\n+\n+    private static Set<String> createKnownTypes() {\n+        Set<String> set = new HashSet<>();\n+        set.add(String.class.getName());\n+        set.add(Thread.class.getName());\n+        set.add(Class.class.getName());\n+        set.add(\"jdk.types.ThreadGroup\");\n+        set.add(\"jdk.types.ClassLoader\");\n+        set.add(\"jdk.types.Method\");\n+        set.add(\"jdk.types.StackFrame\");\n+        set.add(\"jdk.types.StackTrace\");\n+        return set;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/FieldBuilder.java","additions":422,"deletions":0,"binary":false,"changes":422,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.query;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedClassLoader;\n+import jdk.jfr.consumer.RecordedFrame;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.consumer.RecordedStackTrace;\n+import jdk.jfr.consumer.RecordedThread;\n+import jdk.jfr.consumer.RecordedThreadGroup;\n+import jdk.jfr.internal.util.ValueFormatter;\n+\n+public class FieldFormatter {\n+\n+    public static String formatCompact(Field field, Object object) {\n+        return format(field, object, true);\n+    }\n+\n+    public static String format(Field field, Object object) {\n+        return format(field, object, false);\n+    }\n+\n+    private static String format(Field field, Object object, boolean compact) {\n+        if (object == null) {\n+            return field.missingText;\n+        }\n+        if (object instanceof String s) {\n+            return stripFormatting(s);\n+        }\n+        if (object instanceof Double d) {\n+            if (Double.isNaN(d) || d == Double.NEGATIVE_INFINITY) {\n+                return field.missingText;\n+            }\n+        }\n+        if (object instanceof Float f) {\n+            if (Float.isNaN(f) || f == Float.NEGATIVE_INFINITY) {\n+                return field.missingText;\n+            }\n+        }\n+        if (object instanceof Long l && l == Long.MIN_VALUE) {\n+            return field.missingText;\n+        }\n+        if (object instanceof Integer i && i == Integer.MIN_VALUE) {\n+            return field.missingText;\n+        }\n+\n+        if (object instanceof RecordedThread t) {\n+            if (t.getJavaThreadId() > 0) {\n+                return t.getJavaName();\n+            } else {\n+                return t.getOSName();\n+            }\n+        }\n+        if (object instanceof RecordedClassLoader cl) {\n+            return format(field, cl.getType(), compact);\n+        }\n+        if (object instanceof RecordedStackTrace st) {\n+            return format(field, st.getFrames().getFirst(), compact);\n+        }\n+        if (object instanceof RecordedThreadGroup tg) {\n+            return tg.getName();\n+        }\n+        if (object instanceof RecordedMethod m) {\n+            return ValueFormatter.formatMethod(m, compact);\n+        }\n+        if (object instanceof RecordedClass clazz) {\n+            String text = ValueFormatter.formatClass(clazz);\n+            if (compact) {\n+                return text.substring(text.lastIndexOf(\".\") + 1);\n+            }\n+            return text;\n+        }\n+        if (object instanceof RecordedFrame f) {\n+            if (f.isJavaFrame()) {\n+                return format(field, f.getMethod(), compact);\n+            }\n+            return \"<unknown>\";\n+        }\n+        if (object instanceof Duration d) {\n+            if (d.getSeconds() == Long.MIN_VALUE && d.getNano() == 0) {\n+                return field.missingText;\n+            }\n+            if (d.equals(ChronoUnit.FOREVER.getDuration())) {\n+                return \"Indefinite\";\n+            }\n+            return ValueFormatter.formatDuration(d);\n+        }\n+        if (object instanceof Instant instant) {\n+            return ValueFormatter.formatTimestamp(instant);\n+        }\n+        if (field.percentage) {\n+            if (object instanceof Number n) {\n+                double d = n.doubleValue();\n+                return String.format(\"%.2f\", d * 100) + \"%\";\n+            }\n+        }\n+        if (field.bits || field.bytes) {\n+            if (object instanceof Number n) {\n+                long amount = n.longValue();\n+                if (field.frequency) {\n+                    if (field.bytes) {\n+                        return ValueFormatter.formatBytesPerSecond(amount);\n+                    }\n+                    if (field.bits) {\n+                        return ValueFormatter.formatBitsPerSecond(amount);\n+                    }\n+                } else {\n+                    if (field.bytes) {\n+                        return ValueFormatter.formatBytes(amount);\n+                    }\n+                    if (field.bits) {\n+                        return ValueFormatter.formatBits(amount);\n+                    }\n+                }\n+            }\n+        }\n+        if (field.memoryAddress) {\n+            if (object instanceof Number n) {\n+                long d = n.longValue();\n+                return String.format(\"0x%08X\", d);\n+            }\n+        }\n+        if (field.frequency) {\n+            if (object instanceof Number) {\n+                return object + \" Hz\";\n+            }\n+        }\n+        if (object instanceof Number number) {\n+            return ValueFormatter.formatNumber(number);\n+        }\n+        return object.toString();\n+    }\n+\n+    private static String stripFormatting(String text) {\n+        if (!hasFormatting(text)) {\n+            return text; \/\/ Fast path to avoid allocation\n+        }\n+        StringBuilder sb = new StringBuilder(text.length());\n+        for (int i = 0; i < text.length(); i++) {\n+            char c = text.charAt(i);\n+            sb.append(isFormatting(c) ? ' ' : c);\n+        }\n+        return sb.toString();\n+    }\n+\n+    private static boolean hasFormatting(String s) {\n+        for (int i = 0; i < s.length(); i++) {\n+            if (isFormatting(s.charAt(i))) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static boolean isFormatting(char c) {\n+        return c == '\\n' || c == '\\r' || c == '\\t';\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/FieldFormatter.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.query;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import jdk.jfr.EventType;\n+import jdk.jfr.Experimental;\n+import jdk.jfr.ValueDescriptor;\n+import jdk.jfr.internal.Utils;\n+\n+\/**\n+ * Type referenced in a FROM-clause.\n+ * <p>\n+ * If the query has a WHEN clause, the available events for the event type\n+ * is restricted by a list of filter conditions.\n+ *\/\n+final class FilteredType {\n+    public record Filter (Field field, String value) {\n+\n+        @Override\n+        public int hashCode() {\n+            return field.name.hashCode() + value.hashCode();\n+        }\n+\n+        @Override\n+        public boolean equals(Object object) {\n+            if (object instanceof Filter that) {\n+                return this.field.name.equals(that.field.name) && Objects.equals(this.value, that.value);\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private final List<Filter> filters = new ArrayList<>();\n+    private final EventType eventType;\n+    private final String simpleName;\n+\n+    public FilteredType(EventType type) {\n+        this.eventType = type;\n+        this.simpleName = Utils.makeSimpleName(type);\n+    }\n+\n+    public boolean isExperimental() {\n+        return eventType.getAnnotation(Experimental.class) != null;\n+    }\n+\n+    public String getName() {\n+        return eventType.getName();\n+    }\n+\n+    public String getLabel() {\n+        return eventType.getLabel();\n+    }\n+\n+    public String getSimpleName() {\n+        return simpleName;\n+    }\n+\n+    public void addFilter(Filter filter) {\n+        filters.add(filter);\n+    }\n+\n+    public List<Filter> getFilters() {\n+        return filters;\n+    }\n+\n+    public ValueDescriptor getField(String name) {\n+        return eventType.getField(name);\n+    }\n+\n+    public List<ValueDescriptor> getFields() {\n+        return eventType.getFields();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Long.hashCode(eventType.getId()) + filters.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object object) {\n+        if (object instanceof FilteredType that) {\n+            return that.eventType.getId() == this.eventType.getId()\n+                && that.filters.equals(this.filters);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(getName());\n+        sb.append(\" \");\n+        for (Filter condition : filters) {\n+            sb.append(condition.field());\n+            sb.append(\" = \");\n+            sb.append(condition.value());\n+            sb.append(\" \");\n+        }\n+        return sb.toString();\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/FilteredType.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.query;\n+\n+\n+\/**\n+ * Class responsible for printing and formatting the contents of the first row in a table,\n+ * as a form.\n+ *\/\n+import jdk.jfr.internal.util.Output;\n+\n+final class FormRenderer {\n+    private static final String LABEL_SUFFIX = \": \";\n+    private final Table table;\n+    private final Output out;\n+    private final Configuration configuration;\n+    private final int width;\n+\n+    public FormRenderer(Configuration configuration, Table table) {\n+        this.table = table;\n+        this.out = configuration.output;\n+        this.configuration = configuration;\n+        this.width = determineWidth(configuration);\n+    }\n+\n+    private static int determineWidth(Configuration configuration) {\n+        if (configuration.width == 0) {\n+            return Configuration.PREFERRED_WIDTH;\n+        } else {\n+            return configuration.width;\n+        }\n+    }\n+\n+    public void render() {\n+        if (table.isEmpty()) {\n+            if (configuration.title != null) {\n+                out.println();\n+                out.println(\"No events found for '\" + configuration.title +\"'.\");\n+            }\n+            return;\n+        }\n+\n+        int maxWidth = 0;\n+        for (Field field : table.getFields()) {\n+            String label = field.label + LABEL_SUFFIX;\n+            maxWidth = Math.max(label.length() + 1, maxWidth);\n+        }\n+        out.println();\n+        if (maxWidth + 2 > width) {\n+            out.println(\"Columns are too wide to fit width \" + configuration.width + \".\");\n+            return;\n+        }\n+        if (configuration.title != null) {\n+            out.println(configuration.title);\n+            out.println(\"-\".repeat(configuration.title.length()));\n+        }\n+        if (table.isEmpty()) {\n+            return;\n+        }\n+        for (Field field : table.getFields()) {\n+            if (field.visible) {\n+                out.println();\n+                renderField(field);\n+            }\n+        }\n+    }\n+\n+    private void renderField(Field field) {\n+        Row row = table.getRows().getFirst();\n+        String label = field.label + LABEL_SUFFIX;\n+        Object value = row.getValue(field.index);\n+        String text = FieldFormatter.format(field, value);\n+        boolean newLine = false;\n+        out.print(label);\n+        long p = width - label.length() - 1;\n+        for (int i = 0; i < text.length(); i++) {\n+            if (newLine) {\n+                out.print(\" \".repeat(label.length()));\n+                newLine = false;\n+            }\n+            out.print(text.charAt(i));\n+            if (i % p == p - 1) {\n+                newLine = true;\n+                out.println();\n+            }\n+        }\n+        out.println();\n+    }\n+\n+    public int getWidth() {\n+        return width;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/FormRenderer.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,662 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.query;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+\n+abstract class Function {\n+\n+    public abstract void add(Object value);\n+\n+    public abstract Object result();\n+\n+    public static Function create(Field field) {\n+        Aggregator aggregator = field.aggregator;\n+\n+        if (field.grouper != null || aggregator == Aggregator.MISSING) {\n+            return new FirstNonNull();\n+        }\n+        if (aggregator == Aggregator.LIST) {\n+            return new List();\n+        }\n+\n+        if (aggregator == Aggregator.DIFFERENCE) {\n+            if (field.timestamp) {\n+                return new TimeDifference();\n+            } else {\n+                return new Difference();\n+            }\n+        }\n+\n+        if (aggregator == Aggregator.STANDARD_DEVIATION) {\n+            if (field.timespan) {\n+                return new TimespanFunction(new StandardDeviation());\n+            } else {\n+                return new StandardDeviation();\n+            }\n+        }\n+\n+        if (aggregator == Aggregator.MEDIAN) {\n+            if (field.timespan) {\n+                return new TimespanFunction(new Median());\n+            } else {\n+                return new Median();\n+            }\n+        }\n+\n+        if (aggregator == Aggregator.P90) {\n+            return createPercentile(field, 0.95);\n+        }\n+\n+        if (aggregator == Aggregator.P95) {\n+            return createPercentile(field, 0.95);\n+\n+        }\n+        if (aggregator == Aggregator.P99) {\n+            return createPercentile(field, 0.99);\n+        }\n+        if (aggregator == Aggregator.P999) {\n+            return createPercentile(field, 0.9999);\n+        }\n+        if (aggregator == Aggregator.MAXIMUM) {\n+            return new Maximum();\n+        }\n+        if (aggregator == Aggregator.MINIMUM) {\n+            return new Minimum();\n+        }\n+        if (aggregator == Aggregator.SUM) {\n+            if (field.timespan) {\n+                return new SumDuration();\n+            }\n+            if (field.fractionalType) {\n+                return new SumDouble();\n+            }\n+            if (field.integralType) {\n+                return new SumLong();\n+            }\n+        }\n+\n+        if (aggregator == Aggregator.FIRST) {\n+            return new First();\n+        }\n+        if (aggregator == Aggregator.LAST_BATCH) {\n+            return new LastBatch(field);\n+        }\n+        if (aggregator == Aggregator.LAST) {\n+            return new Last();\n+        }\n+        if (aggregator == Aggregator.AVERAGE) {\n+            if (field.timespan) {\n+                return new AverageDuration();\n+            } else {\n+                return new Average();\n+            }\n+        }\n+        if (aggregator == Aggregator.COUNT) {\n+            return new Count();\n+        }\n+        if (aggregator == Aggregator.UNIQUE) {\n+            return new Unique();\n+        }\n+        return new Null();\n+    }\n+\n+    \/\/ **** AVERAGE ****\n+\n+    private static final class Average extends Function {\n+        private double total;\n+        private long count;\n+\n+        @Override\n+        public void add(Object value) {\n+            if (value instanceof Number n && Double.isFinite(n.doubleValue())) {\n+                total += n.doubleValue();\n+                count++;\n+            }\n+        }\n+\n+        @Override\n+        public Object result() {\n+            if (count != 0) {\n+                return total \/ count;\n+            } else {\n+                return null;\n+            }\n+        }\n+    }\n+\n+    private static final class AverageDuration extends Function {\n+        private long seconds;\n+        private long nanos;\n+        private int count;\n+\n+        @Override\n+        public void add(Object value) {\n+            if (value instanceof Duration duration) {\n+                seconds += duration.getSeconds();\n+                nanos += duration.getNano();\n+                count++;\n+            }\n+        }\n+\n+        @Override\n+        public Object result() {\n+            if (count != 0) {\n+                long s = seconds \/ count;\n+                long n = nanos \/ count;\n+                return Duration.ofSeconds(s, n);\n+            } else {\n+                return null;\n+            }\n+        }\n+    }\n+\n+    \/\/ **** COUNT ****\n+\n+    private static final class Count extends Function {\n+        private long count = 0;\n+\n+        @Override\n+        public void add(Object value) {\n+            count++;\n+        }\n+\n+        @Override\n+        public Object result() {\n+            return count;\n+        }\n+    }\n+\n+    \/\/ **** FIRST ****\n+\n+    private static final class First extends Function {\n+        private static Object firstObject = new Object();\n+        private Object first = firstObject;\n+\n+        @Override\n+        public void add(Object value) {\n+            if (first == firstObject) {\n+                first = value;\n+            }\n+        }\n+\n+        @Override\n+        public Object result() {\n+            return first == firstObject ? null : first;\n+        }\n+    }\n+\n+    \/\/ **** LAST ****\n+\n+    private static final class Last extends Function {\n+        private static Object lastObject = new Object();\n+        private Object last = lastObject;\n+\n+        @Override\n+        public void add(Object value) {\n+            last = value;\n+        }\n+\n+        @Override\n+        public Object result() {\n+            return last == lastObject ? null : last;\n+        }\n+    }\n+\n+    private static final class FirstNonNull extends Function {\n+        private Object first;\n+\n+        @Override\n+        public void add(Object value) {\n+            if (value == null) {\n+                return;\n+            }\n+            first = value;\n+        }\n+\n+        @Override\n+        public Object result() {\n+            return first;\n+        }\n+    }\n+\n+    \/\/ **** MAXIMUM ****\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final class Maximum extends Function {\n+        private Comparable<Comparable> maximum;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public void add(Object value) {\n+            if (value instanceof Comparable comparable) {\n+                if (maximum == null) {\n+                    maximum = comparable;\n+                    return;\n+                }\n+                if (comparable.compareTo(maximum) > 0) {\n+                    maximum = comparable;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public Object result() {\n+            if (maximum == null) {\n+                System.out.println(\"Why\");\n+            }\n+            return maximum;\n+        }\n+    }\n+\n+    \/\/ **** MINIMUM ****\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final class Minimum extends Function {\n+        private Comparable<Comparable> minimum;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public void add(Object value) {\n+            if (value instanceof Comparable comparable) {\n+                if (minimum == null) {\n+                    minimum = comparable;\n+                    return;\n+                }\n+                if (comparable.compareTo(minimum) < 0) {\n+                    minimum = comparable;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public Object result() {\n+            return minimum;\n+        }\n+    }\n+\n+    \/\/ *** NULL ****\n+\n+    private static final class Null extends Function {\n+        @Override\n+        public void add(Object value) {\n+        }\n+\n+        @Override\n+        public Object result() {\n+            return null;\n+        }\n+    }\n+\n+    \/\/ **** SUM ****\n+\n+    private static final class SumDouble extends Function {\n+        private boolean hasValue = false;\n+        private double sum = 0;\n+\n+        @Override\n+        public void add(Object value) {\n+            if (value instanceof Number n && Double.isFinite(n.doubleValue())) {\n+                sum += n.doubleValue();\n+                hasValue = true;\n+            }\n+        }\n+\n+        @Override\n+        public Object result() {\n+            return hasValue ? sum : null;\n+        }\n+    }\n+\n+    private static final class SumDuration extends Function {\n+        private long seconds;\n+        private long nanos;\n+        private boolean hasValue;\n+\n+        @Override\n+        public void add(Object value) {\n+            if (value instanceof Duration n) {\n+                seconds += n.getSeconds();\n+                nanos += n.getNano();\n+                hasValue = true;\n+            }\n+        }\n+\n+        @Override\n+        public Object result() {\n+            return hasValue ? Duration.ofSeconds(seconds, nanos) : null;\n+        }\n+    }\n+\n+    private static final class SumLong extends Function {\n+        private boolean hasValue = false;\n+        private long sum = 0;\n+\n+        @Override\n+        public void add(Object value) {\n+            if (value instanceof Number n) {\n+                sum += n.longValue();\n+                hasValue = true;\n+            }\n+        }\n+\n+        @Override\n+        public Object result() {\n+            return hasValue ? sum : null;\n+        }\n+    }\n+\n+    \/\/ **** UNIQUE ****\n+\n+    private static final class Unique extends Function {\n+        private final Set<Object> unique = new HashSet<>();\n+\n+        @Override\n+        public void add(Object value) {\n+            unique.add(value);\n+        }\n+\n+        @Override\n+        public Object result() {\n+            return unique.size();\n+        }\n+    }\n+\n+    \/\/ **** LIST ****\n+\n+    private static final class List extends Function {\n+        private final ArrayList<Object> list = new ArrayList<>();\n+\n+        @Override\n+        public void add(Object value) {\n+            list.add(value);\n+        }\n+\n+        @Override\n+        public Object result() {\n+            StringJoiner sj = new StringJoiner(\", \");\n+            for (Object object : list) {\n+                sj.add(String.valueOf(object));\n+            }\n+            return sj.toString();\n+        }\n+    }\n+\n+    \/\/ **** DIFF ****\n+\n+    private static final class Difference extends Function {\n+        private Number first;\n+        private Number last;\n+\n+        @Override\n+        public void add(Object value) {\n+            if (value instanceof Number number && Double.isFinite(number.doubleValue())) {\n+                if (first == null) {\n+                    first = number;\n+                }\n+                last = number;\n+            }\n+        }\n+\n+        @Override\n+        public Object result() {\n+            if (last == null) {\n+                return null;\n+            }\n+            if (isIntegral(first) && isIntegral(last)) {\n+                return last.longValue() - first.longValue();\n+            }\n+            if (first instanceof Float f && last instanceof Float l) {\n+                return l - f;\n+            }\n+            return last.doubleValue() - first.doubleValue();\n+        }\n+\n+        private boolean isIntegral(Number number) {\n+            if ((number instanceof Long) || (number instanceof Integer) || (number instanceof Short)\n+                    || (number instanceof Byte)) {\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n+    private static final class TimeDifference extends Function {\n+        private Instant first;\n+        private Instant last;\n+\n+        @Override\n+        public void add(Object value) {\n+            if (value instanceof Instant instant) {\n+                if (first == null) {\n+                    first = instant;\n+                    return;\n+                }\n+                last = instant;\n+            }\n+        }\n+\n+        @Override\n+        public Object result() {\n+            if (first == null) {\n+                return null;\n+            }\n+            if (last == null) {\n+                return ChronoUnit.FOREVER.getDuration();\n+            }\n+            return Duration.between(first, last);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final class Median extends Function {\n+        private final java.util.List<Comparable> comparables = new ArrayList<>();\n+\n+        @Override\n+        public void add(Object value) {\n+            if (value instanceof Number && value instanceof Comparable c) {\n+                comparables.add(c);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public Object result() {\n+            if (comparables.isEmpty()) {\n+                return null;\n+            }\n+            if (comparables.size() == 1) {\n+                return comparables.getFirst();\n+            }\n+            comparables.sort(Comparator.naturalOrder());\n+            if (comparables.size() % 2 == 1) {\n+                return comparables.get(comparables.size() \/ 2);\n+            }\n+            Number a = (Number) comparables.get(comparables.size() \/ 2 - 1);\n+            Number b = (Number) comparables.get(comparables.size() \/ 2);\n+            return (a.doubleValue() + b.doubleValue()) \/ 2;\n+        }\n+    }\n+\n+    \/\/ **** PERCENTILE ****\n+    private static Function createPercentile(Field field, double percentile) {\n+        Percentile p = new Percentile(percentile);\n+        if (field.timespan) {\n+            return new TimespanFunction(p);\n+        } else {\n+            return p;\n+        }\n+    }\n+\n+    private static final class TimespanFunction extends Function {\n+        private final Function function;\n+\n+        TimespanFunction(Function function) {\n+            this.function = function;\n+        }\n+\n+        @Override\n+        public void add(Object value) {\n+            if (value instanceof Duration duration) {\n+                long nanos = 1_000_000_000L * duration.getSeconds() + duration.getNano();\n+                function.add(nanos);\n+            }\n+        }\n+\n+        @Override\n+        public Object result() {\n+            Object object = function.result();\n+            if (object instanceof Number nanos) {\n+                return Duration.ofNanos(nanos.longValue());\n+            }\n+            return null;\n+        }\n+    }\n+    private static final class Percentile extends Function {\n+        private final double percentile;\n+        private final java.util.List<Number> numbers = new ArrayList<>();\n+\n+        Percentile(double percentile) {\n+            this.percentile = percentile;\n+        }\n+\n+        @Override\n+        public void add(Object value) {\n+            if (value instanceof Number number) {\n+                if (Double.isFinite(number.doubleValue())) {\n+                    numbers.add(number);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public Object result() {\n+            if (numbers.isEmpty()) {\n+                return null;\n+            }\n+            if (numbers.size() == 1) {\n+                return numbers.getFirst();\n+            }\n+            numbers.sort((n1, n2) -> Double.compare(n1.doubleValue(), n2.doubleValue()));\n+            int size = numbers.size();\n+            \/\/ Use size + 1 so range is stretched out for interpolation\n+            \/\/ For example with percentile 50%\n+            \/\/ size |  valueIndex |  valueNextindex | fraction\n+            \/\/   2         0               1            0.50\n+            \/\/   3         1               2             0.0\n+            \/\/   4         1               2            0.50\n+            \/\/   5         2               3             0.0\n+            \/\/   6         2               3            0.50\n+            double doubleIndex = (size + 1) * percentile;\n+            int valueIndex = (int) doubleIndex - 1;\n+            int valueNextIndex = (int) doubleIndex;\n+            double fraction = doubleIndex - valueIndex;\n+\n+            if (valueIndex < 0) {\n+                return numbers.getFirst();\n+            }\n+            if (valueNextIndex >= size) {\n+                return numbers.getLast();\n+            }\n+            double a = numbers.get(valueIndex).doubleValue();\n+            double b = numbers.get(valueNextIndex).doubleValue();\n+            return a + fraction * (b - a);\n+        }\n+    }\n+\n+    \/\/ **** STANDARD DEVIATION ****\n+\n+    private static final class StandardDeviation extends Function {\n+        private final java.util.List<Number> values = new ArrayList<>();\n+\n+        @Override\n+        public void add(Object value) {\n+            if (value instanceof Number n && Double.isFinite(n.doubleValue())) {\n+                values.add(n);\n+            }\n+        }\n+\n+        @Override\n+        public Object result() {\n+            if (values.size() > 0) {\n+                long N = values.size();\n+                double average = sum() \/ N;\n+                double sum = 0;\n+                for (Number number : values) {\n+                    double diff = number.doubleValue() - average;\n+                    sum = sum + (diff * diff);\n+                }\n+                return Math.sqrt(sum \/ N);\n+            }\n+            return null;\n+        }\n+\n+        private double sum() {\n+            double sum = 0;\n+            for (Number number : values) {\n+                sum += number.doubleValue();\n+            }\n+            return sum ;\n+        }\n+    }\n+\n+    public static final class LastBatch extends Function {\n+        private final Field field;\n+        private final Last last = new Last();\n+        private Instant timestamp;\n+\n+        public LastBatch(Field field) {\n+            this.field = field;\n+        }\n+\n+        @Override\n+        public void add(Object value) {\n+            last.add(value);\n+        }\n+\n+        @Override\n+        public Object result() {\n+            return last.result();\n+        }\n+\n+        public void setTime(Instant timestamp) {\n+           this.timestamp = timestamp;\n+           field.last = timestamp;\n+        }\n+\n+        public boolean valid() {\n+            if (timestamp != null) {\n+                return timestamp.equals(field.last);\n+            }\n+            return true;\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/Function.java","additions":662,"deletions":0,"binary":false,"changes":662,"status":"added"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.query;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedClassLoader;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedFrame;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.consumer.RecordedObject;\n+import jdk.jfr.consumer.RecordedStackTrace;\n+import jdk.jfr.consumer.RecordedThread;\n+import jdk.jfr.consumer.RecordedThreadGroup;\n+import jdk.jfr.internal.query.Function.LastBatch;\n+\n+\/**\n+ * Class responsible for aggregating values\n+ *\/\n+final class Histogram {\n+    private static final class LookupKey {\n+        private Object keys;\n+\n+        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+        public void add(Object o) {\n+            \/\/ One key, fast path\n+            if (keys == null) {\n+                keys = o;\n+                return;\n+            }\n+            \/\/ Three or more keys\n+            if (keys instanceof Set set) {\n+                set.add(o);\n+                return;\n+            }\n+            \/\/ Two keys\n+            Set<Object> set = HashSet.newHashSet(2);\n+            set.add(keys);\n+            set.add(o);\n+            keys = set;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hashCode(keys);\n+        }\n+\n+        @Override\n+        public boolean equals(Object object) {\n+            if (object instanceof LookupKey that) {\n+                return Objects.deepEquals(that.keys, this.keys);\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private static final class MethodEquality {\n+        private final String methodName;\n+        private final String descriptor;\n+        private final long classId;\n+\n+        public MethodEquality(RecordedMethod method) {\n+            methodName = method.getName();\n+            descriptor = method.getDescriptor();\n+            classId = method.getType().getId();\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int hash1 = Long.hashCode(classId);\n+            int hash2 = methodName.hashCode();\n+            int hash3 = descriptor.hashCode();\n+            int result = 31 + hash1;\n+            result += 31 * result + hash2;\n+            result += 31 * result + hash3;\n+            return result;\n+        }\n+\n+        @Override\n+        public boolean equals(Object object) {\n+            if (object instanceof MethodEquality that) {\n+                if ((this.classId != that.classId) || !Objects.equals(this.methodName, that.methodName)) {\n+                    return false;\n+                }\n+                return Objects.equals(this.descriptor, that.descriptor);\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private final Map<LookupKey, Function[]> keyFunctionsMap = new HashMap<>();\n+    private final List<Field> fields = new ArrayList<>();\n+\n+    public void addFields(List<Field> fields) {\n+        this.fields.addAll(fields);\n+    }\n+\n+    public void add(RecordedEvent e, FilteredType type, List<Field> sourceFields) {\n+        LookupKey lk = new LookupKey();\n+        final Object[] values = new Object[sourceFields.size()];\n+        for (int i = 0; i < values.length; i++) {\n+            Field field = sourceFields.get(i);\n+            Object value = field.valueGetter.apply(e);\n+            values[i] = value;\n+            if (field.grouper != null) {\n+                lk.add(makeKey(value));\n+            }\n+        }\n+\n+        Function[] fs = keyFunctionsMap.computeIfAbsent(lk, k -> createFunctions());\n+        for (int i = 0; i < values.length; i++) {\n+            Function function = fs[sourceFields.get(i).index];\n+            function.add(values[i]);\n+            if (function instanceof LastBatch l) {\n+                l.setTime(e.getEndTime());\n+            }\n+        }\n+    }\n+\n+    public List<Row> toRows() {\n+        List<Row> rows = new ArrayList<>(keyFunctionsMap.size());\n+        for (Function[] functions : keyFunctionsMap.values()) {\n+            Row row = new Row(fields.size());\n+            boolean valid = true;\n+            int index = 0;\n+            for (Function f : functions) {\n+                if (f instanceof LastBatch last && !last.valid()) {\n+                    valid = false;\n+                }\n+                row.putValue(index++, f.result());\n+            }\n+            if (valid) {\n+                rows.add(row);\n+            }\n+        }\n+        return rows;\n+    }\n+\n+    private Function[] createFunctions() {\n+        Function[] functions = new Function[fields.size()];\n+        for (int i = 0; i < functions.length; i++) {\n+            functions[i] = Function.create(fields.get(i));\n+        }\n+        return functions;\n+    }\n+\n+    private static Object makeKey(Object object) {\n+        if (!(object instanceof RecordedObject)) {\n+            return object;\n+        }\n+        if (object instanceof RecordedMethod method) {\n+            return new MethodEquality(method);\n+        }\n+        if (object instanceof RecordedThread thread) {\n+            return thread.getId();\n+        }\n+        if (object instanceof RecordedClass clazz) {\n+            return clazz.getId();\n+        }\n+        if (object instanceof RecordedFrame frame) {\n+            if (frame.isJavaFrame()) {\n+                return makeKey(frame.getMethod());\n+            }\n+            return null;\n+        }\n+\n+        if (object instanceof RecordedStackTrace stackTrace) {\n+            List<RecordedFrame> recordedFrames = stackTrace.getFrames();\n+            List<Object> frames = new ArrayList<>(recordedFrames.size());\n+            for (RecordedFrame frame : recordedFrames) {\n+                frames.add(makeKey(frame));\n+            }\n+            return frames;\n+        }\n+        if (object instanceof RecordedClassLoader classLoader) {\n+            return classLoader.getId();\n+        }\n+        if (object instanceof RecordedThreadGroup group) {\n+            String name = group.getName();\n+            String parentName = group.getParent() != null ? group.getParent().getName() : null;\n+            return name + \":\" + parentName;\n+        }\n+        return object;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/Histogram.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.query;\n+\n+import java.text.ParseException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+import java.util.function.Consumer;\n+\n+final class Query {\n+    enum SortOrder {\n+        NONE, ASCENDING, DESCENDING\n+    }\n+\n+    record Source(String name, Optional<String> alias) {\n+    }\n+\n+    record Condition(String field, String value) {\n+    }\n+\n+    record Where(List<Condition> conditions) {\n+    }\n+\n+    record Property(String name, Consumer<Field> style) {\n+    }\n+\n+    record Formatter(List<Property> properties) {\n+    }\n+\n+    record Expression(String name, Optional<String> alias, Aggregator aggregator) {\n+    }\n+\n+    record Grouper(String field) {\n+    }\n+\n+    record OrderElement(String name, SortOrder order) {\n+    }\n+\n+    final List<String> column;\n+    final List<Formatter> format;\n+    final List<Expression> select;\n+    final List<Source> from;\n+    final List<Condition> where;\n+    final List<Grouper> groupBy;\n+    final List<OrderElement> orderBy;\n+    final int limit;\n+\n+    public Query(String text) throws ParseException {\n+        try (QueryParser qp = new QueryParser(text)) {\n+            column = qp.column();\n+            format = qp.format();\n+            select = qp.select();\n+            from = qp.from();\n+            where = qp.where();\n+            groupBy = qp.groupBy();\n+            orderBy = qp.orderBy();\n+            limit = qp.limit();\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        if (!column.isEmpty()) {\n+            StringJoiner sj = new StringJoiner(\", \");\n+            for (String c : column) {\n+                sj.add(\"'\" + c + \"'\");\n+            }\n+            sb.append(\"COLUMN \").append(sj).append(\" \");\n+        }\n+        if (!format.isEmpty()) {\n+            StringJoiner sj = new StringJoiner(\", \");\n+            for (Formatter f : format) {\n+                StringJoiner t = new StringJoiner(\";\");\n+                for (Property p : f.properties()) {\n+                    t.add(p.name());\n+                }\n+                sj.add(t.toString());\n+            }\n+            sb.append(\"FORMAT \").append(sj).append(\" \");\n+        }\n+        StringJoiner t = new StringJoiner(\", \");\n+        for (Expression e : select) {\n+            StringBuilder w = new StringBuilder();\n+            if (e.aggregator() != Aggregator.MISSING) {\n+                w.append(e.aggregator().name());\n+                w.append(\"(\");\n+            }\n+            w.append(e.name());\n+            if (e.aggregator() != Aggregator.MISSING) {\n+                w.append(\")\");\n+            }\n+            if (e.alias().isPresent()) {\n+                w.append(\" AS \");\n+                w.append(e.alias().get());\n+            }\n+            t.add(w.toString());\n+        }\n+        sb.append(\"SELECT \")\n+          .append(select.isEmpty() ? \"*\" : t.toString());\n+        StringJoiner u = new StringJoiner(\", \");\n+        for (Source e : from) {\n+            String s = e.name();\n+            if (e.alias().isPresent()) {\n+                s += \" AS \" + e.alias().get();\n+            }\n+            u.add(s);\n+        }\n+        sb.append(\" FROM \").append(u);\n+        if (!where.isEmpty()) {\n+            StringJoiner sj = new StringJoiner(\" AND\");\n+            for (Condition c : where) {\n+                sj.add(\" \" + c.field() + \" = '\" + c.value() + \"'\");\n+            }\n+            sb.append(\" WHERE\").append(sj);\n+        }\n+\n+        if (!groupBy.isEmpty()) {\n+            StringJoiner sj = new StringJoiner(\", \");\n+            for (Grouper g : groupBy) {\n+                sj.add(g.field());\n+            }\n+            sb.append(\" GROUP BY \").append(sj);\n+        }\n+        if (!orderBy.isEmpty()) {\n+            StringJoiner sj = new StringJoiner(\", \");\n+            for (OrderElement e : orderBy) {\n+                String name = e.name();\n+                if (e.order() == SortOrder.ASCENDING) {\n+                    name += \" ASC\";\n+                }\n+                if (e.order() == SortOrder.DESCENDING) {\n+                    name += \" DESC\";\n+                }\n+                sj.add(name);\n+            }\n+            sb.append(\" ORDER BY \").append(sj);\n+        }\n+        if (limit != Integer.MAX_VALUE) {\n+            sb.append(\" LIMIT \" + limit);\n+        }\n+        return sb.toString();\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/Query.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.query;\n+\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.jfr.EventType;\n+import jdk.jfr.consumer.EventStream;\n+import jdk.jfr.consumer.MetadataEvent;\n+\n+final class QueryExecutor {\n+    private final List<QueryRun> queryRuns = new ArrayList<>();\n+    private final List<EventType> eventTypes = new ArrayList<>();\n+    private final EventStream stream;\n+\n+    public QueryExecutor(EventStream stream) {\n+        this(stream, List.of());\n+    }\n+\n+    public QueryExecutor(EventStream stream, Query query) {\n+        this(stream, List.of(query));\n+    }\n+\n+    public QueryExecutor(EventStream stream, List<Query> queries) {\n+        this.stream = stream;\n+        for (Query query : queries) {\n+            queryRuns.add(new QueryRun(stream, query));\n+        }\n+        stream.setReuse(false);\n+        stream.setOrdered(true);\n+        stream.onMetadata(this::onMetadata);\n+    }\n+\n+    public List<QueryRun> run() {\n+        stream.start();\n+        for (QueryRun run : queryRuns) {\n+            run.complete();\n+        }\n+        return queryRuns;\n+    }\n+\n+    private void onMetadata(MetadataEvent e) {\n+        if (eventTypes.isEmpty()) {\n+            eventTypes.addAll(e.getEventTypes());\n+        }\n+        if (queryRuns.isEmpty()) {\n+            addQueryRuns();\n+        }\n+        for (QueryRun run : queryRuns) {\n+            run.onMetadata(e);\n+        }\n+    }\n+\n+    private void addQueryRuns() {\n+        for (EventType type : eventTypes) {\n+            try {\n+                Query query = new Query(\"SELECT * FROM \" + type.getName());\n+                QueryRun run = new QueryRun(stream, query);\n+                queryRuns.add(run);\n+            } catch (ParseException pe) {\n+                \/\/ The event name contained whitespace or similar, ignore.\n+            }\n+        }\n+    }\n+\n+    public List<EventType> getEventTypes() {\n+        return eventTypes;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/QueryExecutor.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,336 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.query;\n+\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import jdk.jfr.internal.query.Configuration.Truncate;\n+import jdk.jfr.internal.query.Query.Condition;\n+import jdk.jfr.internal.query.Query.Expression;\n+import jdk.jfr.internal.query.Query.Formatter;\n+import jdk.jfr.internal.query.Query.Grouper;\n+import jdk.jfr.internal.query.Query.OrderElement;\n+import jdk.jfr.internal.query.Query.Property;\n+import jdk.jfr.internal.query.Query.SortOrder;\n+import jdk.jfr.internal.query.Query.Source;\n+import jdk.jfr.internal.util.Tokenizer;\n+\n+final class QueryParser implements AutoCloseable {\n+    static final char[] SEPARATORS = {'=', ',', ';', '(', ')'};\n+\n+    private final Tokenizer tokenizer;\n+\n+    public QueryParser(String text) {\n+        tokenizer = new Tokenizer(text, SEPARATORS);\n+    }\n+\n+    public List<String> column() throws ParseException {\n+        if (!tokenizer.accept(\"COLUMN\")) {\n+            return List.of();\n+        }\n+        List<String> texts = new ArrayList<>();\n+        texts.add(text());\n+        while (tokenizer.accept(\",\")) {\n+            texts.add(text());\n+        }\n+        return texts;\n+    }\n+\n+    public List<Formatter> format() throws ParseException {\n+        if (tokenizer.accept(\"FORMAT\")) {\n+            List<Formatter> formatters = new ArrayList<>();\n+            formatters.add(formatter());\n+            while (tokenizer.accept(\",\")) {\n+                formatters.add(formatter());\n+            }\n+            return formatters;\n+        }\n+        return List.of();\n+    }\n+\n+    private Formatter formatter() throws ParseException {\n+        List<Property> properties = new ArrayList<>();\n+        properties.add(property());\n+        while (tokenizer.accept(\";\")) {\n+            properties.add(property());\n+        }\n+        return new Formatter(properties);\n+    }\n+\n+    public List<Expression> select() throws ParseException {\n+        tokenizer.expect(\"SELECT\");\n+        if (tokenizer.accept(\"*\")) {\n+            return List.of();\n+        }\n+        List<Expression> expressions = new ArrayList<>();\n+        if (tokenizer.accept(\"FROM\")) {\n+            throw new ParseException(\"Missing fields in SELECT statement\", position());\n+        }\n+        expressions.add(expression());\n+        while (tokenizer.accept(\",\")) {\n+            Expression exp = expression();\n+            if (exp.name().equalsIgnoreCase(\"FROM\")) {\n+                throw new ParseException(\"Missing field name in SELECT statement, or qualify field with event type if name is called '\" + exp.name() + \"'\", position());\n+            }\n+            expressions.add(exp);\n+        }\n+        return expressions;\n+    }\n+\n+    private Expression expression() throws ParseException {\n+        Expression aggregator = aggregator();\n+        if (aggregator != null) {\n+            return aggregator;\n+        } else {\n+            return new Expression(eventField(), alias(), Aggregator.MISSING);\n+        }\n+    }\n+\n+    private Expression aggregator() throws ParseException {\n+        for (Aggregator function : Aggregator.values()) {\n+            if (tokenizer.accept(function.name, \"(\")) {\n+                String eventField = eventField();\n+                tokenizer.expect(\")\");\n+                return new Expression(eventField, alias(), function);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private Optional<String> alias() throws ParseException {\n+        Optional<String> alias = Optional.empty();\n+        if (tokenizer.accept(\"AS\")) {\n+            alias = Optional.of(symbol());\n+        }\n+        return alias;\n+    }\n+\n+    public List<Source> from() throws ParseException {\n+        tokenizer.expect(\"FROM\");\n+        List<Source> sources = new ArrayList<>();\n+        sources.add(source());\n+        while (tokenizer.accept(\",\")) {\n+            sources.add(source());\n+        }\n+        return sources;\n+    }\n+\n+    private Source source() throws ParseException {\n+        String type = type();\n+        if (tokenizer.accept(\"SELECT\")) {\n+            throw new ParseException(\"Subquery is not allowed\", position());\n+        }\n+        if (tokenizer.accept(\"INNER\", \"JOIN\", \"LEFT\", \"RIGHT\", \"FULL\")) {\n+            throw new ParseException(\"JOIN is not allowed\", position());\n+        }\n+        return new Source(type, alias());\n+    }\n+\n+    private String type() throws ParseException {\n+        return tokenizer.next();\n+    }\n+\n+    public List<Condition> where() throws ParseException {\n+        if (tokenizer.accept(\"WHERE\")) {\n+            List<Condition> conditions = new ArrayList<>();\n+            conditions.add(condition());\n+            while (tokenizer.accept(\"AND\")) {\n+                conditions.add(condition());\n+            }\n+            return conditions;\n+        }\n+        return List.of();\n+    }\n+\n+    private Condition condition() throws ParseException {\n+        String field = eventField();\n+        if (tokenizer.acceptAny(\"<\", \">\", \"<>\", \">=\", \"<=\", \"==\", \"BETWEEN\", \"LIKE\", \"IN\")) {\n+            throw new ParseException(\"The only operator allowed in WHERE clause is '='\", position());\n+        }\n+        tokenizer.expect(\"=\");\n+        String value = text();\n+        return new Condition(field, value);\n+    }\n+\n+    public List<Grouper> groupBy() throws ParseException {\n+        if (tokenizer.accept(\"HAVING\")) {\n+            throw new ParseException(\"HAVING is not allowed\", position());\n+        }\n+        if (tokenizer.accept(\"GROUP\")) {\n+            tokenizer.expect(\"BY\");\n+            List<Grouper> groupers = new ArrayList<>();\n+            groupers.add(grouper());\n+            while (tokenizer.accept(\",\")) {\n+                groupers.add(grouper());\n+            }\n+            return groupers;\n+        }\n+        return new ArrayList<>(); \/\/ Need to return mutable collection\n+    }\n+\n+    private Grouper grouper() throws ParseException {\n+        return new Grouper(eventField());\n+    }\n+\n+    public List<OrderElement> orderBy() throws ParseException {\n+        if (tokenizer.accept(\"ORDER\")) {\n+            tokenizer.expect(\"BY\");\n+            List<OrderElement> fields = new ArrayList<>();\n+            fields.add(orderer());\n+            while (tokenizer.accept(\",\")) {\n+                fields.add(orderer());\n+            }\n+            return fields;\n+        }\n+        return List.of();\n+    }\n+\n+    private OrderElement orderer() throws ParseException {\n+        return new OrderElement(eventField(), sortOrder());\n+    }\n+\n+    private SortOrder sortOrder() throws ParseException {\n+        if (tokenizer.accept(\"ASC\")) {\n+            return SortOrder.ASCENDING;\n+        }\n+        if (tokenizer.accept(\"DESC\")) {\n+            return SortOrder.DESCENDING;\n+        }\n+        return SortOrder.NONE;\n+    }\n+\n+    private String text() throws ParseException {\n+        if (tokenizer.peekChar() != '\\'') {\n+            throw new ParseException(\"Expected text to start with a single quote character\", position());\n+        }\n+        return tokenizer.next();\n+    }\n+\n+    private String symbol() throws ParseException {\n+        String s = tokenizer.next();\n+        for (int index = 0; index < s.length(); index++) {\n+            int cp = s.codePointAt(index);\n+            if (!Character.isLetter(cp)) {\n+                throw new ParseException(\"Symbol must consist of letters, found '\" + s.charAt(index) + \"' in '\" + s + \"'\",\n+                        position());\n+            }\n+        }\n+        return s;\n+    }\n+\n+    private String eventField() throws ParseException {\n+        if (!tokenizer.hasNext()) {\n+            throw new ParseException(\"Unexpected end when looking for event field\", position());\n+        }\n+        if (tokenizer.peekChar() == '\\'') {\n+            throw new ParseException(\"Expected unquoted symbolic name (not label)\", position());\n+        }\n+        String name = tokenizer.next();\n+        if (name.equals(\"*\")) {\n+            return name;\n+        }\n+        for (int index = 0; index < name.length(); index++) {\n+            char c = name.charAt(index);\n+            boolean valid = index == 0 ? Character.isJavaIdentifierStart(c) : Character.isJavaIdentifierPart(c);\n+            if (c != '.' && c != '[' && c!= ']' && c != '|' && !valid) {\n+                throw new ParseException(\"Not a valid field name: \" + name, position());\n+            }\n+        }\n+        return name;\n+    }\n+\n+    private Property property() throws ParseException {\n+        String text = tokenizer.next();\n+        Consumer<Field> style = switch (text.toLowerCase()) {\n+            case \"none\" -> field -> {};\n+            case \"missing:\" -> field -> {};\n+            case \"normalized\" -> field -> field.normalized = field.percentage = true;\n+            case \"truncate-beginning\" -> field -> field.truncate = Truncate.BEGINNING;\n+            case \"truncate-end\" -> field -> field.truncate = Truncate.END;\n+            default -> {\n+                if (text.startsWith(\"missing:\")) {\n+                    yield missing(text.substring(\"missing:\".length()));\n+                }\n+                if (text.startsWith(\"cell-height:\")) {\n+                    yield cellHeight(text.substring(\"cell-height:\".length()));\n+                }\n+                throw new ParseException(\"Unknown formatter '\" + text + \"'\", position());\n+            }\n+        };\n+        return new Property(text, style);\n+    }\n+\n+    private Consumer<Field> missing(String missing) {\n+        if (\"whitespace\".equals(missing)) {\n+           return field -> field.missingText = \"\";\n+        } else {\n+           return field -> field.missingText = missing;\n+        }\n+    }\n+\n+    private Consumer<Field> cellHeight(String height) throws ParseException {\n+        try {\n+            int h = Integer.parseInt(height);\n+            if (h < 1) {\n+                throw new ParseException(\"Expected 'cell-height:' to be at least 1' \", position());\n+            }\n+            return field -> field.cellHeight = h;\n+        } catch (NumberFormatException nfe) {\n+            throw new ParseException(\"Not valid number for 'cell-height:' \" + height, position());\n+        }\n+    }\n+\n+    public int position() {\n+        return tokenizer.getPosition();\n+    }\n+\n+    public int limit() throws ParseException {\n+        if (tokenizer.accept(\"LIMIT\")) {\n+            try {\n+                if (tokenizer.hasNext()) {\n+                    String number = tokenizer.next();\n+                    int limit= Integer.parseInt(number);\n+                    if (limit < 0) {\n+                        throw new ParseException(\"Expected a positive integer after LIMIT\", position());\n+                    }\n+                    return limit;\n+                }\n+            } catch (NumberFormatException nfe) {\n+                \/\/ Fall through\n+            }\n+            throw new ParseException(\"Expected an integer after LIMIT\", position());\n+        }\n+        return Integer.MAX_VALUE;\n+    }\n+\n+    @Override\n+    public void close() throws ParseException {\n+        tokenizer.close();\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/QueryParser.java","additions":336,"deletions":0,"binary":false,"changes":336,"status":"added"},{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.query;\n+\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import jdk.jfr.AnnotationElement;\n+import jdk.jfr.EventType;\n+import jdk.jfr.Experimental;\n+import jdk.jfr.Relational;\n+import jdk.jfr.ValueDescriptor;\n+import jdk.jfr.consumer.EventStream;\n+import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.Columnizer;\n+import jdk.jfr.internal.util.Output;\n+import jdk.jfr.internal.util.StopWatch;\n+import jdk.jfr.internal.util.Tokenizer;\n+import jdk.jfr.internal.util.UserDataException;\n+import jdk.jfr.internal.util.UserSyntaxException;\n+import jdk.jfr.internal.util.ValueFormatter;\n+\n+\/**\n+ * Class responsible for executing and displaying the contents of a query.\n+ * <p>\n+ * Used by 'jcmd JFR.query' and 'jfr query'.\n+ *\/\n+public final class QueryPrinter {\n+    private final EventStream stream;\n+    private final Configuration configuration;\n+    private final Output out;\n+    private final StopWatch stopWatch;\n+\n+    \/**\n+     * Constructs a query printer.\n+     *\n+     * @param configuration display configuration\n+     * @param stream a non-started stream from where data should be fetched.\n+     *\/\n+    public QueryPrinter(Configuration configuration, EventStream stream) {\n+        this.configuration = configuration;\n+        this.out = configuration.output;\n+        this.stopWatch = new StopWatch();\n+        this.stream = stream;\n+    }\n+\n+    \/**\n+     * Prints the query.\n+     *\n+     * @see getGrammarText().\n+     *\n+     * @param query the query text\n+     *\n+     * @throws UserDataException   if the stream associated with the printer lacks\n+     *                             event or event metadata\n+     * @throws UserSyntaxException if the syntax of the query is incorrect.\n+     *\/\n+    public void execute(String query) throws UserDataException, UserSyntaxException {\n+        if (showEvents(query) || showFields(query)) {\n+            return;\n+        }\n+        showQuery(query);\n+    }\n+\n+    private void showQuery(String query) throws UserDataException, UserSyntaxException {\n+        try {\n+            stopWatch.beginQueryValidation();\n+            Query q = new Query(query);\n+            QueryExecutor executor = new QueryExecutor(stream, q);\n+            stopWatch.beginAggregation();\n+            QueryRun task = executor.run().getFirst();\n+            if (!task.getSyntaxErrors().isEmpty()) {\n+                throw new UserSyntaxException(task.getSyntaxErrors().getFirst());\n+            }\n+            if (!task.getMetadataErrors().isEmpty()) {\n+                throw new UserDataException(task.getMetadataErrors().getFirst());\n+            }\n+            Table table = task.getTable();\n+            if (configuration.verboseTitle) {\n+                FilteredType type = table.getFields().getFirst().type;\n+                configuration.title = type.getLabel();\n+                if (type.isExperimental()) {\n+                    configuration.title += \" (Experimental)\";\n+                }\n+            }\n+            stopWatch.beginFormatting();\n+            TableRenderer renderer = new TableRenderer(configuration, table, q);\n+            renderer.render();\n+            stopWatch.finish();\n+            if (configuration.verbose) {\n+                out.println();\n+                out.println(\"Execution: \" + stopWatch.toString());\n+            }\n+            if (configuration.startTime != null) {\n+                String s = ValueFormatter.formatTimestamp(configuration.startTime);\n+                String e = ValueFormatter.formatTimestamp(configuration.endTime);\n+                out.println();\n+                out.println(\"Timespan: \" + s + \" - \" + e);\n+            }\n+        } catch (ParseException pe) {\n+            throw new UserSyntaxException(pe.getMessage());\n+        }\n+    }\n+\n+    private boolean showFields(String text) {\n+        String eventType = null;\n+        try (Tokenizer t = new Tokenizer(text)) {\n+            t.expect(\"SHOW\");\n+            t.expect(\"FIELDS\");\n+            eventType = t.next();\n+        } catch (ParseException pe) {\n+            return false;\n+        }\n+        Map<Long, EventType> eventTypes = new HashMap<>();\n+        stream.onMetadata(e -> {\n+            for (EventType t : e.getAddedEventTypes()) {\n+                eventTypes.put(t.getId(), t);\n+            }\n+        });\n+        stream.start();\n+\n+        List<EventType> types = new ArrayList<>(eventTypes.values());\n+        Collections.sort(types, Comparator.comparing(EventType::getName));\n+        for (EventType type : types) {\n+            String qualifiedName = type.getName();\n+            String name = Utils.makeSimpleName(qualifiedName);\n+            if (qualifiedName.equals(eventType) || name.equals(eventType)) {\n+                printFields(type, types);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private void printFields(EventType type, List<EventType> allTypes) {\n+        out.println();\n+        out.println(\"\" + type.getName() + \":\");\n+        out.println();\n+        for (ValueDescriptor f : type.getFields()) {\n+            String typeName = Utils.makeSimpleName(f.getTypeName());\n+            out.println(\" \" + typeName + \" \" + f.getName());\n+        }\n+        List<String> related = new ArrayList<>();\n+        for (String s : relations(type)) {\n+            out.println();\n+            String simpleName = Utils.makeSimpleName(s);\n+            out.println(\"Event types with a \" + simpleName + \" relation:\");\n+            out.println();\n+            for (EventType et : allTypes) {\n+                if (et != type) {\n+                    List<String> r = relations(et);\n+                    if (r.contains(s)) {\n+                        related.add(et.getName());\n+                    }\n+                }\n+            }\n+            out.println(new Columnizer(related, 2).toString());\n+        }\n+        out.println();\n+    }\n+\n+    private List<String> relations(EventType type) {\n+        List<String> relations = new ArrayList<>();\n+        for (ValueDescriptor field : type.getFields()) {\n+            for (AnnotationElement annotation : field.getAnnotationElements()) {\n+                Relational relation = annotation.getAnnotation(Relational.class);\n+                if (relation != null) {\n+                    relations.add(annotation.getTypeName());\n+                }\n+            }\n+        }\n+        return relations;\n+    }\n+\n+    private boolean showEvents(String queryText) {\n+        try (Tokenizer t = new Tokenizer(queryText)) {\n+            t.expect(\"SHOW\");\n+            t.expect(\"EVENTS\");\n+        } catch (ParseException pe) {\n+            return false;\n+            \/\/ Ignore\n+        }\n+        out.println(\"Event Types (number of events):\");\n+        out.println();\n+        Map<Long, Long> eventCount = new HashMap<>();\n+        Map<Long, EventType> eventTypes = new HashMap<>();\n+        stream.onMetadata(e -> {\n+            for (EventType t : e.getAddedEventTypes()) {\n+                eventTypes.put(t.getId(), t);\n+            }\n+        });\n+        stream.onEvent(event -> {\n+            eventCount.merge(event.getEventType().getId(), 1L, Long::sum);\n+        });\n+        stream.start();\n+        List<String> types = new ArrayList<>();\n+        for (EventType type : eventTypes.values()) {\n+            if (!isExperimental(type)) {\n+                String name = Utils.makeSimpleName(type);\n+                Long count = eventCount.get(type.getId());\n+                String countText = count == null ? \"\" : \" (\" + count + \")\";\n+                types.add(name + countText);\n+            }\n+        }\n+        out.println(new Columnizer(types, 2).toString());\n+        return true;\n+    }\n+\n+    private boolean isExperimental(EventType t) {\n+        return t.getAnnotation(Experimental.class) != null;\n+    }\n+\n+    public static String getGrammarText() {\n+        return \"\"\"\n+                Grammar:\n+\n+                 query       ::= [column] [format] select from [where] [groupBy] [orderBy] [limit]\n+                 column      ::= \"COLUMN\" text (\",\" text)*\n+                 format      ::= \"FORMAT\" formatter (\",\" formatter)*\n+                 formatter   ::= property (\";\" property)*\n+                 select      ::= \"SELECT\" \"*\" | expression (\",\" expression)*\n+                 expression  ::= (aggregator | field) [alias]\n+                 aggregator  ::= function \"(\" (field | \"*\") \")\"\n+                 alias       ::= \"AS\" symbol\n+                 from        ::= \"FROM\" source (\",\" source)*\n+                 source      ::= type [alias]\n+                 where       ::= condition (\"AND\" condition)*\n+                 condition   ::= field \"=\" text\n+                 groupBy     ::= \"GROUP BY\" field (\",\" field)*\n+                 orderBy     ::= \"ORDER BY\" orderField (\",\" orderField)*\n+                 orderField  ::= field [sortOrder]\n+                 sortOrder   ::= \"ASC\" | \"DESC\"\n+                 limit       ::= \"LIMIT\" <integer>\n+\n+                 - text, characters surrounded by single quotes\n+                 - symbol, alphabetic characters\n+                 - type, the event type name, for example SystemGC. To avoid ambiguity,\n+                   the name may be qualified, for example jdk.SystemGC\n+                 - field, the event field name, for example stackTrace.\n+                   To avoid ambiguity, the name may be qualified, for example\n+                   jdk.SystemGC.stackTrace. A type alias declared in a FROM clause\n+                   can be used instead of the type, for example S.eventThread\n+                 - function, determines how fields are aggregated when using GROUP BY.\n+                   Aggregate functions are:\n+                    AVG: The numeric average\n+                    COUNT: The number of values\n+                    DIFF: The numeric difference between the last and first value\n+                    FIRST: The first value\n+                    LAST: The last value\n+                    LAST_BATCH: The last set of values with the same end timestamp\n+                    LIST: All values in a comma-separated list\n+                    MAX: The numeric maximum\n+                    MEDIAN: The numeric median\n+                    MIN: The numeric minimum\n+                    P90, P95, P99, P999: The numeric percentile, 90%, 95%, 99% or 99.9%\n+                    STDEV: The numeric standard deviation\n+                    SUM: The numeric sum\n+                    UNIQUE: The unique number of occurrences of a value\n+                   Null values are included, but ignored for numeric functions. If no\n+                   aggregator function is specified, the first non-null value is used.\n+                 - property, any of the following:\n+                    cell-height:<integer> Maximum height of a table cell\n+                    missing:whitespace Replace missing values (N\/A) with blank space\n+                    normalized Normalize values between 0 and 1.0 for the column\n+                    truncate-beginning if value can't fit a table cell, remove the first characters\n+                    truncate-end if value can't fit a table cell, remove the last characters\n+\n+                 If no value exist, or a numeric value can't be aggregated, the result is 'N\/A',\n+                 unless missing:whitespace is used. The top frame of a stack trace can be referred'\n+                 to as stackTrace.topFrame. When multiple event types are specified in a FROM clause,\n+                 the union of the event types are used (not the cartesian product)\n+\n+                 To see all available events, use the query '\"SHOW EVENTS\"'. To see all fields for\n+                 a particular event type, use the query '\"SHOW FIELDS <type>\"'.\"\"\";\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/QueryPrinter.java","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -0,0 +1,372 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.query;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.function.Function;\n+import java.util.regex.Pattern;\n+\n+import jdk.jfr.EventType;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.query.FilteredType.Filter;\n+import jdk.jfr.internal.query.Query.Condition;\n+import jdk.jfr.internal.query.Query.Expression;\n+import jdk.jfr.internal.query.Query.Formatter;\n+import jdk.jfr.internal.query.Query.Grouper;\n+import jdk.jfr.internal.query.Query.OrderElement;\n+import jdk.jfr.internal.query.Query.Source;\n+import jdk.jfr.internal.util.Matcher;\n+import jdk.jfr.internal.util.SpellChecker;\n+\n+\/**\n+ * Purpose of this class is to take a query and all available event types and\n+ * check that the query is valid, for example, to see if all fields and types\n+ * referenced in the query exists. The end result is a list of fields\n+ * suitable for grouping, sorting and rendering operations later.\n+ *\/\n+final class QueryResolver {\n+    @SuppressWarnings(\"serial\")\n+    static class QueryException extends Exception {\n+        public QueryException(String message) {\n+            super(message);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static final class QuerySyntaxException extends QueryException {\n+        public QuerySyntaxException(String message) {\n+            super(message);\n+        }\n+    }\n+\n+    private final List<EventType> eventTypes;\n+    private final List<FilteredType> fromTypes = new ArrayList<>();\n+    private final Map<String, FilteredType> typeAliases = new LinkedHashMap<>();\n+    private final Map<String, Field> fieldAliases = new LinkedHashMap<>();\n+    private final List<Field> resultFields = new ArrayList<>();\n+\n+    \/\/ For readability take query apart\n+    private final List<String> column;\n+    private final List<Formatter> format;\n+    private final List<Expression> select;\n+    private final List<Source> from;\n+    private final List<Condition> where;\n+    private final List<OrderElement> orderBy;\n+    private final List<Grouper> groupBy;\n+\n+    public QueryResolver(Query query, List<EventType> eventTypes) {\n+        this.eventTypes = eventTypes;\n+        this.column = query.column;\n+        this.format = query.format;\n+        this.select = query.select;\n+        this.from = query.from;\n+        this.where = query.where;\n+        this.orderBy = query.orderBy;\n+        this.groupBy = query.groupBy;\n+    }\n+\n+    public List<Field> resolve() throws QueryException {\n+        resolveFrom();\n+        resolveSelect();\n+        resolveGroupBy();\n+        resolveOrderBy();\n+        resolveWhere();\n+        applyColumn();\n+        applyFormat();\n+        return resultFields;\n+    }\n+\n+    private void resolveWhere() throws QuerySyntaxException {\n+        for (Condition condition : where) {\n+            List<Field> fields = new ArrayList<>();\n+            String fieldName = condition.field();\n+            Field aliasedField = fieldAliases.get(fieldName);\n+            if (aliasedField != null) {\n+                fields.add(aliasedField);\n+            } else {\n+                fields.addAll(resolveFields(fieldName, fromTypes));\n+            }\n+            for (Field field : fields) {\n+                field.type.addFilter(new Filter(field, condition.value()));\n+            }\n+        }\n+    }\n+\n+    private void resolveFrom() throws QueryException {\n+        for (Source source : from) {\n+            List<EventType> eventTypes = resolveEventType(source.name());\n+            if (!source.alias().isEmpty() && eventTypes.size() > 1) {\n+                throw new QueryException(\"Alias can only refer to a single event type\");\n+            }\n+            for (EventType eventType : eventTypes) {\n+                FilteredType type = new FilteredType(eventType);\n+                fromTypes.add(type);\n+                source.alias().ifPresent(alias -> typeAliases.put(alias, type));\n+            }\n+        }\n+    }\n+\n+    private void resolveSelect() throws QueryException {\n+        if (select.isEmpty()) { \/\/ SELECT *\n+            resultFields.addAll(FieldBuilder.createWildcardFields(eventTypes, fromTypes));\n+            return;\n+        }\n+        for (Expression expression : select) {\n+            Field field = addField(expression.name(), fromTypes);\n+            field.visible = true;\n+            field.aggregator = expression.aggregator();\n+            FieldBuilder.configureAggregator(field);\n+            expression.alias().ifPresent(alias -> fieldAliases.put(alias, field));\n+            if (field.name.equals(\"*\") && field.aggregator != Aggregator.COUNT) {\n+                throw new QuerySyntaxException(\"Wildcard ('*') can only be used with aggregator function COUNT\");\n+            }\n+        }\n+    }\n+\n+    private void resolveGroupBy() throws QueryException {\n+        if (groupBy.isEmpty()) {\n+            \/\/ Queries on the form \"SELECT SUM(a), b, c FROM D\" should group all rows implicitly\n+            var f = select.stream().filter(e -> e.aggregator() != Aggregator.MISSING).findFirst();\n+            if (f.isPresent()) {\n+                Grouper grouper = new Grouper(\"startTime\");\n+                for (var fr : fromTypes) {\n+                    Field implicit = addField(\"startTime\", List.of(fr));\n+                    implicit.valueGetter = e -> 1;\n+                    implicit.grouper = grouper;\n+                }\n+                groupBy.add(grouper);\n+                return;\n+            }\n+        }\n+\n+        for (Grouper grouper : groupBy) {\n+            for (FilteredType type : fromTypes) {\n+                String fieldName = grouper.field();\n+                \/\/ Check if alias exists, e.g. \"SELECT field AS K FROM ... GROUP BY K\"\n+                Field field= fieldAliases.get(fieldName);\n+                if (field != null) {\n+                    fieldName = field.name;\n+                    if (field.aggregator != Aggregator.MISSING) {\n+                        throw new QueryException(\"Aggregate funtion can't be used together with an alias\");\n+                    }\n+                }\n+                field = addField(fieldName, List.of(type));\n+                field.grouper = grouper;\n+            }\n+        }\n+    }\n+\n+    private void resolveOrderBy() throws QueryException {\n+        for (OrderElement orderer : orderBy) {\n+            Field field = fieldAliases.get(orderer.name());\n+            if (field == null) {\n+                field = addField(orderer.name(), fromTypes);\n+            }\n+            field.orderer = orderer;\n+        }\n+    }\n+\n+    private void applyColumn() throws QueryException {\n+        if (column.isEmpty()) {\n+            return;\n+        }\n+        if (column.size() != select.size()) {\n+            throw new QuerySyntaxException(\"Number of fields in COLUMN clause doesn't match SELECT\");\n+        }\n+\n+        for (Field field : resultFields) {\n+            if (field.visible) {\n+                field.label = column.get(field.index);\n+            }\n+        }\n+    }\n+\n+    private void applyFormat() throws QueryException {\n+        if (format.isEmpty()) {\n+            return;\n+        }\n+        if (format.size() != select.size()) {\n+            throw new QueryException(\"Number of fields in FORMAT doesn't match SELECT\");\n+        }\n+        for (Field field : resultFields) {\n+            if (field.visible) {\n+                for (var formatter : format.get(field.index).properties()) {\n+                    formatter.style().accept(field);\n+                }\n+            }\n+        }\n+    }\n+\n+    private Field addField(String name, List<FilteredType> types) throws QueryException {\n+        List<Field> fields = resolveFields(name, types);\n+        if (fields.isEmpty()) {\n+            throw new QueryException(unknownField(name, types));\n+        }\n+\n+        Field primary = fields.getFirst();\n+        boolean mixedTypes = false;\n+        for (Field f : fields) {\n+            if (!f.dataType.equals(primary.dataType)) {\n+                mixedTypes = true;\n+            }\n+        }\n+        for (Field field: fields) {\n+            field.index = resultFields.size();\n+            primary.sourceFields.add(field);\n+            \/\/ Convert to String if field data types mismatch\n+            if (mixedTypes) {\n+                final Function<RecordedEvent, Object> valueGetter = field.valueGetter;\n+                field.valueGetter = event -> {\n+                  return FieldFormatter.format(field, valueGetter.apply(event));\n+                };\n+                field.lexicalSort = true;\n+                field.dataType = String.class.getName();\n+                field.alignLeft = true;\n+            }\n+        }\n+        resultFields.add(primary);\n+        return primary;\n+    }\n+\n+    private List<Field> resolveFields(String name, List<FilteredType> types) {\n+        List<Field> fields = new ArrayList<>();\n+\n+        if (name.equals(\"*\")) {\n+            \/\/ Used with COUNT(*) and UNIQUE(*)\n+            \/\/ All events should have a start time\n+            name = \"startTime\";\n+        }\n+        if (name.startsWith(\"[\")) {\n+            int index = name.indexOf(\"]\");\n+            if (index != -1) {\n+                String typeNames = name.substring(1, index);\n+                String suffix = name.substring(index + 1);\n+                for (String typeName : typeNames.split(Pattern.quote(\"|\"))) {\n+                    fields.addAll(resolveFields(typeName + suffix, types));\n+                }\n+                return fields;\n+            }\n+        }\n+\n+        \/\/ Match \"namespace.Event.field\" and \"Event.field\"\n+        if (name.contains(\".\")) {\n+            for (FilteredType et : types) {\n+                String fullEventType = et.getName() + \".\";\n+                if (name.startsWith(fullEventType)) {\n+                    String fieldName = name.substring(fullEventType.length());\n+                    FieldBuilder fb = new FieldBuilder(eventTypes, et, fieldName);\n+                    fields.addAll(fb.build());\n+                }\n+                String eventType = et.getSimpleName() + \".\";\n+                if (name.startsWith(eventType)) {\n+                    String fieldName = name.substring(eventType.length());\n+                    FieldBuilder fb = new FieldBuilder(eventTypes, et, fieldName);\n+                    fields.addAll(fb.build());\n+                }\n+            }\n+        }\n+        \/\/ Match \"ALIAS.field\" where ALIAS can be \"namespace.Event\" or \"Event\"\n+        for (var entry : typeAliases.entrySet()) {\n+            String alias = entry.getKey() + \".\";\n+            FilteredType s = entry.getValue();\n+            if (name.startsWith(alias)) {\n+                int index = name.indexOf(\".\");\n+                String unaliased = s.getName() + \".\" + name.substring(index + 1);\n+                fields.addAll(resolveFields(unaliased, List.of(s)));\n+            }\n+        }\n+\n+        \/\/ Match without namespace\n+        for (FilteredType eventType : types) {\n+            FieldBuilder fb = new FieldBuilder(eventTypes, eventType, name);\n+            fields.addAll(fb.build());\n+        }\n+        return fields;\n+    }\n+\n+    private List<EventType> resolveEventType(String name) throws QueryException {\n+        List<EventType> types = new ArrayList<>();\n+        \/\/ Match fully qualified name first\n+        for (EventType eventType : eventTypes) {\n+            if (Matcher.match(eventType.getName(),name)) {\n+                types.add(eventType);\n+            }\n+        }\n+        \/\/ Match less qualified name\n+        for (EventType eventType : eventTypes) {\n+            if (eventType.getName().endsWith(\".\" + name)) {\n+                types.add(eventType);\n+                break;\n+            }\n+        }\n+        if (types.isEmpty()) {\n+            throw new QueryException(unknownEventType(eventTypes, name));\n+        }\n+        return types;\n+    }\n+\n+    private static String unknownField(String name, List<FilteredType> types) {\n+        List<String> alternatives = new ArrayList<>();\n+        StringJoiner sj = new StringJoiner(\", \");\n+        for (FilteredType t : types) {\n+            for (var v : t.getFields()) {\n+                alternatives.add(v.getName());\n+                alternatives.add(t.getName() + \".\" + v.getName());\n+                alternatives.add(t.getSimpleName() + \".\" + v.getName());\n+            }\n+            sj.add(t.getName());\n+        }\n+        String message = \"Can't find field named '\" + name + \"' in \" + sj;\n+        String alternative = SpellChecker.check(name, alternatives);\n+        if (alternative != null) {\n+            return message + \".\\nDid you mean '\" + alternative + \"'?\";\n+        } else {\n+            return message + \".\\nUse 'SHOW FIELDS \" + types.getFirst().getSimpleName() + \"' to list available fields.\";\n+        }\n+    }\n+\n+    private static String unknownEventType(List<EventType> eventTypes, String name) {\n+        List<String> alternatives = new ArrayList<>();\n+        for (EventType type : eventTypes) {\n+            alternatives.add(Utils.makeSimpleName(type));\n+        }\n+        String alternative = SpellChecker.check(name, alternatives);\n+        String message = \"Can't find event type named '\" + name + \"'.\";\n+        if (alternative != null) {\n+            return message + \" Did you mean '\" + alternative + \"'?\";\n+        } else {\n+            return message + \" 'SHOW EVENTS' will list available event types.\";\n+        }\n+    }\n+\n+    public List<FilteredType> getFromTypes() {\n+        return fromTypes;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/QueryResolver.java","additions":372,"deletions":0,"binary":false,"changes":372,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.query;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+\n+import jdk.jfr.consumer.EventStream;\n+import jdk.jfr.consumer.MetadataEvent;\n+import jdk.jfr.internal.query.QueryResolver.QueryException;\n+import jdk.jfr.internal.query.QueryResolver.QuerySyntaxException;\n+\n+final class QueryRun {\n+    private final Histogram histogram = new Histogram();\n+    private final Table table = new Table();\n+    private final List<String> syntaxErrors = new ArrayList<>();\n+    private final List<String> metadataErrors = new ArrayList<>();\n+    private final Query query;\n+    private final EventStream stream;\n+\n+    public QueryRun(EventStream stream, Query query) {\n+        this.stream = stream;\n+        this.query = query;\n+    }\n+\n+    void onMetadata(MetadataEvent e) {\n+        if (table.getFields().isEmpty()) {\n+            \/\/ Only use first metadata event for now\n+            try {\n+                QueryResolver resolver = new QueryResolver(query, e.getEventTypes());\n+                List<Field> fields = resolver.resolve();\n+                table.addFields(fields);\n+                histogram.addFields(fields);\n+                addEventListeners();\n+            } catch (QuerySyntaxException qe) {\n+                syntaxErrors.add(qe.getMessage());\n+            } catch (QueryException qe) {\n+                metadataErrors.add(qe.getMessage());\n+            }\n+        }\n+    }\n+\n+    public void complete() {\n+        if (!query.groupBy.isEmpty()) {\n+            table.addRows(histogram.toRows());\n+        }\n+    }\n+\n+    private void addEventListeners() {\n+        for (var entry : groupByTypeDescriptor().entrySet()) {\n+            FilteredType type = entry.getKey();\n+            List<Field> sourceFields = entry.getValue();\n+            stream.onEvent(type.getName(), e -> {\n+                for (var filter : type.getFilters()) {\n+                    Object object = filter.field().valueGetter.apply(e);\n+                    String text = FieldFormatter.format(filter.field(), object);\n+                    if (!text.equals(filter.value())) {\n+                        return;\n+                    }\n+                }\n+                if (query.groupBy.isEmpty()) {\n+                    table.add(e, sourceFields);\n+                } else {\n+                    histogram.add(e, type, sourceFields);\n+                }\n+            });\n+        }\n+    }\n+\n+    private LinkedHashMap<FilteredType, List<Field>> groupByTypeDescriptor() {\n+        var multiMap = new LinkedHashMap<FilteredType, List<Field>>();\n+        for (Field field : table.getFields()) {\n+            for (Field sourceFields : field.sourceFields) {\n+                multiMap.computeIfAbsent(sourceFields.type, k -> new ArrayList<>()).add(field);\n+            }\n+        }\n+        return multiMap;\n+    }\n+\n+    public List<String> getSyntaxErrors() {\n+        return syntaxErrors;\n+    }\n+\n+    public List<String> getMetadataErrors() {\n+        return metadataErrors;\n+    }\n+\n+    public Query getQuery() {\n+        return query;\n+    }\n+\n+    public Table getTable() {\n+        return table;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/QueryRun.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.query;\n+\n+import java.util.Arrays;\n+\n+final class Row {\n+    private final Object[] values;\n+    private final String[] texts;\n+\n+    public Row(int size) {\n+        values = new Object[size];\n+        texts = new String[size];\n+    }\n+\n+    public Object getValue(int index) {\n+        return values[index];\n+    }\n+\n+    public void putValue(int index, Object o) {\n+        values[index] = o;\n+    }\n+\n+    public String getText(int index) {\n+        return texts[index];\n+    }\n+\n+    public void putText(int index, String text) {\n+        texts[index] = text;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Arrays.asList(values).toString();\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/Row.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.query;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.jfr.consumer.RecordedEvent;\n+\n+\/**\n+ * Class responsible for holding rows, their values and textual\n+ * representation.\n+ *\/\n+final class Table {\n+    private final List<Row> rows = new ArrayList<>();\n+    private final List<Field> fields = new ArrayList<>();\n+\n+    boolean isEmpty() {\n+        return rows.isEmpty();\n+    }\n+\n+    void addRows(List<Row> rows) {\n+        this.rows.addAll(rows);\n+    }\n+\n+    List<Row> getRows() {\n+        return rows;\n+    }\n+\n+    void addFields(List<Field> fields) {\n+        for (int index = 0; index <fields.size(); index++) {\n+            if (fields.get(index).index != index) {\n+                throw new InternalError(\"Field index not in sync. with array position\");\n+            }\n+        }\n+        this.fields.addAll(fields);\n+    }\n+\n+    List<Field> getFields() {\n+        return fields;\n+    }\n+\n+    public void add(RecordedEvent event, List<Field> sourceFields) {\n+        Row row = new Row(fields.size());\n+        for (Field field : sourceFields) {\n+            row.putValue(field.index, field.valueGetter.apply(event));\n+        }\n+        rows.add(row);\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/Table.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.query;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import jdk.jfr.internal.query.Configuration.Truncate;\n+\n+final class TableCell {\n+    static final String ELLIPSIS = \"...\";\n+    static final String COLUMN_SEPARATOR = \" \";\n+    static final int MINIMAL_CELL_WIDTH = 1 + COLUMN_SEPARATOR.length();\n+    static final int ELLIPSIS_LENGTH = ELLIPSIS.length();\n+\n+    private final List<String> lines = new ArrayList<>();\n+    private final Truncate truncate;\n+    private int preferredWidth;\n+\n+    final int cellHeight;\n+    final Field field;\n+    int width;\n+\n+    public TableCell(Field field, int cellHeight, Truncate truncate) {\n+        this.field = field;\n+        this.cellHeight = cellHeight;\n+        this.truncate = truncate;\n+    }\n+\n+    public int getContentWidth() {\n+        return width - COLUMN_SEPARATOR.length();\n+    }\n+\n+    public int getHeight() {\n+        return lines.size();\n+    }\n+\n+    public String getText(int rowIndex) {\n+        return lines.get(rowIndex);\n+    }\n+\n+    public void setPreferredWidth(int width) {\n+        preferredWidth = width;\n+    }\n+\n+    public int getPreferredWidth() {\n+        return preferredWidth;\n+    }\n+    public void addLine(String text) {\n+        int contentWidth = getContentWidth();\n+        if (text.length() >= contentWidth) {\n+            add(truncate(text, contentWidth));\n+        } else {\n+            addAligned(text);\n+        }\n+    }\n+\n+    public void setContent(String text) {\n+        clear();\n+        int contentSize = getContentSize();\n+        \/\/ Bail out early to prevent ellipsis when size is the same\n+        if (text.length() == contentSize) {\n+            add(text);\n+            return;\n+        }\n+        \/\/ Text is larger than size of the cell, truncate\n+        if (text.length() >= contentSize) {\n+            add(truncate(text, contentSize));\n+            return;\n+        }\n+        \/\/ Text fits on one line, pad left or right depending on alignment\n+        int contentWidth = getContentWidth();\n+        if (text.length() < contentWidth) {\n+            addAligned(text);\n+            return;\n+        }\n+        \/\/ Multiple lines and text fits cell\n+        add(text);\n+    }\n+\n+    private void addAligned(String text) {\n+        String padding = \" \".repeat(getContentWidth() - text.length());\n+        if (field.alignLeft) {\n+            add(text + padding);\n+        } else {\n+            add(padding + text);\n+        }\n+    }\n+\n+    public int getContentSize() {\n+        return cellHeight * getContentWidth();\n+    }\n+\n+    public List<String> getLines() {\n+        return lines;\n+    }\n+\n+    private String truncate(String text, int size) {\n+        if (size < ELLIPSIS_LENGTH) {\n+            return ELLIPSIS.substring(0, ELLIPSIS_LENGTH - size);\n+        }\n+        int textSize = size - ELLIPSIS_LENGTH;\n+        if (truncate == Truncate.BEGINNING) {\n+            return ELLIPSIS + text.substring(text.length() - textSize);\n+        } else {\n+            return text.substring(0, textSize) + ELLIPSIS;\n+        }\n+    }\n+\n+    private void add(String text) {\n+        int contentWidth = getContentWidth();\n+        int contentSize = getContentSize();\n+        for (int index = 0; index < contentSize; index += contentWidth) {\n+            int end = index + contentWidth;\n+            if (end >= text.length()) {\n+                String content = text.substring(index);\n+                content += \" \".repeat(contentWidth - content.length());\n+                lines.add(content);\n+                return;\n+            }\n+            lines.add(text.substring(index, end));\n+        }\n+    }\n+\n+    public void clear() {\n+        lines.clear();\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/TableCell.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -0,0 +1,357 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.query;\n+\n+import static jdk.jfr.internal.query.Configuration.MAX_PREFERRED_WIDTH;\n+import static jdk.jfr.internal.query.Configuration.MIN_PREFERRED_WIDTH;\n+import static jdk.jfr.internal.query.Configuration.PREFERRED_WIDTH;\n+\n+import java.util.List;\n+import java.util.function.Predicate;\n+\n+import jdk.jfr.consumer.RecordedFrame;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.consumer.RecordedStackTrace;\n+import jdk.jfr.internal.query.Configuration.Truncate;\n+import jdk.jfr.internal.util.Output;\n+\n+\/**\n+ * Class responsible for printing and formatting the contents of a table.\n+ *\/\n+final class TableRenderer {\n+    private final Configuration configuration;\n+    private final List<TableCell> tableCells;\n+    private final Table table;\n+    private final Query query;\n+    private final Output out;\n+    private int width;\n+    private int preferredWidth;\n+\n+    public TableRenderer(Configuration configuration, Table table, Query query) {\n+        this.configuration = configuration;\n+        this.tableCells = createTableCells(table);\n+        this.table = table;\n+        this.query = query;\n+        this.out = configuration.output;\n+    }\n+\n+    private List<TableCell> createTableCells(Table table) {\n+        return table.getFields().stream().filter(f -> f.visible).map(f -> createTableCell(f)).toList();\n+    }\n+\n+    private TableCell createTableCell(Field field) {\n+        Truncate truncate = configuration.truncate;\n+        if (truncate == null) {\n+            truncate = field.truncate;\n+        }\n+        if (configuration.cellHeight != 0) {\n+            return new TableCell(field, configuration.cellHeight, truncate);\n+        } else {\n+            return new TableCell(field, field.cellHeight, truncate);\n+        }\n+    }\n+\n+    public void render() {\n+        if (isEmpty()) {\n+            if (configuration.title != null) {\n+                out.println();\n+                out.println(\"No events found for '\" + configuration.title +\"'.\");\n+            }\n+            return;\n+        }\n+        if (tooManyColumns()) {\n+            out.println();\n+            out.println(\"Too many columns to fit width.\");\n+            return;\n+        }\n+\n+        formatRow();\n+        sortRows();\n+        setColumnWidths();\n+        printTitle();\n+        printHeaderRow();\n+        printHeaderRowSeparators();\n+        printRows();\n+    }\n+\n+    private boolean isEmpty() {\n+        return tableCells.isEmpty() || table.getRows().isEmpty();\n+    }\n+\n+    private boolean tooManyColumns() {\n+        int minWidth = tableCells.size() * TableCell.MINIMAL_CELL_WIDTH;\n+        if (configuration.width != 0) {\n+            return minWidth > configuration.width;\n+        }\n+        return minWidth > MAX_PREFERRED_WIDTH;\n+    }\n+\n+    private void formatRow() {\n+        double[] max = calculateNormalization();\n+        for (Row row : table.getRows()) {\n+            for (Field field : table.getFields()) {\n+                int index = field.index;\n+                Object object = row.getValue(index);\n+                if (field.normalized && object instanceof Number number) {\n+                    object = number.doubleValue() \/ max[index];\n+                }\n+                String text = FieldFormatter.format(field, object);\n+                row.putText(index, text);\n+                if (index < tableCells.size()) {\n+                    TableCell cell = tableCells.get(index);\n+                    int width = text.length() + TableCell.COLUMN_SEPARATOR.length();\n+                    if (width > cell.getPreferredWidth()) {\n+                        cell.setPreferredWidth(width);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private double[] calculateNormalization() {\n+        double[] max = new double[tableCells.size()];\n+        int index = 0;\n+        for (TableCell cell : tableCells) {\n+            if (cell.field.normalized) {\n+                for (Row row : table.getRows()) {\n+                    if (row.getValue(index) instanceof Number number) {\n+                        max[index] += number.doubleValue();\n+                    }\n+                }\n+            }\n+            index++;\n+        }\n+        return max;\n+    }\n+\n+    private void sortRows() {\n+        TableSorter sorter = new TableSorter(table, query);\n+        sorter.sort();\n+    }\n+\n+    private void setColumnWidths() {\n+        setRowWidths();\n+        setPreferredHeaderWidths();\n+        if (configuration.width == 0) {\n+            preferredWidth= determineTableWidth();\n+        } else {\n+            preferredWidth = configuration.width;\n+        }\n+        \/\/ Set minimum table cell width\n+        distribute(cell -> cell.width < TableCell.MINIMAL_CELL_WIDTH);\n+        \/\/ Fill with preferred width\n+        distribute(cell -> cell.width < cell.getPreferredWidth());\n+        \/\/ Distribute additional width to table cells with a non-fixed size\n+        distribute(cell -> !cell.field.fixedWidth);\n+        \/\/ If all table cells are fixed size, distribute to any of them\n+        distribute(cell -> true);\n+    }\n+\n+    private void setRowWidths() {\n+        int rowCount = 0;\n+        for (Row row : table.getRows()) {\n+            if (rowCount == query.limit) {\n+                return;\n+            }\n+            int columnIndex = 0;\n+            for (TableCell cell : tableCells) {\n+                String text = row.getText(columnIndex);\n+                int width = text.length() + TableCell.COLUMN_SEPARATOR.length();\n+                if (width > cell.getPreferredWidth()) {\n+                    cell.setPreferredWidth(width);\n+                }\n+                columnIndex++;\n+            }\n+            rowCount++;\n+        }\n+    }\n+\n+    private void setPreferredHeaderWidths() {\n+        for (TableCell cell : tableCells) {\n+            int headerWidth = cell.field.label.length();\n+            if (configuration.verboseHeaders) {\n+                headerWidth = Math.max(fieldName(cell.field).length(), headerWidth);\n+            }\n+            headerWidth += TableCell.COLUMN_SEPARATOR.length();\n+            if (headerWidth > cell.getPreferredWidth()) {\n+                cell.setPreferredWidth(headerWidth);\n+            }\n+        }\n+    }\n+\n+    private int determineTableWidth() {\n+        int preferred = 0;\n+        for (TableCell cell : tableCells) {\n+            preferred += cell.getPreferredWidth();\n+        }\n+        \/\/ Avoid a very large table.\n+        if (preferred > MAX_PREFERRED_WIDTH) {\n+            return MAX_PREFERRED_WIDTH;\n+        }\n+        \/\/ Avoid a very small width, but not preferred width if there a few columns\n+        if (preferred < MIN_PREFERRED_WIDTH && tableCells.size() < 3) {\n+            return MIN_PREFERRED_WIDTH;\n+        }\n+        \/\/ Expand to preferred width\n+        if (preferred < PREFERRED_WIDTH) {\n+            return PREFERRED_WIDTH;\n+        }\n+        return preferred;\n+    }\n+\n+    private void distribute(Predicate<TableCell> condition) {\n+        long amountLeft = preferredWidth - width;\n+        long last = -1;\n+        while (amountLeft > 0 && amountLeft != last) {\n+            last = amountLeft;\n+            for (TableCell cell : tableCells) {\n+                if (condition.test(cell)) {\n+                    cell.width++;\n+                    width++;\n+                    amountLeft--;\n+                }\n+            }\n+        }\n+    }\n+\n+    private void printTitle() {\n+        String title = configuration.title;\n+        if (title != null) {\n+            if (isExperimental()) {\n+                title += \" (Experimental)\";\n+            }\n+            int pos = width - title.length();\n+            pos = Math.max(0, pos);\n+            pos = pos \/ 2;\n+            out.println();\n+            out.println(\" \".repeat(pos) + title);\n+            out.println();\n+        }\n+    }\n+\n+    private boolean isExperimental() {\n+        return tableCells.stream().flatMap(c -> c.field.sourceFields.stream()).anyMatch(f -> f.type.isExperimental());\n+    }\n+\n+    private void printHeaderRow() {\n+        printRow(cell -> cell.field.label);\n+        if (configuration.verboseHeaders) {\n+            printRow(cell -> fieldName(cell.field));\n+        }\n+    }\n+\n+    private void printHeaderRowSeparators() {\n+        printRow(cell -> \"-\".repeat(cell.getContentWidth()));\n+    }\n+\n+    private void printRow(java.util.function.Function<TableCell, String> action) {\n+        for (TableCell cell : tableCells) {\n+            cell.setContent(action.apply(cell));\n+        }\n+        printRow();\n+    }\n+\n+    private void printRows() {\n+        int rowCount = 0;\n+        for (Row row : table.getRows()) {\n+            if (rowCount == query.limit) {\n+                return;\n+            }\n+            int columnIndex = 0;\n+            for (TableCell cell : tableCells) {\n+                setCellContent(cell, row, columnIndex++);\n+            }\n+            printRow();\n+            rowCount++;\n+        }\n+    }\n+\n+    private void setCellContent(TableCell cell, Row row, int columnIndex) {\n+        String text = row.getText(columnIndex);\n+        if (cell.cellHeight > 1) {\n+            Object o = row.getValue(columnIndex);\n+            if (o instanceof RecordedStackTrace s) {\n+                setStackTrace(cell, s);\n+                return;\n+            }\n+        }\n+\n+        if (text.length() > cell.getContentSize()) {\n+            Object o = row.getValue(columnIndex);\n+\n+            cell.setContent(FieldFormatter.formatCompact(cell.field, o));\n+            return;\n+        }\n+        cell.setContent(text);\n+    }\n+\n+    private void setStackTrace(TableCell cell, RecordedStackTrace s) {\n+        int row = 0;\n+        cell.clear();\n+        for(RecordedFrame f : s.getFrames()) {\n+            if (row == cell.cellHeight) {\n+                return;\n+            }\n+            if (f.isJavaFrame()) {\n+                RecordedMethod method = f.getMethod();\n+                String text = FieldFormatter.format(cell.field, method);\n+                if (text.length() > cell.getContentWidth()) {\n+                    text = FieldFormatter.formatCompact(cell.field, method);\n+                }\n+                cell.addLine(text);\n+            }\n+            row++;\n+        }\n+    }\n+\n+    private void printRow() {\n+        long maxHeight = 0;\n+        for (TableCell cell : tableCells) {\n+            maxHeight = Math.max(cell.getHeight(), maxHeight);\n+        }\n+        TableCell lastCell = tableCells.get(tableCells.size() - 1);\n+        for (int rowIndex = 0; rowIndex < maxHeight; rowIndex++) {\n+            for (TableCell cell : tableCells) {\n+                if (rowIndex < cell.getHeight()) {\n+                    out.print(cell.getText(rowIndex));\n+                } else {\n+                    out.print(\" \".repeat(cell.getContentWidth()));\n+                }\n+                if (cell != lastCell) {\n+                    out.print(TableCell.COLUMN_SEPARATOR);\n+                }\n+            }\n+            out.println();\n+        }\n+    }\n+\n+    private String fieldName(Field field) {\n+        return \"(\" + field.name + \")\";\n+    }\n+\n+    public long getWidth() {\n+        return width;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/TableRenderer.java","additions":357,"deletions":0,"binary":false,"changes":357,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.query;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.function.Predicate;\n+\n+import jdk.jfr.internal.query.Query.OrderElement;\n+import jdk.jfr.internal.query.Query.SortOrder;\n+\/**\n+ * Class responsible for sorting a table according to an ORDER BY statement or\n+ * a heuristics.\n+ *\/\n+final class TableSorter {\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    private static class ColumnComparator implements Comparator<Row> {\n+        private final int factor;\n+        private final int index;\n+        private final boolean lexical;\n+\n+        public ColumnComparator(Field field, SortOrder order) {\n+            this.factor = sortOrderToFactor(determineSortOrder(field, order));\n+            this.index = field.index;\n+            this.lexical = field.lexicalSort;\n+        }\n+\n+        private SortOrder determineSortOrder(Field field, SortOrder order) {\n+            if (order != SortOrder.NONE) {\n+                return order;\n+            }\n+            if (field.timespan || field.percentage) {\n+                return SortOrder.DESCENDING;\n+            }\n+            return SortOrder.ASCENDING;\n+        }\n+\n+        int sortOrderToFactor(SortOrder order) {\n+            return order == SortOrder.DESCENDING ? -1 : 1;\n+        }\n+\n+        @Override\n+        public int compare(Row rowA, Row rowB) {\n+            if (lexical) {\n+                return compareObjects(rowA.getText(index), rowB.getText(index));\n+            } else {\n+                return compareObjects(rowA.getValue(index), rowB.getValue(index));\n+            }\n+        }\n+\n+        private int compareObjects(Object a, Object b) {\n+            if (a instanceof Comparable c1 && b instanceof Comparable c2) {\n+                return factor * c1.compareTo(c2);\n+            }\n+            return factor;\n+        }\n+    }\n+\n+    private final Table table;\n+    private final Query query;\n+\n+    public TableSorter(Table table, Query query) {\n+        this.table = table;\n+        this.query = query;\n+    }\n+\n+    public void sort() {\n+        if (table.getFields().isEmpty()) {\n+            return;\n+        }\n+        if (query.orderBy.isEmpty()) {\n+            sortDefault();\n+            return;\n+        }\n+        sortOrderBy();\n+    }\n+\n+    private void sortDefault() {\n+        if (sortAggregators()) {\n+            return;\n+        }\n+        if (sortGroupBy()) {\n+            return;\n+        }\n+        sortLeftMost();\n+    }\n+\n+    private boolean sortAggregators() {\n+        return sortPredicate(field -> field.aggregator != Aggregator.MISSING);\n+    }\n+\n+    private boolean sortGroupBy() {\n+        return sortPredicate(field -> query.groupBy.contains(field.grouper));\n+    }\n+\n+    private void sortOrderBy() {\n+        for (OrderElement orderer : query.orderBy.reversed()) {\n+            sortPredicate(field -> field.orderer == orderer);\n+        }\n+    }\n+\n+    private boolean sortPredicate(Predicate<Field> predicate) {\n+        boolean sorted = false;\n+        for (Field field : table.getFields()) {\n+            if (predicate.test(field)) {\n+                sort(field, determineSortOrder(field));\n+                sorted = true;\n+            }\n+        }\n+        return sorted;\n+    }\n+\n+    private SortOrder determineSortOrder(Field field) {\n+        if (field.orderer == null) {\n+            return SortOrder.NONE;\n+        } else {\n+            return field.orderer.order();\n+        }\n+    }\n+\n+    private void sortLeftMost() {\n+        sort(table.getFields().getFirst(), SortOrder.NONE);\n+    }\n+\n+    private void sort(Field field, SortOrder order) {\n+        table.getRows().sort(new ColumnComparator(field, order));\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/TableSorter.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.query;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import jdk.jfr.internal.util.Tokenizer;\n+\n+\/**\n+ * Represents a configuration file that holds a set up queries and their\n+ * associated metadata, such as labels and descriptions.\n+ *\/\n+final class ViewFile {\n+    record ViewConfiguration(String name, String category, Map<String, String> properties) {\n+        public String query() {\n+            String form = get(\"form\");\n+            if (form != null) {\n+                return form;\n+            }\n+            String table = get(\"table\");\n+            if (table != null) {\n+                return table;\n+            }\n+            throw new IllegalStateException(\"Expected section to have form or table attribute\");\n+        }\n+\n+        public String getLabel() {\n+            return get(\"label\");\n+        }\n+\n+        public String getForm() {\n+            return get(\"form\");\n+        }\n+\n+        public String getTable() {\n+            return get(\"table\");\n+        }\n+\n+        private String get(String key) {\n+            return properties.get(key);\n+        }\n+    }\n+\n+    private final List<ViewConfiguration> configurations;\n+\n+    public ViewFile(String text) throws ParseException {\n+        this.configurations = parse(text);\n+    }\n+\n+    public static ViewFile getDefault() {\n+        try {\n+            var is = ViewFile.class.getResourceAsStream(\"\/jdk\/jfr\/internal\/query\/view.ini\");\n+            byte[] bytes = is.readAllBytes();\n+            String query = new String(bytes, Charset.forName(\"UTF-8\"));\n+            return new ViewFile(query);\n+        } catch (ParseException e) {\n+            throw new InternalError(\"Internal error, invalid view.ini\", e);\n+        } catch (IOException e) {\n+            throw new InternalError(\"Internal error, could not read view.ini\", e);\n+        }\n+    }\n+\n+    public List<ViewConfiguration> getViewConfigurations() {\n+       return configurations;\n+    }\n+\n+    private List<ViewConfiguration> parse(String text) throws ParseException {\n+        List<ViewConfiguration> views = new ArrayList<>();\n+        try (Tokenizer tokenizer = new Tokenizer(text, '[', ']', ';')) {\n+            while (tokenizer.hasNext()) {\n+                while (tokenizer.accept(\";\")) {\n+                    tokenizer.skipLine();\n+                }\n+                if (tokenizer.accept(\"[\")) {\n+                    String fullName = tokenizer.next();\n+                    tokenizer.expect(\"]\");\n+                    views.add(createView(fullName));\n+                }\n+                if (views.isEmpty()) {\n+                    throw new ParseException(\"Expected view file to begin with a section\", tokenizer.getPosition());\n+                }\n+                String key = tokenizer.next();\n+                tokenizer.expect(\"=\");\n+                String value = tokenizer.next();\n+                ViewConfiguration view = views.get(views.size() - 1);\n+                view.properties().put(key, value);\n+            }\n+        }\n+        return views;\n+    }\n+\n+    private ViewConfiguration createView(String fullName) {\n+        int index = fullName.lastIndexOf(\".\");\n+        if (index == -1) {\n+            throw new InternalError(\"Missing name space for \" + fullName);\n+        }\n+        String category = fullName.substring(0, index);\n+        String name = fullName.substring(index + 1);\n+        return new ViewConfiguration(name, category, new LinkedHashMap<>());\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/ViewFile.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,350 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.query;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+\n+import jdk.jfr.EventType;\n+import jdk.jfr.consumer.EventStream;\n+import jdk.jfr.internal.query.QueryResolver.QueryException;\n+import jdk.jfr.internal.query.ViewFile.ViewConfiguration;\n+import jdk.jfr.internal.util.Columnizer;\n+import jdk.jfr.internal.util.Output;\n+import jdk.jfr.internal.util.StopWatch;\n+import jdk.jfr.internal.util.Tokenizer;\n+import jdk.jfr.internal.util.UserDataException;\n+import jdk.jfr.internal.util.UserSyntaxException;\n+import jdk.jfr.internal.util.ValueFormatter;\n+\/**\n+ * Class responsible for executing and displaying the contents of a query.\n+ * <p>\n+ * Used by 'jcmd JFR.view' and 'jfr view'.\n+ * <p>\n+ * Views are defined in jdk\/jfr\/internal\/query\/view.ini\n+ *\/\n+public final class ViewPrinter {\n+    private final Configuration configuration;\n+    private final EventStream stream;\n+    private final Output out;\n+    private final StopWatch stopWatch;\n+\n+    \/**\n+     * Constructs a view printer object.\n+     *\n+     * @param configuration display configuration\n+     * @param stream a non-started stream from where data should be fetched.\n+     *\/\n+    public ViewPrinter(Configuration configuration, EventStream stream) {\n+        this.configuration = configuration;\n+        this.out = configuration.output;\n+        this.stopWatch = new StopWatch();\n+        this.stream = stream;\n+    }\n+\n+    \/**\n+     * Prints the view.\n+     *\n+     * @param text the view or event type to display\n+     *\n+     * @throws UserDataException   if the stream associated with the printer lacks\n+     *                             event or event metadata\n+     * @throws UserSyntaxException if the syntax of the query is incorrect.\n+     *\/\n+    public void execute(String text) throws UserDataException, UserSyntaxException {\n+        try {\n+            if (showViews(text) || showEventType(text)) {\n+                return;\n+            }\n+        } catch (ParseException pe) {\n+            throw new InternalError(\"Internal error, view.ini file is invalid\", pe);\n+        }\n+        throw new UserDataException(\"Could not find a view or an event type named \" + text);\n+    }\n+\n+    private boolean showEventType(String eventType) {\n+        try {\n+            QueryPrinter printer = new QueryPrinter(configuration, stream);\n+            configuration.verboseTitle = true;\n+            printer.execute(\"SELECT * FROM \" + eventType);\n+            return true;\n+        } catch (UserDataException | UserSyntaxException e) {\n+            return false;\n+        }\n+    }\n+\n+    private boolean showViews(String text) throws UserDataException, ParseException, UserSyntaxException {\n+        if (configuration.verbose) {\n+            configuration.verboseHeaders = true;\n+        }\n+        if (text.equalsIgnoreCase(\"all-events\")) {\n+            QueryExecutor executor = new QueryExecutor(stream);\n+            stopWatch.beginAggregation();\n+            List<QueryRun> runs = executor.run();\n+            stopWatch.beginFormatting();\n+            for (QueryRun task : runs) {\n+                Table table = task.getTable();\n+                FilteredType type = table.getFields().getFirst().type;\n+                configuration.title = type.getLabel();\n+                TableRenderer renderer = new TableRenderer(configuration, table , task.getQuery());\n+                renderer.render();\n+                out.println();\n+            }\n+            stopWatch.finish();\n+            if (configuration.verbose) {\n+                out.println();\n+                out.println(\"Execution: \" + stopWatch.toString());\n+            }\n+            printTimespan();\n+            return true;\n+        }\n+        if (text.equals(\"types\")) {\n+            QueryPrinter qp = new QueryPrinter(configuration, stream);\n+            qp.execute(\"SHOW EVENTS\");\n+            return true;\n+        }\n+        List<ViewConfiguration> views = ViewFile.getDefault().getViewConfigurations();\n+        if (text.equalsIgnoreCase(\"all-views\")) {\n+            stopWatch.beginQueryValidation();\n+            List<Query> queries = new ArrayList<>();\n+            for (ViewConfiguration view : views) {\n+                queries.add(new Query(view.query()));\n+            }\n+            QueryExecutor executor = new QueryExecutor(stream, queries);\n+            int index = 0;\n+            stopWatch.beginAggregation();\n+            List<QueryRun> runs = executor.run();\n+            stopWatch.beginFormatting();\n+            for (QueryRun run : runs) {\n+                printView(views.get(index++), run);\n+            }\n+            stopWatch.finish();\n+            if (configuration.verbose) {\n+                out.println();\n+                out.println(\"Execution: \" + stopWatch.toString());\n+            }\n+            printTimespan();\n+            printViewTypeRelation(views, executor.getEventTypes());\n+            return true;\n+        }\n+        for (ViewConfiguration view : views) {\n+            if (view.name().equalsIgnoreCase(text)) {\n+                stopWatch.beginQueryValidation();\n+                Query q = new Query(view.query());\n+                QueryExecutor executor = new QueryExecutor(stream, q);\n+                stopWatch.beginAggregation();\n+                QueryRun run = executor.run().getFirst();\n+                stopWatch.beginFormatting();\n+                printView(view, run);\n+                stopWatch.finish();\n+                if (configuration.verbose) {\n+                    out.println();\n+                    out.println(\"Execution: \" + stopWatch.toString());\n+                    out.println();\n+                }\n+                printTimespan();\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    void printViewTypeRelation(List<ViewConfiguration> views, List<EventType> eventTypes) throws ParseException {\n+        if (!configuration.verbose) {\n+            return;\n+        }\n+        out.println();\n+        out.println(\"Event types and views\");\n+        out.println();\n+        Map<String, Set<String>> viewMap = new HashMap<>();\n+        for (EventType type : eventTypes) {\n+            viewMap.put(type.getName(), new LinkedHashSet<>());\n+        }\n+        for (ViewConfiguration view : views) {\n+            Query query = new Query(view.query());\n+            if (query.from.getFirst().name().equals(\"*\")) {\n+                continue;\n+            }\n+            QueryResolver resolver = new QueryResolver(query, eventTypes);\n+            try {\n+                resolver.resolve();\n+            } catch (QueryException e) {\n+               throw new InternalError(e);\n+            }\n+            for (FilteredType ft: resolver.getFromTypes()) {\n+                Set<String> list = viewMap.get(ft.getName());\n+                list.add(view.name());\n+            }\n+        }\n+        List<String> names = new ArrayList<>(viewMap.keySet());\n+        Collections.sort(names);\n+        for (String name : names) {\n+            Set<String> vs = viewMap.get(name);\n+            StringJoiner sj = new StringJoiner(\", \");\n+            vs.stream().forEach(sj::add);\n+            out.println(String.format(\"%-35s %s\", name, sj.toString()));\n+        }\n+    }\n+\n+    private void printTimespan() {\n+        if (configuration.startTime != null) {\n+            String start = ValueFormatter.formatTimestamp(configuration.startTime);\n+            String end = ValueFormatter.formatTimestamp(configuration.endTime);\n+            out.println();\n+            out.println(\"Timespan: \" + start + \" - \" + end);\n+        }\n+    }\n+\n+    private void printView(ViewConfiguration section, QueryRun queryRun)\n+            throws UserDataException, ParseException, UserSyntaxException {\n+        if (!queryRun.getSyntaxErrors().isEmpty()) {\n+            throw new UserSyntaxException(queryRun.getSyntaxErrors().getFirst());\n+        }\n+        if (!queryRun.getMetadataErrors().isEmpty()) {\n+            \/\/ Recording doesn't have the event,\n+            out.println(queryRun.getMetadataErrors().getFirst());\n+            out.println(\"Missing event found for \" + section.name());\n+            return;\n+        }\n+        Table table = queryRun.getTable();\n+        configuration.title = section.getLabel();\n+        long width = 0;\n+        if (section.getForm() != null) {\n+            FormRenderer renderer = new FormRenderer(configuration, table);\n+            renderer.render();\n+            width = renderer.getWidth();\n+        }\n+        if (section.getTable() != null) {\n+            Query query = queryRun.getQuery();\n+            TableRenderer renderer = new TableRenderer(configuration, table, query);\n+            renderer.render();\n+            width = renderer.getWidth();\n+        }\n+        if (width != 0 && configuration.verbose && !queryRun.getTable().isEmpty()) {\n+            out.println();\n+            Query query = queryRun.getQuery();\n+            printQuery(new LineBuilder(out, width), query.toString());\n+        }\n+    }\n+\n+    private void printQuery(LineBuilder lb, String query) {\n+        char[] separators = {'=', ','};\n+        try (Tokenizer tokenizer = new Tokenizer(query, separators)) {\n+            while (tokenizer.hasNext()) {\n+                lb.append(nextText(tokenizer));\n+            }\n+            lb.out.println();\n+        } catch (ParseException pe) {\n+            throw new InternalError(\"Could not format already parsed query\", pe);\n+        }\n+    }\n+\n+    private String nextText(Tokenizer tokenizer) throws ParseException {\n+        if (tokenizer.peekChar() == '\\'') {\n+            return \"'\" + tokenizer.next() + \"'\";\n+        } else {\n+            return tokenizer.next();\n+        }\n+    }\n+\n+    \/\/ Helper class for line breaking\n+    private static class LineBuilder implements Closeable {\n+        private final Output out;\n+        private final long width;\n+        private int position;\n+        LineBuilder(Output out, long width) {\n+            this.out = out;\n+            this.width = width;\n+        }\n+\n+        public void append(String text) {\n+            String original = text;\n+            if (!text.equals(\",\") && !text.equals(\";\") && position != 0) {\n+                text = \" \" + text;\n+            }\n+            if (text.length() > width) {\n+                print(text);\n+                return;\n+            }\n+\n+            if (text.length() + position > width) {\n+                out.println();\n+                position = 0;\n+                text = original;\n+            }\n+            out.print(text);\n+            position += text.length();\n+        }\n+\n+        private void print(String s) {\n+            for (int i = 0; i < s.length(); i++) {\n+                if (position % width == 0 && position != 0) {\n+                    out.println();\n+                }\n+                out.print(s.charAt(i));\n+                position++;\n+            }\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            out.println();\n+        }\n+    }\n+\n+    public static List<String> getAvailableViews() {\n+        List<String> list = new ArrayList<>();\n+        list.add(\"Java virtual machine views:\");\n+        list.add(new Columnizer(getViewList(\"jvm\"), 3).toString());\n+        list.add(\"\");\n+        list.add(\"Environment views:\");\n+        list.add(new Columnizer(getViewList(\"environment\"), 3).toString());\n+        list.add(\"\");\n+        list.add(\"Application views:\");\n+        list.add(new Columnizer(getViewList(\"application\"), 3).toString());\n+        list.add(\"\");\n+        return list;\n+    }\n+\n+    private static List<String> getViewList(String selection) {\n+        List<String> names = new ArrayList<>();\n+        for (var view : ViewFile.getDefault().getViewConfigurations()) {\n+            String category = view.category();\n+            if (selection.equals(category)) {\n+                names.add(view.name());\n+            }\n+        }\n+        return names;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/ViewPrinter.java","additions":350,"deletions":0,"binary":false,"changes":350,"status":"added"},{"patch":"@@ -0,0 +1,576 @@\n+;\n+; Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+; DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+;\n+; This code is free software; you can redistribute it and\/or modify it\n+; under the terms of the GNU General Public License version 2 only, as\n+; published by the Free Software Foundation.  Oracle designates this\n+; particular file as subject to the \"Classpath\" exception as provided\n+; by Oracle in the LICENSE file that accompanied this code.\n+;\n+; This code is distributed in the hope that it will be useful, but WITHOUT\n+; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; version 2 for more details (a copy is included in the LICENSE file that\n+; accompanied this code).\n+;\n+; You should have received a copy of the GNU General Public License version\n+; 2 along with this work; if not, write to the Free Software Foundation,\n+; Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+;\n+; Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+; or visit www.oracle.com if you need additional information or have any\n+; questions.\n+;\n+\n+[environment.active-recordings]\n+label = \"Active Recordings\"\n+table = \"COLUMN 'Start', 'Duration', 'Name',\n+                'Destination', 'Max Age', 'Max Size'\n+         FORMAT none, none, none,\n+                cell-height:5, none, none\n+         SELECT LAST(recordingStart), LAST(recordingDuration), LAST(name),\n+                LAST(destination), LAST(maxAge), LAST(maxSize)\n+         FROM ActiveRecording\n+         GROUP BY id\"\n+\n+[environment.active-settings]\n+label = \"Active Settings\"\n+table = \"COLUMN 'Event Type', 'Enabled', 'Threshold',\n+                'Stack Trace','Period','Cutoff', 'Throttle'\n+         FORMAT none, missing:whitespace, missing:whitespace, missing:whitespace,\n+                missing:whitespace, missing:whitespace, missing:whitespace\n+         SELECT E.id, LAST_BATCH(E.value), LAST_BATCH(T.value),\n+                LAST_BATCH(S.value), LAST_BATCH(P.value),\n+                LAST_BATCH(C.value), LAST_BATCH(U.value)\n+         FROM\n+                ActiveSetting AS E,\n+                ActiveSetting AS T,\n+                ActiveSetting AS S,\n+                ActiveSetting AS P,\n+                ActiveSetting AS C,\n+                ActiveSetting AS U\n+         WHERE\n+               E.name = 'enabled' AND\n+               T.name = 'threshold' AND\n+               S.name = 'stackTrace' AND\n+               P.name = 'period' AND\n+               C.name = 'cutoff' AND\n+               U.name = 'throttle'\n+         GROUP BY\n+                 id\n+         ORDER BY\n+                 E.id\"\n+\n+[application.allocation-by-class]\n+label = \"Allocation by Class\"\n+table = \"COLUMN 'Object Type', 'Allocation Pressure'\n+         FORMAT none, normalized\n+         SELECT objectClass AS O, SUM(weight) AS W\n+         FROM ObjectAllocationSample GROUP BY O ORDER BY W DESC LIMIT 25\"\n+\n+[application.allocation-by-thread]\n+label = \"Allocation by Thread\"\n+table = \"COLUMN 'Thread', 'Allocation Pressure'\n+         FORMAT none, normalized\n+         SELECT eventThread AS T, SUM(weight) AS W\n+         FROM ObjectAllocationSample GROUP BY T ORDER BY W DESC LIMIT 25\"\n+\n+[application.allocation-by-site]\n+label = \"Allocation by Site\"\n+table = \"COLUMN 'Method', 'Allocation Pressure'\n+         FORMAT none, normalized\n+         SELECT stackTrace.topFrame AS S, SUM(weight) AS W\n+         FROM ObjectAllocationSample\n+         GROUP BY S\n+         ORDER BY W DESC LIMIT 25\"\n+\n+[application.class-loaders]\n+label = \"Class Loaders\"\n+table = \"FORMAT missing:null-bootstrap, none, none\n+         SELECT classLoader, LAST(hiddenClassCount),\n+         LAST(classCount) AS C\n+         FROM ClassLoaderStatistics\n+         GROUP BY classLoader ORDER BY C DESC\";\n+\n+[jvm.class-modifications]\n+label = \"Class Modifications\"\n+table = \"COLUMN 'Time', 'Requested By', 'Operation', 'Classes'\n+         SELECT duration, stackTrace.topApplicationFrame, eventType.label, classCount\n+         FROM RetransformClasses, RedefineClasses\n+         GROUP BY redefinitionId\n+         ORDER BY duration DESC\"\n+\n+[jvm.compiler-configuration]\n+label = \"Compiler Configuration\"\n+form = \"SELECT LAST(threadCount), LAST(dynamicCompilerThreadCount), LAST(tieredCompilation)\n+        FROM CompilerConfiguration\"\n+\n+[jvm.compiler-statistics]\n+label = \"Compiler Statistics\"\n+form = \"SELECT LAST(compileCount), LAST(peakTimeSpent), LAST(totalTimeSpent),\n+               LAST(bailoutCount), LAST(osrCompileCount),\n+               LAST(standardCompileCount), LAST(osrBytesCompiled),\n+               LAST(standardBytesCompiled), LAST(nmethodsSize),\n+               LAST(nmethodCodeSize) FROM CompilerStatistics\"\n+\n+[jvm.compiler-phases]\n+label = \"Concurrent Compiler Phases\"\n+table = \"COLUMN 'Level', 'Phase', 'Average',\n+                'P95', 'Longest', 'Count',\n+                'Total'\n+         SELECT phaseLevel AS L, phase AS P, AVG(duration),\n+                P95(duration),  MAX(duration), COUNT(*),\n+                SUM(duration) AS S\n+         FROM CompilerPhase\n+         GROUP BY P ORDER BY L ASC, S DESC\"\n+\n+[environment.container-configuration]\n+label = \"Container Configuration\"\n+form = \"SELECT LAST(containerType), LAST(cpuSlicePeriod), LAST(cpuQuota), LAST(cpuShares),\n+               LAST(effectiveCpuCount), LAST(memorySoftLimit), LAST(memoryLimit),\n+               LAST(swapMemoryLimit), LAST(hostTotalMemory)\n+               FROM ContainerConfiguration\"\n+\n+[environment.container-cpu-usage]\n+label = \"Container CPU Usage\"\n+form = \"SELECT LAST(cpuTime), LAST(cpuUserTime), LAST(cpuSystemTime) FROM ContainerCPUUsage\"\n+\n+[environment.container-memory-usage]\n+label = \"Container Memory Usage\"\n+form = \"SELECT LAST(memoryFailCount), LAST(memoryUsage), LAST(swapMemoryUsage) FROM ContainerMemoryUsage\"\n+\n+[environment.container-io-usage]\n+label = \"Container I\/O Usage\"\n+form = \"SELECT LAST(serviceRequests), LAST(dataTransferred) FROM ContainerIOUsage\"\n+\n+[environment.container-cpu-throttling]\n+label = \"Container CPU Throttling\"\n+form = \"SELECT LAST(cpuElapsedSlices), LAST(cpuThrottledSlices), LAST(cpuThrottledTime) FROM ContainerCPUThrottling\"\n+\n+[application.contention-by-thread]\n+label = \"Contention by Thread\"\n+table = \"COLUMN 'Thread', 'Count', 'Avg', 'P90', 'Max.'\n+         SELECT eventThread, COUNT(*), AVG(duration), P90(duration), MAX(duration) AS M\n+         FROM JavaMonitorEnter GROUP BY eventThread ORDER BY M\"\n+\n+[application.contention-by-class]\n+label = \"Contention by Lock Class\"\n+table = \"COLUMN 'Lock Class', 'Count', 'Avg.', 'P90', 'Max.'\n+         SELECT monitorClass, COUNT(*), AVG(duration), P90(duration), MAX(duration) AS M\n+         FROM JavaMonitorEnter GROUP BY monitorClass ORDER BY M\"\n+\n+[application.contention-by-site]\n+label = \"Contention by Site\"\n+table = \"COLUMN 'StackTrace', 'Count', 'Avg.', 'Max.'\n+         SELECT stackTrace AS S, COUNT(*), AVG(duration), MAX(duration) AS M\n+         FROM JavaMonitorEnter GROUP BY S ORDER BY M\"\n+\n+[application.contention-by-address]\n+label = \"Contention by Monitor Address\"\n+table = \"COLUMN 'Monitor Address', 'Class', 'Threads', 'Max Duration'\n+         SELECT address, FIRST(monitorClass), UNIQUE(*), MAX(duration) AS M\n+         FROM JavaMonitorEnter\n+         GROUP BY monitorClass ORDER BY M\"\n+\n+[environment.cpu-information]\n+label =\"CPU Information\"\n+form = \"SELECT cpu, sockets, cores, hwThreads, description FROM CPUInformation\"\n+\n+[environment.cpu-load]\n+label = \"CPU Load Statistics\"\n+form = \"COLUMN\n+        'JVM User (Minimum)',\n+        'JVM User (Average)',\n+        'JVM User (Maximum)',\n+        'JVM System (Minimum)',\n+        'JVM System (Average)',\n+        'JVM System (Maximum)',\n+        'Machine Total (Minimum)',\n+        'Machine Total (Average)',\n+        'Machine Total (Maximum)'\n+        SELECT MIN(jvmUser), AVG(jvmUser), MAX(jvmUser),\n+               MIN(jvmSystem), AVG(jvmSystem), MAX(jvmSystem),\n+               MIN(machineTotal), AVG(machineTotal), MAX(machineTotal)\n+               FROM CPULoad\"\n+\n+[environment.cpu-load-samples]\n+label = \"CPU Load\"\n+table = \"SELECT startTime, jvmUser, jvmSystem, machineTotal FROM CPULoad\"\n+\n+[environment.cpu-tsc]\n+label =\"CPU Time Stamp Counter\"\n+form = \"SELECT LAST(fastTimeAutoEnabled), LAST(fastTimeEnabled),\n+               LAST(fastTimeFrequency), LAST(osFrequency)\n+        FROM CPUTimeStampCounter\"\n+\n+[jvm.deoptimizations-by-reason]\n+label = \"Deoptimization by Reason\"\n+table = \"SELECT reason, COUNT(reason) AS C\n+         FROM Deoptimization GROUP BY reason ORDER BY C DESC\"\n+\n+[jvm.deoptimizations-by-site]\n+label = \"Deoptimization by Site\"\n+table = \"SELECT method, lineNumber, bci, COUNT(reason) AS C\n+         FROM Deoptimization GROUP BY method ORDER BY C DESC\"\n+\n+[environment.events-by-count]\n+label = \"Event Types by Count\"\n+table = \"SELECT eventType.label AS E, COUNT(*) AS C FROM * GROUP BY E ORDER BY C DESC\"\n+\n+[environment.events-by-name]\n+label = \"Event Types by Name\"\n+table = \"SELECT eventType.label AS E, COUNT(*) AS C FROM * GROUP BY E ORDER BY E ASC\"\n+\n+[environment.environment-variables]\n+label = \"Environment Variables\"\n+table = \"FORMAT none, cell-height:20\n+         SELECT LAST(key) AS K, LAST(value)\n+         FROM InitialEnvironmentVariable GROUP BY key ORDER BY K\"\n+\n+[application.exception-count]\n+label =\"Exception Statistics\"\n+form = \"COLUMN 'Exceptions Thrown' SELECT DIFF(throwables) FROM ExceptionStatistics\"\n+\n+[application.exception-by-type]\n+label =\"Exceptions by Type\"\n+table = \"COLUMN 'Class', 'Count'\n+         SELECT thrownClass AS T, COUNT(thrownClass) AS C\n+         FROM JavaErrorThrow, JavaExceptionThrow GROUP BY T ORDER BY C DESC\"\n+\n+[application.exception-by-message]\n+label =\"Exceptions by Message\"\n+table = \"COLUMN 'Message', 'Count'\n+         SELECT message AS M, COUNT(message) AS C\n+         FROM JavaErrorThrow, JavaExceptionThrow GROUP BY M ORDER BY C DESC\"\n+\n+[application.exception-by-site]\n+label =\"Exceptions by Site\"\n+table = \"COLUMN 'Method', 'Count'\n+         SELECT stackTrace.notInit AS S, COUNT(startTime) AS C\n+         FROM JavaErrorThrow, JavaExceptionThrow GROUP BY S ORDER BY C DESC\"\n+\n+[application.file-reads-by-path]\n+label = \"File Reads by Path\"\n+table = \"COLUMN 'Path', 'Reads', 'Total Read'\n+         FORMAT cell-height:5, none, none\n+         SELECT path, COUNT(*), SUM(bytesRead) AS S FROM FileRead\n+         GROUP BY path ORDER BY S DESC\"\n+\n+[application.file-writes-by-path]\n+label = \"File Writes by Path\"\n+table = \"COLUMN 'Path', 'Writes', 'Total Written'\n+         FORMAT cell-height:5, none, none\n+         SELECT path, COUNT(bytesWritten), SUM(bytesWritten) AS S FROM FileWrite\n+         GROUP BY path ORDER BY S DESC\"\n+\n+[application.finalizers]\n+label = \"Finalizers\"\n+table = \"SELECT finalizableClass, LAST_BATCH(objects) AS O, LAST_BATCH(totalFinalizersRun)\n+         FROM FinalizerStatistics GROUP BY finalizableClass ORDER BY O DESC\"\n+\n+[jvm.gc]\n+label = \"Garbage Collections\"\n+table = \"COLUMN 'Start', 'GC ID', 'Type', 'Heap Before GC', 'Heap After GC', 'Longest Pause'\n+         FORMAT none, none, missing:Unknown, none, none, none\n+         SELECT G.startTime, gcId, [Y|O].eventType.label,\n+                B.heapUsed, A.heapUsed, longestPause\n+         FROM\n+                GarbageCollection AS G,\n+                GCHeapSummary AS B,\n+                GCHeapSummary AS A,\n+                OldGarbageCollection AS O,\n+                YoungGarbageCollection AS Y\n+         WHERE B.when = 'Before GC' AND A.when = 'After GC'\n+         GROUP BY gcId ORDER BY G.startTime\"\n+\n+[jvm.gc-concurrent-phases]\n+label = \"Concurrent GC Phases\"\n+table = \"COLUMN 'Name', 'Average', 'P95',\n+                'Longest', 'Count', 'Total'\n+         SELECT name,  AVG(duration),  P95(duration),\n+                MAX(duration), COUNT(*), SUM(duration) AS S\n+         FROM   GCPhaseConcurrent, GCPhaseConcurrentLevel1\n+         GROUP BY name ORDER BY S\"\n+\n+[jvm.gc-configuration]\n+label = 'GC Configuration'\n+form = \"COLUMN 'Young GC', 'Old GC',\n+               'Parallel GC Threads','Concurrent GC Threads',\n+               'Dynamic GC Threads', 'Concurrent Explicit GC',\n+               'Disable Explicit GC', 'Pause Target',\n+               'GC Time Ratio'\n+        SELECT LAST(youngCollector), LAST(oldCollector),\n+               LAST(parallelGCThreads), LAST(concurrentGCThreads),\n+               LAST(usesDynamicGCThreads), LAST(isExplicitGCConcurrent),\n+               LAST(isExplicitGCDisabled), LAST(pauseTarget),\n+               LAST(gcTimeRatio)\n+        FROM   GCConfiguration\"\n+\n+[jvm.gc-references]\n+label = \"GC References\"\n+table = \"COLUMN 'Time', 'GC ID', 'Soft Ref.', 'Weak Ref.', 'Phantom Ref.', 'Final Ref.', 'Total Count'\n+         SELECT G.startTime, G.gcId, S.count, W.count, P.count, F.count, SUM(G.count)\n+         FROM GCReferenceStatistics AS S,\n+              GCReferenceStatistics AS W,\n+              GCReferenceStatistics AS P,\n+              GCReferenceStatistics AS F,\n+              GCReferenceStatistics AS G\n+         WHERE S.type = 'Soft reference' AND\n+               W.type = 'Weak reference' AND\n+               P.type = 'Phantom reference' AND\n+               F.type = 'Final reference'\n+         GROUP BY gcId ORDER By G.gcId ASC\"\n+\n+[jvm.gc-pause-phases]\n+label = \"GC Pause Phases\"\n+table = \"COLUMN 'Type', 'Name', 'Average',\n+                'P95', 'Longest', 'Count', 'Total'\n+         SELECT eventType.label AS T, name,  AVG(duration),\n+                P95(duration), MAX(duration), COUNT(*), SUM(duration) AS S\n+         FROM   GCPhasePause, GCPhasePauseLevel1, GCPhasePauseLevel2,\n+                GCPhasePauseLevel3, GCPhasePauseLevel4 GROUP BY name\n+         ORDER BY T ASC, S\"\n+\n+[jvm.gc-pauses]\n+label = \"GC Pauses\"\n+form = \"COLUMN 'Total Pause Time','Number of Pauses', 'Minimum Pause Time',\n+               'Median Pause Time', 'Average Pause Time', 'P90 Pause Time',\n+               'P95 Pause Time', 'P99 Pause Time', 'P99.9% Pause Time',\n+               'Maximum Pause Time'\n+        SELECT SUM(duration), COUNT(duration), MIN(duration),\n+               MEDIAN(duration), AVG(duration), P90(duration),\n+               P95(duration), P99(duration), P999(duration),\n+               MAX(duration)\n+        FROM GCPhasePause\"\n+\n+[jvm.gc-allocation-trigger]\n+label = \"GC Allocation Trigger\"\n+table = \"COLUMN 'Trigger Method (Non-JDK)', 'Count', 'Total Requested'\n+         SELECT stackTrace.topApplicationFrame AS S, COUNT(*), SUM(size)\n+         FROM AllocationRequiringGC GROUP BY S\"\n+\n+[jvm.gc-cpu-time]\n+label = \"GC CPU Time\"\n+form = \"COLUMN 'GC User Time', 'GC System Time',\n+               'GC Wall Clock Time', 'Total Time',\n+               'GC Count'\n+        SELECT SUM(userTime), SUM(systemTime),\n+               SUM(realTime), DIFF(startTime), COUNT(*)\n+        FROM GCCPUTime\"\n+\n+[jvm.heap-configuration]\n+label = \"Heap Configuration\"\n+form = \"SELECT LAST(initialSize), LAST(minSize), LAST(maxSize),\n+               LAST(usesCompressedOops), LAST(compressedOopsMode)\n+               FROM GCHeapConfiguration\"\n+\n+[application.hot-methods]\n+label = \"Java Methods that Executes the Most\"\n+table = \"COLUMN 'Method', 'Samples', 'Percent'\n+         FORMAT none, none, normalized\n+         SELECT stackTrace.topFrame AS T, COUNT(*), COUNT(*)\n+         FROM ExecutionSample GROUP BY T LIMIT 25\"\n+\n+[environment.jvm-flags]\n+label = \"Command Line Flags\"\n+table = \"SELECT name AS N, LAST(value)\n+         FROM IntFlag, UnsignedIntFlag, BooleanFlag,\n+         LongFlag, UnsignedLongFlag,\n+         DoubleFlag, StringFlag,\n+         IntFlagChanged, UnsignedIntFlagChanged, BooleanFlagChanged,\n+         LongFlagChanged, UnsignedLongFlagChanged,\n+         DoubleFlagChanged, StringFlagChanged\n+         GROUP BY name ORDER BY name ASC\"\n+\n+[jvm.jvm-information]\n+label = \"JVM Information\"\n+form = \"COLUMN\n+               'PID', 'VM Start', 'Name', 'Version',\n+               'VM Arguments', 'Program Arguments'\n+        SELECT LAST(pid), LAST(jvmStartTime), LAST(jvmName), LAST(jvmVersion),\n+               LAST(jvmArguments), LAST(javaArguments) FROM JVMInformation\"\n+\n+[application.latencies-by-type]\n+label = \"Latencies by Type\"\n+table = \"COLUMN 'Event Type', 'Count', 'Average', 'P 99', 'Longest', 'Total'\n+         SELECT eventType.label AS T, COUNT(*), AVG(duration),  P99(duration), MAX(duration), SUM(duration)\n+         FROM JavaMonitorWait, JavaMonitorEnter, ThreadPark, ThreadSleep,\n+         SocketRead, SocketWrite, FileWrite, FileRead GROUP BY T\"\n+\n+[application.memory-leaks-by-class]\n+label = \"Memory Leak Candidates by Class\"\n+table = \"COLUMN 'Alloc. Time', 'Object Class', 'Object Age', 'Heap Usage'\n+         SELECT LAST_BATCH(allocationTime), LAST_BATCH(object.type), LAST_BATCH(objectAge),\n+         LAST_BATCH(lastKnownHeapUsage) FROM OldObjectSample GROUP BY object.type ORDER BY allocationTime\"\n+\n+[application.memory-leaks-by-site]\n+label = \"Memory Leak Candidates by Site\"\n+table = \"COLUMN 'Alloc. Time', 'Application Method', 'Object Age', 'Heap Usage'\n+         SELECT LAST_BATCH(allocationTime), LAST_BATCH(stackTrace.topApplicationFrame), LAST_BATCH(objectAge),\n+         LAST_BATCH(lastKnownHeapUsage) FROM OldObjectSample GROUP BY stackTrace.topApplicationFrame ORDER BY allocationTime\"\n+\n+[application.modules]\n+label = \"Modules\"\n+table = \"SELECT LAST(source.name) AS S FROM ModuleRequire GROUP BY source.name ORDER BY S\"\n+\n+[application.monitor-inflation]\n+label = \"Monitor Inflation\"\n+table = \"SELECT stackTrace, monitorClass, COUNT(*), SUM(duration) AS S\n+         FROM jdk.JavaMonitorInflate GROUP BY stackTrace, monitorClass ORDER BY S\"\n+\n+[environment.native-libraries]\n+label = \"Native Libraries\"\n+table = \"FORMAT cell-height:2, none, none\n+         SELECT name AS N, baseAddress, topAddress FROM NativeLibrary GROUP BY name ORDER BY N\"\n+\n+[jvm.native-memory-committed]\n+label = \"Native Memory Committed\"\n+table = \"COLUMN 'Memory Type', 'First Observed', 'Average', 'Last Observed', 'Maximum'\n+         SELECT type, FIRST(committed), AVG(committed), LAST(committed), MAX(committed) AS M\n+         FROM NativeMemoryUsage GROUP BY type ORDER BY M DESC\"\n+\n+[jvm.native-memory-reserved]\n+label = \"Native Memory Reserved\"\n+table = \"COLUMN 'Memory Type', 'First Observed', 'Average', 'Last Observed', 'Maximum'\n+         SELECT type, FIRST(reserved), AVG(reserved), LAST(reserved), MAX(reserved) AS M\n+         FROM NativeMemoryUsage GROUP BY type ORDER BY M DESC\"\n+\n+[application.native-methods]\n+label = \"Waiting or Executing Native Methods\"\n+table = \"COLUMN 'Method', 'Samples', 'Percent'\n+         FORMAT none, none, normalized\n+         SELECT stackTrace.topFrame AS T, COUNT(*), COUNT(*)\n+         FROM NativeMethodSample GROUP BY T\"\n+\n+[environment.network-utilization]\n+label = \"Network Utilization\"\n+table = \"SELECT networkInterface, AVG(readRate), MAX(readRate), AVG(writeRate), MAX(writeRate)\n+         FROM NetworkUtilization GROUP BY networkInterface\"\n+\n+[application.object-statistics]\n+label = \"Objects Occupying More than 1%\"\n+table = \"COLUMN 'Class', 'Count', 'Heap Space', 'Increase'\n+         SELECT\n+          LAST_BATCH(objectClass), LAST_BATCH(count),\n+          LAST_BATCH(totalSize), DIFF(totalSize)\n+         FROM ObjectCountAfterGC, ObjectCount\n+         GROUP BY objectClass\n+         ORDER BY totalSize DESC\"\n+\n+[application.pinned-threads]\n+label = \"Pinned Virtual Threads\"\n+table = \"COLUMN 'Method', 'Pinned Count',  'Longest Pinning', 'Total Time Pinned'\n+         SELECT stackTrace.topApplicationFrame AS S, COUNT(*),\n+                MAX(duration), SUM(duration) AS T FROM VirtualThreadPinned\n+         GROUP BY S\n+         ORDER BY T DESC\"\n+\n+[application.thread-count]\n+label =\"Java Thread Statistics\"\n+table = \"SELECT * FROM JavaThreadStatistics\"\n+\n+[environment.recording]\n+label = \"Recording Information\"\n+form = \"COLUMN 'Event Count', 'First Recorded Event', 'Last Recorded Event',\n+                 'Length of Recorded Events', 'Dump Reason'\n+        SELECT   COUNT(startTime), FIRST(startTime), LAST(startTime),\n+                 DIFF(startTime), LAST(jdk.Shutdown.reason)\n+        FROM *\"\n+\n+[jvm.safepoints]\n+label = \"Safepoints\"\n+table = \"COLUMN  'Start Time', 'Duration',\n+                   'State Syncronization', 'Cleanup',\n+                   'JNI Critical Threads', 'Total Threads'\n+         SELECT    B.startTime,  DIFF([B|E].startTime),\n+                   S.duration, C.duration,\n+                   jniCriticalThreadCount, totalThreadCount\n+         FROM SafepointBegin AS B, SafepointEnd AS E,\n+              SafepointCleanup AS C, SafepointStateSynchronization AS S\n+         GROUP BY safepointId ORDER BY B.startTime\"\n+\n+[jvm.longest-compilations]\n+label = \"Longest Compilations\"\n+table = \"SELECT startTime, duration AS D, method, compileLevel, succeded\n+         FROM Compilation ORDER BY D LIMIT 25\"\n+\n+[application.longest-class-loading]\n+label = \"Longest Class Loading\"\n+table = \"COLUMN 'Time', 'Loaded Class', 'Load Time'\n+         SELECT startTime,loadedClass, duration AS D\n+         FROM ClassLoad ORDER BY D DESC LIMIT 25\"\n+\n+[environment.system-properties]\n+label = \"System Properties at Startup\"\n+table = \"FORMAT none, cell-height:25\n+        SELECT key AS K, value FROM InitialSystemProperty GROUP BY key ORDER by K\"\n+\n+[application.socket-writes-by-host]\n+label = \"Socket Writes by Host\"\n+table = \"COLUMN 'Host', 'Writes', 'Total Written'\n+         FORMAT cell-height:2, none, none\n+         SELECT host, COUNT(*), SUM(bytesWritten) AS S FROM SocketWrite\n+         GROUP BY host ORDER BY S DESC\"\n+\n+[application.socket-reads-by-host]\n+label = \"Socket Reads by Host\"\n+table = \"COLUMN 'Host', 'Reads', 'Total Read'\n+         FORMAT cell-height:2, none, none\n+         SELECT host, COUNT(*), SUM(bytesRead) AS S FROM SocketRead\n+         GROUP BY host ORDER BY S DESC\"\n+\n+[environment.system-information]\n+label = \"System Information\"\n+form = \"COLUMN 'Total Physical Memory Size', 'OS Version', 'CPU Type',\n+                 'Number of Cores', 'Number of Hardware Threads',\n+                 'Number of Sockets', 'CPU Description'\n+        SELECT LAST(totalSize), LAST(osVersion), LAST(cpu),\n+               LAST(cores), LAST(hwThreads),\n+               LAST(sockets), LAST(description)\n+        FROM CPUInformation, PhysicalMemory, OSInformation\"\n+\n+[environment.system-processes]\n+label = \"System Processes\"\n+table = \"COLUMN 'First Observed', 'Last Observed', 'PID', 'Command Line'\n+         SELECT FIRST(startTime), LAST(startTime),\n+                FIRST(pid), FIRST(commandLine)\n+         FROM SystemProcess GROUP BY pid\"\n+\n+[jvm.tlabs]\n+label = \"Thread Local Allocation Buffers\"\n+form = \"COLUMN 'Inside TLAB Count', 'Inside TLAB Minimum Size', 'Inside TLAB Average Size',\n+               'Inside TLAB Maximum Size', 'Inside TLAB Total Allocation',\n+               'Outside TLAB Count',  'OutSide TLAB Minimum Size', 'Outside TLAB Average Size',\n+               'Outside TLAB Maximum Size', 'Outside TLAB Total Allocation'\n+        SELECT  COUNT(I.tlabSize), MIN(I.tlabSize), AVG(I.tlabSize),\n+                MAX(I.tlabSize), SUM(I.tlabSize),\n+                COUNT(O.allocationSize), MIN(O.allocationSize), AVG(O.allocationSize),\n+                MAX(O.allocationSize), SUM(O.allocationSize)\n+        FROM ObjectAllocationInNewTLAB AS I, ObjectAllocationOutsideTLAB AS O\"\n+\n+[application.thread-allocation]\n+label = \"Thread Allocation Statistics\"\n+table = \"COLUMN 'Thread', 'Allocated', 'Percentage'\n+         FORMAT none, none, normalized\n+         SELECT thread, LAST(allocated), LAST(allocated) AS A FROM ThreadAllocationStatistics\n+         GROUP BY thread ORDER BY A DESC\"\n+\n+[application.thread-cpu-load]\n+label = \"Thread CPU Load\"\n+table = \"COLUMN 'Thread', 'System', 'User'\n+         SELECT eventThread AS E, LAST(system), LAST(user) AS U\n+         FROM ThreadCPULoad GROUP BY E ORDER BY U DESC\"\n+\n+[application.thread-start]\n+label = \"Platform Thread Start by Method\"\n+table = \"COLUMN 'Start Time','Stack Trace', 'Thread', 'Duration'\n+         SELECT S.startTime, S.stackTrace, eventThread, DIFF(startTime) AS D\n+         FROM ThreadStart AS S, ThreadEnd AS E GROUP\n+         by eventThread ORDER BY D DESC\"\n+\n+[jvm.vm-operations]\n+label = \"VM Operations\"\n+table = \"COLUMN 'VM Operation', 'Average Duration', 'Longest Duration', 'Count' , 'Total Duration'\n+         SELECT operation,  AVG(duration), MAX(duration), COUNT(*), SUM(duration)\n+         FROM jdk.ExecuteVMOperation GROUP BY operation\"\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/view.ini","additions":576,"deletions":0,"binary":false,"changes":576,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,3 @@\n+import jdk.jfr.internal.util.UserDataException;\n+import jdk.jfr.internal.util.UserSyntaxException;\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Assemble.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,3 @@\n+import jdk.jfr.internal.util.UserDataException;\n+import jdk.jfr.internal.util.UserSyntaxException;\n+\n@@ -51,0 +54,3 @@\n+        \/\/ Uncomment when developing new queries for the view command\n+        \/\/ commands.add(new Query());\n+        commands.add(new View());\n@@ -173,0 +179,12 @@\n+    protected int acceptInt(Deque<String> options, String text) throws UserSyntaxException {\n+        if (options.size() < 1) {\n+            throw new UserSyntaxException(\"missing integer value\");\n+        }\n+        String t = options.remove();\n+        try {\n+            return Integer.parseInt(t);\n+        } catch (NumberFormatException nfe) {\n+            throw new UserSyntaxException(\"could not parse integer value \" + t);\n+        }\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Command.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,2 @@\n+import jdk.jfr.internal.util.UserDataException;\n+import jdk.jfr.internal.util.UserSyntaxException;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Configure.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,2 @@\n+import jdk.jfr.internal.util.UserDataException;\n+import jdk.jfr.internal.util.UserSyntaxException;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Disassemble.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import jdk.jfr.internal.util.UserSyntaxException;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Filters.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,3 @@\n+import jdk.jfr.internal.util.UserDataException;\n+import jdk.jfr.internal.util.UserSyntaxException;\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Help.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,3 @@\n+import jdk.jfr.internal.util.UserDataException;\n+import jdk.jfr.internal.util.UserSyntaxException;\n+\n@@ -52,1 +55,1 @@\n-            System.out.println(\"A recording can also be started on already running Java Virtual Machine:\");\n+            System.out.println(\"A recording can also be started on an already running Java Virtual Machine:\");\n@@ -74,1 +77,1 @@\n-            System.out.println(\" jfr summary recording.jfr\");\n+            System.out.println(\" jfr view gc recording.jfr\");\n@@ -76,1 +79,3 @@\n-            System.out.println(\" jfr metadata recording.jfr\");\n+            System.out.println(\" jfr view allocation-by-site recording.jfr\");\n+            System.out.println();\n+            System.out.println(\" jfr summary recording.jfr\");\n@@ -78,1 +83,1 @@\n-            System.out.println(\" jfr metadata --categories GC,Detailed\");\n+            System.out.println(\" jfr metadata\");\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Main.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,2 @@\n+import jdk.jfr.internal.util.UserDataException;\n+import jdk.jfr.internal.util.UserSyntaxException;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Metadata.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,2 @@\n+import jdk.jfr.internal.util.UserDataException;\n+import jdk.jfr.internal.util.UserSyntaxException;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Print.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.tool;\n+\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.List;\n+\n+import jdk.jfr.consumer.EventStream;\n+import jdk.jfr.internal.util.UserDataException;\n+import jdk.jfr.internal.util.Output.BufferedPrinter;\n+import jdk.jfr.internal.util.UserSyntaxException;\n+import jdk.jfr.internal.query.QueryPrinter;\n+import jdk.jfr.internal.query.Configuration.Truncate;\n+import jdk.jfr.internal.query.Configuration;\n+\n+final class Query extends Command {\n+    @Override\n+    public String getName() {\n+        return \"query\";\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return \"Display event values in a recording file (.jfr) in a tabular format\";\n+    }\n+\n+    @Override\n+    public void displayOptionUsage(PrintStream p) {\n+                \/\/ 0123456789001234567890012345678900123456789001234567890012345678900123456789001234567890\n+        p.println(\"  --verbose               Displays the symbolic column names\");\n+        p.println();\n+        p.println(\"  --width <integer>       The width of the table. Default value depends on the query\");\n+        p.println();\n+        p.println(\"  <query>                 Query, for example \\\"SELECT * FROM GarbageCollection\\\"\");\n+        p.println(\"                          See below for grammar.\");\n+        p.println();\n+        p.println(\"  <file>                  Location of the recording file (.jfr)\");\n+        p.println();\n+        p.println(QueryPrinter.getGrammarText());\n+        p.println();\n+        p.println(\"Example usage:\");\n+        p.println();\n+        p.println(\" $ jfr query \\\"SHOW EVENTS\\\" recording.jfr\");\n+        p.println();\n+        p.println(\" $ jfr query \\\"SHOW FIELDS ObjectAllocationSample\\\" recording.jfr\");\n+        p.println();\n+        p.println(\" $ jfr query --verbose \\\"SELECT * FROM ObjectAllocationSample\\\" recording.jfr\");\n+        p.println();\n+        p.println(\" $ jfr query --width 160 \\\"SELECT pid, path FROM SystemProcess\\\" recording.jfr\");\n+        p.println();\n+        p.println(\" $ jfr query \\\"SELECT stackTrace.topFrame AS T, SUM(weight)\");\n+        p.println(\"              FROM ObjectAllocationSample GROUP BY T\\\" recording.jfr\");\n+        p.println();\n+        p.println(\"$ jfr JFR.query \\\"COLUMN 'Method', 'Percentage'\");\n+        p.println(\"                 FORMAT default, normalized;width:10\");\n+        p.println(\"                 SELECT stackTrace.topFrame AS T, COUNT(*) AS C\");\n+        p.println(\"                 GROUP BY T\");\n+        p.println(\"                 FROM ExecutionSample ORDER BY C DESC\\\" recording.jfr\");\n+        p.println();\n+        p.println(\"$ jcmd <pid> JFR.query \\\"COLUMN 'Start', 'GC ID', 'Heap Before GC',\");\n+        p.println(\"                        'Heap After GC', 'Longest Pause'\");\n+        p.println(\"                        SELECT G.startTime, G.gcId, B.heapUsed,\");\n+        p.println(\"                             A.heapUsed, longestPause\");\n+        p.println(\"                        FROM GarbageCollection AS G,\");\n+        p.println(\"                             GCHeapSummary AS B,\");\n+        p.println(\"                             GCHeapSummary AS A\");\n+        p.println(\"                        WHERE B.when = 'Before GC' AND A.when = 'After GC'\");\n+        p.println(\"                        GROUP BY gcId\");\n+        p.println(\"                        ORDER BY G.startTime\\\" recording.jfr\");\n+   }\n+\n+    @Override\n+    public List<String> getOptionSyntax() {\n+        List<String> list = new ArrayList<>();\n+        list.add(\"[--verbose] [--width <integer>] <query> <file>\");\n+        return list;\n+    }\n+\n+    @Override\n+    public void execute(Deque<String> options) throws UserSyntaxException, UserDataException {\n+        Path file = getJFRInputFile(options);\n+        int optionCount = options.size();\n+        var configuration = new Configuration();\n+        BufferedPrinter printer = new BufferedPrinter(System.out);\n+        configuration.output = printer;\n+        while (optionCount > 0) {\n+            if (acceptSwitch(options, \"--verbose\")) {\n+                configuration.verbose = true;\n+                configuration.verboseHeaders = true;\n+            }\n+            if (acceptOption(options, \"--truncate\")) {\n+                String mode = options.remove();\n+                try {\n+                    configuration.truncate = Truncate.valueOf(mode.toUpperCase());\n+                } catch (IllegalArgumentException iae) {\n+                    throw new UserSyntaxException(\"truncate must be 'beginning' or 'end'\");\n+                }\n+            }\n+            if (acceptOption(options, \"--cell-height\")) {\n+                configuration.cellHeight = acceptInt(options, \"cell-height\");\n+            }\n+            if (acceptOption(options, \"--width\")) {\n+                configuration.width = acceptInt(options, \"width\");\n+            }\n+            if (optionCount == 1) {\n+                String query = options.pop();\n+                try (EventStream stream = EventStream.openFile(file)) {\n+                    QueryPrinter qp = new QueryPrinter(configuration, stream);\n+                    qp.execute(query);\n+                    printer.flush();\n+                } catch (IOException ioe) {\n+                    couldNotReadError(file, ioe);\n+                }\n+                return;\n+            }\n+            if (optionCount == options.size()) {\n+                throw new UserSyntaxException(\"unknown option \" + options.peek());\n+            }\n+            optionCount = options.size();\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Query.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,2 @@\n+import jdk.jfr.internal.util.UserDataException;\n+import jdk.jfr.internal.util.UserSyntaxException;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Scrub.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,2 @@\n+import jdk.jfr.internal.util.UserDataException;\n+import jdk.jfr.internal.util.UserSyntaxException;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Summary.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.tool;\n+\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.List;\n+\n+import jdk.jfr.consumer.EventStream;\n+import jdk.jfr.internal.util.Columnizer;\n+import jdk.jfr.internal.query.ViewPrinter;\n+import jdk.jfr.internal.query.Configuration;\n+import jdk.jfr.internal.query.Configuration.Truncate;\n+import jdk.jfr.internal.util.UserDataException;\n+import jdk.jfr.internal.util.UserSyntaxException;\n+import jdk.jfr.internal.util.Output.BufferedPrinter;\n+\n+public final class View extends Command {\n+    @Override\n+    public String getName() {\n+        return \"view\";\n+    }\n+\n+    @Override\n+    protected String getTitle() {\n+        return \"Display event values in a recording file (.jfr) in predefined views\";\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return \"Display events in a tabular format. See 'jfr help view' for details.\";\n+    }\n+\n+    @Override\n+    public void displayOptionUsage(PrintStream stream) {\n+        stream.println(\"  --verbose               Displays the query that makes up the view\");\n+        stream.println(\"\");\n+        stream.println(\"  --width <integer>       The width of the view in characters. Default value depends on the view\");\n+        stream.println(\"\");\n+        stream.println(\"  --truncate <mode>       How to truncate content that exceeds space in a table cell.\");\n+        stream.println(\"                          Mode can be 'beginning' or 'end'. Default value is 'end'\");\n+        stream.println(\"\");\n+        stream.println(\"  --cell-height <integer> Maximum number of rows in a table cell. Default value depends on the view\");\n+        stream.println(\"\");\n+        stream.println(\"  <view>                  Name of the view or event type to display. See list below for\");\n+        stream.println(\"                          available views\");\n+        stream.println(\"\");\n+        stream.println(\"  <file>                  Location of the recording file (.jfr)\");\n+        stream.println();\n+        for (String line : ViewPrinter.getAvailableViews()) {\n+            stream.println(line);\n+        }\n+        stream.println(\" The <view> parameter can be an event type name. Use the 'jfr view types <file>'\");\n+        stream.println(\" to see a list. To display all views, use 'jfr view all-views <file>'. To display\");\n+        stream.println(\" all events, use 'jfr view all-events <file>'.\");\n+        stream.println();\n+        stream.println(\"Example usage:\");\n+        stream.println();\n+        stream.println(\" jfr view gc recording.jfr\");\n+        stream.println();\n+        stream.println(\" jfr view --width 160 hot-methods recording.jfr\");\n+        stream.println();\n+        stream.println(\" jfr view --verbose allocation-by-class recording.jfr\");\n+        stream.println();\n+        stream.println(\" jfr view contention-by-site recording.jfr\");\n+        stream.println();\n+        stream.println(\" jfr view jdk.GarbageCollection recording.jfr\");\n+        stream.println();\n+        stream.println(\" jfr view --cell-height 10 ThreadStart recording.jfr\");\n+        stream.println();\n+        stream.println(\" jfr view --truncate beginning SystemProcess recording.jfr\");\n+        stream.println();\n+    }\n+\n+    @Override\n+    public List<String> getOptionSyntax() {\n+        List<String> list = new ArrayList<>();\n+        list.add(\"[--verbose]\");\n+        list.add(\"[--width <integer>\");\n+        list.add(\"[--truncate <mode>]\");\n+        list.add(\"[--cell-height <integer>]\");\n+        list.add(\"<view>\");\n+        list.add(\"<file>\");\n+        return list;\n+    }\n+\n+    @Override\n+    public void execute(Deque<String> options) throws UserSyntaxException, UserDataException {\n+        Path file = getJFRInputFile(options);\n+        int optionCount = options.size();\n+        if (optionCount < 1) {\n+            throw new UserSyntaxException(\"must specify a view or event type\");\n+        }\n+        Configuration configuration = new Configuration();\n+        BufferedPrinter printer = new BufferedPrinter(System.out);\n+        configuration.output = printer;\n+        while (true) {\n+            if (acceptSwitch(options, \"--verbose\")) {\n+                configuration.verbose = true;\n+            }\n+            if (acceptOption(options, \"--truncate\")) {\n+                String mode = options.remove();\n+                try {\n+                    configuration.truncate = Truncate.valueOf(mode.toUpperCase());\n+                } catch (IllegalArgumentException iae) {\n+                    throw new UserSyntaxException(\"truncate must be 'beginning' or 'end'\");\n+                }\n+            }\n+            if (acceptOption(options, \"--cell-height\")) {\n+                configuration.cellHeight = acceptInt(options, \"cell-height\");\n+            }\n+            if (acceptOption(options, \"--width\")) {\n+                configuration.width = acceptInt(options, \"width\");\n+            }\n+            if (options.size() == 1) {\n+                String view = options.pop();\n+                try (EventStream stream = EventStream.openFile(file)) {\n+                    ViewPrinter vp = new ViewPrinter(configuration, stream);\n+                    vp.execute(view);\n+                    printer.flush();\n+                    return;\n+                } catch (IOException ioe) {\n+                    couldNotReadError(file, ioe);\n+                }\n+            }\n+            System.out.println(\"count:\" + optionCount);\n+            System.out.println(\"size:\" + options.size());\n+            if (optionCount == options.size()) {\n+                String peek = options.peek();\n+                if (peek == null) {\n+                    throw new UserSyntaxException(\"must specify option <view>\");\n+                }\n+                throw new UserSyntaxException(\"unknown option \" + peek);\n+            }\n+            optionCount = options.size();\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/View.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+\/**\n+ * Class that creates a column-sorted list.\n+ * <p>\n+ * For example, the list: \"Bison\", \"Dog\", \"Frog\", Goldfish\", \"Kangaroo\", \"Ant\",\n+ * \"Jaguar\", \"Cat\", \"Elephant\", \"Ibex\" becomes:\n+ * <pre>\n+ *  Ant   Elephant Jaguar\n+ *  Bison Frog     Kangaroo\n+ *  Cat   Goldfish\n+ *  Dog   Ibex\"\n+ * <\/pre>\n+ *\/\n+public final class Columnizer {\n+    private static final class Column {\n+        int maxWidth;\n+        List<String> entries = new ArrayList<>();\n+        public void add(String text) {\n+            entries.add(text);\n+            maxWidth = Math.max(maxWidth, text.length());\n+        }\n+    }\n+    private final List<Column> columns = new ArrayList<>();\n+\n+    public Columnizer(List<String> texts, int columnCount) {\n+        List<String> list = new ArrayList<>(texts);\n+        Collections.sort(list);\n+        int columnHeight = (list.size() + columnCount - 1) \/ columnCount;\n+        int index = 0;\n+        Column column = null;\n+        for (String text : list) {\n+            if (index % columnHeight == 0) {\n+                column = new Column();\n+                columns.add(column);\n+            }\n+            column.add(text);\n+            index++;\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        int index = 0;\n+        while (true) {\n+            for (Column column : columns) {\n+                if (index == column.entries.size()) {\n+                    return sb.toString();\n+                }\n+                if (index != 0 && columns.getFirst() == column) {\n+                    sb.append(System.lineSeparator());\n+                }\n+                String text = column.entries.get(index);\n+                sb.append(\" \");\n+                sb.append(text);\n+                sb.append(\" \".repeat(column.maxWidth - text.length()));\n+            }\n+            index++;\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Columnizer.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.util;\n+\n+public final class Matcher {\n+\n+    \/**\n+     * Returns true if text matches pattern of characters, '*' and '?'\n+     *\/\n+    public static boolean match(String text, String pattern) {\n+        if (pattern.length() == 0) {\n+            \/\/ empty filter string matches if string is empty\n+            return text.length() == 0;\n+        }\n+        if (pattern.charAt(0) == '*') { \/\/ recursive check\n+            pattern = pattern.substring(1);\n+            for (int n = 0; n <= text.length(); n++) {\n+                if (match(text.substring(n), pattern))\n+                    return true;\n+            }\n+        } else if (text.length() == 0) {\n+            \/\/ empty string and non-empty filter does not match\n+            return false;\n+        } else if (pattern.charAt(0) == '?') {\n+            \/\/ eat any char and move on\n+            return match(text.substring(1), pattern.substring(1));\n+        } else if (pattern.charAt(0) == text.charAt(0)) {\n+            \/\/ eat chars and move on\n+            return match(text.substring(1), pattern.substring(1));\n+        }\n+        return false;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Matcher.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.util;\n+\n+import java.io.PrintStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public interface Output {\n+\n+    public void println();\n+\n+    public void print(String s);\n+\n+    public void print(String s, Object... args);\n+\n+    default public void println(String s, Object... args) {\n+        print(s, args);\n+        println();\n+    }\n+\n+    public void print(char c);\n+\n+    public static final class LinePrinter implements Output {\n+        private final StringBuilder currentLine = new StringBuilder(80);\n+        private final List<String> lines = new ArrayList<>();\n+\n+        @Override\n+        public void println() {\n+            lines.add(currentLine.toString());\n+            currentLine.setLength(0);\n+        }\n+\n+        @Override\n+        public void print(String s) {\n+            currentLine.append(s);\n+        }\n+\n+        @Override\n+        public void print(String s, Object... args) {\n+            currentLine.append(args.length > 0 ? String.format(s, args) : s);\n+        }\n+\n+        @Override\n+        public void print(char c) {\n+            currentLine.append(c);\n+        }\n+\n+        public List<String> getLines() {\n+            return lines;\n+        }\n+    }\n+\n+    public static final class BufferedPrinter implements Output {\n+        private final StringBuilder buffer = new StringBuilder(100_000);\n+        private final PrintStream out;\n+\n+        public BufferedPrinter(PrintStream out) {\n+            this.out = out;\n+        }\n+\n+        @Override\n+        public void println() {\n+            buffer.append(System.lineSeparator());\n+            flushCheck();\n+        }\n+\n+        @Override\n+        public void print(String s) {\n+            buffer.append(s);\n+            flushCheck();\n+        }\n+\n+        @Override\n+        public void print(String s, Object... args) {\n+            if (args.length > 0) {\n+                buffer.append(String.format(s, args));\n+            } else {\n+                buffer.append(s);\n+            }\n+            flushCheck();\n+        }\n+\n+        @Override\n+        public void print(char c) {\n+            buffer.append(c);\n+            flush();\n+        }\n+\n+        public void flush() {\n+            out.print(buffer.toString());\n+            buffer.setLength(0);\n+        }\n+\n+        private void flushCheck() {\n+            if (buffer.length() > 99_000) {\n+                flush();\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Output.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.util;\n+\n+import java.util.List;\n+\n+public final class SpellChecker {\n+    public static String check(String name, List<String> alternatives) {\n+        for (String expected : alternatives) {\n+            String s = name.toLowerCase();\n+            int lengthDifference = expected.length() - s.length();\n+            boolean spellingError = false;\n+            if (lengthDifference == 0) {\n+                if (expected.equals(s)) {\n+                    spellingError = true; \/\/ incorrect case, or we wouldn't be here\n+                } else {\n+                    if (s.length() < 6) {\n+                        spellingError = diff(expected, s) < 2; \/\/ one incorrect letter\n+                    } else {\n+                        spellingError = diff(expected, s) < 3; \/\/ two incorrect letter\n+                    }\n+                }\n+            }\n+            if (lengthDifference == 1) {\n+                spellingError = inSequence(expected, s); \/\/ missing letter\n+            }\n+            if (lengthDifference == -1) {\n+                spellingError = inSequence(s, expected); \/\/ additional letter\n+            }\n+            if (spellingError) {\n+                return expected;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static int diff(String a, String b) {\n+        int count = a.length();\n+        for (int i = 0; i < a.length(); i++) {\n+            if (a.charAt(i) == b.charAt(i)) {\n+                count--;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    private static boolean inSequence(String longer, String shorter) {\n+        int l = 0;\n+        int s = 0;\n+        while (l < longer.length() && s < shorter.length()) {\n+            if (longer.charAt(l) == shorter.charAt(s)) {\n+                s++;\n+            }\n+            l++;\n+        }\n+        return shorter.length() == s; \/\/ if 0, all letters in longer found in shorter\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/SpellChecker.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.util;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+\n+public final class StopWatch {\n+    private record Timing(String name, Instant start) {\n+    }\n+\n+    private final List<Timing> timings = new ArrayList<>();\n+\n+    public void beginQueryValidation() {\n+        beginTask(\"query-validation\");\n+    }\n+\n+    public void beginAggregation() {\n+        beginTask(\"aggregation\");\n+    }\n+\n+    public void beginFormatting() {\n+        beginTask(\"formatting\");\n+    }\n+\n+    public void beginTask(String name) {\n+        timings.add(new Timing(name, Instant.now()));\n+    }\n+\n+    public void finish() {\n+        beginTask(\"end\");\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringJoiner sb = new StringJoiner(\", \");\n+        for (int i = 0; i < timings.size() - 1; i++) {\n+            Timing current = timings.get(i);\n+            Timing next = timings.get(i + 1);\n+            Duration d = Duration.between(current.start(), next.start());\n+            sb.add(current.name() + \"=\" + ValueFormatter.formatDuration(d));\n+        }\n+        return sb.toString();\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/StopWatch.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.util;\n+\n+import java.text.ParseException;\n+\n+public final class Tokenizer implements AutoCloseable {\n+    private final String text;\n+    private final char[] separators;\n+    private int index;\n+\n+    \/**\n+     * Constructs a Tokenizer.\n+     *\n+     * @param text       text to tokenize\n+     * @param separators separator, for example ',' or ';'\n+     *\/\n+    public Tokenizer(String text, char... separators) {\n+        this.text = text;\n+        this.separators = separators;\n+    }\n+\n+    \/**\n+     * If the next token matches a string, it is consumed and {@code true} returned,\n+     * {@code false} otherwise.\n+     *\/\n+    public boolean accept(String match) {\n+        skipWhitespace();\n+        int t = 0;\n+        while (index + t < text.length() && t < match.length()) {\n+            char c = Character.toLowerCase(text.charAt(index + t));\n+            char d = Character.toLowerCase(match.charAt(t));\n+            if (d != c) {\n+                return false;\n+            }\n+            t++;\n+            if (isSeparator(c)) {\n+                break;\n+            }\n+        }\n+        if (t == match.length()) {\n+            index += match.length();\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Similar to accept(String), but requires several tokens to match.\n+     *\/\n+    public boolean accept(String... matches) {\n+        int position = index;\n+        for (String s : matches) {\n+            if (!accept(s)) {\n+                index = position;\n+                return false;\n+\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Similar to accept(String...), but sufficient if one token matches.\n+     *\n+     * @param matches\n+     * @return\n+     *\/\n+    public boolean acceptAny(String... matches) {\n+        for (String match : matches) {\n+            if (accept(match)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Return {@code true} if there are more tokens.\n+     *\/\n+    public boolean hasNext() {\n+        int k = index;\n+        while (k < text.length()) {\n+            char c = text.charAt(k);\n+            if (!Character.isWhitespace(c)) {\n+                return true;\n+            }\n+            k++;\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Throws exception if the next token doesn't match.\n+     *\/\n+    public void expect(String expected) throws ParseException {\n+        if (!accept(expected)) {\n+            throw new ParseException(\"Expected \" + expected, index);\n+        }\n+    }\n+\n+    \/**\n+     * Return the next character without consuming it, or throw exception if\n+     * {@code EOF} is reached.\n+     *\/\n+    public char peekChar() throws ParseException {\n+        skipWhitespace();\n+        if (index < text.length()) {\n+            return text.charAt(index);\n+        }\n+        throw new ParseException(\"Unexpected EOF reached\", index);\n+    }\n+\n+    \/**\n+     * Return the next token, or throw exception if {@code EOF} is reached.\n+     *\/\n+    public String next() throws ParseException {\n+        skipWhitespace();\n+        StringBuilder sb = new StringBuilder();\n+        while (index < text.length()) {\n+            char c = text.charAt(index);\n+            if (isQuoteCharacter(c)) {\n+                int p = findNext(c);\n+                String t = text.substring(index + 1, p);\n+                sb.append(t);\n+                index = p;\n+            } else {\n+                if (isSeparator(c)) {\n+                    if (sb.isEmpty()) {\n+                        index++;\n+                        return String.valueOf(c); \/\/ Inte helt optimalt\n+                    } else {\n+                        return sb.toString();\n+                    }\n+                }\n+                if (Character.isWhitespace(c)) {\n+                    return sb.toString();\n+                }\n+                sb.append(c);\n+            }\n+            index++;\n+        }\n+        if (sb.isEmpty()) {\n+            throw new ParseException(\"Unexpected EOF reached\", index);\n+        }\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Skips all character until {@code '\\n'}\n+     *\/\n+    public void skipLine() {\n+        while (index < text.length()) {\n+            char c = text.charAt(index++);\n+            if (c == '\\n') {\n+                return;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns the current position in the text.\n+     *\/\n+    public int getPosition() {\n+        return index;\n+    }\n+\n+    private void skipWhitespace() {\n+        while (index < text.length()) {\n+            char c = text.charAt(index);\n+            if (!Character.isWhitespace(c)) {\n+                return;\n+            }\n+            index++;\n+        }\n+    }\n+\n+    private boolean isSeparator(char c) {\n+        for (char separator : separators) {\n+            if (c == separator) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private int findNext(char c) throws ParseException {\n+        for (int p = index + 1; p < text.length(); p++) {\n+            if (c == text.charAt(p)) {\n+                return p;\n+            }\n+        }\n+        throw new ParseException(\"Could not find match \" + c, index);\n+    }\n+\n+    private boolean isQuoteCharacter(char c) {\n+        return c == '\\'' || c == '\"';\n+    }\n+\n+    \/**\n+     * Closes the Tokenizer.\n+     * <p>\n+     * Requires that all the tokens have been consumed.\n+     *\n+     * @throws ParseException if there are tokens left\n+     *\/\n+    @Override\n+    public void close() throws ParseException {\n+        skipWhitespace();\n+        if (index != text.length()) {\n+            throw new ParseException(\"Unexpected token '\" + next() + \"' found\", getPosition());\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Tokenizer.java","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.util;\n+\n+\/**\n+ * Exception that is thrown if there is something wrong with the input, for instance\n+ * a file that can't be read or a numerical value that is out of range.\n+ * <p>\n+ * When this exception is thrown, a user will typically not want to see the\n+ * command line syntax, but instead information about what was wrong with the\n+ * input.\n+ *\/\n+public final class UserDataException extends Exception {\n+    private static final long serialVersionUID = 6656457380115167810L;\n+    \/**\n+     * The error message.\n+     *\n+     * The first letter should not be capitalized, so a context can be printed prior\n+     * to the error message.\n+     *\n+     * @param errorMessage\n+     *\/\n+    public UserDataException(String errorMessage) {\n+        super(errorMessage);\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/UserDataException.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.util;\n+\n+\/**\n+ * Exception that is thrown if options don't follow the syntax of the command.\n+ *\/\n+public final class UserSyntaxException extends Exception {\n+    private static final long serialVersionUID = 3437009454344160933L;\n+\n+    \/**\n+     * The error message.\n+     *\n+     * The first letter should not be capitalized, so a context can be printed prior\n+     * to the error message.\n+     *\n+     * @param errorMessage message\n+     *\/\n+    public UserSyntaxException(String errorMessage) {\n+        super(errorMessage);\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/UserSyntaxException.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,275 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.util;\n+\n+import java.text.NumberFormat;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedMethod;\n+\n+public final class ValueFormatter {\n+    private static final NumberFormat NUMBER_FORMAT = NumberFormat.getNumberInstance();\n+    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n+    private static final Duration MICRO_SECOND = Duration.ofNanos(1_000);\n+    private static final Duration SECOND = Duration.ofSeconds(1);\n+    private static final Duration MINUTE = Duration.ofMinutes(1);\n+    private static final Duration HOUR = Duration.ofHours(1);\n+    private static final Duration DAY = Duration.ofDays(1);\n+    private static final int NANO_SIGNIFICANT_FIGURES = 9;\n+    private static final int MILL_SIGNIFICANT_FIGURES = 3;\n+    private static final int DISPLAY_NANO_DIGIT = 3;\n+    private static final int BASE = 10;\n+\n+    public static String formatNumber(Number n) {\n+        return NUMBER_FORMAT.format(n);\n+    }\n+\n+    public static String formatDuration(Duration d) {\n+        Duration roundedDuration = roundDuration(d);\n+        if (roundedDuration.equals(Duration.ZERO)) {\n+            return \"0 s\";\n+        } else if (roundedDuration.isNegative()) {\n+            return \"-\" + formatPositiveDuration(roundedDuration.abs());\n+        } else {\n+            return formatPositiveDuration(roundedDuration);\n+        }\n+    }\n+\n+    private static String formatPositiveDuration(Duration d){\n+        if (d.compareTo(MICRO_SECOND) < 0) {\n+            \/\/ 0.000001 ms - 0.000999 ms\n+            double outputMs = (double) d.toNanosPart() \/ 1_000_000;\n+            return String.format(\"%.6f ms\", outputMs);\n+        } else if (d.compareTo(SECOND) < 0) {\n+            \/\/ 0.001 ms - 999 ms\n+            int valueLength = countLength(d.toNanosPart());\n+            int outputDigit = NANO_SIGNIFICANT_FIGURES - valueLength;\n+            double outputMs = (double) d.toNanosPart() \/ 1_000_000;\n+            return String.format(\"%.\" + outputDigit + \"f ms\", outputMs);\n+        } else if (d.compareTo(MINUTE) < 0) {\n+            \/\/ 1.00 s - 59.9 s\n+            int valueLength = countLength(d.toSecondsPart());\n+            int outputDigit = MILL_SIGNIFICANT_FIGURES - valueLength;\n+            double outputSecond = d.toSecondsPart() + (double) d.toMillisPart() \/ 1_000;\n+            return String.format(\"%.\" + outputDigit + \"f s\", outputSecond);\n+        } else if (d.compareTo(HOUR) < 0) {\n+            \/\/ 1 m 0 s - 59 m 59 s\n+            return String.format(\"%d m %d s\", d.toMinutesPart(), d.toSecondsPart());\n+        } else if (d.compareTo(DAY) < 0) {\n+            \/\/ 1 h 0 m - 23 h 59 m\n+            return String.format(\"%d h %d m\", d.toHoursPart(), d.toMinutesPart());\n+        } else {\n+            \/\/ 1 d 0 h -\n+            return String.format(\"%d d %d h\", d.toDaysPart(), d.toHoursPart());\n+        }\n+    }\n+\n+    private static int countLength(long value){\n+        return (int) Math.log10(value) + 1;\n+    }\n+\n+    private static Duration roundDuration(Duration d) {\n+        if (d.equals(Duration.ZERO)) {\n+            return d;\n+        } else if(d.isNegative()) {\n+            Duration roundedPositiveDuration = roundPositiveDuration(d.abs());\n+            return roundedPositiveDuration.negated();\n+        } else {\n+            return roundPositiveDuration(d);\n+        }\n+    }\n+\n+    private static Duration roundPositiveDuration(Duration d){\n+        if (d.compareTo(MICRO_SECOND) < 0) {\n+            \/\/ No round\n+            return d;\n+        } else if (d.compareTo(SECOND) < 0) {\n+            \/\/ Round significant figures to three digits\n+            int valueLength = countLength(d.toNanosPart());\n+            int roundValue = (int) Math.pow(BASE, valueLength - DISPLAY_NANO_DIGIT);\n+            long roundedNanos = Math.round((double) d.toNanosPart() \/ roundValue) * roundValue;\n+            return d.truncatedTo(ChronoUnit.SECONDS).plusNanos(roundedNanos);\n+        } else if (d.compareTo(MINUTE) < 0) {\n+            \/\/ Round significant figures to three digits\n+            int valueLength = countLength(d.toSecondsPart());\n+            int roundValue = (int) Math.pow(BASE, valueLength);\n+            long roundedMills = Math.round((double) d.toMillisPart() \/ roundValue) * roundValue;\n+            return d.truncatedTo(ChronoUnit.SECONDS).plusMillis(roundedMills);\n+        } else if (d.compareTo(HOUR) < 0) {\n+            \/\/ Round for more than 500 ms or less\n+            return d.plusMillis(SECOND.dividedBy(2).toMillisPart()).truncatedTo(ChronoUnit.SECONDS);\n+        } else if (d.compareTo(DAY) < 0) {\n+            \/\/ Round for more than 30 seconds or less\n+            return d.plusSeconds(MINUTE.dividedBy(2).toSecondsPart()).truncatedTo(ChronoUnit.MINUTES);\n+        } else {\n+            \/\/ Round for more than 30 minutes or less\n+            return d.plusMinutes(HOUR.dividedBy(2).toMinutesPart()).truncatedTo(ChronoUnit.HOURS);\n+        }\n+    }\n+\n+    public static String formatClass(RecordedClass clazz) {\n+        String name = clazz.getName();\n+        if (name.startsWith(\"[\")) {\n+            return decodeDescriptors(name, \"\").getFirst();\n+        }\n+        return name;\n+    }\n+\n+    \/\/ Tjis method can't handle Long.MIN_VALUE because absolute value is negative\n+    private static String formatDataAmount(String formatter, long amount) {\n+        int exp = (int) (Math.log(Math.abs(amount)) \/ Math.log(1024));\n+        char unitPrefix = \"kMGTPE\".charAt(exp - 1);\n+        return String.format(formatter, amount \/ Math.pow(1024, exp), unitPrefix);\n+    }\n+\n+    public static String formatBytesCompact(long bytes) {\n+        if (bytes < 1024) {\n+            return String.valueOf(bytes);\n+        }\n+        return formatDataAmount(\"%.1f%cB\", bytes);\n+    }\n+\n+    public static String formatBits(long bits) {\n+        if (bits == 1 || bits == -1) {\n+            return bits + \" bit\";\n+        }\n+        if (bits < 1024 && bits > -1024) {\n+            return bits + \" bits\";\n+        }\n+        return formatDataAmount(\"%.1f %cbit\", bits);\n+    }\n+\n+    public static String formatBytes(long bytes) {\n+        if (bytes == 1 || bytes == -1) {\n+            return bytes + \" byte\";\n+        }\n+        if (bytes < 1024 && bytes > -1024) {\n+            return bytes + \" bytes\";\n+        }\n+        return formatDataAmount(\"%.1f %cB\", bytes);\n+    }\n+\n+    public static String formatBytesPerSecond(long bytes) {\n+        if (bytes < 1024 && bytes > -1024) {\n+            return bytes + \" byte\/s\";\n+        }\n+        return formatDataAmount(\"%.1f %cB\/s\", bytes);\n+    }\n+\n+    public static String formatBitsPerSecond(long bits) {\n+        if (bits < 1024 && bits > -1024) {\n+            return bits + \" bps\";\n+        }\n+        return formatDataAmount(\"%.1f %cbps\", bits);\n+    }\n+\n+    public static String formatMethod(RecordedMethod m, boolean compact) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(m.getType().getName());\n+        sb.append(\".\");\n+        sb.append(m.getName());\n+        sb.append(\"(\");\n+        StringJoiner sj = new StringJoiner(\", \");\n+        String md = m.getDescriptor().replace(\"\/\", \".\");\n+        String parameter = md.substring(1, md.lastIndexOf(\")\"));\n+        List<String> parameters = decodeDescriptors(parameter, \"\");\n+        if (!compact) {\n+            for (String qualifiedName :parameters) {\n+                String typeName = qualifiedName.substring(qualifiedName.lastIndexOf('.') + 1);\n+                sj.add(typeName);\n+            }\n+            sb.append(sj.toString());\n+        } else {\n+            if (!parameters.isEmpty()) {\n+               sb.append(\"...\");\n+            }\n+        }\n+        sb.append(\")\");\n+\n+        return sb.toString();\n+    }\n+\n+    private static List<String> decodeDescriptors(String descriptor, String arraySize) {\n+        List<String> descriptors = new ArrayList<>();\n+        for (int index = 0; index < descriptor.length(); index++) {\n+            String arrayBrackets = \"\";\n+            while (descriptor.charAt(index) == '[') {\n+                arrayBrackets = arrayBrackets + \"[\" + arraySize + \"]\";\n+                arraySize = \"\";\n+                index++;\n+            }\n+            char c = descriptor.charAt(index);\n+            String type;\n+            switch (c) {\n+            case 'L':\n+                int endIndex = descriptor.indexOf(';', index);\n+                type = descriptor.substring(index + 1, endIndex);\n+                index = endIndex;\n+                break;\n+            case 'I':\n+                type = \"int\";\n+                break;\n+            case 'J':\n+                type = \"long\";\n+                break;\n+            case 'Z':\n+                type = \"boolean\";\n+                break;\n+            case 'D':\n+                type = \"double\";\n+                break;\n+            case 'F':\n+                type = \"float\";\n+                break;\n+            case 'S':\n+                type = \"short\";\n+                break;\n+            case 'C':\n+                type = \"char\";\n+                break;\n+            case 'B':\n+                type = \"byte\";\n+                break;\n+            default:\n+                type = \"<unknown-descriptor-type>\";\n+            }\n+            descriptors.add(type + arrayBrackets);\n+        }\n+        return descriptors;\n+    }\n+\n+    public static String formatTimestamp(Instant instant) {\n+        return LocalTime.ofInstant(instant, ZoneId.systemDefault()).format(DATE_FORMAT);\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/ValueFormatter.java","additions":275,"deletions":0,"binary":false,"changes":275,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jcmd;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\/**\n+ * @test\n+ * @summary The test verifies JFR.view command\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @requires (vm.gc == \"G1\" | vm.gc == null)\n+ *           & vm.opt.ExplicitGCInvokesConcurrent != false\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm -XX:-ExplicitGCInvokesConcurrent -XX:-DisableExplicitGC\n+ *                   -XX:+UseG1GC jdk.jfr.jcmd.TestJcmdView\n+ *\/\n+public class TestJcmdView {\n+\n+    public static void main(String... args) throws Throwable {\n+        CountDownLatch jvmInformation = new CountDownLatch(1);\n+        CountDownLatch systemGC = new CountDownLatch(1);\n+        CountDownLatch gcHeapSummary = new CountDownLatch(1);\n+        CountDownLatch oldCollection = new CountDownLatch(1);\n+        CountDownLatch garbageCollection = new CountDownLatch(1);\n+\n+        try (RecordingStream rs = new RecordingStream()) {\n+            \/\/ Make sure chunks are not released after consumption\n+            rs.setMaxSize(Long.MAX_VALUE);\n+            rs.enable(\"jdk.JVMInformation\").with(\"period\", \"beginChunk\");\n+            rs.enable(\"jdk.SystemGC\");\n+            rs.enable(\"jdk.GCHeapSummary\");\n+            rs.enable(\"jdk.GarbageCollection\");\n+            rs.enable(\"jdk.OldGarbageCollection\");\n+            rs.enable(\"jdk.YoungGarbageCollection\");\n+            rs.onEvent(\"jdk.JVMInformation\", e -> {\n+                jvmInformation.countDown();\n+                System.out.println(e);\n+            });\n+            rs.onEvent(\"jdk.SystemGC\", e -> {\n+                systemGC.countDown();\n+                System.out.println(e);\n+            });\n+            rs.onEvent(\"jdk.GCHeapSummary\", e -> {\n+                gcHeapSummary.countDown();\n+                System.out.println(e);\n+            });\n+            rs.onEvent(\"jdk.OldGarbageCollection\", e -> {\n+                oldCollection.countDown();\n+                System.out.println(e);\n+            });\n+            rs.onEvent(\"jdk.GarbageCollection\", e-> {\n+                garbageCollection.countDown();\n+                System.out.println(e);\n+            });\n+            rs.startAsync();\n+            \/\/ Emit some GC events\n+            System.gc();\n+            System.gc();\n+            System.gc();\n+            \/\/ Wait for them being in the repository\n+            jvmInformation.await();\n+            systemGC.await();\n+            gcHeapSummary.await();\n+            oldCollection.countDown();\n+            \/\/ Test events that are in the current chunk\n+            testEventType();\n+            testFormView();\n+            testTableView();\n+            rs.disable(\"jdk.JVMInformation\");\n+            \/\/ Force chunk rotation\n+            rotate();\n+            \/\/ Test events that are NOT in current chunk\n+            testEventType();\n+            testFormView();\n+            testTableView();\n+        }\n+    }\n+\n+    private static void rotate() {\n+       try (Recording r = new Recording()) {\n+           r.start();\n+       }\n+    }\n+\n+    private static void testFormView() throws Throwable {\n+        OutputAnalyzer output = JcmdHelper.jcmd(\"JFR.view\", \"jvm-information\");\n+        \/\/ Verify title\n+        output.shouldContain(\"JVM Information\");\n+        \/\/ Verify field label\n+        output.shouldContain(\"VM Arguments:\");\n+        \/\/ Verify field value\n+        long pid = ProcessHandle.current().pid();\n+        String lastThreeDigits = String.valueOf(pid % 1000);\n+        output.shouldContain(lastThreeDigits);\n+    }\n+\n+    private static void testTableView() throws Throwable {\n+        OutputAnalyzer output = JcmdHelper.jcmd(\"JFR.view\", \"verbose=true\", \"gc\");\n+        \/\/ Verify heading\n+        output.shouldContain(\"Longest Pause\");\n+        \/\/ Verify verbose heading\n+        output.shouldContain(\"(longestPause)\");\n+        \/\/ Verify row contents\n+        output.shouldContain(\"Old Garbage Collection\");\n+        \/\/ Verify verbose query\n+        output.shouldContain(\"SELECT\");\n+    }\n+\n+    private static void testEventType() throws Throwable {\n+        OutputAnalyzer output = JcmdHelper.jcmd(\n+             \"JFR.view\", \"verbose=true\", \"width=300\", \"cell-height=100\", \"SystemGC\");\n+        \/\/ Verify title\n+        output.shouldContain(\"System GC\");\n+        \/\/ Verify headings\n+        output.shouldContain(\"Invoked Concurrent\");\n+        \/\/ Verify verbose headings\n+        output.shouldContain(\"invokedConcurrent\");\n+        \/\/ Verify thread value\n+        output.shouldContain(Thread.currentThread().getName());\n+        \/\/ Verify stack frame\n+        output.shouldContain(\"TestJcmdView.main\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jcmd\/TestJcmdView.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.tool;\n+\n+import java.io.FileWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\/**\n+ * @test\n+ * @summary Test jfr view\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @requires (vm.gc == \"G1\" | vm.gc == null)\n+ *           & vm.opt.ExplicitGCInvokesConcurrent != false\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm -XX:-ExplicitGCInvokesConcurrent -XX:-DisableExplicitGC\n+ *                   -XX:+UseG1GC jdk.jfr.jcmd.TestJcmdView\n+ *\/\n+public class TestView {\n+\n+    public static void main(String... args) throws Throwable {\n+        testIncorrectUsage();\n+        String recordingFile = ExecuteHelper.createProfilingRecording().toAbsolutePath().toString();\n+        testEventType(recordingFile);\n+        testFormView(recordingFile);\n+        testTableView(recordingFile);\n+    }\n+\n+    private static void testIncorrectUsage() throws Throwable {\n+        OutputAnalyzer output = ExecuteHelper.jfr(\"view\");\n+        output.shouldContain(\"missing file\");\n+\n+        output = ExecuteHelper.jfr(\"view\", \"missing.jfr\");\n+        output.shouldContain(\"could not open file \");\n+\n+        Path file = Utils.createTempFile(\"faked-file\", \".jfr\");\n+        FileWriter fw = new FileWriter(file.toFile());\n+        fw.write('d');\n+        fw.close();\n+        output = ExecuteHelper.jfr(\"view\", \"--wrongOption\", file.toAbsolutePath().toString());\n+        output.shouldContain(\"unknown option\");\n+        Files.delete(file);\n+    }\n+\n+    private static void testFormView(String recording) throws Throwable {\n+        OutputAnalyzer output = ExecuteHelper.jfr(\"view\", \"jvm-information\", recording);\n+        \/\/ Verify title\n+        output.shouldContain(\"JVM Information\");\n+        \/\/ Verify field label\n+        output.shouldContain(\"VM Arguments:\");\n+        \/\/ Verify field value\n+        long pid = ProcessHandle.current().pid();\n+        String lastThreeDigits = String.valueOf(pid % 1000);\n+        output.shouldContain(lastThreeDigits);\n+    }\n+\n+    private static void testTableView(String recording) throws Throwable {\n+        OutputAnalyzer output = ExecuteHelper.jfr(\"view\", \"--verbose\", \"gc\", recording);\n+        \/\/ Verify heading\n+        output.shouldContain(\"Longest Pause\");\n+        \/\/ Verify verbose heading\n+        output.shouldContain(\"(longestPause)\");\n+        \/\/ Verify row contents\n+        output.shouldContain(\"Old Garbage Collection\");\n+        \/\/ Verify verbose query\n+        output.shouldContain(\"SELECT\");\n+    }\n+\n+    private static void testEventType(String recording) throws Throwable {\n+        OutputAnalyzer output = ExecuteHelper.jfr(\n+             \"view\", \"--verbose\", \"--width\", \"300\", \"--cell-height\", \"100\", \"SystemGC\", recording);\n+        \/\/ Verify title\n+        output.shouldContain(\"System GC\");\n+        \/\/ Verify headings\n+        output.shouldContain(\"Invoked Concurrent\");\n+        \/\/ Verify verbose headings\n+        output.shouldContain(\"invokedConcurrent\");\n+        \/\/ Verify thread value\n+        output.shouldContain(Thread.currentThread().getName());\n+        \/\/ Verify stack frame\n+        output.shouldContain(\"ExecuteHelper.createProfilingRecording\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/tool\/TestView.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"}]}