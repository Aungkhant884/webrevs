{"files":[{"patch":"@@ -1382,0 +1382,44 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * <p>More formally, if this map contains a mapping from a key\n+     * {@code k} to a value {@code v} such that {@code key == k}\n+     * and {@code value == v}, then this method removes the mapping\n+     * for this key and returns {@code true}; otherwise it returns\n+     * {@code false}.\n+     *\/\n+    @Override\n+    public boolean remove(Object key, Object value) {\n+        return removeMapping(key, value);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * <p>More formally, if this map contains a mapping from a key\n+     * {@code k} to a value {@code v} such that {@code key == k}\n+     * and {@code oldValue == v}, then this method associates\n+     * {@code k} to {@code newValue} and returns {@code true};\n+     * otherwise it returns {@code false}.\n+     *\/\n+    @Override\n+    public boolean replace(K key, V oldValue, V newValue) {\n+        Object k = maskNull(key);\n+        Object[] tab = table;\n+        int len = tab.length;\n+        int i = hash(k, len);\n+\n+        while (true) {\n+            Object item = tab[i];\n+            if (item == k) {\n+                if (tab[i + 1] != oldValue)\n+                    return false;\n+                tab[i + 1] = newValue;\n+                return true;\n+            }\n+            if (item == null)\n+                return false;\n+            i = nextKeyIndex(i, len);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/IdentityHashMap.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.util.IdentityHashMap;\n+\n+\/*\n+ * @test\n+ * @bug 8178355\n+ * @summary Use identity-based comparison for IdentityHashMap#remove and #replace\n+ * @run testng DefaultRemoveReplaceTest\n+ *\/\n+public class DefaultRemoveReplaceTest {\n+    \/** A minimal record that can represent difference in equality and identity. *\/\n+    record Box(int i) { }\n+\n+    private static final Box ONE = new Box(1);\n+    private static final Box ANOTHER_ONE = new Box(1);\n+    private static final Box SIX = new Box(6);\n+    private static final Box THREE = new Box(3);\n+\n+    static {\n+        Assert.assertEquals(ANOTHER_ONE, ONE);\n+        Assert.assertNotSame(ANOTHER_ONE, ONE);\n+    }\n+\n+    @DataProvider\n+    public Object[][] makeMap() {\n+        var map = new IdentityHashMap<Box, Box>();\n+        map.put(null, THREE);\n+        map.put(THREE, ONE);\n+        map.put(ONE, SIX);\n+        map.put(ANOTHER_ONE, null);\n+\n+        Assert.assertEquals(map.size(), 4);\n+\n+        return new Object[][] {\n+                { map }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"makeMap\")\n+    public void testReplaceUnequal(IdentityHashMap<Box, Box> map) {\n+        var seven = new Box(7);\n+        var fakeThree = new Box(3);\n+        Assert.assertFalse(map.replace(seven, ONE, fakeThree));\n+\n+        \/\/ Make sure false return has no side effects\n+        Assert.assertFalse(map.containsKey(seven));\n+        Assert.assertTrue(map.containsValue(ONE));\n+        Assert.assertFalse(map.containsValue(fakeThree));\n+        Assert.assertEquals(map.size(), 4);\n+    }\n+\n+    @Test(dataProvider = \"makeMap\")\n+    public void testReplaceEqualKey(IdentityHashMap<Box, Box> map) {\n+        var seven = new Box(7);\n+        var fakeThree = new Box(3);\n+        Assert.assertFalse(map.replace(fakeThree, ONE, seven));\n+\n+        \/\/ Make sure false return has no side effects\n+        Assert.assertTrue(map.containsKey(THREE));\n+        Assert.assertFalse(map.containsKey(fakeThree));\n+        Assert.assertTrue(map.containsValue(ONE));\n+        Assert.assertFalse(map.containsValue(seven));\n+        Assert.assertEquals(map.size(), 4);\n+    }\n+\n+    @Test(dataProvider = \"makeMap\")\n+    public void testReplaceEqualValue(IdentityHashMap<Box, Box> map) {\n+        var seven = new Box(7);\n+        var fakeOne = new Box(1);\n+        Assert.assertFalse(map.replace(THREE, fakeOne, seven));\n+\n+        \/\/ Make sure false return has no side effects\n+        Assert.assertTrue(map.containsKey(THREE));\n+        Assert.assertSame(map.get(THREE), ONE);\n+        Assert.assertTrue(map.containsValue(ONE));\n+        Assert.assertFalse(map.containsValue(seven));\n+        Assert.assertFalse(map.containsValue(fakeOne));\n+        Assert.assertEquals(map.size(), 4);\n+    }\n+\n+    @Test(dataProvider = \"makeMap\")\n+    public void testReplaceSuccess(IdentityHashMap<Box, Box> map) {\n+        var seven = new Box(7);\n+        Assert.assertTrue(map.replace(ANOTHER_ONE, null, seven));\n+\n+        \/\/ Check aftereffects\n+        Assert.assertTrue(map.containsKey(ANOTHER_ONE));\n+        Assert.assertSame(map.get(ANOTHER_ONE), seven);\n+        Assert.assertTrue(map.containsValue(seven));\n+        Assert.assertFalse(map.containsValue(null));\n+        Assert.assertTrue(map.containsValue(seven));\n+        Assert.assertEquals(map.size(), 4);\n+    }\n+\n+    @Test(dataProvider = \"makeMap\")\n+    public void testRemoveUnequal(IdentityHashMap<Box, Box> map) {\n+        Assert.assertFalse(map.remove(THREE, SIX));\n+\n+        \/\/ Make sure false return has no side effects\n+        Assert.assertTrue(map.containsKey(THREE));\n+        Assert.assertTrue(map.containsValue(SIX));\n+        Assert.assertSame(map.get(ONE), SIX);\n+        Assert.assertSame(map.get(THREE), ONE);\n+        Assert.assertEquals(map.size(), 4);\n+    }\n+\n+    @Test(dataProvider = \"makeMap\")\n+    public void testRemoveEqualKey(IdentityHashMap<Box, Box> map) {\n+        var fakeThree = new Box(3);\n+        Assert.assertFalse(map.remove(null, fakeThree));\n+\n+        \/\/ Make sure false return has no side effects\n+        Assert.assertTrue(map.containsKey(null));\n+        Assert.assertSame(map.get(null), THREE);\n+        Assert.assertTrue(map.containsValue(THREE));\n+        Assert.assertFalse(map.containsValue(fakeThree));\n+        Assert.assertEquals(map.size(), 4);\n+    }\n+\n+    @Test(dataProvider = \"makeMap\")\n+    public void testRemoveSuccess(IdentityHashMap<Box, Box> map) {\n+        Assert.assertTrue(map.remove(ONE, SIX));\n+\n+        \/\/ Check aftereffects\n+        Assert.assertFalse(map.containsKey(ONE));\n+        Assert.assertFalse(map.containsValue(SIX));\n+        Assert.assertTrue(map.containsKey(ANOTHER_ONE));\n+        Assert.assertTrue(map.containsValue(null));\n+        Assert.assertNull(map.get(ONE));\n+        Assert.assertNull(map.get(ANOTHER_ONE));\n+        Assert.assertEquals(map.size(), 3);\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/IdentityHashMap\/DefaultRemoveReplaceTest.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"}]}