{"files":[{"patch":"@@ -52,0 +52,4 @@\n+ * <p>The view collections of this map also have reference-equality semantics\n+ * for their elements. See the {@link keySet() keySet}, {@link values() values},\n+ * and {@link entrySet() entrySet} methods for further information.\n+ *\n@@ -349,1 +353,2 @@\n-     * hash map.\n+     * hash map. Returns {@code true} if and only if this map contains a mapping\n+     * with key {@code k} such that {@code (key == k)}.\n@@ -373,1 +378,2 @@\n-     * hash map.\n+     * hash map. Returns {@code true} if and only if this map contains a mapping\n+     * with value {@code v} such that {@code (value == v)}.\n@@ -414,2 +420,3 @@\n-     * hash map.  If the map previously contained a mapping for the key, the\n-     * old value is replaced.\n+     * hash map. If this map already {@link containsKey(Object) contains}\n+     * a mapping for the key, the old value is replaced, otherwise, a new mapping\n+     * is inserted into this map.\n@@ -500,2 +507,4 @@\n-     * These mappings will replace any mappings that this map had for\n-     * any of the keys currently in the specified map.\n+     * For each mapping in the specified map, if this map already\n+     * {@link containsKey(Object) contains} a mapping for the key,\n+     * its value is replaced with the value from the specified map;\n+     * otherwise, a new mapping is inserted into this map.\n@@ -519,0 +528,2 @@\n+     * The mapping is removed if and only if the mapping has a key\n+     * {@code k} such that (key == k).\n@@ -635,1 +646,3 @@\n-     * {@code this.entrySet().equals(m.entrySet())}.\n+     * {@code this.entrySet().equals(m.entrySet())}. See the\n+     * {@link entrySet() entrySet} method for the specification of equality\n+     * of this map's entries.\n@@ -670,2 +683,5 @@\n-     * defined to be the sum of the hash codes of each entry in the map's\n-     * {@code entrySet()} view.  This ensures that {@code m1.equals(m2)}\n+     * defined to be the sum of the hash codes of each entry of this map.\n+     * See the {@link entrySet() entrySet} method for a specification of the\n+     * hash code of this map's entries.\n+     *\n+     * <p>This specification ensures that {@code m1.equals(m2)}\n@@ -1165,1 +1181,3 @@\n-     * System.identityHashCode(e.getValue())}.\n+     * System.identityHashCode(e.getValue())}. (While the keys and values\n+     * are compared using reference equality, the {@code Map.Entry}\n+     * objects themselves are not.)\n@@ -1385,0 +1403,44 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * <p>More formally, if this map contains a mapping from a key\n+     * {@code k} to a value {@code v} such that {@code (key == k)}\n+     * and {@code (value == v)}, then this method removes the mapping\n+     * for this key and returns {@code true}; otherwise it returns\n+     * {@code false}.\n+     *\/\n+    @Override\n+    public boolean remove(Object key, Object value) {\n+        return removeMapping(key, value);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * <p>More formally, if this map contains a mapping from a key\n+     * {@code k} to a value {@code v} such that {@code (key == k)}\n+     * and {@code (oldValue == v)}, then this method associates\n+     * {@code k} with {@code newValue} and returns {@code true};\n+     * otherwise it returns {@code false}.\n+     *\/\n+    @Override\n+    public boolean replace(K key, V oldValue, V newValue) {\n+        Object k = maskNull(key);\n+        Object[] tab = table;\n+        int len = tab.length;\n+        int i = hash(k, len);\n+\n+        while (true) {\n+            Object item = tab[i];\n+            if (item == k) {\n+                if (tab[i + 1] != oldValue)\n+                    return false;\n+                tab[i + 1] = newValue;\n+                return true;\n+            }\n+            if (item == null)\n+                return false;\n+            i = nextKeyIndex(i, len);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/IdentityHashMap.java","additions":72,"deletions":10,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * @bug 8285295\n+ * @bug 8285295 8178355\n@@ -52,2 +52,0 @@\n-\/\/ TODO remove(k, v)\n-\/\/ TODO replace(k, v1, v2)\n@@ -487,0 +485,91 @@\n+    \/\/ remove(Object, Object) absent key, absent value\n+    @Test\n+    public void testRemoveAA() {\n+        Box k1c = new Box(k1a);\n+        Box v1c = new Box(v1a);\n+        assertFalse(map.remove(k1c, v1c));\n+        checkEntries(map.entrySet(),\n+                entry(k1a, v1a),\n+                entry(k1b, v1b),\n+                entry(k2, v2));\n+    }\n+\n+    \/\/ remove(Object, Object) absent key, present value\n+    @Test\n+    public void testRemoveAV() {\n+        Box k1c = new Box(k1a);\n+        assertFalse(map.remove(k1c, v1a));\n+        checkEntries(map.entrySet(),\n+                     entry(k1a, v1a),\n+                     entry(k1b, v1b),\n+                     entry(k2, v2));\n+    }\n+\n+    \/\/ remove(Object, Object) present key, absent value\n+    @Test\n+    public void testRemoveKA() {\n+        Box v1c = new Box(v1a);\n+        assertFalse(map.remove(k1a, v1c));\n+        checkEntries(map.entrySet(),\n+                entry(k1a, v1a),\n+                entry(k1b, v1b),\n+                entry(k2, v2));\n+    }\n+\n+    \/\/ remove(Object, Object) present key, present value\n+    @Test\n+    public void testRemoveKV() {\n+        assertTrue(map.remove(k1a, v1a));\n+        checkEntries(map.entrySet(),\n+                entry(k1b, v1b),\n+                entry(k2, v2));\n+    }\n+\n+    \/\/ replace(K, V, V) absent key, absent oldValue\n+    @Test\n+    public void testReplaceAA() {\n+        Box k1c = new Box(k1a);\n+        Box v1c = new Box(v1a);\n+        Box newVal = new Box(v2);\n+        assertFalse(map.replace(k1c, v1c, newVal));\n+        checkEntries(map.entrySet(),\n+                entry(k1a, v1a),\n+                entry(k1b, v1b),\n+                entry(k2, v2));\n+    }\n+\n+    \/\/ replace(K, V, V) absent key, present oldValue\n+    @Test\n+    public void testReplaceAV() {\n+        Box k1c = new Box(k1a);\n+        Box newVal = new Box(v2);\n+        assertFalse(map.replace(k1c, v1a, newVal));\n+        checkEntries(map.entrySet(),\n+                entry(k1a, v1a),\n+                entry(k1b, v1b),\n+                entry(k2, v2));\n+    }\n+\n+    \/\/ replace(K, V, V) present key, absent oldValue\n+    @Test\n+    public void testReplaceKA() {\n+        Box v1c = new Box(v1a);\n+        Box newVal = new Box(v2);\n+        assertFalse(map.replace(k1a, v1c, newVal));\n+        checkEntries(map.entrySet(),\n+                entry(k1a, v1a),\n+                entry(k1b, v1b),\n+                entry(k2, v2));\n+    }\n+\n+    \/\/ replace(K, V, V) present key, present oldValue\n+    @Test\n+    public void testReplaceKV() {\n+        Box newVal = new Box(v2);\n+        assertTrue(map.replace(k1a, v1a, newVal));\n+        checkEntries(map.entrySet(),\n+                entry(k1a, newVal),\n+                entry(k1b, v1b),\n+                entry(k2, v2));\n+    }\n+\n","filename":"test\/jdk\/java\/util\/IdentityHashMap\/Basic.java","additions":92,"deletions":3,"binary":false,"changes":95,"status":"modified"}]}