{"files":[{"patch":"@@ -547,0 +547,32 @@\n+    \/**\n+     * Removes the specified key-value mapping from the map if it is present.\n+     *\n+     * @param   key   possible key\n+     * @param   value possible value\n+     * @return  {@code true} if and only if the specified key-value\n+     *          mapping was in the map\n+     *\/\n+    private boolean removeMapping(Object key, Object value) {\n+        Object k = maskNull(key);\n+        Object[] tab = table;\n+        int len = tab.length;\n+        int i = hash(k, len);\n+\n+        while (true) {\n+            Object item = tab[i];\n+            if (item == k) {\n+                if (tab[i + 1] != value)\n+                    return false;\n+                modCount++;\n+                size--;\n+                tab[i] = null;\n+                tab[i + 1] = null;\n+                closeDeletion(i);\n+                return true;\n+            }\n+            if (item == null)\n+                return false;\n+            i = nextKeyIndex(i, len);\n+        }\n+    }\n+\n@@ -1163,1 +1195,1 @@\n-                    && IdentityHashMap.this.remove(entry.getKey(), entry.getValue());\n+                    && removeMapping(entry.getKey(), entry.getValue());\n@@ -1361,21 +1393,1 @@\n-        Object k = maskNull(key);\n-        Object[] tab = table;\n-        int len = tab.length;\n-        int i = hash(k, len);\n-\n-        while (true) {\n-            Object item = tab[i];\n-            if (item == k) {\n-                if (tab[i + 1] != value)\n-                    return false;\n-                modCount++;\n-                size--;\n-                tab[i] = null;\n-                tab[i + 1] = null;\n-                closeDeletion(i);\n-                return true;\n-            }\n-            if (item == null)\n-                return false;\n-            i = nextKeyIndex(i, len);\n-        }\n+        return removeMapping(key, value);\n","filename":"src\/java.base\/share\/classes\/java\/util\/IdentityHashMap.java","additions":34,"deletions":22,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -1,68 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.IdentityHashMap;\n-import java.util.Objects;\n-\n-\/*\n- * @test\n- * @bug 8178355\n- * @summary Use identity-based comparison for IdentityHashMap#remove and #replace\n- *\/\n-public class DefaultRemoveReplace {\n-    public static void main(String[] args) {\n-        final String key = \"key\";\n-        final String internedValue = \"value\";\n-        final String constructedValue = new String(new char[]{'v', 'a', 'l', 'u', 'e'});\n-\n-        if (!Objects.equals(internedValue, constructedValue)) {\n-            throw new AssertionError(\"Bad test data: equality should hold\");\n-        }\n-\n-        if (internedValue == constructedValue) {\n-            throw new AssertionError(\"Bad test data: identity should be different\");\n-        }\n-\n-        final IdentityHashMap<String, String> map = new IdentityHashMap<>();\n-        map.put(key, internedValue);\n-\n-        if (map.replace(key, constructedValue, \"dummy\")) {\n-            throw new AssertionError(\"Erroneously replacd value by equality\");\n-        }\n-\n-        if (!map.replace(key, internedValue, \"dummy\")) {\n-            throw new AssertionError(\"Failed to replace value by identity\");\n-        }\n-\n-        map.clear();\n-        map.put(key, constructedValue);\n-\n-        if (map.remove(key, internedValue)) {\n-            throw new AssertionError(\"Erroneously removed value by equality\");\n-        }\n-\n-        if (!map.remove(key, constructedValue)) {\n-            throw new AssertionError(\"Failed to remove value by identity\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/IdentityHashMap\/DefaultRemoveReplace.java","additions":0,"deletions":68,"binary":false,"changes":68,"status":"deleted"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.util.IdentityHashMap;\n+\n+\/*\n+ * @test\n+ * @bug 8178355\n+ * @summary Use identity-based comparison for IdentityHashMap#remove and #replace\n+ * @run testng DefaultRemoveReplaceTest\n+ *\/\n+public class DefaultRemoveReplaceTest {\n+    \/** A minimal record that can represent difference in equality and identity. *\/\n+    record Box(int i) { }\n+\n+    private static final Box ONE = new Box(1);\n+    private static final Box ANOTHER_ONE = new Box(1);\n+    private static final Box SIX = new Box(6);\n+    private static final Box THREE = new Box(3);\n+\n+    static {\n+        Assert.assertEquals(ONE, ANOTHER_ONE);\n+        Assert.assertNotSame(ONE, ANOTHER_ONE);\n+    }\n+\n+    @DataProvider\n+    public Object[][] makeMap() {\n+        var map = new IdentityHashMap<Box, Box>();\n+        map.put(null, THREE);\n+        map.put(THREE, ONE);\n+        map.put(ONE, SIX);\n+        map.put(ANOTHER_ONE, null);\n+\n+        Assert.assertEquals(4, map.size());\n+\n+        return new Object[][] {\n+                { map }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"makeMap\")\n+    public void testReplaceUnequal(IdentityHashMap<Box, Box> map) {\n+        var seven = new Box(7);\n+        var fakeThree = new Box(3);\n+        Assert.assertFalse(map.replace(seven, ONE, fakeThree));\n+\n+        \/\/ Make sure false return has no side effects\n+        Assert.assertFalse(map.containsKey(seven));\n+        Assert.assertTrue(map.containsValue(ONE));\n+        Assert.assertFalse(map.containsValue(fakeThree));\n+        Assert.assertEquals(4, map.size());\n+    }\n+\n+    @Test(dataProvider = \"makeMap\")\n+    public void testReplaceEqualKey(IdentityHashMap<Box, Box> map) {\n+        var seven = new Box(7);\n+        var fakeThree = new Box(3);\n+        Assert.assertFalse(map.replace(fakeThree, ONE, seven));\n+\n+        \/\/ Make sure false return has no side effects\n+        Assert.assertTrue(map.containsKey(THREE));\n+        Assert.assertFalse(map.containsKey(fakeThree));\n+        Assert.assertTrue(map.containsValue(ONE));\n+        Assert.assertFalse(map.containsValue(seven));\n+        Assert.assertEquals(4, map.size());\n+    }\n+\n+    @Test(dataProvider = \"makeMap\")\n+    public void testReplaceEqualValue(IdentityHashMap<Box, Box> map) {\n+        var seven = new Box(7);\n+        var fakeOne = new Box(1);\n+        Assert.assertFalse(map.replace(THREE, fakeOne, seven));\n+\n+        \/\/ Make sure false return has no side effects\n+        Assert.assertTrue(map.containsKey(THREE));\n+        Assert.assertSame(ONE, map.get(THREE));\n+        Assert.assertTrue(map.containsValue(ONE));\n+        Assert.assertFalse(map.containsValue(seven));\n+        Assert.assertFalse(map.containsValue(fakeOne));\n+        Assert.assertEquals(4, map.size());\n+    }\n+\n+    @Test(dataProvider = \"makeMap\")\n+    public void testReplaceSuccess(IdentityHashMap<Box, Box> map) {\n+        var seven = new Box(7);\n+        Assert.assertTrue(map.replace(ANOTHER_ONE, null, seven));\n+\n+        \/\/ Check aftereffects\n+        Assert.assertTrue(map.containsKey(ANOTHER_ONE));\n+        Assert.assertSame(seven, map.get(ANOTHER_ONE));\n+        Assert.assertTrue(map.containsValue(seven));\n+        Assert.assertFalse(map.containsValue(null));\n+        Assert.assertTrue(map.containsValue(seven));\n+        Assert.assertEquals(4, map.size());\n+    }\n+\n+    @Test(dataProvider = \"makeMap\")\n+    public void testRemoveUnequal(IdentityHashMap<Box, Box> map) {\n+        Assert.assertFalse(map.remove(THREE, SIX));\n+\n+        \/\/ Make sure false return has no side effects\n+        Assert.assertTrue(map.containsKey(THREE));\n+        Assert.assertTrue(map.containsValue(SIX));\n+        Assert.assertSame(SIX, map.get(ONE));\n+        Assert.assertSame(ONE, map.get(THREE));\n+        Assert.assertEquals(4, map.size());\n+    }\n+\n+    @Test(dataProvider = \"makeMap\")\n+    public void testRemoveEqualKey(IdentityHashMap<Box, Box> map) {\n+        var fakeThree = new Box(3);\n+        Assert.assertFalse(map.remove(null, fakeThree));\n+\n+        \/\/ Make sure false return has no side effects\n+        Assert.assertTrue(map.containsKey(null));\n+        Assert.assertSame(THREE, map.get(null));\n+        Assert.assertTrue(map.containsValue(THREE));\n+        Assert.assertFalse(map.containsValue(fakeThree));\n+        Assert.assertEquals(4, map.size());\n+    }\n+\n+    @Test(dataProvider = \"makeMap\")\n+    public void testRemoveSuccess(IdentityHashMap<Box, Box> map) {\n+        Assert.assertTrue(map.remove(ONE, SIX));\n+\n+        \/\/ Check aftereffects\n+        Assert.assertFalse(map.containsKey(ONE));\n+        Assert.assertFalse(map.containsValue(SIX));\n+        Assert.assertTrue(map.containsKey(ANOTHER_ONE));\n+        Assert.assertTrue(map.containsValue(null));\n+        Assert.assertNull(map.get(ONE));\n+        Assert.assertNull(map.get(ANOTHER_ONE));\n+        Assert.assertEquals(3, map.size());\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/IdentityHashMap\/DefaultRemoveReplaceTest.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"}]}