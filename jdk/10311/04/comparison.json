{"files":[{"patch":"@@ -130,1 +130,1 @@\n-  __ far_call(Address(Runtime1::entry_for(Runtime1::throw_div0_exception_id), relocInfo::runtime_call_type));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::throw_div0_exception_id)));\n","filename":"src\/hotspot\/cpu\/riscv\/c1_CodeStubs_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -395,8 +395,0 @@\n-  \/\/ The interpreter and compiler(s) always save fp in a known\n-  \/\/ location on entry. We must record where that location is\n-  \/\/ so that if fp was live on callout from c2 we can find\n-  \/\/ the saved copy no matter what it called.\n-\n-  \/\/ Since the interpreter always saves fp if we record where it is then\n-  \/\/ we don't have to always save fp on entry and exit to c2 compiled\n-  \/\/ code, on entry will be enough.\n@@ -404,0 +396,4 @@\n+  \/\/ The interpreter and compiler(s) always save FP in a known\n+  \/\/ location on entry. C2-compiled code uses FP as an allocatable\n+  \/\/ callee-saved register. We must record where that location is so\n+  \/\/ that if FP was live on callout from C2 we can find the saved copy.\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.inline.hpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2442,0 +2442,3 @@\n+  assert(entry.rspec().type() == relocInfo::external_word_type\n+        || entry.rspec().type() == relocInfo::runtime_call_type\n+        || entry.rspec().type() == relocInfo::none, \"wrong entry relocInfo type\");\n@@ -2457,0 +2460,3 @@\n+  assert(entry.rspec().type() == relocInfo::external_word_type\n+        || entry.rspec().type() == relocInfo::runtime_call_type\n+        || entry.rspec().type() == relocInfo::none, \"wrong entry relocInfo type\");\n@@ -2704,1 +2710,1 @@\n-  \/\/ [-(2G + 2K), 2G - 2k).\n+  \/\/ [-(2G + 2K), 2G - 2K).\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -599,2 +599,9 @@\n-  \/\/ Jumps that can reach anywhere in the code cache.\n-  \/\/ Trashes tmp.\n+  \/\/ Emit a direct call\/jump if the entry address will always be in range,\n+  \/\/ otherwise a far call\/jump.\n+  \/\/ The address must be inside the code cache.\n+  \/\/ Supported entry.rspec():\n+  \/\/ - relocInfo::external_word_type\n+  \/\/ - relocInfo::runtime_call_type\n+  \/\/ - relocInfo::none\n+  \/\/ In the case of a far call\/jump, the entry address is put in the tmp register.\n+  \/\/ The tmp register is invalidated.\n@@ -638,0 +645,64 @@\n+  \/\/ RISCV64 OpenJDK uses four different types of calls:\n+  \/\/   - direct call: jal pc_relative_offset\n+  \/\/     This is the shortest and the fastest, but the offset has the range: +\/-1MB.\n+  \/\/\n+  \/\/   - far call: auipc reg, pc_relative_offset; jalr ra, reg, offset\n+  \/\/     This is longer than a direct call. The offset has\n+  \/\/     the range [-(2G + 2K), 2G - 2K). Addresses out of the range in the code cache\n+  \/\/     requires indirect call.\n+  \/\/     If a jump is needed rather than a call, a far jump 'jalr x0, reg, offset' can\n+  \/\/     be used instead.\n+  \/\/     All instructions are embedded at a call site.\n+  \/\/\n+  \/\/   - trampoline call:\n+  \/\/     This is only available in C1\/C2-generated code (nmethod). It is a combination\n+  \/\/     of a direct call, which is used if the destination of a call is in range,\n+  \/\/     and a register-indirect call. It has the advantages of reaching anywhere in\n+  \/\/     the RISCV address space and being patchable at runtime when the generated\n+  \/\/     code is being executed by other threads.\n+  \/\/\n+  \/\/     [Main code section]\n+  \/\/       jal trampoline\n+  \/\/     [Stub code section]\n+  \/\/     trampoline:\n+  \/\/       ld    reg, pc + 8 (auipc + ld)\n+  \/\/       jr    reg\n+  \/\/       <64-bit destination address>\n+  \/\/\n+  \/\/     If the destination is in range when the generated code is moved to the code\n+  \/\/     cache, 'jal trampoline' is replaced with 'jal destination' and the trampoline\n+  \/\/     is not used.\n+  \/\/     The optimization does not remove the trampoline from the stub section.\n+\n+  \/\/     This is necessary because the trampoline may well be redirected later when\n+  \/\/     code is patched, and the new destination may not be reachable by a simple JAL\n+  \/\/     instruction.\n+  \/\/\n+  \/\/   - indirect call: movptr_with_offset + jalr\n+  \/\/     This too can reach anywhere in the address space, but it cannot be\n+  \/\/     patched while code is running, so it must only be modified at a safepoint.\n+  \/\/     This form of call is most suitable for targets at fixed addresses, which\n+  \/\/     will never be patched.\n+  \/\/\n+  \/\/\n+  \/\/ To patch a trampoline call when the JAL can't reach, we first modify\n+  \/\/ the 64-bit destination address in the trampoline, then modify the\n+  \/\/ JAL to point to the trampoline, then flush the instruction cache to\n+  \/\/ broadcast the change to all executing threads. See\n+  \/\/ NativeCall::set_destination_mt_safe for the details.\n+  \/\/\n+  \/\/ There is a benign race in that the other thread might observe the\n+  \/\/ modified JAL before it observes the modified 64-bit destination\n+  \/\/ address. That does not matter because the destination method has been\n+  \/\/ invalidated, so there will be a trap at its start.\n+  \/\/ For this to work, the destination address in the trampoline is\n+  \/\/ always updated, even if we're not using the trampoline.\n+\n+  \/\/ Emit a direct call if the entry address will always be in range,\n+  \/\/ otherwise a trampoline call.\n+  \/\/ Supported entry.rspec():\n+  \/\/ - relocInfo::runtime_call_type\n+  \/\/ - relocInfo::opt_virtual_call_type\n+  \/\/ - relocInfo::static_call_type\n+  \/\/ - relocInfo::virtual_call_type\n+  \/\/\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":73,"deletions":2,"binary":false,"changes":75,"status":"modified"}]}