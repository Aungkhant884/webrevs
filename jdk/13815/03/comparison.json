{"files":[{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.concurrent;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.LockSupport;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Benchmark)\n+@Fork(1)\n+@Threads(1)\n+@Warmup(iterations =  5, time = 5)\n+@Measurement(iterations =  5, time = 5)\n+public class UnparkBenchSleepersAfter {\n+\n+    \/*\n+        This micro creates thousands of sleeper threads after the threads doing the barrier await\n+        to see if that has any effect on the barrier performance.\n+     *\/\n+\n+    @Param({\"4000\"})\n+    int idles;\n+\n+    @Param({\"2\"})\n+    int workers;\n+\n+    CyclicBarrier barrier;\n+\n+    @Benchmark\n+    public void barrier() throws InterruptedException {\n+        CountDownLatch latch = new CountDownLatch(workers);\n+        for (int i = 0; i < workers; i++) {\n+            exec.submit(() ->\n+            {\n+                try {\n+                    barrier.await();\n+                } catch (InterruptedException | BrokenBarrierException e) {\n+                    barrier.reset();\n+                } finally {\n+                    latch.countDown();\n+                }\n+            });\n+        }\n+        latch.await();\n+    }\n+\n+    IdleRunnable[] idleRunnables;\n+\n+    ExecutorService exec;\n+\n+    @Setup\n+    public void setup() throws InterruptedException {\n+        barrier = new CyclicBarrier(workers);\n+        exec = Executors.newFixedThreadPool(workers);\n+        CountDownLatch latch = new CountDownLatch(workers);\n+        for (int i = 0; i < workers; i++) { \/\/ warmup exec\n+            exec.submit(() -> {\n+                try {\n+                    Thread.sleep(0);\n+                } catch (InterruptedException e) {\n+                    throw new RuntimeException(e);\n+                } finally {\n+                    latch.countDown();\n+                }\n+            });\n+        }\n+        latch.await();\n+        idleRunnables = new IdleRunnable[idles];\n+        for(int i = 0; i < idles; i++) {\n+            IdleRunnable r = new IdleRunnable();\n+            idleRunnables[i] = r;\n+            new Thread(r).start();\n+        }\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        for (IdleRunnable r : idleRunnables) {\n+            r.stop();\n+        }\n+        exec.shutdown();\n+    }\n+\n+    public static class IdleRunnable implements Runnable {\n+        volatile boolean done;\n+        Thread myThread;\n+\n+        @Override\n+        public void run() {\n+            myThread = Thread.currentThread();\n+            while (!done) {\n+                LockSupport.park();\n+            }\n+        }\n+\n+        public void stop() {\n+            done = true;\n+            LockSupport.unpark(myThread);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/concurrent\/UnparkBenchSleepersAfter.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.concurrent;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.BenchmarkParams;\n+import org.openjdk.jmh.infra.Control;\n+\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.LongAdder;\n+import java.util.concurrent.locks.LockSupport;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Benchmark)\n+@Fork(1)\n+@Threads(1)\n+@Warmup(iterations =  5, time = 5)\n+@Measurement(iterations =  5, time = 5)\n+public class UnparkBenchSleepersBefore {\n+\n+    \/*\n+        This micro creates thousands of sleeper threads before the threads doing the barrier await\n+        to see if that has any effect on the barrier performance, as seen with JDK-8305670.\n+     *\/\n+\n+    @Param({\"4000\"})\n+    int idles;\n+\n+    @Param({\"2\"})\n+    int workers;\n+\n+    CyclicBarrier barrier;\n+\n+    @Benchmark\n+    public void barrier() throws InterruptedException {\n+        CountDownLatch latch = new CountDownLatch(workers);\n+        for (int i = 0; i < workers; i++) {\n+            exec.submit(() -> {\n+                try {\n+                    barrier.await();\n+                } catch (InterruptedException | BrokenBarrierException e) {\n+                    barrier.reset();\n+                } finally {\n+                    latch.countDown();\n+                }\n+            });\n+        }\n+        latch.await();\n+    }\n+\n+    IdleRunnable[] idleRunnables;\n+\n+    ExecutorService exec;\n+\n+    @Setup\n+    public void setup() {\n+        idleRunnables = new IdleRunnable[idles];\n+        for(int i = 0; i < idleRunnables.length; i++) {\n+            idleRunnables[i] = new IdleRunnable();\n+            new Thread(idleRunnables[i]).start();\n+        }\n+        barrier = new CyclicBarrier(workers);\n+        exec = Executors.newFixedThreadPool(workers); \/\/ order is important, create this executor only after idle threads\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        for (IdleRunnable r : idleRunnables) {\n+            r.stop();\n+        }\n+        exec.shutdown();\n+    }\n+\n+    public static class IdleRunnable implements Runnable {\n+        volatile boolean done;\n+        Thread myThread;\n+\n+        @Override\n+        public void run() {\n+            myThread = Thread.currentThread();\n+            while (!done) {\n+                LockSupport.park();\n+            }\n+        }\n+\n+        public void stop() {\n+            done = true;\n+            LockSupport.unpark(myThread);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/concurrent\/UnparkBenchSleepersBefore.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"}]}