{"files":[{"patch":"@@ -116,1 +116,1 @@\n-  if (comp_level == CompLevel_all) {\n+  if (comp_level == CompLevel_any) {\n@@ -129,1 +129,1 @@\n-  assert(WhiteBoxAPI || comp_level == CompLevel_all || is_compile(comp_level), \"illegal compilation level\");\n+  assert(WhiteBoxAPI || comp_level == CompLevel_any || is_compile(comp_level), \"illegal compilation level\");\n@@ -144,1 +144,1 @@\n-  if (comp_level == CompLevel_all || is_compile(comp_level)) {\n+  if (comp_level == CompLevel_any || is_compile(comp_level)) {\n@@ -154,1 +154,1 @@\n-  if (comp_level == CompLevel_all || is_compile(comp_level)) {\n+  if (comp_level == CompLevel_any || is_compile(comp_level)) {\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-  static bool must_be_compiled(const methodHandle& m, int comp_level = CompLevel_all);\n+  static bool must_be_compiled(const methodHandle& m, int comp_level = CompLevel_any);\n@@ -251,1 +251,1 @@\n-  static bool can_be_compiled(const methodHandle& m, int comp_level = CompLevel_all);\n+  static bool can_be_compiled(const methodHandle& m, int comp_level = CompLevel_any);\n@@ -253,1 +253,1 @@\n-  static bool can_be_osr_compiled(const methodHandle& m, int comp_level = CompLevel_all);\n+  static bool can_be_osr_compiled(const methodHandle& m, int comp_level = CompLevel_any);\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,2 +58,2 @@\n-  CompLevel_any               = -2,\n-  CompLevel_all               = -2,\n+  CompLevel_any               = -2,        \/\/ Used for querying the state\n+  CompLevel_all               = -2,        \/\/ Used for changing the state\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -835,0 +835,19 @@\n+static bool is_excluded_for_compiler(AbstractCompiler* comp, methodHandle& mh) {\n+  if (comp == NULL) {\n+    return true;\n+  }\n+  DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, comp);\n+  if (directive->ExcludeOption) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+static bool can_be_compiled_at_level(methodHandle& mh, jboolean is_osr, int level) {\n+  if (is_osr) {\n+    return CompilationPolicy::can_be_osr_compiled(mh, level);\n+  } else {\n+    return CompilationPolicy::can_be_compiled(mh, level);\n+  }\n+}\n+\n@@ -843,4 +862,23 @@\n-  if (is_osr) {\n-    return CompilationPolicy::can_be_osr_compiled(mh, comp_level);\n-  } else {\n-    return CompilationPolicy::can_be_compiled(mh, comp_level);\n+\n+  \/\/ The ExcludeOption directive is evaluated lazily upon compilation attempt. If a method was not tried to be compiled by\n+  \/\/ a compiler, yet, the method object is not set to be not compilable by that compiler. Thus, evaluate the compiler directive\n+  \/\/ to exclude a compilation of 'method'.\n+  if (comp_level == CompLevel_any) {\n+    \/\/ Both compilers could have ExcludeOption set. Check all combinations.\n+    bool excluded_c1 = is_excluded_for_compiler(CompileBroker::compiler1(), mh);\n+    bool excluded_c2 = is_excluded_for_compiler(CompileBroker::compiler2(), mh);\n+    if (excluded_c1 && excluded_c2) {\n+      \/\/ Compilation of 'method' excluded by both compilers.\n+      return false;\n+    }\n+\n+    if (excluded_c1) {\n+      \/\/ C1 only has ExcludeOption set: Check if compilable with C2.\n+      return can_be_compiled_at_level(mh, is_osr, CompLevel_full_optimization);\n+    } else if (excluded_c2) {\n+      \/\/ C2 only has ExcludeOption set: Check if compilable with C1.\n+      return can_be_compiled_at_level(mh, is_osr, CompLevel_simple);\n+    }\n+  } else if (comp_level > CompLevel_none && is_excluded_for_compiler(CompileBroker::compiler((int)comp_level), mh)) {\n+    \/\/ Compilation of 'method' excluded by compiler used for 'comp_level'.\n+    return false;\n@@ -848,0 +886,2 @@\n+\n+  return can_be_compiled_at_level(mh, is_osr, (int)comp_level);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":44,"deletions":4,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Tests WB::isMethodCompilable(m) in combination with compiler directives that prevent a compilation of m.\n+ * @bug 8263582\n+ * @library \/test\/lib \/\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      -XX:CompileCommand=compileonly,compiler.whitebox.TestMethodCompilableCompilerDirectives::doesNotExist\n+ *      compiler.whitebox.TestMethodCompilableCompilerDirectives\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      -XX:CompileCommand=exclude,compiler.whitebox.TestMethodCompilableCompilerDirectives::*\n+ *      compiler.whitebox.TestMethodCompilableCompilerDirectives\n+ *\/\n+\n+package compiler.whitebox;\n+\n+import jdk.test.lib.Asserts;\n+import sun.hotspot.WhiteBox;\n+import java.lang.reflect.Method;\n+\n+public class TestMethodCompilableCompilerDirectives {\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    \/\/ Method too simple for C2 and only C1 compiled.\n+    public static int c1Compiled() {\n+        return 3;\n+    }\n+\n+\n+    \/\/ Method first C1 and then C2 compiled.\n+    public static int c2Compiled() {\n+        for (int i = 0; i < 100; i++);\n+        return 3;\n+    }\n+\n+    \/\/ WB::isMethodCompilable(m) uses Method::is_not_compilable() to decide if m is compilable. Method::is_not_compilable(), however,\n+    \/\/ returns false regardless of any compiler directives if m was not yet tried to be compiled. The compiler directive ExcludeOption\n+    \/\/ to prevent a compilation is evaluated lazily and is only applied when a compilation for m is attempted.\n+    \/\/ Another problem is that Method::is_not_compilable() only returns true for CompLevel_any if C1 AND C2 cannot compile it.\n+    \/\/ This means that a compilation of m must have been attempted for C1 and C2 before WB::isMethodCompilable(m, CompLevel_any) will\n+    \/\/ ever return false. This disregards any compiler directives (e.g. compileonly, exclude) that prohibit a compilation of m completely.\n+    \/\/ WB::isMethodCompilable() should be aware of the ExcludeOption compiler directives at any point in time.\n+    public static void main(String[] args) throws NoSuchMethodException {\n+        Method c1CompiledMethod = TestMethodCompilableCompilerDirectives.class.getDeclaredMethod(\"c1Compiled\");\n+        Method c2CompiledMethod = TestMethodCompilableCompilerDirectives.class.getDeclaredMethod(\"c2Compiled\");\n+\n+        boolean compilable = WhiteBox.getWhiteBox().isMethodCompilable(c1CompiledMethod);\n+        Asserts.assertFalse(compilable);\n+        for (int i = 0; i < 3000; i++) {\n+            c1Compiled();\n+        }\n+        compilable = WhiteBox.getWhiteBox().isMethodCompilable(c1CompiledMethod);\n+        Asserts.assertFalse(compilable);\n+\n+\n+        compilable = WhiteBox.getWhiteBox().isMethodCompilable(c2CompiledMethod);\n+        Asserts.assertFalse(compilable);\n+        for (int i = 0; i < 3000; i++) {\n+            c2Compiled();\n+        }\n+        compilable = WhiteBox.getWhiteBox().isMethodCompilable(c2CompiledMethod);\n+        Asserts.assertFalse(compilable);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/TestMethodCompilableCompilerDirectives.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"}]}