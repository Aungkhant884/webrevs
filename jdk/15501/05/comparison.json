{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,8 @@\n+\n+        CopyOption[] replaceExistingOrEmpty() {\n+            if (replaceExisting) {\n+                return new CopyOption[] { StandardCopyOption.REPLACE_EXISTING };\n+            } else {\n+                return new CopyOption[0];\n+            }\n+        }\n@@ -132,6 +140,0 @@\n-        \/\/ delete target if it exists and REPLACE_EXISTING is specified\n-        if (opts.replaceExisting) {\n-            Files.deleteIfExists(target);\n-        } else if (Files.exists(target))\n-            throw new FileAlreadyExistsException(target.toString());\n-\n@@ -140,0 +142,2 @@\n+            if (opts.replaceExisting)\n+                Files.deleteIfExists(target);\n@@ -143,1 +147,1 @@\n-                Files.copy(in, target);\n+                Files.copy(in, target, opts.replaceExistingOrEmpty());\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/CopyMoveHelper.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -898,0 +898,9 @@\n+        if (sourceAttrs.isDirectory()) {\n+            \/\/ ensure source can be moved\n+            try {\n+                access(source, W_OK);\n+            } catch (UnixException exc) {\n+                exc.rethrowAsIOException(source);\n+            }\n+        }\n+\n@@ -913,1 +922,1 @@\n-            if (!flags.replaceExisting) {\n+            if (!flags.replaceExisting)\n@@ -916,1 +925,0 @@\n-            }\n@@ -1022,0 +1030,11 @@\n+        \/\/ ensure source can be copied\n+        if (!sourceAttrs.isSymbolicLink() || flags.followLinks) {\n+            try {\n+                \/\/ the access(2) system call always follows links so it\n+                \/\/ is suppressed if the source is an unfollowed link\n+                access(source, R_OK);\n+            } catch (UnixException exc) {\n+                exc.rethrowAsIOException(source);\n+            }\n+        }\n+\n@@ -1040,0 +1059,1 @@\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystem.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -498,1 +498,1 @@\n-                \"not supported when creating symbolic link\");\n+                \" not supported when creating symbolic link\");\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystemProvider.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * @bug 4313887 6838333 6917021 7006126 6950237 8006645 8201407 8264744 8267820\n+ * @bug 4313887 6838333 6917021 7006126 6950237 8006645 8073061 8201407 8264744\n+ *      8267820\n@@ -38,1 +39,0 @@\n-import static java.nio.file.StandardCopyOption.*;\n@@ -40,0 +40,1 @@\n+import static java.nio.file.StandardCopyOption.*;\n@@ -817,0 +818,19 @@\n+        \/**\n+         * Test: ensure target not deleted if source permissions are zero\n+         *\/\n+        source = createSourceFile(dir1);\n+        if (getFileStore(source).supportsFileAttributeView(\"posix\")) {\n+            Files.setPosixFilePermissions(source, Set.of());\n+            target = getTargetFile(dir2);\n+            createFile(target);\n+            try {\n+                Files.copy(source, target, REPLACE_EXISTING);\n+                throw new RuntimeException(\"AccessDeniedException not thrown\");\n+            } catch (AccessDeniedException expected) {\n+            }\n+            if (!Files.exists(target))\n+                throw new RuntimeException(\"target deleted\");\n+            delete(target);\n+        }\n+        delete(source);\n+\n","filename":"test\/jdk\/java\/nio\/file\/Files\/CopyAndMove.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8073061\n+ * @requires (os.family == \"linux\") | (os.family == \"mac\")\n+ * @summary Test Files.copy and Files.move with numerous parameters\n+ * @run junit CopyMoveVariations\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.AccessDeniedException;\n+import java.nio.file.CopyOption;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.LinkOption;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.PosixFilePermission;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+import static java.nio.file.LinkOption.*;\n+import static java.nio.file.StandardCopyOption.*;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class CopyMoveVariations {\n+    enum OpType {\n+        COPY,\n+        MOVE\n+    }\n+\n+    enum PathType {\n+        FILE,\n+        DIR,\n+        LINK\n+    }\n+\n+    private static Stream<Arguments> params() {\n+        List<Arguments> list = new ArrayList<Arguments>();\n+\n+        boolean[] falseAndTrue = new boolean[] {false, true};\n+        for (PathType type : PathType.values()) {\n+            String[] modes = new String[] {\n+                \"---------\", \"r--r--r--\", \"-w--w--w-\", \"rw-rw-rw-\"\n+            };\n+            for (String mode : modes) {\n+                for (boolean replaceExisting : falseAndTrue) {\n+                    for (boolean targetExists : falseAndTrue) {\n+                        list.add(Arguments.of(type, mode, replaceExisting,\n+                                              targetExists));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"params\")\n+    void copyFollow(PathType type, String mode, boolean replaceExisting,\n+                    boolean targetExists) throws IOException {\n+        op(OpType.COPY, type, mode, replaceExisting, targetExists, true);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"params\")\n+    void copyNoFollow(PathType type, String mode, boolean replaceExisting,\n+                    boolean targetExists) throws IOException {\n+        op(OpType.COPY, type, mode, replaceExisting, targetExists, false);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"params\")\n+    void move(PathType type, String mode, boolean replaceExisting,\n+              boolean targetExists) throws IOException {\n+        op(OpType.MOVE, type, mode, replaceExisting, targetExists, false);\n+    }\n+\n+    void op(OpType op, PathType type, String mode, boolean replaceExisting,\n+            boolean targetExists, boolean followLinks) throws IOException {\n+\n+        Path source = null;\n+        Path target = null;\n+        Path linkTarget = null;\n+        try {\n+            switch (type) {\n+                case FILE ->\n+                    source = Files.createTempFile(\"file\", \"dat\");\n+                case DIR ->\n+                    source = Files.createTempDirectory(\"dir\");\n+                case LINK -> {\n+                    linkTarget = Files.createTempFile(\"link\", \"target\");\n+                    Path link = Path.of(\"link\");\n+                    source = Files.createSymbolicLink(link, linkTarget);\n+                }\n+            }\n+\n+            if (Files.getFileStore(source).supportsFileAttributeView(\"posix\")) {\n+                Set<PosixFilePermission> perms =\n+                    PosixFilePermissions.fromString(mode);\n+                if (op == OpType.COPY && type == PathType.LINK && followLinks)\n+                    Files.setPosixFilePermissions(linkTarget, perms);\n+                else\n+                    Files.setPosixFilePermissions(source, perms);\n+            }\n+\n+            if (targetExists)\n+                target = Files.createTempFile(\"file\", \"target\");\n+            else\n+                target = Path.of(\"target\");\n+\n+            Set<CopyOption> optionSet = new HashSet();\n+            if (replaceExisting)\n+                optionSet.add(REPLACE_EXISTING);\n+            if (op == OpType.COPY && !followLinks)\n+                optionSet.add(NOFOLLOW_LINKS);\n+            CopyOption[] options = optionSet.toArray(new CopyOption[0]);\n+\n+            final Path src = source;\n+            final Path dst = target;\n+            if (type == PathType.FILE) {\n+                if (op == OpType.COPY) {\n+                    try {\n+                        Files.copy(source, target, options);\n+                        assert Files.exists(target);\n+                    } catch (AccessDeniedException ade) {\n+                        assertTrue(mode.charAt(0) != 'r');\n+                    } catch (FileAlreadyExistsException faee) {\n+                        assertTrue(targetExists && !replaceExisting);\n+                    }\n+                    if (targetExists && mode.charAt(0) == '-')\n+                        assertTrue(Files.exists(target));\n+                } else if (!replaceExisting && targetExists) {\n+                    assertThrows(FileAlreadyExistsException.class,\n+                                 () -> Files.move(src, dst, options));\n+                } else {\n+                    Files.move(source, target, options);\n+                    assert Files.exists(target);\n+                }\n+            } else if (type == PathType.DIR) {\n+                if (op == OpType.COPY) {\n+                    try {\n+                        Files.copy(source, target, options);\n+                        assert Files.exists(target);\n+                    } catch (AccessDeniedException ade) {\n+                        assertTrue(mode.charAt(0) != 'r');\n+                    } catch (FileAlreadyExistsException faee) {\n+                        assertTrue(targetExists && !replaceExisting);\n+                    }\n+                    if (targetExists && mode.charAt(0) == '-')\n+                        assertTrue(Files.exists(target));\n+                } else {\n+                    try {\n+                        Files.move(source, target, options);\n+                        assert Files.exists(target);\n+                    } catch (AccessDeniedException ade) {\n+                        assertTrue(mode.charAt(1) != 'w');\n+                    } catch (FileAlreadyExistsException faee) {\n+                        assertTrue(targetExists && !replaceExisting);\n+                    }\n+                }\n+            } else if (type == PathType.LINK) {\n+                if (op == OpType.COPY) {\n+                    try {\n+                        Files.copy(source, target, options);\n+                        assert Files.exists(target);\n+                    } catch (AccessDeniedException ade) {\n+                        assertTrue(mode.charAt(0) != 'r');\n+                    } catch (FileAlreadyExistsException faee) {\n+                        assertTrue(targetExists && !replaceExisting);\n+                    }\n+                } else {\n+                    try {\n+                        Files.move(source, target, options);\n+                        assert Files.exists(target);\n+                    } catch (AccessDeniedException ade) {\n+                        assertTrue(mode.charAt(0) != 'r');\n+                    } catch (FileAlreadyExistsException faee) {\n+                        assertTrue(targetExists && !replaceExisting);\n+                    }\n+                }\n+            } else {\n+                assert false;\n+            }\n+        } finally {\n+            try {\n+                if (source != null)\n+                    Files.deleteIfExists(source);\n+            } catch (IOException x) {\n+            }\n+            try {\n+                if (target != null)\n+                    Files.deleteIfExists(target);\n+            } catch (IOException x) {\n+            }\n+            try {\n+                if (linkTarget != null)\n+                    Files.deleteIfExists(linkTarget);\n+            } catch (IOException x) {\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/Files\/CopyMoveVariations.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"}]}