{"files":[{"patch":"@@ -330,1 +330,3 @@\n-  Atomic::dec(&_pending_threads, memory_order_release);\n+  Atomic::dec(&_pending_threads);\n+  \/\/ Trailing fence, used to make sure removal of the operation strictly\n+  \/\/ happened after we completed the operation.\n@@ -422,8 +424,0 @@\n-  class MatchOp {\n-    HandshakeOperation* _op;\n-   public:\n-    MatchOp(HandshakeOperation* op) : _op(op) {}\n-    bool operator()(HandshakeOperation* op) {\n-      return op == _op;\n-    }\n-  };\n@@ -434,1 +428,1 @@\n-HandshakeOperation* HandshakeState::pop_for_self() {\n+HandshakeOperation* HandshakeState::get_op_for_self() {\n@@ -437,1 +431,1 @@\n-  return _queue.pop();\n+  return _queue.peek();\n@@ -450,1 +444,1 @@\n-HandshakeOperation* HandshakeState::pop() {\n+HandshakeOperation* HandshakeState::get_op() {\n@@ -453,1 +447,8 @@\n-  return _queue.pop(non_self_queue_filter);\n+  return _queue.peek(non_self_queue_filter);\n+};\n+\n+void HandshakeState::remove_op(HandshakeOperation* op) {\n+  assert(_lock.owned_by_self(), \"Lock must be held\");\n+  MatchOp mo(op);\n+  HandshakeOperation* ret = _queue.pop(mo);\n+  assert(ret == op, \"Popped op must match requested op\");\n@@ -472,1 +473,1 @@\n-  while (should_process()) {\n+  while (has_operation()) {\n@@ -474,1 +475,1 @@\n-    HandshakeOperation* op = pop_for_self();\n+    HandshakeOperation* op = get_op_for_self();\n@@ -484,1 +485,2 @@\n-        op->do_handshake(_handshakee);\n+        op->do_handshake(_handshakee); \/\/ acquire, op removed after\n+        remove_op(op);\n@@ -489,1 +491,2 @@\n-        op->do_handshake(_handshakee);\n+        op->do_handshake(_handshakee); \/\/ acquire, op removed after\n+        remove_op(op);\n@@ -534,0 +537,1 @@\n+    OrderAccess::loadload(); \/\/ Matches the implicit storestore in add_operation()\n@@ -568,2 +572,1 @@\n-  HandshakeState::ProcessResult pr_ret = HandshakeState::_processed;\n-  int executed = 0;\n+  HandshakeOperation* op = get_op();\n@@ -571,12 +574,3 @@\n-  do {\n-    HandshakeOperation* op = pop();\n-    if (op != NULL) {\n-      assert(SafepointMechanism::local_poll_armed(_handshakee), \"Must be\");\n-      assert(op->_target == NULL || _handshakee == op->_target, \"Wrong thread\");\n-      log_trace(handshake)(\"Processing handshake \" INTPTR_FORMAT \" by %s(%s)\", p2i(op),\n-                           op == match_op ? \"handshaker\" : \"cooperative\",\n-                           current_thread->is_VM_thread() ? \"VM Thread\" : \"JavaThread\");\n-\n-      if (op == match_op) {\n-        pr_ret = HandshakeState::_succeeded;\n-      }\n+  assert(op != NULL, \"Must have an op\");\n+  assert(SafepointMechanism::local_poll_armed(_handshakee), \"Must be\");\n+  assert(op->_target == NULL || _handshakee == op->_target, \"Wrong thread\");\n@@ -584,1 +578,3 @@\n-      op->prepare(_handshakee, current_thread);\n+  log_trace(handshake)(\"Processing handshake \" INTPTR_FORMAT \" by %s(%s)\", p2i(op),\n+                       op == match_op ? \"handshaker\" : \"cooperative\",\n+                       current_thread->is_VM_thread() ? \"VM Thread\" : \"JavaThread\");\n@@ -586,3 +582,1 @@\n-      _active_handshaker = current_thread;\n-      op->do_handshake(_handshakee);\n-      _active_handshaker = NULL;\n+  op->prepare(_handshakee, current_thread);\n@@ -590,3 +584,4 @@\n-      executed++;\n-    }\n-  } while (have_non_self_executable_operation());\n+  set_active_handshaker(current_thread);\n+  op->do_handshake(_handshakee); \/\/ acquire, op removed after\n+  set_active_handshaker(NULL);\n+  remove_op(op);\n@@ -596,1 +591,1 @@\n-  log_trace(handshake)(\"%s(\" INTPTR_FORMAT \") executed %d ops for JavaThread: \" INTPTR_FORMAT \" %s target op: \" INTPTR_FORMAT,\n+  log_trace(handshake)(\"%s(\" INTPTR_FORMAT \") executed an op for JavaThread: \" INTPTR_FORMAT \" %s target op: \" INTPTR_FORMAT,\n@@ -598,3 +593,4 @@\n-                       p2i(current_thread), executed, p2i(_handshakee),\n-                       pr_ret == HandshakeState::_succeeded ? \"including\" : \"excluding\", p2i(match_op));\n-  return pr_ret;\n+                       p2i(current_thread), p2i(_handshakee),\n+                       op == match_op ? \"including\" : \"excluding\", p2i(match_op));\n+\n+  return op == match_op ? HandshakeState::_succeeded : HandshakeState::_processed;\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":38,"deletions":42,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/orderAccess.hpp\"\n@@ -88,1 +89,1 @@\n-  Thread* _active_handshaker;\n+  Thread* volatile _active_handshaker;\n@@ -102,2 +103,14 @@\n-  HandshakeOperation* pop_for_self();\n-  HandshakeOperation* pop();\n+  HandshakeOperation* get_op_for_self();\n+  HandshakeOperation* get_op();\n+  void remove_op(HandshakeOperation* op);\n+\n+  void set_active_handshaker(Thread* thread) { Atomic::store(&_active_handshaker, thread); }\n+\n+  class MatchOp {\n+    HandshakeOperation* _op;\n+   public:\n+    MatchOp(HandshakeOperation* op) : _op(op) {}\n+    bool operator()(HandshakeOperation* op) {\n+      return op == _op;\n+    }\n+  };\n@@ -116,22 +129,0 @@\n-  \/\/ Both _queue and _lock must be checked. If a thread has seen this _handshakee\n-  \/\/ as safe it will execute all possible handshake operations in a loop while\n-  \/\/ holding _lock. We use lock free addition to the queue, which means it is\n-  \/\/ possible for the queue to be seen as empty by _handshakee but as non-empty\n-  \/\/ by the thread executing in the loop. To avoid the _handshakee continuing\n-  \/\/ while handshake operations are being executed, the _handshakee\n-  \/\/ must take slow path, process_by_self(), if _lock is held.\n-  bool should_process() {\n-    \/\/ The holder of the _lock can add an asynchronous handshake to queue.\n-    \/\/ To make sure it is seen by the handshakee, the handshakee must first\n-    \/\/ check the _lock, and if held go to slow path.\n-    \/\/ Since the handshakee is unsafe if _lock gets locked after this check\n-    \/\/ we know other threads cannot process any handshakes.\n-    \/\/ Now we can check the queue to see if there is anything we should processs.\n-    if (_lock.is_locked()) {\n-      return true;\n-    }\n-    \/\/ Lock check must be done before queue check, force ordering.\n-    OrderAccess::loadload();\n-    return !_queue.is_empty();\n-  }\n-\n@@ -150,1 +141,1 @@\n-  Thread* active_handshaker() const { return _active_handshaker; }\n+  Thread* active_handshaker() const { return Atomic::load(&_active_handshaker); }\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":17,"deletions":26,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-    need_rechecking = thread->handshake_state()->should_process() && thread->handshake_state()->process_by_self();\n+    need_rechecking = thread->handshake_state()->has_operation() && thread->handshake_state()->process_by_self();\n@@ -116,0 +116,1 @@\n+  assert(thread == Thread::current(), \"Must be\");\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-  \/\/ Same as pop(MATCH_FUNC& match_func) but matches everything, thus returning\n+  \/\/ Same as peek(MATCH_FUNC& match_func) but matches everything, thus returning\n@@ -72,2 +72,2 @@\n-  E pop() {\n-    return pop(match_all);\n+  E peek() {\n+    return peek(match_all);\n@@ -84,0 +84,3 @@\n+\n+  template <typename MATCH_FUNC>\n+  E peek(MATCH_FUNC& match_func);\n","filename":"src\/hotspot\/share\/utilities\/filterQueue.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,0 +115,25 @@\n+\/\/ MT-Unsafe, external serialization needed.\n+template <class E>\n+template <typename MATCH_FUNC>\n+E FilterQueue<E>::peek(MATCH_FUNC& match_func) {\n+  Node*  first       = load_first();\n+  Node*  cur         = first;\n+  Node*  match       = NULL;\n+\n+  if (cur == NULL) {\n+    return (E)NULL;\n+  }\n+  do {\n+    if (match_func(cur->_data)) {\n+      match = cur;\n+    }\n+    cur = cur->_next;\n+  } while (cur != NULL);\n+\n+  if (match == NULL) {\n+    return (E)NULL;\n+  }\n+\n+  return (E)match->_data;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/filterQueue.inline.hpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,2 @@\n+  EXPECT_EQ(queue.peek(match_1), (uintptr_t)0) << \"Must be empty.\";\n+  EXPECT_EQ(queue.peek(match_all), (uintptr_t)0) << \"Must be empty.\";\n@@ -71,0 +73,3 @@\n+  EXPECT_EQ(queue.peek(match_1), (uintptr_t)1) << \"Must match 1.\";\n+  EXPECT_NE(queue.peek(match_all), (uintptr_t)0) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.peek(match_even), (uintptr_t)0) << \"Must not contain a value.\";\n@@ -87,0 +92,5 @@\n+  EXPECT_EQ(queue.peek(match_1), (uintptr_t)1) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.peek(match_2), (uintptr_t)2) << \"Must contain a value.\";\n+  EXPECT_NE(queue.peek(match_all), (uintptr_t)0) << \"Must contain a value.\";\n+  EXPECT_NE(queue.peek(match_even), (uintptr_t)0) << \"Must contain a value.\";\n+\n@@ -95,0 +105,5 @@\n+  EXPECT_EQ(queue.peek(match_1), (uintptr_t)0) << \"Must not contain a value.\";\n+  EXPECT_EQ(queue.peek(match_2), (uintptr_t)2) << \"Must contain a value.\";\n+  EXPECT_NE(queue.peek(match_all), (uintptr_t)0) << \"Must contain a value.\";\n+  EXPECT_NE(queue.peek(match_even), (uintptr_t)0) << \"Must contain a value.\";\n+\n@@ -97,0 +112,1 @@\n+  EXPECT_EQ(queue.peek(match_even), (uintptr_t)2) << \"Must not be empty.\";\n@@ -109,0 +125,5 @@\n+  EXPECT_EQ(queue.peek(match_3), (uintptr_t)3) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.peek(match_2), (uintptr_t)0) << \"Must be empty.\";\n+  EXPECT_EQ(queue.peek(match_all), (uintptr_t)3) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.peek(match_even), (uintptr_t)0) << \"Must be empty.\";\n+\n@@ -131,0 +152,3 @@\n+  EXPECT_EQ(queue.peek(match_even), (uintptr_t)2) << \"Must not be empty.\";\n+  EXPECT_EQ(queue.peek(match_all), (uintptr_t)1) << \"Must not be empty.\";\n+\n@@ -163,0 +187,1 @@\n+        while (_fq->peek(*this) == 0) {}\n","filename":"test\/hotspot\/gtest\/utilities\/test_filterQueue.cpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"}]}