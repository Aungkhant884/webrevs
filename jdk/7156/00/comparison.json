{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -672,1 +672,1 @@\n-                    if (Code.truncate(typecode) == INTcode)\n+                    if (Code.truncate(typecode) == INTcode && typecode != CHARcode)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Items.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8280067\n+ * @summary Verify constant\/immediate char values are correctly enhanced to ints when used in unary\n+ *          operators\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.code\n+ *          jdk.compiler\/com.sun.tools.javac.comp\n+ *          jdk.compiler\/com.sun.tools.javac.jvm\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.tree\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.jdeps\/com.sun.tools.classfile\n+ *          jdk.jdeps\/com.sun.tools.javap\n+ * @build toolbox.JarTask toolbox.JavacTask toolbox.JavapTask toolbox.ToolBox\n+ * @compile CharImmediateValue.java\n+ * @run main CharImmediateValue\n+ *\/\n+\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+\n+import com.sun.source.util.JavacTask;\n+import com.sun.source.util.Plugin;\n+import com.sun.source.util.TaskEvent;\n+import com.sun.source.util.TaskListener;\n+\n+import com.sun.tools.classfile.Attribute;\n+import com.sun.tools.classfile.ClassFile;\n+import com.sun.tools.classfile.Code_attribute;\n+import com.sun.tools.classfile.Instruction;\n+import com.sun.tools.classfile.Opcode;\n+\n+import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;\n+import com.sun.tools.javac.tree.JCTree.JCIdent;\n+import com.sun.tools.javac.tree.TreeScanner;\n+\n+import toolbox.JarTask;\n+import toolbox.ToolBox;\n+\n+\n+public class CharImmediateValue implements Plugin {\n+    public static void main(String... args) throws Exception {\n+        new CharImmediateValue().runSourceTest();\n+        new CharImmediateValue().runReplacementTest();\n+    }\n+\n+    void runSourceTest() throws Exception {\n+        int param = 0;\n+        Character var = (char) -(false ? (char) param : (char) 2);\n+    }\n+\n+    void runReplacementTest() throws Exception {\n+        ToolBox tb = new ToolBox();\n+        Path pluginClasses = Path.of(\"plugin-classes\");\n+        tb.writeFile(pluginClasses.resolve(\"META-INF\").resolve(\"services\").resolve(Plugin.class.getName()),\n+                CharImmediateValue.class.getName() + System.lineSeparator());\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(Path.of(ToolBox.testClasses))) {\n+            for (Path p : ds) {\n+                if (p.getFileName().toString().startsWith(\"CharImmediateValue\") ||\n+                    p.getFileName().toString().endsWith(\".class\")) {\n+                    Files.copy(p, pluginClasses.resolve(p.getFileName()));\n+                }\n+            }\n+        }\n+\n+        Path pluginJar = Path.of(\"plugin.jar\");\n+        new JarTask(tb, pluginJar)\n+                .baseDir(pluginClasses)\n+                .files(\".\")\n+                .run();\n+\n+        Path src = Path.of(\"src\");\n+            tb.writeJavaFiles(src,\n+                    \"\"\"\n+                    public class Test{\n+                        private static char replace; \/\/this will be replace with a constant \"1\" after constant folding is done\n+                        public static String run() {\n+                            char c = (char) - replace;\n+                            if (c < 0) {\n+                                throw new AssertionError(\"Incorrect value!\");\n+                            } else {\n+                                return Integer.toString(c);\n+                            }\n+                        }\n+                    }\n+                    \"\"\");\n+        Path classes = Files.createDirectories(Path.of(\"classes\"));\n+\n+        new toolbox.JavacTask(tb)\n+                .classpath(pluginJar)\n+                .options(\"-XDaccessInternalAPI\")\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run()\n+                .writeAll();\n+\n+        URLClassLoader cl = new URLClassLoader(new URL[] {classes.toUri().toURL()});\n+\n+        String actual = (String) cl.loadClass(\"Test\")\n+                                   .getMethod(\"run\")\n+                                   .invoke(null);\n+        String expected = \"65535\";\n+        if (!Objects.equals(actual, expected)) {\n+            throw new AssertionError(\"expected: \" + expected + \"; but got: \" + actual);\n+        }\n+\n+        Path testClass = classes.resolve(\"Test.class\");\n+        ClassFile cf = ClassFile.read(testClass);\n+        Code_attribute codeAttr =\n+                (Code_attribute) cf.methods[1].attributes.get(Attribute.Code);\n+        boolean seenCast = false;\n+        for (Instruction i : codeAttr.getInstructions()) {\n+            if (i.getOpcode() == Opcode.I2C) {\n+                seenCast = true;\n+            }\n+        }\n+        if (!seenCast) {\n+            throw new AssertionError(\"Missing cast!\");\n+        }\n+    }\n+\n+    \/\/ Plugin impl...\n+\n+    @Override\n+    public String getName() { return \"CharImmediateValue\"; }\n+\n+    @Override\n+    public void init(JavacTask task, String... args) {\n+        task.addTaskListener(new TaskListener() {\n+            @Override\n+            public void started(TaskEvent e) {\n+                if (e.getKind() == TaskEvent.Kind.GENERATE) {\n+                    convert((JCCompilationUnit) e.getCompilationUnit());\n+                }\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public boolean autoStart() {\n+        return true;\n+    }\n+\n+    private void convert(JCCompilationUnit toplevel) {\n+        new TreeScanner() {\n+            @Override\n+            public void visitIdent(JCIdent tree) {\n+                if (tree.name.contentEquals(\"replace\")) {\n+                    tree.type = tree.type.constType(1);\n+                }\n+                super.visitIdent(tree);\n+            }\n+        }.scan(toplevel);\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/code\/CharImmediateValue.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"}]}