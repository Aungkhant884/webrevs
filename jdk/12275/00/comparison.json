{"files":[{"patch":"@@ -31,1 +31,0 @@\n-#include \"utilities\/hashtable.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,257 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"classfile\/dictionary.hpp\"\n-#include \"classfile\/javaClasses.inline.hpp\"\n-#include \"classfile\/vmClasses.hpp\"\n-#include \"code\/nmethod.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"oops\/symbol.hpp\"\n-#include \"oops\/weakHandle.inline.hpp\"\n-#include \"prims\/jvmtiTagMapTable.hpp\"\n-#include \"runtime\/safepoint.hpp\"\n-#include \"utilities\/dtrace.hpp\"\n-#include \"utilities\/hashtable.hpp\"\n-#include \"utilities\/hashtable.inline.hpp\"\n-#include \"utilities\/numberSeq.hpp\"\n-\n-\/\/ This hashtable is implemented as an open hash table with a fixed number of buckets.\n-\n-\/\/ Hashtable entry allocates in the C heap directly.\n-\n-template <MEMFLAGS F> BasicHashtableEntry<F>* BasicHashtable<F>::new_entry(unsigned int hashValue) {\n-  BasicHashtableEntry<F>* entry = ::new (NEW_C_HEAP_ARRAY(char, this->entry_size(), F))\n-                                        BasicHashtableEntry<F>(hashValue);\n-  return entry;\n-}\n-\n-\n-template <class T, MEMFLAGS F> HashtableEntry<T, F>* Hashtable<T, F>::new_entry(unsigned int hashValue, T obj) {\n-  HashtableEntry<T, F>* entry = ::new (NEW_C_HEAP_ARRAY(char, this->entry_size(), F))\n-                                      HashtableEntry<T, F>(hashValue, obj);\n-  return entry;\n-}\n-\n-template <MEMFLAGS F> inline void BasicHashtable<F>::free_entry(BasicHashtableEntry<F>* entry) {\n-  \/\/ Unlink from the Hashtable prior to freeing\n-  unlink_entry(entry);\n-  FREE_C_HEAP_ARRAY(char, entry);\n-  JFR_ONLY(_stats_rate.remove();)\n-}\n-\n-\n-template <MEMFLAGS F> void BasicHashtable<F>::free_buckets() {\n-  FREE_C_HEAP_ARRAY(HashtableBucket, _buckets);\n-  _buckets = nullptr;\n-}\n-\n-\/\/ Default overload, for types that are uninteresting.\n-template<typename T> static size_t literal_size(T) { return 0; }\n-\n-static size_t literal_size(oop obj) {\n-  if (obj == nullptr) {\n-    return 0;\n-  }\n-\n-  size_t word_size = obj->size();\n-\n-  if (obj->klass() == vmClasses::String_klass()) {\n-    \/\/ This may overcount if String.value arrays are shared.\n-    word_size += java_lang_String::value(obj)->size();\n-  }\n-\n-  return word_size * HeapWordSize;\n-}\n-\n-static size_t literal_size(WeakHandle v) {\n-  return literal_size(v.peek());\n-}\n-\n-const double _resize_factor    = 2.0;     \/\/ by how much we will resize using current number of entries\n-const int _small_table_sizes[] = { 107, 1009, 2017, 4049, 5051, 10103, 20201, 40423 } ;\n-const int _small_array_size = sizeof(_small_table_sizes)\/sizeof(int);\n-\n-\/\/ possible hashmap sizes - odd primes that roughly double in size.\n-\/\/ To avoid excessive resizing the odd primes from 4801-76831 and\n-\/\/ 76831-307261 have been removed.\n-const int _large_table_sizes[] =  { 4801, 76831, 307261, 614563, 1228891,\n-    2457733, 4915219, 9830479, 19660831, 39321619, 78643219 };\n-const int _large_array_size = sizeof(_large_table_sizes)\/sizeof(int);\n-\n-\/\/ Calculate next \"good\" hashtable size based on requested count\n-template <MEMFLAGS F> int BasicHashtable<F>::calculate_resize(bool use_large_table_sizes) const {\n-  int requested = (int)(_resize_factor*number_of_entries());\n-  const int* primelist = use_large_table_sizes ? _large_table_sizes : _small_table_sizes;\n-  int arraysize =  use_large_table_sizes ? _large_array_size  : _small_array_size;\n-  int newsize;\n-  for (int i = 0; i < arraysize; i++) {\n-    newsize = primelist[i];\n-    if (newsize >= requested)\n-      break;\n-  }\n-  return newsize;\n-}\n-\n-template <MEMFLAGS F> bool BasicHashtable<F>::resize(int new_size) {\n-\n-  \/\/ Allocate new buckets\n-  HashtableBucket<F>* buckets_new = NEW_C_HEAP_ARRAY2_RETURN_NULL(HashtableBucket<F>, new_size, F, CURRENT_PC);\n-  if (buckets_new == nullptr) {\n-    return false;\n-  }\n-\n-  \/\/ Clear the new buckets\n-  for (int i = 0; i < new_size; i++) {\n-    buckets_new[i].clear();\n-  }\n-\n-  int table_size_old = _table_size;\n-  \/\/ hash_to_index() uses _table_size, so switch the sizes now\n-  _table_size = new_size;\n-\n-  \/\/ Move entries from the old table to a new table\n-  for (int index_old = 0; index_old < table_size_old; index_old++) {\n-    for (BasicHashtableEntry<F>* p = _buckets[index_old].get_entry(); p != nullptr; ) {\n-      BasicHashtableEntry<F>* next = p->next();\n-      int index_new = hash_to_index(p->hash());\n-\n-      p->set_next(buckets_new[index_new].get_entry());\n-      buckets_new[index_new].set_entry(p);\n-      p = next;\n-    }\n-  }\n-\n-  \/\/ The old backets now can be released\n-  BasicHashtable<F>::free_buckets();\n-\n-  \/\/ Switch to the new storage\n-  _buckets = buckets_new;\n-\n-  return true;\n-}\n-\n-template <MEMFLAGS F> bool BasicHashtable<F>::maybe_grow(int max_size, int load_factor) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be at safepoint\");\n-\n-  if (table_size() >= max_size) {\n-    return false;\n-  }\n-  if (number_of_entries() \/ table_size() > load_factor) {\n-    resize(MIN2<int>(table_size() * 2, max_size));\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}\n-\n-template <class T, MEMFLAGS F> TableStatistics Hashtable<T, F>::statistics_calculate(T (*literal_load_barrier)(HashtableEntry<T, F>*)) {\n-  NumberSeq summary;\n-  size_t literal_bytes = 0;\n-  for (int i = 0; i < this->table_size(); ++i) {\n-    int count = 0;\n-    for (HashtableEntry<T, F>* e = this->bucket(i);\n-         e != nullptr; e = e->next()) {\n-      count++;\n-      T l = (literal_load_barrier != nullptr) ? literal_load_barrier(e) : e->literal();\n-      literal_bytes += literal_size(l);\n-    }\n-    summary.add((double)count);\n-  }\n-  return TableStatistics(this->_stats_rate, summary, literal_bytes, sizeof(HashtableBucket<F>), sizeof(HashtableEntry<T, F>));\n-}\n-\n-\/\/ Dump footprint and bucket length statistics\n-template <class T, MEMFLAGS F> void Hashtable<T, F>::print_table_statistics(outputStream* st,\n-                                                                            const char *table_name,\n-                                                                            T (*literal_load_barrier)(HashtableEntry<T, F>*)) {\n-  TableStatistics ts = statistics_calculate(literal_load_barrier);\n-  ts.print(st, table_name);\n-}\n-\n-#ifndef PRODUCT\n-template <class T> static void print_literal(T const& l) { l.print(); }\n-template <class T> static void print_literal(T* l) { print_literal(*l); }\n-\n-template <class T, MEMFLAGS F> void Hashtable<T, F>::print() {\n-  ResourceMark rm;\n-\n-  for (int i = 0; i < BasicHashtable<F>::table_size(); i++) {\n-    HashtableEntry<T, F>* entry = bucket(i);\n-    while(entry != nullptr) {\n-      tty->print(\"%d : \", i);\n-      print_literal(entry->literal());\n-      tty->cr();\n-      entry = entry->next();\n-    }\n-  }\n-}\n-\n-template <MEMFLAGS F>\n-template <class T> void BasicHashtable<F>::verify_table(const char* table_name) {\n-  int element_count = 0;\n-  int max_bucket_count = 0;\n-  int max_bucket_number = 0;\n-  for (int index = 0; index < table_size(); index++) {\n-    int bucket_count = 0;\n-    for (T* probe = (T*)bucket(index); probe != nullptr; probe = probe->next()) {\n-      probe->verify();\n-      bucket_count++;\n-    }\n-    element_count += bucket_count;\n-    if (bucket_count > max_bucket_count) {\n-      max_bucket_count = bucket_count;\n-      max_bucket_number = index;\n-    }\n-  }\n-  guarantee(number_of_entries() == element_count,\n-            \"Verify of %s failed\", table_name);\n-\n-  \/\/ Log some statistics about the hashtable\n-  log_info(hashtables)(\"%s max bucket size %d bucket %d element count %d table size %d\", table_name,\n-                       max_bucket_count, max_bucket_number, _number_of_entries, _table_size);\n-  if (_number_of_entries > 0 && log_is_enabled(Debug, hashtables)) {\n-    for (int index = 0; index < table_size(); index++) {\n-      int bucket_count = 0;\n-      for (T* probe = (T*)bucket(index); probe != nullptr; probe = probe->next()) {\n-        log_debug(hashtables)(\"bucket %d hash \" INTPTR_FORMAT, index, (intptr_t)probe->hash());\n-        bucket_count++;\n-      }\n-      if (bucket_count > 0) {\n-        log_debug(hashtables)(\"bucket %d count %d\", index, bucket_count);\n-      }\n-    }\n-  }\n-}\n-#endif \/\/ PRODUCT\n-\n-\/\/ Explicitly instantiate these types\n-template class BasicHashtable<mtGC>;\n-template class BasicHashtable<mtServiceability>;\n-\n-template class Hashtable<nmethod*, mtGC>;\n-template class Hashtable<WeakHandle, mtServiceability>;\n","filename":"src\/hotspot\/share\/utilities\/hashtable.cpp","additions":0,"deletions":257,"binary":false,"changes":257,"status":"deleted"},{"patch":"@@ -1,223 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_UTILITIES_HASHTABLE_HPP\n-#define SHARE_UTILITIES_HASHTABLE_HPP\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"oops\/symbol.hpp\"\n-#include \"runtime\/handles.hpp\"\n-#include \"utilities\/tableStatistics.hpp\"\n-\n-\/\/ This is a generic hashtable which is implemented as an open hash table with\n-\/\/ a fixed number of buckets.\n-\n-template <MEMFLAGS F> class BasicHashtableEntry {\n-  friend class VMStructs;\n-private:\n-  unsigned int         _hash;           \/\/ 32-bit hash for item\n-\n-  \/\/ Link to next element in the linked list for this bucket.\n-  BasicHashtableEntry<F>* _next;\n-\n-public:\n-  BasicHashtableEntry(unsigned int hashValue) : _hash(hashValue), _next(nullptr) {}\n-  \/\/ Still should not call this. Entries are placement new allocated, so are\n-  \/\/ deleted with free_entry.\n-  ~BasicHashtableEntry() { ShouldNotReachHere(); }\n-\n-  unsigned int hash() const             { return _hash; }\n-  void set_hash(unsigned int hash)      { _hash = hash; }\n-  unsigned int* hash_addr()             { return &_hash; }\n-\n-  BasicHashtableEntry<F>* next() const {\n-    return _next;\n-  }\n-\n-  void set_next(BasicHashtableEntry<F>* next) {\n-    _next = next;\n-  }\n-\n-  BasicHashtableEntry<F>** next_addr() {\n-    return &_next;\n-  }\n-};\n-\n-\n-\n-template <class T, MEMFLAGS F> class HashtableEntry : public BasicHashtableEntry<F> {\n-  friend class VMStructs;\n-private:\n-  T               _literal;          \/\/ ref to item in table.\n-\n-public:\n-  HashtableEntry(unsigned int hashValue, T value) : BasicHashtableEntry<F>(hashValue), _literal(value) {}\n-\n-  \/\/ Literal\n-  T literal() const                   { return _literal; }\n-  T* literal_addr()                   { return &_literal; }\n-  void set_literal(T s)               { _literal = s; }\n-\n-  HashtableEntry* next() const {\n-    return (HashtableEntry*)BasicHashtableEntry<F>::next();\n-  }\n-  HashtableEntry** next_addr() {\n-    return (HashtableEntry**)BasicHashtableEntry<F>::next_addr();\n-  }\n-};\n-\n-\n-\n-template <MEMFLAGS F> class HashtableBucket : public CHeapObj<F> {\n-  friend class VMStructs;\n-private:\n-  \/\/ Instance variable\n-  BasicHashtableEntry<F>*       _entry;\n-\n-public:\n-  \/\/ Accessing\n-  void clear()                        { _entry = nullptr; }\n-\n-  \/\/ The following methods use order access methods to avoid race\n-  \/\/ conditions in multiprocessor systems.\n-  BasicHashtableEntry<F>* get_entry() const;\n-  void set_entry(BasicHashtableEntry<F>* l);\n-\n-  \/\/ The following method is not MT-safe and must be done under lock.\n-  BasicHashtableEntry<F>** entry_addr()  { return &_entry; }\n-\n-};\n-\n-\n-template <MEMFLAGS F> class BasicHashtable : public CHeapObj<F> {\n-  friend class VMStructs;\n-\n-public:\n-  BasicHashtable(int table_size, int entry_size);\n-  BasicHashtable(int table_size, int entry_size,\n-                 HashtableBucket<F>* buckets, int number_of_entries);\n-  ~BasicHashtable();\n-\n-  \/\/ Bucket handling\n-  int hash_to_index(unsigned int full_hash) const {\n-    int h = full_hash % _table_size;\n-    assert(h >= 0 && h < _table_size, \"Illegal hash value\");\n-    return h;\n-  }\n-\n-private:\n-  \/\/ Instance variables\n-  int                              _table_size;\n-  HashtableBucket<F>*              _buckets;\n-  int                              _entry_size;\n-  volatile int                     _number_of_entries;\n-\n-protected:\n-\n-  TableRateStatistics _stats_rate;\n-\n-  void initialize(int table_size, int entry_size, int number_of_entries);\n-\n-  \/\/ Accessor\n-  int entry_size() const { return _entry_size; }\n-\n-  \/\/ The following method is MT-safe and may be used with caution.\n-  BasicHashtableEntry<F>* bucket(int i) const;\n-\n-  \/\/ The following method is not MT-safe and must be done under lock.\n-  BasicHashtableEntry<F>** bucket_addr(int i) { return _buckets[i].entry_addr(); }\n-\n-  \/\/ Table entry management\n-  BasicHashtableEntry<F>* new_entry(unsigned int hashValue);\n-\n-  \/\/ Used when moving the entry to another table or deleting entry.\n-  \/\/ Clean up links.\n-  void unlink_entry(BasicHashtableEntry<F>* entry) {\n-    entry->set_next(nullptr);\n-    --_number_of_entries;\n-  }\n-\n-  \/\/ Free the buckets in this hashtable\n-  void free_buckets();\n-public:\n-  int table_size() const { return _table_size; }\n-  void set_entry(int index, BasicHashtableEntry<F>* entry);\n-\n-  void add_entry(int index, BasicHashtableEntry<F>* entry);\n-\n-  void free_entry(BasicHashtableEntry<F>* entry);\n-\n-  int number_of_entries() const { return _number_of_entries; }\n-\n-  int calculate_resize(bool use_large_table_sizes) const;\n-  bool resize(int new_size);\n-\n-  \/\/ Grow the number of buckets if the average entries per bucket is over the load_factor\n-  bool maybe_grow(int max_size, int load_factor = 8);\n-\n-  template <class T> void verify_table(const char* table_name) PRODUCT_RETURN;\n-};\n-\n-\n-template <class T, MEMFLAGS F> class Hashtable : public BasicHashtable<F> {\n-  friend class VMStructs;\n-\n-public:\n-  Hashtable(int table_size, int entry_size)\n-    : BasicHashtable<F>(table_size, entry_size) { }\n-\n-  Hashtable(int table_size, int entry_size,\n-                   HashtableBucket<F>* buckets, int number_of_entries)\n-    : BasicHashtable<F>(table_size, entry_size, buckets, number_of_entries) { }\n-\n-  \/\/ Debugging\n-  void print()               PRODUCT_RETURN;\n-\n-  unsigned int compute_hash(const Symbol* name) const {\n-    return (unsigned int) name->identity_hash();\n-  }\n-\n-  int index_for(const Symbol* name) const {\n-    return this->hash_to_index(compute_hash(name));\n-  }\n-\n-  TableStatistics statistics_calculate(T (*literal_load_barrier)(HashtableEntry<T, F>*) = nullptr);\n-  void print_table_statistics(outputStream* st, const char *table_name, T (*literal_load_barrier)(HashtableEntry<T, F>*) = nullptr);\n-\n- protected:\n-\n-  HashtableEntry<T, F>* new_entry(unsigned int hashValue, T obj);\n-\n-  \/\/ The following method is MT-safe and may be used with caution.\n-  HashtableEntry<T, F>* bucket(int i) const {\n-    return (HashtableEntry<T, F>*)BasicHashtable<F>::bucket(i);\n-  }\n-\n-  \/\/ The following method is not MT-safe and must be done under lock.\n-  HashtableEntry<T, F>** bucket_addr(int i) {\n-    return (HashtableEntry<T, F>**)BasicHashtable<F>::bucket_addr(i);\n-  }\n-};\n-\n-#endif \/\/ SHARE_UTILITIES_HASHTABLE_HPP\n","filename":"src\/hotspot\/share\/utilities\/hashtable.hpp","additions":0,"deletions":223,"binary":false,"changes":223,"status":"deleted"},{"patch":"@@ -1,115 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_UTILITIES_HASHTABLE_INLINE_HPP\n-#define SHARE_UTILITIES_HASHTABLE_INLINE_HPP\n-\n-#include \"utilities\/hashtable.hpp\"\n-\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"services\/memTracker.hpp\"\n-\n-\/\/ Inline function definitions for hashtable.hpp.\n-\n-\/\/ --------------------------------------------------------------------------\n-\n-\/\/ Initialize a table.\n-\n-template <MEMFLAGS F> inline BasicHashtable<F>::BasicHashtable(int table_size, int entry_size) {\n-  \/\/ Called on startup, no locking needed\n-  initialize(table_size, entry_size, 0);\n-  _buckets = NEW_C_HEAP_ARRAY2(HashtableBucket<F>, table_size, F, CURRENT_PC);\n-  for (int index = 0; index < _table_size; index++) {\n-    _buckets[index].clear();\n-  }\n-  _stats_rate = TableRateStatistics();\n-}\n-\n-\n-template <MEMFLAGS F> inline BasicHashtable<F>::BasicHashtable(int table_size, int entry_size,\n-                                      HashtableBucket<F>* buckets,\n-                                      int number_of_entries) {\n-\n-  \/\/ Called on startup, no locking needed\n-  initialize(table_size, entry_size, number_of_entries);\n-  _buckets = buckets;\n-  _stats_rate = TableRateStatistics();\n-}\n-\n-template <MEMFLAGS F> inline BasicHashtable<F>::~BasicHashtable() {\n-  free_buckets();\n-}\n-\n-template <MEMFLAGS F> inline void BasicHashtable<F>::initialize(int table_size, int entry_size,\n-                                       int number_of_entries) {\n-  \/\/ Called on startup, no locking needed\n-  _table_size = table_size;\n-  _entry_size = entry_size;\n-  _number_of_entries = number_of_entries;\n-}\n-\n-\n-\/\/ The following method is MT-safe and may be used with caution.\n-template <MEMFLAGS F> inline BasicHashtableEntry<F>* BasicHashtable<F>::bucket(int i) const {\n-  return _buckets[i].get_entry();\n-}\n-\n-\n-template <MEMFLAGS F> inline void HashtableBucket<F>::set_entry(BasicHashtableEntry<F>* l) {\n-  \/\/ Warning: Preserve store ordering.  The PackageEntryTable, ModuleEntryTable and\n-  \/\/          SystemDictionary are read without locks.  The new entry must be\n-  \/\/          complete before other threads can be allowed to see it\n-  \/\/          via a store to _buckets[index].\n-  Atomic::release_store(&_entry, l);\n-}\n-\n-\n-template <MEMFLAGS F> inline BasicHashtableEntry<F>* HashtableBucket<F>::get_entry() const {\n-  \/\/ Warning: Preserve load ordering.  The PackageEntryTable, ModuleEntryTable and\n-  \/\/          SystemDictionary are read without locks.  The new entry must be\n-  \/\/          complete before other threads can be allowed to see it\n-  \/\/          via a store to _buckets[index].\n-  return Atomic::load_acquire(&_entry);\n-}\n-\n-\n-template <MEMFLAGS F> inline void BasicHashtable<F>::set_entry(int index, BasicHashtableEntry<F>* entry) {\n-  _buckets[index].set_entry(entry);\n-  if (entry != nullptr) {\n-    JFR_ONLY(_stats_rate.add();)\n-  } else {\n-    JFR_ONLY(_stats_rate.remove();)\n-  }\n-}\n-\n-\n-template <MEMFLAGS F> inline void BasicHashtable<F>::add_entry(int index, BasicHashtableEntry<F>* entry) {\n-  entry->set_next(bucket(index));\n-  _buckets[index].set_entry(entry);\n-  ++_number_of_entries;\n-  JFR_ONLY(_stats_rate.add();)\n-}\n-\n-#endif \/\/ SHARE_UTILITIES_HASHTABLE_INLINE_HPP\n","filename":"src\/hotspot\/share\/utilities\/hashtable.inline.hpp","additions":0,"deletions":115,"binary":false,"changes":115,"status":"deleted"}]}