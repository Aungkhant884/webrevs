{"files":[{"patch":"@@ -69,2 +69,1 @@\n-import java.util.Collections;\n-import java.util.Map;\n+import java.util.*;\n@@ -72,4 +71,0 @@\n-import java.util.HashMap;\n-import java.util.IdentityHashMap;\n-import java.util.LinkedHashMap;\n-import java.util.Set;\n@@ -526,1 +521,3 @@\n-            JCCase previousC = null;\n+\n+            cases = patchCompletingNormallyCases(cases);\n+\n@@ -578,2 +575,1 @@\n-                        boolean hasGuard = c.guard != null;\n-                        if (hasGuard) {\n+                        if (c.guard != null) {\n@@ -590,4 +586,0 @@\n-                        if (previousC != null && hasGuard && previousCompletesNormally) {\n-                            previousC.stats = previousC.stats.appendList(c.stats); \/\/ copying to previous\n-                        }\n-\n@@ -602,1 +594,0 @@\n-                        previousC = c;\n@@ -643,1 +634,0 @@\n-\n@@ -668,0 +658,35 @@\n+\n+    \/\/ Duplicates the block statement where needed.\n+    \/\/ Processes cases in reverse order, e.g.\n+    \/\/ switch (obj) {\n+    \/\/     case Integer _ when ((Integer) obj) > 0:\n+    \/\/     case String _  when !((String) obj).isEmpty():\n+    \/\/         return 1;\n+    \/\/     ...\n+    \/\/ }\n+    \/\/ =>\n+    \/\/ switch (typeSwitch(...)) {\n+    \/\/     case 0:\n+    \/\/         if (!((Integer)obj) > 0) { ... }\n+    \/\/         return 1;\n+    \/\/     case 1:\n+    \/\/         if (!((String)obj).isEmpty()) { ... }\n+    \/\/         return 1;\n+    \/\/     ...\n+    \/\/ }\n+    private static List<JCCase> patchCompletingNormallyCases(List<JCCase> cases) {\n+        ListBuffer<JCCase> newCases = new ListBuffer<>();\n+        for (int j = cases.size() - 1; j >= 0; j--) {\n+            var currentCase = cases.get(j);\n+\n+            if (currentCase != cases.last() && currentCase.guard != null &&\n+                    currentCase.caseKind == CaseKind.STATEMENT &&\n+                    currentCase.completesNormally) {\n+                var nextCase = cases.get(j + 1);\n+                currentCase.stats = currentCase.stats.appendList(nextCase.stats);\n+            }\n+            newCases.add(currentCase);\n+        }\n+        return newCases.toList().reverse();\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":40,"deletions":15,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -36,1 +36,23 @@\n-            case String _ when !((String) obj).isEmpty():\n+            case String _  when !((String) obj).isEmpty():\n+                return 1;\n+            default:\n+                return -1;\n+        }\n+    }\n+\n+    int multipleGuardedCases2a(Object obj) {\n+        switch (obj) {\n+            case Integer _ when ((Integer) obj) > 0:\n+            case Float _   when ((Float) obj) > 0.0f:\n+            case String _  when !((String) obj).isEmpty():\n+                return 1;\n+            default:\n+                return -1;\n+        }\n+    }\n+\n+    int multipleGuardedCases2b(Object obj) {\n+        switch (obj) {\n+            case Float _   when ((Float) obj) > 0.0f: \/\/ reversing the order\n+            case Integer _ when ((Integer) obj) > 0:\n+            case String _  when !((String) obj).isEmpty():\n@@ -45,1 +67,1 @@\n-            case String _ when !((String) obj).isEmpty():\n+            case String _          when !((String) obj).isEmpty():\n@@ -70,0 +92,6 @@\n+        assertEquals(1, multipleGuardedCases2a(42.0f));\n+        assertEquals(1, multipleGuardedCases2a(\"test\"));\n+        assertEquals(-1, multipleGuardedCases2a(\"\"));\n+        assertEquals(1, multipleGuardedCases2b(42.0f));\n+        assertEquals(1, multipleGuardedCases2b(\"test\"));\n+        assertEquals(-1, multipleGuardedCases2b(\"\"));\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8314226.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"}]}