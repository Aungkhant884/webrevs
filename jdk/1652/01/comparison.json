{"files":[{"patch":"@@ -679,1 +679,1 @@\n-enum OptionType parse_option_type(const char* type_str) {\n+enum OptionType CompilerOracle::parse_option_type(const char* type_str) {\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -174,0 +174,4 @@\n+\n+  \/\/ convert a string to a proper option type\n+  \/\/ returns OptionType::Unknown on strings not matching an option type.\n+  static enum OptionType parse_option_type(const char* type_str);\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"compiler\/compilerOracle.hpp\"\n@@ -108,1 +109,0 @@\n-    bool in_signature = false;\n@@ -272,0 +272,12 @@\n+    \/\/ Over-consumption\n+    \/\/ method_name points to an option type or option name because the method name is not specified by users.\n+    \/\/ In very rare case, the method name happens to be same as option type\/name, so look ahead to make sure\n+    \/\/ it doesn't show up again.\n+    if ((OptionType::Unknown != CompilerOracle::parse_option_type(method_name) ||\n+        CompileCommand::Unknown != CompilerOracle::string_to_option(method_name)) &&\n+        strstr(line + bytes_read, method_name) == NULL) {\n+      error_msg = \"Did not specify any method name\";\n+      m_match = MethodMatcher::Unknown;\n+      method_name[0] = '\\0';\n+    }\n+\n","filename":"src\/hotspot\/share\/compiler\/methodMatcher.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"}]}