{"files":[{"patch":"@@ -210,1 +210,4 @@\n-\/\/ Platform specific implementations that underpin VM Mutex\/Monitor classes\n+\/\/ Platform specific implementations that underpin VM Mutex\/Monitor classes.\n+\/\/ Note that we use \"normal\" pthread_mutex_t attributes so that recursive\n+\/\/ locking is not supported, which matches the expected semantics of the\n+\/\/ VM Mutex class.\n","filename":"src\/hotspot\/os\/posix\/os_posix.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -190,1 +190,4 @@\n-\/\/ Platform specific implementations that underpin VM Mutex\/Monitor classes\n+\/\/ Platform specific implementations that underpin VM Mutex\/Monitor classes.\n+\/\/ Note that CRITICAL_SECTION supports recursive locking, while the semantics\n+\/\/ of the VM Mutex class does not. It is up to the Mutex class to hide this\n+\/\/ difference in behaviour.\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -140,1 +140,0 @@\n-\n@@ -146,1 +145,3 @@\n-  if (_lock.try_lock()) {\n+  \/\/ Checking the owner hides the potential difference in recursive locking behaviour\n+  \/\/ on some platforms.\n+  if (_owner != self && _lock.try_lock()) {\n","filename":"src\/hotspot\/share\/runtime\/mutex.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,0 +35,6 @@\n+\/\/ Locking is non-recursive: if you try to lock a mutex you already own then you\n+\/\/ will get an assertion failure in a debug build (which should suffice to expose\n+\/\/ usage bugs). If you call try_lock on a mutex you already own it will return false.\n+\/\/ The underlying PlatformMutex may support recursive locking but this is not exposed\n+\/\/ and we account for that possibility in try_lock.\n+\n","filename":"src\/hotspot\/share\/runtime\/mutex.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}