{"files":[{"patch":"@@ -2334,1 +2334,3 @@\n-  \/\/ Clamp the limit to handle integer under-\/overflows.\n+  \/\/ Clamp the limit to handle integer under-\/overflows by using long values.\n+  \/\/ We only convert the limit back to int when we handled under-\/overflows.\n+  \/\/ Note that all values are longs in the following computations.\n@@ -2336,1 +2338,3 @@\n-  \/\/   MIN(old_limit, MAX(limit, min_jint))\n+  \/\/   INT(MINL(old_limit, MAXL(limit, min_jint)))\n+  \/\/   - integer underflow of limit: MAXL chooses min_jint.\n+  \/\/   - integer overflow of limit: MINL chooses old_limit (<= MAX_INT < limit)\n@@ -2338,1 +2342,7 @@\n-  \/\/   MAX(old_limit, MIN(limit, max_jint))\n+  \/\/   INT(MAXL(old_limit, MINL(limit, max_jint)))\n+  \/\/   - integer overflow of limit: MINL chooses max_jint.\n+  \/\/   - integer underflow of limit: MAXL chooses old_limit (>= MIN_INT > limit)\n+  \/\/ INT() is finally converting the limit back to an integer value.\n+\n+  \/\/ We use CMove nodes to implement long versions of min\/max (MINL\/MAXL).\n+  \/\/ Inner MINL\/MAXL with CmovL to keep a long value for the outer MINL\/MAXL comparison:\n@@ -2343,7 +2353,14 @@\n-  limit = new ConvL2INode(limit);\n-  register_new_node(limit, pre_ctrl);\n-  limit = new CMoveINode(bol, limit, _igvn.intcon(is_positive_stride ? min_jint : max_jint), TypeInt::INT);\n-  register_new_node(limit, pre_ctrl);\n-\n-  limit = is_positive_stride ? (Node*)(new MinINode(old_limit, limit))\n-                             : (Node*)(new MaxINode(old_limit, limit));\n+  Node* inner_result_long = new CMoveLNode(bol, limit, _igvn.longcon(is_positive_stride ? min_jint : max_jint), TypeLong::LONG);\n+  register_new_node(inner_result_long, pre_ctrl);\n+\n+  \/\/ Outer MINL\/MAXL:\n+  \/\/ The comparison is done with long values but the result is the converted back to int by using CmovI.\n+  Node* old_limit_long = new ConvI2LNode(old_limit);\n+  register_new_node(old_limit_long, pre_ctrl);\n+  cmp = new CmpLNode(old_limit_long, limit);\n+  register_new_node(cmp, pre_ctrl);\n+  bol = new BoolNode(cmp, is_positive_stride ? BoolTest::gt : BoolTest::lt);\n+  register_new_node(bol, pre_ctrl);\n+  Node* inner_result_int = new ConvL2INode(inner_result_long); \/\/ Could under-\/overflow but that's fine as comparison was done with CmpL\n+  register_new_node(inner_result_int, pre_ctrl);\n+  limit = new CMoveINode(bol, old_limit, inner_result_int, TypeInt::INT);\n@@ -2351,0 +2368,1 @@\n+  C->print_method(PHASE_ADD_UNSAFE_BARRIER, 3);\n@@ -2400,19 +2418,0 @@\n-    if (low_limit->get_long() == -max_jint) {\n-      \/\/ If offset > 0, then low_limit - offset will either\n-      \/\/ underflow or if offset = 1, a division by -1 will still be\n-      \/\/ min_int. To avoid these problems, we replace the positive\n-      \/\/ offset with 0. This is done with an AND:\n-      \/\/ offset = offset & offset >> 63\n-      Node* shift = _igvn.intcon(63);\n-      set_ctrl(shift, C->root());\n-      Node* sign = new RShiftLNode(offset, shift);\n-      register_new_node(sign, pre_ctrl);\n-      offset = new AndLNode(offset, sign);\n-      register_new_node(offset, pre_ctrl);\n-    } else {\n-      assert(low_limit->get_long() == 0, \"wrong low limit for range check\");\n-      \/\/ The only problem here is when offset == min_int:\n-      \/\/ 0-min_int == min_int. It may be fine for stride > 0\n-      \/\/ but for stride < 0, limit will be < original_limit. To avoid it\n-      \/\/ max(pre_limit, original_limit) is used in do_range_check().\n-    }\n@@ -2448,19 +2447,0 @@\n-    if (low_limit->get_long() == -max_jint) {\n-      \/\/ If offset+1 > 0, then low_limit - (offset+1) will either\n-      \/\/ underflow or if offset = 0, a division by -1 will still be\n-      \/\/ min_int. To avoid these problems, we replace the positive\n-      \/\/ \"offset+1\" (plus_one) with 0. This is done with an AND:\n-      \/\/ plus_one = \"offset+1\" & \"offset+1\" >> 63\n-      Node* shift = _igvn.intcon(63);\n-      set_ctrl(shift, C->root());\n-      Node* sign = new RShiftLNode(plus_one, shift);\n-      register_new_node(sign, pre_ctrl);\n-      plus_one = new AndLNode(plus_one, sign);\n-      register_new_node(plus_one, pre_ctrl);\n-    } else {\n-      assert(low_limit->get_long() == 0, \"wrong low limit for range check\");\n-      \/\/ The only problem here is when offset == max_int:\n-      \/\/ low_limit - max_int+1 = 0 - min_int = min_int.\n-      \/\/ But this is fine since the main-loop will either\n-      \/\/ have less iterations or will be skipped.\n-    }\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":28,"deletions":48,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n- * @summary Dominator failure because ConvL2I node becomes TOP due to missing case in overflow\/underflow handling in range check elimination.\n+ * @summary Dominator failure because ConvL2I node becomes TOP due to missing overflow\/underflow handling in range check elimination\n+ *          in PhaseIdealLoop::add_constraint().\n@@ -41,2 +42,31 @@\n-        test();\n-        test2();\n+        \/\/ Test all cases in PhaseIdealLoop::add_constraint().\n+        testPositiveCaseMainLoop();\n+        testNegativeCaseMainLoop();\n+        testPositiveCasePreLoop();\n+        testNegativeCasePreLoop();\n+    }\n+    \n+    public static void testPositiveCaseMainLoop() {\n+        int e, f, g = 0, h[] = new int[a];\n+        double i[] = new double[a];\n+        long j = 9;\n+        Helper.init(h, 3);\n+        for (e = 5; e < 154; e++) {\n+            for (f = 1; f < 169; f += 2) {\n+                b = e;\n+            }\n+            i[1] = b;\n+            for (g = 8; g < 168; g += 2) {\n+                j = g - 5;\n+                if (j > Integer.MAX_VALUE - 1) {\n+                    switch (3) {\n+                        case 3:\n+                    }\n+                }\n+            }\n+            \n+        }\n+        if (g != 168) {\n+            throw new RuntimeException(\"fail\");\n+        }\n+        lFld = j;\n@@ -45,2 +75,3 @@\n-    public static void test() {\n-        int e, f, g, h[] = new int[a];\n+    \n+    public static void testPositiveCasePreLoop() {\n+        int e, f, g = 0, h[] = new int[a];\n@@ -55,2 +86,26 @@\n-            \/\/ In RC: flipped to negative stride*scale\n-            for (g = 8; 168 > g; g += 2) {\n+            for (g = 8; g < 168; g += 2) {\n+                j = g + 5;\n+                if (j > 180) {\n+                    switch (3) {\n+                        case 3:\n+                    }\n+                }\n+            }\n+        }\n+        if (g != 168) {\n+            throw new RuntimeException(\"fail\");\n+        }\n+        lFld = j;\n+    }\n+    \n+    public static void testNegativeCaseMainLoop() {\n+        int e, f, g = 0, h[] = new int[a];\n+        double i[] = new double[a];\n+        long j = 9;\n+        Helper.init(h, 3);\n+        for (e = 5; e < 154; e++) {\n+            for (f = 1; f < 169; f += 2) {\n+                b = e;\n+            }\n+            i[1] = b;\n+            for (g = 8; g < 168; g += 2) {\n@@ -58,1 +113,1 @@\n-                if (j < 3) {\n+                if (j < 5) {\n@@ -65,0 +120,3 @@\n+        if (g != 168) {\n+            throw new RuntimeException(\"fail\");\n+        }\n@@ -67,3 +125,4 @@\n-\n-    public static void test2() {\n-        int e, f, g, h[] = new int[a];\n+    \n+    \n+    public static void testNegativeCasePreLoop() {\n+        int e, f, g = 0, h[] = new int[a];\n@@ -78,4 +137,3 @@\n-            \/\/ In RC: flipped to positive stride*scale\n-            for (g = 168; 8 < g; g -= 2) {\n-                j = g - 1;\n-                if (j < 3) {\n+            for (g = 168; g > 8; g -= 2) {\n+                j = g - 5;\n+                if (j > Integer.MAX_VALUE - 1) {\n@@ -88,0 +146,3 @@\n+        if (g != 8) {\n+            throw new RuntimeException(\"fail\");\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestRangeCheckLimits.java","additions":76,"deletions":15,"binary":false,"changes":91,"status":"modified"}]}