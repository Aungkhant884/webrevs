{"files":[{"patch":"@@ -2334,1 +2334,3 @@\n-  \/\/ Clamp the limit to handle integer under-\/overflows.\n+  \/\/ Clamp the limit to handle integer under-\/overflows by using long values.\n+  \/\/ We only convert the limit back to int when we handled under-\/overflows.\n+  \/\/ Note that all values are longs in the following computations.\n@@ -2336,1 +2338,3 @@\n-  \/\/   MIN(old_limit, MAX(limit, min_jint))\n+  \/\/   INT(MINL(old_limit, MAXL(limit, min_jint)))\n+  \/\/   - integer underflow of limit: MAXL chooses min_jint.\n+  \/\/   - integer overflow of limit: MINL chooses old_limit (<= MAX_INT < limit)\n@@ -2338,2 +2342,19 @@\n-  \/\/   MAX(old_limit, MIN(limit, max_jint))\n-  Node* cmp = new CmpLNode(limit, _igvn.longcon(is_positive_stride ? min_jint : max_jint));\n+  \/\/   INT(MAXL(old_limit, MINL(limit, max_jint)))\n+  \/\/   - integer overflow of limit: MINL chooses max_jint.\n+  \/\/   - integer underflow of limit: MAXL chooses old_limit (>= MIN_INT > limit)\n+  \/\/ INT() is finally converting the limit back to an integer value.\n+\n+  \/\/ We use CMove nodes to implement long versions of min\/max (MINL\/MAXL).\n+  \/\/ We use helper methods for inner MINL\/MAXL which return CMoveL nodes to keep a long value for the outer MINL\/MAXL comparison:\n+  Node* inner_result_long;\n+  if (is_positive_stride) {\n+    inner_result_long = MaxNode::signed_max(limit, _igvn.longcon(min_jint), TypeLong::LONG, _igvn);\n+  } else {\n+    inner_result_long = MaxNode::signed_min(limit, _igvn.longcon(max_jint), TypeLong::LONG, _igvn);\n+  }\n+\n+  \/\/ Outer MINL\/MAXL:\n+  \/\/ The comparison is done with long values but the result is the converted back to int by using CmovI.\n+  Node* old_limit_long = new ConvI2LNode(old_limit);\n+  register_new_node(old_limit_long, pre_ctrl);\n+  Node* cmp = new CmpLNode(old_limit_long, limit);\n@@ -2341,1 +2362,1 @@\n-  Node* bol = new BoolNode(cmp, is_positive_stride ? BoolTest::lt : BoolTest::gt);\n+  Node* bol = new BoolNode(cmp, is_positive_stride ? BoolTest::gt : BoolTest::lt);\n@@ -2343,7 +2364,3 @@\n-  limit = new ConvL2INode(limit);\n-  register_new_node(limit, pre_ctrl);\n-  limit = new CMoveINode(bol, limit, _igvn.intcon(is_positive_stride ? min_jint : max_jint), TypeInt::INT);\n-  register_new_node(limit, pre_ctrl);\n-\n-  limit = is_positive_stride ? (Node*)(new MinINode(old_limit, limit))\n-                             : (Node*)(new MaxINode(old_limit, limit));\n+  Node* inner_result_int = new ConvL2INode(inner_result_long); \/\/ Could under-\/overflow but that's fine as comparison was done with CmpL\n+  register_new_node(inner_result_int, pre_ctrl);\n+  limit = new CMoveINode(bol, old_limit, inner_result_int, TypeInt::INT);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":29,"deletions":12,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262017\n+ * @summary Dominator failure because ConvL2I node becomes TOP due to missing overflow\/underflow handling in range check elimination\n+ *          in PhaseIdealLoop::add_constraint().\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileCommand=compileonly,compiler.rangechecks.TestRangeCheckLimits::*\n+ *                   compiler.rangechecks.TestRangeCheckLimits\n+ *\/\n+\n+ package compiler.rangechecks;\n+\n+ public class TestRangeCheckLimits {\n+    static int a = 400;\n+    static volatile int b;\n+    static long lFld;\n+    static int iFld;\n+\n+    public static void main(String[] k) {\n+        \/\/ Test all cases in PhaseIdealLoop::add_constraint().\n+        testPositiveCaseMainLoop();\n+        testNegativeCaseMainLoop();\n+        testPositiveCasePreLoop();\n+        testNegativeCasePreLoop();\n+    }\n+\n+    public static void testPositiveCaseMainLoop() {\n+        int e, f, g = 0, h[] = new int[a];\n+        double i[] = new double[a];\n+        long j = 9;\n+        Helper.init(h, 3);\n+        for (e = 5; e < 154; e++) {\n+            for (f = 1; f < 169; f += 2) {\n+                b = e;\n+            }\n+            i[1] = b;\n+            for (g = 8; g < 168; g += 2) {\n+                j = g - 5;\n+                if (j > Integer.MAX_VALUE - 1) {\n+                    switch (3) {\n+                        case 3:\n+                    }\n+                }\n+            }\n+        }\n+        if (g != 168) {\n+            throw new RuntimeException(\"fail\");\n+        }\n+        lFld = j;\n+    }\n+\n+\n+    public static void testPositiveCasePreLoop() {\n+        int e, f, g = 0, h[] = new int[a];\n+        double i[] = new double[a];\n+        long j = 9;\n+        Helper.init(h, 3);\n+        for (e = 5; e < 154; e++) {\n+            for (f = 1; f < 169; f += 2) {\n+                b = e;\n+            }\n+            i[1] = b;\n+            for (g = 8; g < 168; g += 2) {\n+                j = g + 5;\n+                if (j > 180) {\n+                    switch (3) {\n+                        case 3:\n+                    }\n+                }\n+            }\n+        }\n+        if (g != 168) {\n+            throw new RuntimeException(\"fail\");\n+        }\n+        lFld = j;\n+    }\n+\n+    public static void testNegativeCaseMainLoop() {\n+        int e, f, g = 0, h[] = new int[a];\n+        double i[] = new double[a];\n+        long j = 9;\n+        Helper.init(h, 3);\n+        for (e = 5; e < 154; e++) {\n+            for (f = 1; f < 169; f += 2) {\n+                b = e;\n+            }\n+            i[1] = b;\n+            for (g = 8; g < 168; g += 2) {\n+                j = g;\n+                if (j < 5) {\n+                    switch (3) {\n+                        case 3:\n+                    }\n+                }\n+            }\n+        }\n+        if (g != 168) {\n+            throw new RuntimeException(\"fail\");\n+        }\n+        lFld = j;\n+    }\n+\n+\n+    public static void testNegativeCasePreLoop() {\n+        int e, f, g = 0, h[] = new int[a];\n+        double i[] = new double[a];\n+        long j = 9;\n+        Helper.init(h, 3);\n+        for (e = 5; e < 154; e++) {\n+            for (f = 1; f < 169; f += 2) {\n+                b = e;\n+            }\n+            i[1] = b;\n+            for (g = 168; g > 8; g -= 2) {\n+                j = g - 5;\n+                if (j > Integer.MAX_VALUE - 1) {\n+                    switch (3) {\n+                        case 3:\n+                    }\n+                }\n+            }\n+        }\n+        if (g != 8) {\n+            throw new RuntimeException(\"fail\");\n+        }\n+        lFld = j;\n+    }\n+}\n+\n+class Helper {\n+    public static void init(int[] a, int seed) {\n+        for (int j = 0; j < a.length; j++) {\n+            a[j] = (j % 2 == 0) ? seed + j : seed - j;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestRangeCheckLimits.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"}]}