{"files":[{"patch":"@@ -52,1 +52,2 @@\n-    FILES := $(TOPDIR)\/src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java, \\\n+    FILES := $(TOPDIR)\/src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java \\\n+        $(TOPDIR)\/src\/java.base\/share\/classes\/jdk\/internal\/javac\/NoPreview.java, \\\n","filename":"make\/CompileInterimLangtools.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.ConstantCallSite;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * Bootstrap methods for linking {@code invokedynamic} call sites that implement\n+ * the selection functionality of the {@code switch} statement.  The bootstraps\n+ * take additional static arguments corresponding to the {@code case} labels\n+ * of the {@code switch}, implicitly numbered sequentially from {@code [0..N)}.\n+ *\n+ * <p>The bootstrap call site accepts a single parameter of the type of the\n+ * operand of the {@code switch}, and return an {@code int} that is the index of\n+ * the matched {@code case} label, {@code -1} if the target is {@code null},\n+ * or {@code N} if the target is not null but matches no {@code case} label.\n+ *\n+ * @since 17\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING)\n+public class SwitchBootstraps {\n+\n+    private SwitchBootstraps() {}\n+\n+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+\n+    private static final MethodHandle DO_SWITCH;\n+\n+    static {\n+        try {\n+            DO_SWITCH = LOOKUP.findStatic(SwitchBootstraps.class, \"doSwitch\",\n+                                           MethodType.methodType(int.class, Object.class, int.class, Object[].class));\n+        }\n+        catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    \/**\n+     * Bootstrap method for linking an {@code invokedynamic} call site that\n+     * implements a {@code switch} on a reference-typed target.  The static\n+     * arguments are a varargs array of case labels. Constants of type {@code String} or\n+     * {@code Integer} and {@code Class} instances are accepted.\n+     *\n+     * @param lookup Represents a lookup context with the accessibility\n+     *               privileges of the caller.  When used with {@code invokedynamic},\n+     *               this is stacked automatically by the VM.\n+     * @param invocationName The invocation name, which is ignored.  When used with\n+     *                       {@code invokedynamic}, this is provided by the\n+     *                       {@code NameAndType} of the {@code InvokeDynamic}\n+     *                       structure and is stacked automatically by the VM.\n+     * @param invocationType The invocation type of the {@code CallSite}.  This\n+     *                       method type should have a single parameter of\n+     *                       a reference type, and return {@code int}.  When\n+     *                       used with {@code invokedynamic}, this is provided by\n+     *                       the {@code NameAndType} of the {@code InvokeDynamic}\n+     *                       structure and is stacked automatically by the VM.\n+     * @param labels non-null case labels - {@code String} and {@code Integer} constants\n+     *                        and {@code Class} instances, in any combination\n+     * @return a {@code CallSite}, which accepts two parameters: one is an instance\n+     *         of the target type, and second is a restart index. It returns the\n+     *         index into {@code labels} of the target value, if the target\n+     *         is an instance of any of the types or equal to any of the constants, {@literal -1} if the target\n+     *         value is {@code null}, or {@code types.length} if the target value\n+     *         is not an instance of any of the types or equal to any of the constants. Will return\n+     *         an index that is greater or equal to the restart index provided.\n+     * @throws NullPointerException if any required argument is null\n+     * @throws IllegalArgumentException if any labels are null, or if the\n+     * invocation type is not {@code (T)int for some reference type {@code T}}\n+     * @throws Throwable if there is any error linking the call site\n+     *\/\n+    public static CallSite typeSwitch(MethodHandles.Lookup lookup,\n+                                      String invocationName,\n+                                      MethodType invocationType,\n+                                      Object... labels) throws Throwable {\n+        if (invocationType.parameterCount() != 2\n+            || (!invocationType.returnType().equals(int.class))\n+            || invocationType.parameterType(0).isPrimitive())\n+            throw new IllegalArgumentException(\"Illegal invocation type \" + invocationType);\n+        requireNonNull(labels);\n+\n+        labels = labels.clone();\n+        Stream.of(labels).forEach(SwitchBootstraps::verifyLabel);\n+\n+        MethodHandle target = MethodHandles.insertArguments(DO_SWITCH, 2, (Object) labels);\n+        return new ConstantCallSite(target);\n+    }\n+\n+    private static void verifyLabel(Object label) {\n+        if (label == null) {\n+            throw new IllegalArgumentException(\"null label found\");\n+        }\n+        Class<?> labelClass = label.getClass();\n+        if (labelClass != Class.class &&\n+            labelClass != String.class &&\n+            labelClass != Integer.class) {\n+            throw new IllegalArgumentException(\"label with illegal type found: \" + label.getClass());\n+        }\n+    }\n+\n+    private static int doSwitch(Object target, int startIndex, Object[] labels) {\n+        if (target == null)\n+            return -1;\n+\n+        \/\/ Dumbest possible strategy\n+        Class<?> targetClass = target.getClass();\n+        for (int i = startIndex; i < labels.length; i++) {\n+            Object label = labels[i];\n+            if (label instanceof Class<?> c) {\n+                if (c.isAssignableFrom(targetClass))\n+                    return i;\n+            } else {\n+                if (label instanceof Integer constant) {\n+                    if (target instanceof Number input && constant.intValue() == input.intValue()) {\n+                        return i;\n+                    }\n+                    if (target instanceof Character input && constant.intValue() == input.charValue()) {\n+                        return i;\n+                    }\n+                } else if (label.equals(target)) {\n+                    return i;\n+                }\n+            }\n+        }\n+\n+        return labels.length;\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.javac;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/**\n+ * The element annotated with this annotation should not be marked as a preview element.\n+ *\/\n+@Target({ElementType.METHOD,\n+         ElementType.CONSTRUCTOR,\n+         ElementType.FIELD,\n+         ElementType.PACKAGE,\n+         ElementType.MODULE,\n+         ElementType.TYPE})\n+@Retention(RetentionPolicy.CLASS)\n+public @interface NoPreview {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/NoPreview.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -61,0 +61,1 @@\n+        SWITCH_PATTERN_MATCHING,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.source.tree;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**A marker interface for {@code Tree}s that may be used as {@link CaseTree} labels.\n+ *\n+ * @since 17\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+public interface CaseLabelTree extends Tree {}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/CaseLabelTree.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -68,0 +70,10 @@\n+    \/**\n+     * Returns the labels for this case.\n+     * For {@code default} case return a list with a single element, {@link DefaultCaseLabelTree}.\n+     *\n+     * @return labels for this case\n+     * @since 17\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    List<? extends CaseLabelTree> getLabels();\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/CaseTree.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.source.tree;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/** A case label that marks {@code default} in {@code case null, default}.\n+ * @since 17\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+public interface DefaultCaseLabelTree extends CaseLabelTree {}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/DefaultCaseLabelTree.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.NoPreview;\n+\n@@ -38,1 +40,2 @@\n-public interface ExpressionTree extends Tree {}\n+@NoPreview\n+public interface ExpressionTree extends Tree, CaseLabelTree {}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/ExpressionTree.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.source.tree;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A guard pattern tree.\n+ *\n+ * @since 17\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+public interface GuardedPatternTree extends PatternTree {\n+\n+    \/**\n+     * The guarded pattern expression.\n+     * @return the guarded pattern\n+     *\/\n+    public PatternTree getPattern();\n+\n+    \/**\n+     * The guard expression.\n+     * @return the guard expression\n+     *\/\n+    public ExpressionTree getExpression();\n+\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/GuardedPatternTree.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2005, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.source.tree;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A tree node for a parenthesized pattern.\n+ *\n+ * For example:\n+ * <pre>\n+ *   ( <em>pattern<\/em> )\n+ * <\/pre>\n+ *\n+ * @jls 14.30.1 Kinds of Patterns\n+ *\n+ * @since 17\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+public interface ParenthesizedPatternTree extends PatternTree {\n+    \/**\n+     * Returns the pattern within the parentheses.\n+     * @return the pattern\n+     *\/\n+    PatternTree getPattern();\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/ParenthesizedPatternTree.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -34,1 +34,1 @@\n-public interface PatternTree extends Tree {}\n+public interface PatternTree extends Tree, CaseLabelTree {}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/PatternTree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -229,0 +231,24 @@\n+        \/**\n+         * Used for instances of {@link GuardedPatternTree}.\n+         *\n+         * @since 17\n+         *\/\n+        @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+        GUARDED_PATTERN(GuardedPatternTree.class),\n+\n+        \/**\n+         * Used for instances of {@link ParenthesizedPatternTree}.\n+         *\n+         * @since 17\n+         *\/\n+        @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+        PARENTHESIZED_PATTERN(ParenthesizedPatternTree.class),\n+\n+        \/**\n+         * Used for instances of {@link DefaultCaseLabelTree}.\n+         *\n+         * @since 17\n+         *\/\n+        @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+        DEFAULT_CASE_LABEL(DefaultCaseLabelTree.class),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -269,0 +271,10 @@\n+    \/**\n+     * Visits a DefaultCaseLabelTree node.\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     * @since 17\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    R visitDefaultCaseLabel(DefaultCaseLabelTree node, P p);\n+\n@@ -293,0 +305,20 @@\n+    \/**\n+     * Visits a GuardPatternTree node.\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     * @since 17\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    R visitGuardedPattern(GuardedPatternTree node, P p);\n+\n+    \/**\n+     * Visits a ParenthesizedPatternTree node.\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     * @since 17\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    R visitParenthesizedPattern(ParenthesizedPatternTree node, P p);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -567,0 +568,14 @@\n+    \/**\n+     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     * @since 17\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    public R visitDefaultCaseLabel(DefaultCaseLabelTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n@@ -591,0 +606,28 @@\n+    \/**\n+     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     * @since 17\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    public R visitParenthesizedPattern(ParenthesizedPatternTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     * @since 17\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    public R visitGuardedPattern(GuardedPatternTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -698,0 +699,14 @@\n+    \/**\n+     * {@inheritDoc} This implementation returns {@code null}.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     * @since 17\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    public R visitDefaultCaseLabel(DefaultCaseLabelTree node, P p) {\n+        return null;\n+    }\n+\n@@ -724,0 +739,29 @@\n+    \/**\n+     * {@inheritDoc} This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     * @since 17\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    public R visitParenthesizedPattern(ParenthesizedPatternTree node, P p) {\n+        return scan(node.getPattern(), p);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     * @since 17\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    public R visitGuardedPattern(GuardedPatternTree node, P p) {\n+        R r = scan(node.getPattern(), p);\n+        return scanAndReduce(node.getExpression(), p, r);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic;\n@@ -82,0 +83,1 @@\n+    private final Source source;\n@@ -99,1 +101,1 @@\n-        Source source = Source.instance(context);\n+        source = Source.instance(context);\n@@ -186,0 +188,3 @@\n+            case CASE_NULL -> true;\n+            case PATTERN_SWITCH -> true;\n+\n@@ -239,0 +244,15 @@\n+    public void checkSourceLevel(DiagnosticPosition pos, Feature feature) {\n+        if (isPreview(feature) && !isEnabled()) {\n+            \/\/preview feature without --preview flag, error\n+            log.error(JCDiagnostic.DiagnosticFlag.SOURCE_LEVEL, pos, disabledError(feature));\n+        } else {\n+            if (!feature.allowedInSource(source)) {\n+                log.error(JCDiagnostic.DiagnosticFlag.SOURCE_LEVEL, pos,\n+                          feature.error(source.name));\n+            }\n+            if (isEnabled() && isPreview(feature)) {\n+                warnPreview(pos, feature);\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -227,0 +227,2 @@\n+        CASE_NULL(JDK17, Fragments.FeatureCaseNull, DiagKind.NORMAL),\n+        PATTERN_SWITCH(JDK17, Fragments.FeaturePatternSwitch, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -223,0 +223,1 @@\n+    public final Type switchBootstrapsType;\n@@ -588,0 +589,1 @@\n+        switchBootstrapsType = enterClass(\"java.lang.runtime.SwitchBootstraps\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1660,2 +1660,10 @@\n-            if (!enumSwitch && !stringSwitch)\n-                seltype = chk.checkType(selector.pos(), seltype, syms.intType);\n+            boolean patternSwitch;\n+            if (!enumSwitch && !stringSwitch && !errorEnumSwitch &&\n+                !types.isAssignable(seltype, syms.intType)) {\n+                preview.checkSourceLevel(selector.pos(), Feature.PATTERN_SWITCH);\n+                patternSwitch = true;\n+            } else {\n+                patternSwitch = cases.stream()\n+                                     .flatMap(c -> c.labels.stream())\n+                                     .anyMatch(l -> l.isPattern());\n+            }\n@@ -1666,1 +1674,4 @@\n-            boolean hasDefault = false;      \/\/ Is there a default label?\n+            List<Type> coveredTypes = List.nil();\n+            boolean hasDefault = false;           \/\/ Is there a default label?\n+            boolean hasTotalPattern = false;      \/\/ Is there a total pattern?\n+            boolean hasNullPattern = false;       \/\/ Is there a null pattern?\n@@ -1669,0 +1680,2 @@\n+            MatchBindings prevBindings = null;\n+            boolean prevCompletedNormally = false;\n@@ -1678,5 +1691,15 @@\n-                if (c.getExpressions().nonEmpty()) {\n-                    for (JCExpression pat : c.getExpressions()) {\n-                        if (TreeInfo.isNull(pat)) {\n-                            log.error(pat.pos(),\n-                                      Errors.SwitchNullNotAllowed);\n+                MatchBindings currentBindings = prevBindings;\n+                boolean wasTotalPattern = hasTotalPattern;\n+                for (JCCaseLabel pat : c.labels) {\n+                    if (pat.isExpression()) {\n+                        JCExpression expr = (JCExpression) pat;\n+                        if (TreeInfo.isNull(expr)) {\n+                            preview.checkSourceLevel(expr.pos(), Feature.CASE_NULL);\n+                            if (hasNullPattern) {\n+                                log.error(c.pos(), Errors.DuplicateCaseLabel);\n+                            } else if (wasTotalPattern) {\n+                                log.error(c.pos(), Errors.PatternDominated);\n+                            }\n+                            hasNullPattern = true;\n+                            attribExpr(expr, switchEnv, seltype);\n+                            matchBindings = new MatchBindings(matchBindings.bindingsWhenTrue, matchBindings.bindingsWhenFalse, true);\n@@ -1684,1 +1707,1 @@\n-                            Symbol sym = enumConstant(pat, seltype);\n+                            Symbol sym = enumConstant(expr, seltype);\n@@ -1686,1 +1709,1 @@\n-                                log.error(pat.pos(), Errors.EnumLabelMustBeUnqualifiedEnum);\n+                                log.error(expr.pos(), Errors.EnumLabelMustBeUnqualifiedEnum);\n@@ -1689,0 +1712,2 @@\n+                            } else {\n+                                checkCaseLabelDominated(pat.pos(), coveredTypes, sym.type);\n@@ -1702,1 +1727,1 @@\n-                            Type pattype = attribExpr(pat, switchEnv, seltype);\n+                            Type pattype = attribExpr(expr, switchEnv, seltype);\n@@ -1704,0 +1729,3 @@\n+                                if (!stringSwitch && !types.isAssignable(seltype, syms.intType)) {\n+                                    log.error(pat.pos(), Errors.ConstantLabelNotCompatible(pattype, seltype));\n+                                }\n@@ -1705,1 +1733,1 @@\n-                                    log.error(pat.pos(),\n+                                    log.error(expr.pos(),\n@@ -1709,0 +1737,2 @@\n+                                } else {\n+                                    checkCaseLabelDominated(pat.pos(), coveredTypes, types.boxedTypeOrType(pattype));\n@@ -1712,0 +1742,39 @@\n+                    } else if (pat.hasTag(DEFAULTCASELABEL)) {\n+                        if (hasDefault) {\n+                            log.error(pat.pos(), Errors.DuplicateDefaultLabel);\n+                        } else if (hasTotalPattern) {\n+                            log.error(pat.pos(), Errors.TotalPatternAndDefault);\n+                        } else if (matchBindings.bindingsWhenTrue.nonEmpty()) {\n+                            \/\/there was a pattern, and the execution flows into a default:\n+                            log.error(pat.pos(), Errors.FlowsThroughFromPattern);\n+                        }\n+                        hasDefault = true;\n+                        matchBindings = MatchBindingsComputer.EMPTY;\n+                    } else {\n+                        if (prevCompletedNormally) {\n+                            log.error(pat.pos(), Errors.FlowsThroughToPattern);\n+                        }\n+                        \/\/binding pattern\n+                        attribExpr(pat, switchEnv);\n+                        var primary = TreeInfo.primaryPatternType((JCPattern) pat);\n+                        Type primaryType = primary.type();\n+                        if (!primaryType.hasTag(TYPEVAR)) {\n+                            primaryType = chk.checkClassOrArrayType(pat.pos(), primaryType);\n+                        }\n+                        checkCastablePattern(pat.pos(), seltype, primaryType);\n+                        Type patternType = types.erasure(primaryType);\n+                        boolean isTotal = primary.unconditional() &&\n+                                          !patternType.isErroneous() &&\n+                                          types.isSubtype(types.erasure(seltype), patternType);\n+                        if (isTotal) {\n+                            if (hasTotalPattern) {\n+                                log.error(pat.pos(), Errors.DuplicateTotalPattern);\n+                            } else if (hasDefault) {\n+                                log.error(pat.pos(), Errors.TotalPatternAndDefault);\n+                            }\n+                            hasTotalPattern = true;\n+                        }\n+                        checkCaseLabelDominated(pat.pos(), coveredTypes, patternType);\n+                        if (primary.unconditional() && !patternType.isErroneous()) {\n+                            coveredTypes = coveredTypes.prepend(patternType);\n+                        }\n@@ -1713,4 +1782,2 @@\n-                } else if (hasDefault) {\n-                    log.error(c.pos(), Errors.DuplicateDefaultLabel);\n-                } else {\n-                    hasDefault = true;\n+                    currentBindings = matchBindingsComputer.switchCase(pat, currentBindings, matchBindings);\n+                    prevCompletedNormally = !TreeInfo.isNull(pat);\n@@ -1719,1 +1786,1 @@\n-                    switchEnv.dup(c, env.info.dup(switchEnv.info.scope.dup()));\n+                        bindingEnv(switchEnv, c, currentBindings.bindingsWhenTrue);\n@@ -1726,0 +1793,16 @@\n+\n+                boolean completesNormally = c.caseKind == CaseTree.CaseKind.STATEMENT ? flow.aliveAfter(caseEnv, c, make) : false;\n+                prevBindings = completesNormally ? currentBindings : null;\n+                prevCompletedNormally =\n+                        completesNormally &&\n+                        !(c.labels.size() == 1 &&\n+                          TreeInfo.isNull(c.labels.head) && c.stats.isEmpty());\n+            }\n+            if (switchTree.hasTag(SWITCH)) {\n+                ((JCSwitch) switchTree).hasTotalPattern = hasDefault || hasTotalPattern;\n+                ((JCSwitch) switchTree).patternSwitch = patternSwitch;\n+            } else if (switchTree.hasTag(SWITCH_EXPRESSION)) {\n+                ((JCSwitchExpression) switchTree).hasTotalPattern = hasDefault || hasTotalPattern;\n+                ((JCSwitchExpression) switchTree).patternSwitch = patternSwitch;\n+            } else {\n+                Assert.error(switchTree.getTag().name());\n@@ -1740,0 +1823,8 @@\n+        private void checkCaseLabelDominated(DiagnosticPosition pos,\n+                                             List<Type> coveredTypes, Type patternType) {\n+            for (Type existing : coveredTypes) {\n+                if (types.isSubtype(patternType, existing)) {\n+                    log.error(pos, Errors.PatternDominated);\n+                }\n+            }\n+        }\n@@ -2083,1 +2174,5 @@\n-        Env<AttrContext> env1 = env.dup(env.tree, env.info.dup(env.info.scope.dup()));\n+        return bindingEnv(env, env.tree, bindings);\n+    }\n+\n+    Env<AttrContext> bindingEnv(Env<AttrContext> env, JCTree newTree, List<BindingSymbol> bindings) {\n+        Env<AttrContext> env1 = env.dup(newTree, env.info.dup(env.info.scope.dup()));\n@@ -3997,10 +4092,1 @@\n-                Warner warner = new Warner();\n-                if (!types.isCastable(exprtype, clazztype, warner)) {\n-                    chk.basicHandler.report(tree.expr.pos(),\n-                                            diags.fragment(Fragments.InconvertibleTypes(exprtype, clazztype)));\n-                } else if (warner.hasLint(LintCategory.UNCHECKED)) {\n-                    log.error(tree.expr.pos(),\n-                              Errors.InstanceofReifiableNotSafe(exprtype, clazztype));\n-                } else {\n-                    valid = true;\n-                }\n+                valid = checkCastablePattern(tree.expr.pos(), exprtype, clazztype);\n@@ -4021,0 +4107,17 @@\n+    private boolean checkCastablePattern(DiagnosticPosition pos,\n+                                         Type exprType,\n+                                         Type pattType) {\n+        Warner warner = new Warner();\n+        if (!types.isCastable(exprType, pattType, warner)) {\n+            chk.basicHandler.report(pos,\n+                    diags.fragment(Fragments.InconvertibleTypes(exprType, pattType)));\n+            return false;\n+        } else if (warner.hasLint(LintCategory.UNCHECKED)) {\n+            log.error(pos,\n+                    Errors.InstanceofReifiableNotSafe(exprType, pattType));\n+            return false;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n@@ -4036,0 +4139,19 @@\n+\n+    @Override\n+    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n+        attribExpr(tree.pattern, env);\n+    }\n+\n+    @Override\n+    public void visitGuardPattern(JCGuardPattern tree) {\n+        attribExpr(tree.patt, env);\n+        MatchBindings afterPattern = matchBindings;\n+        Env<AttrContext> bodyEnv = bindingEnv(env, matchBindings.bindingsWhenTrue);\n+        try {\n+            attribExpr(tree.expr, bodyEnv, syms.booleanType);\n+        } finally {\n+            bodyEnv.info.scope.leave();\n+        }\n+        result = tree.type = tree.patt.type;\n+        matchBindings = matchBindingsComputer.guardedPattern(tree, afterPattern, matchBindings);\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":150,"deletions":28,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import com.sun.tools.javac.tree.TreeInfo.PatternPrimaryType;\n@@ -56,0 +57,2 @@\n+import com.sun.tools.javac.resources.CompilerProperties.Fragments;\n+import com.sun.tools.javac.tree.JCTree.JCParenthesizedPattern;\n@@ -57,0 +60,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.Fragment;\n@@ -664,1 +668,1 @@\n-            boolean hasDefault = false;\n+            Set<Object> constants = tree.patternSwitch ? allSwitchConstants(tree.selector) : null;\n@@ -668,6 +672,3 @@\n-                if (c.pats.isEmpty())\n-                    hasDefault = true;\n-                else {\n-                    for (JCExpression pat : c.pats) {\n-                        scan(pat);\n-                    }\n+                for (JCCaseLabel pat : c.labels) {\n+                    scan(pat);\n+                    handleConstantCaseLabel(constants, pat);\n@@ -689,1 +690,5 @@\n-            if (!hasDefault) {\n+            if ((constants == null || !constants.isEmpty()) && !tree.hasTotalPattern &&\n+                tree.patternSwitch && !TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases)) {\n+                log.error(tree, Errors.NotExhaustiveStatement);\n+            }\n+            if (!tree.hasTotalPattern) {\n@@ -700,11 +705,1 @@\n-            Set<Object> constants = null;\n-            TypeSymbol selectorSym = tree.selector.type.tsym;\n-            if ((selectorSym.flags() & ENUM) != 0) {\n-                constants = new HashSet<>();\n-                Predicate<Symbol> enumConstantFilter =\n-                        s -> (s.flags() & ENUM) != 0 && s.kind == Kind.VAR;\n-                for (Symbol s : selectorSym.members().getSymbols(enumConstantFilter)) {\n-                    constants.add(s.name);\n-                }\n-            }\n-            boolean hasDefault = false;\n+            Set<Object> constants = allSwitchConstants(tree.selector);\n@@ -715,12 +710,3 @@\n-                if (c.pats.isEmpty())\n-                    hasDefault = true;\n-                else {\n-                    for (JCExpression pat : c.pats) {\n-                        scan(pat);\n-                        if (constants != null) {\n-                            if (pat.hasTag(IDENT))\n-                                constants.remove(((JCIdent) pat).name);\n-                            if (pat.type != null)\n-                                constants.remove(pat.type.constValue());\n-                        }\n-                    }\n+                for (JCCaseLabel pat : c.labels) {\n+                    scan(pat);\n+                    handleConstantCaseLabel(constants, pat);\n@@ -740,1 +726,1 @@\n-            if ((constants == null || !constants.isEmpty()) && !hasDefault &&\n+            if ((constants == null || !constants.isEmpty()) && !tree.hasTotalPattern &&\n@@ -748,0 +734,33 @@\n+        private Set<Object> allSwitchConstants(JCExpression selector) {\n+            Set<Object> constants = null;\n+            TypeSymbol selectorSym = selector.type.tsym;\n+            if ((selectorSym.flags() & ENUM) != 0) {\n+                constants = new HashSet<>();\n+                Predicate<Symbol> enumConstantFilter =\n+                        s -> (s.flags() & ENUM) != 0 && s.kind == Kind.VAR;\n+                for (Symbol s : selectorSym.members().getSymbols(enumConstantFilter)) {\n+                    constants.add(s.name);\n+                }\n+            } else if (selectorSym.isAbstract() && selectorSym.isSealed() && selectorSym.kind == Kind.TYP) {\n+                constants = new HashSet<>();\n+                constants.addAll(((ClassSymbol) selectorSym).permitted);\n+            }\n+            return constants;\n+        }\n+\n+        private void handleConstantCaseLabel(Set<Object> constants, JCCaseLabel pat) {\n+            if (constants != null) {\n+                if (pat.isExpression()) {\n+                    JCExpression expr = (JCExpression) pat;\n+                    if (expr.hasTag(IDENT))\n+                        constants.remove(((JCIdent) expr).name);\n+                } else if (pat.isPattern()) {\n+                    PatternPrimaryType patternType = TreeInfo.primaryPatternType((JCPattern) pat);\n+\n+                    if (patternType.unconditional()) {\n+                        constants.remove(patternType.type().tsym);\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -1197,1 +1216,1 @@\n-                scan(c.pats);\n+                scan(c.labels);\n@@ -2355,1 +2374,1 @@\n-            handleSwitch(tree, tree.selector, tree.cases);\n+            handleSwitch(tree, tree.selector, tree.cases, tree.hasTotalPattern);\n@@ -2359,1 +2378,1 @@\n-            handleSwitch(tree, tree.selector, tree.cases);\n+            handleSwitch(tree, tree.selector, tree.cases, tree.hasTotalPattern);\n@@ -2362,1 +2381,2 @@\n-        private void handleSwitch(JCTree tree, JCExpression selector, List<JCCase> cases) {\n+        private void handleSwitch(JCTree tree, JCExpression selector,\n+                                  List<JCCase> cases, boolean hasTotalPattern) {\n@@ -2369,1 +2389,0 @@\n-            boolean hasDefault = false;\n@@ -2374,10 +2393,15 @@\n-                if (c.pats.isEmpty()) {\n-                    hasDefault = true;\n-                } else {\n-                    for (JCExpression pat : c.pats) {\n-                        scanExpr(pat);\n-                    }\n-                }\n-                if (hasDefault) {\n-                    inits.assign(initsSwitch);\n-                    uninits.assign(uninits.andSet(uninitsSwitch));\n+                for (JCCaseLabel pat : c.labels) {\n+                    scan(pat);\n+                }\n+                if (l.head.stats.isEmpty() &&\n+                    l.tail.nonEmpty() &&\n+                    l.tail.head.labels.size() == 1 &&\n+                    l.tail.head.labels.head.isExpression() &&\n+                    TreeInfo.isNull(l.tail.head.labels.head)) {\n+                    \/\/handling:\n+                    \/\/case Integer i:\n+                    \/\/case null:\n+                    \/\/joining these two cases together - processing Integer i pattern,\n+                    \/\/but statements from case null:\n+                    l = l.tail;\n+                    c = l.head;\n@@ -2390,4 +2414,0 @@\n-                if (!hasDefault) {\n-                    inits.assign(initsSwitch);\n-                    uninits.assign(uninits.andSet(uninitsSwitch));\n-                }\n@@ -2396,1 +2416,1 @@\n-            if (!hasDefault) {\n+            if (!hasTotalPattern) {\n@@ -2400,1 +2420,2 @@\n-                    inits.andSet(initsSwitch);\n+                    inits.assign(initsSwitch);\n+                    uninits.assign(uninits.andSet(uninitsSwitch));\n@@ -2855,0 +2876,1 @@\n+                    case GUARDPATTERN:\n@@ -2878,0 +2900,1 @@\n+                        case GUARDPATTERN:\n@@ -2886,2 +2909,6 @@\n-            String subKey = currentTree.hasTag(LAMBDA) ?\n-                  \"lambda\"  : \"inner.cls\";\n+            Fragment subKey = switch (currentTree.getTag()) {\n+                case LAMBDA -> Fragments.Lambda;\n+                case GUARDPATTERN -> Fragments.Guard;\n+                case CLASSDEF -> Fragments.InnerCls;\n+                default -> throw new AssertionError(\"Unexpected tree kind: \" + currentTree.getTag());\n+            };\n@@ -2923,0 +2950,12 @@\n+        @Override\n+        public void visitGuardPattern(JCGuardPattern tree) {\n+            scan(tree.patt);\n+            JCTree prevTree = currentTree;\n+            try {\n+                currentTree = tree;\n+                scan(tree.expr);\n+            } finally {\n+                currentTree = prevTree;\n+            }\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":94,"deletions":55,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -3586,1 +3586,2 @@\n-        handleSwitch(tree, tree.selector, tree.cases);\n+        List<JCCase> cases = tree.patternSwitch ? addDefaultIfNeeded(tree.cases) : tree.cases;\n+        handleSwitch(tree, tree.selector, cases);\n@@ -3591,1 +3592,6 @@\n-        if (tree.cases.stream().noneMatch(c -> c.pats.isEmpty())) {\n+        List<JCCase> cases = addDefaultIfNeeded(tree.cases);\n+        handleSwitch(tree, tree.selector, cases);\n+    }\n+\n+    private List<JCCase> addDefaultIfNeeded(List<JCCase> cases) {\n+        if (cases.stream().flatMap(c -> c.labels.stream()).noneMatch(p -> p.hasTag(Tag.DEFAULTCASELABEL))) {\n@@ -3594,2 +3600,2 @@\n-            JCCase c = make.Case(JCCase.STATEMENT, List.nil(), List.of(thr), null);\n-            tree.cases = tree.cases.append(c);\n+            JCCase c = make.Case(JCCase.STATEMENT, List.of(make.DefaultCaseLabel()), List.of(thr), null);\n+            cases = cases.append(c);\n@@ -3597,1 +3603,2 @@\n-        handleSwitch(tree, tree.selector, tree.cases);\n+\n+        return cases;\n@@ -3605,1 +3612,1 @@\n-            switch (c.pats.size()) {\n+            switch (c.labels.size()) {\n@@ -3616,1 +3623,1 @@\n-                    List<JCExpression> patterns = c.pats;\n+                    List<JCCaseLabel> patterns = c.labels;\n@@ -3624,1 +3631,1 @@\n-                    c.pats = patterns;\n+                    c.labels = patterns;\n@@ -3632,1 +3639,1 @@\n-                JCBreak b = make_at(c.pos()).Break(null);\n+                JCBreak b = make.at(TreeInfo.endPos(c.stats.last())).Break(null);\n@@ -3645,3 +3652,2 @@\n-        Type target = enumSwitch ? selector.type :\n-            (stringSwitch? syms.stringType : syms.intType);\n-        selector = translate(selector, target);\n+        boolean boxedSwitch = !enumSwitch && !stringSwitch && !selector.type.isPrimitive();\n+        selector = translate(selector, selector.type);\n@@ -3662,0 +3668,4 @@\n+        } else if (boxedSwitch) {\n+            \/\/An switch over boxed primitive. Pattern matching switches are already translated\n+            \/\/by TransPatterns, so all non-primitive types are only boxed primitives:\n+            result = visitBoxedPrimitiveSwitch(tree, selector, cases);\n@@ -3675,3 +3685,26 @@\n-        JCArrayAccess newSelector = make.Indexed(map.mapVar,\n-                                        make.App(make.Select(selector,\n-                                                             ordinalMethod)));\n+        JCExpression newSelector;\n+\n+        if (cases.stream().anyMatch(c -> TreeInfo.isNull(c.labels.head))) {\n+            \/\/for enum switches with case null, do:\n+            \/\/switch ($selector != null ? $mapVar[$selector.ordinal()] : -1) {...}\n+            \/\/replacing case null with case -1:\n+            VarSymbol dollar_s = new VarSymbol(FINAL|SYNTHETIC,\n+                                               names.fromString(\"s\" + tree.pos + this.target.syntheticNameChar()),\n+                                               selector.type,\n+                                               currentMethodSym);\n+            JCStatement var = make.at(tree.pos()).VarDef(dollar_s, selector).setType(dollar_s.type);\n+            newSelector = make.Indexed(map.mapVar,\n+                    make.App(make.Select(make.Ident(dollar_s),\n+                            ordinalMethod)));\n+            newSelector =\n+                    make.LetExpr(List.of(var),\n+                                 make.Conditional(makeBinary(NE, make.Ident(dollar_s), makeNull()),\n+                                                  newSelector,\n+                                                  makeLit(syms.intType, -1))\n+                                     .setType(newSelector.type))\n+                        .setType(newSelector.type);\n+        } else {\n+            newSelector = make.Indexed(map.mapVar,\n+                    make.App(make.Select(selector,\n+                            ordinalMethod)));\n+        }\n@@ -3680,3 +3713,8 @@\n-            if (c.pats.nonEmpty()) {\n-                VarSymbol label = (VarSymbol)TreeInfo.symbol(c.pats.head);\n-                JCLiteral pat = map.forConstant(label);\n+            if (c.labels.head.isExpression()) {\n+                JCExpression pat;\n+                if (TreeInfo.isNull(c.labels.head)) {\n+                    pat = makeLit(syms.intType, -1);\n+                } else {\n+                    VarSymbol label = (VarSymbol)TreeInfo.symbol((JCExpression) c.labels.head);\n+                    pat = map.forConstant(label);\n+                }\n@@ -3759,0 +3797,2 @@\n+            JCCase nullCase = null;\n+            int nullCaseLabel = -1;\n@@ -3761,12 +3801,4 @@\n-                if (oneCase.pats.nonEmpty()) { \/\/ pats is empty for a \"default\" case\n-                    JCExpression expression = oneCase.pats.head;\n-                    String labelExpr = (String) expression.type.constValue();\n-                    Integer mapping = caseLabelToPosition.put(labelExpr, casePosition);\n-                    Assert.checkNull(mapping);\n-                    int hashCode = labelExpr.hashCode();\n-\n-                    Set<String> stringSet = hashToString.get(hashCode);\n-                    if (stringSet == null) {\n-                        stringSet = new LinkedHashSet<>(1, 1.0f);\n-                        stringSet.add(labelExpr);\n-                        hashToString.put(hashCode, stringSet);\n+                if (oneCase.labels.head.isExpression()) {\n+                    if (TreeInfo.isNull(oneCase.labels.head)) {\n+                        nullCase = oneCase;\n+                        nullCaseLabel = casePosition;\n@@ -3774,2 +3806,15 @@\n-                        boolean added = stringSet.add(labelExpr);\n-                        Assert.check(added);\n+                        JCExpression expression = (JCExpression) oneCase.labels.head;\n+                        String labelExpr = (String) expression.type.constValue();\n+                        Integer mapping = caseLabelToPosition.put(labelExpr, casePosition);\n+                        Assert.checkNull(mapping);\n+                        int hashCode = labelExpr.hashCode();\n+\n+                        Set<String> stringSet = hashToString.get(hashCode);\n+                        if (stringSet == null) {\n+                            stringSet = new LinkedHashSet<>(1, 1.0f);\n+                            stringSet.add(labelExpr);\n+                            hashToString.put(hashCode, stringSet);\n+                        } else {\n+                            boolean added = stringSet.add(labelExpr);\n+                            Assert.check(added);\n+                        }\n@@ -3850,1 +3895,8 @@\n-            stmtList.append(switch1);\n+\n+            if (nullCase != null) {\n+                stmtList.append(make.If(makeBinary(NE, make.Ident(dollar_s), makeNull()), switch1, make.Exec(make.Assign(make.Ident(dollar_tmp),\n+                                                             make.Literal(nullCaseLabel)).\n+                                                 setType(dollar_tmp.type))).setType(syms.intType));\n+            } else {\n+                stmtList.append(switch1);\n+            }\n@@ -3858,2 +3910,2 @@\n-                boolean isDefault = (oneCase.pats.isEmpty());\n-                JCExpression caseExpr;\n+                boolean isDefault = !oneCase.labels.head.isExpression();\n+                JCCaseLabel caseExpr;\n@@ -3862,2 +3914,4 @@\n-                else {\n-                    caseExpr = make.Literal(caseLabelToPosition.get((String)TreeInfo.skipParens(oneCase.pats.head).\n+                else if (oneCase == nullCase) {\n+                    caseExpr = make.Literal(nullCaseLabel);\n+                } else {\n+                    caseExpr = make.Literal(caseLabelToPosition.get((String)TreeInfo.skipParens((JCExpression) oneCase.labels.head).\n@@ -3867,1 +3921,1 @@\n-                lb.append(make.Case(JCCase.STATEMENT, caseExpr == null ? List.nil() : List.of(caseExpr),\n+                lb.append(make.Case(JCCase.STATEMENT, caseExpr == null ? List.of(make.DefaultCaseLabel()) : List.of(caseExpr),\n@@ -3901,0 +3955,64 @@\n+    private JCTree visitBoxedPrimitiveSwitch(JCTree tree, JCExpression selector, List<JCCase> cases) {\n+        JCExpression newSelector;\n+\n+        if (cases.stream().anyMatch(c -> TreeInfo.isNull(c.labels.head))) {\n+            \/\/a switch over a boxed primitive, with a null case. Pick two constants that are\n+            \/\/not used by any branch in the case (c1 and c2), close to other constants that are\n+            \/\/used in the switch. Then do:\n+            \/\/switch ($selector != null ? $selector != c1 ? $selector : c2 : c1) {...}\n+            \/\/replacing case null with case c1\n+            Set<Integer> constants = new LinkedHashSet<>();\n+            JCCase nullCase = null;\n+\n+            for (JCCase c : cases) {\n+                if (TreeInfo.isNull(c.labels.head)) {\n+                    nullCase = c;\n+                } else if (!c.labels.head.hasTag(DEFAULTCASELABEL)) {\n+                    constants.add((int) c.labels.head.type.constValue());\n+                }\n+            }\n+\n+            Assert.checkNonNull(nullCase);\n+\n+            int nullValue = constants.isEmpty() ? 0 : constants.iterator().next();\n+\n+            while (constants.contains(nullValue)) nullValue++;\n+\n+            constants.add(nullValue);\n+            nullCase.labels.head = makeLit(syms.intType, nullValue);\n+\n+            int replacementValue = nullValue;\n+\n+            while (constants.contains(replacementValue)) replacementValue++;\n+\n+            VarSymbol dollar_s = new VarSymbol(FINAL|SYNTHETIC,\n+                                               names.fromString(\"s\" + tree.pos + this.target.syntheticNameChar()),\n+                                               selector.type,\n+                                               currentMethodSym);\n+            JCStatement var = make.at(tree.pos()).VarDef(dollar_s, selector).setType(dollar_s.type);\n+            JCExpression nullValueReplacement =\n+                    make.Conditional(makeBinary(NE,\n+                                                 unbox(make.Ident(dollar_s), syms.intType),\n+                                                 makeLit(syms.intType, nullValue)),\n+                                     unbox(make.Ident(dollar_s), syms.intType),\n+                                     makeLit(syms.intType, replacementValue))\n+                        .setType(syms.intType);\n+            JCExpression nullCheck =\n+                    make.Conditional(makeBinary(NE, make.Ident(dollar_s), makeNull()),\n+                                     nullValueReplacement,\n+                                     makeLit(syms.intType, nullValue))\n+                        .setType(syms.intType);\n+            newSelector = make.LetExpr(List.of(var), nullCheck).setType(syms.intType);\n+        } else {\n+            newSelector = unbox(selector, syms.intType);\n+        }\n+\n+        if (tree.hasTag(SWITCH)) {\n+            ((JCSwitch) tree).selector = newSelector;\n+        } else {\n+            ((JCSwitchExpression) tree).selector = newSelector;\n+        }\n+\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":156,"deletions":38,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCGuardPattern;\n@@ -99,7 +100,1 @@\n-                \/\/ e.T = union(x.T, y.T)\n-                \/\/ e.F = intersection(x.F, y.F) (error recovery)\n-                List<BindingSymbol> bindingsWhenTrue =\n-                        union(tree.pos(), lhsBindings.bindingsWhenTrue, rhsBindings.bindingsWhenTrue);\n-                List<BindingSymbol> bindingsWhenFalse = \/\/error recovery\n-                        intersection(tree.pos(), lhsBindings.bindingsWhenFalse, rhsBindings.bindingsWhenFalse);\n-                return new MatchBindings(bindingsWhenTrue, bindingsWhenFalse);\n+                return andOperation(tree.pos(), lhsBindings, rhsBindings);\n@@ -120,0 +115,30 @@\n+    public MatchBindings guardedPattern(JCGuardPattern tree, MatchBindings patternBindings, MatchBindings guardBindings) {\n+        return andOperation(tree.pos(), patternBindings, guardBindings);\n+    }\n+\n+    public MatchBindings andOperation(DiagnosticPosition pos, MatchBindings lhsBindings, MatchBindings rhsBindings) {\n+        \/\/ e.T = union(x.T, y.T)\n+        \/\/ e.F = intersection(x.F, y.F) (error recovery)\n+        List<BindingSymbol> bindingsWhenTrue =\n+                union(pos, lhsBindings.bindingsWhenTrue, rhsBindings.bindingsWhenTrue);\n+        List<BindingSymbol> bindingsWhenFalse = \/\/error recovery\n+                intersection(pos, lhsBindings.bindingsWhenFalse, rhsBindings.bindingsWhenFalse);\n+        return new MatchBindings(bindingsWhenTrue, bindingsWhenFalse);\n+    }\n+\n+    public MatchBindings switchCase(JCTree tree, MatchBindings prevBindings, MatchBindings currentBindings) {\n+        if (prevBindings == null)\n+            return currentBindings;\n+        if (!prevBindings.bindingsWhenTrue.isEmpty() && !currentBindings.bindingsWhenTrue.isEmpty()) {\n+            log.error(tree.pos(), Errors.FlowsThroughToPattern);\n+        }\n+        if (prevBindings.nullPattern) {\n+            return currentBindings;\n+        }\n+        if (currentBindings.nullPattern) {\n+            return prevBindings;\n+        }\n+        return new MatchBindings(intersection(tree.pos(), prevBindings.bindingsWhenTrue, currentBindings.bindingsWhenTrue),\n+                                 intersection(tree.pos(), prevBindings.bindingsWhenFalse, currentBindings.bindingsWhenFalse));\n+    }\n+\n@@ -123,0 +148,1 @@\n+            case PARENTHESIZEDPATTERN: case GUARDPATTERN:\n@@ -135,0 +161,1 @@\n+        public final boolean nullPattern;\n@@ -137,0 +164,4 @@\n+            this(bindingsWhenTrue, bindingsWhenFalse, false);\n+        }\n+\n+        public MatchBindings(List<BindingSymbol> bindingsWhenTrue, List<BindingSymbol> bindingsWhenFalse, boolean nullPattern) {\n@@ -139,0 +170,1 @@\n+            this.nullPattern = nullPattern;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MatchBindingsComputer.java","additions":39,"deletions":7,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import com.sun.source.tree.CaseTree;\n+import com.sun.tools.javac.code.BoundKind;\n@@ -31,0 +33,1 @@\n+import com.sun.tools.javac.code.Preview;\n@@ -33,0 +36,2 @@\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import com.sun.tools.javac.code.Symbol.DynamicMethodSymbol;\n@@ -47,0 +52,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCSwitch;\n@@ -55,1 +61,0 @@\n-import com.sun.tools.javac.util.Log;\n@@ -59,0 +64,1 @@\n+import java.util.Collection;\n@@ -64,0 +70,4 @@\n+import com.sun.tools.javac.code.Type.ClassType;\n+import com.sun.tools.javac.code.Type.MethodType;\n+import com.sun.tools.javac.code.Type.WildcardType;\n+import com.sun.tools.javac.code.TypeTag;\n@@ -65,0 +75,1 @@\n+import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;\n@@ -68,0 +79,5 @@\n+import com.sun.tools.javac.tree.JCTree.JCBreak;\n+import com.sun.tools.javac.tree.JCTree.JCCase;\n+import com.sun.tools.javac.tree.JCTree.JCCaseLabel;\n+import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n+import com.sun.tools.javac.tree.JCTree.JCContinue;\n@@ -69,0 +85,2 @@\n+import com.sun.tools.javac.tree.JCTree.JCFieldAccess;\n+import com.sun.tools.javac.tree.JCTree.JCGuardPattern;\n@@ -70,0 +88,2 @@\n+import com.sun.tools.javac.tree.JCTree.JCParenthesizedPattern;\n+import com.sun.tools.javac.tree.JCTree.JCPattern;\n@@ -71,0 +91,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCSwitchExpression;\n@@ -73,0 +94,1 @@\n+import com.sun.tools.javac.util.Assert;\n@@ -90,0 +112,2 @@\n+    private final Attr attr;\n+    private final Resolve rs;\n@@ -92,2 +116,0 @@\n-    private final Log log;\n-    private final ConstFold constFold;\n@@ -96,0 +118,1 @@\n+    private final Preview preview;\n@@ -97,0 +120,1 @@\n+    private Env<AttrContext> env;\n@@ -109,0 +133,5 @@\n+        @Override\n+        List<JCStatement> bindingVars(int diagPos) {\n+            return List.nil();\n+        }\n+\n@@ -135,0 +164,1 @@\n+    private ClassSymbol currentClass = null;\n@@ -136,0 +166,1 @@\n+    private VarSymbol currentValue = null;\n@@ -140,0 +171,2 @@\n+        attr = Attr.instance(context);\n+        rs = Resolve.instance(context);\n@@ -143,2 +176,0 @@\n-        log = Log.instance(context);\n-        constFold = ConstFold.instance(context);\n@@ -147,0 +178,1 @@\n+        preview = Preview.instance(context);\n@@ -152,2 +184,2 @@\n-        if (tree.pattern.hasTag(Tag.BINDINGPATTERN)) {\n-            \/\/E instanceof T N\n+        if (tree.pattern instanceof JCPattern) {\n+            \/\/E instanceof $pattern\n@@ -155,1 +187,2 @@\n-            \/\/(let T' N$temp = E; N$temp instanceof T && (N = (T) N$temp == (T) N$temp))\n+            \/\/(let T' N$temp = E; N$temp instanceof typeof($pattern) && <desugared $pattern>)\n+            \/\/note the pattern desugaring performs binding variable assignments\n@@ -157,2 +190,0 @@\n-            JCBindingPattern patt = (JCBindingPattern)tree.pattern;\n-            VarSymbol pattSym = patt.var.sym;\n@@ -162,5 +193,200 @@\n-            VarSymbol temp;\n-            if (exprSym != null &&\n-                exprSym.kind == Kind.VAR &&\n-                exprSym.owner.kind.matches(Kinds.KindSelector.VAL_MTH)) {\n-                temp = (VarSymbol) exprSym;\n+            VarSymbol prevCurrentValue = currentValue;\n+            try {\n+                if (exprSym != null &&\n+                    exprSym.kind == Kind.VAR &&\n+                    exprSym.owner.kind.matches(Kinds.KindSelector.VAL_MTH)) {\n+                    currentValue = (VarSymbol) exprSym;\n+                } else {\n+                    currentValue = new VarSymbol(Flags.FINAL | Flags.SYNTHETIC,\n+                            names.fromString(\"patt\" + tree.pos + target.syntheticNameChar() + \"temp\"),\n+                            tempType,\n+                            currentMethodSym);\n+                }\n+\n+                JCExpression translatedExpr = translate(tree.expr);\n+                Type principalType = principalType((JCPattern) tree.pattern);\n+                result = makeBinary(Tag.AND,\n+                                    makeTypeTest(make.Ident(currentValue), make.Type(principalType)),\n+                                    (JCExpression) this.<JCTree>translate(tree.pattern));\n+                if (currentValue != exprSym) {\n+                    result = make.at(tree.pos).LetExpr(make.VarDef(currentValue, translatedExpr),\n+                                                        (JCExpression)result).setType(syms.booleanType);\n+                    ((LetExpr) result).needsCond = true;\n+                }\n+            } finally {\n+                currentValue = prevCurrentValue;\n+            }\n+        } else {\n+            super.visitTypeTest(tree);\n+        }\n+    }\n+\n+    @Override\n+    public void visitBindingPattern(JCBindingPattern tree) {\n+        \/\/it is assumed the primary type has already been checked:\n+        BindingSymbol binding = (BindingSymbol) tree.var.sym;\n+        Type castTargetType = principalType(tree);\n+        VarSymbol bindingVar = bindingContext.bindingDeclared(binding);\n+\n+        if (bindingVar != null) {\n+            JCAssign fakeInit = (JCAssign)make.at(TreeInfo.getStartPos(tree)).Assign(\n+                    make.Ident(bindingVar), convert(make.Ident(currentValue), castTargetType)).setType(bindingVar.erasure(types));\n+            LetExpr nestedLE = make.LetExpr(List.of(make.Exec(fakeInit)),\n+                                            make.Literal(true));\n+            nestedLE.needsCond = true;\n+            nestedLE.setType(syms.booleanType);\n+            result = nestedLE;\n+        } else {\n+            result = make.Literal(true);\n+        }\n+    }\n+\n+    @Override\n+    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n+        result = translate(tree.pattern);\n+    }\n+\n+    @Override\n+    public void visitGuardPattern(JCGuardPattern tree) {\n+        JCExpression pattern = (JCExpression) this.<JCTree>translate(tree.patt);\n+        JCExpression guard = translate(tree.expr);\n+        result = makeBinary(Tag.AND, pattern, guard);\n+    }\n+\n+    @Override\n+    public void visitSwitch(JCSwitch tree) {\n+        handleSwitch(tree, tree.selector, tree.cases, tree.hasTotalPattern, tree.patternSwitch);\n+    }\n+\n+    @Override\n+    public void visitSwitchExpression(JCSwitchExpression tree) {\n+        handleSwitch(tree, tree.selector, tree.cases, tree.hasTotalPattern, tree.patternSwitch);\n+    }\n+\n+    private void handleSwitch(JCTree tree,\n+                              JCExpression selector,\n+                              List<JCCase> cases,\n+                              boolean hasTotalPattern,\n+                              boolean patternSwitch) {\n+        Type seltype = selector.type;\n+        boolean enumSwitch = (seltype.tsym.flags() & Flags.ENUM) != 0;\n+\n+        if (patternSwitch) {\n+            Assert.check(preview.isEnabled());\n+            Assert.check(preview.usesPreview(env.toplevel.sourcefile));\n+\n+            \/\/rewrite pattern matching switches:\n+            \/\/switch ($obj) {\n+            \/\/     case $constant: $stats$\n+            \/\/     case $pattern1: $stats$\n+            \/\/     case $pattern2, null: $stats$\n+            \/\/     case $pattern3: $stats$\n+            \/\/}\n+            \/\/=>\n+            \/\/int $idx = 0;\n+            \/\/$RESTART: switch (invokeDynamic typeSwitch($constant, typeof($pattern1), typeof($pattern2), typeof($pattern3))($obj, $idx)) {\n+            \/\/     case 0:\n+            \/\/         if (!(<desugared $pattern1>)) { $idx = 1; continue $RESTART; }\n+            \/\/         $stats$\n+            \/\/     case 1:\n+            \/\/         if (!(<desugared $pattern1>)) { $idx = 2; continue $RESTART; }\n+            \/\/         $stats$\n+            \/\/     case 2, -1:\n+            \/\/         if (!(<desugared $pattern1>)) { $idx = 3; continue $RESTART; }\n+            \/\/         $stats$\n+            \/\/     case 3:\n+            \/\/         if (!(<desugared $pattern1>)) { $idx = 4; continue $RESTART; }\n+            \/\/         $stats$\n+            \/\/}\n+            \/\/notes:\n+            \/\/-pattern desugaring performs assignment to the binding variables\n+            \/\/-the selector is evaluated only once and stored in a temporary variable\n+            \/\/-typeSwitch bootstrap method can restart matching at specified index. The bootstrap will\n+            \/\/ categorize the input, and return the case index whose type or constant matches the input.\n+            \/\/ The bootstrap does not evaluate guards, which are injected at the beginning of the case's\n+            \/\/ statement list, and if the guard fails, the switch is \"continued\" and matching is\n+            \/\/ restarted from the next index.\n+            \/\/-case null is always desugared to case -1, as the typeSwitch bootstrap method will\n+            \/\/ return -1 when the input is null\n+            \/\/\n+            \/\/a special case for switches over enums with pattern case\n+            \/\/with only a single unguarded (type) pattern case, which is equivalent\n+            \/\/to a default with additional binding variable assignment:\n+            \/\/switch ($enum) {\n+            \/\/    case $constant1: $stats$\n+            \/\/    case $constant2: $stats$\n+            \/\/    case typeof($enum) e: $stats$\n+            \/\/}\n+            \/\/=>\n+            \/\/switch ($enum) {\n+            \/\/    case $constant1: $stats$\n+            \/\/    case $constant2: $stats$\n+            \/\/    default: typeof($enum) e = $enum; $stats$\n+            \/\/}\n+            \/\/constant labels in switches over enums with one or more pattern cases\n+            \/\/with guards are desugared into guards:\n+            \/\/case $constant1: $stats$\n+            \/\/=>\n+            \/\/case typeof($enum) e && e == $constant1: $stats$\n+            \/\/and handled as a normal pattern matching switch\n+            \/\/\n+            \/\/note the selector is evaluated only once and stored in a temporary variable\n+            ListBuffer<JCCase> newCases = new ListBuffer<>();\n+            for (List<JCCase> c = cases; c.nonEmpty(); c = c.tail) {\n+                if (c.head.stats.isEmpty() && c.tail.nonEmpty()) {\n+                    c.tail.head.labels = c.tail.head.labels.prependList(c.head.labels);\n+                } else {\n+                    newCases.add(c.head);\n+                }\n+            }\n+            if (enumSwitch && hasGuards(newCases)) {\n+                for (JCCase c : newCases) {\n+                    for (List<JCCaseLabel> l = c.labels; l.nonEmpty(); l = l.tail) {\n+                        if (l.head.isExpression() && !TreeInfo.isNull(l.head)) {\n+                            BindingSymbol temp = new BindingSymbol(Flags.SYNTHETIC,\n+                                    names.fromString(\"enumGuard\" + c.pos +\n+                                                     target.syntheticNameChar() + \"temp\"),\n+                                    seltype,\n+                                    currentMethodSym);\n+                            JCBindingPattern binding =\n+                                    make.at(l.head.pos()).BindingPattern(make.VarDef(temp, null));\n+                            binding.setType(seltype);\n+                            l.head = make.GuardPattern(binding,\n+                                                       makeBinary(Tag.EQ,\n+                                                                  make.Ident(temp),\n+                                                                  (JCExpression) l.head));\n+                        }\n+                    }\n+                }\n+                enumSwitch = false;\n+            }\n+            cases = newCases.toList();\n+            ListBuffer<JCStatement> statements = new ListBuffer<>();\n+            VarSymbol temp = new VarSymbol(Flags.SYNTHETIC,\n+                    names.fromString(\"selector\" + tree.pos + target.syntheticNameChar() + \"temp\"),\n+                    seltype,\n+                    currentMethodSym);\n+            boolean hasNullCase = cases.stream()\n+                                       .flatMap(c -> c.labels.stream())\n+                                       .anyMatch(p -> p.isExpression() &&\n+                                                      TreeInfo.isNull((JCExpression) p));\n+\n+            JCCase lastCase = cases.last();\n+\n+            if (hasTotalPattern && !hasNullCase) {\n+                JCCase last = lastCase;\n+                if (last.labels.stream().noneMatch(l -> l.hasTag(Tag.DEFAULTCASELABEL))) {\n+                    last.labels = last.labels.prepend(makeLit(syms.botType, null));\n+                    hasNullCase = true;\n+                }\n+            }\n+            statements.append(make.at(tree.pos).VarDef(temp, !hasNullCase ? attr.makeNullCheck(selector)\n+                                                                          : selector));\n+            VarSymbol index = new VarSymbol(Flags.SYNTHETIC,\n+                    names.fromString(tree.pos + target.syntheticNameChar() + \"index\"),\n+                    syms.intType,\n+                    currentMethodSym);\n+            statements.append(make.at(tree.pos).VarDef(index, makeLit(syms.intType, 0)));\n+\n+            if (enumSwitch) {\n+                selector = make.Ident(temp);\n@@ -168,4 +394,36 @@\n-                temp = new VarSymbol(pattSym.flags() | Flags.SYNTHETIC,\n-                        names.fromString(pattSym.name.toString() + target.syntheticNameChar() + \"temp\"),\n-                        tempType,\n-                        patt.var.sym.owner);\n+                List<Type> staticArgTypes = List.of(syms.methodHandleLookupType,\n+                                                    syms.stringType,\n+                                                    syms.methodTypeType,\n+                                                    types.makeArrayType(new ClassType(syms.classType.getEnclosingType(),\n+                                                                        List.of(new WildcardType(syms.objectType, BoundKind.UNBOUND,\n+                                                                                                 syms.boundClass)),\n+                                                                        syms.classType.tsym)));\n+                LoadableConstant[] staticArgValues =\n+                        cases.stream()\n+                             .flatMap(c -> c.labels.stream())\n+                             .map(l -> toLoadableConstant(l))\n+                             .filter(c -> c != null)\n+                             .toArray(s -> new LoadableConstant[s]);\n+\n+                Symbol bsm = rs.resolveInternalMethod(tree.pos(), env, syms.switchBootstrapsType,\n+                        names.fromString(\"typeSwitch\"), staticArgTypes, List.nil());\n+\n+                MethodType indyType = new MethodType(\n+                        List.of(syms.objectType, syms.intType),\n+                        syms.intType,\n+                        List.nil(),\n+                        syms.methodClass\n+                );\n+                DynamicMethodSymbol dynSym = new DynamicMethodSymbol(names.fromString(\"typeSwitch\"),\n+                        syms.noSymbol,\n+                        ((MethodSymbol)bsm).asHandle(),\n+                        indyType,\n+                        staticArgValues);\n+\n+                JCFieldAccess qualifier = make.Select(make.QualIdent(bsm.owner), dynSym.name);\n+                qualifier.sym = dynSym;\n+                qualifier.type = syms.intType;\n+                selector = make.Apply(List.nil(),\n+                                      qualifier,\n+                                      List.of(make.Ident(temp), make.Ident(index)))\n+                               .setType(syms.intType);\n@@ -173,14 +431,73 @@\n-            JCExpression translatedExpr = translate(tree.expr);\n-            Type castTargetType = types.boxedTypeOrType(pattSym.erasure(types));\n-\n-            result = makeTypeTest(make.Ident(temp), make.Type(castTargetType));\n-\n-            VarSymbol bindingVar = bindingContext.bindingDeclared((BindingSymbol) patt.var.sym);\n-            if (bindingVar != null) { \/\/TODO: cannot be null here?\n-                JCAssign fakeInit = (JCAssign)make.at(tree.pos).Assign(\n-                        make.Ident(bindingVar), convert(make.Ident(temp), castTargetType)).setType(bindingVar.erasure(types));\n-                LetExpr nestedLE = make.LetExpr(List.of(make.Exec(fakeInit)),\n-                                                make.Literal(true));\n-                nestedLE.needsCond = true;\n-                nestedLE.setType(syms.booleanType);\n-                result = makeBinary(Tag.AND, (JCExpression)result, nestedLE);\n+\n+            int i = 0;\n+            boolean previousCompletesNormally = false;\n+\n+            for (var c : cases) {\n+                List<JCCaseLabel> clearedPatterns = c.labels;\n+                boolean hasJoinedNull =\n+                        c.labels.size() > 1 && c.labels.stream().anyMatch(l -> l.isNullPattern());\n+                if (hasJoinedNull) {\n+                    clearedPatterns = c.labels.stream()\n+                                              .filter(l -> !l.isNullPattern())\n+                                              .collect(List.collector());\n+                }\n+                if (clearedPatterns.size() == 1 && clearedPatterns.head.isPattern() && !previousCompletesNormally) {\n+                    JCCaseLabel p = clearedPatterns.head;\n+                    bindingContext = new BasicBindingContext();\n+                    VarSymbol prevCurrentValue = currentValue;\n+                    try {\n+                        currentValue = temp;\n+                        JCExpression test = (JCExpression) this.<JCTree>translate(p);\n+                        c.stats = translate(c.stats);\n+                        JCContinue continueSwitch = make.at(clearedPatterns.head.pos()).Continue(null);\n+                        continueSwitch.target = tree;\n+                        c.stats = c.stats.prepend(make.If(makeUnary(Tag.NOT, test).setType(syms.booleanType),\n+                                                           make.Block(0, List.of(make.Exec(make.Assign(make.Ident(index),\n+                                                                                                       makeLit(syms.intType, i + 1))\n+                                                                                     .setType(syms.intType)),\n+                                                                                 continueSwitch)),\n+                                                           null));\n+                        c.stats = c.stats.prependList(bindingContext.bindingVars(c.pos));\n+                    } finally {\n+                        currentValue = prevCurrentValue;\n+                        bindingContext.pop();\n+                    }\n+                }\n+                if (enumSwitch) {\n+                    var labels = c.labels;\n+\n+                    while (labels.nonEmpty()) {\n+                        if (labels.head.isPattern()) {\n+                            labels.head = make.DefaultCaseLabel();\n+                        }\n+                        labels = labels.tail;\n+                    }\n+                } else {\n+                    ListBuffer<JCCaseLabel> translatedLabels = new ListBuffer<>();\n+                    for (var p : c.labels) {\n+                        if (p.hasTag(Tag.DEFAULTCASELABEL)) {\n+                            translatedLabels.add(p);\n+                        } else if (hasTotalPattern && c == lastCase && p.isPattern()) {\n+                            \/\/If the switch has total pattern, the last case will contain it.\n+                            \/\/Convert the total pattern to default:\n+                            translatedLabels.add(make.DefaultCaseLabel());\n+                        } else {\n+                            int value;\n+                            if (p.isNullPattern()) {\n+                                value = -1;\n+                            } else {\n+                                value = i++;\n+                            }\n+                            translatedLabels.add(make.Literal(value));\n+                        }\n+                    }\n+                    c.labels = translatedLabels.toList();\n+                }\n+                if (c.caseKind == CaseTree.CaseKind.STATEMENT) {\n+                    previousCompletesNormally = c.completesNormally;\n+                } else {\n+                    previousCompletesNormally = false;\n+                    JCBreak brk = make.at(TreeInfo.endPos(c.stats.last())).Break(null);\n+                    brk.target = tree;\n+                    c.stats = c.stats.append(brk);\n+                }\n@@ -188,3 +505,14 @@\n-            if (temp != exprSym) {\n-                result = make.at(tree.pos).LetExpr(make.VarDef(temp, translatedExpr), (JCExpression)result).setType(syms.booleanType);\n-                ((LetExpr) result).needsCond = true;\n+\n+            if (tree.hasTag(Tag.SWITCH)) {\n+                ((JCSwitch) tree).selector = selector;\n+                ((JCSwitch) tree).cases = cases;\n+                statements.append((JCSwitch) tree);\n+                result = make.Block(0, statements.toList());\n+            } else {\n+                ((JCSwitchExpression) tree).selector = selector;\n+                ((JCSwitchExpression) tree).cases = cases;\n+                LetExpr r = (LetExpr) make.LetExpr(statements.toList(), (JCSwitchExpression) tree)\n+                                          .setType(tree.type);\n+\n+                r.needsCond = true;\n+                result = r;\n@@ -192,0 +520,4 @@\n+            return ;\n+        }\n+        if (tree.hasTag(Tag.SWITCH)) {\n+            super.visitSwitch((JCSwitch) tree);\n@@ -193,1 +525,29 @@\n-            super.visitTypeTest(tree);\n+            super.visitSwitchExpression((JCSwitchExpression) tree);\n+        }\n+    }\n+\n+    private boolean hasGuards(Collection<JCCase> cases) {\n+        return cases.stream()\n+                    .flatMap(c -> c.labels.stream())\n+                    .filter(JCCaseLabel::isPattern)\n+                    .anyMatch(l -> !TreeInfo.primaryPatternType((JCPattern) l).unconditional());\n+    }\n+\n+    private Type principalType(JCPattern p) {\n+        return types.boxedTypeOrType(types.erasure(TreeInfo.primaryPatternType(p).type()));\n+    }\n+\n+    private LoadableConstant toLoadableConstant(JCCaseLabel l) {\n+        if (l.isPattern()) {\n+            return (LoadableConstant) principalType((JCPattern) l);\n+        } else if (l.isExpression() && !TreeInfo.isNull((JCExpression) l)) {\n+            Assert.checkNonNull(l.type.constValue());\n+\n+            return switch (l.type.getTag()) {\n+                case BYTE, CHAR,\n+                     SHORT, INT -> LoadableConstant.Int((Integer) l.type.constValue());\n+                case CLASS -> LoadableConstant.String((String) l.type.constValue());\n+                default -> throw new AssertionError();\n+            };\n+        } else {\n+            return null;\n@@ -311,0 +671,1 @@\n+        MethodSymbol oldMethodSym = currentMethodSym;\n@@ -312,0 +673,7 @@\n+            if (currentMethodSym == null) {\n+                \/\/ Block is a static or instance initializer.\n+                currentMethodSym =\n+                    new MethodSymbol(tree.flags | Flags.BLOCK,\n+                                     names.empty, null,\n+                                     currentClass);\n+            }\n@@ -319,0 +687,1 @@\n+            currentMethodSym = oldMethodSym;\n@@ -334,0 +703,30 @@\n+    @Override\n+    public void visitClassDef(JCClassDecl tree) {\n+        ClassSymbol prevCurrentClass = currentClass;\n+        try {\n+            currentClass = tree.sym;\n+            super.visitClassDef(tree);\n+        } finally {\n+            currentClass = prevCurrentClass;\n+        }\n+    }\n+\n+    public void visitVarDef(JCVariableDecl tree) {\n+        MethodSymbol prevMethodSym = currentMethodSym;\n+        try {\n+            tree.mods = translate(tree.mods);\n+            tree.vartype = translate(tree.vartype);\n+            if (currentMethodSym == null) {\n+                \/\/ A class or instance field initializer.\n+                currentMethodSym =\n+                    new MethodSymbol((tree.mods.flags&Flags.STATIC) | Flags.BLOCK,\n+                                     names.empty, null,\n+                                     currentClass);\n+            }\n+            if (tree.init != null) tree.init = translate(tree.init);\n+            result = tree;\n+        } finally {\n+            currentMethodSym = prevMethodSym;\n+        }\n+    }\n+\n@@ -337,0 +736,1 @@\n+            this.env = env;\n@@ -341,0 +741,1 @@\n+            this.env = null;\n@@ -369,0 +770,11 @@\n+    \/** Make an attributed unary expression.\n+     *  @param optag    The operators tree tag.\n+     *  @param arg      The operator's argument.\n+     *\/\n+    JCTree.JCUnary makeUnary(JCTree.Tag optag, JCExpression arg) {\n+        JCTree.JCUnary tree = make.Unary(optag, arg);\n+        tree.operator = operators.resolveUnary(tree, optag, arg.type);\n+        tree.type = tree.operator.type.getReturnType();\n+        return tree;\n+    }\n+\n@@ -378,0 +790,1 @@\n+        abstract List<JCStatement> bindingVars(int diagPos);\n@@ -416,0 +829,14 @@\n+        @Override\n+        List<JCStatement> bindingVars(int diagPos) {\n+            if (hoistedVarMap.isEmpty()) return List.nil();\n+            ListBuffer<JCStatement> stats = new ListBuffer<>();\n+            for (Entry<BindingSymbol, VarSymbol> e : hoistedVarMap.entrySet()) {\n+                JCVariableDecl decl = makeHoistedVarDecl(diagPos, e.getValue());\n+                if (!e.getKey().isPreserved() ||\n+                    !parent.tryPrepend(e.getKey(), decl)) {\n+                    stats.add(decl);\n+                }\n+            }\n+            return stats.toList();\n+        }\n+\n@@ -418,1 +845,0 @@\n-            if (hoistedVarMap.isEmpty()) return stat;\n@@ -429,8 +855,1 @@\n-            ListBuffer<JCStatement> stats = new ListBuffer<>();\n-            for (Entry<BindingSymbol, VarSymbol> e : hoistedVarMap.entrySet()) {\n-                JCVariableDecl decl = makeHoistedVarDecl(stat.pos, e.getValue());\n-                if (!e.getKey().isPreserved() ||\n-                    !parent.tryPrepend(e.getKey(), decl)) {\n-                    stats.add(decl);\n-                }\n-            }\n+            List<JCStatement> stats = bindingVars(stat.pos);\n@@ -438,2 +857,1 @@\n-                stats.add(stat);\n-                stat = make.at(stat.pos).Block(0, stats.toList());\n+                stat = make.at(stat.pos).Block(0, stats.append(stat));\n@@ -478,0 +896,10 @@\n+\n+    \/** Make an attributed tree representing a literal. This will be an\n+     *  Ident node in the case of boolean literals, a Literal node in all\n+     *  other cases.\n+     *  @param type       The literal's type.\n+     *  @param value      The literal's value.\n+     *\/\n+    JCExpression makeLit(Type type, Object value) {\n+        return make.Literal(type.getTag(), value).setType(type.constType(value));\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":476,"deletions":48,"binary":false,"changes":524,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.*;\n@@ -34,3 +33,0 @@\n-import com.sun.tools.javac.code.Type.IntersectionClassType;\n-import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;\n-import com.sun.tools.javac.resources.CompilerProperties.Errors;\n@@ -565,1 +561,1 @@\n-        tree.pats = translate(tree.pats, null);\n+        tree.labels = translate(tree.labels, null);\n@@ -586,0 +582,13 @@\n+    @Override\n+    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n+        tree.pattern = translate(tree.pattern, null);\n+        result = tree;\n+    }\n+\n+    @Override\n+    public void visitGuardPattern(JCGuardPattern tree) {\n+        tree.patt = translate(tree.patt, null);\n+        tree.expr = translate(tree.expr, syms.booleanType);\n+        result = tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCDefaultCaseLabel;\n@@ -287,1 +288,6 @@\n-        result = scan(tree.pats, that.pats) && scan(tree.stats, that.stats);\n+        result = scan(tree.labels, that.labels) && scan(tree.stats, that.stats);\n+    }\n+\n+    @Override\n+    public void visitDefaultCaseLabel(JCDefaultCaseLabel tree) {\n+        result = true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TreeDiffer.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -325,1 +325,1 @@\n-            sr.mergeWith(csp(tree.pats));\n+            sr.mergeWith(csp(tree.labels));\n@@ -330,0 +330,5 @@\n+        @Override\n+        public void visitDefaultCaseLabel(JCTree.JCDefaultCaseLabel that) {\n+            result = null;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/CRTable.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1193,1 +1193,1 @@\n-        handleSwitch(tree, tree.selector, tree.cases);\n+        handleSwitch(tree, tree.selector, tree.cases, tree.patternSwitch);\n@@ -1238,1 +1238,1 @@\n-                handleSwitch(tree, tree.selector, tree.cases);\n+                handleSwitch(tree, tree.selector, tree.cases, tree.patternSwitch);\n@@ -1268,1 +1268,2 @@\n-    private void handleSwitch(JCTree swtch, JCExpression selector, List<JCCase> cases) {\n+    private void handleSwitch(JCTree swtch, JCExpression selector, List<JCCase> cases,\n+                              boolean patternSwitch) {\n@@ -1271,0 +1272,1 @@\n+        int switchStart = patternSwitch ? code.entryPoint() : -1;\n@@ -1300,3 +1302,3 @@\n-                if (l.head.pats.nonEmpty()) {\n-                    Assert.check(l.head.pats.size() == 1);\n-                    int val = ((Number)l.head.pats.head.type.constValue()).intValue();\n+                if (l.head.labels.head.isExpression()) {\n+                    Assert.check(l.head.labels.size() == 1);\n+                    int val = ((Number)((JCExpression) l.head.labels.head).type.constValue()).intValue();\n@@ -1374,0 +1376,6 @@\n+            if (switchEnv.info.cont != null) {\n+                Assert.check(patternSwitch);\n+                code.resolve(switchEnv.info.cont);\n+                code.resolve(code.branch(goto_), switchStart);\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+import java.util.function.BiFunction;\n@@ -761,0 +762,27 @@\n+\n+    \/** parses patterns.\n+     *\/\n+\n+    public JCPattern parsePattern(int pos, JCModifiers mods, JCExpression parsedType, boolean inInstanceOf) {\n+        if (token.kind == LPAREN && parsedType == null) {\n+            int startPos = token.pos;\n+            accept(LPAREN);\n+            JCPattern p = parsePattern(token.pos, null, null, false);\n+            accept(RPAREN);\n+            return toP(F.at(startPos).ParenthesizedPattern(p));\n+        } else {\n+            JCPattern pattern;\n+            JCExpression e = parsedType == null ? term(EXPR | TYPE | NOLAMBDA) : parsedType;\n+            mods = mods != null ? mods : F.at(token.pos).Modifiers(0);\n+            JCVariableDecl var = toP(F.at(token.pos).VarDef(mods, ident(), e, null));\n+            pattern = toP(F.at(pos).BindingPattern(var));\n+            if (!inInstanceOf && token.kind == AMPAMP) {\n+                checkSourceLevel(Feature.PATTERN_SWITCH);\n+                nextToken();\n+                JCExpression guard = term(EXPR | NOLAMBDA);\n+                pattern = F.at(pos).GuardPattern(pattern, guard);\n+            }\n+            return pattern;\n+        }\n+    }\n+\n@@ -939,4 +967,0 @@\n-                int patternPos = token.pos;\n-                JCModifiers mods = optFinal(0);\n-                int typePos = token.pos;\n-                JCExpression type = unannotatedType(false);\n@@ -944,4 +968,3 @@\n-                if (token.kind == IDENTIFIER) {\n-                    checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);\n-                    JCVariableDecl var = toP(F.at(token.pos).VarDef(mods, ident(), type, null));\n-                    pattern = toP(F.at(patternPos).BindingPattern(var));\n+                if (token.kind == LPAREN) {\n+                    checkSourceLevel(token.pos, Feature.PATTERN_SWITCH);\n+                    pattern = parsePattern(token.pos, null, null, true);\n@@ -949,13 +972,23 @@\n-                    checkNoMods(typePos, mods.flags & ~Flags.DEPRECATED);\n-                    if (mods.annotations.nonEmpty()) {\n-                        checkSourceLevel(mods.annotations.head.pos, Feature.TYPE_ANNOTATIONS);\n-                        List<JCAnnotation> typeAnnos =\n-                                mods.annotations\n-                                    .map(decl -> {\n-                                        JCAnnotation typeAnno = F.at(decl.pos)\n-                                                                 .TypeAnnotation(decl.annotationType,\n-                                                                                  decl.args);\n-                                        endPosTable.replaceTree(decl, typeAnno);\n-                                        return typeAnno;\n-                                    });\n-                        type = insertAnnotationsToMostInner(type, typeAnnos, false);\n+                    int patternPos = token.pos;\n+                    JCModifiers mods = optFinal(0);\n+                    int typePos = token.pos;\n+                    JCExpression type = unannotatedType(false);\n+                    if (token.kind == IDENTIFIER) {\n+                        checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);\n+                        pattern = parsePattern(patternPos, mods, type, true);\n+                    } else {\n+                        checkNoMods(typePos, mods.flags & ~Flags.DEPRECATED);\n+                        if (mods.annotations.nonEmpty()) {\n+                            checkSourceLevel(mods.annotations.head.pos, Feature.TYPE_ANNOTATIONS);\n+                            List<JCAnnotation> typeAnnos =\n+                                    mods.annotations\n+                                        .map(decl -> {\n+                                            JCAnnotation typeAnno = F.at(decl.pos)\n+                                                                     .TypeAnnotation(decl.annotationType,\n+                                                                                      decl.args);\n+                                            endPosTable.replaceTree(decl, typeAnno);\n+                                            return typeAnno;\n+                                        });\n+                            type = insertAnnotationsToMostInner(type, typeAnnos, false);\n+                        }\n+                        pattern = type;\n@@ -963,1 +996,0 @@\n-                    pattern = type;\n@@ -1464,1 +1496,1 @@\n-        ListBuffer<JCExpression> pats = new ListBuffer<>();\n+        ListBuffer<JCCaseLabel> pats = new ListBuffer<>();\n@@ -1468,0 +1500,1 @@\n+            pats.append(toP(F.at(casePos).DefaultCaseLabel()));\n@@ -1471,1 +1504,2 @@\n-                pats.append(term(EXPR | NOLAMBDA));\n+                JCCaseLabel label = parseCaseLabel();\n+                pats.append(label);\n@@ -2965,1 +2999,1 @@\n-            ListBuffer<JCExpression> pats = new ListBuffer<>();\n+            ListBuffer<JCCaseLabel> pats = new ListBuffer<>();\n@@ -2967,1 +3001,1 @@\n-                pats.append(term(EXPR | NOLAMBDA));\n+                pats.append(parseCaseLabel());\n@@ -2998,0 +3032,1 @@\n+            int patternPos = token.pos;\n@@ -3013,1 +3048,2 @@\n-            c = F.at(pos).Case(caseKind, List.nil(), stats, body);\n+            JCCaseLabel defaultPattern = toP(F.at(patternPos).DefaultCaseLabel());\n+            c = F.at(pos).Case(caseKind, List.of(defaultPattern), stats, body);\n@@ -3022,0 +3058,40 @@\n+    private JCCaseLabel parseCaseLabel() {\n+        int patternPos = token.pos;\n+        JCCaseLabel label;\n+\n+        if (token.kind == DEFAULT) {\n+            checkSourceLevel(token.pos, Feature.PATTERN_SWITCH);\n+            nextToken();\n+            label = toP(F.at(patternPos).DefaultCaseLabel());\n+        } else {\n+            if (token.kind == LPAREN) {\n+                int lookahead = 0;\n+                Token ahead;\n+                while ((ahead = S.token(lookahead)).kind != EOF && ahead.kind != RPAREN && ahead.kind != AMPAMP) {\n+                    lookahead++;\n+                }\n+                Token twoBack;\n+                boolean pattern = S.token(lookahead - 1).kind == IDENTIFIER &&\n+                                  ((twoBack = S.token(lookahead - 2)).kind == IDENTIFIER ||\n+                                   twoBack.kind == GT || twoBack.kind == GTGT || twoBack.kind == GTGTGT);\n+                if (pattern) {\n+                    return parsePattern(token.pos, null, null, false);\n+                } else {\n+                    return term(EXPR | TYPE | NOLAMBDA);\n+                }\n+            } else {\n+                JCModifiers mods = optFinal(0);\n+                JCExpression e = term(EXPR | TYPE | NOLAMBDA);\n+\n+                if (token.kind == IDENTIFIER || mods.flags != 0 || mods.annotations.nonEmpty()) {\n+                    checkSourceLevel(token.pos, Feature.PATTERN_SWITCH);\n+                    return parsePattern(patternPos, null, e, false);\n+                } else {\n+                    return e;\n+                }\n+            }\n+        }\n+\n+        return label;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":103,"deletions":27,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -354,0 +354,3 @@\n+compiler.misc.guard=\\\n+    a guard\n+\n@@ -497,0 +500,3 @@\n+compiler.err.pattern.dominated=\\\n+    this case label is dominated by a preceding case label\n+\n@@ -500,0 +506,16 @@\n+compiler.err.duplicate.total.pattern=\\\n+    duplicate total pattern\n+\n+compiler.err.total.pattern.and.default=\\\n+    switch has both a total pattern and a default label\n+\n+# 0: type, 1: type\n+compiler.err.constant.label.not.compatible=\\\n+    constant label of type {0} is not compatible with switch selector type {1}\n+\n+compiler.err.flows.through.to.pattern=\\\n+    illegal fall-through to a pattern\n+\n+compiler.err.flows.through.from.pattern=\\\n+    illegal fall-through from a pattern\n+\n@@ -1360,0 +1382,3 @@\n+compiler.err.not.exhaustive.statement=\\\n+    the switch statement does not cover all possible input values\n+\n@@ -2961,0 +2986,6 @@\n+compiler.misc.feature.case.null=\\\n+    null in switch cases\n+\n+compiler.misc.feature.pattern.switch=\\\n+    patterns in switch statements\n+\n@@ -3482,3 +3513,0 @@\n-compiler.err.switch.null.not.allowed=\\\n-    null label in case is not allowed\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":31,"deletions":3,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -243,0 +243,3 @@\n+        DEFAULTCASELABEL,\n+        GUARDPATTERN,\n+        PARENTHESIZEDPATTERN,\n@@ -702,1 +705,9 @@\n-    public static abstract class JCExpression extends JCTree implements ExpressionTree {\n+    public static abstract class JCCaseLabel extends JCTree implements CaseLabelTree {\n+        public abstract boolean isExpression();\n+        public boolean isNullPattern() {\n+            return isExpression() && TreeInfo.isNull((JCExpression) this);\n+        }\n+        public abstract boolean isPattern();\n+    }\n+\n+    public static abstract class JCExpression extends JCCaseLabel implements ExpressionTree {\n@@ -716,0 +727,10 @@\n+\n+        @Override\n+        public boolean isExpression() {\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean isPattern() {\n+            return false;\n+        }\n@@ -1267,0 +1288,2 @@\n+        public boolean hasTotalPattern;\n+        public boolean patternSwitch;\n@@ -1299,1 +1322,1 @@\n-        public List<JCExpression> pats;\n+        public List<JCCaseLabel> labels;\n@@ -1303,1 +1326,1 @@\n-        protected JCCase(CaseKind caseKind, List<JCExpression> pats,\n+        protected JCCase(CaseKind caseKind, List<JCCaseLabel> labels,\n@@ -1305,2 +1328,2 @@\n-            Assert.checkNonNull(pats);\n-            Assert.check(pats.isEmpty() || pats.head != null);\n+            Assert.checkNonNull(labels);\n+            Assert.check(labels.isEmpty() || labels.head != null);\n@@ -1308,1 +1331,1 @@\n-            this.pats = pats;\n+            this.labels = labels;\n@@ -1318,1 +1341,1 @@\n-        public JCExpression getExpression() { return pats.head; }\n+        public JCExpression getExpression() { return getExpressions().head; }\n@@ -1320,1 +1343,3 @@\n-        public List<JCExpression> getExpressions() { return pats; }\n+        public List<JCExpression> getExpressions() { return labels.stream().filter(p -> p instanceof JCExpression).map(p -> (JCExpression) p).collect(List.collector()); }\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public List<JCCaseLabel> getLabels() { return labels; }\n@@ -1349,0 +1374,2 @@\n+        public boolean hasTotalPattern;\n+        public boolean patternSwitch;\n@@ -2215,1 +2242,1 @@\n-    public static abstract class JCPattern extends JCTree\n+    public static abstract class JCPattern extends JCCaseLabel\n@@ -2217,0 +2244,10 @@\n+\n+        @Override\n+        public boolean isExpression() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isPattern() {\n+            return true;\n+        }\n@@ -2254,0 +2291,115 @@\n+    public static class JCDefaultCaseLabel extends JCCaseLabel\n+            implements DefaultCaseLabelTree {\n+\n+        protected JCDefaultCaseLabel() {\n+        }\n+\n+        @Override\n+        public void accept(Visitor v) {\n+            v.visitDefaultCaseLabel(this);\n+        }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() {\n+            return Kind.DEFAULT_CASE_LABEL;\n+        }\n+\n+        @Override\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public <R, D> R accept(TreeVisitor<R, D> v, D d) {\n+            return v.visitDefaultCaseLabel(this, d);\n+        }\n+\n+        @Override\n+        public Tag getTag() {\n+            return DEFAULTCASELABEL;\n+        }\n+\n+        @Override\n+        public boolean isExpression() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isPattern() {\n+            return false;\n+        }\n+    }\n+\n+    public static class JCParenthesizedPattern extends JCPattern\n+            implements ParenthesizedPatternTree {\n+        public JCPattern pattern;\n+\n+        public JCParenthesizedPattern(JCPattern pattern) {\n+            this.pattern = pattern;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public PatternTree getPattern() {\n+            return pattern;\n+        }\n+\n+        @Override\n+        public void accept(Visitor v) {\n+            v.visitParenthesizedPattern(this);\n+        }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() {\n+            return Kind.PARENTHESIZED_PATTERN;\n+        }\n+\n+        @Override\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public <R, D> R accept(TreeVisitor<R, D> v, D d) {\n+            return v.visitParenthesizedPattern(this, d);\n+        }\n+\n+        @Override\n+        public Tag getTag() {\n+            return PARENTHESIZEDPATTERN;\n+        }\n+    }\n+\n+    public static class JCGuardPattern extends JCPattern\n+            implements GuardedPatternTree {\n+        public JCPattern patt;\n+        public JCExpression expr;\n+\n+        public JCGuardPattern(JCPattern patt, JCExpression expr) {\n+            this.patt = patt;\n+            this.expr = expr;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public PatternTree getPattern() {\n+            return patt;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public ExpressionTree getExpression() {\n+            return expr;\n+        }\n+\n+        @Override\n+        public void accept(Visitor v) {\n+            v.visitGuardPattern(this);\n+        }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() {\n+            return Kind.GUARDED_PATTERN;\n+        }\n+\n+        @Override\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public <R, D> R accept(TreeVisitor<R, D> v, D d) {\n+            return v.visitGuardedPattern(this, d);\n+        }\n+\n+        @Override\n+        public Tag getTag() {\n+            return Tag.GUARDPATTERN;\n+        }\n+    }\n+\n@@ -3190,1 +3342,1 @@\n-        JCCase Case(CaseTree.CaseKind caseKind, List<JCExpression> pat,\n+        JCCase Case(CaseTree.CaseKind caseKind, List<JCCaseLabel> labels,\n@@ -3294,0 +3446,3 @@\n+        public void visitDefaultCaseLabel(JCDefaultCaseLabel that) { visitTree(that); }\n+        public void visitParenthesizedPattern(JCParenthesizedPattern that) { visitTree(that); }\n+        public void visitGuardPattern(JCGuardPattern that) { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":165,"deletions":10,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -855,1 +855,1 @@\n-            if (tree.pats.isEmpty()) {\n+            if (tree.labels.size() == 1 && tree.labels.get(0).hasTag(DEFAULTCASELABEL)) {\n@@ -859,1 +859,1 @@\n-                printExprs(tree.pats);\n+                printExprs(tree.labels);\n@@ -870,1 +870,5 @@\n-                printStat(tree.stats.head);\n+                if (tree.stats.size() == 1) {\n+                    printStat(tree.stats.head);\n+                } else {\n+                    printBlock(tree.stats);\n+                }\n@@ -877,0 +881,9 @@\n+    @Override\n+    public void visitDefaultCaseLabel(JCTree.JCDefaultCaseLabel that) {\n+        try {\n+            print(\"default\");\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n@@ -902,0 +915,22 @@\n+        }\n+    }\n+\n+    @Override\n+    public void visitParenthesizedPattern(JCParenthesizedPattern patt) {\n+        try {\n+            print(\"(\");\n+            printExpr(patt.pattern);\n+            print(\")\");\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void visitGuardPattern(JCGuardPattern patt) {\n+        try {\n+            printExpr(patt.patt);\n+            print(\" && \");\n+            printExpr(patt.expr);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":38,"deletions":3,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-        List<JCExpression> pats = copy(t.pats, p);\n+        List<JCCaseLabel> labels = copy(t.labels, p);\n@@ -164,1 +164,1 @@\n-        return M.at(t.pos).Case(t.caseKind, pats, stats, body);\n+        return M.at(t.pos).Case(t.caseKind, labels, stats, body);\n@@ -500,0 +500,21 @@\n+    @DefinedBy(Api.COMPILER_TREE)\n+    public JCTree visitGuardedPattern(GuardedPatternTree node, P p) {\n+        JCGuardPattern t = (JCGuardPattern) node;\n+        JCPattern patt = copy(t.patt, p);\n+        JCExpression expr = copy(t.expr, p);\n+        return M.at(t.pos).GuardPattern(patt, expr);\n+    }\n+\n+    @DefinedBy(Api.COMPILER_TREE)\n+    public JCTree visitParenthesizedPattern(ParenthesizedPatternTree node, P p) {\n+        JCParenthesizedPattern t = (JCParenthesizedPattern) node;\n+        JCPattern pattern = copy(t.pattern, p);\n+        return M.at(t.pos).ParenthesizedPattern(pattern);\n+    }\n+\n+    @DefinedBy(Api.COMPILER_TREE)\n+    public JCTree visitDefaultCaseLabel(DefaultCaseLabelTree node, P p) {\n+        JCDefaultCaseLabel t = (JCDefaultCaseLabel) node;\n+        return M.at(t.pos).DefaultCaseLabel();\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import static com.sun.tools.javac.code.TypeTag.BOOLEAN;\n@@ -544,0 +545,4 @@\n+            case GUARDPATTERN: {\n+                JCGuardPattern node = (JCGuardPattern) tree;\n+                return getStartPos(node.patt);\n+            }\n@@ -633,0 +638,8 @@\n+            case PARENTHESIZEDPATTERN: {\n+                JCParenthesizedPattern node = (JCParenthesizedPattern) tree;\n+                return getEndPos(node.pattern, endPosTable);\n+            }\n+            case GUARDPATTERN: {\n+                JCGuardPattern node = (JCGuardPattern) tree;\n+                return getEndPos(node.expr, endPosTable);\n+            }\n@@ -1332,1 +1345,1 @@\n-               cases.stream().flatMap(c -> c.pats.stream())\n+               cases.stream().flatMap(c -> c.labels.stream())\n@@ -1335,0 +1348,24 @@\n+\n+    public static PatternPrimaryType primaryPatternType(JCPattern pat) {\n+        return switch (pat.getTag()) {\n+            case BINDINGPATTERN -> new PatternPrimaryType(((JCBindingPattern) pat).type, true);\n+            case GUARDPATTERN -> {\n+                JCGuardPattern guarded = (JCGuardPattern) pat;\n+                PatternPrimaryType nested = primaryPatternType(guarded.patt);\n+                boolean unconditional = nested.unconditional();\n+                if (guarded.expr.type.hasTag(BOOLEAN) && unconditional) {\n+                    unconditional = false;\n+                    var constValue = guarded.expr.type.constValue();\n+                    if (constValue != null && ((int) constValue) == 1) {\n+                        unconditional = true;\n+                    }\n+                }\n+                yield new PatternPrimaryType(nested.type(), unconditional);\n+            }\n+            case PARENTHESIZEDPATTERN -> primaryPatternType(((JCParenthesizedPattern) pat).pattern);\n+            default -> throw new AssertionError();\n+        };\n+    }\n+\n+    public record PatternPrimaryType(Type type, boolean unconditional) {}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-    public JCCase Case(CaseTree.CaseKind caseKind, List<JCExpression> pats,\n+    public JCCase Case(CaseTree.CaseKind caseKind, List<JCCaseLabel> labels,\n@@ -296,1 +296,1 @@\n-        JCCase tree = new JCCase(caseKind, pats, stats, body);\n+        JCCase tree = new JCCase(caseKind, labels, stats, body);\n@@ -491,0 +491,18 @@\n+    public JCDefaultCaseLabel DefaultCaseLabel() {\n+        JCDefaultCaseLabel tree = new JCDefaultCaseLabel();\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n+    public JCParenthesizedPattern ParenthesizedPattern(JCPattern pattern) {\n+        JCParenthesizedPattern tree = new JCParenthesizedPattern(pattern);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n+    public JCGuardPattern GuardPattern(JCPattern guardedPattern, JCExpression expr) {\n+        JCGuardPattern tree = new JCGuardPattern(guardedPattern, expr);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-        scan(tree.pats);\n+        scan(tree.labels);\n@@ -310,0 +310,15 @@\n+    @Override\n+    public void visitDefaultCaseLabel(JCDefaultCaseLabel tree) {\n+    }\n+\n+    @Override\n+    public void visitParenthesizedPattern(JCParenthesizedPattern that) {\n+        scan(that.pattern);\n+    }\n+\n+    @Override\n+    public void visitGuardPattern(JCGuardPattern that) {\n+        scan(that.patt);\n+        scan(that.expr);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-        tree.pats = translate(tree.pats);\n+        tree.labels = translate(tree.labels);\n@@ -366,0 +366,18 @@\n+    @Override\n+    public void visitDefaultCaseLabel(JCDefaultCaseLabel tree) {\n+        result = tree;\n+    }\n+\n+    @Override\n+    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n+        tree.pattern = translate(tree.pattern);\n+        result = tree;\n+    }\n+\n+    @Override\n+    public void visitGuardPattern(JCGuardPattern tree) {\n+        tree.patt = translate(tree.patt);\n+        tree.expr = translate(tree.expr);\n+        result = tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3199,5 +3199,6 @@\n-        if (!previewLanguageFeaturesUsed(el).isEmpty() ||\n-            configuration.workArounds.isPreviewAPI(el) ||\n-            !previewAPIs.previewAPI.isEmpty() ||\n-            !previewAPIs.reflectivePreviewAPI.isEmpty() ||\n-            !previewAPIs.declaredUsingPreviewFeature.isEmpty())  {\n+        if ((!previewLanguageFeaturesUsed(el).isEmpty() ||\n+             configuration.workArounds.isPreviewAPI(el) ||\n+             !previewAPIs.previewAPI.isEmpty() ||\n+             !previewAPIs.reflectivePreviewAPI.isEmpty() ||\n+             !previewAPIs.declaredUsingPreviewFeature.isEmpty()) &&\n+            !hasNoProviewAnnotation(el)) {\n@@ -3219,0 +3220,5 @@\n+    private boolean hasNoProviewAnnotation(Element el) {\n+        return el.getAnnotationMirrors()\n+                 .stream()\n+                 .anyMatch(am -> \"jdk.internal.javac.NoPreview\".equals(getQualifiedTypeName(am.getAnnotationType())));\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.Serializable;\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.runtime.SwitchBootstraps;\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.fail;\n+\n+\/**\n+ * @test\n+ * @compile --enable-preview -source ${jdk.version} SwitchBootstrapsTest.java\n+ * @run testng\/othervm --enable-preview SwitchBootstrapsTest\n+ *\/\n+@Test\n+public class SwitchBootstrapsTest {\n+\n+    public static final MethodHandle BSM_TYPE_SWITCH;\n+\n+    static {\n+        try {\n+            BSM_TYPE_SWITCH = MethodHandles.lookup().findStatic(SwitchBootstraps.class, \"typeSwitch\",\n+                                                                MethodType.methodType(CallSite.class, MethodHandles.Lookup.class, String.class, MethodType.class, Object[].class));\n+        }\n+        catch (NoSuchMethodException | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void testType(Object target, int start, int result, Object... labels) throws Throwable {\n+        MethodType switchType = MethodType.methodType(int.class, Object.class, int.class);\n+        MethodHandle indy = ((CallSite) BSM_TYPE_SWITCH.invoke(MethodHandles.lookup(), \"\", switchType, labels)).dynamicInvoker();\n+        assertEquals((int) indy.invoke(target, start), result);\n+        assertEquals(-1, (int) indy.invoke(null, start));\n+    }\n+\n+    public enum E1 {\n+        A;\n+    }\n+\n+    public enum E2 {\n+        C;\n+    }\n+\n+    public void testTypes() throws Throwable {\n+        testType(\"\", 0, 0, String.class, Object.class);\n+        testType(\"\", 0, 0, Object.class);\n+        testType(\"\", 0, 1, Integer.class);\n+        testType(\"\", 0, 1, Integer.class, Serializable.class);\n+        testType(E1.A, 0, 0, E1.class, Object.class);\n+        testType(E2.C, 0, 1, E1.class, Object.class);\n+        testType(new Serializable() { }, 0, 1, Comparable.class, Serializable.class);\n+        testType(\"\", 0, 0, \"\", String.class);\n+        testType(\"\", 1, 1, \"\", String.class);\n+        testType(\"a\", 0, 1, \"\", String.class);\n+        testType(1, 0, 0, 1, Integer.class);\n+        testType(2, 0, 1, 1, Integer.class);\n+        testType(Byte.valueOf((byte) 1), 0, 0, 1, Integer.class);\n+        testType(Short.valueOf((short) 1), 0, 0, 1, Integer.class);\n+        testType(Character.valueOf((char) 1), 0, 0, 1, Integer.class);\n+        testType(Integer.valueOf((int) 1), 0, 0, 1, Integer.class);\n+        try {\n+            testType(1, 0, 1, 1.0, Integer.class);\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IllegalArgumentException ex) {\n+            \/\/OK\n+        }\n+        testType(\"\", 0, 0, String.class, String.class, String.class);\n+        testType(\"\", 1, 1, String.class, String.class, String.class);\n+        testType(\"\", 2, 2, String.class, String.class, String.class);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/runtime\/SwitchBootstrapsTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -68,1 +68,1 @@\n-                for (JavaFileObject file : compile(testCase.src).getClasses().values()) {\n+                for (JavaFileObject file : compile(testCase.extraCompilerOptions, testCase.src).getClasses().values()) {\n@@ -87,4 +87,11 @@\n-                assertTrue(coveredLines.containsAll(testCase.expectedLines),\n-                        format(\"All significant lines are not covered.%n\" +\n-                                \"Covered: %s%n\" +\n-                                \"Expected: %s%n\", coveredLines, testCase.expectedLines));\n+                if (testCase.exactLines) {\n+                    assertTrue(coveredLines.equals(testCase.expectedLines),\n+                            format(\"Incorrect covered lines.%n\" +\n+                                    \"Covered: %s%n\" +\n+                                    \"Expected: %s%n\", coveredLines, testCase.expectedLines));\n+                } else {\n+                    assertTrue(coveredLines.containsAll(testCase.expectedLines),\n+                            format(\"All significant lines are not covered.%n\" +\n+                                    \"Covered: %s%n\" +\n+                                    \"Expected: %s%n\", coveredLines, testCase.expectedLines));\n+                }\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/LineNumberTable\/LineNumberTestBase.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262891\n+ * @summary Verify correct LineNumberTable for rule switches.\n+ * @library \/tools\/lib \/tools\/javac\/lib ..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.jdeps\/com.sun.tools.classfile\n+ * @build toolbox.ToolBox InMemoryFileManager TestBase\n+ * @build LineNumberTestBase TestCase\n+ * @run main RuleSwitchBreaks\n+ *\/\n+\n+import java.util.List;\n+\n+public class RuleSwitchBreaks extends LineNumberTestBase {\n+    public static void main(String[] args) throws Exception {\n+        new RuleSwitchBreaks().test();\n+    }\n+\n+    public void test() throws Exception {\n+        test(List.of(TEST_CASE));\n+    }\n+\n+    private static final TestCase[] TEST_CASE = new TestCase[] {\n+        new TestCase(\"\"\"\n+                     public class Test {                                   \/\/ 1\n+                         private void test(int i) {                        \/\/ 2\n+                             switch (i) {                                  \/\/ 3\n+                                 case 0 ->                                 \/\/ 4\n+                                     System.out.println(\"a\");              \/\/ 5\n+                                 case 1 ->                                 \/\/ 6\n+                                     System.out.println(\"a\");              \/\/ 7\n+                                 default ->                                \/\/ 8\n+                                     System.out.println(\"default\");        \/\/ 9\n+                             }                                             \/\/10\n+                         }                                                 \/\/11\n+                     }                                                     \/\/12\n+                     \"\"\",\n+                     List.of(1, 3, 5, 7, 9, 11),\n+                     true,\n+                     List.of(),\n+                     \"Test\"),\n+        new TestCase(\"\"\"\n+                     public class TestGuards {                             \/\/ 1\n+                         private void test(Object o) {                     \/\/ 2\n+                             switch (o) {                                  \/\/ 3\n+                                 case String s && s.isEmpty() ->           \/\/ 4\n+                                     System.out.println(\"a\");              \/\/ 5\n+                                 case String s ->                          \/\/ 6\n+                                     System.out.println(\"a\");              \/\/ 7\n+                                 default ->                                \/\/ 8\n+                                     System.out.println(\"default\");        \/\/ 9\n+                             }                                             \/\/10\n+                         }                                                 \/\/11\n+                     }                                                     \/\/12\n+                     \"\"\",\n+                     List.of(1, 3, 4, 5, 6, 7, 9, 11),\n+                     true,\n+                     List.of(\"--enable-preview\", \"-source\", System.getProperty(\"java.specification.version\")),\n+                     \"TestGuards\")\n+    };\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/LineNumberTable\/RuleSwitchBreaks.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+import java.util.List;\n@@ -35,0 +36,2 @@\n+    public final boolean exactLines;\n+    public final List<String> extraCompilerOptions;\n@@ -44,0 +47,6 @@\n+        this(src, expectedLines, false, List.of(), name);\n+    }\n+\n+    public TestCase(String src, Collection<Integer> expectedLines,\n+                    boolean exactLines, List<String> extraCompilerOptions,\n+                    String name) {\n@@ -46,0 +55,2 @@\n+        this.exactLines = exactLines;\n+        this.extraCompilerOptions = extraCompilerOptions;\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/LineNumberTable\/TestCase.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,0 +27,4 @@\n+\/\/ key: compiler.misc.guard\n+\/\/ key: compiler.misc.feature.pattern.switch\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n@@ -44,0 +48,7 @@\n+\n+    void test3(Object o, int i) {\n+        switch (o) {\n+            case String s && s.length() == i++: break;\n+            default: break;\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantRefNonEffectivelyFinalVar.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.misc.feature.case.null\n+\/\/ key: compiler.warn.preview.feature.use\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class CaseNull {\n+    private void doSwitch(String s) {\n+        switch (s) {\n+            case null: break;\n+            default: break;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CaseNull.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.constant.label.not.compatible\n+\/\/ key: compiler.misc.feature.pattern.switch\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class ConstantLabelNotCompatible {\n+    private void doSwitch(Object o) {\n+        switch (o) {\n+            case 0:\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ConstantLabelNotCompatible.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.duplicate.total.pattern\n+\/\/ key: compiler.misc.feature.pattern.switch\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class DuplicateTotalPattern {\n+    private void doSwitch(Object o) {\n+        switch (o) {\n+            case Object obj: break;\n+            case Object obj: break;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/DuplicateTotalPattern.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.flows.through.from.pattern\n+\/\/ key: compiler.misc.feature.pattern.switch\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class FlowsThroughToPattern {\n+    private void doSwitch(Object o) {\n+        switch (o) {\n+            case String str:\n+            default: break;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FlowsThroughFromPattern.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.flows.through.to.pattern\n+\/\/ key: compiler.misc.feature.pattern.switch\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class FlowsThroughToPattern {\n+    private void doSwitch(Object o) {\n+        switch (o) {\n+            case String str:\n+            case Object obj: break;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FlowsThroughToPattern.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.not.exhaustive.statement\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview --source ${jdk.version}\n+\n+class NotExhaustive {\n+    void t(Object o) {\n+        switch (o) {\n+            case String s -> System.err.println(\"String of length: \" + s.length());\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NotExhaustiveStatement.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.pattern.dominated\n+\/\/ key: compiler.misc.feature.pattern.switch\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class PatternDominated {\n+    private void doSwitch(Object o) {\n+        switch (o) {\n+            case CharSequence cs: break;\n+            case String str: break;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PatternDominated.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.misc.feature.pattern.switch\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class PatternSwitch {\n+    private void doSwitch(Object o) {\n+        switch (o) {\n+            case String str: break;\n+            default: break;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PatternSwitch.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.switch.null.not.allowed\n-\n-class SwitchNullNotAllowed {\n-\n-    void test(Integer i) {\n-        switch (i) {\n-            case null: break;\n-            case 0: break;\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/SwitchNullNotAllowed.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.total.pattern.and.default\n+\/\/ key: compiler.misc.feature.pattern.switch\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class TotalPatternAndDefault {\n+    private void doSwitch(Object o) {\n+        switch (o) {\n+            case Object obj: break;\n+            default: break;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/TotalPatternAndDefault.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -741,1 +741,1 @@\n-            printList(\"pat\", tree.pats);\n+            printList(\"labels\", tree.labels);\n","filename":"test\/langtools\/tools\/javac\/lib\/DPrinter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8262891\n+ * @summary Check null handling for non-pattern switches.\n+ * @compile\/fail\/ref=CaseDefault.out -source 16 -Xlint:-options -XDrawDiagnostics CaseDefault.java\n+ * @compile --enable-preview -source ${jdk.version} CaseDefault.java\n+ * @run main\/othervm --enable-preview CaseDefault\n+ *\/\n+\n+public class CaseDefault {\n+\n+    public static void main(String[] args) {\n+        new CaseDefault().run();\n+    }\n+\n+    void run() {\n+        String str = \"other\";\n+        switch (str) {\n+            case \"a\": throw new AssertionError(\"Wrong branch.\");\n+            case default: break; \/\/OK\n+        }\n+        switch (str) {\n+            case \"a\" -> throw new AssertionError(\"Wrong branch.\");\n+            case default -> {} \/\/OK\n+        }\n+        int i;\n+        i = switch (str) {\n+            case \"a\": throw new AssertionError(\"Wrong branch.\");\n+            case default: yield 0; \/\/OK\n+        };\n+        i = switch (str) {\n+            case \"a\" -> throw new AssertionError(\"Wrong branch.\");\n+            case default -> 0; \/\/OK\n+        };\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/CaseDefault.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CaseDefault.java:20:18: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\n+1 error\n","filename":"test\/langtools\/tools\/javac\/patterns\/CaseDefault.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/**\n+ * @test\n+ * @modules jdk.compiler\/com.sun.tools.javac.file\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.parser\n+ *          jdk.compiler\/com.sun.tools.javac.tree\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @compile --enable-preview -source ${jdk.version} DisambiguateParenthesizedPattern.java\n+ * @run main\/othervm --enable-preview DisambiguateParenthesizedPattern\n+ *\/\n+\n+import com.sun.source.tree.CaseLabelTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.PatternTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.tools.javac.file.JavacFileManager;\n+import com.sun.tools.javac.parser.JavacParser;\n+import com.sun.tools.javac.parser.ParserFactory;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.main.Option;\n+import com.sun.tools.javac.util.Options;\n+import java.nio.charset.Charset;\n+\n+public class DisambiguateParenthesizedPattern {\n+\n+    public static void main(String... args) throws Throwable {\n+        DisambiguateParenthesizedPattern test = new DisambiguateParenthesizedPattern();\n+        test.disambiguationTest(\"String s\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"String s && s.isEmpty()\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"(String s)\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"((String s))\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"(String) s\",\n+                                 ExpressionType.EXPRESSION);\n+        test.disambiguationTest(\"((String) s)\",\n+                                 ExpressionType.EXPRESSION);\n+        test.disambiguationTest(\"((0x1))\",\n+                                 ExpressionType.EXPRESSION);\n+    }\n+\n+    private final ParserFactory factory;\n+\n+    public DisambiguateParenthesizedPattern() {\n+        Context context = new Context();\n+        JavacFileManager jfm = new JavacFileManager(context, true, Charset.defaultCharset());\n+        Options.instance(context).put(Option.PREVIEW, \"\");\n+        factory = ParserFactory.instance(context);\n+    }\n+\n+    void disambiguationTest(String snippet, ExpressionType expectedType) {\n+        String code = \"\"\"\n+                      public class Test {\n+                          private void test() {\n+                              switch (null) {\n+                                  case SNIPPET -> {}\n+                              }\n+                          }\n+                      }\n+                      \"\"\".replace(\"SNIPPET\", snippet);\n+        JavacParser parser = factory.newParser(code, false, false, false);\n+        CompilationUnitTree result = parser.parseCompilationUnit();\n+        ClassTree clazz = (ClassTree) result.getTypeDecls().get(0);\n+        MethodTree method = (MethodTree) clazz.getMembers().get(0);\n+        SwitchTree st = (SwitchTree) method.getBody().getStatements().get(0);\n+        CaseLabelTree label = st.getCases().get(0).getLabels().get(0);\n+        ExpressionType actualType = switch (label) {\n+            case ExpressionTree et -> ExpressionType.EXPRESSION;\n+            case PatternTree pt -> ExpressionType.PATTERN;\n+            default -> throw new AssertionError(\"Unexpected result: \" + result);\n+        };\n+        if (expectedType != actualType) {\n+            throw new AssertionError(\"Expected: \" + expectedType + \", actual: \" + actualType +\n+                                      \", for: \" + code + \", parsed: \" + result);\n+        }\n+    }\n+\n+    enum ExpressionType {\n+        PATTERN,\n+        EXPRESSION;\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/DisambiguateParenthesizedPattern.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262891\n+ * @summary Check the pattern domination error are reported correctly.\n+ * @compile\/fail\/ref=Domination.out -XDrawDiagnostics --enable-preview -source ${jdk.version} Domination.java\n+ *\/\n+public class Domination {\n+\n+    int testDominatesError1(Object o) {\n+        switch (o) {\n+            case CharSequence cs: return 0;\n+            case String s: return 1;\n+            case Object x: return -1;\n+        }\n+    }\n+\n+    int testDominatesError2(Object o) {\n+        switch (o) {\n+            case CharSequence cs: return 0;\n+            case String s && s.isEmpty(): return 1;\n+            case Object x: return -1;\n+        }\n+    }\n+\n+    int testDominatesError3(Object o) {\n+        switch (o) {\n+            case CharSequence cs && true: return 0;\n+            case String s && s.isEmpty(): return 1;\n+            case Object x: return -1;\n+        }\n+    }\n+\n+    int testNotDominates1(Object o) {\n+        switch (o) {\n+            case CharSequence cs && cs.length() == 0: return 0;\n+            case String s: return 1;\n+            case Object x: return -1;\n+        }\n+    }\n+\n+    int testDominatesStringConstant(String str) {\n+        switch (str) {\n+            case String s: return 1;\n+            case \"\": return -1;\n+        }\n+    }\n+\n+    int testDominatesIntegerConstant(Integer i) {\n+        switch (i) {\n+            case Integer j: return 1;\n+            case 0: return -1;\n+        }\n+    }\n+\n+    int testDominatesEnumConstant() {\n+        enum E {\n+            A, B;\n+        }\n+        E e = E.A;\n+        switch (e) {\n+            case E d: return 1;\n+            case A: return -1;\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/Domination.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,9 @@\n+Domination.java:35:18: compiler.err.pattern.dominated\n+Domination.java:43:18: compiler.err.pattern.dominated\n+Domination.java:51:18: compiler.err.pattern.dominated\n+Domination.java:67:18: compiler.err.pattern.dominated\n+Domination.java:74:18: compiler.err.pattern.dominated\n+Domination.java:85:18: compiler.err.pattern.dominated\n+- compiler.note.preview.filename: Domination.java, DEFAULT\n+- compiler.note.preview.recompile\n+6 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/Domination.out","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -0,0 +1,643 @@\n+\/*\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8262891\n+ * @summary Check exhaustiveness of switches over sealed types.\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main Exhaustiveness\n+*\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class Exhaustiveness extends TestRunner {\n+\n+    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n+\n+    ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new Exhaustiveness().runTests();\n+    }\n+\n+    Exhaustiveness() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testExhaustiveSealedClasses(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case B b -> 1;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testNonExhaustiveSealedClasses(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:5:16: compiler.err.not.exhaustive\",\n+               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+               \"- compiler.note.preview.recompile\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testAbstractSealedClasses(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed abstract class S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A extends S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B extends S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case B b -> 1;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testConcreteSealedClasses(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed class S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A extends S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B extends S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case B b -> 1;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:5:16: compiler.err.not.exhaustive\",\n+               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+               \"- compiler.note.preview.recompile\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testGuards1(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a && a.toString().isEmpty() -> 0;\n+                           case B b -> 1;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:5:16: compiler.err.not.exhaustive\",\n+               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+               \"- compiler.note.preview.recompile\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testGuards2(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private static final boolean TEST = true;\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a && !(!(TEST)) -> 0;\n+                           case B b -> 1;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testGuards3(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a && false -> 0;\n+                           case B b -> 1;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:5:16: compiler.err.not.exhaustive\",\n+               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+               \"- compiler.note.preview.recompile\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testCoversType1(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case S s -> 1;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testCoversType2(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public interface S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case S s -> 1;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testCoversType3(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public interface S<T> {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S<A> {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S<B> {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case S<?> s -> 1;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    private void doTest(Path base, String[] libraryCode, String testCode, String... expectedErrors) throws IOException {\n+        Path current = base.resolve(\".\");\n+        Path libSrc = current.resolve(\"lib-src\");\n+        for (String code : libraryCode) {\n+            tb.writeJavaFiles(libSrc, code);\n+        }\n+\n+        Path libClasses = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        new JavacTask(tb)\n+                .options(\"--enable-preview\",\n+                         \"-source\", JAVA_VERSION)\n+                .outdir(libClasses)\n+                .files(tb.findJavaFiles(libSrc))\n+                .run();\n+\n+        Path src = current.resolve(\"src\");\n+        tb.writeJavaFiles(src, testCode);\n+\n+        Path classes = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        var log =\n+                new JavacTask(tb)\n+                    .options(\"--enable-preview\",\n+                             \"-source\", JAVA_VERSION,\n+                             \"-XDrawDiagnostics\",\n+                             \"-Xlint:-preview\",\n+                             \"--class-path\", libClasses.toString())\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(expectedErrors.length > 0 ? Task.Expect.FAIL : Task.Expect.SUCCESS)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+        if (expectedErrors.length > 0 && !List.of(expectedErrors).equals(log)) {\n+            throw new AssertionError(\"Incorrect errors, expected: \" + List.of(expectedErrors) +\n+                                      \", actual: \" + log);\n+        }\n+    }\n+\n+    @Test\n+    public void testInaccessiblePermitted(Path base) throws IOException {\n+        Path current = base.resolve(\".\");\n+        Path libSrc = current.resolve(\"lib-src\");\n+\n+        tb.writeJavaFiles(libSrc,\n+                           \"\"\"\n+                           package lib;\n+                           public sealed interface S permits A, B {}\n+                           \"\"\",\n+                           \"\"\"\n+                           package lib;\n+                           public final class A implements S {}\n+                           \"\"\",\n+                           \"\"\"\n+                           package lib;\n+                           final class B implements S {}\n+                           \"\"\");\n+\n+        Path libClasses = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        new JavacTask(tb)\n+                .options(\"--enable-preview\",\n+                         \"-source\", JAVA_VERSION)\n+                .outdir(libClasses)\n+                .files(tb.findJavaFiles(libSrc))\n+                .run();\n+\n+        Path src = current.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                           \"\"\"\n+                           package test;\n+                           import lib.*;\n+                           public class Test {\n+                               private int test(S obj) {\n+                                   return switch (obj) {\n+                                       case A a -> 0;\n+                                   };\n+                               }\n+                           }\n+                           \"\"\");\n+\n+        Path classes = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        var log =\n+                new JavacTask(tb)\n+                    .options(\"--enable-preview\",\n+                             \"-source\", JAVA_VERSION,\n+                             \"-XDrawDiagnostics\",\n+                             \"-Xlint:-preview\",\n+                             \"--class-path\", libClasses.toString())\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expectedErrors = List.of(\n+               \"Test.java:5:16: compiler.err.not.exhaustive\",\n+               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+               \"- compiler.note.preview.recompile\",\n+               \"1 error\");\n+\n+        if (!expectedErrors.equals(log)) {\n+            throw new AssertionError(\"Incorrect errors, expected: \" + expectedErrors +\n+                                      \", actual: \" + log);\n+        }\n+\n+        Path bClass = libClasses.resolve(\"lib\").resolve(\"B.class\");\n+\n+        Files.delete(bClass);\n+\n+        var log2 =\n+                new JavacTask(tb)\n+                    .options(\"--enable-preview\",\n+                             \"-source\", JAVA_VERSION,\n+                             \"-XDrawDiagnostics\",\n+                             \"-Xlint:-preview\",\n+                             \"--class-path\", libClasses.toString())\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        if (!expectedErrors.equals(log2)) {\n+            throw new AssertionError(\"Incorrect errors, expected: \" + expectedErrors +\n+                                      \", actual: \" + log2);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testExhaustiveStatement1(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public interface Lib {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Object obj) {\n+                       switch (obj) {\n+                           case Object o: return 0;\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testExhaustiveStatement2(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public interface Lib {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(Object obj) {\n+                       switch (obj) {\n+                           case String s: return;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:4:9: compiler.err.not.exhaustive.statement\",\n+               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+               \"- compiler.note.preview.recompile\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testExhaustiveStatement3(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case S s -> 1;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testExhaustiveStatement4(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:5:16: compiler.err.not.exhaustive\",\n+               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+               \"- compiler.note.preview.recompile\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testExhaustiveStatement5(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case B b -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":643,"deletions":0,"binary":false,"changes":643,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262891\n+ * @summary Check guards implementation.\n+ * @compile --enable-preview -source ${jdk.version} Guards.java\n+ * @run main\/othervm --enable-preview Guards\n+ *\/\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+public class Guards {\n+    public static void main(String... args) {\n+        new Guards().run();\n+    }\n+\n+    void run() {\n+        run(this::typeTestPatternSwitchTest);\n+        run(this::typeTestPatternSwitchExpressionTest);\n+        run(this::testBooleanSwitchExpression);\n+        assertEquals(\"a\", testPatternInGuard(\"a\"));\n+        assertEquals(null, testPatternInGuard(1));\n+    }\n+\n+    void run(Function<Object, String> convert) {\n+        assertEquals(\"zero\", convert.apply(0));\n+        assertEquals(\"one\", convert.apply(1));\n+        assertEquals(\"other\", convert.apply(-1));\n+        assertEquals(\"any\", convert.apply(\"\"));\n+    }\n+\n+    String typeTestPatternSwitchTest(Object o) {\n+        switch (o) {\n+            case Integer i && i == 0: return \"zero\";\n+            case Integer i && i == 1: return \"one\";\n+            case Integer i: return \"other\";\n+            case Object x: return \"any\";\n+        }\n+    }\n+\n+    String typeTestPatternSwitchExpressionTest(Object o) {\n+        return switch (o) {\n+            case Integer i && i == 0 -> \"zero\";\n+            case Integer i && i == 1 -> { yield \"one\"; }\n+            case Integer i -> \"other\";\n+            case Object x -> \"any\";\n+        };\n+    }\n+\n+    String testBooleanSwitchExpression(Object o) {\n+        String x;\n+        if (switch (o) {\n+            case Integer i && i == 0 -> (x = \"zero\") != null;\n+            case Integer i && i == 1 -> { x = \"one\"; yield true; }\n+            case Integer i -> { x = \"other\"; yield true; }\n+            case Object other -> (x = \"any\") != null;\n+        }) {\n+            return x;\n+        } else {\n+            throw new IllegalStateException(\"TODO - needed?\");\n+        }\n+    }\n+\n+    String testPatternInGuard(Object o) {\n+        if (o instanceof (CharSequence cs && cs instanceof String s)) {\n+            return s;\n+        }\n+        return null;\n+    }\n+\n+    void assertEquals(String expected, String actual) {\n+        if (!Objects.equals(expected, actual)) {\n+            throw new AssertionError(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/Guards.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262891\n+ * @summary Check errors reported for guarded patterns.\n+ * @compile\/fail\/ref=GuardsErrors.out -XDrawDiagnostics --enable-preview -source ${jdk.version} GuardsErrors.java\n+ *\/\n+\n+public class GuardsErrors {\n+\n+    void typeTestPatternSwitchTest(Object o, int check) {\n+        switch (o) {\n+            case Integer i && i == check -> System.err.println(); \/\/error: check is not effectivelly final\n+            default -> {}\n+        }\n+        check = 0;\n+\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/GuardsErrors.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+GuardsErrors.java:35:36: compiler.err.cant.ref.non.effectively.final.var: check, (compiler.misc.guard)\n+- compiler.note.preview.filename: GuardsErrors.java, DEFAULT\n+- compiler.note.preview.recompile\n+1 error\n","filename":"test\/langtools\/tools\/javac\/patterns\/GuardsErrors.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8262891\n+ * @summary Check null handling for non-pattern switches.\n+ * @compile --enable-preview -source ${jdk.version} NullSwitch.java\n+ * @run main\/othervm --enable-preview NullSwitch\n+ *\/\n+\n+public class NullSwitch {\n+\n+    public static void main(String[] args) {\n+        new NullSwitch().switchTest();\n+    }\n+\n+    void switchTest() {\n+        assertEquals(0, matchingSwitch1(\"\"));\n+        assertEquals(1, matchingSwitch1(\"a\"));\n+        assertEquals(100, matchingSwitch1(0));\n+        assertEquals(-1, matchingSwitch1(null));\n+        assertEquals(-2, matchingSwitch1(0.0));\n+        assertEquals(0, matchingSwitch2(\"\"));\n+        assertEquals(1, matchingSwitch2(null));\n+        assertEquals(1, matchingSwitch2(0.0));\n+        assertEquals(0, matchingSwitch3(\"\"));\n+        assertEquals(1, matchingSwitch3(\"a\"));\n+        assertEquals(100, matchingSwitch3(0));\n+        assertEquals(-1, matchingSwitch3(null));\n+        assertEquals(-2, matchingSwitch3(0.0));\n+        assertEquals(0, matchingSwitch4(\"\"));\n+        assertEquals(1, matchingSwitch4(null));\n+        assertEquals(1, matchingSwitch4(0.0));\n+        assertEquals(0, matchingSwitch5(\"\"));\n+        assertEquals(1, matchingSwitch5(\"a\"));\n+        assertEquals(100, matchingSwitch5(0));\n+        assertEquals(-1, matchingSwitch5(null));\n+        assertEquals(-2, matchingSwitch5(0.0));\n+        assertEquals(0, matchingSwitch6(\"\"));\n+        assertEquals(1, matchingSwitch6(null));\n+        assertEquals(1, matchingSwitch6(0.0));\n+        assertEquals(0, matchingSwitch7(\"\"));\n+        assertEquals(1, matchingSwitch7(\"a\"));\n+        assertEquals(100, matchingSwitch7(0));\n+        assertEquals(-1, matchingSwitch7(null));\n+        assertEquals(-2, matchingSwitch7(0.0));\n+        assertEquals(0, matchingSwitch8(\"\"));\n+        assertEquals(1, matchingSwitch8(null));\n+        assertEquals(1, matchingSwitch8(0.0));\n+        assertEquals(0, matchingSwitch9(\"\"));\n+        assertEquals(1, matchingSwitch9(null));\n+        assertEquals(1, matchingSwitch9(0.0));\n+        assertEquals(0, matchingSwitch10(\"\"));\n+        assertEquals(1, matchingSwitch10(null));\n+        assertEquals(1, matchingSwitch10(0.0));\n+        assertEquals(0, matchingSwitch11(\"\"));\n+        assertEquals(2, matchingSwitch11(null));\n+        assertEquals(1, matchingSwitch11(0.0));\n+        assertEquals(0, matchingSwitch12(\"\"));\n+        assertEquals(2, matchingSwitch12(null));\n+        assertEquals(1, matchingSwitch12(0.0));\n+    }\n+\n+    private int matchingSwitch1(Object obj) {\n+        return switch (obj) {\n+            case String s -> s.length();\n+            case null, Integer i -> i == null ? -1 : 100 + i;\n+            default -> -2;\n+        };\n+    }\n+\n+    private int matchingSwitch2(Object obj) {\n+        return switch (obj) {\n+            case String s -> 0;\n+            case null, default -> 1;\n+        };\n+    }\n+\n+    private int matchingSwitch3(Object obj) {\n+        return switch (obj) {\n+            case String s -> s.length();\n+            case Integer i, null -> i == null ? -1 : 100 + i;\n+            default -> -2;\n+        };\n+    }\n+\n+    private int matchingSwitch4(Object obj) {\n+        return switch (obj) {\n+            case String s -> 0;\n+            case default, null -> 1;\n+        };\n+    }\n+\n+    private int matchingSwitch5(Object obj) {\n+        return switch (obj) {\n+            case String s: yield s.length();\n+            case null:\n+            case Integer i: yield i == null ? -1 : 100 + i;\n+            default: yield -2;\n+        };\n+    }\n+\n+    private int matchingSwitch6(Object obj) {\n+        return switch (obj) {\n+            case String s: yield 0;\n+            case null:\n+            default: yield 1;\n+        };\n+    }\n+\n+    private int matchingSwitch7(Object obj) {\n+        return switch (obj) {\n+            case String s: yield s.length();\n+            case Integer i:\n+            case null: yield i == null ? -1 : 100 + i;\n+            default: yield -2;\n+        };\n+    }\n+\n+    private int matchingSwitch8(Object obj) {\n+        return switch (obj) {\n+            case String s: yield 0;\n+            default:\n+            case null: yield 1;\n+        };\n+    }\n+\n+    private int matchingSwitch9(Object obj) {\n+        return switch (obj) {\n+            case String s: yield 0;\n+            case Object o: yield 1;\n+        };\n+    }\n+\n+    private int matchingSwitch10(Object obj) {\n+        switch (obj) {\n+            case String s: return 0;\n+            case Object o: return 1;\n+        }\n+    }\n+\n+    private int matchingSwitch11(Object obj) {\n+        try {\n+            return switch (obj) {\n+                case String s: yield 0;\n+                default: yield 1;\n+            };\n+        } catch (NullPointerException ex) {\n+            return 2;\n+        }\n+    }\n+\n+    private int matchingSwitch12(Object obj) {\n+        try {\n+            switch (obj) {\n+                case String s: return 0;\n+                default: return 1;\n+            }\n+        } catch (NullPointerException ex) {\n+            return 2;\n+        }\n+    }\n+\n+    static void assertEquals(int expected, int actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected: \" + expected + \", actual: \" + actual);\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/NullSwitch.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262891\n+ * @summary Test parenthesized pattern\n+ * @compile --enable-preview -source ${jdk.version} Parenthesized.java\n+ * @run main\/othervm --enable-preview Parenthesized\n+ *\/\n+public class Parenthesized {\n+    public static void main(String... args) {\n+        new Parenthesized().run();\n+    }\n+\n+    void run() {\n+        Object o = \"\";\n+        switch (o) {\n+            case (String s && s.isEmpty()) -> System.err.println(\"OK: \" + s);\n+            default -> throw new AssertionError();\n+        }\n+        System.err.println(switch (o) {\n+            case (String s && s.isEmpty()) -> \"OK: \" + s;\n+            default -> throw new AssertionError();\n+        });\n+        if (o instanceof (String s && s.isEmpty())) {\n+            System.err.println(\"OK: \" + s);\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/Parenthesized.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262891\n+ * @summary Verify pattern switches work properly when the set of sealed types changes.\n+ * @compile --enable-preview -source ${jdk.version} SealedTypeChanges.java\n+ * @compile --enable-preview -source ${jdk.version} SealedTypeChanges2.java\n+ * @run main\/othervm --enable-preview SealedTypeChanges\n+ *\/\n+\n+import java.util.function.Consumer;\n+\n+public class SealedTypeChanges {\n+\n+    public static void main(String... args) throws Exception {\n+        new SealedTypeChanges().run();\n+    }\n+\n+    void run() throws Exception {\n+        doRun(this::expression);\n+        doRun(this::statement);\n+    }\n+\n+    void doRun(Consumer<SealedTypeChangesIntf> t) throws Exception {\n+        t.accept(new A());\n+        try {\n+            t.accept((SealedTypeChangesIntf) Class.forName(\"SealedTypeChangesClass\").newInstance());\n+            throw new AssertionError(\"Expected an exception, but none thrown.\");\n+        } catch (IncompatibleClassChangeError ex) {\n+            \/\/OK\n+        }\n+    }\n+\n+    void statement(SealedTypeChangesIntf obj) {\n+        switch (obj) {\n+            case A a -> System.err.println(1);\n+        }\n+    }\n+\n+    int expression(SealedTypeChangesIntf obj) {\n+        return switch (obj) {\n+            case A a -> 0;\n+        };\n+    }\n+\n+    final static class A implements SealedTypeChangesIntf {}\n+}\n+\n+sealed interface SealedTypeChangesIntf permits SealedTypeChanges.A {}\n","filename":"test\/langtools\/tools\/javac\/patterns\/SealedTypeChanges.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+sealed interface SealedTypeChangesIntf permits SealedTypeChanges.A, SealedTypeChangesClass {}\n+final class SealedTypeChangesClass implements SealedTypeChangesIntf {}\n","filename":"test\/langtools\/tools\/javac\/patterns\/SealedTypeChanges2.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/**\n+ * @test\n+ * @compile --enable-preview -source ${jdk.version} -doe SimpleAndGuardPattern.java\n+ * @run main\/othervm --enable-preview SimpleAndGuardPattern\n+ *\/\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class SimpleAndGuardPattern {\n+\n+    public static void main(String... args) throws Throwable {\n+        if (!Objects.equals(4, simple(\"test\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!Objects.equals(4, simple(\"TEST\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!Objects.equals(-1, simple(\"other\"))) {\n+            throw new IllegalStateException();\n+        }\n+    }\n+\n+    private static int simple(Object o) throws Throwable {\n+        return switch (o) {\n+            case String s && s.equalsIgnoreCase(\"test\") -> s.length();\n+            default -> -1;\n+        };\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/SimpleAndGuardPattern.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262891\n+ * @summary Verify errors related to pattern switches.\n+ * @compile\/fail\/ref=SwitchErrors.out --enable-preview -source ${jdk.version} -XDrawDiagnostics -XDshould-stop.at=FLOW SwitchErrors.java\n+ *\/\n+public class SwitchErrors {\n+    void incompatibleSelectorObjectString(Object o) {\n+        switch (o) {\n+            case \"A\": break;\n+            case CharSequence cs: break;\n+        }\n+    }\n+    void incompatibleSelectorObjectInteger(Object o) {\n+        switch (o) {\n+            case 1: break;\n+            case CharSequence cs: break;\n+        }\n+    }\n+    void incompatibleSelectorIntegerString(Integer i) {\n+        switch (i) {\n+            case \"A\": break;\n+            case CharSequence cs: break;\n+        }\n+    }\n+    void incompatibleSelectorPrimitive(int i) {\n+        switch (i) {\n+            case null: break;\n+            case \"A\": break;\n+            case CharSequence cs: break;\n+        }\n+    }\n+    void totalAndDefault1(Object o) {\n+        switch (o) {\n+            case Object obj: break;\n+            default: break;\n+        }\n+    }\n+    void totalAndDefault2(Object o) {\n+        switch (o) {\n+            case Object obj: break;\n+            case null, default: break;\n+        }\n+    }\n+    void totalAndDefault3(Object o) {\n+        switch (o) {\n+            default: break;\n+            case Object obj: break;\n+        }\n+    }\n+    void duplicatedTotal(Object o) {\n+        switch (o) {\n+            case Object obj: break;\n+            case Object obj: break;\n+        }\n+    }\n+    void duplicatedDefault1(Object o) {\n+        switch (o) {\n+            case null, default: break;\n+            default: break;\n+        }\n+    }\n+    void duplicatedDefault2(Object o) {\n+        switch (o) {\n+            case default: break;\n+            default: break;\n+        }\n+    }\n+    void duplicatedDefault3(Object o) {\n+        switch (o) {\n+            case default, default: break;\n+        }\n+    }\n+    void duplicatedNullCase1(Object o) {\n+        switch (o) {\n+            case null: break;\n+            case null: break;\n+        }\n+    }\n+    void duplicatedNullCase2(Object o) {\n+        switch (o) {\n+            case null, null: break;\n+        }\n+    }\n+    void duplicatedTypePatterns1(Object o) {\n+        switch (o) {\n+            case String s, Integer i: break;\n+        }\n+    }\n+    void duplicatedTypePatterns2(Object o) {\n+        switch (o) {\n+            case String s:\n+            case Integer i: break;\n+        }\n+    }\n+    void duplicatedTypePatterns3(Object o) {\n+        switch (o) {\n+            case String s:\n+                System.err.println(1);\n+            case Integer i: break;\n+        }\n+    }\n+    void flowIntoTypePatterns(Object o) {\n+        switch (o) {\n+            case null:\n+                System.err.println(1);\n+            case Integer i: break;\n+        }\n+    }\n+    void incompatible1(String str) {\n+        switch (str) {\n+            case Integer i: break;\n+            default: break;\n+        }\n+    }\n+    void incompatible2(java.util.List l) {\n+        switch (l) {\n+            case java.util.List<Integer> l2: break;\n+        }\n+    }\n+    void erroneous(Object o) {\n+        switch (o) {\n+            case String s: break;\n+            case Undefined u: break;\n+            case Integer i: break;\n+            default: break;\n+        }\n+    }\n+    void primitivePattern(Object o) {\n+        switch (o) {\n+            case int i: break;\n+            default: break;\n+        }\n+    }\n+    void patternAndDefault1(Object o) {\n+        switch (o) {\n+            case String s, default: break;\n+        }\n+    }\n+    void patternAndDefault2(Object o) {\n+        switch (o) {\n+            case String s:\n+            case default: break;\n+        }\n+    }\n+    void patternAndDefault3(Object o) {\n+        switch (o) {\n+            case default, String s: break;\n+        }\n+    }\n+    void patternAndDefault4(Object o) {\n+        switch (o) {\n+            case default:\n+            case String s: break;\n+        }\n+    }\n+    void nullAfterTotal(Object o) {\n+        switch (o) {\n+            case Object obj: break;\n+            case null: break;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+SwitchErrors.java:33:18: compiler.err.constant.label.not.compatible: java.lang.String, java.lang.Object\n+SwitchErrors.java:39:18: compiler.err.constant.label.not.compatible: int, java.lang.Object\n+SwitchErrors.java:45:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, java.lang.Integer)\n+SwitchErrors.java:46:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Integer, java.lang.CharSequence)\n+SwitchErrors.java:51:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, int)\n+SwitchErrors.java:52:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, int)\n+SwitchErrors.java:53:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.CharSequence)\n+SwitchErrors.java:59:20: compiler.err.total.pattern.and.default\n+SwitchErrors.java:65:13: compiler.err.pattern.dominated\n+SwitchErrors.java:65:24: compiler.err.total.pattern.and.default\n+SwitchErrors.java:71:18: compiler.err.total.pattern.and.default\n+SwitchErrors.java:77:18: compiler.err.duplicate.total.pattern\n+SwitchErrors.java:83:20: compiler.err.duplicate.default.label\n+SwitchErrors.java:89:20: compiler.err.duplicate.default.label\n+SwitchErrors.java:94:27: compiler.err.duplicate.default.label\n+SwitchErrors.java:100:13: compiler.err.duplicate.case.label\n+SwitchErrors.java:105:13: compiler.err.duplicate.case.label\n+SwitchErrors.java:110:28: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:116:18: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:123:18: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:130:18: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:135:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, java.lang.Integer)\n+SwitchErrors.java:141:18: compiler.err.instanceof.reifiable.not.safe: java.util.List, java.util.List<java.lang.Integer>\n+SwitchErrors.java:147:18: compiler.err.cant.resolve.location: kindname.class, Undefined, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n+SwitchErrors.java:154:18: compiler.err.type.found.req: int, (compiler.misc.type.req.class.array)\n+SwitchErrors.java:160:28: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:166:18: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:171:27: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:177:18: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:183:13: compiler.err.pattern.dominated\n+SwitchErrors.java:32:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:38:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:44:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:50:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:98:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:104:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:109:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:114:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:120:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:127:9: compiler.err.not.exhaustive.statement\n+- compiler.note.preview.filename: SwitchErrors.java, DEFAULT\n+- compiler.note.preview.recompile\n+40 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.out","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,344 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+\/*\n+ * @test\n+ * @bug 8262891\n+ * @summary Check behavior of pattern switches.\n+ * @compile --enable-preview -source ${jdk.version} Switches.java\n+ * @run main\/othervm --enable-preview Switches\n+ *\/\n+public class Switches {\n+\n+    public static void main(String... args) {\n+        new Switches().run();\n+    }\n+\n+    void run() {\n+        run(this::typeTestPatternSwitchTest);\n+        run(this::typeTestPatternSwitchExpressionTest);\n+        run(this::testBooleanSwitchExpression);\n+        assertFalse(testNullSwitch(null));\n+        assertTrue(testNullSwitch(\"\"));\n+        runArrayTypeTest(this::testArrayTypeStatement);\n+        runArrayTypeTest(this::testArrayTypeExpression);\n+        runEnumTest(this::testEnumExpression1);\n+        runEnumTest(this::testEnumExpression2);\n+        runEnumTest(this::testEnumWithGuards1);\n+        runEnumTest(this::testEnumWithGuards2);\n+        runEnumTest(this::testEnumWithGuardsExpression1);\n+        runEnumTest(this::testEnumWithGuardsExpression2);\n+        runEnumTest(this::testStringWithGuards1);\n+        runEnumTest(this::testStringWithGuardsExpression1);\n+        runEnumTest(this::testIntegerWithGuards1);\n+        runEnumTest(this::testIntegerWithGuardsExpression1);\n+        runStringWithConstant(this::testStringWithConstant);\n+        runStringWithConstant(this::testStringWithConstantExpression);\n+        npeTest(this::npeTestStatement);\n+        npeTest(this::npeTestExpression);\n+        exhaustiveStatementSane(\"\");\n+        exhaustiveStatementSane(null);\n+    }\n+\n+    void run(Function<Object, Integer> mapper) {\n+        assertEquals(2, mapper.apply(\"2\"));\n+        assertEquals(3, mapper.apply(\"3\"));\n+        assertEquals(8, mapper.apply(new StringBuilder(\"4\")));\n+        assertEquals(2, mapper.apply(2));\n+        assertEquals(3, mapper.apply(3));\n+        assertEquals(-1, mapper.apply(2.0));\n+        assertEquals(-1, mapper.apply(new Object()));\n+    }\n+\n+    void runArrayTypeTest(Function<Object, String> mapper) {\n+        assertEquals(\"arr0\", mapper.apply(new int[0]));\n+        assertEquals(\"str6\", mapper.apply(\"string\"));\n+        assertEquals(\"i1\", mapper.apply(1));\n+        assertEquals(\"\", mapper.apply(1.0));\n+    }\n+\n+    void runEnumTest(Function<E, String> mapper) {\n+        assertEquals(\"a\", mapper.apply(E.A));\n+        assertEquals(\"b\", mapper.apply(E.B));\n+        assertEquals(\"C\", mapper.apply(E.C));\n+        assertEquals(\"null\", mapper.apply(null));\n+    }\n+\n+    void runStringWithConstant(Function<String, Integer> mapper) {\n+        assertEquals(1, mapper.apply(\"A\"));\n+        assertEquals(2, mapper.apply(\"AA\"));\n+        assertEquals(0, mapper.apply(\"\"));\n+        assertEquals(-1, mapper.apply(null));\n+    }\n+\n+    void npeTest(Consumer<I> testCase) {\n+        try {\n+            testCase.accept(null);\n+            throw new AssertionError(\"Expected a NullPointerException, but got nothing.\");\n+        } catch (NullPointerException ex) {\n+            \/\/OK\n+        }\n+    }\n+\n+    int typeTestPatternSwitchTest(Object o) {\n+        switch (o) {\n+            case String s: return Integer.parseInt(s.toString());\n+            case CharSequence s: return 2 * Integer.parseInt(s.toString());\n+            case Integer i: return i;\n+            case Object x: return -1;\n+        }\n+    }\n+\n+    int typeTestPatternSwitchExpressionTest(Object o) {\n+        return switch (o) {\n+            case String s -> Integer.parseInt(s.toString());\n+            case @Deprecated CharSequence s -> { yield 2 * Integer.parseInt(s.toString()); }\n+            case final Integer i -> i;\n+            case Object x -> -1;\n+        };\n+    }\n+\n+    int testBooleanSwitchExpression(Object o) {\n+        Object x;\n+        if (switch (o) {\n+            default -> false;\n+        }) {\n+            return -3;\n+        } else if (switch (o) {\n+            case String s -> (x = s) != null;\n+            default -> false;\n+        }) {\n+            return Integer.parseInt(x.toString());\n+        } else if (switch (o) {\n+            case CharSequence s -> {\n+                x = s;\n+                yield true;\n+            }\n+            default -> false;\n+        }) {\n+            return 2 * Integer.parseInt(x.toString());\n+        }\n+        return typeTestPatternSwitchTest(o);\n+    }\n+\n+    boolean testNullSwitch(Object o) {\n+        return switch (o) {\n+            case null -> false;\n+            default -> true;\n+        };\n+    }\n+\n+    String testArrayTypeStatement(Object o) {\n+        String res;\n+        switch (o) {\n+            case Integer i -> res = \"i\" + i;\n+            case int[] arr -> res = \"arr\" + arr.length;\n+            case String str -> res = \"str\" + str.length();\n+            default -> res = \"\";\n+        }\n+        return res;\n+    }\n+\n+    String testArrayTypeExpression(Object o) {\n+        return switch (o) {\n+            case Integer i -> \"i\" + i;\n+            case int[] arr -> \"arr\" + arr.length;\n+            case String str -> \"str\" + str.length();\n+            default -> \"\";\n+        };\n+    }\n+\n+    int testStringWithConstant(String str) {\n+        switch (str) {\n+            case \"A\": return 1;\n+            case null: return -1;\n+            case String s:  return s.length();\n+        }\n+    }\n+\n+    int testStringWithConstantExpression(String str) {\n+        return switch (str) {\n+            case \"A\" -> 1;\n+            case null -> -1;\n+            case String s -> s.length();\n+        };\n+    }\n+\n+    String testEnumExpression1(E e) {\n+        return switch (e) {\n+            case A -> \"a\";\n+            case B -> \"b\";\n+            case null, E x -> String.valueOf(x);\n+        };\n+    }\n+\n+    String testEnumExpression2(E e) {\n+        return switch (e) {\n+            case A -> \"a\";\n+            case B -> \"b\";\n+            case E x, null -> String.valueOf(x);\n+        };\n+    }\n+\n+    String testEnumWithGuards1(E e) {\n+        switch (e) {\n+            case A: return \"a\";\n+            case B: return \"b\";\n+            case E x && \"A\".equals(x.name()): return \"broken\";\n+            case C: return String.valueOf(e);\n+            case null, E x: return String.valueOf(x);\n+        }\n+    }\n+\n+    String testEnumWithGuardsExpression1(E e) {\n+        return switch (e) {\n+            case A -> \"a\";\n+            case B -> \"b\";\n+            case E x && \"A\".equals(x.name()) -> \"broken\";\n+            case C -> String.valueOf(e);\n+            case null, E x -> String.valueOf(x);\n+        };\n+    }\n+\n+    String testEnumWithGuards2(E e) {\n+        switch (e) {\n+            case A: return \"a\";\n+            case B: return \"b\";\n+            case E x && \"C\".equals(x.name()): return \"C\";\n+            case C: return \"broken\";\n+            case null, E x: return String.valueOf(x);\n+        }\n+    }\n+\n+    String testEnumWithGuardsExpression2(E e) {\n+        return switch (e) {\n+            case A -> \"a\";\n+            case B -> \"b\";\n+            case E x && \"C\".equals(x.name()) -> \"C\";\n+            case C -> \"broken\";\n+            case null, E x -> String.valueOf(x);\n+        };\n+    }\n+\n+    String testStringWithGuards1(E e) {\n+        switch (e != null ? e.name() : null) {\n+            case \"A\": return \"a\";\n+            case \"B\": return \"b\";\n+            case String x && \"C\".equals(x): return \"C\";\n+            case \"C\": return \"broken\";\n+            case null, String x: return String.valueOf(x);\n+        }\n+    }\n+\n+    String testStringWithGuardsExpression1(E e) {\n+        return switch (e != null ? e.name() : null) {\n+            case \"A\" -> \"a\";\n+            case \"B\" -> \"b\";\n+            case String x && \"C\".equals(x) -> \"C\";\n+            case \"C\" -> \"broken\";\n+            case null, String x -> String.valueOf(x);\n+        };\n+    }\n+\n+    String testIntegerWithGuards1(E e) {\n+        switch (e != null ? e.ordinal() : null) {\n+            case 0: return \"a\";\n+            case 1: return \"b\";\n+            case Integer x && x.equals(2): return \"C\";\n+            case 2: return \"broken\";\n+            case null, Integer x: return String.valueOf(x);\n+        }\n+    }\n+\n+    String testIntegerWithGuardsExpression1(E e) {\n+        return switch (e != null ? e.ordinal() : null) {\n+            case 0 -> \"a\";\n+            case 1 -> \"b\";\n+            case Integer x && x.equals(2) -> \"C\";\n+            case 2 -> \"broken\";\n+            case null, Integer x -> String.valueOf(x);\n+        };\n+    }\n+\n+    void npeTestStatement(I i) {\n+        switch (i) {\n+            case A a -> {}\n+            case B b -> {}\n+        }\n+    }\n+\n+    void npeTestExpression(I i) {\n+        int j = switch (i) {\n+            case A a -> 0;\n+            case B b -> 1;\n+        };\n+    }\n+\n+    void exhaustiveStatementSane(Object o) {\n+        switch (o) {\n+            case Object obj:; \/\/no break intentionally - should not fall through to any possible default\n+        }\n+        switch (o) {\n+            case null, Object obj:; \/\/no break intentionally - should not fall through to any possible default\n+        }\n+        switch (o) {\n+            case Object obj, null:; \/\/no break intentionally - should not fall through to any possible default\n+        }\n+    }\n+\n+    sealed interface I {}\n+    final class A implements I {}\n+    final class B implements I {}\n+\n+    void assertEquals(int expected, int actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n+    void assertEquals(String expected, String actual) {\n+        if (!Objects.equals(expected, actual)) {\n+            throw new AssertionError(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n+    void assertTrue(boolean actual) {\n+        if (!actual) {\n+            throw new AssertionError(\"Expected: true, but got false\");\n+        }\n+    }\n+\n+    void assertFalse(boolean actual) {\n+        if (actual) {\n+            throw new AssertionError(\"Expected: false, but got true\");\n+        }\n+    }\n+\n+    public enum E {\n+        A, B, C;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/Switches.java","additions":344,"deletions":0,"binary":false,"changes":344,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262891\n+ * @summary Verify StackMapTable is sensible for simple ordinary switches\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.jdeps\/com.sun.tools.javap\n+ * @build toolbox.ToolBox toolbox.JavapTask\n+ * @run compile OrdinarySwitchStackMapTest.java\n+ * @run main OrdinarySwitchStackMapTest\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import toolbox.JavapTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class OrdinarySwitchStackMapTest {\n+\n+    class Test {\n+        void method0(int i) throws Exception {\n+            switch (i) {\n+                case 0: System.err.println(0); break;\n+                case 1: System.err.println(1); break;\n+                default: System.err.println(2); break;\n+            }\n+        }\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        ToolBox tb = new ToolBox();\n+        Path pathToClass = Paths.get(ToolBox.testClasses, \"OrdinarySwitchStackMapTest$Test.class\");\n+        String javapOut = new JavapTask(tb)\n+                .options(\"-v\")\n+                .classes(pathToClass.toString())\n+                .run()\n+                .getOutput(Task.OutputKind.DIRECT);\n+\n+        if (!javapOut.contains(\"StackMapTable: number_of_entries = 4\"))\n+            throw new AssertionError(\"The number of entries of the stack map \"\n+                    + \"table should be equal to 4\");\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/stackmap\/OrdinarySwitchStackMapTest.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -1,5 +1,6 @@\n-SwitchNoExtraTypes.java:11:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: boolean, int)\n-SwitchNoExtraTypes.java:17:16: compiler.err.prob.found.req: (compiler.misc.possible.loss.of.precision: long, int)\n-SwitchNoExtraTypes.java:23:16: compiler.err.prob.found.req: (compiler.misc.possible.loss.of.precision: float, int)\n-SwitchNoExtraTypes.java:29:16: compiler.err.prob.found.req: (compiler.misc.possible.loss.of.precision: double, int)\n-4 errors\n+SwitchNoExtraTypes.java:11:16: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\n+SwitchNoExtraTypes.java:12:18: compiler.err.constant.label.not.compatible: boolean, boolean\n+SwitchNoExtraTypes.java:18:18: compiler.err.constant.label.not.compatible: int, long\n+SwitchNoExtraTypes.java:24:18: compiler.err.constant.label.not.compatible: int, float\n+SwitchNoExtraTypes.java:30:18: compiler.err.constant.label.not.compatible: int, double\n+5 errors\n","filename":"test\/langtools\/tools\/javac\/switchextra\/SwitchNoExtraTypes.out","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,2 +1,4 @@\n-SwitchObject.java:10:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object, int)\n-1 error\n+SwitchObject.java:10:16: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\n+SwitchObject.java:11:18: compiler.err.constant.label.not.compatible: int, java.lang.Object\n+SwitchObject.java:12:18: compiler.err.constant.label.not.compatible: java.lang.String, java.lang.Object\n+3 errors\n","filename":"test\/langtools\/tools\/javac\/switchextra\/SwitchObject.out","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262891\n+ * @summary Verify \"case null\" behavior.\n+ * @compile --enable-preview -source ${jdk.version} SwitchNull.java\n+ * @run main\/othervm --enable-preview SwitchNull\n+ *\/\n+\n+public class SwitchNull {\n+    public static void main(String... args) {\n+        SwitchNull instance = new SwitchNull();\n+\n+        instance.run();\n+    }\n+\n+    private void run() {\n+        assertEquals(0, switchIntegerBox(Integer.MIN_VALUE));\n+        assertEquals(1, switchIntegerBox(-2));\n+        assertEquals(2, switchIntegerBox(-1));\n+        assertEquals(3, switchIntegerBox(0));\n+        assertEquals(4, switchIntegerBox(1));\n+        assertEquals(5, switchIntegerBox(2));\n+        assertEquals(6, switchIntegerBox(Integer.MAX_VALUE));\n+        assertEquals(-1, switchIntegerBox(null));\n+        assertEquals(-2, switchIntegerBox(3));\n+        assertEquals(0, switchString(\"\"));\n+        assertEquals(1, switchString(\"a\"));\n+        assertEquals(2, switchString(\"A\"));\n+        assertEquals(-1, switchString(null));\n+        assertEquals(-2, switchString(\"c\"));\n+        assertEquals(0, switchEnum(E.A));\n+        assertEquals(1, switchEnum(E.B));\n+        assertEquals(2, switchEnum(E.C));\n+        assertEquals(-1, switchEnum(null));\n+        assertEquals(0, switchEnumWithDefault(E.A));\n+        assertEquals(1, switchEnumWithDefault(E.B));\n+        assertEquals(1, switchEnumWithDefault(E.C));\n+        assertEquals(-1, switchEnumWithDefault(null));\n+        testSwitchIntegerBoxExhaustive();\n+    }\n+\n+    private int switchIntegerBox(Integer i) {\n+        switch (i) {\n+            case Integer.MIN_VALUE: return 0;\n+            case -2: return 1;\n+            case -1: return 2;\n+            case 0: return 3;\n+            case 1: return 4;\n+            case 2: return 5;\n+            case Integer.MAX_VALUE: return 6;\n+            case null: return -1;\n+            default: return -2;\n+        }\n+    }\n+\n+    private int switchString(String s) {\n+        switch (s) {\n+            case \"\": return 0;\n+            case \"a\": return 1;\n+            case \"A\": return 2;\n+            case null: return -1;\n+            default: return -2;\n+        }\n+    }\n+\n+    private int switchEnum(E e) {\n+        switch (e) {\n+            case A: return 0;\n+            case B: return 1;\n+            case C: return 2;\n+            case null: return -1;\n+        }\n+        throw new AssertionError(String.valueOf(e));\n+    }\n+\n+    private int switchEnumWithDefault(E e) {\n+        switch (e) {\n+            case A: return 0;\n+            default: return 1;\n+            case null: return -1;\n+        }\n+    }\n+\n+    private void testSwitchIntegerBoxExhaustive() {\n+        int i = Integer.MIN_VALUE;\n+\n+        do {\n+            int result = switchIntegerBoxExhaustive(i);\n+            int expected = i == 0 ? 0 : 1;\n+            assertEquals(expected, result);\n+        } while (i++ < Integer.MAX_VALUE);\n+\n+        int result = switchIntegerBoxExhaustive(null);\n+        assertEquals(-1, result);\n+    }\n+\n+    private int switchIntegerBoxExhaustive(Integer i) {\n+        return switch (i) {\n+            case null -> -1;\n+            case 0 -> 0;\n+            default -> 1;\n+        };\n+    }\n+\n+    enum E {\n+        A,\n+        B,\n+        C;\n+    }\n+\n+    private void assertEquals(int expected, int actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected: \" + expected + \", actual: \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/switchnull\/SwitchNull.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+SwitchNullDisabled.java:13:18: compiler.err.preview.feature.disabled: (compiler.misc.feature.case.null)\n+1 error\n","filename":"test\/langtools\/tools\/javac\/switchnull\/SwitchNullDisabled-preview.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -4,2 +4,4 @@\n- * @summary Verify \"case null\" is not allowed.\n- * @compile\/fail\/ref=SwitchNullDisabled.out -XDrawDiagnostics SwitchNullDisabled.java\n+ * @summary Verify \"case null\" is not allowed for -source 16\n+ * @compile\/fail\/ref=SwitchNullDisabled.out -XDrawDiagnostics -source 16 -Xlint:-options SwitchNullDisabled.java\n+ * @compile\/fail\/ref=SwitchNullDisabled-preview.out -XDrawDiagnostics SwitchNullDisabled.java\n+ * @compile --enable-preview -source ${jdk.version} SwitchNullDisabled.java\n","filename":"test\/langtools\/tools\/javac\/switchnull\/SwitchNullDisabled.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-SwitchNullDisabled.java:11:18: compiler.err.switch.null.not.allowed\n+SwitchNullDisabled.java:13:18: compiler.err.preview.feature.disabled: (compiler.misc.feature.case.null)\n","filename":"test\/langtools\/tools\/javac\/switchnull\/SwitchNullDisabled.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,0 +98,2 @@\n+            if (!tree.sourcefile.toString().contains(\"EmptyBreak.java\"))\n+                return 0;\n@@ -146,19 +148,23 @@\n-                expect.add(tree);\n-                for (Field f: getFields(tree)) {\n-                    if (TypeBoundKind.class.isAssignableFrom(f.getType())) {\n-                        \/\/ not part of public API\n-                        continue;\n-                    }\n-                    try {\n-                        \/\/System.err.println(\"FIELD: \" + f.getName());\n-                        if (tree instanceof JCModuleDecl && f.getName().equals(\"mods\")) {\n-                            \/\/ The modifiers will not found by TreeScanner,\n-                            \/\/ but the embedded annotations will be.\n-                            reflectiveScan(((JCModuleDecl) tree).mods.annotations);\n-                        } else if (tree instanceof JCCase &&\n-                                   ((JCCase) tree).getCaseKind() == CaseKind.RULE &&\n-                                   f.getName().equals(\"stats\")) {\n-                            \/\/value case, visit value:\n-                            reflectiveScan(((JCCase) tree).getBody());\n-                        } else {\n-                            reflectiveScan(f.get(tree));\n+                if (!tree.hasTag(JCTree.Tag.DEFAULTCASELABEL)) {\n+                    expect.add(tree);\n+                    for (Field f: getFields(tree)) {\n+                        if (TypeBoundKind.class.isAssignableFrom(f.getType())) {\n+                            \/\/ not part of public API\n+                            continue;\n+                        }\n+                        try {\n+                            \/\/System.err.println(\"FIELD: \" + f.getName());\n+                            if (tree instanceof JCModuleDecl && f.getName().equals(\"mods\")) {\n+                                \/\/ The modifiers will not found by TreeScanner,\n+                                \/\/ but the embedded annotations will be.\n+                                reflectiveScan(((JCModuleDecl) tree).mods.annotations);\n+                            } else if (tree instanceof JCCase &&\n+                                       ((JCCase) tree).getCaseKind() == CaseKind.RULE &&\n+                                       f.getName().equals(\"stats\")) {\n+                                \/\/value case, visit value:\n+                                reflectiveScan(((JCCase) tree).getBody());\n+                            } else {\n+                                reflectiveScan(f.get(tree));\n+                            }\n+                        } catch (IllegalAccessException e) {\n+                            error(e.toString());\n@@ -166,2 +172,0 @@\n-                    } catch (IllegalAccessException e) {\n-                        error(e.toString());\n","filename":"test\/langtools\/tools\/javac\/tree\/SourceTreeScannerTest.java","additions":25,"deletions":21,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+                                \"java.base\/jdk.internal.javac\",\n","filename":"test\/langtools\/tools\/jdeps\/listdeps\/ListModuleDeps.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}