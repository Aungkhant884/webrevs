{"files":[{"patch":"@@ -4151,1 +4151,1 @@\n-            attribExpr(tree.expr, env, syms.booleanType);\n+            attribExpr(tree.expr, bodyEnv, syms.booleanType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+import java.util.Collection;\n@@ -312,1 +313,1 @@\n-            \/\/only a single (type) pattern case is valid, which is equivalent\n+            \/\/with only a single unguarded (type) pattern case, which is equivalent\n@@ -325,0 +326,7 @@\n+            \/\/constant labels in switches over enums with one or more pattern cases\n+            \/\/with guards are desugared into guards:\n+            \/\/case $constant1: $stats$\n+            \/\/=>\n+            \/\/case typeof($enum) e && e == $constant1: $stats$\n+            \/\/and handled as a normal pattern matching switch\n+            \/\/\n@@ -334,0 +342,21 @@\n+            if (enumSwitch && hasGuards(newCases)) {\n+                for (JCCase c : newCases) {\n+                    for (List<JCCaseLabel> l = c.labels; l.nonEmpty(); l = l.tail) {\n+                        if (l.head.isExpression() && !TreeInfo.isNull(l.head)) {\n+                            BindingSymbol temp = new BindingSymbol(Flags.SYNTHETIC,\n+                                    names.fromString(\"enumGuard\" + c.pos +\n+                                                     target.syntheticNameChar() + \"temp\"),\n+                                    seltype,\n+                                    currentMethodSym);\n+                            JCBindingPattern binding =\n+                                    make.at(l.head.pos()).BindingPattern(make.VarDef(temp, null));\n+                            binding.setType(seltype);\n+                            l.head = make.GuardPattern(binding,\n+                                                       makeBinary(Tag.EQ,\n+                                                                  make.Ident(temp),\n+                                                                  (JCExpression) l.head));\n+                        }\n+                    }\n+                }\n+                enumSwitch = false;\n+            }\n@@ -500,0 +529,7 @@\n+    private boolean hasGuards(Collection<JCCase> cases) {\n+        return cases.stream()\n+                    .flatMap(c -> c.labels.stream())\n+                    .filter(JCCaseLabel::isPattern)\n+                    .anyMatch(l -> !TreeInfo.primaryPatternType((JCPattern) l).unconditional());\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -51,0 +51,4 @@\n+        runEnumTest(this::testEnumWithGuards1);\n+        runEnumTest(this::testEnumWithGuards2);\n+        runEnumTest(this::testEnumWithGuardsExpression1);\n+        runEnumTest(this::testEnumWithGuardsExpression2);\n@@ -199,0 +203,40 @@\n+    String testEnumWithGuards1(E e) {\n+        switch (e) {\n+            case A: return \"a\";\n+            case B: return \"b\";\n+            case E x && \"A\".equals(x.name()): return \"broken\";\n+            case C: return String.valueOf(e);\n+            case null, E x: return String.valueOf(x);\n+        }\n+    }\n+\n+    String testEnumWithGuardsExpression1(E e) {\n+        return switch (e) {\n+            case A -> \"a\";\n+            case B -> \"b\";\n+            case E x && \"A\".equals(x.name()) -> \"broken\";\n+            case C -> String.valueOf(e);\n+            case null, E x -> String.valueOf(x);\n+        };\n+    }\n+\n+    String testEnumWithGuards2(E e) {\n+        switch (e) {\n+            case A: return \"a\";\n+            case B: return \"b\";\n+            case E x && \"C\".equals(x.name()): return \"C\";\n+            case C: return \"broken\";\n+            case null, E x: return String.valueOf(x);\n+        }\n+    }\n+\n+    String testEnumWithGuardsExpression2(E e) {\n+        return switch (e) {\n+            case A -> \"a\";\n+            case B -> \"b\";\n+            case E x && \"C\".equals(x.name()) -> \"C\";\n+            case C -> \"broken\";\n+            case null, E x -> String.valueOf(x);\n+        };\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Switches.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"}]}