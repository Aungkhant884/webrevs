{"files":[{"patch":"@@ -47,5 +47,0 @@\n- * <p>The bootstrap call site accepts a single parameter of the type of the\n- * operand of the {@code switch}, and return an {@code int} that is the index of\n- * the matched {@code case} label, {@code -1} if the target is {@code null},\n- * or {@code N} if the target is not null but matches no {@code case} label.\n- *\n@@ -87,1 +82,1 @@\n-     * the {@code target} is not {@code null}, then the method of the call site\n+     * If the {@code target} is not {@code null}, then the method of the call site\n@@ -91,2 +86,2 @@\n-     *   <li>the element is of type {@code Class} and the target value\n-     *       is a subtype of this {@code Class}; or<\/li>\n+     *   <li>the element is of type {@code Class} that is assignable\n+     *       from the target's class; or<\/li>\n@@ -110,1 +105,1 @@\n-     * @throws NullPointerException if any argument is null\n+     * @throws NullPointerException if any argument is {@code null}\n@@ -161,9 +156,4 @@\n-            } else {\n-                if (label instanceof Integer constant) {\n-                    if (target instanceof Number input && constant.intValue() == input.intValue()) {\n-                        return i;\n-                    }\n-                    if (target instanceof Character input && constant.intValue() == input.charValue()) {\n-                        return i;\n-                    }\n-                } else if (label.equals(target)) {\n+            } else if (label instanceof Integer constant) {\n+                if (target instanceof Number input && constant.intValue() == input.intValue()) {\n+                    return i;\n+                } else if (target instanceof Character input && constant.intValue() == input.charValue()) {\n@@ -172,0 +162,2 @@\n+            } else if (label.equals(target)) {\n+                return i;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":10,"deletions":18,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-\/**A marker interface for {@code Tree}s that may be used as {@link CaseTree} labels.\n+\/**\n+ * A marker interface for {@code Tree}s that may be used as {@link CaseTree} labels.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/CaseLabelTree.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,3 @@\n-\/** A case label that marks {@code default} in {@code case null, default}.\n+\/**\n+ * A case label that marks {@code default} in {@code case null, default}.\n+ *\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/DefaultCaseLabelTree.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,2 +53,2 @@\n-        catch (NoSuchMethodException | IllegalAccessException e) {\n-            throw new RuntimeException(e);\n+        catch (ReflectiveOperationException e) {\n+            throw new AssertionError(\"Should not happen\", e);\n@@ -116,0 +116,17 @@\n+\n+    public void testNullLabels() throws Throwable {\n+        MethodType switchType = MethodType.methodType(int.class, Object.class, int.class);\n+        try {\n+            BSM_TYPE_SWITCH.invoke(MethodHandles.lookup(), \"\", switchType, (Object[]) null);\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (NullPointerException ex) {\n+            \/\/OK\n+        }\n+        try {\n+            BSM_TYPE_SWITCH.invoke(MethodHandles.lookup(), \"\", switchType,\n+                                   new Object[] {1, null, String.class});\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IllegalArgumentException ex) {\n+            \/\/OK\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/runtime\/SwitchBootstrapsTest.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -42,2 +42,8 @@\n-        doRun(this::expression);\n-        doRun(this::statement);\n+        doRun(this::expressionIntf, this::validateIncompatibleClassChangeError);\n+        doRun(this::statementIntf, this::validateIncompatibleClassChangeError);\n+        doRun(this::expressionCls, this::validateIncompatibleClassChangeError);\n+        doRun(this::statementCls, this::validateIncompatibleClassChangeError);\n+        doRun(this::expressionCoveredIntf, this::validateTestException);\n+        doRun(this::statementCoveredIntf, this::validateTestException);\n+        doRun(this::expressionCoveredCls, this::validateTestException);\n+        doRun(this::statementCoveredCls, this::validateTestException);\n@@ -46,2 +52,2 @@\n-    void doRun(Consumer<SealedTypeChangesIntf> t) throws Exception {\n-        t.accept(new A());\n+    <T> void doRun(Consumer<T> t, Consumer<Throwable> validateException) throws Exception {\n+        t.accept((T) new A());\n@@ -49,1 +55,1 @@\n-            t.accept((SealedTypeChangesIntf) Class.forName(\"SealedTypeChangesClass\").newInstance());\n+            t.accept((T) Class.forName(\"SealedTypeChangesClass\").newInstance());\n@@ -51,2 +57,2 @@\n-        } catch (IncompatibleClassChangeError ex) {\n-            \/\/OK\n+        } catch (Throwable ex) {\n+            validateException.accept(ex);\n@@ -56,1 +62,51 @@\n-    void statement(SealedTypeChangesIntf obj) {\n+    void validateIncompatibleClassChangeError(Throwable t) {\n+        if (!(t instanceof IncompatibleClassChangeError)) {\n+            throw new AssertionError(\"Unexpected exception\", t);\n+        }\n+    }\n+\n+    void validateTestException(Throwable t) {\n+        if (!(t instanceof TestException)) {\n+            throw new AssertionError(\"Unexpected exception\", t);\n+        }\n+    }\n+\n+    void statementIntf(SealedTypeChangesIntf obj) {\n+        switch (obj) {\n+            case A a -> System.err.println(1);\n+        }\n+    }\n+\n+    int expressionIntf(SealedTypeChangesIntf obj) {\n+        return switch (obj) {\n+            case A a -> 0;\n+        };\n+    }\n+\n+    void statementCls(SealedTypeChangesCls obj) {\n+        switch (obj) {\n+            case A a -> System.err.println(1);\n+        }\n+    }\n+\n+    int expressionCls(SealedTypeChangesCls obj) {\n+        return switch (obj) {\n+            case A a -> 0;\n+        };\n+    }\n+\n+    void statementCoveredIntf(SealedTypeChangesIntf obj) {\n+        switch (obj) {\n+            case A a -> System.err.println(1);\n+            case SealedTypeChangesIntf o -> throw new TestException();\n+        }\n+    }\n+\n+    int expressionCoveredIntf(SealedTypeChangesIntf obj) {\n+        return switch (obj) {\n+            case A a -> 0;\n+            case SealedTypeChangesIntf o -> throw new TestException();\n+        };\n+    }\n+\n+    void statementCoveredCls(SealedTypeChangesCls obj) {\n@@ -59,0 +115,1 @@\n+            case SealedTypeChangesCls o -> throw new TestException();\n@@ -62,1 +119,1 @@\n-    int expression(SealedTypeChangesIntf obj) {\n+    int expressionCoveredCls(SealedTypeChangesCls obj) {\n@@ -65,0 +122,1 @@\n+            case SealedTypeChangesCls o -> throw new TestException();\n@@ -68,1 +126,2 @@\n-    final static class A implements SealedTypeChangesIntf {}\n+    final static class A extends SealedTypeChangesCls implements SealedTypeChangesIntf {}\n+    class TestException extends RuntimeException {}\n@@ -72,0 +131,1 @@\n+sealed abstract class SealedTypeChangesCls permits SealedTypeChanges.A {}\n","filename":"test\/langtools\/tools\/javac\/patterns\/SealedTypeChanges.java","additions":70,"deletions":10,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n-final class SealedTypeChangesClass implements SealedTypeChangesIntf {}\n+sealed abstract class SealedTypeChangesCls permits SealedTypeChanges.A, SealedTypeChangesClass {}\n+final class SealedTypeChangesClass extends SealedTypeChangesCls implements SealedTypeChangesIntf {}\n","filename":"test\/langtools\/tools\/javac\/patterns\/SealedTypeChanges2.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -186,0 +186,7 @@\n+    void sealedNonAbstract(SealedNonAbstract obj) {\n+        switch (obj) {\/\/does not cover SealedNonAbstract\n+            case A a -> {}\n+        }\n+    }\n+    sealed class SealedNonAbstract permits A {}\n+    final class A extends SealedNonAbstract {}\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+SwitchErrors.java:187:9: compiler.err.not.exhaustive.statement\n@@ -43,1 +44,1 @@\n-40 errors\n+41 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.out","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}