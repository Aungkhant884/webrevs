{"files":[{"patch":"@@ -52,1 +52,2 @@\n-    FILES := $(TOPDIR)\/src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java $(TOPDIR)\/src\/java.base\/share\/classes\/jdk\/internal\/javac\/NoPreview.java, \\\n+    FILES := $(TOPDIR)\/src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java \\\n+        $(TOPDIR)\/src\/java.base\/share\/classes\/jdk\/internal\/javac\/NoPreview.java, \\\n","filename":"make\/CompileInterimLangtools.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,3 +61,1 @@\n-    \/\/typeSwitch implementation:\n-    private static final MethodHandle TYPE_INIT_HOOK;\n-    private static final MethodHandle TYPE_SWITCH_METHOD;\n+    private static final MethodHandle DO_SWITCH;\n@@ -67,4 +65,2 @@\n-            TYPE_INIT_HOOK = LOOKUP.findStatic(SwitchBootstraps.class, \"typeInitHook\",\n-                                                  MethodType.methodType(MethodHandle.class, CallSite.class));\n-            TYPE_SWITCH_METHOD = LOOKUP.findVirtual(TypeSwitchCallSite.class, \"doSwitch\",\n-                                                    MethodType.methodType(int.class, Object.class, int.class));\n+            DO_SWITCH = LOOKUP.findStatic(SwitchBootstraps.class, \"doSwitch\",\n+                                           MethodType.methodType(int.class, Object.class, int.class, Object[].class));\n@@ -77,4 +73,0 @@\n-    private static<T extends CallSite> MethodHandle typeInitHook(T receiver) {\n-        return TYPE_SWITCH_METHOD.bindTo(receiver);\n-    }\n-\n@@ -127,1 +119,2 @@\n-        return new TypeSwitchCallSite(invocationType, labels);\n+        MethodHandle target = MethodHandles.insertArguments(DO_SWITCH, 2, (Object) labels);\n+        return new ConstantCallSite(target);\n@@ -131,1 +124,1 @@\n-        if (Objects.isNull(label)) {\n+        if (label == null) {\n@@ -134,3 +127,4 @@\n-        if (label.getClass() != Class.class &&\n-            label.getClass() != String.class &&\n-            label.getClass() != Integer.class) {\n+        Class<?> labelClass = label.getClass();\n+        if (labelClass != Class.class &&\n+            labelClass != String.class &&\n+            labelClass != Integer.class) {\n@@ -141,19 +135,14 @@\n-    static class TypeSwitchCallSite extends ConstantCallSite {\n-        private final Object[] labels;\n-\n-        TypeSwitchCallSite(MethodType targetType,\n-                           Object[] labels) throws Throwable {\n-            super(targetType, TYPE_INIT_HOOK);\n-            this.labels = labels;\n-        }\n-\n-        int doSwitch(Object target, int startIndex) {\n-            if (target == null)\n-                return -1;\n-\n-            \/\/ Dumbest possible strategy\n-            Class<?> targetClass = target.getClass();\n-            for (int i = startIndex; i < labels.length; i++) {\n-                if (labels[i] instanceof Class<?>) {\n-                    Class<?> c = (Class<?>) labels[i];\n-                    if (c.isAssignableFrom(targetClass))\n+    private static int doSwitch(Object target, int startIndex, Object[] labels) {\n+        if (target == null)\n+            return -1;\n+\n+        \/\/ Dumbest possible strategy\n+        Class<?> targetClass = target.getClass();\n+        for (int i = startIndex; i < labels.length; i++) {\n+            Object label = labels[i];\n+            if (label instanceof Class<?> c) {\n+                if (c.isAssignableFrom(targetClass))\n+                    return i;\n+            } else {\n+                if (label instanceof Integer constant) {\n+                    if (target instanceof Number input && constant.intValue() == input.intValue()) {\n@@ -161,9 +150,2 @@\n-                } else {\n-                    if (labels[i] instanceof Integer constant) {\n-                        if (target instanceof Number input && constant.intValue() == input.intValue()) {\n-                            return i;\n-                        }\n-                        if (target instanceof Character input && constant.intValue() == input.charValue()) {\n-                            return i;\n-                        }\n-                    } else if (labels[i].equals(target)) {\n+                    }\n+                    if (target instanceof Character input && constant.intValue() == input.charValue()) {\n@@ -172,0 +154,2 @@\n+                } else if (label.equals(target)) {\n+                    return i;\n@@ -174,2 +158,0 @@\n-\n-            return labels.length;\n@@ -177,0 +159,2 @@\n+\n+        return labels.length;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":30,"deletions":46,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -1662,1 +1662,3 @@\n-            if (!enumSwitch && !stringSwitch && !types.isAssignable(seltype, syms.intType)) {\n+            boolean patternSwitch;\n+            if (!enumSwitch && !stringSwitch && !errorEnumSwitch &&\n+                !types.isAssignable(seltype, syms.intType)) {\n@@ -1664,0 +1666,5 @@\n+                patternSwitch = true;\n+            } else {\n+                patternSwitch = cases.stream()\n+                                     .flatMap(c -> c.labels.stream())\n+                                     .anyMatch(l -> l.isPattern());\n@@ -1786,0 +1793,1 @@\n+                ((JCSwitch) switchTree).patternSwitch = patternSwitch;\n@@ -1788,0 +1796,1 @@\n+                ((JCSwitchExpression) switchTree).patternSwitch = patternSwitch;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -668,0 +668,1 @@\n+            Set<Object> constants = tree.patternSwitch ? allSwitchConstants(tree.selector) : null;\n@@ -673,0 +674,1 @@\n+                    handleConstantCaseLabel(constants, pat);\n@@ -688,0 +690,4 @@\n+            if ((constants == null || !constants.isEmpty()) && !tree.hasTotalPattern &&\n+                tree.patternSwitch && !TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases)) {\n+                log.error(tree, Errors.NotExhaustiveStatement);\n+            }\n@@ -699,14 +705,1 @@\n-            Set<Object> constants = null;\n-            TypeSymbol selectorSym = tree.selector.type.tsym;\n-            if ((selectorSym.flags() & ENUM) != 0) {\n-                constants = new HashSet<>();\n-                Predicate<Symbol> enumConstantFilter =\n-                        s -> (s.flags() & ENUM) != 0 && s.kind == Kind.VAR;\n-                for (Symbol s : selectorSym.members().getSymbols(enumConstantFilter)) {\n-                    constants.add(s.name);\n-                }\n-            } else if (selectorSym.isAbstract() && selectorSym.isSealed() && selectorSym.kind == Kind.TYP) {\n-                constants = new HashSet<>();\n-                constants.addAll(((ClassSymbol) selectorSym).permitted);\n-            }\n-            boolean coversInput = false;\n+            Set<Object> constants = allSwitchConstants(tree.selector);\n@@ -719,21 +712,1 @@\n-                    if (constants != null) {\n-                        if (pat.isExpression()) {\n-                            JCExpression expr = (JCExpression) pat;\n-                            if (expr.hasTag(IDENT))\n-                                constants.remove(((JCIdent) expr).name);\n-                        } else if (pat.isPattern()) {\n-                            PatternPrimaryType patternType = TreeInfo.primaryPatternType((JCPattern) pat);\n-\n-                            if (patternType.unconditional()) {\n-                                constants.remove(patternType.type().tsym);\n-                            }\n-                        }\n-                    }\n-                    if (pat.isPattern()) {\n-                        PatternPrimaryType patternType = TreeInfo.primaryPatternType((JCPattern) pat);\n-                        if (patternType.unconditional() &&\n-                            types.isSubtype(types.erasure(tree.selector.type),\n-                                            types.erasure(patternType.type()))) {\n-                            coversInput = true;\n-                        }\n-                    }\n+                    handleConstantCaseLabel(constants, pat);\n@@ -754,1 +727,1 @@\n-                !coversInput && !TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases)) {\n+                !TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases)) {\n@@ -761,0 +734,33 @@\n+        private Set<Object> allSwitchConstants(JCExpression selector) {\n+            Set<Object> constants = null;\n+            TypeSymbol selectorSym = selector.type.tsym;\n+            if ((selectorSym.flags() & ENUM) != 0) {\n+                constants = new HashSet<>();\n+                Predicate<Symbol> enumConstantFilter =\n+                        s -> (s.flags() & ENUM) != 0 && s.kind == Kind.VAR;\n+                for (Symbol s : selectorSym.members().getSymbols(enumConstantFilter)) {\n+                    constants.add(s.name);\n+                }\n+            } else if (selectorSym.isAbstract() && selectorSym.isSealed() && selectorSym.kind == Kind.TYP) {\n+                constants = new HashSet<>();\n+                constants.addAll(((ClassSymbol) selectorSym).permitted);\n+            }\n+            return constants;\n+        }\n+\n+        private void handleConstantCaseLabel(Set<Object> constants, JCCaseLabel pat) {\n+            if (constants != null) {\n+                if (pat.isExpression()) {\n+                    JCExpression expr = (JCExpression) pat;\n+                    if (expr.hasTag(IDENT))\n+                        constants.remove(((JCIdent) expr).name);\n+                } else if (pat.isPattern()) {\n+                    PatternPrimaryType patternType = TreeInfo.primaryPatternType((JCPattern) pat);\n+\n+                    if (patternType.unconditional()) {\n+                        constants.remove(patternType.type().tsym);\n+                    }\n+                }\n+            }\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":42,"deletions":36,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -3586,1 +3586,2 @@\n-        handleSwitch(tree, tree.selector, tree.cases);\n+        List<JCCase> cases = tree.patternSwitch ? addDefaultIfNeeded(tree.cases) : tree.cases;\n+        handleSwitch(tree, tree.selector, cases);\n@@ -3591,1 +3592,6 @@\n-        if (tree.cases.stream().flatMap(c -> c.labels.stream()).noneMatch(p -> p.hasTag(Tag.DEFAULTCASELABEL))) {\n+        List<JCCase> cases = addDefaultIfNeeded(tree.cases);\n+        handleSwitch(tree, tree.selector, cases);\n+    }\n+\n+    private List<JCCase> addDefaultIfNeeded(List<JCCase> cases) {\n+        if (cases.stream().flatMap(c -> c.labels.stream()).noneMatch(p -> p.hasTag(Tag.DEFAULTCASELABEL))) {\n@@ -3595,1 +3601,1 @@\n-            tree.cases = tree.cases.append(c);\n+            cases = cases.append(c);\n@@ -3597,1 +3603,2 @@\n-        handleSwitch(tree, tree.selector, tree.cases);\n+\n+        return cases;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+import com.sun.tools.javac.code.TypeTag;\n@@ -256,1 +257,1 @@\n-        handleSwitch(tree, tree.selector, tree.cases);\n+        handleSwitch(tree, tree.selector, tree.cases, tree.hasTotalPattern, tree.patternSwitch);\n@@ -261,1 +262,1 @@\n-        handleSwitch(tree, tree.selector, tree.cases);\n+        handleSwitch(tree, tree.selector, tree.cases, tree.hasTotalPattern, tree.patternSwitch);\n@@ -266,1 +267,3 @@\n-                              List<JCCase> cases) {\n+                              List<JCCase> cases,\n+                              boolean hasTotalPattern,\n+                              boolean patternSwitch) {\n@@ -269,7 +272,2 @@\n-        boolean stringSwitch = types.isSameType(seltype, syms.stringType);\n-        boolean enhancedType = !types.unboxedTypeOrType(seltype).isPrimitive() &&\n-                               !enumSwitch && !stringSwitch;\n-        boolean hasPatternLabels = cases.stream()\n-                                        .flatMap(c -> c.labels.stream())\n-                                        .anyMatch(l -> l.isPattern());\n-        if (hasPatternLabels || enhancedType) {\n+\n+        if (patternSwitch) {\n@@ -290,1 +288,1 @@\n-            \/\/         if (!(<desugared $pattern1)) { $idx = 1; continue $RESTART; }\n+            \/\/         if (!(<desugared $pattern1>)) { $idx = 1; continue $RESTART; }\n@@ -293,1 +291,1 @@\n-            \/\/         if (!(<desugared $pattern1)) { $idx = 2; continue $RESTART; }\n+            \/\/         if (!(<desugared $pattern1>)) { $idx = 2; continue $RESTART; }\n@@ -296,1 +294,1 @@\n-            \/\/         if (!(<desugared $pattern1)) { $idx = 3; continue $RESTART; }\n+            \/\/         if (!(<desugared $pattern1>)) { $idx = 3; continue $RESTART; }\n@@ -299,1 +297,1 @@\n-            \/\/         if (!(<desugared $pattern1)) { $idx = 4; continue $RESTART; }\n+            \/\/         if (!(<desugared $pattern1>)) { $idx = 4; continue $RESTART; }\n@@ -307,1 +305,1 @@\n-            \/\/ The bootstrap does not evaluate guards, which are injected at the begining of the case's\n+            \/\/ The bootstrap does not evaluate guards, which are injected at the beginning of the case's\n@@ -310,0 +308,2 @@\n+            \/\/-case null is always desugared to case -1, as the typeSwitch bootstrap method will\n+            \/\/ return -1 when the input is null\n@@ -344,0 +344,7 @@\n+            if (hasTotalPattern && !hasNullCase) {\n+                JCCase last = cases.last();\n+                if (last.labels.stream().noneMatch(l -> l.hasTag(Tag.DEFAULTCASELABEL))) {\n+                    last.labels = last.labels.prepend(makeLit(syms.botType, null));\n+                    hasNullCase = true;\n+                }\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":22,"deletions":15,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1379,0 +1379,3 @@\n+compiler.err.not.exhaustive.statement=\\\n+    the switch statement does not cover all possible input values\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1273,0 +1273,1 @@\n+        public boolean patternSwitch;\n@@ -1358,0 +1359,1 @@\n+        public boolean patternSwitch;\n@@ -2241,1 +2243,0 @@\n-\/\/        public boolean nullable;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+            default: break;\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantRefNonEffectivelyFinalVar.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.not.exhaustive.statement\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview --source ${jdk.version}\n+\n+class NotExhaustive {\n+    void t(Object o) {\n+        switch (o) {\n+            case String s -> System.err.println(\"String of length: \" + s.length());\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NotExhaustiveStatement.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -66,1 +66,0 @@\n-    \/\/TODO: interfaces\/classes (abstract non-abstract)\/exhaustive non-exhaustive\/inaccessible permitted classes\n@@ -511,0 +510,133 @@\n+\n+    @Test\n+    public void testExhaustiveStatement1(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public interface Lib {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Object obj) {\n+                       switch (obj) {\n+                           case Object o: return 0;\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testExhaustiveStatement2(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public interface Lib {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(Object obj) {\n+                       switch (obj) {\n+                           case String s: return;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:4:9: compiler.err.not.exhaustive.statement\",\n+               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+               \"- compiler.note.preview.recompile\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testExhaustiveStatement3(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case S s -> 1;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testExhaustiveStatement4(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:5:16: compiler.err.not.exhaustive\",\n+               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+               \"- compiler.note.preview.recompile\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testExhaustiveStatement5(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case B b -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":133,"deletions":1,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+            default -> {}\n","filename":"test\/langtools\/tools\/javac\/patterns\/GuardsErrors.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,12 @@\n+        assertEquals(0, matchingSwitch9(\"\"));\n+        assertEquals(1, matchingSwitch9(null));\n+        assertEquals(1, matchingSwitch9(0.0));\n+        assertEquals(0, matchingSwitch10(\"\"));\n+        assertEquals(1, matchingSwitch10(null));\n+        assertEquals(1, matchingSwitch10(0.0));\n+        assertEquals(0, matchingSwitch11(\"\"));\n+        assertEquals(2, matchingSwitch11(null));\n+        assertEquals(1, matchingSwitch11(0.0));\n+        assertEquals(0, matchingSwitch12(\"\"));\n+        assertEquals(2, matchingSwitch12(null));\n+        assertEquals(1, matchingSwitch12(0.0));\n@@ -114,0 +126,36 @@\n+    private int matchingSwitch9(Object obj) {\n+        return switch (obj) {\n+            case String s: yield 0;\n+            case Object o: yield 1;\n+        };\n+    }\n+\n+    private int matchingSwitch10(Object obj) {\n+        switch (obj) {\n+            case String s: return 0;\n+            case Object o: return 1;\n+        }\n+    }\n+\n+    private int matchingSwitch11(Object obj) {\n+        try {\n+            return switch (obj) {\n+                case String s: yield 0;\n+                default: yield 1;\n+            };\n+        } catch (NullPointerException ex) {\n+            return 2;\n+        }\n+    }\n+\n+    private int matchingSwitch12(Object obj) {\n+        try {\n+            switch (obj) {\n+                case String s: return 0;\n+                default: return 1;\n+            }\n+        } catch (NullPointerException ex) {\n+            return 2;\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/NullSwitch.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262891\n+ * @summary Verify pattern switches work properly when the set of sealed types changes.\n+ * @compile --enable-preview -source ${jdk.version} SealedTypeChanges.java\n+ * @compile --enable-preview -source ${jdk.version} SealedTypeChanges2.java\n+ * @run main\/othervm --enable-preview SealedTypeChanges\n+ *\/\n+\n+import java.util.function.Consumer;\n+\n+public class SealedTypeChanges {\n+\n+    public static void main(String... args) throws Exception {\n+        new SealedTypeChanges().run();\n+    }\n+\n+    void run() throws Exception {\n+        doRun(this::expression);\n+        doRun(this::statement);\n+    }\n+\n+    void doRun(Consumer<SealedTypeChangesIntf> t) throws Exception {\n+        t.accept(new A());\n+        try {\n+            t.accept((SealedTypeChangesIntf) Class.forName(\"SealedTypeChangesClass\").newInstance());\n+            throw new AssertionError(\"Expected an exception, but none thrown.\");\n+        } catch (IncompatibleClassChangeError ex) {\n+            \/\/OK\n+        }\n+    }\n+\n+    void statement(SealedTypeChangesIntf obj) {\n+        switch (obj) {\n+            case A a -> System.err.println(1);\n+        }\n+    }\n+\n+    int expression(SealedTypeChangesIntf obj) {\n+        return switch (obj) {\n+            case A a -> 0;\n+        };\n+    }\n+\n+    final static class A implements SealedTypeChangesIntf {}\n+}\n+\n+sealed interface SealedTypeChangesIntf permits SealedTypeChanges.A {}\n","filename":"test\/langtools\/tools\/javac\/patterns\/SealedTypeChanges.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+sealed interface SealedTypeChangesIntf permits SealedTypeChanges.A, SealedTypeChangesClass {}\n+final class SealedTypeChangesClass implements SealedTypeChangesIntf {}\n","filename":"test\/langtools\/tools\/javac\/patterns\/SealedTypeChanges2.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n- * @compile\/fail\/ref=SwitchErrors.out --enable-preview -source ${jdk.version} -XDrawDiagnostics SwitchErrors.java\n+ * @compile\/fail\/ref=SwitchErrors.out --enable-preview -source ${jdk.version} -XDrawDiagnostics -XDshould-stop.at=FLOW SwitchErrors.java\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -21,0 +21,8 @@\n+SwitchErrors.java:32:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:38:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:98:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:104:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:109:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:114:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:120:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:127:9: compiler.err.not.exhaustive.statement\n@@ -23,1 +31,1 @@\n-20 errors\n+28 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.out","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.util.function.Consumer;\n@@ -52,0 +53,2 @@\n+        npeTest(this::npeTestStatement);\n+        npeTest(this::npeTestExpression);\n@@ -62,6 +65,0 @@\n-        try {\n-            mapper.apply(null);\n-            throw new AssertionError(\"Expected a NullPointerException, but got nothing.\");\n-        } catch (NullPointerException ex) {\n-            \/\/OK\n-        }\n@@ -91,0 +88,9 @@\n+    void npeTest(Consumer<I> testCase) {\n+        try {\n+            testCase.accept(null);\n+            throw new AssertionError(\"Expected a NullPointerException, but got nothing.\");\n+        } catch (NullPointerException ex) {\n+            \/\/OK\n+        }\n+    }\n+\n@@ -191,0 +197,18 @@\n+    void npeTestStatement(I i) {\n+        switch (i) {\n+            case A a -> {}\n+            case B b -> {}\n+        }\n+    }\n+\n+    void npeTestExpression(I i) {\n+        int j = switch (i) {\n+            case A a -> 0;\n+            case B b -> 1;\n+        };\n+    }\n+\n+    sealed interface I {}\n+    final class A implements I {}\n+    final class B implements I {}\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Switches.java","additions":30,"deletions":6,"binary":false,"changes":36,"status":"modified"}]}