{"files":[{"patch":"@@ -60,1 +60,1 @@\n-    _decoration_offset[LogDecorators::full_name##_decorator] = position; \\\n+    _decoration_offset[LogDecorators::full_name##_decorator] = (offset_t)(position - _decorations_buffer); \\\n@@ -63,1 +63,1 @@\n-    _decoration_offset[LogDecorators::full_name##_decorator] = NULL; \\\n+    _decoration_offset[LogDecorators::full_name##_decorator] = invalid_offset; \\\n","filename":"src\/hotspot\/share\/logging\/logDecorations.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+  \/\/ Buffer for resolved decorations\n@@ -36,1 +37,7 @@\n-  char* _decoration_offset[LogDecorators::Count];\n+  \/\/ Lookup table, contains offsets of the decoration string start addresses by logtag\n+  \/\/ To keep its size small (which matters, see e.g. JDK-8229517) we use a byte index. That is\n+  \/\/  fine since the max. size of the decorations buffer is 256. Note: 255 is reserved\n+  \/\/  as \"invalid offset\" marker.\n+  typedef uint8_t offset_t;\n+  static const offset_t invalid_offset = DecorationsBufferSize - 1;\n+  offset_t _decoration_offset[LogDecorators::Count];\n@@ -59,1 +66,5 @@\n-    return _decoration_offset[decorator];\n+    const offset_t offset = _decoration_offset[decorator];\n+    if (offset == invalid_offset) {\n+      return NULL;\n+    }\n+    return _decorations_buffer + offset;\n","filename":"src\/hotspot\/share\/logging\/logDecorations.hpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -233,0 +233,37 @@\n+\n+\/\/ Test that the LogDecorations object can be safely copied.\n+TEST_VM(LogDecorations, copy) {\n+  \/\/ A literal with all decorations, comma-separated\n+  const char* const all_decorators =\n+#define DECORATOR(name, abbr) \",\" #name\n+  DECORATOR_LIST\n+#undef DECORATOR\n+  ;\n+  LogDecorators decorator_selection;\n+  ASSERT_TRUE(decorator_selection.parse(all_decorators + 1 \/\/ skip leading comma\n+              , tty));\n+  LogDecorations decorations_orig(LogLevel::Info, tagset, decorator_selection);\n+  LogDecorations decorations_copy(decorations_orig);\n+\n+  for (uint i = 0; i < LogDecorators::Count; i++) {\n+    LogDecorators::Decorator decorator = static_cast<LogDecorators::Decorator>(i);\n+    \/\/ Each decorator should be set here\n+    EXPECT_TRUE(decorator_selection.is_decorator(decorator));\n+\n+    \/\/ We expect the resolved decorations to be not-null, to be semantically equal but\n+    \/\/ to point to different addresses within each LogDecorations object\n+    \/\/ (unless level string, which is a constant kept somewhere else)\n+    const char* orig_deco = decorations_orig.decoration(decorator);\n+    const char* copy_deco = decorations_copy.decoration(decorator);\n+    EXPECT_NE(orig_deco, (const char*)NULL);\n+    EXPECT_NE(copy_deco, (const char*)NULL);\n+    EXPECT_EQ(::strcmp(orig_deco, copy_deco), 0);\n+    if (decorator != LogDecorators::level_decorator) {\n+      EXPECT_NE(orig_deco, copy_deco);\n+      EXPECT_GE((address)orig_deco, (address)(&decorations_orig));\n+      EXPECT_LT((address)orig_deco, (address)(&decorations_orig + 1));\n+      EXPECT_GE((address)copy_deco, (address)(&decorations_copy));\n+      EXPECT_LT((address)copy_deco, (address)(&decorations_copy + 1));\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/logging\/test_logDecorations.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"}]}