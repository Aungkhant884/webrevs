{"files":[{"patch":"@@ -59,1 +59,0 @@\n-        ensureObj(obj);\n@@ -69,1 +68,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -125,1 +124,0 @@\n-        ensureObj(obj);\n@@ -127,0 +125,1 @@\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -138,1 +137,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleBooleanFieldAccessorImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -130,1 +130,0 @@\n-        ensureObj(obj);\n@@ -132,0 +131,1 @@\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -143,1 +143,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleByteFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -105,0 +105,1 @@\n+        ensureObj(obj);\n@@ -106,1 +107,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -149,1 +149,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleCharacterFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -105,0 +105,1 @@\n+        ensureObj(obj);\n@@ -106,1 +107,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -198,1 +198,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleDoubleFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-    protected IllegalArgumentException newGetIllegalArgumentException(Class<?> type) {\n-        return new IllegalArgumentException(getMessage(true, type.getName()));\n+    protected IllegalArgumentException newGetIllegalArgumentException(Object o) {\n+        return new IllegalArgumentException(getMessage(true, o != null ? o.getClass().getName() : \"\"));\n@@ -79,2 +79,2 @@\n-    protected IllegalArgumentException newSetIllegalArgumentException(Class<?> type) {\n-        return new IllegalArgumentException(getMessage(false, type.getName()));\n+    protected IllegalArgumentException newSetIllegalArgumentException(Object o) {\n+        return new IllegalArgumentException(getMessage(false, o != null ? o.getClass().getName() : \"\"));\n@@ -82,2 +82,0 @@\n-\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleFieldAccessorImpl.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -105,0 +105,1 @@\n+        ensureObj(obj);\n@@ -106,1 +107,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -189,1 +189,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleFloatFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -105,0 +105,1 @@\n+        ensureObj(obj);\n@@ -106,1 +107,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -171,1 +171,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleIntegerFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -105,0 +105,1 @@\n+        ensureObj(obj);\n@@ -106,1 +107,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -180,1 +180,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleLongFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -101,0 +101,1 @@\n+        ensureObj(obj);\n@@ -102,1 +103,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -114,1 +114,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ already ensure the receiver type.  So this CCE is due to the value.\n+            throwSetIllegalArgumentException(value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleObjectFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -105,0 +105,1 @@\n+        ensureObj(obj);\n@@ -106,1 +107,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -159,1 +159,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleShortFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,582 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8277451\n+ * @run testng\/othervm -Djdk.reflect.useDirectMethodHandle=true NegativeTest\n+ * @run testng\/othervm -Djdk.reflect.useDirectMethodHandle=false NegativeTest\n+ * @summary Test exception thrown due to bad receiver and bad value on\n+ *          Field with and without setAccessible(true)\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class NegativeTest {\n+    static class Fields {\n+        public static int si;\n+        public static char sc;\n+        public static byte sb;\n+        public static short ss;\n+        public static long sl;\n+        public static double sd;\n+        public static float sf;\n+        public static boolean sz;\n+        public static String so;\n+\n+        public static final int sfi = 10;\n+        public static final char sfc = 'a';\n+        public static final byte sfb = 1;\n+        public static final short sfs = 2;\n+        public static final long sfl = 1000L;\n+        public static final double sfd = 1.0;\n+        public static final float sff = 2.0f;\n+        public static final boolean sfz = true;\n+        public static final String sfo = \"abc\";\n+\n+        public int i;\n+        public char c;\n+        public byte b;\n+        public short s;\n+        public long l;\n+        public double d;\n+        public float f;\n+        public boolean z;\n+        public String o;\n+\n+        public final int fi = 10;\n+        public final char fc = 'a';\n+        public final byte fb = 1;\n+        public final short fs = 2;\n+        public final long fl = 1000L;\n+        public final double fd = 1.0;\n+        public final float ff = 2.0f;\n+        public final boolean fz = true;\n+        public final String fo = \"abc\";\n+    }\n+\n+    static final Field i_field = field(\"i\", false);\n+    static final Field c_field = field(\"c\", false);\n+    static final Field b_field = field(\"b\", false);\n+    static final Field s_field = field(\"s\", false);\n+    static final Field l_field = field(\"l\", false);\n+    static final Field d_field = field(\"d\", false);\n+    static final Field f_field = field(\"f\", false);\n+    static final Field z_field = field(\"z\", false);\n+    static final Field o_field = field(\"o\", false);\n+    static final Field fi_field = field(\"fi\", false);\n+    static final Field fc_field = field(\"fc\", false);\n+    static final Field fb_field = field(\"fb\", false);\n+    static final Field fs_field = field(\"fs\", false);\n+    static final Field fl_field = field(\"fl\", false);\n+    static final Field fd_field = field(\"fd\", false);\n+    static final Field ff_field = field(\"ff\", false);\n+    static final Field fz_field = field(\"fz\", false);\n+    static final Field fo_field = field(\"fo\", false);\n+\n+    static final Field override_i_field = field(\"i\", true);\n+    static final Field override_c_field = field(\"c\", true);\n+    static final Field override_b_field = field(\"b\", true);\n+    static final Field override_s_field = field(\"s\", true);\n+    static final Field override_l_field = field(\"l\", true);\n+    static final Field override_d_field = field(\"d\", true);\n+    static final Field override_f_field = field(\"f\", true);\n+    static final Field override_z_field = field(\"z\", true);\n+    static final Field override_o_field = field(\"o\", true);\n+    static final Field override_fi_field = field(\"fi\", true);\n+    static final Field override_fc_field = field(\"fc\", true);\n+    static final Field override_fb_field = field(\"fb\", true);\n+    static final Field override_fs_field = field(\"fs\", true);\n+    static final Field override_fl_field = field(\"fl\", true);\n+    static final Field override_fd_field = field(\"fd\", true);\n+    static final Field override_ff_field = field(\"ff\", true);\n+    static final Field override_fz_field = field(\"fz\", true);\n+    static final Field override_fo_field = field(\"fo\", true);\n+\n+    static final Field si_field = field(\"si\", false);\n+    static final Field sc_field = field(\"sc\", false);\n+    static final Field sb_field = field(\"sb\", false);\n+    static final Field ss_field = field(\"ss\", false);\n+    static final Field sl_field = field(\"sl\", false);\n+    static final Field sd_field = field(\"sd\", false);\n+    static final Field sf_field = field(\"sf\", false);\n+    static final Field sz_field = field(\"sz\", false);\n+    static final Field so_field = field(\"so\", false);\n+    static final Field sfi_field = field(\"sfi\", false);\n+    static final Field sfc_field = field(\"sfc\", false);\n+    static final Field sfb_field = field(\"sfb\", false);\n+    static final Field sfs_field = field(\"sfs\", false);\n+    static final Field sfl_field = field(\"sfl\", false);\n+    static final Field sfd_field = field(\"sfd\", false);\n+    static final Field sff_field = field(\"sff\", false);\n+    static final Field sfz_field = field(\"sfz\", false);\n+    static final Field sfo_field = field(\"sfo\", false);\n+\n+    static final Field override_si_field = field(\"si\", true);\n+    static final Field override_sc_field = field(\"sc\", true);\n+    static final Field override_sb_field = field(\"sb\", true);\n+    static final Field override_ss_field = field(\"ss\", true);\n+    static final Field override_sl_field = field(\"sl\", true);\n+    static final Field override_sd_field = field(\"sd\", true);\n+    static final Field override_sf_field = field(\"sf\", true);\n+    static final Field override_sz_field = field(\"sz\", true);\n+    static final Field override_so_field = field(\"so\", true);\n+    static final Field override_sfi_field = field(\"sfi\", true);\n+    static final Field override_sfc_field = field(\"sfc\", true);\n+    static final Field override_sfb_field = field(\"sfb\", true);\n+    static final Field override_sfs_field = field(\"sfs\", true);\n+    static final Field override_sfl_field = field(\"sfl\", true);\n+    static final Field override_sfd_field = field(\"sfd\", true);\n+    static final Field override_sff_field = field(\"sff\", true);\n+    static final Field override_sfz_field = field(\"sfz\", true);\n+    static final Field override_sfo_field = field(\"sfo\", true);\n+\n+    private static Field field(String name, boolean suppressAccessCheck) {\n+        try {\n+            Field f = Fields.class.getDeclaredField(name);\n+            if (suppressAccessCheck) {\n+                f.setAccessible(true);\n+            }\n+            return f;\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @DataProvider(name = \"instanceFields\")\n+    private Object[][] instanceFields() {\n+        return new Object[][]{\n+                new Object[]{i_field},\n+                new Object[]{c_field},\n+                new Object[]{b_field},\n+                new Object[]{s_field},\n+                new Object[]{l_field},\n+                new Object[]{d_field},\n+                new Object[]{f_field},\n+                new Object[]{z_field},\n+                new Object[]{o_field},\n+                new Object[]{override_i_field},\n+                new Object[]{override_c_field},\n+                new Object[]{override_b_field},\n+                new Object[]{override_s_field},\n+                new Object[]{override_l_field},\n+                new Object[]{override_d_field},\n+                new Object[]{override_f_field},\n+                new Object[]{override_z_field},\n+                new Object[]{override_o_field},\n+                \/\/ final instance fields\n+                new Object[]{fi_field},\n+                new Object[]{fc_field},\n+                new Object[]{fb_field},\n+                new Object[]{fs_field},\n+                new Object[]{fl_field},\n+                new Object[]{fd_field},\n+                new Object[]{ff_field},\n+                new Object[]{fz_field},\n+                new Object[]{fo_field},\n+                new Object[]{override_fi_field},\n+                new Object[]{override_fc_field},\n+                new Object[]{override_fb_field},\n+                new Object[]{override_fs_field},\n+                new Object[]{override_fl_field},\n+                new Object[]{override_fd_field},\n+                new Object[]{override_ff_field},\n+                new Object[]{override_fz_field},\n+                new Object[]{override_fo_field},\n+        };\n+    }\n+    private static Fields INSTANCE = new Fields();\n+\n+    \/*\n+     * Test Field::get on a good receiver, a bad receiver and null.\n+     *\n+     * IllegalArgumentException is thrown if the receiver is of\n+     * a bad type.  NullPointerException is thrown if the receiver is null.\n+     *\/\n+    @Test(dataProvider = \"instanceFields\")\n+    public void testReceiver(Field f) throws ReflectiveOperationException {\n+        f.get(INSTANCE);     \/\/ good receiver\n+\n+        testBadReceiver(f);\n+        testNullReceiver(f);\n+    }\n+\n+    \/*\n+     * IllegalArgumentException should be thrown for bad receiver type\n+     *\/\n+    private void testBadReceiver(Field f) throws ReflectiveOperationException {\n+        assertFalse(Modifier.isStatic(f.getModifiers()));  \/\/ instance field\n+        Object badObj = new NegativeTest();\n+        try {\n+            f.get(badObj);\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            \/\/ expected\n+        }\n+        Class<?> fType = f.getType();\n+        if (fType.isPrimitive()) {\n+            try {\n+                switch (fType.descriptorString()) {\n+                    case \"B\" -> f.getByte(badObj);\n+                    case \"C\" -> f.getChar(badObj);\n+                    case \"D\" -> f.getDouble(badObj);\n+                    case \"F\" -> f.getFloat(badObj);\n+                    case \"I\" -> f.getInt(badObj);\n+                    case \"J\" -> f.getLong(badObj);\n+                    case \"S\" -> f.getShort(badObj);\n+                    case \"Z\" -> f.getBoolean(badObj);\n+                }\n+                fail(\"expected IllegalArgumentException\");\n+            } catch (IllegalArgumentException e) {\n+                \/\/ expected\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * NullPointerException should be thrown for null receiver\n+     *\/\n+    private void testNullReceiver(Field f) throws ReflectiveOperationException {\n+        assertFalse(Modifier.isStatic(f.getModifiers()));  \/\/ instance field\n+        try {\n+            f.get(null);\n+            fail(\"expected NullPointerException\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+\n+        Class<?> fType = f.getType();\n+        if (fType.isPrimitive()) {\n+            try {\n+                switch (fType.descriptorString()) {\n+                    case \"B\" -> f.getByte(null);\n+                    case \"C\" -> f.getChar(null);\n+                    case \"D\" -> f.getDouble(null);\n+                    case \"F\" -> f.getFloat(null);\n+                    case \"I\" -> f.getInt(null);\n+                    case \"J\" -> f.getLong(null);\n+                    case \"S\" -> f.getShort(null);\n+                    case \"Z\" -> f.getBoolean(null);\n+                }\n+                fail(\"expected NullPointerException\");\n+            } catch (NullPointerException e) {\n+                \/\/ expected\n+            }\n+        }\n+    }\n+\n+    @DataProvider(name = \"writeableFields\")\n+    private Object[][] writeableFields() {\n+        Fields obj = new Fields();\n+        return new Object[][]{\n+                \/\/ instance fields with and without setAccessible(true)\n+                new Object[]{i_field, obj, Integer.valueOf(10)},\n+                new Object[]{c_field, obj, Character.valueOf('c')},\n+                new Object[]{b_field, obj, Byte.valueOf((byte)1)},\n+                new Object[]{s_field, obj, Short.valueOf((short)2)},\n+                new Object[]{l_field, obj, Long.valueOf(1000)},\n+                new Object[]{d_field, obj, Double.valueOf(1.2)},\n+                new Object[]{f_field, obj, Float.valueOf(2.5f)},\n+                new Object[]{z_field, obj, Boolean.valueOf(true)},\n+                new Object[]{o_field, obj, \"good-value\"},\n+                new Object[]{override_i_field, obj, Integer.valueOf(10)},\n+                new Object[]{override_c_field, obj, Character.valueOf('c')},\n+                new Object[]{override_b_field, obj, Byte.valueOf((byte)1)},\n+                new Object[]{override_s_field, obj, Short.valueOf((short)2)},\n+                new Object[]{override_l_field, obj, Long.valueOf(1000)},\n+                new Object[]{override_d_field, obj, Double.valueOf(1.2)},\n+                new Object[]{override_f_field, obj, Float.valueOf(2.5f)},\n+                new Object[]{override_z_field, obj, Boolean.valueOf(true)},\n+                new Object[]{override_o_field, obj, \"good-value\"},\n+                \/\/ instance final fields with setAccessible(true)\n+                new Object[]{override_fi_field, obj, Integer.valueOf(10)},\n+                new Object[]{override_fc_field, obj, Character.valueOf('c')},\n+                new Object[]{override_fb_field, obj, Byte.valueOf((byte)1)},\n+                new Object[]{override_fs_field, obj, Short.valueOf((short)2)},\n+                new Object[]{override_fl_field, obj, Long.valueOf(1000)},\n+                new Object[]{override_fd_field, obj, Double.valueOf(1.2)},\n+                new Object[]{override_ff_field, obj, Float.valueOf(2.5f)},\n+                new Object[]{override_fz_field, obj, Boolean.valueOf(true)},\n+                new Object[]{override_fo_field, obj, \"good-value\"},\n+                \/\/ static fields with and without setAccessible(true)\n+                new Object[]{si_field, null, Integer.valueOf(10)},\n+                new Object[]{sc_field, null, Character.valueOf('c')},\n+                new Object[]{sb_field, null, Byte.valueOf((byte)1)},\n+                new Object[]{ss_field, null, Short.valueOf((short)2)},\n+                new Object[]{sl_field, null, Long.valueOf(1000)},\n+                new Object[]{sd_field, null, Double.valueOf(1.2)},\n+                new Object[]{sf_field, null, Float.valueOf(2.5f)},\n+                new Object[]{sz_field, null, Boolean.valueOf(true)},\n+                new Object[]{so_field, null, \"good-value\"},\n+                new Object[]{override_si_field, null, Integer.valueOf(10)},\n+                new Object[]{override_sc_field, null, Character.valueOf('c')},\n+                new Object[]{override_sb_field, null, Byte.valueOf((byte)1)},\n+                new Object[]{override_ss_field, null, Short.valueOf((short)2)},\n+                new Object[]{override_sl_field, null, Long.valueOf(1000)},\n+                new Object[]{override_sd_field, null, Double.valueOf(1.2)},\n+                new Object[]{override_sf_field, null, Float.valueOf(2.5f)},\n+                new Object[]{override_sz_field, null, Boolean.valueOf(true)},\n+                new Object[]{override_so_field, null, \"good-value\"},\n+        };\n+    }\n+\n+    \/*\n+     * Test Field::set with a good and bad value.\n+     * Test setting to null if the field type is primitive.\n+     *\n+     * IllegalArgumentException is thrown if the value is of a bad type or null.\n+     * NullPointerException is thrown if the receiver of an instance field is null.\n+     * The receiver is checked\n+     *\/\n+    @Test(dataProvider = \"writeableFields\")\n+    public void testSetValue(Field f, Object obj, Object value) throws IllegalAccessException {\n+        f.set(obj, value);\n+        Class<?> fType = f.getType();\n+        if (fType.isPrimitive()) {\n+            switch (fType.descriptorString()) {\n+                case \"B\" -> f.setByte(obj, ((Byte) value).byteValue());\n+                case \"C\" -> f.setChar(obj, ((Character) value).charValue());\n+                case \"D\" -> f.setDouble(obj, ((Double) value).doubleValue());\n+                case \"F\" -> f.setFloat(obj, ((Float) value).floatValue());\n+                case \"I\" -> f.setInt(obj, ((Integer) value).intValue());\n+                case \"J\" -> f.setLong(obj, ((Long) value).longValue());\n+                case \"S\" -> f.setShort(obj, ((Short) value).shortValue());\n+                case \"Z\" -> f.setBoolean(obj, ((Boolean) value).booleanValue());\n+            }\n+\n+            \/\/ test null value only if it's primitive type\n+            try {\n+                f.set(obj, null);\n+                fail(\"expected IllegalArgumentException\");\n+            } catch (IllegalArgumentException e) {\n+                \/\/ expected\n+            }\n+        }\n+\n+        Object badValue = new NegativeTest();\n+        try {\n+            f.set(obj, badValue);\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    @DataProvider(name = \"readOnlyFinalFields\")\n+    private Object[][] readOnlyFinalFields() {\n+        Object obj = INSTANCE;\n+        return new Object[][]{\n+                \/\/ instance final fields\n+                new Object[]{fi_field, obj, Integer.valueOf(10)},\n+                new Object[]{fc_field, obj, Character.valueOf('c')},\n+                new Object[]{fb_field, obj, Byte.valueOf((byte)1)},\n+                new Object[]{fs_field, obj, Short.valueOf((short)2)},\n+                new Object[]{fl_field, obj, Long.valueOf(1000)},\n+                new Object[]{fd_field, obj, Double.valueOf(1.2)},\n+                new Object[]{ff_field, obj, Float.valueOf(2.5f)},\n+                new Object[]{fz_field, obj, Boolean.valueOf(true)},\n+                new Object[]{fo_field, obj, \"good-value\"},\n+                \/\/ static final fields\n+                new Object[]{sfi_field, null, Integer.valueOf(10)},\n+                new Object[]{sfc_field, null, Character.valueOf('c')},\n+                new Object[]{sfb_field, null, Byte.valueOf((byte)1)},\n+                new Object[]{sfs_field, null, Short.valueOf((short)2)},\n+                new Object[]{sfl_field, null, Long.valueOf(1000)},\n+                new Object[]{sfd_field, null, Double.valueOf(1.2)},\n+                new Object[]{sff_field, null, Float.valueOf(2.5f)},\n+                new Object[]{sfz_field, null, Boolean.valueOf(true)},\n+                new Object[]{sfo_field, null, \"good-value\"},\n+                new Object[]{override_sfi_field, null, Integer.valueOf(10)},\n+                new Object[]{override_sfc_field, null, Character.valueOf('c')},\n+                new Object[]{override_sfb_field, null, Byte.valueOf((byte)1)},\n+                new Object[]{override_sfs_field, null, Short.valueOf((short)2)},\n+                new Object[]{override_sfl_field, null, Long.valueOf(1000)},\n+                new Object[]{override_sfd_field, null, Double.valueOf(1.2)},\n+                new Object[]{override_sff_field, null, Float.valueOf(2.5f)},\n+                new Object[]{override_sfz_field, null, Boolean.valueOf(true)},\n+                new Object[]{override_sfo_field, null, \"good-value\"},\n+        };\n+    }\n+\n+    \/*\n+     * Test Field::set on a read-only final field.\n+     * IllegalAccessException is thrown regardless of whether the value\n+     * is of a bad type or not.\n+     *\/\n+    @Test(dataProvider = \"readOnlyFinalFields\")\n+    public void testSetValueOnFinalField(Field f, Object obj, Object value) {\n+        assertTrue(Modifier.isFinal(f.getModifiers()));\n+        try {\n+            f.set(obj, value);\n+            fail(\"expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            \/\/ expected\n+        }\n+\n+        Class<?> fType = f.getType();\n+        if (fType.isPrimitive()) {\n+            try {\n+                switch (fType.descriptorString()) {\n+                    case \"B\" -> f.setByte(obj, ((Byte)value).byteValue());\n+                    case \"C\" -> f.setChar(obj, ((Character)value).charValue());\n+                    case \"D\" -> f.setDouble(obj, ((Double)value).doubleValue());\n+                    case \"F\" -> f.setFloat(obj, ((Float)value).floatValue());\n+                    case \"I\" -> f.setInt(obj, ((Integer)value).intValue());\n+                    case \"J\" -> f.setLong(obj, ((Long)value).longValue());\n+                    case \"S\" -> f.setShort(obj, ((Short)value).shortValue());\n+                    case \"Z\" -> f.setBoolean(obj, ((Boolean)value).booleanValue());\n+                }\n+                fail(\"expected IllegalAccessException\");\n+            } catch (IllegalAccessException e) {\n+                \/\/ expected\n+            }\n+\n+            \/\/ test null value only if it's primitive type\n+            try {\n+                f.set(obj, null);\n+                fail(\"expected IllegalAccessException\");\n+            } catch (IllegalAccessException e) {\n+                \/\/ expected\n+            }\n+        }\n+\n+        Object badValue = new NegativeTest();\n+        try {\n+            f.set(obj, badValue);\n+            fail(\"expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+\n+\n+    @DataProvider(name = \"finalInstanceFields\")\n+    private Object[][] finalInstanceFields() {\n+        return new Object[][]{\n+                new Object[]{fi_field, Integer.valueOf(10)},\n+                new Object[]{fc_field, Character.valueOf('c')},\n+                new Object[]{fb_field, Byte.valueOf((byte) 1)},\n+                new Object[]{fs_field, Short.valueOf((short) 2)},\n+                new Object[]{fl_field, Long.valueOf(1000)},\n+                new Object[]{fd_field, Double.valueOf(1.2)},\n+                new Object[]{ff_field, Float.valueOf(2.5f)},\n+                new Object[]{fz_field, Boolean.valueOf(true)},\n+                new Object[]{fo_field, \"good-value\"},\n+        };\n+    }\n+\n+    \/*\n+     * Test Field::set on a final instance field with either a bad receiver\n+     * or null.  IllegalArgumentException is thrown if the receiver is of\n+     * a bad type.  NullPointerException is thrown if the receiver is null.\n+     * The receiver is checked before the access check is performed and\n+     * also before the value is checked.\n+     *\/\n+    @Test(dataProvider = \"finalInstanceFields\")\n+    public void testReceiverOnFinalField(Field f, Object value) {\n+        assertTrue(Modifier.isFinal(f.getModifiers()));\n+        Object badReceiver = new NegativeTest();\n+        \/\/ set the field with a bad receiver with a good value\n+        try {\n+            f.set(badReceiver, value);\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            \/\/ expected\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(\"Expected IllegalArgumentException but got: \" + e.getMessage(), e);\n+        }\n+\n+        \/\/ set the field with a bad receiver with a bad value\n+        Object badValue = new NegativeTest();\n+        try {\n+            f.set(badReceiver, badValue);\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            \/\/ expected\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(\"Expected IllegalArgumentException but got: \" + e.getMessage(), e);\n+        }\n+\n+        \/\/ set the field with a null receiver with a good value\n+        try {\n+            f.set(null, value);\n+            fail(\"expected NullPointerException\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(\"Expected NullPointerException but got: \" + e.getMessage(), e);\n+        }\n+        \/\/ set the field with a null receiver with a bad value\n+        try {\n+            f.set(null, badValue);\n+            fail(\"expected NullPointerException\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(\"Expected NullPointerException but got: \" + e.getMessage(), e);\n+        }\n+\n+        Class<?> fType = f.getType();\n+        if (fType.isPrimitive()) {\n+            \/\/ test bad receiver\n+            try {\n+                switch (fType.descriptorString()) {\n+                    case \"B\" -> f.setByte(badReceiver, ((Byte) value).byteValue());\n+                    case \"C\" -> f.setChar(badReceiver, ((Character) value).charValue());\n+                    case \"D\" -> f.setDouble(badReceiver, ((Double) value).doubleValue());\n+                    case \"F\" -> f.setFloat(badReceiver, ((Float) value).floatValue());\n+                    case \"I\" -> f.setInt(badReceiver, ((Integer) value).intValue());\n+                    case \"J\" -> f.setLong(badReceiver, ((Long) value).longValue());\n+                    case \"S\" -> f.setShort(badReceiver, ((Short) value).shortValue());\n+                    case \"Z\" -> f.setBoolean(badReceiver, ((Boolean) value).booleanValue());\n+                }\n+            } catch (IllegalArgumentException e) {\n+            } catch (IllegalAccessException e) {\n+                throw new RuntimeException(\"Expected IllegalArgumentException but got: \" + e.getMessage(), e);\n+            }\n+            \/\/ test null receiver\n+            try {\n+                switch (fType.descriptorString()) {\n+                    case \"B\" -> f.setByte(null, ((Byte) value).byteValue());\n+                    case \"C\" -> f.setChar(null, ((Character) value).charValue());\n+                    case \"D\" -> f.setDouble(null, ((Double) value).doubleValue());\n+                    case \"F\" -> f.setFloat(null, ((Float) value).floatValue());\n+                    case \"I\" -> f.setInt(null, ((Integer) value).intValue());\n+                    case \"J\" -> f.setLong(null, ((Long) value).longValue());\n+                    case \"S\" -> f.setShort(null, ((Short) value).shortValue());\n+                    case \"Z\" -> f.setBoolean(null, ((Boolean) value).booleanValue());\n+                }\n+            } catch (NullPointerException e) {\n+                \/\/ expected\n+            } catch (IllegalAccessException e) {\n+                throw new RuntimeException(\"Expected NullPointerException but got: \" + e.getMessage(), e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/NegativeTest.java","additions":582,"deletions":0,"binary":false,"changes":582,"status":"added"},{"patch":"@@ -118,0 +118,2 @@\n+        private static String name = \"name\";\n+        private byte b = 9;\n@@ -133,0 +135,5 @@\n+        public Public(byte b) {\n+            this.b = b;\n+            this.i = 0;\n+            this.s = null;\n+        }\n@@ -165,0 +172,1 @@\n+                   \", b=\" + b +\n@@ -388,2 +396,5 @@\n-    private static final Throwable[] cannot_get_final_field = new Throwable[] {\n-            new IllegalArgumentException(\"Can not get final\")\n+    private static final Throwable[] cannot_get_field = new Throwable[] {\n+            new IllegalArgumentException(\"Can not get\")\n+    };\n+    private static final Throwable[] cannot_set_field = new Throwable[] {\n+            new IllegalArgumentException(\"Can not set\")\n@@ -391,2 +402,2 @@\n-    private static final Throwable[] cannot_set_final_field = new Throwable[] {\n-            new IllegalArgumentException(\"Can not set final\")\n+    private static final Throwable[] mismatched_field_type = new Throwable[] {\n+            new IllegalArgumentException(\"Can not set\")\n@@ -595,0 +606,1 @@\n+        String wrongInst = new String();\n@@ -598,2 +610,0 @@\n-                new Object[]{\"s\", new Object(), \"test\",\n-                             newImpl ? cannot_get_final_field : cannot_set_final_field},\n@@ -601,0 +611,4 @@\n+                new Object[]{\"s\", wrongInst, \"test\",\n+                        newImpl ? cannot_get_field : cannot_set_field},\n+                new Object[]{\"b\", wrongInst, 0,\n+                        newImpl ? cannot_get_field : cannot_set_field},\n@@ -605,0 +619,2 @@\n+        Object o = new Object();\n+        byte b = 1;\n@@ -607,0 +623,1 @@\n+                new Object[]{\"i\", new Public(100), 100, Integer.valueOf(10), noException},\n@@ -608,3 +625,0 @@\n-                \/\/ ## no exception thrown\n-                \/\/ new Object[]{\"i\", new Public(100), 100, new Object(), cannot_set_final_field},\n-                new Object[]{\"s\", new Object(), \"test\", \"dummy\", cannot_set_final_field},\n@@ -612,0 +626,4 @@\n+                new Object[]{\"b\", new Public(b), b, null, mismatched_field_type},\n+                new Object[]{\"b\", new Public(b), b, Long.valueOf(10), mismatched_field_type},\n+                new Object[]{\"name\", null, \"name\", o, mismatched_field_type},\n+                new Object[]{\"i\", new Public(100), 100, o, mismatched_field_type},\n","filename":"test\/jdk\/java\/lang\/reflect\/MethodHandleAccessorsTest.java","additions":27,"deletions":9,"binary":false,"changes":36,"status":"modified"}]}