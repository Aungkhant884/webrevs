{"files":[{"patch":"@@ -2444,1 +2444,1 @@\n-  _page_sizes[0] = 0;\n+  _page_sizes.add(Aix::_page_size);\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2096,1 +2096,1 @@\n-  init_page_sizes((size_t) Bsd::page_size());\n+  _page_sizes.add(Bsd::page_size());\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3772,3 +3772,1 @@\n-    _page_sizes[0] = _large_page_size;\n-    _page_sizes[1] = default_page_size;\n-    _page_sizes[2] = 0;\n+    _page_sizes.add(_large_page_size);\n@@ -4402,1 +4400,1 @@\n-  init_page_sizes((size_t) Linux::page_size());\n+  _page_sizes.add(Linux::page_size());\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3121,1 +3121,0 @@\n-\n@@ -3124,3 +3123,1 @@\n-    _page_sizes[0] = _large_page_size;\n-    _page_sizes[1] = default_page_size;\n-    _page_sizes[2] = 0;\n+    _page_sizes.add(_large_page_size);\n@@ -4169,1 +4166,1 @@\n-  init_page_sizes((size_t) win32::vm_page_size());\n+  _page_sizes.add(win32::vm_page_size());\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -78,1 +79,1 @@\n-size_t            os::_page_sizes[os::page_sizes_max];\n+os::PageSizes     os::_page_sizes;\n@@ -1393,2 +1394,2 @@\n-    for (size_t i = 0; _page_sizes[i] != 0; ++i) {\n-      const size_t page_size = _page_sizes[i];\n+    for (size_t page_size = page_sizes().largest(); page_size != 0;\n+         page_size = page_sizes().next_smaller(page_size)) {\n@@ -1539,13 +1540,0 @@\n-void os::trace_page_sizes(const char* str, const size_t* page_sizes, int count) {\n-  LogTarget(Info, pagesize) log;\n-  if (log.is_enabled()) {\n-    LogStream out(log);\n-\n-    out.print(\"%s: \", str);\n-    for (int i = 0; i < count; ++i) {\n-      out.print(\" \" SIZE_FORMAT, page_sizes[i]);\n-    }\n-    out.cr();\n-  }\n-}\n-\n@@ -1860,0 +1848,70 @@\n+\n+\n+\/\/\/\/\/\/ Implementation of PageSizes\n+\n+void os::PageSizes::add(size_t page_size) {\n+  assert(is_power_of_2(page_size), \"page_size must be a power of 2: \" SIZE_FORMAT_HEX, page_size);\n+  _v |= page_size;\n+}\n+\n+bool os::PageSizes::contains(size_t page_size) const {\n+  assert(is_power_of_2(page_size), \"page_size must be a power of 2: \" SIZE_FORMAT_HEX, page_size);\n+  return (_v & page_size) != 0;\n+}\n+\n+size_t os::PageSizes::next_smaller(size_t page_size) const {\n+  assert(is_power_of_2(page_size), \"page_size must be a power of 2: \" SIZE_FORMAT_HEX, page_size);\n+  size_t v2 = _v & (page_size - 1);\n+  if (v2 == 0) {\n+    return 0;\n+  }\n+  return round_down_power_of_2(v2);\n+}\n+\n+size_t os::PageSizes::next_larger(size_t page_size) const {\n+  assert(is_power_of_2(page_size), \"page_size must be a power of 2: \" SIZE_FORMAT_HEX, page_size);\n+  if (page_size == max_power_of_2<size_t>()) { \/\/ Shift by 32\/64 would be UB\n+    return 0;\n+  }\n+  \/\/ Remove current and smaller page sizes\n+  size_t v2 = _v & ~(page_size + (page_size - 1));\n+  if (v2 == 0) {\n+    return 0;\n+  }\n+  return (size_t)1 << count_trailing_zeros(v2);\n+}\n+\n+size_t os::PageSizes::largest() const {\n+  const size_t max = max_power_of_2<size_t>();\n+  if (contains(max)) {\n+    return max;\n+  }\n+  return next_smaller(max);\n+}\n+\n+size_t os::PageSizes::smallest() const {\n+  \/\/ Strictly speaking the set should not contain sizes < os::vm_page_size().\n+  \/\/ But this is not enforced.\n+  return next_larger(1);\n+}\n+\n+void os::PageSizes::print_on(outputStream* st) const {\n+  bool first = true;\n+  for (size_t sz = smallest(); sz != 0; sz = next_larger(sz)) {\n+    if (first) {\n+      first = false;\n+    } else {\n+      st->print_raw(\", \");\n+    }\n+    if (sz < M) {\n+      st->print(SIZE_FORMAT \"k\", sz \/ K);\n+    } else if (sz < G) {\n+      st->print(SIZE_FORMAT \"M\", sz \/ M);\n+    } else {\n+      st->print(SIZE_FORMAT \"G\", sz \/ G);\n+    }\n+  }\n+  if (first) {\n+    st->print(\"empty\");\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":74,"deletions":16,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -103,1 +103,19 @@\n-  enum { page_sizes_max = 9 }; \/\/ Size of _page_sizes array (8 plus a sentinel)\n+\n+  \/\/ A simple value class holding a set of page sizes (similar to sigset_t)\n+  class PageSizes {\n+    size_t _v; \/\/ actually a bitmap.\n+  public:\n+    PageSizes() : _v(0) {}\n+    void add(size_t pagesize);\n+    bool contains(size_t pagesize) const;\n+    \/\/ Given a page size, return the next smaller page size in this set, or 0.\n+    size_t next_smaller(size_t pagesize) const;\n+    \/\/ Given a page size, return the next larger page size in this set, or 0.\n+    size_t next_larger(size_t pagesize) const;\n+    \/\/ Returns the largest page size in this set, or 0 if set is empty.\n+    size_t largest() const;\n+    \/\/ Returns the smallest page size in this set, or 0 if set is empty.\n+    size_t smallest() const;\n+    \/\/ Prints one line of comma separated, human readable page sizes, \"empty\" if empty.\n+    void print_on(outputStream* st) const;\n+  };\n@@ -108,8 +126,1 @@\n- public:\n-  static size_t             _page_sizes[page_sizes_max];\n-\n- private:\n-  static void init_page_sizes(size_t default_page_size) {\n-    _page_sizes[0] = default_page_size;\n-    _page_sizes[1] = 0; \/\/ sentinel\n-  }\n+  static PageSizes          _page_sizes;\n@@ -277,0 +288,4 @@\n+  \/\/ The set of page sizes which the VM is allowed to use (may be a subset of\n+  \/\/  the page sizes actually available on the platform).\n+  static const PageSizes& page_sizes() { return _page_sizes; }\n+\n@@ -288,4 +303,1 @@\n-  static size_t max_page_size() {\n-    \/\/ The _page_sizes array is sorted in descending order.\n-    return _page_sizes[0];\n-  }\n+  static size_t max_page_size() { return page_sizes().largest(); }\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":25,"deletions":13,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -88,4 +88,3 @@\n-    for (size_t i = 0; os::_page_sizes[i] != 0; i++) {\n-      size_t expected = os::_page_sizes[i];\n-      size_t actual = os::page_size_for_region_unaligned(expected, 1);\n-      ASSERT_EQ(expected, actual);\n+    for (size_t s = os::page_sizes().largest(); s != 0; s = os::page_sizes().next_smaller(s)) {\n+      size_t actual = os::page_size_for_region_unaligned(s, 1);\n+      ASSERT_EQ(s, actual);\n@@ -95,4 +94,3 @@\n-    for (size_t i = 0; os::_page_sizes[i] != 0; i++) {\n-      size_t expected = os::_page_sizes[i];\n-      size_t actual = os::page_size_for_region_unaligned(expected + 17, 1);\n-      ASSERT_EQ(expected, actual);\n+    for (size_t s = os::page_sizes().largest(); s != 0; s = os::page_sizes().next_smaller(s)) {\n+      size_t actual = os::page_size_for_region_unaligned(s + 17, 1);\n+      ASSERT_EQ(s, actual);\n@@ -103,4 +101,6 @@\n-    if (os::_page_sizes[1] > os::_page_sizes[0]) {\n-      size_t expected = os::_page_sizes[0];\n-      size_t actual = os::page_size_for_region_unaligned(os::_page_sizes[1] - 17, 1);\n-      ASSERT_EQ(actual, expected);\n+    for (size_t s = os::page_sizes().largest(); s != 0; s = os::page_sizes().next_smaller(s)) {\n+      const size_t expected = os::page_sizes().next_smaller(s);\n+      if (expected != 0) {\n+        size_t actual = os::page_size_for_region_unaligned(expected - 17, 1);\n+        ASSERT_EQ(actual, expected);\n+      }\n@@ -110,1 +110,1 @@\n-    size_t small_page = small_page_size();\n+    size_t small_page = os::page_sizes().smallest();\n@@ -366,1 +366,1 @@\n-  for (int stripe = 0; stripe < num_stripes; stripe ++) {\n+  for (int stripe = 0; stripe < num_stripes; stripe++) {\n@@ -386,1 +386,1 @@\n-  for (int stripe = 0; stripe < num_stripes; stripe ++) {\n+  for (int stripe = 0; stripe < num_stripes; stripe++) {\n@@ -399,1 +399,1 @@\n-  for (int stripe = 0; stripe < num_stripes; stripe ++) {\n+  for (int stripe = 0; stripe < num_stripes; stripe++) {\n@@ -577,1 +577,1 @@\n-    for (int stripe = 0; stripe < 4; stripe ++) {\n+    for (int stripe = 0; stripe < 4; stripe++) {\n@@ -590,0 +590,75 @@\n+\n+TEST_VM(os, os_pagesizes) {\n+  ASSERT_EQ(os::min_page_size(), 4 * K);\n+  ASSERT_LE(os::min_page_size(), (size_t)os::vm_page_size());\n+  \/\/ The vm_page_size should be the smallest in the set of allowed page sizes\n+  \/\/ (contract says \"default\" page size but a lot of code actually assumes\n+  \/\/  this to be the smallest page size; notable, deliberate exception is\n+  \/\/  AIX which can have smaller page sizes but those are not part of the\n+  \/\/  page_sizes() set).\n+  ASSERT_EQ(os::page_sizes().smallest(), (size_t)os::vm_page_size());\n+  \/\/ The large page size, if it exists, shall be part of the set\n+  if (UseLargePages) {\n+    ASSERT_GT(os::large_page_size(), (size_t)os::vm_page_size());\n+    ASSERT_TRUE(os::page_sizes().contains(os::large_page_size()));\n+  }\n+  os::page_sizes().print_on(tty);\n+  tty->cr();\n+}\n+\n+static const int min_page_size_log2 = exact_log2(os::min_page_size());\n+static const int max_page_size_log2 = (int)BitsPerWord;\n+\n+TEST_VM(os, pagesizes_test_range) {\n+  for (int bit = min_page_size_log2; bit < max_page_size_log2; bit++) {\n+    for (int bit2 = min_page_size_log2; bit2 < max_page_size_log2; bit2++) {\n+      const size_t s =  (size_t)1 << bit;\n+      const size_t s2 = (size_t)1 << bit2;\n+      os::PageSizes pss;\n+      ASSERT_EQ((size_t)0, pss.smallest());\n+      ASSERT_EQ((size_t)0, pss.largest());\n+      \/\/ one size set\n+      pss.add(s);\n+      ASSERT_TRUE(pss.contains(s));\n+      ASSERT_EQ(s, pss.smallest());\n+      ASSERT_EQ(s, pss.largest());\n+      ASSERT_EQ(pss.next_larger(s), (size_t)0);\n+      ASSERT_EQ(pss.next_smaller(s), (size_t)0);\n+      \/\/ two set\n+      pss.add(s2);\n+      ASSERT_TRUE(pss.contains(s2));\n+      if (s2 < s) {\n+        ASSERT_EQ(s2, pss.smallest());\n+        ASSERT_EQ(s, pss.largest());\n+        ASSERT_EQ(pss.next_larger(s2), (size_t)s);\n+        ASSERT_EQ(pss.next_smaller(s2), (size_t)0);\n+        ASSERT_EQ(pss.next_larger(s), (size_t)0);\n+        ASSERT_EQ(pss.next_smaller(s), (size_t)s2);\n+      } else if (s2 > s) {\n+        ASSERT_EQ(s, pss.smallest());\n+        ASSERT_EQ(s2, pss.largest());\n+        ASSERT_EQ(pss.next_larger(s), (size_t)s2);\n+        ASSERT_EQ(pss.next_smaller(s), (size_t)0);\n+        ASSERT_EQ(pss.next_larger(s2), (size_t)0);\n+        ASSERT_EQ(pss.next_smaller(s2), (size_t)s);\n+      }\n+      for (int bit3 = min_page_size_log2; bit3 < max_page_size_log2; bit3++) {\n+        const size_t s3 = (size_t)1 << bit3;\n+        ASSERT_EQ(s3 == s || s3 == s2, pss.contains(s3));\n+      }\n+    }\n+  }\n+}\n+\n+TEST_VM(os, pagesizes_test_print) {\n+  os::PageSizes pss;\n+  const size_t sizes[] = { 16 * K, 64 * K, 128 * K, 1 * M, 4 * M, 1 * G, 2 * G, 0 };\n+  static const char* const expected = \"16k, 64k, 128k, 1M, 4M, 1G, 2G\";\n+  for (int i = 0; sizes[i] != 0; i++) {\n+    pss.add(sizes[i]);\n+  }\n+  char buffer[256];\n+  stringStream ss(buffer, sizeof(buffer));\n+  pss.print_on(&ss);\n+  ASSERT_EQ(strcmp(expected, buffer), 0);\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":92,"deletions":17,"binary":false,"changes":109,"status":"modified"}]}