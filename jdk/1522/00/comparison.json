{"files":[{"patch":"@@ -2444,1 +2444,1 @@\n-  _page_sizes[0] = 0;\n+  _page_sizes.add(Aix::_page_size);\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2096,1 +2096,1 @@\n-  init_page_sizes((size_t) Bsd::page_size());\n+  _page_sizes.add(Bsd::page_size());\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3772,3 +3772,1 @@\n-    _page_sizes[0] = _large_page_size;\n-    _page_sizes[1] = default_page_size;\n-    _page_sizes[2] = 0;\n+    _page_sizes.add(_large_page_size);\n@@ -4402,1 +4400,1 @@\n-  init_page_sizes((size_t) Linux::page_size());\n+  _page_sizes.add(Linux::page_size());\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3121,1 +3121,0 @@\n-\n@@ -3124,3 +3123,1 @@\n-    _page_sizes[0] = _large_page_size;\n-    _page_sizes[1] = default_page_size;\n-    _page_sizes[2] = 0;\n+    _page_sizes.add(_large_page_size);\n@@ -4169,1 +4166,1 @@\n-  init_page_sizes((size_t) win32::vm_page_size());\n+  _page_sizes.add(win32::vm_page_size());\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -78,1 +79,1 @@\n-size_t            os::_page_sizes[os::page_sizes_max];\n+os::PagesizeSet os::_page_sizes;\n@@ -1393,2 +1394,2 @@\n-    for (size_t i = 0; _page_sizes[i] != 0; ++i) {\n-      const size_t page_size = _page_sizes[i];\n+    for (size_t page_size = page_sizes().largest(); page_size != 0;\n+         page_size = page_sizes().next_smaller(page_size)) {\n@@ -1539,13 +1540,0 @@\n-void os::trace_page_sizes(const char* str, const size_t* page_sizes, int count) {\n-  LogTarget(Info, pagesize) log;\n-  if (log.is_enabled()) {\n-    LogStream out(log);\n-\n-    out.print(\"%s: \", str);\n-    for (int i = 0; i < count; ++i) {\n-      out.print(\" \" SIZE_FORMAT, page_sizes[i]);\n-    }\n-    out.cr();\n-  }\n-}\n-\n@@ -1860,0 +1848,72 @@\n+\n+\n+\/\/\/\/\/\/ Implementation of pagesizeset_t\n+\n+\/\/ A pagesizeset_t is a set containing a set of page sizes.\n+\n+\/\/ sets the given page size\n+void os::PagesizeSet::add(size_t pagesize) {\n+  assert(is_power_of_2(pagesize), \"pagesize must be a power of 2: \" INTPTR_FORMAT, pagesize);\n+  _v |= pagesize;\n+}\n+\n+\/\/ returns true if given page size is part of the set\n+bool os::PagesizeSet::is_set(size_t pagesize) const {\n+  assert(is_power_of_2(pagesize), \"pagesize must be a power of 2: \" INTPTR_FORMAT, pagesize);\n+  return _v & pagesize;\n+}\n+\n+\/\/ returns the next smallest page size set in this set, or 0.\n+size_t os::PagesizeSet::next_smaller(size_t pagesize) const {\n+  assert(is_power_of_2(pagesize), \"pagesize must be a power of 2: \" INTPTR_FORMAT, pagesize);\n+  \/\/ mask out all pages sizes >= pagesize:\n+  uintx v2 = _v & pagesize - 1;\n+  if (v2 > 0) {\n+    return round_down_power_of_2(v2);\n+  }\n+  return 0;\n+}\n+\n+size_t os::PagesizeSet::next_larger(size_t pagesize) const {\n+  assert(is_power_of_2(pagesize), \"pagesize must be a power of 2: \" INTPTR_FORMAT, pagesize);\n+  int l = exact_log2(pagesize) + 1;\n+  uintx v2 = _v >> l;\n+  if (v2 == 0) {\n+    return 0;\n+  }\n+  while ((v2 & 1) == 0) {\n+    v2 >>= 1;\n+    l ++;\n+  }\n+  return (size_t)1 << l;\n+}\n+\n+size_t os::PagesizeSet::largest() const {\n+  return next_smaller(max_power_of_2<uintx>());\n+}\n+\n+size_t os::PagesizeSet::smallest() const {\n+  assert(min_page_size() <= 4 * K, \"must be\");\n+  return next_larger(min_page_size() \/ 2);\n+}\n+\n+void os::PagesizeSet::print_on(outputStream* st) const {\n+  bool first = true;\n+  for (size_t sz = smallest(); sz != 0; sz = next_larger(sz)) {\n+    if (first) {\n+      first = false;\n+    } else {\n+      st->print_raw(\", \");\n+    }\n+    if (sz < M) {\n+      st->print(SIZE_FORMAT \"k\", sz \/ K);\n+    } else if (sz < G) {\n+      st->print(SIZE_FORMAT \"m\", sz \/ M);\n+    } else {\n+      st->print(SIZE_FORMAT \"g\", sz \/ G);\n+    }\n+  }\n+  if (first) {\n+    st->print(\"empty\");\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":76,"deletions":16,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -103,1 +103,19 @@\n-  enum { page_sizes_max = 9 }; \/\/ Size of _page_sizes array (8 plus a sentinel)\n+\n+  \/\/ A simple value class holding a set of page sizes (similar to sigset_t)\n+  class PagesizeSet {\n+    uintx _v;\n+  public:\n+    PagesizeSet() : _v(0) {}\n+    void add(size_t pagesize);\n+    bool is_set(size_t pagesize) const;\n+    \/\/ given a page size, return the next smaller page size in this set, or 0.\n+    size_t next_smaller(size_t pagesize) const;\n+    \/\/ given a page size, return the next larger page size in this set, or 0.\n+    size_t next_larger(size_t pagesize) const;\n+    \/\/ returns the largest page size in this set, or 0 if set is empty.\n+    size_t largest() const;\n+    \/\/ returns the smallest page size in this set, or 0 if set is empty.\n+    size_t smallest() const;\n+    \/\/ prints one line of comma separated, human readable page sizes, \"empty\" if empty.\n+    void print_on(outputStream* st) const;\n+  };\n@@ -108,8 +126,1 @@\n- public:\n-  static size_t             _page_sizes[page_sizes_max];\n-\n- private:\n-  static void init_page_sizes(size_t default_page_size) {\n-    _page_sizes[0] = default_page_size;\n-    _page_sizes[1] = 0; \/\/ sentinel\n-  }\n+  static PagesizeSet        _page_sizes;\n@@ -277,0 +288,4 @@\n+  \/\/ The set of page sizes which the VM is allowed to use (may be a subset of\n+  \/\/  the page sizes actually available on the platform).\n+  static const PagesizeSet& page_sizes() { return _page_sizes; }\n+\n@@ -288,4 +303,1 @@\n-  static size_t max_page_size() {\n-    \/\/ The _page_sizes array is sorted in descending order.\n-    return _page_sizes[0];\n-  }\n+  static size_t max_page_size() { return page_sizes().largest(); }\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":25,"deletions":13,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -88,4 +88,3 @@\n-    for (size_t i = 0; os::_page_sizes[i] != 0; i++) {\n-      size_t expected = os::_page_sizes[i];\n-      size_t actual = os::page_size_for_region_unaligned(expected, 1);\n-      ASSERT_EQ(expected, actual);\n+    for (size_t s = os::page_sizes().largest(); s != 0; s = os::page_sizes().next_smaller(s)) {\n+      size_t actual = os::page_size_for_region_unaligned(s, 1);\n+      ASSERT_EQ(s, actual);\n@@ -95,4 +94,3 @@\n-    for (size_t i = 0; os::_page_sizes[i] != 0; i++) {\n-      size_t expected = os::_page_sizes[i];\n-      size_t actual = os::page_size_for_region_unaligned(expected + 17, 1);\n-      ASSERT_EQ(expected, actual);\n+    for (size_t s = os::page_sizes().largest(); s != 0; s = os::page_sizes().next_smaller(s)) {\n+      size_t actual = os::page_size_for_region_unaligned(s + 17, 1);\n+      ASSERT_EQ(s, actual);\n@@ -103,4 +101,6 @@\n-    if (os::_page_sizes[1] > os::_page_sizes[0]) {\n-      size_t expected = os::_page_sizes[0];\n-      size_t actual = os::page_size_for_region_unaligned(os::_page_sizes[1] - 17, 1);\n-      ASSERT_EQ(actual, expected);\n+    for (size_t s = os::page_sizes().largest(); s != 0; s = os::page_sizes().next_smaller(s)) {\n+      const size_t expected = os::page_sizes().next_smaller(s);\n+      if (expected != 0) {\n+        size_t actual = os::page_size_for_region_unaligned(expected - 17, 1);\n+        ASSERT_EQ(actual, expected);\n+      }\n@@ -110,1 +110,1 @@\n-    size_t small_page = small_page_size();\n+    size_t small_page = os::page_sizes().smallest();\n@@ -590,0 +590,77 @@\n+\n+TEST_VM(os, pagesizes) {\n+  \/\/ The vm_page_size should be the smallest in the set of allowed page sizes\n+  \/\/ (contract says \"default\" page size but a lot of code actually assumes\n+  \/\/  this to be the smallest page size; notable, deliberate exception is\n+  \/\/  AIX which can have smaller page sizes but those are not part of the\n+  \/\/  page_sizes() set).\n+  ASSERT_EQ(os::page_sizes().smallest(), (size_t)os::vm_page_size());\n+  \/\/ The large page size, if it exists, shall be part of the set\n+  if (UseLargePages) {\n+    ASSERT_GT(os::large_page_size(), (size_t)os::vm_page_size());\n+    ASSERT_TRUE(os::page_sizes().is_set(os::large_page_size()));\n+  }\n+  os::page_sizes().print_on(tty);\n+  tty->cr();\n+}\n+\n+TEST_VM(os, pagesizeset) {\n+  const size_t largest_page_size = LP64_ONLY(1024 * G) NOT_LP64(1 * G);\n+  \/\/ Test a set with just one page size set\n+  for (size_t s = os::min_page_size(); s <= largest_page_size; s *= 2) {\n+    os::PagesizeSet pss;\n+    \/\/ Empty set\n+    ASSERT_FALSE(pss.is_set(s));\n+    ASSERT_FALSE(pss.is_set(s \/ 2));\n+    ASSERT_FALSE(pss.is_set(s * 2));\n+    ASSERT_EQ((size_t)0, pss.smallest());\n+    ASSERT_EQ((size_t)0, pss.largest());\n+    pss.add(s);\n+    \/\/ one size set\n+    ASSERT_TRUE(pss.is_set(s));\n+    ASSERT_FALSE(pss.is_set(s \/ 2));\n+    ASSERT_FALSE(pss.is_set(s * 2));\n+    ASSERT_EQ(s, pss.smallest());\n+    ASSERT_EQ(s, pss.largest());\n+    ASSERT_EQ(pss.next_larger(s), (size_t)0);\n+    ASSERT_EQ(pss.next_smaller(s), (size_t)0);\n+  }\n+  \/\/ Test a random set\n+  {\n+    os::PagesizeSet pss;\n+    const uintx master = LP64_ONLY(((uintx)os::random() << 32) + )\n+                                    (uintx)os::random();\n+    for (size_t s = os::min_page_size(); s < largest_page_size; s *= 2) {\n+      if (master & s) {\n+        pss.add(s);\n+      }\n+    }\n+    \/\/ query all sizes\n+    for (size_t s = os::min_page_size(); s < largest_page_size; s *= 2) {\n+      ASSERT_EQ(((master & s) > 0), pss.is_set(s));\n+    }\n+    \/\/ iterate both ways\n+    for (size_t s = pss.smallest(); s != 0; s = pss.next_larger(s)) {\n+      ASSERT_TRUE(master & s);\n+      ASSERT_TRUE(pss.is_set(s));\n+    }\n+    for (size_t s = pss.largest(); s != 0; s = pss.next_smaller(s)) {\n+      ASSERT_TRUE(master & s);\n+      ASSERT_TRUE(pss.is_set(s));\n+    }\n+  }\n+  \/\/ Test printing\n+  {\n+    os::PagesizeSet pss;\n+    const size_t sizes[] = { 16 * K, 64 * K, 128 * K, 1 * M, 4 * M, 1 * G, 2 * G, 0 };\n+    \/\/ init set\n+    for (int i = 0; sizes[i] != 0; i ++) {\n+      pss.add(sizes[i]);\n+    }\n+    \/\/ test printing\n+    char buffer[256];\n+    stringStream ss(buffer, sizeof(buffer));\n+    pss.print_on(&ss);\n+    ASSERT_EQ(strcmp(\"16k, 64k, 128k, 1m, 4m, 1g, 2g\", buffer), 0);\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":90,"deletions":13,"binary":false,"changes":103,"status":"modified"}]}