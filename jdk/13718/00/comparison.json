{"files":[{"patch":"@@ -163,1 +163,1 @@\n-  void set_next(ClassLoaderData* next) { _next = next; }\n+  void set_next(ClassLoaderData* next) { Atomic::store(&_next, next); }\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -264,0 +264,7 @@\n+inline void assert_is_safepoint_or_gc() {\n+  assert(SafepointSynchronize::is_at_safepoint() ||\n+         Thread::current()->is_ConcurrentGC_thread() ||\n+         Thread::current()->is_Worker_thread(),\n+         \"Must be called by safepoint or GC\");\n+}\n+\n@@ -265,1 +272,1 @@\n-  assert_locked_or_safepoint_weak(ClassLoaderDataGraph_lock);\n+  assert_is_safepoint_or_gc();\n@@ -275,2 +282,2 @@\n-  assert_locked_or_safepoint_weak(ClassLoaderDataGraph_lock);\n-  for (ClassLoaderData* cld = _head;  cld != nullptr; cld = cld->_next) {\n+  assert_is_safepoint_or_gc();\n+  for (ClassLoaderData* cld = Atomic::load_acquire(&_head);  cld != nullptr; cld = cld->next()) {\n@@ -282,2 +289,2 @@\n-  assert_locked_or_safepoint_weak(ClassLoaderDataGraph_lock);\n-  for (ClassLoaderData* cld = _head;  cld != nullptr; cld = cld->_next) {\n+  assert_is_safepoint_or_gc();\n+  for (ClassLoaderData* cld = Atomic::load_acquire(&_head);  cld != nullptr; cld = cld->next()) {\n@@ -292,1 +299,1 @@\n-  assert_locked_or_safepoint_weak(ClassLoaderDataGraph_lock);\n+  assert_is_safepoint_or_gc();\n@@ -523,1 +530,2 @@\n-      _head = data;\n+      \/\/ The GC might be walking this concurrently\n+      Atomic::store(&_head, data);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -177,10 +177,0 @@\n-\/\/ a weaker assertion than the above\n-void assert_locked_or_safepoint_weak(const Mutex* lock) {\n-  if (DebuggingContext::is_enabled() || VMError::is_error_reported()) return;\n-  assert(lock != nullptr, \"Need non-null lock\");\n-  if (lock->is_locked()) return;\n-  if (SafepointSynchronize::is_at_safepoint()) return;\n-  if (!Universe::is_fully_initialized()) return;\n-  fatal(\"must own lock %s\", lock->name());\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -183,1 +183,0 @@\n-void assert_locked_or_safepoint_weak(const Mutex* lock);\n@@ -187,1 +186,0 @@\n-#define assert_locked_or_safepoint_weak(lock)\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}