{"files":[{"patch":"@@ -28,0 +28,2 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -36,0 +38,2 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -47,0 +51,2 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -57,0 +63,2 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -67,0 +75,2 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -77,0 +87,2 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -93,0 +105,2 @@\n+import jdk.test.lib.Platform;\n+import jtreg.SkippedException;\n@@ -100,2 +114,8 @@\n-    private static boolean debug = false;\n-    private static int run = 0;\n+    private static boolean debug;\n+    private static int run;\n+\n+    private static long getKernelVersion() {\n+        long kernelVersion = Platform.getOsVersionMajor() << 8 | Platform.getOsVersionMinor();\n+        debug(\"kernelVersion \" + Long.toHexString(kernelVersion));\n+        return kernelVersion;\n+    }\n@@ -109,1 +129,1 @@\n-        System.out.println(\"Copied \" + p1 + \" to \" + p2 + \"...\");\n+        debug(\"Copied \" + p1 + \" to \" + p2 + \"...\");\n@@ -113,5 +133,1 @@\n-    \/\/ Parse \/proc\/self\/smaps using a regexp capturing the address\n-    \/\/ ranges, what page size they have and if they might use\n-    \/\/ transparent huge pages. The pattern is not greedy and will\n-    \/\/ match as little as possible so each \"segment\" in the file\n-    \/\/ will generate a match.\n+    \/\/ Parse \/proc\/self\/smaps.\n@@ -130,0 +146,4 @@\n+        \/\/ This is a simple smaps parser; it will recognize smaps section start lines\n+        \/\/  (e.g. \"40fa00000-439b80000 rw-p 00000000 00:00 0 \") and look for keywords inside the section.\n+        \/\/ Section will be finished and written into a RangeWithPageSize when either the next section is found\n+        \/\/  or the end of file is encountered.\n@@ -182,1 +202,1 @@\n-        System.out.println(\"Parsing: \" + smapsFileToParse.getFileName() + \"...\");\n+        debug(\"Parsing: \" + smapsFileToParse.getFileName() + \"...\");\n@@ -224,0 +244,16 @@\n+        } else {\n+            debug = false;\n+        }\n+\n+        \/\/ To be able to detect large page use (esp. THP) somewhat reliably, we\n+        \/\/  need at least kernel 3.8 to get the \"VmFlags\" tag in smaps.\n+        \/\/ (Note: its still good we started the VM at least since this serves as a nice\n+        \/\/  test for all manners of large page options).\n+        if (getKernelVersion() < 0x308) {\n+            throw new SkippedException(\"Kernel older than 3.8 - skipping this test.\");\n+        }\n+\n+        \/\/ For similar reasons, we skip the test on ppc platforms, since there the smaps\n+        \/\/  format may follow a different logic.\n+        if (Platform.isPPC()) {\n+            throw new SkippedException(\"PPC - skipping this test.\");\n@@ -302,0 +338,2 @@\n+        \/\/ Note: since we insist on kernels >= 3.8, all the following information should be present\n+        \/\/  (none of the input strings be null).\n@@ -305,1 +343,0 @@\n-\n@@ -311,7 +348,5 @@\n-        if (vmFlags != null) {\n-            for (String flag : vmFlags.split(\" \")) {\n-                if (flag.equals(\"ht\")) {\n-                    vmFlagHT = true;\n-                } else if (flag.equals(\"hg\")) {\n-                    vmFlagHG = true;\n-                }\n+        for (String flag : vmFlags.split(\" \")) {\n+            if (flag.equals(\"ht\")) {\n+                vmFlagHT = true;\n+            } else if (flag.equals(\"hg\")) {\n+                vmFlagHG = true;\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTracePageSizes.java","additions":52,"deletions":17,"binary":false,"changes":69,"status":"modified"}]}