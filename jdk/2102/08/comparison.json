{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,3 @@\n-import java.nio.charset.Charset;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.*;\n@@ -54,0 +56,2 @@\n+import sun.nio.cs.ArrayDecoder;\n+import sun.nio.cs.ArrayEncoder;\n@@ -55,1 +59,3 @@\n-import static java.util.function.Predicate.not;\n+import static java.lang.StringCoding.ISO_8859_1;\n+import static java.lang.StringCoding.US_ASCII;\n+import static java.lang.StringCoding.UTF_8;\n@@ -478,1 +484,1 @@\n-    public String(byte bytes[], int offset, int length, String charsetName)\n+    public String(byte[] bytes, int offset, int length, String charsetName)\n@@ -480,7 +486,1 @@\n-        if (charsetName == null)\n-            throw new NullPointerException(\"charsetName\");\n-        checkBoundsOffCount(offset, length, bytes.length);\n-        StringCoding.Result ret =\n-            StringCoding.decode(charsetName, bytes, offset, length);\n-        this.value = ret.value;\n-        this.coder = ret.coder;\n+        this(bytes, offset, length, lookupCharset(charsetName));\n@@ -519,3 +519,2 @@\n-    public String(byte bytes[], int offset, int length, Charset charset) {\n-        if (charset == null)\n-            throw new NullPointerException(\"charset\");\n+    public String(byte[] bytes, int offset, int length, Charset charset) {\n+        Objects.requireNonNull(charset);\n@@ -523,4 +522,818 @@\n-        StringCoding.Result ret =\n-            StringCoding.decode(charset, bytes, offset, length);\n-        this.value = ret.value;\n-        this.coder = ret.coder;\n+        if (length == 0) {\n+            this.value = \"\".value;\n+            this.coder = \"\".coder;\n+        } else if (charset == UTF_8) {\n+            if (COMPACT_STRINGS && !StringCoding.hasNegatives(bytes, offset, length)) {\n+                this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n+                this.coder = LATIN1;\n+            } else {\n+                int sl = offset + length;\n+                int dp = 0;\n+                byte[] dst = null;\n+                if (COMPACT_STRINGS) {\n+                    dst = new byte[length];\n+                    while (offset < sl) {\n+                        int b1 = bytes[offset];\n+                        if (b1 >= 0) {\n+                            dst[dp++] = (byte)b1;\n+                            offset++;\n+                            continue;\n+                        }\n+                        if ((b1 == (byte)0xc2 || b1 == (byte)0xc3) &&\n+                                offset + 1 < sl) {\n+                            int b2 = bytes[offset + 1];\n+                            if (!isNotContinuation(b2)) {\n+                                dst[dp++] = (byte)decode2(b1, b2);\n+                                offset += 2;\n+                                continue;\n+                            }\n+                        }\n+                        \/\/ anything not a latin1, including the repl\n+                        \/\/ we have to go with the utf16\n+                        break;\n+                    }\n+                    if (offset == sl) {\n+                        if (dp != dst.length) {\n+                            dst = Arrays.copyOf(dst, dp);\n+                        }\n+                        this.value = dst;\n+                        this.coder = LATIN1;\n+                        return;\n+                    }\n+                }\n+                if (dp == 0 || dst == null) {\n+                    dst = new byte[length << 1];\n+                } else {\n+                    byte[] buf = new byte[length << 1];\n+                    StringLatin1.inflate(dst, 0, buf, 0, dp);\n+                    dst = buf;\n+                }\n+                dp = decodeUTF8_UTF16(bytes, offset, sl, dst, dp, true);\n+                if (dp != length) {\n+                    dst = Arrays.copyOf(dst, dp << 1);\n+                }\n+                this.value = dst;\n+                this.coder = UTF16;\n+            }\n+        } else if (charset == ISO_8859_1) {\n+            if (COMPACT_STRINGS) {\n+                this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n+                this.coder = LATIN1;\n+            } else {\n+                this.value = StringLatin1.inflate(bytes, offset, length);\n+                this.coder = UTF16;\n+            }\n+        } else if (charset == US_ASCII) {\n+            if (COMPACT_STRINGS && !StringCoding.hasNegatives(bytes, offset, length)) {\n+                this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n+                this.coder = LATIN1;\n+            } else {\n+                byte[] dst = new byte[length << 1];\n+                int dp = 0;\n+                while (dp < length) {\n+                    int b = bytes[offset++];\n+                    StringUTF16.putChar(dst, dp++, (b >= 0) ? (char) b : REPL);\n+                }\n+                this.value = dst;\n+                this.coder = UTF16;\n+            }\n+        } else {\n+            \/\/ (1)We never cache the \"external\" cs, the only benefit of creating\n+            \/\/ an additional StringDe\/Encoder object to wrap it is to share the\n+            \/\/ de\/encode() method. These SD\/E objects are short-lived, the young-gen\n+            \/\/ gc should be able to take care of them well. But the best approach\n+            \/\/ is still not to generate them if not really necessary.\n+            \/\/ (2)The defensive copy of the input byte\/char[] has a big performance\n+            \/\/ impact, as well as the outgoing result byte\/char[]. Need to do the\n+            \/\/ optimization check of (sm==null && classLoader0==null) for both.\n+            CharsetDecoder cd = charset.newDecoder();\n+            \/\/ ArrayDecoder fastpaths\n+            if (cd instanceof ArrayDecoder ad) {\n+                \/\/ ascii\n+                if (ad.isASCIICompatible() && !StringCoding.hasNegatives(bytes, offset, length)) {\n+                    if (COMPACT_STRINGS) {\n+                        this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n+                        this.coder = LATIN1;\n+                        return;\n+                    }\n+                    this.value = StringLatin1.inflate(bytes, offset, length);\n+                    this.coder = UTF16;\n+                    return;\n+                }\n+\n+                \/\/ fastpath for always Latin1 decodable single byte\n+                if (COMPACT_STRINGS && ad.isLatin1Decodable()) {\n+                    byte[] dst = new byte[length];\n+                    ad.decodeToLatin1(bytes, offset, length, dst);\n+                    this.value = dst;\n+                    this.coder = LATIN1;\n+                    return;\n+                }\n+\n+                int en = scale(length, cd.maxCharsPerByte());\n+                cd.onMalformedInput(CodingErrorAction.REPLACE)\n+                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+                char[] ca = new char[en];\n+                int clen = ad.decode(bytes, offset, length, ca);\n+                if (COMPACT_STRINGS) {\n+                    byte[] bs = StringUTF16.compress(ca, 0, clen);\n+                    if (bs != null) {\n+                        value = bs;\n+                        coder = LATIN1;\n+                        return;\n+                    }\n+                }\n+                coder = UTF16;\n+                value = StringUTF16.toBytes(ca, 0, clen);\n+                return;\n+            }\n+\n+            \/\/ decode using CharsetDecoder\n+            int en = scale(length, cd.maxCharsPerByte());\n+            cd.onMalformedInput(CodingErrorAction.REPLACE)\n+                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+            char[] ca = new char[en];\n+            if (charset.getClass().getClassLoader0() != null &&\n+                    System.getSecurityManager() != null) {\n+                bytes = Arrays.copyOfRange(bytes, offset, offset + length);\n+                offset = 0;\n+            }\n+\n+            int caLen = decodeWithDecoder(cd, ca, bytes, offset, length);\n+            if (COMPACT_STRINGS) {\n+                byte[] bs = StringUTF16.compress(ca, 0, caLen);\n+                if (bs != null) {\n+                    value = bs;\n+                    coder = LATIN1;\n+                    return;\n+                }\n+            }\n+            coder = UTF16;\n+            value = StringUTF16.toBytes(ca, 0, caLen);\n+        }\n+    }\n+\n+    \/*\n+     * Throws iae, instead of replacing, if malformed or unmappable.\n+     *\/\n+    static String newStringUTF8NoRepl(byte[] bytes, int offset, int length) {\n+        checkBoundsOffCount(offset, length, bytes.length);\n+        if (length == 0) {\n+            return \"\";\n+        }\n+        if (COMPACT_STRINGS && !StringCoding.hasNegatives(bytes, offset, length)) {\n+            return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n+        } else {\n+            int sl = offset + length;\n+            int dp = 0;\n+            byte[] dst = null;\n+            if (COMPACT_STRINGS) {\n+                dst = new byte[length];\n+                while (offset < sl) {\n+                    int b1 = bytes[offset];\n+                    if (b1 >= 0) {\n+                        dst[dp++] = (byte) b1;\n+                        offset++;\n+                        continue;\n+                    }\n+                    if ((b1 == (byte) 0xc2 || b1 == (byte) 0xc3) &&\n+                            offset + 1 < sl) {\n+                        int b2 = bytes[offset + 1];\n+                        if (!isNotContinuation(b2)) {\n+                            dst[dp++] = (byte) decode2(b1, b2);\n+                            offset += 2;\n+                            continue;\n+                        }\n+                    }\n+                    \/\/ anything not a latin1, including the REPL\n+                    \/\/ we have to go with the utf16\n+                    break;\n+                }\n+                if (offset == sl) {\n+                    if (dp != dst.length) {\n+                        dst = Arrays.copyOf(dst, dp);\n+                    }\n+                    return new String(dst, LATIN1);\n+                }\n+            }\n+            if (dp == 0 || dst == null) {\n+                dst = new byte[length << 1];\n+            } else {\n+                byte[] buf = new byte[length << 1];\n+                StringLatin1.inflate(dst, 0, buf, 0, dp);\n+                dst = buf;\n+            }\n+            dp = decodeUTF8_UTF16(bytes, offset, sl, dst, dp, false);\n+            if (dp != length) {\n+                dst = Arrays.copyOf(dst, dp << 1);\n+            }\n+            return new String(dst, UTF16);\n+        }\n+    }\n+\n+    static String newStringNoRepl(byte[] src, Charset cs) throws CharacterCodingException {\n+        try {\n+            return newStringNoRepl1(src, cs);\n+        } catch (IllegalArgumentException e) {\n+            \/\/newStringNoRepl1 throws IAE with MalformedInputException or CCE as the cause\n+            Throwable cause = e.getCause();\n+            if (cause instanceof MalformedInputException mie) {\n+                throw mie;\n+            }\n+            throw (CharacterCodingException)cause;\n+        }\n+    }\n+\n+    private static String newStringNoRepl1(byte[] src, Charset cs) {\n+        int len = src.length;\n+        if (len == 0) {\n+            return \"\";\n+        }\n+        if (cs == UTF_8) {\n+            return newStringUTF8NoRepl(src, 0, src.length);\n+        }\n+        if (cs == ISO_8859_1) {\n+            if (COMPACT_STRINGS)\n+                return new String(src, LATIN1);\n+            return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n+        }\n+        if (cs == US_ASCII) {\n+            if (!StringCoding.hasNegatives(src, 0, src.length)) {\n+                if (COMPACT_STRINGS)\n+                    return new String(src, LATIN1);\n+                return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n+            } else {\n+                throwMalformed(src);\n+            }\n+        }\n+\n+        CharsetDecoder cd = cs.newDecoder();\n+        \/\/ ascii fastpath\n+        if (cd instanceof ArrayDecoder ad &&\n+                ad.isASCIICompatible() &&\n+                !StringCoding.hasNegatives(src, 0, src.length)) {\n+            return new String(src, 0, src.length, ISO_8859_1);\n+        }\n+        int en = scale(len, cd.maxCharsPerByte());\n+        char[] ca = new char[en];\n+        if (cs.getClass().getClassLoader0() != null &&\n+                System.getSecurityManager() != null) {\n+            src = Arrays.copyOf(src, len);\n+        }\n+        int caLen = decodeWithDecoder(cd, ca, src, 0, src.length);\n+        if (COMPACT_STRINGS) {\n+            byte[] bs = StringUTF16.compress(ca, 0, caLen);\n+            if (bs != null) {\n+                return new String(bs, LATIN1);\n+            }\n+        }\n+        return new String(StringUTF16.toBytes(ca, 0, caLen), UTF16);\n+    }\n+\n+    private static final char REPL = '\\ufffd';\n+\n+    \/\/ Trim the given byte array to the given length\n+    private static byte[] safeTrim(byte[] ba, int len, boolean isTrusted) {\n+        if (len == ba.length && (isTrusted || System.getSecurityManager() == null)) {\n+            return ba;\n+        } else {\n+            return Arrays.copyOf(ba, len);\n+        }\n+    }\n+\n+    private static int scale(int len, float expansionFactor) {\n+        \/\/ We need to perform double, not float, arithmetic; otherwise\n+        \/\/ we lose low order bits when len is larger than 2**24.\n+        return (int)(len * (double)expansionFactor);\n+    }\n+\n+    private static Charset lookupCharset(String csn) throws UnsupportedEncodingException {\n+        Objects.requireNonNull(csn);\n+        try {\n+            return Charset.forName(csn);\n+        } catch (UnsupportedCharsetException | IllegalCharsetNameException x) {\n+            throw new UnsupportedEncodingException(csn);\n+        }\n+    }\n+\n+    private static byte[] encode(String csn, byte coder, byte[] val)\n+            throws UnsupportedEncodingException\n+    {\n+        return encode(lookupCharset(csn), coder, val);\n+    }\n+\n+    private static byte[] encode(Charset cs, byte coder, byte[] val) {\n+        if (val.length == 0) {\n+            return \"\".value();\n+        }\n+        if (cs == UTF_8) {\n+            return encodeUTF8(coder, val, true);\n+        }\n+        if (cs == ISO_8859_1) {\n+            return encode8859_1(coder, val);\n+        }\n+        if (cs == US_ASCII) {\n+            return encodeASCII(coder, val);\n+        }\n+        CharsetEncoder ce = cs.newEncoder();\n+        int len = val.length >> coder;  \/\/ assume LATIN1=0\/UTF16=1;\n+        int en = scale(len, ce.maxBytesPerChar());\n+        if (ce instanceof ArrayEncoder ae) {\n+            \/\/ fastpath for ascii compatible\n+            if (coder == LATIN1 &&\n+                    ae.isASCIICompatible() &&\n+                    !StringCoding.hasNegatives(val, 0, val.length)) {\n+                return Arrays.copyOf(val, val.length);\n+            }\n+            byte[] ba = new byte[en];\n+            ce.onMalformedInput(CodingErrorAction.REPLACE)\n+                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+\n+            int blen = (coder == LATIN1) ? ae.encodeFromLatin1(val, 0, len, ba)\n+                    : ae.encodeFromUTF16(val, 0, len, ba);\n+            if (blen != -1) {\n+                return safeTrim(ba, blen, true);\n+            }\n+        }\n+\n+        byte[] ba = new byte[en];\n+        ce.onMalformedInput(CodingErrorAction.REPLACE)\n+                .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+        char[] ca = (coder == LATIN1 ) ? StringLatin1.toChars(val)\n+                : StringUTF16.toChars(val);\n+        ByteBuffer bb = ByteBuffer.wrap(ba);\n+        CharBuffer cb = CharBuffer.wrap(ca, 0, len);\n+        try {\n+            CoderResult cr = ce.encode(cb, bb, true);\n+            if (!cr.isUnderflow())\n+                cr.throwException();\n+            cr = ce.flush(bb);\n+            if (!cr.isUnderflow())\n+                cr.throwException();\n+        } catch (CharacterCodingException x) {\n+            throw new Error(x);\n+        }\n+        return safeTrim(ba, bb.position(), cs.getClass().getClassLoader0() == null);\n+    }\n+\n+    private static byte[] encode(byte coder, byte[] val) {\n+        return encode(Charset.defaultCharset(), coder, val);\n+    }\n+\n+    private static byte[] encodeASCII(byte coder, byte[] val) {\n+        if (coder == LATIN1) {\n+            byte[] dst = new byte[val.length];\n+            for (int i = 0; i < val.length; i++) {\n+                if (val[i] < 0) {\n+                    dst[i] = '?';\n+                } else {\n+                    dst[i] = val[i];\n+                }\n+            }\n+            return dst;\n+        }\n+        int len = val.length >> 1;\n+        byte[] dst = new byte[len];\n+        int dp = 0;\n+        for (int i = 0; i < len; i++) {\n+            char c = StringUTF16.getChar(val, i);\n+            if (c < 0x80) {\n+                dst[dp++] = (byte)c;\n+                continue;\n+            }\n+            if (Character.isHighSurrogate(c) && i + 1 < len &&\n+                    Character.isLowSurrogate(StringUTF16.getChar(val, i + 1))) {\n+                i++;\n+            }\n+            dst[dp++] = '?';\n+        }\n+        if (len == dp) {\n+            return dst;\n+        }\n+        return Arrays.copyOf(dst, dp);\n+    }\n+\n+    private static byte[] encode8859_1(byte coder, byte[] val) {\n+        return encode8859_1(coder, val, true);\n+    }\n+\n+    private static byte[] encode8859_1(byte coder, byte[] val, boolean doReplace) {\n+        if (coder == LATIN1) {\n+            return Arrays.copyOf(val, val.length);\n+        }\n+        int len = val.length >> 1;\n+        byte[] dst = new byte[len];\n+        int dp = 0;\n+        int sp = 0;\n+        int sl = len;\n+        while (sp < sl) {\n+            int ret = StringCoding.implEncodeISOArray(val, sp, dst, dp, len);\n+            sp = sp + ret;\n+            dp = dp + ret;\n+            if (ret != len) {\n+                if (!doReplace) {\n+                    throwUnmappable(sp);\n+                }\n+                char c = StringUTF16.getChar(val, sp++);\n+                if (Character.isHighSurrogate(c) && sp < sl &&\n+                        Character.isLowSurrogate(StringUTF16.getChar(val, sp))) {\n+                    sp++;\n+                }\n+                dst[dp++] = '?';\n+                len = sl - sp;\n+            }\n+        }\n+        if (dp == dst.length) {\n+            return dst;\n+        }\n+        return Arrays.copyOf(dst, dp);\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ utf8 \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\n+    private static boolean isNotContinuation(int b) {\n+        return (b & 0xc0) != 0x80;\n+    }\n+\n+    private static boolean isMalformed3(int b1, int b2, int b3) {\n+        return (b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n+                (b2 & 0xc0) != 0x80 || (b3 & 0xc0) != 0x80;\n+    }\n+\n+    private static boolean isMalformed3_2(int b1, int b2) {\n+        return (b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n+                (b2 & 0xc0) != 0x80;\n+    }\n+\n+    private static boolean isMalformed4(int b2, int b3, int b4) {\n+        return (b2 & 0xc0) != 0x80 || (b3 & 0xc0) != 0x80 ||\n+                (b4 & 0xc0) != 0x80;\n+    }\n+\n+    private static boolean isMalformed4_2(int b1, int b2) {\n+        return (b1 == 0xf0 && (b2 < 0x90 || b2 > 0xbf)) ||\n+                (b1 == 0xf4 && (b2 & 0xf0) != 0x80) ||\n+                (b2 & 0xc0) != 0x80;\n+    }\n+\n+    private static boolean isMalformed4_3(int b3) {\n+        return (b3 & 0xc0) != 0x80;\n+    }\n+\n+    private static char decode2(int b1, int b2) {\n+        return (char)(((b1 << 6) ^ b2) ^\n+                (((byte) 0xC0 << 6) ^\n+                        ((byte) 0x80 << 0)));\n+    }\n+\n+    private static char decode3(int b1, int b2, int b3) {\n+        return (char)((b1 << 12) ^\n+                (b2 <<  6) ^\n+                (b3 ^\n+                        (((byte) 0xE0 << 12) ^\n+                                ((byte) 0x80 <<  6) ^\n+                                ((byte) 0x80 <<  0))));\n+    }\n+\n+    private static int decode4(int b1, int b2, int b3, int b4) {\n+        return ((b1 << 18) ^\n+                (b2 << 12) ^\n+                (b3 <<  6) ^\n+                (b4 ^\n+                        (((byte) 0xF0 << 18) ^\n+                                ((byte) 0x80 << 12) ^\n+                                ((byte) 0x80 <<  6) ^\n+                                ((byte) 0x80 <<  0))));\n+    }\n+\n+    private static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp, boolean doReplace) {\n+        while (sp < sl) {\n+            int b1 = src[sp++];\n+            if (b1 >= 0) {\n+                StringUTF16.putChar(dst, dp++, (char) b1);\n+            } else if ((b1 >> 5) == -2 && (b1 & 0x1e) != 0) {\n+                if (sp < sl) {\n+                    int b2 = src[sp++];\n+                    if (isNotContinuation(b2)) {\n+                        if (!doReplace) {\n+                            throwMalformed(sp - 1, 1);\n+                        }\n+                        StringUTF16.putChar(dst, dp++, REPL);\n+                        sp--;\n+                    } else {\n+                        StringUTF16.putChar(dst, dp++, decode2(b1, b2));\n+                    }\n+                    continue;\n+                }\n+                if (!doReplace) {\n+                    throwMalformed(sp, 1);  \/\/ underflow()\n+                }\n+                StringUTF16.putChar(dst, dp++, REPL);\n+                break;\n+            } else if ((b1 >> 4) == -2) {\n+                if (sp + 1 < sl) {\n+                    int b2 = src[sp++];\n+                    int b3 = src[sp++];\n+                    if (isMalformed3(b1, b2, b3)) {\n+                        if (!doReplace) {\n+                            throwMalformed(sp - 3, 3);\n+                        }\n+                        StringUTF16.putChar(dst, dp++, REPL);\n+                        sp -= 3;\n+                        sp += malformed3(src, sp);\n+                    } else {\n+                        char c = decode3(b1, b2, b3);\n+                        if (Character.isSurrogate(c)) {\n+                            if (!doReplace) {\n+                                throwMalformed(sp - 3, 3);\n+                            }\n+                            StringUTF16.putChar(dst, dp++, REPL);\n+                        } else {\n+                            StringUTF16.putChar(dst, dp++, c);\n+                        }\n+                    }\n+                    continue;\n+                }\n+                if (sp < sl && isMalformed3_2(b1, src[sp])) {\n+                    if (!doReplace) {\n+                        throwMalformed(sp - 1, 2);\n+                    }\n+                    StringUTF16.putChar(dst, dp++, REPL);\n+                    continue;\n+                }\n+                if (!doReplace) {\n+                    throwMalformed(sp, 1);\n+                }\n+                StringUTF16.putChar(dst, dp++, REPL);\n+                break;\n+            } else if ((b1 >> 3) == -2) {\n+                if (sp + 2 < sl) {\n+                    int b2 = src[sp++];\n+                    int b3 = src[sp++];\n+                    int b4 = src[sp++];\n+                    int uc = decode4(b1, b2, b3, b4);\n+                    if (isMalformed4(b2, b3, b4) ||\n+                            !Character.isSupplementaryCodePoint(uc)) { \/\/ shortest form check\n+                        if (!doReplace) {\n+                            throwMalformed(sp - 4, 4);\n+                        }\n+                        StringUTF16.putChar(dst, dp++, REPL);\n+                        sp -= 4;\n+                        sp += malformed4(src, sp);\n+                    } else {\n+                        StringUTF16.putChar(dst, dp++, Character.highSurrogate(uc));\n+                        StringUTF16.putChar(dst, dp++, Character.lowSurrogate(uc));\n+                    }\n+                    continue;\n+                }\n+                b1 &= 0xff;\n+                if (b1 > 0xf4 || sp < sl && isMalformed4_2(b1, src[sp] & 0xff)) {\n+                    if (!doReplace) {\n+                        throwMalformed(sp - 1, 1);  \/\/ or 2\n+                    }\n+                    StringUTF16.putChar(dst, dp++, REPL);\n+                    continue;\n+                }\n+                if (!doReplace) {\n+                    throwMalformed(sp - 1, 1);\n+                }\n+                sp++;\n+                StringUTF16.putChar(dst, dp++, REPL);\n+                if (sp < sl && isMalformed4_3(src[sp])) {\n+                    continue;\n+                }\n+                break;\n+            } else {\n+                if (!doReplace) {\n+                    throwMalformed(sp - 1, 1);\n+                }\n+                StringUTF16.putChar(dst, dp++, REPL);\n+            }\n+        }\n+        return dp;\n+    }\n+\n+    private static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length) {\n+        ByteBuffer bb = ByteBuffer.wrap(src, offset, length);\n+        CharBuffer cb = CharBuffer.wrap(dst, 0, dst.length);\n+        try {\n+            CoderResult cr = cd.decode(bb, cb, true);\n+            if (!cr.isUnderflow())\n+                cr.throwException();\n+            cr = cd.flush(cb);\n+            if (!cr.isUnderflow())\n+                cr.throwException();\n+        } catch (CharacterCodingException x) {\n+            \/\/ Substitution is always enabled,\n+            \/\/ so this shouldn't happen\n+            throw new Error(x);\n+        }\n+        return cb.position();\n+    }\n+\n+    private static int malformed3(byte[] src, int sp) {\n+        int b1 = src[sp++];\n+        int b2 = src[sp];    \/\/ no need to lookup b3\n+        return ((b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n+                isNotContinuation(b2)) ? 1 : 2;\n+    }\n+\n+    private static int malformed4(byte[] src, int sp) {\n+        \/\/ we don't care the speed here\n+        int b1 = src[sp++] & 0xff;\n+        int b2 = src[sp++] & 0xff;\n+        if (b1 > 0xf4 ||\n+                (b1 == 0xf0 && (b2 < 0x90 || b2 > 0xbf)) ||\n+                (b1 == 0xf4 && (b2 & 0xf0) != 0x80) ||\n+                isNotContinuation(b2))\n+            return 1;\n+        if (isNotContinuation(src[sp]))\n+            return 2;\n+        return 3;\n+    }\n+\n+    private static void throwMalformed(int off, int nb) {\n+        String msg = \"malformed input off : \" + off + \", length : \" + nb;\n+        throw new IllegalArgumentException(msg, new MalformedInputException(nb));\n+    }\n+\n+    private static void throwMalformed(byte[] val) {\n+        int dp = 0;\n+        while (dp < val.length && val[dp] >=0) { dp++; }\n+        throwMalformed(dp, 1);\n+    }\n+\n+    private static void throwUnmappable(int off) {\n+        String msg = \"malformed input off : \" + off + \", length : 1\";\n+        throw new IllegalArgumentException(msg, new UnmappableCharacterException(1));\n+    }\n+\n+    private static void throwUnmappable(byte[] val) {\n+        int dp = 0;\n+        while (dp < val.length && val[dp] >=0) { dp++; }\n+        throwUnmappable(dp);\n+    }\n+\n+    private static byte[] encodeUTF8(byte coder, byte[] val, boolean doReplace) {\n+        if (coder == UTF16)\n+            return encodeUTF8_UTF16(val, doReplace);\n+\n+        if (!StringCoding.hasNegatives(val, 0, val.length))\n+            return Arrays.copyOf(val, val.length);\n+\n+        int dp = 0;\n+        byte[] dst = new byte[val.length << 1];\n+        for (byte c : val) {\n+            if (c < 0) {\n+                dst[dp++] = (byte) (0xc0 | ((c & 0xff) >> 6));\n+                dst[dp++] = (byte) (0x80 | (c & 0x3f));\n+            } else {\n+                dst[dp++] = c;\n+            }\n+        }\n+        if (dp == dst.length)\n+            return dst;\n+        return Arrays.copyOf(dst, dp);\n+    }\n+\n+    private static byte[] encodeUTF8_UTF16(byte[] val, boolean doReplace) {\n+        int dp = 0;\n+        int sp = 0;\n+        int sl = val.length >> 1;\n+        byte[] dst = new byte[sl * 3];\n+        char c;\n+        while (sp < sl && (c = StringUTF16.getChar(val, sp)) < '\\u0080') {\n+            \/\/ ascii fast loop;\n+            dst[dp++] = (byte)c;\n+            sp++;\n+        }\n+        while (sp < sl) {\n+            c = StringUTF16.getChar(val, sp++);\n+            if (c < 0x80) {\n+                dst[dp++] = (byte)c;\n+            } else if (c < 0x800) {\n+                dst[dp++] = (byte)(0xc0 | (c >> 6));\n+                dst[dp++] = (byte)(0x80 | (c & 0x3f));\n+            } else if (Character.isSurrogate(c)) {\n+                int uc = -1;\n+                char c2;\n+                if (Character.isHighSurrogate(c) && sp < sl &&\n+                        Character.isLowSurrogate(c2 = StringUTF16.getChar(val, sp))) {\n+                    uc = Character.toCodePoint(c, c2);\n+                }\n+                if (uc < 0) {\n+                    if (doReplace) {\n+                        dst[dp++] = '?';\n+                    } else {\n+                        throwUnmappable(sp - 1);\n+                    }\n+                } else {\n+                    dst[dp++] = (byte)(0xf0 | ((uc >> 18)));\n+                    dst[dp++] = (byte)(0x80 | ((uc >> 12) & 0x3f));\n+                    dst[dp++] = (byte)(0x80 | ((uc >>  6) & 0x3f));\n+                    dst[dp++] = (byte)(0x80 | (uc & 0x3f));\n+                    sp++;  \/\/ 2 chars\n+                }\n+            } else {\n+                \/\/ 3 bytes, 16 bits\n+                dst[dp++] = (byte)(0xe0 | ((c >> 12)));\n+                dst[dp++] = (byte)(0x80 | ((c >>  6) & 0x3f));\n+                dst[dp++] = (byte)(0x80 | (c & 0x3f));\n+            }\n+        }\n+        if (dp == dst.length) {\n+            return dst;\n+        }\n+        return Arrays.copyOf(dst, dp);\n+    }\n+\n+    \/*\n+     * Throws iae, instead of replacing, if unmappable.\n+     *\/\n+    static byte[] getBytesUTF8NoRepl(String s) {\n+        return encodeUTF8(s.coder(), s.value(), false);\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ for j.n.f.Files \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    private static boolean isASCII(byte[] src) {\n+        return !StringCoding.hasNegatives(src, 0, src.length);\n+    }\n+\n+    \/*\n+     * Throws CCE, instead of replacing, if unmappable.\n+     *\/\n+    static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n+        try {\n+            return getBytesNoRepl1(s, cs);\n+        } catch (IllegalArgumentException e) {\n+            \/\/getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause\n+            Throwable cause = e.getCause();\n+            if (cause instanceof UnmappableCharacterException) {\n+                throw (UnmappableCharacterException)cause;\n+            }\n+            throw (CharacterCodingException)cause;\n+        }\n+    }\n+\n+    private static byte[] getBytesNoRepl1(String s, Charset cs) {\n+        byte[] val = s.value();\n+        byte coder = s.coder();\n+        if (cs == UTF_8) {\n+            if (coder == LATIN1 && isASCII(val)) {\n+                return val;\n+            }\n+            return encodeUTF8(coder, val, false);\n+        }\n+        if (cs == ISO_8859_1) {\n+            if (coder == LATIN1) {\n+                return val;\n+            }\n+            return encode8859_1(coder, val, false);\n+        }\n+        if (cs == US_ASCII) {\n+            if (coder == LATIN1) {\n+                if (isASCII(val)) {\n+                    return val;\n+                } else {\n+                    throwUnmappable(val);\n+                }\n+            }\n+        }\n+        CharsetEncoder ce = cs.newEncoder();\n+        \/\/ fastpath for ascii compatible\n+        if (coder == LATIN1 &&\n+                ce instanceof ArrayEncoder ae &&\n+                ae.isASCIICompatible() &&\n+                isASCII(val)) {\n+            return val;\n+        }\n+        int len = val.length >> coder;  \/\/ assume LATIN1=0\/UTF16=1;\n+        int en = scale(len, ce.maxBytesPerChar());\n+        byte[] ba = new byte[en];\n+        if (len == 0) {\n+            return ba;\n+        }\n+        if (ce instanceof ArrayEncoder ae) {\n+            int blen = (coder == LATIN1 ) ? ae.encodeFromLatin1(val, 0, len, ba)\n+                                          : ae.encodeFromUTF16(val, 0, len, ba);\n+            if (blen != -1) {\n+                return safeTrim(ba, blen, true);\n+            }\n+        }\n+        char[] ca = (coder == LATIN1 ) ? StringLatin1.toChars(val)\n+                                       : StringUTF16.toChars(val);\n+        ByteBuffer bb = ByteBuffer.wrap(ba);\n+        CharBuffer cb = CharBuffer.wrap(ca, 0, len);\n+        try {\n+            CoderResult cr = ce.encode(cb, bb, true);\n+            if (!cr.isUnderflow())\n+                cr.throwException();\n+            cr = ce.flush(bb);\n+            if (!cr.isUnderflow())\n+                cr.throwException();\n+        } catch (CharacterCodingException x) {\n+            throw new IllegalArgumentException(x);\n+        }\n+        return safeTrim(ba, bb.position(), cs.getClass().getClassLoader0() == null );\n@@ -607,5 +1420,2 @@\n-    public String(byte bytes[], int offset, int length) {\n-        checkBoundsOffCount(offset, length, bytes.length);\n-        StringCoding.Result ret = StringCoding.decode(bytes, offset, length);\n-        this.value = ret.value;\n-        this.coder = ret.coder;\n+    public String(byte[] bytes, int offset, int length) {\n+        this(bytes, offset, length, Charset.defaultCharset());\n@@ -959,1 +1769,1 @@\n-        return StringCoding.encode(charsetName, coder(), value);\n+        return encode(charsetName, coder(), value);\n@@ -982,1 +1792,1 @@\n-        return StringCoding.encode(charset, coder(), value);\n+        return encode(charset, coder(), value);\n@@ -999,1 +1809,1 @@\n-        return StringCoding.encode(coder(), value);\n+        return encode(coder(), value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":836,"deletions":26,"binary":false,"changes":862,"status":"modified"},{"patch":"@@ -28,4 +28,0 @@\n-import java.io.UnsupportedEncodingException;\n-import java.lang.ref.SoftReference;\n-import java.nio.ByteBuffer;\n-import java.nio.CharBuffer;\n@@ -33,10 +29,1 @@\n-import java.nio.charset.CharsetDecoder;\n-import java.nio.charset.CharsetEncoder;\n-import java.nio.charset.CharacterCodingException;\n-import java.nio.charset.CoderResult;\n-import java.nio.charset.CodingErrorAction;\n-import java.nio.charset.IllegalCharsetNameException;\n-import java.nio.charset.MalformedInputException;\n-import java.nio.charset.UnmappableCharacterException;\n-import java.nio.charset.UnsupportedCharsetException;\n-import java.util.Arrays;\n+\n@@ -44,3 +31,0 @@\n-import sun.nio.cs.HistoricallyNamedCharset;\n-import sun.nio.cs.ArrayDecoder;\n-import sun.nio.cs.ArrayEncoder;\n@@ -48,8 +32,0 @@\n-import static java.lang.String.LATIN1;\n-import static java.lang.String.UTF16;\n-import static java.lang.String.COMPACT_STRINGS;\n-import static java.lang.Character.isSurrogate;\n-import static java.lang.Character.highSurrogate;\n-import static java.lang.Character.lowSurrogate;\n-import static java.lang.Character.isSupplementaryCodePoint;\n-import static java.lang.StringUTF16.putChar;\n@@ -60,1 +36,0 @@\n-\n@@ -65,452 +40,3 @@\n-    \/** The cached coders for each thread *\/\n-    private static final ThreadLocal<SoftReference<StringDecoder>> decoder =\n-        new ThreadLocal<>();\n-    private static final ThreadLocal<SoftReference<StringEncoder>> encoder =\n-        new ThreadLocal<>();\n-\n-    private static final Charset ISO_8859_1 = sun.nio.cs.ISO_8859_1.INSTANCE;\n-    private static final Charset US_ASCII = sun.nio.cs.US_ASCII.INSTANCE;\n-    private static final Charset UTF_8 = sun.nio.cs.UTF_8.INSTANCE;\n-\n-    private static <T> T deref(ThreadLocal<SoftReference<T>> tl) {\n-        SoftReference<T> sr = tl.get();\n-        if (sr == null)\n-            return null;\n-        return sr.get();\n-    }\n-\n-    private static <T> void set(ThreadLocal<SoftReference<T>> tl, T ob) {\n-        tl.set(new SoftReference<>(ob));\n-    }\n-\n-    \/\/ Trim the given byte array to the given length\n-    private static byte[] safeTrim(byte[] ba, int len, boolean isTrusted) {\n-        if (len == ba.length && (isTrusted || System.getSecurityManager() == null))\n-            return ba;\n-        else\n-            return Arrays.copyOf(ba, len);\n-    }\n-\n-    private static int scale(int len, float expansionFactor) {\n-        \/\/ We need to perform double, not float, arithmetic; otherwise\n-        \/\/ we lose low order bits when len is larger than 2**24.\n-        return (int)(len * (double)expansionFactor);\n-    }\n-\n-    private static Charset lookupCharset(String csn) {\n-        if (Charset.isSupported(csn)) {\n-            try {\n-                return Charset.forName(csn);\n-            } catch (UnsupportedCharsetException x) {\n-                throw new Error(x);\n-            }\n-        }\n-        return null;\n-    }\n-\n-    static class Result {\n-        byte[] value;\n-        byte coder;\n-\n-        Result with() {\n-            coder = COMPACT_STRINGS ? LATIN1 : UTF16;\n-            value = new byte[0];\n-            return this;\n-        }\n-\n-        Result with(char[] val, int off, int len) {\n-            if (String.COMPACT_STRINGS) {\n-                byte[] bs = StringUTF16.compress(val, off, len);\n-                if (bs != null) {\n-                    value = bs;\n-                    coder = LATIN1;\n-                    return this;\n-                }\n-            }\n-            coder = UTF16;\n-            value = StringUTF16.toBytes(val, off, len);\n-            return this;\n-        }\n-\n-        Result with(byte[] val, byte coder) {\n-            this.coder = coder;\n-            value = val;\n-            return this;\n-        }\n-    }\n-\n-    @IntrinsicCandidate\n-    public static boolean hasNegatives(byte[] ba, int off, int len) {\n-        for (int i = off; i < off + len; i++) {\n-            if (ba[i] < 0) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    \/\/ -- Decoding --\n-    static class StringDecoder {\n-        private final String requestedCharsetName;\n-        private final Charset cs;\n-        private final boolean isASCIICompatible;\n-        private final CharsetDecoder cd;\n-        protected final Result result;\n-\n-        StringDecoder(Charset cs, String rcn) {\n-            this.requestedCharsetName = rcn;\n-            this.cs = cs;\n-            this.cd = cs.newDecoder()\n-                .onMalformedInput(CodingErrorAction.REPLACE)\n-                .onUnmappableCharacter(CodingErrorAction.REPLACE);\n-            this.result = new Result();\n-            this.isASCIICompatible = (cd instanceof ArrayDecoder) &&\n-                    ((ArrayDecoder)cd).isASCIICompatible();\n-        }\n-\n-        String charsetName() {\n-            if (cs instanceof HistoricallyNamedCharset)\n-                return ((HistoricallyNamedCharset)cs).historicalName();\n-            return cs.name();\n-        }\n-\n-        final String requestedCharsetName() {\n-            return requestedCharsetName;\n-        }\n-\n-        Result decode(byte[] ba, int off, int len) {\n-            if (len == 0) {\n-                return result.with();\n-            }\n-            \/\/ fastpath for ascii compatible\n-            if (isASCIICompatible && !hasNegatives(ba, off, len)) {\n-                if (COMPACT_STRINGS) {\n-                    return result.with(Arrays.copyOfRange(ba, off, off + len),\n-                                      LATIN1);\n-                } else {\n-                    return result.with(StringLatin1.inflate(ba, off, len), UTF16);\n-                }\n-            }\n-            \/\/ fastpath for always Latin1 decodable single byte\n-            if (COMPACT_STRINGS && cd instanceof ArrayDecoder && ((ArrayDecoder)cd).isLatin1Decodable()) {\n-                byte[] dst = new byte[len];\n-                ((ArrayDecoder)cd).decodeToLatin1(ba, off, len, dst);\n-                return result.with(dst, LATIN1);\n-            }\n-            int en = scale(len, cd.maxCharsPerByte());\n-            char[] ca = new char[en];\n-            if (cd instanceof ArrayDecoder) {\n-                int clen = ((ArrayDecoder)cd).decode(ba, off, len, ca);\n-                return result.with(ca, 0, clen);\n-            }\n-            cd.reset();\n-            ByteBuffer bb = ByteBuffer.wrap(ba, off, len);\n-            CharBuffer cb = CharBuffer.wrap(ca);\n-            try {\n-                CoderResult cr = cd.decode(bb, cb, true);\n-                if (!cr.isUnderflow())\n-                    cr.throwException();\n-                cr = cd.flush(cb);\n-                if (!cr.isUnderflow())\n-                    cr.throwException();\n-            } catch (CharacterCodingException x) {\n-                \/\/ Substitution is always enabled,\n-                \/\/ so this shouldn't happen\n-                throw new Error(x);\n-            }\n-            return result.with(ca, 0, cb.position());\n-        }\n-    }\n-\n-    static Result decode(String charsetName, byte[] ba, int off, int len)\n-        throws UnsupportedEncodingException\n-    {\n-        StringDecoder sd = deref(decoder);\n-        String csn = (charsetName == null) ? \"ISO-8859-1\" : charsetName;\n-        if ((sd == null) || !(csn.equals(sd.requestedCharsetName())\n-                              || csn.equals(sd.charsetName()))) {\n-            sd = null;\n-            try {\n-                Charset cs = lookupCharset(csn);\n-                if (cs != null) {\n-                    if (cs == UTF_8) {\n-                        return decodeUTF8(ba, off, len, true);\n-                    }\n-                    if (cs == ISO_8859_1) {\n-                        return decodeLatin1(ba, off, len);\n-                    }\n-                    if (cs == US_ASCII) {\n-                        return decodeASCII(ba, off, len);\n-                    }\n-                    sd = new StringDecoder(cs, csn);\n-                }\n-            } catch (IllegalCharsetNameException x) {}\n-            if (sd == null)\n-                throw new UnsupportedEncodingException(csn);\n-            set(decoder, sd);\n-        }\n-        return sd.decode(ba, off, len);\n-    }\n-\n-    static Result decode(Charset cs, byte[] ba, int off, int len) {\n-        if (cs == UTF_8) {\n-            return decodeUTF8(ba, off, len, true);\n-        }\n-        if (cs == ISO_8859_1) {\n-            return decodeLatin1(ba, off, len);\n-        }\n-        if (cs == US_ASCII) {\n-            return decodeASCII(ba, off, len);\n-        }\n-\n-        \/\/ (1)We never cache the \"external\" cs, the only benefit of creating\n-        \/\/ an additional StringDe\/Encoder object to wrap it is to share the\n-        \/\/ de\/encode() method. These SD\/E objects are short-lived, the young-gen\n-        \/\/ gc should be able to take care of them well. But the best approach\n-        \/\/ is still not to generate them if not really necessary.\n-        \/\/ (2)The defensive copy of the input byte\/char[] has a big performance\n-        \/\/ impact, as well as the outgoing result byte\/char[]. Need to do the\n-        \/\/ optimization check of (sm==null && classLoader0==null) for both.\n-        \/\/ (3)There might be a timing gap in isTrusted setting. getClassLoader0()\n-        \/\/ is only checked (and then isTrusted gets set) when (SM==null). It is\n-        \/\/ possible that the SM==null for now but then SM is NOT null later\n-        \/\/ when safeTrim() is invoked...the \"safe\" way to do is to redundant\n-        \/\/ check (... && (isTrusted || SM == null || getClassLoader0())) in trim\n-        \/\/ but it then can be argued that the SM is null when the operation\n-        \/\/ is started...\n-        CharsetDecoder cd = cs.newDecoder();\n-        \/\/ ascii fastpath\n-        if ((cd instanceof ArrayDecoder) &&\n-            ((ArrayDecoder)cd).isASCIICompatible() && !hasNegatives(ba, off, len)) {\n-            return decodeLatin1(ba, off, len);\n-        }\n-        \/\/ fastpath for always Latin1 decodable single byte\n-        if (COMPACT_STRINGS && cd instanceof ArrayDecoder && ((ArrayDecoder)cd).isLatin1Decodable()) {\n-            byte[] dst = new byte[len];\n-            ((ArrayDecoder)cd).decodeToLatin1(ba, off, len, dst);\n-            return new Result().with(dst, LATIN1);\n-        }\n-\n-        int en = scale(len, cd.maxCharsPerByte());\n-        if (len == 0) {\n-            return new Result().with();\n-        }\n-        cd.onMalformedInput(CodingErrorAction.REPLACE)\n-          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n-          .reset();\n-        char[] ca = new char[en];\n-        if (cd instanceof ArrayDecoder) {\n-            int clen = ((ArrayDecoder)cd).decode(ba, off, len, ca);\n-            return new Result().with(ca, 0, clen);\n-        }\n-        if (cs.getClass().getClassLoader0() != null &&\n-            System.getSecurityManager() != null) {\n-            ba = Arrays.copyOfRange(ba, off, off + len);\n-            off = 0;\n-        }\n-        ByteBuffer bb = ByteBuffer.wrap(ba, off, len);\n-        CharBuffer cb = CharBuffer.wrap(ca);\n-        try {\n-            CoderResult cr = cd.decode(bb, cb, true);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-            cr = cd.flush(cb);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-        } catch (CharacterCodingException x) {\n-            \/\/ Substitution is always enabled,\n-            \/\/ so this shouldn't happen\n-            throw new Error(x);\n-        }\n-        return new Result().with(ca, 0, cb.position());\n-    }\n-\n-    static Result decode(byte[] ba, int off, int len) {\n-        Charset cs = Charset.defaultCharset();\n-        if (cs == UTF_8) {\n-            return decodeUTF8(ba, off, len, true);\n-        }\n-        if (cs == ISO_8859_1) {\n-            return decodeLatin1(ba, off, len);\n-        }\n-        if (cs == US_ASCII) {\n-            return decodeASCII(ba, off, len);\n-        }\n-        StringDecoder sd = deref(decoder);\n-        if (sd == null || !cs.name().equals(sd.cs.name())) {\n-            sd = new StringDecoder(cs, cs.name());\n-            set(decoder, sd);\n-        }\n-        return sd.decode(ba, off, len);\n-    }\n-\n-    \/\/ -- Encoding --\n-    private static class StringEncoder {\n-        private Charset cs;\n-        private CharsetEncoder ce;\n-        private final boolean isASCIICompatible;\n-        private final String requestedCharsetName;\n-        private final boolean isTrusted;\n-\n-        private StringEncoder(Charset cs, String rcn) {\n-            this.requestedCharsetName = rcn;\n-            this.cs = cs;\n-            this.ce = cs.newEncoder()\n-                .onMalformedInput(CodingErrorAction.REPLACE)\n-                .onUnmappableCharacter(CodingErrorAction.REPLACE);\n-            this.isTrusted = (cs.getClass().getClassLoader0() == null);\n-            this.isASCIICompatible = (ce instanceof ArrayEncoder) &&\n-                    ((ArrayEncoder)ce).isASCIICompatible();\n-        }\n-\n-        String charsetName() {\n-            if (cs instanceof HistoricallyNamedCharset)\n-                return ((HistoricallyNamedCharset)cs).historicalName();\n-            return cs.name();\n-        }\n-\n-        final String requestedCharsetName() {\n-            return requestedCharsetName;\n-        }\n-\n-        byte[] encode(byte coder, byte[] val) {\n-            \/\/ fastpath for ascii compatible\n-            if (coder == LATIN1 && isASCIICompatible &&\n-                !hasNegatives(val, 0, val.length)) {\n-                return Arrays.copyOf(val, val.length);\n-            }\n-            int len = val.length >> coder;  \/\/ assume LATIN1=0\/UTF16=1;\n-            int en = scale(len, ce.maxBytesPerChar());\n-            byte[] ba = new byte[en];\n-            if (len == 0) {\n-                return ba;\n-            }\n-            if (ce instanceof ArrayEncoder) {\n-                int blen = (coder == LATIN1 ) ? ((ArrayEncoder)ce).encodeFromLatin1(val, 0, len, ba)\n-                                              : ((ArrayEncoder)ce).encodeFromUTF16(val, 0, len, ba);\n-                if (blen != -1) {\n-                    return safeTrim(ba, blen, isTrusted);\n-                }\n-            }\n-            char[] ca = (coder == LATIN1 ) ? StringLatin1.toChars(val)\n-                                           : StringUTF16.toChars(val);\n-            ce.reset();\n-            ByteBuffer bb = ByteBuffer.wrap(ba);\n-            CharBuffer cb = CharBuffer.wrap(ca, 0, len);\n-            try {\n-                CoderResult cr = ce.encode(cb, bb, true);\n-                if (!cr.isUnderflow())\n-                    cr.throwException();\n-                cr = ce.flush(bb);\n-                if (!cr.isUnderflow())\n-                    cr.throwException();\n-            } catch (CharacterCodingException x) {\n-                \/\/ Substitution is always enabled,\n-                \/\/ so this shouldn't happen\n-                throw new Error(x);\n-            }\n-            return safeTrim(ba, bb.position(), isTrusted);\n-        }\n-    }\n-\n-    static byte[] encode(String charsetName, byte coder, byte[] val)\n-        throws UnsupportedEncodingException\n-    {\n-        StringEncoder se = deref(encoder);\n-        String csn = (charsetName == null) ? \"ISO-8859-1\" : charsetName;\n-        if ((se == null) || !(csn.equals(se.requestedCharsetName())\n-                              || csn.equals(se.charsetName()))) {\n-            se = null;\n-            try {\n-                Charset cs = lookupCharset(csn);\n-                if (cs != null) {\n-                    if (cs == UTF_8) {\n-                        return encodeUTF8(coder, val, true);\n-                    }\n-                    if (cs == ISO_8859_1) {\n-                        return encode8859_1(coder, val);\n-                    }\n-                    if (cs == US_ASCII) {\n-                        return encodeASCII(coder, val);\n-                    }\n-                    se = new StringEncoder(cs, csn);\n-                }\n-            } catch (IllegalCharsetNameException x) {}\n-            if (se == null) {\n-                throw new UnsupportedEncodingException (csn);\n-            }\n-            set(encoder, se);\n-        }\n-        return se.encode(coder, val);\n-    }\n-\n-    static byte[] encode(Charset cs, byte coder, byte[] val) {\n-        if (cs == UTF_8) {\n-            return encodeUTF8(coder, val, true);\n-        }\n-        if (cs == ISO_8859_1) {\n-            return encode8859_1(coder, val);\n-        }\n-        if (cs == US_ASCII) {\n-            return encodeASCII(coder, val);\n-        }\n-        CharsetEncoder ce = cs.newEncoder();\n-        \/\/ fastpath for ascii compatible\n-        if (coder == LATIN1 && (((ce instanceof ArrayEncoder) &&\n-                                 ((ArrayEncoder)ce).isASCIICompatible() &&\n-                                 !hasNegatives(val, 0, val.length)))) {\n-            return Arrays.copyOf(val, val.length);\n-        }\n-        int len = val.length >> coder;  \/\/ assume LATIN1=0\/UTF16=1;\n-        int en = scale(len, ce.maxBytesPerChar());\n-        byte[] ba = new byte[en];\n-        if (len == 0) {\n-            return ba;\n-        }\n-        ce.onMalformedInput(CodingErrorAction.REPLACE)\n-          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n-          .reset();\n-        if (ce instanceof ArrayEncoder) {\n-            int blen = (coder == LATIN1 ) ? ((ArrayEncoder)ce).encodeFromLatin1(val, 0, len, ba)\n-                                          : ((ArrayEncoder)ce).encodeFromUTF16(val, 0, len, ba);\n-            if (blen != -1) {\n-                return safeTrim(ba, blen, true);\n-            }\n-        }\n-        boolean isTrusted = cs.getClass().getClassLoader0() == null ||\n-                            System.getSecurityManager() == null;\n-        char[] ca = (coder == LATIN1 ) ? StringLatin1.toChars(val)\n-                                       : StringUTF16.toChars(val);\n-        ByteBuffer bb = ByteBuffer.wrap(ba);\n-        CharBuffer cb = CharBuffer.wrap(ca, 0, len);\n-        try {\n-            CoderResult cr = ce.encode(cb, bb, true);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-            cr = ce.flush(bb);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-        } catch (CharacterCodingException x) {\n-            throw new Error(x);\n-        }\n-        return safeTrim(ba, bb.position(), isTrusted);\n-    }\n-\n-    static byte[] encode(byte coder, byte[] val) {\n-        Charset cs = Charset.defaultCharset();\n-        if (cs == UTF_8) {\n-            return encodeUTF8(coder, val, true);\n-        }\n-        if (cs == ISO_8859_1) {\n-            return encode8859_1(coder, val);\n-        }\n-        if (cs == US_ASCII) {\n-            return encodeASCII(coder, val);\n-        }\n-        StringEncoder se = deref(encoder);\n-        if (se == null || !cs.name().equals(se.cs.name())) {\n-            se = new StringEncoder(cs, cs.name());\n-            set(encoder, se);\n-        }\n-        return se.encode(coder, val);\n-    }\n+    static final Charset ISO_8859_1 = sun.nio.cs.ISO_8859_1.INSTANCE;\n+    static final Charset US_ASCII = sun.nio.cs.US_ASCII.INSTANCE;\n+    static final Charset UTF_8 = sun.nio.cs.UTF_8.INSTANCE;\n@@ -525,57 +51,5 @@\n-     \/* The cached Result for each thread *\/\n-    private static final ThreadLocal<SoftReference<Result>>\n-        resultCached = new ThreadLocal<>() {\n-            protected SoftReference<Result> initialValue() {\n-                return new SoftReference<>(new Result());\n-            }};\n-    private static Result resultCached() {\n-        SoftReference<Result> sr = resultCached.get();\n-        Result r;\n-        if (sr == null || (r = sr.get()) == null) {\n-            r = new Result();\n-            resultCached.set(new SoftReference<>(r));\n-        }\n-        return r;\n-    }\n-\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ ascii \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-    private static Result decodeASCII(byte[] ba, int off, int len) {\n-        Result result = resultCached();\n-        if (COMPACT_STRINGS && !hasNegatives(ba, off, len)) {\n-            return result.with(Arrays.copyOfRange(ba, off, off + len),\n-                               LATIN1);\n-        }\n-        byte[] dst = new byte[len<<1];\n-        int dp = 0;\n-        while (dp < len) {\n-            int b = ba[off++];\n-            putChar(dst, dp++, (b >= 0) ? (char)b : repl);\n-        }\n-        return result.with(dst, UTF16);\n-    }\n-\n-    private static byte[] encodeASCII(byte coder, byte[] val) {\n-        if (coder == LATIN1) {\n-            byte[] dst = new byte[val.length];\n-            for (int i = 0; i < val.length; i++) {\n-                if (val[i] < 0) {\n-                    dst[i] = '?';\n-                } else {\n-                    dst[i] = val[i];\n-                }\n-            }\n-            return dst;\n-        }\n-        int len = val.length >> 1;\n-        byte[] dst = new byte[len];\n-        int dp = 0;\n-        for (int i = 0; i < len; i++) {\n-            char c = StringUTF16.getChar(val, i);\n-            if (c < 0x80) {\n-                dst[dp++] = (byte)c;\n-                continue;\n-            }\n-            if (Character.isHighSurrogate(c) && i + 1 < len &&\n-                Character.isLowSurrogate(StringUTF16.getChar(val, i + 1))) {\n-                i++;\n+    @IntrinsicCandidate\n+    public static boolean hasNegatives(byte[] ba, int off, int len) {\n+        for (int i = off; i < off + len; i++) {\n+            if (ba[i] < 0) {\n+                return true;\n@@ -583,4 +57,0 @@\n-            dst[dp++] = '?';\n-        }\n-        if (len == dp) {\n-            return dst;\n@@ -588,12 +58,1 @@\n-        return Arrays.copyOf(dst, dp);\n-    }\n-\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ latin1\/8859_1 \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-    private static Result decodeLatin1(byte[] ba, int off, int len) {\n-       Result result = resultCached();\n-       if (COMPACT_STRINGS) {\n-           return result.with(Arrays.copyOfRange(ba, off, off + len), LATIN1);\n-       } else {\n-           return result.with(StringLatin1.inflate(ba, off, len), UTF16);\n-       }\n+        return false;\n@@ -603,1 +62,1 @@\n-    private static int implEncodeISOArray(byte[] sa, int sp,\n+    public static int implEncodeISOArray(byte[] sa, int sp,\n@@ -615,536 +74,0 @@\n-    private static byte[] encode8859_1(byte coder, byte[] val) {\n-        return encode8859_1(coder, val, true);\n-    }\n-\n-    private static byte[] encode8859_1(byte coder, byte[] val, boolean doReplace) {\n-        if (coder == LATIN1) {\n-            return Arrays.copyOf(val, val.length);\n-        }\n-        int len = val.length >> 1;\n-        byte[] dst = new byte[len];\n-        int dp = 0;\n-        int sp = 0;\n-        int sl = len;\n-        while (sp < sl) {\n-            int ret = implEncodeISOArray(val, sp, dst, dp, len);\n-            sp = sp + ret;\n-            dp = dp + ret;\n-            if (ret != len) {\n-                if (!doReplace) {\n-                    throwUnmappable(sp, 1);\n-                }\n-                char c = StringUTF16.getChar(val, sp++);\n-                if (Character.isHighSurrogate(c) && sp < sl &&\n-                    Character.isLowSurrogate(StringUTF16.getChar(val, sp))) {\n-                    sp++;\n-                }\n-                dst[dp++] = '?';\n-                len = sl - sp;\n-            }\n-        }\n-        if (dp == dst.length) {\n-            return dst;\n-        }\n-        return Arrays.copyOf(dst, dp);\n-    }\n-\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ utf8 \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-    private static boolean isNotContinuation(int b) {\n-        return (b & 0xc0) != 0x80;\n-    }\n-\n-    private static boolean isMalformed3(int b1, int b2, int b3) {\n-        return (b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n-               (b2 & 0xc0) != 0x80 || (b3 & 0xc0) != 0x80;\n-    }\n-\n-    private static boolean isMalformed3_2(int b1, int b2) {\n-        return (b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n-               (b2 & 0xc0) != 0x80;\n-    }\n-\n-    private static boolean isMalformed4(int b2, int b3, int b4) {\n-        return (b2 & 0xc0) != 0x80 || (b3 & 0xc0) != 0x80 ||\n-               (b4 & 0xc0) != 0x80;\n-    }\n-\n-    private static boolean isMalformed4_2(int b1, int b2) {\n-        return (b1 == 0xf0 && (b2  < 0x90 || b2 > 0xbf)) ||\n-               (b1 == 0xf4 && (b2 & 0xf0) != 0x80) ||\n-               (b2 & 0xc0) != 0x80;\n-    }\n-\n-    private static boolean isMalformed4_3(int b3) {\n-        return (b3 & 0xc0) != 0x80;\n-    }\n-\n-    \/\/ for nb == 3\/4\n-    private static int malformedN(byte[] src, int sp, int nb) {\n-        if (nb == 3) {\n-            int b1 = src[sp++];\n-            int b2 = src[sp++];    \/\/ no need to lookup b3\n-            return ((b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n-                    isNotContinuation(b2)) ? 1 : 2;\n-        } else if (nb == 4) { \/\/ we don't care the speed here\n-            int b1 = src[sp++] & 0xff;\n-            int b2 = src[sp++] & 0xff;\n-            if (b1 > 0xf4 ||\n-                (b1 == 0xf0 && (b2 < 0x90 || b2 > 0xbf)) ||\n-                (b1 == 0xf4 && (b2 & 0xf0) != 0x80) ||\n-                isNotContinuation(b2))\n-                return 1;\n-            if (isNotContinuation(src[sp++]))\n-                return 2;\n-            return 3;\n-        }\n-        assert false;\n-        return -1;\n-    }\n-\n-    private static void throwMalformed(int off, int nb) {\n-        String msg = \"malformed input off : \" + off + \", length : \" + nb;\n-        throw new IllegalArgumentException(msg, new MalformedInputException(nb));\n-    }\n-\n-    private static void throwMalformed(byte[] val) {\n-        int dp = 0;\n-        while (dp < val.length && val[dp] >=0) { dp++; }\n-        throwMalformed(dp, 1);\n-    }\n-\n-    private static void throwUnmappable(int off, int nb) {\n-        String msg = \"malformed input off : \" + off + \", length : \" + nb;\n-        throw new IllegalArgumentException(msg, new UnmappableCharacterException(nb));\n-    }\n-\n-    private static void throwUnmappable(byte[] val) {\n-        int dp = 0;\n-        while (dp < val.length && val[dp] >=0) { dp++; }\n-        throwUnmappable(dp, 1);\n-    }\n-\n-    private static char repl = '\\ufffd';\n-\n-    private static Result decodeUTF8(byte[] src, int sp, int len, boolean doReplace) {\n-        \/\/ ascii-bais, which has a relative impact to the non-ascii-only bytes\n-        if (COMPACT_STRINGS && !hasNegatives(src, sp, len))\n-            return resultCached().with(Arrays.copyOfRange(src, sp, sp + len),\n-                                           LATIN1);\n-        return decodeUTF8_0(src, sp, len, doReplace);\n-    }\n-\n-    private static Result decodeUTF8_0(byte[] src, int sp, int len, boolean doReplace) {\n-        Result ret = resultCached();\n-\n-        int sl = sp + len;\n-        int dp = 0;\n-        byte[] dst = new byte[len];\n-\n-        if (COMPACT_STRINGS) {\n-            while (sp < sl) {\n-                int b1 = src[sp];\n-                if (b1 >= 0) {\n-                    dst[dp++] = (byte)b1;\n-                    sp++;\n-                    continue;\n-                }\n-                if ((b1 == (byte)0xc2 || b1 == (byte)0xc3) &&\n-                    sp + 1 < sl) {\n-                    int b2 = src[sp + 1];\n-                    if (!isNotContinuation(b2)) {\n-                        dst[dp++] = (byte)(((b1 << 6) ^ b2)^\n-                                           (((byte) 0xC0 << 6) ^\n-                                           ((byte) 0x80 << 0)));\n-                        sp += 2;\n-                        continue;\n-                    }\n-                }\n-                \/\/ anything not a latin1, including the repl\n-                \/\/ we have to go with the utf16\n-                break;\n-            }\n-            if (sp == sl) {\n-                if (dp != dst.length) {\n-                    dst = Arrays.copyOf(dst, dp);\n-                }\n-                return ret.with(dst, LATIN1);\n-            }\n-        }\n-        if (dp == 0) {\n-            dst = new byte[len << 1];\n-        } else {\n-            byte[] buf = new byte[len << 1];\n-            StringLatin1.inflate(dst, 0, buf, 0, dp);\n-            dst = buf;\n-        }\n-        while (sp < sl) {\n-            int b1 = src[sp++];\n-            if (b1 >= 0) {\n-                putChar(dst, dp++, (char) b1);\n-            } else if ((b1 >> 5) == -2 && (b1 & 0x1e) != 0) {\n-                if (sp < sl) {\n-                    int b2 = src[sp++];\n-                    if (isNotContinuation(b2)) {\n-                        if (!doReplace) {\n-                            throwMalformed(sp - 1, 1);\n-                        }\n-                        putChar(dst, dp++, repl);\n-                        sp--;\n-                    } else {\n-                        putChar(dst, dp++, (char)(((b1 << 6) ^ b2)^\n-                                                  (((byte) 0xC0 << 6) ^\n-                                                  ((byte) 0x80 << 0))));\n-                    }\n-                    continue;\n-                }\n-                if (!doReplace) {\n-                    throwMalformed(sp, 1);  \/\/ underflow()\n-                }\n-                putChar(dst, dp++, repl);\n-                break;\n-            } else if ((b1 >> 4) == -2) {\n-                if (sp + 1 < sl) {\n-                    int b2 = src[sp++];\n-                    int b3 = src[sp++];\n-                    if (isMalformed3(b1, b2, b3)) {\n-                        if (!doReplace) {\n-                            throwMalformed(sp - 3, 3);\n-                        }\n-                        putChar(dst, dp++, repl);\n-                        sp -= 3;\n-                        sp += malformedN(src, sp, 3);\n-                    } else {\n-                        char c = (char)((b1 << 12) ^\n-                                        (b2 <<  6) ^\n-                                        (b3 ^\n-                                         (((byte) 0xE0 << 12) ^\n-                                         ((byte) 0x80 <<  6) ^\n-                                         ((byte) 0x80 <<  0))));\n-                        if (isSurrogate(c)) {\n-                            if (!doReplace) {\n-                                throwMalformed(sp - 3, 3);\n-                            }\n-                            putChar(dst, dp++, repl);\n-                        } else {\n-                            putChar(dst, dp++, c);\n-                        }\n-                    }\n-                    continue;\n-                }\n-                if (sp  < sl && isMalformed3_2(b1, src[sp])) {\n-                    if (!doReplace) {\n-                        throwMalformed(sp - 1, 2);\n-                    }\n-                    putChar(dst, dp++, repl);\n-                    continue;\n-                }\n-                if (!doReplace){\n-                    throwMalformed(sp, 1);\n-                }\n-                putChar(dst, dp++, repl);\n-                break;\n-            } else if ((b1 >> 3) == -2) {\n-                if (sp + 2 < sl) {\n-                    int b2 = src[sp++];\n-                    int b3 = src[sp++];\n-                    int b4 = src[sp++];\n-                    int uc = ((b1 << 18) ^\n-                              (b2 << 12) ^\n-                              (b3 <<  6) ^\n-                              (b4 ^\n-                               (((byte) 0xF0 << 18) ^\n-                               ((byte) 0x80 << 12) ^\n-                               ((byte) 0x80 <<  6) ^\n-                               ((byte) 0x80 <<  0))));\n-                    if (isMalformed4(b2, b3, b4) ||\n-                        !isSupplementaryCodePoint(uc)) { \/\/ shortest form check\n-                        if (!doReplace) {\n-                            throwMalformed(sp - 4, 4);\n-                        }\n-                        putChar(dst, dp++, repl);\n-                        sp -= 4;\n-                        sp += malformedN(src, sp, 4);\n-                    } else {\n-                        putChar(dst, dp++, highSurrogate(uc));\n-                        putChar(dst, dp++, lowSurrogate(uc));\n-                    }\n-                    continue;\n-                }\n-                b1 &= 0xff;\n-                if (b1 > 0xf4 ||\n-                    sp  < sl && isMalformed4_2(b1, src[sp] & 0xff)) {\n-                    if (!doReplace) {\n-                        throwMalformed(sp - 1, 1);  \/\/ or 2\n-                    }\n-                    putChar(dst, dp++, repl);\n-                    continue;\n-                }\n-                if (!doReplace) {\n-                    throwMalformed(sp - 1, 1);\n-                }\n-                sp++;\n-                putChar(dst, dp++, repl);\n-                if (sp  < sl && isMalformed4_3(src[sp])) {\n-                    continue;\n-                }\n-                break;\n-            } else {\n-                if (!doReplace) {\n-                    throwMalformed(sp - 1, 1);\n-                }\n-                putChar(dst, dp++, repl);\n-            }\n-        }\n-        if (dp != len) {\n-            dst = Arrays.copyOf(dst, dp << 1);\n-        }\n-        return ret.with(dst, UTF16);\n-    }\n-\n-    private static byte[] encodeUTF8(byte coder, byte[] val, boolean doReplace) {\n-        if (coder == UTF16)\n-            return encodeUTF8_UTF16(val, doReplace);\n-\n-        if (!hasNegatives(val, 0, val.length))\n-            return Arrays.copyOf(val, val.length);\n-\n-        int dp = 0;\n-        byte[] dst = new byte[val.length << 1];\n-        for (int sp = 0; sp < val.length; sp++) {\n-            byte c = val[sp];\n-            if (c < 0) {\n-                dst[dp++] = (byte)(0xc0 | ((c & 0xff) >> 6));\n-                dst[dp++] = (byte)(0x80 | (c & 0x3f));\n-            } else {\n-                dst[dp++] = c;\n-            }\n-        }\n-        if (dp == dst.length)\n-            return dst;\n-        return Arrays.copyOf(dst, dp);\n-    }\n-\n-    private static byte[] encodeUTF8_UTF16(byte[] val, boolean doReplace) {\n-        int dp = 0;\n-        int sp = 0;\n-        int sl = val.length >> 1;\n-        byte[] dst = new byte[sl * 3];\n-        char c;\n-        while (sp < sl && (c = StringUTF16.getChar(val, sp)) < '\\u0080') {\n-            \/\/ ascii fast loop;\n-            dst[dp++] = (byte)c;\n-            sp++;\n-        }\n-        while (sp < sl) {\n-            c = StringUTF16.getChar(val, sp++);\n-            if (c < 0x80) {\n-                dst[dp++] = (byte)c;\n-            } else if (c < 0x800) {\n-                dst[dp++] = (byte)(0xc0 | (c >> 6));\n-                dst[dp++] = (byte)(0x80 | (c & 0x3f));\n-            } else if (Character.isSurrogate(c)) {\n-                int uc = -1;\n-                char c2;\n-                if (Character.isHighSurrogate(c) && sp < sl &&\n-                    Character.isLowSurrogate(c2 = StringUTF16.getChar(val, sp))) {\n-                    uc = Character.toCodePoint(c, c2);\n-                }\n-                if (uc < 0) {\n-                    if (doReplace) {\n-                        dst[dp++] = '?';\n-                    } else {\n-                        throwUnmappable(sp - 1, 1); \/\/ or 2, does not matter here\n-                    }\n-                } else {\n-                    dst[dp++] = (byte)(0xf0 | ((uc >> 18)));\n-                    dst[dp++] = (byte)(0x80 | ((uc >> 12) & 0x3f));\n-                    dst[dp++] = (byte)(0x80 | ((uc >>  6) & 0x3f));\n-                    dst[dp++] = (byte)(0x80 | (uc & 0x3f));\n-                    sp++;  \/\/ 2 chars\n-                }\n-            } else {\n-                \/\/ 3 bytes, 16 bits\n-                dst[dp++] = (byte)(0xe0 | ((c >> 12)));\n-                dst[dp++] = (byte)(0x80 | ((c >>  6) & 0x3f));\n-                dst[dp++] = (byte)(0x80 | (c & 0x3f));\n-            }\n-        }\n-        if (dp == dst.length) {\n-            return dst;\n-        }\n-        return Arrays.copyOf(dst, dp);\n-    }\n-\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ for j.u.z.ZipCoder \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-    \/*\n-     * Throws iae, instead of replacing, if malformed or unmappable.\n-     *\/\n-    static String newStringUTF8NoRepl(byte[] src, int off, int len) {\n-        if (COMPACT_STRINGS && !hasNegatives(src, off, len))\n-            return new String(Arrays.copyOfRange(src, off, off + len), LATIN1);\n-        Result ret = decodeUTF8_0(src, off, len, false);\n-        return new String(ret.value, ret.coder);\n-    }\n-\n-    \/*\n-     * Throws iae, instead of replacing, if unmappable.\n-     *\/\n-    static byte[] getBytesUTF8NoRepl(String s) {\n-        return encodeUTF8(s.coder(), s.value(), false);\n-    }\n-\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ for j.n.f.Files \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-    private static boolean isASCII(byte[] src) {\n-        return !hasNegatives(src, 0, src.length);\n-    }\n-\n-    private static String newStringLatin1(byte[] src) {\n-        if (COMPACT_STRINGS)\n-           return new String(src, LATIN1);\n-        return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n-    }\n-\n-    static String newStringNoRepl(byte[] src, Charset cs) throws CharacterCodingException {\n-        try {\n-            return newStringNoRepl1(src, cs);\n-        } catch (IllegalArgumentException e) {\n-            \/\/newStringNoRepl1 throws IAE with MalformedInputException or CCE as the cause\n-            Throwable cause = e.getCause();\n-            if (cause instanceof MalformedInputException) {\n-                throw (MalformedInputException)cause;\n-            }\n-            throw (CharacterCodingException)cause;\n-        }\n-    }\n-\n-    static String newStringNoRepl1(byte[] src, Charset cs) {\n-        if (cs == UTF_8) {\n-            if (COMPACT_STRINGS && isASCII(src))\n-                return new String(src, LATIN1);\n-            Result ret = decodeUTF8_0(src, 0, src.length, false);\n-            return new String(ret.value, ret.coder);\n-        }\n-        if (cs == ISO_8859_1) {\n-            return newStringLatin1(src);\n-        }\n-        if (cs == US_ASCII) {\n-            if (isASCII(src)) {\n-                return newStringLatin1(src);\n-            } else {\n-                throwMalformed(src);\n-            }\n-        }\n-\n-        CharsetDecoder cd = cs.newDecoder();\n-        \/\/ ascii fastpath\n-        if ((cd instanceof ArrayDecoder) &&\n-            ((ArrayDecoder)cd).isASCIICompatible() && isASCII(src)) {\n-            return newStringLatin1(src);\n-        }\n-        int len = src.length;\n-        if (len == 0) {\n-            return \"\";\n-        }\n-        int en = scale(len, cd.maxCharsPerByte());\n-        char[] ca = new char[en];\n-        if (cs.getClass().getClassLoader0() != null &&\n-            System.getSecurityManager() != null) {\n-            src = Arrays.copyOf(src, len);\n-        }\n-        ByteBuffer bb = ByteBuffer.wrap(src);\n-        CharBuffer cb = CharBuffer.wrap(ca);\n-        try {\n-            CoderResult cr = cd.decode(bb, cb, true);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-            cr = cd.flush(cb);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-        } catch (CharacterCodingException x) {\n-            throw new IllegalArgumentException(x);  \/\/ todo\n-        }\n-        Result ret = resultCached().with(ca, 0, cb.position());\n-        return new String(ret.value, ret.coder);\n-    }\n-\n-    \/*\n-     * Throws CCE, instead of replacing, if unmappable.\n-     *\/\n-    static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n-        try {\n-            return getBytesNoRepl1(s, cs);\n-        } catch (IllegalArgumentException e) {\n-            \/\/getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause\n-            Throwable cause = e.getCause();\n-            if (cause instanceof UnmappableCharacterException) {\n-                throw (UnmappableCharacterException)cause;\n-            }\n-            throw (CharacterCodingException)cause;\n-        }\n-    }\n-\n-    static byte[] getBytesNoRepl1(String s, Charset cs) {\n-        byte[] val = s.value();\n-        byte coder = s.coder();\n-        if (cs == UTF_8) {\n-            if (coder == LATIN1 && isASCII(val)) {\n-                return val;\n-            }\n-            return encodeUTF8(coder, val, false);\n-        }\n-        if (cs == ISO_8859_1) {\n-            if (coder == LATIN1) {\n-                return val;\n-            }\n-            return encode8859_1(coder, val, false);\n-        }\n-        if (cs == US_ASCII) {\n-            if (coder == LATIN1) {\n-                if (isASCII(val)) {\n-                    return val;\n-                } else {\n-                    throwUnmappable(val);\n-                }\n-            }\n-        }\n-        CharsetEncoder ce = cs.newEncoder();\n-        \/\/ fastpath for ascii compatible\n-        if (coder == LATIN1 && (((ce instanceof ArrayEncoder) &&\n-                                 ((ArrayEncoder)ce).isASCIICompatible() &&\n-                                 isASCII(val)))) {\n-            return val;\n-        }\n-        int len = val.length >> coder;  \/\/ assume LATIN1=0\/UTF16=1;\n-        int en = scale(len, ce.maxBytesPerChar());\n-        byte[] ba = new byte[en];\n-        if (len == 0) {\n-            return ba;\n-        }\n-        if (ce instanceof ArrayEncoder) {\n-            int blen = (coder == LATIN1 ) ? ((ArrayEncoder)ce).encodeFromLatin1(val, 0, len, ba)\n-                                          : ((ArrayEncoder)ce).encodeFromUTF16(val, 0, len, ba);\n-            if (blen != -1) {\n-                return safeTrim(ba, blen, true);\n-            }\n-        }\n-        boolean isTrusted = cs.getClass().getClassLoader0() == null ||\n-                            System.getSecurityManager() == null;\n-        char[] ca = (coder == LATIN1 ) ? StringLatin1.toChars(val)\n-                                       : StringUTF16.toChars(val);\n-        ByteBuffer bb = ByteBuffer.wrap(ba);\n-        CharBuffer cb = CharBuffer.wrap(ca, 0, len);\n-        try {\n-            CoderResult cr = ce.encode(cb, bb, true);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-            cr = ce.flush(bb);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-        } catch (CharacterCodingException x) {\n-            throw new IllegalArgumentException(x);\n-        }\n-        return safeTrim(ba, bb.position(), isTrusted);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringCoding.java","additions":11,"deletions":1088,"binary":false,"changes":1099,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -2265,1 +2265,1 @@\n-                return StringCoding.newStringNoRepl(bytes, cs);\n+                return String.newStringNoRepl(bytes, cs);\n@@ -2269,1 +2269,1 @@\n-                return StringCoding.getBytesNoRepl(s, cs);\n+                return String.getBytesNoRepl(s, cs);\n@@ -2273,1 +2273,1 @@\n-                return StringCoding.newStringUTF8NoRepl(bytes, off, len);\n+                return String.newStringUTF8NoRepl(bytes, off, len);\n@@ -2277,1 +2277,1 @@\n-                return StringCoding.getBytesUTF8NoRepl(s);\n+                return String.getBytesUTF8NoRepl(s);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.nio.charset.Charset;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = \"-Xmx1g\")\n+@Warmup(iterations = 5, time = 2)\n+@Measurement(iterations = 5, time = 3)\n+@State(Scope.Thread)\n+public class StringDecode {\n+\n+    @BenchmarkMode(Mode.AverageTime)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    @Fork(value = 3, jvmArgs = \"-Xmx1g\")\n+    @Warmup(iterations = 5, time = 2)\n+    @Measurement(iterations = 5, time = 2)\n+    @State(Scope.Thread)\n+    public static class WithCharset {\n+\n+        @Param({\"US-ASCII\", \"ISO-8859-1\", \"UTF-8\", \"MS932\", \"ISO-8859-6\"})\n+        private String charsetName;\n+\n+        private Charset charset;\n+        private byte[] asciiString;\n+        private byte[] utf16String;\n+\n+        @Setup\n+        public void setup() {\n+            charset = Charset.forName(charsetName);\n+            asciiString = \"ascii string\".getBytes(charset);\n+            utf16String = \"UTF-\\uFF11\\uFF16 string\".getBytes(charset);\n+        }\n+\n+        @Benchmark\n+        public void decodeCharsetName(Blackhole bh) throws Exception {\n+            bh.consume(new String(asciiString, charsetName));\n+            bh.consume(new String(utf16String, charsetName));\n+        }\n+\n+        @Benchmark\n+        public void decodeCharset(Blackhole bh) throws Exception {\n+            bh.consume(new String(asciiString, charset));\n+            bh.consume(new String(utf16String, charset));\n+        }\n+    }\n+\n+    private byte[] asciiDefaultString;\n+    private byte[] utf16DefaultString;\n+\n+    @Setup\n+    public void setup() {\n+        asciiDefaultString = \"ascii string\".getBytes();\n+        utf16DefaultString = \"UTF-\\uFF11\\uFF16 string\".getBytes();\n+    }\n+\n+    @Benchmark\n+    public void decodeDefault(Blackhole bh) throws Exception {\n+        bh.consume(new String(asciiDefaultString));\n+        bh.consume(new String(utf16DefaultString));\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringDecode.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.nio.charset.Charset;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = \"-Xmx1g\")\n+@Warmup(iterations = 5, time = 2)\n+@Measurement(iterations = 5, time = 3)\n+@State(Scope.Thread)\n+public class StringEncode {\n+\n+    @BenchmarkMode(Mode.AverageTime)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    @Fork(value = 3, jvmArgs = \"-Xmx1g\")\n+    @Warmup(iterations = 5, time = 2)\n+    @Measurement(iterations = 5, time = 2)\n+    @State(Scope.Thread)\n+    public static class WithCharset {\n+\n+        @Param({\"US-ASCII\", \"ISO-8859-1\", \"UTF-8\", \"MS932\", \"ISO-8859-6\"})\n+        private String charsetName;\n+\n+        private Charset charset;\n+        private String asciiString;\n+        private String utf16String;\n+\n+        @Setup\n+        public void setup() {\n+            charset = Charset.forName(charsetName);\n+            asciiString = \"ascii string\";\n+            utf16String = \"UTF-\\uFF11\\uFF16 string\";\n+        }\n+\n+        @Benchmark\n+        public void encodeCharsetName(Blackhole bh) throws Exception {\n+            bh.consume(asciiString.getBytes(charsetName));\n+            bh.consume(utf16String.getBytes(charsetName));\n+        }\n+\n+        @Benchmark\n+        public void encodeCharset(Blackhole bh) throws Exception {\n+            bh.consume(asciiString.getBytes(charset));\n+            bh.consume(utf16String.getBytes(charset));\n+        }\n+    }\n+\n+    private String asciiDefaultString;\n+    private String utf16DefaultString;\n+\n+    @Setup\n+    public void setup() {\n+        asciiDefaultString = \"ascii string\";\n+        utf16DefaultString = \"UTF-\\uFF11\\uFF16 string\";\n+    }\n+\n+    @Benchmark\n+    public void encodeDefault(Blackhole bh) throws Exception {\n+        bh.consume(asciiDefaultString.getBytes());\n+        bh.consume(utf16DefaultString.getBytes());\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringEncode.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"}]}