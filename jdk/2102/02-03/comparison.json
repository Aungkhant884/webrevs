{"files":[{"patch":"@@ -686,1 +686,1 @@\n-            int caLen = decode(cd, ca, bytes, offset, length);\n+            int caLen = StringCoding.decodeWithDecoder(cd, ca, bytes, offset, length);\n@@ -700,20 +700,0 @@\n-    private static int decode(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length) {\n-        ByteBuffer bb = ByteBuffer.wrap(src, offset, length);\n-        CharBuffer cb = CharBuffer.wrap(dst, 0, dst.length);\n-        try {\n-            CoderResult cr = cd.decode(bb, cb, true);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-            cr = cd.flush(cb);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-        } catch (CharacterCodingException x) {\n-            \/\/ Substitution is always enabled,\n-            \/\/ so this shouldn't happen\n-            throw new Error(x);\n-        }\n-        return cb.position();\n-    }\n-\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ for j.u.z.ZipCoder \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n@@ -723,2 +703,45 @@\n-    static String newStringUTF8NoRepl(byte[] src, int off, int len) {\n-        return new String(src, off, len, (Void)null);\n+    static String newStringUTF8NoRepl(byte[] bytes, int offset, int length) {\n+        checkBoundsOffCount(offset, length, bytes.length);\n+        int sl = offset + length;\n+        int dp = 0;\n+        byte[] dst = new byte[length];\n+        if (COMPACT_STRINGS) {\n+            while (offset < sl) {\n+                int b1 = bytes[offset];\n+                if (b1 >= 0) {\n+                    dst[dp++] = (byte)b1;\n+                    offset++;\n+                    continue;\n+                }\n+                if ((b1 == (byte)0xc2 || b1 == (byte)0xc3) &&\n+                        offset + 1 < sl) {\n+                    int b2 = bytes[offset + 1];\n+                    if (!StringCoding.isNotContinuation(b2)) {\n+                        dst[dp++] = (byte)StringCoding.decode2(b1, b2);\n+                        offset += 2;\n+                        continue;\n+                    }\n+                }\n+                \/\/ anything not a latin1, including the REPL\n+                \/\/ we have to go with the utf16\n+                break;\n+            }\n+            if (offset == sl) {\n+                if (dp != dst.length) {\n+                    dst = Arrays.copyOf(dst, dp);\n+                }\n+                return new String(dst, LATIN1);\n+            }\n+        }\n+        if (dp == 0) {\n+            dst = new byte[length << 1];\n+        } else {\n+            byte[] buf = new byte[length << 1];\n+            StringLatin1.inflate(dst, 0, buf, 0, dp);\n+            dst = buf;\n+        }\n+        dp = StringCoding.decodeUTF8_UTF16(bytes, offset, sl, dst, dp, false);\n+        if (dp != length) {\n+            dst = Arrays.copyOf(dst, dp << 1);\n+        }\n+        return new String(dst, UTF16);\n@@ -775,12 +798,1 @@\n-        ByteBuffer bb = ByteBuffer.wrap(src);\n-        CharBuffer cb = CharBuffer.wrap(ca);\n-        try {\n-            CoderResult cr = cd.decode(bb, cb, true);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-            cr = cd.flush(cb);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-        } catch (CharacterCodingException x) {\n-            throw new IllegalArgumentException(x);\n-        }\n+        int caLen = StringCoding.decodeWithDecoder(cd, ca, src, 0, src.length);\n@@ -788,1 +800,1 @@\n-            byte[] bs = StringUTF16.compress(ca, 0, cb.position());\n+            byte[] bs = StringUTF16.compress(ca, 0, caLen);\n@@ -793,55 +805,1 @@\n-        return new String(StringUTF16.toBytes(ca, 0, cb.position()), UTF16);\n-    }\n-\n-    \/*\n-     * Private constructor for doing UTF-8 decode, but throwing iae on malformed or\n-     * unmappable characters\n-     *\/\n-    private String(byte[] bytes, int offset, int length, Void throwOnError) {\n-        checkBoundsOffCount(offset, length, bytes.length);\n-        int sl = offset + length;\n-        int dp = 0;\n-        byte[] dst = new byte[length];\n-        if (COMPACT_STRINGS) {\n-            while (offset < sl) {\n-                int b1 = bytes[offset];\n-                if (b1 >= 0) {\n-                    dst[dp++] = (byte)b1;\n-                    offset++;\n-                    continue;\n-                }\n-                if ((b1 == (byte)0xc2 || b1 == (byte)0xc3) &&\n-                        offset + 1 < sl) {\n-                    int b2 = bytes[offset + 1];\n-                    if (!StringCoding.isNotContinuation(b2)) {\n-                        dst[dp++] = (byte)StringCoding.decode2(b1, b2);\n-                        offset += 2;\n-                        continue;\n-                    }\n-                }\n-                \/\/ anything not a latin1, including the REPL\n-                \/\/ we have to go with the utf16\n-                break;\n-            }\n-            if (offset == sl) {\n-                if (dp != dst.length) {\n-                    dst = Arrays.copyOf(dst, dp);\n-                }\n-                this.value = dst;\n-                this.coder = LATIN1;\n-                return;\n-            }\n-        }\n-        if (dp == 0) {\n-            dst = new byte[length << 1];\n-        } else {\n-            byte[] buf = new byte[length << 1];\n-            StringLatin1.inflate(dst, 0, buf, 0, dp);\n-            dst = buf;\n-        }\n-        dp = StringCoding.decodeUTF8_UTF16(bytes, offset, sl, dst, dp, false);\n-        if (dp != length) {\n-            dst = Arrays.copyOf(dst, dp << 1);\n-        }\n-        this.value = dst;\n-        this.coder = UTF16;\n+        return new String(StringUTF16.toBytes(ca, 0, caLen), UTF16);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":49,"deletions":91,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.nio.charset.CharsetDecoder;\n@@ -539,0 +540,18 @@\n+    static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length) {\n+        ByteBuffer bb = ByteBuffer.wrap(src, offset, length);\n+        CharBuffer cb = CharBuffer.wrap(dst, 0, dst.length);\n+        try {\n+            CoderResult cr = cd.decode(bb, cb, true);\n+            if (!cr.isUnderflow())\n+                cr.throwException();\n+            cr = cd.flush(cb);\n+            if (!cr.isUnderflow())\n+                cr.throwException();\n+        } catch (CharacterCodingException x) {\n+            \/\/ Substitution is always enabled,\n+            \/\/ so this shouldn't happen\n+            throw new Error(x);\n+        }\n+        return cb.position();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringCoding.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"}]}