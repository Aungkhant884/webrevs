{"files":[{"patch":"@@ -57,0 +57,1 @@\n+import sun.nio.cs.ArrayEncoder;\n@@ -61,1 +62,0 @@\n-import static java.util.function.Predicate.not;\n@@ -486,1 +486,1 @@\n-        this(bytes, offset, length, StringCoding.lookupCharset(charsetName));\n+        this(bytes, offset, length, lookupCharset(charsetName));\n@@ -525,3 +525,1 @@\n-            return;\n-        }\n-        if (charset == UTF_8) {\n+        } else if (charset == UTF_8) {\n@@ -531,1 +529,0 @@\n-                return;\n@@ -548,2 +545,2 @@\n-                            if (!StringCoding.isNotContinuation(b2)) {\n-                                dst[dp++] = (byte)StringCoding.decode2(b1, b2);\n+                            if (!isNotContinuation(b2)) {\n+                                dst[dp++] = (byte)decode2(b1, b2);\n@@ -574,1 +571,1 @@\n-                dp = StringCoding.decodeUTF8_UTF16(bytes, offset, sl, dst, dp, true);\n+                dp = decodeUTF8_UTF16(bytes, offset, sl, dst, dp, true);\n@@ -598,1 +595,1 @@\n-                    StringUTF16.putChar(dst, dp++, (b >= 0) ? (char) b : StringCoding.REPL);\n+                    StringUTF16.putChar(dst, dp++, (b >= 0) ? (char) b : REPL);\n@@ -636,1 +633,1 @@\n-                int en = StringCoding.scale(length, cd.maxCharsPerByte());\n+                int en = scale(length, cd.maxCharsPerByte());\n@@ -655,1 +652,1 @@\n-            int en = StringCoding.scale(length, cd.maxCharsPerByte());\n+            int en = scale(length, cd.maxCharsPerByte());\n@@ -665,1 +662,1 @@\n-            int caLen = StringCoding.decodeWithDecoder(cd, ca, bytes, offset, length);\n+            int caLen = decodeWithDecoder(cd, ca, bytes, offset, length);\n@@ -705,2 +702,2 @@\n-                        if (!StringCoding.isNotContinuation(b2)) {\n-                            dst[dp++] = (byte) StringCoding.decode2(b1, b2);\n+                        if (!isNotContinuation(b2)) {\n+                            dst[dp++] = (byte) decode2(b1, b2);\n@@ -729,1 +726,1 @@\n-            dp = StringCoding.decodeUTF8_UTF16(bytes, offset, sl, dst, dp, false);\n+            dp = decodeUTF8_UTF16(bytes, offset, sl, dst, dp, false);\n@@ -769,1 +766,1 @@\n-                StringCoding.throwMalformed(src);\n+                throwMalformed(src);\n@@ -776,1 +773,2 @@\n-                ad.isASCIICompatible() && !StringCoding.hasNegatives(src, 0, src.length)) {\n+                ad.isASCIICompatible() &&\n+                !StringCoding.hasNegatives(src, 0, src.length)) {\n@@ -779,1 +777,1 @@\n-        int en = StringCoding.scale(len, cd.maxCharsPerByte());\n+        int en = scale(len, cd.maxCharsPerByte());\n@@ -785,1 +783,1 @@\n-        int caLen = StringCoding.decodeWithDecoder(cd, ca, src, 0, src.length);\n+        int caLen = decodeWithDecoder(cd, ca, src, 0, src.length);\n@@ -795,0 +793,549 @@\n+    private static final char REPL = '\\ufffd';\n+\n+    \/\/ Trim the given byte array to the given length\n+    private static byte[] safeTrim(byte[] ba, int len, boolean isTrusted) {\n+        if (len == ba.length && (isTrusted || System.getSecurityManager() == null)) {\n+            return ba;\n+        } else {\n+            return Arrays.copyOf(ba, len);\n+        }\n+    }\n+\n+    private static int scale(int len, float expansionFactor) {\n+        \/\/ We need to perform double, not float, arithmetic; otherwise\n+        \/\/ we lose low order bits when len is larger than 2**24.\n+        return (int)(len * (double)expansionFactor);\n+    }\n+\n+    private static Charset lookupCharset(String csn) throws UnsupportedEncodingException {\n+        Objects.requireNonNull(csn);\n+        try {\n+            return Charset.forName(csn);\n+        } catch (UnsupportedCharsetException | IllegalCharsetNameException x) {\n+            throw new UnsupportedEncodingException(csn);\n+        }\n+    }\n+\n+    private static byte[] encode(String csn, byte coder, byte[] val)\n+            throws UnsupportedEncodingException\n+    {\n+        return encode(lookupCharset(csn), coder, val);\n+    }\n+\n+    private static byte[] encode(Charset cs, byte coder, byte[] val) {\n+        if (val.length == 0) {\n+            return \"\".value();\n+        }\n+        if (cs == UTF_8) {\n+            return encodeUTF8(coder, val, true);\n+        }\n+        if (cs == ISO_8859_1) {\n+            return encode8859_1(coder, val);\n+        }\n+        if (cs == US_ASCII) {\n+            return encodeASCII(coder, val);\n+        }\n+        CharsetEncoder ce = cs.newEncoder();\n+        int len = val.length >> coder;  \/\/ assume LATIN1=0\/UTF16=1;\n+        int en = scale(len, ce.maxBytesPerChar());\n+        if (ce instanceof ArrayEncoder ae) {\n+            \/\/ fastpath for ascii compatible\n+            if (coder == LATIN1 &&\n+                    ae.isASCIICompatible() &&\n+                    !StringCoding.hasNegatives(val, 0, val.length)) {\n+                return Arrays.copyOf(val, val.length);\n+            }\n+            byte[] ba = new byte[en];\n+            ce.onMalformedInput(CodingErrorAction.REPLACE)\n+                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+\n+            int blen = (coder == LATIN1) ? ae.encodeFromLatin1(val, 0, len, ba)\n+                    : ae.encodeFromUTF16(val, 0, len, ba);\n+            if (blen != -1) {\n+                return safeTrim(ba, blen, true);\n+            }\n+        }\n+\n+        byte[] ba = new byte[en];\n+        ce.onMalformedInput(CodingErrorAction.REPLACE)\n+                .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+        char[] ca = (coder == LATIN1 ) ? StringLatin1.toChars(val)\n+                : StringUTF16.toChars(val);\n+        ByteBuffer bb = ByteBuffer.wrap(ba);\n+        CharBuffer cb = CharBuffer.wrap(ca, 0, len);\n+        try {\n+            CoderResult cr = ce.encode(cb, bb, true);\n+            if (!cr.isUnderflow())\n+                cr.throwException();\n+            cr = ce.flush(bb);\n+            if (!cr.isUnderflow())\n+                cr.throwException();\n+        } catch (CharacterCodingException x) {\n+            throw new Error(x);\n+        }\n+        return safeTrim(ba, bb.position(), cs.getClass().getClassLoader0() == null);\n+    }\n+\n+    private static byte[] encode(byte coder, byte[] val) {\n+        return encode(Charset.defaultCharset(), coder, val);\n+    }\n+\n+    private static byte[] encodeASCII(byte coder, byte[] val) {\n+        if (coder == LATIN1) {\n+            byte[] dst = new byte[val.length];\n+            for (int i = 0; i < val.length; i++) {\n+                if (val[i] < 0) {\n+                    dst[i] = '?';\n+                } else {\n+                    dst[i] = val[i];\n+                }\n+            }\n+            return dst;\n+        }\n+        int len = val.length >> 1;\n+        byte[] dst = new byte[len];\n+        int dp = 0;\n+        for (int i = 0; i < len; i++) {\n+            char c = StringUTF16.getChar(val, i);\n+            if (c < 0x80) {\n+                dst[dp++] = (byte)c;\n+                continue;\n+            }\n+            if (Character.isHighSurrogate(c) && i + 1 < len &&\n+                    Character.isLowSurrogate(StringUTF16.getChar(val, i + 1))) {\n+                i++;\n+            }\n+            dst[dp++] = '?';\n+        }\n+        if (len == dp) {\n+            return dst;\n+        }\n+        return Arrays.copyOf(dst, dp);\n+    }\n+\n+    private static byte[] encode8859_1(byte coder, byte[] val) {\n+        return encode8859_1(coder, val, true);\n+    }\n+\n+    private static byte[] encode8859_1(byte coder, byte[] val, boolean doReplace) {\n+        if (coder == LATIN1) {\n+            return Arrays.copyOf(val, val.length);\n+        }\n+        int len = val.length >> 1;\n+        byte[] dst = new byte[len];\n+        int dp = 0;\n+        int sp = 0;\n+        int sl = len;\n+        while (sp < sl) {\n+            int ret = StringCoding.implEncodeISOArray(val, sp, dst, dp, len);\n+            sp = sp + ret;\n+            dp = dp + ret;\n+            if (ret != len) {\n+                if (!doReplace) {\n+                    throwUnmappable(sp);\n+                }\n+                char c = StringUTF16.getChar(val, sp++);\n+                if (Character.isHighSurrogate(c) && sp < sl &&\n+                        Character.isLowSurrogate(StringUTF16.getChar(val, sp))) {\n+                    sp++;\n+                }\n+                dst[dp++] = '?';\n+                len = sl - sp;\n+            }\n+        }\n+        if (dp == dst.length) {\n+            return dst;\n+        }\n+        return Arrays.copyOf(dst, dp);\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ utf8 \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\n+    private static boolean isNotContinuation(int b) {\n+        return (b & 0xc0) != 0x80;\n+    }\n+\n+    private static boolean isMalformed3(int b1, int b2, int b3) {\n+        return (b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n+                (b2 & 0xc0) != 0x80 || (b3 & 0xc0) != 0x80;\n+    }\n+\n+    private static boolean isMalformed3_2(int b1, int b2) {\n+        return (b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n+                (b2 & 0xc0) != 0x80;\n+    }\n+\n+    private static boolean isMalformed4(int b2, int b3, int b4) {\n+        return (b2 & 0xc0) != 0x80 || (b3 & 0xc0) != 0x80 ||\n+                (b4 & 0xc0) != 0x80;\n+    }\n+\n+    private static boolean isMalformed4_2(int b1, int b2) {\n+        return (b1 == 0xf0 && (b2 < 0x90 || b2 > 0xbf)) ||\n+                (b1 == 0xf4 && (b2 & 0xf0) != 0x80) ||\n+                (b2 & 0xc0) != 0x80;\n+    }\n+\n+    private static boolean isMalformed4_3(int b3) {\n+        return (b3 & 0xc0) != 0x80;\n+    }\n+\n+    private static char decode2(int b1, int b2) {\n+        return (char)(((b1 << 6) ^ b2) ^\n+                (((byte) 0xC0 << 6) ^\n+                        ((byte) 0x80 << 0)));\n+    }\n+\n+    private static char decode3(int b1, int b2, int b3) {\n+        return (char)((b1 << 12) ^\n+                (b2 <<  6) ^\n+                (b3 ^\n+                        (((byte) 0xE0 << 12) ^\n+                                ((byte) 0x80 <<  6) ^\n+                                ((byte) 0x80 <<  0))));\n+    }\n+\n+    private static int decode4(int b1, int b2, int b3, int b4) {\n+        return ((b1 << 18) ^\n+                (b2 << 12) ^\n+                (b3 <<  6) ^\n+                (b4 ^\n+                        (((byte) 0xF0 << 18) ^\n+                                ((byte) 0x80 << 12) ^\n+                                ((byte) 0x80 <<  6) ^\n+                                ((byte) 0x80 <<  0))));\n+    }\n+\n+    private static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp, boolean doReplace) {\n+        while (sp < sl) {\n+            int b1 = src[sp++];\n+            if (b1 >= 0) {\n+                StringUTF16.putChar(dst, dp++, (char) b1);\n+            } else if ((b1 >> 5) == -2 && (b1 & 0x1e) != 0) {\n+                if (sp < sl) {\n+                    int b2 = src[sp++];\n+                    if (isNotContinuation(b2)) {\n+                        if (!doReplace) {\n+                            throwMalformed(sp - 1, 1);\n+                        }\n+                        StringUTF16.putChar(dst, dp++, REPL);\n+                        sp--;\n+                    } else {\n+                        StringUTF16.putChar(dst, dp++, decode2(b1, b2));\n+                    }\n+                    continue;\n+                }\n+                if (!doReplace) {\n+                    throwMalformed(sp, 1);  \/\/ underflow()\n+                }\n+                StringUTF16.putChar(dst, dp++, REPL);\n+                break;\n+            } else if ((b1 >> 4) == -2) {\n+                if (sp + 1 < sl) {\n+                    int b2 = src[sp++];\n+                    int b3 = src[sp++];\n+                    if (isMalformed3(b1, b2, b3)) {\n+                        if (!doReplace) {\n+                            throwMalformed(sp - 3, 3);\n+                        }\n+                        StringUTF16.putChar(dst, dp++, REPL);\n+                        sp -= 3;\n+                        sp += malformed3(src, sp);\n+                    } else {\n+                        char c = decode3(b1, b2, b3);\n+                        if (Character.isSurrogate(c)) {\n+                            if (!doReplace) {\n+                                throwMalformed(sp - 3, 3);\n+                            }\n+                            StringUTF16.putChar(dst, dp++, REPL);\n+                        } else {\n+                            StringUTF16.putChar(dst, dp++, c);\n+                        }\n+                    }\n+                    continue;\n+                }\n+                if (sp < sl && isMalformed3_2(b1, src[sp])) {\n+                    if (!doReplace) {\n+                        throwMalformed(sp - 1, 2);\n+                    }\n+                    StringUTF16.putChar(dst, dp++, REPL);\n+                    continue;\n+                }\n+                if (!doReplace) {\n+                    throwMalformed(sp, 1);\n+                }\n+                StringUTF16.putChar(dst, dp++, REPL);\n+                break;\n+            } else if ((b1 >> 3) == -2) {\n+                if (sp + 2 < sl) {\n+                    int b2 = src[sp++];\n+                    int b3 = src[sp++];\n+                    int b4 = src[sp++];\n+                    int uc = decode4(b1, b2, b3, b4);\n+                    if (isMalformed4(b2, b3, b4) ||\n+                            !Character.isSupplementaryCodePoint(uc)) { \/\/ shortest form check\n+                        if (!doReplace) {\n+                            throwMalformed(sp - 4, 4);\n+                        }\n+                        StringUTF16.putChar(dst, dp++, REPL);\n+                        sp -= 4;\n+                        sp += malformed4(src, sp);\n+                    } else {\n+                        StringUTF16.putChar(dst, dp++, Character.highSurrogate(uc));\n+                        StringUTF16.putChar(dst, dp++, Character.lowSurrogate(uc));\n+                    }\n+                    continue;\n+                }\n+                b1 &= 0xff;\n+                if (b1 > 0xf4 || sp < sl && isMalformed4_2(b1, src[sp] & 0xff)) {\n+                    if (!doReplace) {\n+                        throwMalformed(sp - 1, 1);  \/\/ or 2\n+                    }\n+                    StringUTF16.putChar(dst, dp++, REPL);\n+                    continue;\n+                }\n+                if (!doReplace) {\n+                    throwMalformed(sp - 1, 1);\n+                }\n+                sp++;\n+                StringUTF16.putChar(dst, dp++, REPL);\n+                if (sp < sl && isMalformed4_3(src[sp])) {\n+                    continue;\n+                }\n+                break;\n+            } else {\n+                if (!doReplace) {\n+                    throwMalformed(sp - 1, 1);\n+                }\n+                StringUTF16.putChar(dst, dp++, REPL);\n+            }\n+        }\n+        return dp;\n+    }\n+\n+    private static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length) {\n+        ByteBuffer bb = ByteBuffer.wrap(src, offset, length);\n+        CharBuffer cb = CharBuffer.wrap(dst, 0, dst.length);\n+        try {\n+            CoderResult cr = cd.decode(bb, cb, true);\n+            if (!cr.isUnderflow())\n+                cr.throwException();\n+            cr = cd.flush(cb);\n+            if (!cr.isUnderflow())\n+                cr.throwException();\n+        } catch (CharacterCodingException x) {\n+            \/\/ Substitution is always enabled,\n+            \/\/ so this shouldn't happen\n+            throw new Error(x);\n+        }\n+        return cb.position();\n+    }\n+\n+    private static int malformed3(byte[] src, int sp) {\n+        int b1 = src[sp++];\n+        int b2 = src[sp];    \/\/ no need to lookup b3\n+        return ((b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n+                isNotContinuation(b2)) ? 1 : 2;\n+    }\n+\n+    private static int malformed4(byte[] src, int sp) {\n+        \/\/ we don't care the speed here\n+        int b1 = src[sp++] & 0xff;\n+        int b2 = src[sp++] & 0xff;\n+        if (b1 > 0xf4 ||\n+                (b1 == 0xf0 && (b2 < 0x90 || b2 > 0xbf)) ||\n+                (b1 == 0xf4 && (b2 & 0xf0) != 0x80) ||\n+                isNotContinuation(b2))\n+            return 1;\n+        if (isNotContinuation(src[sp]))\n+            return 2;\n+        return 3;\n+    }\n+\n+    private static void throwMalformed(int off, int nb) {\n+        String msg = \"malformed input off : \" + off + \", length : \" + nb;\n+        throw new IllegalArgumentException(msg, new MalformedInputException(nb));\n+    }\n+\n+    private static void throwMalformed(byte[] val) {\n+        int dp = 0;\n+        while (dp < val.length && val[dp] >=0) { dp++; }\n+        throwMalformed(dp, 1);\n+    }\n+\n+    private static void throwUnmappable(int off) {\n+        String msg = \"malformed input off : \" + off + \", length : 1\";\n+        throw new IllegalArgumentException(msg, new UnmappableCharacterException(1));\n+    }\n+\n+    private static void throwUnmappable(byte[] val) {\n+        int dp = 0;\n+        while (dp < val.length && val[dp] >=0) { dp++; }\n+        throwUnmappable(dp);\n+    }\n+\n+    private static byte[] encodeUTF8(byte coder, byte[] val, boolean doReplace) {\n+        if (coder == UTF16)\n+            return encodeUTF8_UTF16(val, doReplace);\n+\n+        if (!StringCoding.hasNegatives(val, 0, val.length))\n+            return Arrays.copyOf(val, val.length);\n+\n+        int dp = 0;\n+        byte[] dst = new byte[val.length << 1];\n+        for (byte c : val) {\n+            if (c < 0) {\n+                dst[dp++] = (byte) (0xc0 | ((c & 0xff) >> 6));\n+                dst[dp++] = (byte) (0x80 | (c & 0x3f));\n+            } else {\n+                dst[dp++] = c;\n+            }\n+        }\n+        if (dp == dst.length)\n+            return dst;\n+        return Arrays.copyOf(dst, dp);\n+    }\n+\n+    private static byte[] encodeUTF8_UTF16(byte[] val, boolean doReplace) {\n+        int dp = 0;\n+        int sp = 0;\n+        int sl = val.length >> 1;\n+        byte[] dst = new byte[sl * 3];\n+        char c;\n+        while (sp < sl && (c = StringUTF16.getChar(val, sp)) < '\\u0080') {\n+            \/\/ ascii fast loop;\n+            dst[dp++] = (byte)c;\n+            sp++;\n+        }\n+        while (sp < sl) {\n+            c = StringUTF16.getChar(val, sp++);\n+            if (c < 0x80) {\n+                dst[dp++] = (byte)c;\n+            } else if (c < 0x800) {\n+                dst[dp++] = (byte)(0xc0 | (c >> 6));\n+                dst[dp++] = (byte)(0x80 | (c & 0x3f));\n+            } else if (Character.isSurrogate(c)) {\n+                int uc = -1;\n+                char c2;\n+                if (Character.isHighSurrogate(c) && sp < sl &&\n+                        Character.isLowSurrogate(c2 = StringUTF16.getChar(val, sp))) {\n+                    uc = Character.toCodePoint(c, c2);\n+                }\n+                if (uc < 0) {\n+                    if (doReplace) {\n+                        dst[dp++] = '?';\n+                    } else {\n+                        throwUnmappable(sp - 1);\n+                    }\n+                } else {\n+                    dst[dp++] = (byte)(0xf0 | ((uc >> 18)));\n+                    dst[dp++] = (byte)(0x80 | ((uc >> 12) & 0x3f));\n+                    dst[dp++] = (byte)(0x80 | ((uc >>  6) & 0x3f));\n+                    dst[dp++] = (byte)(0x80 | (uc & 0x3f));\n+                    sp++;  \/\/ 2 chars\n+                }\n+            } else {\n+                \/\/ 3 bytes, 16 bits\n+                dst[dp++] = (byte)(0xe0 | ((c >> 12)));\n+                dst[dp++] = (byte)(0x80 | ((c >>  6) & 0x3f));\n+                dst[dp++] = (byte)(0x80 | (c & 0x3f));\n+            }\n+        }\n+        if (dp == dst.length) {\n+            return dst;\n+        }\n+        return Arrays.copyOf(dst, dp);\n+    }\n+\n+    \/*\n+     * Throws iae, instead of replacing, if unmappable.\n+     *\/\n+    static byte[] getBytesUTF8NoRepl(String s) {\n+        return encodeUTF8(s.coder(), s.value(), false);\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ for j.n.f.Files \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    private static boolean isASCII(byte[] src) {\n+        return !StringCoding.hasNegatives(src, 0, src.length);\n+    }\n+\n+    \/*\n+     * Throws CCE, instead of replacing, if unmappable.\n+     *\/\n+    static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n+        try {\n+            return getBytesNoRepl1(s, cs);\n+        } catch (IllegalArgumentException e) {\n+            \/\/getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause\n+            Throwable cause = e.getCause();\n+            if (cause instanceof UnmappableCharacterException) {\n+                throw (UnmappableCharacterException)cause;\n+            }\n+            throw (CharacterCodingException)cause;\n+        }\n+    }\n+\n+    private static byte[] getBytesNoRepl1(String s, Charset cs) {\n+        byte[] val = s.value();\n+        byte coder = s.coder();\n+        if (cs == UTF_8) {\n+            if (coder == LATIN1 && isASCII(val)) {\n+                return val;\n+            }\n+            return encodeUTF8(coder, val, false);\n+        }\n+        if (cs == ISO_8859_1) {\n+            if (coder == LATIN1) {\n+                return val;\n+            }\n+            return encode8859_1(coder, val, false);\n+        }\n+        if (cs == US_ASCII) {\n+            if (coder == LATIN1) {\n+                if (isASCII(val)) {\n+                    return val;\n+                } else {\n+                    throwUnmappable(val);\n+                }\n+            }\n+        }\n+        CharsetEncoder ce = cs.newEncoder();\n+        \/\/ fastpath for ascii compatible\n+        if (coder == LATIN1 &&\n+                ce instanceof ArrayEncoder ae &&\n+                ae.isASCIICompatible() &&\n+                isASCII(val)) {\n+            return val;\n+        }\n+        int len = val.length >> coder;  \/\/ assume LATIN1=0\/UTF16=1;\n+        int en = scale(len, ce.maxBytesPerChar());\n+        byte[] ba = new byte[en];\n+        if (len == 0) {\n+            return ba;\n+        }\n+        if (ce instanceof ArrayEncoder ae) {\n+            int blen = (coder == LATIN1 ) ? ae.encodeFromLatin1(val, 0, len, ba)\n+                                          : ae.encodeFromUTF16(val, 0, len, ba);\n+            if (blen != -1) {\n+                return safeTrim(ba, blen, true);\n+            }\n+        }\n+        char[] ca = (coder == LATIN1 ) ? StringLatin1.toChars(val)\n+                                       : StringUTF16.toChars(val);\n+        ByteBuffer bb = ByteBuffer.wrap(ba);\n+        CharBuffer cb = CharBuffer.wrap(ca, 0, len);\n+        try {\n+            CoderResult cr = ce.encode(cb, bb, true);\n+            if (!cr.isUnderflow())\n+                cr.throwException();\n+            cr = ce.flush(bb);\n+            if (!cr.isUnderflow())\n+                cr.throwException();\n+        } catch (CharacterCodingException x) {\n+            throw new IllegalArgumentException(x);\n+        }\n+        return safeTrim(ba, bb.position(), cs.getClass().getClassLoader0() == null );\n+    }\n+\n@@ -1222,1 +1769,1 @@\n-        return StringCoding.encode(charsetName, coder(), value);\n+        return encode(charsetName, coder(), value);\n@@ -1245,1 +1792,1 @@\n-        return StringCoding.encode(charset, coder(), value);\n+        return encode(charset, coder(), value);\n@@ -1262,1 +1809,1 @@\n-        return StringCoding.encode(coder(), value);\n+        return encode(coder(), value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":570,"deletions":23,"binary":false,"changes":593,"status":"modified"},{"patch":"@@ -28,4 +28,0 @@\n-import java.io.UnsupportedEncodingException;\n-import java.lang.ref.SoftReference;\n-import java.nio.ByteBuffer;\n-import java.nio.CharBuffer;\n@@ -33,11 +29,0 @@\n-import java.nio.charset.CharsetDecoder;\n-import java.nio.charset.CharsetEncoder;\n-import java.nio.charset.CharacterCodingException;\n-import java.nio.charset.CoderResult;\n-import java.nio.charset.CodingErrorAction;\n-import java.nio.charset.IllegalCharsetNameException;\n-import java.nio.charset.MalformedInputException;\n-import java.nio.charset.UnmappableCharacterException;\n-import java.nio.charset.UnsupportedCharsetException;\n-import java.util.Arrays;\n-import java.util.Objects;\n@@ -46,2 +31,0 @@\n-import sun.nio.cs.HistoricallyNamedCharset;\n-import sun.nio.cs.ArrayEncoder;\n@@ -49,3 +32,0 @@\n-import static java.lang.String.LATIN1;\n-import static java.lang.String.UTF16;\n-import static java.lang.StringUTF16.putChar;\n@@ -56,1 +36,0 @@\n-\n@@ -61,4 +40,0 @@\n-    \/** The cached coders for each thread *\/\n-    private static final ThreadLocal<SoftReference<StringEncoder>> encoder =\n-        new ThreadLocal<>();\n-\n@@ -69,208 +44,0 @@\n-    static final char REPL = '\\ufffd';\n-\n-    private static <T> T deref(ThreadLocal<SoftReference<T>> tl) {\n-        SoftReference<T> sr = tl.get();\n-        if (sr == null)\n-            return null;\n-        return sr.get();\n-    }\n-\n-    private static <T> void set(ThreadLocal<SoftReference<T>> tl, T ob) {\n-        tl.set(new SoftReference<>(ob));\n-    }\n-\n-    \/\/ Trim the given byte array to the given length\n-    private static byte[] safeTrim(byte[] ba, int len, boolean isTrusted) {\n-        if (len == ba.length && (isTrusted || System.getSecurityManager() == null))\n-            return ba;\n-        else\n-            return Arrays.copyOf(ba, len);\n-    }\n-\n-    static int scale(int len, float expansionFactor) {\n-        \/\/ We need to perform double, not float, arithmetic; otherwise\n-        \/\/ we lose low order bits when len is larger than 2**24.\n-        return (int)(len * (double)expansionFactor);\n-    }\n-\n-    static Charset lookupCharset(String csn) throws UnsupportedEncodingException {\n-        Objects.requireNonNull(csn);\n-        try {\n-            return Charset.forName(csn);\n-        } catch (UnsupportedCharsetException | IllegalCharsetNameException x) {\n-            throw new UnsupportedEncodingException(csn);\n-        }\n-    }\n-\n-    @IntrinsicCandidate\n-    public static boolean hasNegatives(byte[] ba, int off, int len) {\n-        for (int i = off; i < off + len; i++) {\n-            if (ba[i] < 0) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    \/\/ -- Encoding --\n-    private static class StringEncoder {\n-        private Charset cs;\n-        private CharsetEncoder ce;\n-        private final boolean isASCIICompatible;\n-        private final String requestedCharsetName;\n-        private final boolean isTrusted;\n-\n-        private StringEncoder(Charset cs, String rcn) {\n-            this.requestedCharsetName = rcn;\n-            this.cs = cs;\n-            this.ce = cs.newEncoder()\n-                .onMalformedInput(CodingErrorAction.REPLACE)\n-                .onUnmappableCharacter(CodingErrorAction.REPLACE);\n-            this.isTrusted = (cs.getClass().getClassLoader0() == null);\n-            this.isASCIICompatible = (ce instanceof ArrayEncoder) &&\n-                    ((ArrayEncoder)ce).isASCIICompatible();\n-        }\n-\n-        private String charsetName() {\n-            if (cs instanceof HistoricallyNamedCharset)\n-                return ((HistoricallyNamedCharset)cs).historicalName();\n-            return cs.name();\n-        }\n-\n-        private final String requestedCharsetName() {\n-            return requestedCharsetName;\n-        }\n-\n-        private byte[] encode(byte coder, byte[] val) {\n-            \/\/ fastpath for ascii compatible\n-            if (coder == LATIN1 && isASCIICompatible &&\n-                !hasNegatives(val, 0, val.length)) {\n-                return Arrays.copyOf(val, val.length);\n-            }\n-            int len = val.length >> coder;  \/\/ assume LATIN1=0\/UTF16=1;\n-            int en = scale(len, ce.maxBytesPerChar());\n-            byte[] ba = new byte[en];\n-            if (len == 0) {\n-                return ba;\n-            }\n-            if (ce instanceof ArrayEncoder) {\n-                int blen = (coder == LATIN1 ) ? ((ArrayEncoder)ce).encodeFromLatin1(val, 0, len, ba)\n-                                              : ((ArrayEncoder)ce).encodeFromUTF16(val, 0, len, ba);\n-                if (blen != -1) {\n-                    return safeTrim(ba, blen, isTrusted);\n-                }\n-            }\n-            char[] ca = (coder == LATIN1 ) ? StringLatin1.toChars(val)\n-                                           : StringUTF16.toChars(val);\n-            ce.reset();\n-            ByteBuffer bb = ByteBuffer.wrap(ba);\n-            CharBuffer cb = CharBuffer.wrap(ca, 0, len);\n-            try {\n-                CoderResult cr = ce.encode(cb, bb, true);\n-                if (!cr.isUnderflow())\n-                    cr.throwException();\n-                cr = ce.flush(bb);\n-                if (!cr.isUnderflow())\n-                    cr.throwException();\n-            } catch (CharacterCodingException x) {\n-                \/\/ Substitution is always enabled,\n-                \/\/ so this shouldn't happen\n-                throw new Error(x);\n-            }\n-            return safeTrim(ba, bb.position(), isTrusted);\n-        }\n-    }\n-\n-    static byte[] encode(String csn, byte coder, byte[] val)\n-        throws UnsupportedEncodingException\n-    {\n-        StringEncoder se = deref(encoder);\n-        if ((se == null) || !(csn.equals(se.requestedCharsetName())\n-                              || csn.equals(se.charsetName()))) {\n-            Charset cs = lookupCharset(csn);\n-            if (cs == UTF_8) {\n-                return encodeUTF8(coder, val, true);\n-            }\n-            if (cs == ISO_8859_1) {\n-                return encode8859_1(coder, val);\n-            }\n-            if (cs == US_ASCII) {\n-                return encodeASCII(coder, val);\n-            }\n-            se = new StringEncoder(cs, csn);\n-            set(encoder, se);\n-        }\n-        return se.encode(coder, val);\n-    }\n-\n-    static byte[] encode(Charset cs, byte coder, byte[] val) {\n-        if (cs == UTF_8) {\n-            return encodeUTF8(coder, val, true);\n-        }\n-        if (cs == ISO_8859_1) {\n-            return encode8859_1(coder, val);\n-        }\n-        if (cs == US_ASCII) {\n-            return encodeASCII(coder, val);\n-        }\n-        CharsetEncoder ce = cs.newEncoder();\n-        \/\/ fastpath for ascii compatible\n-        if (coder == LATIN1 && (((ce instanceof ArrayEncoder) &&\n-                                 ((ArrayEncoder)ce).isASCIICompatible() &&\n-                                 !hasNegatives(val, 0, val.length)))) {\n-            return Arrays.copyOf(val, val.length);\n-        }\n-        int len = val.length >> coder;  \/\/ assume LATIN1=0\/UTF16=1;\n-        int en = scale(len, ce.maxBytesPerChar());\n-        byte[] ba = new byte[en];\n-        if (len == 0) {\n-            return ba;\n-        }\n-        ce.onMalformedInput(CodingErrorAction.REPLACE)\n-          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n-          .reset();\n-        if (ce instanceof ArrayEncoder) {\n-            int blen = (coder == LATIN1 ) ? ((ArrayEncoder)ce).encodeFromLatin1(val, 0, len, ba)\n-                                          : ((ArrayEncoder)ce).encodeFromUTF16(val, 0, len, ba);\n-            if (blen != -1) {\n-                return safeTrim(ba, blen, true);\n-            }\n-        }\n-        boolean isTrusted = cs.getClass().getClassLoader0() == null ||\n-                            System.getSecurityManager() == null;\n-        char[] ca = (coder == LATIN1 ) ? StringLatin1.toChars(val)\n-                                       : StringUTF16.toChars(val);\n-        ByteBuffer bb = ByteBuffer.wrap(ba);\n-        CharBuffer cb = CharBuffer.wrap(ca, 0, len);\n-        try {\n-            CoderResult cr = ce.encode(cb, bb, true);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-            cr = ce.flush(bb);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-        } catch (CharacterCodingException x) {\n-            throw new Error(x);\n-        }\n-        return safeTrim(ba, bb.position(), isTrusted);\n-    }\n-\n-    static byte[] encode(byte coder, byte[] val) {\n-        Charset cs = Charset.defaultCharset();\n-        if (cs == UTF_8) {\n-            return encodeUTF8(coder, val, true);\n-        }\n-        if (cs == ISO_8859_1) {\n-            return encode8859_1(coder, val);\n-        }\n-        if (cs == US_ASCII) {\n-            return encodeASCII(coder, val);\n-        }\n-        StringEncoder se = deref(encoder);\n-        if (se == null || !cs.name().equals(se.cs.name())) {\n-            se = new StringEncoder(cs, cs.name());\n-            set(encoder, se);\n-        }\n-        return se.encode(coder, val);\n-    }\n-\n@@ -284,24 +51,5 @@\n-    private static byte[] encodeASCII(byte coder, byte[] val) {\n-        if (coder == LATIN1) {\n-            byte[] dst = new byte[val.length];\n-            for (int i = 0; i < val.length; i++) {\n-                if (val[i] < 0) {\n-                    dst[i] = '?';\n-                } else {\n-                    dst[i] = val[i];\n-                }\n-            }\n-            return dst;\n-        }\n-        int len = val.length >> 1;\n-        byte[] dst = new byte[len];\n-        int dp = 0;\n-        for (int i = 0; i < len; i++) {\n-            char c = StringUTF16.getChar(val, i);\n-            if (c < 0x80) {\n-                dst[dp++] = (byte)c;\n-                continue;\n-            }\n-            if (Character.isHighSurrogate(c) && i + 1 < len &&\n-                Character.isLowSurrogate(StringUTF16.getChar(val, i + 1))) {\n-                i++;\n+    @IntrinsicCandidate\n+    public static boolean hasNegatives(byte[] ba, int off, int len) {\n+        for (int i = off; i < off + len; i++) {\n+            if (ba[i] < 0) {\n+                return true;\n@@ -309,1 +57,0 @@\n-            dst[dp++] = '?';\n@@ -311,4 +58,1 @@\n-        if (len == dp) {\n-            return dst;\n-        }\n-        return Arrays.copyOf(dst, dp);\n+        return false;\n@@ -318,1 +62,1 @@\n-    private static int implEncodeISOArray(byte[] sa, int sp,\n+    public static int implEncodeISOArray(byte[] sa, int sp,\n@@ -330,428 +74,0 @@\n-    private static byte[] encode8859_1(byte coder, byte[] val) {\n-        return encode8859_1(coder, val, true);\n-    }\n-\n-    private static byte[] encode8859_1(byte coder, byte[] val, boolean doReplace) {\n-        if (coder == LATIN1) {\n-            return Arrays.copyOf(val, val.length);\n-        }\n-        int len = val.length >> 1;\n-        byte[] dst = new byte[len];\n-        int dp = 0;\n-        int sp = 0;\n-        int sl = len;\n-        while (sp < sl) {\n-            int ret = implEncodeISOArray(val, sp, dst, dp, len);\n-            sp = sp + ret;\n-            dp = dp + ret;\n-            if (ret != len) {\n-                if (!doReplace) {\n-                    throwUnmappable(sp);\n-                }\n-                char c = StringUTF16.getChar(val, sp++);\n-                if (Character.isHighSurrogate(c) && sp < sl &&\n-                    Character.isLowSurrogate(StringUTF16.getChar(val, sp))) {\n-                    sp++;\n-                }\n-                dst[dp++] = '?';\n-                len = sl - sp;\n-            }\n-        }\n-        if (dp == dst.length) {\n-            return dst;\n-        }\n-        return Arrays.copyOf(dst, dp);\n-    }\n-\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ utf8 \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-\n-    static boolean isNotContinuation(int b) {\n-        return (b & 0xc0) != 0x80;\n-    }\n-\n-    private static boolean isMalformed3(int b1, int b2, int b3) {\n-        return (b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n-               (b2 & 0xc0) != 0x80 || (b3 & 0xc0) != 0x80;\n-    }\n-\n-    private static boolean isMalformed3_2(int b1, int b2) {\n-        return (b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n-               (b2 & 0xc0) != 0x80;\n-    }\n-\n-    private static boolean isMalformed4(int b2, int b3, int b4) {\n-        return (b2 & 0xc0) != 0x80 || (b3 & 0xc0) != 0x80 ||\n-               (b4 & 0xc0) != 0x80;\n-    }\n-\n-    private static boolean isMalformed4_2(int b1, int b2) {\n-        return (b1 == 0xf0 && (b2 < 0x90 || b2 > 0xbf)) ||\n-               (b1 == 0xf4 && (b2 & 0xf0) != 0x80) ||\n-               (b2 & 0xc0) != 0x80;\n-    }\n-\n-    private static boolean isMalformed4_3(int b3) {\n-        return (b3 & 0xc0) != 0x80;\n-    }\n-\n-    static char decode2(int b1, int b2) {\n-        return (char)(((b1 << 6) ^ b2) ^\n-                      (((byte) 0xC0 << 6) ^\n-                       ((byte) 0x80 << 0)));\n-    }\n-\n-    private static char decode3(int b1, int b2, int b3) {\n-        return (char)((b1 << 12) ^\n-                      (b2 <<  6) ^\n-                      (b3 ^\n-                       (((byte) 0xE0 << 12) ^\n-                        ((byte) 0x80 <<  6) ^\n-                        ((byte) 0x80 <<  0))));\n-    }\n-\n-    private static int decode4(int b1, int b2, int b3, int b4) {\n-        return ((b1 << 18) ^\n-                (b2 << 12) ^\n-                (b3 <<  6) ^\n-                (b4 ^\n-                 (((byte) 0xF0 << 18) ^\n-                  ((byte) 0x80 << 12) ^\n-                  ((byte) 0x80 <<  6) ^\n-                  ((byte) 0x80 <<  0))));\n-    }\n-\n-    static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp, boolean doReplace) {\n-        while (sp < sl) {\n-            int b1 = src[sp++];\n-            if (b1 >= 0) {\n-                putChar(dst, dp++, (char) b1);\n-            } else if ((b1 >> 5) == -2 && (b1 & 0x1e) != 0) {\n-                if (sp < sl) {\n-                    int b2 = src[sp++];\n-                    if (StringCoding.isNotContinuation(b2)) {\n-                        if (!doReplace) {\n-                            throwMalformed(sp - 1, 1);\n-                        }\n-                        putChar(dst, dp++, REPL);\n-                        sp--;\n-                    } else {\n-                        putChar(dst, dp++, decode2(b1, b2));\n-                    }\n-                    continue;\n-                }\n-                if (!doReplace) {\n-                    throwMalformed(sp, 1);  \/\/ underflow()\n-                }\n-                putChar(dst, dp++, REPL);\n-                break;\n-            } else if ((b1 >> 4) == -2) {\n-                if (sp + 1 < sl) {\n-                    int b2 = src[sp++];\n-                    int b3 = src[sp++];\n-                    if (isMalformed3(b1, b2, b3)) {\n-                        if (!doReplace) {\n-                            throwMalformed(sp - 3, 3);\n-                        }\n-                        putChar(dst, dp++, REPL);\n-                        sp -= 3;\n-                        sp += malformedN(src, sp, 3);\n-                    } else {\n-                        char c = decode3(b1, b2, b3);\n-                        if (Character.isSurrogate(c)) {\n-                            if (!doReplace) {\n-                                throwMalformed(sp - 3, 3);\n-                            }\n-                            putChar(dst, dp++, REPL);\n-                        } else {\n-                            putChar(dst, dp++, c);\n-                        }\n-                    }\n-                    continue;\n-                }\n-                if (sp < sl && isMalformed3_2(b1, src[sp])) {\n-                    if (!doReplace) {\n-                        throwMalformed(sp - 1, 2);\n-                    }\n-                    putChar(dst, dp++, REPL);\n-                    continue;\n-                }\n-                if (!doReplace) {\n-                    throwMalformed(sp, 1);\n-                }\n-                putChar(dst, dp++, REPL);\n-                break;\n-            } else if ((b1 >> 3) == -2) {\n-                if (sp + 2 < sl) {\n-                    int b2 = src[sp++];\n-                    int b3 = src[sp++];\n-                    int b4 = src[sp++];\n-                    int uc = decode4(b1, b2, b3, b4);\n-                    if (isMalformed4(b2, b3, b4) ||\n-                            !Character.isSupplementaryCodePoint(uc)) { \/\/ shortest form check\n-                        if (!doReplace) {\n-                            throwMalformed(sp - 4, 4);\n-                        }\n-                        putChar(dst, dp++, REPL);\n-                        sp -= 4;\n-                        sp += StringCoding.malformedN(src, sp, 4);\n-                    } else {\n-                        putChar(dst, dp++, Character.highSurrogate(uc));\n-                        putChar(dst, dp++, Character.lowSurrogate(uc));\n-                    }\n-                    continue;\n-                }\n-                b1 &= 0xff;\n-                if (b1 > 0xf4 || sp < sl && StringCoding.isMalformed4_2(b1, src[sp] & 0xff)) {\n-                    if (!doReplace) {\n-                        throwMalformed(sp - 1, 1);  \/\/ or 2\n-                    }\n-                    putChar(dst, dp++, REPL);\n-                    continue;\n-                }\n-                if (!doReplace) {\n-                    throwMalformed(sp - 1, 1);\n-                }\n-                sp++;\n-                putChar(dst, dp++, REPL);\n-                if (sp < sl && StringCoding.isMalformed4_3(src[sp])) {\n-                    continue;\n-                }\n-                break;\n-            } else {\n-                if (!doReplace) {\n-                    throwMalformed(sp - 1, 1);\n-                }\n-                putChar(dst, dp++, REPL);\n-            }\n-        }\n-        return dp;\n-    }\n-\n-    static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length) {\n-        ByteBuffer bb = ByteBuffer.wrap(src, offset, length);\n-        CharBuffer cb = CharBuffer.wrap(dst, 0, dst.length);\n-        try {\n-            CoderResult cr = cd.decode(bb, cb, true);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-            cr = cd.flush(cb);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-        } catch (CharacterCodingException x) {\n-            \/\/ Substitution is always enabled,\n-            \/\/ so this shouldn't happen\n-            throw new Error(x);\n-        }\n-        return cb.position();\n-    }\n-\n-    \/\/ for nb == 3\/4\n-    static int malformedN(byte[] src, int sp, int nb) {\n-        if (nb == 3) {\n-            int b1 = src[sp++];\n-            int b2 = src[sp];    \/\/ no need to lookup b3\n-            return ((b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n-                    isNotContinuation(b2)) ? 1 : 2;\n-        } else if (nb == 4) { \/\/ we don't care the speed here\n-            int b1 = src[sp++] & 0xff;\n-            int b2 = src[sp++] & 0xff;\n-            if (b1 > 0xf4 ||\n-                (b1 == 0xf0 && (b2 < 0x90 || b2 > 0xbf)) ||\n-                (b1 == 0xf4 && (b2 & 0xf0) != 0x80) ||\n-                isNotContinuation(b2))\n-                return 1;\n-            if (isNotContinuation(src[sp]))\n-                return 2;\n-            return 3;\n-        }\n-        assert false;\n-        return -1;\n-    }\n-\n-    private static void throwMalformed(int off, int nb) {\n-        String msg = \"malformed input off : \" + off + \", length : \" + nb;\n-        throw new IllegalArgumentException(msg, new MalformedInputException(nb));\n-    }\n-\n-    static void throwMalformed(byte[] val) {\n-        int dp = 0;\n-        while (dp < val.length && val[dp] >=0) { dp++; }\n-        throwMalformed(dp, 1);\n-    }\n-\n-    private static void throwUnmappable(int off) {\n-        String msg = \"malformed input off : \" + off + \", length : 1\";\n-        throw new IllegalArgumentException(msg, new UnmappableCharacterException(1));\n-    }\n-\n-    static void throwUnmappable(byte[] val) {\n-        int dp = 0;\n-        while (dp < val.length && val[dp] >=0) { dp++; }\n-        throwUnmappable(dp);\n-    }\n-\n-    private static byte[] encodeUTF8(byte coder, byte[] val, boolean doReplace) {\n-        if (coder == UTF16)\n-            return encodeUTF8_UTF16(val, doReplace);\n-\n-        if (!hasNegatives(val, 0, val.length))\n-            return Arrays.copyOf(val, val.length);\n-\n-        int dp = 0;\n-        byte[] dst = new byte[val.length << 1];\n-        for (byte c : val) {\n-            if (c < 0) {\n-                dst[dp++] = (byte) (0xc0 | ((c & 0xff) >> 6));\n-                dst[dp++] = (byte) (0x80 | (c & 0x3f));\n-            } else {\n-                dst[dp++] = c;\n-            }\n-        }\n-        if (dp == dst.length)\n-            return dst;\n-        return Arrays.copyOf(dst, dp);\n-    }\n-\n-    private static byte[] encodeUTF8_UTF16(byte[] val, boolean doReplace) {\n-        int dp = 0;\n-        int sp = 0;\n-        int sl = val.length >> 1;\n-        byte[] dst = new byte[sl * 3];\n-        char c;\n-        while (sp < sl && (c = StringUTF16.getChar(val, sp)) < '\\u0080') {\n-            \/\/ ascii fast loop;\n-            dst[dp++] = (byte)c;\n-            sp++;\n-        }\n-        while (sp < sl) {\n-            c = StringUTF16.getChar(val, sp++);\n-            if (c < 0x80) {\n-                dst[dp++] = (byte)c;\n-            } else if (c < 0x800) {\n-                dst[dp++] = (byte)(0xc0 | (c >> 6));\n-                dst[dp++] = (byte)(0x80 | (c & 0x3f));\n-            } else if (Character.isSurrogate(c)) {\n-                int uc = -1;\n-                char c2;\n-                if (Character.isHighSurrogate(c) && sp < sl &&\n-                    Character.isLowSurrogate(c2 = StringUTF16.getChar(val, sp))) {\n-                    uc = Character.toCodePoint(c, c2);\n-                }\n-                if (uc < 0) {\n-                    if (doReplace) {\n-                        dst[dp++] = '?';\n-                    } else {\n-                        throwUnmappable(sp - 1);\n-                    }\n-                } else {\n-                    dst[dp++] = (byte)(0xf0 | ((uc >> 18)));\n-                    dst[dp++] = (byte)(0x80 | ((uc >> 12) & 0x3f));\n-                    dst[dp++] = (byte)(0x80 | ((uc >>  6) & 0x3f));\n-                    dst[dp++] = (byte)(0x80 | (uc & 0x3f));\n-                    sp++;  \/\/ 2 chars\n-                }\n-            } else {\n-                \/\/ 3 bytes, 16 bits\n-                dst[dp++] = (byte)(0xe0 | ((c >> 12)));\n-                dst[dp++] = (byte)(0x80 | ((c >>  6) & 0x3f));\n-                dst[dp++] = (byte)(0x80 | (c & 0x3f));\n-            }\n-        }\n-        if (dp == dst.length) {\n-            return dst;\n-        }\n-        return Arrays.copyOf(dst, dp);\n-    }\n-\n-    \/*\n-     * Throws iae, instead of replacing, if unmappable.\n-     *\/\n-    static byte[] getBytesUTF8NoRepl(String s) {\n-        return encodeUTF8(s.coder(), s.value(), false);\n-    }\n-\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ for j.n.f.Files \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-    private static boolean isASCII(byte[] src) {\n-        return !hasNegatives(src, 0, src.length);\n-    }\n-\n-    \/*\n-     * Throws CCE, instead of replacing, if unmappable.\n-     *\/\n-    static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n-        try {\n-            return getBytesNoRepl1(s, cs);\n-        } catch (IllegalArgumentException e) {\n-            \/\/getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause\n-            Throwable cause = e.getCause();\n-            if (cause instanceof UnmappableCharacterException) {\n-                throw (UnmappableCharacterException)cause;\n-            }\n-            throw (CharacterCodingException)cause;\n-        }\n-    }\n-\n-    static byte[] getBytesNoRepl1(String s, Charset cs) {\n-        byte[] val = s.value();\n-        byte coder = s.coder();\n-        if (cs == UTF_8) {\n-            if (coder == LATIN1 && isASCII(val)) {\n-                return val;\n-            }\n-            return encodeUTF8(coder, val, false);\n-        }\n-        if (cs == ISO_8859_1) {\n-            if (coder == LATIN1) {\n-                return val;\n-            }\n-            return encode8859_1(coder, val, false);\n-        }\n-        if (cs == US_ASCII) {\n-            if (coder == LATIN1) {\n-                if (isASCII(val)) {\n-                    return val;\n-                } else {\n-                    throwUnmappable(val);\n-                }\n-            }\n-        }\n-        CharsetEncoder ce = cs.newEncoder();\n-        \/\/ fastpath for ascii compatible\n-        if (coder == LATIN1 && (((ce instanceof ArrayEncoder) &&\n-                                 ((ArrayEncoder)ce).isASCIICompatible() &&\n-                                 isASCII(val)))) {\n-            return val;\n-        }\n-        int len = val.length >> coder;  \/\/ assume LATIN1=0\/UTF16=1;\n-        int en = scale(len, ce.maxBytesPerChar());\n-        byte[] ba = new byte[en];\n-        if (len == 0) {\n-            return ba;\n-        }\n-        if (ce instanceof ArrayEncoder) {\n-            int blen = (coder == LATIN1 ) ? ((ArrayEncoder)ce).encodeFromLatin1(val, 0, len, ba)\n-                                          : ((ArrayEncoder)ce).encodeFromUTF16(val, 0, len, ba);\n-            if (blen != -1) {\n-                return safeTrim(ba, blen, true);\n-            }\n-        }\n-        boolean isTrusted = cs.getClass().getClassLoader0() == null ||\n-                            System.getSecurityManager() == null;\n-        char[] ca = (coder == LATIN1 ) ? StringLatin1.toChars(val)\n-                                       : StringUTF16.toChars(val);\n-        ByteBuffer bb = ByteBuffer.wrap(ba);\n-        CharBuffer cb = CharBuffer.wrap(ca, 0, len);\n-        try {\n-            CoderResult cr = ce.encode(cb, bb, true);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-            cr = ce.flush(bb);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-        } catch (CharacterCodingException x) {\n-            throw new IllegalArgumentException(x);\n-        }\n-        return safeTrim(ba, bb.position(), isTrusted);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringCoding.java","additions":7,"deletions":691,"binary":false,"changes":698,"status":"modified"},{"patch":"@@ -2269,1 +2269,1 @@\n-                return StringCoding.getBytesNoRepl(s, cs);\n+                return String.getBytesNoRepl(s, cs);\n@@ -2277,1 +2277,1 @@\n-                return StringCoding.getBytesUTF8NoRepl(s);\n+                return String.getBytesUTF8NoRepl(s);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.nio.charset.Charset;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = \"-Xmx1g\")\n+@Warmup(iterations = 5, time = 2)\n+@Measurement(iterations = 5, time = 3)\n+@State(Scope.Thread)\n+public class StringEncode {\n+\n+    @BenchmarkMode(Mode.AverageTime)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    @Fork(value = 3, jvmArgs = \"-Xmx1g\")\n+    @Warmup(iterations = 5, time = 2)\n+    @Measurement(iterations = 5, time = 2)\n+    @State(Scope.Thread)\n+    public static class WithCharset {\n+\n+        @Param({\"US-ASCII\", \"ISO-8859-1\", \"UTF-8\", \"MS932\", \"ISO-8859-6\"})\n+        private String charsetName;\n+\n+        private Charset charset;\n+        private String asciiString;\n+        private String utf16String;\n+\n+        @Setup\n+        public void setup() {\n+            charset = Charset.forName(charsetName);\n+            asciiString = \"ascii string\";\n+            utf16String = \"UTF-\\uFF11\\uFF16 string\";\n+        }\n+\n+        @Benchmark\n+        public void encodeCharsetName(Blackhole bh) throws Exception {\n+            bh.consume(asciiString.getBytes(charsetName));\n+            bh.consume(utf16String.getBytes(charsetName));\n+        }\n+\n+        @Benchmark\n+        public void encodeCharset(Blackhole bh) throws Exception {\n+            bh.consume(asciiString.getBytes(charset));\n+            bh.consume(utf16String.getBytes(charset));\n+        }\n+    }\n+\n+    private String asciiDefaultString;\n+    private String utf16DefaultString;\n+\n+    @Setup\n+    public void setup() {\n+        asciiDefaultString = \"ascii string\";\n+        utf16DefaultString = \"UTF-\\uFF11\\uFF16 string\";\n+    }\n+\n+    @Benchmark\n+    public void encodeDefault(Blackhole bh) throws Exception {\n+        bh.consume(asciiDefaultString.getBytes());\n+        bh.consume(utf16DefaultString.getBytes());\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringEncode.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"}]}