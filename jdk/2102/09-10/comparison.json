{"files":[{"patch":"@@ -829,0 +829,4 @@\n+        return encodeWithEncoder(cs, coder, val, true);\n+    }\n+\n+    private static byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val, boolean doReplace) {\n@@ -843,2 +847,4 @@\n-            ce.onMalformedInput(CodingErrorAction.REPLACE)\n-                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+            if (doReplace) {\n+                ce.onMalformedInput(CodingErrorAction.REPLACE)\n+                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+            }\n@@ -857,2 +863,4 @@\n-        ce.onMalformedInput(CodingErrorAction.REPLACE)\n-                .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+        if (doReplace) {\n+            ce.onMalformedInput(CodingErrorAction.REPLACE)\n+                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+        }\n@@ -871,1 +879,5 @@\n-            throw new Error(x);\n+            if (doReplace) {\n+                throw new IllegalArgumentException(x);\n+            } else {\n+                throw new Error(x);\n+            }\n@@ -876,0 +888,54 @@\n+    \/*\n+     * Throws iae, instead of replacing, if unmappable.\n+     *\/\n+    static byte[] getBytesUTF8NoRepl(String s) {\n+        return encodeUTF8(s.coder(), s.value(), false);\n+    }\n+\n+    private static boolean isASCII(byte[] src) {\n+        return !StringCoding.hasNegatives(src, 0, src.length);\n+    }\n+\n+    \/*\n+     * Throws CCE, instead of replacing, if unmappable.\n+     *\/\n+    static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n+        try {\n+            return getBytesNoRepl1(s, cs);\n+        } catch (IllegalArgumentException e) {\n+            \/\/getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause\n+            Throwable cause = e.getCause();\n+            if (cause instanceof UnmappableCharacterException) {\n+                throw (UnmappableCharacterException)cause;\n+            }\n+            throw (CharacterCodingException)cause;\n+        }\n+    }\n+\n+    private static byte[] getBytesNoRepl1(String s, Charset cs) {\n+        byte[] val = s.value();\n+        byte coder = s.coder();\n+        if (cs == UTF_8) {\n+            if (coder == LATIN1 && isASCII(val)) {\n+                return val;\n+            }\n+            return encodeUTF8(coder, val, false);\n+        }\n+        if (cs == ISO_8859_1) {\n+            if (coder == LATIN1) {\n+                return val;\n+            }\n+            return encode8859_1(coder, val, false);\n+        }\n+        if (cs == US_ASCII) {\n+            if (coder == LATIN1) {\n+                if (isASCII(val)) {\n+                    return val;\n+                } else {\n+                    throwUnmappable(val);\n+                }\n+            }\n+        }\n+        return encodeWithEncoder(cs, coder, val, false);\n+    }\n+\n@@ -878,3 +944,3 @@\n-            byte[] dst = new byte[val.length];\n-            for (int i = 0; i < val.length; i++) {\n-                if (val[i] < 0) {\n+            byte[] dst = Arrays.copyOf(val, val.length);\n+            for (int i = 0; i < dst.length; i++) {\n+                if (dst[i] < 0) {\n@@ -882,2 +948,0 @@\n-                } else {\n-                    dst[i] = val[i];\n@@ -1244,91 +1308,0 @@\n-    \/*\n-     * Throws iae, instead of replacing, if unmappable.\n-     *\/\n-    static byte[] getBytesUTF8NoRepl(String s) {\n-        return encodeUTF8(s.coder(), s.value(), false);\n-    }\n-\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ for j.n.f.Files \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-    private static boolean isASCII(byte[] src) {\n-        return !StringCoding.hasNegatives(src, 0, src.length);\n-    }\n-\n-    \/*\n-     * Throws CCE, instead of replacing, if unmappable.\n-     *\/\n-    static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n-        try {\n-            return getBytesNoRepl1(s, cs);\n-        } catch (IllegalArgumentException e) {\n-            \/\/getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause\n-            Throwable cause = e.getCause();\n-            if (cause instanceof UnmappableCharacterException) {\n-                throw (UnmappableCharacterException)cause;\n-            }\n-            throw (CharacterCodingException)cause;\n-        }\n-    }\n-\n-    private static byte[] getBytesNoRepl1(String s, Charset cs) {\n-        byte[] val = s.value();\n-        byte coder = s.coder();\n-        if (cs == UTF_8) {\n-            if (coder == LATIN1 && isASCII(val)) {\n-                return val;\n-            }\n-            return encodeUTF8(coder, val, false);\n-        }\n-        if (cs == ISO_8859_1) {\n-            if (coder == LATIN1) {\n-                return val;\n-            }\n-            return encode8859_1(coder, val, false);\n-        }\n-        if (cs == US_ASCII) {\n-            if (coder == LATIN1) {\n-                if (isASCII(val)) {\n-                    return val;\n-                } else {\n-                    throwUnmappable(val);\n-                }\n-            }\n-        }\n-        CharsetEncoder ce = cs.newEncoder();\n-        \/\/ fastpath for ascii compatible\n-        if (coder == LATIN1 &&\n-                ce instanceof ArrayEncoder ae &&\n-                ae.isASCIICompatible() &&\n-                isASCII(val)) {\n-            return val;\n-        }\n-        int len = val.length >> coder;  \/\/ assume LATIN1=0\/UTF16=1;\n-        int en = scale(len, ce.maxBytesPerChar());\n-        byte[] ba = new byte[en];\n-        if (len == 0) {\n-            return ba;\n-        }\n-        if (ce instanceof ArrayEncoder ae) {\n-            int blen = (coder == LATIN1 ) ? ae.encodeFromLatin1(val, 0, len, ba)\n-                                          : ae.encodeFromUTF16(val, 0, len, ba);\n-            if (blen != -1) {\n-                return safeTrim(ba, blen, true);\n-            }\n-        }\n-        char[] ca = (coder == LATIN1 ) ? StringLatin1.toChars(val)\n-                                       : StringUTF16.toChars(val);\n-        ByteBuffer bb = ByteBuffer.wrap(ba);\n-        CharBuffer cb = CharBuffer.wrap(ca, 0, len);\n-        try {\n-            CoderResult cr = ce.encode(cb, bb, true);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-            cr = ce.flush(bb);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-        } catch (CharacterCodingException x) {\n-            throw new IllegalArgumentException(x);\n-        }\n-        return safeTrim(ba, bb.position(), cs.getClass().getClassLoader0() == null );\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":74,"deletions":101,"binary":false,"changes":175,"status":"modified"}]}