{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,3 @@\n-import java.nio.charset.Charset;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.*;\n@@ -54,0 +56,1 @@\n+import sun.nio.cs.ArrayDecoder;\n@@ -55,0 +58,3 @@\n+import static java.lang.StringCoding.ISO_8859_1;\n+import static java.lang.StringCoding.US_ASCII;\n+import static java.lang.StringCoding.UTF_8;\n@@ -478,1 +484,1 @@\n-    public String(byte bytes[], int offset, int length, String charsetName)\n+    public String(byte[] bytes, int offset, int length, String charsetName)\n@@ -480,7 +486,1 @@\n-        if (charsetName == null)\n-            throw new NullPointerException(\"charsetName\");\n-        checkBoundsOffCount(offset, length, bytes.length);\n-        StringCoding.Result ret =\n-            StringCoding.decode(charsetName, bytes, offset, length);\n-        this.value = ret.value;\n-        this.coder = ret.coder;\n+        this(bytes, offset, length, StringCoding.lookupCharset(charsetName));\n@@ -519,3 +519,171 @@\n-    public String(byte bytes[], int offset, int length, Charset charset) {\n-        if (charset == null)\n-            throw new NullPointerException(\"charset\");\n+    public String(byte[] bytes, int offset, int length, Charset charset) {\n+        Objects.requireNonNull(charset);\n+        checkBoundsOffCount(offset, length, bytes.length);\n+        if (length == 0) {\n+            this.value = \"\".value;\n+            this.coder = \"\".coder;\n+            return;\n+        }\n+        if (charset == UTF_8) {\n+            if (COMPACT_STRINGS && !StringCoding.hasNegatives(bytes, offset, length)) {\n+                this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n+                this.coder = LATIN1;\n+                return;\n+            } else {\n+                int sl = offset + length;\n+                int dp = 0;\n+                byte[] dst = new byte[length];\n+\n+                if (COMPACT_STRINGS) {\n+                    while (offset < sl) {\n+                        int b1 = bytes[offset];\n+                        if (b1 >= 0) {\n+                            dst[dp++] = (byte)b1;\n+                            offset++;\n+                            continue;\n+                        }\n+                        if ((b1 == (byte)0xc2 || b1 == (byte)0xc3) &&\n+                                offset + 1 < sl) {\n+                            int b2 = bytes[offset + 1];\n+                            if (!StringCoding.isNotContinuation(b2)) {\n+                                dst[dp++] = (byte)StringCoding.decode2(b1, b2);\n+                                offset += 2;\n+                                continue;\n+                            }\n+                        }\n+                        \/\/ anything not a latin1, including the repl\n+                        \/\/ we have to go with the utf16\n+                        break;\n+                    }\n+                    if (offset == sl) {\n+                        if (dp != dst.length) {\n+                            dst = Arrays.copyOf(dst, dp);\n+                        }\n+                        this.value = dst;\n+                        this.coder = LATIN1;\n+                        return;\n+                    }\n+                }\n+                if (dp == 0) {\n+                    dst = new byte[length << 1];\n+                } else {\n+                    byte[] buf = new byte[length << 1];\n+                    StringLatin1.inflate(dst, 0, buf, 0, dp);\n+                    dst = buf;\n+                }\n+                dp = StringCoding.decodeUTF8_UTF16(bytes, offset, sl, dst, dp, true);\n+                if (dp != length) {\n+                    dst = Arrays.copyOf(dst, dp << 1);\n+                }\n+                this.value = dst;\n+                this.coder = UTF16;\n+            }\n+        } else if (charset == ISO_8859_1) {\n+            if (COMPACT_STRINGS) {\n+                this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n+                this.coder = LATIN1;\n+            } else {\n+                this.value = StringLatin1.inflate(bytes, offset, length);\n+                this.coder = UTF16;\n+            }\n+        } else if (charset == US_ASCII) {\n+            if (COMPACT_STRINGS && !StringCoding.hasNegatives(bytes, offset, length)) {\n+                this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n+                this.coder = LATIN1;\n+            } else {\n+                byte[] dst = new byte[length << 1];\n+                int dp = 0;\n+                while (dp < length) {\n+                    int b = bytes[offset++];\n+                    StringUTF16.putChar(dst, dp++, (b >= 0) ? (char) b : StringCoding.REPL);\n+                }\n+                this.value = dst;\n+                this.coder = UTF16;\n+            }\n+        } else {\n+            \/\/ (1)We never cache the \"external\" cs, the only benefit of creating\n+            \/\/ an additional StringDe\/Encoder object to wrap it is to share the\n+            \/\/ de\/encode() method. These SD\/E objects are short-lived, the young-gen\n+            \/\/ gc should be able to take care of them well. But the best approach\n+            \/\/ is still not to generate them if not really necessary.\n+            \/\/ (2)The defensive copy of the input byte\/char[] has a big performance\n+            \/\/ impact, as well as the outgoing result byte\/char[]. Need to do the\n+            \/\/ optimization check of (sm==null && classLoader0==null) for both.\n+            \/\/ (3)There might be a timing gap in isTrusted setting. getClassLoader0()\n+            \/\/ is only checked (and then isTrusted gets set) when (SM==null). It is\n+            \/\/ possible that the SM==null for now but then SM is NOT null later\n+            \/\/ when safeTrim() is invoked...the \"safe\" way to do is to redundant\n+            \/\/ check (... && (isTrusted || SM == null || getClassLoader0())) in trim\n+            \/\/ but it then can be argued that the SM is null when the operation\n+            \/\/ is started...\n+            CharsetDecoder cd = charset.newDecoder();\n+            \/\/ ArrayDecoder fastpaths\n+            if (cd instanceof ArrayDecoder ad) {\n+                \/\/ ascii\n+                if (ad.isASCIICompatible() && !StringCoding.hasNegatives(bytes, offset, length)) {\n+                    if (COMPACT_STRINGS) {\n+                        this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n+                        this.coder = LATIN1;\n+                        return;\n+                    }\n+                    this.value = StringLatin1.inflate(bytes, offset, length);\n+                    this.coder = UTF16;\n+                    return;\n+                }\n+\n+                \/\/ fastpath for always Latin1 decodable single byte\n+                if (COMPACT_STRINGS && ad.isLatin1Decodable()) {\n+                    byte[] dst = new byte[length];\n+                    ad.decodeToLatin1(bytes, offset, length, dst);\n+                    this.value = dst;\n+                    this.coder = LATIN1;\n+                    return;\n+                }\n+\n+                int en = StringCoding.scale(length, cd.maxCharsPerByte());\n+                cd.onMalformedInput(CodingErrorAction.REPLACE)\n+                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+                char[] ca = new char[en];\n+                int clen = ad.decode(bytes, offset, length, ca);\n+                if (COMPACT_STRINGS) {\n+                    byte[] bs = StringUTF16.compress(ca, 0, clen);\n+                    if (bs != null) {\n+                        value = bs;\n+                        coder = LATIN1;\n+                        return;\n+                    }\n+                }\n+                coder = UTF16;\n+                value = StringUTF16.toBytes(ca, 0, clen);\n+                return;\n+            }\n+\n+            \/\/ decode using CharsetDecoder\n+            int en = StringCoding.scale(length, cd.maxCharsPerByte());\n+            cd.onMalformedInput(CodingErrorAction.REPLACE)\n+                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+            char[] ca = new char[en];\n+            if (charset.getClass().getClassLoader0() != null &&\n+                    System.getSecurityManager() != null) {\n+                bytes = Arrays.copyOfRange(bytes, offset, offset + length);\n+                offset = 0;\n+            }\n+\n+            int caLen = StringCoding.decodeWithDecoder(cd, ca, bytes, offset, length);\n+            if (COMPACT_STRINGS) {\n+                byte[] bs = StringUTF16.compress(ca, 0, caLen);\n+                if (bs != null) {\n+                    value = bs;\n+                    coder = LATIN1;\n+                    return;\n+                }\n+            }\n+            coder = UTF16;\n+            value = StringUTF16.toBytes(ca, 0, caLen);\n+        }\n+    }\n+\n+    \/*\n+     * Throws iae, instead of replacing, if malformed or unmappable.\n+     *\/\n+    static String newStringUTF8NoRepl(byte[] bytes, int offset, int length) {\n@@ -523,4 +691,101 @@\n-        StringCoding.Result ret =\n-            StringCoding.decode(charset, bytes, offset, length);\n-        this.value = ret.value;\n-        this.coder = ret.coder;\n+        int sl = offset + length;\n+        int dp = 0;\n+        byte[] dst = new byte[length];\n+        if (COMPACT_STRINGS) {\n+            while (offset < sl) {\n+                int b1 = bytes[offset];\n+                if (b1 >= 0) {\n+                    dst[dp++] = (byte)b1;\n+                    offset++;\n+                    continue;\n+                }\n+                if ((b1 == (byte)0xc2 || b1 == (byte)0xc3) &&\n+                        offset + 1 < sl) {\n+                    int b2 = bytes[offset + 1];\n+                    if (!StringCoding.isNotContinuation(b2)) {\n+                        dst[dp++] = (byte)StringCoding.decode2(b1, b2);\n+                        offset += 2;\n+                        continue;\n+                    }\n+                }\n+                \/\/ anything not a latin1, including the REPL\n+                \/\/ we have to go with the utf16\n+                break;\n+            }\n+            if (offset == sl) {\n+                if (dp != dst.length) {\n+                    dst = Arrays.copyOf(dst, dp);\n+                }\n+                return new String(dst, LATIN1);\n+            }\n+        }\n+        if (dp == 0) {\n+            dst = new byte[length << 1];\n+        } else {\n+            byte[] buf = new byte[length << 1];\n+            StringLatin1.inflate(dst, 0, buf, 0, dp);\n+            dst = buf;\n+        }\n+        dp = StringCoding.decodeUTF8_UTF16(bytes, offset, sl, dst, dp, false);\n+        if (dp != length) {\n+            dst = Arrays.copyOf(dst, dp << 1);\n+        }\n+        return new String(dst, UTF16);\n+    }\n+\n+    static String newStringNoRepl(byte[] src, Charset cs) throws CharacterCodingException {\n+        try {\n+            return newStringNoRepl1(src, cs);\n+        } catch (IllegalArgumentException e) {\n+            \/\/newStringNoRepl1 throws IAE with MalformedInputException or CCE as the cause\n+            Throwable cause = e.getCause();\n+            if (cause instanceof MalformedInputException mie) {\n+                throw mie;\n+            }\n+            throw (CharacterCodingException)cause;\n+        }\n+    }\n+\n+    static String newStringNoRepl1(byte[] src, Charset cs) {\n+        if (cs == UTF_8) {\n+            return newStringUTF8NoRepl(src, 0, src.length);\n+        }\n+        if (cs == ISO_8859_1) {\n+            if (COMPACT_STRINGS)\n+                return new String(src, LATIN1);\n+            return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n+        }\n+        if (cs == US_ASCII) {\n+            if (!StringCoding.hasNegatives(src, 0, src.length)) {\n+                if (COMPACT_STRINGS)\n+                    return new String(src, LATIN1);\n+                return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n+            } else {\n+                StringCoding.throwMalformed(src);\n+            }\n+        }\n+\n+        CharsetDecoder cd = cs.newDecoder();\n+        \/\/ ascii fastpath\n+        if (cd instanceof ArrayDecoder ad &&\n+                ad.isASCIICompatible() && !StringCoding.hasNegatives(src, 0, src.length)) {\n+            return new String(src, 0, src.length, ISO_8859_1);\n+        }\n+        int len = src.length;\n+        if (len == 0) {\n+            return \"\";\n+        }\n+        int en = StringCoding.scale(len, cd.maxCharsPerByte());\n+        char[] ca = new char[en];\n+        if (cs.getClass().getClassLoader0() != null &&\n+                System.getSecurityManager() != null) {\n+            src = Arrays.copyOf(src, len);\n+        }\n+        int caLen = StringCoding.decodeWithDecoder(cd, ca, src, 0, src.length);\n+        if (COMPACT_STRINGS) {\n+            byte[] bs = StringUTF16.compress(ca, 0, caLen);\n+            if (bs != null) {\n+                return new String(bs, LATIN1);\n+            }\n+        }\n+        return new String(StringUTF16.toBytes(ca, 0, caLen), UTF16);\n@@ -607,5 +872,2 @@\n-    public String(byte bytes[], int offset, int length) {\n-        checkBoundsOffCount(offset, length, bytes.length);\n-        StringCoding.Result ret = StringCoding.decode(bytes, offset, length);\n-        this.value = ret.value;\n-        this.coder = ret.coder;\n+    public String(byte[] bytes, int offset, int length) {\n+        this(bytes, offset, length, Charset.defaultCharset());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":284,"deletions":22,"binary":false,"changes":306,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+import java.util.Objects;\n+\n@@ -45,1 +47,0 @@\n-import sun.nio.cs.ArrayDecoder;\n@@ -50,5 +51,0 @@\n-import static java.lang.String.COMPACT_STRINGS;\n-import static java.lang.Character.isSurrogate;\n-import static java.lang.Character.highSurrogate;\n-import static java.lang.Character.lowSurrogate;\n-import static java.lang.Character.isSupplementaryCodePoint;\n@@ -66,2 +62,0 @@\n-    private static final ThreadLocal<SoftReference<StringDecoder>> decoder =\n-        new ThreadLocal<>();\n@@ -71,3 +65,5 @@\n-    private static final Charset ISO_8859_1 = sun.nio.cs.ISO_8859_1.INSTANCE;\n-    private static final Charset US_ASCII = sun.nio.cs.US_ASCII.INSTANCE;\n-    private static final Charset UTF_8 = sun.nio.cs.UTF_8.INSTANCE;\n+    static final Charset ISO_8859_1 = sun.nio.cs.ISO_8859_1.INSTANCE;\n+    static final Charset US_ASCII = sun.nio.cs.US_ASCII.INSTANCE;\n+    static final Charset UTF_8 = sun.nio.cs.UTF_8.INSTANCE;\n+\n+    static final char REPL = '\\ufffd';\n@@ -94,1 +90,1 @@\n-    private static int scale(int len, float expansionFactor) {\n+    static int scale(int len, float expansionFactor) {\n@@ -100,39 +96,6 @@\n-    private static Charset lookupCharset(String csn) {\n-        if (Charset.isSupported(csn)) {\n-            try {\n-                return Charset.forName(csn);\n-            } catch (UnsupportedCharsetException x) {\n-                throw new Error(x);\n-            }\n-        }\n-        return null;\n-    }\n-\n-    static class Result {\n-        byte[] value;\n-        byte coder;\n-\n-        Result with() {\n-            coder = COMPACT_STRINGS ? LATIN1 : UTF16;\n-            value = new byte[0];\n-            return this;\n-        }\n-\n-        Result with(char[] val, int off, int len) {\n-            if (String.COMPACT_STRINGS) {\n-                byte[] bs = StringUTF16.compress(val, off, len);\n-                if (bs != null) {\n-                    value = bs;\n-                    coder = LATIN1;\n-                    return this;\n-                }\n-            }\n-            coder = UTF16;\n-            value = StringUTF16.toBytes(val, off, len);\n-            return this;\n-        }\n-\n-        Result with(byte[] val, byte coder) {\n-            this.coder = coder;\n-            value = val;\n-            return this;\n+    static Charset lookupCharset(String csn) throws UnsupportedEncodingException {\n+        Objects.requireNonNull(csn);\n+        try {\n+            return Charset.forName(csn);\n+        } catch (UnsupportedCharsetException | IllegalCharsetNameException x) {\n+            throw new UnsupportedEncodingException(csn);\n@@ -152,195 +115,0 @@\n-    \/\/ -- Decoding --\n-    static class StringDecoder {\n-        private final String requestedCharsetName;\n-        private final Charset cs;\n-        private final boolean isASCIICompatible;\n-        private final CharsetDecoder cd;\n-        protected final Result result;\n-\n-        StringDecoder(Charset cs, String rcn) {\n-            this.requestedCharsetName = rcn;\n-            this.cs = cs;\n-            this.cd = cs.newDecoder()\n-                .onMalformedInput(CodingErrorAction.REPLACE)\n-                .onUnmappableCharacter(CodingErrorAction.REPLACE);\n-            this.result = new Result();\n-            this.isASCIICompatible = (cd instanceof ArrayDecoder) &&\n-                    ((ArrayDecoder)cd).isASCIICompatible();\n-        }\n-\n-        String charsetName() {\n-            if (cs instanceof HistoricallyNamedCharset)\n-                return ((HistoricallyNamedCharset)cs).historicalName();\n-            return cs.name();\n-        }\n-\n-        final String requestedCharsetName() {\n-            return requestedCharsetName;\n-        }\n-\n-        Result decode(byte[] ba, int off, int len) {\n-            if (len == 0) {\n-                return result.with();\n-            }\n-            \/\/ fastpath for ascii compatible\n-            if (isASCIICompatible && !hasNegatives(ba, off, len)) {\n-                if (COMPACT_STRINGS) {\n-                    return result.with(Arrays.copyOfRange(ba, off, off + len),\n-                                      LATIN1);\n-                } else {\n-                    return result.with(StringLatin1.inflate(ba, off, len), UTF16);\n-                }\n-            }\n-            \/\/ fastpath for always Latin1 decodable single byte\n-            if (COMPACT_STRINGS && cd instanceof ArrayDecoder && ((ArrayDecoder)cd).isLatin1Decodable()) {\n-                byte[] dst = new byte[len];\n-                ((ArrayDecoder)cd).decodeToLatin1(ba, off, len, dst);\n-                return result.with(dst, LATIN1);\n-            }\n-            int en = scale(len, cd.maxCharsPerByte());\n-            char[] ca = new char[en];\n-            if (cd instanceof ArrayDecoder) {\n-                int clen = ((ArrayDecoder)cd).decode(ba, off, len, ca);\n-                return result.with(ca, 0, clen);\n-            }\n-            cd.reset();\n-            ByteBuffer bb = ByteBuffer.wrap(ba, off, len);\n-            CharBuffer cb = CharBuffer.wrap(ca);\n-            try {\n-                CoderResult cr = cd.decode(bb, cb, true);\n-                if (!cr.isUnderflow())\n-                    cr.throwException();\n-                cr = cd.flush(cb);\n-                if (!cr.isUnderflow())\n-                    cr.throwException();\n-            } catch (CharacterCodingException x) {\n-                \/\/ Substitution is always enabled,\n-                \/\/ so this shouldn't happen\n-                throw new Error(x);\n-            }\n-            return result.with(ca, 0, cb.position());\n-        }\n-    }\n-\n-    static Result decode(String charsetName, byte[] ba, int off, int len)\n-        throws UnsupportedEncodingException\n-    {\n-        StringDecoder sd = deref(decoder);\n-        String csn = (charsetName == null) ? \"ISO-8859-1\" : charsetName;\n-        if ((sd == null) || !(csn.equals(sd.requestedCharsetName())\n-                              || csn.equals(sd.charsetName()))) {\n-            sd = null;\n-            try {\n-                Charset cs = lookupCharset(csn);\n-                if (cs != null) {\n-                    if (cs == UTF_8) {\n-                        return decodeUTF8(ba, off, len, true);\n-                    }\n-                    if (cs == ISO_8859_1) {\n-                        return decodeLatin1(ba, off, len);\n-                    }\n-                    if (cs == US_ASCII) {\n-                        return decodeASCII(ba, off, len);\n-                    }\n-                    sd = new StringDecoder(cs, csn);\n-                }\n-            } catch (IllegalCharsetNameException x) {}\n-            if (sd == null)\n-                throw new UnsupportedEncodingException(csn);\n-            set(decoder, sd);\n-        }\n-        return sd.decode(ba, off, len);\n-    }\n-\n-    static Result decode(Charset cs, byte[] ba, int off, int len) {\n-        if (cs == UTF_8) {\n-            return decodeUTF8(ba, off, len, true);\n-        }\n-        if (cs == ISO_8859_1) {\n-            return decodeLatin1(ba, off, len);\n-        }\n-        if (cs == US_ASCII) {\n-            return decodeASCII(ba, off, len);\n-        }\n-\n-        \/\/ (1)We never cache the \"external\" cs, the only benefit of creating\n-        \/\/ an additional StringDe\/Encoder object to wrap it is to share the\n-        \/\/ de\/encode() method. These SD\/E objects are short-lived, the young-gen\n-        \/\/ gc should be able to take care of them well. But the best approach\n-        \/\/ is still not to generate them if not really necessary.\n-        \/\/ (2)The defensive copy of the input byte\/char[] has a big performance\n-        \/\/ impact, as well as the outgoing result byte\/char[]. Need to do the\n-        \/\/ optimization check of (sm==null && classLoader0==null) for both.\n-        \/\/ (3)There might be a timing gap in isTrusted setting. getClassLoader0()\n-        \/\/ is only checked (and then isTrusted gets set) when (SM==null). It is\n-        \/\/ possible that the SM==null for now but then SM is NOT null later\n-        \/\/ when safeTrim() is invoked...the \"safe\" way to do is to redundant\n-        \/\/ check (... && (isTrusted || SM == null || getClassLoader0())) in trim\n-        \/\/ but it then can be argued that the SM is null when the operation\n-        \/\/ is started...\n-        CharsetDecoder cd = cs.newDecoder();\n-        \/\/ ascii fastpath\n-        if ((cd instanceof ArrayDecoder) &&\n-            ((ArrayDecoder)cd).isASCIICompatible() && !hasNegatives(ba, off, len)) {\n-            return decodeLatin1(ba, off, len);\n-        }\n-        \/\/ fastpath for always Latin1 decodable single byte\n-        if (COMPACT_STRINGS && cd instanceof ArrayDecoder && ((ArrayDecoder)cd).isLatin1Decodable()) {\n-            byte[] dst = new byte[len];\n-            ((ArrayDecoder)cd).decodeToLatin1(ba, off, len, dst);\n-            return new Result().with(dst, LATIN1);\n-        }\n-\n-        int en = scale(len, cd.maxCharsPerByte());\n-        if (len == 0) {\n-            return new Result().with();\n-        }\n-        cd.onMalformedInput(CodingErrorAction.REPLACE)\n-          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n-          .reset();\n-        char[] ca = new char[en];\n-        if (cd instanceof ArrayDecoder) {\n-            int clen = ((ArrayDecoder)cd).decode(ba, off, len, ca);\n-            return new Result().with(ca, 0, clen);\n-        }\n-        if (cs.getClass().getClassLoader0() != null &&\n-            System.getSecurityManager() != null) {\n-            ba = Arrays.copyOfRange(ba, off, off + len);\n-            off = 0;\n-        }\n-        ByteBuffer bb = ByteBuffer.wrap(ba, off, len);\n-        CharBuffer cb = CharBuffer.wrap(ca);\n-        try {\n-            CoderResult cr = cd.decode(bb, cb, true);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-            cr = cd.flush(cb);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-        } catch (CharacterCodingException x) {\n-            \/\/ Substitution is always enabled,\n-            \/\/ so this shouldn't happen\n-            throw new Error(x);\n-        }\n-        return new Result().with(ca, 0, cb.position());\n-    }\n-\n-    static Result decode(byte[] ba, int off, int len) {\n-        Charset cs = Charset.defaultCharset();\n-        if (cs == UTF_8) {\n-            return decodeUTF8(ba, off, len, true);\n-        }\n-        if (cs == ISO_8859_1) {\n-            return decodeLatin1(ba, off, len);\n-        }\n-        if (cs == US_ASCII) {\n-            return decodeASCII(ba, off, len);\n-        }\n-        StringDecoder sd = deref(decoder);\n-        if (sd == null || !cs.name().equals(sd.cs.name())) {\n-            sd = new StringDecoder(cs, cs.name());\n-            set(decoder, sd);\n-        }\n-        return sd.decode(ba, off, len);\n-    }\n-\n@@ -416,1 +184,1 @@\n-    static byte[] encode(String charsetName, byte coder, byte[] val)\n+    static byte[] encode(String csn, byte coder, byte[] val)\n@@ -420,1 +188,0 @@\n-        String csn = (charsetName == null) ? \"ISO-8859-1\" : charsetName;\n@@ -423,18 +190,3 @@\n-            se = null;\n-            try {\n-                Charset cs = lookupCharset(csn);\n-                if (cs != null) {\n-                    if (cs == UTF_8) {\n-                        return encodeUTF8(coder, val, true);\n-                    }\n-                    if (cs == ISO_8859_1) {\n-                        return encode8859_1(coder, val);\n-                    }\n-                    if (cs == US_ASCII) {\n-                        return encodeASCII(coder, val);\n-                    }\n-                    se = new StringEncoder(cs, csn);\n-                }\n-            } catch (IllegalCharsetNameException x) {}\n-            if (se == null) {\n-                throw new UnsupportedEncodingException (csn);\n+            Charset cs = lookupCharset(csn);\n+            if (cs == UTF_8) {\n+                return encodeUTF8(coder, val, true);\n@@ -442,0 +194,7 @@\n+            if (cs == ISO_8859_1) {\n+                return encode8859_1(coder, val);\n+            }\n+            if (cs == US_ASCII) {\n+                return encodeASCII(coder, val);\n+            }\n+            se = new StringEncoder(cs, csn);\n@@ -525,33 +284,0 @@\n-     \/* The cached Result for each thread *\/\n-    private static final ThreadLocal<SoftReference<Result>>\n-        resultCached = new ThreadLocal<>() {\n-            protected SoftReference<Result> initialValue() {\n-                return new SoftReference<>(new Result());\n-            }};\n-    private static Result resultCached() {\n-        SoftReference<Result> sr = resultCached.get();\n-        Result r;\n-        if (sr == null || (r = sr.get()) == null) {\n-            r = new Result();\n-            resultCached.set(new SoftReference<>(r));\n-        }\n-        return r;\n-    }\n-\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ ascii \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-    private static Result decodeASCII(byte[] ba, int off, int len) {\n-        Result result = resultCached();\n-        if (COMPACT_STRINGS && !hasNegatives(ba, off, len)) {\n-            return result.with(Arrays.copyOfRange(ba, off, off + len),\n-                               LATIN1);\n-        }\n-        byte[] dst = new byte[len<<1];\n-        int dp = 0;\n-        while (dp < len) {\n-            int b = ba[off++];\n-            putChar(dst, dp++, (b >= 0) ? (char)b : repl);\n-        }\n-        return result.with(dst, UTF16);\n-    }\n-\n@@ -591,11 +317,0 @@\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ latin1\/8859_1 \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-    private static Result decodeLatin1(byte[] ba, int off, int len) {\n-       Result result = resultCached();\n-       if (COMPACT_STRINGS) {\n-           return result.with(Arrays.copyOfRange(ba, off, off + len), LATIN1);\n-       } else {\n-           return result.with(StringLatin1.inflate(ba, off, len), UTF16);\n-       }\n-    }\n-\n@@ -653,1 +368,1 @@\n-    private static boolean isNotContinuation(int b) {\n+    static boolean isNotContinuation(int b) {\n@@ -657,1 +372,1 @@\n-    private static boolean isMalformed3(int b1, int b2, int b3) {\n+    static boolean isMalformed3(int b1, int b2, int b3) {\n@@ -662,1 +377,1 @@\n-    private static boolean isMalformed3_2(int b1, int b2) {\n+    static boolean isMalformed3_2(int b1, int b2) {\n@@ -667,1 +382,1 @@\n-    private static boolean isMalformed4(int b2, int b3, int b4) {\n+    static boolean isMalformed4(int b2, int b3, int b4) {\n@@ -672,1 +387,1 @@\n-    private static boolean isMalformed4_2(int b1, int b2) {\n+    static boolean isMalformed4_2(int b1, int b2) {\n@@ -678,1 +393,1 @@\n-    private static boolean isMalformed4_3(int b3) {\n+    static boolean isMalformed4_3(int b3) {\n@@ -682,32 +397,4 @@\n-    \/\/ for nb == 3\/4\n-    private static int malformedN(byte[] src, int sp, int nb) {\n-        if (nb == 3) {\n-            int b1 = src[sp++];\n-            int b2 = src[sp++];    \/\/ no need to lookup b3\n-            return ((b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n-                    isNotContinuation(b2)) ? 1 : 2;\n-        } else if (nb == 4) { \/\/ we don't care the speed here\n-            int b1 = src[sp++] & 0xff;\n-            int b2 = src[sp++] & 0xff;\n-            if (b1 > 0xf4 ||\n-                (b1 == 0xf0 && (b2 < 0x90 || b2 > 0xbf)) ||\n-                (b1 == 0xf4 && (b2 & 0xf0) != 0x80) ||\n-                isNotContinuation(b2))\n-                return 1;\n-            if (isNotContinuation(src[sp++]))\n-                return 2;\n-            return 3;\n-        }\n-        assert false;\n-        return -1;\n-    }\n-\n-    private static void throwMalformed(int off, int nb) {\n-        String msg = \"malformed input off : \" + off + \", length : \" + nb;\n-        throw new IllegalArgumentException(msg, new MalformedInputException(nb));\n-    }\n-\n-    private static void throwMalformed(byte[] val) {\n-        int dp = 0;\n-        while (dp < val.length && val[dp] >=0) { dp++; }\n-        throwMalformed(dp, 1);\n+    static char decode2(int b1, int b2) {\n+        return (char)(((b1 << 6) ^ b2)^\n+                (((byte) 0xC0 << 6) ^\n+                ((byte) 0x80 << 0)));\n@@ -716,3 +403,7 @@\n-    private static void throwUnmappable(int off, int nb) {\n-        String msg = \"malformed input off : \" + off + \", length : \" + nb;\n-        throw new IllegalArgumentException(msg, new UnmappableCharacterException(nb));\n+    static char decode3(int b1, int b2, int b3) {\n+        return (char)((b1 << 12) ^\n+                        (b2 <<  6) ^\n+                        (b3 ^\n+                         (((byte) 0xE0 << 12) ^\n+                          ((byte) 0x80 <<  6) ^\n+                          ((byte) 0x80 <<  0))));\n@@ -721,14 +412,9 @@\n-    private static void throwUnmappable(byte[] val) {\n-        int dp = 0;\n-        while (dp < val.length && val[dp] >=0) { dp++; }\n-        throwUnmappable(dp, 1);\n-    }\n-\n-    private static char repl = '\\ufffd';\n-\n-    private static Result decodeUTF8(byte[] src, int sp, int len, boolean doReplace) {\n-        \/\/ ascii-bais, which has a relative impact to the non-ascii-only bytes\n-        if (COMPACT_STRINGS && !hasNegatives(src, sp, len))\n-            return resultCached().with(Arrays.copyOfRange(src, sp, sp + len),\n-                                           LATIN1);\n-        return decodeUTF8_0(src, sp, len, doReplace);\n+    static int decode4(int b1, int b2, int b3, int b4) {\n+        return ((b1 << 18) ^\n+                (b2 << 12) ^\n+                (b3 <<  6) ^\n+                (b4 ^\n+                 (((byte) 0xF0 << 18) ^\n+                  ((byte) 0x80 << 12) ^\n+                  ((byte) 0x80 <<  6) ^\n+                  ((byte) 0x80 <<  0))));\n@@ -737,46 +423,3 @@\n-    private static Result decodeUTF8_0(byte[] src, int sp, int len, boolean doReplace) {\n-        Result ret = resultCached();\n-\n-        int sl = sp + len;\n-        int dp = 0;\n-        byte[] dst = new byte[len];\n-\n-        if (COMPACT_STRINGS) {\n-            while (sp < sl) {\n-                int b1 = src[sp];\n-                if (b1 >= 0) {\n-                    dst[dp++] = (byte)b1;\n-                    sp++;\n-                    continue;\n-                }\n-                if ((b1 == (byte)0xc2 || b1 == (byte)0xc3) &&\n-                    sp + 1 < sl) {\n-                    int b2 = src[sp + 1];\n-                    if (!isNotContinuation(b2)) {\n-                        dst[dp++] = (byte)(((b1 << 6) ^ b2)^\n-                                           (((byte) 0xC0 << 6) ^\n-                                           ((byte) 0x80 << 0)));\n-                        sp += 2;\n-                        continue;\n-                    }\n-                }\n-                \/\/ anything not a latin1, including the repl\n-                \/\/ we have to go with the utf16\n-                break;\n-            }\n-            if (sp == sl) {\n-                if (dp != dst.length) {\n-                    dst = Arrays.copyOf(dst, dp);\n-                }\n-                return ret.with(dst, LATIN1);\n-            }\n-        }\n-        if (dp == 0) {\n-            dst = new byte[len << 1];\n-        } else {\n-            byte[] buf = new byte[len << 1];\n-            StringLatin1.inflate(dst, 0, buf, 0, dp);\n-            dst = buf;\n-        }\n-        while (sp < sl) {\n-            int b1 = src[sp++];\n+    static int decodeUTF8_UTF16(byte[] bytes, int offset, int sl, byte[] dst, int dp, boolean doReplace) {\n+        while (offset < sl) {\n+            int b1 = bytes[offset++];\n@@ -786,3 +429,3 @@\n-                if (sp < sl) {\n-                    int b2 = src[sp++];\n-                    if (isNotContinuation(b2)) {\n+                if (offset < sl) {\n+                    int b2 = bytes[offset++];\n+                    if (StringCoding.isNotContinuation(b2)) {\n@@ -790,1 +433,1 @@\n-                            throwMalformed(sp - 1, 1);\n+                            throwMalformed(offset - 1, 1);\n@@ -792,2 +435,2 @@\n-                        putChar(dst, dp++, repl);\n-                        sp--;\n+                        putChar(dst, dp++, REPL);\n+                        offset--;\n@@ -795,3 +438,1 @@\n-                        putChar(dst, dp++, (char)(((b1 << 6) ^ b2)^\n-                                                  (((byte) 0xC0 << 6) ^\n-                                                  ((byte) 0x80 << 0))));\n+                        putChar(dst, dp++, decode2(b1, b2));\n@@ -802,1 +443,1 @@\n-                    throwMalformed(sp, 1);  \/\/ underflow()\n+                    throwMalformed(offset, 1);  \/\/ underflow()\n@@ -804,1 +445,1 @@\n-                putChar(dst, dp++, repl);\n+                putChar(dst, dp++, REPL);\n@@ -807,3 +448,3 @@\n-                if (sp + 1 < sl) {\n-                    int b2 = src[sp++];\n-                    int b3 = src[sp++];\n+                if (offset + 1 < sl) {\n+                    int b2 = bytes[offset++];\n+                    int b3 = bytes[offset++];\n@@ -812,1 +453,1 @@\n-                            throwMalformed(sp - 3, 3);\n+                            throwMalformed(offset - 3, 3);\n@@ -814,3 +455,3 @@\n-                        putChar(dst, dp++, repl);\n-                        sp -= 3;\n-                        sp += malformedN(src, sp, 3);\n+                        putChar(dst, dp++, REPL);\n+                        offset -= 3;\n+                        offset += malformedN(bytes, offset, 3);\n@@ -818,7 +459,2 @@\n-                        char c = (char)((b1 << 12) ^\n-                                        (b2 <<  6) ^\n-                                        (b3 ^\n-                                         (((byte) 0xE0 << 12) ^\n-                                         ((byte) 0x80 <<  6) ^\n-                                         ((byte) 0x80 <<  0))));\n-                        if (isSurrogate(c)) {\n+                        char c = decode3(b1, b2, b3);\n+                        if (Character.isSurrogate(c)) {\n@@ -826,1 +462,1 @@\n-                                throwMalformed(sp - 3, 3);\n+                                throwMalformed(offset - 3, 3);\n@@ -828,1 +464,1 @@\n-                            putChar(dst, dp++, repl);\n+                            putChar(dst, dp++, REPL);\n@@ -835,1 +471,1 @@\n-                if (sp  < sl && isMalformed3_2(b1, src[sp])) {\n+                if (offset < sl && isMalformed3_2(b1, bytes[offset])) {\n@@ -837,1 +473,1 @@\n-                        throwMalformed(sp - 1, 2);\n+                        throwMalformed(offset - 1, 2);\n@@ -839,1 +475,1 @@\n-                    putChar(dst, dp++, repl);\n+                    putChar(dst, dp++, REPL);\n@@ -842,2 +478,2 @@\n-                if (!doReplace){\n-                    throwMalformed(sp, 1);\n+                if (!doReplace) {\n+                    throwMalformed(offset, 1);\n@@ -845,1 +481,1 @@\n-                putChar(dst, dp++, repl);\n+                putChar(dst, dp++, REPL);\n@@ -848,12 +484,5 @@\n-                if (sp + 2 < sl) {\n-                    int b2 = src[sp++];\n-                    int b3 = src[sp++];\n-                    int b4 = src[sp++];\n-                    int uc = ((b1 << 18) ^\n-                              (b2 << 12) ^\n-                              (b3 <<  6) ^\n-                              (b4 ^\n-                               (((byte) 0xF0 << 18) ^\n-                               ((byte) 0x80 << 12) ^\n-                               ((byte) 0x80 <<  6) ^\n-                               ((byte) 0x80 <<  0))));\n+                if (offset + 2 < sl) {\n+                    int b2 = bytes[offset++];\n+                    int b3 = bytes[offset++];\n+                    int b4 = bytes[offset++];\n+                    int uc = decode4(b1, b2, b3, b4);\n@@ -861,1 +490,1 @@\n-                        !isSupplementaryCodePoint(uc)) { \/\/ shortest form check\n+                            !Character.isSupplementaryCodePoint(uc)) { \/\/ shortest form check\n@@ -863,1 +492,1 @@\n-                            throwMalformed(sp - 4, 4);\n+                            throwMalformed(offset - 4, 4);\n@@ -865,3 +494,3 @@\n-                        putChar(dst, dp++, repl);\n-                        sp -= 4;\n-                        sp += malformedN(src, sp, 4);\n+                        putChar(dst, dp++, REPL);\n+                        offset -= 4;\n+                        offset += StringCoding.malformedN(bytes, offset, 4);\n@@ -869,2 +498,2 @@\n-                        putChar(dst, dp++, highSurrogate(uc));\n-                        putChar(dst, dp++, lowSurrogate(uc));\n+                        putChar(dst, dp++, Character.highSurrogate(uc));\n+                        putChar(dst, dp++, Character.lowSurrogate(uc));\n@@ -876,1 +505,1 @@\n-                    sp  < sl && isMalformed4_2(b1, src[sp] & 0xff)) {\n+                        offset  < sl && StringCoding.isMalformed4_2(b1, bytes[offset] & 0xff)) {\n@@ -878,1 +507,1 @@\n-                        throwMalformed(sp - 1, 1);  \/\/ or 2\n+                        throwMalformed(offset - 1, 1);  \/\/ or 2\n@@ -880,1 +509,1 @@\n-                    putChar(dst, dp++, repl);\n+                    putChar(dst, dp++, REPL);\n@@ -884,1 +513,1 @@\n-                    throwMalformed(sp - 1, 1);\n+                    throwMalformed(offset - 1, 1);\n@@ -886,3 +515,3 @@\n-                sp++;\n-                putChar(dst, dp++, repl);\n-                if (sp  < sl && isMalformed4_3(src[sp])) {\n+                offset++;\n+                putChar(dst, dp++, REPL);\n+                if (offset < sl && StringCoding.isMalformed4_3(bytes[offset])) {\n@@ -894,1 +523,1 @@\n-                    throwMalformed(sp - 1, 1);\n+                    throwMalformed(offset - 1, 1);\n@@ -896,1 +525,1 @@\n-                putChar(dst, dp++, repl);\n+                putChar(dst, dp++, REPL);\n@@ -899,2 +528,39 @@\n-        if (dp != len) {\n-            dst = Arrays.copyOf(dst, dp << 1);\n+        return dp;\n+    }\n+\n+    static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length) {\n+        ByteBuffer bb = ByteBuffer.wrap(src, offset, length);\n+        CharBuffer cb = CharBuffer.wrap(dst, 0, dst.length);\n+        try {\n+            CoderResult cr = cd.decode(bb, cb, true);\n+            if (!cr.isUnderflow())\n+                cr.throwException();\n+            cr = cd.flush(cb);\n+            if (!cr.isUnderflow())\n+                cr.throwException();\n+        } catch (CharacterCodingException x) {\n+            \/\/ Substitution is always enabled,\n+            \/\/ so this shouldn't happen\n+            throw new Error(x);\n+        }\n+        return cb.position();\n+    }\n+\n+    \/\/ for nb == 3\/4\n+    static int malformedN(byte[] src, int sp, int nb) {\n+        if (nb == 3) {\n+            int b1 = src[sp++];\n+            int b2 = src[sp++];    \/\/ no need to lookup b3\n+            return ((b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n+                    isNotContinuation(b2)) ? 1 : 2;\n+        } else if (nb == 4) { \/\/ we don't care the speed here\n+            int b1 = src[sp++] & 0xff;\n+            int b2 = src[sp++] & 0xff;\n+            if (b1 > 0xf4 ||\n+                (b1 == 0xf0 && (b2 < 0x90 || b2 > 0xbf)) ||\n+                (b1 == 0xf4 && (b2 & 0xf0) != 0x80) ||\n+                isNotContinuation(b2))\n+                return 1;\n+            if (isNotContinuation(src[sp++]))\n+                return 2;\n+            return 3;\n@@ -902,1 +568,24 @@\n-        return ret.with(dst, UTF16);\n+        assert false;\n+        return -1;\n+    }\n+\n+    static void throwMalformed(int off, int nb) {\n+        String msg = \"malformed input off : \" + off + \", length : \" + nb;\n+        throw new IllegalArgumentException(msg, new MalformedInputException(nb));\n+    }\n+\n+    static void throwMalformed(byte[] val) {\n+        int dp = 0;\n+        while (dp < val.length && val[dp] >=0) { dp++; }\n+        throwMalformed(dp, 1);\n+    }\n+\n+    static void throwUnmappable(int off, int nb) {\n+        String msg = \"malformed input off : \" + off + \", length : \" + nb;\n+        throw new IllegalArgumentException(msg, new UnmappableCharacterException(nb));\n+    }\n+\n+    static void throwUnmappable(byte[] val) {\n+        int dp = 0;\n+        while (dp < val.length && val[dp] >=0) { dp++; }\n+        throwUnmappable(dp, 1);\n@@ -979,12 +668,0 @@\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ for j.u.z.ZipCoder \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-    \/*\n-     * Throws iae, instead of replacing, if malformed or unmappable.\n-     *\/\n-    static String newStringUTF8NoRepl(byte[] src, int off, int len) {\n-        if (COMPACT_STRINGS && !hasNegatives(src, off, len))\n-            return new String(Arrays.copyOfRange(src, off, off + len), LATIN1);\n-        Result ret = decodeUTF8_0(src, off, len, false);\n-        return new String(ret.value, ret.coder);\n-    }\n-\n@@ -1004,69 +681,0 @@\n-    private static String newStringLatin1(byte[] src) {\n-        if (COMPACT_STRINGS)\n-           return new String(src, LATIN1);\n-        return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n-    }\n-\n-    static String newStringNoRepl(byte[] src, Charset cs) throws CharacterCodingException {\n-        try {\n-            return newStringNoRepl1(src, cs);\n-        } catch (IllegalArgumentException e) {\n-            \/\/newStringNoRepl1 throws IAE with MalformedInputException or CCE as the cause\n-            Throwable cause = e.getCause();\n-            if (cause instanceof MalformedInputException) {\n-                throw (MalformedInputException)cause;\n-            }\n-            throw (CharacterCodingException)cause;\n-        }\n-    }\n-\n-    static String newStringNoRepl1(byte[] src, Charset cs) {\n-        if (cs == UTF_8) {\n-            if (COMPACT_STRINGS && isASCII(src))\n-                return new String(src, LATIN1);\n-            Result ret = decodeUTF8_0(src, 0, src.length, false);\n-            return new String(ret.value, ret.coder);\n-        }\n-        if (cs == ISO_8859_1) {\n-            return newStringLatin1(src);\n-        }\n-        if (cs == US_ASCII) {\n-            if (isASCII(src)) {\n-                return newStringLatin1(src);\n-            } else {\n-                throwMalformed(src);\n-            }\n-        }\n-\n-        CharsetDecoder cd = cs.newDecoder();\n-        \/\/ ascii fastpath\n-        if ((cd instanceof ArrayDecoder) &&\n-            ((ArrayDecoder)cd).isASCIICompatible() && isASCII(src)) {\n-            return newStringLatin1(src);\n-        }\n-        int len = src.length;\n-        if (len == 0) {\n-            return \"\";\n-        }\n-        int en = scale(len, cd.maxCharsPerByte());\n-        char[] ca = new char[en];\n-        if (cs.getClass().getClassLoader0() != null &&\n-            System.getSecurityManager() != null) {\n-            src = Arrays.copyOf(src, len);\n-        }\n-        ByteBuffer bb = ByteBuffer.wrap(src);\n-        CharBuffer cb = CharBuffer.wrap(ca);\n-        try {\n-            CoderResult cr = cd.decode(bb, cb, true);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-            cr = cd.flush(cb);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-        } catch (CharacterCodingException x) {\n-            throw new IllegalArgumentException(x);  \/\/ todo\n-        }\n-        Result ret = resultCached().with(ca, 0, cb.position());\n-        return new String(ret.value, ret.coder);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringCoding.java","additions":164,"deletions":556,"binary":false,"changes":720,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -2265,1 +2265,1 @@\n-                return StringCoding.newStringNoRepl(bytes, cs);\n+                return String.newStringNoRepl(bytes, cs);\n@@ -2273,1 +2273,1 @@\n-                return StringCoding.newStringUTF8NoRepl(bytes, off, len);\n+                return String.newStringUTF8NoRepl(bytes, off, len);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.nio.charset.Charset;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = \"-Xmx1g\")\n+@Warmup(iterations = 5, time = 2)\n+@Measurement(iterations = 5, time = 3)\n+@State(Scope.Thread)\n+public class StringDecode {\n+\n+    @BenchmarkMode(Mode.AverageTime)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    @Fork(value = 3, jvmArgs = \"-Xmx1g\")\n+    @Warmup(iterations = 5, time = 2)\n+    @Measurement(iterations = 5, time = 2)\n+    @State(Scope.Thread)\n+    public static class WithCharset {\n+\n+        @Param({\"US-ASCII\", \"ISO-8859-1\", \"UTF-8\", \"MS932\", \"ISO-8859-6\"})\n+        private String charsetName;\n+\n+        private Charset charset;\n+        private byte[] asciiString;\n+        private byte[] utf16String;\n+\n+        @Setup\n+        public void setup() {\n+            charset = Charset.forName(charsetName);\n+            asciiString = \"ascii string\".getBytes(charset);\n+            utf16String = \"UTF-\\uFF11\\uFF16 string\".getBytes(charset);\n+        }\n+\n+        @Benchmark\n+        public void decodeCharsetName(Blackhole bh) throws Exception {\n+            bh.consume(new String(asciiString, charsetName));\n+            bh.consume(new String(utf16String, charsetName));\n+        }\n+\n+        @Benchmark\n+        public void decodeCharset(Blackhole bh) throws Exception {\n+            bh.consume(new String(asciiString, charset));\n+            bh.consume(new String(utf16String, charset));\n+        }\n+    }\n+\n+    private byte[] asciiDefaultString;\n+    private byte[] utf16DefaultString;\n+\n+    @Setup\n+    public void setup() {\n+        asciiDefaultString = \"ascii string\".getBytes();\n+        utf16DefaultString = \"UTF-\\uFF11\\uFF16 string\".getBytes();\n+    }\n+\n+    @Benchmark\n+    public void decodeDefault(Blackhole bh) throws Exception {\n+        bh.consume(new String(asciiDefaultString));\n+        bh.consume(new String(utf16DefaultString));\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringDecode.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"}]}