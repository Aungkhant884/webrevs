{"files":[{"patch":"@@ -31,6 +31,0 @@\n-#include \"opto\/node.hpp\"\n-#include \"opto\/connode.hpp\"\n-#include \"opto\/divnode.hpp\"\n-#include \"opto\/subnode.hpp\"\n-#include \"opto\/cfgnode.hpp\"\n-#include \"opto\/phase.hpp\"\n@@ -39,2 +33,0 @@\n-static void parse_div_mod(Parse& parser);\n-\n@@ -47,1 +39,1 @@\n-      parse_div_mod(parser);\n+      parser.do_divmod_fixup();\n@@ -54,72 +46,0 @@\n-static void parse_div_mod(Parse& parser) {\n-  Bytecodes::Code bc = parser.bc();\n-  PhaseGVN& gvn = parser.gvn();\n-  BasicType bt = (bc == Bytecodes::_idiv || bc == Bytecodes::_irem) ? T_INT : T_LONG;\n-  \/\/ Operands need to stay in the stack during zero check\n-  if (bt == T_INT) {\n-    parser.zero_check_int(parser.peek(0));\n-  } else {\n-    parser.zero_check_long(parser.peek(1));\n-  }\n-  \/\/ Compile-time detection of arithmetic exception\n-  if (parser.stopped()) {\n-    return;\n-  }\n-\n-  Node* in2 = (bt == T_INT) ? parser.pop() : parser.pop_pair();\n-  Node* in1 = (bt == T_INT) ? parser.pop() : parser.pop_pair();\n-\n-  auto generate_division = [](PhaseGVN& gvn, Node* control, Node* in1, Node* in2,\n-                              Bytecodes::Code bc) {\n-    switch (bc) {\n-      case Bytecodes::_idiv: return gvn.transform(new DivINode(control, in1, in2));\n-      case Bytecodes::_ldiv: return gvn.transform(new DivLNode(control, in1, in2));\n-      case Bytecodes::_irem: return gvn.transform(new ModINode(control, in1, in2));\n-      case Bytecodes::_lrem: return gvn.transform(new ModLNode(control, in1, in2));\n-      default:\n-        ShouldNotReachHere();\n-        return static_cast<Node*>(nullptr);\n-    }\n-  };\n-\n-  auto push_result = [](Parse& parser, Node* res, BasicType bt) {\n-    if (bt == T_INT) {\n-      parser.push(res);\n-    } else {\n-      parser.push_pair(res);\n-    }\n-  };\n-\n-  \/\/ No overflow possibility here\n-  if ((in1 == in2) ||\n-      (bt == T_INT  &&  !TypeInt::MIN->higher_equal(gvn.type(in1))) ||\n-      (bt == T_LONG && !TypeLong::MIN->higher_equal(gvn.type(in1)))) {\n-    Node* res = generate_division(gvn, parser.control(), in1, in2, bc);\n-    push_result(parser, res, bt);\n-    return;\n-  }\n-\n-  \/\/ The generated graph is equivalent to (in2 == -1) ? -in1 : (in1 \/ in2)\n-  \/\/ we need to have a separate branch for in2 == -1 due to overflow error\n-  \/\/ with (min_jint \/ -1) on x86\n-  Node* cmp = gvn.transform(CmpNode::make(in2, gvn.integercon(-1, bt), bt));\n-  Node* bol = parser.Bool(cmp, BoolTest::eq);\n-  IfNode* iff = parser.create_and_map_if(parser.control(), bol, PROB_UNLIKELY_MAG(3), COUNT_UNKNOWN);\n-  Node* iff_true = parser.IfTrue(iff);\n-  Node* iff_false = parser.IfFalse(iff);\n-  Node* res_fast = (bc == Bytecodes::_idiv || bc == Bytecodes::_ldiv)\n-                   ? gvn.transform(SubNode::make(gvn.zerocon(bt), in1, bt))\n-                   : gvn.zerocon(bt);\n-  Node* res_slow = generate_division(gvn, iff_false, in1, in2, bc);\n-  Node* merge = new RegionNode(3);\n-  merge->init_req(1, iff_true);\n-  merge->init_req(2, iff_false);\n-  parser.record_for_igvn(merge);\n-  parser.set_control(gvn.transform(merge));\n-  Node* res = new PhiNode(merge, Type::get_const_basic_type(bt));\n-  res->init_req(1, res_fast);\n-  res->init_req(2, res_slow);\n-  res = gvn.transform(res);\n-  push_result(parser, res, bt);\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.cpp","additions":1,"deletions":81,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -417,0 +417,4 @@\n+  \/\/ implementation of div\/rem bytecodes for handling of special case\n+  \/\/ min_jint \/ -1, called from Matcher::parse_one_bytecode\n+  void do_divmod_fixup();\n+\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -436,0 +436,74 @@\n+\n+\/\/ On some architectures, a division cannot be done immediately due to\n+\/\/ the special case with min_jint \/ -1. As a result, we need to have\n+\/\/ special handling for the this case\n+void Parse::do_divmod_fixup() {\n+  Bytecodes::Code bc = this->bc();\n+  BasicType bt = (bc == Bytecodes::_idiv || bc == Bytecodes::_irem) ? T_INT : T_LONG;\n+  \/\/ Operands need to stay in the stack during zero check\n+  if (bt == T_INT) {\n+    zero_check_int(peek(0));\n+  } else {\n+    zero_check_long(peek(1));\n+  }\n+  \/\/ Compile-time detection of arithmetic exception\n+  if (stopped()) {\n+    return;\n+  }\n+\n+  Node* in2 = (bt == T_INT) ? pop() : pop_pair();\n+  Node* in1 = (bt == T_INT) ? pop() : pop_pair();\n+\n+  auto generate_division = [](PhaseGVN& gvn, Node* control, Node* in1, Node* in2,\n+                              Bytecodes::Code bc) {\n+    switch (bc) {\n+      case Bytecodes::_idiv: return gvn.transform(new DivINode(control, in1, in2));\n+      case Bytecodes::_ldiv: return gvn.transform(new DivLNode(control, in1, in2));\n+      case Bytecodes::_irem: return gvn.transform(new ModINode(control, in1, in2));\n+      case Bytecodes::_lrem: return gvn.transform(new ModLNode(control, in1, in2));\n+      default:\n+        ShouldNotReachHere();\n+        return static_cast<Node*>(nullptr);\n+    }\n+  };\n+\n+  auto push_result = [](Parse& parser, Node* res, BasicType bt) {\n+    if (bt == T_INT) {\n+      parser.push(res);\n+    } else {\n+      parser.push_pair(res);\n+    }\n+  };\n+\n+  \/\/ No overflow possibility here\n+  if ((in1 == in2) ||\n+      (bt == T_INT  &&  !TypeInt::MIN->higher_equal(_gvn.type(in1))) ||\n+      (bt == T_LONG && !TypeLong::MIN->higher_equal(_gvn.type(in1)))) {\n+    Node* res = generate_division(_gvn, control(), in1, in2, bc);\n+    push_result(*this, res, bt);\n+    return;\n+  }\n+\n+  \/\/ The generated graph is equivalent to (in2 == -1) ? -in1 : (in1 \/ in2)\n+  \/\/ we need to have a separate branch for in2 == -1 due to the special\n+  \/\/ case of min_jint \/ -1\n+  Node* cmp = _gvn.transform(CmpNode::make(in2, _gvn.integercon(-1, bt), bt));\n+  Node* bol = Bool(cmp, BoolTest::eq);\n+  IfNode* iff = create_and_map_if(control(), bol, PROB_UNLIKELY_MAG(3), COUNT_UNKNOWN);\n+  Node* iff_true = IfTrue(iff);\n+  Node* iff_false = IfFalse(iff);\n+  Node* res_fast = (bc == Bytecodes::_idiv || bc == Bytecodes::_ldiv)\n+                   ? _gvn.transform(SubNode::make(_gvn.zerocon(bt), in1, bt))\n+                   : _gvn.zerocon(bt);\n+  Node* res_slow = generate_division(_gvn, iff_false, in1, in2, bc);\n+  Node* merge = new RegionNode(3);\n+  merge->init_req(1, iff_true);\n+  merge->init_req(2, iff_false);\n+  record_for_igvn(merge);\n+  set_control(_gvn.transform(merge));\n+  Node* res = new PhiNode(merge, Type::get_const_basic_type(bt));\n+  res->init_req(1, res_fast);\n+  res->init_req(2, res_slow);\n+  res = _gvn.transform(res);\n+  push_result(*this, res, bt);\n+}\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"}]}