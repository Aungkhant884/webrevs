{"files":[{"patch":"@@ -7759,1 +7759,1 @@\n-  match(Set rax (NODivI rax div));\n+  match(Set rax (NoOvfDivI rax div));\n@@ -7774,1 +7774,1 @@\n-  match(Set dst (NODivL src1 src2));\n+  match(Set dst (NoOvfDivL src1 src2));\n@@ -7789,1 +7789,1 @@\n-  match(NODivModI rax div);\n+  match(NoOvfDivModI rax div);\n@@ -7804,1 +7804,1 @@\n-  match(Set rdx (NOModI rax div));\n+  match(Set rdx (NoOvfModI rax div));\n@@ -7820,1 +7820,1 @@\n-  match(Set dst (NOModL src1 src2));\n+  match(Set dst (NoOvfModL src1 src2));\n@@ -7833,0 +7833,138 @@\n+\/\/ Divide Register Long (no special case since divisor != -1)\n+instruct divL_eReg_imm32( eADXRegL dst, immL32 imm, rRegI tmp, rRegI tmp2, eFlagsReg cr ) %{\n+  match(Set dst (DivL dst imm));\n+  effect( TEMP tmp, TEMP tmp2, KILL cr );\n+  ins_cost(1000);\n+  format %{ \"MOV    $tmp,abs($imm) # ldiv EDX:EAX,$imm\\n\\t\"\n+            \"XOR    $tmp2,$tmp2\\n\\t\"\n+            \"CMP    $tmp,EDX\\n\\t\"\n+            \"JA,s   fast\\n\\t\"\n+            \"MOV    $tmp2,EAX\\n\\t\"\n+            \"MOV    EAX,EDX\\n\\t\"\n+            \"MOV    EDX,0\\n\\t\"\n+            \"JLE,s  pos\\n\\t\"\n+            \"LNEG   EAX : $tmp2\\n\\t\"\n+            \"DIV    $tmp # unsigned division\\n\\t\"\n+            \"XCHG   EAX,$tmp2\\n\\t\"\n+            \"DIV    $tmp\\n\\t\"\n+            \"LNEG   $tmp2 : EAX\\n\\t\"\n+            \"JMP,s  done\\n\"\n+    \"pos:\\n\\t\"\n+            \"DIV    $tmp\\n\\t\"\n+            \"XCHG   EAX,$tmp2\\n\"\n+    \"fast:\\n\\t\"\n+            \"DIV    $tmp\\n\"\n+    \"done:\\n\\t\"\n+            \"MOV    EDX,$tmp2\\n\\t\"\n+            \"NEG    EDX:EAX # if $imm < 0\" %}\n+  ins_encode %{\n+    int con = (int)$imm$$constant;\n+    assert(con != 0 && con != -1 && con != min_jint, \"wrong divisor\");\n+    int pcon = (con > 0) ? con : -con;\n+    Label Lfast, Lpos, Ldone;\n+\n+    __ movl($tmp$$Register, pcon);\n+    __ xorl($tmp2$$Register,$tmp2$$Register);\n+    __ cmpl($tmp$$Register, HIGH_FROM_LOW($dst$$Register));\n+    __ jccb(Assembler::above, Lfast); \/\/ result fits into 32 bit\n+\n+    __ movl($tmp2$$Register, $dst$$Register); \/\/ save\n+    __ movl($dst$$Register, HIGH_FROM_LOW($dst$$Register));\n+    __ movl(HIGH_FROM_LOW($dst$$Register),0); \/\/ preserve flags\n+    __ jccb(Assembler::lessEqual, Lpos); \/\/ result is positive\n+\n+    \/\/ Negative dividend.\n+    \/\/ convert value to positive to use unsigned division\n+    __ lneg($dst$$Register, $tmp2$$Register);\n+    __ divl($tmp$$Register);\n+    __ xchgl($dst$$Register, $tmp2$$Register);\n+    __ divl($tmp$$Register);\n+    \/\/ revert result back to negative\n+    __ lneg($tmp2$$Register, $dst$$Register);\n+    __ jmpb(Ldone);\n+\n+    __ bind(Lpos);\n+    __ divl($tmp$$Register); \/\/ Use unsigned division\n+    __ xchgl($dst$$Register, $tmp2$$Register);\n+    \/\/ Fallthrow for final divide, tmp2 has 32 bit hi result\n+\n+    __ bind(Lfast);\n+    \/\/ fast path: src is positive\n+    __ divl($tmp$$Register); \/\/ Use unsigned division\n+\n+    __ bind(Ldone);\n+    __ movl(HIGH_FROM_LOW($dst$$Register),$tmp2$$Register);\n+    if (con < 0) {\n+      __ lneg(HIGH_FROM_LOW($dst$$Register), $dst$$Register);\n+    }\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ Remainder Register Long (remainder fit into 32 bits)\n+instruct modL_eReg_imm32( eADXRegL dst, immL32 imm, rRegI tmp, rRegI tmp2, eFlagsReg cr ) %{\n+  match(Set dst (ModL dst imm));\n+  effect( TEMP tmp, TEMP tmp2, KILL cr );\n+  ins_cost(1000);\n+  format %{ \"MOV    $tmp,abs($imm) # lrem EDX:EAX,$imm\\n\\t\"\n+            \"CMP    $tmp,EDX\\n\\t\"\n+            \"JA,s   fast\\n\\t\"\n+            \"MOV    $tmp2,EAX\\n\\t\"\n+            \"MOV    EAX,EDX\\n\\t\"\n+            \"MOV    EDX,0\\n\\t\"\n+            \"JLE,s  pos\\n\\t\"\n+            \"LNEG   EAX : $tmp2\\n\\t\"\n+            \"DIV    $tmp # unsigned division\\n\\t\"\n+            \"MOV    EAX,$tmp2\\n\\t\"\n+            \"DIV    $tmp\\n\\t\"\n+            \"NEG    EDX\\n\\t\"\n+            \"JMP,s  done\\n\"\n+    \"pos:\\n\\t\"\n+            \"DIV    $tmp\\n\\t\"\n+            \"MOV    EAX,$tmp2\\n\"\n+    \"fast:\\n\\t\"\n+            \"DIV    $tmp\\n\"\n+    \"done:\\n\\t\"\n+            \"MOV    EAX,EDX\\n\\t\"\n+            \"SAR    EDX,31\\n\\t\" %}\n+  ins_encode %{\n+    int con = (int)$imm$$constant;\n+    assert(con != 0 && con != -1 && con != min_jint, \"wrong divisor\");\n+    int pcon = (con > 0) ? con : -con;\n+    Label  Lfast, Lpos, Ldone;\n+\n+    __ movl($tmp$$Register, pcon);\n+    __ cmpl($tmp$$Register, HIGH_FROM_LOW($dst$$Register));\n+    __ jccb(Assembler::above, Lfast); \/\/ src is positive and result fits into 32 bit\n+\n+    __ movl($tmp2$$Register, $dst$$Register); \/\/ save\n+    __ movl($dst$$Register, HIGH_FROM_LOW($dst$$Register));\n+    __ movl(HIGH_FROM_LOW($dst$$Register),0); \/\/ preserve flags\n+    __ jccb(Assembler::lessEqual, Lpos); \/\/ result is positive\n+\n+    \/\/ Negative dividend.\n+    \/\/ convert value to positive to use unsigned division\n+    __ lneg($dst$$Register, $tmp2$$Register);\n+    __ divl($tmp$$Register);\n+    __ movl($dst$$Register, $tmp2$$Register);\n+    __ divl($tmp$$Register);\n+    \/\/ revert remainder back to negative\n+    __ negl(HIGH_FROM_LOW($dst$$Register));\n+    __ jmpb(Ldone);\n+\n+    __ bind(Lpos);\n+    __ divl($tmp$$Register);\n+    __ movl($dst$$Register, $tmp2$$Register);\n+\n+    __ bind(Lfast);\n+    \/\/ fast path: src is positive\n+    __ divl($tmp$$Register);\n+\n+    __ bind(Ldone);\n+    __ movl($dst$$Register, HIGH_FROM_LOW($dst$$Register));\n+    __ sarl(HIGH_FROM_LOW($dst$$Register), 31); \/\/ result sign\n+\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":143,"deletions":5,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -8554,1 +8554,1 @@\n-  match(Set rax (NODivI rax div));\n+  match(Set rax (NoOvfDivI rax div));\n@@ -8570,1 +8570,1 @@\n-  match(Set rax (NODivI rax (LoadI div)));\n+  match(Set rax (NoOvfDivI rax (LoadI div)));\n@@ -8586,1 +8586,1 @@\n-  match(Set rax (NODivL rax div));\n+  match(Set rax (NoOvfDivL rax div));\n@@ -8602,1 +8602,1 @@\n-  match(Set rax (NODivL rax (LoadL div)));\n+  match(Set rax (NoOvfDivL rax (LoadL div)));\n@@ -8645,1 +8645,1 @@\n-  match(NODivModI rax div);\n+  match(NoOvfDivModI rax div);\n@@ -8662,1 +8662,1 @@\n-  match(NODivModL rax div);\n+  match(NoOvfDivModL rax div);\n@@ -8712,1 +8712,1 @@\n-  match(Set rdx (NOModI rax div));\n+  match(Set rdx (NoOvfModI rax div));\n@@ -8728,1 +8728,1 @@\n-  match(Set rdx (NOModI rax (LoadI div)));\n+  match(Set rdx (NoOvfModI rax (LoadI div)));\n@@ -8744,1 +8744,1 @@\n-  match(Set rdx (NOModL rax div));\n+  match(Set rdx (NoOvfModL rax div));\n@@ -8760,1 +8760,1 @@\n-  match(Set rdx (NOModL rax (LoadL div)));\n+  match(Set rdx (NoOvfModL rax (LoadL div)));\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -165,2 +165,2 @@\n-macro(NODivI)\n-macro(NODivL)\n+macro(NoOvfDivI)\n+macro(NoOvfDivL)\n@@ -172,2 +172,2 @@\n-macro(NODivModI)\n-macro(NODivModL)\n+macro(NoOvfDivModI)\n+macro(NoOvfDivModL)\n@@ -242,2 +242,2 @@\n-macro(NOModI)\n-macro(NOModL)\n+macro(NoOvfModI)\n+macro(NoOvfModL)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3532,1 +3532,1 @@\n-  case Op_NOModI:\n+  case Op_NoOvfModI:\n@@ -3535,1 +3535,1 @@\n-      Node* d = n->find_similar(Op_NODivI);\n+      Node* d = n->find_similar(Op_NoOvfDivI);\n@@ -3538,2 +3538,2 @@\n-        if (Matcher::has_match_rule(Op_NODivModI)) {\n-          NODivModINode* divmod = NODivModINode::make(n);\n+        if (Matcher::has_match_rule(Op_NoOvfDivModI)) {\n+          NoOvfDivModINode* divmod = NoOvfDivModINode::make(n);\n@@ -3552,1 +3552,1 @@\n-  case Op_NOModL:\n+  case Op_NoOvfModL:\n@@ -3555,1 +3555,1 @@\n-      Node* d = n->find_similar(Op_NODivL);\n+      Node* d = n->find_similar(Op_NoOvfDivL);\n@@ -3558,2 +3558,2 @@\n-        if (Matcher::has_match_rule(Op_NODivModL)) {\n-          NODivModLNode* divmod = NODivModLNode::make(n);\n+        if (Matcher::has_match_rule(Op_NoOvfDivModL)) {\n+          NoOvfDivModLNode* divmod = NoOvfDivModLNode::make(n);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1471,1 +1471,1 @@\n-NODivModINode* NODivModINode::make(Node* div_or_mod) {\n+NoOvfDivModINode* NoOvfDivModINode::make(Node* div_or_mod) {\n@@ -1473,1 +1473,1 @@\n-  assert(n->Opcode() == Op_NODivI || n->Opcode() == Op_NOModI,\n+  assert(n->Opcode() == Op_NoOvfDivI || n->Opcode() == Op_NoOvfModI,\n@@ -1476,1 +1476,1 @@\n-  NODivModINode* divmod = new NODivModINode(n->in(0), n->in(1), n->in(2));\n+  NoOvfDivModINode* divmod = new NoOvfDivModINode(n->in(0), n->in(1), n->in(2));\n@@ -1483,1 +1483,1 @@\n-NODivModLNode* NODivModLNode::make(Node* div_or_mod) {\n+NoOvfDivModLNode* NoOvfDivModLNode::make(Node* div_or_mod) {\n@@ -1485,1 +1485,1 @@\n-  assert(n->Opcode() == Op_NODivL || n->Opcode() == Op_NOModL,\n+  assert(n->Opcode() == Op_NoOvfDivL || n->Opcode() == Op_NoOvfModL,\n@@ -1488,1 +1488,1 @@\n-  NODivModLNode* divmod = new NODivModLNode(n->in(0), n->in(1), n->in(2));\n+  NoOvfDivModLNode* divmod = new NoOvfDivModLNode(n->in(0), n->in(1), n->in(2));\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -106,18 +106,0 @@\n-\/\/-----------------------------NODivINode--------------------------------------\n-\/\/ Non-overflow integer division, UB when dividend == min_jint and divisor == -1\n-\/\/ so user has to ensure this combination does not appear\n-class NODivINode : public DivINode {\n-public:\n-  NODivINode( Node *c, Node *dividend, Node *divisor ) : DivINode(c, dividend, divisor ) {}\n-  virtual int Opcode() const;\n-};\n-\n-\/\/-----------------------------NODivLNode--------------------------------------\n-\/\/ Non-overflow long division, UB when dividend == min_jlong and divisor == -1\n-\/\/ so user has to ensure this combination does not appear\n-class NODivLNode : public DivLNode {\n-public:\n-  NODivLNode( Node *c, Node *dividend, Node *divisor ) : DivLNode(c, dividend, divisor ) {}\n-  virtual int Opcode() const;\n-};\n-\n@@ -137,0 +119,18 @@\n+\/\/---------------------------NoOvfDivINode-------------------------------------\n+\/\/ Non-overflow integer division, UB when dividend == min_jint and divisor == -1\n+\/\/ so user has to ensure this combination does not appear\n+class NoOvfDivINode : public DivINode {\n+public:\n+  NoOvfDivINode( Node *c, Node *dividend, Node *divisor ) : DivINode(c, dividend, divisor ) {}\n+  virtual int Opcode() const;\n+};\n+\n+\/\/---------------------------NoOvfDivLNode-------------------------------------\n+\/\/ Non-overflow long division, UB when dividend == min_jlong and divisor == -1\n+\/\/ so user has to ensure this combination does not appear\n+class NoOvfDivLNode : public DivLNode {\n+public:\n+  NoOvfDivLNode( Node *c, Node *dividend, Node *divisor ) : DivLNode(c, dividend, divisor ) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -205,1 +205,1 @@\n-\/\/-----------------------------NOModINode--------------------------------------\n+\/\/---------------------------NoOvfModINode-------------------------------------\n@@ -208,1 +208,1 @@\n-class NOModINode : public ModINode {\n+class NoOvfModINode : public ModINode {\n@@ -210,1 +210,1 @@\n-  NOModINode( Node *c, Node *dividend, Node *divisor ) : ModINode(c, dividend, divisor ) {}\n+  NoOvfModINode( Node *c, Node *dividend, Node *divisor ) : ModINode(c, dividend, divisor ) {}\n@@ -214,1 +214,1 @@\n-\/\/-----------------------------NOModLNode--------------------------------------\n+\/\/---------------------------NoOvfModLNode-------------------------------------\n@@ -217,1 +217,1 @@\n-class NOModLNode : public ModLNode {\n+class NoOvfModLNode : public ModLNode {\n@@ -219,1 +219,1 @@\n-  NOModLNode( Node *c, Node *dividend, Node *divisor ) : ModLNode(c, dividend, divisor ) {}\n+  NoOvfModLNode( Node *c, Node *dividend, Node *divisor ) : ModLNode(c, dividend, divisor ) {}\n@@ -298,1 +298,1 @@\n-\/\/----------------------------NODivModINode------------------------------------\n+\/\/---------------------------NoOvfDivModINode----------------------------------\n@@ -301,1 +301,1 @@\n-class NODivModINode : public DivModINode {\n+class NoOvfDivModINode : public DivModINode {\n@@ -303,1 +303,1 @@\n-  NODivModINode( Node *c, Node *dividend, Node *divisor ) : DivModINode(c, dividend, divisor) {}\n+  NoOvfDivModINode( Node *c, Node *dividend, Node *divisor ) : DivModINode(c, dividend, divisor) {}\n@@ -307,1 +307,1 @@\n-  static NODivModINode* make(Node* div_or_mod);\n+  static NoOvfDivModINode* make(Node* div_or_mod);\n@@ -310,1 +310,1 @@\n-\/\/----------------------------NODivModLNode------------------------------------\n+\/\/---------------------------NoOvfDivModLNode----------------------------------\n@@ -313,1 +313,1 @@\n-class NODivModLNode : public DivModLNode {\n+class NoOvfDivModLNode : public DivModLNode {\n@@ -315,1 +315,1 @@\n-  NODivModLNode( Node *c, Node *dividend, Node *divisor ) : DivModLNode(c, dividend, divisor) {}\n+  NoOvfDivModLNode( Node *c, Node *dividend, Node *divisor ) : DivModLNode(c, dividend, divisor) {}\n@@ -319,1 +319,1 @@\n-  static NODivModLNode* make(Node* div_or_mod);\n+  static NoOvfDivModLNode* make(Node* div_or_mod);\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -460,4 +460,4 @@\n-      case Bytecodes::_idiv: return gvn.transform(new NODivINode(control, in1, in2));\n-      case Bytecodes::_ldiv: return gvn.transform(new NODivLNode(control, in1, in2));\n-      case Bytecodes::_irem: return gvn.transform(new NOModINode(control, in1, in2));\n-      case Bytecodes::_lrem: return gvn.transform(new NOModLNode(control, in1, in2));\n+      case Bytecodes::_idiv: return gvn.transform(new NoOvfDivINode(control, in1, in2));\n+      case Bytecodes::_ldiv: return gvn.transform(new NoOvfDivLNode(control, in1, in2));\n+      case Bytecodes::_irem: return gvn.transform(new NoOvfModINode(control, in1, in2));\n+      case Bytecodes::_lrem: return gvn.transform(new NoOvfModLNode(control, in1, in2));\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1584,2 +1584,2 @@\n-  declare_c2_type(NODivINode, DivINode)                                   \\\n-  declare_c2_type(NODivLNode, DivLNode)                                   \\\n+  declare_c2_type(NoOvfDivINode, DivINode)                                \\\n+  declare_c2_type(NoOvfDivLNode, DivLNode)                                \\\n@@ -1592,2 +1592,2 @@\n-  declare_c2_type(NOModINode, ModINode)                                   \\\n-  declare_c2_type(NOModLNode, ModLNode)                                   \\\n+  declare_c2_type(NoOvfModINode, ModINode)                                \\\n+  declare_c2_type(NoOvfModLNode, ModLNode)                                \\\n@@ -1599,2 +1599,2 @@\n-  declare_c2_type(NODivModINode, DivModINode)                             \\\n-  declare_c2_type(NODivModLNode, DivModLNode)                             \\\n+  declare_c2_type(NoOvfDivModINode, DivModINode)                          \\\n+  declare_c2_type(NoOvfDivModLNode, DivModLNode)                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -172,2 +172,2 @@\n-    public static final String DIV = START + \"(NO)?Div(I|L|F|D)\" + MID + END;\n-    public static final String DIV_L = START + \"(NO)?DivL\" + MID + END;\n+    public static final String DIV = START + \"(NoOvf)?Div(I|L|F|D)\" + MID + END;\n+    public static final String DIV_L = START + \"(NoOvf)?DivL\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}