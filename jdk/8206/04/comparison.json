{"files":[{"patch":"@@ -2797,0 +2797,4 @@\n+}\n+\n+bool Parse::do_one_bytecode_targeted() {\n+  return false;\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1162,0 +1162,4 @@\n+bool Parse::do_one_bytecode_targeted() {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2410,0 +2410,4 @@\n+bool Parse::do_one_bytecode_targeted() {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2047,0 +2047,4 @@\n+bool Parse::do_one_bytecode_targeted() {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1701,0 +1701,4 @@\n+bool Parse::do_one_bytecode_targeted() {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2238,0 +2238,7 @@\n+void Assembler::idivl(Address src) {\n+  InstructionMark im(this);\n+  prefix(src);\n+  emit_int8((unsigned char)0xF7);\n+  emit_operand(as_Register(7), src);\n+}\n+\n@@ -12369,0 +12376,7 @@\n+void Assembler::idivq(Address src) {\n+  InstructionMark im(this);\n+  prefixq(src);\n+  emit_int8((unsigned char)0xF7);\n+  emit_operand(as_Register(7), src);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1199,0 +1199,3 @@\n+  void divl(Register src);\n+  void divq(Register src);\n+\n@@ -1367,3 +1370,1 @@\n-  void divl(Register src); \/\/ Unsigned division\n-\n-#ifdef _LP64\n+  void idivl(Address src);\n@@ -1371,2 +1372,1 @@\n-  void divq(Register src); \/\/ Unsigned division\n-#endif\n+  void idivq(Address src);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#ifdef COMPILER2\n+\n+#include \"opto\/parse.hpp\"\n+#include \"interpreter\/bytecodes.hpp\"\n+\n+bool Parse::do_one_bytecode_targeted() {\n+  switch (bc()) {\n+    case Bytecodes::_idiv: \/\/ fallthrough\n+    case Bytecodes::_ldiv: \/\/ fallthrough\n+    case Bytecodes::_irem: \/\/ fallthrough\n+    case Bytecodes::_lrem:\n+      do_divmod_fixup();\n+      return true;\n+    default:\n+      return false;\n+  }\n+}\n+\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/x86\/parse_x86.cpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -1559,41 +1559,0 @@\n-  enc_class cdq_enc %{\n-    \/\/ Full implementation of Java idiv and irem; checks for\n-    \/\/ special case as described in JVM spec., p.243 & p.271.\n-    \/\/\n-    \/\/         normal case                           special case\n-    \/\/\n-    \/\/ input : rax,: dividend                         min_int\n-    \/\/         reg: divisor                          -1\n-    \/\/\n-    \/\/ output: rax,: quotient  (= rax, idiv reg)       min_int\n-    \/\/         rdx: remainder (= rax, irem reg)       0\n-    \/\/\n-    \/\/  Code sequnce:\n-    \/\/\n-    \/\/  81 F8 00 00 00 80    cmp         rax,80000000h\n-    \/\/  0F 85 0B 00 00 00    jne         normal_case\n-    \/\/  33 D2                xor         rdx,edx\n-    \/\/  83 F9 FF             cmp         rcx,0FFh\n-    \/\/  0F 84 03 00 00 00    je          done\n-    \/\/                  normal_case:\n-    \/\/  99                   cdq\n-    \/\/  F7 F9                idiv        rax,ecx\n-    \/\/                  done:\n-    \/\/\n-    emit_opcode(cbuf,0x81); emit_d8(cbuf,0xF8);\n-    emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);\n-    emit_opcode(cbuf,0x00); emit_d8(cbuf,0x80);                     \/\/ cmp rax,80000000h\n-    emit_opcode(cbuf,0x0F); emit_d8(cbuf,0x85);\n-    emit_opcode(cbuf,0x0B); emit_d8(cbuf,0x00);\n-    emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);                     \/\/ jne normal_case\n-    emit_opcode(cbuf,0x33); emit_d8(cbuf,0xD2);                     \/\/ xor rdx,edx\n-    emit_opcode(cbuf,0x83); emit_d8(cbuf,0xF9); emit_d8(cbuf,0xFF); \/\/ cmp rcx,0FFh\n-    emit_opcode(cbuf,0x0F); emit_d8(cbuf,0x84);\n-    emit_opcode(cbuf,0x03); emit_d8(cbuf,0x00);\n-    emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);                     \/\/ je done\n-    \/\/ normal_case:\n-    emit_opcode(cbuf,0x99);                                         \/\/ cdq\n-    \/\/ idiv (note: must be emitted by the user of this rule)\n-    \/\/ normal:\n-  %}\n-\n@@ -7800,1 +7759,1 @@\n-  match(Set rax (DivI rax div));\n+  match(Set rax (NODivI rax div));\n@@ -7802,13 +7761,9 @@\n-  size(26);\n-  ins_cost(30*100+10*100);\n-  format %{ \"CMP    EAX,0x80000000\\n\\t\"\n-            \"JNE,s  normal\\n\\t\"\n-            \"XOR    EDX,EDX\\n\\t\"\n-            \"CMP    ECX,-1\\n\\t\"\n-            \"JE,s   done\\n\"\n-    \"normal: CDQ\\n\\t\"\n-            \"IDIV   $div\\n\\t\"\n-    \"done:\"        %}\n-  opcode(0xF7, 0x7);  \/* Opcode F7 \/7 *\/\n-  ins_encode( cdq_enc, OpcP, RegOpc(div) );\n-  ins_pipe( ialu_reg_reg_alu0 );\n+  size(3);\n+  ins_cost(500);\n+  format %{ \"CDQ\\n\\t\"\n+            \"IDIV   $div\" %}\n+  ins_encode %{\n+    __ cdql();\n+    __ idivl($div$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n@@ -7819,1 +7774,1 @@\n-  match(Set dst (DivL src1 src2));\n+  match(Set dst (NODivL src1 src2));\n@@ -7834,1 +7789,1 @@\n-  match(DivModI rax div);\n+  match(NODivModI rax div);\n@@ -7836,12 +7791,8 @@\n-  size(26);\n-  ins_cost(30*100+10*100);\n-  format %{ \"CMP    EAX,0x80000000\\n\\t\"\n-            \"JNE,s  normal\\n\\t\"\n-            \"XOR    EDX,EDX\\n\\t\"\n-            \"CMP    ECX,-1\\n\\t\"\n-            \"JE,s   done\\n\"\n-    \"normal: CDQ\\n\\t\"\n-            \"IDIV   $div\\n\\t\"\n-    \"done:\"        %}\n-  opcode(0xF7, 0x7);  \/* Opcode F7 \/7 *\/\n-  ins_encode( cdq_enc, OpcP, RegOpc(div) );\n+  size(3);\n+  ins_cost(500);\n+  format %{ \"CDQ\\n\\t\"\n+            \"IDIV   $div\" %}\n+  ins_encode %{\n+    __ cdql();\n+    __ idivl($div$$Register);\n+  %}\n@@ -7853,1 +7804,1 @@\n-  match(Set rdx (ModI rax div));\n+  match(Set rdx (NOModI rax div));\n@@ -7856,2 +7807,2 @@\n-  size(26);\n-  ins_cost(300);\n+  size(3);\n+  ins_cost(500);\n@@ -7860,3 +7811,5 @@\n-  opcode(0xF7, 0x7);  \/* Opcode F7 \/7 *\/\n-  ins_encode( cdq_enc, OpcP, RegOpc(div) );\n-  ins_pipe( ialu_reg_reg_alu0 );\n+  ins_encode %{\n+    __ cdql();\n+    __ idivl($div$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n@@ -7867,1 +7820,1 @@\n-  match(Set dst (ModL src1 src2));\n+  match(Set dst (NOModL src1 src2));\n@@ -7880,138 +7833,0 @@\n-\/\/ Divide Register Long (no special case since divisor != -1)\n-instruct divL_eReg_imm32( eADXRegL dst, immL32 imm, rRegI tmp, rRegI tmp2, eFlagsReg cr ) %{\n-  match(Set dst (DivL dst imm));\n-  effect( TEMP tmp, TEMP tmp2, KILL cr );\n-  ins_cost(1000);\n-  format %{ \"MOV    $tmp,abs($imm) # ldiv EDX:EAX,$imm\\n\\t\"\n-            \"XOR    $tmp2,$tmp2\\n\\t\"\n-            \"CMP    $tmp,EDX\\n\\t\"\n-            \"JA,s   fast\\n\\t\"\n-            \"MOV    $tmp2,EAX\\n\\t\"\n-            \"MOV    EAX,EDX\\n\\t\"\n-            \"MOV    EDX,0\\n\\t\"\n-            \"JLE,s  pos\\n\\t\"\n-            \"LNEG   EAX : $tmp2\\n\\t\"\n-            \"DIV    $tmp # unsigned division\\n\\t\"\n-            \"XCHG   EAX,$tmp2\\n\\t\"\n-            \"DIV    $tmp\\n\\t\"\n-            \"LNEG   $tmp2 : EAX\\n\\t\"\n-            \"JMP,s  done\\n\"\n-    \"pos:\\n\\t\"\n-            \"DIV    $tmp\\n\\t\"\n-            \"XCHG   EAX,$tmp2\\n\"\n-    \"fast:\\n\\t\"\n-            \"DIV    $tmp\\n\"\n-    \"done:\\n\\t\"\n-            \"MOV    EDX,$tmp2\\n\\t\"\n-            \"NEG    EDX:EAX # if $imm < 0\" %}\n-  ins_encode %{\n-    int con = (int)$imm$$constant;\n-    assert(con != 0 && con != -1 && con != min_jint, \"wrong divisor\");\n-    int pcon = (con > 0) ? con : -con;\n-    Label Lfast, Lpos, Ldone;\n-\n-    __ movl($tmp$$Register, pcon);\n-    __ xorl($tmp2$$Register,$tmp2$$Register);\n-    __ cmpl($tmp$$Register, HIGH_FROM_LOW($dst$$Register));\n-    __ jccb(Assembler::above, Lfast); \/\/ result fits into 32 bit\n-\n-    __ movl($tmp2$$Register, $dst$$Register); \/\/ save\n-    __ movl($dst$$Register, HIGH_FROM_LOW($dst$$Register));\n-    __ movl(HIGH_FROM_LOW($dst$$Register),0); \/\/ preserve flags\n-    __ jccb(Assembler::lessEqual, Lpos); \/\/ result is positive\n-\n-    \/\/ Negative dividend.\n-    \/\/ convert value to positive to use unsigned division\n-    __ lneg($dst$$Register, $tmp2$$Register);\n-    __ divl($tmp$$Register);\n-    __ xchgl($dst$$Register, $tmp2$$Register);\n-    __ divl($tmp$$Register);\n-    \/\/ revert result back to negative\n-    __ lneg($tmp2$$Register, $dst$$Register);\n-    __ jmpb(Ldone);\n-\n-    __ bind(Lpos);\n-    __ divl($tmp$$Register); \/\/ Use unsigned division\n-    __ xchgl($dst$$Register, $tmp2$$Register);\n-    \/\/ Fallthrow for final divide, tmp2 has 32 bit hi result\n-\n-    __ bind(Lfast);\n-    \/\/ fast path: src is positive\n-    __ divl($tmp$$Register); \/\/ Use unsigned division\n-\n-    __ bind(Ldone);\n-    __ movl(HIGH_FROM_LOW($dst$$Register),$tmp2$$Register);\n-    if (con < 0) {\n-      __ lneg(HIGH_FROM_LOW($dst$$Register), $dst$$Register);\n-    }\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\/\/ Remainder Register Long (remainder fit into 32 bits)\n-instruct modL_eReg_imm32( eADXRegL dst, immL32 imm, rRegI tmp, rRegI tmp2, eFlagsReg cr ) %{\n-  match(Set dst (ModL dst imm));\n-  effect( TEMP tmp, TEMP tmp2, KILL cr );\n-  ins_cost(1000);\n-  format %{ \"MOV    $tmp,abs($imm) # lrem EDX:EAX,$imm\\n\\t\"\n-            \"CMP    $tmp,EDX\\n\\t\"\n-            \"JA,s   fast\\n\\t\"\n-            \"MOV    $tmp2,EAX\\n\\t\"\n-            \"MOV    EAX,EDX\\n\\t\"\n-            \"MOV    EDX,0\\n\\t\"\n-            \"JLE,s  pos\\n\\t\"\n-            \"LNEG   EAX : $tmp2\\n\\t\"\n-            \"DIV    $tmp # unsigned division\\n\\t\"\n-            \"MOV    EAX,$tmp2\\n\\t\"\n-            \"DIV    $tmp\\n\\t\"\n-            \"NEG    EDX\\n\\t\"\n-            \"JMP,s  done\\n\"\n-    \"pos:\\n\\t\"\n-            \"DIV    $tmp\\n\\t\"\n-            \"MOV    EAX,$tmp2\\n\"\n-    \"fast:\\n\\t\"\n-            \"DIV    $tmp\\n\"\n-    \"done:\\n\\t\"\n-            \"MOV    EAX,EDX\\n\\t\"\n-            \"SAR    EDX,31\\n\\t\" %}\n-  ins_encode %{\n-    int con = (int)$imm$$constant;\n-    assert(con != 0 && con != -1 && con != min_jint, \"wrong divisor\");\n-    int pcon = (con > 0) ? con : -con;\n-    Label  Lfast, Lpos, Ldone;\n-\n-    __ movl($tmp$$Register, pcon);\n-    __ cmpl($tmp$$Register, HIGH_FROM_LOW($dst$$Register));\n-    __ jccb(Assembler::above, Lfast); \/\/ src is positive and result fits into 32 bit\n-\n-    __ movl($tmp2$$Register, $dst$$Register); \/\/ save\n-    __ movl($dst$$Register, HIGH_FROM_LOW($dst$$Register));\n-    __ movl(HIGH_FROM_LOW($dst$$Register),0); \/\/ preserve flags\n-    __ jccb(Assembler::lessEqual, Lpos); \/\/ result is positive\n-\n-    \/\/ Negative dividend.\n-    \/\/ convert value to positive to use unsigned division\n-    __ lneg($dst$$Register, $tmp2$$Register);\n-    __ divl($tmp$$Register);\n-    __ movl($dst$$Register, $tmp2$$Register);\n-    __ divl($tmp$$Register);\n-    \/\/ revert remainder back to negative\n-    __ negl(HIGH_FROM_LOW($dst$$Register));\n-    __ jmpb(Ldone);\n-\n-    __ bind(Lpos);\n-    __ divl($tmp$$Register);\n-    __ movl($dst$$Register, $tmp2$$Register);\n-\n-    __ bind(Lfast);\n-    \/\/ fast path: src is positive\n-    __ divl($tmp$$Register);\n-\n-    __ bind(Ldone);\n-    __ movl($dst$$Register, HIGH_FROM_LOW($dst$$Register));\n-    __ sarl(HIGH_FROM_LOW($dst$$Register), 31); \/\/ result sign\n-\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":29,"deletions":214,"binary":false,"changes":243,"status":"modified"},{"patch":"@@ -341,0 +341,1 @@\n+extern RegMask _STACK_OR_LONG_NO_RAX_RDX_REG_mask;\n@@ -342,0 +343,1 @@\n+extern RegMask _STACK_OR_INT_NO_RAX_RDX_REG_mask;\n@@ -345,0 +347,3 @@\n+inline const RegMask& STACK_OR_LONG_NO_RAX_RDX_REG_mask() {\n+  return _STACK_OR_LONG_NO_RAX_RDX_REG_mask;\n+}\n@@ -346,0 +351,3 @@\n+inline const RegMask& STACK_OR_INT_NO_RAX_RDX_REG_mask() {\n+  return _STACK_OR_INT_NO_RAX_RDX_REG_mask;\n+}\n@@ -371,0 +379,1 @@\n+RegMask _STACK_OR_LONG_NO_RAX_RDX_REG_mask;\n@@ -372,0 +381,1 @@\n+RegMask _STACK_OR_INT_NO_RAX_RDX_REG_mask;\n@@ -432,0 +442,3 @@\n+  _STACK_OR_LONG_NO_RAX_RDX_REG_mask = _LONG_NO_RAX_RDX_REG_mask;\n+  _STACK_OR_LONG_NO_RAX_RDX_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());\n+\n@@ -454,0 +467,3 @@\n+  _STACK_OR_INT_NO_RAX_RDX_REG_mask = _INT_NO_RAX_RDX_REG_mask;\n+  _STACK_OR_INT_NO_RAX_RDX_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());\n+\n@@ -1910,117 +1926,0 @@\n-  enc_class cdql_enc(no_rax_rdx_RegI div)\n-  %{\n-    \/\/ Full implementation of Java idiv and irem; checks for\n-    \/\/ special case as described in JVM spec., p.243 & p.271.\n-    \/\/\n-    \/\/         normal case                           special case\n-    \/\/\n-    \/\/ input : rax: dividend                         min_int\n-    \/\/         reg: divisor                          -1\n-    \/\/\n-    \/\/ output: rax: quotient  (= rax idiv reg)       min_int\n-    \/\/         rdx: remainder (= rax irem reg)       0\n-    \/\/\n-    \/\/  Code sequnce:\n-    \/\/\n-    \/\/    0:   3d 00 00 00 80          cmp    $0x80000000,%eax\n-    \/\/    5:   75 07\/08                jne    e <normal>\n-    \/\/    7:   33 d2                   xor    %edx,%edx\n-    \/\/  [div >= 8 -> offset + 1]\n-    \/\/  [REX_B]\n-    \/\/    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div\n-    \/\/    c:   74 03\/04                je     11 <done>\n-    \/\/ 000000000000000e <normal>:\n-    \/\/    e:   99                      cltd\n-    \/\/  [div >= 8 -> offset + 1]\n-    \/\/  [REX_B]\n-    \/\/    f:   f7 f9                   idiv   $div\n-    \/\/ 0000000000000011 <done>:\n-    MacroAssembler _masm(&cbuf);\n-    Label normal;\n-    Label done;\n-\n-    \/\/ cmp    $0x80000000,%eax\n-    __ cmpl(as_Register(RAX_enc), 0x80000000);\n-\n-    \/\/ jne    e <normal>\n-    __ jccb(Assembler::notEqual, normal);\n-\n-    \/\/ xor    %edx,%edx\n-    __ xorl(as_Register(RDX_enc), as_Register(RDX_enc));\n-\n-    \/\/ cmp    $0xffffffffffffffff,%ecx\n-    __ cmpl($div$$Register, -1);\n-\n-    \/\/ je     11 <done>\n-    __ jccb(Assembler::equal, done);\n-\n-    \/\/ <normal>\n-    \/\/ cltd\n-    __ bind(normal);\n-    __ cdql();\n-\n-    \/\/ idivl\n-    \/\/ <done>\n-    __ idivl($div$$Register);\n-    __ bind(done);\n-  %}\n-\n-  enc_class cdqq_enc(no_rax_rdx_RegL div)\n-  %{\n-    \/\/ Full implementation of Java ldiv and lrem; checks for\n-    \/\/ special case as described in JVM spec., p.243 & p.271.\n-    \/\/\n-    \/\/         normal case                           special case\n-    \/\/\n-    \/\/ input : rax: dividend                         min_long\n-    \/\/         reg: divisor                          -1\n-    \/\/\n-    \/\/ output: rax: quotient  (= rax idiv reg)       min_long\n-    \/\/         rdx: remainder (= rax irem reg)       0\n-    \/\/\n-    \/\/  Code sequnce:\n-    \/\/\n-    \/\/    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx\n-    \/\/    7:   00 00 80\n-    \/\/    a:   48 39 d0                cmp    %rdx,%rax\n-    \/\/    d:   75 08                   jne    17 <normal>\n-    \/\/    f:   33 d2                   xor    %edx,%edx\n-    \/\/   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div\n-    \/\/   15:   74 05                   je     1c <done>\n-    \/\/ 0000000000000017 <normal>:\n-    \/\/   17:   48 99                   cqto\n-    \/\/   19:   48 f7 f9                idiv   $div\n-    \/\/ 000000000000001c <done>:\n-    MacroAssembler _masm(&cbuf);\n-    Label normal;\n-    Label done;\n-\n-    \/\/ mov    $0x8000000000000000,%rdx\n-    __ mov64(as_Register(RDX_enc), 0x8000000000000000);\n-\n-    \/\/ cmp    %rdx,%rax\n-    __ cmpq(as_Register(RAX_enc), as_Register(RDX_enc));\n-\n-    \/\/ jne    17 <normal>\n-    __ jccb(Assembler::notEqual, normal);\n-\n-    \/\/ xor    %edx,%edx\n-    __ xorl(as_Register(RDX_enc), as_Register(RDX_enc));\n-\n-    \/\/ cmp    $0xffffffffffffffff,$div\n-    __ cmpq($div$$Register, -1);\n-\n-    \/\/ je     1e <done>\n-    __ jccb(Assembler::equal, done);\n-\n-    \/\/ <normal>\n-    \/\/ cqto\n-    __ bind(normal);\n-    __ cdqq();\n-\n-    \/\/ idivq (note: must be emitted by the user of this rule)\n-    \/\/ <done>\n-    __ idivq($div$$Register);\n-    __ bind(done);\n-  %}\n-\n@@ -8655,1 +8554,1 @@\n-  match(Set rax (DivI rax div));\n+  match(Set rax (NODivI rax div));\n@@ -8658,11 +8557,24 @@\n-  ins_cost(30*100+10*100); \/\/ XXX\n-  format %{ \"cmpl    rax, 0x80000000\\t# idiv\\n\\t\"\n-            \"jne,s   normal\\n\\t\"\n-            \"xorl    rdx, rdx\\n\\t\"\n-            \"cmpl    $div, -1\\n\\t\"\n-            \"je,s    done\\n\"\n-    \"normal: cdql\\n\\t\"\n-            \"idivl   $div\\n\"\n-    \"done:\"        %}\n-  ins_encode(cdql_enc(div));\n-  ins_pipe(ialu_reg_reg_alu0);\n+  ins_cost(500);\n+  format %{ \"cdql\\n\\t\"\n+            \"idivl   $div\" %}\n+  ins_encode %{\n+    __ cdql();\n+    __ idivl($div$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct divI_mem(rax_RegI rax, rdx_RegI rdx, memory div,\n+                   rFlagsReg cr)\n+%{\n+  match(Set rax (NODivI rax (LoadI div)));\n+  effect(KILL rdx, KILL cr);\n+\n+  ins_cost(575);\n+  format %{ \"cdql\\n\\t\"\n+            \"idivl   $div\" %}\n+  ins_encode %{\n+    __ cdql();\n+    __ idivl($div$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n@@ -8674,1 +8586,1 @@\n-  match(Set rax (DivL rax div));\n+  match(Set rax (NODivL rax div));\n@@ -8677,12 +8589,24 @@\n-  ins_cost(30*100+10*100); \/\/ XXX\n-  format %{ \"movq    rdx, 0x8000000000000000\\t# ldiv\\n\\t\"\n-            \"cmpq    rax, rdx\\n\\t\"\n-            \"jne,s   normal\\n\\t\"\n-            \"xorl    rdx, rdx\\n\\t\"\n-            \"cmpq    $div, -1\\n\\t\"\n-            \"je,s    done\\n\"\n-    \"normal: cdqq\\n\\t\"\n-            \"idivq   $div\\n\"\n-    \"done:\"        %}\n-  ins_encode(cdqq_enc(div));\n-  ins_pipe(ialu_reg_reg_alu0);\n+  ins_cost(500);\n+  format %{ \"cdqq\\n\\t\"\n+            \"idivq   $div\" %}\n+  ins_encode %{\n+    __ cdqq();\n+    __ idivq($div$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct divL_mem(rax_RegL rax, rdx_RegL rdx, memory div,\n+                   rFlagsReg cr)\n+%{\n+  match(Set rax (NODivL rax (LoadL div)));\n+  effect(KILL rdx, KILL cr);\n+\n+  ins_cost(575);\n+  format %{ \"cdqq\\n\\t\"\n+            \"idivq   $div\" %}\n+  ins_encode %{\n+    __ cdqq();\n+    __ idivq($div$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n@@ -8721,1 +8645,1 @@\n-  match(DivModI rax div);\n+  match(NODivModI rax div);\n@@ -8724,10 +8648,7 @@\n-  ins_cost(30*100+10*100); \/\/ XXX\n-  format %{ \"cmpl    rax, 0x80000000\\t# idiv\\n\\t\"\n-            \"jne,s   normal\\n\\t\"\n-            \"xorl    rdx, rdx\\n\\t\"\n-            \"cmpl    $div, -1\\n\\t\"\n-            \"je,s    done\\n\"\n-    \"normal: cdql\\n\\t\"\n-            \"idivl   $div\\n\"\n-    \"done:\"        %}\n-  ins_encode(cdql_enc(div));\n+  ins_cost(500);\n+  format %{ \"cdql\\n\\t\"\n+            \"idivl   $div\" %}\n+  ins_encode %{\n+    __ cdql();\n+    __ idivl($div$$Register);\n+  %}\n@@ -8741,1 +8662,1 @@\n-  match(DivModL rax div);\n+  match(NODivModL rax div);\n@@ -8744,11 +8665,7 @@\n-  ins_cost(30*100+10*100); \/\/ XXX\n-  format %{ \"movq    rdx, 0x8000000000000000\\t# ldiv\\n\\t\"\n-            \"cmpq    rax, rdx\\n\\t\"\n-            \"jne,s   normal\\n\\t\"\n-            \"xorl    rdx, rdx\\n\\t\"\n-            \"cmpq    $div, -1\\n\\t\"\n-            \"je,s    done\\n\"\n-    \"normal: cdqq\\n\\t\"\n-            \"idivq   $div\\n\"\n-    \"done:\"        %}\n-  ins_encode(cdqq_enc(div));\n+  ins_cost(500);\n+  format %{ \"cdqq\\n\\t\"\n+            \"idivq   $div\" %}\n+  ins_encode %{\n+    __ cdqq();\n+    __ idivq($div$$Register);\n+  %}\n@@ -8792,26 +8709,2 @@\n-\n-\/\/----------- DivL-By-Constant-Expansions--------------------------------------\n-\/\/ DivI cases are handled by the compiler\n-\n-\/\/ Magic constant, reciprocal of 10\n-instruct loadConL_0x6666666666666667(rRegL dst)\n-%{\n-  effect(DEF dst);\n-\n-  format %{ \"movq    $dst, #0x666666666666667\\t# Used in div-by-10\" %}\n-  ins_encode(load_immL(dst, 0x6666666666666667));\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct mul_hi(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)\n-%{\n-  effect(DEF dst, USE src, USE_KILL rax, KILL cr);\n-\n-  format %{ \"imulq   rdx:rax, rax, $src\\t# Used in div-by-10\" %}\n-  ins_encode %{\n-    __ imulq($src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n-instruct sarL_rReg_63(rRegL dst, rFlagsReg cr)\n+instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,\n+                   rFlagsReg cr)\n@@ -8819,1 +8712,2 @@\n-  effect(USE_DEF dst, KILL cr);\n+  match(Set rdx (NOModI rax div));\n+  effect(KILL rax, KILL cr);\n@@ -8821,1 +8715,3 @@\n-  format %{ \"sarq    $dst, #63\\t# Used in div-by-10\" %}\n+  ins_cost(500);\n+  format %{ \"cdql\\n\\t\"\n+            \"idivl   $div\" %}\n@@ -8823,1 +8719,2 @@\n-    __ sarq($dst$$Register, 63);\n+    __ cdql();\n+    __ idivl($div$$Register);\n@@ -8825,1 +8722,1 @@\n-  ins_pipe(ialu_reg);\n+  ins_pipe(pipe_slow);\n@@ -8828,1 +8725,2 @@\n-instruct sarL_rReg_2(rRegL dst, rFlagsReg cr)\n+instruct modI_mem(rdx_RegI rdx, rax_RegI rax, memory div,\n+                   rFlagsReg cr)\n@@ -8830,1 +8728,2 @@\n-  effect(USE_DEF dst, KILL cr);\n+  match(Set rdx (NOModI rax (LoadI div)));\n+  effect(KILL rax, KILL cr);\n@@ -8832,1 +8731,3 @@\n-  format %{ \"sarq    $dst, #2\\t# Used in div-by-10\" %}\n+  ins_cost(575);\n+  format %{ \"cdql\\n\\t\"\n+            \"idivl   $div\" %}\n@@ -8834,18 +8735,2 @@\n-    __ sarq($dst$$Register, 2);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct divL_10(rdx_RegL dst, no_rax_RegL src, immL10 div)\n-%{\n-  match(Set dst (DivL src div));\n-\n-  ins_cost((5+8)*100);\n-  expand %{\n-    rax_RegL rax;                     \/\/ Killed temp\n-    rFlagsReg cr;                     \/\/ Killed\n-    loadConL_0x6666666666666667(rax); \/\/ movq  rax, 0x6666666666666667\n-    mul_hi(dst, src, rax, cr);        \/\/ mulq  rdx:rax <= rax * $src\n-    sarL_rReg_63(src, cr);            \/\/ sarq  src, 63\n-    sarL_rReg_2(dst, cr);             \/\/ sarq  rdx, 2\n-    subL_rReg(dst, src, cr);          \/\/ subl  rdx, src\n+    __ cdql();\n+    __ idivl($div$$Address);\n@@ -8853,0 +8738,1 @@\n+  ins_pipe(pipe_slow);\n@@ -8855,3 +8741,1 @@\n-\/\/-----------------------------------------------------------------------------\n-\n-instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,\n+instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,\n@@ -8860,1 +8744,1 @@\n-  match(Set rdx (ModI rax div));\n+  match(Set rdx (NOModL rax div));\n@@ -8863,11 +8747,8 @@\n-  ins_cost(300); \/\/ XXX\n-  format %{ \"cmpl    rax, 0x80000000\\t# irem\\n\\t\"\n-            \"jne,s   normal\\n\\t\"\n-            \"xorl    rdx, rdx\\n\\t\"\n-            \"cmpl    $div, -1\\n\\t\"\n-            \"je,s    done\\n\"\n-    \"normal: cdql\\n\\t\"\n-            \"idivl   $div\\n\"\n-    \"done:\"        %}\n-  ins_encode(cdql_enc(div));\n-  ins_pipe(ialu_reg_reg_alu0);\n+  ins_cost(500);\n+  format %{ \"cdqq\\n\\t\"\n+            \"idivq   $div\" %}\n+  ins_encode %{\n+    __ cdqq();\n+    __ idivq($div$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n@@ -8876,1 +8757,1 @@\n-instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,\n+instruct modL_mem(rdx_RegL rdx, rax_RegL rax, memory div,\n@@ -8879,1 +8760,1 @@\n-  match(Set rdx (ModL rax div));\n+  match(Set rdx (NOModL rax (LoadL div)));\n@@ -8882,12 +8763,8 @@\n-  ins_cost(300); \/\/ XXX\n-  format %{ \"movq    rdx, 0x8000000000000000\\t# lrem\\n\\t\"\n-            \"cmpq    rax, rdx\\n\\t\"\n-            \"jne,s   normal\\n\\t\"\n-            \"xorl    rdx, rdx\\n\\t\"\n-            \"cmpq    $div, -1\\n\\t\"\n-            \"je,s    done\\n\"\n-    \"normal: cdqq\\n\\t\"\n-            \"idivq   $div\\n\"\n-    \"done:\"        %}\n-  ins_encode(cdqq_enc(div));\n-  ins_pipe(ialu_reg_reg_alu0);\n+  ins_cost(575);\n+  format %{ \"cdqq\\n\\t\"\n+            \"idivq   $div\" %}\n+  ins_encode %{\n+    __ cdqq();\n+    __ idivq($div$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":122,"deletions":245,"binary":false,"changes":367,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -229,0 +229,1 @@\n+  AD.addInclude(AD._CPP_file, \"opto\/parse.hpp\");\n","filename":"src\/hotspot\/share\/adlc\/main.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -165,0 +165,2 @@\n+macro(NODivI)\n+macro(NODivL)\n@@ -170,0 +172,2 @@\n+macro(NODivModI)\n+macro(NODivModL)\n@@ -238,0 +242,2 @@\n+macro(NOModI)\n+macro(NOModL)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3532,0 +3532,40 @@\n+  case Op_NOModI:\n+    if (UseDivMod) {\n+      \/\/ Check if a%b and a\/b both exist\n+      Node* d = n->find_similar(Op_NODivI);\n+      if (d) {\n+        \/\/ Replace them with a fused divmod if supported\n+        if (Matcher::has_match_rule(Op_NODivModI)) {\n+          NODivModINode* divmod = NODivModINode::make(n);\n+          d->subsume_by(divmod->div_proj(), this);\n+          n->subsume_by(divmod->mod_proj(), this);\n+        } else {\n+          \/\/ replace a%b with a-((a\/b)*b)\n+          Node* mult = new MulINode(d, d->in(2));\n+          Node* sub  = new SubINode(d->in(1), mult);\n+          n->subsume_by(sub, this);\n+        }\n+      }\n+    }\n+    break;\n+\n+  case Op_NOModL:\n+    if (UseDivMod) {\n+      \/\/ Check if a%b and a\/b both exist\n+      Node* d = n->find_similar(Op_NODivL);\n+      if (d) {\n+        \/\/ Replace them with a fused divmod if supported\n+        if (Matcher::has_match_rule(Op_NODivModL)) {\n+          NODivModLNode* divmod = NODivModLNode::make(n);\n+          d->subsume_by(divmod->div_proj(), this);\n+          n->subsume_by(divmod->mod_proj(), this);\n+        } else {\n+          \/\/ replace a%b with a-((a\/b)*b)\n+          Node* mult = new MulLNode(d, d->in(2));\n+          Node* sub  = new SubLNode(d->in(1), mult);\n+          n->subsume_by(sub, this);\n+        }\n+      }\n+    }\n+    break;\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1469,0 +1469,24 @@\n+\n+\/\/------------------------------make------------------------------------------\n+NODivModINode* NODivModINode::make(Node* div_or_mod) {\n+  Node* n = div_or_mod;\n+  assert(n->Opcode() == Op_NODivI || n->Opcode() == Op_NOModI,\n+         \"only div or mod input pattern accepted\");\n+\n+  NODivModINode* divmod = new NODivModINode(n->in(0), n->in(1), n->in(2));\n+  Node*        dproj  = new ProjNode(divmod, DivModNode::div_proj_num);\n+  Node*        mproj  = new ProjNode(divmod, DivModNode::mod_proj_num);\n+  return divmod;\n+}\n+\n+\/\/------------------------------make------------------------------------------\n+NODivModLNode* NODivModLNode::make(Node* div_or_mod) {\n+  Node* n = div_or_mod;\n+  assert(n->Opcode() == Op_NODivL || n->Opcode() == Op_NOModL,\n+         \"only div or mod input pattern accepted\");\n+\n+  NODivModLNode* divmod = new NODivModLNode(n->in(0), n->in(1), n->in(2));\n+  Node*        dproj  = new ProjNode(divmod, DivModNode::div_proj_num);\n+  Node*        mproj  = new ProjNode(divmod, DivModNode::mod_proj_num);\n+  return divmod;\n+}\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -106,1 +106,19 @@\n-\/\/------------------------------UDivLNode---------------------------------------\n+\/\/-----------------------------NODivINode--------------------------------------\n+\/\/ Non-overflow integer division, UB when dividend == min_jint and divisor == -1\n+\/\/ so user has to ensure this combination does not appear\n+class NODivINode : public DivINode {\n+public:\n+  NODivINode( Node *c, Node *dividend, Node *divisor ) : DivINode(c, dividend, divisor ) {}\n+  virtual int Opcode() const;\n+};\n+\n+\/\/-----------------------------NODivLNode--------------------------------------\n+\/\/ Non-overflow long division, UB when dividend == min_jlong and divisor == -1\n+\/\/ so user has to ensure this combination does not appear\n+class NODivLNode : public DivLNode {\n+public:\n+  NODivLNode( Node *c, Node *dividend, Node *divisor ) : DivLNode(c, dividend, divisor ) {}\n+  virtual int Opcode() const;\n+};\n+\n+\/\/------------------------------UDivLNode--------------------------------------\n@@ -165,1 +183,1 @@\n-\/\/------------------------------UModINode---------------------------------------\n+\/\/------------------------------UModINode--------------------------------------\n@@ -176,1 +194,1 @@\n-\/\/------------------------------UModLNode---------------------------------------\n+\/\/------------------------------UModLNode--------------------------------------\n@@ -187,1 +205,19 @@\n-\/\/------------------------------DivModNode---------------------------------------\n+\/\/-----------------------------NOModINode--------------------------------------\n+\/\/ Non-overflow integer modulus, UB when dividend == min_jint and divisor == -1\n+\/\/ so user has to ensure this combination does not appear\n+class NOModINode : public ModINode {\n+public:\n+  NOModINode( Node *c, Node *dividend, Node *divisor ) : ModINode(c, dividend, divisor ) {}\n+  virtual int Opcode() const;\n+};\n+\n+\/\/-----------------------------NOModLNode--------------------------------------\n+\/\/ Non-overflow long modulus, UB when dividend == min_jlong and divisor == -1\n+\/\/ so user has to ensure this combination does not appear\n+class NOModLNode : public ModLNode {\n+public:\n+  NOModLNode( Node *c, Node *dividend, Node *divisor ) : ModLNode(c, dividend, divisor ) {}\n+  virtual int Opcode() const;\n+};\n+\n+\/\/-----------------------------DivModNode--------------------------------------\n@@ -209,1 +245,1 @@\n-\/\/------------------------------DivModINode---------------------------------------\n+\/\/-----------------------------DivModINode-------------------------------------\n@@ -222,1 +258,1 @@\n-\/\/------------------------------DivModLNode---------------------------------------\n+\/\/-----------------------------DivModLNode-------------------------------------\n@@ -236,1 +272,1 @@\n-\/\/------------------------------UDivModINode---------------------------------------\n+\/\/----------------------------UDivModINode-------------------------------------\n@@ -249,1 +285,1 @@\n-\/\/------------------------------UDivModLNode---------------------------------------\n+\/\/----------------------------UDivModLNode-------------------------------------\n@@ -262,0 +298,24 @@\n+\/\/----------------------------NODivModINode------------------------------------\n+\/\/ Non-overflow integer division with remainder result, UB when dividend == min_jint\n+\/\/ and divisor == -1 so user has to ensure this combination does not appear\n+class NODivModINode : public DivModINode {\n+public:\n+  NODivModINode( Node *c, Node *dividend, Node *divisor ) : DivModINode(c, dividend, divisor) {}\n+  virtual int Opcode() const;\n+\n+  \/\/ Make a divmod and associated projections from a div or mod.\n+  static NODivModINode* make(Node* div_or_mod);\n+};\n+\n+\/\/----------------------------NODivModLNode------------------------------------\n+\/\/ Non-overflow long division with remainder result, UB when dividend == min_jlong\n+\/\/ and divisor == -1 so user has to ensure this combination does not appear\n+class NODivModLNode : public DivModLNode {\n+public:\n+  NODivModLNode( Node *c, Node *dividend, Node *divisor ) : DivModLNode(c, dividend, divisor) {}\n+  virtual int Opcode() const;\n+\n+  \/\/ Make a divmod and associated projections from a div or mod.\n+  static NODivModLNode* make(Node* div_or_mod);\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":68,"deletions":8,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -465,1 +465,2 @@\n-  void do_one_bytecode();\n+  void do_one_bytecode_common();\n+  bool do_one_bytecode_targeted();\n@@ -537,0 +538,4 @@\n+  \/\/ implementation of div\/rem bytecodes for handling of special case\n+  \/\/ min_jint \/ -1\n+  void do_divmod_fixup();\n+\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"jvm_io.h\"\n@@ -1555,1 +1556,16 @@\n-    do_one_bytecode();\n+    \/\/ Try parsing machine-dependently, then if it is not needed then parse\n+    \/\/ the bytecode in a machine independent manner\n+    if (!do_one_bytecode_targeted()) {\n+      do_one_bytecode_common();\n+    }\n+#ifndef PRODUCT\n+    if (C->should_print_igv(1)) {\n+      IdealGraphPrinter* printer = C->igv_printer();\n+      char buffer[256];\n+      jio_snprintf(buffer, sizeof(buffer), \"Bytecode %d: %s\", bci(), Bytecodes::name(bc()));\n+      bool old = printer->traverse_outs();\n+      printer->set_traverse_outs(true);\n+      printer->print_method(buffer, 4);\n+      printer->set_traverse_outs(old);\n+    }\n+#endif\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1805,1 +1805,1 @@\n-void Parse::do_one_bytecode() {\n+void Parse::do_one_bytecode_common() {\n@@ -2753,12 +2753,0 @@\n-\n-#ifndef PRODUCT\n-  if (C->should_print_igv(1)) {\n-    IdealGraphPrinter* printer = C->igv_printer();\n-    char buffer[256];\n-    jio_snprintf(buffer, sizeof(buffer), \"Bytecode %d: %s\", bci(), Bytecodes::name(bc()));\n-    bool old = printer->traverse_outs();\n-    printer->set_traverse_outs(true);\n-    printer->print_method(buffer, 4);\n-    printer->set_traverse_outs(old);\n-  }\n-#endif\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -436,0 +436,74 @@\n+\n+\/\/ On some architectures, a division cannot be done immediately due to\n+\/\/ the special case with min_jint \/ -1. As a result, we need to have\n+\/\/ special handling for this case\n+void Parse::do_divmod_fixup() {\n+  Bytecodes::Code bc = this->bc();\n+  BasicType bt = (bc == Bytecodes::_idiv || bc == Bytecodes::_irem) ? T_INT : T_LONG;\n+  \/\/ Operands need to stay in the stack during zero check\n+  if (bt == T_INT) {\n+    zero_check_int(peek(0));\n+  } else {\n+    zero_check_long(peek(1));\n+  }\n+  \/\/ Compile-time detection of arithmetic exception\n+  if (stopped()) {\n+    return;\n+  }\n+\n+  Node* in2 = (bt == T_INT) ? pop() : pop_pair();\n+  Node* in1 = (bt == T_INT) ? pop() : pop_pair();\n+\n+  auto generate_division = [](PhaseGVN& gvn, Node* control, Node* in1, Node* in2,\n+                              Bytecodes::Code bc) {\n+    switch (bc) {\n+      case Bytecodes::_idiv: return gvn.transform(new NODivINode(control, in1, in2));\n+      case Bytecodes::_ldiv: return gvn.transform(new NODivLNode(control, in1, in2));\n+      case Bytecodes::_irem: return gvn.transform(new NOModINode(control, in1, in2));\n+      case Bytecodes::_lrem: return gvn.transform(new NOModLNode(control, in1, in2));\n+      default:\n+        ShouldNotReachHere();\n+        return static_cast<Node*>(nullptr);\n+    }\n+  };\n+\n+  auto push_result = [](Parse& parser, Node* res, BasicType bt) {\n+    if (bt == T_INT) {\n+      parser.push(res);\n+    } else {\n+      parser.push_pair(res);\n+    }\n+  };\n+\n+  \/\/ No overflow possibility here\n+  if ((in1 == in2) ||\n+      (bt == T_INT  &&  !TypeInt::MIN->higher_equal(_gvn.type(in1))) ||\n+      (bt == T_LONG && !TypeLong::MIN->higher_equal(_gvn.type(in1)))) {\n+    Node* res = generate_division(_gvn, control(), in1, in2, bc);\n+    push_result(*this, res, bt);\n+    return;\n+  }\n+\n+  \/\/ The generated graph is equivalent to (in2 == -1) ? -in1 : (in1 \/ in2)\n+  \/\/ we need to have a separate branch for in2 == -1 due to the special\n+  \/\/ case of min_jint \/ -1\n+  Node* cmp = _gvn.transform(CmpNode::make(in2, _gvn.integercon(-1, bt), bt));\n+  Node* bol = Bool(cmp, BoolTest::eq);\n+  IfNode* iff = create_and_map_if(control(), bol, PROB_UNLIKELY_MAG(3), COUNT_UNKNOWN);\n+  Node* iff_true = IfTrue(iff);\n+  Node* iff_false = IfFalse(iff);\n+  Node* res_fast = (bc == Bytecodes::_idiv || bc == Bytecodes::_ldiv)\n+                   ? _gvn.transform(SubNode::make(_gvn.zerocon(bt), in1, bt))\n+                   : _gvn.zerocon(bt);\n+  Node* res_slow = generate_division(_gvn, iff_false, in1, in2, bc);\n+  Node* merge = new RegionNode(3);\n+  merge->init_req(1, iff_true);\n+  merge->init_req(2, iff_false);\n+  record_for_igvn(merge);\n+  set_control(_gvn.transform(merge));\n+  Node* res = new PhiNode(merge, Type::get_const_basic_type(bt));\n+  res->init_req(1, res_fast);\n+  res->init_req(2, res_slow);\n+  res = _gvn.transform(res);\n+  push_result(*this, res, bt);\n+}\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":75,"deletions":1,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -1584,0 +1584,2 @@\n+  declare_c2_type(NODivINode, DivINode)                                   \\\n+  declare_c2_type(NODivLNode, DivLNode)                                   \\\n@@ -1590,0 +1592,2 @@\n+  declare_c2_type(NOModINode, ModINode)                                   \\\n+  declare_c2_type(NOModLNode, ModLNode)                                   \\\n@@ -1595,0 +1599,2 @@\n+  declare_c2_type(NODivModINode, DivModINode)                             \\\n+  declare_c2_type(NODivModLNode, DivModLNode)                             \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.integerArithmetic;\n+\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test TestDivision\n+ * @bug 8284742\n+ * @summary Tests to verify compiled code correctly handles integral divisions.\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,*.TestDivision::divide\n+ *      -XX:CompileCommand=compileonly,*.TestDivision::remainder\n+ *      compiler.integerArithmetic.TestDivision\n+ *\/\n+public class TestDivision {\n+    public static void main(String[] args) {\n+        Asserts.assertEquals(divide(19, 7), 19 \/ 7);\n+        Asserts.assertEquals(remainder(19, 7), 19 % 7);\n+        Asserts.assertEquals(divide(19L, 7L), 19L \/ 7L);\n+        Asserts.assertEquals(remainder(19L, 7L), 19L % 7L);\n+\n+        Asserts.assertEquals(divide(19, -7), 19 \/ -7);\n+        Asserts.assertEquals(remainder(19, -7), 19 % -7);\n+        Asserts.assertEquals(divide(19L, -7L), 19L \/ -7L);\n+        Asserts.assertEquals(remainder(19L, -7L), 19L % -7L);\n+\n+        Asserts.assertEquals(divide(-19, 7), -19 \/ 7);\n+        Asserts.assertEquals(remainder(-19, 7), -19 % 7);\n+        Asserts.assertEquals(divide(-19L, 7L), -19L \/ 7L);\n+        Asserts.assertEquals(remainder(-19L, 7L), -19L % 7L);\n+\n+        Asserts.assertEquals(divide(-19, -7), -19 \/ -7);\n+        Asserts.assertEquals(remainder(-19, -7), -19 % -7);\n+        Asserts.assertEquals(divide(-19L, -7L), -19L \/ -7L);\n+        Asserts.assertEquals(remainder(-19L, -7L), -19L % -7L);\n+\n+        Asserts.assertEquals(divide(Integer.MIN_VALUE, -1), Integer.MIN_VALUE \/ -1);\n+        Asserts.assertEquals(remainder(Integer.MIN_VALUE, -1), Integer.MIN_VALUE % -1);\n+        Asserts.assertEquals(divide(Long.MIN_VALUE, -1), Long.MIN_VALUE \/ -1L);\n+        Asserts.assertEquals(remainder(Long.MIN_VALUE, -1), Long.MIN_VALUE % -1L);\n+\n+        try {\n+            divide(19, 0);\n+            Asserts.fail();\n+        } catch (ArithmeticException e) {}\n+        try {\n+            remainder(19, 0);\n+            Asserts.fail();\n+        } catch (ArithmeticException e) {}\n+        try {\n+            divide(19L, 0L);\n+            Asserts.fail();\n+        } catch (ArithmeticException e) {}\n+        try {\n+            remainder(19L, 0L);\n+            Asserts.fail();\n+        } catch (ArithmeticException e) {}\n+    }\n+\n+    static int divide(int x, int y) {\n+        return x \/ y;\n+    }\n+\n+    static int remainder(int x, int y) {\n+        return x % y;\n+    }\n+\n+    static long divide(long x, long y) {\n+        return x \/ y;\n+    }\n+\n+    static long remainder(long x, long y) {\n+        return x % y;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/integerArithmetic\/TestDivision.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -172,2 +172,2 @@\n-    public static final String DIV = START + \"Div(I|L|F|D)\" + MID + END;\n-    public static final String DIV_L = START + \"DivL\" + MID + END;\n+    public static final String DIV = START + \"(NO)?Div(I|L|F|D)\" + MID + END;\n+    public static final String DIV_L = START + \"(NO)?DivL\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import org.openjdk.jmh.annotations.Fork;\n@@ -37,3 +38,0 @@\n-\/**\n- * Tests unsigned division and modulus methods in java.lang.Integer\n- *\/\n@@ -43,0 +41,1 @@\n+@Fork(1)\n@@ -63,2 +62,5 @@\n-            if (divisorType.equals(\"positive\")) divisor = Math.abs(divisor);\n-            else if (divisorType.equals(\"negative\")) divisor = -Math.abs(divisor);\n+            if (divisorType.equals(\"positive\")) {\n+                divisor = Math.abs(divisor);\n+            } else if (divisorType.equals(\"negative\")) {\n+                divisor = -Math.abs(divisor);\n+            }\n@@ -69,0 +71,22 @@\n+    @Benchmark\n+    public void testDivide() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = dividends[i] \/ divisors[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testDivideKnownPositive() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = dividends[i] \/ Math.max(1, divisors[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testDivideHoistedDivisor() {\n+        int x = divisors[0];\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = dividends[i] \/ x;\n+        }\n+    }\n+\n@@ -94,1 +118,0 @@\n-\n@@ -96,3 +119,0 @@\n-\n-\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/IntegerDivMod.java","additions":29,"deletions":9,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import org.openjdk.jmh.annotations.Fork;\n@@ -37,3 +38,0 @@\n-\/**\n- * Tests unsigned division and modulus methods in java.lang.Long\n- *\/\n@@ -43,0 +41,1 @@\n+@Fork(1)\n@@ -63,2 +62,5 @@\n-            if (divisorType.equals(\"positive\")) divisor = Math.abs(divisor);\n-            else if (divisorType.equals(\"negative\")) divisor = -Math.abs(divisor);\n+            if (divisorType.equals(\"positive\")) {\n+                divisor = Math.abs(divisor);\n+            } else if (divisorType.equals(\"negative\")) {\n+                divisor = -Math.abs(divisor);\n+            }\n@@ -69,0 +71,22 @@\n+    @Benchmark\n+    public void testDivide() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = dividends[i] \/ divisors[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testDivideKnownPositive() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = dividends[i] \/ Math.max(1, divisors[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testDivideHoistedDivisor() {\n+        long x = divisors[0];\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = dividends[i] \/ x;\n+        }\n+    }\n+\n@@ -94,1 +118,0 @@\n-\n@@ -96,3 +119,0 @@\n-\n-\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/LongDivMod.java","additions":29,"deletions":9,"binary":false,"changes":38,"status":"modified"}]}