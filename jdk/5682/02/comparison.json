{"files":[{"patch":"@@ -293,0 +293,9 @@\n+inline void log_preclean_ref(const DiscoveredListIterator& iter, const char* reason) {\n+  if (log_develop_is_enabled(Trace, gc, ref)) {\n+    ResourceMark rm;\n+    log_develop_trace(gc, ref)(\"Precleaning %s reference \" PTR_FORMAT \": %s\",\n+                               reason, p2i(iter.obj()),\n+                               iter.obj()->klass()->internal_name());\n+  }\n+}\n+\n@@ -1128,8 +1137,9 @@\n-\/\/ Walk the given discovered ref list, and remove all reference objects\n-\/\/ whose referents are still alive, whose referents are NULL or which\n-\/\/ are not active (have a non-NULL next field). NOTE: When we are\n-\/\/ thus precleaning the ref lists (which happens single-threaded today),\n-\/\/ we do not disable refs discovery to honor the correct semantics of\n-\/\/ java.lang.Reference. As a result, we need to be careful below\n-\/\/ that ref removal steps interleave safely with ref discovery steps\n-\/\/ (in this thread).\n+\/\/ Walk the given discovered ref list, and remove all reference objects whose\n+\/\/ referents are still alive or NULL. NOTE: When we are precleaning the\n+\/\/ ref lists, we do not disable refs discovery to honor the correct semantics of\n+\/\/ java.lang.Reference. Therefore, as we iterate over the discovered list (DL)\n+\/\/ and drop elements from it, newly discovered refs can be discovered and added\n+\/\/ to the DL. Because precleaning is implemented single-threaded today, for\n+\/\/ each per-thread DL, the insertion of refs (calling `complete_gc`) happens\n+\/\/ after the iteration. The clear separation means no special synchronization\n+\/\/ is needed.\n@@ -1148,5 +1158,6 @@\n-    if (iter.referent() == NULL || iter.is_referent_alive()) {\n-      \/\/ The referent has been cleared, or is alive; we need to trace\n-      \/\/ and mark its cohort.\n-      log_develop_trace(gc, ref)(\"Precleaning Reference (\" INTPTR_FORMAT \": %s)\",\n-                                 p2i(iter.obj()), iter.obj()->klass()->internal_name());\n+    if (iter.referent() == nullptr) {\n+      log_preclean_ref(iter, \"cleared\");\n+      iter.remove();\n+      iter.move_to_next();\n+    } else if (iter.is_referent_alive()) {\n+      log_preclean_ref(iter, \"reachable\");\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":24,"deletions":13,"binary":false,"changes":37,"status":"modified"}]}