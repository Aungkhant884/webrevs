{"files":[{"patch":"@@ -293,0 +293,9 @@\n+inline void log_preclean_ref(const DiscoveredListIterator& iter, const char* reason) {\n+  if (log_develop_is_enabled(Trace, gc, ref)) {\n+    ResourceMark rm;\n+    log_develop_trace(gc, ref)(\"Precleaning %s reference \" PTR_FORMAT \": %s\",\n+                               reason, p2i(iter.obj()),\n+                               iter.obj()->klass()->internal_name());\n+  }\n+}\n+\n@@ -1129,7 +1138,1 @@\n-\/\/ whose referents are still alive, whose referents are NULL or which\n-\/\/ are not active (have a non-NULL next field). NOTE: When we are\n-\/\/ thus precleaning the ref lists (which happens single-threaded today),\n-\/\/ we do not disable refs discovery to honor the correct semantics of\n-\/\/ java.lang.Reference. As a result, we need to be careful below\n-\/\/ that ref removal steps interleave safely with ref discovery steps\n-\/\/ (in this thread).\n+\/\/ whose referents are still alive or NULL.\n@@ -1148,5 +1151,6 @@\n-    if (iter.referent() == NULL || iter.is_referent_alive()) {\n-      \/\/ The referent has been cleared, or is alive; we need to trace\n-      \/\/ and mark its cohort.\n-      log_develop_trace(gc, ref)(\"Precleaning Reference (\" INTPTR_FORMAT \": %s)\",\n-                                 p2i(iter.obj()), iter.obj()->klass()->internal_name());\n+    if (iter.referent() == nullptr) {\n+      log_preclean_ref(iter, \"cleared\");\n+      iter.remove();\n+      iter.move_to_next();\n+    } else if (iter.is_referent_alive()) {\n+      log_preclean_ref(iter, \"reachable\");\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"}]}