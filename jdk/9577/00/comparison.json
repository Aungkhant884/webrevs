{"files":[{"patch":"@@ -730,0 +730,1 @@\n+    const char* generated = \"\";\n@@ -774,0 +775,3 @@\n+      if (ik->is_generated_shared_class()) {\n+        generated = \" ** generated\";\n+      }\n@@ -780,1 +784,3 @@\n-      log_debug(cds, class)(\"klasses[%5d] = \" PTR_FORMAT \" %-5s %s%s%s\", i, p2i(to_requested(k)), type, k->external_name(), hidden, unlinked);\n+      log_debug(cds, class)(\"klasses[%5d] = \" PTR_FORMAT \" %-5s %s%s%s%s\", i,\n+                            p2i(to_requested(k)), type, k->external_name(),\n+                            hidden, unlinked, generated);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -168,14 +168,22 @@\n-    int len = h_bytes->length();\n-    \/\/ make a copy of class bytes so GC will not affect us.\n-    char *buf = NEW_RESOURCE_ARRAY(char, len);\n-    memcpy(buf, (char*)h_bytes->byte_at_addr(0), len);\n-    ClassFileStream st((u1*)buf, len, NULL, ClassFileStream::verify);\n-    regenerate_class(class_name, st, CHECK);\n-  }\n-}\n-\n-\/\/ check if a class name is a species\n-bool is_a_species(const char* species_name) {\n-  log_info(cds)(\"Checking class %s\", species_name);\n-  if (strstr(species_name, \"java\/lang\/invoke\/BoundMethodHandle$Species_\") != nullptr) {\n-    return true;\n+    if (strstr(class_name, \"java\/lang\/invoke\/BoundMethodHandle$Species_\") != nullptr) {\n+      \/\/ The species classes are already loaded into the system dictionary\n+      \/\/ during the execution of CDS.generateLambdaFormHolderClasses(). No\n+      \/\/ need to regenerate.\n+      TempNewSymbol class_name_sym = SymbolTable::new_symbol(class_name);\n+      Klass* klass = SystemDictionary::resolve_or_null(class_name_sym, THREAD);\n+      assert(klass != NULL, \"must already be loaded\");\n+      if (!klass->is_shared() && klass->shared_classpath_index() < 0) {\n+        \/\/ Fake it, so that it will be included into the archive.\n+        klass->set_shared_classpath_index(0);\n+        \/\/ Set the \"generated\" bit, so it won't interfere with JVMTI.\n+        \/\/ See SystemDictionaryShared::find_builtin_class().\n+        klass->set_is_generated_shared_class();\n+      }\n+    } else {\n+      int len = h_bytes->length();\n+      \/\/ make a copy of class bytes so GC will not affect us.\n+      char *buf = NEW_RESOURCE_ARRAY(char, len);\n+      memcpy(buf, (char*)h_bytes->byte_at_addr(0), len);\n+      ClassFileStream st((u1*)buf, len, NULL, ClassFileStream::verify);\n+      regenerate_class(class_name, st, CHECK);\n+    }\n@@ -183,1 +191,0 @@\n-  return false;\n@@ -186,14 +193,4 @@\n-void LambdaFormInvokers::regenerate_class(char* name, ClassFileStream& st, TRAPS) {\n-  Symbol* class_name = SymbolTable::new_symbol((const char*)name);\n-  \/\/ the class must exist\n-  Klass* klass = SystemDictionary::resolve_or_null(class_name, THREAD);\n-  if (klass == NULL) {\n-    log_info(cds)(\"Class %s not present, skip\", name);\n-    return;\n-  }\n-  \/\/ the species is shared in base archive, skip it.\n-  if (klass->is_regenerated() && is_a_species(name)) {\n-    log_info(cds)(\"Skip regenerating for shared  %s\", name);\n-    return;\n-  }\n-\n+void LambdaFormInvokers::regenerate_class(char* class_name, ClassFileStream& st, TRAPS) {\n+  TempNewSymbol class_name_sym = SymbolTable::new_symbol(class_name);\n+  Klass* klass = SystemDictionary::resolve_or_null(class_name_sym, THREAD);\n+  assert(klass != NULL, \"must exist\");\n@@ -207,1 +204,1 @@\n-                                                   class_name,\n+                                                   class_name_sym,\n@@ -223,1 +220,1 @@\n-  result->set_regenerated();  \/\/ mark for regenerated\n+  result->set_is_generated_shared_class();\n@@ -227,1 +224,1 @@\n-                 name, p2i(klass), p2i(result));\n+                 class_name, p2i(klass), p2i(result));\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.cpp","additions":29,"deletions":32,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -1344,1 +1344,2 @@\n-    \/\/ Those regenerated holder classes are in dynamic archive\n+    \/\/ Use the regenerated holder classes in the dynamic archive as they\n+    \/\/ have more methods than those in the base archive.\n@@ -1376,1 +1377,1 @@\n-    \/\/ We did not save the classfile data of the regenerated LambdaForm invoker classes,\n+    \/\/ We did not save the classfile data of the generated LambdaForm invoker classes,\n@@ -1378,1 +1379,1 @@\n-    if (record->_klass->is_regenerated() && JvmtiExport::should_post_class_file_load_hook()) {\n+    if (record->_klass->is_generated_shared_class() && JvmtiExport::should_post_class_file_load_hook()) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-  \/\/ Flags of the current shared class.\n+  \/\/ Various attributes for shared classes. Should be zero for a non-shared class.\n@@ -178,1 +178,1 @@\n-  enum {\n+  enum CDSSharedClassFlags {\n@@ -183,1 +183,3 @@\n-    _regenerated                           = 1 << 5\n+    \/\/ This class was not loaded from a classfile in the module image\n+    \/\/ or classpath.\n+    _is_generated_shared_class             = 1 << 5\n@@ -355,2 +357,2 @@\n-  void set_regenerated() {\n-    CDS_ONLY(_shared_class_flags |= _regenerated;)\n+  void set_is_generated_shared_class() {\n+    CDS_ONLY(_shared_class_flags |= _is_generated_shared_class;)\n@@ -358,2 +360,2 @@\n-  bool is_regenerated() const {\n-    CDS_ONLY(return (_shared_class_flags & _regenerated) != 0;)\n+  bool is_generated_shared_class() const {\n+    CDS_ONLY(return (_shared_class_flags & _is_generated_shared_class) != 0;)\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -31,0 +31,6 @@\n+        \/\/ The following calls trigger the generation of new Species classes\n+        \/\/ that are not included in the base archive (or the default modules image.\n+        \/\/ - java.lang.invoke.BoundMethodHandle$Species_F\n+        \/\/ - java.lang.invoke.BoundMethodHandle$Species_FL\n+        \/\/ - java.lang.invoke.BoundMethodHandle$Species_J\n+        \/\/ - java.lang.invoke.BoundMethodHandle$Species_JL\n@@ -33,1 +39,1 @@\n-        invoke(MethodHandles.identity(int.class), 1);\n+        invoke(MethodHandles.identity(int.class), 1); \/\/ Note: Species_IL is in default modules image.\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/CDSLambdaInvoker.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+             \"-Xlog:cds+class=debug\",\n@@ -50,1 +51,6 @@\n-                 output.shouldContain(\"Skip regenerating for shared\");\n+                 \/\/ This should be not be generated from the dynamic dump, as it should be included\n+                 \/\/ by the base archive.\n+                 output.shouldNotMatch(\"cds,class.*=.*java.lang.invoke.BoundMethodHandle.Species_IL\");\n+\n+                 \/\/ This should be generated from the dynamic dump\n+                 output.shouldMatch(\"cds,class.*=.*java.lang.invoke.BoundMethodHandle.Species_JL\");\n@@ -60,1 +66,5 @@\n-                 \/\/ java.lang.invoke.BoundMethodHandle$Species_JL is generated from CDSLambdaInvoker\n+                 \/\/ java.lang.invoke.BoundMethodHandle$Species_IL is loaded from base archive\n+                 output.shouldContain(\"java.lang.invoke.BoundMethodHandle$Species_IL source: shared objects file\");\n+\n+                 \/\/ java.lang.invoke.BoundMethodHandle$Species_JL is generated from CDSLambdaInvoker and\n+                 \/\/ stored in the dynamic archive\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestLambdaInvokers.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"}]}