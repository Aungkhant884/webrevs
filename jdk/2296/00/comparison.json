{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -201,7 +201,2 @@\n-  if (DynamicDumpSharedSpaces) {\n-    _buckets = DynamicArchive::buffer_to_target(buckets);\n-    _entries = DynamicArchive::buffer_to_target(entries);\n-  } else {\n-    _buckets = buckets;\n-    _entries = entries;\n-  }\n+  _buckets = buckets;\n+  _entries = entries;\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"memory\/archiveBuilder.hpp\"\n@@ -857,1 +858,3 @@\n-          assert(fd->signature() == vmSymbols::string_signature(),\n+          \/\/ Can't use vmSymbols::string_signature() as fd->signature() may have been relocated\n+          \/\/ during DumpSharedSpaces\n+          assert(fd->signature()->equals(\"Ljava\/lang\/String;\"),\n@@ -1124,0 +1127,15 @@\n+static void set_klass_field_in_archived_mirror(oop mirror_obj, int offset, Klass* k) {\n+  assert(java_lang_Class::is_instance(mirror_obj), \"must be\");\n+  \/\/ this is the copy of k in the output buffer\n+  Klass* copy = ArchiveBuilder::get_relocated_klass(k);\n+\n+  \/\/ This is the address of k, if the archive is loaded at the requested location\n+  Klass* def = ArchiveBuilder::current()->to_requested(copy);\n+\n+  log_debug(cds, heap, mirror)(\n+      \"Relocate mirror metadata field at %d from \" PTR_FORMAT \" ==> \" PTR_FORMAT,\n+      offset, p2i(k), p2i(def));\n+\n+  mirror_obj->metadata_field_put(offset, def);\n+}\n+\n@@ -1138,2 +1156,1 @@\n-        Klass *reloc_ak = MetaspaceShared::get_relocated_klass(ak, true);\n-        archived_m->metadata_field_put(_array_klass_offset, reloc_ak);\n+        set_klass_field_in_archived_mirror(archived_m, _array_klass_offset, ak);\n@@ -1261,5 +1278,1 @@\n-  Klass *reloc_k = MetaspaceShared::get_relocated_klass(as_Klass(mirror), true);\n-  log_debug(cds, heap, mirror)(\n-    \"Relocate mirror metadata field at _klass_offset from \" PTR_FORMAT \" ==> \" PTR_FORMAT,\n-    p2i(as_Klass(mirror)), p2i(reloc_k));\n-  archived_mirror->metadata_field_put(_klass_offset, reloc_k);\n+  set_klass_field_in_archived_mirror(archived_mirror, _klass_offset, as_Klass(mirror));\n@@ -1271,5 +1284,1 @@\n-    Klass *reloc_arr = MetaspaceShared::get_relocated_klass(arr, true);\n-    log_debug(cds, heap, mirror)(\n-      \"Relocate mirror metadata field at _array_klass_offset from \" PTR_FORMAT \" ==> \" PTR_FORMAT,\n-      p2i(arr), p2i(reloc_arr));\n-    archived_mirror->metadata_field_put(_array_klass_offset, reloc_arr);\n+    set_klass_field_in_archived_mirror(archived_mirror, _array_klass_offset, arr);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":22,"deletions":13,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -722,0 +722,1 @@\n+  assert(java_lang_String::is_instance(s), \"sanity\");\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -587,0 +587,1 @@\n+  ArchiveBuilder* builder = ArchiveBuilder::current();\n@@ -594,4 +595,1 @@\n-    if (DynamicDumpSharedSpaces) {\n-      sym = DynamicArchive::buffer_to_target(sym);\n-    }\n-    writer->add(fixed_hash, MetaspaceShared::object_delta_u4(sym));\n+    writer->add(fixed_hash, builder->buffer_to_offset_u4((address)sym));\n@@ -612,9 +610,0 @@\n-\n-    \/\/ Verify the written shared table is correct -- at this point,\n-    \/\/ vmSymbols has already been relocated to point to the archived\n-    \/\/ version of the Symbols.\n-    Symbol* sym = vmSymbols::java_lang_Object();\n-    const char* name = (const char*)sym->bytes();\n-    int len = sym->utf8_length();\n-    unsigned int hash = hash_symbol(name, len, _alt_hash);\n-    assert(sym == _shared_table.lookup(name, hash, len), \"sanity\");\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"memory\/archiveBuilder.hpp\"\n@@ -281,9 +282,0 @@\n-  template <typename T> static void original_to_target(T& field) {\n-    if (field != NULL) {\n-      if (DynamicDumpSharedSpaces) {\n-        field = DynamicArchive::original_to_target(field);\n-      }\n-      ArchivePtrMarker::mark_pointer(&field);\n-    }\n-  }\n-\n@@ -320,7 +312,7 @@\n-  void original_to_target() {\n-    original_to_target(_caller_ik);\n-    original_to_target(_instantiated_method_type);\n-    original_to_target(_invoked_name);\n-    original_to_target(_invoked_type);\n-    original_to_target(_member_method);\n-    original_to_target(_method_type);\n+  void mark_pointers() {\n+    ArchivePtrMarker::mark_pointer(&_caller_ik);\n+    ArchivePtrMarker::mark_pointer(&_instantiated_method_type);\n+    ArchivePtrMarker::mark_pointer(&_invoked_name);\n+    ArchivePtrMarker::mark_pointer(&_invoked_type);\n+    ArchivePtrMarker::mark_pointer(&_member_method);\n+    ArchivePtrMarker::mark_pointer(&_method_type);\n@@ -339,5 +331,5 @@\n-    return SystemDictionaryShared::hash_for_shared_dictionary(_caller_ik) +\n-           SystemDictionaryShared::hash_for_shared_dictionary(_invoked_name) +\n-           SystemDictionaryShared::hash_for_shared_dictionary(_invoked_type) +\n-           SystemDictionaryShared::hash_for_shared_dictionary(_method_type) +\n-           SystemDictionaryShared::hash_for_shared_dictionary(_instantiated_method_type);\n+    return SystemDictionaryShared::hash_for_shared_dictionary((address)_caller_ik) +\n+           SystemDictionaryShared::hash_for_shared_dictionary((address)_invoked_name) +\n+           SystemDictionaryShared::hash_for_shared_dictionary((address)_invoked_type) +\n+           SystemDictionaryShared::hash_for_shared_dictionary((address)_method_type) +\n+           SystemDictionaryShared::hash_for_shared_dictionary((address)_instantiated_method_type);\n@@ -408,4 +400,2 @@\n-    _key.original_to_target();\n-    _proxy_klass_head = DynamicDumpSharedSpaces ?\n-                          DynamicArchive::original_to_target(info._proxy_klasses->at(0)) :\n-                          info._proxy_klasses->at(0);\n+    _key.mark_pointers();\n+    _proxy_klass_head = info._proxy_klasses->at(0);\n@@ -606,7 +596,0 @@\n-  static u4 object_delta_u4(Symbol* sym) {\n-    if (DynamicDumpSharedSpaces) {\n-      sym = DynamicArchive::original_to_target(sym);\n-    }\n-    return MetaspaceShared::object_delta_u4(sym);\n-  }\n-\n@@ -614,0 +597,2 @@\n+    ArchiveBuilder* builder = ArchiveBuilder::current();\n+    assert(builder->is_in_buffer_space(info._klass), \"must be\");\n@@ -627,2 +612,2 @@\n-        vf_constraints[i]._name      = object_delta_u4(info._verifier_constraints->at(i)._name);\n-        vf_constraints[i]._from_name = object_delta_u4(info._verifier_constraints->at(i)._from_name);\n+        vf_constraints[i]._name      = builder->any_to_offset_u4(info._verifier_constraints->at(i)._name);\n+        vf_constraints[i]._from_name = builder->any_to_offset_u4(info._verifier_constraints->at(i)._from_name);\n@@ -638,1 +623,1 @@\n-        ld_constraints[i]._name = object_delta_u4(info._loader_constraints->at(i)._name);\n+        ld_constraints[i]._name = builder->any_to_offset_u4(info._loader_constraints->at(i)._name);\n@@ -646,3 +631,0 @@\n-      if (DynamicDumpSharedSpaces) {\n-        n_h = DynamicArchive::original_to_target(n_h);\n-      }\n@@ -651,1 +633,0 @@\n-    _klass = DynamicDumpSharedSpaces ? DynamicArchive::original_to_target(info._klass) : info._klass;\n@@ -684,7 +665,3 @@\n-    if (DynamicDumpSharedSpaces) {\n-      klass = DynamicArchive::original_to_buffer(klass);\n-      *info_pointer_addr(klass) = DynamicArchive::buffer_to_target(record);\n-    } else {\n-      *info_pointer_addr(klass) = record;\n-    }\n-\n+    assert(ArchiveBuilder::current()->is_in_buffer_space(klass), \"must be\");\n+    assert(ArchiveBuilder::current()->is_in_buffer_space(record), \"must be\");\n+    *info_pointer_addr(klass) = record;\n@@ -2028,0 +2005,15 @@\n+unsigned int SystemDictionaryShared::hash_for_shared_dictionary(address ptr) {\n+  if (ArchiveBuilder::is_active()) {\n+    uintx offset = ArchiveBuilder::current()->any_to_offset(ptr);\n+    unsigned int hash = primitive_hash<uintx>(offset);\n+    DEBUG_ONLY({\n+        if (MetaspaceObj::is_shared((const MetaspaceObj*)ptr)) {\n+          assert(hash == SystemDictionaryShared::hash_for_shared_dictionary_quick(ptr), \"must be\");\n+        }\n+      });\n+    return hash;\n+  } else {\n+    return SystemDictionaryShared::hash_for_shared_dictionary_quick(ptr);\n+  }\n+}\n+\n@@ -2030,0 +2022,1 @@\n+  ArchiveBuilder* _builder;\n@@ -2032,1 +2025,1 @@\n-    : _writer(writer) {}\n+  : _writer(writer), _builder(ArchiveBuilder::current()) {}\n@@ -2049,4 +2042,2 @@\n-    unsigned int hash = runtime_info->hash(); \/\/ Fields in runtime_info->_key already point to target space.\n-    u4 delta = DynamicDumpSharedSpaces ?\n-                 MetaspaceShared::object_delta_u4((void*)DynamicArchive::buffer_to_target(runtime_info)) :\n-                 MetaspaceShared::object_delta_u4((void*)runtime_info);\n+    unsigned int hash = runtime_info->hash();\n+    u4 delta = _builder->any_to_offset_u4((void*)runtime_info);\n@@ -2067,2 +2058,4 @@\n-        InstanceKlass* bk0 = DynamicDumpSharedSpaces ? DynamicArchive::original_to_buffer(ok0) : ok0;\n-        InstanceKlass* bk1 = DynamicDumpSharedSpaces ? DynamicArchive::original_to_buffer(ok1) : ok1;\n+        assert(ArchiveBuilder::current()->is_in_buffer_space(ok0), \"must be\");\n+        assert(ArchiveBuilder::current()->is_in_buffer_space(ok1), \"must be\");\n+        InstanceKlass* bk0 = ok0;\n+        InstanceKlass* bk1 = ok1;\n@@ -2076,5 +2069,2 @@\n-    if (DynamicDumpSharedSpaces) {\n-      DynamicArchive::original_to_buffer(info._proxy_klasses->at(0))->set_lambda_proxy_is_available();\n-    } else {\n-      info._proxy_klasses->at(0)->set_lambda_proxy_is_available();\n-    }\n+    info._proxy_klasses->at(0)->set_lambda_proxy_is_available();\n+\n@@ -2088,0 +2078,1 @@\n+  ArchiveBuilder *_builder;\n@@ -2091,1 +2082,1 @@\n-    : _writer(writer), _is_builtin(is_builtin) {}\n+    : _writer(writer), _is_builtin(is_builtin), _builder(ArchiveBuilder::current()) {}\n@@ -2102,10 +2093,2 @@\n-      if (DynamicDumpSharedSpaces) {\n-        name = DynamicArchive::original_to_target(name);\n-      }\n-      hash = SystemDictionaryShared::hash_for_shared_dictionary(name);\n-      u4 delta;\n-      if (DynamicDumpSharedSpaces) {\n-        delta = MetaspaceShared::object_delta_u4(DynamicArchive::buffer_to_target(record));\n-      } else {\n-        delta = MetaspaceShared::object_delta_u4(record);\n-      }\n+      hash = SystemDictionaryShared::hash_for_shared_dictionary((address)name);\n+      u4 delta = _builder->buffer_to_offset_u4((address)record);\n@@ -2202,1 +2185,1 @@\n-  unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary(name);\n+  unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary_quick(name);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":53,"deletions":70,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -344,1 +344,2 @@\n-  static unsigned int hash_for_shared_dictionary(T* ptr) {\n+  static unsigned int hash_for_shared_dictionary_quick(T* ptr) {\n+    assert(MetaspaceObj::is_shared((const MetaspaceObj*)ptr), \"must be\");\n@@ -346,2 +347,2 @@\n-    address p = address(ptr) - SharedBaseAddress;\n-    return primitive_hash<address>(p);\n+    uintx offset = uintx(ptr) - uintx(SharedBaseAddress);\n+    return primitive_hash<uintx>(offset);\n@@ -350,0 +351,2 @@\n+  static unsigned int hash_for_shared_dictionary(address ptr);\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"classfile\/symbolTable.hpp\"\n@@ -47,3 +48,1 @@\n-ArchiveBuilder* ArchiveBuilder::_singleton = NULL;\n-intx ArchiveBuilder::_buffer_to_target_delta = 0;\n-\n+ArchiveBuilder* ArchiveBuilder::_current = NULL;\n@@ -72,1 +71,1 @@\n-  char* newtop = ArchiveBuilder::singleton()->_ro_region->top();\n+  char* newtop = ArchiveBuilder::current()->_ro_region->top();\n@@ -164,2 +163,2 @@\n-  assert(_singleton == NULL, \"must be\");\n-  _singleton = this;\n+  assert(_current == NULL, \"must be\");\n+  _current = this;\n@@ -180,0 +179,2 @@\n+  _num_dump_regions_used = 0;\n+\n@@ -181,0 +182,10 @@\n+  _estimated_hashtable_bytes = 0;\n+  _estimated_trampoline_bytes = 0;\n+\n+  _requested_static_archive_bottom = NULL;\n+  _requested_static_archive_top = NULL;\n+  _mapped_static_archive_bottom = NULL;\n+  _mapped_static_archive_top = NULL;\n+  _requested_dynamic_archive_bottom = NULL;\n+  _requested_dynamic_archive_top = NULL;\n+  _buffer_to_requested_delta = 0;\n@@ -184,2 +195,2 @@\n-  assert(_singleton == this, \"must be\");\n-  _singleton = NULL;\n+  assert(_current == this, \"must be\");\n+  _current = NULL;\n@@ -285,0 +296,4 @@\n+\n+    \/\/ TODO -- we need a proper estimate for the archived modules, etc,\n+    \/\/ but this should be enough for now\n+    _estimated_metaspaceobj_bytes += 200 * 1024 * 1024;\n@@ -316,0 +331,87 @@\n+size_t ArchiveBuilder::estimate_archive_size() {\n+  \/\/ size of the symbol table and two dictionaries, plus the RunTimeSharedClassInfo's\n+  size_t symbol_table_est = SymbolTable::estimate_size_for_archive();\n+  size_t dictionary_est = SystemDictionaryShared::estimate_size_for_archive();\n+  _estimated_hashtable_bytes = symbol_table_est + dictionary_est;\n+\n+  _estimated_trampoline_bytes = allocate_method_trampoline_info();\n+\n+  size_t total = 0;\n+\n+  total += _estimated_metaspaceobj_bytes;\n+  total += _estimated_hashtable_bytes;\n+  total += _estimated_trampoline_bytes;\n+\n+  \/\/ allow fragmentation at the end of each dump region\n+  total += _total_dump_regions * reserve_alignment();\n+\n+  log_info(cds)(\"_estimated_hashtable_bytes = \" SIZE_FORMAT \" + \" SIZE_FORMAT \" = \" SIZE_FORMAT,\n+                symbol_table_est, dictionary_est, _estimated_hashtable_bytes);\n+  log_info(cds)(\"_estimated_metaspaceobj_bytes = \" SIZE_FORMAT, _estimated_metaspaceobj_bytes);\n+  log_info(cds)(\"_estimated_trampoline_bytes = \" SIZE_FORMAT, _estimated_trampoline_bytes);\n+  log_info(cds)(\"total estimate bytes = \" SIZE_FORMAT, total);\n+\n+  return align_up(total, reserve_alignment());\n+}\n+\n+address ArchiveBuilder::reserve_buffer() {\n+  size_t buffer_size = estimate_archive_size();\n+  ReservedSpace rs(buffer_size);\n+  if (!rs.is_reserved()) {\n+    log_error(cds)(\"Failed to reserve \" SIZE_FORMAT \" bytes of output buffer.\", buffer_size);\n+    vm_direct_exit(0);\n+  }\n+\n+  \/\/ buffer_bottom is the lowest address of the 3 core regions (mc, rw, ro) when\n+  \/\/ we are copying the class metadata into the buffer.\n+  address buffer_bottom = (address)rs.base();\n+  log_info(cds)(\"Reserved output buffer space at    : \" PTR_FORMAT \" [\" SIZE_FORMAT \" bytes]\",\n+                p2i(buffer_bottom), buffer_size);\n+  MetaspaceShared::set_shared_rs(rs);\n+\n+  MetaspaceShared::init_shared_dump_space(_mc_region);\n+  _buffer_bottom = buffer_bottom;\n+  _last_verified_top = buffer_bottom;\n+  _current_dump_space = _mc_region;\n+  _num_dump_regions_used = 1;\n+  _other_region_used_bytes = 0;\n+\n+  ArchivePtrMarker::initialize(&_ptrmap, (address*)_mc_region->base(), (address*)_mc_region->top());\n+\n+  \/\/ The bottom of the static archive should be mapped at this address by default.\n+  _requested_static_archive_bottom = (address)MetaspaceShared::requested_base_address();\n+\n+  \/\/ The bottom of the archive (that I am writing now) should be mapped at this address by default.\n+  address my_archive_requested_bottom;\n+\n+  if (DumpSharedSpaces) {\n+    my_archive_requested_bottom = _requested_static_archive_bottom;\n+  } else {\n+    _mapped_static_archive_bottom = (address)MetaspaceObj::shared_metaspace_base();\n+    _mapped_static_archive_top  = (address)MetaspaceObj::shared_metaspace_top();\n+    assert(_mapped_static_archive_top >= _mapped_static_archive_bottom, \"must be\");\n+    size_t static_archive_size = _mapped_static_archive_top - _mapped_static_archive_bottom;\n+\n+    \/\/ At run time, we will mmap the dynamic archive at my_archive_requested_bottom\n+    _requested_static_archive_top = _requested_static_archive_bottom + static_archive_size;\n+    my_archive_requested_bottom = align_up(_requested_static_archive_top, MetaspaceShared::reserved_space_alignment());\n+\n+    _requested_dynamic_archive_bottom = my_archive_requested_bottom;\n+  }\n+\n+  _buffer_to_requested_delta = my_archive_requested_bottom - _buffer_bottom;\n+\n+  address my_archive_requested_top = my_archive_requested_bottom + buffer_size;\n+  if (my_archive_requested_bottom <  _requested_static_archive_bottom ||\n+      my_archive_requested_top    <= _requested_static_archive_bottom) {\n+    \/\/ Size overflow.\n+    log_error(cds)(\"my_archive_requested_bottom = \" INTPTR_FORMAT, p2i(my_archive_requested_bottom));\n+    log_error(cds)(\"my_archive_requested_top    = \" INTPTR_FORMAT, p2i(my_archive_requested_top));\n+    log_error(cds)(\"SharedBaseAddress (\" INTPTR_FORMAT \") is too high. \"\n+                   \"Please rerun java -Xshare:dump with a lower value\", p2i(_requested_static_archive_bottom));\n+    vm_direct_exit(0);\n+  }\n+\n+  return buffer_bottom;\n+}\n+\n@@ -566,0 +668,1 @@\n+  log_info(cds)(\"Relocating external roots ... \");\n@@ -570,0 +673,1 @@\n+  log_info(cds)(\"done\");\n@@ -572,2 +676,2 @@\n-void ArchiveBuilder::relocate_pointers() {\n-  log_info(cds)(\"Relocating embedded pointers ... \");\n+void ArchiveBuilder::relocate_metaspaceobj_embedded_pointers() {\n+  log_info(cds)(\"Relocating embedded pointers in core regions ... \");\n@@ -577,5 +681,0 @@\n-\n-  log_info(cds)(\"Relocating external roots ... \");\n-  relocate_roots();\n-\n-  log_info(cds)(\"done\");\n@@ -616,1 +715,92 @@\n-        log_debug(cds, class)(\"klasses[%4d] = \" PTR_FORMAT \" %s\", i, p2i(to_target(ik)), ik->external_name());\n+        log_debug(cds, class)(\"klasses[%4d] = \" PTR_FORMAT \" %s\", i, p2i(to_requested(ik)), ik->external_name());\n+      }\n+    }\n+  }\n+}\n+\n+uintx ArchiveBuilder::buffer_to_offset(address p) const {\n+  address requested_p = to_requested(p);\n+  assert(requested_p >= _requested_static_archive_bottom, \"must be\");\n+  return requested_p - _requested_static_archive_bottom;\n+}\n+\n+uintx ArchiveBuilder::any_to_offset(address p) const {\n+  if (is_in_mapped_static_archive(p)) {\n+    return p - _mapped_static_archive_bottom;\n+  }\n+  return buffer_to_offset(p);\n+}\n+\n+\/\/ Update a Java object to point its Klass* to the new location after\n+\/\/ shared archive has been compacted.\n+void ArchiveBuilder::relocate_klass_ptr(oop o) {\n+  assert(DumpSharedSpaces, \"sanity\");\n+  Klass* k = get_relocated_klass(o->klass());\n+  Klass* requested_k = to_requested(k);\n+  narrowKlass nk = CompressedKlassPointers::encode_not_null(requested_k, _requested_static_archive_bottom);\n+  o->set_narrow_klass(nk);\n+}\n+\n+\/\/ RelocateBufferToRequested --- Relocate all the pointers in mc\/rw\/ro,\n+\/\/ so that the archive can be mapped to the \"requested\" location without runtime relocation.\n+\/\/\n+\/\/ - See ArchiveBuilder header for the definition of \"buffer\", \"mapped\" and \"requested\"\n+\/\/ - ArchivePtrMarker::ptrmap() marks all the pointers in the mc\/rw\/ro regions\n+\/\/ - Every pointer must have one of the following values:\n+\/\/   [a] NULL:\n+\/\/       No relocation is needed. Remove this pointer from ptrmap so we don't need to\n+\/\/       consider it at runtime.\n+\/\/   [b] Points into an object X which is inside the buffer:\n+\/\/       Adjust this pointer by _buffer_to_requested_delta, so it points to X\n+\/\/       when the archive is mapped at the requested location.\n+\/\/   [c] Points into an object Y which is inside mapped static archive:\n+\/\/       - This happens only during dynamic dump\n+\/\/       - Adjust this pointer by _mapped_to_requested_static_archive_delta,\n+\/\/         so it points to Y when the static archive is mapped at the requested location.\n+template <bool STATIC_DUMP>\n+class RelocateBufferToRequested : public BitMapClosure {\n+  ArchiveBuilder* _builder;\n+  address _buffer_bottom;\n+  intx _buffer_to_requested_delta;\n+  intx _mapped_to_requested_static_archive_delta;\n+  size_t _max_non_null_offset;\n+\n+ public:\n+  RelocateBufferToRequested(ArchiveBuilder* builder) {\n+    _builder = builder;\n+    _buffer_bottom = _builder->buffer_bottom();\n+    _buffer_to_requested_delta = builder->buffer_to_requested_delta();\n+    _mapped_to_requested_static_archive_delta = builder->requested_static_archive_bottom() - builder->mapped_static_archive_bottom();\n+    _max_non_null_offset = 0;\n+\n+    address bottom = _builder->buffer_bottom();\n+    address top = _builder->buffer_top();\n+    address new_bottom = bottom + _buffer_to_requested_delta;\n+    address new_top = top + _buffer_to_requested_delta;\n+    log_debug(cds)(\"Relocating archive from [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \" ] to \"\n+                   \"[\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \" ]\",\n+                   p2i(bottom), p2i(top),\n+                   p2i(new_bottom), p2i(new_top));\n+  }\n+\n+  bool do_bit(size_t offset) {\n+    address* p = (address*)_buffer_bottom + offset;\n+    assert(_builder->is_in_buffer_space(p), \"pointer must live in buffer space\");\n+\n+    if (*p == NULL) {\n+      \/\/ todo -- clear bit, etc\n+      ArchivePtrMarker::ptrmap()->clear_bit(offset);\n+    } else {\n+      if (STATIC_DUMP) {\n+        assert(_builder->is_in_buffer_space(*p), \"old pointer must point inside buffer space\");\n+        *p += _buffer_to_requested_delta;\n+        assert(_builder->is_in_requested_static_archive(*p), \"new pointer must point inside requested archive\");\n+      } else {\n+        if (_builder->is_in_buffer_space(*p)) {\n+          *p += _buffer_to_requested_delta;\n+          \/\/ assert is in requested dynamic archive\n+        } else {\n+          assert(_builder->is_in_mapped_static_archive(*p), \"old pointer must point inside buffer space or mapped static archive\");\n+          *p += _mapped_to_requested_static_archive_delta;\n+          assert(_builder->is_in_requested_static_archive(*p), \"new pointer must point inside requested archive\");\n+        }\n@@ -618,0 +808,1 @@\n+      _max_non_null_offset = offset;\n@@ -619,0 +810,23 @@\n+\n+    return true; \/\/ keep iterating\n+  }\n+\n+  void doit() {\n+    ArchivePtrMarker::ptrmap()->iterate(this);\n+    ArchivePtrMarker::compact(_max_non_null_offset);\n+  }\n+};\n+\n+\n+void ArchiveBuilder::relocate_to_requested() {\n+  size_t my_archive_size = buffer_top() - buffer_bottom();\n+\n+  if (DumpSharedSpaces) {\n+    _requested_static_archive_top = _requested_static_archive_bottom + my_archive_size;\n+    RelocateBufferToRequested<true> patcher(this);\n+    patcher.doit();\n+  } else {\n+    assert(DynamicDumpSharedSpaces, \"must be\");\n+    _requested_dynamic_archive_top = _requested_dynamic_archive_bottom + my_archive_size;\n+    RelocateBufferToRequested<false> patcher(this);\n+    patcher.doit();\n@@ -635,1 +849,1 @@\n-    \/\/ Translate the buffers used by the MC\/RW\/RO regions to their eventual locations\n+    \/\/ Translate the buffers used by the MC\/RW\/RO regions to their eventual (requested) locations\n@@ -637,1 +851,1 @@\n-    return _buffer_to_target_delta + MetaspaceShared::final_delta();\n+    return ArchiveBuilder::current()->buffer_to_requested_delta();\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.cpp","additions":232,"deletions":18,"binary":false,"changes":250,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -43,0 +44,16 @@\n+\/\/ Overview of CDS archive creation (for both static and dynamic dump):\n+\/\/\n+\/\/ [1] Load all classes (static dump: from the classlist, dynamic dump: as part of app execution)\n+\/\/ [2] Allocate \"output buffer\"\n+\/\/ [3] Copy contents of the 3 \"core\" regions (mc\/rw\/ro) into the output buffer.\n+\/\/       - mc region:\n+\/\/         allocate_method_trampolines();\n+\/\/         allocate the cpp vtables (static dump only)\n+\/\/       - memcpy the MetaspaceObjs into rw\/ro:\n+\/\/         dump_rw_region();\n+\/\/         dump_ro_region();\n+\/\/       - fix all the pointers in the MetaspaceObjs to point to the copies\n+\/\/         relocate_metaspaceobj_embedded_pointers()\n+\/\/ [4] Copy symbol table, dictionary, etc, into the ro region\n+\/\/ [5] Relocate all the pointers in mc\/rw\/ro, so that the archive can be mapped to\n+\/\/     the \"requested\" location without runtime relocation. See relocate_to_requested()\n@@ -44,0 +61,26 @@\n+protected:\n+  DumpRegion* _current_dump_space;\n+  address _buffer_bottom;                      \/\/ for writing the contents of mc\/rw\/ro regions\n+  address _last_verified_top;\n+  int _num_dump_regions_used;\n+  size_t _other_region_used_bytes;\n+\n+  \/\/ These are the addresses where we will request the static and dynamic archives to be\n+  \/\/ mapped at run time. If the request fails (due to ASLR), we will map the archives at\n+  \/\/ os-selected addresses.\n+  address _requested_static_archive_bottom;     \/\/ This is determined solely by the value of\n+                                                \/\/ SharedBaseAddress during -Xshare:dump.\n+  address _requested_static_archive_top;\n+  address _requested_dynamic_archive_bottom;    \/\/ Used only during dynamic dump. It's placed\n+                                                \/\/ immediately above _requested_static_archive_top.\n+  address _requested_dynamic_archive_top;\n+\n+  \/\/ (Used only during dynamic dump) where the static archive is actually mapped. This\n+  \/\/ may be different than _requested_static_archive_{bottom,top} due to ASLR\n+  address _mapped_static_archive_bottom;\n+  address _mapped_static_archive_top;\n+\n+  intx _buffer_to_requested_delta;\n+\n+  DumpRegion* current_dump_space() const {  return _current_dump_space;  }\n+\n@@ -149,0 +192,1 @@\n+  CHeapBitMap _ptrmap;    \/\/ bitmap used by ArchivePtrMarker\n@@ -164,1 +208,1 @@\n-  static ArchiveBuilder* _singleton;\n+  static ArchiveBuilder* _current;\n@@ -174,1 +218,1 @@\n-      _oldtop = _singleton->_ro_region->top();\n+      _oldtop = _current->_ro_region->top();\n@@ -193,1 +237,0 @@\n-  void relocate_roots();\n@@ -197,0 +240,1 @@\n+\n@@ -202,0 +246,2 @@\n+  size_t _estimated_hashtable_bytes;     \/\/ symbol table and dictionaries\n+  size_t _estimated_trampoline_bytes;    \/\/ method entry trampolines\n@@ -203,3 +249,1 @@\n-protected:\n-  DumpRegion* _current_dump_space;\n-  address _alloc_bottom;\n+  static const int _total_dump_regions = 3;\n@@ -207,1 +251,5 @@\n-  DumpRegion* current_dump_space() const {  return _current_dump_space;  }\n+  size_t estimate_archive_size();\n+\n+  static size_t reserve_alignment() {\n+    return os::vm_allocation_granularity();\n+  }\n@@ -211,0 +259,7 @@\n+  address reserve_buffer();\n+\n+  address buffer_bottom()                    const { return _buffer_bottom;                       }\n+  address buffer_top()                       const { return (address)current_dump_space()->top(); }\n+  address requested_static_archive_bottom()  const { return  _requested_static_archive_bottom;    }\n+  address mapped_static_archive_bottom()     const { return  _mapped_static_archive_bottom;       }\n+  intx buffer_to_requested_delta()           const { return _buffer_to_requested_delta;           }\n@@ -213,1 +268,5 @@\n-    return (_alloc_bottom <= p && p < (address)current_dump_space()->top());\n+    return (buffer_bottom() <= p && p < buffer_top());\n+  }\n+\n+  template <typename T> bool is_in_requested_static_archive(T p) const {\n+    return _requested_static_archive_bottom <= (address)p && (address)p < _requested_static_archive_top;\n@@ -216,3 +275,2 @@\n-  template <typename T> bool is_in_target_space(T target_obj) const {\n-    address buff_obj = address(target_obj) - _buffer_to_target_delta;\n-    return is_in_buffer_space(buff_obj);\n+  template <typename T> bool is_in_mapped_static_archive(T p) const {\n+    return _mapped_static_archive_bottom <= (address)p && (address)p < _mapped_static_archive_top;\n@@ -225,2 +283,3 @@\n-  template <typename T> T to_target_no_check(T obj) const {\n-    return (T)(address(obj) + _buffer_to_target_delta);\n+  template <typename T> T to_requested(T obj) const {\n+    assert(is_in_buffer_space(obj), \"must be\");\n+    return (T)(address(obj) + _buffer_to_requested_delta);\n@@ -229,3 +288,27 @@\n-  template <typename T> T to_target(T obj) const {\n-    assert(is_in_buffer_space(obj), \"must be\");\n-    return (T)(address(obj) + _buffer_to_target_delta);\n+  static intx get_buffer_to_requested_delta() {\n+    return current()->buffer_to_requested_delta();\n+  }\n+\n+public:\n+  static const uintx MAX_SHARED_DELTA = 0x7FFFFFFF;\n+\n+  \/\/ The address p points to an object inside the output buffer. When the archive is mapped\n+  \/\/ at the requested address, what's the offset of this object from _requested_static_archive_bottom?\n+  uintx buffer_to_offset(address p) const;\n+\n+  \/\/ Same as buffer_to_offset, except that the address p points to either (a) an object\n+  \/\/ inside the output buffer, or (b), an object in the currently mapped static archive.\n+  uintx any_to_offset(address p) const;\n+\n+  template <typename T>\n+  u4 buffer_to_offset_u4(T p) const {\n+    uintx offset = buffer_to_offset((address)p);\n+    guarantee(offset <= MAX_SHARED_DELTA, \"must be 32-bit offset\");\n+    return (u4)offset;\n+  }\n+\n+  template <typename T>\n+  u4 any_to_offset_u4(T p) const {\n+    uintx offset = any_to_offset((address)p);\n+    guarantee(offset <= MAX_SHARED_DELTA, \"must be 32-bit offset\");\n+    return (u4)offset;\n@@ -247,1 +330,2 @@\n-  void relocate_pointers();\n+  void relocate_metaspaceobj_embedded_pointers();\n+  void relocate_roots();\n@@ -250,0 +334,1 @@\n+  void relocate_to_requested();\n@@ -261,3 +346,7 @@\n-  static ArchiveBuilder* singleton() {\n-    assert(_singleton != NULL, \"ArchiveBuilder must be active\");\n-    return _singleton;\n+  static bool is_active() {\n+    return (_current != NULL);\n+  }\n+\n+  static ArchiveBuilder* current() {\n+    assert(_current != NULL, \"ArchiveBuilder must be active\");\n+    return _current;\n@@ -267,1 +356,1 @@\n-    return singleton()->_alloc_stats;\n+    return current()->_alloc_stats;\n@@ -270,0 +359,2 @@\n+  void relocate_klass_ptr(oop o);\n+\n@@ -271,1 +362,1 @@\n-    Klass* klass = (Klass*)singleton()->get_dumped_addr((address)orig_klass);\n+    Klass* klass = (Klass*)current()->get_dumped_addr((address)orig_klass);\n@@ -277,1 +368,1 @@\n-    return (Symbol*)singleton()->get_dumped_addr((address)orig_symbol);\n+    return (Symbol*)current()->get_dumped_addr((address)orig_symbol);\n@@ -281,1 +372,0 @@\n-  static intx _buffer_to_target_delta;\n@@ -288,1 +378,0 @@\n-\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.hpp","additions":114,"deletions":25,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"memory\/archiveBuilder.hpp\"\n@@ -152,0 +153,3 @@\n+  MetaspaceShared::commit_to(_rs, _vs, newtop);\n+  _top = newtop;\n+\n@@ -153,7 +157,2 @@\n-    uintx delta;\n-    if (DynamicDumpSharedSpaces) {\n-      delta = DynamicArchive::object_delta_uintx(newtop);\n-    } else {\n-      delta = MetaspaceShared::object_delta_uintx(newtop);\n-    }\n-    if (delta > MAX_SHARED_DELTA) {\n+    uintx delta = ArchiveBuilder::current()->buffer_to_offset((address)(newtop-1));\n+    if (delta > ArchiveBuilder::MAX_SHARED_DELTA) {\n@@ -168,2 +167,0 @@\n-  MetaspaceShared::commit_to(_rs, _vs, newtop);\n-  _top = newtop;\n@@ -195,1 +192,1 @@\n-                 p2i(_base + MetaspaceShared::final_delta()));\n+                 p2i(ArchiveBuilder::current()->to_requested(_base)));\n","filename":"src\/hotspot\/share\/memory\/archiveUtils.cpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,0 @@\n-template <bool COMPACTING>\n@@ -107,6 +106,0 @@\n-  \/\/ The following fields are used only when COMPACTING == true;\n-  \/\/ The highest offset (inclusive) in the bitmap that contains a non-null pointer.\n-  \/\/ This is used at dump time to reduce the size of the bitmap (which may have been over-allocated).\n-  size_t _max_non_null_offset;\n-  CHeapBitMap* _ptrmap;\n-\n@@ -116,2 +109,1 @@\n-                      address valid_new_base, address valid_new_end, intx delta,\n-                      CHeapBitMap* ptrmap = NULL) :\n+                      address valid_new_base, address valid_new_end, intx delta) :\n@@ -128,14 +120,0 @@\n-    if (COMPACTING) {\n-      assert(ptrmap != NULL, \"must be\");\n-      _max_non_null_offset = 0;\n-      _ptrmap = ptrmap;\n-    } else {\n-      \/\/ Don't touch the _max_non_null_offset and _ptrmap fields. Hopefully a good C++ compiler can\n-      \/\/ elide them.\n-      assert(ptrmap == NULL, \"must be\");\n-    }\n-  }\n-\n-  size_t max_non_null_offset() {\n-    assert(COMPACTING, \"must be\");\n-    return _max_non_null_offset;\n@@ -144,1 +122,1 @@\n-  inline bool do_bit(size_t offset);\n+  bool do_bit(size_t offset);\n","filename":"src\/hotspot\/share\/memory\/archiveUtils.hpp","additions":3,"deletions":25,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,1 @@\n-template <bool COMPACTING>\n-inline bool SharedDataRelocator<COMPACTING>::do_bit(size_t offset) {\n+inline bool SharedDataRelocator::do_bit(size_t offset) {\n@@ -37,20 +36,2 @@\n-  if (old_ptr == NULL) {\n-    assert(COMPACTING, \"NULL pointers should not be marked when relocating at run-time\");\n-  } else {\n-    assert(_valid_old_base <= old_ptr && old_ptr < _valid_old_end, \"must be\");\n-  }\n-\n-  if (COMPACTING) {\n-    \/\/ Start-up performance: use a template parameter to elide this block for run-time archive\n-    \/\/ relocation.\n-    assert(Arguments::is_dumping_archive(), \"Don't do this during run-time archive loading!\");\n-    if (old_ptr == NULL) {\n-      _ptrmap->clear_bit(offset);\n-      DEBUG_ONLY(log_trace(cds, reloc)(\"Clearing pointer [\" PTR_FORMAT  \"] -> NULL @ \" SIZE_FORMAT_W(9), p2i(p), offset));\n-      return true;\n-    } else {\n-      _max_non_null_offset = offset;\n-    }\n-  } else {\n-    assert(old_ptr != NULL, \"bits for NULL pointers should have been cleaned at dump time\");\n-  }\n+  assert(_valid_old_base <= old_ptr && old_ptr < _valid_old_end, \"must be\");\n+  assert(old_ptr != NULL, \"bits for NULL pointers should have been cleaned at dump time\");\n","filename":"src\/hotspot\/share\/memory\/archiveUtils.inline.hpp","additions":4,"deletions":23,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"runtime\/os.inline.hpp\"\n+#include \"runtime\/os.hpp\"\n@@ -55,3 +55,0 @@\n-  static const int _total_dump_regions = 3;\n-  int _num_dump_regions_used;\n-\n@@ -75,10 +72,2 @@\n-    if (!MetaspaceShared::is_in_shared_metaspace(a_name)) {\n-      \/\/ a_name points to a Symbol in the top archive.\n-      \/\/ When this method is called, a_name is still pointing to the output space.\n-      \/\/ Translate it to point to the output space, so that it can be compared with\n-      \/\/ Symbols in the base archive.\n-      a_name = (Symbol*)(address(a_name) + _buffer_to_target_delta);\n-    }\n-    if (!MetaspaceShared::is_in_shared_metaspace(b_name)) {\n-      b_name = (Symbol*)(address(b_name) + _buffer_to_target_delta);\n-    }\n+    u4 a_offset = ArchiveBuilder::current()->any_to_offset_u4(a_name);\n+    u4 b_offset = ArchiveBuilder::current()->any_to_offset_u4(b_name);\n@@ -86,1 +75,6 @@\n-    return a_name->fast_compare(b_name);\n+    if (a_offset < b_offset) {\n+      return -1;\n+    } else {\n+      assert(a_offset > b_offset, \"must be\");\n+      return 1;\n+    }\n@@ -91,6 +85,0 @@\n-  address _last_verified_top;\n-  size_t _other_region_used_bytes;\n-\n-  \/\/ Conservative estimate for number of bytes needed for:\n-  size_t _estimated_hashtable_bytes;     \/\/ symbol table and dictionaries\n-  size_t _estimated_trampoline_bytes;    \/\/ method entry trampolines\n@@ -98,4 +86,1 @@\n-  size_t estimate_archive_size();\n-  size_t estimate_class_file_size();\n-  address reserve_space_and_init_buffer_to_target_delta();\n-  void init_header(address addr);\n+  void init_header();\n@@ -106,1 +91,0 @@\n-  void relocate_buffer_to_target();\n@@ -109,11 +93,0 @@\n-  void init_first_dump_space(address reserved_bottom) {\n-    DumpRegion* mc_space = MetaspaceShared::misc_code_dump_space();\n-    DumpRegion* rw_space = MetaspaceShared::read_write_dump_space();\n-\n-    \/\/ Use the same MC->RW->RO ordering as in the base archive.\n-    MetaspaceShared::init_shared_dump_space(mc_space);\n-    _current_dump_space = mc_space;\n-    _last_verified_top = reserved_bottom;\n-    _num_dump_regions_used = 1;\n-  }\n-\n@@ -124,4 +97,0 @@\n-    _estimated_hashtable_bytes = 0;\n-    _estimated_trampoline_bytes = 0;\n-\n-    _num_dump_regions_used = 0;\n@@ -175,6 +144,3 @@\n-    \/\/ rw space starts ...\n-    address reserved_bottom = reserve_space_and_init_buffer_to_target_delta();\n-    init_header(reserved_bottom);\n-\n-    CHeapBitMap ptrmap;\n-    ArchivePtrMarker::initialize(&ptrmap, (address*)reserved_bottom, (address*)current_dump_space()->top());\n+    \/\/ mc space starts ...\n+    reserve_buffer();\n+    init_header();\n@@ -186,0 +152,1 @@\n+    \/\/ rw space starts ...\n@@ -197,1 +164,2 @@\n-    relocate_pointers();\n+    relocate_metaspaceobj_embedded_pointers();\n+    relocate_roots();\n@@ -228,2 +196,1 @@\n-    log_info(cds)(\"Final relocation of pointers ... \");\n-    relocate_buffer_to_target();\n+    relocate_to_requested();\n@@ -239,3 +206,0 @@\n-    if (!is_relocating_pointers) {\n-      SystemDictionaryShared::dumptime_classes_do(it);\n-    }\n@@ -243,0 +207,1 @@\n+    SystemDictionaryShared::dumptime_classes_do(it);\n@@ -246,63 +211,1 @@\n-size_t DynamicArchiveBuilder::estimate_archive_size() {\n-  \/\/ size of the symbol table and two dictionaries, plus the RunTimeSharedClassInfo's\n-  size_t symbol_table_est = SymbolTable::estimate_size_for_archive();\n-  size_t dictionary_est = SystemDictionaryShared::estimate_size_for_archive();\n-  _estimated_hashtable_bytes = symbol_table_est + dictionary_est;\n-\n-  _estimated_trampoline_bytes = allocate_method_trampoline_info();\n-\n-  size_t total = 0;\n-\n-  total += _estimated_metaspaceobj_bytes;\n-  total += _estimated_hashtable_bytes;\n-  total += _estimated_trampoline_bytes;\n-\n-  \/\/ allow fragmentation at the end of each dump region\n-  total += _total_dump_regions * reserve_alignment();\n-\n-  log_info(cds, dynamic)(\"_estimated_hashtable_bytes = \" SIZE_FORMAT \" + \" SIZE_FORMAT \" = \" SIZE_FORMAT,\n-                         symbol_table_est, dictionary_est, _estimated_hashtable_bytes);\n-  log_info(cds, dynamic)(\"_estimated_metaspaceobj_bytes = \" SIZE_FORMAT, _estimated_metaspaceobj_bytes);\n-  log_info(cds, dynamic)(\"_estimated_trampoline_bytes = \" SIZE_FORMAT, _estimated_trampoline_bytes);\n-  log_info(cds, dynamic)(\"total estimate bytes = \" SIZE_FORMAT, total);\n-\n-  return align_up(total, reserve_alignment());\n-}\n-\n-address DynamicArchiveBuilder::reserve_space_and_init_buffer_to_target_delta() {\n-  size_t total = estimate_archive_size();\n-  ReservedSpace rs(total);\n-  if (!rs.is_reserved()) {\n-    log_error(cds, dynamic)(\"Failed to reserve %d bytes of output buffer.\", (int)total);\n-    vm_direct_exit(0);\n-  }\n-\n-  address buffer_base = (address)rs.base();\n-  log_info(cds, dynamic)(\"Reserved output buffer space at    : \" PTR_FORMAT \" [%d bytes]\",\n-                         p2i(buffer_base), (int)total);\n-  MetaspaceShared::set_shared_rs(rs);\n-\n-  \/\/ At run time, we will mmap the dynamic archive at target_space_bottom.\n-  \/\/ However, at dump time, we may not be able to write into the target_space,\n-  \/\/ as it's occupied by dynamically loaded Klasses. So we allocate a buffer\n-  \/\/ at an arbitrary location chosen by the OS. We will write all the dynamically\n-  \/\/ archived classes into this buffer. At the final stage of dumping, we relocate\n-  \/\/ all pointers that are inside the buffer_space to point to their (runtime)\n-  \/\/ target location inside thetarget_space.\n-  address target_space_bottom =\n-    (address)align_up(MetaspaceShared::shared_metaspace_top(), reserve_alignment());\n-  _buffer_to_target_delta = intx(target_space_bottom) - intx(buffer_base);\n-\n-  log_info(cds, dynamic)(\"Target archive space at            : \" PTR_FORMAT, p2i(target_space_bottom));\n-  log_info(cds, dynamic)(\"Buffer-space to target-space delta : \" PTR_FORMAT, p2i((address)_buffer_to_target_delta));\n-\n-  return buffer_base;\n-}\n-\n-void DynamicArchiveBuilder::init_header(address reserved_bottom) {\n-  _alloc_bottom = reserved_bottom;\n-  _last_verified_top = reserved_bottom;\n-  _other_region_used_bytes = 0;\n-\n-  init_first_dump_space(reserved_bottom);\n-\n+void DynamicArchiveBuilder::init_header() {\n@@ -362,1 +265,2 @@\n-    log_debug(cds, dynamic)(\"sorting methods for \" PTR_FORMAT \" %s\", p2i(to_target(ik)), ik->external_name());\n+    log_debug(cds, dynamic)(\"sorting methods for \" PTR_FORMAT \" (\" PTR_FORMAT \") %s\",\n+                            p2i(ik), p2i(to_requested(ik)), ik->external_name());\n@@ -430,81 +334,0 @@\n-class RelocateBufferToTarget: public BitMapClosure {\n-  DynamicArchiveBuilder *_builder;\n-  address* _buffer_bottom;\n-  intx _buffer_to_target_delta;\n- public:\n-  RelocateBufferToTarget(DynamicArchiveBuilder* builder, address* bottom, intx delta) :\n-    _builder(builder), _buffer_bottom(bottom), _buffer_to_target_delta(delta) {}\n-\n-  bool do_bit(size_t offset) {\n-    address* p = _buffer_bottom + offset;\n-    assert(_builder->is_in_buffer_space(p), \"pointer must live in buffer space\");\n-\n-    address old_ptr = *p;\n-    if (_builder->is_in_buffer_space(old_ptr)) {\n-      address new_ptr = old_ptr + _buffer_to_target_delta;\n-      log_trace(cds, dynamic)(\"Final patch: @%6d [\" PTR_FORMAT \" -> \" PTR_FORMAT \"] \" PTR_FORMAT \" => \" PTR_FORMAT,\n-                              (int)offset, p2i(p), p2i(_builder->to_target(p)),\n-                              p2i(old_ptr), p2i(new_ptr));\n-      *p = new_ptr;\n-    }\n-\n-    return true; \/\/ keep iterating\n-  }\n-};\n-\n-void DynamicArchiveBuilder::relocate_buffer_to_target() {\n-  RelocateBufferToTarget patcher(this, (address*)_alloc_bottom, _buffer_to_target_delta);\n-  ArchivePtrMarker::ptrmap()->iterate(&patcher);\n-\n-  Array<u8>* table = FileMapInfo::saved_shared_path_table().table();\n-  SharedPathTable runtime_table(to_target(table), FileMapInfo::shared_path_table().size());\n-  _header->set_shared_path_table(runtime_table);\n-\n-  address relocatable_base = (address)SharedBaseAddress;\n-  address relocatable_end = (address)(current_dump_space()->top()) + _buffer_to_target_delta;\n-\n-  intx addr_delta = MetaspaceShared::final_delta();\n-  if (addr_delta == 0) {\n-    ArchivePtrMarker::compact(relocatable_base, relocatable_end);\n-  } else {\n-    \/\/ The base archive is NOT mapped at MetaspaceShared::requested_base_address() (due to ASLR).\n-    \/\/ This means that the current content of the dynamic archive is based on a random\n-    \/\/ address. Let's relocate all the pointers, so that it can be mapped to\n-    \/\/ MetaspaceShared::requested_base_address() without runtime relocation.\n-    \/\/\n-    \/\/ Note: both the base and dynamic archive are written with\n-    \/\/ FileMapHeader::_requested_base_address == MetaspaceShared::requested_base_address()\n-\n-    \/\/ Patch all pointers that are marked by ptrmap within this region,\n-    \/\/ where we have just dumped all the metaspace data.\n-    address patch_base = (address)_alloc_bottom;\n-    address patch_end  = (address)current_dump_space()->top();\n-\n-    \/\/ the current value of the pointers to be patched must be within this\n-    \/\/ range (i.e., must point to either the top archive (as currently mapped), or to the\n-    \/\/ (targeted address of) the top archive)\n-    address valid_old_base = relocatable_base;\n-    address valid_old_end  = relocatable_end;\n-    size_t base_plus_top_size = valid_old_end - valid_old_base;\n-    size_t top_size = patch_end - patch_base;\n-    size_t base_size = base_plus_top_size - top_size;\n-    assert(base_plus_top_size > base_size, \"no overflow\");\n-    assert(base_plus_top_size > top_size, \"no overflow\");\n-\n-    \/\/ after patching, the pointers must point inside this range\n-    \/\/ (the requested location of the archive, as mapped at runtime).\n-    address valid_new_base = (address)MetaspaceShared::requested_base_address();\n-    address valid_new_end  = valid_new_base + base_plus_top_size;\n-\n-    log_debug(cds)(\"Relocating archive from [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"] to \"\n-                   \"[\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"], delta = \" INTX_FORMAT \" bytes\",\n-                   p2i(patch_base + base_size), p2i(patch_end),\n-                   p2i(valid_new_base + base_size), p2i(valid_new_end), addr_delta);\n-\n-    SharedDataRelocator<true> patcher((address*)patch_base, (address*)patch_end, valid_old_base, valid_old_end,\n-                                      valid_new_base, valid_new_end, addr_delta, ArchivePtrMarker::ptrmap());\n-    ArchivePtrMarker::ptrmap()->iterate(&patcher);\n-    ArchivePtrMarker::compact(patcher.max_non_null_offset());\n-  }\n-}\n-\n@@ -515,1 +338,4 @@\n-  _header->set_serialized_data(to_target(serialized_data));\n+  Array<u8>* table = FileMapInfo::saved_shared_path_table().table();\n+  SharedPathTable runtime_table(table, FileMapInfo::shared_path_table().size());\n+  _header->set_shared_path_table(runtime_table);\n+  _header->set_serialized_data(serialized_data);\n@@ -525,1 +351,1 @@\n-  dynamic_info->set_final_requested_base((char*)MetaspaceShared::requested_base_address());\n+  dynamic_info->set_requested_base((char*)MetaspaceShared::requested_base_address());\n@@ -534,2 +360,2 @@\n-  address base = to_target(_alloc_bottom);\n-  address top  = address(current_dump_space()->top()) + _buffer_to_target_delta;\n+  address base = _requested_dynamic_archive_bottom;\n+  address top  = _requested_dynamic_archive_top;\n@@ -538,2 +364,0 @@\n-  base += MetaspaceShared::final_delta();\n-  top += MetaspaceShared::final_delta();\n@@ -543,0 +367,1 @@\n+\n@@ -575,1 +400,0 @@\n-  _builder = &builder;\n@@ -578,34 +402,0 @@\n-  _builder = NULL;\n-}\n-\n-address DynamicArchive::original_to_buffer_impl(address orig_obj) {\n-  assert(DynamicDumpSharedSpaces, \"must be\");\n-  address buff_obj = _builder->get_dumped_addr(orig_obj);\n-  assert(buff_obj != NULL, \"orig_obj must be used by the dynamic archive\");\n-  assert(buff_obj != orig_obj, \"call this only when you know orig_obj must be copied and not just referenced\");\n-  assert(_builder->is_in_buffer_space(buff_obj), \"must be\");\n-  return buff_obj;\n-}\n-\n-address DynamicArchive::buffer_to_target_impl(address buff_obj) {\n-  assert(DynamicDumpSharedSpaces, \"must be\");\n-  assert(_builder->is_in_buffer_space(buff_obj), \"must be\");\n-  return _builder->to_target(buff_obj);\n-}\n-\n-address DynamicArchive::original_to_target_impl(address orig_obj) {\n-  assert(DynamicDumpSharedSpaces, \"must be\");\n-  if (MetaspaceShared::is_in_shared_metaspace(orig_obj)) {\n-    \/\/ This happens when the top archive points to a Symbol* in the base archive.\n-    return orig_obj;\n-  }\n-  address buff_obj = _builder->get_dumped_addr(orig_obj);\n-  assert(buff_obj != NULL, \"orig_obj must be used by the dynamic archive\");\n-  if (buff_obj == orig_obj) {\n-    \/\/ We are storing a pointer to an original object into the dynamic buffer. E.g.,\n-    \/\/ a Symbol* that used by both the base and top archives.\n-    assert(MetaspaceShared::is_in_shared_metaspace(orig_obj), \"must be\");\n-    return orig_obj;\n-  } else {\n-    return _builder->to_target(buff_obj);\n-  }\n@@ -614,16 +404,0 @@\n-uintx DynamicArchive::object_delta_uintx(void* buff_obj) {\n-  assert(DynamicDumpSharedSpaces, \"must be\");\n-  address target_obj = _builder->to_target_no_check(address(buff_obj));\n-  assert(uintx(target_obj) >= SharedBaseAddress, \"must be\");\n-  return uintx(target_obj) - SharedBaseAddress;\n-}\n-\n-bool DynamicArchive::is_in_target_space(void *obj) {\n-  assert(DynamicDumpSharedSpaces, \"must be\");\n-  return _builder->is_in_target_space(obj);\n-}\n-\n-\n-DynamicArchiveBuilder* DynamicArchive::_builder = NULL;\n-\n-\n","filename":"src\/hotspot\/share\/memory\/dynamicArchive.cpp","additions":29,"deletions":255,"binary":false,"changes":284,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,5 +61,0 @@\n-  static class DynamicArchiveBuilder* _builder;\n-  static address original_to_target_impl(address orig_obj);\n-  static address original_to_buffer_impl(address orig_obj);\n-  static address buffer_to_target_impl(address buff_obj);\n-\n@@ -68,34 +63,0 @@\n-\n-  \/\/ obj is a copy of a MetaspaceObj, stored in the dumping buffer.\n-  \/\/\n-  \/\/ The return value is the runtime targeted location of this object as\n-  \/\/ mapped from the dynamic archive.\n-  template <typename T> static T buffer_to_target(T buff_obj) {\n-    return (T)buffer_to_target_impl(address(buff_obj));\n-  }\n-\n-  \/\/ obj is an original MetaspaceObj used by the JVM (e.g., a valid Symbol* in the\n-  \/\/ SymbolTable).\n-  \/\/\n-  \/\/ The return value is the runtime targeted location of this object as\n-  \/\/ mapped from the dynamic archive.\n-  template <typename T> static T original_to_target(T obj) {\n-    return (T)original_to_target_impl(address(obj));\n-  }\n-\n-  \/\/ obj is an original MetaspaceObj use by the JVM (e.g., a valid Symbol* in the\n-  \/\/ SymbolTable).\n-  \/\/\n-  \/\/ The return value is the location of this object in the dump time\n-  \/\/ buffer space\n-  template <typename T> static T original_to_buffer(T obj) {\n-    return (T)original_to_buffer_impl(address(obj));\n-  }\n-\n-  \/\/ Delta of this object from SharedBaseAddress\n-  static uintx object_delta_uintx(void* buff_obj);\n-\n-  \/\/ Does obj point to an address inside the runtime target space of the dynamic\n-  \/\/ archive?\n-  static bool is_in_target_space(void *obj);\n-\n","filename":"src\/hotspot\/share\/memory\/dynamicArchive.hpp","additions":1,"deletions":40,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"memory\/archiveBuilder.hpp\"\n@@ -1258,1 +1259,1 @@\n-void FileMapRegion::init(int region_index, char* base, size_t size, bool read_only,\n+void FileMapRegion::init(int region_index, size_t mapping_offset, size_t size, bool read_only,\n@@ -1262,15 +1263,1 @@\n-  _mapping_offset = 0;\n-\n-  if (_is_heap_region) {\n-    assert(!DynamicDumpSharedSpaces, \"must be\");\n-    assert((base - (char*)CompressedKlassPointers::base()) % HeapWordSize == 0, \"Sanity\");\n-    if (base != NULL) {\n-      _mapping_offset = (size_t)CompressedOops::encode_not_null((oop)base);\n-      assert(_mapping_offset == (size_t)(uint32_t)_mapping_offset, \"must be 32-bit only\");\n-    }\n-  } else {\n-    if (base != NULL) {\n-      assert(base >= (char*)SharedBaseAddress, \"must be\");\n-      _mapping_offset = base - (char*)SharedBaseAddress;\n-    }\n-  }\n+  _mapping_offset = mapping_offset;\n@@ -1317,1 +1304,2 @@\n-  char* target_base;\n+  char* requested_base;\n+  size_t mapping_offset = 0;\n@@ -1320,1 +1308,9 @@\n-    target_base = NULL; \/\/ always NULL for bm region.\n+    requested_base = NULL; \/\/ always NULL for bm region\n+  } else if (size == 0) {\n+    \/\/ This is an unused region (e.g., a heap region when !INCLUDE_CDS_JAVA_HEAP)\n+    requested_base = NULL;\n+  } else if (HeapShared::is_heap_region(region)) {\n+    assert(!DynamicDumpSharedSpaces, \"must be\");\n+    requested_base = base;\n+    mapping_offset = (size_t)CompressedOops::encode_not_null((oop)base);\n+    assert(mapping_offset == (size_t)(uint32_t)mapping_offset, \"must be 32-bit only\");\n@@ -1322,6 +1318,4 @@\n-    if (DynamicDumpSharedSpaces) {\n-      assert(!HeapShared::is_heap_region(region), \"dynamic archive doesn't support heap regions\");\n-      target_base = DynamicArchive::buffer_to_target(base);\n-    } else {\n-      target_base = base;\n-    }\n+    char* requested_SharedBaseAddress = (char*)MetaspaceShared::requested_base_address();\n+    requested_base = ArchiveBuilder::current()->to_requested(base);\n+    assert(requested_base >= requested_SharedBaseAddress, \"must be\");\n+    mapping_offset = requested_base - requested_SharedBaseAddress;\n@@ -1331,1 +1325,0 @@\n-  char* requested_base = (target_base == NULL) ? NULL : target_base + MetaspaceShared::final_delta();\n@@ -1334,1 +1327,1 @@\n-    log_debug(cds)(\"Shared file region (%-3s)  %d: \" SIZE_FORMAT_W(8)\n+    log_info(cds)(\"Shared file region (%-3s)  %d: \" SIZE_FORMAT_W(8)\n@@ -1339,1 +1332,1 @@\n-  si->init(region, target_base, size, read_only, allow_exec, crc);\n+  si->init(region, mapping_offset, size, read_only, allow_exec, crc);\n@@ -1497,4 +1490,0 @@\n-void FileMapInfo::set_final_requested_base(char* b) {\n-  header()->set_final_requested_base(b);\n-}\n-\n@@ -1578,1 +1567,1 @@\n-  if (addr_delta != 0 && !relocate_pointers(addr_delta)) {\n+  if (addr_delta != 0 && !relocate_pointers_in_core_regions(addr_delta)) {\n@@ -1691,1 +1680,3 @@\n-bool FileMapInfo::relocate_pointers(intx addr_delta) {\n+\/\/ This is called when we cannot map the archive at the requested[ base address (usually 0x800000000).\n+\/\/ We relocate all pointers in the 3 core regions (mc, ro, rw).\n+bool FileMapInfo::relocate_pointers_in_core_regions(intx addr_delta) {\n@@ -1696,1 +1687,1 @@\n-    return false;\n+    return false; \/\/ OOM, or CRC check failure\n@@ -1719,2 +1710,2 @@\n-    SharedDataRelocator<false> patcher((address*)patch_base, (address*)patch_end, valid_old_base, valid_old_end,\n-                                       valid_new_base, valid_new_end, addr_delta);\n+    SharedDataRelocator patcher((address*)patch_base, (address*)patch_end, valid_old_base, valid_old_end,\n+                                valid_new_base, valid_new_end, addr_delta);\n@@ -2194,0 +2185,4 @@\n+void FileMapHeader::set_as_offset(char* p, size_t *offset) {\n+  *offset = ArchiveBuilder::current()->any_to_offset((address)p);\n+}\n+\n","filename":"src\/hotspot\/share\/memory\/filemap.cpp","additions":31,"deletions":36,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -172,1 +172,1 @@\n-  void init(int region_index, char* base, size_t size, bool read_only,\n+  void init(int region_index, size_t mapping_offset, size_t size, bool read_only,\n@@ -244,4 +244,1 @@\n-  void set_mapped_offset(char* p, size_t *offset) {\n-    assert(p >= mapped_base_address(), \"sanity\");\n-    *offset = p - mapped_base_address();\n-  }\n+  void set_as_offset(char* p, size_t *offset);\n@@ -290,2 +287,2 @@\n-  void set_cloned_vtables(char* p)               { set_mapped_offset(p, &_cloned_vtables_offset); }\n-  void set_serialized_data(char* p)              { set_mapped_offset(p, &_serialized_data_offset); }\n+  void set_cloned_vtables(char* p)               { set_as_offset(p, &_cloned_vtables_offset); }\n+  void set_serialized_data(char* p)              { set_as_offset(p, &_serialized_data_offset); }\n@@ -299,1 +296,1 @@\n-    set_mapped_offset((char*)p, &_i2i_entry_code_buffers_offset);\n+    set_as_offset((char*)p, &_i2i_entry_code_buffers_offset);\n@@ -303,1 +300,1 @@\n-    set_mapped_offset((char*)table.table(), &_shared_path_table_offset);\n+    set_as_offset((char*)table.table(), &_shared_path_table_offset);\n@@ -307,1 +304,1 @@\n-  void set_final_requested_base(char* b) {\n+  void set_requested_base(char* b) {\n@@ -424,3 +421,0 @@\n-  void set_final_requested_base(char* b);\n-\n-  char* requested_base_address()           const { return header()->requested_base_address(); }\n@@ -428,0 +422,2 @@\n+  void set_requested_base(char* b)                  { header()->set_requested_base(b); }\n+  char* requested_base_address()           const    { return header()->requested_base_address(); }\n@@ -581,1 +577,1 @@\n-  bool  relocate_pointers(intx addr_delta);\n+  bool  relocate_pointers_in_core_regions(intx addr_delta);\n","filename":"src\/hotspot\/share\/memory\/filemap.hpp","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -268,1 +268,0 @@\n-    MetaspaceShared::relocate_klass_ptr(archived_oop);\n@@ -304,1 +303,1 @@\n-    Klass* k = klasses->at(i);\n+    Klass* k = ArchiveBuilder::get_relocated_klass(klasses->at(i));\n@@ -456,1 +455,1 @@\n-  Klass* relocated_k = MetaspaceShared::get_relocated_klass(k);\n+  Klass* relocated_k = ArchiveBuilder::get_relocated_klass(k);\n@@ -466,1 +465,1 @@\n-  Klass* relocated_k = MetaspaceShared::get_relocated_klass(k);\n+  Klass* relocated_k = ArchiveBuilder::get_relocated_klass(k);\n@@ -486,1 +485,1 @@\n-void KlassSubGraphInfo::add_subgraph_object_klass(Klass* orig_k, Klass* relocated_k) {\n+void KlassSubGraphInfo::add_subgraph_object_klass(Klass* orig_k) {\n@@ -488,2 +487,1 @@\n-  assert(relocated_k == MetaspaceShared::get_relocated_klass(orig_k),\n-         \"must be the relocated Klass in the shared space\");\n+  Klass* relocated_k = ArchiveBuilder::get_relocated_klass(orig_k);\n@@ -496,1 +494,1 @@\n-  assert(ArchiveBuilder::singleton()->is_in_buffer_space(relocated_k), \"must be a shared class\");\n+  assert(ArchiveBuilder::current()->is_in_buffer_space(relocated_k), \"must be a shared class\");\n@@ -621,2 +619,2 @@\n-      unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary(klass);\n-      u4 delta = MetaspaceShared::object_delta_u4(record);\n+      unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary((address)klass);\n+      u4 delta = ArchiveBuilder::current()->any_to_offset_u4(record);\n@@ -743,1 +741,4 @@\n-  unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary(k);\n+  if (!k->is_shared()) {\n+    return NULL;\n+  }\n+  unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary_quick(k);\n@@ -774,1 +775,5 @@\n-        resolve_or_init(klasses->at(i), do_init, CHECK_NULL);\n+        Klass* klass = klasses->at(i);\n+        if (!klass->is_shared()) {\n+          return NULL;\n+        }\n+        resolve_or_init(klass, do_init, CHECK_NULL);\n@@ -831,1 +836,1 @@\n-  unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary(k);\n+  unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary_quick(k);\n@@ -1023,2 +1028,1 @@\n-  Klass *relocated_k = archived_obj->klass();\n-  subgraph_info->add_subgraph_object_klass(orig_k, relocated_k);\n+  subgraph_info->add_subgraph_object_klass(orig_k);\n@@ -1407,0 +1411,1 @@\n+  ArchiveBuilder* builder = DumpSharedSpaces ? ArchiveBuilder::current() : NULL;\n@@ -1413,0 +1418,3 @@\n+    if (DumpSharedSpaces) {\n+      builder->relocate_klass_ptr(o);\n+    }\n","filename":"src\/hotspot\/share\/memory\/heapShared.cpp","additions":24,"deletions":16,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-  void add_subgraph_object_klass(Klass *orig_k, Klass *relocated_k);\n+  void add_subgraph_object_klass(Klass *orig_k);\n","filename":"src\/hotspot\/share\/memory\/heapShared.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -675,0 +675,5 @@\n+  if (DumpSharedSpaces) {\n+    assert(!UseSharedSpaces, \"sanity\");\n+    MetaspaceShared::initialize_for_static_dump();\n+  }\n+\n@@ -676,1 +681,1 @@\n-  \/\/ a) if CDS is active (either dump time or runtime), it will create the ccs\n+  \/\/ a) if CDS archive has been mapped, it will create the ccs\n@@ -679,1 +684,1 @@\n-  \/\/ b) if CDS is not active, we will create the ccs on our own. It will be\n+  \/\/ b) otherwise, we will create the ccs on our own. It will be\n@@ -686,3 +691,1 @@\n-  if (DumpSharedSpaces) {\n-    MetaspaceShared::initialize_dumptime_shared_and_meta_spaces();\n-  } else if (UseSharedSpaces) {\n+  if (UseSharedSpaces) {\n@@ -702,1 +705,1 @@\n-    assert(!UseSharedSpaces && !DumpSharedSpaces, \"CDS should be off at this point\");\n+    assert(!UseSharedSpaces, \"CDS archive is not mapped at this point\");\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-static bool shared_base_too_high(char* shared_base, size_t cds_total) {\n+static bool shared_base_too_high(char* shared_base, size_t cds_max) {\n@@ -181,1 +181,1 @@\n-  if (max_uintx - uintx(shared_base) < uintx(cds_total)) {\n+  if (max_uintx - uintx(shared_base) < uintx(cds_max)) {\n@@ -189,1 +189,1 @@\n-static char* compute_shared_base(size_t cds_total) {\n+static char* compute_shared_base(size_t cds_max) {\n@@ -192,1 +192,1 @@\n-  if (shared_base_too_high(shared_base, cds_total)) {\n+  if (shared_base_too_high(shared_base, cds_max)) {\n@@ -204,1 +204,1 @@\n-  assert(!shared_base_too_high(shared_base, cds_total) && shared_base_valid(shared_base), \"Sanity\");\n+  assert(!shared_base_too_high(shared_base, cds_max) && shared_base_valid(shared_base), \"Sanity\");\n@@ -208,1 +208,1 @@\n-void MetaspaceShared::initialize_dumptime_shared_and_meta_spaces() {\n+void MetaspaceShared::initialize_for_static_dump() {\n@@ -211,0 +211,3 @@\n+  \/\/ The max allowed size for CDS archive. We use this to limit SharedBaseAddress\n+  \/\/ to avoid address space wrap around.\n+  size_t cds_max;\n@@ -214,3 +217,0 @@\n-  \/\/ On 64-bit VM we reserve a 4G range and, if UseCompressedClassPointers=1,\n-  \/\/  will use that to house both the archives and the ccs. See below for\n-  \/\/  details.\n@@ -218,1 +218,1 @@\n-  const size_t cds_total = align_down(UnscaledClassSpaceMax, reserve_alignment);\n+  cds_max = align_down(UnscaledClassSpaceMax, reserve_alignment);\n@@ -222,1 +222,1 @@\n-  size_t cds_total = align_down(256*M, reserve_alignment);\n+  cds_max = align_down(256*M, reserve_alignment);\n@@ -225,122 +225,2 @@\n-  char* shared_base = compute_shared_base(cds_total);\n-  _requested_base_address = shared_base;\n-\n-  \/\/ Whether to use SharedBaseAddress as attach address.\n-  bool use_requested_base = true;\n-\n-  if (shared_base == NULL) {\n-    use_requested_base = false;\n-  }\n-\n-  if (ArchiveRelocationMode == 1) {\n-    log_info(cds)(\"ArchiveRelocationMode == 1: always allocate class space at an alternative address\");\n-    use_requested_base = false;\n-  }\n-\n-  \/\/ First try to reserve the space at the specified SharedBaseAddress.\n-  assert(!_shared_rs.is_reserved(), \"must be\");\n-  if (use_requested_base) {\n-    _shared_rs = ReservedSpace(cds_total, reserve_alignment,\n-                               false \/* large *\/, (char*)shared_base);\n-    if (_shared_rs.is_reserved()) {\n-      assert(_shared_rs.base() == shared_base, \"should match\");\n-    } else {\n-      log_info(cds)(\"dumptime space reservation: failed to map at \"\n-                    \"SharedBaseAddress \" PTR_FORMAT, p2i(shared_base));\n-    }\n-  }\n-  if (!_shared_rs.is_reserved()) {\n-    \/\/ Get a reserved space anywhere if attaching at the SharedBaseAddress\n-    \/\/  fails:\n-    if (UseCompressedClassPointers) {\n-      \/\/ If we need to reserve class space as well, let the platform handle\n-      \/\/  the reservation.\n-      LP64_ONLY(_shared_rs =\n-                Metaspace::reserve_address_space_for_compressed_classes(cds_total);)\n-      NOT_LP64(ShouldNotReachHere();)\n-    } else {\n-      \/\/ anywhere is fine.\n-      _shared_rs = ReservedSpace(cds_total, reserve_alignment,\n-                                 false \/* large *\/, (char*)NULL);\n-    }\n-  }\n-\n-  if (!_shared_rs.is_reserved()) {\n-    vm_exit_during_initialization(\"Unable to reserve memory for shared space\",\n-                                  err_msg(SIZE_FORMAT \" bytes.\", cds_total));\n-  }\n-\n-#ifdef _LP64\n-\n-  if (UseCompressedClassPointers) {\n-\n-    assert(CompressedKlassPointers::is_valid_base((address)_shared_rs.base()), \"Sanity\");\n-\n-    \/\/ On 64-bit VM, if UseCompressedClassPointers=1, the compressed class space\n-    \/\/  must be allocated near the cds such as that the compressed Klass pointer\n-    \/\/  encoding can be used to en\/decode pointers from both cds and ccs. Since\n-    \/\/  Metaspace cannot do this (it knows nothing about cds), we do it for\n-    \/\/  Metaspace here and pass it the space to use for ccs.\n-    \/\/\n-    \/\/ We do this by reserving space for the ccs behind the archives. Note\n-    \/\/  however that ccs follows a different alignment\n-    \/\/  (Metaspace::reserve_alignment), so there may be a gap between ccs and\n-    \/\/  cds.\n-    \/\/ We use a similar layout at runtime, see reserve_address_space_for_archives().\n-    \/\/\n-    \/\/                              +-- SharedBaseAddress (default = 0x800000000)\n-    \/\/                              v\n-    \/\/ +-..---------+---------+ ... +----+----+----+--------+-----------------+\n-    \/\/ |    Heap    | Archive |     | MC | RW | RO | [gap]  |    class space  |\n-    \/\/ +-..---------+---------+ ... +----+----+----+--------+-----------------+\n-    \/\/ |<--   MaxHeapSize  -->|     |<-- UnscaledClassSpaceMax = 4GB -->|\n-    \/\/\n-    \/\/ Note: ccs must follow the archives, and the archives must start at the\n-    \/\/  encoding base. However, the exact placement of ccs does not matter as\n-    \/\/  long as it it resides in the encoding range of CompressedKlassPointers\n-    \/\/  and comes after the archive.\n-    \/\/\n-    \/\/ We do this by splitting up the allocated 4G into 3G of archive space,\n-    \/\/  followed by 1G for the ccs:\n-    \/\/ + The upper 1 GB is used as the \"temporary compressed class space\"\n-    \/\/   -- preload_classes() will store Klasses into this space.\n-    \/\/ + The lower 3 GB is used for the archive -- when preload_classes()\n-    \/\/   is done, ArchiveBuilder will copy the class metadata into this\n-    \/\/   space, first the RW parts, then the RO parts.\n-\n-    \/\/ Starting address of ccs must be aligned to Metaspace::reserve_alignment()...\n-    size_t class_space_size = align_down(_shared_rs.size() \/ 4, Metaspace::reserve_alignment());\n-    address class_space_start = (address)align_down(_shared_rs.end() - class_space_size, Metaspace::reserve_alignment());\n-    size_t archive_size = class_space_start - (address)_shared_rs.base();\n-\n-    ReservedSpace tmp_class_space = _shared_rs.last_part(archive_size);\n-    _shared_rs = _shared_rs.first_part(archive_size);\n-\n-    \/\/ ... as does the size of ccs.\n-    tmp_class_space = tmp_class_space.first_part(class_space_size);\n-    CompressedClassSpaceSize = class_space_size;\n-\n-    \/\/ Let Metaspace initialize ccs\n-    Metaspace::initialize_class_space(tmp_class_space);\n-\n-    \/\/ and set up CompressedKlassPointers encoding.\n-    CompressedKlassPointers::initialize((address)_shared_rs.base(), cds_total);\n-\n-    log_info(cds)(\"narrow_klass_base = \" PTR_FORMAT \", narrow_klass_shift = %d\",\n-                  p2i(CompressedKlassPointers::base()), CompressedKlassPointers::shift());\n-\n-    log_info(cds)(\"Allocated temporary class space: \" SIZE_FORMAT \" bytes at \" PTR_FORMAT,\n-                  CompressedClassSpaceSize, p2i(tmp_class_space.base()));\n-\n-    assert(_shared_rs.end() == tmp_class_space.base() &&\n-           is_aligned(_shared_rs.base(), MetaspaceShared::reserved_space_alignment()) &&\n-           is_aligned(tmp_class_space.base(), Metaspace::reserve_alignment()) &&\n-           is_aligned(tmp_class_space.size(), Metaspace::reserve_alignment()), \"Sanity\");\n-  }\n-\n-#endif\n-\n-  init_shared_dump_space(&_mc_region);\n-  SharedBaseAddress = (size_t)_shared_rs.base();\n-  log_info(cds)(\"Allocated shared space: \" SIZE_FORMAT \" bytes at \" PTR_FORMAT,\n-                _shared_rs.size(), p2i(_shared_rs.base()));\n+  _requested_base_address = compute_shared_base(cds_max);\n+  SharedBaseAddress = (size_t)_requested_base_address;\n@@ -465,4 +345,0 @@\n-void MetaspaceShared::initialize_ptr_marker(CHeapBitMap* ptrmap) {\n-  ArchivePtrMarker::initialize(ptrmap, (address*)_shared_vs.low(), (address*)_shared_vs.high());\n-}\n-\n@@ -531,12 +407,0 @@\n-uintx MetaspaceShared::object_delta_uintx(void* obj) {\n-  Arguments::assert_is_dumping_archive();\n-  if (DumpSharedSpaces) {\n-    assert(shared_rs()->contains(obj), \"must be\");\n-  } else {\n-    assert(is_in_shared_metaspace(obj) || DynamicArchive::is_in_target_space(obj), \"must be\");\n-  }\n-  address base_address = address(SharedBaseAddress);\n-  uintx deltax = address(obj) - base_address;\n-  return deltax;\n-}\n-\n@@ -604,1 +468,0 @@\n-  void relocate_to_requested_base_address(CHeapBitMap* ptrmap);\n@@ -622,4 +485,1 @@\n-    : ArchiveBuilder(mc_region, rw_region, ro_region) {\n-    _alloc_bottom = address(SharedBaseAddress);\n-    _buffer_to_target_delta = 0;\n-  }\n+    : ArchiveBuilder(mc_region, rw_region, ro_region) {}\n@@ -664,40 +524,0 @@\n-void VM_PopulateDumpSharedSpace::relocate_to_requested_base_address(CHeapBitMap* ptrmap) {\n-  intx addr_delta = MetaspaceShared::final_delta();\n-  if (addr_delta == 0) {\n-    ArchivePtrMarker::compact((address)SharedBaseAddress, (address)_ro_region.top());\n-  } else {\n-    \/\/ We are not able to reserve space at MetaspaceShared::requested_base_address() (due to ASLR).\n-    \/\/ This means that the current content of the archive is based on a random\n-    \/\/ address. Let's relocate all the pointers, so that it can be mapped to\n-    \/\/ MetaspaceShared::requested_base_address() without runtime relocation.\n-    \/\/\n-    \/\/ Note: both the base and dynamic archive are written with\n-    \/\/ FileMapHeader::_requested_base_address == MetaspaceShared::requested_base_address()\n-\n-    \/\/ Patch all pointers that are marked by ptrmap within this region,\n-    \/\/ where we have just dumped all the metaspace data.\n-    address patch_base = (address)SharedBaseAddress;\n-    address patch_end  = (address)_ro_region.top();\n-    size_t size = patch_end - patch_base;\n-\n-    \/\/ the current value of the pointers to be patched must be within this\n-    \/\/ range (i.e., must point to valid metaspace objects)\n-    address valid_old_base = patch_base;\n-    address valid_old_end  = patch_end;\n-\n-    \/\/ after patching, the pointers must point inside this range\n-    \/\/ (the requested location of the archive, as mapped at runtime).\n-    address valid_new_base = (address)MetaspaceShared::requested_base_address();\n-    address valid_new_end  = valid_new_base + size;\n-\n-    log_debug(cds)(\"Relocating archive from [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \" ] to \"\n-                   \"[\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \" ]\", p2i(patch_base), p2i(patch_end),\n-                   p2i(valid_new_base), p2i(valid_new_end));\n-\n-    SharedDataRelocator<true> patcher((address*)patch_base, (address*)patch_end, valid_old_base, valid_old_end,\n-                                      valid_new_base, valid_new_end, addr_delta, ptrmap);\n-    ptrmap->iterate(&patcher);\n-    ArchivePtrMarker::compact(patcher.max_non_null_offset());\n-  }\n-}\n-\n@@ -706,2 +526,0 @@\n-  CHeapBitMap ptrmap;\n-  MetaspaceShared::initialize_ptr_marker(&ptrmap);\n@@ -738,1 +556,0 @@\n-  builder.set_current_dump_space(&_mc_region);\n@@ -740,0 +557,1 @@\n+  builder.reserve_buffer();\n@@ -775,3 +593,1 @@\n-  builder.relocate_pointers();\n-\n-  dump_shared_symbol_table(builder.symbols());\n+  builder.relocate_metaspaceobj_embedded_pointers();\n@@ -784,0 +600,3 @@\n+  builder.relocate_roots();\n+  dump_shared_symbol_table(builder.symbols());\n+\n@@ -803,1 +622,1 @@\n-  relocate_to_requested_base_address(&ptrmap);\n+  builder.relocate_to_requested();\n@@ -828,1 +647,1 @@\n-  mapinfo->set_final_requested_base((char*)MetaspaceShared::requested_base_address());\n+  mapinfo->set_requested_base((char*)MetaspaceShared::requested_base_address());\n@@ -924,17 +743,0 @@\n-\/\/ Update a Java object to point its Klass* to the new location after\n-\/\/ shared archive has been compacted.\n-void MetaspaceShared::relocate_klass_ptr(oop o) {\n-  assert(DumpSharedSpaces, \"sanity\");\n-  Klass* k = ArchiveBuilder::get_relocated_klass(o->klass());\n-  o->set_klass(k);\n-}\n-\n-Klass* MetaspaceShared::get_relocated_klass(Klass *k, bool is_final) {\n-  assert(DumpSharedSpaces, \"sanity\");\n-  k = ArchiveBuilder::get_relocated_klass(k);\n-  if (is_final) {\n-    k = (Klass*)(address(k) + final_delta());\n-  }\n-  return k;\n-}\n-\n@@ -1841,7 +1643,0 @@\n-\/\/ This is used to relocate the pointers so that the base archive can be mapped at\n-\/\/ MetaspaceShared::requested_base_address() without runtime relocation.\n-intx MetaspaceShared::final_delta() {\n-  return intx(MetaspaceShared::requested_base_address())  \/\/ We want the base archive to be mapped to here at runtime\n-       - intx(SharedBaseAddress);                         \/\/ .. but the base archive is mapped at here at dump time\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":21,"deletions":226,"binary":false,"changes":247,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,0 @@\n-#define MAX_SHARED_DELTA                (0x7FFFFFFF)\n-\n@@ -128,1 +126,1 @@\n-  static void initialize_dumptime_shared_and_meta_spaces() NOT_CDS_RETURN;\n+  static void initialize_for_static_dump() NOT_CDS_RETURN;\n@@ -134,10 +132,0 @@\n-  \/\/ Delta of this object from SharedBaseAddress\n-  static uintx object_delta_uintx(void* obj);\n-\n-  static u4 object_delta_u4(void* obj) {\n-    \/\/ offset is guaranteed to be less than MAX_SHARED_DELTA in DumpRegion::expand_top_to()\n-    uintx deltax = object_delta_uintx(obj);\n-    guarantee(deltax <= MAX_SHARED_DELTA, \"must be 32-bit offset\");\n-    return (u4)deltax;\n-  }\n-\n@@ -242,3 +230,0 @@\n-  static void relocate_klass_ptr(oop o);\n-  static Klass* get_relocated_klass(Klass *k, bool is_final=false);\n-\n@@ -255,1 +240,1 @@\n-  static intx final_delta();\n+\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.hpp","additions":3,"deletions":18,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,0 +184,1 @@\n+  static inline Klass* decode_raw(narrowKlass v, address base);\n@@ -186,0 +187,1 @@\n+  static inline Klass* decode_not_null(narrowKlass v, address base);\n@@ -188,0 +190,1 @@\n+  static inline narrowKlass encode_not_null(Klass* v, address base);\n","filename":"src\/hotspot\/share\/oops\/compressedOops.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,2 +120,6 @@\n-    return (Klass*)(void*)((uintptr_t)base() +((uintptr_t)v << shift()));\n-  }\n+  return decode_raw(v, base());\n+}\n+\n+inline Klass* CompressedKlassPointers::decode_raw(narrowKlass v, address narrow_base) {\n+  return (Klass*)(void*)((uintptr_t)narrow_base +((uintptr_t)v << shift()));\n+}\n@@ -124,0 +128,4 @@\n+  return decode_not_null(v, base());\n+}\n+\n+inline Klass* CompressedKlassPointers::decode_not_null(narrowKlass v, address narrow_base) {\n@@ -125,1 +133,1 @@\n-  Klass* result = decode_raw(v);\n+  Klass* result = decode_raw(v, narrow_base);\n@@ -135,0 +143,4 @@\n+  return encode_not_null(v, base());\n+}\n+\n+inline narrowKlass CompressedKlassPointers::encode_not_null(Klass* v, address narrow_base) {\n@@ -137,1 +149,1 @@\n-  uint64_t pd = (uint64_t)(pointer_delta((void*)v, base(), 1));\n+  uint64_t pd = (uint64_t)(pointer_delta((void*)v, narrow_base, 1));\n@@ -141,1 +153,1 @@\n-  assert(decode(result) == v, \"reversibility\");\n+  assert(decode_not_null(result, narrow_base) == v, \"reversibility\");\n","filename":"src\/hotspot\/share\/oops\/compressedOops.inline.hpp","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -146,0 +146,8 @@\n+#if INCLUDE_CDS_JAVA_HEAP\n+void oopDesc::set_narrow_klass(narrowKlass nk) {\n+  assert(DumpSharedSpaces, \"Used by CDS only. Do not abuse!\");\n+  assert(UseCompressedClassPointers, \"must be\");\n+  _metadata._compressed_klass = nk;\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+  void set_narrow_klass(narrowKlass nk) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,3 +43,2 @@\n-            test(true,  false);\n-            test(false, true);\n-            test(true,  true);\n+            test(false);\n+            test(true);\n@@ -54,1 +53,0 @@\n-    \/\/ dump_reloc - force relocation of archive during dump time?\n@@ -56,1 +54,2 @@\n-    static void test(boolean dump_reloc, boolean run_reloc) throws Exception {\n+    \/\/ Note: relocation always happens during dumping.\n+    static void test(boolean run_reloc) throws Exception {\n@@ -59,2 +58,1 @@\n-        System.out.println(\"case = \" + caseCount + \", dump = \" + dump_reloc\n-                           + \", run = \" + run_reloc);\n+        System.out.println(\"case = \" + caseCount + \", run_reloc = \" + run_reloc);\n@@ -63,1 +61,0 @@\n-\n@@ -67,1 +64,0 @@\n-        String dumpRelocArg = dump_reloc ? forceRelocation : \"-showversion\";\n@@ -75,5 +71,2 @@\n-                                             unlockArg, dumpRelocArg, logArg, nmtArg);\n-        if (dump_reloc) {\n-            out.shouldContain(\"ArchiveRelocationMode == 1: always allocate class space at an alternative address\");\n-            out.shouldContain(\"Relocating archive from\");\n-        }\n+                                             unlockArg, logArg, nmtArg);\n+        out.shouldContain(\"Relocating archive from\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/ArchiveRelocationTest.java","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,4 @@\n-        String s = output.firstMatch(\"Number of entries       : .*\");\n+        \/\/ Look for this pattern:\n+        \/\/ [4.661s][info][cds,hashtables] Shared symbol table stats -------- base: 0x0000000800000000\n+        \/\/ [4.661s][info][cds,hashtables] Number of entries       :     50078\n+        String s = output.firstMatch(\"Shared symbol table stats[^\\n]*\\n[^\\n]*Number of entries       : .*\");\n@@ -79,1 +82,1 @@\n-        int numEntries = Integer.parseInt(subs[1].trim());\n+        int numEntries = Integer.parseInt(subs[2].trim());\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/ExtraSymbols.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,2 +60,1 @@\n-                    output.shouldContain(\"Buffer-space to target-space delta\")\n-                           .shouldContain(\"Written dynamic archive 0x\");\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/AppendClasspath.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,2 +142,1 @@\n-                    output.shouldContain(\"Buffer-space to target-space delta\")\n-                          .shouldContain(\"Written dynamic archive 0x\");\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/ArchiveConsistency.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,2 +62,1 @@\n-                    output.shouldContain(\"Buffer-space to target-space delta\")\n-                           .shouldContain(\"Written dynamic archive 0x\");\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/ClassResolutionFailure.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,2 +46,1 @@\n-            testOuter(false);\n-            testOuter(true);\n+            testOuter();\n@@ -54,4 +53,4 @@\n-    static void testOuter(boolean dump_base_reloc) throws Exception {\n-        testInner(dump_base_reloc, true,  false);\n-        testInner(dump_base_reloc, false, true);\n-        testInner(dump_base_reloc, true,  true);\n+    static void testOuter() throws Exception {\n+        testInner(true,  false);\n+        testInner(false, true);\n+        testInner(true,  true);\n@@ -60,1 +59,1 @@\n-    static boolean dump_base_reloc, dump_top_reloc, run_reloc;\n+    static boolean dump_top_reloc, run_reloc;\n@@ -62,1 +61,0 @@\n-    \/\/ dump_base_reloc - force relocation of archive when dumping base archive\n@@ -65,2 +63,1 @@\n-    static void testInner(boolean dump_base_reloc, boolean dump_top_reloc, boolean run_reloc) throws Exception {\n-        DynamicArchiveRelocationTest.dump_base_reloc = dump_base_reloc;\n+    static void testInner(boolean dump_top_reloc, boolean run_reloc) throws Exception {\n@@ -77,2 +74,2 @@\n-        System.out.println(\"case = \" + caseCount + \", base = \" + dump_base_reloc\n-                           + \", top = \" + dump_top_reloc\n+        System.out.println(\"case = \" + caseCount\n+                           + \", top_reloc = \" + dump_top_reloc\n@@ -85,1 +82,0 @@\n-        String dumpBaseRelocArg = dump_base_reloc ? forceRelocation : \"-showversion\";\n@@ -100,5 +96,1 @@\n-        OutputAnalyzer out = TestCommon.dumpBaseArchive(baseArchiveName, unlockArg, dumpBaseRelocArg, logArg);\n-        if (dump_base_reloc) {\n-            out.shouldContain(\"ArchiveRelocationMode == 1: always allocate class space at an alternative address\");\n-            out.shouldContain(\"Relocating archive from\");\n-        }\n+        OutputAnalyzer out = TestCommon.dumpBaseArchive(baseArchiveName, unlockArg, logArg);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/DynamicArchiveRelocationTest.java","additions":11,"deletions":19,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,2 +83,1 @@\n-                 output.shouldContain(\"Buffer-space to target-space delta\")\n-                        .shouldContain(\"Written dynamic archive 0x\");\n+                 output.shouldContain(\"Written dynamic archive 0x\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/DynamicLotsOfClasses.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,2 +68,1 @@\n-                    output.shouldContain(\"Buffer-space to target-space delta\")\n-                           .shouldContain(\"Written dynamic archive 0x\");\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/HelloDynamic.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,2 +65,1 @@\n-                output.shouldContain(\"Buffer-space to target-space delta\")\n-                      .shouldContain(\"Written dynamic archive 0x\")\n+                output.shouldContain(\"Written dynamic archive 0x\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/HelloDynamicCustom.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,2 +73,1 @@\n-                output.shouldContain(\"Buffer-space to target-space delta\")\n-                      .shouldContain(\"Written dynamic archive 0x\")\n+                output.shouldContain(\"Written dynamic archive 0x\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/HelloDynamicCustomUnload.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,2 +60,1 @@\n-                    output.shouldContain(\"Buffer-space to target-space delta\")\n-                           .shouldContain(\"Written dynamic archive 0x\");\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/JITInteraction.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,2 +84,1 @@\n-                    output.shouldContain(\"Buffer-space to target-space delta\")\n-                           .shouldContain(\"Written dynamic archive 0x\");\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/LambdaInBaseArchive.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,2 +109,1 @@\n-                    output.shouldContain(\"Buffer-space to target-space delta\")\n-                          .shouldContain(\"Written dynamic archive 0x\");\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/MainModuleOnly.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,1 @@\n-                    output.shouldContain(\"Buffer-space to target-space delta\")\n-                           .shouldContain(\"Written dynamic archive 0x\");\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/MismatchedBaseArchive.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,2 +68,1 @@\n-                    output.shouldContain(\"Buffer-space to target-space delta\")\n-                           .shouldContain(\"Written dynamic archive 0x\");\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/MissingArchive.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,2 +86,1 @@\n-                    output.shouldContain(\"Buffer-space to target-space delta\")\n-                           .shouldContain(\"Written dynamic archive 0x\");\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/SharedArchiveFileOption.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,2 +69,1 @@\n-                 output.shouldContain(\"Buffer-space to target-space delta\")\n-                        .shouldContain(\"Written dynamic archive 0x\");\n+                 output.shouldContain(\"Written dynamic archive 0x\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/UnusedCPDuringDump.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}