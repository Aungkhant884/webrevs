{"files":[{"patch":"@@ -2964,1 +2964,1 @@\n-        if (!method.equals(\"HEAD\")) {\n+        if (!method.equals(\"HEAD\") || doingNTLM2ndStage || doingNTLMp2ndStage) {\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/HttpURLConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,263 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8270290\n+ * @modules java.base\/sun.net.www\n+ * @library \/test\/lib\n+ * @run main\/othervm NTLMHeadTest SERVER\n+ * @run main\/othervm NTLMHeadTest PROXY\n+ * @run main\/othervm NTLMHeadTest TUNNEL\n+ * @summary test for the incorrect logic in reading (and discarding) HTTP response body when\n+ *      processing NTLMSSP_CHALLENGE response from server. When this response is\n+ *      received by client, reset() is called on the connection to read and discard the\n+ *      response body. This code path was broken when initial client request uses \"HEAD\"\n+ *      method, in this case response body is not read from the socket. This does not cause\n+ *      problems with the majority of (proxy) servers because InputStream opened over the response\n+ *      socket is buffered with 8kb buffer size. Problem is only reproducible if the response\n+ *      size (headers + body) is larger than 8kb. There are three code paths (modes) where NTLM\n+ *      auth can be used: direct server (SERVER), HTTP proxying (PROXY) and HTTPS tunneling (TUNNEL).\n+ *\/\n+\n+import java.net.*;\n+import java.io.*;\n+import java.util.*;\n+import sun.net.www.MessageHeader;\n+import jdk.test.lib.net.URIBuilder;\n+\n+public class NTLMHeadTest {\n+\n+    enum Mode { SERVER, PROXY, TUNNEL }\n+\n+    static final int BODY_LEN = 8192;\n+\n+    static final String RESP_SERVER_AUTH =\n+            \"HTTP\/1.1 401 Unauthorized\\r\\n\" +\n+            \"WWW-Authenticate: NTLM\\r\\n\" +\n+            \"Connection: close\\r\\n\" +\n+            \"Content-Length: 0\\r\\n\" +\n+            \"\\r\\n\";\n+\n+    static final String RESP_SERVER_NTLM =\n+            \"HTTP\/1.1 401 Unauthorized\\r\\n\" +\n+            \"WWW-Authenticate: NTLM TlRMTVNTUAACAAAAAAAAACgAAAABggAAU3J2Tm9uY2UAAAAAAAAAAA==\\r\\n\" +\n+            \"Connection: Keep-Alive\\r\\n\" +\n+            \"Content-Length: \" + BODY_LEN + \"\\r\\n\" +\n+            \"\\r\\n\" +\n+            generateBody(BODY_LEN);\n+\n+    static final String RESP_SERVER_DEST =\n+            \"HTTP\/1.1 200 OK\\r\\n\" +\n+            \"Connection: close\\r\\n\" +\n+            \"Content-Length: 0\\r\\n\" +\n+            \"\\r\\n\";\n+\n+    static final String RESP_PROXY_AUTH =\n+            \"HTTP\/1.1 407 Proxy Authentication Required\\r\\n\" +\n+            \"Proxy-Authenticate: NTLM\\r\\n\" +\n+            \"Proxy-Connection: close\\r\\n\" +\n+            \"Connection: close\\r\\n\" +\n+            \"Content-Length: 0\\r\\n\" +\n+            \"\\r\\n\";\n+\n+    static final String RESP_PROXY_NTLM =\n+            \"HTTP\/1.1 407 Proxy Authentication Required\\r\\n\" +\n+            \"Proxy-Authenticate: NTLM TlRMTVNTUAACAAAAAAAAACgAAAABggAAU3J2Tm9uY2UAAAAAAAAAAA==\\r\\n\" +\n+            \"Proxy-Connection: Keep-Alive\\r\\n\" +\n+            \"Connection: Keep-Alive\\r\\n\" +\n+            \"Content-Length: \" + BODY_LEN + \"\\r\\n\" +\n+            \"\\r\\n\" +\n+            generateBody(BODY_LEN);\n+\n+    static final String RESP_PROXY_TUNNEL =\n+            \"HTTP\/1.1 200 Connection Established\\r\\n\\r\\n\";\n+\n+    public static void main(String[] args) throws Exception {\n+        Authenticator.setDefault(new TestAuthenticator());\n+\n+        if (1 != args.length) {\n+            throw new IllegalArgumentException(\"Mode value must be specified, one of: [SERVER, PROXY, TUNNEL]\");\n+        }\n+        Mode mode = Mode.valueOf(args[0]);\n+        System.out.println(\"Running with mode: \" + mode);\n+        switch (mode) {\n+            case SERVER: testSever(); return;\n+            case PROXY: testProxy(); return;\n+            case TUNNEL: testTunnel(); return;\n+            default: throw new IllegalArgumentException(\"Invalid mode: \" + mode);\n+        }\n+    }\n+\n+    private static void testSever() throws Exception {\n+        try (NTLMServer server = startServer(new ServerSocket(0, 0, InetAddress.getLoopbackAddress()), Mode.SERVER)) {\n+            URL url = URIBuilder.newBuilder()\n+                    .scheme(\"http\")\n+                    .loopback()\n+                    .port(server.getLocalPort())\n+                    .path(\"\/\")\n+                    .toURLUnchecked();\n+            HttpURLConnection uc = (HttpURLConnection) url.openConnection();\n+            uc.setRequestMethod(\"HEAD\");\n+            try {\n+                uc.getInputStream().readAllBytes();\n+            } catch(IOException e) {\n+                \/\/ Invalid Http response\n+                System.err.println(\"Error: cannot read 200 response code\");\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private static void testProxy() throws Exception {\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        try (NTLMServer server = startServer(new ServerSocket(0, 0, loopback), Mode.PROXY)) {\n+            SocketAddress proxyAddr = new InetSocketAddress(loopback, server.getLocalPort());\n+            Proxy proxy = new Proxy(java.net.Proxy.Type.HTTP, proxyAddr);\n+            URL url = URIBuilder.newBuilder()\n+                    .scheme(\"http\")\n+                    .loopback()\n+                    .port(8080)\n+                    .path(\"\/\")\n+                    .toURLUnchecked();\n+            HttpURLConnection uc = (HttpURLConnection) url.openConnection(proxy);\n+            uc.setRequestMethod(\"HEAD\");\n+            try {\n+                uc.getInputStream().readAllBytes();\n+            } catch(IOException e) {\n+                \/\/ Invalid Http response\n+                System.err.println(\"Error: cannot read 200 response code\");\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private static void testTunnel() throws Exception {\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        try (NTLMServer server = startServer(new ServerSocket(0, 0, loopback), Mode.TUNNEL)) {\n+            SocketAddress proxyAddr = new InetSocketAddress(loopback, server.getLocalPort());\n+            Proxy proxy = new Proxy(java.net.Proxy.Type.HTTP, proxyAddr);\n+            URL url = URIBuilder.newBuilder()\n+                    .scheme(\"https\")\n+                    .loopback()\n+                    .port(8443)\n+                    .path(\"\/\")\n+                    .toURLUnchecked();\n+            HttpURLConnection uc = (HttpURLConnection) url.openConnection(proxy);\n+            uc.setRequestMethod(\"HEAD\");\n+            try {\n+                uc.getInputStream().readAllBytes();\n+            } catch (IOException e) {\n+                \/\/ can be SocketException or SSLHandshakeException\n+                \/\/ Tunnel established and closed by server\n+                System.out.println(\"Tunnel established successfully\");\n+            } catch (NoSuchElementException e) {\n+                System.err.println(\"Error: cannot read 200 response code\");\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    static class NTLMServer extends Thread implements AutoCloseable {\n+        final ServerSocket ss;\n+        final Mode mode;\n+        volatile boolean closed;\n+\n+        NTLMServer(ServerSocket serverSS, Mode mode) {\n+            super();\n+            setDaemon(true);\n+            this.ss = serverSS;\n+            this.mode = mode;\n+        }\n+\n+       public int getLocalPort() { return ss.getLocalPort(); }\n+\n+        @Override\n+        public void run() {\n+            boolean doing2ndStageNTLM = false;\n+            while (!closed) {\n+                try {\n+                    Socket s = ss.accept();\n+                    InputStream is = s.getInputStream();\n+                    OutputStream os = s.getOutputStream();\n+\n+                    if (!doing2ndStageNTLM) {\n+                        new MessageHeader(is);\n+                        if (Mode.SERVER == mode) {\n+                            os.write(RESP_SERVER_AUTH.getBytes(\"ASCII\"));\n+                        } else {\n+                            os.write(RESP_PROXY_AUTH.getBytes(\"ASCII\"));\n+                        }\n+                        doing2ndStageNTLM = true;\n+                    } else {\n+                        new MessageHeader(is);\n+                        if (Mode.SERVER == mode) {\n+                            os.write(RESP_SERVER_NTLM.getBytes(\"ASCII\"));\n+                        } else {\n+                            os.write(RESP_PROXY_NTLM.getBytes(\"ASCII\"));\n+                        }\n+                        new MessageHeader(is);\n+                        if (Mode.TUNNEL == mode) {\n+                            os.write(RESP_PROXY_TUNNEL.getBytes(\"ASCII\"));\n+                        } else {\n+                            os.write(RESP_SERVER_DEST.getBytes(\"ASCII\"));\n+                        }\n+                        os.close();\n+                    }\n+                } catch (IOException ioe) {\n+                    if (!closed) ioe.printStackTrace();\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void close() {\n+           if (closed) return;\n+           synchronized(this) {\n+               if (closed) return;\n+               closed = true;\n+           }\n+           try { ss.close(); } catch (IOException x) { };\n+        }\n+    }\n+\n+    public static NTLMServer startServer(ServerSocket serverSS, Mode mode) {\n+        NTLMServer server = new NTLMServer(serverSS, mode);\n+        server.start();\n+        return server;\n+    }\n+\n+    private static String generateBody(int length) {\n+        StringBuilder sb = new StringBuilder();\n+        for(int i = 0; i < length; i++) {\n+            sb.append(i % 10);\n+        }\n+        return sb.toString();\n+    }\n+\n+    static class TestAuthenticator extends java.net.Authenticator {\n+        protected PasswordAuthentication getPasswordAuthentication() {\n+            return new PasswordAuthentication(\"test\", \"secret\".toCharArray());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/http\/NTLMHeadTest.java","additions":263,"deletions":0,"binary":false,"changes":263,"status":"added"}]}