{"files":[{"patch":"@@ -1838,1 +1838,1 @@\n-                           false,                                          \/\/ Reference discovery is not atomic\n+                           true,                                           \/\/ Reference discovery is concurrent\n@@ -1847,1 +1847,1 @@\n-                           true,                                 \/\/ Reference discovery is atomic\n+                           false,                                \/\/ Reference discovery is not concurrent\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -804,1 +804,1 @@\n-                           true,                       \/\/ atomic_discovery\n+                           false,                      \/\/ concurrent_discovery\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-                                       bool      atomic_discovery,\n+                                       bool      concurrent_discovery,\n@@ -100,5 +100,5 @@\n-  _discovery_is_atomic = atomic_discovery;\n-  _discovery_is_mt     = mt_discovery;\n-  _num_queues          = MAX2(1U, mt_processing_degree);\n-  _max_num_queues      = MAX2(_num_queues, mt_discovery_degree);\n-  _discovered_refs     = NEW_C_HEAP_ARRAY(DiscoveredList,\n+  _discovery_is_concurrent = concurrent_discovery;\n+  _discovery_is_mt         = mt_discovery;\n+  _num_queues              = MAX2(1U, mt_processing_degree);\n+  _max_num_queues          = MAX2(_num_queues, mt_discovery_degree);\n+  _discovered_refs         = NEW_C_HEAP_ARRAY(DiscoveredList,\n@@ -313,1 +313,1 @@\n-    iter.load_ptrs(DEBUG_ONLY(!discovery_is_atomic() \/* allow_null_referent *\/));\n+    iter.load_ptrs(DEBUG_ONLY(discovery_is_concurrent() \/* allow_null_referent *\/));\n@@ -316,1 +316,1 @@\n-      \/\/ discovery is not atomic (checked by load_ptrs).  Remove\n+      \/\/ discovery is concurrent (checked by load_ptrs).  Remove\n@@ -869,1 +869,1 @@\n-  if (discovery_is_atomic()) {\n+  if (discovery_is_stw()) {\n@@ -886,1 +886,1 @@\n-  if (discovery_is_atomic()) {\n+  if (discovery_is_stw()) {\n@@ -897,3 +897,2 @@\n-\/\/ Non-atomic (i.e. concurrent) discovery might allow us\n-\/\/ to observe j.l.References with NULL referents, being those\n-\/\/ cleared concurrently by mutators during (or after) discovery.\n+\/\/ Concurrent discovery might allow us to observe j.l.References with NULL\n+\/\/ referents, being those cleared concurrently by mutators during (or after) discovery.\n@@ -901,1 +900,1 @@\n-  bool da = discovery_is_atomic();\n+  bool concurrent = discovery_is_concurrent();\n@@ -903,1 +902,1 @@\n-  assert(da ? oopDesc::is_oop(referent) : oopDesc::is_oop_or_null(referent),\n+  assert(concurrent ? oopDesc::is_oop_or_null(referent) : oopDesc::is_oop(referent),\n@@ -905,2 +904,2 @@\n-         INTPTR_FORMAT \" during %satomic discovery \",\n-         p2i(referent), p2i(obj), da ? \"\" : \"non-\");\n+         INTPTR_FORMAT \" during %sconcurrent discovery \",\n+         p2i(referent), p2i(obj), concurrent ? \"\" : \"non-\");\n@@ -916,1 +915,1 @@\n-\/\/     (or part of the heap being collected, indicated by our \"span\"\n+\/\/     (or part of the heap being collected, indicated by our \"span\")\n@@ -928,3 +927,3 @@\n-\/\/     a different concurrently running collector (as may be the\n-\/\/     case, for instance, if the reference object is in CMS and\n-\/\/     the referent in DefNewGeneration), and provided the processing\n+\/\/     a different concurrently running discoverer (as may be the\n+\/\/     case, for instance, if the reference object is in G1 old gen and\n+\/\/     the referent in G1 young gen), and provided the processing\n@@ -932,2 +931,2 @@\n-\/\/     appear atomic to every other collector in the system.\n-\/\/     (Thus, for instance, a concurrent collector may not\n+\/\/     appear atomically to every other discoverer in the system.\n+\/\/     (Thus, for instance, a concurrent discoverer may not\n@@ -939,1 +938,1 @@\n-\/\/     We call this choice the \"RefeferentBasedDiscovery\" policy.\n+\/\/     We call this choice the \"ReferentBasedDiscovery\" policy.\n@@ -1010,1 +1009,1 @@\n-    \/\/ .. we are an atomic collector and referent is in our span\n+    \/\/ .. we are a stw discoverer and referent is in our span\n@@ -1012,1 +1011,1 @@\n-        (discovery_is_atomic() &&\n+        (discovery_is_stw() &&\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":25,"deletions":26,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -198,2 +198,1 @@\n-  bool        _discovery_is_atomic;     \/\/ if discovery is atomic wrt\n-                                        \/\/ other collectors in configuration\n+  bool        _discovery_is_concurrent; \/\/ if discovery is concurrent to the mutator\n@@ -254,1 +253,1 @@\n-  \/\/ or NULL if discovery is not atomic. Enqueue and clear the reference for\n+  \/\/ or NULL if discovery is concurrent. Enqueue and clear the reference for\n@@ -355,1 +354,1 @@\n-                     bool atomic_discovery = true,\n+                     bool concurrent_discovery = false,\n@@ -384,2 +383,3 @@\n-  \/\/ whether discovery is atomic wrt other collectors\n-  bool discovery_is_atomic() const { return _discovery_is_atomic; }\n+  \/\/ whether discovery is concurrent to the mutator, or done in an stw pause.\n+  bool discovery_is_concurrent() const { return _discovery_is_concurrent; }\n+  bool discovery_is_stw() const { return !discovery_is_concurrent(); }\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}