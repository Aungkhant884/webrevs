{"files":[{"patch":"@@ -232,0 +232,2 @@\n+  address* pc_addr = (address*)&(own_abi()->lr);\n+\n@@ -236,0 +238,6 @@\n+  assert(!Continuation::is_return_barrier_entry(*pc_addr), \"return barrier\");\n+  assert(_pc == *pc_addr || pc == *pc_addr || 0 == *pc_addr,\n+         \"must be (pc: \" INTPTR_FORMAT \" _pc: \" INTPTR_FORMAT \" pc_addr: \" INTPTR_FORMAT\n+         \" *pc_addr: \" INTPTR_FORMAT  \" sp: \" INTPTR_FORMAT \")\",\n+         p2i(pc), p2i(_pc), p2i(pc_addr), p2i(*pc_addr), p2i(sp()));\n+  DEBUG_ONLY(address old_pc = _pc;)\n@@ -237,3 +245,4 @@\n-  if (_cb != NULL && _cb->is_nmethod() && ((nmethod*)_cb)->is_deopt_pc(_pc)) {\n-    address orig = (((nmethod*)_cb)->get_original_pc(this));\n-    assert(orig == _pc, \"expected original to be stored before patching\");\n+  _pc = pc; \/\/ must be set before call to get_deopt_original_pc\n+  address original_pc = CompiledMethod::get_deopt_original_pc(this);\n+  if (original_pc != NULL) {\n+    assert(original_pc == old_pc, \"expected original PC to be stored before patching\");\n@@ -241,1 +250,1 @@\n-    \/\/ Leave _pc as is.\n+    _pc = original_pc;\n@@ -244,1 +253,0 @@\n-    _pc = pc;\n@@ -246,0 +254,11 @@\n+  assert(!is_compiled_frame() || !_cb->as_compiled_method()->is_deopt_entry(_pc), \"must be\");\n+\n+#ifdef ASSERT\n+  {\n+    frame f(this->sp(), pc, this->unextended_sp());\n+    assert(f.is_deoptimized_frame() == this->is_deoptimized_frame() && f.pc() == this->pc() && f.raw_pc() == this->raw_pc(),\n+           \"must be (f.is_deoptimized_frame(): %d this->is_deoptimized_frame(): %d \"\n+           \"f.pc(): \" INTPTR_FORMAT \" this->pc(): \" INTPTR_FORMAT \" f.raw_pc(): \" INTPTR_FORMAT \" this->raw_pc(): \" INTPTR_FORMAT \")\",\n+           f.is_deoptimized_frame(), this->is_deoptimized_frame(), p2i(f.pc()), p2i(this->pc()), p2i(f.raw_pc()), p2i(this->raw_pc()));\n+  }\n+#endif\n@@ -387,0 +406,3 @@\n+                                             _pc((address)pc),\n+                                             _cb(NULL),\n+                                             _oop_map(NULL),\n@@ -388,2 +410,4 @@\n-                                             _unextended_sp((intptr_t*)sp) {\n-  find_codeblob_and_set_pc_and_deopt_state((address)pc); \/\/ also sets _fp and adjusts _unextended_sp\n+                                             DEBUG_ONLY(_frame_index(-1) COMMA)\n+                                             _unextended_sp((intptr_t*)sp),\n+                                             _fp(NULL) {\n+  setup(); \/\/ also sets _fp and adjusts _unextended_sp\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":31,"deletions":7,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -377,2 +377,2 @@\n-  \/\/ Find codeblob and set deopt_state.\n-  inline void find_codeblob_and_set_pc_and_deopt_state(address pc);\n+  \/\/ Initialize frame members (_pc and _sp must be given)\n+  inline void setup();\n@@ -386,1 +386,1 @@\n-  inline frame(intptr_t* sp, address pc, intptr_t* unextended_sp);\n+  inline frame(intptr_t* sp, address pc, intptr_t* unextended_sp, intptr_t* fp = nullptr, CodeBlob* cb = nullptr);\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -35,3 +36,3 @@\n-\/\/ Find codeblob and set deopt_state.\n-inline void frame::find_codeblob_and_set_pc_and_deopt_state(address pc) {\n-  assert(pc != NULL, \"precondition: must have PC\");\n+\/\/ Initialize frame members (_pc and _sp must be given)\n+inline void frame::setup() {\n+  assert(_pc != nullptr, \"precondition: must have PC\");\n@@ -39,2 +40,7 @@\n-  _cb = CodeCache::find_blob(pc);\n-  _pc = pc;   \/\/ Must be set for get_deopt_original_pc()\n+  if (_cb == nullptr) {\n+    _cb = CodeCache::find_blob(_pc);\n+  }\n+\n+  if (_fp == nullptr) {\n+    _fp = (intptr_t*)own_abi()->callers_sp;\n+  }\n@@ -42,1 +48,3 @@\n-  _fp = (intptr_t*)own_abi()->callers_sp;\n+  \/\/ When thawing continuation frames the _unextended_sp passed to the constructor is not aligend\n+  assert(_on_heap || (is_aligned(_sp, alignment_in_bytes) && is_aligned(_fp, alignment_in_bytes)),\n+         \"invalid alignment sp:\" PTR_FORMAT \" unextended_sp:\" PTR_FORMAT \" fp:\" PTR_FORMAT, p2i(_sp), p2i(_unextended_sp), p2i(_fp));\n@@ -45,1 +53,1 @@\n-  if (original_pc != NULL) {\n+  if (original_pc != nullptr) {\n@@ -48,0 +56,2 @@\n+    assert(_cb == nullptr || _cb->as_compiled_method()->insts_contains_inclusive(_pc),\n+           \"original PC must be in the main code section of the the compiled method (or must be immediately following it)\");\n@@ -49,1 +59,5 @@\n-    _deopt_state = not_deoptimized;\n+    if (_cb == SharedRuntime::deopt_blob()) {\n+      _deopt_state = is_deoptimized;\n+    } else {\n+      _deopt_state = not_deoptimized;\n+    }\n@@ -52,1 +66,1 @@\n-  assert(((uint64_t)_sp & 0xf) == 0, \"SP must be 16-byte aligned\");\n+  assert(_on_heap || is_aligned(_sp, frame::frame_alignment), \"SP must be 16-byte aligned\");\n@@ -58,5 +72,2 @@\n-inline frame::frame() : _sp(NULL), _pc(NULL), _cb(NULL),  _deopt_state(unknown), _on_heap(false),\n-#ifdef ASSERT\n-                        _frame_index(-1),\n-#endif\n-                        _unextended_sp(NULL), _fp(NULL) {}\n+inline frame::frame() : _sp(nullptr), _pc(nullptr), _cb(nullptr), _oop_map(nullptr), _deopt_state(unknown),\n+                        _on_heap(false), DEBUG_ONLY(_frame_index(-1) COMMA) _unextended_sp(nullptr), _fp(nullptr) {}\n@@ -64,6 +75,4 @@\n-inline frame::frame(intptr_t* sp) : _sp(sp), _on_heap(false),\n-#ifdef ASSERT\n-                        _frame_index(-1),\n-#endif\n-                        _unextended_sp(sp) {\n-  find_codeblob_and_set_pc_and_deopt_state((address)own_abi()->lr); \/\/ also sets _fp and adjusts _unextended_sp\n+inline frame::frame(intptr_t* sp)\n+  : _sp(sp), _pc((address)own_abi()->lr), _cb(nullptr), _oop_map(nullptr),\n+    _on_heap(false), DEBUG_ONLY(_frame_index(-1) COMMA) _unextended_sp(sp), _fp(nullptr) {\n+  setup();\n@@ -72,6 +81,4 @@\n-inline frame::frame(intptr_t* sp, address pc) : _sp(sp), _on_heap(false),\n-#ifdef ASSERT\n-                         _frame_index(-1),\n-#endif\n-                        _unextended_sp(sp) {\n-  find_codeblob_and_set_pc_and_deopt_state(pc); \/\/ also sets _fp and adjusts _unextended_sp\n+inline frame::frame(intptr_t* sp, address pc)\n+  : _sp(sp), _pc(pc), _cb(nullptr), _oop_map(nullptr),\n+    _on_heap(false), DEBUG_ONLY(_frame_index(-1) COMMA) _unextended_sp(sp), _fp(nullptr) {\n+  setup();\n@@ -80,6 +87,4 @@\n-inline frame::frame(intptr_t* sp, address pc, intptr_t* unextended_sp) : _sp(sp), _on_heap(false),\n-#ifdef ASSERT\n-                    _frame_index(-1),\n-#endif\n-                    _unextended_sp(unextended_sp) {\n-  find_codeblob_and_set_pc_and_deopt_state(pc); \/\/ also sets _fp and adjusts _unextended_sp\n+inline frame::frame(intptr_t* sp, address pc, intptr_t* unextended_sp, intptr_t* fp, CodeBlob* cb)\n+  : _sp(sp), _pc(pc), _cb(nullptr), _oop_map(nullptr),\n+    _on_heap(false), DEBUG_ONLY(_frame_index(-1) COMMA) _unextended_sp(unextended_sp), _fp(fp) {\n+  setup();\n@@ -236,1 +241,10 @@\n-  Unimplemented();\n+  if (_cb == NULL) return NULL;\n+  if (_cb->oop_maps() != NULL) {\n+    NativePostCallNop* nop = nativePostCallNop_at(_pc);\n+    if (nop != NULL && nop->displacement() != 0) {\n+      int slot = ((nop->displacement() >> 24) & 0xff);\n+      return _cb->oop_map_for_slot(slot, _pc);\n+    }\n+    const ImmutableOopMap* oop_map = OopMapSet::find_map(this);\n+    return oop_map;\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.inline.hpp","additions":47,"deletions":33,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -509,1 +509,1 @@\n-  int displacement() const { Unimplemented(); return 0; }\n+  int displacement() const { return 0; }\n@@ -515,1 +515,1 @@\n-  Unimplemented();\n+  \/\/ Unimplemented();\n@@ -527,1 +527,1 @@\n-    Unimplemented();\n+    \/\/ Unimplemented();\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4504,0 +4504,68 @@\n+  RuntimeStub* generate_cont_doYield() {\n+    if (!Continuations::enabled()) return nullptr;\n+    Unimplemented();\n+    return nullptr;\n+  }\n+\n+  address generate_cont_thaw(bool return_barrier, bool exception) {\n+    if (!Continuations::enabled()) return nullptr;\n+    Unimplemented();\n+    return nullptr;\n+  }\n+\n+  address generate_cont_thaw() {\n+    if (!Continuations::enabled()) return nullptr;\n+    Unimplemented();\n+    return nullptr;\n+  }\n+\n+  address generate_cont_returnBarrier() {\n+    if (!Continuations::enabled()) return nullptr;\n+    Unimplemented();\n+    return nullptr;\n+  }\n+\n+  address generate_cont_returnBarrier_exception() {\n+    if (!Continuations::enabled()) return nullptr;\n+    Unimplemented();\n+    return nullptr;\n+  }\n+\n+#if INCLUDE_JFR\n+\n+  static RuntimeStub* generate_jfr_stub(const char* name, address entrypoint) {\n+    int insts_size = 512;\n+    int locs_size = 64;\n+    CodeBuffer code(name, insts_size, locs_size);\n+    OopMapSet* oop_maps = new OopMapSet();\n+    MacroAssembler* masm = new MacroAssembler(&code);\n+    MacroAssembler* _masm = masm;\n+\n+    address start = __ pc();\n+    __ unimplemented(FILE_AND_LINE);\n+    int frame_complete = __ pc() - start;\n+\n+    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+      RuntimeStub::new_runtime_stub(name, &code, frame_complete,\n+                                    0 \/*framesize*\/,\n+                                    oop_maps, false);\n+    return stub;\n+  }\n+\n+  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+  \/\/ It returns a jobject handle to the event writer.\n+  \/\/ The handle is dereferenced and the return value is the event writer oop.\n+  RuntimeStub* generate_jfr_write_checkpoint() {\n+    return generate_jfr_stub(\"jfr_write_checkpoint\",\n+                              CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint));\n+  }\n+\n+  \/\/ For c1: call the corresponding runtime routine, it returns a jobject handle to the event writer.\n+  \/\/ The handle is dereferenced and the return value is the event writer oop.\n+  RuntimeStub* generate_jfr_get_event_writer() {\n+    return generate_jfr_stub(\"jfr_get_event_writer\",\n+                              CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::event_writer));\n+  }\n+#endif \/\/ INCLUDE_JFR\n+\n+\n@@ -4539,0 +4607,15 @@\n+  void generate_phase1() {\n+    \/\/ Continuation stubs:\n+    StubRoutines::_cont_thaw          = generate_cont_thaw();\n+    StubRoutines::_cont_returnBarrier = generate_cont_returnBarrier();\n+    StubRoutines::_cont_returnBarrierExc = generate_cont_returnBarrier_exception();\n+    StubRoutines::_cont_doYield_stub = generate_cont_doYield();\n+    StubRoutines::_cont_doYield      = StubRoutines::_cont_doYield_stub == nullptr ? nullptr\n+                                        : StubRoutines::_cont_doYield_stub->entry_point();\n+\n+    JFR_ONLY(StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();)\n+    JFR_ONLY(StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();)\n+    JFR_ONLY(StubRoutines::_jfr_get_event_writer_stub = generate_jfr_get_event_writer();)\n+    JFR_ONLY(StubRoutines::_jfr_get_event_writer = StubRoutines::_jfr_get_event_writer_stub->entry_point();)\n+  }\n+\n@@ -4611,4 +4694,2 @@\n-  StubGenerator(CodeBuffer* code, bool all) : StubCodeGenerator(code) {\n-    if (all) {\n-      generate_all();\n-    } else {\n+  StubGenerator(CodeBuffer* code, int phase) : StubCodeGenerator(code) {\n+    if (phase == 0) {\n@@ -4616,0 +4697,4 @@\n+    } else if (phase == 1) {\n+      generate_phase1(); \/\/ stubs that must be available for the interpreter\n+    } else {\n+      generate_all();\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":89,"deletions":4,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -480,0 +480,1 @@\n+  if (!Continuations::enabled()) return nullptr;\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+  if (!Continuations::enabled()) return false;\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -233,0 +233,8 @@\n+#if defined(PPC64)\n+    if (_int_args < Argument::n_int_register_parameters_j) {\n+      _int_args++;\n+    } else {\n+      _stack_arg_slots += 1;\n+    }\n+    break;\n+#endif \/\/ defined(PPC64)\n@@ -240,0 +248,1 @@\n+      PPC64_ONLY(_stack_arg_slots = align_up(_stack_arg_slots, 2));\n@@ -244,0 +253,8 @@\n+#if defined(PPC64)\n+    if (_fp_args < Argument::n_float_register_parameters_j) {\n+      _fp_args++;\n+    } else {\n+      _stack_arg_slots += 1;\n+    }\n+    break;\n+#endif \/\/ defined(PPC64)\n@@ -248,0 +265,1 @@\n+      PPC64_ONLY(_stack_arg_slots = align_up(_stack_arg_slots, 2));\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"}]}