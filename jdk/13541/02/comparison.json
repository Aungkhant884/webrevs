{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -22,1 +22,0 @@\n- *\n@@ -27,7 +26,0 @@\n-import java.lang.constant.ConstantDesc;\n-import java.lang.constant.DirectMethodHandleDesc;\n-import java.lang.constant.DynamicCallSiteDesc;\n-import java.lang.constant.DynamicConstantDesc;\n-import java.lang.constant.MethodHandleDesc;\n-import java.lang.constant.MethodTypeDesc;\n-import java.util.List;\n@@ -36,5 +28,0 @@\n-import jdk.internal.classfile.Annotation;\n-import jdk.internal.classfile.AnnotationElement;\n-import jdk.internal.classfile.AnnotationValue;\n-import jdk.internal.classfile.ClassBuilder;\n-import jdk.internal.classfile.ClassElement;\n@@ -42,1 +29,0 @@\n-import jdk.internal.classfile.ClassSignature;\n@@ -45,3 +31,0 @@\n-import jdk.internal.classfile.CodeBuilder;\n-import jdk.internal.classfile.CodeElement;\n-import jdk.internal.classfile.CodeModel;\n@@ -49,3 +32,0 @@\n-import jdk.internal.classfile.FieldBuilder;\n-import jdk.internal.classfile.FieldElement;\n-import jdk.internal.classfile.FieldModel;\n@@ -53,13 +33,0 @@\n-import jdk.internal.classfile.Interfaces;\n-import jdk.internal.classfile.MethodBuilder;\n-import jdk.internal.classfile.MethodElement;\n-import jdk.internal.classfile.impl.TemporaryConstantPool;\n-import jdk.internal.classfile.instruction.FieldInstruction;\n-import jdk.internal.classfile.instruction.InvokeDynamicInstruction;\n-import jdk.internal.classfile.instruction.InvokeInstruction;\n-import jdk.internal.classfile.instruction.NewMultiArrayInstruction;\n-import jdk.internal.classfile.instruction.NewObjectInstruction;\n-import jdk.internal.classfile.instruction.NewReferenceArrayInstruction;\n-import jdk.internal.classfile.instruction.TypeCheckInstruction;\n-import jdk.internal.classfile.MethodModel;\n-import jdk.internal.classfile.MethodSignature;\n@@ -67,28 +34,1 @@\n-import jdk.internal.classfile.Signature;\n-import jdk.internal.classfile.Superclass;\n-import jdk.internal.classfile.TypeAnnotation;\n-import jdk.internal.classfile.attribute.AnnotationDefaultAttribute;\n-import jdk.internal.classfile.attribute.EnclosingMethodAttribute;\n-import jdk.internal.classfile.attribute.ExceptionsAttribute;\n-import jdk.internal.classfile.attribute.InnerClassInfo;\n-import jdk.internal.classfile.attribute.InnerClassesAttribute;\n-import jdk.internal.classfile.attribute.ModuleAttribute;\n-import jdk.internal.classfile.attribute.ModuleProvideInfo;\n-import jdk.internal.classfile.attribute.NestHostAttribute;\n-import jdk.internal.classfile.attribute.NestMembersAttribute;\n-import jdk.internal.classfile.attribute.PermittedSubclassesAttribute;\n-import jdk.internal.classfile.attribute.RecordAttribute;\n-import jdk.internal.classfile.attribute.RecordComponentInfo;\n-import jdk.internal.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.RuntimeInvisibleParameterAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.RuntimeVisibleParameterAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.SignatureAttribute;\n-import jdk.internal.classfile.constantpool.Utf8Entry;\n-import jdk.internal.classfile.instruction.ExceptionCatch;\n-import jdk.internal.classfile.instruction.LocalVariable;\n-import jdk.internal.classfile.instruction.LocalVariableType;\n-import jdk.internal.classfile.impl.Util;\n-import jdk.internal.classfile.instruction.ConstantInstruction.LoadConstantInstruction;\n+import jdk.internal.classfile.impl.ClassRemapperImpl;\n@@ -112,1 +52,1 @@\n-public sealed interface ClassRemapper extends ClassTransform {\n+public sealed interface ClassRemapper extends ClassTransform permits ClassRemapperImpl {\n@@ -138,1 +78,1 @@\n-     * @return class target class\n+     * @return target class\n@@ -143,2 +83,1 @@\n-     * Returns this {@code ClassRemapper} as {@link FieldTransform} instance\n-     * @return this {@code ClassRemapper} as {@link FieldTransform} instance\n+     * {@return this {@code ClassRemapper} as {@link FieldTransform} instance}\n@@ -149,2 +88,1 @@\n-     * Returns this {@code ClassRemapper} as {@link MethodTransform} instance\n-     * @return this {@code ClassRemapper} as {@link MethodTransform} instance\n+     * {@return this {@code ClassRemapper} as {@link MethodTransform} instance}\n@@ -155,2 +93,1 @@\n-     * Returns this {@code ClassRemapper} as {@link CodeTransform} instance\n-     * @return this {@code ClassRemapper} as {@link CodeTransform} instance\n+     * {@return this {@code ClassRemapper} as {@link CodeTransform} instance}\n@@ -169,326 +106,0 @@\n-\n-    record ClassRemapperImpl(Function<ClassDesc, ClassDesc> mapFunction) implements ClassRemapper {\n-\n-        @Override\n-        public void accept(ClassBuilder clb, ClassElement cle) {\n-            switch (cle) {\n-                case FieldModel fm ->\n-                    clb.withField(fm.fieldName().stringValue(), map(\n-                            fm.fieldTypeSymbol()), fb ->\n-                                    fm.forEachElement(asFieldTransform().resolve(fb).consumer()));\n-                case MethodModel mm ->\n-                    clb.withMethod(mm.methodName().stringValue(), mapMethodDesc(\n-                            mm.methodTypeSymbol()), mm.flags().flagsMask(), mb ->\n-                                    mm.forEachElement(asMethodTransform().resolve(mb).consumer()));\n-                case Superclass sc ->\n-                    clb.withSuperclass(map(sc.superclassEntry().asSymbol()));\n-                case Interfaces ins ->\n-                    clb.withInterfaceSymbols(Util.mappedList(ins.interfaces(), in ->\n-                            map(in.asSymbol())));\n-                case SignatureAttribute sa ->\n-                    clb.with(SignatureAttribute.of(mapClassSignature(sa.asClassSignature())));\n-                case InnerClassesAttribute ica ->\n-                    clb.with(InnerClassesAttribute.of(ica.classes().stream().map(ici ->\n-                            InnerClassInfo.of(map(ici.innerClass().asSymbol()),\n-                                    ici.outerClass().map(oc -> map(oc.asSymbol())),\n-                                    ici.innerName().map(Utf8Entry::stringValue),\n-                                    ici.flagsMask())).toList()));\n-                case EnclosingMethodAttribute ema ->\n-                    clb.with(EnclosingMethodAttribute.of(map(ema.enclosingClass().asSymbol()),\n-                            ema.enclosingMethodName().map(Utf8Entry::stringValue),\n-                            ema.enclosingMethodTypeSymbol().map(this::mapMethodDesc)));\n-                case RecordAttribute ra ->\n-                    clb.with(RecordAttribute.of(ra.components().stream()\n-                            .map(this::mapRecordComponent).toList()));\n-                case ModuleAttribute ma ->\n-                    clb.with(ModuleAttribute.of(ma.moduleName(), ma.moduleFlagsMask(),\n-                            ma.moduleVersion().orElse(null),\n-                            ma.requires(), ma.exports(), ma.opens(),\n-                            ma.uses().stream().map(ce ->\n-                                    clb.constantPool().classEntry(map(ce.asSymbol()))).toList(),\n-                            ma.provides().stream().map(mp ->\n-                                    ModuleProvideInfo.of(map(mp.provides().asSymbol()),\n-                                            mp.providesWith().stream().map(pw ->\n-                                                    map(pw.asSymbol())).toList())).toList()));\n-                case NestHostAttribute nha ->\n-                    clb.with(NestHostAttribute.of(map(nha.nestHost().asSymbol())));\n-                case NestMembersAttribute nma ->\n-                    clb.with(NestMembersAttribute.ofSymbols(nma.nestMembers().stream()\n-                            .map(nm -> map(nm.asSymbol())).toList()));\n-                case PermittedSubclassesAttribute psa ->\n-                    clb.with(PermittedSubclassesAttribute.ofSymbols(\n-                            psa.permittedSubclasses().stream().map(ps ->\n-                                    map(ps.asSymbol())).toList()));\n-                case RuntimeVisibleAnnotationsAttribute aa ->\n-                    clb.with(RuntimeVisibleAnnotationsAttribute.of(\n-                            mapAnnotations(aa.annotations())));\n-                case RuntimeInvisibleAnnotationsAttribute aa ->\n-                    clb.with(RuntimeInvisibleAnnotationsAttribute.of(\n-                            mapAnnotations(aa.annotations())));\n-                case RuntimeVisibleTypeAnnotationsAttribute aa ->\n-                    clb.with(RuntimeVisibleTypeAnnotationsAttribute.of(\n-                            mapTypeAnnotations(aa.annotations())));\n-                case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n-                    clb.with(RuntimeInvisibleTypeAnnotationsAttribute.of(\n-                            mapTypeAnnotations(aa.annotations())));\n-                default ->\n-                    clb.with(cle);\n-            }\n-        }\n-\n-        @Override\n-        public FieldTransform asFieldTransform() {\n-            return (FieldBuilder fb, FieldElement fe) -> {\n-                switch (fe) {\n-                    case SignatureAttribute sa ->\n-                        fb.with(SignatureAttribute.of(\n-                                mapSignature(sa.asTypeSignature())));\n-                    case RuntimeVisibleAnnotationsAttribute aa ->\n-                        fb.with(RuntimeVisibleAnnotationsAttribute.of(\n-                                mapAnnotations(aa.annotations())));\n-                    case RuntimeInvisibleAnnotationsAttribute aa ->\n-                        fb.with(RuntimeInvisibleAnnotationsAttribute.of(\n-                                mapAnnotations(aa.annotations())));\n-                    case RuntimeVisibleTypeAnnotationsAttribute aa ->\n-                        fb.with(RuntimeVisibleTypeAnnotationsAttribute.of(\n-                                mapTypeAnnotations(aa.annotations())));\n-                    case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n-                        fb.with(RuntimeInvisibleTypeAnnotationsAttribute.of(\n-                                mapTypeAnnotations(aa.annotations())));\n-                    default ->\n-                        fb.with(fe);\n-                }\n-            };\n-        }\n-\n-        @Override\n-        public MethodTransform asMethodTransform() {\n-            return (MethodBuilder mb, MethodElement me) -> {\n-                switch (me) {\n-                    case AnnotationDefaultAttribute ada ->\n-                        mb.with(AnnotationDefaultAttribute.of(\n-                                mapAnnotationValue(ada.defaultValue())));\n-                    case CodeModel com ->\n-                        mb.transformCode(com, asCodeTransform());\n-                    case ExceptionsAttribute ea ->\n-                        mb.with(ExceptionsAttribute.ofSymbols(\n-                                ea.exceptions().stream().map(ce ->\n-                                        map(ce.asSymbol())).toList()));\n-                    case SignatureAttribute sa ->\n-                        mb.with(SignatureAttribute.of(\n-                                mapMethodSignature(sa.asMethodSignature())));\n-                    case RuntimeVisibleAnnotationsAttribute aa ->\n-                        mb.with(RuntimeVisibleAnnotationsAttribute.of(\n-                                mapAnnotations(aa.annotations())));\n-                    case RuntimeInvisibleAnnotationsAttribute aa ->\n-                        mb.with(RuntimeInvisibleAnnotationsAttribute.of(\n-                                mapAnnotations(aa.annotations())));\n-                    case RuntimeVisibleParameterAnnotationsAttribute paa ->\n-                        mb.with(RuntimeVisibleParameterAnnotationsAttribute.of(\n-                                paa.parameterAnnotations().stream()\n-                                        .map(this::mapAnnotations).toList()));\n-                    case RuntimeInvisibleParameterAnnotationsAttribute paa ->\n-                        mb.with(RuntimeInvisibleParameterAnnotationsAttribute.of(\n-                                paa.parameterAnnotations().stream()\n-                                        .map(this::mapAnnotations).toList()));\n-                    case RuntimeVisibleTypeAnnotationsAttribute aa ->\n-                        mb.with(RuntimeVisibleTypeAnnotationsAttribute.of(\n-                                mapTypeAnnotations(aa.annotations())));\n-                    case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n-                        mb.with(RuntimeInvisibleTypeAnnotationsAttribute.of(\n-                                mapTypeAnnotations(aa.annotations())));\n-                    default ->\n-                        mb.with(me);\n-                }\n-            };\n-        }\n-\n-        @Override\n-        public CodeTransform asCodeTransform() {\n-            return (CodeBuilder cob, CodeElement coe) -> {\n-                switch (coe) {\n-                    case FieldInstruction fai ->\n-                        cob.fieldInstruction(fai.opcode(), map(fai.owner().asSymbol()),\n-                                fai.name().stringValue(), map(fai.typeSymbol()));\n-                    case InvokeInstruction ii ->\n-                        cob.invokeInstruction(ii.opcode(), map(ii.owner().asSymbol()),\n-                                ii.name().stringValue(), mapMethodDesc(ii.typeSymbol()),\n-                                ii.isInterface());\n-                    case InvokeDynamicInstruction idi ->\n-                        cob.invokeDynamicInstruction(DynamicCallSiteDesc.of(\n-                                idi.bootstrapMethod(), idi.name().stringValue(),\n-                                mapMethodDesc(idi.typeSymbol()),\n-                                idi.bootstrapArgs().stream().map(this::mapConstantValue).toArray(ConstantDesc[]::new)));\n-                    case NewObjectInstruction c ->\n-                        cob.newObjectInstruction(map(c.className().asSymbol()));\n-                    case NewReferenceArrayInstruction c ->\n-                        cob.anewarray(map(c.componentType().asSymbol()));\n-                    case NewMultiArrayInstruction c ->\n-                        cob.multianewarray(map(c.arrayType().asSymbol()), c.dimensions());\n-                    case TypeCheckInstruction c ->\n-                        cob.typeCheckInstruction(c.opcode(), map(c.type().asSymbol()));\n-                    case ExceptionCatch c ->\n-                        cob.exceptionCatch(c.tryStart(), c.tryEnd(), c.handler(),c.catchType()\n-                                .map(d -> TemporaryConstantPool.INSTANCE.classEntry(map(d.asSymbol()))));\n-                    case LocalVariable c ->\n-                        cob.localVariable(c.slot(), c.name().stringValue(), map(c.typeSymbol()),\n-                                c.startScope(), c.endScope());\n-                    case LocalVariableType c ->\n-                        cob.localVariableType(c.slot(), c.name().stringValue(),\n-                                mapSignature(c.signatureSymbol()), c.startScope(), c.endScope());\n-                    case LoadConstantInstruction ldc ->\n-                        cob.constantInstruction(ldc.opcode(),\n-                                mapConstantValue(ldc.constantValue()));\n-                    case RuntimeVisibleTypeAnnotationsAttribute aa ->\n-                        cob.with(RuntimeVisibleTypeAnnotationsAttribute.of(\n-                                mapTypeAnnotations(aa.annotations())));\n-                    case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n-                        cob.with(RuntimeInvisibleTypeAnnotationsAttribute.of(\n-                                mapTypeAnnotations(aa.annotations())));\n-                    default ->\n-                        cob.with(coe);\n-                }\n-            };\n-        }\n-\n-        @Override\n-        public ClassDesc map(ClassDesc desc) {\n-            if (desc == null) return null;\n-            if (desc.isArray()) return map(desc.componentType()).arrayType();\n-            if (desc.isPrimitive()) return desc;\n-            return mapFunction.apply(desc);\n-        }\n-\n-        MethodTypeDesc mapMethodDesc(MethodTypeDesc desc) {\n-            return MethodTypeDesc.of(map(desc.returnType()),\n-                    desc.parameterList().stream().map(this::map).toArray(ClassDesc[]::new));\n-        }\n-\n-        ClassSignature mapClassSignature(ClassSignature signature) {\n-            return ClassSignature.of(mapTypeParams(signature.typeParameters()),\n-                    mapSignature(signature.superclassSignature()),\n-                    signature.superinterfaceSignatures().stream()\n-                            .map(this::mapSignature).toArray(Signature.RefTypeSig[]::new));\n-        }\n-\n-        MethodSignature mapMethodSignature(MethodSignature signature) {\n-            return MethodSignature.of(mapTypeParams(signature.typeParameters()),\n-                    signature.throwableSignatures().stream().map(this::mapSignature).toList(),\n-                    mapSignature(signature.result()),\n-                    signature.arguments().stream()\n-                            .map(this::mapSignature).toArray(Signature[]::new));\n-        }\n-\n-        RecordComponentInfo mapRecordComponent(RecordComponentInfo component) {\n-            return RecordComponentInfo.of(component.name().stringValue(),\n-                    map(component.descriptorSymbol()),\n-                    component.attributes().stream().map(atr ->\n-                        switch (atr) {\n-                            case SignatureAttribute sa ->\n-                                SignatureAttribute.of(\n-                                        mapSignature(sa.asTypeSignature()));\n-                            case RuntimeVisibleAnnotationsAttribute aa ->\n-                                RuntimeVisibleAnnotationsAttribute.of(\n-                                        mapAnnotations(aa.annotations()));\n-                            case RuntimeInvisibleAnnotationsAttribute aa ->\n-                                RuntimeInvisibleAnnotationsAttribute.of(\n-                                        mapAnnotations(aa.annotations()));\n-                            case RuntimeVisibleTypeAnnotationsAttribute aa ->\n-                                RuntimeVisibleTypeAnnotationsAttribute.of(\n-                                        mapTypeAnnotations(aa.annotations()));\n-                            case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n-                                RuntimeInvisibleTypeAnnotationsAttribute.of(\n-                                        mapTypeAnnotations(aa.annotations()));\n-                            default -> atr;\n-                        }).toList());\n-        }\n-\n-        DirectMethodHandleDesc mapDirectMethodHandle(DirectMethodHandleDesc dmhd) {\n-            return switch (dmhd.kind()) {\n-                case GETTER, SETTER, STATIC_GETTER, STATIC_SETTER ->\n-                    MethodHandleDesc.ofField(dmhd.kind(), map(dmhd.owner()),\n-                            dmhd.methodName(),\n-                            map(ClassDesc.ofDescriptor(dmhd.lookupDescriptor())));\n-                default ->\n-                    MethodHandleDesc.ofMethod(dmhd.kind(), map(dmhd.owner()),\n-                            dmhd.methodName(),\n-                            mapMethodDesc(MethodTypeDesc.ofDescriptor(dmhd.lookupDescriptor())));\n-            };\n-        }\n-\n-        ConstantDesc mapConstantValue(ConstantDesc value) {\n-            return switch (value) {\n-                case ClassDesc cd ->\n-                    map(cd);\n-                case DynamicConstantDesc<?> dcd ->\n-                    mapDynamicConstant(dcd);\n-                case DirectMethodHandleDesc dmhd ->\n-                    mapDirectMethodHandle(dmhd);\n-                case MethodTypeDesc mtd ->\n-                    mapMethodDesc(mtd);\n-                default -> value;\n-            };\n-        }\n-\n-        DynamicConstantDesc<?> mapDynamicConstant(DynamicConstantDesc<?> dcd) {\n-            return DynamicConstantDesc.ofNamed(mapDirectMethodHandle(dcd.bootstrapMethod()),\n-                    dcd.constantName(),\n-                    map(dcd.constantType()),\n-                    dcd.bootstrapArgsList().stream().map(this::mapConstantValue).toArray(ConstantDesc[]::new));\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        <S extends Signature> S mapSignature(S signature) {\n-            return (S) switch (signature) {\n-                case Signature.ArrayTypeSig ats ->\n-                    Signature.ArrayTypeSig.of(mapSignature(ats.componentSignature()));\n-                case Signature.ClassTypeSig cts ->\n-                    Signature.ClassTypeSig.of(\n-                            cts.outerType().map(this::mapSignature).orElse(null),\n-                            map(cts.classDesc()),\n-                            cts.typeArgs().stream()\n-                                    .map(ta -> Signature.TypeArg.of(\n-                                            ta.wildcardIndicator(),\n-                                            ta.boundType().map(this::mapSignature)))\n-                                    .toArray(Signature.TypeArg[]::new));\n-                default -> signature;\n-            };\n-        }\n-\n-        List<Annotation> mapAnnotations(List<Annotation> annotations) {\n-            return annotations.stream().map(this::mapAnnotation).toList();\n-        }\n-\n-        Annotation mapAnnotation(Annotation a) {\n-            return Annotation.of(map(a.classSymbol()), a.elements().stream().map(el ->\n-                    AnnotationElement.of(el.name(), mapAnnotationValue(el.value()))).toList());\n-        }\n-\n-        AnnotationValue mapAnnotationValue(AnnotationValue val) {\n-            return switch (val) {\n-                case AnnotationValue.OfAnnotation oa ->\n-                    AnnotationValue.ofAnnotation(mapAnnotation(oa.annotation()));\n-                case AnnotationValue.OfArray oa ->\n-                    AnnotationValue.ofArray(oa.values().stream().map(this::mapAnnotationValue).toList());\n-                case AnnotationValue.OfConstant oc -> oc;\n-                case AnnotationValue.OfClass oc ->\n-                    AnnotationValue.ofClass(map(oc.classSymbol()));\n-                case AnnotationValue.OfEnum oe ->\n-                    AnnotationValue.ofEnum(map(oe.classSymbol()), oe.constantName().stringValue());\n-            };\n-        }\n-\n-        List<TypeAnnotation> mapTypeAnnotations(List<TypeAnnotation> typeAnnotations) {\n-            return typeAnnotations.stream().map(a -> TypeAnnotation.of(a.targetInfo(),\n-                    a.targetPath(), map(a.classSymbol()),\n-                    a.elements().stream().map(el -> AnnotationElement.of(el.name(),\n-                            mapAnnotationValue(el.value()))).toList())).toList();\n-        }\n-\n-        List<Signature.TypeParam> mapTypeParams(List<Signature.TypeParam> typeParams) {\n-            return typeParams.stream().map(tp -> Signature.TypeParam.of(tp.identifier(),\n-                    tp.classBound().map(this::mapSignature),\n-                    tp.interfaceBounds().stream()\n-                            .map(this::mapSignature).toArray(Signature.RefTypeSig[]::new))).toList();\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/ClassRemapper.java","additions":7,"deletions":396,"binary":false,"changes":403,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -22,1 +22,0 @@\n- *\n@@ -27,2 +26,0 @@\n-import java.util.Arrays;\n-\n@@ -31,2 +28,0 @@\n-import jdk.internal.classfile.CodeBuilder;\n-import jdk.internal.classfile.CodeElement;\n@@ -34,5 +29,0 @@\n-import jdk.internal.classfile.Signature;\n-import jdk.internal.classfile.instruction.IncrementInstruction;\n-import jdk.internal.classfile.instruction.LoadInstruction;\n-import jdk.internal.classfile.instruction.LocalVariable;\n-import jdk.internal.classfile.instruction.StoreInstruction;\n@@ -40,1 +30,1 @@\n-import jdk.internal.classfile.instruction.LocalVariableType;\n+import jdk.internal.classfile.impl.CodeLocalsShifterImpl;\n@@ -48,1 +38,1 @@\n-public sealed interface CodeLocalsShifter extends CodeTransform {\n+public sealed interface CodeLocalsShifter extends CodeTransform permits CodeLocalsShifterImpl {\n@@ -52,1 +42,1 @@\n-     * with fixed local slots calculated from provided method information\n+     * with fixed local slots calculated from provided method information.\n@@ -63,61 +53,0 @@\n-\n-    final static class CodeLocalsShifterImpl implements CodeLocalsShifter {\n-\n-        private int[] locals = new int[0];\n-        private final int fixed;\n-\n-        private CodeLocalsShifterImpl(int fixed) {\n-            this.fixed = fixed;\n-        }\n-\n-        @Override\n-        public void accept(CodeBuilder cob, CodeElement coe) {\n-            switch (coe) {\n-                case LoadInstruction li ->\n-                    cob.loadInstruction(\n-                            li.typeKind(),\n-                            shift(cob, li.slot(), li.typeKind()));\n-                case StoreInstruction si ->\n-                    cob.storeInstruction(\n-                            si.typeKind(),\n-                            shift(cob, si.slot(), si.typeKind()));\n-                case IncrementInstruction ii ->\n-                    cob.incrementInstruction(\n-                            shift(cob, ii.slot(), TypeKind.IntType),\n-                            ii.constant());\n-                case LocalVariable lv ->\n-                    cob.localVariable(\n-                            shift(cob, lv.slot(), TypeKind.fromDescriptor(lv.type().stringValue())),\n-                            lv.name(),\n-                            lv.type(),\n-                            lv.startScope(),\n-                            lv.endScope());\n-                case LocalVariableType lvt ->\n-                    cob.localVariableType(\n-                            shift(cob, lvt.slot(),\n-                                    (lvt.signatureSymbol() instanceof Signature.BaseTypeSig bsig)\n-                                            ? TypeKind.fromDescriptor(bsig.signatureString())\n-                                            : TypeKind.ReferenceType),\n-                            lvt.name(),\n-                            lvt.signature(),\n-                            lvt.startScope(),\n-                            lvt.endScope());\n-                default -> cob.with(coe);\n-            }\n-        }\n-\n-        private int shift(CodeBuilder cob, int slot, TypeKind tk) {\n-            if (tk == TypeKind.VoidType)  throw new IllegalArgumentException(\"Illegal local void type\");\n-            if (slot >= fixed) {\n-                int key = 2*slot - fixed + tk.slotSize() - 1;\n-                if (key >= locals.length) locals = Arrays.copyOf(locals, key + 20);\n-                slot = locals[key] - 1;\n-                if (slot < 0) {\n-                    slot = cob.allocateLocal(tk);\n-                    locals[key] = slot + 1;\n-                    if (tk.slotSize() == 2) locals[key - 1] = slot + 1;\n-                }\n-            }\n-            return slot;\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/CodeLocalsShifter.java","additions":4,"deletions":75,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -22,1 +22,0 @@\n- *\n@@ -30,1 +29,0 @@\n-import jdk.internal.classfile.CodeElement;\n@@ -32,4 +30,0 @@\n-import jdk.internal.classfile.instruction.BranchInstruction;\n-import jdk.internal.classfile.instruction.LookupSwitchInstruction;\n-import jdk.internal.classfile.instruction.SwitchCase;\n-import jdk.internal.classfile.instruction.TableSwitchInstruction;\n@@ -37,5 +31,1 @@\n-import jdk.internal.classfile.instruction.CharacterRange;\n-import jdk.internal.classfile.instruction.ExceptionCatch;\n-import jdk.internal.classfile.instruction.LabelTarget;\n-import jdk.internal.classfile.instruction.LocalVariable;\n-import jdk.internal.classfile.instruction.LocalVariableType;\n+import jdk.internal.classfile.impl.CodeRelabelerImpl;\n@@ -53,1 +43,1 @@\n-public sealed interface CodeRelabeler extends CodeTransform {\n+public sealed interface CodeRelabeler extends CodeTransform permits CodeRelabelerImpl {\n@@ -56,2 +46,2 @@\n-     * Creates new instance of CodeRelabeler\n-     * @return new instance of CodeRelabeler\n+     * Creates a new instance of CodeRelabeler.\n+     * @return a new instance of CodeRelabeler\n@@ -64,1 +54,1 @@\n-     * Creates new instance of CodeRelabeler storing the label mapping into the provided map\n+     * Creates a new instance of CodeRelabeler storing the label mapping into the provided map.\n@@ -66,1 +56,1 @@\n-     * @return new instance of CodeRelabeler\n+     * @return a new instance of CodeRelabeler\n@@ -73,1 +63,1 @@\n-     * Creates new instance of CodeRelabeler using provided {@link java.util.function.BiFunction}\n+     * Creates a new instance of CodeRelabeler using provided {@link java.util.function.BiFunction}\n@@ -76,1 +66,1 @@\n-     * @return\n+     * @return a new instance of CodeRelabeler\n@@ -89,66 +79,0 @@\n-\n-    record CodeRelabelerImpl(BiFunction<Label, CodeBuilder, Label> mapFunction) implements  CodeRelabeler {\n-\n-        @Override\n-        public Label relabel(Label label, CodeBuilder cob) {\n-            return mapFunction.apply(label, cob);\n-        }\n-\n-        @Override\n-        public void accept(CodeBuilder cob, CodeElement coe) {\n-            switch (coe) {\n-                case BranchInstruction bi ->\n-                    cob.branchInstruction(\n-                            bi.opcode(),\n-                            relabel(bi.target(), cob));\n-                case LookupSwitchInstruction lsi ->\n-                    cob.lookupSwitchInstruction(\n-                            relabel(lsi.defaultTarget(), cob),\n-                            lsi.cases().stream().map(c ->\n-                                    SwitchCase.of(\n-                                            c.caseValue(),\n-                                            relabel(c.target(), cob))).toList());\n-                case TableSwitchInstruction tsi ->\n-                    cob.tableSwitchInstruction(\n-                            tsi.lowValue(),\n-                            tsi.highValue(),\n-                            relabel(tsi.defaultTarget(), cob),\n-                            tsi.cases().stream().map(c ->\n-                                    SwitchCase.of(\n-                                            c.caseValue(),\n-                                            relabel(c.target(), cob))).toList());\n-                case LabelTarget lt ->\n-                    cob.labelBinding(\n-                            relabel(lt.label(), cob));\n-                case ExceptionCatch ec ->\n-                    cob.exceptionCatch(\n-                            relabel(ec.tryStart(), cob),\n-                            relabel(ec.tryEnd(), cob),\n-                            relabel(ec.handler(), cob),\n-                            ec.catchType());\n-                case LocalVariable lv ->\n-                    cob.localVariable(\n-                            lv.slot(),\n-                            lv.name().stringValue(),\n-                            lv.typeSymbol(),\n-                            relabel(lv.startScope(), cob),\n-                            relabel(lv.endScope(), cob));\n-                case LocalVariableType lvt ->\n-                    cob.localVariableType(\n-                            lvt.slot(),\n-                            lvt.name().stringValue(),\n-                            lvt.signatureSymbol(),\n-                            relabel(lvt.startScope(), cob),\n-                            relabel(lvt.endScope(), cob));\n-                case CharacterRange chr ->\n-                    cob.characterRange(\n-                            relabel(chr.startScope(), cob),\n-                            relabel(chr.endScope(), cob),\n-                            chr.characterRangeStart(),\n-                            chr.characterRangeEnd(),\n-                            chr.flags());\n-                default ->\n-                    cob.with(coe);\n-            }\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/CodeRelabeler.java","additions":9,"deletions":85,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -22,1 +22,0 @@\n- *\n@@ -26,1 +25,0 @@\n-import java.util.AbstractCollection;\n@@ -28,4 +26,0 @@\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.Map;\n-import java.util.NoSuchElementException;\n@@ -33,3 +27,0 @@\n-import java.util.function.Consumer;\n-import jdk.internal.classfile.CodeBuilder;\n-import jdk.internal.classfile.CodeElement;\n@@ -38,1 +29,0 @@\n-import jdk.internal.classfile.Opcode;\n@@ -40,1 +30,1 @@\n-import jdk.internal.classfile.instruction.*;\n+import jdk.internal.classfile.impl.CodeStackTrackerImpl;\n@@ -60,1 +50,1 @@\n-public sealed interface CodeStackTracker extends CodeTransform {\n+public sealed interface CodeStackTracker extends CodeTransform permits CodeStackTrackerImpl {\n@@ -63,1 +53,1 @@\n-     * Creates new instance of {@link CodeStackTracker} initialized with provided stack items\n+     * Creates new instance of {@link CodeStackTracker} initialized with provided stack items.\n@@ -75,1 +65,1 @@\n-      *\n+      * <p>\n@@ -87,1 +77,1 @@\n-      *\n+      * <p>\n@@ -94,280 +84,0 @@\n-\n-    final static class CodeStackTrackerImpl implements CodeStackTracker {\n-\n-        private static record Item(TypeKind type, Item next) {\n-        }\n-\n-        private final class Stack extends AbstractCollection<TypeKind> {\n-\n-            private Item top;\n-            private int count, realSize;\n-\n-            Stack(Item top, int count, int realSize) {\n-                this.top = top;\n-                this.count = count;\n-                this.realSize = realSize;\n-            }\n-\n-            @Override\n-            public Iterator<TypeKind> iterator() {\n-                return new Iterator<TypeKind>() {\n-                    Item i = top;\n-\n-                    @Override\n-                    public boolean hasNext() {\n-                        return i != null;\n-                    }\n-\n-                    @Override\n-                    public TypeKind next() {\n-                        if (i == null) {\n-                            throw new NoSuchElementException();\n-                        }\n-                        var t = i.type;\n-                        i = i.next;\n-                        return t;\n-                    }\n-                };\n-            }\n-\n-            @Override\n-            public int size() {\n-                return count;\n-            }\n-\n-            private void push(TypeKind type) {\n-                top = new Item(type, top);\n-                realSize += type.slotSize();\n-                count++;\n-                if (maxSize != null && realSize > maxSize) maxSize = realSize;\n-            }\n-\n-            private TypeKind pop() {\n-                var t = top.type;\n-                realSize -= t.slotSize();\n-                count--;\n-                top = top.next;\n-                return t;\n-            }\n-        }\n-\n-        private Stack stack = new Stack(null, 0, 0);\n-        private Integer maxSize = 0;\n-\n-        CodeStackTrackerImpl(TypeKind... initialStack) {\n-            for (int i = initialStack.length - 1; i >= 0; i--)\n-                push(initialStack[i]);\n-        }\n-\n-        @Override\n-        public Optional<Collection<TypeKind>> stack() {\n-            return Optional.ofNullable(fork());\n-        }\n-\n-        @Override\n-        public Optional<Integer> maxStackSize() {\n-            return Optional.ofNullable(maxSize);\n-        }\n-\n-        private final Map<Label, Stack> map = new HashMap<>();\n-\n-        private void push(TypeKind type) {\n-            if (stack != null) {\n-                if (type != TypeKind.VoidType) stack.push(type);\n-            } else {\n-                maxSize = null;\n-            }\n-        }\n-\n-        private void pop(int i) {\n-            if (stack != null) {\n-                while (i-- > 0) stack.pop();\n-            } else {\n-                maxSize = null;\n-            }\n-        }\n-\n-        private Stack fork() {\n-            return stack == null ? null : new Stack(stack.top, stack.count, stack.realSize);\n-        }\n-\n-        private void withStack(Consumer<Stack> c) {\n-            if (stack != null) c.accept(stack);\n-            else maxSize = null;\n-        }\n-\n-        @Override\n-        public void accept(CodeBuilder cb, CodeElement el) {\n-            cb.with(el);\n-            switch (el) {\n-                case ArrayLoadInstruction i -> {\n-                    pop(2);push(i.typeKind());\n-                }\n-                case ArrayStoreInstruction i ->\n-                    pop(3);\n-                case BranchInstruction i -> {\n-                    if (i.opcode() == Opcode.GOTO || i.opcode() == Opcode.GOTO_W) {\n-                        map.put(i.target(), stack);\n-                        stack = null;\n-                    } else {\n-                        pop(1);\n-                        map.put(i.target(), fork());\n-                    }\n-                }\n-                case ConstantInstruction i ->\n-                    push(i.typeKind());\n-                case ConvertInstruction i -> {\n-                    pop(1);push(i.toType());\n-                }\n-                case FieldInstruction i -> {\n-                    switch (i.opcode()) {\n-                        case GETSTATIC ->\n-                            push(TypeKind.fromDescriptor(i.type().stringValue()));\n-                        case GETFIELD -> {\n-                            pop(1);push(TypeKind.fromDescriptor(i.type().stringValue()));\n-                        }\n-                        case PUTSTATIC ->\n-                            pop(1);\n-                        case PUTFIELD ->\n-                            pop(2);\n-                    }\n-                }\n-                case InvokeDynamicInstruction i -> {\n-                    var type = i.typeSymbol();\n-                    pop(type.parameterCount());\n-                    push(TypeKind.from(type.returnType()));\n-                }\n-                case InvokeInstruction i -> {\n-                    var type = i.typeSymbol();\n-                    pop(type.parameterCount());\n-                    if (i.opcode() != Opcode.INVOKESTATIC) pop(1);\n-                    push(TypeKind.from(type.returnType()));\n-                }\n-                case LoadInstruction i ->\n-                    push(i.typeKind());\n-                case StoreInstruction i ->\n-                    pop(1);\n-                case LookupSwitchInstruction i -> {\n-                    map.put(i.defaultTarget(), stack);\n-                    for (var c : i.cases()) map.put(c.target(), fork());\n-                    stack = null;\n-                }\n-                case MonitorInstruction i ->\n-                    pop(1);\n-                case NewMultiArrayInstruction i -> {\n-                    pop(i.dimensions());push(TypeKind.ReferenceType);\n-                }\n-                case NewObjectInstruction i ->\n-                    push(TypeKind.ReferenceType);\n-                case NewPrimitiveArrayInstruction i -> {\n-                    pop(1);push(TypeKind.ReferenceType);\n-                }\n-                case NewReferenceArrayInstruction i -> {\n-                    pop(1);push(TypeKind.ReferenceType);\n-                }\n-                case NopInstruction i -> {}\n-                case OperatorInstruction i -> {\n-                    switch (i.opcode()) {\n-                        case ARRAYLENGTH, INEG, LNEG, FNEG, DNEG -> pop(1);\n-                        default -> pop(2);\n-                    }\n-                    push(i.typeKind());\n-                }\n-                case ReturnInstruction i ->\n-                    stack = null;\n-                case StackInstruction i -> {\n-                    switch (i.opcode()) {\n-                        case POP -> pop(1);\n-                        case POP2 -> withStack(s -> {\n-                            if (s.pop().slotSize() == 1) s.pop();\n-                        });\n-                        case DUP ->  withStack(s -> {\n-                            var v = s.pop();s.push(v);s.push(v);\n-                        });\n-                        case DUP2 -> withStack(s -> {\n-                            var v1 = s.pop();\n-                            if (v1.slotSize() == 1) {\n-                                var v2 = s.pop();\n-                                s.push(v2);s.push(v1);\n-                                s.push(v2);s.push(v1);\n-                            } else {\n-                                s.push(v1);s.push(v1);\n-                            }\n-                        });\n-                        case DUP_X1 -> withStack(s -> {\n-                            var v1 = s.pop();\n-                            var v2 = s.pop();\n-                            s.push(v1);s.push(v2);s.push(v1);\n-                        });\n-                        case DUP_X2 -> withStack(s -> {\n-                            var v1 = s.pop();\n-                            var v2 = s.pop();\n-                            if (v2.slotSize() == 1) {\n-                                var v3 = s.pop();\n-                                s.push(v1);s.push(v3);s.push(v2);s.push(v1);\n-                            } else {\n-                                s.push(v1);s.push(v2);s.push(v1);\n-                            }\n-                        });\n-                        case DUP2_X1 -> withStack(s -> {\n-                            var v1 = s.pop();\n-                            var v2 = s.pop();\n-                            if (v1.slotSize() == 1) {\n-                                var v3 = s.pop();\n-                                s.push(v2);s.push(v1);s.push(v3);s.push(v2);s.push(v1);\n-                            } else {\n-                                s.push(v1);s.push(v2);s.push(v1);\n-                            }\n-                        });\n-                        case DUP2_X2 -> withStack(s -> {\n-                            var v1 = s.pop();\n-                            var v2 = s.pop();\n-                            if (v1.slotSize() == 1) {\n-                                var v3 = s.pop();\n-                                if (v3.slotSize() == 1) {\n-                                    var v4 = s.pop();\n-                                    s.push(v2);s.push(v1);s.push(v4);s.push(v3);s.push(v2);s.push(v1);\n-                                } else {\n-                                    s.push(v2);s.push(v1);s.push(v3);s.push(v2);s.push(v1);\n-                                }\n-                            } else {\n-                                if (v2.slotSize() == 1) {\n-                                    var v3 = s.pop();\n-                                    s.push(v1);s.push(v3);s.push(v2);s.push(v1);\n-                                } else {\n-                                    s.push(v1);s.push(v2);s.push(v1);\n-                                }\n-                            }\n-                        });\n-                        case SWAP -> withStack(s -> {\n-                            var v1 = s.pop();\n-                            var v2 = s.pop();\n-                            s.push(v1);s.push(v2);\n-                        });\n-                    }\n-                }\n-                case TableSwitchInstruction i -> {\n-                    map.put(i.defaultTarget(), stack);\n-                    for (var c : i.cases()) map.put(c.target(), fork());\n-                    stack = null;\n-                }\n-                case ThrowInstruction i ->\n-                    stack = null;\n-                case TypeCheckInstruction i -> {\n-                    switch (i.opcode()) {\n-                        case CHECKCAST -> {\n-                            pop(1);push(TypeKind.ReferenceType);\n-                        }\n-                        case INSTANCEOF -> {\n-                            pop(1);push(TypeKind.IntType);\n-                        }\n-                    }\n-                }\n-                case ExceptionCatch i ->\n-                    map.put(i.handler(), new Stack(new Item(TypeKind.ReferenceType, null), 1, 1));\n-                case LabelTarget i ->\n-                    stack = map.getOrDefault(i.label(), stack);\n-                default -> {}\n-            }\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/CodeStackTracker.java","additions":6,"deletions":296,"binary":false,"changes":302,"status":"modified"},{"patch":"@@ -0,0 +1,416 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.Annotation;\n+import jdk.internal.classfile.AnnotationElement;\n+import jdk.internal.classfile.AnnotationValue;\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.ClassSignature;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.CodeTransform;\n+import jdk.internal.classfile.FieldBuilder;\n+import jdk.internal.classfile.FieldElement;\n+import jdk.internal.classfile.FieldModel;\n+import jdk.internal.classfile.FieldTransform;\n+import jdk.internal.classfile.Interfaces;\n+import jdk.internal.classfile.MethodBuilder;\n+import jdk.internal.classfile.MethodElement;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.MethodSignature;\n+import jdk.internal.classfile.MethodTransform;\n+import jdk.internal.classfile.Signature;\n+import jdk.internal.classfile.Superclass;\n+import jdk.internal.classfile.TypeAnnotation;\n+import jdk.internal.classfile.attribute.AnnotationDefaultAttribute;\n+import jdk.internal.classfile.attribute.EnclosingMethodAttribute;\n+import jdk.internal.classfile.attribute.ExceptionsAttribute;\n+import jdk.internal.classfile.attribute.InnerClassInfo;\n+import jdk.internal.classfile.attribute.InnerClassesAttribute;\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n+import jdk.internal.classfile.attribute.ModuleProvideInfo;\n+import jdk.internal.classfile.attribute.NestHostAttribute;\n+import jdk.internal.classfile.attribute.NestMembersAttribute;\n+import jdk.internal.classfile.attribute.PermittedSubclassesAttribute;\n+import jdk.internal.classfile.attribute.RecordAttribute;\n+import jdk.internal.classfile.attribute.RecordComponentInfo;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleParameterAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleParameterAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.SignatureAttribute;\n+import jdk.internal.classfile.components.ClassRemapper;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.instruction.ConstantInstruction.LoadConstantInstruction;\n+import jdk.internal.classfile.instruction.ExceptionCatch;\n+import jdk.internal.classfile.instruction.FieldInstruction;\n+import jdk.internal.classfile.instruction.InvokeDynamicInstruction;\n+import jdk.internal.classfile.instruction.InvokeInstruction;\n+import jdk.internal.classfile.instruction.LocalVariable;\n+import jdk.internal.classfile.instruction.LocalVariableType;\n+import jdk.internal.classfile.instruction.NewMultiArrayInstruction;\n+import jdk.internal.classfile.instruction.NewObjectInstruction;\n+import jdk.internal.classfile.instruction.NewReferenceArrayInstruction;\n+import jdk.internal.classfile.instruction.TypeCheckInstruction;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicCallSiteDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+public record ClassRemapperImpl(Function<ClassDesc, ClassDesc> mapFunction) implements ClassRemapper {\n+\n+    @Override\n+    public void accept(ClassBuilder clb, ClassElement cle) {\n+        switch (cle) {\n+            case FieldModel fm ->\n+                clb.withField(fm.fieldName().stringValue(), map(\n+                        fm.fieldTypeSymbol()), fb ->\n+                                fm.forEachElement(asFieldTransform().resolve(fb).consumer()));\n+            case MethodModel mm ->\n+                clb.withMethod(mm.methodName().stringValue(), mapMethodDesc(\n+                        mm.methodTypeSymbol()), mm.flags().flagsMask(), mb ->\n+                                mm.forEachElement(asMethodTransform().resolve(mb).consumer()));\n+            case Superclass sc ->\n+                clb.withSuperclass(map(sc.superclassEntry().asSymbol()));\n+            case Interfaces ins ->\n+                clb.withInterfaceSymbols(Util.mappedList(ins.interfaces(), in ->\n+                        map(in.asSymbol())));\n+            case SignatureAttribute sa ->\n+                clb.with(SignatureAttribute.of(mapClassSignature(sa.asClassSignature())));\n+            case InnerClassesAttribute ica ->\n+                clb.with(InnerClassesAttribute.of(ica.classes().stream().map(ici ->\n+                        InnerClassInfo.of(map(ici.innerClass().asSymbol()),\n+                                ici.outerClass().map(oc -> map(oc.asSymbol())),\n+                                ici.innerName().map(Utf8Entry::stringValue),\n+                                ici.flagsMask())).toList()));\n+            case EnclosingMethodAttribute ema ->\n+                clb.with(EnclosingMethodAttribute.of(map(ema.enclosingClass().asSymbol()),\n+                        ema.enclosingMethodName().map(Utf8Entry::stringValue),\n+                        ema.enclosingMethodTypeSymbol().map(this::mapMethodDesc)));\n+            case RecordAttribute ra ->\n+                clb.with(RecordAttribute.of(ra.components().stream()\n+                        .map(this::mapRecordComponent).toList()));\n+            case ModuleAttribute ma ->\n+                clb.with(ModuleAttribute.of(ma.moduleName(), ma.moduleFlagsMask(),\n+                        ma.moduleVersion().orElse(null),\n+                        ma.requires(), ma.exports(), ma.opens(),\n+                        ma.uses().stream().map(ce ->\n+                                clb.constantPool().classEntry(map(ce.asSymbol()))).toList(),\n+                        ma.provides().stream().map(mp ->\n+                                ModuleProvideInfo.of(map(mp.provides().asSymbol()),\n+                                        mp.providesWith().stream().map(pw ->\n+                                                map(pw.asSymbol())).toList())).toList()));\n+            case NestHostAttribute nha ->\n+                clb.with(NestHostAttribute.of(map(nha.nestHost().asSymbol())));\n+            case NestMembersAttribute nma ->\n+                clb.with(NestMembersAttribute.ofSymbols(nma.nestMembers().stream()\n+                        .map(nm -> map(nm.asSymbol())).toList()));\n+            case PermittedSubclassesAttribute psa ->\n+                clb.with(PermittedSubclassesAttribute.ofSymbols(\n+                        psa.permittedSubclasses().stream().map(ps ->\n+                                map(ps.asSymbol())).toList()));\n+            case RuntimeVisibleAnnotationsAttribute aa ->\n+                clb.with(RuntimeVisibleAnnotationsAttribute.of(\n+                        mapAnnotations(aa.annotations())));\n+            case RuntimeInvisibleAnnotationsAttribute aa ->\n+                clb.with(RuntimeInvisibleAnnotationsAttribute.of(\n+                        mapAnnotations(aa.annotations())));\n+            case RuntimeVisibleTypeAnnotationsAttribute aa ->\n+                clb.with(RuntimeVisibleTypeAnnotationsAttribute.of(\n+                        mapTypeAnnotations(aa.annotations())));\n+            case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n+                clb.with(RuntimeInvisibleTypeAnnotationsAttribute.of(\n+                        mapTypeAnnotations(aa.annotations())));\n+            default ->\n+                clb.with(cle);\n+        }\n+    }\n+\n+    @Override\n+    public FieldTransform asFieldTransform() {\n+        return (FieldBuilder fb, FieldElement fe) -> {\n+            switch (fe) {\n+                case SignatureAttribute sa ->\n+                    fb.with(SignatureAttribute.of(\n+                            mapSignature(sa.asTypeSignature())));\n+                case RuntimeVisibleAnnotationsAttribute aa ->\n+                    fb.with(RuntimeVisibleAnnotationsAttribute.of(\n+                            mapAnnotations(aa.annotations())));\n+                case RuntimeInvisibleAnnotationsAttribute aa ->\n+                    fb.with(RuntimeInvisibleAnnotationsAttribute.of(\n+                            mapAnnotations(aa.annotations())));\n+                case RuntimeVisibleTypeAnnotationsAttribute aa ->\n+                    fb.with(RuntimeVisibleTypeAnnotationsAttribute.of(\n+                            mapTypeAnnotations(aa.annotations())));\n+                case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n+                    fb.with(RuntimeInvisibleTypeAnnotationsAttribute.of(\n+                            mapTypeAnnotations(aa.annotations())));\n+                default ->\n+                    fb.with(fe);\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public MethodTransform asMethodTransform() {\n+        return (MethodBuilder mb, MethodElement me) -> {\n+            switch (me) {\n+                case AnnotationDefaultAttribute ada ->\n+                    mb.with(AnnotationDefaultAttribute.of(\n+                            mapAnnotationValue(ada.defaultValue())));\n+                case CodeModel com ->\n+                    mb.transformCode(com, asCodeTransform());\n+                case ExceptionsAttribute ea ->\n+                    mb.with(ExceptionsAttribute.ofSymbols(\n+                            ea.exceptions().stream().map(ce ->\n+                                    map(ce.asSymbol())).toList()));\n+                case SignatureAttribute sa ->\n+                    mb.with(SignatureAttribute.of(\n+                            mapMethodSignature(sa.asMethodSignature())));\n+                case RuntimeVisibleAnnotationsAttribute aa ->\n+                    mb.with(RuntimeVisibleAnnotationsAttribute.of(\n+                            mapAnnotations(aa.annotations())));\n+                case RuntimeInvisibleAnnotationsAttribute aa ->\n+                    mb.with(RuntimeInvisibleAnnotationsAttribute.of(\n+                            mapAnnotations(aa.annotations())));\n+                case RuntimeVisibleParameterAnnotationsAttribute paa ->\n+                    mb.with(RuntimeVisibleParameterAnnotationsAttribute.of(\n+                            paa.parameterAnnotations().stream()\n+                                    .map(this::mapAnnotations).toList()));\n+                case RuntimeInvisibleParameterAnnotationsAttribute paa ->\n+                    mb.with(RuntimeInvisibleParameterAnnotationsAttribute.of(\n+                            paa.parameterAnnotations().stream()\n+                                    .map(this::mapAnnotations).toList()));\n+                case RuntimeVisibleTypeAnnotationsAttribute aa ->\n+                    mb.with(RuntimeVisibleTypeAnnotationsAttribute.of(\n+                            mapTypeAnnotations(aa.annotations())));\n+                case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n+                    mb.with(RuntimeInvisibleTypeAnnotationsAttribute.of(\n+                            mapTypeAnnotations(aa.annotations())));\n+                default ->\n+                    mb.with(me);\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public CodeTransform asCodeTransform() {\n+        return (CodeBuilder cob, CodeElement coe) -> {\n+            switch (coe) {\n+                case FieldInstruction fai ->\n+                    cob.fieldInstruction(fai.opcode(), map(fai.owner().asSymbol()),\n+                            fai.name().stringValue(), map(fai.typeSymbol()));\n+                case InvokeInstruction ii ->\n+                    cob.invokeInstruction(ii.opcode(), map(ii.owner().asSymbol()),\n+                            ii.name().stringValue(), mapMethodDesc(ii.typeSymbol()),\n+                            ii.isInterface());\n+                case InvokeDynamicInstruction idi ->\n+                    cob.invokeDynamicInstruction(DynamicCallSiteDesc.of(\n+                            idi.bootstrapMethod(), idi.name().stringValue(),\n+                            mapMethodDesc(idi.typeSymbol()),\n+                            idi.bootstrapArgs().stream().map(this::mapConstantValue).toArray(ConstantDesc[]::new)));\n+                case NewObjectInstruction c ->\n+                    cob.newObjectInstruction(map(c.className().asSymbol()));\n+                case NewReferenceArrayInstruction c ->\n+                    cob.anewarray(map(c.componentType().asSymbol()));\n+                case NewMultiArrayInstruction c ->\n+                    cob.multianewarray(map(c.arrayType().asSymbol()), c.dimensions());\n+                case TypeCheckInstruction c ->\n+                    cob.typeCheckInstruction(c.opcode(), map(c.type().asSymbol()));\n+                case ExceptionCatch c ->\n+                    cob.exceptionCatch(c.tryStart(), c.tryEnd(), c.handler(),c.catchType()\n+                            .map(d -> TemporaryConstantPool.INSTANCE.classEntry(map(d.asSymbol()))));\n+                case LocalVariable c ->\n+                    cob.localVariable(c.slot(), c.name().stringValue(), map(c.typeSymbol()),\n+                            c.startScope(), c.endScope());\n+                case LocalVariableType c ->\n+                    cob.localVariableType(c.slot(), c.name().stringValue(),\n+                            mapSignature(c.signatureSymbol()), c.startScope(), c.endScope());\n+                case LoadConstantInstruction ldc ->\n+                    cob.constantInstruction(ldc.opcode(),\n+                            mapConstantValue(ldc.constantValue()));\n+                case RuntimeVisibleTypeAnnotationsAttribute aa ->\n+                    cob.with(RuntimeVisibleTypeAnnotationsAttribute.of(\n+                            mapTypeAnnotations(aa.annotations())));\n+                case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n+                    cob.with(RuntimeInvisibleTypeAnnotationsAttribute.of(\n+                            mapTypeAnnotations(aa.annotations())));\n+                default ->\n+                    cob.with(coe);\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public ClassDesc map(ClassDesc desc) {\n+        if (desc == null) return null;\n+        if (desc.isArray()) return map(desc.componentType()).arrayType();\n+        if (desc.isPrimitive()) return desc;\n+        return mapFunction.apply(desc);\n+    }\n+\n+    MethodTypeDesc mapMethodDesc(MethodTypeDesc desc) {\n+        return MethodTypeDesc.of(map(desc.returnType()),\n+                desc.parameterList().stream().map(this::map).toArray(ClassDesc[]::new));\n+    }\n+\n+    ClassSignature mapClassSignature(ClassSignature signature) {\n+        return ClassSignature.of(mapTypeParams(signature.typeParameters()),\n+                mapSignature(signature.superclassSignature()),\n+                signature.superinterfaceSignatures().stream()\n+                        .map(this::mapSignature).toArray(Signature.RefTypeSig[]::new));\n+    }\n+\n+    MethodSignature mapMethodSignature(MethodSignature signature) {\n+        return MethodSignature.of(mapTypeParams(signature.typeParameters()),\n+                signature.throwableSignatures().stream().map(this::mapSignature).toList(),\n+                mapSignature(signature.result()),\n+                signature.arguments().stream()\n+                        .map(this::mapSignature).toArray(Signature[]::new));\n+    }\n+\n+    RecordComponentInfo mapRecordComponent(RecordComponentInfo component) {\n+        return RecordComponentInfo.of(component.name().stringValue(),\n+                map(component.descriptorSymbol()),\n+                component.attributes().stream().map(atr ->\n+                    switch (atr) {\n+                        case SignatureAttribute sa ->\n+                            SignatureAttribute.of(\n+                                    mapSignature(sa.asTypeSignature()));\n+                        case RuntimeVisibleAnnotationsAttribute aa ->\n+                            RuntimeVisibleAnnotationsAttribute.of(\n+                                    mapAnnotations(aa.annotations()));\n+                        case RuntimeInvisibleAnnotationsAttribute aa ->\n+                            RuntimeInvisibleAnnotationsAttribute.of(\n+                                    mapAnnotations(aa.annotations()));\n+                        case RuntimeVisibleTypeAnnotationsAttribute aa ->\n+                            RuntimeVisibleTypeAnnotationsAttribute.of(\n+                                    mapTypeAnnotations(aa.annotations()));\n+                        case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n+                            RuntimeInvisibleTypeAnnotationsAttribute.of(\n+                                    mapTypeAnnotations(aa.annotations()));\n+                        default -> atr;\n+                    }).toList());\n+    }\n+\n+    DirectMethodHandleDesc mapDirectMethodHandle(DirectMethodHandleDesc dmhd) {\n+        return switch (dmhd.kind()) {\n+            case GETTER, SETTER, STATIC_GETTER, STATIC_SETTER ->\n+                MethodHandleDesc.ofField(dmhd.kind(), map(dmhd.owner()),\n+                        dmhd.methodName(),\n+                        map(ClassDesc.ofDescriptor(dmhd.lookupDescriptor())));\n+            default ->\n+                MethodHandleDesc.ofMethod(dmhd.kind(), map(dmhd.owner()),\n+                        dmhd.methodName(),\n+                        mapMethodDesc(MethodTypeDesc.ofDescriptor(dmhd.lookupDescriptor())));\n+        };\n+    }\n+\n+    ConstantDesc mapConstantValue(ConstantDesc value) {\n+        return switch (value) {\n+            case ClassDesc cd ->\n+                map(cd);\n+            case DynamicConstantDesc<?> dcd ->\n+                mapDynamicConstant(dcd);\n+            case DirectMethodHandleDesc dmhd ->\n+                mapDirectMethodHandle(dmhd);\n+            case MethodTypeDesc mtd ->\n+                mapMethodDesc(mtd);\n+            default -> value;\n+        };\n+    }\n+\n+    DynamicConstantDesc<?> mapDynamicConstant(DynamicConstantDesc<?> dcd) {\n+        return DynamicConstantDesc.ofNamed(mapDirectMethodHandle(dcd.bootstrapMethod()),\n+                dcd.constantName(),\n+                map(dcd.constantType()),\n+                dcd.bootstrapArgsList().stream().map(this::mapConstantValue).toArray(ConstantDesc[]::new));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    <S extends Signature> S mapSignature(S signature) {\n+        return (S) switch (signature) {\n+            case Signature.ArrayTypeSig ats ->\n+                Signature.ArrayTypeSig.of(mapSignature(ats.componentSignature()));\n+            case Signature.ClassTypeSig cts ->\n+                Signature.ClassTypeSig.of(\n+                        cts.outerType().map(this::mapSignature).orElse(null),\n+                        map(cts.classDesc()),\n+                        cts.typeArgs().stream()\n+                                .map(ta -> Signature.TypeArg.of(\n+                                        ta.wildcardIndicator(),\n+                                        ta.boundType().map(this::mapSignature)))\n+                                .toArray(Signature.TypeArg[]::new));\n+            default -> signature;\n+        };\n+    }\n+\n+    List<Annotation> mapAnnotations(List<Annotation> annotations) {\n+        return annotations.stream().map(this::mapAnnotation).toList();\n+    }\n+\n+    Annotation mapAnnotation(Annotation a) {\n+        return Annotation.of(map(a.classSymbol()), a.elements().stream().map(el ->\n+                AnnotationElement.of(el.name(), mapAnnotationValue(el.value()))).toList());\n+    }\n+\n+    AnnotationValue mapAnnotationValue(AnnotationValue val) {\n+        return switch (val) {\n+            case AnnotationValue.OfAnnotation oa ->\n+                AnnotationValue.ofAnnotation(mapAnnotation(oa.annotation()));\n+            case AnnotationValue.OfArray oa ->\n+                AnnotationValue.ofArray(oa.values().stream().map(this::mapAnnotationValue).toList());\n+            case AnnotationValue.OfConstant oc -> oc;\n+            case AnnotationValue.OfClass oc ->\n+                AnnotationValue.ofClass(map(oc.classSymbol()));\n+            case AnnotationValue.OfEnum oe ->\n+                AnnotationValue.ofEnum(map(oe.classSymbol()), oe.constantName().stringValue());\n+        };\n+    }\n+\n+    List<TypeAnnotation> mapTypeAnnotations(List<TypeAnnotation> typeAnnotations) {\n+        return typeAnnotations.stream().map(a -> TypeAnnotation.of(a.targetInfo(),\n+                a.targetPath(), map(a.classSymbol()),\n+                a.elements().stream().map(el -> AnnotationElement.of(el.name(),\n+                        mapAnnotationValue(el.value()))).toList())).toList();\n+    }\n+\n+    List<Signature.TypeParam> mapTypeParams(List<Signature.TypeParam> typeParams) {\n+        return typeParams.stream().map(tp -> Signature.TypeParam.of(tp.identifier(),\n+                tp.classBound().map(this::mapSignature),\n+                tp.interfaceBounds().stream()\n+                        .map(this::mapSignature).toArray(Signature.RefTypeSig[]::new))).toList();\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":416,"deletions":0,"binary":false,"changes":416,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.Signature;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.components.CodeLocalsShifter;\n+import jdk.internal.classfile.instruction.IncrementInstruction;\n+import jdk.internal.classfile.instruction.LoadInstruction;\n+import jdk.internal.classfile.instruction.LocalVariable;\n+import jdk.internal.classfile.instruction.LocalVariableType;\n+import jdk.internal.classfile.instruction.StoreInstruction;\n+\n+import java.util.Arrays;\n+\n+public final class CodeLocalsShifterImpl implements CodeLocalsShifter {\n+\n+    private int[] locals = new int[0];\n+    private final int fixed;\n+\n+    public CodeLocalsShifterImpl(int fixed) {\n+        this.fixed = fixed;\n+    }\n+\n+    @Override\n+    public void accept(CodeBuilder cob, CodeElement coe) {\n+        switch (coe) {\n+            case LoadInstruction li ->\n+                cob.loadInstruction(\n+                        li.typeKind(),\n+                        shift(cob, li.slot(), li.typeKind()));\n+            case StoreInstruction si ->\n+                cob.storeInstruction(\n+                        si.typeKind(),\n+                        shift(cob, si.slot(), si.typeKind()));\n+            case IncrementInstruction ii ->\n+                cob.incrementInstruction(\n+                        shift(cob, ii.slot(), TypeKind.IntType),\n+                        ii.constant());\n+            case LocalVariable lv ->\n+                cob.localVariable(\n+                        shift(cob, lv.slot(), TypeKind.fromDescriptor(lv.type().stringValue())),\n+                        lv.name(),\n+                        lv.type(),\n+                        lv.startScope(),\n+                        lv.endScope());\n+            case LocalVariableType lvt ->\n+                cob.localVariableType(\n+                        shift(cob, lvt.slot(),\n+                                (lvt.signatureSymbol() instanceof Signature.BaseTypeSig bsig)\n+                                        ? TypeKind.fromDescriptor(bsig.signatureString())\n+                                        : TypeKind.ReferenceType),\n+                        lvt.name(),\n+                        lvt.signature(),\n+                        lvt.startScope(),\n+                        lvt.endScope());\n+            default -> cob.with(coe);\n+        }\n+    }\n+\n+    private int shift(CodeBuilder cob, int slot, TypeKind tk) {\n+        if (tk == TypeKind.VoidType)  throw new IllegalArgumentException(\"Illegal local void type\");\n+        if (slot >= fixed) {\n+            int key = 2*slot - fixed + tk.slotSize() - 1;\n+            if (key >= locals.length) locals = Arrays.copyOf(locals, key + 20);\n+            slot = locals[key] - 1;\n+            if (slot < 0) {\n+                slot = cob.allocateLocal(tk);\n+                locals[key] = slot + 1;\n+                if (tk.slotSize() == 2) locals[key - 1] = slot + 1;\n+            }\n+        }\n+        return slot;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeLocalsShifterImpl.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.components.CodeRelabeler;\n+import jdk.internal.classfile.instruction.BranchInstruction;\n+import jdk.internal.classfile.instruction.CharacterRange;\n+import jdk.internal.classfile.instruction.ExceptionCatch;\n+import jdk.internal.classfile.instruction.LabelTarget;\n+import jdk.internal.classfile.instruction.LocalVariable;\n+import jdk.internal.classfile.instruction.LocalVariableType;\n+import jdk.internal.classfile.instruction.LookupSwitchInstruction;\n+import jdk.internal.classfile.instruction.SwitchCase;\n+import jdk.internal.classfile.instruction.TableSwitchInstruction;\n+\n+import java.util.function.BiFunction;\n+\n+public record CodeRelabelerImpl(BiFunction<Label, CodeBuilder, Label> mapFunction) implements CodeRelabeler {\n+\n+    @Override\n+    public Label relabel(Label label, CodeBuilder cob) {\n+        return mapFunction.apply(label, cob);\n+    }\n+\n+    @Override\n+    public void accept(CodeBuilder cob, CodeElement coe) {\n+        switch (coe) {\n+            case BranchInstruction bi ->\n+                cob.branchInstruction(\n+                        bi.opcode(),\n+                        relabel(bi.target(), cob));\n+            case LookupSwitchInstruction lsi ->\n+                cob.lookupSwitchInstruction(\n+                        relabel(lsi.defaultTarget(), cob),\n+                        lsi.cases().stream().map(c ->\n+                                SwitchCase.of(\n+                                        c.caseValue(),\n+                                        relabel(c.target(), cob))).toList());\n+            case TableSwitchInstruction tsi ->\n+                cob.tableSwitchInstruction(\n+                        tsi.lowValue(),\n+                        tsi.highValue(),\n+                        relabel(tsi.defaultTarget(), cob),\n+                        tsi.cases().stream().map(c ->\n+                                SwitchCase.of(\n+                                        c.caseValue(),\n+                                        relabel(c.target(), cob))).toList());\n+            case LabelTarget lt ->\n+                cob.labelBinding(\n+                        relabel(lt.label(), cob));\n+            case ExceptionCatch ec ->\n+                cob.exceptionCatch(\n+                        relabel(ec.tryStart(), cob),\n+                        relabel(ec.tryEnd(), cob),\n+                        relabel(ec.handler(), cob),\n+                        ec.catchType());\n+            case LocalVariable lv ->\n+                cob.localVariable(\n+                        lv.slot(),\n+                        lv.name().stringValue(),\n+                        lv.typeSymbol(),\n+                        relabel(lv.startScope(), cob),\n+                        relabel(lv.endScope(), cob));\n+            case LocalVariableType lvt ->\n+                cob.localVariableType(\n+                        lvt.slot(),\n+                        lvt.name().stringValue(),\n+                        lvt.signatureSymbol(),\n+                        relabel(lvt.startScope(), cob),\n+                        relabel(lvt.endScope(), cob));\n+            case CharacterRange chr ->\n+                cob.characterRange(\n+                        relabel(chr.startScope(), cob),\n+                        relabel(chr.endScope(), cob),\n+                        chr.characterRangeStart(),\n+                        chr.characterRangeEnd(),\n+                        chr.flags());\n+            default ->\n+                cob.with(coe);\n+        }\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeRelabelerImpl.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,344 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.components.CodeStackTracker;\n+import jdk.internal.classfile.instruction.ArrayLoadInstruction;\n+import jdk.internal.classfile.instruction.ArrayStoreInstruction;\n+import jdk.internal.classfile.instruction.BranchInstruction;\n+import jdk.internal.classfile.instruction.ConstantInstruction;\n+import jdk.internal.classfile.instruction.ConvertInstruction;\n+import jdk.internal.classfile.instruction.ExceptionCatch;\n+import jdk.internal.classfile.instruction.FieldInstruction;\n+import jdk.internal.classfile.instruction.InvokeDynamicInstruction;\n+import jdk.internal.classfile.instruction.InvokeInstruction;\n+import jdk.internal.classfile.instruction.LabelTarget;\n+import jdk.internal.classfile.instruction.LoadInstruction;\n+import jdk.internal.classfile.instruction.LookupSwitchInstruction;\n+import jdk.internal.classfile.instruction.MonitorInstruction;\n+import jdk.internal.classfile.instruction.NewMultiArrayInstruction;\n+import jdk.internal.classfile.instruction.NewObjectInstruction;\n+import jdk.internal.classfile.instruction.NewPrimitiveArrayInstruction;\n+import jdk.internal.classfile.instruction.NewReferenceArrayInstruction;\n+import jdk.internal.classfile.instruction.NopInstruction;\n+import jdk.internal.classfile.instruction.OperatorInstruction;\n+import jdk.internal.classfile.instruction.ReturnInstruction;\n+import jdk.internal.classfile.instruction.StackInstruction;\n+import jdk.internal.classfile.instruction.StoreInstruction;\n+import jdk.internal.classfile.instruction.TableSwitchInstruction;\n+import jdk.internal.classfile.instruction.ThrowInstruction;\n+import jdk.internal.classfile.instruction.TypeCheckInstruction;\n+\n+import java.util.AbstractCollection;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+public final class CodeStackTrackerImpl implements CodeStackTracker {\n+\n+    private static record Item(TypeKind type, Item next) {\n+    }\n+\n+    private final class Stack extends AbstractCollection<TypeKind> {\n+\n+        private Item top;\n+        private int count, realSize;\n+\n+        Stack(Item top, int count, int realSize) {\n+            this.top = top;\n+            this.count = count;\n+            this.realSize = realSize;\n+        }\n+\n+        @Override\n+        public Iterator<TypeKind> iterator() {\n+            return new Iterator<TypeKind>() {\n+                Item i = top;\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return i != null;\n+                }\n+\n+                @Override\n+                public TypeKind next() {\n+                    if (i == null) {\n+                        throw new NoSuchElementException();\n+                    }\n+                    var t = i.type;\n+                    i = i.next;\n+                    return t;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public int size() {\n+            return count;\n+        }\n+\n+        private void push(TypeKind type) {\n+            top = new Item(type, top);\n+            realSize += type.slotSize();\n+            count++;\n+            if (maxSize != null && realSize > maxSize) maxSize = realSize;\n+        }\n+\n+        private TypeKind pop() {\n+            var t = top.type;\n+            realSize -= t.slotSize();\n+            count--;\n+            top = top.next;\n+            return t;\n+        }\n+    }\n+\n+    private Stack stack = new Stack(null, 0, 0);\n+    private Integer maxSize = 0;\n+\n+    public CodeStackTrackerImpl(TypeKind... initialStack) {\n+        for (int i = initialStack.length - 1; i >= 0; i--)\n+            push(initialStack[i]);\n+    }\n+\n+    @Override\n+    public Optional<Collection<TypeKind>> stack() {\n+        return Optional.ofNullable(fork());\n+    }\n+\n+    @Override\n+    public Optional<Integer> maxStackSize() {\n+        return Optional.ofNullable(maxSize);\n+    }\n+\n+    private final Map<Label, Stack> map = new HashMap<>();\n+\n+    private void push(TypeKind type) {\n+        if (stack != null) {\n+            if (type != TypeKind.VoidType) stack.push(type);\n+        } else {\n+            maxSize = null;\n+        }\n+    }\n+\n+    private void pop(int i) {\n+        if (stack != null) {\n+            while (i-- > 0) stack.pop();\n+        } else {\n+            maxSize = null;\n+        }\n+    }\n+\n+    private Stack fork() {\n+        return stack == null ? null : new Stack(stack.top, stack.count, stack.realSize);\n+    }\n+\n+    private void withStack(Consumer<Stack> c) {\n+        if (stack != null) c.accept(stack);\n+        else maxSize = null;\n+    }\n+\n+    @Override\n+    public void accept(CodeBuilder cb, CodeElement el) {\n+        cb.with(el);\n+        switch (el) {\n+            case ArrayLoadInstruction i -> {\n+                pop(2);push(i.typeKind());\n+            }\n+            case ArrayStoreInstruction i ->\n+                pop(3);\n+            case BranchInstruction i -> {\n+                if (i.opcode() == Opcode.GOTO || i.opcode() == Opcode.GOTO_W) {\n+                    map.put(i.target(), stack);\n+                    stack = null;\n+                } else {\n+                    pop(1);\n+                    map.put(i.target(), fork());\n+                }\n+            }\n+            case ConstantInstruction i ->\n+                push(i.typeKind());\n+            case ConvertInstruction i -> {\n+                pop(1);push(i.toType());\n+            }\n+            case FieldInstruction i -> {\n+                switch (i.opcode()) {\n+                    case GETSTATIC ->\n+                        push(TypeKind.fromDescriptor(i.type().stringValue()));\n+                    case GETFIELD -> {\n+                        pop(1);push(TypeKind.fromDescriptor(i.type().stringValue()));\n+                    }\n+                    case PUTSTATIC ->\n+                        pop(1);\n+                    case PUTFIELD ->\n+                        pop(2);\n+                }\n+            }\n+            case InvokeDynamicInstruction i -> {\n+                var type = i.typeSymbol();\n+                pop(type.parameterCount());\n+                push(TypeKind.from(type.returnType()));\n+            }\n+            case InvokeInstruction i -> {\n+                var type = i.typeSymbol();\n+                pop(type.parameterCount());\n+                if (i.opcode() != Opcode.INVOKESTATIC) pop(1);\n+                push(TypeKind.from(type.returnType()));\n+            }\n+            case LoadInstruction i ->\n+                push(i.typeKind());\n+            case StoreInstruction i ->\n+                pop(1);\n+            case LookupSwitchInstruction i -> {\n+                map.put(i.defaultTarget(), stack);\n+                for (var c : i.cases()) map.put(c.target(), fork());\n+                stack = null;\n+            }\n+            case MonitorInstruction i ->\n+                pop(1);\n+            case NewMultiArrayInstruction i -> {\n+                pop(i.dimensions());push(TypeKind.ReferenceType);\n+            }\n+            case NewObjectInstruction i ->\n+                push(TypeKind.ReferenceType);\n+            case NewPrimitiveArrayInstruction i -> {\n+                pop(1);push(TypeKind.ReferenceType);\n+            }\n+            case NewReferenceArrayInstruction i -> {\n+                pop(1);push(TypeKind.ReferenceType);\n+            }\n+            case NopInstruction i -> {}\n+            case OperatorInstruction i -> {\n+                switch (i.opcode()) {\n+                    case ARRAYLENGTH, INEG, LNEG, FNEG, DNEG -> pop(1);\n+                    default -> pop(2);\n+                }\n+                push(i.typeKind());\n+            }\n+            case ReturnInstruction i ->\n+                stack = null;\n+            case StackInstruction i -> {\n+                switch (i.opcode()) {\n+                    case POP -> pop(1);\n+                    case POP2 -> withStack(s -> {\n+                        if (s.pop().slotSize() == 1) s.pop();\n+                    });\n+                    case DUP ->  withStack(s -> {\n+                        var v = s.pop();s.push(v);s.push(v);\n+                    });\n+                    case DUP2 -> withStack(s -> {\n+                        var v1 = s.pop();\n+                        if (v1.slotSize() == 1) {\n+                            var v2 = s.pop();\n+                            s.push(v2);s.push(v1);\n+                            s.push(v2);s.push(v1);\n+                        } else {\n+                            s.push(v1);s.push(v1);\n+                        }\n+                    });\n+                    case DUP_X1 -> withStack(s -> {\n+                        var v1 = s.pop();\n+                        var v2 = s.pop();\n+                        s.push(v1);s.push(v2);s.push(v1);\n+                    });\n+                    case DUP_X2 -> withStack(s -> {\n+                        var v1 = s.pop();\n+                        var v2 = s.pop();\n+                        if (v2.slotSize() == 1) {\n+                            var v3 = s.pop();\n+                            s.push(v1);s.push(v3);s.push(v2);s.push(v1);\n+                        } else {\n+                            s.push(v1);s.push(v2);s.push(v1);\n+                        }\n+                    });\n+                    case DUP2_X1 -> withStack(s -> {\n+                        var v1 = s.pop();\n+                        var v2 = s.pop();\n+                        if (v1.slotSize() == 1) {\n+                            var v3 = s.pop();\n+                            s.push(v2);s.push(v1);s.push(v3);s.push(v2);s.push(v1);\n+                        } else {\n+                            s.push(v1);s.push(v2);s.push(v1);\n+                        }\n+                    });\n+                    case DUP2_X2 -> withStack(s -> {\n+                        var v1 = s.pop();\n+                        var v2 = s.pop();\n+                        if (v1.slotSize() == 1) {\n+                            var v3 = s.pop();\n+                            if (v3.slotSize() == 1) {\n+                                var v4 = s.pop();\n+                                s.push(v2);s.push(v1);s.push(v4);s.push(v3);s.push(v2);s.push(v1);\n+                            } else {\n+                                s.push(v2);s.push(v1);s.push(v3);s.push(v2);s.push(v1);\n+                            }\n+                        } else {\n+                            if (v2.slotSize() == 1) {\n+                                var v3 = s.pop();\n+                                s.push(v1);s.push(v3);s.push(v2);s.push(v1);\n+                            } else {\n+                                s.push(v1);s.push(v2);s.push(v1);\n+                            }\n+                        }\n+                    });\n+                    case SWAP -> withStack(s -> {\n+                        var v1 = s.pop();\n+                        var v2 = s.pop();\n+                        s.push(v1);s.push(v2);\n+                    });\n+                }\n+            }\n+            case TableSwitchInstruction i -> {\n+                map.put(i.defaultTarget(), stack);\n+                for (var c : i.cases()) map.put(c.target(), fork());\n+                stack = null;\n+            }\n+            case ThrowInstruction i ->\n+                stack = null;\n+            case TypeCheckInstruction i -> {\n+                switch (i.opcode()) {\n+                    case CHECKCAST -> {\n+                        pop(1);push(TypeKind.ReferenceType);\n+                    }\n+                    case INSTANCEOF -> {\n+                        pop(1);push(TypeKind.IntType);\n+                    }\n+                }\n+            }\n+            case ExceptionCatch i ->\n+                map.put(i.handler(), new Stack(new Item(TypeKind.ReferenceType, null), 1, 1));\n+            case LabelTarget i ->\n+                stack = map.getOrDefault(i.label(), stack);\n+            default -> {}\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeStackTrackerImpl.java","additions":344,"deletions":0,"binary":false,"changes":344,"status":"added"}]}