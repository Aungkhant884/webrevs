{"files":[{"patch":"@@ -344,1 +344,1 @@\n-  do_intrinsic(_arraySort,                java_util_Arrays,       arraySort_name, arraySort_signature,           F_S)   \\\n+  do_intrinsic(_arraySort,                java_util_DualPivotQuicksort,       arraySort_name, arraySort_signature, F_S) \\\n@@ -346,1 +346,1 @@\n-   do_signature(arraySort_signature,                             \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JIII)V\")          \\\n+   do_signature(arraySort_signature,          \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JIII)V\")                             \\\n@@ -348,3 +348,3 @@\n-  do_intrinsic(_arrayPartition, java_util_Arrays, arrayPartition_name, arrayPartition_signature, F_S)                   \\\n-   do_name(arrayPartition_name, \"arrayPartition\")                                                                       \\\n-  do_signature(arrayPartition_signature, \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JII[IJZ)V\")                               \\\n+  do_intrinsic(_arrayPartition, java_util_DualPivotQuicksort, arrayPartition_name, arrayPartition_signature, F_S)       \\\n+   do_name(     arrayPartition_name,                             \"arrayPartition\")                                      \\\n+  do_signature(arrayPartition_signature,      \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JII[IJZ)V\")                          \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -146,0 +146,1 @@\n+  template(java_util_DualPivotQuicksort,              \"java\/util\/DualPivotQuicksort\")             \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -82,45 +81,0 @@\n-    \/**\n-     * Sorts the specified array into ascending numerical order.\n-     * While the intrinsic is free to choose its own sorting algorithm, the\n-     * fallback implementation uses either mixed insertion sort or simple\n-     * insertion sort.\n-     *\n-     * @param elemType the class of the elements of the array to be sorted\n-     * @param array the array to be sorted\n-     * @param offset the relative offset, in bytes, from the base address of\n-     * the array to sort, otherwise if the array is {@code null},an absolute\n-     * address pointing to the first element to sort from.\n-     * @param fromIndex the index of the first element, inclusive, to be sorted\n-     * @param toIndex the index of the last element, exclusive, to be sorted\n-     * @param end the index of the last element for simple insertion sort (in\n-     * the case of mixed insertion sort). In the fallback implementation,\n-     * if end < 0, we use insertion sort else we use mixed insertion sort.\n-     *\/\n-    @IntrinsicCandidate\n-    static void arraySort(Class<?> elemType, Object array, long offset, int fromIndex, int toIndex, int end) {\n-        DualPivotQuicksort.smallArraySort(array, fromIndex, toIndex, end);\n-    }\n-\n-    \/**\n-     * Partitions the specified array based on the pivot(s) provided.\n-     *\n-     * @param elemType the class of the array to be sorted\n-     * @param array the array to be sorted\n-     * @param offset the relative offset, in bytes, from the base address of\n-     * the array to partition, otherwise if the array is {@code null},an absolute\n-     * address pointing to the first element to partition from.\n-     * @param fromIndex the index of the first element, inclusive, to be sorted\n-     * @param toIndex the index of the last element, exclusive, to be sorted\n-     * @param pivotIndices the array containing the indices of the pivots. After\n-     * partitioning, this array is updated with the new indices of the pivots.\n-     * @param pivot_offset the offset in bytes pointing to the base address of\n-     * the array used to store the indices of the pivots.\n-     * @param isDualPivot a boolean value to choose between dual pivot\n-     * partitioning and single pivot partitioning\n-     *\/\n-    @IntrinsicCandidate\n-    static void arrayPartition(Class<?> elemType, Object array, long offset, int fromIndex, int toIndex, int[] pivotIndices, long pivot_offset, boolean isDualPivot) {\n-        if (isDualPivot) DualPivotQuicksort.partitionDualPivot(array, fromIndex, toIndex, pivotIndices);\n-        else DualPivotQuicksort.partitionSinglePivot(array, fromIndex, toIndex, pivotIndices);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/Arrays.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n@@ -131,0 +132,46 @@\n+    \/**\n+     * Sorts the specified array into ascending numerical order.\n+     * While the intrinsic is free to choose its own sorting algorithm, the\n+     * fallback implementation uses either mixed insertion sort or simple\n+     * insertion sort.\n+     *\n+     * @param elemType the class of the elements of the array to be sorted\n+     * @param array the array to be sorted\n+     * @param offset the relative offset, in bytes, from the base address of\n+     * the array to sort, otherwise if the array is {@code null},an absolute\n+     * address pointing to the first element to sort from.\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @param end the index of the last element for simple insertion sort (in\n+     * the case of mixed insertion sort). In the fallback implementation,\n+     * if end < 0, we use insertion sort else we use mixed insertion sort.\n+     *\/\n+    @IntrinsicCandidate\n+    static void arraySort(Class<?> elemType, Object array, long offset, int low, int high, int end) {\n+       if (end < 0) insertionSort(array, low, high);\n+       else mixedInsertionSort(array, low, end, high);\n+    }\n+\n+    \/**\n+     * Partitions the specified array based on the pivot(s) provided.\n+     *\n+     * @param elemType the class of the array to be sorted\n+     * @param array the array to be sorted\n+     * @param offset the relative offset, in bytes, from the base address of\n+     * the array to partition, otherwise if the array is {@code null},an absolute\n+     * address pointing to the first element to partition from.\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @param pivotIndices the array containing the indices of the pivots. After\n+     * partitioning, this array is updated with the new indices of the pivots.\n+     * @param pivot_offset the offset in bytes pointing to the base address of\n+     * the array used to store the indices of the pivots.\n+     * @param isDualPivot a boolean value to choose between dual pivot\n+     * partitioning and single pivot partitioning\n+     *\/\n+    @IntrinsicCandidate\n+    static void arrayPartition(Class<?> elemType, Object array, long offset, int low, int high, int[] pivotIndices, long pivot_offset, boolean isDualPivot) {\n+        if (isDualPivot) partitionDualPivot(array, low, high, pivotIndices);\n+        else partitionSinglePivot(array, low, high, pivotIndices);\n+    }\n+\n@@ -148,17 +195,0 @@\n-    \/**\n-     * Sorts the specified range of the array using either insertion sort\n-     * or mixed insertion sort depending on the value of end. if end < 0,\n-     * we use insertion sort else we use mixed insertion sort.\n-     *\n-     * @param array the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     * @param end the index of the last element for simple insertion sort (in\n-     * the case of mixed insertion sort). If end < 0, we use insertion sort\n-     * else we use mixed insertion sort.\n-     *\/\n-    static void smallArraySort(Object array, int low, int high, int end) {\n-       if (end < 0) insertionSort(array, low, high);\n-       else mixedInsertionSort(array, low, end, high);\n-    }\n-\n@@ -292,1 +322,1 @@\n-                else Arrays.arraySort(int.class, a, baseOffset, low, high, last);\n+                else arraySort(int.class, a, baseOffset, low, high, last);\n@@ -301,1 +331,1 @@\n-                else Arrays.arraySort(int.class, a, baseOffset, low, high, -1);\n+                else arraySort(int.class, a, baseOffset, low, high, -1);\n@@ -389,1 +419,1 @@\n-                Arrays.arrayPartition(int.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n+                arrayPartition(int.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n@@ -414,1 +444,1 @@\n-                Arrays.arrayPartition(int.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n+                arrayPartition(int.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n@@ -1105,1 +1135,1 @@\n-                else Arrays.arraySort(long.class, a, baseOffset, low, high, last);\n+                else arraySort(long.class, a, baseOffset, low, high, last);\n@@ -1114,1 +1144,1 @@\n-                else Arrays.arraySort(long.class, a, baseOffset, low, high, -1);\n+                else arraySort(long.class, a, baseOffset, low, high, -1);\n@@ -1203,1 +1233,1 @@\n-                Arrays.arrayPartition(long.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n+                arrayPartition(long.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n@@ -1225,1 +1255,1 @@\n-                Arrays.arrayPartition(long.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n+                arrayPartition(long.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n@@ -2701,1 +2731,1 @@\n-                else Arrays.arraySort(float.class, a, baseOffset, low, high, last);\n+                else arraySort(float.class, a, baseOffset, low, high, last);\n@@ -2710,1 +2740,1 @@\n-                else Arrays.arraySort(float.class, a, baseOffset, low, high, -1);\n+                else arraySort(float.class, a, baseOffset, low, high, -1);\n@@ -2799,1 +2829,1 @@\n-                Arrays.arrayPartition(float.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n+                arrayPartition(float.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n@@ -2821,1 +2851,1 @@\n-                Arrays.arrayPartition(float.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n+                arrayPartition(float.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n@@ -3562,1 +3592,1 @@\n-                else Arrays.arraySort(double.class, a, baseOffset, low, high, last);\n+                else arraySort(double.class, a, baseOffset, low, high, last);\n@@ -3571,1 +3601,1 @@\n-                else Arrays.arraySort(double.class, a, baseOffset, low, high, -1);\n+                else arraySort(double.class, a, baseOffset, low, high, -1);\n@@ -3660,1 +3690,1 @@\n-                Arrays.arrayPartition(double.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n+                arrayPartition(double.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n@@ -3682,1 +3712,1 @@\n-                Arrays.arrayPartition(double.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n+                arrayPartition(double.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":63,"deletions":33,"binary":false,"changes":96,"status":"modified"}]}