{"files":[{"patch":"@@ -395,22 +395,0 @@\n-template <typename vtype, typename type_t>\n-X86_SIMD_SORT_INLINE type_t get_pivot_32bit(type_t *arr, const int64_t left,\n-                                            const int64_t right) {\n-    \/\/ median of 16\n-    int64_t size = (right - left) \/ 16;\n-    using zmm_t = typename vtype::zmm_t;\n-    using ymm_t = typename vtype::ymm_t;\n-    __m512i rand_index1 = _mm512_set_epi64(\n-        left + size, left + 2 * size, left + 3 * size, left + 4 * size,\n-        left + 5 * size, left + 6 * size, left + 7 * size, left + 8 * size);\n-    __m512i rand_index2 = _mm512_set_epi64(\n-        left + 9 * size, left + 10 * size, left + 11 * size, left + 12 * size,\n-        left + 13 * size, left + 14 * size, left + 15 * size, left + 16 * size);\n-    ymm_t rand_vec1 =\n-        vtype::template i64gather<sizeof(type_t)>(rand_index1, arr);\n-    ymm_t rand_vec2 =\n-        vtype::template i64gather<sizeof(type_t)>(rand_index2, arr);\n-    zmm_t rand_vec = vtype::merge(rand_vec1, rand_vec2);\n-    zmm_t sort = sort_zmm_32bit<vtype>(rand_vec);\n-    \/\/ pivot will never be a nan, since there are no nan's!\n-    return ((type_t *)&sort)[8];\n-}\n@@ -436,1 +414,1 @@\n-    type_t pivot = get_pivot_32bit<vtype>(arr, left, right);\n+    type_t pivot = get_pivot_scalar<type_t>(arr, left, right);\n","filename":"src\/java.base\/linux\/native\/libx86_64\/avx512-32bit-qsort.hpp","additions":1,"deletions":23,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -213,14 +213,0 @@\n-template <typename vtype, typename type_t>\n-X86_SIMD_SORT_INLINE type_t get_pivot_64bit(type_t *arr, const int64_t left,\n-                                            const int64_t right) {\n-    \/\/ median of 8\n-    int64_t size = (right - left) \/ 8;\n-    using zmm_t = typename vtype::zmm_t;\n-    __m512i rand_index = _mm512_set_epi64(\n-        left + size, left + 2 * size, left + 3 * size, left + 4 * size,\n-        left + 5 * size, left + 6 * size, left + 7 * size, left + 8 * size);\n-    zmm_t rand_vec = vtype::template i64gather<sizeof(type_t)>(rand_index, arr);\n-    \/\/ pivot will never be a nan, since there are no nan's!\n-    zmm_t sort = sort_zmm_64bit<vtype>(rand_vec);\n-    return ((type_t *)&sort)[4];\n-}\n","filename":"src\/java.base\/linux\/native\/libx86_64\/avx512-64bit-common.h","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -745,1 +745,1 @@\n-    type_t pivot = get_pivot_64bit<vtype>(arr, left, right);\n+    type_t pivot = get_pivot_scalar<type_t>(arr, left, right);\n","filename":"src\/java.base\/linux\/native\/libx86_64\/avx512-64bit-qsort.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -135,4 +135,0 @@\n-\/*\n- * Sort all the NAN's to end of the array and return the index of the last elem\n- * in the array which is not a nan\n- *\/\n@@ -140,14 +136,9 @@\n-int64_t move_nans_to_end_of_array(T *arr, int64_t arrsize) {\n-    int64_t jj = arrsize - 1;\n-    int64_t ii = 0;\n-    int64_t count = 0;\n-    while (ii <= jj) {\n-        if (is_a_nan(arr[ii])) {\n-            std::swap(arr[ii], arr[jj]);\n-            jj -= 1;\n-            count++;\n-        } else {\n-            ii += 1;\n-        }\n-    }\n-    return arrsize - count - 1;\n+X86_SIMD_SORT_INLINE T get_pivot_scalar(T *arr, const int64_t left, const int64_t right) {\n+    \/\/ median of 8 equally spaced elements\n+    int64_t NUM_ELEMENTS = 8;\n+    int64_t MID = NUM_ELEMENTS \/ 2;\n+    int64_t size = (right - left) \/ NUM_ELEMENTS;\n+    T temp[NUM_ELEMENTS];\n+    for (int64_t i = 0; i < NUM_ELEMENTS; i++) temp[i] = arr[left + (i * size)];\n+    std::sort(temp, temp + NUM_ELEMENTS);\n+    return temp[MID];\n","filename":"src\/java.base\/linux\/native\/libx86_64\/avx512-common-qsort.h","additions":9,"deletions":18,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,0 +126,5 @@\n+    \/**\n+     * Min array size to call fast small array sort.\n+     *\/\n+    private static final int MIN_FAST_SMALL_ARRAY_SORT_SIZE = 16;\n+\n@@ -285,1 +290,3 @@\n-                Arrays.arraySort(int.class, a, baseOffset, low, high, high - 3 * ((size >> 5) << 3));\n+                int last  = high - 3 * ((size >> 5) << 3);\n+                if (size < MIN_FAST_SMALL_ARRAY_SORT_SIZE) mixedInsertionSort(a, low, last , high);\n+                else Arrays.arraySort(int.class, a, baseOffset, low, high, last);\n@@ -293,1 +300,2 @@\n-                Arrays.arraySort(int.class, a, baseOffset, low, high, -1);\n+                if (size < MIN_FAST_SMALL_ARRAY_SORT_SIZE) insertionSort(a, low, high);\n+                else Arrays.arraySort(int.class, a, baseOffset, low, high, -1);\n@@ -1095,1 +1103,3 @@\n-                Arrays.arraySort(long.class, a, baseOffset, low, high, high - 3 * ((size >> 5) << 3));\n+                int last  = high - 3 * ((size >> 5) << 3);\n+                if (size < MIN_FAST_SMALL_ARRAY_SORT_SIZE) mixedInsertionSort(a, low, last , high);\n+                else Arrays.arraySort(long.class, a, baseOffset, low, high, last);\n@@ -1103,1 +1113,2 @@\n-                Arrays.arraySort(long.class, a, baseOffset, low, high, -1);\n+                if (size < MIN_FAST_SMALL_ARRAY_SORT_SIZE) insertionSort(a, low, high);\n+                else Arrays.arraySort(long.class, a, baseOffset, low, high, -1);\n@@ -2688,1 +2699,3 @@\n-                Arrays.arraySort(float.class, a, baseOffset, low, high, high - 3 * ((size >> 5) << 3));\n+                int last  = high - 3 * ((size >> 5) << 3);\n+                if (size < MIN_FAST_SMALL_ARRAY_SORT_SIZE) mixedInsertionSort(a, low, last , high);\n+                else Arrays.arraySort(float.class, a, baseOffset, low, high, last);\n@@ -2696,1 +2709,2 @@\n-                Arrays.arraySort(float.class, a, baseOffset, low, high, -1);\n+                if (size < MIN_FAST_SMALL_ARRAY_SORT_SIZE) insertionSort(a, low, high);\n+                else Arrays.arraySort(float.class, a, baseOffset, low, high, -1);\n@@ -3546,1 +3560,3 @@\n-                Arrays.arraySort(double.class, a, baseOffset, low, high, high - 3 * ((size >> 5) << 3));\n+                int last  = high - 3 * ((size >> 5) << 3);\n+                if (size < MIN_FAST_SMALL_ARRAY_SORT_SIZE) mixedInsertionSort(a, low, last , high);\n+                else Arrays.arraySort(double.class, a, baseOffset, low, high, last);\n@@ -3554,1 +3570,2 @@\n-                Arrays.arraySort(double.class, a, baseOffset, low, high, -1);\n+                if (size < MIN_FAST_SMALL_ARRAY_SORT_SIZE) insertionSort(a, low, high);\n+                else Arrays.arraySort(double.class, a, baseOffset, low, high, -1);\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":26,"deletions":9,"binary":false,"changes":35,"status":"modified"}]}