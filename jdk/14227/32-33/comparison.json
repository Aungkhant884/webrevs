{"files":[{"patch":"@@ -241,2 +241,2 @@\n-    $(eval $(call SetupJdkLibrary, BUILD_LIB_X86_64_SORT, \\\n-        NAME := x86_64_sort, \\\n+    $(eval $(call SetupJdkLibrary, BUILD_LIB_SIMD_SORT, \\\n+        NAME := simdsort, \\\n@@ -253,1 +253,1 @@\n-    TARGETS += $(BUILD_LIB_X86_64_SORT)\n+    TARGETS += $(BUILD_LIB_SIMD_SORT)\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4185,5 +4185,5 @@\n-      void *libx86_64_sort = nullptr;\n-      char ebuf_x86_64[1024];\n-      char dll_name_avx512_sort[JVM_MAXPATHLEN];\n-      if (os::dll_locate_lib(dll_name_avx512_sort, sizeof(dll_name_avx512_sort), Arguments::get_dll_dir(), \"x86_64_sort\")) {\n-        libx86_64_sort = os::dll_load(dll_name_avx512_sort, ebuf_x86_64, sizeof ebuf_x86_64);\n+      void *libsimdsort = nullptr;\n+      char ebuf_[1024];\n+      char dll_name_simd_sort[JVM_MAXPATHLEN];\n+      if (os::dll_locate_lib(dll_name_simd_sort, sizeof(dll_name_simd_sort), Arguments::get_dll_dir(), \"simdsort\")) {\n+        libsimdsort = os::dll_load(dll_name_simd_sort, ebuf_, sizeof ebuf_);\n@@ -4192,2 +4192,2 @@\n-    if (libx86_64_sort != nullptr) {\n-      log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, JNI_LIB_PREFIX \"x86_64\" JNI_LIB_SUFFIX, p2i(libx86_64_sort));\n+    if (libsimdsort != nullptr) {\n+      log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, JNI_LIB_PREFIX \"x86_64\" JNI_LIB_SUFFIX, p2i(libsimdsort));\n@@ -4195,2 +4195,2 @@\n-      snprintf(ebuf_x86_64, sizeof(ebuf_x86_64), \"avx512_sort_int\");\n-      StubRoutines::_arraysort_int = (address)os::dll_lookup(libx86_64_sort, ebuf_x86_64);\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_sort_int\");\n+      StubRoutines::_arraysort_int = (address)os::dll_lookup(libsimdsort, ebuf_);\n@@ -4198,2 +4198,2 @@\n-      snprintf(ebuf_x86_64, sizeof(ebuf_x86_64), \"avx512_sort_long\");\n-      StubRoutines::_arraysort_long = (address)os::dll_lookup(libx86_64_sort, ebuf_x86_64);\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_sort_long\");\n+      StubRoutines::_arraysort_long = (address)os::dll_lookup(libsimdsort, ebuf_);\n@@ -4201,2 +4201,2 @@\n-      snprintf(ebuf_x86_64, sizeof(ebuf_x86_64), \"avx512_sort_float\");\n-      StubRoutines::_arraysort_float = (address)os::dll_lookup(libx86_64_sort, ebuf_x86_64);\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_sort_float\");\n+      StubRoutines::_arraysort_float = (address)os::dll_lookup(libsimdsort, ebuf_);\n@@ -4204,2 +4204,2 @@\n-      snprintf(ebuf_x86_64, sizeof(ebuf_x86_64), \"avx512_sort_double\");\n-      StubRoutines::_arraysort_double = (address)os::dll_lookup(libx86_64_sort, ebuf_x86_64);\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_sort_double\");\n+      StubRoutines::_arraysort_double = (address)os::dll_lookup(libsimdsort, ebuf_);\n@@ -4207,2 +4207,2 @@\n-      snprintf(ebuf_x86_64, sizeof(ebuf_x86_64), \"avx512_partition_int\");\n-      StubRoutines::_array_partition_int = (address)os::dll_lookup(libx86_64_sort, ebuf_x86_64);\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_partition_single_int\");\n+      StubRoutines::_array_partition_single_int = (address)os::dll_lookup(libsimdsort, ebuf_);\n@@ -4210,2 +4210,2 @@\n-      snprintf(ebuf_x86_64, sizeof(ebuf_x86_64), \"avx512_partition_long\");\n-      StubRoutines::_array_partition_long = (address)os::dll_lookup(libx86_64_sort, ebuf_x86_64);\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_partition_dual_int\");\n+      StubRoutines::_array_partition_dual_int = (address)os::dll_lookup(libsimdsort, ebuf_);\n@@ -4213,2 +4213,2 @@\n-      snprintf(ebuf_x86_64, sizeof(ebuf_x86_64), \"avx512_partition_float\");\n-      StubRoutines::_array_partition_float = (address)os::dll_lookup(libx86_64_sort, ebuf_x86_64);\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_partition_single_long\");\n+      StubRoutines::_array_partition_single_long = (address)os::dll_lookup(libsimdsort, ebuf_);\n@@ -4216,2 +4216,14 @@\n-      snprintf(ebuf_x86_64, sizeof(ebuf_x86_64), \"avx512_partition_double\");\n-      StubRoutines::_array_partition_double = (address)os::dll_lookup(libx86_64_sort, ebuf_x86_64);\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_partition_dual_long\");\n+      StubRoutines::_array_partition_dual_long = (address)os::dll_lookup(libsimdsort, ebuf_);\n+\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_partition_single_float\");\n+      StubRoutines::_array_partition_single_float = (address)os::dll_lookup(libsimdsort, ebuf_);\n+\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_partition_dual_float\");\n+      StubRoutines::_array_partition_dual_float = (address)os::dll_lookup(libsimdsort, ebuf_);\n+\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_partition_single_double\");\n+      StubRoutines::_array_partition_single_double = (address)os::dll_lookup(libsimdsort, ebuf_);\n+\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_partition_dual_double\");\n+      StubRoutines::_array_partition_dual_double = (address)os::dll_lookup(libsimdsort, ebuf_);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":35,"deletions":23,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -344,3 +344,6 @@\n-  do_intrinsic(_arraySort,                java_util_DualPivotQuicksort,       arraySort_name, arraySort_signature, F_S) \\\n-   do_name(     arraySort_name,                                  \"arraySort\")                                           \\\n-   do_signature(arraySort_signature,          \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JIII)V\")                             \\\n+  do_intrinsic(_arraySortMI, java_util_DualPivotQuicksort, arraySortMI_name, arraySortMI_signature, F_S)                \\\n+   do_name(     arraySortMI_name,                                  \"mixedInsertionSort\")                                \\\n+   do_signature(arraySortMI_signature,          \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JIII)V\")                            \\\n+  do_intrinsic(_arraySortI, java_util_DualPivotQuicksort, arraySortI_name, arraySortI_signature, F_S)                   \\\n+   do_name(     arraySortI_name,                                   \"insertionSort\")                                     \\\n+   do_signature(arraySortI_signature,          \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JII)V\")                             \\\n@@ -348,3 +351,6 @@\n-  do_intrinsic(_arrayPartition, java_util_DualPivotQuicksort, arrayPartition_name, arrayPartition_signature, F_S)       \\\n-   do_name(     arrayPartition_name,                             \"arrayPartition\")                                      \\\n-  do_signature(arrayPartition_signature,      \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JII[IZ)V\")                           \\\n+  do_intrinsic(_arrayPartitionSP, java_util_DualPivotQuicksort, arrayPartitionSP_name, arrayPartitionSP_signature, F_S) \\\n+   do_name(     arrayPartitionSP_name,                             \"partitionSinglePivot\")                              \\\n+  do_signature(arrayPartitionSP_signature,      \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JIII)[I\")                          \\\n+  do_intrinsic(_arrayPartitionDP, java_util_DualPivotQuicksort, arrayPartitionDP_name, arrayPartitionDP_signature, F_S) \\\n+   do_name(     arrayPartitionDP_name,                             \"partitionDualPivot\")                                \\\n+  do_signature(arrayPartitionDP_signature,      \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JIIII)[I\")                         \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -391,2 +391,2 @@\n-        { { TypeFunc::Parms, ShenandoahStore }, { TypeFunc::Parms+3, ShenandoahStore }, { -1, ShenandoahNone },\n-          { -1, ShenandoahNone }, { -1, ShenandoahNone } },\n+        { { TypeFunc::Parms, ShenandoahStore }, { TypeFunc::Parms+3, ShenandoahStore },   { -1, ShenandoahNone },\n+          { -1, ShenandoahNone },                { -1, ShenandoahNone },                  { -1, ShenandoahNone } },\n@@ -394,1 +394,2 @@\n-        { { TypeFunc::Parms, ShenandoahStore }, { -1, ShenandoahNone }, { -1, ShenandoahNone } },\n+        { { TypeFunc::Parms, ShenandoahStore },  { -1, ShenandoahNone },                  { -1, ShenandoahNone },\n+          { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -334,4 +334,8 @@\n-  static_field(StubRoutines,                _array_partition_int,                             address)                               \\\n-  static_field(StubRoutines,                _array_partition_long,                            address)                               \\\n-  static_field(StubRoutines,                _array_partition_float,                           address)                               \\\n-  static_field(StubRoutines,                _array_partition_double,                          address)                               \\\n+  static_field(StubRoutines,                _array_partition_single_int,                      address)                               \\\n+  static_field(StubRoutines,                _array_partition_dual_int,                        address)                               \\\n+  static_field(StubRoutines,                _array_partition_single_long,                     address)                               \\\n+  static_field(StubRoutines,                _array_partition_dual_long,                       address)                               \\\n+  static_field(StubRoutines,                _array_partition_single_float,                    address)                               \\\n+  static_field(StubRoutines,                _array_partition_dual_float,                      address)                               \\\n+  static_field(StubRoutines,                _array_partition_single_double,                   address)                               \\\n+  static_field(StubRoutines,                _array_partition_dual_double,                     address)                               \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -600,2 +600,4 @@\n-  case vmIntrinsics::_arraySort:\n-  case vmIntrinsics::_arrayPartition:\n+  case vmIntrinsics::_arraySortMI:\n+  case vmIntrinsics::_arraySortI:\n+  case vmIntrinsics::_arrayPartitionSP:\n+  case vmIntrinsics::_arrayPartitionDP:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -296,2 +296,5 @@\n-  case vmIntrinsics::_arraySort:                return inline_arraysort();\n-  case vmIntrinsics::_arrayPartition:           return inline_array_partition();\n+  case vmIntrinsics::_arraySortMI:\n+  case vmIntrinsics::_arraySortI:               return inline_arraysort();\n+\n+  case vmIntrinsics::_arrayPartitionSP:         return inline_array_partition(false \/* single pivot*\/);\n+  case vmIntrinsics::_arrayPartitionDP:         return inline_array_partition(true \/* dual pivot*\/);\n@@ -5370,1 +5373,1 @@\n-bool LibraryCallKit::inline_array_partition() {\n+bool LibraryCallKit::inline_array_partition(bool is_dual_pivot) {\n@@ -5381,2 +5384,2 @@\n-  Node* pivot_indices   = argument(6);\n-  Node* isDualPivot     = argument(7);\n+  Node* indexPivot1     = argument(6);\n+  Node* indexPivot2     = is_dual_pivot? argument(7) : nullptr;\n@@ -5387,3 +5390,6 @@\n-  stubAddr = StubRoutines::select_array_partition_function(bt);\n-  if (stubAddr == nullptr) return false;\n-\n+  stubAddr = StubRoutines::select_array_partition_function(bt, is_dual_pivot);\n+  \/\/ stub not loaded\n+  if (stubAddr == nullptr) {\n+    return false;\n+  }\n+  \/\/ get the address of the array\n@@ -5396,9 +5402,11 @@\n-  pivot_indices = must_be_not_null(pivot_indices, true);\n-  const TypeAryPtr* pivot_indices_type = pivot_indices->Value(&_gvn)->isa_aryptr();\n-  if (pivot_indices_type == nullptr || pivot_indices_type->elem() == Type::BOTTOM ) {\n-    return false; \/\/ failed input validation\n-  }\n-  Node* pivot_indices_adr = array_element_address(pivot_indices, intcon(0), T_INT);\n-\n-  \/\/ Call the stub.\n-  make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::array_partition_Type(),\n+  \/\/ create the pivotIndices array of type int and size = 2\n+  Node* pivotIndices = nullptr;\n+  Node* size = intcon(2);\n+  Node* klass_node = makecon(TypeKlassPtr::make(ciTypeArrayKlass::make(T_INT)));\n+  pivotIndices = new_array(klass_node, size, 0);  \/\/ no arguments to push\n+  AllocateArrayNode* alloc = tightly_coupled_allocation(pivotIndices);\n+  guarantee(alloc != nullptr, \"created above\");\n+  Node* pivotIndices_adr = basic_plus_adr(pivotIndices, arrayOopDesc::base_offset_in_bytes(T_INT));\n+\n+  \/\/ Call the stub\n+  make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::array_partition_Type(is_dual_pivot),\n@@ -5406,1 +5414,5 @@\n-                    obj_adr, fromIndex, toIndex, pivot_indices_adr, isDualPivot);\n+                    obj_adr, fromIndex, toIndex, pivotIndices_adr, indexPivot1, indexPivot2);\n+\n+  if (!stopped()) {\n+    set_result(pivotIndices);\n+  }\n@@ -5429,1 +5441,4 @@\n-  if (stubAddr == nullptr) return false;\n+  \/\/stub not loaded\n+  if (stubAddr == nullptr) {\n+    return false;\n+  }\n@@ -5431,0 +5446,1 @@\n+  \/\/ get address of the array\n@@ -5436,0 +5452,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":36,"deletions":19,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -281,1 +281,1 @@\n-  bool inline_array_partition();\n+  bool inline_array_partition(bool is_dual_pivot);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -860,1 +860,1 @@\n-const TypeFunc* OptoRuntime::array_partition_Type() {\n+const TypeFunc* OptoRuntime::array_partition_Type(bool is_dual_pivot) {\n@@ -862,1 +862,1 @@\n-  int num_args = 5;\n+  int num_args = is_dual_pivot ? 6 : 5;\n@@ -866,5 +866,8 @@\n-  fields[argp++] = TypePtr::NOTNULL;    \/\/ array\n-  fields[argp++] = TypeInt::INT;    \/\/ low\n-  fields[argp++] = TypeInt::INT;    \/\/ end\n-  fields[argp++] = TypePtr::NOTNULL;    \/\/ pivot_indices (int array)\n-  fields[argp++] = TypeInt::BOOL;       \/\/ isDualPivot\n+  fields[argp++] = TypePtr::NOTNULL;  \/\/ array\n+  fields[argp++] = TypeInt::INT;      \/\/ low\n+  fields[argp++] = TypeInt::INT;      \/\/ end\n+  fields[argp++] = TypePtr::NOTNULL;  \/\/ pivot_indices (int array)\n+  fields[argp++] = TypeInt::INT;      \/\/ indexPivot1\n+  if (is_dual_pivot) {\n+    fields[argp++] = TypeInt::INT;    \/\/ indexPivot2\n+  }\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -272,1 +272,1 @@\n-  static const TypeFunc* array_partition_Type();\n+  static const TypeFunc* array_partition_Type(bool is_dual_pivot);\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -183,4 +183,8 @@\n-address StubRoutines::_array_partition_int  = nullptr;\n-address StubRoutines::_array_partition_long = nullptr;\n-address StubRoutines::_array_partition_float = nullptr;\n-address StubRoutines::_array_partition_double = nullptr;\n+address StubRoutines::_array_partition_single_int  = nullptr;\n+address StubRoutines::_array_partition_dual_int  = nullptr;\n+address StubRoutines::_array_partition_single_long = nullptr;\n+address StubRoutines::_array_partition_dual_long = nullptr;\n+address StubRoutines::_array_partition_single_float = nullptr;\n+address StubRoutines::_array_partition_dual_float = nullptr;\n+address StubRoutines::_array_partition_single_double = nullptr;\n+address StubRoutines::_array_partition_dual_double = nullptr;\n@@ -556,1 +560,1 @@\n-address StubRoutines::select_array_partition_function(BasicType t) {\n+address StubRoutines::select_array_partition_function(BasicType t, bool is_dual_pivot) {\n@@ -558,4 +562,4 @@\n-    case T_INT:    return _array_partition_int;\n-    case T_LONG:   return _array_partition_long;\n-    case T_FLOAT:  return _array_partition_float;\n-    case T_DOUBLE: return _array_partition_double;\n+    case T_INT:    return is_dual_pivot ? _array_partition_dual_int : _array_partition_single_int;\n+    case T_LONG:   return is_dual_pivot ? _array_partition_dual_long : _array_partition_single_long;\n+    case T_FLOAT:  return is_dual_pivot ? _array_partition_dual_float : _array_partition_single_float;\n+    case T_DOUBLE: return is_dual_pivot ? _array_partition_dual_double : _array_partition_single_double;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -160,4 +160,8 @@\n-  static address _array_partition_int;\n-  static address _array_partition_long;\n-  static address _array_partition_float;\n-  static address _array_partition_double;\n+  static address _array_partition_single_int;\n+  static address _array_partition_dual_int;\n+  static address _array_partition_single_long;\n+  static address _array_partition_dual_long;\n+  static address _array_partition_single_float;\n+  static address _array_partition_dual_float;\n+  static address _array_partition_single_double;\n+  static address _array_partition_dual_double;\n@@ -387,1 +391,1 @@\n-  static address select_array_partition_function(BasicType t);\n+  static address select_array_partition_function(BasicType t, bool is_dual_pivot);\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -426,1 +426,1 @@\n-inline void avx512_qsort<int32_t>(int32_t *arr, int64_t fromIndex, int64_t toIndex) {\n+void inline avx512_qsort<int32_t>(int32_t *arr, int64_t fromIndex, int64_t toIndex) {\n@@ -435,1 +435,1 @@\n-inline void avx512_qsort<float>(float *arr, int64_t fromIndex, int64_t toIndex) {\n+void inline avx512_qsort<float>(float *arr, int64_t fromIndex, int64_t toIndex) {\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avx512-32bit-qsort.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/java.base\/linux\/native\/libx86_64_sort\/avx512-32bit-qsort.hpp","status":"renamed"},{"patch":"","filename":"src\/java.base\/linux\/native\/libsimdsort\/avx512-64bit-common.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/java.base\/linux\/native\/libx86_64_sort\/avx512-64bit-common.h","status":"renamed"},{"patch":"@@ -757,1 +757,1 @@\n-inline void avx512_qsort<int64_t>(int64_t *arr, int64_t fromIndex, int64_t toIndex) {\n+void inline avx512_qsort<int64_t>(int64_t *arr, int64_t fromIndex, int64_t toIndex) {\n@@ -766,1 +766,1 @@\n-inline void avx512_qsort<double>(double *arr, int64_t fromIndex, int64_t toIndex) {\n+void inline avx512_qsort<double>(double *arr, int64_t fromIndex, int64_t toIndex) {\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avx512-64bit-qsort.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/java.base\/linux\/native\/libx86_64_sort\/avx512-64bit-qsort.hpp","status":"renamed"},{"patch":"@@ -374,1 +374,1 @@\n-\/\/ right = to_index (exclusive)\n+\/\/ to_index (exclusive)\n@@ -376,1 +376,1 @@\n-static int64_t vectorized_partition(type_t *arr, int64_t left, int64_t right, type_t pivot, bool use_gt) {\n+static int64_t vectorized_partition(type_t *arr, int64_t from_index, int64_t to_index, type_t pivot, bool use_gt) {\n@@ -380,1 +380,1 @@\n-            arr, left, right, pivot, &smallest, &biggest, use_gt);\n+            arr, from_index, to_index, pivot, &smallest, &biggest, use_gt);\n@@ -386,5 +386,3 @@\n-void avx512_dual_pivot_partition(T *arr, int64_t from_index, int64_t to_index, int32_t *pivot_indices){\n-    const int64_t pidx1 = pivot_indices[0];\n-    const int64_t pidx2 = pivot_indices[1];\n-    const T pivot1 = arr[pidx1];\n-    const T pivot2 = arr[pidx2];\n+void avx512_dual_pivot_partition(T *arr, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int64_t index_pivot1, int64_t index_pivot2){\n+    const T pivot1 = arr[index_pivot1];\n+    const T pivot2 = arr[index_pivot2];\n@@ -398,2 +396,2 @@\n-    std::swap(arr[pidx1], arr[low]);\n-    std::swap(arr[pidx2], arr[end]);\n+    std::swap(arr[index_pivot1], arr[low]);\n+    std::swap(arr[index_pivot2], arr[end]);\n@@ -406,0 +404,7 @@\n+    \/\/ if all other elements are greater than pivot2 (and pivot1), no need to do further partitioning\n+    if (upper == start) {\n+        pivot_indices[0] = low;\n+        pivot_indices[1] = upper;\n+        return;\n+    }\n+\n@@ -415,3 +420,2 @@\n-void avx512_single_pivot_partition(T *arr, int64_t from_index, int64_t to_index, int32_t *pivot_indices){\n-    const int64_t pidx = pivot_indices[0];\n-    const T pivot = arr[pidx];\n+void avx512_single_pivot_partition(T *arr, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int64_t index_pivot){\n+    const T pivot = arr[index_pivot];\n@@ -421,1 +425,0 @@\n-    \/\/const int64_t start = low + 1;\n@@ -436,1 +439,1 @@\n-inline void avx512_partition(T *arr, int64_t from_index, int64_t to_index, int32_t *pivot_indices, bool is_dual_pviot) {\n+void inline avx512_partition(T *arr, int64_t from_index, int64_t to_index, int32_t *pivot_indices, bool is_dual_pviot) {\n@@ -441,0 +444,26 @@\n+template <typename T>\n+void inline insertion_sort(T *arr, int32_t from_index, int32_t to_index) {\n+    for (int i, k = from_index; ++k < to_index; ) {\n+        T ai = arr[i = k];\n+\n+        if (ai < arr[i - 1]) {\n+            while (--i >= from_index && ai < arr[i]) {\n+                arr[i + 1] = arr[i];\n+            }\n+            arr[i + 1] = ai;\n+        }\n+    }\n+}\n+\n+template <typename T>\n+void inline avx512_fastsort(T *arr, int64_t from_index, int64_t to_index, const int32_t INS_SORT_THRESHOLD) {\n+    int32_t size = to_index - from_index;\n+\n+    if (size <= INS_SORT_THRESHOLD) {\n+        insertion_sort<T>(arr, from_index, to_index);\n+    }\n+    else {\n+        avx512_qsort<T>(arr, from_index, to_index);\n+    }\n+}\n+\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avx512-common-qsort.h","additions":44,"deletions":15,"binary":false,"changes":59,"previous_filename":"src\/java.base\/linux\/native\/libx86_64_sort\/avx512-common-qsort.h","status":"renamed"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2023 Intel Corporation. All rights reserved.\n+ * Intel x86-simd-sort source code.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#pragma GCC target(\"avx512dq\", \"avx512f\")\n+#include \"avx512-32bit-qsort.hpp\"\n+#include \"avx512-64bit-qsort.hpp\"\n+\n+#define DLL_PUBLIC __attribute__((visibility(\"default\")))\n+#define INSERTION_SORT_THRESHOLD_32BIT 16\n+#define INSERTION_SORT_THRESHOLD_64BIT 20\n+\n+extern \"C\" {\n+\n+    DLL_PUBLIC void avx512_sort_int(int32_t *array, int64_t from_index, int64_t to_index) {\n+        avx512_fastsort<int32_t>(array, from_index, to_index, INSERTION_SORT_THRESHOLD_32BIT);\n+    }\n+\n+    DLL_PUBLIC void avx512_sort_long(int64_t *array, int64_t from_index, int64_t to_index) {\n+        avx512_fastsort<int64_t>(array, from_index, to_index, INSERTION_SORT_THRESHOLD_64BIT);\n+    }\n+\n+    DLL_PUBLIC void avx512_sort_float(float *array, int64_t from_index, int64_t to_index) {\n+        avx512_fastsort<float>(array, from_index, to_index, INSERTION_SORT_THRESHOLD_32BIT);\n+    }\n+\n+    DLL_PUBLIC void avx512_sort_double(double *array, int64_t from_index, int64_t to_index) {\n+        avx512_fastsort<double>(array, from_index, to_index, INSERTION_SORT_THRESHOLD_64BIT);\n+    }\n+\n+    DLL_PUBLIC void avx512_partition_single_int(int32_t *array, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int32_t index_pivot) {\n+        avx512_single_pivot_partition<int32_t>(array, from_index, to_index, pivot_indices, index_pivot);\n+    }\n+\n+    DLL_PUBLIC void avx512_partition_dual_int(int32_t *array, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int32_t index_pivot1, int32_t index_pivot2) {\n+        avx512_dual_pivot_partition<int32_t>(array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n+    }\n+\n+    DLL_PUBLIC void avx512_partition_single_long(int64_t *array, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int32_t index_pivot) {\n+        avx512_single_pivot_partition<int64_t>(array, from_index, to_index, pivot_indices, index_pivot);\n+    }\n+\n+    DLL_PUBLIC void avx512_partition_dual_long(int64_t *array, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int32_t index_pivot1, int32_t index_pivot2) {\n+        avx512_dual_pivot_partition<int64_t>(array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n+    }\n+\n+    DLL_PUBLIC void avx512_partition_single_float(float *array, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int32_t index_pivot) {\n+        avx512_single_pivot_partition<float>(array, from_index, to_index, pivot_indices, index_pivot);\n+    }\n+\n+    DLL_PUBLIC void avx512_partition_dual_float(float *array, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int32_t index_pivot1, int32_t index_pivot2) {\n+        avx512_dual_pivot_partition<float>(array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n+    }\n+\n+    DLL_PUBLIC void avx512_partition_single_double(double *array, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int32_t index_pivot) {\n+        avx512_single_pivot_partition<double>(array, from_index, to_index, pivot_indices, index_pivot);\n+    }\n+\n+    DLL_PUBLIC void avx512_partition_dual_double(double *array, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int32_t index_pivot1, int32_t index_pivot2) {\n+        avx512_dual_pivot_partition<double>(array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n+    }\n+\n+}\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avxsort_linux_x86.cpp","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2023 Intel Corporation. All rights reserved.\n- * Intel x86-simd-sort source code.\n- *\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#pragma GCC target(\"avx512dq\", \"avx512f\")\n-#include \"avx512-32bit-qsort.hpp\"\n-#include \"avx512-64bit-qsort.hpp\"\n-\n-#define DLL_PUBLIC __attribute__((visibility(\"default\")))\n-\n-extern \"C\" {\n-\n-    DLL_PUBLIC void avx512_sort_int(int32_t *array, int64_t from_index, int64_t to_index) {\n-        avx512_qsort<int32_t>(array, from_index, to_index);\n-    }\n-\n-    DLL_PUBLIC void avx512_sort_long(int64_t *array, int64_t from_index, int64_t to_index) {\n-        avx512_qsort<int64_t>(array, from_index, to_index);\n-    }\n-\n-    DLL_PUBLIC void avx512_sort_float(float *array, int64_t from_index, int64_t to_index) {\n-        avx512_qsort<float>(array, from_index, to_index);\n-    }\n-\n-    DLL_PUBLIC void avx512_sort_double(double *array, int64_t from_index, int64_t to_index) {\n-        avx512_qsort<double>(array, from_index, to_index);\n-    }\n-\n-    DLL_PUBLIC void avx512_partition_int(int32_t *array, int64_t from_index, int64_t to_index, int32_t *pivot_indices, bool is_dual_pivot) {\n-        avx512_partition<int32_t>(array, from_index, to_index, pivot_indices, is_dual_pivot);\n-    }\n-\n-    DLL_PUBLIC void avx512_partition_long(int64_t *array, int64_t from_index, int64_t to_index, int32_t *pivot_indices, bool is_dual_pivot) {\n-        avx512_partition<int64_t>(array, from_index, to_index, pivot_indices, is_dual_pivot);\n-    }\n-\n-    DLL_PUBLIC void avx512_partition_float(float *array, int64_t from_index, int64_t to_index, int32_t *pivot_indices, bool is_dual_pivot) {\n-        avx512_partition<float>(array, from_index, to_index, pivot_indices, is_dual_pivot);\n-    }\n-\n-    DLL_PUBLIC void avx512_partition_double(double *array, int64_t from_index, int64_t to_index, int32_t *pivot_indices, bool is_dual_pivot) {\n-        avx512_partition<double>(array, from_index, to_index, pivot_indices, is_dual_pivot);\n-    }\n-\n-}\n","filename":"src\/java.base\/linux\/native\/libx86_64_sort\/avxsort_linux_x86.cpp","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -129,9 +129,3 @@\n-     * Min array size to call fast small array sort.\n-     *\/\n-    private static final int MIN_FAST_SMALL_ARRAY_SORT_SIZE = 16;\n-\n-    \/**\n-     * Sorts the specified array into ascending numerical order.\n-     * While the intrinsic is free to choose its own sorting algorithm, the\n-     * fallback implementation uses either mixed insertion sort or simple\n-     * insertion sort.\n+     * Sorts the specified array into ascending numerical order using\n+     * mixed insertion sort.The intrinsic is free to choose its own\n+     * sorting algorithm.\n@@ -146,3 +140,1 @@\n-     * @param end the index of the last element for simple insertion sort (in\n-     * the case of mixed insertion sort). In the fallback implementation,\n-     * if end < 0, we use insertion sort else we use mixed insertion sort.\n+     * @param end the index of the last element for simple insertion sort\n@@ -151,4 +143,8 @@\n-    @ForceInline\n-    private static void arraySort(Class<?> elemType, Object array, long offset, int low, int high, int end) {\n-       if (end < 0) insertionSort(array, low, high);\n-       else mixedInsertionSort(array, low, end, high);\n+    private static void mixedInsertionSort(Class<?> elemType, Object array, long offset, int low, int high, int end) {\n+        switch (array) {\n+            case int[] arr -> mixedInsertionSort(arr, low, end, high);\n+            case long[] arr ->  mixedInsertionSort(arr, low, end, high);\n+            case float[] arr ->  mixedInsertionSort(arr, low, end, high);\n+            case double[] arr ->  mixedInsertionSort(arr, low, end, high);\n+            default -> throw new UnsupportedOperationException();\n+        }\n@@ -158,1 +154,3 @@\n-     * Partitions the specified array based on the pivot(s) provided.\n+     * Sorts the specified array into ascending numerical order using\n+     * insertion sort.The intrinsic is free to choose its own\n+     * sorting algorithm.\n@@ -160,1 +158,1 @@\n-     * @param elemType the class of the array to be sorted\n+     * @param elemType the class of the elements of the array to be sorted\n@@ -163,2 +161,2 @@\n-     * the array to partition, otherwise if the array is {@code null},an absolute\n-     * address pointing to the first element to partition from.\n+     * the array to sort, otherwise if the array is {@code null},an absolute\n+     * address pointing to the first element to sort from.\n@@ -167,4 +165,0 @@\n-     * @param pivotIndices the array containing the indices of the pivots. After\n-     * partitioning, this array is updated with the new indices of the pivots.\n-     * @param isDualPivot a boolean value to choose between dual pivot\n-     * partitioning and single pivot partitioning\n@@ -173,33 +167,2 @@\n-    @ForceInline\n-    private static void arrayPartition(Class<?> elemType, Object array, long offset, int low, int high, int[] pivotIndices, boolean isDualPivot) {\n-        if (isDualPivot) partitionDualPivot(array, low, high, pivotIndices);\n-        else partitionSinglePivot(array, low, high, pivotIndices);\n-    }\n-\n-    \/**\n-     * Calculates the double depth of parallel merging.\n-     * Depth is negative, if tasks split before sorting.\n-     *\n-     * @param parallelism the parallelism level\n-     * @param size the target size\n-     * @return the depth of parallel merging\n-     *\/\n-    private static int getDepth(int parallelism, int size) {\n-        int depth = 0;\n-\n-        while ((parallelism >>= 3) > 0 && (size >>= 2) > 0) {\n-            depth -= 2;\n-        }\n-        return depth;\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using insertion sort\n-     *\n-     * @param array the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\n-     *\/\n-    private static void insertionSort(Object array, int low, int high) {\n-        switch (array) {\n+    private static void insertionSort(Class<?> elemType, Object array, long offset, int low, int high) {\n+       switch (array) {\n@@ -215,1 +178,1 @@\n-     * Sorts the specified range of the array using mixed insertion sort.\n+     * Partitions the specified array based on the two pivots provided.\n@@ -217,0 +180,1 @@\n+     * @param elemType the class of the array to be sorted\n@@ -218,0 +182,3 @@\n+     * @param offset the relative offset, in bytes, from the base address of\n+     * the array to partition, otherwise if the array is {@code null},an absolute\n+     * address pointing to the first element to partition from.\n@@ -220,2 +187,2 @@\n-     * @param end the index of the last element for simple insertion sort\n-     *\n+     * @param indexPivot1 the index of pivot1, the first pivot\n+     * @param indexPivot2 the index of pivot2, the second pivot\n@@ -223,6 +190,8 @@\n-    private static void mixedInsertionSort(Object array, int low, int end, int high) {\n-        switch (array) {\n-            case int[] arr -> mixedInsertionSort(arr, low, end, high);\n-            case long[] arr ->  mixedInsertionSort(arr, low, end, high);\n-            case float[] arr ->  mixedInsertionSort(arr, low, end, high);\n-            case double[] arr ->  mixedInsertionSort(arr, low, end, high);\n+    @IntrinsicCandidate\n+    @ForceInline\n+    private static int[] partitionDualPivot(Class<?> elemType, Object array, long offset, int low, int high, int indexPivot1, int indexPivot2) {\n+        return switch(array) {\n+            case int[] arr -> partitionDualPivot(arr, low, high, indexPivot1, indexPivot2);\n+            case long[] arr -> partitionDualPivot(arr, low, high, indexPivot1, indexPivot2);\n+            case float[] arr -> partitionDualPivot(arr, low, high, indexPivot1, indexPivot2);\n+            case double[] arr -> partitionDualPivot(arr, low, high, indexPivot1, indexPivot2);\n@@ -230,1 +199,1 @@\n-        }\n+        };\n@@ -234,7 +203,1 @@\n-     * Partitions the specified range of the array using the two pivots specified.\n-     *\n-     * @param array the array to be partitioned\n-     * @param low the index of the first element, inclusive, for partitioning\n-     * @param high the index of the last element, exclusive, for partitioning\n-     * @param pivotIndices an array containing the indices of the two pivots to be used.\n-     * After partitioning, the indices of the pivots is updated as well.\n+     * Partitions the specified array based on the single pivot provided.\n@@ -242,0 +205,8 @@\n+     * @param elemType the class of the array to be sorted\n+     * @param array the array to be sorted\n+     * @param offset the relative offset, in bytes, from the base address of\n+     * the array to partition, otherwise if the array is {@code null},an absolute\n+     * address pointing to the first element to partition from.\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @param indexPivot the index of the pivot\n@@ -243,6 +214,8 @@\n-    private static void partitionDualPivot(Object array, int low, int high, int[] pivotIndices) {\n-        switch(array) {\n-            case int[] arr -> partitionDualPivot(arr, low, high, pivotIndices);\n-            case long[] arr -> partitionDualPivot(arr, low, high, pivotIndices);\n-            case float[] arr -> partitionDualPivot(arr, low, high, pivotIndices);\n-            case double[] arr -> partitionDualPivot(arr, low, high, pivotIndices);\n+    @IntrinsicCandidate\n+    @ForceInline\n+    private static int[] partitionSinglePivot(Class<?> elemType, Object array, long offset, int low, int high, int indexPivot) {\n+        return switch(array) {\n+            case int[] arr -> partitionSinglePivot(arr, low, high, indexPivot);\n+            case long[] arr -> partitionSinglePivot(arr, low, high, indexPivot);\n+            case float[] arr -> partitionSinglePivot(arr, low, high, indexPivot);\n+            case double[] arr -> partitionSinglePivot(arr, low, high, indexPivot);\n@@ -250,1 +223,1 @@\n-        }\n+        };\n@@ -254,7 +227,2 @@\n-     * Partitions the specified range of the array using a single pivot specified.\n-     *\n-     * @param array the array to be partitioned\n-     * @param low the index of the first element, inclusive, for partitioning\n-     * @param high the index of the last element, exclusive, for partitioning\n-     * @param pivotIndices an array containing the indices of the pivot to be used.\n-     * After partitioning, the indices of the pivots is updated as well.\n+     * Calculates the double depth of parallel merging.\n+     * Depth is negative, if tasks split before sorting.\n@@ -262,0 +230,3 @@\n+     * @param parallelism the parallelism level\n+     * @param size the target size\n+     * @return the depth of parallel merging\n@@ -263,7 +234,5 @@\n-    private static void partitionSinglePivot(Object array, int low, int high, int[] pivotIndices) {\n-        switch(array) {\n-            case int[] arr -> partitionSinglePivot(arr, low, high, pivotIndices);\n-            case long[] arr -> partitionSinglePivot(arr, low, high, pivotIndices);\n-            case float[] arr -> partitionSinglePivot(arr, low, high, pivotIndices);\n-            case double[] arr -> partitionSinglePivot(arr, low, high, pivotIndices);\n-            default -> throw new UnsupportedOperationException();\n+    private static int getDepth(int parallelism, int size) {\n+        int depth = 0;\n+\n+        while ((parallelism >>= 3) > 0 && (size >>= 2) > 0) {\n+            depth -= 2;\n@@ -271,0 +240,1 @@\n+        return depth;\n@@ -312,0 +282,1 @@\n+        int[] pivotIndices;\n@@ -314,3 +285,0 @@\n-            int[] pivotIndices;\n-            int baseOffset = Unsafe.ARRAY_INT_BASE_OFFSET;\n-\n@@ -321,3 +289,1 @@\n-                int last  = high - 3 * ((size >> 5) << 3);\n-                if (size < MIN_FAST_SMALL_ARRAY_SORT_SIZE) mixedInsertionSort(a, low, last , high);\n-                else arraySort(int.class, a, baseOffset, low, high, last);\n+                mixedInsertionSort(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, high - 3 * ((size >> 5) << 3));\n@@ -331,2 +297,1 @@\n-                if (size < MIN_FAST_SMALL_ARRAY_SORT_SIZE) insertionSort(a, low, high);\n-                else arraySort(int.class, a, baseOffset, low, high, -1);\n+                insertionSort(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high);\n@@ -412,2 +377,1 @@\n-            boolean isDualPivot = (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]);\n-            if (isDualPivot) {\n+            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n@@ -419,2 +383,1 @@\n-                pivotIndices = new int[] {e1, e5};\n-                arrayPartition(int.class, a, baseOffset, low, high, pivotIndices, isDualPivot);\n+                pivotIndices = partitionDualPivot(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, e1, e5);\n@@ -444,2 +407,1 @@\n-                pivotIndices = new int[] {e3, e3};\n-                arrayPartition(int.class, a, baseOffset, low, high, pivotIndices, isDualPivot);\n+                pivotIndices = partitionSinglePivot(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, e3);\n@@ -464,1 +426,1 @@\n-     * Partitions the specified range of the array using the two pivots specified.\n+     * Partitions the specified range of the array using the two pivots provided.\n@@ -469,2 +431,2 @@\n-     * @param pivotIndices an array containing the indices of the two pivots to be used.\n-     * After partitioning, this array the indices of the pivots is updated as well.\n+     * @param indexPivot1 the index of pivot1, the first pivot\n+     * @param indexPivot2 the index of pivot2, the second pivot\n@@ -473,1 +435,2 @@\n-    private static void partitionDualPivot(int[] a, int low, int high, int[] pivotIndices) {\n+    @ForceInline\n+    private static int[] partitionDualPivot(int[] a, int low, int high, int indexPivot1, int indexPivot2) {\n@@ -478,2 +441,2 @@\n-        int e1 = pivotIndices[0];\n-        int e5 = pivotIndices[1];\n+        int e1 = indexPivot1;\n+        int e5 = indexPivot2;\n@@ -546,2 +509,1 @@\n-        pivotIndices[0] = lower;\n-        pivotIndices[1] = upper;\n+        return new int[] {lower, upper};\n@@ -553,1 +515,1 @@\n-     * Partitions the specified range of the array using a single pivot specified.\n+     * Partitions the specified range of the array using a single pivot provided.\n@@ -558,2 +520,1 @@\n-     * @param pivotIndices an array containing the indices of the pivot to be used.\n-     * After partitioning, this array the indices of the pivots is updated as well.\n+     * @param indexPivot the index of the pivot\n@@ -562,1 +523,2 @@\n-    private static void partitionSinglePivot(int[] a, int low, int high, int[] pivotIndices) {\n+    @ForceInline\n+    private static int[] partitionSinglePivot(int[] a, int low, int high, int indexPivot) {\n@@ -566,3 +528,1 @@\n-\n-\n-        int e3 = pivotIndices[0];\n+        int e3 = indexPivot;\n@@ -622,2 +582,1 @@\n-        pivotIndices[0] = lower;\n-        pivotIndices[1] = upper;\n+        return new int[] {lower, upper};\n@@ -1125,0 +1084,1 @@\n+        int[] pivotIndices;\n@@ -1127,2 +1087,0 @@\n-            int[] pivotIndices;\n-            int baseOffset = Unsafe.ARRAY_LONG_BASE_OFFSET;\n@@ -1135,2 +1093,1 @@\n-                if (size < MIN_FAST_SMALL_ARRAY_SORT_SIZE) mixedInsertionSort(a, low, last , high);\n-                else arraySort(long.class, a, baseOffset, low, high, last);\n+                mixedInsertionSort(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, high - 3 * ((size >> 5) << 3));\n@@ -1144,2 +1101,1 @@\n-                if (size < MIN_FAST_SMALL_ARRAY_SORT_SIZE) insertionSort(a, low, high);\n-                else arraySort(long.class, a, baseOffset, low, high, -1);\n+                insertionSort(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high);\n@@ -1225,2 +1181,1 @@\n-            boolean isDualPivot = (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]);\n-            if(isDualPivot)  {\n+            if(a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n@@ -1233,2 +1188,1 @@\n-                pivotIndices = new int[] {e1, e5};\n-                arrayPartition(long.class, a, baseOffset, low, high, pivotIndices, isDualPivot);\n+                pivotIndices = partitionDualPivot(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, e1, e5);\n@@ -1255,2 +1209,1 @@\n-                pivotIndices = new int[] {e3, e3};\n-                arrayPartition(long.class, a, baseOffset, low, high, pivotIndices, isDualPivot);\n+                pivotIndices = partitionSinglePivot(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, e3);\n@@ -1275,1 +1228,1 @@\n-     * Partitions the specified range of the array using the two pivots specified.\n+     * Partitions the specified range of the array using the two pivots provided.\n@@ -1280,2 +1233,2 @@\n-     * @param pivotIndices an array containing the indices of the two pivots to be used.\n-     * After partitioning, this array the indices of the pivots is updated as well.\n+     * @param indexPivot1 the index of pivot1, the first pivot\n+     * @param indexPivot2 the index of pivot2, the second pivot\n@@ -1284,1 +1237,2 @@\n-    private static void partitionDualPivot(long[] a, int low, int high, int[] pivotIndices) {\n+    @ForceInline\n+    private static int[] partitionDualPivot(long[] a, int low, int high, int indexPivot1, int indexPivot2) {\n@@ -1289,2 +1243,2 @@\n-        int e1 = pivotIndices[0];\n-        int e5 = pivotIndices[1];\n+        int e1 = indexPivot1;\n+        int e5 = indexPivot2;\n@@ -1357,2 +1311,1 @@\n-        pivotIndices[0] = lower;\n-        pivotIndices[1] = upper;\n+        return new int[] {lower, upper};\n@@ -1363,1 +1316,1 @@\n-     * Partitions the specified range of the array using a single pivot specified.\n+     * Partitions the specified range of the array using a single pivot provided.\n@@ -1368,2 +1321,1 @@\n-     * @param pivotIndices an array containing the indices of the pivot to be used.\n-     * After partitioning, this array the indices of the pivots is updated as well.\n+     * @param indexPivot the index of the pivot\n@@ -1372,1 +1324,2 @@\n-    private static void partitionSinglePivot(long[] a, int low, int high, int[] pivotIndices) {\n+    @ForceInline\n+    private static int[] partitionSinglePivot(long[] a, int low, int high, int indexPivot) {\n@@ -1377,1 +1330,1 @@\n-        int e3 = pivotIndices[0];\n+        int e3 = indexPivot;\n@@ -1431,2 +1384,1 @@\n-        pivotIndices[0] = lower;\n-        pivotIndices[1] = upper;\n+        return new int[] {lower, upper};\n@@ -2721,0 +2673,1 @@\n+        int[] pivotIndices;\n@@ -2723,2 +2676,0 @@\n-            int[] pivotIndices;\n-            int baseOffset = Unsafe.ARRAY_FLOAT_BASE_OFFSET;\n@@ -2731,2 +2682,1 @@\n-                if (size < MIN_FAST_SMALL_ARRAY_SORT_SIZE) mixedInsertionSort(a, low, last , high);\n-                else arraySort(float.class, a, baseOffset, low, high, last);\n+                mixedInsertionSort(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, high - 3 * ((size >> 5) << 3));\n@@ -2740,2 +2690,1 @@\n-                if (size < MIN_FAST_SMALL_ARRAY_SORT_SIZE) insertionSort(a, low, high);\n-                else arraySort(float.class, a, baseOffset, low, high, -1);\n+                insertionSort(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high);\n@@ -2821,2 +2770,1 @@\n-            boolean isDualPivot = (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]);\n-            if(isDualPivot)  {\n+            if(a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n@@ -2829,2 +2777,1 @@\n-                pivotIndices = new int[] {e1, e5};\n-                arrayPartition(float.class, a, baseOffset, low, high, pivotIndices, isDualPivot);\n+                pivotIndices = partitionDualPivot(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, e1, e5);\n@@ -2851,2 +2798,1 @@\n-                pivotIndices = new int[] {e3, e3};\n-                arrayPartition(float.class, a, baseOffset, low, high, pivotIndices, isDualPivot);\n+                pivotIndices = partitionSinglePivot(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, e3);\n@@ -2871,1 +2817,1 @@\n-     * Partitions the specified range of the array using the two pivots specified.\n+     * Partitions the specified range of the array using the two pivots provided.\n@@ -2876,2 +2822,2 @@\n-     * @param pivotIndices an array containing the indices of the two pivots to be used.\n-     * After partitioning, this array the indices of the pivots is updated as well.\n+     * @param indexPivot1 the index of pivot1, the first pivot\n+     * @param indexPivot2 the index of pivot2, the second pivot\n@@ -2880,1 +2826,2 @@\n-    private static void partitionDualPivot(float[] a, int low, int high, int[] pivotIndices) {\n+    @ForceInline\n+    private static int[] partitionDualPivot(float[] a, int low, int high, int indexPivot1, int indexPivot2) {\n@@ -2885,2 +2832,2 @@\n-        int e1 = pivotIndices[0];\n-        int e5 = pivotIndices[1];\n+        int e1 = indexPivot1;\n+        int e5 = indexPivot2;\n@@ -2953,2 +2900,1 @@\n-        pivotIndices[0] = lower;\n-        pivotIndices[1] = upper;\n+        return new int[] {lower, upper};\n@@ -2959,1 +2905,1 @@\n-     * Partitions the specified range of the array using a single pivot specified.\n+     * Partitions the specified range of the array using a single pivot provided.\n@@ -2964,2 +2910,1 @@\n-     * @param pivotIndices an array containing the indices of the pivot to be used.\n-     * After partitioning, this array the indices of the pivots is updated as well.\n+     * @param indexPivot the index of the pivot\n@@ -2968,1 +2913,2 @@\n-    private static void partitionSinglePivot(float[] a, int low, int high, int[] pivotIndices) {\n+    @ForceInline\n+    private static int[] partitionSinglePivot(float[] a, int low, int high, int indexPivot) {\n@@ -2973,1 +2919,1 @@\n-        int e3 = pivotIndices[0];\n+        int e3 = indexPivot;\n@@ -3027,2 +2973,1 @@\n-        pivotIndices[0] = lower;\n-        pivotIndices[1] = upper;\n+        return new int[] {lower, upper};\n@@ -3582,0 +3527,1 @@\n+        int[] pivotIndices;\n@@ -3584,3 +3530,0 @@\n-            int[] pivotIndices;\n-            int baseOffset = Unsafe.ARRAY_DOUBLE_BASE_OFFSET;\n-\n@@ -3592,2 +3535,1 @@\n-                if (size < MIN_FAST_SMALL_ARRAY_SORT_SIZE) mixedInsertionSort(a, low, last , high);\n-                else arraySort(double.class, a, baseOffset, low, high, last);\n+                mixedInsertionSort(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, high - 3 * ((size >> 5) << 3));\n@@ -3601,2 +3543,1 @@\n-                if (size < MIN_FAST_SMALL_ARRAY_SORT_SIZE) insertionSort(a, low, high);\n-                else arraySort(double.class, a, baseOffset, low, high, -1);\n+                insertionSort(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high);\n@@ -3682,2 +3623,1 @@\n-            boolean isDualPivot = (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]);\n-            if(isDualPivot)  {\n+            if(a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n@@ -3690,2 +3630,1 @@\n-                pivotIndices = new int[] {e1, e5};\n-                arrayPartition(double.class, a, baseOffset, low, high, pivotIndices, isDualPivot);\n+                pivotIndices = partitionDualPivot(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, e1, e5);\n@@ -3712,2 +3651,1 @@\n-                pivotIndices = new int[] {e3, e3};\n-                arrayPartition(double.class, a, baseOffset, low, high, pivotIndices, isDualPivot);\n+                pivotIndices = partitionSinglePivot(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, e3);\n@@ -3733,1 +3671,1 @@\n-     * Partitions the specified range of the array using the two pivots specified.\n+     * Partitions the specified range of the array using the two pivots provided.\n@@ -3738,2 +3676,2 @@\n-     * @param pivotIndices an array containing the indices of the two pivots to be used.\n-     * After partitioning, this array the indices of the pivots is updated as well.\n+     * @param indexPivot1 the index of pivot1, the first pivot\n+     * @param indexPivot2 the index of pivot2, the second pivot\n@@ -3742,1 +3680,2 @@\n-    private static void partitionDualPivot(double[] a, int low, int high, int[] pivotIndices) {\n+    @ForceInline\n+    private static int[] partitionDualPivot(double[] a, int low, int high, int indexPivot1, int indexPivot2) {\n@@ -3747,2 +3686,2 @@\n-        int e1 = pivotIndices[0];\n-        int e5 = pivotIndices[1];\n+        int e1 = indexPivot1;\n+        int e5 = indexPivot2;\n@@ -3815,2 +3754,1 @@\n-        pivotIndices[0] = lower;\n-        pivotIndices[1] = upper;\n+        return new int[] {lower, upper};\n@@ -3822,1 +3760,1 @@\n-     * Partitions the specified range of the array using a single pivot specified.\n+     * Partitions the specified range of the array using a single pivot provided.\n@@ -3827,2 +3765,1 @@\n-     * @param pivotIndices an array containing the indices of the pivot to be used.\n-     * After partitioning, this array the indices of the pivots is updated as well.\n+     * @param indexPivot the index of the pivot\n@@ -3830,1 +3767,2 @@\n-    private static void partitionSinglePivot(double[] a, int low, int high, int[] pivotIndices) {\n+    @ForceInline\n+    private static int[] partitionSinglePivot(double[] a, int low, int high, int indexPivot) {\n@@ -3835,1 +3773,1 @@\n-        int e3 = pivotIndices[0];\n+        int e3 = indexPivot;\n@@ -3889,2 +3827,1 @@\n-        pivotIndices[0] = lower;\n-        pivotIndices[1] = upper;\n+        return new int[] {lower, upper};\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":145,"deletions":208,"binary":false,"changes":353,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,2 @@\n- * @run main Sorting -shortrun\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:DisableIntrinsic=_arraySortI,_arraySortMI,_arrayPartitionSP,_arrayPartitionDP Sorting -shortrun\n+ * @run main\/othervm -XX:CompileThreshold=1 -XX:-TieredCompilation Sorting -shortrun\n@@ -49,1 +50,1 @@\n-        1, 3, 8, 21, 55, 100, 1_000, 10_000, 100_000 };\n+        1, 3, 8, 21, 55, 100, 1_000, 10_000, 100_000};\n","filename":"test\/jdk\/java\/util\/Arrays\/Sorting.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}