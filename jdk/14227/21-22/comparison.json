{"files":[{"patch":"@@ -4133,1 +4133,1 @@\n-  \/\/ Get avx512 sort stub routine addresses\n+  \/\/ Get addresses for avx512 sort and partition routines\n@@ -4156,0 +4156,12 @@\n+\n+      snprintf(ebuf_x86_64, sizeof(ebuf_x86_64), \"avx512_partition_int\");\n+      StubRoutines::_array_partition_int = (address)os::dll_lookup(libx86_64, ebuf_x86_64);\n+\n+      snprintf(ebuf_x86_64, sizeof(ebuf_x86_64), \"avx512_partition_long\");\n+      StubRoutines::_array_partition_long = (address)os::dll_lookup(libx86_64, ebuf_x86_64);\n+\n+      snprintf(ebuf_x86_64, sizeof(ebuf_x86_64), \"avx512_partition_float\");\n+      StubRoutines::_array_partition_float = (address)os::dll_lookup(libx86_64, ebuf_x86_64);\n+\n+      snprintf(ebuf_x86_64, sizeof(ebuf_x86_64), \"avx512_partition_double\");\n+      StubRoutines::_array_partition_double = (address)os::dll_lookup(libx86_64, ebuf_x86_64);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -346,1 +346,6 @@\n-   do_signature(arraySort_signature,                             \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JII)V\")           \\\n+   do_signature(arraySort_signature,                             \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JIII)V\")          \\\n+                                                                                                                        \\\n+  do_intrinsic(_arrayPartition, java_util_Arrays, arrayPartition_name, arrayPartition_signature, F_S)                   \\\n+   do_name(arrayPartition_name, \"arrayPartition\")                                                                       \\\n+  do_signature(arrayPartition_signature, \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JII[IJZ)V\")                               \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -390,0 +390,3 @@\n+        \"array_partition_stub\",\n+        { { TypeFunc::Parms, ShenandoahStore }, { TypeFunc::Parms+3, ShenandoahStore }, { -1, ShenandoahNone },\n+          { -1, ShenandoahNone }, { -1, ShenandoahNone } },\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -334,0 +334,4 @@\n+  static_field(StubRoutines,                _array_partition_int,                             address)                               \\\n+  static_field(StubRoutines,                _array_partition_long,                            address)                               \\\n+  static_field(StubRoutines,                _array_partition_float,                           address)                               \\\n+  static_field(StubRoutines,                _array_partition_double,                          address)                               \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -572,0 +572,1 @@\n+  case vmIntrinsics::_arrayPartition:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1194,0 +1194,1 @@\n+                  strcmp(call->as_CallLeaf()->_name, \"array_partition_stub\") == 0 ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -295,1 +295,2 @@\n-  case vmIntrinsics::_arraySort:               return inline_arraysort();\n+  case vmIntrinsics::_arraySort:                return inline_arraysort();\n+  case vmIntrinsics::_arrayPartition:           return inline_array_partition();\n@@ -5197,0 +5198,41 @@\n+\/\/------------------------------inline_array_partition-----------------------\n+bool LibraryCallKit::inline_array_partition() {\n+\n+  address stubAddr = nullptr;\n+  const char *stubName;\n+  stubName = \"array_partition_stub\";\n+\n+  Node* elementType     = null_check(argument(0));\n+  Node* obj             = argument(1);\n+  Node* offset          = argument(2);\n+  Node* fromIndex       = argument(4);\n+  Node* toIndex         = argument(5);\n+  Node* pivot_indices   = argument(6);\n+  Node* pivot_offset    = argument(7);\n+  Node* isDualPivot     = argument(9);\n+\n+  const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  BasicType bt = elem_type->basic_type();\n+  stubAddr = StubRoutines::select_array_partition_function(bt);\n+  if (stubAddr == nullptr) return false;\n+\n+  const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n+  if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n+    return false; \/\/ failed input validation\n+  }\n+\n+  Node* obj_adr = make_unsafe_address(obj, offset);\n+\n+  pivot_indices = must_be_not_null(pivot_indices, true);\n+  Node* pivot_indices_adr = make_unsafe_address(pivot_indices, pivot_offset); \/\/this offset is not same as array offset\n+\n+  \/\/ Call the stub.\n+  make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::array_partition_Type(),\n+                    stubAddr, stubName, TypePtr::BOTTOM,\n+                    obj_adr, fromIndex, toIndex, pivot_indices_adr, isDualPivot);\n+\n+  return true;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":43,"deletions":1,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -283,0 +283,1 @@\n+  bool inline_array_partition();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -860,0 +860,21 @@\n+const TypeFunc* OptoRuntime::array_partition_Type() {\n+  \/\/ create input type (domain)\n+  int num_args = 5;\n+  int argcnt = num_args;\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ array\n+  fields[argp++] = TypeInt::INT;    \/\/ low\n+  fields[argp++] = TypeInt::INT;    \/\/ end\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ pivot_indices (int array)\n+  fields[argp++] = TypeInt::BOOL;       \/\/ isDualPivot\n+  assert(argp == TypeFunc::Parms+argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ no result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n+  return TypeFunc::make(domain, range);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -272,0 +272,1 @@\n+  static const TypeFunc* array_partition_Type();\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -179,4 +179,8 @@\n-address StubRoutines::_arraysort_int        = nullptr;\n-address StubRoutines::_arraysort_long       = nullptr;\n-address StubRoutines::_arraysort_float      = nullptr;\n-address StubRoutines::_arraysort_double     = nullptr;\n+address StubRoutines::_arraysort_int = nullptr;\n+address StubRoutines::_arraysort_long = nullptr;\n+address StubRoutines::_arraysort_float = nullptr;\n+address StubRoutines::_arraysort_double = nullptr;\n+address StubRoutines::_array_partition_int  = nullptr;\n+address StubRoutines::_array_partition_long = nullptr;\n+address StubRoutines::_array_partition_float = nullptr;\n+address StubRoutines::_array_partition_double = nullptr;\n@@ -668,0 +672,12 @@\n+\n+address StubRoutines::select_array_partition_function(BasicType t) {\n+  switch(t) {\n+    case T_INT:    return _array_partition_int;\n+    case T_LONG:   return _array_partition_long;\n+    case T_FLOAT:  return _array_partition_float;\n+    case T_DOUBLE: return _array_partition_double;\n+  default:\n+    ShouldNotReachHere();\n+    return nullptr;\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -160,0 +160,4 @@\n+  static address _array_partition_int;\n+  static address _array_partition_long;\n+  static address _array_partition_float;\n+  static address _array_partition_double;\n@@ -381,0 +385,1 @@\n+  static address select_array_partition_function(BasicType t);\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -64,0 +64,3 @@\n+    static opmask_t gt(zmm_t x, zmm_t y) {\n+        return _mm512_cmp_epi32_mask(x, y, _MM_CMPINT_GT);\n+    }\n@@ -120,0 +123,3 @@\n+    static opmask_t gt(zmm_t x, zmm_t y) {\n+        return _mm512_cmp_ps_mask(x, y, _CMP_GT_OQ);\n+    }\n@@ -434,1 +440,1 @@\n-        arr, left, right + 1, pivot, &smallest, &biggest);\n+        arr, left, right + 1, pivot, &smallest, &biggest, false);\n@@ -442,1 +448,2 @@\n-void avx512_qsort<int32_t>(int32_t *arr, int64_t arrsize) {\n+inline void avx512_qsort<int32_t>(int32_t *arr, int64_t fromIndex, int64_t toIndex) {\n+    int64_t arrsize = toIndex - fromIndex;\n@@ -444,1 +451,1 @@\n-        qsort_32bit_<zmm_vector<int32_t>, int32_t>(arr, 0, arrsize - 1,\n+        qsort_32bit_<zmm_vector<int32_t>, int32_t>(arr, fromIndex, toIndex - 1,\n@@ -450,3 +457,2 @@\n-void avx512_qsort<float>(float *arr, int64_t arrsize) {\n-    int64_t idx_last_elem_not_nan = move_nans_to_end_of_array(arr, arrsize);\n-    arrsize = idx_last_elem_not_nan + 1;\n+inline void avx512_qsort<float>(float *arr, int64_t fromIndex, int64_t toIndex) {\n+    int64_t arrsize = toIndex - fromIndex;\n@@ -454,1 +460,1 @@\n-        qsort_32bit_<zmm_vector<float>, float>(arr, 0, idx_last_elem_not_nan,\n+        qsort_32bit_<zmm_vector<float>, float>(arr, fromIndex, toIndex - 1,\n","filename":"src\/java.base\/linux\/native\/libx86_64\/avx512-32bit-qsort.hpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -73,0 +73,3 @@\n+    static opmask_t gt(zmm_t x, zmm_t y) {\n+        return _mm512_cmp_epi64_mask(x, y, _MM_CMPINT_GT);\n+    }\n@@ -142,0 +145,3 @@\n+    static opmask_t gt(zmm_t x, zmm_t y) {\n+        return _mm512_cmp_pd_mask(x, y, _CMP_GT_OQ);\n+    }\n","filename":"src\/java.base\/linux\/native\/libx86_64\/avx512-64bit-common.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -749,1 +749,1 @@\n-        arr, left, right + 1, pivot, &smallest, &biggest);\n+        arr, left, right + 1, pivot, &smallest, &biggest, false);\n@@ -757,1 +757,2 @@\n-void avx512_qsort<int64_t>(int64_t *arr, int64_t arrsize) {\n+inline void avx512_qsort<int64_t>(int64_t *arr, int64_t fromIndex, int64_t toIndex) {\n+    int64_t arrsize = toIndex - fromIndex;\n@@ -759,1 +760,1 @@\n-        qsort_64bit_<zmm_vector<int64_t>, int64_t>(arr, 0, arrsize - 1,\n+        qsort_64bit_<zmm_vector<int64_t>, int64_t>(arr, fromIndex, toIndex - 1,\n@@ -765,3 +766,2 @@\n-void avx512_qsort<double>(double *arr, int64_t arrsize) {\n-    int64_t idx_last_elem_not_nan = move_nans_to_end_of_array(arr, arrsize);\n-    arrsize = idx_last_elem_not_nan + 1;\n+inline void avx512_qsort<double>(double *arr, int64_t fromIndex, int64_t toIndex) {\n+    int64_t arrsize = toIndex - fromIndex;\n@@ -769,1 +769,1 @@\n-        qsort_64bit_<zmm_vector<double>, double>(arr, 0, idx_last_elem_not_nan,\n+        qsort_64bit_<zmm_vector<double>, double>(arr, fromIndex, toIndex - 1,\n@@ -773,0 +773,1 @@\n+\n","filename":"src\/java.base\/linux\/native\/libx86_64\/avx512-64bit-qsort.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-\n+#include <iostream>\n@@ -119,0 +119,6 @@\n+template <typename T>\n+void avx512_dual_pivot_partition(T *arr, int64_t low, int64_t high, int32_t *pivot_indices, bool isDualPivot);\n+\n+template <typename T>\n+void avx512_single_pivot_partition(T *arr, int64_t low, int64_t high, int32_t *pivot_indices, bool isDualPivot);\n+\n@@ -122,0 +128,3 @@\n+template <typename T>\n+void inline avx512_qsort(T *arr, int64_t from_index, int64_t to_index);\n+\n@@ -149,1 +158,1 @@\n-bool comparison_func(const T &a, const T &b) {\n+bool comparison_func_ge(const T &a, const T &b) {\n@@ -153,0 +162,5 @@\n+template <typename vtype, typename T = typename vtype::type_t>\n+bool comparison_func_gt(const T &a, const T &b) {\n+    return a <= b;\n+}\n+\n@@ -176,1 +190,1 @@\n-                                    zmm_t *smallest_vec, zmm_t *biggest_vec) {\n+                                    zmm_t *smallest_vec, zmm_t *biggest_vec, bool use_gt) {\n@@ -178,3 +192,6 @@\n-    typename vtype::opmask_t ge_mask = vtype::ge(curr_vec, pivot_vec);\n-    int32_t amount_ge_pivot = _mm_popcnt_u32((int32_t)ge_mask);\n-    vtype::mask_compressstoreu(arr + left, vtype::knot_opmask(ge_mask),\n+    typename vtype::opmask_t mask;\n+    if (use_gt) mask = vtype::gt(curr_vec, pivot_vec);\n+    else mask = vtype::ge(curr_vec, pivot_vec);\n+    \/\/mask = vtype::ge(curr_vec, pivot_vec);\n+    int32_t amount_ge_pivot = _mm_popcnt_u32((int32_t)mask);\n+    vtype::mask_compressstoreu(arr + left, vtype::knot_opmask(mask),\n@@ -182,1 +199,1 @@\n-    vtype::mask_compressstoreu(arr + right - amount_ge_pivot, ge_mask,\n+    vtype::mask_compressstoreu(arr + right - amount_ge_pivot, mask,\n@@ -195,1 +212,2 @@\n-                                       type_t *biggest) {\n+                                       type_t *biggest, bool use_gt) {\n+    auto comparison_func = use_gt ? comparison_func_gt<vtype> : comparison_func_ge<vtype>;\n@@ -198,3 +216,3 @@\n-        *smallest = std::min(*smallest, arr[left], comparison_func<vtype>);\n-        *biggest = std::max(*biggest, arr[left], comparison_func<vtype>);\n-        if (!comparison_func<vtype>(arr[left], pivot)) {\n+        *smallest = std::min(*smallest, arr[left], comparison_func);\n+        *biggest = std::max(*biggest, arr[left], comparison_func);\n+        if (!comparison_func(arr[left], pivot)) {\n@@ -219,1 +237,1 @@\n-                                 pivot_vec, &min_vec, &max_vec);\n+                                 pivot_vec, &min_vec, &max_vec, use_gt);\n@@ -251,1 +269,1 @@\n-                                 curr_vec, pivot_vec, &min_vec, &max_vec);\n+                                 curr_vec, pivot_vec, &min_vec, &max_vec, use_gt);\n@@ -260,1 +278,1 @@\n-                             pivot_vec, &min_vec, &max_vec);\n+                             pivot_vec, &min_vec, &max_vec, use_gt);\n@@ -264,1 +282,1 @@\n-                             pivot_vec, &min_vec, &max_vec);\n+                             pivot_vec, &min_vec, &max_vec, use_gt);\n@@ -276,1 +294,1 @@\n-                                                type_t *biggest) {\n+                                                type_t *biggest, bool use_gt) {\n@@ -279,1 +297,1 @@\n-                                       biggest);\n+                                       biggest, use_gt);\n@@ -281,0 +299,2 @@\n+\n+    auto comparison_func = use_gt ? comparison_func_gt<vtype> : comparison_func_ge<vtype>;\n@@ -285,3 +305,3 @@\n-        *smallest = std::min(*smallest, arr[left], comparison_func<vtype>);\n-        *biggest = std::max(*biggest, arr[left], comparison_func<vtype>);\n-        if (!comparison_func<vtype>(arr[left], pivot)) {\n+        *smallest = std::min(*smallest, arr[left], comparison_func);\n+        *biggest = std::max(*biggest, arr[left], comparison_func);\n+        if (!comparison_func(arr[left], pivot)) {\n@@ -342,1 +362,1 @@\n-                pivot_vec, &min_vec, &max_vec);\n+                pivot_vec, &min_vec, &max_vec, use_gt);\n@@ -353,1 +373,1 @@\n-                                 vec_left[ii], pivot_vec, &min_vec, &max_vec);\n+                                 vec_left[ii], pivot_vec, &min_vec, &max_vec, use_gt);\n@@ -361,1 +381,1 @@\n-                                 vec_right[ii], pivot_vec, &min_vec, &max_vec);\n+                                 vec_right[ii], pivot_vec, &min_vec, &max_vec, use_gt);\n@@ -370,0 +390,69 @@\n+\/\/ right = to_index (exclusive)\n+template <typename vtype, typename type_t>\n+static int64_t vectorized_partition(type_t *arr, int64_t left, int64_t right, type_t pivot, bool use_gt) {\n+    type_t smallest = vtype::type_max();\n+    type_t biggest = vtype::type_min();\n+    int64_t pivot_index = partition_avx512_unrolled<vtype, 2>(\n+            arr, left, right, pivot, &smallest, &biggest, use_gt);\n+    return pivot_index;\n+}\n+\n+\/\/ partitioning functions\n+template <typename T>\n+void avx512_dual_pivot_partition(T *arr, int64_t from_index, int64_t to_index, int32_t *pivot_indices){\n+    const int64_t pidx1 = pivot_indices[0];\n+    const int64_t pidx2 = pivot_indices[1];\n+    const T pivot1 = arr[pidx1];\n+    const T pivot2 = arr[pidx2];\n+\n+    const int64_t low = from_index;\n+    const int64_t high = to_index;\n+    const int64_t start = low + 1;\n+    const int64_t end = high - 1;\n+\n+\n+    std::swap(arr[pidx1], arr[low]);\n+    std::swap(arr[pidx2], arr[end]);\n+\n+\n+    const int64_t pivot_index2 = vectorized_partition<zmm_vector<T>, T>(arr, start, end, pivot2, true); \/\/ use_gt = true\n+    std::swap(arr[end], arr[pivot_index2]);\n+    int64_t upper = pivot_index2;\n+\n+    const int64_t pivot_index1 = vectorized_partition<zmm_vector<T>, T>(arr, start, upper, pivot1, false); \/\/ use_ge (use_gt = false)\n+    int64_t lower = pivot_index1 - 1;\n+    std::swap(arr[low], arr[lower]);\n+\n+    pivot_indices[0] = lower;\n+    pivot_indices[1] = upper;\n+}\n+\n+template <typename T>\n+void avx512_single_pivot_partition(T *arr, int64_t from_index, int64_t to_index, int32_t *pivot_indices){\n+    const int64_t pidx = pivot_indices[0];\n+    const T pivot = arr[pidx];\n+\n+    const int64_t low = from_index;\n+    const int64_t high = to_index;\n+    \/\/const int64_t start = low + 1;\n+    const int64_t end = high - 1;\n+\n+\n+    const int64_t pivot_index1 = vectorized_partition<zmm_vector<T>, T>(arr, low, high, pivot, false); \/\/ use_gt = false (use_ge)\n+    int64_t lower = pivot_index1;\n+\n+    const int64_t pivot_index2 = vectorized_partition<zmm_vector<T>, T>(arr, pivot_index1, high, pivot, true); \/\/ use_gt = true\n+    int64_t upper = pivot_index2;\n+\n+    pivot_indices[0] = lower;\n+    pivot_indices[1] = upper;\n+}\n+\n+template <typename T>\n+inline void avx512_partition(T *arr, int64_t from_index, int64_t to_index, int32_t *pivot_indices, bool is_dual_pviot) {\n+    if(is_dual_pviot) avx512_dual_pivot_partition<T>(arr, from_index, to_index, pivot_indices);\n+        else avx512_single_pivot_partition<T>(arr, from_index, to_index, pivot_indices);\n+}\n+\n+\n+\n","filename":"src\/java.base\/linux\/native\/libx86_64\/avx512-common-qsort.h","additions":112,"deletions":23,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -35,3 +35,2 @@\n-    DLL_PUBLIC void avx512_sort_int(int32_t *array_fromIndex, int64_t fromIndex,\n-                                    int64_t toIndex) {\n-        avx512_qsort<int32_t>(array_fromIndex, toIndex - fromIndex);\n+    DLL_PUBLIC void avx512_sort_int(int32_t *array, int64_t from_index, int64_t to_index) {\n+        avx512_qsort<int32_t>(array, from_index, to_index);\n@@ -40,3 +39,2 @@\n-    DLL_PUBLIC void avx512_sort_long(int64_t *array_fromIndex, int64_t fromIndex,\n-                                    int64_t toIndex) {\n-        avx512_qsort<int64_t>(array_fromIndex, toIndex - fromIndex);\n+    DLL_PUBLIC void avx512_sort_long(int64_t *array, int64_t from_index, int64_t to_index) {\n+        avx512_qsort<int64_t>(array, from_index, to_index);\n@@ -45,3 +43,2 @@\n-    DLL_PUBLIC void avx512_sort_float(float *array_fromIndex, int64_t fromIndex,\n-                                    int64_t toIndex) {\n-        avx512_qsort<float>(array_fromIndex, toIndex - fromIndex);\n+    DLL_PUBLIC void avx512_sort_float(float *array, int64_t from_index, int64_t to_index) {\n+        avx512_qsort<float>(array, from_index, to_index);\n@@ -50,3 +47,18 @@\n-    DLL_PUBLIC void avx512_sort_double(double *array_fromIndex, int64_t fromIndex,\n-                                    int64_t toIndex) {\n-        avx512_qsort<double>(array_fromIndex, toIndex - fromIndex);\n+    DLL_PUBLIC void avx512_sort_double(double *array, int64_t from_index, int64_t to_index) {\n+        avx512_qsort<double>(array, from_index, to_index);\n+    }\n+\n+    DLL_PUBLIC void avx512_partition_int(int32_t *array, int64_t from_index, int64_t to_index, int32_t *pivot_indices, bool is_dual_pivot) {\n+        avx512_partition<int32_t>(array, from_index, to_index, pivot_indices, is_dual_pivot);\n+    }\n+\n+    DLL_PUBLIC void avx512_partition_long(int64_t *array, int64_t from_index, int64_t to_index, int32_t *pivot_indices, bool is_dual_pivot) {\n+        avx512_partition<int64_t>(array, from_index, to_index, pivot_indices, is_dual_pivot);\n+    }\n+\n+    DLL_PUBLIC void avx512_partition_float(float *array, int64_t from_index, int64_t to_index, int32_t *pivot_indices, bool is_dual_pivot) {\n+        avx512_partition<float>(array, from_index, to_index, pivot_indices, is_dual_pivot);\n+    }\n+\n+    DLL_PUBLIC void avx512_partition_double(double *array, int64_t from_index, int64_t to_index, int32_t *pivot_indices, bool is_dual_pivot) {\n+        avx512_partition<double>(array, from_index, to_index, pivot_indices, is_dual_pivot);\n","filename":"src\/java.base\/linux\/native\/libx86_64\/avxsort_linux_x86.cpp","additions":24,"deletions":12,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -84,1 +84,3 @@\n-     *\n+     * While the intrinsic is free to choose its own sorting algorithm, the\n+     * fallback implementation uses either mixed insertion sort or simple\n+     * insertion sort.\n@@ -93,0 +95,25 @@\n+     * @param end the index of the last element for simple insertion sort (in\n+     * the case of mixed insertion sort). In the fallback implementation,\n+     * if end < 0, we use insertion sort else we use mixed insertion sort.\n+     *\/\n+    @IntrinsicCandidate\n+    static void arraySort(Class<?> elemType, Object array, long offset, int fromIndex, int toIndex, int end) {\n+        DualPivotQuicksort.smallArraySort(array, fromIndex, toIndex, end);\n+    }\n+\n+    \/**\n+     * Partitions the specified array based on the pivot(s) provided.\n+     *\n+     * @param elemType the class of the array to be sorted\n+     * @param array the array to be sorted\n+     * @param offset the relative offset, in bytes, from the base address of\n+     * the array to partition, otherwise if the array is {@code null},an absolute\n+     * address pointing to the first element to partition from.\n+     * @param fromIndex the index of the first element, inclusive, to be sorted\n+     * @param toIndex the index of the last element, exclusive, to be sorted\n+     * @param pivotIndices the array containing the indices of the pivots. After\n+     * partitioning, this array is updated with the new indices of the pivots.\n+     * @param pivot_offset the offset in bytes pointing to the base address of\n+     * the array used to store the indices of the pivots.\n+     * @param isDualPivot a boolean value to choose between dual pivot\n+     * partitioning and single pivot partitioning\n@@ -95,9 +122,3 @@\n-    private static void arraySort(Class<?> elemType, Object array, long offset, int fromIndex, int toIndex) {\n-        switch (array) {\n-            case int[] arr -> DualPivotQuicksort.sort(arr, 0, fromIndex, toIndex);\n-            case long[] arr -> DualPivotQuicksort.sort(arr, 0, fromIndex, toIndex);\n-            case float[] arr -> DualPivotQuicksort.sort(arr, 0, fromIndex, toIndex);\n-            case double[] arr -> DualPivotQuicksort.sort(arr, 0, fromIndex, toIndex);\n-            default -> throw new UnsupportedOperationException(\n-                    \"arraySort intrinsic not supported for this type: \" + elemType);\n-        }\n+    static void arrayPartition(Class<?> elemType, Object array, long offset, int fromIndex, int toIndex, int[] pivotIndices, long pivot_offset, boolean isDualPivot) {\n+        if (isDualPivot) DualPivotQuicksort.partitionDualPivot(array, fromIndex, toIndex, pivotIndices);\n+        else DualPivotQuicksort.partitionSinglePivot(array, fromIndex, toIndex, pivotIndices);\n@@ -125,2 +146,1 @@\n-        int offset = Unsafe.ARRAY_INT_BASE_OFFSET;\n-        arraySort(int.class, a, offset, 0, a.length);\n+        DualPivotQuicksort.sort(a, 0, 0, a.length);\n@@ -150,2 +170,1 @@\n-        int offset = Unsafe.ARRAY_INT_BASE_OFFSET + (fromIndex << ArraysSupport.LOG2_ARRAY_INT_INDEX_SCALE);\n-        arraySort(int.class, a, offset, fromIndex, toIndex);\n+        DualPivotQuicksort.sort(a, 0, fromIndex, toIndex);\n@@ -165,2 +184,1 @@\n-        int offset = Unsafe.ARRAY_LONG_BASE_OFFSET;\n-        arraySort(long.class, a, offset, 0, a.length);\n+        DualPivotQuicksort.sort(a, 0, 0, a.length);\n@@ -190,2 +208,1 @@\n-        int offset = Unsafe.ARRAY_LONG_BASE_OFFSET + (fromIndex << ArraysSupport.LOG2_ARRAY_LONG_INDEX_SCALE);\n-        arraySort(long.class, a, offset, fromIndex, toIndex);\n+        DualPivotQuicksort.sort(a, 0, fromIndex, toIndex);\n@@ -327,2 +344,1 @@\n-        int offset = Unsafe.ARRAY_FLOAT_BASE_OFFSET;\n-        arraySort(float.class, a, offset, 0, a.length);\n+        DualPivotQuicksort.sort(a, 0, 0, a.length);\n@@ -360,2 +376,1 @@\n-        int offset = Unsafe.ARRAY_FLOAT_BASE_OFFSET + (fromIndex << ArraysSupport.LOG2_ARRAY_FLOAT_INDEX_SCALE);\n-        arraySort(float.class, a, offset, fromIndex, toIndex);\n+        DualPivotQuicksort.sort(a, 0, fromIndex, toIndex);\n@@ -383,2 +398,1 @@\n-        int offset = Unsafe.ARRAY_DOUBLE_BASE_OFFSET;\n-        arraySort(double.class, a, offset, 0, a.length);\n+         DualPivotQuicksort.sort(a, 0, 0, a.length);\n@@ -416,2 +430,1 @@\n-        int offset = Unsafe.ARRAY_DOUBLE_BASE_OFFSET + (fromIndex << ArraysSupport.LOG2_ARRAY_DOUBLE_INDEX_SCALE);\n-        arraySort(double.class, a, offset, fromIndex, toIndex);\n+        DualPivotQuicksort.sort(a, 0, fromIndex, toIndex);\n","filename":"src\/java.base\/share\/classes\/java\/util\/Arrays.java","additions":39,"deletions":26,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+import java.util.Arrays;\n+import jdk.internal.misc.Unsafe;\n+\n@@ -140,0 +143,94 @@\n+    \/**\n+     * Sorts the specified range of the array using either insertion sort\n+     * or mixed insertion sort depending on the value of end. if end < 0,\n+     * we use insertion sort else we use mixed insertion sort.\n+     *\n+     * @param array the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @param end the index of the last element for simple insertion sort (in\n+     * the case of mixed insertion sort). If end < 0, we use insertion sort\n+     * else we use mixed insertion sort.\n+     *\/\n+    static void smallArraySort(Object array, int low, int high, int end) {\n+       if (end < 0) insertionSort(array, low, high);\n+       else mixedInsertionSort(array, low, end, high);\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using insertion sort\n+     *\n+     * @param array the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\n+     *\/\n+    static void insertionSort(Object array, int low, int high) {\n+        switch (array) {\n+            case int[] arr -> insertionSort(arr, low, high);\n+            case long[] arr -> insertionSort(arr, low, high);\n+            case float[] arr -> insertionSort(arr, low, high);\n+            case double[] arr -> insertionSort(arr, low, high);\n+            default -> throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using mixed insertion sort.\n+     *\n+     * @param array the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @param end the index of the last element for simple insertion sort\n+     *\n+     *\/\n+    static void mixedInsertionSort(Object array, int low, int end, int high) {\n+        switch (array) {\n+            case int[] arr -> mixedInsertionSort(arr, low, end, high);\n+            case long[] arr ->  mixedInsertionSort(arr, low, end, high);\n+            case float[] arr ->  mixedInsertionSort(arr, low, end, high);\n+            case double[] arr ->  mixedInsertionSort(arr, low, end, high);\n+            default -> throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    \/**\n+     * Partitions the specified range of the array using the two pivots specified.\n+     *\n+     * @param array the array to be partitioned\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndices an array containing the indices of the two pivots to be used.\n+     * After partitioning, the indices of the pivots is updated as well.\n+     *\n+     *\/\n+    static void partitionDualPivot(Object array, int low, int high, int[] pivotIndices) {\n+        switch(array) {\n+            case int[] arr -> partitionDualPivot(arr, low, high, pivotIndices);\n+            case long[] arr -> partitionDualPivot(arr, low, high, pivotIndices);\n+            case float[] arr -> partitionDualPivot(arr, low, high, pivotIndices);\n+            case double[] arr -> partitionDualPivot(arr, low, high, pivotIndices);\n+            default -> throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    \/**\n+     * Partitions the specified range of the array using a single pivot specified.\n+     *\n+     * @param array the array to be partitioned\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndices an array containing the indices of the pivot to be used.\n+     * After partitioning, the indices of the pivots is updated as well.\n+     *\n+     *\/\n+    static void partitionSinglePivot(Object array, int low, int high, int[] pivotIndices) {\n+        switch(array) {\n+            case int[] arr -> partitionSinglePivot(arr, low, high, pivotIndices);\n+            case long[] arr -> partitionSinglePivot(arr, low, high, pivotIndices);\n+            case float[] arr -> partitionSinglePivot(arr, low, high, pivotIndices);\n+            case double[] arr -> partitionSinglePivot(arr, low, high, pivotIndices);\n+            default -> throw new UnsupportedOperationException();\n+        }\n+    }\n+\n@@ -181,0 +278,2 @@\n+            int[] pivotIndices;\n+            int baseOffset = Unsafe.ARRAY_INT_BASE_OFFSET;\n@@ -186,1 +285,1 @@\n-                mixedInsertionSort(a, low, high - 3 * ((size >> 5) << 3), high);\n+                Arrays.arraySort(int.class, a, baseOffset, low, high, high - 3 * ((size >> 5) << 3));\n@@ -194,1 +293,1 @@\n-                insertionSort(a, low, high);\n+                Arrays.arraySort(int.class, a, baseOffset, low, high, -1);\n@@ -274,2 +373,2 @@\n-            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n-\n+            boolean isDualPivot = (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]);\n+            if (isDualPivot) {\n@@ -281,40 +380,4 @@\n-                int pivot1 = a[e1];\n-                int pivot2 = a[e5];\n-\n-                \/*\n-                 * The first and the last elements to be sorted are moved\n-                 * to the locations formerly occupied by the pivots. When\n-                 * partitioning is completed, the pivots are swapped back\n-                 * into their final positions, and excluded from the next\n-                 * subsequent sorting.\n-                 *\/\n-                a[e1] = a[lower];\n-                a[e5] = a[upper];\n-\n-                \/*\n-                 * Skip elements, which are less or greater than the pivots.\n-                 *\/\n-                while (a[++lower] < pivot1);\n-                while (a[--upper] > pivot2);\n-\n-                \/*\n-                 * Backward 3-interval partitioning\n-                 *\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int unused = --lower, k = ++upper; --k > lower; ) {\n-                    int ak = a[k];\n+                pivotIndices = new int[] {e1, e5};\n+                Arrays.arrayPartition(int.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n+                lower = pivotIndices[0];\n+                upper = pivotIndices[1];\n@@ -322,18 +385,0 @@\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n-                                break;\n-                            }\n-                        }\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n-                        a[k] = a[--upper];\n-                        a[upper] = ak;\n-                    }\n-                }\n@@ -341,5 +386,0 @@\n-                \/*\n-                 * Swap the pivots into their final positions.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot1;\n-                a[end] = a[upper]; a[upper] = pivot2;\n@@ -365,2 +405,4 @@\n-                int pivot = a[e3];\n-\n+                pivotIndices = new int[] {e3, e3};\n+                Arrays.arrayPartition(int.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n+                lower = pivotIndices[0];\n+                upper = pivotIndices[1];\n@@ -368,5 +410,3 @@\n-                 * The first element to be sorted is moved to the\n-                 * location formerly occupied by the pivot. After\n-                 * completion of partitioning the pivot is swapped\n-                 * back into its final position, and excluded from\n-                 * the next subsequent sorting.\n+                 * Sort the right part (possibly in parallel), excluding\n+                 * known pivot. All elements from the central part are\n+                 * equal and therefore already sorted.\n@@ -374,1 +414,9 @@\n-                a[e3] = a[lower];\n+                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+                    sorter.forkSorter(bits | 1, upper, high);\n+                } else {\n+                    sort(sorter, a, bits | 1, upper, high);\n+                }\n+            }\n+            high = lower; \/\/ Iterate along the left part\n+        }\n+    }\n@@ -376,21 +424,14 @@\n-                \/*\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n-                 *\n-                 *   left part                 central part    right part\n-                 * +------------------------------------------------------+\n-                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-                 * +------------------------------------------------------+\n-                 *              ^           ^                ^\n-                 *              |           |                |\n-                 *            lower         k              upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int k = ++upper; --k > lower; ) {\n-                    int ak = a[k];\n+    \/**\n+     * Partitions the specified range of the array using the two pivots specified.\n+     *\n+     * @param array the array to be partitioned\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndices an array containing the indices of the two pivots to be used.\n+     * After partitioning, this array the indices of the pivots is updated as well.\n+     *\n+     *\/\n+    private static void partitionDualPivot(int[] a, int low, int high, int[] pivotIndices) {\n+        int end = high - 1;\n+        int lower = low;\n+        int upper = end;\n@@ -398,2 +439,4 @@\n-                    if (ak != pivot) {\n-                        a[k] = pivot;\n+        int e1 = pivotIndices[0];\n+        int e5 = pivotIndices[1];\n+        int pivot1 = a[e1];\n+        int pivot2 = a[e5];\n@@ -401,2 +444,9 @@\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n-                            while (a[++lower] < pivot);\n+        \/*\n+        * The first and the last elements to be sorted are moved\n+        * to the locations formerly occupied by the pivots. When\n+        * partitioning is completed, the pivots are swapped back\n+        * into their final positions, and excluded from the next\n+        * subsequent sorting.\n+        *\/\n+        a[e1] = a[lower];\n+        a[e5] = a[upper];\n@@ -404,6 +454,36 @@\n-                            if (a[lower] > pivot) {\n-                                a[--upper] = a[lower];\n-                            }\n-                            a[lower] = ak;\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n-                            a[--upper] = ak;\n+        \/*\n+        * Skip elements, which are less or greater than the pivots.\n+        *\/\n+        while (a[++lower] < pivot1);\n+        while (a[--upper] > pivot2);\n+\n+        \/*\n+        * Backward 3-interval partitioning\n+        *\n+        *   left part                 central part          right part\n+        * +------------------------------------------------------------+\n+                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n+        * +------------------------------------------------------------+\n+        *             ^       ^                            ^\n+        *             |       |                            |\n+        *           lower     k                          upper\n+        *\n+        * Invariants:\n+        *\n+        *              all in (low, lower] < pivot1\n+        *    pivot1 <= all in (k, upper)  <= pivot2\n+        *              all in [upper, end) > pivot2\n+        *\n+        * Pointer k is the last index of ?-part\n+        *\/\n+        for (int unused = --lower, k = ++upper; --k > lower; ) {\n+            int ak = a[k];\n+\n+            if (ak < pivot1) { \/\/ Move a[k] to the left side\n+                while (lower < k) {\n+                    if (a[++lower] >= pivot1) {\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n@@ -411,0 +491,2 @@\n+                        a[lower] = ak;\n+                        break;\n@@ -413,0 +495,5 @@\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                a[k] = a[--upper];\n+                a[upper] = ak;\n+            }\n+        }\n@@ -414,4 +501,5 @@\n-                \/*\n-                 * Swap the pivot into its final position.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot;\n+        \/*\n+         * Swap the pivots into their final positions.\n+         *\/\n+        a[low] = a[lower]; a[lower] = pivot1;\n+        a[end] = a[upper]; a[upper] = pivot2;\n@@ -419,9 +507,68 @@\n-                \/*\n-                 * Sort the right part (possibly in parallel), excluding\n-                 * known pivot. All elements from the central part are\n-                 * equal and therefore already sorted.\n-                 *\/\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.forkSorter(bits | 1, upper, high);\n-                } else {\n-                    sort(sorter, a, bits | 1, upper, high);\n+        pivotIndices[0] = lower;\n+        pivotIndices[1] = upper;\n+    }\n+\n+\n+\n+    \/**\n+     * Partitions the specified range of the array using a single pivot specified.\n+     *\n+     * @param array the array to be partitioned\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndices an array containing the indices of the pivot to be used.\n+     * After partitioning, this array the indices of the pivots is updated as well.\n+     *\n+     *\/\n+    private static void partitionSinglePivot(int[] a, int low, int high, int[] pivotIndices) {\n+        int end = high - 1;\n+        int lower = low;\n+        int upper = end;\n+\n+\n+        int e3 = pivotIndices[0];\n+        int pivot = a[e3];\n+\n+        \/*\n+        * The first element to be sorted is moved to the\n+        * location formerly occupied by the pivot. After\n+        * completion of partitioning the pivot is swapped\n+        * back into its final position, and excluded from\n+        * the next subsequent sorting.\n+        *\/\n+        a[e3] = a[lower];\n+\n+        \/*\n+        * Traditional 3-way (Dutch National Flag) partitioning\n+        *\n+        *   left part                 central part    right part\n+        * +------------------------------------------------------+\n+        * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n+        * +------------------------------------------------------+\n+        *              ^           ^                ^\n+        *              |           |                |\n+        *            lower         k              upper\n+        *\n+        * Invariants:\n+        *\n+        *   all in (low, lower] < pivot\n+        *   all in (k, upper)  == pivot\n+        *   all in [upper, end] > pivot\n+        *\n+        * Pointer k is the last index of ?-part\n+        *\/\n+        for (int k = ++upper; --k > lower; ) {\n+            int ak = a[k];\n+\n+            if (ak != pivot) {\n+                a[k] = pivot;\n+\n+                if (ak < pivot) { \/\/ Move a[k] to the left side\n+                    while (a[++lower] < pivot);\n+\n+                    if (a[lower] > pivot) {\n+                        a[--upper] = a[lower];\n+                    }\n+                    a[lower] = ak;\n+                } else { \/\/ ak > pivot - Move a[k] to the right side\n+                    a[--upper] = ak;\n@@ -430,1 +577,0 @@\n-            high = lower; \/\/ Iterate along the left part\n@@ -432,0 +578,7 @@\n+\n+        \/*\n+        * Swap the pivot into its final position.\n+        *\/\n+        a[low] = a[lower]; a[lower] = pivot;\n+        pivotIndices[0] = lower;\n+        pivotIndices[1] = upper;\n@@ -935,0 +1088,2 @@\n+            int[] pivotIndices;\n+            int baseOffset = Unsafe.ARRAY_LONG_BASE_OFFSET;\n@@ -940,1 +1095,1 @@\n-                mixedInsertionSort(a, low, high - 3 * ((size >> 5) << 3), high);\n+                Arrays.arraySort(long.class, a, baseOffset, low, high, high - 3 * ((size >> 5) << 3));\n@@ -948,1 +1103,1 @@\n-                insertionSort(a, low, high);\n+                Arrays.arraySort(long.class, a, baseOffset, low, high, -1);\n@@ -1028,1 +1183,2 @@\n-            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n+            boolean isDualPivot = (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]);\n+            if(isDualPivot)  {\n@@ -1035,3 +1191,4 @@\n-                long pivot1 = a[e1];\n-                long pivot2 = a[e5];\n-\n+                pivotIndices = new int[] {e1, e5};\n+                Arrays.arrayPartition(long.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n+                lower = pivotIndices[0];\n+                upper = pivotIndices[1];\n@@ -1039,5 +1196,2 @@\n-                 * The first and the last elements to be sorted are moved\n-                 * to the locations formerly occupied by the pivots. When\n-                 * partitioning is completed, the pivots are swapped back\n-                 * into their final positions, and excluded from the next\n-                 * subsequent sorting.\n+                 * Sort non-left parts recursively (possibly in parallel),\n+                 * excluding known pivots.\n@@ -1045,2 +1199,9 @@\n-                a[e1] = a[lower];\n-                a[e5] = a[upper];\n+                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+                    sorter.forkSorter(bits | 1, lower + 1, upper);\n+                    sorter.forkSorter(bits | 1, upper + 1, high);\n+                } else {\n+                    sort(sorter, a, bits | 1, lower + 1, upper);\n+                    sort(sorter, a, bits | 1, upper + 1, high);\n+                }\n+\n+            } else { \/\/ Use single pivot in case of many equal elements\n@@ -1049,1 +1210,2 @@\n-                 * Skip elements, which are less or greater than the pivots.\n+                 * Use the third of the five sorted elements as the pivot.\n+                 * This value is inexpensive approximation of the median.\n@@ -1051,3 +1213,4 @@\n-                while (a[++lower] < pivot1);\n-                while (a[--upper] > pivot2);\n-\n+                pivotIndices = new int[] {e3, e3};\n+                Arrays.arrayPartition(long.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n+                lower = pivotIndices[0];\n+                upper = pivotIndices[1];\n@@ -1055,17 +1218,3 @@\n-                 * Backward 3-interval partitioning\n-                 *\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n-                 *\n-                 * Pointer k is the last index of ?-part\n+                 * Sort the right part (possibly in parallel), excluding\n+                 * known pivot. All elements from the central part are\n+                 * equal and therefore already sorted.\n@@ -1073,2 +1222,9 @@\n-                for (int unused = --lower, k = ++upper; --k > lower; ) {\n-                    long ak = a[k];\n+                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+                    sorter.forkSorter(bits | 1, upper, high);\n+                } else {\n+                    sort(sorter, a, bits | 1, upper, high);\n+                }\n+            }\n+            high = lower; \/\/ Iterate along the left part\n+        }\n+    }\n@@ -1076,18 +1232,14 @@\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n-                                break;\n-                            }\n-                        }\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n-                        a[k] = a[--upper];\n-                        a[upper] = ak;\n-                    }\n-                }\n+    \/**\n+     * Partitions the specified range of the array using the two pivots specified.\n+     *\n+     * @param array the array to be partitioned\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndices an array containing the indices of the two pivots to be used.\n+     * After partitioning, this array the indices of the pivots is updated as well.\n+     *\n+     *\/\n+    private static void partitionDualPivot(long[] a, int low, int high, int[] pivotIndices) {\n+        int end = high - 1;\n+        int lower = low;\n+        int upper = end;\n@@ -1095,5 +1247,4 @@\n-                \/*\n-                 * Swap the pivots into their final positions.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot1;\n-                a[end] = a[upper]; a[upper] = pivot2;\n+        int e1 = pivotIndices[0];\n+        int e5 = pivotIndices[1];\n+        long pivot1 = a[e1];\n+        long pivot2 = a[e5];\n@@ -1101,11 +1252,9 @@\n-                \/*\n-                 * Sort non-left parts recursively (possibly in parallel),\n-                 * excluding known pivots.\n-                 *\/\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n-                } else {\n-                    sort(sorter, a, bits | 1, lower + 1, upper);\n-                    sort(sorter, a, bits | 1, upper + 1, high);\n-                }\n+        \/*\n+        * The first and the last elements to be sorted are moved\n+        * to the locations formerly occupied by the pivots. When\n+        * partitioning is completed, the pivots are swapped back\n+        * into their final positions, and excluded from the next\n+        * subsequent sorting.\n+        *\/\n+        a[e1] = a[lower];\n+        a[e5] = a[upper];\n@@ -1113,1 +1262,5 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+        \/*\n+        * Skip elements, which are less or greater than the pivots.\n+        *\/\n+        while (a[++lower] < pivot1);\n+        while (a[--upper] > pivot2);\n@@ -1115,5 +1268,40 @@\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                long pivot = a[e3];\n+        \/*\n+        * Backward 3-interval partitioning\n+        *\n+        *   left part                 central part          right part\n+        * +------------------------------------------------------------+\n+                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n+        * +------------------------------------------------------------+\n+        *             ^       ^                            ^\n+        *             |       |                            |\n+        *           lower     k                          upper\n+        *\n+        * Invariants:\n+        *\n+        *              all in (low, lower] < pivot1\n+        *    pivot1 <= all in (k, upper)  <= pivot2\n+        *              all in [upper, end) > pivot2\n+        *\n+        * Pointer k is the last index of ?-part\n+        *\/\n+        for (int unused = --lower, k = ++upper; --k > lower; ) {\n+            long ak = a[k];\n+\n+            if (ak < pivot1) { \/\/ Move a[k] to the left side\n+                while (lower < k) {\n+                    if (a[++lower] >= pivot1) {\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n+                        }\n+                        a[lower] = ak;\n+                        break;\n+                    }\n+                }\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                a[k] = a[--upper];\n+                a[upper] = ak;\n+            }\n+        }\n@@ -1121,8 +1309,5 @@\n-                \/*\n-                 * The first element to be sorted is moved to the\n-                 * location formerly occupied by the pivot. After\n-                 * completion of partitioning the pivot is swapped\n-                 * back into its final position, and excluded from\n-                 * the next subsequent sorting.\n-                 *\/\n-                a[e3] = a[lower];\n+        \/*\n+         * Swap the pivots into their final positions.\n+         *\/\n+        a[low] = a[lower]; a[lower] = pivot1;\n+        a[end] = a[upper]; a[upper] = pivot2;\n@@ -1130,21 +1315,3 @@\n-                \/*\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n-                 *\n-                 *   left part                 central part    right part\n-                 * +------------------------------------------------------+\n-                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-                 * +------------------------------------------------------+\n-                 *              ^           ^                ^\n-                 *              |           |                |\n-                 *            lower         k              upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int k = ++upper; --k > lower; ) {\n-                    long ak = a[k];\n+        pivotIndices[0] = lower;\n+        pivotIndices[1] = upper;\n+    }\n@@ -1152,2 +1319,0 @@\n-                    if (ak != pivot) {\n-                        a[k] = pivot;\n@@ -1155,2 +1320,14 @@\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n-                            while (a[++lower] < pivot);\n+    \/**\n+     * Partitions the specified range of the array using a single pivot specified.\n+     *\n+     * @param array the array to be partitioned\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndices an array containing the indices of the pivot to be used.\n+     * After partitioning, this array the indices of the pivots is updated as well.\n+     *\n+     *\/\n+    private static void partitionSinglePivot(long[] a, int low, int high, int[] pivotIndices) {\n+        int end = high - 1;\n+        int lower = low;\n+        int upper = end;\n@@ -1158,9 +1335,2 @@\n-                            if (a[lower] > pivot) {\n-                                a[--upper] = a[lower];\n-                            }\n-                            a[lower] = ak;\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n-                            a[--upper] = ak;\n-                        }\n-                    }\n-                }\n+        int e3 = pivotIndices[0];\n+        long pivot = a[e3];\n@@ -1168,4 +1338,8 @@\n-                \/*\n-                 * Swap the pivot into its final position.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot;\n+        \/*\n+        * The first element to be sorted is moved to the\n+        * location formerly occupied by the pivot. After\n+        * completion of partitioning the pivot is swapped\n+        * back into its final position, and excluded from\n+        * the next subsequent sorting.\n+        *\/\n+        a[e3] = a[lower];\n@@ -1173,9 +1347,34 @@\n-                \/*\n-                 * Sort the right part (possibly in parallel), excluding\n-                 * known pivot. All elements from the central part are\n-                 * equal and therefore already sorted.\n-                 *\/\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.forkSorter(bits | 1, upper, high);\n-                } else {\n-                    sort(sorter, a, bits | 1, upper, high);\n+        \/*\n+        * Traditional 3-way (Dutch National Flag) partitioning\n+        *\n+        *   left part                 central part    right part\n+        * +------------------------------------------------------+\n+        * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n+        * +------------------------------------------------------+\n+        *              ^           ^                ^\n+        *              |           |                |\n+        *            lower         k              upper\n+        *\n+        * Invariants:\n+        *\n+        *   all in (low, lower] < pivot\n+        *   all in (k, upper)  == pivot\n+        *   all in [upper, end] > pivot\n+        *\n+        * Pointer k is the last index of ?-part\n+        *\/\n+        for (int k = ++upper; --k > lower; ) {\n+            long ak = a[k];\n+\n+            if (ak != pivot) {\n+                a[k] = pivot;\n+\n+                if (ak < pivot) { \/\/ Move a[k] to the left side\n+                    while (a[++lower] < pivot);\n+\n+                    if (a[lower] > pivot) {\n+                        a[--upper] = a[lower];\n+                    }\n+                    a[lower] = ak;\n+                } else { \/\/ ak > pivot - Move a[k] to the right side\n+                    a[--upper] = ak;\n@@ -1184,1 +1383,0 @@\n-            high = lower; \/\/ Iterate along the left part\n@@ -1186,0 +1384,7 @@\n+\n+        \/*\n+            * Swap the pivot into its final position.\n+            *\/\n+        a[low] = a[lower]; a[lower] = pivot;\n+        pivotIndices[0] = lower;\n+        pivotIndices[1] = upper;\n@@ -2476,0 +2681,2 @@\n+            int[] pivotIndices;\n+            int baseOffset = Unsafe.ARRAY_FLOAT_BASE_OFFSET;\n@@ -2481,1 +2688,1 @@\n-                mixedInsertionSort(a, low, high - 3 * ((size >> 5) << 3), high);\n+                Arrays.arraySort(float.class, a, baseOffset, low, high, high - 3 * ((size >> 5) << 3));\n@@ -2489,1 +2696,1 @@\n-                insertionSort(a, low, high);\n+                Arrays.arraySort(float.class, a, baseOffset, low, high, -1);\n@@ -2569,1 +2776,2 @@\n-            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n+            boolean isDualPivot = (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]);\n+            if(isDualPivot)  {\n@@ -2576,66 +2784,4 @@\n-                float pivot1 = a[e1];\n-                float pivot2 = a[e5];\n-\n-                \/*\n-                 * The first and the last elements to be sorted are moved\n-                 * to the locations formerly occupied by the pivots. When\n-                 * partitioning is completed, the pivots are swapped back\n-                 * into their final positions, and excluded from the next\n-                 * subsequent sorting.\n-                 *\/\n-                a[e1] = a[lower];\n-                a[e5] = a[upper];\n-\n-                \/*\n-                 * Skip elements, which are less or greater than the pivots.\n-                 *\/\n-                while (a[++lower] < pivot1);\n-                while (a[--upper] > pivot2);\n-\n-                \/*\n-                 * Backward 3-interval partitioning\n-                 *\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int unused = --lower, k = ++upper; --k > lower; ) {\n-                    float ak = a[k];\n-\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n-                                break;\n-                            }\n-                        }\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n-                        a[k] = a[--upper];\n-                        a[upper] = ak;\n-                    }\n-                }\n-\n-                \/*\n-                 * Swap the pivots into their final positions.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot1;\n-                a[end] = a[upper]; a[upper] = pivot2;\n-\n+                pivotIndices = new int[] {e1, e5};\n+                Arrays.arrayPartition(float.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n+                lower = pivotIndices[0];\n+                upper = pivotIndices[1];\n@@ -2660,2 +2806,4 @@\n-                float pivot = a[e3];\n-\n+                pivotIndices = new int[] {e3, e3};\n+                Arrays.arrayPartition(float.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n+                lower = pivotIndices[0];\n+                upper = pivotIndices[1];\n@@ -2663,5 +2811,3 @@\n-                 * The first element to be sorted is moved to the\n-                 * location formerly occupied by the pivot. After\n-                 * completion of partitioning the pivot is swapped\n-                 * back into its final position, and excluded from\n-                 * the next subsequent sorting.\n+                 * Sort the right part (possibly in parallel), excluding\n+                 * known pivot. All elements from the central part are\n+                 * equal and therefore already sorted.\n@@ -2669,1 +2815,9 @@\n-                a[e3] = a[lower];\n+                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+                    sorter.forkSorter(bits | 1, upper, high);\n+                } else {\n+                    sort(sorter, a, bits | 1, upper, high);\n+                }\n+            }\n+            high = lower; \/\/ Iterate along the left part\n+        }\n+    }\n@@ -2671,21 +2825,14 @@\n-                \/*\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n-                 *\n-                 *   left part                 central part    right part\n-                 * +------------------------------------------------------+\n-                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-                 * +------------------------------------------------------+\n-                 *              ^           ^                ^\n-                 *              |           |                |\n-                 *            lower         k              upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int k = ++upper; --k > lower; ) {\n-                    float ak = a[k];\n+    \/**\n+     * Partitions the specified range of the array using the two pivots specified.\n+     *\n+     * @param array the array to be partitioned\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndices an array containing the indices of the two pivots to be used.\n+     * After partitioning, this array the indices of the pivots is updated as well.\n+     *\n+     *\/\n+    private static void partitionDualPivot(float[] a, int low, int high, int[] pivotIndices) {\n+        int end = high - 1;\n+        int lower = low;\n+        int upper = end;\n@@ -2693,2 +2840,4 @@\n-                    if (ak != pivot) {\n-                        a[k] = pivot;\n+        int e1 = pivotIndices[0];\n+        int e5 = pivotIndices[1];\n+        float pivot1 = a[e1];\n+        float pivot2 = a[e5];\n@@ -2696,2 +2845,9 @@\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n-                            while (a[++lower] < pivot);\n+        \/*\n+        * The first and the last elements to be sorted are moved\n+        * to the locations formerly occupied by the pivots. When\n+        * partitioning is completed, the pivots are swapped back\n+        * into their final positions, and excluded from the next\n+        * subsequent sorting.\n+        *\/\n+        a[e1] = a[lower];\n+        a[e5] = a[upper];\n@@ -2699,6 +2855,36 @@\n-                            if (a[lower] > pivot) {\n-                                a[--upper] = a[lower];\n-                            }\n-                            a[lower] = ak;\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n-                            a[--upper] = ak;\n+        \/*\n+        * Skip elements, which are less or greater than the pivots.\n+        *\/\n+                while (a[++lower] < pivot1);\n+                while (a[--upper] > pivot2);\n+\n+        \/*\n+        * Backward 3-interval partitioning\n+        *\n+        *   left part                 central part          right part\n+        * +------------------------------------------------------------+\n+                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n+        * +------------------------------------------------------------+\n+        *             ^       ^                            ^\n+        *             |       |                            |\n+        *           lower     k                          upper\n+        *\n+        * Invariants:\n+        *\n+        *              all in (low, lower] < pivot1\n+        *    pivot1 <= all in (k, upper)  <= pivot2\n+        *              all in [upper, end) > pivot2\n+        *\n+        * Pointer k is the last index of ?-part\n+        *\/\n+        for (int unused = --lower, k = ++upper; --k > lower; ) {\n+            float ak = a[k];\n+\n+            if (ak < pivot1) { \/\/ Move a[k] to the left side\n+                while (lower < k) {\n+                    if (a[++lower] >= pivot1) {\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n@@ -2706,0 +2892,2 @@\n+                        a[lower] = ak;\n+                        break;\n@@ -2708,0 +2896,5 @@\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                a[k] = a[--upper];\n+                a[upper] = ak;\n+            }\n+        }\n@@ -2709,4 +2902,5 @@\n-                \/*\n-                 * Swap the pivot into its final position.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot;\n+        \/*\n+         * Swap the pivots into their final positions.\n+         *\/\n+        a[low] = a[lower]; a[lower] = pivot1;\n+        a[end] = a[upper]; a[upper] = pivot2;\n@@ -2714,9 +2908,66 @@\n-                \/*\n-                 * Sort the right part (possibly in parallel), excluding\n-                 * known pivot. All elements from the central part are\n-                 * equal and therefore already sorted.\n-                 *\/\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.forkSorter(bits | 1, upper, high);\n-                } else {\n-                    sort(sorter, a, bits | 1, upper, high);\n+        pivotIndices[0] = lower;\n+        pivotIndices[1] = upper;\n+    }\n+\n+\n+    \/**\n+     * Partitions the specified range of the array using a single pivot specified.\n+     *\n+     * @param array the array to be partitioned\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndices an array containing the indices of the pivot to be used.\n+     * After partitioning, this array the indices of the pivots is updated as well.\n+     *\n+     *\/\n+    private static void partitionSinglePivot(float[] a, int low, int high, int[] pivotIndices) {\n+        int end = high - 1;\n+        int lower = low;\n+        int upper = end;\n+\n+        int e3 = pivotIndices[0];\n+        float pivot = a[e3];\n+\n+        \/*\n+        * The first element to be sorted is moved to the\n+        * location formerly occupied by the pivot. After\n+        * completion of partitioning the pivot is swapped\n+        * back into its final position, and excluded from\n+        * the next subsequent sorting.\n+        *\/\n+        a[e3] = a[lower];\n+\n+        \/*\n+        * Traditional 3-way (Dutch National Flag) partitioning\n+        *\n+        *   left part                 central part    right part\n+        * +------------------------------------------------------+\n+        * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n+        * +------------------------------------------------------+\n+        *              ^           ^                ^\n+        *              |           |                |\n+        *            lower         k              upper\n+        *\n+        * Invariants:\n+        *\n+        *   all in (low, lower] < pivot\n+        *   all in (k, upper)  == pivot\n+        *   all in [upper, end] > pivot\n+        *\n+        * Pointer k is the last index of ?-part\n+        *\/\n+        for (int k = ++upper; --k > lower; ) {\n+            float ak = a[k];\n+\n+            if (ak != pivot) {\n+                a[k] = pivot;\n+\n+                if (ak < pivot) { \/\/ Move a[k] to the left side\n+                    while (a[++lower] < pivot);\n+\n+                    if (a[lower] > pivot) {\n+                        a[--upper] = a[lower];\n+                    }\n+                    a[lower] = ak;\n+                } else { \/\/ ak > pivot - Move a[k] to the right side\n+                    a[--upper] = ak;\n@@ -2725,1 +2976,0 @@\n-            high = lower; \/\/ Iterate along the left part\n@@ -2727,0 +2977,7 @@\n+\n+        \/*\n+            * Swap the pivot into its final position.\n+            *\/\n+        a[low] = a[lower]; a[lower] = pivot;\n+        pivotIndices[0] = lower;\n+        pivotIndices[1] = upper;\n@@ -3282,0 +3539,2 @@\n+            int[] pivotIndices;\n+            int baseOffset = Unsafe.ARRAY_DOUBLE_BASE_OFFSET;\n@@ -3287,1 +3546,1 @@\n-                mixedInsertionSort(a, low, high - 3 * ((size >> 5) << 3), high);\n+                Arrays.arraySort(double.class, a, baseOffset, low, high, high - 3 * ((size >> 5) << 3));\n@@ -3295,1 +3554,1 @@\n-                insertionSort(a, low, high);\n+                Arrays.arraySort(double.class, a, baseOffset, low, high, -1);\n@@ -3375,66 +3634,2 @@\n-            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n-\n-                \/*\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n-                 *\/\n-                double pivot1 = a[e1];\n-                double pivot2 = a[e5];\n-\n-                \/*\n-                 * The first and the last elements to be sorted are moved\n-                 * to the locations formerly occupied by the pivots. When\n-                 * partitioning is completed, the pivots are swapped back\n-                 * into their final positions, and excluded from the next\n-                 * subsequent sorting.\n-                 *\/\n-                a[e1] = a[lower];\n-                a[e5] = a[upper];\n-\n-                \/*\n-                 * Skip elements, which are less or greater than the pivots.\n-                 *\/\n-                while (a[++lower] < pivot1);\n-                while (a[--upper] > pivot2);\n-\n-                \/*\n-                 * Backward 3-interval partitioning\n-                 *\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int unused = --lower, k = ++upper; --k > lower; ) {\n-                    double ak = a[k];\n-\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n-                                break;\n-                            }\n-                        }\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n-                        a[k] = a[--upper];\n-                        a[upper] = ak;\n-                    }\n-                }\n+            boolean isDualPivot = (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]);\n+            if(isDualPivot)  {\n@@ -3443,5 +3638,8 @@\n-                 * Swap the pivots into their final positions.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot1;\n-                a[end] = a[upper]; a[upper] = pivot2;\n-\n+                * Use the first and fifth of the five sorted elements as\n+                * the pivots. These values are inexpensive approximation\n+                * of tertiles. Note, that pivot1 < pivot2.\n+                *\/\n+                pivotIndices = new int[] {e1, e5};\n+                Arrays.arrayPartition(double.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n+                lower = pivotIndices[0];\n+                upper = pivotIndices[1];\n@@ -3466,1 +3664,4 @@\n-                double pivot = a[e3];\n+                pivotIndices = new int[] {e3, e3};\n+                Arrays.arrayPartition(double.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n+                lower = pivotIndices[0];\n+                upper = pivotIndices[1];\n@@ -3469,5 +3670,3 @@\n-                 * The first element to be sorted is moved to the\n-                 * location formerly occupied by the pivot. After\n-                 * completion of partitioning the pivot is swapped\n-                 * back into its final position, and excluded from\n-                 * the next subsequent sorting.\n+                 * Sort the right part (possibly in parallel), excluding\n+                 * known pivot. All elements from the central part are\n+                 * equal and therefore already sorted.\n@@ -3475,1 +3674,9 @@\n-                a[e3] = a[lower];\n+                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+                    sorter.forkSorter(bits | 1, upper, high);\n+                } else {\n+                    sort(sorter, a, bits | 1, upper, high);\n+                }\n+            }\n+            high = lower; \/\/ Iterate along the left part\n+        }\n+    }\n@@ -3477,21 +3684,14 @@\n-                \/*\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n-                 *\n-                 *   left part                 central part    right part\n-                 * +------------------------------------------------------+\n-                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-                 * +------------------------------------------------------+\n-                 *              ^           ^                ^\n-                 *              |           |                |\n-                 *            lower         k              upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int k = ++upper; --k > lower; ) {\n-                    double ak = a[k];\n+    \/**\n+     * Partitions the specified range of the array using the two pivots specified.\n+     *\n+     * @param array the array to be partitioned\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndices an array containing the indices of the two pivots to be used.\n+     * After partitioning, this array the indices of the pivots is updated as well.\n+     *\n+     *\/\n+    private static void partitionDualPivot(double[] a, int low, int high, int[] pivotIndices) {\n+        int end = high - 1;\n+        int lower = low;\n+        int upper = end;\n@@ -3499,2 +3699,4 @@\n-                    if (ak != pivot) {\n-                        a[k] = pivot;\n+        int e1 = pivotIndices[0];\n+        int e5 = pivotIndices[1];\n+        double pivot1 = a[e1];\n+        double pivot2 = a[e5];\n@@ -3502,2 +3704,9 @@\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n-                            while (a[++lower] < pivot);\n+        \/*\n+        * The first and the last elements to be sorted are moved\n+        * to the locations formerly occupied by the pivots. When\n+        * partitioning is completed, the pivots are swapped back\n+        * into their final positions, and excluded from the next\n+        * subsequent sorting.\n+        *\/\n+        a[e1] = a[lower];\n+        a[e5] = a[upper];\n@@ -3505,6 +3714,36 @@\n-                            if (a[lower] > pivot) {\n-                                a[--upper] = a[lower];\n-                            }\n-                            a[lower] = ak;\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n-                            a[--upper] = ak;\n+        \/*\n+        * Skip elements, which are less or greater than the pivots.\n+        *\/\n+                while (a[++lower] < pivot1);\n+                while (a[--upper] > pivot2);\n+\n+        \/*\n+        * Backward 3-interval partitioning\n+        *\n+        *   left part                 central part          right part\n+        * +------------------------------------------------------------+\n+                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n+        * +------------------------------------------------------------+\n+        *             ^       ^                            ^\n+        *             |       |                            |\n+        *           lower     k                          upper\n+        *\n+        * Invariants:\n+        *\n+        *              all in (low, lower] < pivot1\n+        *    pivot1 <= all in (k, upper)  <= pivot2\n+        *              all in [upper, end) > pivot2\n+        *\n+        * Pointer k is the last index of ?-part\n+        *\/\n+        for (int unused = --lower, k = ++upper; --k > lower; ) {\n+            double ak = a[k];\n+\n+            if (ak < pivot1) { \/\/ Move a[k] to the left side\n+                while (lower < k) {\n+                    if (a[++lower] >= pivot1) {\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n@@ -3512,0 +3751,2 @@\n+                        a[lower] = ak;\n+                        break;\n@@ -3514,0 +3755,5 @@\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                a[k] = a[--upper];\n+                a[upper] = ak;\n+            }\n+        }\n@@ -3515,4 +3761,5 @@\n-                \/*\n-                 * Swap the pivot into its final position.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot;\n+        \/*\n+         * Swap the pivots into their final positions.\n+         *\/\n+        a[low] = a[lower]; a[lower] = pivot1;\n+        a[end] = a[upper]; a[upper] = pivot2;\n@@ -3520,9 +3767,66 @@\n-                \/*\n-                 * Sort the right part (possibly in parallel), excluding\n-                 * known pivot. All elements from the central part are\n-                 * equal and therefore already sorted.\n-                 *\/\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.forkSorter(bits | 1, upper, high);\n-                } else {\n-                    sort(sorter, a, bits | 1, upper, high);\n+        pivotIndices[0] = lower;\n+        pivotIndices[1] = upper;\n+    }\n+\n+\n+\n+    \/**\n+     * Partitions the specified range of the array using a single pivot specified.\n+     *\n+     * @param array the array to be partitioned\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndices an array containing the indices of the pivot to be used.\n+     * After partitioning, this array the indices of the pivots is updated as well.\n+     *\/\n+    private static void partitionSinglePivot(double[] a, int low, int high, int[] pivotIndices) {\n+        int end = high - 1;\n+        int lower = low;\n+        int upper = end;\n+\n+        int e3 = pivotIndices[0];\n+        double pivot = a[e3];\n+\n+        \/*\n+        * The first element to be sorted is moved to the\n+        * location formerly occupied by the pivot. After\n+        * completion of partitioning the pivot is swapped\n+        * back into its final position, and excluded from\n+        * the next subsequent sorting.\n+        *\/\n+        a[e3] = a[lower];\n+\n+        \/*\n+        * Traditional 3-way (Dutch National Flag) partitioning\n+        *\n+        *   left part                 central part    right part\n+        * +------------------------------------------------------+\n+        * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n+        * +------------------------------------------------------+\n+        *              ^           ^                ^\n+        *              |           |                |\n+        *            lower         k              upper\n+        *\n+        * Invariants:\n+        *\n+        *   all in (low, lower] < pivot\n+        *   all in (k, upper)  == pivot\n+        *   all in [upper, end] > pivot\n+        *\n+        * Pointer k is the last index of ?-part\n+        *\/\n+        for (int k = ++upper; --k > lower; ) {\n+            double ak = a[k];\n+\n+            if (ak != pivot) {\n+                a[k] = pivot;\n+\n+                if (ak < pivot) { \/\/ Move a[k] to the left side\n+                    while (a[++lower] < pivot);\n+\n+                    if (a[lower] > pivot) {\n+                        a[--upper] = a[lower];\n+                    }\n+                    a[lower] = ak;\n+                } else { \/\/ ak > pivot - Move a[k] to the right side\n+                    a[--upper] = ak;\n@@ -3531,1 +3835,0 @@\n-            high = lower; \/\/ Iterate along the left part\n@@ -3533,0 +3836,7 @@\n+\n+        \/*\n+            * Swap the pivot into its final position.\n+            *\/\n+        a[low] = a[lower]; a[lower] = pivot;\n+        pivotIndices[0] = lower;\n+        pivotIndices[1] = upper;\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":809,"deletions":499,"binary":false,"changes":1308,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+@Fork(value=1, jvmArgsAppend={\"-XX:CompileThreshold=1\", \"-XX:-TieredCompilation\"})\n@@ -53,1 +54,2 @@\n-@Fork(value = 1)\n+@Warmup(iterations = 3, time=5)\n+@Measurement(iterations = 3, time=3)\n@@ -56,0 +58,3 @@\n+    @Param({\"10\",\"25\",\"50\",\"75\",\"100\", \"1000\", \"10000\", \"100000\", \"1000000\"})\n+    private int size;\n+\n@@ -67,1 +72,1 @@\n-    public void initialize(int size) {\n+    public void initialize() {\n@@ -75,0 +80,2 @@\n+        int[] intSpecialCases = {Integer.MIN_VALUE, Integer.MAX_VALUE};\n+        long[] longSpecialCases = {Long.MIN_VALUE, Long.MAX_VALUE};\n@@ -82,0 +89,2 @@\n+                ints_unsorted[i] = rnd.nextInt();\n+                longs_unsorted[i] = rnd.nextLong();\n@@ -85,3 +94,4 @@\n-                int rndIdx = rnd.nextInt(doubleSpecialCases.length);\n-                floats_unsorted[i] = floatSpecialCases[rndIdx];\n-                doubles_unsorted[i] = doubleSpecialCases[rndIdx];\n+                ints_unsorted[i] = intSpecialCases[rnd.nextInt(intSpecialCases.length)];\n+                longs_unsorted[i] = longSpecialCases[rnd.nextInt(longSpecialCases.length)];\n+                floats_unsorted[i] = floatSpecialCases[rnd.nextInt(floatSpecialCases.length)];\n+                doubles_unsorted[i] = doubleSpecialCases[rnd.nextInt(doubleSpecialCases.length)];\n@@ -92,0 +102,5 @@\n+    @Setup\n+    public void setup() throws UnsupportedEncodingException, ClassNotFoundException, NoSuchMethodException, Throwable {\n+        initialize();\n+    }\n+\n@@ -124,48 +139,0 @@\n-    @Warmup(iterations = 3, time=2)\n-    @Measurement(iterations = 3, time=5)\n-    public static class Small extends ArraysSort {\n-        @Param({\"10\",\"25\",\"50\",\"75\",\"100\"})\n-        private int size;\n-\n-        @Setup\n-        public void setup() throws UnsupportedEncodingException, ClassNotFoundException, NoSuchMethodException, Throwable {\n-            initialize(size);\n-        }\n-    }\n-\n-    @Warmup(iterations = 3, time=2)\n-    @Measurement(iterations = 3, time=5)\n-    public static class Medium extends ArraysSort {\n-        @Param({\"1000\", \"10000\"})\n-        private int size;\n-\n-        @Setup\n-        public void setup() throws UnsupportedEncodingException, ClassNotFoundException, NoSuchMethodException, Throwable {\n-            initialize(size);\n-        }\n-    }\n-\n-    @Warmup(iterations = 3, time=40)\n-    @Measurement(iterations = 3, time=30)\n-    public static class Large extends ArraysSort {\n-        @Param({\"50000\", \"100000\"})\n-        private int size;\n-\n-        @Setup\n-        public void setup() throws UnsupportedEncodingException, ClassNotFoundException, NoSuchMethodException, Throwable {\n-            initialize(size);\n-        }\n-    }\n-\n-    @Warmup(iterations = 3, time=120)\n-    @Measurement(iterations = 3, time=30)\n-    public static class VeryLarge extends ArraysSort {\n-        @Param({\"1000000\"})\n-        private int size;\n-\n-        @Setup\n-        public void setup() throws UnsupportedEncodingException, ClassNotFoundException, NoSuchMethodException, Throwable {\n-            initialize(size);\n-        }\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/ArraysSort.java","additions":20,"deletions":53,"binary":false,"changes":73,"status":"modified"}]}