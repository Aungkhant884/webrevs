{"files":[{"patch":"@@ -236,0 +236,22 @@\n+\n+################################################################################\n+\n+ifeq ($(call isTargetOs, linux)+$(call isTargetCpu, x86_64)+$(INCLUDE_COMPILER2), true+true+true)\n+  ifeq ($(TOOLCHAIN_TYPE), gcc)\n+    $(eval $(call SetupJdkLibrary, BUILD_LIB_SIMD_SORT, \\\n+        NAME := simdsort, \\\n+        TOOLCHAIN := TOOLCHAIN_LINK_CXX, \\\n+        OPTIMIZATION := HIGH, \\\n+        CFLAGS := $(CFLAGS_JDKLIB), \\\n+        CXXFLAGS := $(CXXFLAGS_JDKLIB), \\\n+        LDFLAGS := $(LDFLAGS_JDKLIB) \\\n+            $(call SET_SHARED_LIBRARY_ORIGIN), \\\n+        LIBS := $(LIBCXX), \\\n+        LIBS_linux := -lc -lm -ldl, \\\n+    ))\n+\n+    TARGETS += $(BUILD_LIB_SIMD_SORT)\n+  endif\n+endif\n+\n+################################################################################\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -4182,0 +4182,51 @@\n+  \/\/ Load x86_64_sort library on supported hardware to enable avx512 sort and partition intrinsics\n+    if (UseAVX > 2 && VM_Version::supports_avx512dq()) {\n+\n+      void *libsimdsort = nullptr;\n+      char ebuf_[1024];\n+      char dll_name_simd_sort[JVM_MAXPATHLEN];\n+      if (os::dll_locate_lib(dll_name_simd_sort, sizeof(dll_name_simd_sort), Arguments::get_dll_dir(), \"simdsort\")) {\n+        libsimdsort = os::dll_load(dll_name_simd_sort, ebuf_, sizeof ebuf_);\n+      }\n+    \/\/ Get addresses for avx512 sort and partition routines\n+    if (libsimdsort != nullptr) {\n+      log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, JNI_LIB_PREFIX \"x86_64\" JNI_LIB_SUFFIX, p2i(libsimdsort));\n+\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_sort_int\");\n+      StubRoutines::_arraysort_int = (address)os::dll_lookup(libsimdsort, ebuf_);\n+\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_sort_long\");\n+      StubRoutines::_arraysort_long = (address)os::dll_lookup(libsimdsort, ebuf_);\n+\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_sort_float\");\n+      StubRoutines::_arraysort_float = (address)os::dll_lookup(libsimdsort, ebuf_);\n+\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_sort_double\");\n+      StubRoutines::_arraysort_double = (address)os::dll_lookup(libsimdsort, ebuf_);\n+\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_partition_single_int\");\n+      StubRoutines::_array_partition_single_int = (address)os::dll_lookup(libsimdsort, ebuf_);\n+\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_partition_dual_int\");\n+      StubRoutines::_array_partition_dual_int = (address)os::dll_lookup(libsimdsort, ebuf_);\n+\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_partition_single_long\");\n+      StubRoutines::_array_partition_single_long = (address)os::dll_lookup(libsimdsort, ebuf_);\n+\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_partition_dual_long\");\n+      StubRoutines::_array_partition_dual_long = (address)os::dll_lookup(libsimdsort, ebuf_);\n+\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_partition_single_float\");\n+      StubRoutines::_array_partition_single_float = (address)os::dll_lookup(libsimdsort, ebuf_);\n+\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_partition_dual_float\");\n+      StubRoutines::_array_partition_dual_float = (address)os::dll_lookup(libsimdsort, ebuf_);\n+\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_partition_single_double\");\n+      StubRoutines::_array_partition_single_double = (address)os::dll_lookup(libsimdsort, ebuf_);\n+\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_partition_dual_double\");\n+      StubRoutines::_array_partition_dual_double = (address)os::dll_lookup(libsimdsort, ebuf_);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -344,0 +344,15 @@\n+  do_intrinsic(_arraySortMI, java_util_DualPivotQuicksort, arraySortMI_name, arraySortMI_signature, F_S)                \\\n+   do_name(     arraySortMI_name,                                  \"mixedInsertionSort\")                                \\\n+   do_signature(arraySortMI_signature,          \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JIII)V\")                            \\\n+  do_intrinsic(_arraySortI, java_util_DualPivotQuicksort, arraySortI_name, arraySortI_signature, F_S)                   \\\n+   do_name(     arraySortI_name,                                   \"insertionSort\")                                     \\\n+   do_signature(arraySortI_signature,          \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JII)V\")                             \\\n+                                                                                                                        \\\n+  do_intrinsic(_arrayPartitionSP, java_util_DualPivotQuicksort, arrayPartitionSP_name, arrayPartitionSP_signature, F_S) \\\n+   do_name(     arrayPartitionSP_name,                             \"partitionSinglePivot\")                              \\\n+  do_signature(arrayPartitionSP_signature,      \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JIII)[I\")                          \\\n+  do_intrinsic(_arrayPartitionDP, java_util_DualPivotQuicksort, arrayPartitionDP_name, arrayPartitionDP_signature, F_S) \\\n+   do_name(     arrayPartitionDP_name,                             \"partitionDualPivot\")                                \\\n+  do_signature(arrayPartitionDP_signature,      \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JIIII)[I\")                         \\\n+                                                                                                                        \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -148,0 +148,1 @@\n+  template(java_util_DualPivotQuicksort,              \"java\/util\/DualPivotQuicksort\")             \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -390,0 +390,6 @@\n+        \"array_partition_stub\",\n+        { { TypeFunc::Parms, ShenandoahStore }, { TypeFunc::Parms+3, ShenandoahStore },   { -1, ShenandoahNone },\n+          { -1, ShenandoahNone },                { -1, ShenandoahNone },                  { -1, ShenandoahNone } },\n+        \"arraysort_stub\",\n+        { { TypeFunc::Parms, ShenandoahStore },  { -1, ShenandoahNone },                  { -1, ShenandoahNone },\n+          { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -330,0 +330,12 @@\n+  static_field(StubRoutines,                _arraysort_int,                                   address)                               \\\n+  static_field(StubRoutines,                _arraysort_long,                                  address)                               \\\n+  static_field(StubRoutines,                _arraysort_float,                                 address)                               \\\n+  static_field(StubRoutines,                _arraysort_double,                                address)                               \\\n+  static_field(StubRoutines,                _array_partition_single_int,                      address)                               \\\n+  static_field(StubRoutines,                _array_partition_dual_int,                        address)                               \\\n+  static_field(StubRoutines,                _array_partition_single_long,                     address)                               \\\n+  static_field(StubRoutines,                _array_partition_dual_long,                       address)                               \\\n+  static_field(StubRoutines,                _array_partition_single_float,                    address)                               \\\n+  static_field(StubRoutines,                _array_partition_dual_float,                      address)                               \\\n+  static_field(StubRoutines,                _array_partition_single_double,                   address)                               \\\n+  static_field(StubRoutines,                _array_partition_dual_double,                     address)                               \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -600,0 +600,4 @@\n+  case vmIntrinsics::_arraySortMI:\n+  case vmIntrinsics::_arraySortI:\n+  case vmIntrinsics::_arrayPartitionSP:\n+  case vmIntrinsics::_arrayPartitionDP:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1578,0 +1578,2 @@\n+                  strcmp(call->as_CallLeaf()->_name, \"arraysort_stub\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"array_partition_stub\") == 0 ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -296,0 +296,6 @@\n+  case vmIntrinsics::_arraySortMI:\n+  case vmIntrinsics::_arraySortI:               return inline_arraysort();\n+\n+  case vmIntrinsics::_arrayPartitionSP:         return inline_array_partition(false \/* single pivot*\/);\n+  case vmIntrinsics::_arrayPartitionDP:         return inline_array_partition(true \/* dual pivot*\/);\n+\n@@ -5366,0 +5372,90 @@\n+\/\/------------------------------inline_array_partition-----------------------\n+bool LibraryCallKit::inline_array_partition(bool is_dual_pivot) {\n+\n+  address stubAddr = nullptr;\n+  const char *stubName;\n+  stubName = \"array_partition_stub\";\n+\n+  Node* elementType     = null_check(argument(0));\n+  Node* obj             = argument(1);\n+  Node* offset          = argument(2);\n+  Node* fromIndex       = argument(4);\n+  Node* toIndex         = argument(5);\n+  Node* indexPivot1     = argument(6);\n+  Node* indexPivot2     = is_dual_pivot? argument(7) : nullptr;\n+\n+  const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  BasicType bt = elem_type->basic_type();\n+  stubAddr = StubRoutines::select_array_partition_function(bt, is_dual_pivot);\n+  \/\/ stub not loaded\n+  if (stubAddr == nullptr) {\n+    return false;\n+  }\n+  \/\/ get the address of the array\n+  const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n+  if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n+    return false; \/\/ failed input validation\n+  }\n+  Node* obj_adr = make_unsafe_address(obj, offset);\n+\n+  \/\/ create the pivotIndices array of type int and size = 2\n+  Node* pivotIndices = nullptr;\n+  Node* size = intcon(2);\n+  Node* klass_node = makecon(TypeKlassPtr::make(ciTypeArrayKlass::make(T_INT)));\n+  pivotIndices = new_array(klass_node, size, 0);  \/\/ no arguments to push\n+  AllocateArrayNode* alloc = tightly_coupled_allocation(pivotIndices);\n+  guarantee(alloc != nullptr, \"created above\");\n+  Node* pivotIndices_adr = basic_plus_adr(pivotIndices, arrayOopDesc::base_offset_in_bytes(T_INT));\n+\n+  \/\/ Call the stub\n+  make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::array_partition_Type(is_dual_pivot),\n+                    stubAddr, stubName, TypePtr::BOTTOM,\n+                    obj_adr, fromIndex, toIndex, pivotIndices_adr, indexPivot1, indexPivot2);\n+\n+  if (!stopped()) {\n+    set_result(pivotIndices);\n+  }\n+\n+  return true;\n+}\n+\n+\n+\/\/------------------------------inline_arraysort-----------------------\n+bool LibraryCallKit::inline_arraysort() {\n+\n+  address stubAddr = nullptr;\n+  const char *stubName;\n+  stubName = \"arraysort_stub\";\n+\n+  Node* elementType     = null_check(argument(0));\n+  Node* obj             = argument(1);\n+  Node* offset          = argument(2);\n+  Node* fromIndex       = argument(4);\n+  Node* toIndex         = argument(5);\n+\n+  const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  BasicType bt = elem_type->basic_type();\n+  stubAddr = StubRoutines::select_arraysort_function(bt);\n+  \/\/stub not loaded\n+  if (stubAddr == nullptr) {\n+    return false;\n+  }\n+\n+  \/\/ get address of the array\n+  const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n+  if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n+    return false; \/\/ failed input validation\n+  }\n+  Node* obj_adr = make_unsafe_address(obj, offset);\n+\n+  \/\/ Call the stub.\n+  make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::array_sort_Type(),\n+                    stubAddr, stubName, TypePtr::BOTTOM,\n+                    obj_adr, fromIndex, toIndex);\n+\n+  return true;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":96,"deletions":0,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -280,1 +280,2 @@\n-\n+  bool inline_arraysort();\n+  bool inline_array_partition(bool is_dual_pivot);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -860,0 +860,43 @@\n+const TypeFunc* OptoRuntime::array_partition_Type(bool is_dual_pivot) {\n+  \/\/ create input type (domain)\n+  int num_args = is_dual_pivot ? 6 : 5;\n+  int argcnt = num_args;\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;  \/\/ array\n+  fields[argp++] = TypeInt::INT;      \/\/ low\n+  fields[argp++] = TypeInt::INT;      \/\/ end\n+  fields[argp++] = TypePtr::NOTNULL;  \/\/ pivot_indices (int array)\n+  fields[argp++] = TypeInt::INT;      \/\/ indexPivot1\n+  if (is_dual_pivot) {\n+    fields[argp++] = TypeInt::INT;    \/\/ indexPivot2\n+  }\n+  assert(argp == TypeFunc::Parms+argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ no result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n+  return TypeFunc::make(domain, range);\n+}\n+\n+const TypeFunc* OptoRuntime::array_sort_Type() {\n+  \/\/ create input type (domain)\n+  int num_args      = 3;\n+  int argcnt = num_args;\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ array\n+  fields[argp++] = TypeInt::INT;    \/\/ fromIndex\n+  fields[argp++] = TypeInt::INT;    \/\/ toIndex\n+  assert(argp == TypeFunc::Parms+argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ no result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n+  return TypeFunc::make(domain, range);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -271,0 +271,2 @@\n+  static const TypeFunc* array_sort_Type();\n+  static const TypeFunc* array_partition_Type(bool is_dual_pivot);\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -179,0 +179,13 @@\n+address StubRoutines::_arraysort_int = nullptr;\n+address StubRoutines::_arraysort_long = nullptr;\n+address StubRoutines::_arraysort_float = nullptr;\n+address StubRoutines::_arraysort_double = nullptr;\n+address StubRoutines::_array_partition_single_int  = nullptr;\n+address StubRoutines::_array_partition_dual_int  = nullptr;\n+address StubRoutines::_array_partition_single_long = nullptr;\n+address StubRoutines::_array_partition_dual_long = nullptr;\n+address StubRoutines::_array_partition_single_float = nullptr;\n+address StubRoutines::_array_partition_dual_float = nullptr;\n+address StubRoutines::_array_partition_single_double = nullptr;\n+address StubRoutines::_array_partition_dual_double = nullptr;\n+\n@@ -534,0 +547,24 @@\n+\n+address StubRoutines::select_arraysort_function(BasicType t) {\n+  switch(t) {\n+    case T_INT:    return _arraysort_int;\n+    case T_LONG:   return _arraysort_long;\n+    case T_FLOAT:  return _arraysort_float;\n+    case T_DOUBLE: return _arraysort_double;\n+  default:\n+    ShouldNotReachHere();\n+    return nullptr;\n+  }\n+}\n+\n+address StubRoutines::select_array_partition_function(BasicType t, bool is_dual_pivot) {\n+  switch(t) {\n+    case T_INT:    return is_dual_pivot ? _array_partition_dual_int : _array_partition_single_int;\n+    case T_LONG:   return is_dual_pivot ? _array_partition_dual_long : _array_partition_single_long;\n+    case T_FLOAT:  return is_dual_pivot ? _array_partition_dual_float : _array_partition_single_float;\n+    case T_DOUBLE: return is_dual_pivot ? _array_partition_dual_double : _array_partition_single_double;\n+  default:\n+    ShouldNotReachHere();\n+    return nullptr;\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -156,0 +156,12 @@\n+  static address _arraysort_int;\n+  static address _arraysort_long;\n+  static address _arraysort_float;\n+  static address _arraysort_double;\n+  static address _array_partition_single_int;\n+  static address _array_partition_dual_int;\n+  static address _array_partition_single_long;\n+  static address _array_partition_dual_long;\n+  static address _array_partition_single_float;\n+  static address _array_partition_dual_float;\n+  static address _array_partition_single_double;\n+  static address _array_partition_dual_double;\n@@ -378,0 +390,2 @@\n+  static address select_arraysort_function(BasicType t);\n+  static address select_array_partition_function(BasicType t, bool is_dual_pivot);\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,443 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2021 Serge Sans Paille. All rights reserved.\n+ * Intel x86-simd-sort source code.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This implementation is based on x86-simd-sort(https:\/\/github.com\/intel\/x86-simd-sort)\n+\n+#ifndef AVX512_QSORT_32BIT\n+#define AVX512_QSORT_32BIT\n+\n+#include \"avx512-common-qsort.h\"\n+\n+\/*\n+ * Constants used in sorting 16 elements in a ZMM registers. Based on Bitonic\n+ * sorting network (see\n+ * https:\/\/en.wikipedia.org\/wiki\/Bitonic_sorter#\/media\/File:BitonicSort.svg)\n+ *\/\n+#define NETWORK_32BIT_1 14, 15, 12, 13, 10, 11, 8, 9, 6, 7, 4, 5, 2, 3, 0, 1\n+#define NETWORK_32BIT_2 12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3\n+#define NETWORK_32BIT_3 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7\n+#define NETWORK_32BIT_4 13, 12, 15, 14, 9, 8, 11, 10, 5, 4, 7, 6, 1, 0, 3, 2\n+#define NETWORK_32BIT_5 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\n+#define NETWORK_32BIT_6 11, 10, 9, 8, 15, 14, 13, 12, 3, 2, 1, 0, 7, 6, 5, 4\n+#define NETWORK_32BIT_7 7, 6, 5, 4, 3, 2, 1, 0, 15, 14, 13, 12, 11, 10, 9, 8\n+\n+template <>\n+struct zmm_vector<int32_t> {\n+    using type_t = int32_t;\n+    using zmm_t = __m512i;\n+    using ymm_t = __m256i;\n+    using opmask_t = __mmask16;\n+    static const uint8_t numlanes = 16;\n+\n+    static type_t type_max() { return X86_SIMD_SORT_MAX_INT32; }\n+    static type_t type_min() { return X86_SIMD_SORT_MIN_INT32; }\n+    static zmm_t zmm_max() { return _mm512_set1_epi32(type_max()); }\n+\n+    static opmask_t knot_opmask(opmask_t x) { return _mm512_knot(x); }\n+    static opmask_t ge(zmm_t x, zmm_t y) {\n+        return _mm512_cmp_epi32_mask(x, y, _MM_CMPINT_NLT);\n+    }\n+    static opmask_t gt(zmm_t x, zmm_t y) {\n+        return _mm512_cmp_epi32_mask(x, y, _MM_CMPINT_GT);\n+    }\n+    template <int scale>\n+    static ymm_t i64gather(__m512i index, void const *base) {\n+        return _mm512_i64gather_epi32(index, base, scale);\n+    }\n+    static zmm_t merge(ymm_t y1, ymm_t y2) {\n+        zmm_t z1 = _mm512_castsi256_si512(y1);\n+        return _mm512_inserti32x8(z1, y2, 1);\n+    }\n+    static zmm_t loadu(void const *mem) { return _mm512_loadu_si512(mem); }\n+    static void mask_compressstoreu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm512_mask_compressstoreu_epi32(mem, mask, x);\n+    }\n+    static zmm_t mask_loadu(zmm_t x, opmask_t mask, void const *mem) {\n+        return _mm512_mask_loadu_epi32(x, mask, mem);\n+    }\n+    static zmm_t mask_mov(zmm_t x, opmask_t mask, zmm_t y) {\n+        return _mm512_mask_mov_epi32(x, mask, y);\n+    }\n+    static void mask_storeu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm512_mask_storeu_epi32(mem, mask, x);\n+    }\n+    static zmm_t min(zmm_t x, zmm_t y) { return _mm512_min_epi32(x, y); }\n+    static zmm_t max(zmm_t x, zmm_t y) { return _mm512_max_epi32(x, y); }\n+    static zmm_t permutexvar(__m512i idx, zmm_t zmm) {\n+        return _mm512_permutexvar_epi32(idx, zmm);\n+    }\n+    static type_t reducemax(zmm_t v) { return _mm512_reduce_max_epi32(v); }\n+    static type_t reducemin(zmm_t v) { return _mm512_reduce_min_epi32(v); }\n+    static zmm_t set1(type_t v) { return _mm512_set1_epi32(v); }\n+    template <uint8_t mask>\n+    static zmm_t shuffle(zmm_t zmm) {\n+        return _mm512_shuffle_epi32(zmm, (_MM_PERM_ENUM)mask);\n+    }\n+    static void storeu(void *mem, zmm_t x) {\n+        return _mm512_storeu_si512(mem, x);\n+    }\n+\n+    static ymm_t max(ymm_t x, ymm_t y) { return _mm256_max_epi32(x, y); }\n+    static ymm_t min(ymm_t x, ymm_t y) { return _mm256_min_epi32(x, y); }\n+};\n+template <>\n+struct zmm_vector<float> {\n+    using type_t = float;\n+    using zmm_t = __m512;\n+    using ymm_t = __m256;\n+    using opmask_t = __mmask16;\n+    static const uint8_t numlanes = 16;\n+\n+    static type_t type_max() { return X86_SIMD_SORT_INFINITYF; }\n+    static type_t type_min() { return -X86_SIMD_SORT_INFINITYF; }\n+    static zmm_t zmm_max() { return _mm512_set1_ps(type_max()); }\n+\n+    static opmask_t knot_opmask(opmask_t x) { return _mm512_knot(x); }\n+    static opmask_t ge(zmm_t x, zmm_t y) {\n+        return _mm512_cmp_ps_mask(x, y, _CMP_GE_OQ);\n+    }\n+    static opmask_t gt(zmm_t x, zmm_t y) {\n+        return _mm512_cmp_ps_mask(x, y, _CMP_GT_OQ);\n+    }\n+    template <int scale>\n+    static ymm_t i64gather(__m512i index, void const *base) {\n+        return _mm512_i64gather_ps(index, base, scale);\n+    }\n+    static zmm_t merge(ymm_t y1, ymm_t y2) {\n+        zmm_t z1 = _mm512_castsi512_ps(\n+            _mm512_castsi256_si512(_mm256_castps_si256(y1)));\n+        return _mm512_insertf32x8(z1, y2, 1);\n+    }\n+    static zmm_t loadu(void const *mem) { return _mm512_loadu_ps(mem); }\n+    static zmm_t max(zmm_t x, zmm_t y) { return _mm512_max_ps(x, y); }\n+    static void mask_compressstoreu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm512_mask_compressstoreu_ps(mem, mask, x);\n+    }\n+    static zmm_t mask_loadu(zmm_t x, opmask_t mask, void const *mem) {\n+        return _mm512_mask_loadu_ps(x, mask, mem);\n+    }\n+    static zmm_t mask_mov(zmm_t x, opmask_t mask, zmm_t y) {\n+        return _mm512_mask_mov_ps(x, mask, y);\n+    }\n+    static void mask_storeu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm512_mask_storeu_ps(mem, mask, x);\n+    }\n+    static zmm_t min(zmm_t x, zmm_t y) { return _mm512_min_ps(x, y); }\n+    static zmm_t permutexvar(__m512i idx, zmm_t zmm) {\n+        return _mm512_permutexvar_ps(idx, zmm);\n+    }\n+    static type_t reducemax(zmm_t v) { return _mm512_reduce_max_ps(v); }\n+    static type_t reducemin(zmm_t v) { return _mm512_reduce_min_ps(v); }\n+    static zmm_t set1(type_t v) { return _mm512_set1_ps(v); }\n+    template <uint8_t mask>\n+    static zmm_t shuffle(zmm_t zmm) {\n+        return _mm512_shuffle_ps(zmm, zmm, (_MM_PERM_ENUM)mask);\n+    }\n+    static void storeu(void *mem, zmm_t x) { return _mm512_storeu_ps(mem, x); }\n+\n+    static ymm_t max(ymm_t x, ymm_t y) { return _mm256_max_ps(x, y); }\n+    static ymm_t min(ymm_t x, ymm_t y) { return _mm256_min_ps(x, y); }\n+};\n+\n+\/*\n+ * Assumes zmm is random and performs a full sorting network defined in\n+ * https:\/\/en.wikipedia.org\/wiki\/Bitonic_sorter#\/media\/File:BitonicSort.svg\n+ *\/\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n+X86_SIMD_SORT_INLINE zmm_t sort_zmm_32bit(zmm_t zmm) {\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(2, 3, 0, 1)>(zmm), 0xAAAA);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(0, 1, 2, 3)>(zmm), 0xCCCC);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(2, 3, 0, 1)>(zmm), 0xAAAA);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_3), zmm),\n+        0xF0F0);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 0, 3, 2)>(zmm), 0xCCCC);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(2, 3, 0, 1)>(zmm), 0xAAAA);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5), zmm),\n+        0xFF00);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_6), zmm),\n+        0xF0F0);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 0, 3, 2)>(zmm), 0xCCCC);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(2, 3, 0, 1)>(zmm), 0xAAAA);\n+    return zmm;\n+}\n+\n+\/\/ Assumes zmm is bitonic and performs a recursive half cleaner\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n+X86_SIMD_SORT_INLINE zmm_t bitonic_merge_zmm_32bit(zmm_t zmm) {\n+    \/\/ 1) half_cleaner[16]: compare 1-9, 2-10, 3-11 etc ..\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_7), zmm),\n+        0xFF00);\n+    \/\/ 2) half_cleaner[8]: compare 1-5, 2-6, 3-7 etc ..\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_6), zmm),\n+        0xF0F0);\n+    \/\/ 3) half_cleaner[4]\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 0, 3, 2)>(zmm), 0xCCCC);\n+    \/\/ 3) half_cleaner[1]\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(2, 3, 0, 1)>(zmm), 0xAAAA);\n+    return zmm;\n+}\n+\n+\/\/ Assumes zmm1 and zmm2 are sorted and performs a recursive half cleaner\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n+X86_SIMD_SORT_INLINE void bitonic_merge_two_zmm_32bit(zmm_t *zmm1,\n+                                                      zmm_t *zmm2) {\n+    \/\/ 1) First step of a merging network: coex of zmm1 and zmm2 reversed\n+    *zmm2 = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5), *zmm2);\n+    zmm_t zmm3 = vtype::min(*zmm1, *zmm2);\n+    zmm_t zmm4 = vtype::max(*zmm1, *zmm2);\n+    \/\/ 2) Recursive half cleaner for each\n+    *zmm1 = bitonic_merge_zmm_32bit<vtype>(zmm3);\n+    *zmm2 = bitonic_merge_zmm_32bit<vtype>(zmm4);\n+}\n+\n+\/\/ Assumes [zmm0, zmm1] and [zmm2, zmm3] are sorted and performs a recursive\n+\/\/ half cleaner\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n+X86_SIMD_SORT_INLINE void bitonic_merge_four_zmm_32bit(zmm_t *zmm) {\n+    zmm_t zmm2r = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5), zmm[2]);\n+    zmm_t zmm3r = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5), zmm[3]);\n+    zmm_t zmm_t1 = vtype::min(zmm[0], zmm3r);\n+    zmm_t zmm_t2 = vtype::min(zmm[1], zmm2r);\n+    zmm_t zmm_t3 = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5),\n+                                      vtype::max(zmm[1], zmm2r));\n+    zmm_t zmm_t4 = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5),\n+                                      vtype::max(zmm[0], zmm3r));\n+    zmm_t zmm0 = vtype::min(zmm_t1, zmm_t2);\n+    zmm_t zmm1 = vtype::max(zmm_t1, zmm_t2);\n+    zmm_t zmm2 = vtype::min(zmm_t3, zmm_t4);\n+    zmm_t zmm3 = vtype::max(zmm_t3, zmm_t4);\n+    zmm[0] = bitonic_merge_zmm_32bit<vtype>(zmm0);\n+    zmm[1] = bitonic_merge_zmm_32bit<vtype>(zmm1);\n+    zmm[2] = bitonic_merge_zmm_32bit<vtype>(zmm2);\n+    zmm[3] = bitonic_merge_zmm_32bit<vtype>(zmm3);\n+}\n+\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n+X86_SIMD_SORT_INLINE void bitonic_merge_eight_zmm_32bit(zmm_t *zmm) {\n+    zmm_t zmm4r = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5), zmm[4]);\n+    zmm_t zmm5r = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5), zmm[5]);\n+    zmm_t zmm6r = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5), zmm[6]);\n+    zmm_t zmm7r = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5), zmm[7]);\n+    zmm_t zmm_t1 = vtype::min(zmm[0], zmm7r);\n+    zmm_t zmm_t2 = vtype::min(zmm[1], zmm6r);\n+    zmm_t zmm_t3 = vtype::min(zmm[2], zmm5r);\n+    zmm_t zmm_t4 = vtype::min(zmm[3], zmm4r);\n+    zmm_t zmm_t5 = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5),\n+                                      vtype::max(zmm[3], zmm4r));\n+    zmm_t zmm_t6 = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5),\n+                                      vtype::max(zmm[2], zmm5r));\n+    zmm_t zmm_t7 = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5),\n+                                      vtype::max(zmm[1], zmm6r));\n+    zmm_t zmm_t8 = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5),\n+                                      vtype::max(zmm[0], zmm7r));\n+    COEX<vtype>(zmm_t1, zmm_t3);\n+    COEX<vtype>(zmm_t2, zmm_t4);\n+    COEX<vtype>(zmm_t5, zmm_t7);\n+    COEX<vtype>(zmm_t6, zmm_t8);\n+    COEX<vtype>(zmm_t1, zmm_t2);\n+    COEX<vtype>(zmm_t3, zmm_t4);\n+    COEX<vtype>(zmm_t5, zmm_t6);\n+    COEX<vtype>(zmm_t7, zmm_t8);\n+    zmm[0] = bitonic_merge_zmm_32bit<vtype>(zmm_t1);\n+    zmm[1] = bitonic_merge_zmm_32bit<vtype>(zmm_t2);\n+    zmm[2] = bitonic_merge_zmm_32bit<vtype>(zmm_t3);\n+    zmm[3] = bitonic_merge_zmm_32bit<vtype>(zmm_t4);\n+    zmm[4] = bitonic_merge_zmm_32bit<vtype>(zmm_t5);\n+    zmm[5] = bitonic_merge_zmm_32bit<vtype>(zmm_t6);\n+    zmm[6] = bitonic_merge_zmm_32bit<vtype>(zmm_t7);\n+    zmm[7] = bitonic_merge_zmm_32bit<vtype>(zmm_t8);\n+}\n+\n+template <typename vtype, typename type_t>\n+X86_SIMD_SORT_INLINE void sort_16_32bit(type_t *arr, int32_t N) {\n+    typename vtype::opmask_t load_mask = (0x0001 << N) - 0x0001;\n+    typename vtype::zmm_t zmm =\n+        vtype::mask_loadu(vtype::zmm_max(), load_mask, arr);\n+    vtype::mask_storeu(arr, load_mask, sort_zmm_32bit<vtype>(zmm));\n+}\n+\n+template <typename vtype, typename type_t>\n+X86_SIMD_SORT_INLINE void sort_32_32bit(type_t *arr, int32_t N) {\n+    if (N <= 16) {\n+        sort_16_32bit<vtype>(arr, N);\n+        return;\n+    }\n+    using zmm_t = typename vtype::zmm_t;\n+    zmm_t zmm1 = vtype::loadu(arr);\n+    typename vtype::opmask_t load_mask = (0x0001 << (N - 16)) - 0x0001;\n+    zmm_t zmm2 = vtype::mask_loadu(vtype::zmm_max(), load_mask, arr + 16);\n+    zmm1 = sort_zmm_32bit<vtype>(zmm1);\n+    zmm2 = sort_zmm_32bit<vtype>(zmm2);\n+    bitonic_merge_two_zmm_32bit<vtype>(&zmm1, &zmm2);\n+    vtype::storeu(arr, zmm1);\n+    vtype::mask_storeu(arr + 16, load_mask, zmm2);\n+}\n+\n+template <typename vtype, typename type_t>\n+X86_SIMD_SORT_INLINE void sort_64_32bit(type_t *arr, int32_t N) {\n+    if (N <= 32) {\n+        sort_32_32bit<vtype>(arr, N);\n+        return;\n+    }\n+    using zmm_t = typename vtype::zmm_t;\n+    using opmask_t = typename vtype::opmask_t;\n+    zmm_t zmm[4];\n+    zmm[0] = vtype::loadu(arr);\n+    zmm[1] = vtype::loadu(arr + 16);\n+    opmask_t load_mask1 = 0xFFFF, load_mask2 = 0xFFFF;\n+    uint64_t combined_mask = (0x1ull << (N - 32)) - 0x1ull;\n+    load_mask1 &= combined_mask & 0xFFFF;\n+    load_mask2 &= (combined_mask >> 16) & 0xFFFF;\n+    zmm[2] = vtype::mask_loadu(vtype::zmm_max(), load_mask1, arr + 32);\n+    zmm[3] = vtype::mask_loadu(vtype::zmm_max(), load_mask2, arr + 48);\n+    zmm[0] = sort_zmm_32bit<vtype>(zmm[0]);\n+    zmm[1] = sort_zmm_32bit<vtype>(zmm[1]);\n+    zmm[2] = sort_zmm_32bit<vtype>(zmm[2]);\n+    zmm[3] = sort_zmm_32bit<vtype>(zmm[3]);\n+    bitonic_merge_two_zmm_32bit<vtype>(&zmm[0], &zmm[1]);\n+    bitonic_merge_two_zmm_32bit<vtype>(&zmm[2], &zmm[3]);\n+    bitonic_merge_four_zmm_32bit<vtype>(zmm);\n+    vtype::storeu(arr, zmm[0]);\n+    vtype::storeu(arr + 16, zmm[1]);\n+    vtype::mask_storeu(arr + 32, load_mask1, zmm[2]);\n+    vtype::mask_storeu(arr + 48, load_mask2, zmm[3]);\n+}\n+\n+template <typename vtype, typename type_t>\n+X86_SIMD_SORT_INLINE void sort_128_32bit(type_t *arr, int32_t N) {\n+    if (N <= 64) {\n+        sort_64_32bit<vtype>(arr, N);\n+        return;\n+    }\n+    using zmm_t = typename vtype::zmm_t;\n+    using opmask_t = typename vtype::opmask_t;\n+    zmm_t zmm[8];\n+    zmm[0] = vtype::loadu(arr);\n+    zmm[1] = vtype::loadu(arr + 16);\n+    zmm[2] = vtype::loadu(arr + 32);\n+    zmm[3] = vtype::loadu(arr + 48);\n+    zmm[0] = sort_zmm_32bit<vtype>(zmm[0]);\n+    zmm[1] = sort_zmm_32bit<vtype>(zmm[1]);\n+    zmm[2] = sort_zmm_32bit<vtype>(zmm[2]);\n+    zmm[3] = sort_zmm_32bit<vtype>(zmm[3]);\n+    opmask_t load_mask1 = 0xFFFF, load_mask2 = 0xFFFF;\n+    opmask_t load_mask3 = 0xFFFF, load_mask4 = 0xFFFF;\n+    if (N != 128) {\n+        uint64_t combined_mask = (0x1ull << (N - 64)) - 0x1ull;\n+        load_mask1 &= combined_mask & 0xFFFF;\n+        load_mask2 &= (combined_mask >> 16) & 0xFFFF;\n+        load_mask3 &= (combined_mask >> 32) & 0xFFFF;\n+        load_mask4 &= (combined_mask >> 48) & 0xFFFF;\n+    }\n+    zmm[4] = vtype::mask_loadu(vtype::zmm_max(), load_mask1, arr + 64);\n+    zmm[5] = vtype::mask_loadu(vtype::zmm_max(), load_mask2, arr + 80);\n+    zmm[6] = vtype::mask_loadu(vtype::zmm_max(), load_mask3, arr + 96);\n+    zmm[7] = vtype::mask_loadu(vtype::zmm_max(), load_mask4, arr + 112);\n+    zmm[4] = sort_zmm_32bit<vtype>(zmm[4]);\n+    zmm[5] = sort_zmm_32bit<vtype>(zmm[5]);\n+    zmm[6] = sort_zmm_32bit<vtype>(zmm[6]);\n+    zmm[7] = sort_zmm_32bit<vtype>(zmm[7]);\n+    bitonic_merge_two_zmm_32bit<vtype>(&zmm[0], &zmm[1]);\n+    bitonic_merge_two_zmm_32bit<vtype>(&zmm[2], &zmm[3]);\n+    bitonic_merge_two_zmm_32bit<vtype>(&zmm[4], &zmm[5]);\n+    bitonic_merge_two_zmm_32bit<vtype>(&zmm[6], &zmm[7]);\n+    bitonic_merge_four_zmm_32bit<vtype>(zmm);\n+    bitonic_merge_four_zmm_32bit<vtype>(zmm + 4);\n+    bitonic_merge_eight_zmm_32bit<vtype>(zmm);\n+    vtype::storeu(arr, zmm[0]);\n+    vtype::storeu(arr + 16, zmm[1]);\n+    vtype::storeu(arr + 32, zmm[2]);\n+    vtype::storeu(arr + 48, zmm[3]);\n+    vtype::mask_storeu(arr + 64, load_mask1, zmm[4]);\n+    vtype::mask_storeu(arr + 80, load_mask2, zmm[5]);\n+    vtype::mask_storeu(arr + 96, load_mask3, zmm[6]);\n+    vtype::mask_storeu(arr + 112, load_mask4, zmm[7]);\n+}\n+\n+\n+template <typename vtype, typename type_t>\n+static void qsort_32bit_(type_t *arr, int64_t left, int64_t right,\n+                         int64_t max_iters) {\n+    \/*\n+     * Resort to std::sort if quicksort isnt making any progress\n+     *\/\n+    if (max_iters <= 0) {\n+        std::sort(arr + left, arr + right + 1);\n+        return;\n+    }\n+    \/*\n+     * Base case: use bitonic networks to sort arrays <= 128\n+     *\/\n+    if (right + 1 - left <= 128) {\n+        sort_128_32bit<vtype>(arr + left, (int32_t)(right + 1 - left));\n+        return;\n+    }\n+\n+    type_t pivot = get_pivot_scalar<type_t>(arr, left, right);\n+    type_t smallest = vtype::type_max();\n+    type_t biggest = vtype::type_min();\n+    int64_t pivot_index = partition_avx512_unrolled<vtype, 2>(\n+        arr, left, right + 1, pivot, &smallest, &biggest, false);\n+    if (pivot != smallest)\n+        qsort_32bit_<vtype>(arr, left, pivot_index - 1, max_iters - 1);\n+    if (pivot != biggest)\n+        qsort_32bit_<vtype>(arr, pivot_index, right, max_iters - 1);\n+}\n+\n+template <>\n+void inline avx512_qsort<int32_t>(int32_t *arr, int64_t fromIndex, int64_t toIndex) {\n+    int64_t arrsize = toIndex - fromIndex;\n+    if (arrsize > 1) {\n+        qsort_32bit_<zmm_vector<int32_t>, int32_t>(arr, fromIndex, toIndex - 1,\n+                                                   2 * (int64_t)log2(arrsize));\n+    }\n+}\n+\n+template <>\n+void inline avx512_qsort<float>(float *arr, int64_t fromIndex, int64_t toIndex) {\n+    int64_t arrsize = toIndex - fromIndex;\n+    if (arrsize > 1) {\n+        qsort_32bit_<zmm_vector<float>, float>(arr, fromIndex, toIndex - 1,\n+                                               2 * (int64_t)log2(arrsize));\n+    }\n+}\n+\n+#endif  \/\/ AVX512_QSORT_32BIT\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avx512-32bit-qsort.hpp","additions":443,"deletions":0,"binary":false,"changes":443,"status":"added"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Intel Corporation. All rights reserved.\n+ * Intel x86-simd-sort source code.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This implementation is based on x86-simd-sort(https:\/\/github.com\/intel\/x86-simd-sort)\n+\n+#ifndef AVX512_64BIT_COMMON\n+#define AVX512_64BIT_COMMON\n+#include \"avx512-common-qsort.h\"\n+\n+\/*\n+ * Constants used in sorting 8 elements in a ZMM registers. Based on Bitonic\n+ * sorting network (see\n+ * https:\/\/en.wikipedia.org\/wiki\/Bitonic_sorter#\/media\/File:BitonicSort.svg)\n+ *\/\n+\/\/ ZMM                  7, 6, 5, 4, 3, 2, 1, 0\n+#define NETWORK_64BIT_1 4, 5, 6, 7, 0, 1, 2, 3\n+#define NETWORK_64BIT_2 0, 1, 2, 3, 4, 5, 6, 7\n+#define NETWORK_64BIT_3 5, 4, 7, 6, 1, 0, 3, 2\n+#define NETWORK_64BIT_4 3, 2, 1, 0, 7, 6, 5, 4\n+\n+template <>\n+struct zmm_vector<int64_t> {\n+    using type_t = int64_t;\n+    using zmm_t = __m512i;\n+    using zmmi_t = __m512i;\n+    using ymm_t = __m512i;\n+    using opmask_t = __mmask8;\n+    static const uint8_t numlanes = 8;\n+\n+    static type_t type_max() { return X86_SIMD_SORT_MAX_INT64; }\n+    static type_t type_min() { return X86_SIMD_SORT_MIN_INT64; }\n+    static zmm_t zmm_max() {\n+        return _mm512_set1_epi64(type_max());\n+    }  \/\/ TODO: this should broadcast bits as is?\n+\n+    static zmmi_t seti(int v1, int v2, int v3, int v4, int v5, int v6, int v7,\n+                       int v8) {\n+        return _mm512_set_epi64(v1, v2, v3, v4, v5, v6, v7, v8);\n+    }\n+    static opmask_t kxor_opmask(opmask_t x, opmask_t y) {\n+        return _kxor_mask8(x, y);\n+    }\n+    static opmask_t knot_opmask(opmask_t x) { return _knot_mask8(x); }\n+    static opmask_t le(zmm_t x, zmm_t y) {\n+        return _mm512_cmp_epi64_mask(x, y, _MM_CMPINT_LE);\n+    }\n+    static opmask_t ge(zmm_t x, zmm_t y) {\n+        return _mm512_cmp_epi64_mask(x, y, _MM_CMPINT_NLT);\n+    }\n+    static opmask_t gt(zmm_t x, zmm_t y) {\n+        return _mm512_cmp_epi64_mask(x, y, _MM_CMPINT_GT);\n+    }\n+    static opmask_t eq(zmm_t x, zmm_t y) {\n+        return _mm512_cmp_epi64_mask(x, y, _MM_CMPINT_EQ);\n+    }\n+    template <int scale>\n+    static zmm_t mask_i64gather(zmm_t src, opmask_t mask, __m512i index,\n+                                void const *base) {\n+        return _mm512_mask_i64gather_epi64(src, mask, index, base, scale);\n+    }\n+    template <int scale>\n+    static zmm_t i64gather(__m512i index, void const *base) {\n+        return _mm512_i64gather_epi64(index, base, scale);\n+    }\n+    static zmm_t loadu(void const *mem) { return _mm512_loadu_si512(mem); }\n+    static zmm_t max(zmm_t x, zmm_t y) { return _mm512_max_epi64(x, y); }\n+    static void mask_compressstoreu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm512_mask_compressstoreu_epi64(mem, mask, x);\n+    }\n+    static zmm_t maskz_loadu(opmask_t mask, void const *mem) {\n+        return _mm512_maskz_loadu_epi64(mask, mem);\n+    }\n+    static zmm_t mask_loadu(zmm_t x, opmask_t mask, void const *mem) {\n+        return _mm512_mask_loadu_epi64(x, mask, mem);\n+    }\n+    static zmm_t mask_mov(zmm_t x, opmask_t mask, zmm_t y) {\n+        return _mm512_mask_mov_epi64(x, mask, y);\n+    }\n+    static void mask_storeu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm512_mask_storeu_epi64(mem, mask, x);\n+    }\n+    static zmm_t min(zmm_t x, zmm_t y) { return _mm512_min_epi64(x, y); }\n+    static zmm_t permutexvar(__m512i idx, zmm_t zmm) {\n+        return _mm512_permutexvar_epi64(idx, zmm);\n+    }\n+    static type_t reducemax(zmm_t v) { return _mm512_reduce_max_epi64(v); }\n+    static type_t reducemin(zmm_t v) { return _mm512_reduce_min_epi64(v); }\n+    static zmm_t set1(type_t v) { return _mm512_set1_epi64(v); }\n+    template <uint8_t mask>\n+    static zmm_t shuffle(zmm_t zmm) {\n+        __m512d temp = _mm512_castsi512_pd(zmm);\n+        return _mm512_castpd_si512(\n+            _mm512_shuffle_pd(temp, temp, (_MM_PERM_ENUM)mask));\n+    }\n+    static void storeu(void *mem, zmm_t x) { _mm512_storeu_si512(mem, x); }\n+};\n+template <>\n+struct zmm_vector<double> {\n+    using type_t = double;\n+    using zmm_t = __m512d;\n+    using zmmi_t = __m512i;\n+    using ymm_t = __m512d;\n+    using opmask_t = __mmask8;\n+    static const uint8_t numlanes = 8;\n+\n+    static type_t type_max() { return X86_SIMD_SORT_INFINITY; }\n+    static type_t type_min() { return -X86_SIMD_SORT_INFINITY; }\n+    static zmm_t zmm_max() { return _mm512_set1_pd(type_max()); }\n+\n+    static zmmi_t seti(int v1, int v2, int v3, int v4, int v5, int v6, int v7,\n+                       int v8) {\n+        return _mm512_set_epi64(v1, v2, v3, v4, v5, v6, v7, v8);\n+    }\n+\n+    static zmm_t maskz_loadu(opmask_t mask, void const *mem) {\n+        return _mm512_maskz_loadu_pd(mask, mem);\n+    }\n+    static opmask_t knot_opmask(opmask_t x) { return _knot_mask8(x); }\n+    static opmask_t ge(zmm_t x, zmm_t y) {\n+        return _mm512_cmp_pd_mask(x, y, _CMP_GE_OQ);\n+    }\n+    static opmask_t gt(zmm_t x, zmm_t y) {\n+        return _mm512_cmp_pd_mask(x, y, _CMP_GT_OQ);\n+    }\n+    static opmask_t eq(zmm_t x, zmm_t y) {\n+        return _mm512_cmp_pd_mask(x, y, _CMP_EQ_OQ);\n+    }\n+    template <int type>\n+    static opmask_t fpclass(zmm_t x) {\n+        return _mm512_fpclass_pd_mask(x, type);\n+    }\n+    template <int scale>\n+    static zmm_t mask_i64gather(zmm_t src, opmask_t mask, __m512i index,\n+                                void const *base) {\n+        return _mm512_mask_i64gather_pd(src, mask, index, base, scale);\n+    }\n+    template <int scale>\n+    static zmm_t i64gather(__m512i index, void const *base) {\n+        return _mm512_i64gather_pd(index, base, scale);\n+    }\n+    static zmm_t loadu(void const *mem) { return _mm512_loadu_pd(mem); }\n+    static zmm_t max(zmm_t x, zmm_t y) { return _mm512_max_pd(x, y); }\n+    static void mask_compressstoreu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm512_mask_compressstoreu_pd(mem, mask, x);\n+    }\n+    static zmm_t mask_loadu(zmm_t x, opmask_t mask, void const *mem) {\n+        return _mm512_mask_loadu_pd(x, mask, mem);\n+    }\n+    static zmm_t mask_mov(zmm_t x, opmask_t mask, zmm_t y) {\n+        return _mm512_mask_mov_pd(x, mask, y);\n+    }\n+    static void mask_storeu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm512_mask_storeu_pd(mem, mask, x);\n+    }\n+    static zmm_t min(zmm_t x, zmm_t y) { return _mm512_min_pd(x, y); }\n+    static zmm_t permutexvar(__m512i idx, zmm_t zmm) {\n+        return _mm512_permutexvar_pd(idx, zmm);\n+    }\n+    static type_t reducemax(zmm_t v) { return _mm512_reduce_max_pd(v); }\n+    static type_t reducemin(zmm_t v) { return _mm512_reduce_min_pd(v); }\n+    static zmm_t set1(type_t v) { return _mm512_set1_pd(v); }\n+    template <uint8_t mask>\n+    static zmm_t shuffle(zmm_t zmm) {\n+        return _mm512_shuffle_pd(zmm, zmm, (_MM_PERM_ENUM)mask);\n+    }\n+    static void storeu(void *mem, zmm_t x) { _mm512_storeu_pd(mem, x); }\n+};\n+\n+\/*\n+ * Assumes zmm is random and performs a full sorting network defined in\n+ * https:\/\/en.wikipedia.org\/wiki\/Bitonic_sorter#\/media\/File:BitonicSort.svg\n+ *\/\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n+X86_SIMD_SORT_INLINE zmm_t sort_zmm_64bit(zmm_t zmm) {\n+    const typename vtype::zmmi_t rev_index = vtype::seti(NETWORK_64BIT_2);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 1, 1, 1)>(zmm), 0xAA);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::permutexvar(vtype::seti(NETWORK_64BIT_1), zmm), 0xCC);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 1, 1, 1)>(zmm), 0xAA);\n+    zmm = cmp_merge<vtype>(zmm, vtype::permutexvar(rev_index, zmm), 0xF0);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::permutexvar(vtype::seti(NETWORK_64BIT_3), zmm), 0xCC);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 1, 1, 1)>(zmm), 0xAA);\n+    return zmm;\n+}\n+\n+\n+#endif\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avx512-64bit-common.h","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -0,0 +1,774 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Intel Corporation. All rights reserved.\n+ * Intel x86-simd-sort source code.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This implementation is based on x86-simd-sort(https:\/\/github.com\/intel\/x86-simd-sort)\n+\n+#ifndef AVX512_QSORT_64BIT\n+#define AVX512_QSORT_64BIT\n+\n+#include \"avx512-64bit-common.h\"\n+\n+\/\/ Assumes zmm is bitonic and performs a recursive half cleaner\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n+X86_SIMD_SORT_INLINE zmm_t bitonic_merge_zmm_64bit(zmm_t zmm) {\n+    \/\/ 1) half_cleaner[8]: compare 0-4, 1-5, 2-6, 3-7\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::permutexvar(_mm512_set_epi64(NETWORK_64BIT_4), zmm), 0xF0);\n+    \/\/ 2) half_cleaner[4]\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::permutexvar(_mm512_set_epi64(NETWORK_64BIT_3), zmm), 0xCC);\n+    \/\/ 3) half_cleaner[1]\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 1, 1, 1)>(zmm), 0xAA);\n+    return zmm;\n+}\n+\/\/ Assumes zmm1 and zmm2 are sorted and performs a recursive half cleaner\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n+X86_SIMD_SORT_INLINE void bitonic_merge_two_zmm_64bit(zmm_t &zmm1,\n+                                                      zmm_t &zmm2) {\n+    const __m512i rev_index = _mm512_set_epi64(NETWORK_64BIT_2);\n+    \/\/ 1) First step of a merging network: coex of zmm1 and zmm2 reversed\n+    zmm2 = vtype::permutexvar(rev_index, zmm2);\n+    zmm_t zmm3 = vtype::min(zmm1, zmm2);\n+    zmm_t zmm4 = vtype::max(zmm1, zmm2);\n+    \/\/ 2) Recursive half cleaner for each\n+    zmm1 = bitonic_merge_zmm_64bit<vtype>(zmm3);\n+    zmm2 = bitonic_merge_zmm_64bit<vtype>(zmm4);\n+}\n+\/\/ Assumes [zmm0, zmm1] and [zmm2, zmm3] are sorted and performs a recursive\n+\/\/ half cleaner\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n+X86_SIMD_SORT_INLINE void bitonic_merge_four_zmm_64bit(zmm_t *zmm) {\n+    const __m512i rev_index = _mm512_set_epi64(NETWORK_64BIT_2);\n+    \/\/ 1) First step of a merging network\n+    zmm_t zmm2r = vtype::permutexvar(rev_index, zmm[2]);\n+    zmm_t zmm3r = vtype::permutexvar(rev_index, zmm[3]);\n+    zmm_t zmm_t1 = vtype::min(zmm[0], zmm3r);\n+    zmm_t zmm_t2 = vtype::min(zmm[1], zmm2r);\n+    \/\/ 2) Recursive half clearer: 16\n+    zmm_t zmm_t3 = vtype::permutexvar(rev_index, vtype::max(zmm[1], zmm2r));\n+    zmm_t zmm_t4 = vtype::permutexvar(rev_index, vtype::max(zmm[0], zmm3r));\n+    zmm_t zmm0 = vtype::min(zmm_t1, zmm_t2);\n+    zmm_t zmm1 = vtype::max(zmm_t1, zmm_t2);\n+    zmm_t zmm2 = vtype::min(zmm_t3, zmm_t4);\n+    zmm_t zmm3 = vtype::max(zmm_t3, zmm_t4);\n+    zmm[0] = bitonic_merge_zmm_64bit<vtype>(zmm0);\n+    zmm[1] = bitonic_merge_zmm_64bit<vtype>(zmm1);\n+    zmm[2] = bitonic_merge_zmm_64bit<vtype>(zmm2);\n+    zmm[3] = bitonic_merge_zmm_64bit<vtype>(zmm3);\n+}\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n+X86_SIMD_SORT_INLINE void bitonic_merge_eight_zmm_64bit(zmm_t *zmm) {\n+    const __m512i rev_index = _mm512_set_epi64(NETWORK_64BIT_2);\n+    zmm_t zmm4r = vtype::permutexvar(rev_index, zmm[4]);\n+    zmm_t zmm5r = vtype::permutexvar(rev_index, zmm[5]);\n+    zmm_t zmm6r = vtype::permutexvar(rev_index, zmm[6]);\n+    zmm_t zmm7r = vtype::permutexvar(rev_index, zmm[7]);\n+    zmm_t zmm_t1 = vtype::min(zmm[0], zmm7r);\n+    zmm_t zmm_t2 = vtype::min(zmm[1], zmm6r);\n+    zmm_t zmm_t3 = vtype::min(zmm[2], zmm5r);\n+    zmm_t zmm_t4 = vtype::min(zmm[3], zmm4r);\n+    zmm_t zmm_t5 = vtype::permutexvar(rev_index, vtype::max(zmm[3], zmm4r));\n+    zmm_t zmm_t6 = vtype::permutexvar(rev_index, vtype::max(zmm[2], zmm5r));\n+    zmm_t zmm_t7 = vtype::permutexvar(rev_index, vtype::max(zmm[1], zmm6r));\n+    zmm_t zmm_t8 = vtype::permutexvar(rev_index, vtype::max(zmm[0], zmm7r));\n+    COEX<vtype>(zmm_t1, zmm_t3);\n+    COEX<vtype>(zmm_t2, zmm_t4);\n+    COEX<vtype>(zmm_t5, zmm_t7);\n+    COEX<vtype>(zmm_t6, zmm_t8);\n+    COEX<vtype>(zmm_t1, zmm_t2);\n+    COEX<vtype>(zmm_t3, zmm_t4);\n+    COEX<vtype>(zmm_t5, zmm_t6);\n+    COEX<vtype>(zmm_t7, zmm_t8);\n+    zmm[0] = bitonic_merge_zmm_64bit<vtype>(zmm_t1);\n+    zmm[1] = bitonic_merge_zmm_64bit<vtype>(zmm_t2);\n+    zmm[2] = bitonic_merge_zmm_64bit<vtype>(zmm_t3);\n+    zmm[3] = bitonic_merge_zmm_64bit<vtype>(zmm_t4);\n+    zmm[4] = bitonic_merge_zmm_64bit<vtype>(zmm_t5);\n+    zmm[5] = bitonic_merge_zmm_64bit<vtype>(zmm_t6);\n+    zmm[6] = bitonic_merge_zmm_64bit<vtype>(zmm_t7);\n+    zmm[7] = bitonic_merge_zmm_64bit<vtype>(zmm_t8);\n+}\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n+X86_SIMD_SORT_INLINE void bitonic_merge_sixteen_zmm_64bit(zmm_t *zmm) {\n+    const __m512i rev_index = _mm512_set_epi64(NETWORK_64BIT_2);\n+    zmm_t zmm8r = vtype::permutexvar(rev_index, zmm[8]);\n+    zmm_t zmm9r = vtype::permutexvar(rev_index, zmm[9]);\n+    zmm_t zmm10r = vtype::permutexvar(rev_index, zmm[10]);\n+    zmm_t zmm11r = vtype::permutexvar(rev_index, zmm[11]);\n+    zmm_t zmm12r = vtype::permutexvar(rev_index, zmm[12]);\n+    zmm_t zmm13r = vtype::permutexvar(rev_index, zmm[13]);\n+    zmm_t zmm14r = vtype::permutexvar(rev_index, zmm[14]);\n+    zmm_t zmm15r = vtype::permutexvar(rev_index, zmm[15]);\n+    zmm_t zmm_t1 = vtype::min(zmm[0], zmm15r);\n+    zmm_t zmm_t2 = vtype::min(zmm[1], zmm14r);\n+    zmm_t zmm_t3 = vtype::min(zmm[2], zmm13r);\n+    zmm_t zmm_t4 = vtype::min(zmm[3], zmm12r);\n+    zmm_t zmm_t5 = vtype::min(zmm[4], zmm11r);\n+    zmm_t zmm_t6 = vtype::min(zmm[5], zmm10r);\n+    zmm_t zmm_t7 = vtype::min(zmm[6], zmm9r);\n+    zmm_t zmm_t8 = vtype::min(zmm[7], zmm8r);\n+    zmm_t zmm_t9 = vtype::permutexvar(rev_index, vtype::max(zmm[7], zmm8r));\n+    zmm_t zmm_t10 = vtype::permutexvar(rev_index, vtype::max(zmm[6], zmm9r));\n+    zmm_t zmm_t11 = vtype::permutexvar(rev_index, vtype::max(zmm[5], zmm10r));\n+    zmm_t zmm_t12 = vtype::permutexvar(rev_index, vtype::max(zmm[4], zmm11r));\n+    zmm_t zmm_t13 = vtype::permutexvar(rev_index, vtype::max(zmm[3], zmm12r));\n+    zmm_t zmm_t14 = vtype::permutexvar(rev_index, vtype::max(zmm[2], zmm13r));\n+    zmm_t zmm_t15 = vtype::permutexvar(rev_index, vtype::max(zmm[1], zmm14r));\n+    zmm_t zmm_t16 = vtype::permutexvar(rev_index, vtype::max(zmm[0], zmm15r));\n+    \/\/ Recusive half clear 16 zmm regs\n+    COEX<vtype>(zmm_t1, zmm_t5);\n+    COEX<vtype>(zmm_t2, zmm_t6);\n+    COEX<vtype>(zmm_t3, zmm_t7);\n+    COEX<vtype>(zmm_t4, zmm_t8);\n+    COEX<vtype>(zmm_t9, zmm_t13);\n+    COEX<vtype>(zmm_t10, zmm_t14);\n+    COEX<vtype>(zmm_t11, zmm_t15);\n+    COEX<vtype>(zmm_t12, zmm_t16);\n+    \/\/\n+    COEX<vtype>(zmm_t1, zmm_t3);\n+    COEX<vtype>(zmm_t2, zmm_t4);\n+    COEX<vtype>(zmm_t5, zmm_t7);\n+    COEX<vtype>(zmm_t6, zmm_t8);\n+    COEX<vtype>(zmm_t9, zmm_t11);\n+    COEX<vtype>(zmm_t10, zmm_t12);\n+    COEX<vtype>(zmm_t13, zmm_t15);\n+    COEX<vtype>(zmm_t14, zmm_t16);\n+    \/\/\n+    COEX<vtype>(zmm_t1, zmm_t2);\n+    COEX<vtype>(zmm_t3, zmm_t4);\n+    COEX<vtype>(zmm_t5, zmm_t6);\n+    COEX<vtype>(zmm_t7, zmm_t8);\n+    COEX<vtype>(zmm_t9, zmm_t10);\n+    COEX<vtype>(zmm_t11, zmm_t12);\n+    COEX<vtype>(zmm_t13, zmm_t14);\n+    COEX<vtype>(zmm_t15, zmm_t16);\n+    \/\/\n+    zmm[0] = bitonic_merge_zmm_64bit<vtype>(zmm_t1);\n+    zmm[1] = bitonic_merge_zmm_64bit<vtype>(zmm_t2);\n+    zmm[2] = bitonic_merge_zmm_64bit<vtype>(zmm_t3);\n+    zmm[3] = bitonic_merge_zmm_64bit<vtype>(zmm_t4);\n+    zmm[4] = bitonic_merge_zmm_64bit<vtype>(zmm_t5);\n+    zmm[5] = bitonic_merge_zmm_64bit<vtype>(zmm_t6);\n+    zmm[6] = bitonic_merge_zmm_64bit<vtype>(zmm_t7);\n+    zmm[7] = bitonic_merge_zmm_64bit<vtype>(zmm_t8);\n+    zmm[8] = bitonic_merge_zmm_64bit<vtype>(zmm_t9);\n+    zmm[9] = bitonic_merge_zmm_64bit<vtype>(zmm_t10);\n+    zmm[10] = bitonic_merge_zmm_64bit<vtype>(zmm_t11);\n+    zmm[11] = bitonic_merge_zmm_64bit<vtype>(zmm_t12);\n+    zmm[12] = bitonic_merge_zmm_64bit<vtype>(zmm_t13);\n+    zmm[13] = bitonic_merge_zmm_64bit<vtype>(zmm_t14);\n+    zmm[14] = bitonic_merge_zmm_64bit<vtype>(zmm_t15);\n+    zmm[15] = bitonic_merge_zmm_64bit<vtype>(zmm_t16);\n+}\n+\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n+X86_SIMD_SORT_INLINE void bitonic_merge_32_zmm_64bit(zmm_t *zmm) {\n+    const __m512i rev_index = _mm512_set_epi64(NETWORK_64BIT_2);\n+    zmm_t zmm16r = vtype::permutexvar(rev_index, zmm[16]);\n+    zmm_t zmm17r = vtype::permutexvar(rev_index, zmm[17]);\n+    zmm_t zmm18r = vtype::permutexvar(rev_index, zmm[18]);\n+    zmm_t zmm19r = vtype::permutexvar(rev_index, zmm[19]);\n+    zmm_t zmm20r = vtype::permutexvar(rev_index, zmm[20]);\n+    zmm_t zmm21r = vtype::permutexvar(rev_index, zmm[21]);\n+    zmm_t zmm22r = vtype::permutexvar(rev_index, zmm[22]);\n+    zmm_t zmm23r = vtype::permutexvar(rev_index, zmm[23]);\n+    zmm_t zmm24r = vtype::permutexvar(rev_index, zmm[24]);\n+    zmm_t zmm25r = vtype::permutexvar(rev_index, zmm[25]);\n+    zmm_t zmm26r = vtype::permutexvar(rev_index, zmm[26]);\n+    zmm_t zmm27r = vtype::permutexvar(rev_index, zmm[27]);\n+    zmm_t zmm28r = vtype::permutexvar(rev_index, zmm[28]);\n+    zmm_t zmm29r = vtype::permutexvar(rev_index, zmm[29]);\n+    zmm_t zmm30r = vtype::permutexvar(rev_index, zmm[30]);\n+    zmm_t zmm31r = vtype::permutexvar(rev_index, zmm[31]);\n+    zmm_t zmm_t1 = vtype::min(zmm[0], zmm31r);\n+    zmm_t zmm_t2 = vtype::min(zmm[1], zmm30r);\n+    zmm_t zmm_t3 = vtype::min(zmm[2], zmm29r);\n+    zmm_t zmm_t4 = vtype::min(zmm[3], zmm28r);\n+    zmm_t zmm_t5 = vtype::min(zmm[4], zmm27r);\n+    zmm_t zmm_t6 = vtype::min(zmm[5], zmm26r);\n+    zmm_t zmm_t7 = vtype::min(zmm[6], zmm25r);\n+    zmm_t zmm_t8 = vtype::min(zmm[7], zmm24r);\n+    zmm_t zmm_t9 = vtype::min(zmm[8], zmm23r);\n+    zmm_t zmm_t10 = vtype::min(zmm[9], zmm22r);\n+    zmm_t zmm_t11 = vtype::min(zmm[10], zmm21r);\n+    zmm_t zmm_t12 = vtype::min(zmm[11], zmm20r);\n+    zmm_t zmm_t13 = vtype::min(zmm[12], zmm19r);\n+    zmm_t zmm_t14 = vtype::min(zmm[13], zmm18r);\n+    zmm_t zmm_t15 = vtype::min(zmm[14], zmm17r);\n+    zmm_t zmm_t16 = vtype::min(zmm[15], zmm16r);\n+    zmm_t zmm_t17 = vtype::permutexvar(rev_index, vtype::max(zmm[15], zmm16r));\n+    zmm_t zmm_t18 = vtype::permutexvar(rev_index, vtype::max(zmm[14], zmm17r));\n+    zmm_t zmm_t19 = vtype::permutexvar(rev_index, vtype::max(zmm[13], zmm18r));\n+    zmm_t zmm_t20 = vtype::permutexvar(rev_index, vtype::max(zmm[12], zmm19r));\n+    zmm_t zmm_t21 = vtype::permutexvar(rev_index, vtype::max(zmm[11], zmm20r));\n+    zmm_t zmm_t22 = vtype::permutexvar(rev_index, vtype::max(zmm[10], zmm21r));\n+    zmm_t zmm_t23 = vtype::permutexvar(rev_index, vtype::max(zmm[9], zmm22r));\n+    zmm_t zmm_t24 = vtype::permutexvar(rev_index, vtype::max(zmm[8], zmm23r));\n+    zmm_t zmm_t25 = vtype::permutexvar(rev_index, vtype::max(zmm[7], zmm24r));\n+    zmm_t zmm_t26 = vtype::permutexvar(rev_index, vtype::max(zmm[6], zmm25r));\n+    zmm_t zmm_t27 = vtype::permutexvar(rev_index, vtype::max(zmm[5], zmm26r));\n+    zmm_t zmm_t28 = vtype::permutexvar(rev_index, vtype::max(zmm[4], zmm27r));\n+    zmm_t zmm_t29 = vtype::permutexvar(rev_index, vtype::max(zmm[3], zmm28r));\n+    zmm_t zmm_t30 = vtype::permutexvar(rev_index, vtype::max(zmm[2], zmm29r));\n+    zmm_t zmm_t31 = vtype::permutexvar(rev_index, vtype::max(zmm[1], zmm30r));\n+    zmm_t zmm_t32 = vtype::permutexvar(rev_index, vtype::max(zmm[0], zmm31r));\n+    \/\/ Recusive half clear 16 zmm regs\n+    COEX<vtype>(zmm_t1, zmm_t9);\n+    COEX<vtype>(zmm_t2, zmm_t10);\n+    COEX<vtype>(zmm_t3, zmm_t11);\n+    COEX<vtype>(zmm_t4, zmm_t12);\n+    COEX<vtype>(zmm_t5, zmm_t13);\n+    COEX<vtype>(zmm_t6, zmm_t14);\n+    COEX<vtype>(zmm_t7, zmm_t15);\n+    COEX<vtype>(zmm_t8, zmm_t16);\n+    COEX<vtype>(zmm_t17, zmm_t25);\n+    COEX<vtype>(zmm_t18, zmm_t26);\n+    COEX<vtype>(zmm_t19, zmm_t27);\n+    COEX<vtype>(zmm_t20, zmm_t28);\n+    COEX<vtype>(zmm_t21, zmm_t29);\n+    COEX<vtype>(zmm_t22, zmm_t30);\n+    COEX<vtype>(zmm_t23, zmm_t31);\n+    COEX<vtype>(zmm_t24, zmm_t32);\n+    \/\/\n+    COEX<vtype>(zmm_t1, zmm_t5);\n+    COEX<vtype>(zmm_t2, zmm_t6);\n+    COEX<vtype>(zmm_t3, zmm_t7);\n+    COEX<vtype>(zmm_t4, zmm_t8);\n+    COEX<vtype>(zmm_t9, zmm_t13);\n+    COEX<vtype>(zmm_t10, zmm_t14);\n+    COEX<vtype>(zmm_t11, zmm_t15);\n+    COEX<vtype>(zmm_t12, zmm_t16);\n+    COEX<vtype>(zmm_t17, zmm_t21);\n+    COEX<vtype>(zmm_t18, zmm_t22);\n+    COEX<vtype>(zmm_t19, zmm_t23);\n+    COEX<vtype>(zmm_t20, zmm_t24);\n+    COEX<vtype>(zmm_t25, zmm_t29);\n+    COEX<vtype>(zmm_t26, zmm_t30);\n+    COEX<vtype>(zmm_t27, zmm_t31);\n+    COEX<vtype>(zmm_t28, zmm_t32);\n+    \/\/\n+    COEX<vtype>(zmm_t1, zmm_t3);\n+    COEX<vtype>(zmm_t2, zmm_t4);\n+    COEX<vtype>(zmm_t5, zmm_t7);\n+    COEX<vtype>(zmm_t6, zmm_t8);\n+    COEX<vtype>(zmm_t9, zmm_t11);\n+    COEX<vtype>(zmm_t10, zmm_t12);\n+    COEX<vtype>(zmm_t13, zmm_t15);\n+    COEX<vtype>(zmm_t14, zmm_t16);\n+    COEX<vtype>(zmm_t17, zmm_t19);\n+    COEX<vtype>(zmm_t18, zmm_t20);\n+    COEX<vtype>(zmm_t21, zmm_t23);\n+    COEX<vtype>(zmm_t22, zmm_t24);\n+    COEX<vtype>(zmm_t25, zmm_t27);\n+    COEX<vtype>(zmm_t26, zmm_t28);\n+    COEX<vtype>(zmm_t29, zmm_t31);\n+    COEX<vtype>(zmm_t30, zmm_t32);\n+    \/\/\n+    COEX<vtype>(zmm_t1, zmm_t2);\n+    COEX<vtype>(zmm_t3, zmm_t4);\n+    COEX<vtype>(zmm_t5, zmm_t6);\n+    COEX<vtype>(zmm_t7, zmm_t8);\n+    COEX<vtype>(zmm_t9, zmm_t10);\n+    COEX<vtype>(zmm_t11, zmm_t12);\n+    COEX<vtype>(zmm_t13, zmm_t14);\n+    COEX<vtype>(zmm_t15, zmm_t16);\n+    COEX<vtype>(zmm_t17, zmm_t18);\n+    COEX<vtype>(zmm_t19, zmm_t20);\n+    COEX<vtype>(zmm_t21, zmm_t22);\n+    COEX<vtype>(zmm_t23, zmm_t24);\n+    COEX<vtype>(zmm_t25, zmm_t26);\n+    COEX<vtype>(zmm_t27, zmm_t28);\n+    COEX<vtype>(zmm_t29, zmm_t30);\n+    COEX<vtype>(zmm_t31, zmm_t32);\n+    \/\/\n+    zmm[0] = bitonic_merge_zmm_64bit<vtype>(zmm_t1);\n+    zmm[1] = bitonic_merge_zmm_64bit<vtype>(zmm_t2);\n+    zmm[2] = bitonic_merge_zmm_64bit<vtype>(zmm_t3);\n+    zmm[3] = bitonic_merge_zmm_64bit<vtype>(zmm_t4);\n+    zmm[4] = bitonic_merge_zmm_64bit<vtype>(zmm_t5);\n+    zmm[5] = bitonic_merge_zmm_64bit<vtype>(zmm_t6);\n+    zmm[6] = bitonic_merge_zmm_64bit<vtype>(zmm_t7);\n+    zmm[7] = bitonic_merge_zmm_64bit<vtype>(zmm_t8);\n+    zmm[8] = bitonic_merge_zmm_64bit<vtype>(zmm_t9);\n+    zmm[9] = bitonic_merge_zmm_64bit<vtype>(zmm_t10);\n+    zmm[10] = bitonic_merge_zmm_64bit<vtype>(zmm_t11);\n+    zmm[11] = bitonic_merge_zmm_64bit<vtype>(zmm_t12);\n+    zmm[12] = bitonic_merge_zmm_64bit<vtype>(zmm_t13);\n+    zmm[13] = bitonic_merge_zmm_64bit<vtype>(zmm_t14);\n+    zmm[14] = bitonic_merge_zmm_64bit<vtype>(zmm_t15);\n+    zmm[15] = bitonic_merge_zmm_64bit<vtype>(zmm_t16);\n+    zmm[16] = bitonic_merge_zmm_64bit<vtype>(zmm_t17);\n+    zmm[17] = bitonic_merge_zmm_64bit<vtype>(zmm_t18);\n+    zmm[18] = bitonic_merge_zmm_64bit<vtype>(zmm_t19);\n+    zmm[19] = bitonic_merge_zmm_64bit<vtype>(zmm_t20);\n+    zmm[20] = bitonic_merge_zmm_64bit<vtype>(zmm_t21);\n+    zmm[21] = bitonic_merge_zmm_64bit<vtype>(zmm_t22);\n+    zmm[22] = bitonic_merge_zmm_64bit<vtype>(zmm_t23);\n+    zmm[23] = bitonic_merge_zmm_64bit<vtype>(zmm_t24);\n+    zmm[24] = bitonic_merge_zmm_64bit<vtype>(zmm_t25);\n+    zmm[25] = bitonic_merge_zmm_64bit<vtype>(zmm_t26);\n+    zmm[26] = bitonic_merge_zmm_64bit<vtype>(zmm_t27);\n+    zmm[27] = bitonic_merge_zmm_64bit<vtype>(zmm_t28);\n+    zmm[28] = bitonic_merge_zmm_64bit<vtype>(zmm_t29);\n+    zmm[29] = bitonic_merge_zmm_64bit<vtype>(zmm_t30);\n+    zmm[30] = bitonic_merge_zmm_64bit<vtype>(zmm_t31);\n+    zmm[31] = bitonic_merge_zmm_64bit<vtype>(zmm_t32);\n+}\n+\n+template <typename vtype, typename type_t>\n+X86_SIMD_SORT_INLINE void sort_8_64bit(type_t *arr, int32_t N) {\n+    typename vtype::opmask_t load_mask = (0x01 << N) - 0x01;\n+    typename vtype::zmm_t zmm =\n+        vtype::mask_loadu(vtype::zmm_max(), load_mask, arr);\n+    vtype::mask_storeu(arr, load_mask, sort_zmm_64bit<vtype>(zmm));\n+}\n+\n+template <typename vtype, typename type_t>\n+X86_SIMD_SORT_INLINE void sort_16_64bit(type_t *arr, int32_t N) {\n+    if (N <= 8) {\n+        sort_8_64bit<vtype>(arr, N);\n+        return;\n+    }\n+    using zmm_t = typename vtype::zmm_t;\n+    zmm_t zmm1 = vtype::loadu(arr);\n+    typename vtype::opmask_t load_mask = (0x01 << (N - 8)) - 0x01;\n+    zmm_t zmm2 = vtype::mask_loadu(vtype::zmm_max(), load_mask, arr + 8);\n+    zmm1 = sort_zmm_64bit<vtype>(zmm1);\n+    zmm2 = sort_zmm_64bit<vtype>(zmm2);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm1, zmm2);\n+    vtype::storeu(arr, zmm1);\n+    vtype::mask_storeu(arr + 8, load_mask, zmm2);\n+}\n+\n+template <typename vtype, typename type_t>\n+X86_SIMD_SORT_INLINE void sort_32_64bit(type_t *arr, int32_t N) {\n+    if (N <= 16) {\n+        sort_16_64bit<vtype>(arr, N);\n+        return;\n+    }\n+    using zmm_t = typename vtype::zmm_t;\n+    using opmask_t = typename vtype::opmask_t;\n+    zmm_t zmm[4];\n+    zmm[0] = vtype::loadu(arr);\n+    zmm[1] = vtype::loadu(arr + 8);\n+    opmask_t load_mask1 = 0xFF, load_mask2 = 0xFF;\n+    uint64_t combined_mask = (0x1ull << (N - 16)) - 0x1ull;\n+    load_mask1 = (combined_mask)&0xFF;\n+    load_mask2 = (combined_mask >> 8) & 0xFF;\n+    zmm[2] = vtype::mask_loadu(vtype::zmm_max(), load_mask1, arr + 16);\n+    zmm[3] = vtype::mask_loadu(vtype::zmm_max(), load_mask2, arr + 24);\n+    zmm[0] = sort_zmm_64bit<vtype>(zmm[0]);\n+    zmm[1] = sort_zmm_64bit<vtype>(zmm[1]);\n+    zmm[2] = sort_zmm_64bit<vtype>(zmm[2]);\n+    zmm[3] = sort_zmm_64bit<vtype>(zmm[3]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[0], zmm[1]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[2], zmm[3]);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm);\n+    vtype::storeu(arr, zmm[0]);\n+    vtype::storeu(arr + 8, zmm[1]);\n+    vtype::mask_storeu(arr + 16, load_mask1, zmm[2]);\n+    vtype::mask_storeu(arr + 24, load_mask2, zmm[3]);\n+}\n+\n+template <typename vtype, typename type_t>\n+X86_SIMD_SORT_INLINE void sort_64_64bit(type_t *arr, int32_t N) {\n+    if (N <= 32) {\n+        sort_32_64bit<vtype>(arr, N);\n+        return;\n+    }\n+    using zmm_t = typename vtype::zmm_t;\n+    using opmask_t = typename vtype::opmask_t;\n+    zmm_t zmm[8];\n+    zmm[0] = vtype::loadu(arr);\n+    zmm[1] = vtype::loadu(arr + 8);\n+    zmm[2] = vtype::loadu(arr + 16);\n+    zmm[3] = vtype::loadu(arr + 24);\n+    zmm[0] = sort_zmm_64bit<vtype>(zmm[0]);\n+    zmm[1] = sort_zmm_64bit<vtype>(zmm[1]);\n+    zmm[2] = sort_zmm_64bit<vtype>(zmm[2]);\n+    zmm[3] = sort_zmm_64bit<vtype>(zmm[3]);\n+    opmask_t load_mask1 = 0xFF, load_mask2 = 0xFF;\n+    opmask_t load_mask3 = 0xFF, load_mask4 = 0xFF;\n+    \/\/ N-32 >= 1\n+    uint64_t combined_mask = (0x1ull << (N - 32)) - 0x1ull;\n+    load_mask1 = (combined_mask)&0xFF;\n+    load_mask2 = (combined_mask >> 8) & 0xFF;\n+    load_mask3 = (combined_mask >> 16) & 0xFF;\n+    load_mask4 = (combined_mask >> 24) & 0xFF;\n+    zmm[4] = vtype::mask_loadu(vtype::zmm_max(), load_mask1, arr + 32);\n+    zmm[5] = vtype::mask_loadu(vtype::zmm_max(), load_mask2, arr + 40);\n+    zmm[6] = vtype::mask_loadu(vtype::zmm_max(), load_mask3, arr + 48);\n+    zmm[7] = vtype::mask_loadu(vtype::zmm_max(), load_mask4, arr + 56);\n+    zmm[4] = sort_zmm_64bit<vtype>(zmm[4]);\n+    zmm[5] = sort_zmm_64bit<vtype>(zmm[5]);\n+    zmm[6] = sort_zmm_64bit<vtype>(zmm[6]);\n+    zmm[7] = sort_zmm_64bit<vtype>(zmm[7]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[0], zmm[1]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[2], zmm[3]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[4], zmm[5]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[6], zmm[7]);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm + 4);\n+    bitonic_merge_eight_zmm_64bit<vtype>(zmm);\n+    vtype::storeu(arr, zmm[0]);\n+    vtype::storeu(arr + 8, zmm[1]);\n+    vtype::storeu(arr + 16, zmm[2]);\n+    vtype::storeu(arr + 24, zmm[3]);\n+    vtype::mask_storeu(arr + 32, load_mask1, zmm[4]);\n+    vtype::mask_storeu(arr + 40, load_mask2, zmm[5]);\n+    vtype::mask_storeu(arr + 48, load_mask3, zmm[6]);\n+    vtype::mask_storeu(arr + 56, load_mask4, zmm[7]);\n+}\n+\n+template <typename vtype, typename type_t>\n+X86_SIMD_SORT_INLINE void sort_128_64bit(type_t *arr, int32_t N) {\n+    if (N <= 64) {\n+        sort_64_64bit<vtype>(arr, N);\n+        return;\n+    }\n+    using zmm_t = typename vtype::zmm_t;\n+    using opmask_t = typename vtype::opmask_t;\n+    zmm_t zmm[16];\n+    zmm[0] = vtype::loadu(arr);\n+    zmm[1] = vtype::loadu(arr + 8);\n+    zmm[2] = vtype::loadu(arr + 16);\n+    zmm[3] = vtype::loadu(arr + 24);\n+    zmm[4] = vtype::loadu(arr + 32);\n+    zmm[5] = vtype::loadu(arr + 40);\n+    zmm[6] = vtype::loadu(arr + 48);\n+    zmm[7] = vtype::loadu(arr + 56);\n+    zmm[0] = sort_zmm_64bit<vtype>(zmm[0]);\n+    zmm[1] = sort_zmm_64bit<vtype>(zmm[1]);\n+    zmm[2] = sort_zmm_64bit<vtype>(zmm[2]);\n+    zmm[3] = sort_zmm_64bit<vtype>(zmm[3]);\n+    zmm[4] = sort_zmm_64bit<vtype>(zmm[4]);\n+    zmm[5] = sort_zmm_64bit<vtype>(zmm[5]);\n+    zmm[6] = sort_zmm_64bit<vtype>(zmm[6]);\n+    zmm[7] = sort_zmm_64bit<vtype>(zmm[7]);\n+    opmask_t load_mask1 = 0xFF, load_mask2 = 0xFF;\n+    opmask_t load_mask3 = 0xFF, load_mask4 = 0xFF;\n+    opmask_t load_mask5 = 0xFF, load_mask6 = 0xFF;\n+    opmask_t load_mask7 = 0xFF, load_mask8 = 0xFF;\n+    if (N != 128) {\n+        uint64_t combined_mask = (0x1ull << (N - 64)) - 0x1ull;\n+        load_mask1 = (combined_mask)&0xFF;\n+        load_mask2 = (combined_mask >> 8) & 0xFF;\n+        load_mask3 = (combined_mask >> 16) & 0xFF;\n+        load_mask4 = (combined_mask >> 24) & 0xFF;\n+        load_mask5 = (combined_mask >> 32) & 0xFF;\n+        load_mask6 = (combined_mask >> 40) & 0xFF;\n+        load_mask7 = (combined_mask >> 48) & 0xFF;\n+        load_mask8 = (combined_mask >> 56) & 0xFF;\n+    }\n+    zmm[8] = vtype::mask_loadu(vtype::zmm_max(), load_mask1, arr + 64);\n+    zmm[9] = vtype::mask_loadu(vtype::zmm_max(), load_mask2, arr + 72);\n+    zmm[10] = vtype::mask_loadu(vtype::zmm_max(), load_mask3, arr + 80);\n+    zmm[11] = vtype::mask_loadu(vtype::zmm_max(), load_mask4, arr + 88);\n+    zmm[12] = vtype::mask_loadu(vtype::zmm_max(), load_mask5, arr + 96);\n+    zmm[13] = vtype::mask_loadu(vtype::zmm_max(), load_mask6, arr + 104);\n+    zmm[14] = vtype::mask_loadu(vtype::zmm_max(), load_mask7, arr + 112);\n+    zmm[15] = vtype::mask_loadu(vtype::zmm_max(), load_mask8, arr + 120);\n+    zmm[8] = sort_zmm_64bit<vtype>(zmm[8]);\n+    zmm[9] = sort_zmm_64bit<vtype>(zmm[9]);\n+    zmm[10] = sort_zmm_64bit<vtype>(zmm[10]);\n+    zmm[11] = sort_zmm_64bit<vtype>(zmm[11]);\n+    zmm[12] = sort_zmm_64bit<vtype>(zmm[12]);\n+    zmm[13] = sort_zmm_64bit<vtype>(zmm[13]);\n+    zmm[14] = sort_zmm_64bit<vtype>(zmm[14]);\n+    zmm[15] = sort_zmm_64bit<vtype>(zmm[15]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[0], zmm[1]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[2], zmm[3]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[4], zmm[5]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[6], zmm[7]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[8], zmm[9]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[10], zmm[11]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[12], zmm[13]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[14], zmm[15]);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm + 4);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm + 8);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm + 12);\n+    bitonic_merge_eight_zmm_64bit<vtype>(zmm);\n+    bitonic_merge_eight_zmm_64bit<vtype>(zmm + 8);\n+    bitonic_merge_sixteen_zmm_64bit<vtype>(zmm);\n+    vtype::storeu(arr, zmm[0]);\n+    vtype::storeu(arr + 8, zmm[1]);\n+    vtype::storeu(arr + 16, zmm[2]);\n+    vtype::storeu(arr + 24, zmm[3]);\n+    vtype::storeu(arr + 32, zmm[4]);\n+    vtype::storeu(arr + 40, zmm[5]);\n+    vtype::storeu(arr + 48, zmm[6]);\n+    vtype::storeu(arr + 56, zmm[7]);\n+    vtype::mask_storeu(arr + 64, load_mask1, zmm[8]);\n+    vtype::mask_storeu(arr + 72, load_mask2, zmm[9]);\n+    vtype::mask_storeu(arr + 80, load_mask3, zmm[10]);\n+    vtype::mask_storeu(arr + 88, load_mask4, zmm[11]);\n+    vtype::mask_storeu(arr + 96, load_mask5, zmm[12]);\n+    vtype::mask_storeu(arr + 104, load_mask6, zmm[13]);\n+    vtype::mask_storeu(arr + 112, load_mask7, zmm[14]);\n+    vtype::mask_storeu(arr + 120, load_mask8, zmm[15]);\n+}\n+\n+template <typename vtype, typename type_t>\n+X86_SIMD_SORT_INLINE void sort_256_64bit(type_t *arr, int32_t N) {\n+    if (N <= 128) {\n+        sort_128_64bit<vtype>(arr, N);\n+        return;\n+    }\n+    using zmm_t = typename vtype::zmm_t;\n+    using opmask_t = typename vtype::opmask_t;\n+    zmm_t zmm[32];\n+    zmm[0] = vtype::loadu(arr);\n+    zmm[1] = vtype::loadu(arr + 8);\n+    zmm[2] = vtype::loadu(arr + 16);\n+    zmm[3] = vtype::loadu(arr + 24);\n+    zmm[4] = vtype::loadu(arr + 32);\n+    zmm[5] = vtype::loadu(arr + 40);\n+    zmm[6] = vtype::loadu(arr + 48);\n+    zmm[7] = vtype::loadu(arr + 56);\n+    zmm[8] = vtype::loadu(arr + 64);\n+    zmm[9] = vtype::loadu(arr + 72);\n+    zmm[10] = vtype::loadu(arr + 80);\n+    zmm[11] = vtype::loadu(arr + 88);\n+    zmm[12] = vtype::loadu(arr + 96);\n+    zmm[13] = vtype::loadu(arr + 104);\n+    zmm[14] = vtype::loadu(arr + 112);\n+    zmm[15] = vtype::loadu(arr + 120);\n+    zmm[0] = sort_zmm_64bit<vtype>(zmm[0]);\n+    zmm[1] = sort_zmm_64bit<vtype>(zmm[1]);\n+    zmm[2] = sort_zmm_64bit<vtype>(zmm[2]);\n+    zmm[3] = sort_zmm_64bit<vtype>(zmm[3]);\n+    zmm[4] = sort_zmm_64bit<vtype>(zmm[4]);\n+    zmm[5] = sort_zmm_64bit<vtype>(zmm[5]);\n+    zmm[6] = sort_zmm_64bit<vtype>(zmm[6]);\n+    zmm[7] = sort_zmm_64bit<vtype>(zmm[7]);\n+    zmm[8] = sort_zmm_64bit<vtype>(zmm[8]);\n+    zmm[9] = sort_zmm_64bit<vtype>(zmm[9]);\n+    zmm[10] = sort_zmm_64bit<vtype>(zmm[10]);\n+    zmm[11] = sort_zmm_64bit<vtype>(zmm[11]);\n+    zmm[12] = sort_zmm_64bit<vtype>(zmm[12]);\n+    zmm[13] = sort_zmm_64bit<vtype>(zmm[13]);\n+    zmm[14] = sort_zmm_64bit<vtype>(zmm[14]);\n+    zmm[15] = sort_zmm_64bit<vtype>(zmm[15]);\n+    opmask_t load_mask1 = 0xFF, load_mask2 = 0xFF;\n+    opmask_t load_mask3 = 0xFF, load_mask4 = 0xFF;\n+    opmask_t load_mask5 = 0xFF, load_mask6 = 0xFF;\n+    opmask_t load_mask7 = 0xFF, load_mask8 = 0xFF;\n+    opmask_t load_mask9 = 0xFF, load_mask10 = 0xFF;\n+    opmask_t load_mask11 = 0xFF, load_mask12 = 0xFF;\n+    opmask_t load_mask13 = 0xFF, load_mask14 = 0xFF;\n+    opmask_t load_mask15 = 0xFF, load_mask16 = 0xFF;\n+    if (N != 256) {\n+        uint64_t combined_mask;\n+        if (N < 192) {\n+            combined_mask = (0x1ull << (N - 128)) - 0x1ull;\n+            load_mask1 = (combined_mask)&0xFF;\n+            load_mask2 = (combined_mask >> 8) & 0xFF;\n+            load_mask3 = (combined_mask >> 16) & 0xFF;\n+            load_mask4 = (combined_mask >> 24) & 0xFF;\n+            load_mask5 = (combined_mask >> 32) & 0xFF;\n+            load_mask6 = (combined_mask >> 40) & 0xFF;\n+            load_mask7 = (combined_mask >> 48) & 0xFF;\n+            load_mask8 = (combined_mask >> 56) & 0xFF;\n+            load_mask9 = 0x00;\n+            load_mask10 = 0x0;\n+            load_mask11 = 0x00;\n+            load_mask12 = 0x00;\n+            load_mask13 = 0x00;\n+            load_mask14 = 0x00;\n+            load_mask15 = 0x00;\n+            load_mask16 = 0x00;\n+        } else {\n+            combined_mask = (0x1ull << (N - 192)) - 0x1ull;\n+            load_mask9 = (combined_mask)&0xFF;\n+            load_mask10 = (combined_mask >> 8) & 0xFF;\n+            load_mask11 = (combined_mask >> 16) & 0xFF;\n+            load_mask12 = (combined_mask >> 24) & 0xFF;\n+            load_mask13 = (combined_mask >> 32) & 0xFF;\n+            load_mask14 = (combined_mask >> 40) & 0xFF;\n+            load_mask15 = (combined_mask >> 48) & 0xFF;\n+            load_mask16 = (combined_mask >> 56) & 0xFF;\n+        }\n+    }\n+    zmm[16] = vtype::mask_loadu(vtype::zmm_max(), load_mask1, arr + 128);\n+    zmm[17] = vtype::mask_loadu(vtype::zmm_max(), load_mask2, arr + 136);\n+    zmm[18] = vtype::mask_loadu(vtype::zmm_max(), load_mask3, arr + 144);\n+    zmm[19] = vtype::mask_loadu(vtype::zmm_max(), load_mask4, arr + 152);\n+    zmm[20] = vtype::mask_loadu(vtype::zmm_max(), load_mask5, arr + 160);\n+    zmm[21] = vtype::mask_loadu(vtype::zmm_max(), load_mask6, arr + 168);\n+    zmm[22] = vtype::mask_loadu(vtype::zmm_max(), load_mask7, arr + 176);\n+    zmm[23] = vtype::mask_loadu(vtype::zmm_max(), load_mask8, arr + 184);\n+    if (N < 192) {\n+        zmm[24] = vtype::zmm_max();\n+        zmm[25] = vtype::zmm_max();\n+        zmm[26] = vtype::zmm_max();\n+        zmm[27] = vtype::zmm_max();\n+        zmm[28] = vtype::zmm_max();\n+        zmm[29] = vtype::zmm_max();\n+        zmm[30] = vtype::zmm_max();\n+        zmm[31] = vtype::zmm_max();\n+    } else {\n+        zmm[24] = vtype::mask_loadu(vtype::zmm_max(), load_mask9, arr + 192);\n+        zmm[25] = vtype::mask_loadu(vtype::zmm_max(), load_mask10, arr + 200);\n+        zmm[26] = vtype::mask_loadu(vtype::zmm_max(), load_mask11, arr + 208);\n+        zmm[27] = vtype::mask_loadu(vtype::zmm_max(), load_mask12, arr + 216);\n+        zmm[28] = vtype::mask_loadu(vtype::zmm_max(), load_mask13, arr + 224);\n+        zmm[29] = vtype::mask_loadu(vtype::zmm_max(), load_mask14, arr + 232);\n+        zmm[30] = vtype::mask_loadu(vtype::zmm_max(), load_mask15, arr + 240);\n+        zmm[31] = vtype::mask_loadu(vtype::zmm_max(), load_mask16, arr + 248);\n+    }\n+    zmm[16] = sort_zmm_64bit<vtype>(zmm[16]);\n+    zmm[17] = sort_zmm_64bit<vtype>(zmm[17]);\n+    zmm[18] = sort_zmm_64bit<vtype>(zmm[18]);\n+    zmm[19] = sort_zmm_64bit<vtype>(zmm[19]);\n+    zmm[20] = sort_zmm_64bit<vtype>(zmm[20]);\n+    zmm[21] = sort_zmm_64bit<vtype>(zmm[21]);\n+    zmm[22] = sort_zmm_64bit<vtype>(zmm[22]);\n+    zmm[23] = sort_zmm_64bit<vtype>(zmm[23]);\n+    zmm[24] = sort_zmm_64bit<vtype>(zmm[24]);\n+    zmm[25] = sort_zmm_64bit<vtype>(zmm[25]);\n+    zmm[26] = sort_zmm_64bit<vtype>(zmm[26]);\n+    zmm[27] = sort_zmm_64bit<vtype>(zmm[27]);\n+    zmm[28] = sort_zmm_64bit<vtype>(zmm[28]);\n+    zmm[29] = sort_zmm_64bit<vtype>(zmm[29]);\n+    zmm[30] = sort_zmm_64bit<vtype>(zmm[30]);\n+    zmm[31] = sort_zmm_64bit<vtype>(zmm[31]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[0], zmm[1]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[2], zmm[3]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[4], zmm[5]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[6], zmm[7]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[8], zmm[9]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[10], zmm[11]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[12], zmm[13]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[14], zmm[15]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[16], zmm[17]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[18], zmm[19]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[20], zmm[21]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[22], zmm[23]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[24], zmm[25]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[26], zmm[27]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[28], zmm[29]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[30], zmm[31]);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm + 4);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm + 8);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm + 12);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm + 16);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm + 20);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm + 24);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm + 28);\n+    bitonic_merge_eight_zmm_64bit<vtype>(zmm);\n+    bitonic_merge_eight_zmm_64bit<vtype>(zmm + 8);\n+    bitonic_merge_eight_zmm_64bit<vtype>(zmm + 16);\n+    bitonic_merge_eight_zmm_64bit<vtype>(zmm + 24);\n+    bitonic_merge_sixteen_zmm_64bit<vtype>(zmm);\n+    bitonic_merge_sixteen_zmm_64bit<vtype>(zmm + 16);\n+    bitonic_merge_32_zmm_64bit<vtype>(zmm);\n+    vtype::storeu(arr, zmm[0]);\n+    vtype::storeu(arr + 8, zmm[1]);\n+    vtype::storeu(arr + 16, zmm[2]);\n+    vtype::storeu(arr + 24, zmm[3]);\n+    vtype::storeu(arr + 32, zmm[4]);\n+    vtype::storeu(arr + 40, zmm[5]);\n+    vtype::storeu(arr + 48, zmm[6]);\n+    vtype::storeu(arr + 56, zmm[7]);\n+    vtype::storeu(arr + 64, zmm[8]);\n+    vtype::storeu(arr + 72, zmm[9]);\n+    vtype::storeu(arr + 80, zmm[10]);\n+    vtype::storeu(arr + 88, zmm[11]);\n+    vtype::storeu(arr + 96, zmm[12]);\n+    vtype::storeu(arr + 104, zmm[13]);\n+    vtype::storeu(arr + 112, zmm[14]);\n+    vtype::storeu(arr + 120, zmm[15]);\n+    vtype::mask_storeu(arr + 128, load_mask1, zmm[16]);\n+    vtype::mask_storeu(arr + 136, load_mask2, zmm[17]);\n+    vtype::mask_storeu(arr + 144, load_mask3, zmm[18]);\n+    vtype::mask_storeu(arr + 152, load_mask4, zmm[19]);\n+    vtype::mask_storeu(arr + 160, load_mask5, zmm[20]);\n+    vtype::mask_storeu(arr + 168, load_mask6, zmm[21]);\n+    vtype::mask_storeu(arr + 176, load_mask7, zmm[22]);\n+    vtype::mask_storeu(arr + 184, load_mask8, zmm[23]);\n+    if (N > 192) {\n+        vtype::mask_storeu(arr + 192, load_mask9, zmm[24]);\n+        vtype::mask_storeu(arr + 200, load_mask10, zmm[25]);\n+        vtype::mask_storeu(arr + 208, load_mask11, zmm[26]);\n+        vtype::mask_storeu(arr + 216, load_mask12, zmm[27]);\n+        vtype::mask_storeu(arr + 224, load_mask13, zmm[28]);\n+        vtype::mask_storeu(arr + 232, load_mask14, zmm[29]);\n+        vtype::mask_storeu(arr + 240, load_mask15, zmm[30]);\n+        vtype::mask_storeu(arr + 248, load_mask16, zmm[31]);\n+    }\n+}\n+\n+template <typename vtype, typename type_t>\n+static void qsort_64bit_(type_t *arr, int64_t left, int64_t right,\n+                         int64_t max_iters) {\n+    \/*\n+     * Resort to std::sort if quicksort isnt making any progress\n+     *\/\n+    if (max_iters <= 0) {\n+        std::sort(arr + left, arr + right + 1);\n+        return;\n+    }\n+    \/*\n+     * Base case: use bitonic networks to sort arrays <= 128\n+     *\/\n+    if (right + 1 - left <= 256) {\n+        sort_256_64bit<vtype>(arr + left, (int32_t)(right + 1 - left));\n+        return;\n+    }\n+\n+    type_t pivot = get_pivot_scalar<type_t>(arr, left, right);\n+    type_t smallest = vtype::type_max();\n+    type_t biggest = vtype::type_min();\n+    int64_t pivot_index = partition_avx512_unrolled<vtype, 8>(\n+        arr, left, right + 1, pivot, &smallest, &biggest, false);\n+    if (pivot != smallest)\n+        qsort_64bit_<vtype>(arr, left, pivot_index - 1, max_iters - 1);\n+    if (pivot != biggest)\n+        qsort_64bit_<vtype>(arr, pivot_index, right, max_iters - 1);\n+}\n+\n+template <>\n+void inline avx512_qsort<int64_t>(int64_t *arr, int64_t fromIndex, int64_t toIndex) {\n+    int64_t arrsize = toIndex - fromIndex;\n+    if (arrsize > 1) {\n+        qsort_64bit_<zmm_vector<int64_t>, int64_t>(arr, fromIndex, toIndex - 1,\n+                                                   2 * (int64_t)log2(arrsize));\n+    }\n+}\n+\n+template <>\n+void inline avx512_qsort<double>(double *arr, int64_t fromIndex, int64_t toIndex) {\n+    int64_t arrsize = toIndex - fromIndex;\n+    if (arrsize > 1) {\n+        qsort_64bit_<zmm_vector<double>, double>(arr, fromIndex, toIndex - 1,\n+                                                 2 * (int64_t)log2(arrsize));\n+    }\n+}\n+\n+#endif  \/\/ AVX512_QSORT_64BIT\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avx512-64bit-qsort.hpp","additions":774,"deletions":0,"binary":false,"changes":774,"status":"added"},{"patch":"@@ -0,0 +1,472 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2021 Serge Sans Paille. All rights reserved.\n+ * Intel x86-simd-sort source code.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This implementation is based on x86-simd-sort(https:\/\/github.com\/intel\/x86-simd-sort)\n+#ifndef AVX512_QSORT_COMMON\n+#define AVX512_QSORT_COMMON\n+\n+\/*\n+ * Quicksort using AVX-512. The ideas and code are based on these two research\n+ * papers [1] and [2]. On a high level, the idea is to vectorize quicksort\n+ * partitioning using AVX-512 compressstore instructions. If the array size is\n+ * < 128, then use Bitonic sorting network implemented on 512-bit registers.\n+ * The precise network definitions depend on the dtype and are defined in\n+ * separate files: avx512-16bit-qsort.hpp, avx512-32bit-qsort.hpp and\n+ * avx512-64bit-qsort.hpp. Article [4] is a good resource for bitonic sorting\n+ * network. The core implementations of the vectorized qsort functions\n+ * avx512_qsort<T>(T*, int64_t) are modified versions of avx2 quicksort\n+ * presented in the paper [2] and source code associated with that paper [3].\n+ *\n+ * [1] Fast and Robust Vectorized In-Place Sorting of Primitive Types\n+ *     https:\/\/drops.dagstuhl.de\/opus\/volltexte\/2021\/13775\/\n+ *\n+ * [2] A Novel Hybrid Quicksort Algorithm Vectorized using AVX-512 on Intel\n+ * Skylake https:\/\/arxiv.org\/pdf\/1704.08579.pdf\n+ *\n+ * [3] https:\/\/github.com\/simd-sorting\/fast-and-robust: SPDX-License-Identifier:\n+ * MIT\n+ *\n+ * [4]\n+ * http:\/\/mitp-content-server.mit.edu:18180\/books\/content\/sectbyfn?collid=books_pres_0&fn=Chapter%2027.pdf&id=8030\n+ *\n+ *\/\n+\n+#include <algorithm>\n+#include <cmath>\n+#include <cstdint>\n+#include <cstring>\n+#include <immintrin.h>\n+#include <limits>\n+\n+#define X86_SIMD_SORT_INFINITY std::numeric_limits<double>::infinity()\n+#define X86_SIMD_SORT_INFINITYF std::numeric_limits<float>::infinity()\n+#define X86_SIMD_SORT_INFINITYH 0x7c00\n+#define X86_SIMD_SORT_NEGINFINITYH 0xfc00\n+#define X86_SIMD_SORT_MAX_UINT16 std::numeric_limits<uint16_t>::max()\n+#define X86_SIMD_SORT_MAX_INT16 std::numeric_limits<int16_t>::max()\n+#define X86_SIMD_SORT_MIN_INT16 std::numeric_limits<int16_t>::min()\n+#define X86_SIMD_SORT_MAX_UINT32 std::numeric_limits<uint32_t>::max()\n+#define X86_SIMD_SORT_MAX_INT32 std::numeric_limits<int32_t>::max()\n+#define X86_SIMD_SORT_MIN_INT32 std::numeric_limits<int32_t>::min()\n+#define X86_SIMD_SORT_MAX_UINT64 std::numeric_limits<uint64_t>::max()\n+#define X86_SIMD_SORT_MAX_INT64 std::numeric_limits<int64_t>::max()\n+#define X86_SIMD_SORT_MIN_INT64 std::numeric_limits<int64_t>::min()\n+#define ZMM_MAX_DOUBLE _mm512_set1_pd(X86_SIMD_SORT_INFINITY)\n+#define ZMM_MAX_UINT64 _mm512_set1_epi64(X86_SIMD_SORT_MAX_UINT64)\n+#define ZMM_MAX_INT64 _mm512_set1_epi64(X86_SIMD_SORT_MAX_INT64)\n+#define ZMM_MAX_FLOAT _mm512_set1_ps(X86_SIMD_SORT_INFINITYF)\n+#define ZMM_MAX_UINT _mm512_set1_epi32(X86_SIMD_SORT_MAX_UINT32)\n+#define ZMM_MAX_INT _mm512_set1_epi32(X86_SIMD_SORT_MAX_INT32)\n+#define ZMM_MAX_HALF _mm512_set1_epi16(X86_SIMD_SORT_INFINITYH)\n+#define YMM_MAX_HALF _mm256_set1_epi16(X86_SIMD_SORT_INFINITYH)\n+#define ZMM_MAX_UINT16 _mm512_set1_epi16(X86_SIMD_SORT_MAX_UINT16)\n+#define ZMM_MAX_INT16 _mm512_set1_epi16(X86_SIMD_SORT_MAX_INT16)\n+#define SHUFFLE_MASK(a, b, c, d) (a << 6) | (b << 4) | (c << 2) | d\n+\n+#ifdef _MSC_VER\n+#define X86_SIMD_SORT_INLINE static inline\n+#define X86_SIMD_SORT_FINLINE static __forceinline\n+#elif defined(__CYGWIN__)\n+\/*\n+ * Force inline in cygwin to work around a compiler bug. See\n+ * https:\/\/github.com\/numpy\/numpy\/pull\/22315#issuecomment-1267757584\n+ *\/\n+#define X86_SIMD_SORT_INLINE static __attribute__((always_inline))\n+#define X86_SIMD_SORT_FINLINE static __attribute__((always_inline))\n+#elif defined(__GNUC__)\n+#define X86_SIMD_SORT_INLINE static inline\n+#define X86_SIMD_SORT_FINLINE static __attribute__((always_inline))\n+#else\n+#define X86_SIMD_SORT_INLINE static\n+#define X86_SIMD_SORT_FINLINE static\n+#endif\n+\n+#define LIKELY(x) __builtin_expect((x), 1)\n+#define UNLIKELY(x) __builtin_expect((x), 0)\n+\n+template <typename type>\n+struct zmm_vector;\n+\n+template <typename type>\n+struct ymm_vector;\n+\n+\/\/ Regular quicksort routines:\n+template <typename T>\n+void avx512_qsort(T *arr, int64_t arrsize);\n+\n+template <typename T>\n+void inline avx512_qsort(T *arr, int64_t from_index, int64_t to_index);\n+\n+template <typename T>\n+bool is_a_nan(T elem) {\n+    return std::isnan(elem);\n+}\n+\n+template <typename T>\n+X86_SIMD_SORT_INLINE T get_pivot_scalar(T *arr, const int64_t left, const int64_t right) {\n+    \/\/ median of 8 equally spaced elements\n+    int64_t NUM_ELEMENTS = 8;\n+    int64_t MID = NUM_ELEMENTS \/ 2;\n+    int64_t size = (right - left) \/ NUM_ELEMENTS;\n+    T temp[NUM_ELEMENTS];\n+    for (int64_t i = 0; i < NUM_ELEMENTS; i++) temp[i] = arr[left + (i * size)];\n+    std::sort(temp, temp + NUM_ELEMENTS);\n+    return temp[MID];\n+}\n+\n+template <typename vtype, typename T = typename vtype::type_t>\n+bool comparison_func_ge(const T &a, const T &b) {\n+    return a < b;\n+}\n+\n+template <typename vtype, typename T = typename vtype::type_t>\n+bool comparison_func_gt(const T &a, const T &b) {\n+    return a <= b;\n+}\n+\n+\/*\n+ * COEX == Compare and Exchange two registers by swapping min and max values\n+ *\/\n+template <typename vtype, typename mm_t>\n+static void COEX(mm_t &a, mm_t &b) {\n+    mm_t temp = a;\n+    a = vtype::min(a, b);\n+    b = vtype::max(temp, b);\n+}\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t,\n+          typename opmask_t = typename vtype::opmask_t>\n+static inline zmm_t cmp_merge(zmm_t in1, zmm_t in2, opmask_t mask) {\n+    zmm_t min = vtype::min(in2, in1);\n+    zmm_t max = vtype::max(in2, in1);\n+    return vtype::mask_mov(min, mask, max);  \/\/ 0 -> min, 1 -> max\n+}\n+\/*\n+ * Parition one ZMM register based on the pivot and returns the\n+ * number of elements that are greater than or equal to the pivot.\n+ *\/\n+template <typename vtype, typename type_t, typename zmm_t>\n+static inline int32_t partition_vec(type_t *arr, int64_t left, int64_t right,\n+                                    const zmm_t curr_vec, const zmm_t pivot_vec,\n+                                    zmm_t *smallest_vec, zmm_t *biggest_vec, bool use_gt) {\n+    \/* which elements are larger than or equal to the pivot *\/\n+    typename vtype::opmask_t mask;\n+    if (use_gt) mask = vtype::gt(curr_vec, pivot_vec);\n+    else mask = vtype::ge(curr_vec, pivot_vec);\n+    \/\/mask = vtype::ge(curr_vec, pivot_vec);\n+    int32_t amount_ge_pivot = _mm_popcnt_u32((int32_t)mask);\n+    vtype::mask_compressstoreu(arr + left, vtype::knot_opmask(mask),\n+                               curr_vec);\n+    vtype::mask_compressstoreu(arr + right - amount_ge_pivot, mask,\n+                               curr_vec);\n+    *smallest_vec = vtype::min(curr_vec, *smallest_vec);\n+    *biggest_vec = vtype::max(curr_vec, *biggest_vec);\n+    return amount_ge_pivot;\n+}\n+\/*\n+ * Parition an array based on the pivot and returns the index of the\n+ * first element that is greater than or equal to the pivot.\n+ *\/\n+template <typename vtype, typename type_t>\n+static inline int64_t partition_avx512(type_t *arr, int64_t left, int64_t right,\n+                                       type_t pivot, type_t *smallest,\n+                                       type_t *biggest, bool use_gt) {\n+    auto comparison_func = use_gt ? comparison_func_gt<vtype> : comparison_func_ge<vtype>;\n+    \/* make array length divisible by vtype::numlanes , shortening the array *\/\n+    for (int32_t i = (right - left) % vtype::numlanes; i > 0; --i) {\n+        *smallest = std::min(*smallest, arr[left], comparison_func);\n+        *biggest = std::max(*biggest, arr[left], comparison_func);\n+        if (!comparison_func(arr[left], pivot)) {\n+            std::swap(arr[left], arr[--right]);\n+        } else {\n+            ++left;\n+        }\n+    }\n+\n+    if (left == right)\n+        return left; \/* less than vtype::numlanes elements in the array *\/\n+\n+    using zmm_t = typename vtype::zmm_t;\n+    zmm_t pivot_vec = vtype::set1(pivot);\n+    zmm_t min_vec = vtype::set1(*smallest);\n+    zmm_t max_vec = vtype::set1(*biggest);\n+\n+    if (right - left == vtype::numlanes) {\n+        zmm_t vec = vtype::loadu(arr + left);\n+        int32_t amount_ge_pivot =\n+            partition_vec<vtype>(arr, left, left + vtype::numlanes, vec,\n+                                 pivot_vec, &min_vec, &max_vec, use_gt);\n+        *smallest = vtype::reducemin(min_vec);\n+        *biggest = vtype::reducemax(max_vec);\n+        return left + (vtype::numlanes - amount_ge_pivot);\n+    }\n+\n+    \/\/ first and last vtype::numlanes values are partitioned at the end\n+    zmm_t vec_left = vtype::loadu(arr + left);\n+    zmm_t vec_right = vtype::loadu(arr + (right - vtype::numlanes));\n+    \/\/ store points of the vectors\n+    int64_t r_store = right - vtype::numlanes;\n+    int64_t l_store = left;\n+    \/\/ indices for loading the elements\n+    left += vtype::numlanes;\n+    right -= vtype::numlanes;\n+    while (right - left != 0) {\n+        zmm_t curr_vec;\n+        \/*\n+         * if fewer elements are stored on the right side of the array,\n+         * then next elements are loaded from the right side,\n+         * otherwise from the left side\n+         *\/\n+        if ((r_store + vtype::numlanes) - right < left - l_store) {\n+            right -= vtype::numlanes;\n+            curr_vec = vtype::loadu(arr + right);\n+        } else {\n+            curr_vec = vtype::loadu(arr + left);\n+            left += vtype::numlanes;\n+        }\n+        \/\/ partition the current vector and save it on both sides of the array\n+        int32_t amount_ge_pivot =\n+            partition_vec<vtype>(arr, l_store, r_store + vtype::numlanes,\n+                                 curr_vec, pivot_vec, &min_vec, &max_vec, use_gt);\n+        ;\n+        r_store -= amount_ge_pivot;\n+        l_store += (vtype::numlanes - amount_ge_pivot);\n+    }\n+\n+    \/* partition and save vec_left and vec_right *\/\n+    int32_t amount_ge_pivot =\n+        partition_vec<vtype>(arr, l_store, r_store + vtype::numlanes, vec_left,\n+                             pivot_vec, &min_vec, &max_vec, use_gt);\n+    l_store += (vtype::numlanes - amount_ge_pivot);\n+    amount_ge_pivot =\n+        partition_vec<vtype>(arr, l_store, l_store + vtype::numlanes, vec_right,\n+                             pivot_vec, &min_vec, &max_vec, use_gt);\n+    l_store += (vtype::numlanes - amount_ge_pivot);\n+    *smallest = vtype::reducemin(min_vec);\n+    *biggest = vtype::reducemax(max_vec);\n+    return l_store;\n+}\n+\n+template <typename vtype, int num_unroll,\n+          typename type_t = typename vtype::type_t>\n+static inline int64_t partition_avx512_unrolled(type_t *arr, int64_t left,\n+                                                int64_t right, type_t pivot,\n+                                                type_t *smallest,\n+                                                type_t *biggest, bool use_gt) {\n+    if (right - left <= 2 * num_unroll * vtype::numlanes) {\n+        return partition_avx512<vtype>(arr, left, right, pivot, smallest,\n+                                       biggest, use_gt);\n+    }\n+\n+    auto comparison_func = use_gt ? comparison_func_gt<vtype> : comparison_func_ge<vtype>;\n+    \/* make array length divisible by 8*vtype::numlanes , shortening the array\n+     *\/\n+    for (int32_t i = ((right - left) % (num_unroll * vtype::numlanes)); i > 0;\n+         --i) {\n+        *smallest = std::min(*smallest, arr[left], comparison_func);\n+        *biggest = std::max(*biggest, arr[left], comparison_func);\n+        if (!comparison_func(arr[left], pivot)) {\n+            std::swap(arr[left], arr[--right]);\n+        } else {\n+            ++left;\n+        }\n+    }\n+\n+    if (left == right)\n+        return left; \/* less than vtype::numlanes elements in the array *\/\n+\n+    using zmm_t = typename vtype::zmm_t;\n+    zmm_t pivot_vec = vtype::set1(pivot);\n+    zmm_t min_vec = vtype::set1(*smallest);\n+    zmm_t max_vec = vtype::set1(*biggest);\n+\n+    \/\/ We will now have atleast 16 registers worth of data to process:\n+    \/\/ left and right vtype::numlanes values are partitioned at the end\n+    zmm_t vec_left[num_unroll], vec_right[num_unroll];\n+#pragma GCC unroll 8\n+    for (int ii = 0; ii < num_unroll; ++ii) {\n+        vec_left[ii] = vtype::loadu(arr + left + vtype::numlanes * ii);\n+        vec_right[ii] =\n+            vtype::loadu(arr + (right - vtype::numlanes * (num_unroll - ii)));\n+    }\n+    \/\/ store points of the vectors\n+    int64_t r_store = right - vtype::numlanes;\n+    int64_t l_store = left;\n+    \/\/ indices for loading the elements\n+    left += num_unroll * vtype::numlanes;\n+    right -= num_unroll * vtype::numlanes;\n+    while (right - left != 0) {\n+        zmm_t curr_vec[num_unroll];\n+        \/*\n+         * if fewer elements are stored on the right side of the array,\n+         * then next elements are loaded from the right side,\n+         * otherwise from the left side\n+         *\/\n+        if ((r_store + vtype::numlanes) - right < left - l_store) {\n+            right -= num_unroll * vtype::numlanes;\n+#pragma GCC unroll 8\n+            for (int ii = 0; ii < num_unroll; ++ii) {\n+                curr_vec[ii] = vtype::loadu(arr + right + ii * vtype::numlanes);\n+            }\n+        } else {\n+#pragma GCC unroll 8\n+            for (int ii = 0; ii < num_unroll; ++ii) {\n+                curr_vec[ii] = vtype::loadu(arr + left + ii * vtype::numlanes);\n+            }\n+            left += num_unroll * vtype::numlanes;\n+        }\n+\/\/ partition the current vector and save it on both sides of the array\n+#pragma GCC unroll 8\n+        for (int ii = 0; ii < num_unroll; ++ii) {\n+            int32_t amount_ge_pivot = partition_vec<vtype>(\n+                arr, l_store, r_store + vtype::numlanes, curr_vec[ii],\n+                pivot_vec, &min_vec, &max_vec, use_gt);\n+            l_store += (vtype::numlanes - amount_ge_pivot);\n+            r_store -= amount_ge_pivot;\n+        }\n+    }\n+\n+\/* partition and save vec_left[8] and vec_right[8] *\/\n+#pragma GCC unroll 8\n+    for (int ii = 0; ii < num_unroll; ++ii) {\n+        int32_t amount_ge_pivot =\n+            partition_vec<vtype>(arr, l_store, r_store + vtype::numlanes,\n+                                 vec_left[ii], pivot_vec, &min_vec, &max_vec, use_gt);\n+        l_store += (vtype::numlanes - amount_ge_pivot);\n+        r_store -= amount_ge_pivot;\n+    }\n+#pragma GCC unroll 8\n+    for (int ii = 0; ii < num_unroll; ++ii) {\n+        int32_t amount_ge_pivot =\n+            partition_vec<vtype>(arr, l_store, r_store + vtype::numlanes,\n+                                 vec_right[ii], pivot_vec, &min_vec, &max_vec, use_gt);\n+        l_store += (vtype::numlanes - amount_ge_pivot);\n+        r_store -= amount_ge_pivot;\n+    }\n+    *smallest = vtype::reducemin(min_vec);\n+    *biggest = vtype::reducemax(max_vec);\n+    return l_store;\n+}\n+\n+\/\/ to_index (exclusive)\n+template <typename vtype, typename type_t>\n+static int64_t vectorized_partition(type_t *arr, int64_t from_index, int64_t to_index, type_t pivot, bool use_gt) {\n+    type_t smallest = vtype::type_max();\n+    type_t biggest = vtype::type_min();\n+    int64_t pivot_index = partition_avx512_unrolled<vtype, 2>(\n+            arr, from_index, to_index, pivot, &smallest, &biggest, use_gt);\n+    return pivot_index;\n+}\n+\n+\/\/ partitioning functions\n+template <typename T>\n+void avx512_dual_pivot_partition(T *arr, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int64_t index_pivot1, int64_t index_pivot2){\n+    const T pivot1 = arr[index_pivot1];\n+    const T pivot2 = arr[index_pivot2];\n+\n+    const int64_t low = from_index;\n+    const int64_t high = to_index;\n+    const int64_t start = low + 1;\n+    const int64_t end = high - 1;\n+\n+\n+    std::swap(arr[index_pivot1], arr[low]);\n+    std::swap(arr[index_pivot2], arr[end]);\n+\n+\n+    const int64_t pivot_index2 = vectorized_partition<zmm_vector<T>, T>(arr, start, end, pivot2, true); \/\/ use_gt = true\n+    std::swap(arr[end], arr[pivot_index2]);\n+    int64_t upper = pivot_index2;\n+\n+    \/\/ if all other elements are greater than pivot2 (and pivot1), no need to do further partitioning\n+    if (upper == start) {\n+        pivot_indices[0] = low;\n+        pivot_indices[1] = upper;\n+        return;\n+    }\n+\n+    const int64_t pivot_index1 = vectorized_partition<zmm_vector<T>, T>(arr, start, upper, pivot1, false); \/\/ use_ge (use_gt = false)\n+    int64_t lower = pivot_index1 - 1;\n+    std::swap(arr[low], arr[lower]);\n+\n+    pivot_indices[0] = lower;\n+    pivot_indices[1] = upper;\n+}\n+\n+template <typename T>\n+void avx512_single_pivot_partition(T *arr, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int64_t index_pivot){\n+    const T pivot = arr[index_pivot];\n+\n+    const int64_t low = from_index;\n+    const int64_t high = to_index;\n+    const int64_t end = high - 1;\n+\n+\n+    const int64_t pivot_index1 = vectorized_partition<zmm_vector<T>, T>(arr, low, high, pivot, false); \/\/ use_gt = false (use_ge)\n+    int64_t lower = pivot_index1;\n+\n+    const int64_t pivot_index2 = vectorized_partition<zmm_vector<T>, T>(arr, pivot_index1, high, pivot, true); \/\/ use_gt = true\n+    int64_t upper = pivot_index2;\n+\n+    pivot_indices[0] = lower;\n+    pivot_indices[1] = upper;\n+}\n+\n+template <typename T>\n+void inline avx512_partition(T *arr, int64_t from_index, int64_t to_index, int32_t *pivot_indices, bool is_dual_pviot) {\n+    if(is_dual_pviot) avx512_dual_pivot_partition<T>(arr, from_index, to_index, pivot_indices);\n+        else avx512_single_pivot_partition<T>(arr, from_index, to_index, pivot_indices);\n+}\n+\n+template <typename T>\n+void inline insertion_sort(T *arr, int32_t from_index, int32_t to_index) {\n+    for (int i, k = from_index; ++k < to_index; ) {\n+        T ai = arr[i = k];\n+\n+        if (ai < arr[i - 1]) {\n+            while (--i >= from_index && ai < arr[i]) {\n+                arr[i + 1] = arr[i];\n+            }\n+            arr[i + 1] = ai;\n+        }\n+    }\n+}\n+\n+template <typename T>\n+void inline avx512_fastsort(T *arr, int64_t from_index, int64_t to_index, const int32_t INS_SORT_THRESHOLD) {\n+    int32_t size = to_index - from_index;\n+\n+    if (size <= INS_SORT_THRESHOLD) {\n+        insertion_sort<T>(arr, from_index, to_index);\n+    }\n+    else {\n+        avx512_qsort<T>(arr, from_index, to_index);\n+    }\n+}\n+\n+\n+\n+#endif  \/\/ AVX512_QSORT_COMMON\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avx512-common-qsort.h","additions":472,"deletions":0,"binary":false,"changes":472,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2023 Intel Corporation. All rights reserved.\n+ * Intel x86-simd-sort source code.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#pragma GCC target(\"avx512dq\", \"avx512f\")\n+#include \"avx512-32bit-qsort.hpp\"\n+#include \"avx512-64bit-qsort.hpp\"\n+\n+#define DLL_PUBLIC __attribute__((visibility(\"default\")))\n+#define INSERTION_SORT_THRESHOLD_32BIT 16\n+#define INSERTION_SORT_THRESHOLD_64BIT 20\n+\n+extern \"C\" {\n+\n+    DLL_PUBLIC void avx512_sort_int(int32_t *array, int64_t from_index, int64_t to_index) {\n+        avx512_fastsort<int32_t>(array, from_index, to_index, INSERTION_SORT_THRESHOLD_32BIT);\n+    }\n+\n+    DLL_PUBLIC void avx512_sort_long(int64_t *array, int64_t from_index, int64_t to_index) {\n+        avx512_fastsort<int64_t>(array, from_index, to_index, INSERTION_SORT_THRESHOLD_64BIT);\n+    }\n+\n+    DLL_PUBLIC void avx512_sort_float(float *array, int64_t from_index, int64_t to_index) {\n+        avx512_fastsort<float>(array, from_index, to_index, INSERTION_SORT_THRESHOLD_32BIT);\n+    }\n+\n+    DLL_PUBLIC void avx512_sort_double(double *array, int64_t from_index, int64_t to_index) {\n+        avx512_fastsort<double>(array, from_index, to_index, INSERTION_SORT_THRESHOLD_64BIT);\n+    }\n+\n+    DLL_PUBLIC void avx512_partition_single_int(int32_t *array, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int32_t index_pivot) {\n+        avx512_single_pivot_partition<int32_t>(array, from_index, to_index, pivot_indices, index_pivot);\n+    }\n+\n+    DLL_PUBLIC void avx512_partition_dual_int(int32_t *array, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int32_t index_pivot1, int32_t index_pivot2) {\n+        avx512_dual_pivot_partition<int32_t>(array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n+    }\n+\n+    DLL_PUBLIC void avx512_partition_single_long(int64_t *array, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int32_t index_pivot) {\n+        avx512_single_pivot_partition<int64_t>(array, from_index, to_index, pivot_indices, index_pivot);\n+    }\n+\n+    DLL_PUBLIC void avx512_partition_dual_long(int64_t *array, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int32_t index_pivot1, int32_t index_pivot2) {\n+        avx512_dual_pivot_partition<int64_t>(array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n+    }\n+\n+    DLL_PUBLIC void avx512_partition_single_float(float *array, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int32_t index_pivot) {\n+        avx512_single_pivot_partition<float>(array, from_index, to_index, pivot_indices, index_pivot);\n+    }\n+\n+    DLL_PUBLIC void avx512_partition_dual_float(float *array, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int32_t index_pivot1, int32_t index_pivot2) {\n+        avx512_dual_pivot_partition<float>(array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n+    }\n+\n+    DLL_PUBLIC void avx512_partition_single_double(double *array, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int32_t index_pivot) {\n+        avx512_single_pivot_partition<double>(array, from_index, to_index, pivot_indices, index_pivot);\n+    }\n+\n+    DLL_PUBLIC void avx512_partition_dual_double(double *array, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int32_t index_pivot1, int32_t index_pivot2) {\n+        avx512_dual_pivot_partition<double>(array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n+    }\n+\n+}\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avxsort_linux_x86.cpp","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,5 @@\n+import java.util.Arrays;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n@@ -123,0 +128,98 @@\n+    \/**\n+     * Sorts the specified array into ascending numerical order using\n+     * mixed insertion sort.The intrinsic is free to choose its own\n+     * sorting algorithm.\n+     *\n+     * @param elemType the class of the elements of the array to be sorted\n+     * @param array the array to be sorted\n+     * @param offset the relative offset, in bytes, from the base address of\n+     * the array to sort, otherwise if the array is {@code null},an absolute\n+     * address pointing to the first element to sort from.\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @param end the index of the last element for simple insertion sort\n+     *\/\n+    @IntrinsicCandidate\n+    private static void mixedInsertionSort(Class<?> elemType, Object array, long offset, int low, int high, int end) {\n+        switch (array) {\n+            case int[] arr -> mixedInsertionSort(arr, low, end, high);\n+            case long[] arr ->  mixedInsertionSort(arr, low, end, high);\n+            case float[] arr ->  mixedInsertionSort(arr, low, end, high);\n+            case double[] arr ->  mixedInsertionSort(arr, low, end, high);\n+            default -> throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    \/**\n+     * Sorts the specified array into ascending numerical order using\n+     * insertion sort.The intrinsic is free to choose its own\n+     * sorting algorithm.\n+     *\n+     * @param elemType the class of the elements of the array to be sorted\n+     * @param array the array to be sorted\n+     * @param offset the relative offset, in bytes, from the base address of\n+     * the array to sort, otherwise if the array is {@code null},an absolute\n+     * address pointing to the first element to sort from.\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    @IntrinsicCandidate\n+    private static void insertionSort(Class<?> elemType, Object array, long offset, int low, int high) {\n+       switch (array) {\n+            case int[] arr -> insertionSort(arr, low, high);\n+            case long[] arr -> insertionSort(arr, low, high);\n+            case float[] arr -> insertionSort(arr, low, high);\n+            case double[] arr -> insertionSort(arr, low, high);\n+            default -> throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    \/**\n+     * Partitions the specified array based on the two pivots provided.\n+     *\n+     * @param elemType the class of the array to be sorted\n+     * @param array the array to be sorted\n+     * @param offset the relative offset, in bytes, from the base address of\n+     * the array to partition, otherwise if the array is {@code null},an absolute\n+     * address pointing to the first element to partition from.\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @param indexPivot1 the index of pivot1, the first pivot\n+     * @param indexPivot2 the index of pivot2, the second pivot\n+     *\/\n+    @IntrinsicCandidate\n+    @ForceInline\n+    private static int[] partitionDualPivot(Class<?> elemType, Object array, long offset, int low, int high, int indexPivot1, int indexPivot2) {\n+        return switch(array) {\n+            case int[] arr -> partitionDualPivot(arr, low, high, indexPivot1, indexPivot2);\n+            case long[] arr -> partitionDualPivot(arr, low, high, indexPivot1, indexPivot2);\n+            case float[] arr -> partitionDualPivot(arr, low, high, indexPivot1, indexPivot2);\n+            case double[] arr -> partitionDualPivot(arr, low, high, indexPivot1, indexPivot2);\n+            default -> throw new UnsupportedOperationException();\n+        };\n+    }\n+\n+    \/**\n+     * Partitions the specified array based on the single pivot provided.\n+     *\n+     * @param elemType the class of the array to be sorted\n+     * @param array the array to be sorted\n+     * @param offset the relative offset, in bytes, from the base address of\n+     * the array to partition, otherwise if the array is {@code null},an absolute\n+     * address pointing to the first element to partition from.\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @param indexPivot the index of the pivot\n+     *\/\n+    @IntrinsicCandidate\n+    @ForceInline\n+    private static int[] partitionSinglePivot(Class<?> elemType, Object array, long offset, int low, int high, int indexPivot) {\n+        return switch(array) {\n+            case int[] arr -> partitionSinglePivot(arr, low, high, indexPivot);\n+            case long[] arr -> partitionSinglePivot(arr, low, high, indexPivot);\n+            case float[] arr -> partitionSinglePivot(arr, low, high, indexPivot);\n+            case double[] arr -> partitionSinglePivot(arr, low, high, indexPivot);\n+            default -> throw new UnsupportedOperationException();\n+        };\n+    }\n+\n@@ -179,0 +282,1 @@\n+        int[] pivotIndices;\n@@ -181,1 +285,0 @@\n-\n@@ -186,1 +289,1 @@\n-                mixedInsertionSort(a, low, high - 3 * ((size >> 5) << 3), high);\n+                mixedInsertionSort(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, high - 3 * ((size >> 5) << 3));\n@@ -194,1 +297,1 @@\n-                insertionSort(a, low, high);\n+                insertionSort(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high);\n@@ -268,2 +371,2 @@\n-            int lower = low; \/\/ The index of the last element of the left part\n-            int upper = end; \/\/ The index of the first element of the right part\n+            int lower; \/\/ The index of the last element of the left part\n+            int upper; \/\/ The index of the first element of the right part\n@@ -275,1 +378,0 @@\n-\n@@ -281,40 +383,3 @@\n-                int pivot1 = a[e1];\n-                int pivot2 = a[e5];\n-\n-                \/*\n-                 * The first and the last elements to be sorted are moved\n-                 * to the locations formerly occupied by the pivots. When\n-                 * partitioning is completed, the pivots are swapped back\n-                 * into their final positions, and excluded from the next\n-                 * subsequent sorting.\n-                 *\/\n-                a[e1] = a[lower];\n-                a[e5] = a[upper];\n-\n-                \/*\n-                 * Skip elements, which are less or greater than the pivots.\n-                 *\/\n-                while (a[++lower] < pivot1);\n-                while (a[--upper] > pivot2);\n-\n-                \/*\n-                 * Backward 3-interval partitioning\n-                 *\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int unused = --lower, k = ++upper; --k > lower; ) {\n-                    int ak = a[k];\n+                pivotIndices = partitionDualPivot(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, e1, e5);\n+                lower = pivotIndices[0];\n+                upper = pivotIndices[1];\n@@ -322,18 +387,0 @@\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n-                                break;\n-                            }\n-                        }\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n-                        a[k] = a[--upper];\n-                        a[upper] = ak;\n-                    }\n-                }\n@@ -341,5 +388,0 @@\n-                \/*\n-                 * Swap the pivots into their final positions.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot1;\n-                a[end] = a[upper]; a[upper] = pivot2;\n@@ -365,2 +407,3 @@\n-                int pivot = a[e3];\n-\n+                pivotIndices = partitionSinglePivot(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, e3);\n+                lower = pivotIndices[0];\n+                upper = pivotIndices[1];\n@@ -368,5 +411,3 @@\n-                 * The first element to be sorted is moved to the\n-                 * location formerly occupied by the pivot. After\n-                 * completion of partitioning the pivot is swapped\n-                 * back into its final position, and excluded from\n-                 * the next subsequent sorting.\n+                 * Sort the right part (possibly in parallel), excluding\n+                 * known pivot. All elements from the central part are\n+                 * equal and therefore already sorted.\n@@ -374,1 +415,9 @@\n-                a[e3] = a[lower];\n+                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+                    sorter.forkSorter(bits | 1, upper, high);\n+                } else {\n+                    sort(sorter, a, bits | 1, upper, high);\n+                }\n+            }\n+            high = lower; \/\/ Iterate along the left part\n+        }\n+    }\n@@ -376,21 +425,15 @@\n-                \/*\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n-                 *\n-                 *   left part                 central part    right part\n-                 * +------------------------------------------------------+\n-                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-                 * +------------------------------------------------------+\n-                 *              ^           ^                ^\n-                 *              |           |                |\n-                 *            lower         k              upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int k = ++upper; --k > lower; ) {\n-                    int ak = a[k];\n+    \/**\n+     * Partitions the specified range of the array using the two pivots provided.\n+     *\n+     * @param array the array to be partitioned\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param indexPivot1 the index of pivot1, the first pivot\n+     * @param indexPivot2 the index of pivot2, the second pivot\n+     *\n+     *\/\n+    @ForceInline\n+    private static int[] partitionDualPivot(int[] a, int low, int high, int indexPivot1, int indexPivot2) {\n+        int end = high - 1;\n+        int lower = low;\n+        int upper = end;\n@@ -398,2 +441,4 @@\n-                    if (ak != pivot) {\n-                        a[k] = pivot;\n+        int e1 = indexPivot1;\n+        int e5 = indexPivot2;\n+        int pivot1 = a[e1];\n+        int pivot2 = a[e5];\n@@ -401,2 +446,9 @@\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n-                            while (a[++lower] < pivot);\n+        \/*\n+        * The first and the last elements to be sorted are moved\n+        * to the locations formerly occupied by the pivots. When\n+        * partitioning is completed, the pivots are swapped back\n+        * into their final positions, and excluded from the next\n+        * subsequent sorting.\n+        *\/\n+        a[e1] = a[lower];\n+        a[e5] = a[upper];\n@@ -404,6 +456,36 @@\n-                            if (a[lower] > pivot) {\n-                                a[--upper] = a[lower];\n-                            }\n-                            a[lower] = ak;\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n-                            a[--upper] = ak;\n+        \/*\n+        * Skip elements, which are less or greater than the pivots.\n+        *\/\n+        while (a[++lower] < pivot1);\n+        while (a[--upper] > pivot2);\n+\n+        \/*\n+        * Backward 3-interval partitioning\n+        *\n+        *   left part                 central part          right part\n+        * +------------------------------------------------------------+\n+                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n+        * +------------------------------------------------------------+\n+        *             ^       ^                            ^\n+        *             |       |                            |\n+        *           lower     k                          upper\n+        *\n+        * Invariants:\n+        *\n+        *              all in (low, lower] < pivot1\n+        *    pivot1 <= all in (k, upper)  <= pivot2\n+        *              all in [upper, end) > pivot2\n+        *\n+        * Pointer k is the last index of ?-part\n+        *\/\n+        for (int unused = --lower, k = ++upper; --k > lower; ) {\n+            int ak = a[k];\n+\n+            if (ak < pivot1) { \/\/ Move a[k] to the left side\n+                while (lower < k) {\n+                    if (a[++lower] >= pivot1) {\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n@@ -411,0 +493,2 @@\n+                        a[lower] = ak;\n+                        break;\n@@ -413,0 +497,5 @@\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                a[k] = a[--upper];\n+                a[upper] = ak;\n+            }\n+        }\n@@ -414,4 +503,5 @@\n-                \/*\n-                 * Swap the pivot into its final position.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot;\n+        \/*\n+         * Swap the pivots into their final positions.\n+         *\/\n+        a[low] = a[lower]; a[lower] = pivot1;\n+        a[end] = a[upper]; a[upper] = pivot2;\n@@ -419,9 +509,65 @@\n-                \/*\n-                 * Sort the right part (possibly in parallel), excluding\n-                 * known pivot. All elements from the central part are\n-                 * equal and therefore already sorted.\n-                 *\/\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.forkSorter(bits | 1, upper, high);\n-                } else {\n-                    sort(sorter, a, bits | 1, upper, high);\n+        return new int[] {lower, upper};\n+    }\n+\n+\n+\n+    \/**\n+     * Partitions the specified range of the array using a single pivot provided.\n+     *\n+     * @param array the array to be partitioned\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param indexPivot the index of the pivot\n+     *\n+     *\/\n+    @ForceInline\n+    private static int[] partitionSinglePivot(int[] a, int low, int high, int indexPivot) {\n+        int end = high - 1;\n+        int lower = low;\n+        int upper = end;\n+        int e3 = indexPivot;\n+        int pivot = a[e3];\n+\n+        \/*\n+        * The first element to be sorted is moved to the\n+        * location formerly occupied by the pivot. After\n+        * completion of partitioning the pivot is swapped\n+        * back into its final position, and excluded from\n+        * the next subsequent sorting.\n+        *\/\n+        a[e3] = a[lower];\n+\n+        \/*\n+        * Traditional 3-way (Dutch National Flag) partitioning\n+        *\n+        *   left part                 central part    right part\n+        * +------------------------------------------------------+\n+        * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n+        * +------------------------------------------------------+\n+        *              ^           ^                ^\n+        *              |           |                |\n+        *            lower         k              upper\n+        *\n+        * Invariants:\n+        *\n+        *   all in (low, lower] < pivot\n+        *   all in (k, upper)  == pivot\n+        *   all in [upper, end] > pivot\n+        *\n+        * Pointer k is the last index of ?-part\n+        *\/\n+        for (int k = ++upper; --k > lower; ) {\n+            int ak = a[k];\n+\n+            if (ak != pivot) {\n+                a[k] = pivot;\n+\n+                if (ak < pivot) { \/\/ Move a[k] to the left side\n+                    while (a[++lower] < pivot);\n+\n+                    if (a[lower] > pivot) {\n+                        a[--upper] = a[lower];\n+                    }\n+                    a[lower] = ak;\n+                } else { \/\/ ak > pivot - Move a[k] to the right side\n+                    a[--upper] = ak;\n@@ -430,1 +576,0 @@\n-            high = lower; \/\/ Iterate along the left part\n@@ -432,0 +577,6 @@\n+\n+        \/*\n+        * Swap the pivot into its final position.\n+        *\/\n+        a[low] = a[lower]; a[lower] = pivot;\n+        return new int[] {lower, upper};\n@@ -933,0 +1084,1 @@\n+        int[] pivotIndices;\n@@ -940,1 +1092,2 @@\n-                mixedInsertionSort(a, low, high - 3 * ((size >> 5) << 3), high);\n+                int last  = high - 3 * ((size >> 5) << 3);\n+                mixedInsertionSort(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, high - 3 * ((size >> 5) << 3));\n@@ -948,1 +1101,1 @@\n-                insertionSort(a, low, high);\n+                insertionSort(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high);\n@@ -1022,2 +1175,2 @@\n-            int lower = low; \/\/ The index of the last element of the left part\n-            int upper = end; \/\/ The index of the first element of the right part\n+            int lower; \/\/ The index of the last element of the left part\n+            int upper; \/\/ The index of the first element of the right part\n@@ -1028,1 +1181,1 @@\n-            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n+            if(a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n@@ -1035,66 +1188,3 @@\n-                long pivot1 = a[e1];\n-                long pivot2 = a[e5];\n-\n-                \/*\n-                 * The first and the last elements to be sorted are moved\n-                 * to the locations formerly occupied by the pivots. When\n-                 * partitioning is completed, the pivots are swapped back\n-                 * into their final positions, and excluded from the next\n-                 * subsequent sorting.\n-                 *\/\n-                a[e1] = a[lower];\n-                a[e5] = a[upper];\n-\n-                \/*\n-                 * Skip elements, which are less or greater than the pivots.\n-                 *\/\n-                while (a[++lower] < pivot1);\n-                while (a[--upper] > pivot2);\n-\n-                \/*\n-                 * Backward 3-interval partitioning\n-                 *\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int unused = --lower, k = ++upper; --k > lower; ) {\n-                    long ak = a[k];\n-\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n-                                break;\n-                            }\n-                        }\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n-                        a[k] = a[--upper];\n-                        a[upper] = ak;\n-                    }\n-                }\n-\n-                \/*\n-                 * Swap the pivots into their final positions.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot1;\n-                a[end] = a[upper]; a[upper] = pivot2;\n-\n+                pivotIndices = partitionDualPivot(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, e1, e5);\n+                lower = pivotIndices[0];\n+                upper = pivotIndices[1];\n@@ -1119,2 +1209,3 @@\n-                long pivot = a[e3];\n-\n+                pivotIndices = partitionSinglePivot(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, e3);\n+                lower = pivotIndices[0];\n+                upper = pivotIndices[1];\n@@ -1122,5 +1213,3 @@\n-                 * The first element to be sorted is moved to the\n-                 * location formerly occupied by the pivot. After\n-                 * completion of partitioning the pivot is swapped\n-                 * back into its final position, and excluded from\n-                 * the next subsequent sorting.\n+                 * Sort the right part (possibly in parallel), excluding\n+                 * known pivot. All elements from the central part are\n+                 * equal and therefore already sorted.\n@@ -1128,1 +1217,9 @@\n-                a[e3] = a[lower];\n+                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+                    sorter.forkSorter(bits | 1, upper, high);\n+                } else {\n+                    sort(sorter, a, bits | 1, upper, high);\n+                }\n+            }\n+            high = lower; \/\/ Iterate along the left part\n+        }\n+    }\n@@ -1130,21 +1227,15 @@\n-                \/*\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n-                 *\n-                 *   left part                 central part    right part\n-                 * +------------------------------------------------------+\n-                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-                 * +------------------------------------------------------+\n-                 *              ^           ^                ^\n-                 *              |           |                |\n-                 *            lower         k              upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int k = ++upper; --k > lower; ) {\n-                    long ak = a[k];\n+    \/**\n+     * Partitions the specified range of the array using the two pivots provided.\n+     *\n+     * @param array the array to be partitioned\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param indexPivot1 the index of pivot1, the first pivot\n+     * @param indexPivot2 the index of pivot2, the second pivot\n+     *\n+     *\/\n+    @ForceInline\n+    private static int[] partitionDualPivot(long[] a, int low, int high, int indexPivot1, int indexPivot2) {\n+        int end = high - 1;\n+        int lower = low;\n+        int upper = end;\n@@ -1152,2 +1243,4 @@\n-                    if (ak != pivot) {\n-                        a[k] = pivot;\n+        int e1 = indexPivot1;\n+        int e5 = indexPivot2;\n+        long pivot1 = a[e1];\n+        long pivot2 = a[e5];\n@@ -1155,2 +1248,9 @@\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n-                            while (a[++lower] < pivot);\n+        \/*\n+        * The first and the last elements to be sorted are moved\n+        * to the locations formerly occupied by the pivots. When\n+        * partitioning is completed, the pivots are swapped back\n+        * into their final positions, and excluded from the next\n+        * subsequent sorting.\n+        *\/\n+        a[e1] = a[lower];\n+        a[e5] = a[upper];\n@@ -1158,6 +1258,36 @@\n-                            if (a[lower] > pivot) {\n-                                a[--upper] = a[lower];\n-                            }\n-                            a[lower] = ak;\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n-                            a[--upper] = ak;\n+        \/*\n+        * Skip elements, which are less or greater than the pivots.\n+        *\/\n+        while (a[++lower] < pivot1);\n+        while (a[--upper] > pivot2);\n+\n+        \/*\n+        * Backward 3-interval partitioning\n+        *\n+        *   left part                 central part          right part\n+        * +------------------------------------------------------------+\n+                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n+        * +------------------------------------------------------------+\n+        *             ^       ^                            ^\n+        *             |       |                            |\n+        *           lower     k                          upper\n+        *\n+        * Invariants:\n+        *\n+        *              all in (low, lower] < pivot1\n+        *    pivot1 <= all in (k, upper)  <= pivot2\n+        *              all in [upper, end) > pivot2\n+        *\n+        * Pointer k is the last index of ?-part\n+        *\/\n+        for (int unused = --lower, k = ++upper; --k > lower; ) {\n+            long ak = a[k];\n+\n+            if (ak < pivot1) { \/\/ Move a[k] to the left side\n+                while (lower < k) {\n+                    if (a[++lower] >= pivot1) {\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n@@ -1165,0 +1295,2 @@\n+                        a[lower] = ak;\n+                        break;\n@@ -1167,0 +1299,5 @@\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                a[k] = a[--upper];\n+                a[upper] = ak;\n+            }\n+        }\n@@ -1168,4 +1305,5 @@\n-                \/*\n-                 * Swap the pivot into its final position.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot;\n+        \/*\n+         * Swap the pivots into their final positions.\n+         *\/\n+        a[low] = a[lower]; a[lower] = pivot1;\n+        a[end] = a[upper]; a[upper] = pivot2;\n@@ -1173,9 +1311,65 @@\n-                \/*\n-                 * Sort the right part (possibly in parallel), excluding\n-                 * known pivot. All elements from the central part are\n-                 * equal and therefore already sorted.\n-                 *\/\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.forkSorter(bits | 1, upper, high);\n-                } else {\n-                    sort(sorter, a, bits | 1, upper, high);\n+        return new int[] {lower, upper};\n+    }\n+\n+\n+    \/**\n+     * Partitions the specified range of the array using a single pivot provided.\n+     *\n+     * @param array the array to be partitioned\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param indexPivot the index of the pivot\n+     *\n+     *\/\n+    @ForceInline\n+    private static int[] partitionSinglePivot(long[] a, int low, int high, int indexPivot) {\n+        int end = high - 1;\n+        int lower = low;\n+        int upper = end;\n+\n+        int e3 = indexPivot;\n+        long pivot = a[e3];\n+\n+        \/*\n+        * The first element to be sorted is moved to the\n+        * location formerly occupied by the pivot. After\n+        * completion of partitioning the pivot is swapped\n+        * back into its final position, and excluded from\n+        * the next subsequent sorting.\n+        *\/\n+        a[e3] = a[lower];\n+\n+        \/*\n+        * Traditional 3-way (Dutch National Flag) partitioning\n+        *\n+        *   left part                 central part    right part\n+        * +------------------------------------------------------+\n+        * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n+        * +------------------------------------------------------+\n+        *              ^           ^                ^\n+        *              |           |                |\n+        *            lower         k              upper\n+        *\n+        * Invariants:\n+        *\n+        *   all in (low, lower] < pivot\n+        *   all in (k, upper)  == pivot\n+        *   all in [upper, end] > pivot\n+        *\n+        * Pointer k is the last index of ?-part\n+        *\/\n+        for (int k = ++upper; --k > lower; ) {\n+            long ak = a[k];\n+\n+            if (ak != pivot) {\n+                a[k] = pivot;\n+\n+                if (ak < pivot) { \/\/ Move a[k] to the left side\n+                    while (a[++lower] < pivot);\n+\n+                    if (a[lower] > pivot) {\n+                        a[--upper] = a[lower];\n+                    }\n+                    a[lower] = ak;\n+                } else { \/\/ ak > pivot - Move a[k] to the right side\n+                    a[--upper] = ak;\n@@ -1184,1 +1378,0 @@\n-            high = lower; \/\/ Iterate along the left part\n@@ -1186,0 +1379,6 @@\n+\n+        \/*\n+            * Swap the pivot into its final position.\n+            *\/\n+        a[low] = a[lower]; a[lower] = pivot;\n+        return new int[] {lower, upper};\n@@ -2474,0 +2673,1 @@\n+        int[] pivotIndices;\n@@ -2481,1 +2681,2 @@\n-                mixedInsertionSort(a, low, high - 3 * ((size >> 5) << 3), high);\n+                int last  = high - 3 * ((size >> 5) << 3);\n+                mixedInsertionSort(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, high - 3 * ((size >> 5) << 3));\n@@ -2489,1 +2690,1 @@\n-                insertionSort(a, low, high);\n+                insertionSort(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high);\n@@ -2563,2 +2764,2 @@\n-            int lower = low; \/\/ The index of the last element of the left part\n-            int upper = end; \/\/ The index of the first element of the right part\n+            int lower; \/\/ The index of the last element of the left part\n+            int upper; \/\/ The index of the first element of the right part\n@@ -2569,1 +2770,1 @@\n-            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n+            if(a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n@@ -2576,66 +2777,3 @@\n-                float pivot1 = a[e1];\n-                float pivot2 = a[e5];\n-\n-                \/*\n-                 * The first and the last elements to be sorted are moved\n-                 * to the locations formerly occupied by the pivots. When\n-                 * partitioning is completed, the pivots are swapped back\n-                 * into their final positions, and excluded from the next\n-                 * subsequent sorting.\n-                 *\/\n-                a[e1] = a[lower];\n-                a[e5] = a[upper];\n-\n-                \/*\n-                 * Skip elements, which are less or greater than the pivots.\n-                 *\/\n-                while (a[++lower] < pivot1);\n-                while (a[--upper] > pivot2);\n-\n-                \/*\n-                 * Backward 3-interval partitioning\n-                 *\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int unused = --lower, k = ++upper; --k > lower; ) {\n-                    float ak = a[k];\n-\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n-                                break;\n-                            }\n-                        }\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n-                        a[k] = a[--upper];\n-                        a[upper] = ak;\n-                    }\n-                }\n-\n-                \/*\n-                 * Swap the pivots into their final positions.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot1;\n-                a[end] = a[upper]; a[upper] = pivot2;\n-\n+                pivotIndices = partitionDualPivot(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, e1, e5);\n+                lower = pivotIndices[0];\n+                upper = pivotIndices[1];\n@@ -2660,2 +2798,3 @@\n-                float pivot = a[e3];\n-\n+                pivotIndices = partitionSinglePivot(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, e3);\n+                lower = pivotIndices[0];\n+                upper = pivotIndices[1];\n@@ -2663,5 +2802,3 @@\n-                 * The first element to be sorted is moved to the\n-                 * location formerly occupied by the pivot. After\n-                 * completion of partitioning the pivot is swapped\n-                 * back into its final position, and excluded from\n-                 * the next subsequent sorting.\n+                 * Sort the right part (possibly in parallel), excluding\n+                 * known pivot. All elements from the central part are\n+                 * equal and therefore already sorted.\n@@ -2669,1 +2806,9 @@\n-                a[e3] = a[lower];\n+                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+                    sorter.forkSorter(bits | 1, upper, high);\n+                } else {\n+                    sort(sorter, a, bits | 1, upper, high);\n+                }\n+            }\n+            high = lower; \/\/ Iterate along the left part\n+        }\n+    }\n@@ -2671,21 +2816,15 @@\n-                \/*\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n-                 *\n-                 *   left part                 central part    right part\n-                 * +------------------------------------------------------+\n-                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-                 * +------------------------------------------------------+\n-                 *              ^           ^                ^\n-                 *              |           |                |\n-                 *            lower         k              upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int k = ++upper; --k > lower; ) {\n-                    float ak = a[k];\n+    \/**\n+     * Partitions the specified range of the array using the two pivots provided.\n+     *\n+     * @param array the array to be partitioned\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param indexPivot1 the index of pivot1, the first pivot\n+     * @param indexPivot2 the index of pivot2, the second pivot\n+     *\n+     *\/\n+    @ForceInline\n+    private static int[] partitionDualPivot(float[] a, int low, int high, int indexPivot1, int indexPivot2) {\n+        int end = high - 1;\n+        int lower = low;\n+        int upper = end;\n@@ -2693,2 +2832,4 @@\n-                    if (ak != pivot) {\n-                        a[k] = pivot;\n+        int e1 = indexPivot1;\n+        int e5 = indexPivot2;\n+        float pivot1 = a[e1];\n+        float pivot2 = a[e5];\n@@ -2696,2 +2837,9 @@\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n-                            while (a[++lower] < pivot);\n+        \/*\n+        * The first and the last elements to be sorted are moved\n+        * to the locations formerly occupied by the pivots. When\n+        * partitioning is completed, the pivots are swapped back\n+        * into their final positions, and excluded from the next\n+        * subsequent sorting.\n+        *\/\n+        a[e1] = a[lower];\n+        a[e5] = a[upper];\n@@ -2699,6 +2847,36 @@\n-                            if (a[lower] > pivot) {\n-                                a[--upper] = a[lower];\n-                            }\n-                            a[lower] = ak;\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n-                            a[--upper] = ak;\n+        \/*\n+        * Skip elements, which are less or greater than the pivots.\n+        *\/\n+                while (a[++lower] < pivot1);\n+                while (a[--upper] > pivot2);\n+\n+        \/*\n+        * Backward 3-interval partitioning\n+        *\n+        *   left part                 central part          right part\n+        * +------------------------------------------------------------+\n+                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n+        * +------------------------------------------------------------+\n+        *             ^       ^                            ^\n+        *             |       |                            |\n+        *           lower     k                          upper\n+        *\n+        * Invariants:\n+        *\n+        *              all in (low, lower] < pivot1\n+        *    pivot1 <= all in (k, upper)  <= pivot2\n+        *              all in [upper, end) > pivot2\n+        *\n+        * Pointer k is the last index of ?-part\n+        *\/\n+        for (int unused = --lower, k = ++upper; --k > lower; ) {\n+            float ak = a[k];\n+\n+            if (ak < pivot1) { \/\/ Move a[k] to the left side\n+                while (lower < k) {\n+                    if (a[++lower] >= pivot1) {\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n@@ -2706,0 +2884,2 @@\n+                        a[lower] = ak;\n+                        break;\n@@ -2708,0 +2888,5 @@\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                a[k] = a[--upper];\n+                a[upper] = ak;\n+            }\n+        }\n@@ -2709,4 +2894,5 @@\n-                \/*\n-                 * Swap the pivot into its final position.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot;\n+        \/*\n+         * Swap the pivots into their final positions.\n+         *\/\n+        a[low] = a[lower]; a[lower] = pivot1;\n+        a[end] = a[upper]; a[upper] = pivot2;\n@@ -2714,9 +2900,65 @@\n-                \/*\n-                 * Sort the right part (possibly in parallel), excluding\n-                 * known pivot. All elements from the central part are\n-                 * equal and therefore already sorted.\n-                 *\/\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.forkSorter(bits | 1, upper, high);\n-                } else {\n-                    sort(sorter, a, bits | 1, upper, high);\n+        return new int[] {lower, upper};\n+    }\n+\n+\n+    \/**\n+     * Partitions the specified range of the array using a single pivot provided.\n+     *\n+     * @param array the array to be partitioned\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param indexPivot the index of the pivot\n+     *\n+     *\/\n+    @ForceInline\n+    private static int[] partitionSinglePivot(float[] a, int low, int high, int indexPivot) {\n+        int end = high - 1;\n+        int lower = low;\n+        int upper = end;\n+\n+        int e3 = indexPivot;\n+        float pivot = a[e3];\n+\n+        \/*\n+        * The first element to be sorted is moved to the\n+        * location formerly occupied by the pivot. After\n+        * completion of partitioning the pivot is swapped\n+        * back into its final position, and excluded from\n+        * the next subsequent sorting.\n+        *\/\n+        a[e3] = a[lower];\n+\n+        \/*\n+        * Traditional 3-way (Dutch National Flag) partitioning\n+        *\n+        *   left part                 central part    right part\n+        * +------------------------------------------------------+\n+        * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n+        * +------------------------------------------------------+\n+        *              ^           ^                ^\n+        *              |           |                |\n+        *            lower         k              upper\n+        *\n+        * Invariants:\n+        *\n+        *   all in (low, lower] < pivot\n+        *   all in (k, upper)  == pivot\n+        *   all in [upper, end] > pivot\n+        *\n+        * Pointer k is the last index of ?-part\n+        *\/\n+        for (int k = ++upper; --k > lower; ) {\n+            float ak = a[k];\n+\n+            if (ak != pivot) {\n+                a[k] = pivot;\n+\n+                if (ak < pivot) { \/\/ Move a[k] to the left side\n+                    while (a[++lower] < pivot);\n+\n+                    if (a[lower] > pivot) {\n+                        a[--upper] = a[lower];\n+                    }\n+                    a[lower] = ak;\n+                } else { \/\/ ak > pivot - Move a[k] to the right side\n+                    a[--upper] = ak;\n@@ -2725,1 +2967,0 @@\n-            high = lower; \/\/ Iterate along the left part\n@@ -2727,0 +2968,6 @@\n+\n+        \/*\n+            * Swap the pivot into its final position.\n+            *\/\n+        a[low] = a[lower]; a[lower] = pivot;\n+        return new int[] {lower, upper};\n@@ -3280,0 +3527,1 @@\n+        int[] pivotIndices;\n@@ -3282,1 +3530,0 @@\n-\n@@ -3287,1 +3534,2 @@\n-                mixedInsertionSort(a, low, high - 3 * ((size >> 5) << 3), high);\n+                int last  = high - 3 * ((size >> 5) << 3);\n+                mixedInsertionSort(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, high - 3 * ((size >> 5) << 3));\n@@ -3295,1 +3543,1 @@\n-                insertionSort(a, low, high);\n+                insertionSort(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high);\n@@ -3369,2 +3617,2 @@\n-            int lower = low; \/\/ The index of the last element of the left part\n-            int upper = end; \/\/ The index of the first element of the right part\n+            int lower; \/\/ The index of the last element of the left part\n+            int upper; \/\/ The index of the first element of the right part\n@@ -3375,9 +3623,1 @@\n-            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n-\n-                \/*\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n-                 *\/\n-                double pivot1 = a[e1];\n-                double pivot2 = a[e5];\n+            if(a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n@@ -3386,62 +3626,7 @@\n-                 * The first and the last elements to be sorted are moved\n-                 * to the locations formerly occupied by the pivots. When\n-                 * partitioning is completed, the pivots are swapped back\n-                 * into their final positions, and excluded from the next\n-                 * subsequent sorting.\n-                 *\/\n-                a[e1] = a[lower];\n-                a[e5] = a[upper];\n-\n-                \/*\n-                 * Skip elements, which are less or greater than the pivots.\n-                 *\/\n-                while (a[++lower] < pivot1);\n-                while (a[--upper] > pivot2);\n-\n-                \/*\n-                 * Backward 3-interval partitioning\n-                 *\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int unused = --lower, k = ++upper; --k > lower; ) {\n-                    double ak = a[k];\n-\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n-                                break;\n-                            }\n-                        }\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n-                        a[k] = a[--upper];\n-                        a[upper] = ak;\n-                    }\n-                }\n-\n-                \/*\n-                 * Swap the pivots into their final positions.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot1;\n-                a[end] = a[upper]; a[upper] = pivot2;\n-\n+                * Use the first and fifth of the five sorted elements as\n+                * the pivots. These values are inexpensive approximation\n+                * of tertiles. Note, that pivot1 < pivot2.\n+                *\/\n+                pivotIndices = partitionDualPivot(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, e1, e5);\n+                lower = pivotIndices[0];\n+                upper = pivotIndices[1];\n@@ -3466,1 +3651,3 @@\n-                double pivot = a[e3];\n+                pivotIndices = partitionSinglePivot(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, e3);\n+                lower = pivotIndices[0];\n+                upper = pivotIndices[1];\n@@ -3469,5 +3656,3 @@\n-                 * The first element to be sorted is moved to the\n-                 * location formerly occupied by the pivot. After\n-                 * completion of partitioning the pivot is swapped\n-                 * back into its final position, and excluded from\n-                 * the next subsequent sorting.\n+                 * Sort the right part (possibly in parallel), excluding\n+                 * known pivot. All elements from the central part are\n+                 * equal and therefore already sorted.\n@@ -3475,1 +3660,9 @@\n-                a[e3] = a[lower];\n+                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+                    sorter.forkSorter(bits | 1, upper, high);\n+                } else {\n+                    sort(sorter, a, bits | 1, upper, high);\n+                }\n+            }\n+            high = lower; \/\/ Iterate along the left part\n+        }\n+    }\n@@ -3477,21 +3670,15 @@\n-                \/*\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n-                 *\n-                 *   left part                 central part    right part\n-                 * +------------------------------------------------------+\n-                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-                 * +------------------------------------------------------+\n-                 *              ^           ^                ^\n-                 *              |           |                |\n-                 *            lower         k              upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int k = ++upper; --k > lower; ) {\n-                    double ak = a[k];\n+    \/**\n+     * Partitions the specified range of the array using the two pivots provided.\n+     *\n+     * @param array the array to be partitioned\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param indexPivot1 the index of pivot1, the first pivot\n+     * @param indexPivot2 the index of pivot2, the second pivot\n+     *\n+     *\/\n+    @ForceInline\n+    private static int[] partitionDualPivot(double[] a, int low, int high, int indexPivot1, int indexPivot2) {\n+        int end = high - 1;\n+        int lower = low;\n+        int upper = end;\n@@ -3499,2 +3686,4 @@\n-                    if (ak != pivot) {\n-                        a[k] = pivot;\n+        int e1 = indexPivot1;\n+        int e5 = indexPivot2;\n+        double pivot1 = a[e1];\n+        double pivot2 = a[e5];\n@@ -3502,2 +3691,9 @@\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n-                            while (a[++lower] < pivot);\n+        \/*\n+        * The first and the last elements to be sorted are moved\n+        * to the locations formerly occupied by the pivots. When\n+        * partitioning is completed, the pivots are swapped back\n+        * into their final positions, and excluded from the next\n+        * subsequent sorting.\n+        *\/\n+        a[e1] = a[lower];\n+        a[e5] = a[upper];\n@@ -3505,6 +3701,36 @@\n-                            if (a[lower] > pivot) {\n-                                a[--upper] = a[lower];\n-                            }\n-                            a[lower] = ak;\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n-                            a[--upper] = ak;\n+        \/*\n+        * Skip elements, which are less or greater than the pivots.\n+        *\/\n+                while (a[++lower] < pivot1);\n+                while (a[--upper] > pivot2);\n+\n+        \/*\n+        * Backward 3-interval partitioning\n+        *\n+        *   left part                 central part          right part\n+        * +------------------------------------------------------------+\n+                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n+        * +------------------------------------------------------------+\n+        *             ^       ^                            ^\n+        *             |       |                            |\n+        *           lower     k                          upper\n+        *\n+        * Invariants:\n+        *\n+        *              all in (low, lower] < pivot1\n+        *    pivot1 <= all in (k, upper)  <= pivot2\n+        *              all in [upper, end) > pivot2\n+        *\n+        * Pointer k is the last index of ?-part\n+        *\/\n+        for (int unused = --lower, k = ++upper; --k > lower; ) {\n+            double ak = a[k];\n+\n+            if (ak < pivot1) { \/\/ Move a[k] to the left side\n+                while (lower < k) {\n+                    if (a[++lower] >= pivot1) {\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n@@ -3512,0 +3738,2 @@\n+                        a[lower] = ak;\n+                        break;\n@@ -3514,0 +3742,5 @@\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                a[k] = a[--upper];\n+                a[upper] = ak;\n+            }\n+        }\n@@ -3515,4 +3748,5 @@\n-                \/*\n-                 * Swap the pivot into its final position.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot;\n+        \/*\n+         * Swap the pivots into their final positions.\n+         *\/\n+        a[low] = a[lower]; a[lower] = pivot1;\n+        a[end] = a[upper]; a[upper] = pivot2;\n@@ -3520,9 +3754,65 @@\n-                \/*\n-                 * Sort the right part (possibly in parallel), excluding\n-                 * known pivot. All elements from the central part are\n-                 * equal and therefore already sorted.\n-                 *\/\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.forkSorter(bits | 1, upper, high);\n-                } else {\n-                    sort(sorter, a, bits | 1, upper, high);\n+        return new int[] {lower, upper};\n+    }\n+\n+\n+\n+    \/**\n+     * Partitions the specified range of the array using a single pivot provided.\n+     *\n+     * @param array the array to be partitioned\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param indexPivot the index of the pivot\n+     *\/\n+    @ForceInline\n+    private static int[] partitionSinglePivot(double[] a, int low, int high, int indexPivot) {\n+        int end = high - 1;\n+        int lower = low;\n+        int upper = end;\n+\n+        int e3 = indexPivot;\n+        double pivot = a[e3];\n+\n+        \/*\n+        * The first element to be sorted is moved to the\n+        * location formerly occupied by the pivot. After\n+        * completion of partitioning the pivot is swapped\n+        * back into its final position, and excluded from\n+        * the next subsequent sorting.\n+        *\/\n+        a[e3] = a[lower];\n+\n+        \/*\n+        * Traditional 3-way (Dutch National Flag) partitioning\n+        *\n+        *   left part                 central part    right part\n+        * +------------------------------------------------------+\n+        * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n+        * +------------------------------------------------------+\n+        *              ^           ^                ^\n+        *              |           |                |\n+        *            lower         k              upper\n+        *\n+        * Invariants:\n+        *\n+        *   all in (low, lower] < pivot\n+        *   all in (k, upper)  == pivot\n+        *   all in [upper, end] > pivot\n+        *\n+        * Pointer k is the last index of ?-part\n+        *\/\n+        for (int k = ++upper; --k > lower; ) {\n+            double ak = a[k];\n+\n+            if (ak != pivot) {\n+                a[k] = pivot;\n+\n+                if (ak < pivot) { \/\/ Move a[k] to the left side\n+                    while (a[++lower] < pivot);\n+\n+                    if (a[lower] > pivot) {\n+                        a[--upper] = a[lower];\n+                    }\n+                    a[lower] = ak;\n+                } else { \/\/ ak > pivot - Move a[k] to the right side\n+                    a[--upper] = ak;\n@@ -3531,1 +3821,0 @@\n-            high = lower; \/\/ Iterate along the left part\n@@ -3533,0 +3822,6 @@\n+\n+        \/*\n+            * Swap the pivot into its final position.\n+            *\/\n+        a[low] = a[lower]; a[lower] = pivot;\n+        return new int[] {lower, upper};\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":794,"deletions":499,"binary":false,"changes":1293,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,2 @@\n- * @run main Sorting -shortrun\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:DisableIntrinsic=_arraySortI,_arraySortMI,_arrayPartitionSP,_arrayPartitionDP Sorting -shortrun\n+ * @run main\/othervm -XX:CompileThreshold=1 -XX:-TieredCompilation Sorting -shortrun\n@@ -49,1 +50,1 @@\n-        1, 3, 8, 21, 55, 100, 1_000, 10_000, 100_000 };\n+        1, 3, 8, 21, 55, 100, 1_000, 10_000, 100_000};\n","filename":"test\/jdk\/java\/util\/Arrays\/Sorting.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.io.UnsupportedEncodingException;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+\n+\/**\n+ * Performance test of Arrays.sort() methods\n+ *\/\n+@Fork(value=1, jvmArgsAppend={\"-XX:CompileThreshold=1\", \"-XX:-TieredCompilation\"})\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 3, time=5)\n+@Measurement(iterations = 3, time=3)\n+public class ArraysSort {\n+\n+    @Param({\"10\",\"25\",\"50\",\"75\",\"100\", \"1000\", \"10000\", \"100000\", \"1000000\"})\n+    private int size;\n+\n+    private int[] ints_unsorted;\n+    private long[] longs_unsorted;\n+    private float[] floats_unsorted;\n+    private double[] doubles_unsorted;\n+\n+    private int[] ints_sorted;\n+    private long[] longs_sorted;\n+    private float[] floats_sorted;\n+    private double[] doubles_sorted;\n+\n+\n+    public void initialize() {\n+        Random rnd = new Random(42);\n+\n+        ints_unsorted = new int[size];\n+        longs_unsorted = new long[size];\n+        floats_unsorted = new float[size];\n+        doubles_unsorted = new double[size];\n+\n+        int[] intSpecialCases = {Integer.MIN_VALUE, Integer.MAX_VALUE};\n+        long[] longSpecialCases = {Long.MIN_VALUE, Long.MAX_VALUE};\n+        float[] floatSpecialCases = {+0.0f, -0.0f, Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY, Float.NaN};\n+        double[] doubleSpecialCases = {+0.0, -0.0, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NaN};\n+\n+        for (int i = 0; i < size; i++) {\n+            ints_unsorted[i] = rnd.nextInt();\n+            longs_unsorted[i] = rnd.nextLong();\n+            if (i % 10 != 0) {\n+                ints_unsorted[i] = rnd.nextInt();\n+                longs_unsorted[i] = rnd.nextLong();\n+                floats_unsorted[i] = rnd.nextFloat();\n+                doubles_unsorted[i] = rnd.nextDouble();\n+            } else {\n+                ints_unsorted[i] = intSpecialCases[rnd.nextInt(intSpecialCases.length)];\n+                longs_unsorted[i] = longSpecialCases[rnd.nextInt(longSpecialCases.length)];\n+                floats_unsorted[i] = floatSpecialCases[rnd.nextInt(floatSpecialCases.length)];\n+                doubles_unsorted[i] = doubleSpecialCases[rnd.nextInt(doubleSpecialCases.length)];\n+            }\n+        }\n+    }\n+\n+    @Setup\n+    public void setup() throws UnsupportedEncodingException, ClassNotFoundException, NoSuchMethodException, Throwable {\n+        initialize();\n+    }\n+\n+    @Setup(Level.Invocation)\n+    public void clear() {\n+        ints_sorted = ints_unsorted.clone();\n+        longs_sorted = longs_unsorted.clone();\n+        floats_sorted = floats_unsorted.clone();\n+        doubles_sorted = doubles_unsorted.clone();\n+    }\n+\n+    @Benchmark\n+    public int[] intSort() throws Throwable {\n+        Arrays.sort(ints_sorted);\n+        return ints_sorted;\n+    }\n+\n+    @Benchmark\n+    public int[] intParallelSort() throws Throwable {\n+        Arrays.parallelSort(ints_sorted);\n+        return ints_sorted;\n+    }\n+\n+    @Benchmark\n+    public long[] longSort() throws Throwable {\n+        Arrays.sort(longs_sorted);\n+        return longs_sorted;\n+    }\n+\n+    @Benchmark\n+    public long[] longParallelSort() throws Throwable {\n+        Arrays.parallelSort(longs_sorted);\n+        return longs_sorted;\n+    }\n+\n+    @Benchmark\n+    public float[] floatSort() throws Throwable {\n+        Arrays.sort(floats_sorted);\n+        return floats_sorted;\n+    }\n+\n+    @Benchmark\n+    public float[] floatParallelSort() throws Throwable {\n+        Arrays.parallelSort(floats_sorted);\n+        return floats_sorted;\n+    }\n+\n+    @Benchmark\n+    public double[] doubleSort() throws Throwable {\n+        Arrays.sort(doubles_sorted);\n+        return doubles_sorted;\n+    }\n+\n+    @Benchmark\n+    public double[] doubleParallelSort() throws Throwable {\n+        Arrays.parallelSort(doubles_sorted);\n+        return doubles_sorted;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/ArraysSort.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"}]}