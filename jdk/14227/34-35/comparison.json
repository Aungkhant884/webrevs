{"files":[{"patch":"@@ -4193,1 +4193,1 @@\n-      log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, JNI_LIB_PREFIX \"x86_64\" JNI_LIB_SUFFIX, p2i(libsimdsort));\n+      log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, JNI_LIB_PREFIX \"simdsort\" JNI_LIB_SUFFIX, p2i(libsimdsort));\n@@ -4196,1 +4196,1 @@\n-      StubRoutines::_arraysort = (address)os::dll_lookup(libsimdsort, ebuf_);\n+      StubRoutines::_array_sort = (address)os::dll_lookup(libsimdsort, ebuf_);\n@@ -4198,5 +4198,2 @@\n-      snprintf(ebuf_, sizeof(ebuf_), \"avx512_partition_single\");\n-      StubRoutines::_array_partition_single = (address)os::dll_lookup(libsimdsort, ebuf_);\n-\n-      snprintf(ebuf_, sizeof(ebuf_), \"avx512_partition_dual\");\n-      StubRoutines::_array_partition_dual = (address)os::dll_lookup(libsimdsort, ebuf_);\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_partition\");\n+      StubRoutines::_array_partition = (address)os::dll_lookup(libsimdsort, ebuf_);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -344,13 +344,3 @@\n-  do_intrinsic(_arraySortMI, java_util_DualPivotQuicksort, arraySortMI_name, arraySortMI_signature, F_S)                \\\n-   do_name(     arraySortMI_name,                                  \"mixedInsertionSort\")                                \\\n-   do_signature(arraySortMI_signature,          \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JIII)V\")                            \\\n-  do_intrinsic(_arraySortI, java_util_DualPivotQuicksort, arraySortI_name, arraySortI_signature, F_S)                   \\\n-   do_name(     arraySortI_name,                                   \"insertionSort\")                                     \\\n-   do_signature(arraySortI_signature,          \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JII)V\")                             \\\n-                                                                                                                        \\\n-  do_intrinsic(_arrayPartitionSP, java_util_DualPivotQuicksort, arrayPartitionSP_name, arrayPartitionSP_signature, F_S) \\\n-   do_name(     arrayPartitionSP_name,                             \"partitionSinglePivot\")                              \\\n-  do_signature(arrayPartitionSP_signature,      \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JIII)[I\")                          \\\n-  do_intrinsic(_arrayPartitionDP, java_util_DualPivotQuicksort, arrayPartitionDP_name, arrayPartitionDP_signature, F_S) \\\n-   do_name(     arrayPartitionDP_name,                             \"partitionDualPivot\")                                \\\n-  do_signature(arrayPartitionDP_signature,      \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JIIII)[I\")                         \\\n+  do_intrinsic(_arraySort,                java_util_DualPivotQuicksort, arraySort_name, arraySort_signature,     F_S)   \\\n+   do_name(     arraySort_name,                                  \"arraySort\")                                           \\\n+   do_signature(arraySort_signature,          \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JIILjava\/util\/SortOperation;)V\")     \\\n@@ -358,0 +348,3 @@\n+  do_intrinsic(_arrayPartition,           java_util_DualPivotQuicksort, arrayPartition_name, arrayPartition_signature, F_S)   \\\n+   do_name(     arrayPartition_name,                             \"arrayPartition\")                                      \\\n+   do_signature(arrayPartition_signature, \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JIIIILjava\/util\/PartitionOperation;)[I\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -330,3 +330,2 @@\n-  static_field(StubRoutines,                _arraysort,                                       address)                               \\\n-  static_field(StubRoutines,                _array_partition_single,                          address)                               \\\n-  static_field(StubRoutines,                _array_partition_dual,                            address)                               \\\n+  static_field(StubRoutines,                _array_sort,                                      address)                               \\\n+  static_field(StubRoutines,                _array_partition,                                 address)                               \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -600,4 +600,2 @@\n-  case vmIntrinsics::_arraySortMI:\n-  case vmIntrinsics::_arraySortI:\n-  case vmIntrinsics::_arrayPartitionSP:\n-  case vmIntrinsics::_arrayPartitionDP:\n+  case vmIntrinsics::_arraySort:\n+  case vmIntrinsics::_arrayPartition:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -296,5 +296,2 @@\n-  case vmIntrinsics::_arraySortMI:\n-  case vmIntrinsics::_arraySortI:               return inline_arraysort();\n-\n-  case vmIntrinsics::_arrayPartitionSP:         return inline_array_partition(false \/* single pivot*\/);\n-  case vmIntrinsics::_arrayPartitionDP:         return inline_array_partition(true \/* dual pivot*\/);\n+  case vmIntrinsics::_arraySort:                return inline_array_sort();\n+  case vmIntrinsics::_arrayPartition:           return inline_array_partition();\n@@ -5373,1 +5370,1 @@\n-bool LibraryCallKit::inline_array_partition(bool is_dual_pivot) {\n+bool LibraryCallKit::inline_array_partition() {\n@@ -5385,1 +5382,1 @@\n-  Node* indexPivot2     = is_dual_pivot? argument(7) : nullptr;\n+  Node* indexPivot2     = argument(7);\n@@ -5390,1 +5387,1 @@\n-  stubAddr = StubRoutines::select_array_partition_function(is_dual_pivot);\n+  stubAddr = StubRoutines::select_array_partition_function();\n@@ -5415,1 +5412,1 @@\n-  make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::array_partition_Type(is_dual_pivot),\n+  make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::array_partition_Type(),\n@@ -5427,2 +5424,2 @@\n-\/\/------------------------------inline_arraysort-----------------------\n-bool LibraryCallKit::inline_arraysort() {\n+\/\/------------------------------inline_array_sort-----------------------\n+bool LibraryCallKit::inline_array_sort() {\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -280,2 +280,2 @@\n-  bool inline_arraysort();\n-  bool inline_array_partition(bool is_dual_pivot);\n+  bool inline_array_sort();\n+  bool inline_array_partition();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -860,1 +860,1 @@\n-const TypeFunc* OptoRuntime::array_partition_Type(bool is_dual_pivot) {\n+const TypeFunc* OptoRuntime::array_partition_Type() {\n@@ -862,1 +862,1 @@\n-  int num_args = is_dual_pivot ? 7 : 6;\n+  int num_args = 7;\n@@ -872,3 +872,1 @@\n-  if (is_dual_pivot) {\n-    fields[argp++] = TypeInt::INT;    \/\/ indexPivot2\n-  }\n+  fields[argp++] = TypeInt::INT;      \/\/ indexPivot2\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -272,1 +272,1 @@\n-  static const TypeFunc* array_partition_Type(bool is_dual_pivot);\n+  static const TypeFunc* array_partition_Type();\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -179,3 +179,2 @@\n-address StubRoutines::_arraysort = nullptr;\n-address StubRoutines::_array_partition_single  = nullptr;\n-address StubRoutines::_array_partition_dual  = nullptr;\n+address StubRoutines::_array_sort = nullptr;\n+address StubRoutines::_array_partition  = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -156,3 +156,2 @@\n-  static address _arraysort;\n-  static address _array_partition_single;\n-  static address _array_partition_dual;\n+  static address _array_sort;\n+  static address _array_partition;\n@@ -381,2 +380,2 @@\n-  static address select_arraysort_function() { return _arraysort; }\n-  static address select_array_partition_function(bool is_dual_pivot) { return is_dual_pivot ? _array_partition_dual : _array_partition_single; }\n+  static address select_arraysort_function() { return _array_sort; }\n+  static address select_array_partition_function() { return _array_partition; }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -439,3 +439,7 @@\n-void inline avx512_partition(T *arr, int64_t from_index, int64_t to_index, int32_t *pivot_indices, bool is_dual_pviot) {\n-    if(is_dual_pviot) avx512_dual_pivot_partition<T>(arr, from_index, to_index, pivot_indices);\n-        else avx512_single_pivot_partition<T>(arr, from_index, to_index, pivot_indices);\n+void inline avx512_fast_partition(T *arr, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int64_t index_pivot1, int64_t index_pivot2) {\n+    if (index_pivot1 != index_pivot2) {\n+        avx512_dual_pivot_partition<T>(arr, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n+    }\n+    else {\n+        avx512_single_pivot_partition<T>(arr, from_index, to_index, pivot_indices, index_pivot1);\n+    }\n@@ -459,1 +463,1 @@\n-void inline avx512_fastsort(T *arr, int64_t from_index, int64_t to_index, const int32_t INS_SORT_THRESHOLD) {\n+void inline avx512_fast_sort(T *arr, int64_t from_index, int64_t to_index, const int32_t INS_SORT_THRESHOLD) {\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avx512-common-qsort.h","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-                avx512_fastsort<int32_t>((int32_t*)array, from_index, to_index, INSERTION_SORT_THRESHOLD_32BIT);\n+                avx512_fast_sort<int32_t>((int32_t*)array, from_index, to_index, INSERTION_SORT_THRESHOLD_32BIT);\n@@ -44,1 +44,1 @@\n-                avx512_fastsort<int64_t>((int64_t*)array, from_index, to_index, INSERTION_SORT_THRESHOLD_64BIT);\n+                avx512_fast_sort<int64_t>((int64_t*)array, from_index, to_index, INSERTION_SORT_THRESHOLD_64BIT);\n@@ -47,1 +47,1 @@\n-                avx512_fastsort<float>((float*)array, from_index, to_index, INSERTION_SORT_THRESHOLD_32BIT);\n+                avx512_fast_sort<float>((float*)array, from_index, to_index, INSERTION_SORT_THRESHOLD_32BIT);\n@@ -50,1 +50,1 @@\n-                avx512_fastsort<double>((double*)array, from_index, to_index, INSERTION_SORT_THRESHOLD_64BIT);\n+                avx512_fast_sort<double>((double*)array, from_index, to_index, INSERTION_SORT_THRESHOLD_64BIT);\n@@ -55,1 +55,1 @@\n-    DLL_PUBLIC void avx512_partition_single(void *array, int elem_type, int32_t from_index, int32_t to_index, int32_t *pivot_indices, int32_t index_pivot) {\n+    DLL_PUBLIC void avx512_partition(void *array, int elem_type, int32_t from_index, int32_t to_index, int32_t *pivot_indices, int32_t index_pivot1, int32_t index_pivot2) {\n@@ -58,1 +58,1 @@\n-                avx512_single_pivot_partition<int32_t>((int32_t*)array, from_index, to_index, pivot_indices, index_pivot);\n+                avx512_fast_partition<int32_t>((int32_t*)array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n@@ -61,1 +61,1 @@\n-                avx512_single_pivot_partition<int64_t>((int64_t*)array, from_index, to_index, pivot_indices, index_pivot);\n+                avx512_fast_partition<int64_t>((int64_t*)array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n@@ -64,1 +64,1 @@\n-                 avx512_single_pivot_partition<float>((float*)array, from_index, to_index, pivot_indices, index_pivot);\n+                avx512_fast_partition<float>((float*)array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n@@ -67,18 +67,1 @@\n-                avx512_single_pivot_partition<double>((double*)array, from_index, to_index, pivot_indices, index_pivot);\n-                break;\n-        }\n-    }\n-\n-    DLL_PUBLIC void avx512_partition_dual(void *array, int elem_type, int32_t from_index, int32_t to_index, int32_t *pivot_indices, int32_t index_pivot1, int32_t index_pivot2) {\n-        switch(elem_type) {\n-            case JVM_T_INT:\n-                avx512_dual_pivot_partition<int32_t>((int32_t*)array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n-                break;\n-            case JVM_T_LONG:\n-                avx512_dual_pivot_partition<int64_t>((int64_t*)array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n-                break;\n-            case JVM_T_FLOAT:\n-                avx512_dual_pivot_partition<float>((float*)array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n-                break;\n-            case JVM_T_DOUBLE:\n-                avx512_dual_pivot_partition<double>((double*)array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n+                avx512_fast_partition<double>((double*)array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avxsort_linux_x86.cpp","additions":9,"deletions":26,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -56,0 +56,36 @@\n+\n+\/**\n+ * Represents a function that accepts an array and sorts a specified range\n+ * of the array into ascending order.\n+ *\/\n+@FunctionalInterface\n+interface SortOperation<A> {\n+    \/**\n+     * Sorts the specified range of the array.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    void sort(A a, int low, int high);\n+}\n+\n+\/**\n+ * Represents a function that accepts an array and partitions a specified range\n+ * of the array based on the pivots provided.\n+ *\/\n+@FunctionalInterface\n+interface PartitionOperation<A> {\n+     \/**\n+     * Partitions the specified range of the array.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @param indexPivot1 the index of pivot1, the first pivot\n+     * @param indexPivot2 the index of pivot2, the second pivot\n+     *\/\n+    int[] partition(A a, int low, int high, int indexPivot1, int indexPivot2);\n+}\n+\n+\n@@ -140,25 +176,1 @@\n-     * @param end the index of the last element for simple insertion sort\n-     *\/\n-    @IntrinsicCandidate\n-    private static void mixedInsertionSort(Class<?> elemType, Object array, long offset, int low, int high, int end) {\n-        switch (array) {\n-            case int[] arr -> mixedInsertionSort(arr, low, end, high);\n-            case long[] arr ->  mixedInsertionSort(arr, low, end, high);\n-            case float[] arr ->  mixedInsertionSort(arr, low, end, high);\n-            case double[] arr ->  mixedInsertionSort(arr, low, end, high);\n-            default -> throw new UnsupportedOperationException();\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified array into ascending numerical order using\n-     * insertion sort.The intrinsic is free to choose its own\n-     * sorting algorithm.\n-     *\n-     * @param elemType the class of the elements of the array to be sorted\n-     * @param array the array to be sorted\n-     * @param offset the relative offset, in bytes, from the base address of\n-     * the array to sort, otherwise if the array is {@code null},an absolute\n-     * address pointing to the first element to sort from.\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n+     * @param so the method reference for the fallback implementation\n@@ -167,8 +179,2 @@\n-    private static void insertionSort(Class<?> elemType, Object array, long offset, int low, int high) {\n-       switch (array) {\n-            case int[] arr -> insertionSort(arr, low, high);\n-            case long[] arr -> insertionSort(arr, low, high);\n-            case float[] arr -> insertionSort(arr, low, high);\n-            case double[] arr -> insertionSort(arr, low, high);\n-            default -> throw new UnsupportedOperationException();\n-        }\n+    private static <A> void arraySort(Class<?> elemType, A array, long offset, int low, int high, SortOperation<A> so) {\n+        so.sort(array, low, high);\n@@ -189,0 +195,1 @@\n+     * @param po the method reference for the fallback implementation\n@@ -192,8 +199,2 @@\n-    private static int[] partitionDualPivot(Class<?> elemType, Object array, long offset, int low, int high, int indexPivot1, int indexPivot2) {\n-        return switch(array) {\n-            case int[] arr -> partitionDualPivot(arr, low, high, indexPivot1, indexPivot2);\n-            case long[] arr -> partitionDualPivot(arr, low, high, indexPivot1, indexPivot2);\n-            case float[] arr -> partitionDualPivot(arr, low, high, indexPivot1, indexPivot2);\n-            case double[] arr -> partitionDualPivot(arr, low, high, indexPivot1, indexPivot2);\n-            default -> throw new UnsupportedOperationException();\n-        };\n+    private static <A> int[] arrayPartition(Class<?> elemType, A array, long offset, int low, int high, int indexPivot1, int indexPivot2, PartitionOperation<A> po) {\n+        return po.partition(array, low, high, indexPivot1, indexPivot2);\n@@ -202,23 +203,0 @@\n-    \/**\n-     * Partitions the specified array based on the single pivot provided.\n-     *\n-     * @param elemType the class of the array to be sorted\n-     * @param array the array to be sorted\n-     * @param offset the relative offset, in bytes, from the base address of\n-     * the array to partition, otherwise if the array is {@code null},an absolute\n-     * address pointing to the first element to partition from.\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     * @param indexPivot the index of the pivot\n-     *\/\n-    @IntrinsicCandidate\n-    @ForceInline\n-    private static int[] partitionSinglePivot(Class<?> elemType, Object array, long offset, int low, int high, int indexPivot) {\n-        return switch(array) {\n-            case int[] arr -> partitionSinglePivot(arr, low, high, indexPivot);\n-            case long[] arr -> partitionSinglePivot(arr, low, high, indexPivot);\n-            case float[] arr -> partitionSinglePivot(arr, low, high, indexPivot);\n-            case double[] arr -> partitionSinglePivot(arr, low, high, indexPivot);\n-            default -> throw new UnsupportedOperationException();\n-        };\n-    }\n@@ -289,1 +267,1 @@\n-                mixedInsertionSort(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, high - 3 * ((size >> 5) << 3));\n+                arraySort(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, DualPivotQuicksort::mixedInsertionSort);\n@@ -297,1 +275,1 @@\n-                insertionSort(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high);\n+                arraySort(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, DualPivotQuicksort::insertionSort);\n@@ -383,1 +361,1 @@\n-                pivotIndices = partitionDualPivot(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, e1, e5);\n+                pivotIndices = arrayPartition(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, e1, e5, DualPivotQuicksort::partitionDualPivot);\n@@ -407,1 +385,1 @@\n-                pivotIndices = partitionSinglePivot(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, e3);\n+                pivotIndices = arrayPartition(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, e3, e3, DualPivotQuicksort::partitionSinglePivot);\n@@ -520,1 +498,2 @@\n-     * @param indexPivot the index of the pivot\n+     * @param indexPivot1 the index of pivot1, the first pivot\n+     * @param indexPivot2 the index of pivot2, the second pivot\n@@ -524,1 +503,3 @@\n-    private static int[] partitionSinglePivot(int[] a, int low, int high, int indexPivot) {\n+    private static int[] partitionSinglePivot(int[] a, int low, int high, int indexPivot1, int indexPivot2) {\n+        if (indexPivot1 != indexPivot2) throw new IllegalArgumentException(\"both the pivot indices must be same\");\n+\n@@ -528,1 +509,1 @@\n-        int e3 = indexPivot;\n+        int e3 = indexPivot1;\n@@ -599,1 +580,0 @@\n-     * @param end the index of the last element for simple insertion sort\n@@ -602,1 +582,3 @@\n-    private static void mixedInsertionSort(int[] a, int low, int end, int high) {\n+    private static void mixedInsertionSort(int[] a, int low, int high) {\n+        int size = high - low;\n+        int end = high - 3 * ((size >> 5) << 3);\n@@ -1092,2 +1074,1 @@\n-                int last  = high - 3 * ((size >> 5) << 3);\n-                mixedInsertionSort(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, high - 3 * ((size >> 5) << 3));\n+                arraySort(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, DualPivotQuicksort::mixedInsertionSort);\n@@ -1101,1 +1082,1 @@\n-                insertionSort(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high);\n+                arraySort(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, DualPivotQuicksort::insertionSort);\n@@ -1188,1 +1169,1 @@\n-                pivotIndices = partitionDualPivot(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, e1, e5);\n+                pivotIndices = arrayPartition(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, e1, e5, DualPivotQuicksort::partitionDualPivot);\n@@ -1209,1 +1190,1 @@\n-                pivotIndices = partitionSinglePivot(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, e3);\n+                pivotIndices = arrayPartition(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, e3, e3, DualPivotQuicksort::partitionSinglePivot);\n@@ -1321,1 +1302,2 @@\n-     * @param indexPivot the index of the pivot\n+     * @param indexPivot1 the index of pivot1, the first pivot\n+     * @param indexPivot2 the index of pivot2, the second pivot\n@@ -1325,1 +1307,3 @@\n-    private static int[] partitionSinglePivot(long[] a, int low, int high, int indexPivot) {\n+    private static int[] partitionSinglePivot(long[] a, int low, int high, int indexPivot1, int indexPivot2) {\n+        if (indexPivot1 != indexPivot2) throw new IllegalArgumentException(\"both the pivot indices must be same\");\n+\n@@ -1330,1 +1314,1 @@\n-        int e3 = indexPivot;\n+        int e3 = indexPivot1;\n@@ -1401,1 +1385,0 @@\n-     * @param end the index of the last element for simple insertion sort\n@@ -1404,1 +1387,3 @@\n-    private static void mixedInsertionSort(long[] a, int low, int end, int high) {\n+    private static void mixedInsertionSort(long[] a, int low, int high) {\n+        int size = high - low;\n+        int end = high - 3 * ((size >> 5) << 3);\n@@ -2681,2 +2666,1 @@\n-                int last  = high - 3 * ((size >> 5) << 3);\n-                mixedInsertionSort(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, high - 3 * ((size >> 5) << 3));\n+                arraySort(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, DualPivotQuicksort::mixedInsertionSort);\n@@ -2690,1 +2674,1 @@\n-                insertionSort(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high);\n+                arraySort(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, DualPivotQuicksort::insertionSort);\n@@ -2777,1 +2761,1 @@\n-                pivotIndices = partitionDualPivot(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, e1, e5);\n+                pivotIndices = arrayPartition(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, e1, e5, DualPivotQuicksort::partitionDualPivot);\n@@ -2798,1 +2782,1 @@\n-                pivotIndices = partitionSinglePivot(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, e3);\n+                pivotIndices = arrayPartition(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, e3, e3, DualPivotQuicksort::partitionSinglePivot);\n@@ -2910,1 +2894,2 @@\n-     * @param indexPivot the index of the pivot\n+     * @param indexPivot1 the index of pivot1, the first pivot\n+     * @param indexPivot2 the index of pivot2, the second pivot\n@@ -2914,1 +2899,2 @@\n-    private static int[] partitionSinglePivot(float[] a, int low, int high, int indexPivot) {\n+    private static int[] partitionSinglePivot(float[] a, int low, int high, int indexPivot1, int indexPivot2) {\n+        if (indexPivot1 != indexPivot2) throw new IllegalArgumentException(\"both the pivot indices must be same\");\n@@ -2919,1 +2905,1 @@\n-        int e3 = indexPivot;\n+        int e3 = indexPivot1;\n@@ -2990,1 +2976,0 @@\n-     * @param end the index of the last element for simple insertion sort\n@@ -2993,1 +2978,3 @@\n-    private static void mixedInsertionSort(float[] a, int low, int end, int high) {\n+    private static void mixedInsertionSort(float[] a, int low, int high) {\n+        int size = high - low;\n+        int end = high - 3 * ((size >> 5) << 3);\n@@ -3534,2 +3521,1 @@\n-                int last  = high - 3 * ((size >> 5) << 3);\n-                mixedInsertionSort(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, high - 3 * ((size >> 5) << 3));\n+                arraySort(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, DualPivotQuicksort::mixedInsertionSort);\n@@ -3543,1 +3529,1 @@\n-                insertionSort(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high);\n+                arraySort(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, DualPivotQuicksort::insertionSort);\n@@ -3630,1 +3616,1 @@\n-                pivotIndices = partitionDualPivot(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, e1, e5);\n+                pivotIndices = arrayPartition(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, e1, e5, DualPivotQuicksort::partitionDualPivot);\n@@ -3651,1 +3637,1 @@\n-                pivotIndices = partitionSinglePivot(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, e3);\n+                pivotIndices = arrayPartition(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, e3, e3, DualPivotQuicksort::partitionSinglePivot);\n@@ -3765,1 +3751,2 @@\n-     * @param indexPivot the index of the pivot\n+     * @param indexPivot1 the index of pivot1, the first pivot\n+     * @param indexPivot2 the index of pivot2, the second pivot\n@@ -3768,1 +3755,3 @@\n-    private static int[] partitionSinglePivot(double[] a, int low, int high, int indexPivot) {\n+    private static int[] partitionSinglePivot(double[] a, int low, int high, int indexPivot1, int indexPivot2) {\n+        if (indexPivot1 != indexPivot2) throw new IllegalArgumentException(\"both the pivot indices must be same\");\n+\n@@ -3773,1 +3762,1 @@\n-        int e3 = indexPivot;\n+        int e3 = indexPivot1;\n@@ -3844,1 +3833,0 @@\n-     * @param end the index of the last element for simple insertion sort\n@@ -3847,1 +3835,3 @@\n-    private static void mixedInsertionSort(double[] a, int low, int end, int high) {\n+    private static void mixedInsertionSort(double[] a, int low, int high) {\n+        int size = high - low;\n+        int end = high - 3 * ((size >> 5) << 3);\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":93,"deletions":103,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:DisableIntrinsic=_arraySortI,_arraySortMI,_arrayPartitionSP,_arrayPartitionDP Sorting -shortrun\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:DisableIntrinsic=_arraySort,_arrayPartition, Sorting -shortrun\n","filename":"test\/jdk\/java\/util\/Arrays\/Sorting.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}