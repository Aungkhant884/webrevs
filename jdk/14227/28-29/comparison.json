{"files":[{"patch":"@@ -4133,10 +4133,1 @@\n-  \/\/ Get addresses for avx512 sort and partition routines\n-  void *libx86_64 = nullptr;\n-  char ebuf_x86_64[1024];\n-  char dll_name_avx512[JVM_MAXPATHLEN];\n-  if (os::dll_locate_lib(dll_name_avx512, sizeof(dll_name_avx512), Arguments::get_dll_dir(), \"x86_64\")) {\n-    libx86_64 = os::dll_load(dll_name_avx512, ebuf_x86_64, sizeof ebuf_x86_64);\n-  }\n-  if (libx86_64 != nullptr) {\n-    log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, JNI_LIB_PREFIX \"x86_64\" JNI_LIB_SUFFIX, p2i(libx86_64));\n-\n+  \/\/ Load x86_64 library on supported hardware to enable avx512 sort and partition intrinsics\n@@ -4145,0 +4136,10 @@\n+      void *libx86_64 = nullptr;\n+      char ebuf_x86_64[1024];\n+      char dll_name_avx512[JVM_MAXPATHLEN];\n+      if (os::dll_locate_lib(dll_name_avx512, sizeof(dll_name_avx512), Arguments::get_dll_dir(), \"x86_64\")) {\n+        libx86_64 = os::dll_load(dll_name_avx512, ebuf_x86_64, sizeof ebuf_x86_64);\n+      }\n+    \/\/ Get addresses for avx512 sort and partition routines\n+    if (libx86_64 != nullptr) {\n+      log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, JNI_LIB_PREFIX \"x86_64\" JNI_LIB_SUFFIX, p2i(libx86_64));\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -350,1 +350,1 @@\n-  do_signature(arrayPartition_signature,      \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JII[IJZ)V\")                          \\\n+  do_signature(arrayPartition_signature,      \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JII[IZ)V\")                           \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5211,2 +5211,1 @@\n-  Node* pivot_offset    = argument(7);\n-  Node* isDualPivot     = argument(9);\n+  Node* isDualPivot     = argument(7);\n@@ -5224,1 +5223,0 @@\n-\n@@ -5228,1 +5226,5 @@\n-  Node* pivot_indices_adr = make_unsafe_address(pivot_indices, pivot_offset); \/\/this offset is not same as array offset\n+  const TypeAryPtr* pivot_indices_type = pivot_indices->Value(&_gvn)->isa_aryptr();\n+  if (pivot_indices_type == nullptr || pivot_indices_type->elem() == Type::BOTTOM ) {\n+    return false; \/\/ failed input validation\n+  }\n+  Node* pivot_indices_adr = array_element_address(pivot_indices, intcon(0), T_INT);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -887,1 +887,1 @@\n-  fields[argp++] = TypePtr::NOTNULL;    \/\/ array(fromIndex)\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ array\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,6 +118,0 @@\n-template <typename T>\n-void avx512_dual_pivot_partition(T *arr, int64_t low, int64_t high, int32_t *pivot_indices, bool isDualPivot);\n-\n-template <typename T>\n-void avx512_single_pivot_partition(T *arr, int64_t low, int64_t high, int32_t *pivot_indices, bool isDualPivot);\n-\n","filename":"src\/java.base\/linux\/native\/libx86_64\/avx512-common-qsort.h","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -150,1 +151,2 @@\n-    static void arraySort(Class<?> elemType, Object array, long offset, int low, int high, int end) {\n+    @ForceInline\n+    private static void arraySort(Class<?> elemType, Object array, long offset, int low, int high, int end) {\n@@ -167,2 +169,0 @@\n-     * @param pivot_offset the offset in bytes pointing to the base address of\n-     * the array used to store the indices of the pivots.\n@@ -173,1 +173,2 @@\n-    static void arrayPartition(Class<?> elemType, Object array, long offset, int low, int high, int[] pivotIndices, long pivot_offset, boolean isDualPivot) {\n+    @ForceInline\n+    private static void arrayPartition(Class<?> elemType, Object array, long offset, int low, int high, int[] pivotIndices, boolean isDualPivot) {\n@@ -203,1 +204,1 @@\n-    static void insertionSort(Object array, int low, int high) {\n+    private static void insertionSort(Object array, int low, int high) {\n@@ -222,1 +223,1 @@\n-    static void mixedInsertionSort(Object array, int low, int end, int high) {\n+    private static void mixedInsertionSort(Object array, int low, int end, int high) {\n@@ -242,1 +243,1 @@\n-    static void partitionDualPivot(Object array, int low, int high, int[] pivotIndices) {\n+    private static void partitionDualPivot(Object array, int low, int high, int[] pivotIndices) {\n@@ -262,1 +263,1 @@\n-    static void partitionSinglePivot(Object array, int low, int high, int[] pivotIndices) {\n+    private static void partitionSinglePivot(Object array, int low, int high, int[] pivotIndices) {\n@@ -419,1 +420,1 @@\n-                arrayPartition(int.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n+                arrayPartition(int.class, a, baseOffset, low, high, pivotIndices, isDualPivot);\n@@ -444,1 +445,1 @@\n-                arrayPartition(int.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n+                arrayPartition(int.class, a, baseOffset, low, high, pivotIndices, isDualPivot);\n@@ -1233,1 +1234,1 @@\n-                arrayPartition(long.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n+                arrayPartition(long.class, a, baseOffset, low, high, pivotIndices, isDualPivot);\n@@ -1255,1 +1256,1 @@\n-                arrayPartition(long.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n+                arrayPartition(long.class, a, baseOffset, low, high, pivotIndices, isDualPivot);\n@@ -2829,1 +2830,1 @@\n-                arrayPartition(float.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n+                arrayPartition(float.class, a, baseOffset, low, high, pivotIndices, isDualPivot);\n@@ -2851,1 +2852,1 @@\n-                arrayPartition(float.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n+                arrayPartition(float.class, a, baseOffset, low, high, pivotIndices, isDualPivot);\n@@ -3690,1 +3691,1 @@\n-                arrayPartition(double.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n+                arrayPartition(double.class, a, baseOffset, low, high, pivotIndices, isDualPivot);\n@@ -3712,1 +3713,1 @@\n-                arrayPartition(double.class, a, baseOffset, low, high, pivotIndices, Unsafe.ARRAY_INT_BASE_OFFSET, isDualPivot);\n+                arrayPartition(double.class, a, baseOffset, low, high, pivotIndices, isDualPivot);\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/ArraysSort.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}