{"files":[{"patch":"@@ -236,0 +236,20 @@\n+\n+################################################################################\n+\n+ifeq ($(call isTargetOs, linux)+$(call isTargetCpu, x86_64)+$(INCLUDE_COMPILER2), true+true+true)\n+  $(eval $(call SetupJdkLibrary, BUILD_LIBAVX512_X86_64, \\\n+      NAME := avx512_x86_64, \\\n+      OPTIMIZATION := HIGH, \\\n+      CFLAGS := $(CFLAGS_JDKLIB) -mavx512f -mavx512dq, \\\n+      CXXFLAGS := $(CXXFLAGS_JDKLIB) -mavx512f -mavx512dq, \\\n+      LDFLAGS := $(LDFLAGS_JDKLIB) \\\n+          $(call SET_SHARED_LIBRARY_ORIGIN), \\\n+      LDFLAGS_linux := -Wl$(COMMA)--no-as-needed, \\\n+      LIBS := $(LIBCXX), \\\n+      LIBS_linux := -lc -lm -ldl, \\\n+  ))\n+\n+  TARGETS += $(BUILD_LIBAVX512_X86_64)\n+endif\n+\n+################################################################################\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -4133,0 +4133,26 @@\n+  \/\/ Get avx512 sort stub routine addresses\n+  void *libavx512_x86_64 = nullptr;\n+  char ebuf_avx512[1024];\n+  char dll_name_avx512[JVM_MAXPATHLEN];\n+  if (os::dll_locate_lib(dll_name_avx512, sizeof(dll_name_avx512), Arguments::get_dll_dir(), \"avx512_x86_64\")) {\n+    libavx512_x86_64 = os::dll_load(dll_name_avx512, ebuf_avx512, sizeof ebuf_avx512);\n+  }\n+  if (libavx512_x86_64 != nullptr) {\n+    log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, JNI_LIB_PREFIX \"avx512_x86_64\" JNI_LIB_SUFFIX, p2i(libavx512_x86_64));\n+\n+    if (UseAVX > 2 && VM_Version::supports_avx512dq()) {\n+\n+      snprintf(ebuf_avx512, sizeof(ebuf_avx512), \"avx512_sort_int\");\n+      StubRoutines::_arraysort_int = (address)os::dll_lookup(libavx512_x86_64, ebuf_avx512);\n+\n+      snprintf(ebuf_avx512, sizeof(ebuf_avx512), \"avx512_sort_long\");\n+      StubRoutines::_arraysort_long = (address)os::dll_lookup(libavx512_x86_64, ebuf_avx512);\n+\n+      snprintf(ebuf_avx512, sizeof(ebuf_avx512), \"avx512_sort_float\");\n+      StubRoutines::_arraysort_float = (address)os::dll_lookup(libavx512_x86_64, ebuf_avx512);\n+\n+      snprintf(ebuf_avx512, sizeof(ebuf_avx512), \"avx512_sort_double\");\n+      StubRoutines::_arraysort_double = (address)os::dll_lookup(libavx512_x86_64, ebuf_avx512);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -344,0 +344,4 @@\n+  do_intrinsic(_arraySort,                java_util_Arrays,       arraySort_name, arraySort_signature,           F_S)   \\\n+   do_name(     arraySort_name,                                  \"arraySort\")                                           \\\n+   do_signature(arraySort_signature,                             \"(Ljava\/lang\/Class;Ljava\/lang\/Object;II)V\")            \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -571,0 +571,1 @@\n+  case vmIntrinsics::_arraySort:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -295,0 +295,2 @@\n+  case vmIntrinsics::_arraySort:               return inline_arraysort(intrinsic_id());\n+\n@@ -5195,0 +5197,41 @@\n+\/\/------------------------------inline_arraysort-----------------------\n+bool LibraryCallKit::inline_arraysort(vmIntrinsics::ID id) {\n+\n+  address stubAddr = nullptr;\n+  const char *stubName;\n+  stubName = \"arraysort_stub\";\n+\n+  Node* elementType     = argument(0);\n+  Node* array           = argument(1);\n+  Node* fromIndex       = argument(2);\n+  Node* toIndex         = argument(3);\n+\n+  const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  BasicType bt = elem_type->basic_type();\n+\n+  stubAddr = StubRoutines::select_arraysort_function(bt);\n+  if (stubAddr == nullptr) return false;\n+\n+  array = must_be_not_null(array, true);\n+\n+  const TypeAryPtr* array_type = array->Value(&_gvn)->isa_aryptr();\n+  assert(array_type != nullptr &&  array_type->elem() != Type::BOTTOM, \"args are strange\");\n+\n+  \/\/ for the quick and dirty code we will skip all the checks.\n+  \/\/ we are just trying to get the call to be generated.\n+  Node* array_fromIndex  = array;\n+  if (fromIndex != nullptr || toIndex != nullptr) {\n+    assert(fromIndex != nullptr && toIndex != nullptr, \"\");\n+    array_fromIndex = array_element_address(array, fromIndex, bt);\n+  }\n+\n+  \/\/ Call the stub.\n+  make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::array_sort_Type(),\n+                    stubAddr, stubName, TypePtr::BOTTOM,\n+                    array_fromIndex, fromIndex, toIndex);\n+\n+  return true;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -282,1 +282,1 @@\n-\n+  bool inline_arraysort(vmIntrinsics::ID id);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -860,0 +860,19 @@\n+const TypeFunc* OptoRuntime::array_sort_Type() {\n+  \/\/ create input type (domain)\n+  int num_args      = 3;\n+  int argcnt = num_args;\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ array(fromIndex)\n+  fields[argp++] = TypeInt::INT;    \/\/ fromIndex\n+  fields[argp++] = TypeInt::INT;    \/\/ toIndex\n+  assert(argp == TypeFunc::Parms+argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ no result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n+  return TypeFunc::make(domain, range);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -271,0 +271,1 @@\n+  static const TypeFunc* array_sort_Type();\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -179,0 +179,5 @@\n+address StubRoutines::_arraysort_int        = nullptr;\n+address StubRoutines::_arraysort_long       = nullptr;\n+address StubRoutines::_arraysort_float      = nullptr;\n+address StubRoutines::_arraysort_double     = nullptr;\n+\n@@ -651,0 +656,12 @@\n+\n+address StubRoutines::select_arraysort_function(BasicType t) {\n+  switch(t) {\n+    case T_INT:    return _arraysort_int;\n+    case T_LONG:   return _arraysort_long;\n+    case T_FLOAT:  return _arraysort_float;\n+    case T_DOUBLE: return _arraysort_double;\n+  default:\n+    ShouldNotReachHere();\n+    return nullptr;\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -156,0 +156,4 @@\n+  static address _arraysort_int;\n+  static address _arraysort_long;\n+  static address _arraysort_float;\n+  static address _arraysort_double;\n@@ -376,0 +380,1 @@\n+  static address select_arraysort_function(BasicType t);\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -532,0 +532,4 @@\n+     static_field(StubRoutines,                _arraysort_int,                                address)                               \\\n+     static_field(StubRoutines,                _arraysort_long,                               address)                               \\\n+     static_field(StubRoutines,                _arraysort_float,                              address)                               \\\n+     static_field(StubRoutines,                _arraysort_double,                             address)                               \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,604 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Intel Corporation. All rights reserved.\n+ * Intel x86-simd-sort source code.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This implementation is based on x86-simd-sort(https:\/\/github.com\/intel\/x86-simd-sort)\n+\n+#ifndef AVX512_QSORT_32BIT\n+#define AVX512_QSORT_32BIT\n+\n+#include \"avx512-common-qsort.h\"\n+\n+\/*\n+ * Constants used in sorting 16 elements in a ZMM registers. Based on Bitonic\n+ * sorting network (see\n+ * https:\/\/en.wikipedia.org\/wiki\/Bitonic_sorter#\/media\/File:BitonicSort.svg)\n+ *\/\n+#define NETWORK_32BIT_1 14, 15, 12, 13, 10, 11, 8, 9, 6, 7, 4, 5, 2, 3, 0, 1\n+#define NETWORK_32BIT_2 12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3\n+#define NETWORK_32BIT_3 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7\n+#define NETWORK_32BIT_4 13, 12, 15, 14, 9, 8, 11, 10, 5, 4, 7, 6, 1, 0, 3, 2\n+#define NETWORK_32BIT_5 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\n+#define NETWORK_32BIT_6 11, 10, 9, 8, 15, 14, 13, 12, 3, 2, 1, 0, 7, 6, 5, 4\n+#define NETWORK_32BIT_7 7, 6, 5, 4, 3, 2, 1, 0, 15, 14, 13, 12, 11, 10, 9, 8\n+\n+template <>\n+struct zmm_vector<int32_t> {\n+    using type_t = int32_t;\n+    using zmm_t = __m512i;\n+    using ymm_t = __m256i;\n+    using opmask_t = __mmask16;\n+    static const uint8_t numlanes = 16;\n+\n+    static type_t type_max() { return X86_SIMD_SORT_MAX_INT32; }\n+    static type_t type_min() { return X86_SIMD_SORT_MIN_INT32; }\n+    static zmm_t zmm_max() { return _mm512_set1_epi32(type_max()); }\n+\n+    static opmask_t knot_opmask(opmask_t x) { return _mm512_knot(x); }\n+    static opmask_t ge(zmm_t x, zmm_t y) {\n+        return _mm512_cmp_epi32_mask(x, y, _MM_CMPINT_NLT);\n+    }\n+    template <int scale>\n+    static ymm_t i64gather(__m512i index, void const *base) {\n+        return _mm512_i64gather_epi32(index, base, scale);\n+    }\n+    static zmm_t merge(ymm_t y1, ymm_t y2) {\n+        zmm_t z1 = _mm512_castsi256_si512(y1);\n+        return _mm512_inserti32x8(z1, y2, 1);\n+    }\n+    static zmm_t loadu(void const *mem) { return _mm512_loadu_si512(mem); }\n+    static void mask_compressstoreu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm512_mask_compressstoreu_epi32(mem, mask, x);\n+    }\n+    static zmm_t mask_loadu(zmm_t x, opmask_t mask, void const *mem) {\n+        return _mm512_mask_loadu_epi32(x, mask, mem);\n+    }\n+    static zmm_t mask_mov(zmm_t x, opmask_t mask, zmm_t y) {\n+        return _mm512_mask_mov_epi32(x, mask, y);\n+    }\n+    static void mask_storeu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm512_mask_storeu_epi32(mem, mask, x);\n+    }\n+    static zmm_t min(zmm_t x, zmm_t y) { return _mm512_min_epi32(x, y); }\n+    static zmm_t max(zmm_t x, zmm_t y) { return _mm512_max_epi32(x, y); }\n+    static zmm_t permutexvar(__m512i idx, zmm_t zmm) {\n+        return _mm512_permutexvar_epi32(idx, zmm);\n+    }\n+    static type_t reducemax(zmm_t v) { return _mm512_reduce_max_epi32(v); }\n+    static type_t reducemin(zmm_t v) { return _mm512_reduce_min_epi32(v); }\n+    static zmm_t set1(type_t v) { return _mm512_set1_epi32(v); }\n+    template <uint8_t mask>\n+    static zmm_t shuffle(zmm_t zmm) {\n+        return _mm512_shuffle_epi32(zmm, (_MM_PERM_ENUM)mask);\n+    }\n+    static void storeu(void *mem, zmm_t x) {\n+        return _mm512_storeu_si512(mem, x);\n+    }\n+\n+    static ymm_t max(ymm_t x, ymm_t y) { return _mm256_max_epi32(x, y); }\n+    static ymm_t min(ymm_t x, ymm_t y) { return _mm256_min_epi32(x, y); }\n+};\n+template <>\n+struct zmm_vector<uint32_t> {\n+    using type_t = uint32_t;\n+    using zmm_t = __m512i;\n+    using ymm_t = __m256i;\n+    using opmask_t = __mmask16;\n+    static const uint8_t numlanes = 16;\n+\n+    static type_t type_max() { return X86_SIMD_SORT_MAX_UINT32; }\n+    static type_t type_min() { return 0; }\n+    static zmm_t zmm_max() {\n+        return _mm512_set1_epi32(type_max());\n+    }  \/\/ TODO: this should broadcast bits as is?\n+\n+    template <int scale>\n+    static ymm_t i64gather(__m512i index, void const *base) {\n+        return _mm512_i64gather_epi32(index, base, scale);\n+    }\n+    static zmm_t merge(ymm_t y1, ymm_t y2) {\n+        zmm_t z1 = _mm512_castsi256_si512(y1);\n+        return _mm512_inserti32x8(z1, y2, 1);\n+    }\n+    static opmask_t knot_opmask(opmask_t x) { return _mm512_knot(x); }\n+    static opmask_t ge(zmm_t x, zmm_t y) {\n+        return _mm512_cmp_epu32_mask(x, y, _MM_CMPINT_NLT);\n+    }\n+    static zmm_t loadu(void const *mem) { return _mm512_loadu_si512(mem); }\n+    static zmm_t max(zmm_t x, zmm_t y) { return _mm512_max_epu32(x, y); }\n+    static void mask_compressstoreu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm512_mask_compressstoreu_epi32(mem, mask, x);\n+    }\n+    static zmm_t mask_loadu(zmm_t x, opmask_t mask, void const *mem) {\n+        return _mm512_mask_loadu_epi32(x, mask, mem);\n+    }\n+    static zmm_t mask_mov(zmm_t x, opmask_t mask, zmm_t y) {\n+        return _mm512_mask_mov_epi32(x, mask, y);\n+    }\n+    static void mask_storeu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm512_mask_storeu_epi32(mem, mask, x);\n+    }\n+    static zmm_t min(zmm_t x, zmm_t y) { return _mm512_min_epu32(x, y); }\n+    static zmm_t permutexvar(__m512i idx, zmm_t zmm) {\n+        return _mm512_permutexvar_epi32(idx, zmm);\n+    }\n+    static type_t reducemax(zmm_t v) { return _mm512_reduce_max_epu32(v); }\n+    static type_t reducemin(zmm_t v) { return _mm512_reduce_min_epu32(v); }\n+    static zmm_t set1(type_t v) { return _mm512_set1_epi32(v); }\n+    template <uint8_t mask>\n+    static zmm_t shuffle(zmm_t zmm) {\n+        return _mm512_shuffle_epi32(zmm, (_MM_PERM_ENUM)mask);\n+    }\n+    static void storeu(void *mem, zmm_t x) {\n+        return _mm512_storeu_si512(mem, x);\n+    }\n+\n+    static ymm_t max(ymm_t x, ymm_t y) { return _mm256_max_epu32(x, y); }\n+    static ymm_t min(ymm_t x, ymm_t y) { return _mm256_min_epu32(x, y); }\n+};\n+template <>\n+struct zmm_vector<float> {\n+    using type_t = float;\n+    using zmm_t = __m512;\n+    using ymm_t = __m256;\n+    using opmask_t = __mmask16;\n+    static const uint8_t numlanes = 16;\n+\n+    static type_t type_max() { return X86_SIMD_SORT_INFINITYF; }\n+    static type_t type_min() { return -X86_SIMD_SORT_INFINITYF; }\n+    static zmm_t zmm_max() { return _mm512_set1_ps(type_max()); }\n+\n+    static opmask_t knot_opmask(opmask_t x) { return _mm512_knot(x); }\n+    static opmask_t ge(zmm_t x, zmm_t y) {\n+        return _mm512_cmp_ps_mask(x, y, _CMP_GE_OQ);\n+    }\n+    template <int scale>\n+    static ymm_t i64gather(__m512i index, void const *base) {\n+        return _mm512_i64gather_ps(index, base, scale);\n+    }\n+    static zmm_t merge(ymm_t y1, ymm_t y2) {\n+        zmm_t z1 = _mm512_castsi512_ps(\n+            _mm512_castsi256_si512(_mm256_castps_si256(y1)));\n+        return _mm512_insertf32x8(z1, y2, 1);\n+    }\n+    static zmm_t loadu(void const *mem) { return _mm512_loadu_ps(mem); }\n+    static zmm_t max(zmm_t x, zmm_t y) { return _mm512_max_ps(x, y); }\n+    static void mask_compressstoreu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm512_mask_compressstoreu_ps(mem, mask, x);\n+    }\n+    static zmm_t mask_loadu(zmm_t x, opmask_t mask, void const *mem) {\n+        return _mm512_mask_loadu_ps(x, mask, mem);\n+    }\n+    static zmm_t mask_mov(zmm_t x, opmask_t mask, zmm_t y) {\n+        return _mm512_mask_mov_ps(x, mask, y);\n+    }\n+    static void mask_storeu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm512_mask_storeu_ps(mem, mask, x);\n+    }\n+    static zmm_t min(zmm_t x, zmm_t y) { return _mm512_min_ps(x, y); }\n+    static zmm_t permutexvar(__m512i idx, zmm_t zmm) {\n+        return _mm512_permutexvar_ps(idx, zmm);\n+    }\n+    static type_t reducemax(zmm_t v) { return _mm512_reduce_max_ps(v); }\n+    static type_t reducemin(zmm_t v) { return _mm512_reduce_min_ps(v); }\n+    static zmm_t set1(type_t v) { return _mm512_set1_ps(v); }\n+    template <uint8_t mask>\n+    static zmm_t shuffle(zmm_t zmm) {\n+        return _mm512_shuffle_ps(zmm, zmm, (_MM_PERM_ENUM)mask);\n+    }\n+    static void storeu(void *mem, zmm_t x) { return _mm512_storeu_ps(mem, x); }\n+\n+    static ymm_t max(ymm_t x, ymm_t y) { return _mm256_max_ps(x, y); }\n+    static ymm_t min(ymm_t x, ymm_t y) { return _mm256_min_ps(x, y); }\n+};\n+\n+\/*\n+ * Assumes zmm is random and performs a full sorting network defined in\n+ * https:\/\/en.wikipedia.org\/wiki\/Bitonic_sorter#\/media\/File:BitonicSort.svg\n+ *\/\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n+X86_SIMD_SORT_INLINE zmm_t sort_zmm_32bit(zmm_t zmm) {\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(2, 3, 0, 1)>(zmm), 0xAAAA);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(0, 1, 2, 3)>(zmm), 0xCCCC);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(2, 3, 0, 1)>(zmm), 0xAAAA);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_3), zmm),\n+        0xF0F0);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 0, 3, 2)>(zmm), 0xCCCC);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(2, 3, 0, 1)>(zmm), 0xAAAA);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5), zmm),\n+        0xFF00);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_6), zmm),\n+        0xF0F0);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 0, 3, 2)>(zmm), 0xCCCC);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(2, 3, 0, 1)>(zmm), 0xAAAA);\n+    return zmm;\n+}\n+\n+\/\/ Assumes zmm is bitonic and performs a recursive half cleaner\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n+X86_SIMD_SORT_INLINE zmm_t bitonic_merge_zmm_32bit(zmm_t zmm) {\n+    \/\/ 1) half_cleaner[16]: compare 1-9, 2-10, 3-11 etc ..\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_7), zmm),\n+        0xFF00);\n+    \/\/ 2) half_cleaner[8]: compare 1-5, 2-6, 3-7 etc ..\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_6), zmm),\n+        0xF0F0);\n+    \/\/ 3) half_cleaner[4]\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 0, 3, 2)>(zmm), 0xCCCC);\n+    \/\/ 3) half_cleaner[1]\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(2, 3, 0, 1)>(zmm), 0xAAAA);\n+    return zmm;\n+}\n+\n+\/\/ Assumes zmm1 and zmm2 are sorted and performs a recursive half cleaner\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n+X86_SIMD_SORT_INLINE void bitonic_merge_two_zmm_32bit(zmm_t *zmm1,\n+                                                      zmm_t *zmm2) {\n+    \/\/ 1) First step of a merging network: coex of zmm1 and zmm2 reversed\n+    *zmm2 = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5), *zmm2);\n+    zmm_t zmm3 = vtype::min(*zmm1, *zmm2);\n+    zmm_t zmm4 = vtype::max(*zmm1, *zmm2);\n+    \/\/ 2) Recursive half cleaner for each\n+    *zmm1 = bitonic_merge_zmm_32bit<vtype>(zmm3);\n+    *zmm2 = bitonic_merge_zmm_32bit<vtype>(zmm4);\n+}\n+\n+\/\/ Assumes [zmm0, zmm1] and [zmm2, zmm3] are sorted and performs a recursive\n+\/\/ half cleaner\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n+X86_SIMD_SORT_INLINE void bitonic_merge_four_zmm_32bit(zmm_t *zmm) {\n+    zmm_t zmm2r = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5), zmm[2]);\n+    zmm_t zmm3r = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5), zmm[3]);\n+    zmm_t zmm_t1 = vtype::min(zmm[0], zmm3r);\n+    zmm_t zmm_t2 = vtype::min(zmm[1], zmm2r);\n+    zmm_t zmm_t3 = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5),\n+                                      vtype::max(zmm[1], zmm2r));\n+    zmm_t zmm_t4 = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5),\n+                                      vtype::max(zmm[0], zmm3r));\n+    zmm_t zmm0 = vtype::min(zmm_t1, zmm_t2);\n+    zmm_t zmm1 = vtype::max(zmm_t1, zmm_t2);\n+    zmm_t zmm2 = vtype::min(zmm_t3, zmm_t4);\n+    zmm_t zmm3 = vtype::max(zmm_t3, zmm_t4);\n+    zmm[0] = bitonic_merge_zmm_32bit<vtype>(zmm0);\n+    zmm[1] = bitonic_merge_zmm_32bit<vtype>(zmm1);\n+    zmm[2] = bitonic_merge_zmm_32bit<vtype>(zmm2);\n+    zmm[3] = bitonic_merge_zmm_32bit<vtype>(zmm3);\n+}\n+\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n+X86_SIMD_SORT_INLINE void bitonic_merge_eight_zmm_32bit(zmm_t *zmm) {\n+    zmm_t zmm4r = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5), zmm[4]);\n+    zmm_t zmm5r = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5), zmm[5]);\n+    zmm_t zmm6r = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5), zmm[6]);\n+    zmm_t zmm7r = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5), zmm[7]);\n+    zmm_t zmm_t1 = vtype::min(zmm[0], zmm7r);\n+    zmm_t zmm_t2 = vtype::min(zmm[1], zmm6r);\n+    zmm_t zmm_t3 = vtype::min(zmm[2], zmm5r);\n+    zmm_t zmm_t4 = vtype::min(zmm[3], zmm4r);\n+    zmm_t zmm_t5 = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5),\n+                                      vtype::max(zmm[3], zmm4r));\n+    zmm_t zmm_t6 = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5),\n+                                      vtype::max(zmm[2], zmm5r));\n+    zmm_t zmm_t7 = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5),\n+                                      vtype::max(zmm[1], zmm6r));\n+    zmm_t zmm_t8 = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5),\n+                                      vtype::max(zmm[0], zmm7r));\n+    COEX<vtype>(zmm_t1, zmm_t3);\n+    COEX<vtype>(zmm_t2, zmm_t4);\n+    COEX<vtype>(zmm_t5, zmm_t7);\n+    COEX<vtype>(zmm_t6, zmm_t8);\n+    COEX<vtype>(zmm_t1, zmm_t2);\n+    COEX<vtype>(zmm_t3, zmm_t4);\n+    COEX<vtype>(zmm_t5, zmm_t6);\n+    COEX<vtype>(zmm_t7, zmm_t8);\n+    zmm[0] = bitonic_merge_zmm_32bit<vtype>(zmm_t1);\n+    zmm[1] = bitonic_merge_zmm_32bit<vtype>(zmm_t2);\n+    zmm[2] = bitonic_merge_zmm_32bit<vtype>(zmm_t3);\n+    zmm[3] = bitonic_merge_zmm_32bit<vtype>(zmm_t4);\n+    zmm[4] = bitonic_merge_zmm_32bit<vtype>(zmm_t5);\n+    zmm[5] = bitonic_merge_zmm_32bit<vtype>(zmm_t6);\n+    zmm[6] = bitonic_merge_zmm_32bit<vtype>(zmm_t7);\n+    zmm[7] = bitonic_merge_zmm_32bit<vtype>(zmm_t8);\n+}\n+\n+template <typename vtype, typename type_t>\n+X86_SIMD_SORT_INLINE void sort_16_32bit(type_t *arr, int32_t N) {\n+    typename vtype::opmask_t load_mask = (0x0001 << N) - 0x0001;\n+    typename vtype::zmm_t zmm =\n+        vtype::mask_loadu(vtype::zmm_max(), load_mask, arr);\n+    vtype::mask_storeu(arr, load_mask, sort_zmm_32bit<vtype>(zmm));\n+}\n+\n+template <typename vtype, typename type_t>\n+X86_SIMD_SORT_INLINE void sort_32_32bit(type_t *arr, int32_t N) {\n+    if (N <= 16) {\n+        sort_16_32bit<vtype>(arr, N);\n+        return;\n+    }\n+    using zmm_t = typename vtype::zmm_t;\n+    zmm_t zmm1 = vtype::loadu(arr);\n+    typename vtype::opmask_t load_mask = (0x0001 << (N - 16)) - 0x0001;\n+    zmm_t zmm2 = vtype::mask_loadu(vtype::zmm_max(), load_mask, arr + 16);\n+    zmm1 = sort_zmm_32bit<vtype>(zmm1);\n+    zmm2 = sort_zmm_32bit<vtype>(zmm2);\n+    bitonic_merge_two_zmm_32bit<vtype>(&zmm1, &zmm2);\n+    vtype::storeu(arr, zmm1);\n+    vtype::mask_storeu(arr + 16, load_mask, zmm2);\n+}\n+\n+template <typename vtype, typename type_t>\n+X86_SIMD_SORT_INLINE void sort_64_32bit(type_t *arr, int32_t N) {\n+    if (N <= 32) {\n+        sort_32_32bit<vtype>(arr, N);\n+        return;\n+    }\n+    using zmm_t = typename vtype::zmm_t;\n+    using opmask_t = typename vtype::opmask_t;\n+    zmm_t zmm[4];\n+    zmm[0] = vtype::loadu(arr);\n+    zmm[1] = vtype::loadu(arr + 16);\n+    opmask_t load_mask1 = 0xFFFF, load_mask2 = 0xFFFF;\n+    uint64_t combined_mask = (0x1ull << (N - 32)) - 0x1ull;\n+    load_mask1 &= combined_mask & 0xFFFF;\n+    load_mask2 &= (combined_mask >> 16) & 0xFFFF;\n+    zmm[2] = vtype::mask_loadu(vtype::zmm_max(), load_mask1, arr + 32);\n+    zmm[3] = vtype::mask_loadu(vtype::zmm_max(), load_mask2, arr + 48);\n+    zmm[0] = sort_zmm_32bit<vtype>(zmm[0]);\n+    zmm[1] = sort_zmm_32bit<vtype>(zmm[1]);\n+    zmm[2] = sort_zmm_32bit<vtype>(zmm[2]);\n+    zmm[3] = sort_zmm_32bit<vtype>(zmm[3]);\n+    bitonic_merge_two_zmm_32bit<vtype>(&zmm[0], &zmm[1]);\n+    bitonic_merge_two_zmm_32bit<vtype>(&zmm[2], &zmm[3]);\n+    bitonic_merge_four_zmm_32bit<vtype>(zmm);\n+    vtype::storeu(arr, zmm[0]);\n+    vtype::storeu(arr + 16, zmm[1]);\n+    vtype::mask_storeu(arr + 32, load_mask1, zmm[2]);\n+    vtype::mask_storeu(arr + 48, load_mask2, zmm[3]);\n+}\n+\n+template <typename vtype, typename type_t>\n+X86_SIMD_SORT_INLINE void sort_128_32bit(type_t *arr, int32_t N) {\n+    if (N <= 64) {\n+        sort_64_32bit<vtype>(arr, N);\n+        return;\n+    }\n+    using zmm_t = typename vtype::zmm_t;\n+    using opmask_t = typename vtype::opmask_t;\n+    zmm_t zmm[8];\n+    zmm[0] = vtype::loadu(arr);\n+    zmm[1] = vtype::loadu(arr + 16);\n+    zmm[2] = vtype::loadu(arr + 32);\n+    zmm[3] = vtype::loadu(arr + 48);\n+    zmm[0] = sort_zmm_32bit<vtype>(zmm[0]);\n+    zmm[1] = sort_zmm_32bit<vtype>(zmm[1]);\n+    zmm[2] = sort_zmm_32bit<vtype>(zmm[2]);\n+    zmm[3] = sort_zmm_32bit<vtype>(zmm[3]);\n+    opmask_t load_mask1 = 0xFFFF, load_mask2 = 0xFFFF;\n+    opmask_t load_mask3 = 0xFFFF, load_mask4 = 0xFFFF;\n+    if (N != 128) {\n+        uint64_t combined_mask = (0x1ull << (N - 64)) - 0x1ull;\n+        load_mask1 &= combined_mask & 0xFFFF;\n+        load_mask2 &= (combined_mask >> 16) & 0xFFFF;\n+        load_mask3 &= (combined_mask >> 32) & 0xFFFF;\n+        load_mask4 &= (combined_mask >> 48) & 0xFFFF;\n+    }\n+    zmm[4] = vtype::mask_loadu(vtype::zmm_max(), load_mask1, arr + 64);\n+    zmm[5] = vtype::mask_loadu(vtype::zmm_max(), load_mask2, arr + 80);\n+    zmm[6] = vtype::mask_loadu(vtype::zmm_max(), load_mask3, arr + 96);\n+    zmm[7] = vtype::mask_loadu(vtype::zmm_max(), load_mask4, arr + 112);\n+    zmm[4] = sort_zmm_32bit<vtype>(zmm[4]);\n+    zmm[5] = sort_zmm_32bit<vtype>(zmm[5]);\n+    zmm[6] = sort_zmm_32bit<vtype>(zmm[6]);\n+    zmm[7] = sort_zmm_32bit<vtype>(zmm[7]);\n+    bitonic_merge_two_zmm_32bit<vtype>(&zmm[0], &zmm[1]);\n+    bitonic_merge_two_zmm_32bit<vtype>(&zmm[2], &zmm[3]);\n+    bitonic_merge_two_zmm_32bit<vtype>(&zmm[4], &zmm[5]);\n+    bitonic_merge_two_zmm_32bit<vtype>(&zmm[6], &zmm[7]);\n+    bitonic_merge_four_zmm_32bit<vtype>(zmm);\n+    bitonic_merge_four_zmm_32bit<vtype>(zmm + 4);\n+    bitonic_merge_eight_zmm_32bit<vtype>(zmm);\n+    vtype::storeu(arr, zmm[0]);\n+    vtype::storeu(arr + 16, zmm[1]);\n+    vtype::storeu(arr + 32, zmm[2]);\n+    vtype::storeu(arr + 48, zmm[3]);\n+    vtype::mask_storeu(arr + 64, load_mask1, zmm[4]);\n+    vtype::mask_storeu(arr + 80, load_mask2, zmm[5]);\n+    vtype::mask_storeu(arr + 96, load_mask3, zmm[6]);\n+    vtype::mask_storeu(arr + 112, load_mask4, zmm[7]);\n+}\n+\n+template <typename vtype, typename type_t>\n+X86_SIMD_SORT_INLINE type_t get_pivot_32bit(type_t *arr, const int64_t left,\n+                                            const int64_t right) {\n+    \/\/ median of 16\n+    int64_t size = (right - left) \/ 16;\n+    using zmm_t = typename vtype::zmm_t;\n+    using ymm_t = typename vtype::ymm_t;\n+    __m512i rand_index1 = _mm512_set_epi64(\n+        left + size, left + 2 * size, left + 3 * size, left + 4 * size,\n+        left + 5 * size, left + 6 * size, left + 7 * size, left + 8 * size);\n+    __m512i rand_index2 = _mm512_set_epi64(\n+        left + 9 * size, left + 10 * size, left + 11 * size, left + 12 * size,\n+        left + 13 * size, left + 14 * size, left + 15 * size, left + 16 * size);\n+    ymm_t rand_vec1 =\n+        vtype::template i64gather<sizeof(type_t)>(rand_index1, arr);\n+    ymm_t rand_vec2 =\n+        vtype::template i64gather<sizeof(type_t)>(rand_index2, arr);\n+    zmm_t rand_vec = vtype::merge(rand_vec1, rand_vec2);\n+    zmm_t sort = sort_zmm_32bit<vtype>(rand_vec);\n+    \/\/ pivot will never be a nan, since there are no nan's!\n+    return ((type_t *)&sort)[8];\n+}\n+\n+template <typename vtype, typename type_t>\n+static void qsort_32bit_(type_t *arr, int64_t left, int64_t right,\n+                         int64_t max_iters) {\n+    \/*\n+     * Resort to std::sort if quicksort isnt making any progress\n+     *\/\n+    if (max_iters <= 0) {\n+        std::sort(arr + left, arr + right + 1);\n+        return;\n+    }\n+    \/*\n+     * Base case: use bitonic networks to sort arrays <= 128\n+     *\/\n+    if (right + 1 - left <= 128) {\n+        sort_128_32bit<vtype>(arr + left, (int32_t)(right + 1 - left));\n+        return;\n+    }\n+\n+    type_t pivot = get_pivot_32bit<vtype>(arr, left, right);\n+    type_t smallest = vtype::type_max();\n+    type_t biggest = vtype::type_min();\n+    int64_t pivot_index = partition_avx512_unrolled<vtype, 2>(\n+        arr, left, right + 1, pivot, &smallest, &biggest);\n+    if (pivot != smallest)\n+        qsort_32bit_<vtype>(arr, left, pivot_index - 1, max_iters - 1);\n+    if (pivot != biggest)\n+        qsort_32bit_<vtype>(arr, pivot_index, right, max_iters - 1);\n+}\n+\n+template <typename vtype, typename type_t>\n+static void qselect_32bit_(type_t *arr, int64_t pos, int64_t left,\n+                           int64_t right, int64_t max_iters) {\n+    \/*\n+     * Resort to std::sort if quicksort isnt making any progress\n+     *\/\n+    if (max_iters <= 0) {\n+        std::sort(arr + left, arr + right + 1);\n+        return;\n+    }\n+    \/*\n+     * Base case: use bitonic networks to sort arrays <= 128\n+     *\/\n+    if (right + 1 - left <= 128) {\n+        sort_128_32bit<vtype>(arr + left, (int32_t)(right + 1 - left));\n+        return;\n+    }\n+\n+    type_t pivot = get_pivot_32bit<vtype>(arr, left, right);\n+    type_t smallest = vtype::type_max();\n+    type_t biggest = vtype::type_min();\n+    int64_t pivot_index = partition_avx512_unrolled<vtype, 2>(\n+        arr, left, right + 1, pivot, &smallest, &biggest);\n+    if ((pivot != smallest) && (pos < pivot_index))\n+        qselect_32bit_<vtype>(arr, pos, left, pivot_index - 1, max_iters - 1);\n+    else if ((pivot != biggest) && (pos >= pivot_index))\n+        qselect_32bit_<vtype>(arr, pos, pivot_index, right, max_iters - 1);\n+}\n+\n+X86_SIMD_SORT_INLINE int64_t replace_nan_with_inf(float *arr, int64_t arrsize) {\n+    int64_t nan_count = 0;\n+    __mmask16 loadmask = 0xFFFF;\n+    while (arrsize > 0) {\n+        if (arrsize < 16) {\n+            loadmask = (0x0001 << arrsize) - 0x0001;\n+        }\n+        __m512 in_zmm = _mm512_maskz_loadu_ps(loadmask, arr);\n+        __mmask16 nanmask = _mm512_cmp_ps_mask(in_zmm, in_zmm, _CMP_NEQ_UQ);\n+        nan_count += _mm_popcnt_u32((int32_t)nanmask);\n+        _mm512_mask_storeu_ps(arr, nanmask, ZMM_MAX_FLOAT);\n+        arr += 16;\n+        arrsize -= 16;\n+    }\n+    return nan_count;\n+}\n+\n+X86_SIMD_SORT_INLINE void replace_inf_with_nan(float *arr, int64_t arrsize,\n+                                               int64_t nan_count) {\n+    for (int64_t ii = arrsize - 1; nan_count > 0; --ii) {\n+        arr[ii] = std::nanf(\"1\");\n+        nan_count -= 1;\n+    }\n+}\n+\n+template <>\n+void avx512_qselect<int32_t>(int32_t *arr, int64_t k, int64_t arrsize) {\n+    if (arrsize > 1) {\n+        qselect_32bit_<zmm_vector<int32_t>, int32_t>(\n+            arr, k, 0, arrsize - 1, 2 * (int64_t)log2(arrsize));\n+    }\n+}\n+\n+template <>\n+void avx512_qselect<uint32_t>(uint32_t *arr, int64_t k, int64_t arrsize) {\n+    if (arrsize > 1) {\n+        qselect_32bit_<zmm_vector<uint32_t>, uint32_t>(\n+            arr, k, 0, arrsize - 1, 2 * (int64_t)log2(arrsize));\n+    }\n+}\n+\n+template <>\n+void avx512_qselect<float>(float *arr, int64_t k, int64_t arrsize) {\n+    if (arrsize > 1) {\n+        int64_t nan_count = replace_nan_with_inf(arr, arrsize);\n+        qselect_32bit_<zmm_vector<float>, float>(arr, k, 0, arrsize - 1,\n+                                                 2 * (int64_t)log2(arrsize));\n+        replace_inf_with_nan(arr, arrsize, nan_count);\n+    }\n+}\n+\n+template <>\n+void avx512_qsort<int32_t>(int32_t *arr, int64_t arrsize) {\n+    if (arrsize > 1) {\n+        qsort_32bit_<zmm_vector<int32_t>, int32_t>(arr, 0, arrsize - 1,\n+                                                   2 * (int64_t)log2(arrsize));\n+    }\n+}\n+\n+template <>\n+void avx512_qsort<uint32_t>(uint32_t *arr, int64_t arrsize) {\n+    if (arrsize > 1) {\n+        qsort_32bit_<zmm_vector<uint32_t>, uint32_t>(\n+            arr, 0, arrsize - 1, 2 * (int64_t)log2(arrsize));\n+    }\n+}\n+\n+template <>\n+void avx512_qsort<float>(float *arr, int64_t arrsize) {\n+    if (arrsize > 1) {\n+        int64_t nan_count = replace_nan_with_inf(arr, arrsize);\n+        qsort_32bit_<zmm_vector<float>, float>(arr, 0, arrsize - 1,\n+                                               2 * (int64_t)log2(arrsize));\n+        replace_inf_with_nan(arr, arrsize, nan_count);\n+    }\n+}\n+\n+#endif  \/\/ AVX512_QSORT_32BIT\n","filename":"src\/java.base\/linux\/native\/libavx512_x86_64\/avx512-32bit-qsort.hpp","additions":604,"deletions":0,"binary":false,"changes":604,"status":"added"},{"patch":"@@ -0,0 +1,590 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Intel Corporation. All rights reserved.\n+ * Intel x86-simd-sort source code.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This implementation is based on x86-simd-sort(https:\/\/github.com\/intel\/x86-simd-sort)\n+\n+#ifndef AVX512_64BIT_COMMON\n+#define AVX512_64BIT_COMMON\n+#include \"avx512-common-qsort.h\"\n+\n+\/*\n+ * Constants used in sorting 8 elements in a ZMM registers. Based on Bitonic\n+ * sorting network (see\n+ * https:\/\/en.wikipedia.org\/wiki\/Bitonic_sorter#\/media\/File:BitonicSort.svg)\n+ *\/\n+\/\/ ZMM                  7, 6, 5, 4, 3, 2, 1, 0\n+#define NETWORK_64BIT_1 4, 5, 6, 7, 0, 1, 2, 3\n+#define NETWORK_64BIT_2 0, 1, 2, 3, 4, 5, 6, 7\n+#define NETWORK_64BIT_3 5, 4, 7, 6, 1, 0, 3, 2\n+#define NETWORK_64BIT_4 3, 2, 1, 0, 7, 6, 5, 4\n+\n+template <>\n+struct ymm_vector<float> {\n+    using type_t = float;\n+    using zmm_t = __m256;\n+    using zmmi_t = __m256i;\n+    using opmask_t = __mmask8;\n+    static const uint8_t numlanes = 8;\n+\n+    static type_t type_max() { return X86_SIMD_SORT_INFINITYF; }\n+    static type_t type_min() { return -X86_SIMD_SORT_INFINITYF; }\n+    static zmm_t zmm_max() { return _mm256_set1_ps(type_max()); }\n+\n+    static zmmi_t seti(int v1, int v2, int v3, int v4, int v5, int v6, int v7,\n+                       int v8) {\n+        return _mm256_set_epi32(v1, v2, v3, v4, v5, v6, v7, v8);\n+    }\n+    static opmask_t kxor_opmask(opmask_t x, opmask_t y) {\n+        return _kxor_mask8(x, y);\n+    }\n+    static opmask_t knot_opmask(opmask_t x) { return _knot_mask8(x); }\n+    static opmask_t le(zmm_t x, zmm_t y) {\n+        return _mm256_cmp_ps_mask(x, y, _CMP_LE_OQ);\n+    }\n+    static opmask_t ge(zmm_t x, zmm_t y) {\n+        return _mm256_cmp_ps_mask(x, y, _CMP_GE_OQ);\n+    }\n+    static opmask_t eq(zmm_t x, zmm_t y) {\n+        return _mm256_cmp_ps_mask(x, y, _CMP_EQ_OQ);\n+    }\n+    template <int type>\n+    static opmask_t fpclass(zmm_t x) {\n+        return _mm256_fpclass_ps_mask(x, type);\n+    }\n+    template <int scale>\n+    static zmm_t mask_i64gather(zmm_t src, opmask_t mask, __m512i index,\n+                                void const *base) {\n+        return _mm512_mask_i64gather_ps(src, mask, index, base, scale);\n+    }\n+    template <int scale>\n+    static zmm_t i64gather(__m512i index, void const *base) {\n+        return _mm512_i64gather_ps(index, base, scale);\n+    }\n+    static zmm_t loadu(void const *mem) {\n+        return _mm256_loadu_ps((float *)mem);\n+    }\n+    static zmm_t max(zmm_t x, zmm_t y) { return _mm256_max_ps(x, y); }\n+    static void mask_compressstoreu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm256_mask_compressstoreu_ps(mem, mask, x);\n+    }\n+    static zmm_t maskz_loadu(opmask_t mask, void const *mem) {\n+        return _mm256_maskz_loadu_ps(mask, mem);\n+    }\n+    static zmm_t mask_loadu(zmm_t x, opmask_t mask, void const *mem) {\n+        return _mm256_mask_loadu_ps(x, mask, mem);\n+    }\n+    static zmm_t mask_mov(zmm_t x, opmask_t mask, zmm_t y) {\n+        return _mm256_mask_mov_ps(x, mask, y);\n+    }\n+    static void mask_storeu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm256_mask_storeu_ps(mem, mask, x);\n+    }\n+    static zmm_t min(zmm_t x, zmm_t y) { return _mm256_min_ps(x, y); }\n+    static zmm_t permutexvar(__m256i idx, zmm_t zmm) {\n+        return _mm256_permutexvar_ps(idx, zmm);\n+    }\n+    static type_t reducemax(zmm_t v) {\n+        __m128 v128 =\n+            _mm_max_ps(_mm256_castps256_ps128(v), _mm256_extractf32x4_ps(v, 1));\n+        __m128 v64 = _mm_max_ps(\n+            v128, _mm_shuffle_ps(v128, v128, _MM_SHUFFLE(1, 0, 3, 2)));\n+        __m128 v32 =\n+            _mm_max_ps(v64, _mm_shuffle_ps(v64, v64, _MM_SHUFFLE(0, 0, 0, 1)));\n+        return _mm_cvtss_f32(v32);\n+    }\n+    static type_t reducemin(zmm_t v) {\n+        __m128 v128 =\n+            _mm_min_ps(_mm256_castps256_ps128(v), _mm256_extractf32x4_ps(v, 1));\n+        __m128 v64 = _mm_min_ps(\n+            v128, _mm_shuffle_ps(v128, v128, _MM_SHUFFLE(1, 0, 3, 2)));\n+        __m128 v32 =\n+            _mm_min_ps(v64, _mm_shuffle_ps(v64, v64, _MM_SHUFFLE(0, 0, 0, 1)));\n+        return _mm_cvtss_f32(v32);\n+    }\n+    static zmm_t set1(type_t v) { return _mm256_set1_ps(v); }\n+    template <uint8_t mask, bool = (mask == 0b01010101)>\n+    static zmm_t shuffle(zmm_t zmm) {\n+        \/* Hack!: have to make shuffles within 128-bit lanes work for both\n+         * 32-bit and 64-bit *\/\n+        return _mm256_shuffle_ps(zmm, zmm, 0b10110001);\n+        \/\/ if constexpr (mask == 0b01010101) {\n+        \/\/ }\n+        \/\/ else {\n+        \/\/     \/* Not used, so far *\/\n+        \/\/     return _mm256_shuffle_ps(zmm, zmm, mask);\n+        \/\/ }\n+    }\n+    static void storeu(void *mem, zmm_t x) {\n+        _mm256_storeu_ps((float *)mem, x);\n+    }\n+};\n+template <>\n+struct ymm_vector<uint32_t> {\n+    using type_t = uint32_t;\n+    using zmm_t = __m256i;\n+    using zmmi_t = __m256i;\n+    using opmask_t = __mmask8;\n+    static const uint8_t numlanes = 8;\n+\n+    static type_t type_max() { return X86_SIMD_SORT_MAX_UINT32; }\n+    static type_t type_min() { return 0; }\n+    static zmm_t zmm_max() { return _mm256_set1_epi32(type_max()); }\n+\n+    static zmmi_t seti(int v1, int v2, int v3, int v4, int v5, int v6, int v7,\n+                       int v8) {\n+        return _mm256_set_epi32(v1, v2, v3, v4, v5, v6, v7, v8);\n+    }\n+    static opmask_t kxor_opmask(opmask_t x, opmask_t y) {\n+        return _kxor_mask8(x, y);\n+    }\n+    static opmask_t knot_opmask(opmask_t x) { return _knot_mask8(x); }\n+    static opmask_t le(zmm_t x, zmm_t y) {\n+        return _mm256_cmp_epu32_mask(x, y, _MM_CMPINT_LE);\n+    }\n+    static opmask_t ge(zmm_t x, zmm_t y) {\n+        return _mm256_cmp_epu32_mask(x, y, _MM_CMPINT_NLT);\n+    }\n+    static opmask_t eq(zmm_t x, zmm_t y) {\n+        return _mm256_cmp_epu32_mask(x, y, _MM_CMPINT_EQ);\n+    }\n+    template <int scale>\n+    static zmm_t mask_i64gather(zmm_t src, opmask_t mask, __m512i index,\n+                                void const *base) {\n+        return _mm512_mask_i64gather_epi32(src, mask, index, base, scale);\n+    }\n+    template <int scale>\n+    static zmm_t i64gather(__m512i index, void const *base) {\n+        return _mm512_i64gather_epi32(index, base, scale);\n+    }\n+    static zmm_t loadu(void const *mem) {\n+        return _mm256_loadu_si256((__m256i *)mem);\n+    }\n+    static zmm_t max(zmm_t x, zmm_t y) { return _mm256_max_epu32(x, y); }\n+    static void mask_compressstoreu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm256_mask_compressstoreu_epi32(mem, mask, x);\n+    }\n+    static zmm_t maskz_loadu(opmask_t mask, void const *mem) {\n+        return _mm256_maskz_loadu_epi32(mask, mem);\n+    }\n+    static zmm_t mask_loadu(zmm_t x, opmask_t mask, void const *mem) {\n+        return _mm256_mask_loadu_epi32(x, mask, mem);\n+    }\n+    static zmm_t mask_mov(zmm_t x, opmask_t mask, zmm_t y) {\n+        return _mm256_mask_mov_epi32(x, mask, y);\n+    }\n+    static void mask_storeu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm256_mask_storeu_epi32(mem, mask, x);\n+    }\n+    static zmm_t min(zmm_t x, zmm_t y) { return _mm256_min_epu32(x, y); }\n+    static zmm_t permutexvar(__m256i idx, zmm_t zmm) {\n+        return _mm256_permutexvar_epi32(idx, zmm);\n+    }\n+    static type_t reducemax(zmm_t v) {\n+        __m128i v128 = _mm_max_epu32(_mm256_castsi256_si128(v),\n+                                     _mm256_extracti128_si256(v, 1));\n+        __m128i v64 = _mm_max_epu32(\n+            v128, _mm_shuffle_epi32(v128, _MM_SHUFFLE(1, 0, 3, 2)));\n+        __m128i v32 =\n+            _mm_max_epu32(v64, _mm_shuffle_epi32(v64, _MM_SHUFFLE(0, 0, 0, 1)));\n+        return (type_t)_mm_cvtsi128_si32(v32);\n+    }\n+    static type_t reducemin(zmm_t v) {\n+        __m128i v128 = _mm_min_epu32(_mm256_castsi256_si128(v),\n+                                     _mm256_extracti128_si256(v, 1));\n+        __m128i v64 = _mm_min_epu32(\n+            v128, _mm_shuffle_epi32(v128, _MM_SHUFFLE(1, 0, 3, 2)));\n+        __m128i v32 =\n+            _mm_min_epu32(v64, _mm_shuffle_epi32(v64, _MM_SHUFFLE(0, 0, 0, 1)));\n+        return (type_t)_mm_cvtsi128_si32(v32);\n+    }\n+    static zmm_t set1(type_t v) { return _mm256_set1_epi32(v); }\n+    template <uint8_t mask, bool = (mask == 0b01010101)>\n+    static zmm_t shuffle(zmm_t zmm) {\n+        \/* Hack!: have to make shuffles within 128-bit lanes work for both\n+         * 32-bit and 64-bit *\/\n+        return _mm256_shuffle_epi32(zmm, 0b10110001);\n+    }\n+    static void storeu(void *mem, zmm_t x) {\n+        _mm256_storeu_si256((__m256i *)mem, x);\n+    }\n+};\n+template <>\n+struct ymm_vector<int32_t> {\n+    using type_t = int32_t;\n+    using zmm_t = __m256i;\n+    using zmmi_t = __m256i;\n+    using opmask_t = __mmask8;\n+    static const uint8_t numlanes = 8;\n+\n+    static type_t type_max() { return X86_SIMD_SORT_MAX_INT32; }\n+    static type_t type_min() { return X86_SIMD_SORT_MIN_INT32; }\n+    static zmm_t zmm_max() {\n+        return _mm256_set1_epi32(type_max());\n+    }  \/\/ TODO: this should broadcast bits as is?\n+\n+    static zmmi_t seti(int v1, int v2, int v3, int v4, int v5, int v6, int v7,\n+                       int v8) {\n+        return _mm256_set_epi32(v1, v2, v3, v4, v5, v6, v7, v8);\n+    }\n+    static opmask_t kxor_opmask(opmask_t x, opmask_t y) {\n+        return _kxor_mask8(x, y);\n+    }\n+    static opmask_t knot_opmask(opmask_t x) { return _knot_mask8(x); }\n+    static opmask_t le(zmm_t x, zmm_t y) {\n+        return _mm256_cmp_epi32_mask(x, y, _MM_CMPINT_LE);\n+    }\n+    static opmask_t ge(zmm_t x, zmm_t y) {\n+        return _mm256_cmp_epi32_mask(x, y, _MM_CMPINT_NLT);\n+    }\n+    static opmask_t eq(zmm_t x, zmm_t y) {\n+        return _mm256_cmp_epi32_mask(x, y, _MM_CMPINT_EQ);\n+    }\n+    template <int scale>\n+    static zmm_t mask_i64gather(zmm_t src, opmask_t mask, __m512i index,\n+                                void const *base) {\n+        return _mm512_mask_i64gather_epi32(src, mask, index, base, scale);\n+    }\n+    template <int scale>\n+    static zmm_t i64gather(__m512i index, void const *base) {\n+        return _mm512_i64gather_epi32(index, base, scale);\n+    }\n+    static zmm_t loadu(void const *mem) {\n+        return _mm256_loadu_si256((__m256i *)mem);\n+    }\n+    static zmm_t max(zmm_t x, zmm_t y) { return _mm256_max_epi32(x, y); }\n+    static void mask_compressstoreu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm256_mask_compressstoreu_epi32(mem, mask, x);\n+    }\n+    static zmm_t maskz_loadu(opmask_t mask, void const *mem) {\n+        return _mm256_maskz_loadu_epi32(mask, mem);\n+    }\n+    static zmm_t mask_loadu(zmm_t x, opmask_t mask, void const *mem) {\n+        return _mm256_mask_loadu_epi32(x, mask, mem);\n+    }\n+    static zmm_t mask_mov(zmm_t x, opmask_t mask, zmm_t y) {\n+        return _mm256_mask_mov_epi32(x, mask, y);\n+    }\n+    static void mask_storeu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm256_mask_storeu_epi32(mem, mask, x);\n+    }\n+    static zmm_t min(zmm_t x, zmm_t y) { return _mm256_min_epi32(x, y); }\n+    static zmm_t permutexvar(__m256i idx, zmm_t zmm) {\n+        return _mm256_permutexvar_epi32(idx, zmm);\n+    }\n+    static type_t reducemax(zmm_t v) {\n+        __m128i v128 = _mm_max_epi32(_mm256_castsi256_si128(v),\n+                                     _mm256_extracti128_si256(v, 1));\n+        __m128i v64 = _mm_max_epi32(\n+            v128, _mm_shuffle_epi32(v128, _MM_SHUFFLE(1, 0, 3, 2)));\n+        __m128i v32 =\n+            _mm_max_epi32(v64, _mm_shuffle_epi32(v64, _MM_SHUFFLE(0, 0, 0, 1)));\n+        return (type_t)_mm_cvtsi128_si32(v32);\n+    }\n+    static type_t reducemin(zmm_t v) {\n+        __m128i v128 = _mm_min_epi32(_mm256_castsi256_si128(v),\n+                                     _mm256_extracti128_si256(v, 1));\n+        __m128i v64 = _mm_min_epi32(\n+            v128, _mm_shuffle_epi32(v128, _MM_SHUFFLE(1, 0, 3, 2)));\n+        __m128i v32 =\n+            _mm_min_epi32(v64, _mm_shuffle_epi32(v64, _MM_SHUFFLE(0, 0, 0, 1)));\n+        return (type_t)_mm_cvtsi128_si32(v32);\n+    }\n+    static zmm_t set1(type_t v) { return _mm256_set1_epi32(v); }\n+    template <uint8_t mask, bool = (mask == 0b01010101)>\n+    static zmm_t shuffle(zmm_t zmm) {\n+        \/* Hack!: have to make shuffles within 128-bit lanes work for both\n+         * 32-bit and 64-bit *\/\n+        return _mm256_shuffle_epi32(zmm, 0b10110001);\n+    }\n+    static void storeu(void *mem, zmm_t x) {\n+        _mm256_storeu_si256((__m256i *)mem, x);\n+    }\n+};\n+template <>\n+struct zmm_vector<int64_t> {\n+    using type_t = int64_t;\n+    using zmm_t = __m512i;\n+    using zmmi_t = __m512i;\n+    using ymm_t = __m512i;\n+    using opmask_t = __mmask8;\n+    static const uint8_t numlanes = 8;\n+\n+    static type_t type_max() { return X86_SIMD_SORT_MAX_INT64; }\n+    static type_t type_min() { return X86_SIMD_SORT_MIN_INT64; }\n+    static zmm_t zmm_max() {\n+        return _mm512_set1_epi64(type_max());\n+    }  \/\/ TODO: this should broadcast bits as is?\n+\n+    static zmmi_t seti(int v1, int v2, int v3, int v4, int v5, int v6, int v7,\n+                       int v8) {\n+        return _mm512_set_epi64(v1, v2, v3, v4, v5, v6, v7, v8);\n+    }\n+    static opmask_t kxor_opmask(opmask_t x, opmask_t y) {\n+        return _kxor_mask8(x, y);\n+    }\n+    static opmask_t knot_opmask(opmask_t x) { return _knot_mask8(x); }\n+    static opmask_t le(zmm_t x, zmm_t y) {\n+        return _mm512_cmp_epi64_mask(x, y, _MM_CMPINT_LE);\n+    }\n+    static opmask_t ge(zmm_t x, zmm_t y) {\n+        return _mm512_cmp_epi64_mask(x, y, _MM_CMPINT_NLT);\n+    }\n+    static opmask_t eq(zmm_t x, zmm_t y) {\n+        return _mm512_cmp_epi64_mask(x, y, _MM_CMPINT_EQ);\n+    }\n+    template <int scale>\n+    static zmm_t mask_i64gather(zmm_t src, opmask_t mask, __m512i index,\n+                                void const *base) {\n+        return _mm512_mask_i64gather_epi64(src, mask, index, base, scale);\n+    }\n+    template <int scale>\n+    static zmm_t i64gather(__m512i index, void const *base) {\n+        return _mm512_i64gather_epi64(index, base, scale);\n+    }\n+    static zmm_t loadu(void const *mem) { return _mm512_loadu_si512(mem); }\n+    static zmm_t max(zmm_t x, zmm_t y) { return _mm512_max_epi64(x, y); }\n+    static void mask_compressstoreu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm512_mask_compressstoreu_epi64(mem, mask, x);\n+    }\n+    static zmm_t maskz_loadu(opmask_t mask, void const *mem) {\n+        return _mm512_maskz_loadu_epi64(mask, mem);\n+    }\n+    static zmm_t mask_loadu(zmm_t x, opmask_t mask, void const *mem) {\n+        return _mm512_mask_loadu_epi64(x, mask, mem);\n+    }\n+    static zmm_t mask_mov(zmm_t x, opmask_t mask, zmm_t y) {\n+        return _mm512_mask_mov_epi64(x, mask, y);\n+    }\n+    static void mask_storeu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm512_mask_storeu_epi64(mem, mask, x);\n+    }\n+    static zmm_t min(zmm_t x, zmm_t y) { return _mm512_min_epi64(x, y); }\n+    static zmm_t permutexvar(__m512i idx, zmm_t zmm) {\n+        return _mm512_permutexvar_epi64(idx, zmm);\n+    }\n+    static type_t reducemax(zmm_t v) { return _mm512_reduce_max_epi64(v); }\n+    static type_t reducemin(zmm_t v) { return _mm512_reduce_min_epi64(v); }\n+    static zmm_t set1(type_t v) { return _mm512_set1_epi64(v); }\n+    template <uint8_t mask>\n+    static zmm_t shuffle(zmm_t zmm) {\n+        __m512d temp = _mm512_castsi512_pd(zmm);\n+        return _mm512_castpd_si512(\n+            _mm512_shuffle_pd(temp, temp, (_MM_PERM_ENUM)mask));\n+    }\n+    static void storeu(void *mem, zmm_t x) { _mm512_storeu_si512(mem, x); }\n+};\n+template <>\n+struct zmm_vector<uint64_t> {\n+    using type_t = uint64_t;\n+    using zmm_t = __m512i;\n+    using zmmi_t = __m512i;\n+    using ymm_t = __m512i;\n+    using opmask_t = __mmask8;\n+    static const uint8_t numlanes = 8;\n+\n+    static type_t type_max() { return X86_SIMD_SORT_MAX_UINT64; }\n+    static type_t type_min() { return 0; }\n+    static zmm_t zmm_max() { return _mm512_set1_epi64(type_max()); }\n+\n+    static zmmi_t seti(int v1, int v2, int v3, int v4, int v5, int v6, int v7,\n+                       int v8) {\n+        return _mm512_set_epi64(v1, v2, v3, v4, v5, v6, v7, v8);\n+    }\n+    template <int scale>\n+    static zmm_t mask_i64gather(zmm_t src, opmask_t mask, __m512i index,\n+                                void const *base) {\n+        return _mm512_mask_i64gather_epi64(src, mask, index, base, scale);\n+    }\n+    template <int scale>\n+    static zmm_t i64gather(__m512i index, void const *base) {\n+        return _mm512_i64gather_epi64(index, base, scale);\n+    }\n+    static opmask_t knot_opmask(opmask_t x) { return _knot_mask8(x); }\n+    static opmask_t ge(zmm_t x, zmm_t y) {\n+        return _mm512_cmp_epu64_mask(x, y, _MM_CMPINT_NLT);\n+    }\n+    static opmask_t eq(zmm_t x, zmm_t y) {\n+        return _mm512_cmp_epu64_mask(x, y, _MM_CMPINT_EQ);\n+    }\n+    static zmm_t loadu(void const *mem) { return _mm512_loadu_si512(mem); }\n+    static zmm_t max(zmm_t x, zmm_t y) { return _mm512_max_epu64(x, y); }\n+    static void mask_compressstoreu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm512_mask_compressstoreu_epi64(mem, mask, x);\n+    }\n+    static zmm_t mask_loadu(zmm_t x, opmask_t mask, void const *mem) {\n+        return _mm512_mask_loadu_epi64(x, mask, mem);\n+    }\n+    static zmm_t mask_mov(zmm_t x, opmask_t mask, zmm_t y) {\n+        return _mm512_mask_mov_epi64(x, mask, y);\n+    }\n+    static void mask_storeu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm512_mask_storeu_epi64(mem, mask, x);\n+    }\n+    static zmm_t min(zmm_t x, zmm_t y) { return _mm512_min_epu64(x, y); }\n+    static zmm_t permutexvar(__m512i idx, zmm_t zmm) {\n+        return _mm512_permutexvar_epi64(idx, zmm);\n+    }\n+    static type_t reducemax(zmm_t v) { return _mm512_reduce_max_epu64(v); }\n+    static type_t reducemin(zmm_t v) { return _mm512_reduce_min_epu64(v); }\n+    static zmm_t set1(type_t v) { return _mm512_set1_epi64(v); }\n+    template <uint8_t mask>\n+    static zmm_t shuffle(zmm_t zmm) {\n+        __m512d temp = _mm512_castsi512_pd(zmm);\n+        return _mm512_castpd_si512(\n+            _mm512_shuffle_pd(temp, temp, (_MM_PERM_ENUM)mask));\n+    }\n+    static void storeu(void *mem, zmm_t x) { _mm512_storeu_si512(mem, x); }\n+};\n+template <>\n+struct zmm_vector<double> {\n+    using type_t = double;\n+    using zmm_t = __m512d;\n+    using zmmi_t = __m512i;\n+    using ymm_t = __m512d;\n+    using opmask_t = __mmask8;\n+    static const uint8_t numlanes = 8;\n+\n+    static type_t type_max() { return X86_SIMD_SORT_INFINITY; }\n+    static type_t type_min() { return -X86_SIMD_SORT_INFINITY; }\n+    static zmm_t zmm_max() { return _mm512_set1_pd(type_max()); }\n+\n+    static zmmi_t seti(int v1, int v2, int v3, int v4, int v5, int v6, int v7,\n+                       int v8) {\n+        return _mm512_set_epi64(v1, v2, v3, v4, v5, v6, v7, v8);\n+    }\n+\n+    static zmm_t maskz_loadu(opmask_t mask, void const *mem) {\n+        return _mm512_maskz_loadu_pd(mask, mem);\n+    }\n+    static opmask_t knot_opmask(opmask_t x) { return _knot_mask8(x); }\n+    static opmask_t ge(zmm_t x, zmm_t y) {\n+        return _mm512_cmp_pd_mask(x, y, _CMP_GE_OQ);\n+    }\n+    static opmask_t eq(zmm_t x, zmm_t y) {\n+        return _mm512_cmp_pd_mask(x, y, _CMP_EQ_OQ);\n+    }\n+    template <int type>\n+    static opmask_t fpclass(zmm_t x) {\n+        return _mm512_fpclass_pd_mask(x, type);\n+    }\n+    template <int scale>\n+    static zmm_t mask_i64gather(zmm_t src, opmask_t mask, __m512i index,\n+                                void const *base) {\n+        return _mm512_mask_i64gather_pd(src, mask, index, base, scale);\n+    }\n+    template <int scale>\n+    static zmm_t i64gather(__m512i index, void const *base) {\n+        return _mm512_i64gather_pd(index, base, scale);\n+    }\n+    static zmm_t loadu(void const *mem) { return _mm512_loadu_pd(mem); }\n+    static zmm_t max(zmm_t x, zmm_t y) { return _mm512_max_pd(x, y); }\n+    static void mask_compressstoreu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm512_mask_compressstoreu_pd(mem, mask, x);\n+    }\n+    static zmm_t mask_loadu(zmm_t x, opmask_t mask, void const *mem) {\n+        return _mm512_mask_loadu_pd(x, mask, mem);\n+    }\n+    static zmm_t mask_mov(zmm_t x, opmask_t mask, zmm_t y) {\n+        return _mm512_mask_mov_pd(x, mask, y);\n+    }\n+    static void mask_storeu(void *mem, opmask_t mask, zmm_t x) {\n+        return _mm512_mask_storeu_pd(mem, mask, x);\n+    }\n+    static zmm_t min(zmm_t x, zmm_t y) { return _mm512_min_pd(x, y); }\n+    static zmm_t permutexvar(__m512i idx, zmm_t zmm) {\n+        return _mm512_permutexvar_pd(idx, zmm);\n+    }\n+    static type_t reducemax(zmm_t v) { return _mm512_reduce_max_pd(v); }\n+    static type_t reducemin(zmm_t v) { return _mm512_reduce_min_pd(v); }\n+    static zmm_t set1(type_t v) { return _mm512_set1_pd(v); }\n+    template <uint8_t mask>\n+    static zmm_t shuffle(zmm_t zmm) {\n+        return _mm512_shuffle_pd(zmm, zmm, (_MM_PERM_ENUM)mask);\n+    }\n+    static void storeu(void *mem, zmm_t x) { _mm512_storeu_pd(mem, x); }\n+};\n+X86_SIMD_SORT_INLINE int64_t replace_nan_with_inf(double *arr,\n+                                                  int64_t arrsize) {\n+    int64_t nan_count = 0;\n+    __mmask8 loadmask = 0xFF;\n+    while (arrsize > 0) {\n+        if (arrsize < 8) {\n+            loadmask = (0x01 << arrsize) - 0x01;\n+        }\n+        __m512d in_zmm = _mm512_maskz_loadu_pd(loadmask, arr);\n+        __mmask8 nanmask = _mm512_cmp_pd_mask(in_zmm, in_zmm, _CMP_NEQ_UQ);\n+        nan_count += _mm_popcnt_u32((int32_t)nanmask);\n+        _mm512_mask_storeu_pd(arr, nanmask, ZMM_MAX_DOUBLE);\n+        arr += 8;\n+        arrsize -= 8;\n+    }\n+    return nan_count;\n+}\n+\n+X86_SIMD_SORT_INLINE void replace_inf_with_nan(double *arr, int64_t arrsize,\n+                                               int64_t nan_count) {\n+    for (int64_t ii = arrsize - 1; nan_count > 0; --ii) {\n+        arr[ii] = std::nan(\"1\");\n+        nan_count -= 1;\n+    }\n+}\n+\/*\n+ * Assumes zmm is random and performs a full sorting network defined in\n+ * https:\/\/en.wikipedia.org\/wiki\/Bitonic_sorter#\/media\/File:BitonicSort.svg\n+ *\/\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n+X86_SIMD_SORT_INLINE zmm_t sort_zmm_64bit(zmm_t zmm) {\n+    const typename vtype::zmmi_t rev_index = vtype::seti(NETWORK_64BIT_2);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 1, 1, 1)>(zmm), 0xAA);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::permutexvar(vtype::seti(NETWORK_64BIT_1), zmm), 0xCC);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 1, 1, 1)>(zmm), 0xAA);\n+    zmm = cmp_merge<vtype>(zmm, vtype::permutexvar(rev_index, zmm), 0xF0);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::permutexvar(vtype::seti(NETWORK_64BIT_3), zmm), 0xCC);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 1, 1, 1)>(zmm), 0xAA);\n+    return zmm;\n+}\n+\n+template <typename vtype, typename type_t>\n+X86_SIMD_SORT_INLINE type_t get_pivot_64bit(type_t *arr, const int64_t left,\n+                                            const int64_t right) {\n+    \/\/ median of 8\n+    int64_t size = (right - left) \/ 8;\n+    using zmm_t = typename vtype::zmm_t;\n+    __m512i rand_index = _mm512_set_epi64(\n+        left + size, left + 2 * size, left + 3 * size, left + 4 * size,\n+        left + 5 * size, left + 6 * size, left + 7 * size, left + 8 * size);\n+    zmm_t rand_vec = vtype::template i64gather<sizeof(type_t)>(rand_index, arr);\n+    \/\/ pivot will never be a nan, since there are no nan's!\n+    zmm_t sort = sort_zmm_64bit<vtype>(rand_vec);\n+    return ((type_t *)&sort)[4];\n+}\n+\n+#endif\n","filename":"src\/java.base\/linux\/native\/libavx512_x86_64\/avx512-64bit-common.h","additions":590,"deletions":0,"binary":false,"changes":590,"status":"added"},{"patch":"@@ -0,0 +1,836 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Intel Corporation. All rights reserved.\n+ * Intel x86-simd-sort source code.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This implementation is based on x86-simd-sort(https:\/\/github.com\/intel\/x86-simd-sort)\n+\n+#ifndef AVX512_QSORT_64BIT\n+#define AVX512_QSORT_64BIT\n+\n+#include \"avx512-64bit-common.h\"\n+\n+\/\/ Assumes zmm is bitonic and performs a recursive half cleaner\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n+X86_SIMD_SORT_INLINE zmm_t bitonic_merge_zmm_64bit(zmm_t zmm) {\n+    \/\/ 1) half_cleaner[8]: compare 0-4, 1-5, 2-6, 3-7\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::permutexvar(_mm512_set_epi64(NETWORK_64BIT_4), zmm), 0xF0);\n+    \/\/ 2) half_cleaner[4]\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::permutexvar(_mm512_set_epi64(NETWORK_64BIT_3), zmm), 0xCC);\n+    \/\/ 3) half_cleaner[1]\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 1, 1, 1)>(zmm), 0xAA);\n+    return zmm;\n+}\n+\/\/ Assumes zmm1 and zmm2 are sorted and performs a recursive half cleaner\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n+X86_SIMD_SORT_INLINE void bitonic_merge_two_zmm_64bit(zmm_t &zmm1,\n+                                                      zmm_t &zmm2) {\n+    const __m512i rev_index = _mm512_set_epi64(NETWORK_64BIT_2);\n+    \/\/ 1) First step of a merging network: coex of zmm1 and zmm2 reversed\n+    zmm2 = vtype::permutexvar(rev_index, zmm2);\n+    zmm_t zmm3 = vtype::min(zmm1, zmm2);\n+    zmm_t zmm4 = vtype::max(zmm1, zmm2);\n+    \/\/ 2) Recursive half cleaner for each\n+    zmm1 = bitonic_merge_zmm_64bit<vtype>(zmm3);\n+    zmm2 = bitonic_merge_zmm_64bit<vtype>(zmm4);\n+}\n+\/\/ Assumes [zmm0, zmm1] and [zmm2, zmm3] are sorted and performs a recursive\n+\/\/ half cleaner\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n+X86_SIMD_SORT_INLINE void bitonic_merge_four_zmm_64bit(zmm_t *zmm) {\n+    const __m512i rev_index = _mm512_set_epi64(NETWORK_64BIT_2);\n+    \/\/ 1) First step of a merging network\n+    zmm_t zmm2r = vtype::permutexvar(rev_index, zmm[2]);\n+    zmm_t zmm3r = vtype::permutexvar(rev_index, zmm[3]);\n+    zmm_t zmm_t1 = vtype::min(zmm[0], zmm3r);\n+    zmm_t zmm_t2 = vtype::min(zmm[1], zmm2r);\n+    \/\/ 2) Recursive half clearer: 16\n+    zmm_t zmm_t3 = vtype::permutexvar(rev_index, vtype::max(zmm[1], zmm2r));\n+    zmm_t zmm_t4 = vtype::permutexvar(rev_index, vtype::max(zmm[0], zmm3r));\n+    zmm_t zmm0 = vtype::min(zmm_t1, zmm_t2);\n+    zmm_t zmm1 = vtype::max(zmm_t1, zmm_t2);\n+    zmm_t zmm2 = vtype::min(zmm_t3, zmm_t4);\n+    zmm_t zmm3 = vtype::max(zmm_t3, zmm_t4);\n+    zmm[0] = bitonic_merge_zmm_64bit<vtype>(zmm0);\n+    zmm[1] = bitonic_merge_zmm_64bit<vtype>(zmm1);\n+    zmm[2] = bitonic_merge_zmm_64bit<vtype>(zmm2);\n+    zmm[3] = bitonic_merge_zmm_64bit<vtype>(zmm3);\n+}\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n+X86_SIMD_SORT_INLINE void bitonic_merge_eight_zmm_64bit(zmm_t *zmm) {\n+    const __m512i rev_index = _mm512_set_epi64(NETWORK_64BIT_2);\n+    zmm_t zmm4r = vtype::permutexvar(rev_index, zmm[4]);\n+    zmm_t zmm5r = vtype::permutexvar(rev_index, zmm[5]);\n+    zmm_t zmm6r = vtype::permutexvar(rev_index, zmm[6]);\n+    zmm_t zmm7r = vtype::permutexvar(rev_index, zmm[7]);\n+    zmm_t zmm_t1 = vtype::min(zmm[0], zmm7r);\n+    zmm_t zmm_t2 = vtype::min(zmm[1], zmm6r);\n+    zmm_t zmm_t3 = vtype::min(zmm[2], zmm5r);\n+    zmm_t zmm_t4 = vtype::min(zmm[3], zmm4r);\n+    zmm_t zmm_t5 = vtype::permutexvar(rev_index, vtype::max(zmm[3], zmm4r));\n+    zmm_t zmm_t6 = vtype::permutexvar(rev_index, vtype::max(zmm[2], zmm5r));\n+    zmm_t zmm_t7 = vtype::permutexvar(rev_index, vtype::max(zmm[1], zmm6r));\n+    zmm_t zmm_t8 = vtype::permutexvar(rev_index, vtype::max(zmm[0], zmm7r));\n+    COEX<vtype>(zmm_t1, zmm_t3);\n+    COEX<vtype>(zmm_t2, zmm_t4);\n+    COEX<vtype>(zmm_t5, zmm_t7);\n+    COEX<vtype>(zmm_t6, zmm_t8);\n+    COEX<vtype>(zmm_t1, zmm_t2);\n+    COEX<vtype>(zmm_t3, zmm_t4);\n+    COEX<vtype>(zmm_t5, zmm_t6);\n+    COEX<vtype>(zmm_t7, zmm_t8);\n+    zmm[0] = bitonic_merge_zmm_64bit<vtype>(zmm_t1);\n+    zmm[1] = bitonic_merge_zmm_64bit<vtype>(zmm_t2);\n+    zmm[2] = bitonic_merge_zmm_64bit<vtype>(zmm_t3);\n+    zmm[3] = bitonic_merge_zmm_64bit<vtype>(zmm_t4);\n+    zmm[4] = bitonic_merge_zmm_64bit<vtype>(zmm_t5);\n+    zmm[5] = bitonic_merge_zmm_64bit<vtype>(zmm_t6);\n+    zmm[6] = bitonic_merge_zmm_64bit<vtype>(zmm_t7);\n+    zmm[7] = bitonic_merge_zmm_64bit<vtype>(zmm_t8);\n+}\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n+X86_SIMD_SORT_INLINE void bitonic_merge_sixteen_zmm_64bit(zmm_t *zmm) {\n+    const __m512i rev_index = _mm512_set_epi64(NETWORK_64BIT_2);\n+    zmm_t zmm8r = vtype::permutexvar(rev_index, zmm[8]);\n+    zmm_t zmm9r = vtype::permutexvar(rev_index, zmm[9]);\n+    zmm_t zmm10r = vtype::permutexvar(rev_index, zmm[10]);\n+    zmm_t zmm11r = vtype::permutexvar(rev_index, zmm[11]);\n+    zmm_t zmm12r = vtype::permutexvar(rev_index, zmm[12]);\n+    zmm_t zmm13r = vtype::permutexvar(rev_index, zmm[13]);\n+    zmm_t zmm14r = vtype::permutexvar(rev_index, zmm[14]);\n+    zmm_t zmm15r = vtype::permutexvar(rev_index, zmm[15]);\n+    zmm_t zmm_t1 = vtype::min(zmm[0], zmm15r);\n+    zmm_t zmm_t2 = vtype::min(zmm[1], zmm14r);\n+    zmm_t zmm_t3 = vtype::min(zmm[2], zmm13r);\n+    zmm_t zmm_t4 = vtype::min(zmm[3], zmm12r);\n+    zmm_t zmm_t5 = vtype::min(zmm[4], zmm11r);\n+    zmm_t zmm_t6 = vtype::min(zmm[5], zmm10r);\n+    zmm_t zmm_t7 = vtype::min(zmm[6], zmm9r);\n+    zmm_t zmm_t8 = vtype::min(zmm[7], zmm8r);\n+    zmm_t zmm_t9 = vtype::permutexvar(rev_index, vtype::max(zmm[7], zmm8r));\n+    zmm_t zmm_t10 = vtype::permutexvar(rev_index, vtype::max(zmm[6], zmm9r));\n+    zmm_t zmm_t11 = vtype::permutexvar(rev_index, vtype::max(zmm[5], zmm10r));\n+    zmm_t zmm_t12 = vtype::permutexvar(rev_index, vtype::max(zmm[4], zmm11r));\n+    zmm_t zmm_t13 = vtype::permutexvar(rev_index, vtype::max(zmm[3], zmm12r));\n+    zmm_t zmm_t14 = vtype::permutexvar(rev_index, vtype::max(zmm[2], zmm13r));\n+    zmm_t zmm_t15 = vtype::permutexvar(rev_index, vtype::max(zmm[1], zmm14r));\n+    zmm_t zmm_t16 = vtype::permutexvar(rev_index, vtype::max(zmm[0], zmm15r));\n+    \/\/ Recusive half clear 16 zmm regs\n+    COEX<vtype>(zmm_t1, zmm_t5);\n+    COEX<vtype>(zmm_t2, zmm_t6);\n+    COEX<vtype>(zmm_t3, zmm_t7);\n+    COEX<vtype>(zmm_t4, zmm_t8);\n+    COEX<vtype>(zmm_t9, zmm_t13);\n+    COEX<vtype>(zmm_t10, zmm_t14);\n+    COEX<vtype>(zmm_t11, zmm_t15);\n+    COEX<vtype>(zmm_t12, zmm_t16);\n+    \/\/\n+    COEX<vtype>(zmm_t1, zmm_t3);\n+    COEX<vtype>(zmm_t2, zmm_t4);\n+    COEX<vtype>(zmm_t5, zmm_t7);\n+    COEX<vtype>(zmm_t6, zmm_t8);\n+    COEX<vtype>(zmm_t9, zmm_t11);\n+    COEX<vtype>(zmm_t10, zmm_t12);\n+    COEX<vtype>(zmm_t13, zmm_t15);\n+    COEX<vtype>(zmm_t14, zmm_t16);\n+    \/\/\n+    COEX<vtype>(zmm_t1, zmm_t2);\n+    COEX<vtype>(zmm_t3, zmm_t4);\n+    COEX<vtype>(zmm_t5, zmm_t6);\n+    COEX<vtype>(zmm_t7, zmm_t8);\n+    COEX<vtype>(zmm_t9, zmm_t10);\n+    COEX<vtype>(zmm_t11, zmm_t12);\n+    COEX<vtype>(zmm_t13, zmm_t14);\n+    COEX<vtype>(zmm_t15, zmm_t16);\n+    \/\/\n+    zmm[0] = bitonic_merge_zmm_64bit<vtype>(zmm_t1);\n+    zmm[1] = bitonic_merge_zmm_64bit<vtype>(zmm_t2);\n+    zmm[2] = bitonic_merge_zmm_64bit<vtype>(zmm_t3);\n+    zmm[3] = bitonic_merge_zmm_64bit<vtype>(zmm_t4);\n+    zmm[4] = bitonic_merge_zmm_64bit<vtype>(zmm_t5);\n+    zmm[5] = bitonic_merge_zmm_64bit<vtype>(zmm_t6);\n+    zmm[6] = bitonic_merge_zmm_64bit<vtype>(zmm_t7);\n+    zmm[7] = bitonic_merge_zmm_64bit<vtype>(zmm_t8);\n+    zmm[8] = bitonic_merge_zmm_64bit<vtype>(zmm_t9);\n+    zmm[9] = bitonic_merge_zmm_64bit<vtype>(zmm_t10);\n+    zmm[10] = bitonic_merge_zmm_64bit<vtype>(zmm_t11);\n+    zmm[11] = bitonic_merge_zmm_64bit<vtype>(zmm_t12);\n+    zmm[12] = bitonic_merge_zmm_64bit<vtype>(zmm_t13);\n+    zmm[13] = bitonic_merge_zmm_64bit<vtype>(zmm_t14);\n+    zmm[14] = bitonic_merge_zmm_64bit<vtype>(zmm_t15);\n+    zmm[15] = bitonic_merge_zmm_64bit<vtype>(zmm_t16);\n+}\n+\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n+X86_SIMD_SORT_INLINE void bitonic_merge_32_zmm_64bit(zmm_t *zmm) {\n+    const __m512i rev_index = _mm512_set_epi64(NETWORK_64BIT_2);\n+    zmm_t zmm16r = vtype::permutexvar(rev_index, zmm[16]);\n+    zmm_t zmm17r = vtype::permutexvar(rev_index, zmm[17]);\n+    zmm_t zmm18r = vtype::permutexvar(rev_index, zmm[18]);\n+    zmm_t zmm19r = vtype::permutexvar(rev_index, zmm[19]);\n+    zmm_t zmm20r = vtype::permutexvar(rev_index, zmm[20]);\n+    zmm_t zmm21r = vtype::permutexvar(rev_index, zmm[21]);\n+    zmm_t zmm22r = vtype::permutexvar(rev_index, zmm[22]);\n+    zmm_t zmm23r = vtype::permutexvar(rev_index, zmm[23]);\n+    zmm_t zmm24r = vtype::permutexvar(rev_index, zmm[24]);\n+    zmm_t zmm25r = vtype::permutexvar(rev_index, zmm[25]);\n+    zmm_t zmm26r = vtype::permutexvar(rev_index, zmm[26]);\n+    zmm_t zmm27r = vtype::permutexvar(rev_index, zmm[27]);\n+    zmm_t zmm28r = vtype::permutexvar(rev_index, zmm[28]);\n+    zmm_t zmm29r = vtype::permutexvar(rev_index, zmm[29]);\n+    zmm_t zmm30r = vtype::permutexvar(rev_index, zmm[30]);\n+    zmm_t zmm31r = vtype::permutexvar(rev_index, zmm[31]);\n+    zmm_t zmm_t1 = vtype::min(zmm[0], zmm31r);\n+    zmm_t zmm_t2 = vtype::min(zmm[1], zmm30r);\n+    zmm_t zmm_t3 = vtype::min(zmm[2], zmm29r);\n+    zmm_t zmm_t4 = vtype::min(zmm[3], zmm28r);\n+    zmm_t zmm_t5 = vtype::min(zmm[4], zmm27r);\n+    zmm_t zmm_t6 = vtype::min(zmm[5], zmm26r);\n+    zmm_t zmm_t7 = vtype::min(zmm[6], zmm25r);\n+    zmm_t zmm_t8 = vtype::min(zmm[7], zmm24r);\n+    zmm_t zmm_t9 = vtype::min(zmm[8], zmm23r);\n+    zmm_t zmm_t10 = vtype::min(zmm[9], zmm22r);\n+    zmm_t zmm_t11 = vtype::min(zmm[10], zmm21r);\n+    zmm_t zmm_t12 = vtype::min(zmm[11], zmm20r);\n+    zmm_t zmm_t13 = vtype::min(zmm[12], zmm19r);\n+    zmm_t zmm_t14 = vtype::min(zmm[13], zmm18r);\n+    zmm_t zmm_t15 = vtype::min(zmm[14], zmm17r);\n+    zmm_t zmm_t16 = vtype::min(zmm[15], zmm16r);\n+    zmm_t zmm_t17 = vtype::permutexvar(rev_index, vtype::max(zmm[15], zmm16r));\n+    zmm_t zmm_t18 = vtype::permutexvar(rev_index, vtype::max(zmm[14], zmm17r));\n+    zmm_t zmm_t19 = vtype::permutexvar(rev_index, vtype::max(zmm[13], zmm18r));\n+    zmm_t zmm_t20 = vtype::permutexvar(rev_index, vtype::max(zmm[12], zmm19r));\n+    zmm_t zmm_t21 = vtype::permutexvar(rev_index, vtype::max(zmm[11], zmm20r));\n+    zmm_t zmm_t22 = vtype::permutexvar(rev_index, vtype::max(zmm[10], zmm21r));\n+    zmm_t zmm_t23 = vtype::permutexvar(rev_index, vtype::max(zmm[9], zmm22r));\n+    zmm_t zmm_t24 = vtype::permutexvar(rev_index, vtype::max(zmm[8], zmm23r));\n+    zmm_t zmm_t25 = vtype::permutexvar(rev_index, vtype::max(zmm[7], zmm24r));\n+    zmm_t zmm_t26 = vtype::permutexvar(rev_index, vtype::max(zmm[6], zmm25r));\n+    zmm_t zmm_t27 = vtype::permutexvar(rev_index, vtype::max(zmm[5], zmm26r));\n+    zmm_t zmm_t28 = vtype::permutexvar(rev_index, vtype::max(zmm[4], zmm27r));\n+    zmm_t zmm_t29 = vtype::permutexvar(rev_index, vtype::max(zmm[3], zmm28r));\n+    zmm_t zmm_t30 = vtype::permutexvar(rev_index, vtype::max(zmm[2], zmm29r));\n+    zmm_t zmm_t31 = vtype::permutexvar(rev_index, vtype::max(zmm[1], zmm30r));\n+    zmm_t zmm_t32 = vtype::permutexvar(rev_index, vtype::max(zmm[0], zmm31r));\n+    \/\/ Recusive half clear 16 zmm regs\n+    COEX<vtype>(zmm_t1, zmm_t9);\n+    COEX<vtype>(zmm_t2, zmm_t10);\n+    COEX<vtype>(zmm_t3, zmm_t11);\n+    COEX<vtype>(zmm_t4, zmm_t12);\n+    COEX<vtype>(zmm_t5, zmm_t13);\n+    COEX<vtype>(zmm_t6, zmm_t14);\n+    COEX<vtype>(zmm_t7, zmm_t15);\n+    COEX<vtype>(zmm_t8, zmm_t16);\n+    COEX<vtype>(zmm_t17, zmm_t25);\n+    COEX<vtype>(zmm_t18, zmm_t26);\n+    COEX<vtype>(zmm_t19, zmm_t27);\n+    COEX<vtype>(zmm_t20, zmm_t28);\n+    COEX<vtype>(zmm_t21, zmm_t29);\n+    COEX<vtype>(zmm_t22, zmm_t30);\n+    COEX<vtype>(zmm_t23, zmm_t31);\n+    COEX<vtype>(zmm_t24, zmm_t32);\n+    \/\/\n+    COEX<vtype>(zmm_t1, zmm_t5);\n+    COEX<vtype>(zmm_t2, zmm_t6);\n+    COEX<vtype>(zmm_t3, zmm_t7);\n+    COEX<vtype>(zmm_t4, zmm_t8);\n+    COEX<vtype>(zmm_t9, zmm_t13);\n+    COEX<vtype>(zmm_t10, zmm_t14);\n+    COEX<vtype>(zmm_t11, zmm_t15);\n+    COEX<vtype>(zmm_t12, zmm_t16);\n+    COEX<vtype>(zmm_t17, zmm_t21);\n+    COEX<vtype>(zmm_t18, zmm_t22);\n+    COEX<vtype>(zmm_t19, zmm_t23);\n+    COEX<vtype>(zmm_t20, zmm_t24);\n+    COEX<vtype>(zmm_t25, zmm_t29);\n+    COEX<vtype>(zmm_t26, zmm_t30);\n+    COEX<vtype>(zmm_t27, zmm_t31);\n+    COEX<vtype>(zmm_t28, zmm_t32);\n+    \/\/\n+    COEX<vtype>(zmm_t1, zmm_t3);\n+    COEX<vtype>(zmm_t2, zmm_t4);\n+    COEX<vtype>(zmm_t5, zmm_t7);\n+    COEX<vtype>(zmm_t6, zmm_t8);\n+    COEX<vtype>(zmm_t9, zmm_t11);\n+    COEX<vtype>(zmm_t10, zmm_t12);\n+    COEX<vtype>(zmm_t13, zmm_t15);\n+    COEX<vtype>(zmm_t14, zmm_t16);\n+    COEX<vtype>(zmm_t17, zmm_t19);\n+    COEX<vtype>(zmm_t18, zmm_t20);\n+    COEX<vtype>(zmm_t21, zmm_t23);\n+    COEX<vtype>(zmm_t22, zmm_t24);\n+    COEX<vtype>(zmm_t25, zmm_t27);\n+    COEX<vtype>(zmm_t26, zmm_t28);\n+    COEX<vtype>(zmm_t29, zmm_t31);\n+    COEX<vtype>(zmm_t30, zmm_t32);\n+    \/\/\n+    COEX<vtype>(zmm_t1, zmm_t2);\n+    COEX<vtype>(zmm_t3, zmm_t4);\n+    COEX<vtype>(zmm_t5, zmm_t6);\n+    COEX<vtype>(zmm_t7, zmm_t8);\n+    COEX<vtype>(zmm_t9, zmm_t10);\n+    COEX<vtype>(zmm_t11, zmm_t12);\n+    COEX<vtype>(zmm_t13, zmm_t14);\n+    COEX<vtype>(zmm_t15, zmm_t16);\n+    COEX<vtype>(zmm_t17, zmm_t18);\n+    COEX<vtype>(zmm_t19, zmm_t20);\n+    COEX<vtype>(zmm_t21, zmm_t22);\n+    COEX<vtype>(zmm_t23, zmm_t24);\n+    COEX<vtype>(zmm_t25, zmm_t26);\n+    COEX<vtype>(zmm_t27, zmm_t28);\n+    COEX<vtype>(zmm_t29, zmm_t30);\n+    COEX<vtype>(zmm_t31, zmm_t32);\n+    \/\/\n+    zmm[0] = bitonic_merge_zmm_64bit<vtype>(zmm_t1);\n+    zmm[1] = bitonic_merge_zmm_64bit<vtype>(zmm_t2);\n+    zmm[2] = bitonic_merge_zmm_64bit<vtype>(zmm_t3);\n+    zmm[3] = bitonic_merge_zmm_64bit<vtype>(zmm_t4);\n+    zmm[4] = bitonic_merge_zmm_64bit<vtype>(zmm_t5);\n+    zmm[5] = bitonic_merge_zmm_64bit<vtype>(zmm_t6);\n+    zmm[6] = bitonic_merge_zmm_64bit<vtype>(zmm_t7);\n+    zmm[7] = bitonic_merge_zmm_64bit<vtype>(zmm_t8);\n+    zmm[8] = bitonic_merge_zmm_64bit<vtype>(zmm_t9);\n+    zmm[9] = bitonic_merge_zmm_64bit<vtype>(zmm_t10);\n+    zmm[10] = bitonic_merge_zmm_64bit<vtype>(zmm_t11);\n+    zmm[11] = bitonic_merge_zmm_64bit<vtype>(zmm_t12);\n+    zmm[12] = bitonic_merge_zmm_64bit<vtype>(zmm_t13);\n+    zmm[13] = bitonic_merge_zmm_64bit<vtype>(zmm_t14);\n+    zmm[14] = bitonic_merge_zmm_64bit<vtype>(zmm_t15);\n+    zmm[15] = bitonic_merge_zmm_64bit<vtype>(zmm_t16);\n+    zmm[16] = bitonic_merge_zmm_64bit<vtype>(zmm_t17);\n+    zmm[17] = bitonic_merge_zmm_64bit<vtype>(zmm_t18);\n+    zmm[18] = bitonic_merge_zmm_64bit<vtype>(zmm_t19);\n+    zmm[19] = bitonic_merge_zmm_64bit<vtype>(zmm_t20);\n+    zmm[20] = bitonic_merge_zmm_64bit<vtype>(zmm_t21);\n+    zmm[21] = bitonic_merge_zmm_64bit<vtype>(zmm_t22);\n+    zmm[22] = bitonic_merge_zmm_64bit<vtype>(zmm_t23);\n+    zmm[23] = bitonic_merge_zmm_64bit<vtype>(zmm_t24);\n+    zmm[24] = bitonic_merge_zmm_64bit<vtype>(zmm_t25);\n+    zmm[25] = bitonic_merge_zmm_64bit<vtype>(zmm_t26);\n+    zmm[26] = bitonic_merge_zmm_64bit<vtype>(zmm_t27);\n+    zmm[27] = bitonic_merge_zmm_64bit<vtype>(zmm_t28);\n+    zmm[28] = bitonic_merge_zmm_64bit<vtype>(zmm_t29);\n+    zmm[29] = bitonic_merge_zmm_64bit<vtype>(zmm_t30);\n+    zmm[30] = bitonic_merge_zmm_64bit<vtype>(zmm_t31);\n+    zmm[31] = bitonic_merge_zmm_64bit<vtype>(zmm_t32);\n+}\n+\n+template <typename vtype, typename type_t>\n+X86_SIMD_SORT_INLINE void sort_8_64bit(type_t *arr, int32_t N) {\n+    typename vtype::opmask_t load_mask = (0x01 << N) - 0x01;\n+    typename vtype::zmm_t zmm =\n+        vtype::mask_loadu(vtype::zmm_max(), load_mask, arr);\n+    vtype::mask_storeu(arr, load_mask, sort_zmm_64bit<vtype>(zmm));\n+}\n+\n+template <typename vtype, typename type_t>\n+X86_SIMD_SORT_INLINE void sort_16_64bit(type_t *arr, int32_t N) {\n+    if (N <= 8) {\n+        sort_8_64bit<vtype>(arr, N);\n+        return;\n+    }\n+    using zmm_t = typename vtype::zmm_t;\n+    zmm_t zmm1 = vtype::loadu(arr);\n+    typename vtype::opmask_t load_mask = (0x01 << (N - 8)) - 0x01;\n+    zmm_t zmm2 = vtype::mask_loadu(vtype::zmm_max(), load_mask, arr + 8);\n+    zmm1 = sort_zmm_64bit<vtype>(zmm1);\n+    zmm2 = sort_zmm_64bit<vtype>(zmm2);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm1, zmm2);\n+    vtype::storeu(arr, zmm1);\n+    vtype::mask_storeu(arr + 8, load_mask, zmm2);\n+}\n+\n+template <typename vtype, typename type_t>\n+X86_SIMD_SORT_INLINE void sort_32_64bit(type_t *arr, int32_t N) {\n+    if (N <= 16) {\n+        sort_16_64bit<vtype>(arr, N);\n+        return;\n+    }\n+    using zmm_t = typename vtype::zmm_t;\n+    using opmask_t = typename vtype::opmask_t;\n+    zmm_t zmm[4];\n+    zmm[0] = vtype::loadu(arr);\n+    zmm[1] = vtype::loadu(arr + 8);\n+    opmask_t load_mask1 = 0xFF, load_mask2 = 0xFF;\n+    uint64_t combined_mask = (0x1ull << (N - 16)) - 0x1ull;\n+    load_mask1 = (combined_mask)&0xFF;\n+    load_mask2 = (combined_mask >> 8) & 0xFF;\n+    zmm[2] = vtype::mask_loadu(vtype::zmm_max(), load_mask1, arr + 16);\n+    zmm[3] = vtype::mask_loadu(vtype::zmm_max(), load_mask2, arr + 24);\n+    zmm[0] = sort_zmm_64bit<vtype>(zmm[0]);\n+    zmm[1] = sort_zmm_64bit<vtype>(zmm[1]);\n+    zmm[2] = sort_zmm_64bit<vtype>(zmm[2]);\n+    zmm[3] = sort_zmm_64bit<vtype>(zmm[3]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[0], zmm[1]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[2], zmm[3]);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm);\n+    vtype::storeu(arr, zmm[0]);\n+    vtype::storeu(arr + 8, zmm[1]);\n+    vtype::mask_storeu(arr + 16, load_mask1, zmm[2]);\n+    vtype::mask_storeu(arr + 24, load_mask2, zmm[3]);\n+}\n+\n+template <typename vtype, typename type_t>\n+X86_SIMD_SORT_INLINE void sort_64_64bit(type_t *arr, int32_t N) {\n+    if (N <= 32) {\n+        sort_32_64bit<vtype>(arr, N);\n+        return;\n+    }\n+    using zmm_t = typename vtype::zmm_t;\n+    using opmask_t = typename vtype::opmask_t;\n+    zmm_t zmm[8];\n+    zmm[0] = vtype::loadu(arr);\n+    zmm[1] = vtype::loadu(arr + 8);\n+    zmm[2] = vtype::loadu(arr + 16);\n+    zmm[3] = vtype::loadu(arr + 24);\n+    zmm[0] = sort_zmm_64bit<vtype>(zmm[0]);\n+    zmm[1] = sort_zmm_64bit<vtype>(zmm[1]);\n+    zmm[2] = sort_zmm_64bit<vtype>(zmm[2]);\n+    zmm[3] = sort_zmm_64bit<vtype>(zmm[3]);\n+    opmask_t load_mask1 = 0xFF, load_mask2 = 0xFF;\n+    opmask_t load_mask3 = 0xFF, load_mask4 = 0xFF;\n+    \/\/ N-32 >= 1\n+    uint64_t combined_mask = (0x1ull << (N - 32)) - 0x1ull;\n+    load_mask1 = (combined_mask)&0xFF;\n+    load_mask2 = (combined_mask >> 8) & 0xFF;\n+    load_mask3 = (combined_mask >> 16) & 0xFF;\n+    load_mask4 = (combined_mask >> 24) & 0xFF;\n+    zmm[4] = vtype::mask_loadu(vtype::zmm_max(), load_mask1, arr + 32);\n+    zmm[5] = vtype::mask_loadu(vtype::zmm_max(), load_mask2, arr + 40);\n+    zmm[6] = vtype::mask_loadu(vtype::zmm_max(), load_mask3, arr + 48);\n+    zmm[7] = vtype::mask_loadu(vtype::zmm_max(), load_mask4, arr + 56);\n+    zmm[4] = sort_zmm_64bit<vtype>(zmm[4]);\n+    zmm[5] = sort_zmm_64bit<vtype>(zmm[5]);\n+    zmm[6] = sort_zmm_64bit<vtype>(zmm[6]);\n+    zmm[7] = sort_zmm_64bit<vtype>(zmm[7]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[0], zmm[1]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[2], zmm[3]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[4], zmm[5]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[6], zmm[7]);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm + 4);\n+    bitonic_merge_eight_zmm_64bit<vtype>(zmm);\n+    vtype::storeu(arr, zmm[0]);\n+    vtype::storeu(arr + 8, zmm[1]);\n+    vtype::storeu(arr + 16, zmm[2]);\n+    vtype::storeu(arr + 24, zmm[3]);\n+    vtype::mask_storeu(arr + 32, load_mask1, zmm[4]);\n+    vtype::mask_storeu(arr + 40, load_mask2, zmm[5]);\n+    vtype::mask_storeu(arr + 48, load_mask3, zmm[6]);\n+    vtype::mask_storeu(arr + 56, load_mask4, zmm[7]);\n+}\n+\n+template <typename vtype, typename type_t>\n+X86_SIMD_SORT_INLINE void sort_128_64bit(type_t *arr, int32_t N) {\n+    if (N <= 64) {\n+        sort_64_64bit<vtype>(arr, N);\n+        return;\n+    }\n+    using zmm_t = typename vtype::zmm_t;\n+    using opmask_t = typename vtype::opmask_t;\n+    zmm_t zmm[16];\n+    zmm[0] = vtype::loadu(arr);\n+    zmm[1] = vtype::loadu(arr + 8);\n+    zmm[2] = vtype::loadu(arr + 16);\n+    zmm[3] = vtype::loadu(arr + 24);\n+    zmm[4] = vtype::loadu(arr + 32);\n+    zmm[5] = vtype::loadu(arr + 40);\n+    zmm[6] = vtype::loadu(arr + 48);\n+    zmm[7] = vtype::loadu(arr + 56);\n+    zmm[0] = sort_zmm_64bit<vtype>(zmm[0]);\n+    zmm[1] = sort_zmm_64bit<vtype>(zmm[1]);\n+    zmm[2] = sort_zmm_64bit<vtype>(zmm[2]);\n+    zmm[3] = sort_zmm_64bit<vtype>(zmm[3]);\n+    zmm[4] = sort_zmm_64bit<vtype>(zmm[4]);\n+    zmm[5] = sort_zmm_64bit<vtype>(zmm[5]);\n+    zmm[6] = sort_zmm_64bit<vtype>(zmm[6]);\n+    zmm[7] = sort_zmm_64bit<vtype>(zmm[7]);\n+    opmask_t load_mask1 = 0xFF, load_mask2 = 0xFF;\n+    opmask_t load_mask3 = 0xFF, load_mask4 = 0xFF;\n+    opmask_t load_mask5 = 0xFF, load_mask6 = 0xFF;\n+    opmask_t load_mask7 = 0xFF, load_mask8 = 0xFF;\n+    if (N != 128) {\n+        uint64_t combined_mask = (0x1ull << (N - 64)) - 0x1ull;\n+        load_mask1 = (combined_mask)&0xFF;\n+        load_mask2 = (combined_mask >> 8) & 0xFF;\n+        load_mask3 = (combined_mask >> 16) & 0xFF;\n+        load_mask4 = (combined_mask >> 24) & 0xFF;\n+        load_mask5 = (combined_mask >> 32) & 0xFF;\n+        load_mask6 = (combined_mask >> 40) & 0xFF;\n+        load_mask7 = (combined_mask >> 48) & 0xFF;\n+        load_mask8 = (combined_mask >> 56) & 0xFF;\n+    }\n+    zmm[8] = vtype::mask_loadu(vtype::zmm_max(), load_mask1, arr + 64);\n+    zmm[9] = vtype::mask_loadu(vtype::zmm_max(), load_mask2, arr + 72);\n+    zmm[10] = vtype::mask_loadu(vtype::zmm_max(), load_mask3, arr + 80);\n+    zmm[11] = vtype::mask_loadu(vtype::zmm_max(), load_mask4, arr + 88);\n+    zmm[12] = vtype::mask_loadu(vtype::zmm_max(), load_mask5, arr + 96);\n+    zmm[13] = vtype::mask_loadu(vtype::zmm_max(), load_mask6, arr + 104);\n+    zmm[14] = vtype::mask_loadu(vtype::zmm_max(), load_mask7, arr + 112);\n+    zmm[15] = vtype::mask_loadu(vtype::zmm_max(), load_mask8, arr + 120);\n+    zmm[8] = sort_zmm_64bit<vtype>(zmm[8]);\n+    zmm[9] = sort_zmm_64bit<vtype>(zmm[9]);\n+    zmm[10] = sort_zmm_64bit<vtype>(zmm[10]);\n+    zmm[11] = sort_zmm_64bit<vtype>(zmm[11]);\n+    zmm[12] = sort_zmm_64bit<vtype>(zmm[12]);\n+    zmm[13] = sort_zmm_64bit<vtype>(zmm[13]);\n+    zmm[14] = sort_zmm_64bit<vtype>(zmm[14]);\n+    zmm[15] = sort_zmm_64bit<vtype>(zmm[15]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[0], zmm[1]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[2], zmm[3]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[4], zmm[5]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[6], zmm[7]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[8], zmm[9]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[10], zmm[11]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[12], zmm[13]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[14], zmm[15]);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm + 4);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm + 8);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm + 12);\n+    bitonic_merge_eight_zmm_64bit<vtype>(zmm);\n+    bitonic_merge_eight_zmm_64bit<vtype>(zmm + 8);\n+    bitonic_merge_sixteen_zmm_64bit<vtype>(zmm);\n+    vtype::storeu(arr, zmm[0]);\n+    vtype::storeu(arr + 8, zmm[1]);\n+    vtype::storeu(arr + 16, zmm[2]);\n+    vtype::storeu(arr + 24, zmm[3]);\n+    vtype::storeu(arr + 32, zmm[4]);\n+    vtype::storeu(arr + 40, zmm[5]);\n+    vtype::storeu(arr + 48, zmm[6]);\n+    vtype::storeu(arr + 56, zmm[7]);\n+    vtype::mask_storeu(arr + 64, load_mask1, zmm[8]);\n+    vtype::mask_storeu(arr + 72, load_mask2, zmm[9]);\n+    vtype::mask_storeu(arr + 80, load_mask3, zmm[10]);\n+    vtype::mask_storeu(arr + 88, load_mask4, zmm[11]);\n+    vtype::mask_storeu(arr + 96, load_mask5, zmm[12]);\n+    vtype::mask_storeu(arr + 104, load_mask6, zmm[13]);\n+    vtype::mask_storeu(arr + 112, load_mask7, zmm[14]);\n+    vtype::mask_storeu(arr + 120, load_mask8, zmm[15]);\n+}\n+\n+template <typename vtype, typename type_t>\n+X86_SIMD_SORT_INLINE void sort_256_64bit(type_t *arr, int32_t N) {\n+    if (N <= 128) {\n+        sort_128_64bit<vtype>(arr, N);\n+        return;\n+    }\n+    using zmm_t = typename vtype::zmm_t;\n+    using opmask_t = typename vtype::opmask_t;\n+    zmm_t zmm[32];\n+    zmm[0] = vtype::loadu(arr);\n+    zmm[1] = vtype::loadu(arr + 8);\n+    zmm[2] = vtype::loadu(arr + 16);\n+    zmm[3] = vtype::loadu(arr + 24);\n+    zmm[4] = vtype::loadu(arr + 32);\n+    zmm[5] = vtype::loadu(arr + 40);\n+    zmm[6] = vtype::loadu(arr + 48);\n+    zmm[7] = vtype::loadu(arr + 56);\n+    zmm[8] = vtype::loadu(arr + 64);\n+    zmm[9] = vtype::loadu(arr + 72);\n+    zmm[10] = vtype::loadu(arr + 80);\n+    zmm[11] = vtype::loadu(arr + 88);\n+    zmm[12] = vtype::loadu(arr + 96);\n+    zmm[13] = vtype::loadu(arr + 104);\n+    zmm[14] = vtype::loadu(arr + 112);\n+    zmm[15] = vtype::loadu(arr + 120);\n+    zmm[0] = sort_zmm_64bit<vtype>(zmm[0]);\n+    zmm[1] = sort_zmm_64bit<vtype>(zmm[1]);\n+    zmm[2] = sort_zmm_64bit<vtype>(zmm[2]);\n+    zmm[3] = sort_zmm_64bit<vtype>(zmm[3]);\n+    zmm[4] = sort_zmm_64bit<vtype>(zmm[4]);\n+    zmm[5] = sort_zmm_64bit<vtype>(zmm[5]);\n+    zmm[6] = sort_zmm_64bit<vtype>(zmm[6]);\n+    zmm[7] = sort_zmm_64bit<vtype>(zmm[7]);\n+    zmm[8] = sort_zmm_64bit<vtype>(zmm[8]);\n+    zmm[9] = sort_zmm_64bit<vtype>(zmm[9]);\n+    zmm[10] = sort_zmm_64bit<vtype>(zmm[10]);\n+    zmm[11] = sort_zmm_64bit<vtype>(zmm[11]);\n+    zmm[12] = sort_zmm_64bit<vtype>(zmm[12]);\n+    zmm[13] = sort_zmm_64bit<vtype>(zmm[13]);\n+    zmm[14] = sort_zmm_64bit<vtype>(zmm[14]);\n+    zmm[15] = sort_zmm_64bit<vtype>(zmm[15]);\n+    opmask_t load_mask1 = 0xFF, load_mask2 = 0xFF;\n+    opmask_t load_mask3 = 0xFF, load_mask4 = 0xFF;\n+    opmask_t load_mask5 = 0xFF, load_mask6 = 0xFF;\n+    opmask_t load_mask7 = 0xFF, load_mask8 = 0xFF;\n+    opmask_t load_mask9 = 0xFF, load_mask10 = 0xFF;\n+    opmask_t load_mask11 = 0xFF, load_mask12 = 0xFF;\n+    opmask_t load_mask13 = 0xFF, load_mask14 = 0xFF;\n+    opmask_t load_mask15 = 0xFF, load_mask16 = 0xFF;\n+    if (N != 256) {\n+        uint64_t combined_mask;\n+        if (N < 192) {\n+            combined_mask = (0x1ull << (N - 128)) - 0x1ull;\n+            load_mask1 = (combined_mask)&0xFF;\n+            load_mask2 = (combined_mask >> 8) & 0xFF;\n+            load_mask3 = (combined_mask >> 16) & 0xFF;\n+            load_mask4 = (combined_mask >> 24) & 0xFF;\n+            load_mask5 = (combined_mask >> 32) & 0xFF;\n+            load_mask6 = (combined_mask >> 40) & 0xFF;\n+            load_mask7 = (combined_mask >> 48) & 0xFF;\n+            load_mask8 = (combined_mask >> 56) & 0xFF;\n+            load_mask9 = 0x00;\n+            load_mask10 = 0x0;\n+            load_mask11 = 0x00;\n+            load_mask12 = 0x00;\n+            load_mask13 = 0x00;\n+            load_mask14 = 0x00;\n+            load_mask15 = 0x00;\n+            load_mask16 = 0x00;\n+        } else {\n+            combined_mask = (0x1ull << (N - 192)) - 0x1ull;\n+            load_mask9 = (combined_mask)&0xFF;\n+            load_mask10 = (combined_mask >> 8) & 0xFF;\n+            load_mask11 = (combined_mask >> 16) & 0xFF;\n+            load_mask12 = (combined_mask >> 24) & 0xFF;\n+            load_mask13 = (combined_mask >> 32) & 0xFF;\n+            load_mask14 = (combined_mask >> 40) & 0xFF;\n+            load_mask15 = (combined_mask >> 48) & 0xFF;\n+            load_mask16 = (combined_mask >> 56) & 0xFF;\n+        }\n+    }\n+    zmm[16] = vtype::mask_loadu(vtype::zmm_max(), load_mask1, arr + 128);\n+    zmm[17] = vtype::mask_loadu(vtype::zmm_max(), load_mask2, arr + 136);\n+    zmm[18] = vtype::mask_loadu(vtype::zmm_max(), load_mask3, arr + 144);\n+    zmm[19] = vtype::mask_loadu(vtype::zmm_max(), load_mask4, arr + 152);\n+    zmm[20] = vtype::mask_loadu(vtype::zmm_max(), load_mask5, arr + 160);\n+    zmm[21] = vtype::mask_loadu(vtype::zmm_max(), load_mask6, arr + 168);\n+    zmm[22] = vtype::mask_loadu(vtype::zmm_max(), load_mask7, arr + 176);\n+    zmm[23] = vtype::mask_loadu(vtype::zmm_max(), load_mask8, arr + 184);\n+    if (N < 192) {\n+        zmm[24] = vtype::zmm_max();\n+        zmm[25] = vtype::zmm_max();\n+        zmm[26] = vtype::zmm_max();\n+        zmm[27] = vtype::zmm_max();\n+        zmm[28] = vtype::zmm_max();\n+        zmm[29] = vtype::zmm_max();\n+        zmm[30] = vtype::zmm_max();\n+        zmm[31] = vtype::zmm_max();\n+    } else {\n+        zmm[24] = vtype::mask_loadu(vtype::zmm_max(), load_mask9, arr + 192);\n+        zmm[25] = vtype::mask_loadu(vtype::zmm_max(), load_mask10, arr + 200);\n+        zmm[26] = vtype::mask_loadu(vtype::zmm_max(), load_mask11, arr + 208);\n+        zmm[27] = vtype::mask_loadu(vtype::zmm_max(), load_mask12, arr + 216);\n+        zmm[28] = vtype::mask_loadu(vtype::zmm_max(), load_mask13, arr + 224);\n+        zmm[29] = vtype::mask_loadu(vtype::zmm_max(), load_mask14, arr + 232);\n+        zmm[30] = vtype::mask_loadu(vtype::zmm_max(), load_mask15, arr + 240);\n+        zmm[31] = vtype::mask_loadu(vtype::zmm_max(), load_mask16, arr + 248);\n+    }\n+    zmm[16] = sort_zmm_64bit<vtype>(zmm[16]);\n+    zmm[17] = sort_zmm_64bit<vtype>(zmm[17]);\n+    zmm[18] = sort_zmm_64bit<vtype>(zmm[18]);\n+    zmm[19] = sort_zmm_64bit<vtype>(zmm[19]);\n+    zmm[20] = sort_zmm_64bit<vtype>(zmm[20]);\n+    zmm[21] = sort_zmm_64bit<vtype>(zmm[21]);\n+    zmm[22] = sort_zmm_64bit<vtype>(zmm[22]);\n+    zmm[23] = sort_zmm_64bit<vtype>(zmm[23]);\n+    zmm[24] = sort_zmm_64bit<vtype>(zmm[24]);\n+    zmm[25] = sort_zmm_64bit<vtype>(zmm[25]);\n+    zmm[26] = sort_zmm_64bit<vtype>(zmm[26]);\n+    zmm[27] = sort_zmm_64bit<vtype>(zmm[27]);\n+    zmm[28] = sort_zmm_64bit<vtype>(zmm[28]);\n+    zmm[29] = sort_zmm_64bit<vtype>(zmm[29]);\n+    zmm[30] = sort_zmm_64bit<vtype>(zmm[30]);\n+    zmm[31] = sort_zmm_64bit<vtype>(zmm[31]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[0], zmm[1]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[2], zmm[3]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[4], zmm[5]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[6], zmm[7]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[8], zmm[9]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[10], zmm[11]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[12], zmm[13]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[14], zmm[15]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[16], zmm[17]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[18], zmm[19]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[20], zmm[21]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[22], zmm[23]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[24], zmm[25]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[26], zmm[27]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[28], zmm[29]);\n+    bitonic_merge_two_zmm_64bit<vtype>(zmm[30], zmm[31]);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm + 4);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm + 8);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm + 12);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm + 16);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm + 20);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm + 24);\n+    bitonic_merge_four_zmm_64bit<vtype>(zmm + 28);\n+    bitonic_merge_eight_zmm_64bit<vtype>(zmm);\n+    bitonic_merge_eight_zmm_64bit<vtype>(zmm + 8);\n+    bitonic_merge_eight_zmm_64bit<vtype>(zmm + 16);\n+    bitonic_merge_eight_zmm_64bit<vtype>(zmm + 24);\n+    bitonic_merge_sixteen_zmm_64bit<vtype>(zmm);\n+    bitonic_merge_sixteen_zmm_64bit<vtype>(zmm + 16);\n+    bitonic_merge_32_zmm_64bit<vtype>(zmm);\n+    vtype::storeu(arr, zmm[0]);\n+    vtype::storeu(arr + 8, zmm[1]);\n+    vtype::storeu(arr + 16, zmm[2]);\n+    vtype::storeu(arr + 24, zmm[3]);\n+    vtype::storeu(arr + 32, zmm[4]);\n+    vtype::storeu(arr + 40, zmm[5]);\n+    vtype::storeu(arr + 48, zmm[6]);\n+    vtype::storeu(arr + 56, zmm[7]);\n+    vtype::storeu(arr + 64, zmm[8]);\n+    vtype::storeu(arr + 72, zmm[9]);\n+    vtype::storeu(arr + 80, zmm[10]);\n+    vtype::storeu(arr + 88, zmm[11]);\n+    vtype::storeu(arr + 96, zmm[12]);\n+    vtype::storeu(arr + 104, zmm[13]);\n+    vtype::storeu(arr + 112, zmm[14]);\n+    vtype::storeu(arr + 120, zmm[15]);\n+    vtype::mask_storeu(arr + 128, load_mask1, zmm[16]);\n+    vtype::mask_storeu(arr + 136, load_mask2, zmm[17]);\n+    vtype::mask_storeu(arr + 144, load_mask3, zmm[18]);\n+    vtype::mask_storeu(arr + 152, load_mask4, zmm[19]);\n+    vtype::mask_storeu(arr + 160, load_mask5, zmm[20]);\n+    vtype::mask_storeu(arr + 168, load_mask6, zmm[21]);\n+    vtype::mask_storeu(arr + 176, load_mask7, zmm[22]);\n+    vtype::mask_storeu(arr + 184, load_mask8, zmm[23]);\n+    if (N > 192) {\n+        vtype::mask_storeu(arr + 192, load_mask9, zmm[24]);\n+        vtype::mask_storeu(arr + 200, load_mask10, zmm[25]);\n+        vtype::mask_storeu(arr + 208, load_mask11, zmm[26]);\n+        vtype::mask_storeu(arr + 216, load_mask12, zmm[27]);\n+        vtype::mask_storeu(arr + 224, load_mask13, zmm[28]);\n+        vtype::mask_storeu(arr + 232, load_mask14, zmm[29]);\n+        vtype::mask_storeu(arr + 240, load_mask15, zmm[30]);\n+        vtype::mask_storeu(arr + 248, load_mask16, zmm[31]);\n+    }\n+}\n+\n+template <typename vtype, typename type_t>\n+static void qsort_64bit_(type_t *arr, int64_t left, int64_t right,\n+                         int64_t max_iters) {\n+    \/*\n+     * Resort to std::sort if quicksort isnt making any progress\n+     *\/\n+    if (max_iters <= 0) {\n+        std::sort(arr + left, arr + right + 1);\n+        return;\n+    }\n+    \/*\n+     * Base case: use bitonic networks to sort arrays <= 128\n+     *\/\n+    if (right + 1 - left <= 256) {\n+        sort_256_64bit<vtype>(arr + left, (int32_t)(right + 1 - left));\n+        return;\n+    }\n+\n+    type_t pivot = get_pivot_64bit<vtype>(arr, left, right);\n+    type_t smallest = vtype::type_max();\n+    type_t biggest = vtype::type_min();\n+    int64_t pivot_index = partition_avx512_unrolled<vtype, 8>(\n+        arr, left, right + 1, pivot, &smallest, &biggest);\n+    if (pivot != smallest)\n+        qsort_64bit_<vtype>(arr, left, pivot_index - 1, max_iters - 1);\n+    if (pivot != biggest)\n+        qsort_64bit_<vtype>(arr, pivot_index, right, max_iters - 1);\n+}\n+\n+template <typename vtype, typename type_t>\n+static void qselect_64bit_(type_t *arr, int64_t pos, int64_t left,\n+                           int64_t right, int64_t max_iters) {\n+    \/*\n+     * Resort to std::sort if quicksort isnt making any progress\n+     *\/\n+    if (max_iters <= 0) {\n+        std::sort(arr + left, arr + right + 1);\n+        return;\n+    }\n+    \/*\n+     * Base case: use bitonic networks to sort arrays <= 128\n+     *\/\n+    if (right + 1 - left <= 128) {\n+        sort_128_64bit<vtype>(arr + left, (int32_t)(right + 1 - left));\n+        return;\n+    }\n+\n+    type_t pivot = get_pivot_64bit<vtype>(arr, left, right);\n+    type_t smallest = vtype::type_max();\n+    type_t biggest = vtype::type_min();\n+    int64_t pivot_index = partition_avx512_unrolled<vtype, 8>(\n+        arr, left, right + 1, pivot, &smallest, &biggest);\n+    if ((pivot != smallest) && (pos < pivot_index))\n+        qselect_64bit_<vtype>(arr, pos, left, pivot_index - 1, max_iters - 1);\n+    else if ((pivot != biggest) && (pos >= pivot_index))\n+        qselect_64bit_<vtype>(arr, pos, pivot_index, right, max_iters - 1);\n+}\n+\n+template <>\n+void avx512_qselect<int64_t>(int64_t *arr, int64_t k, int64_t arrsize) {\n+    if (arrsize > 1) {\n+        qselect_64bit_<zmm_vector<int64_t>, int64_t>(\n+            arr, k, 0, arrsize - 1, 2 * (int64_t)log2(arrsize));\n+    }\n+}\n+\n+template <>\n+void avx512_qselect<uint64_t>(uint64_t *arr, int64_t k, int64_t arrsize) {\n+    if (arrsize > 1) {\n+        qselect_64bit_<zmm_vector<uint64_t>, uint64_t>(\n+            arr, k, 0, arrsize - 1, 2 * (int64_t)log2(arrsize));\n+    }\n+}\n+\n+template <>\n+void avx512_qselect<double>(double *arr, int64_t k, int64_t arrsize) {\n+    if (arrsize > 1) {\n+        int64_t nan_count = replace_nan_with_inf(arr, arrsize);\n+        qselect_64bit_<zmm_vector<double>, double>(arr, k, 0, arrsize - 1,\n+                                                   2 * (int64_t)log2(arrsize));\n+        replace_inf_with_nan(arr, arrsize, nan_count);\n+    }\n+}\n+\n+template <>\n+void avx512_qsort<int64_t>(int64_t *arr, int64_t arrsize) {\n+    if (arrsize > 1) {\n+        qsort_64bit_<zmm_vector<int64_t>, int64_t>(arr, 0, arrsize - 1,\n+                                                   2 * (int64_t)log2(arrsize));\n+    }\n+}\n+\n+template <>\n+void avx512_qsort<uint64_t>(uint64_t *arr, int64_t arrsize) {\n+    if (arrsize > 1) {\n+        qsort_64bit_<zmm_vector<uint64_t>, uint64_t>(\n+            arr, 0, arrsize - 1, 2 * (int64_t)log2(arrsize));\n+    }\n+}\n+\n+template <>\n+void avx512_qsort<double>(double *arr, int64_t arrsize) {\n+    if (arrsize > 1) {\n+        int64_t nan_count = replace_nan_with_inf(arr, arrsize);\n+        qsort_64bit_<zmm_vector<double>, double>(arr, 0, arrsize - 1,\n+                                                 2 * (int64_t)log2(arrsize));\n+        replace_inf_with_nan(arr, arrsize, nan_count);\n+    }\n+}\n+#endif  \/\/ AVX512_QSORT_64BIT\n","filename":"src\/java.base\/linux\/native\/libavx512_x86_64\/avx512-64bit-qsort.hpp","additions":836,"deletions":0,"binary":false,"changes":836,"status":"added"},{"patch":"@@ -0,0 +1,524 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2021 Serge Sans Paille. All rights reserved.\n+ * Intel x86-simd-sort source code.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This implementation is based on x86-simd-sort(https:\/\/github.com\/intel\/x86-simd-sort)\n+\n+#ifndef AVX512_QSORT_COMMON\n+#define AVX512_QSORT_COMMON\n+\n+\/*\n+ * Quicksort using AVX-512. The ideas and code are based on these two research\n+ * papers [1] and [2]. On a high level, the idea is to vectorize quicksort\n+ * partitioning using AVX-512 compressstore instructions. If the array size is\n+ * < 128, then use Bitonic sorting network implemented on 512-bit registers.\n+ * The precise network definitions depend on the dtype and are defined in\n+ * separate files: avx512-16bit-qsort.hpp, avx512-32bit-qsort.hpp and\n+ * avx512-64bit-qsort.hpp. Article [4] is a good resource for bitonic sorting\n+ * network. The core implementations of the vectorized qsort functions\n+ * avx512_qsort<T>(T*, int64_t) are modified versions of avx2 quicksort\n+ * presented in the paper [2] and source code associated with that paper [3].\n+ *\n+ * [1] Fast and Robust Vectorized In-Place Sorting of Primitive Types\n+ *     https:\/\/drops.dagstuhl.de\/opus\/volltexte\/2021\/13775\/\n+ *\n+ * [2] A Novel Hybrid Quicksort Algorithm Vectorized using AVX-512 on Intel\n+ * Skylake https:\/\/arxiv.org\/pdf\/1704.08579.pdf\n+ *\n+ * [3] https:\/\/github.com\/simd-sorting\/fast-and-robust: SPDX-License-Identifier:\n+ * MIT\n+ *\n+ * [4]\n+ * http:\/\/mitp-content-server.mit.edu:18180\/books\/content\/sectbyfn?collid=books_pres_0&fn=Chapter%2027.pdf&id=8030\n+ *\n+ *\/\n+\n+#include <immintrin.h>\n+\n+#include <algorithm>\n+#include <cmath>\n+#include <cstdint>\n+#include <cstring>\n+#include <limits>\n+\n+#define X86_SIMD_SORT_INFINITY std::numeric_limits<double>::infinity()\n+#define X86_SIMD_SORT_INFINITYF std::numeric_limits<float>::infinity()\n+#define X86_SIMD_SORT_INFINITYH 0x7c00\n+#define X86_SIMD_SORT_NEGINFINITYH 0xfc00\n+#define X86_SIMD_SORT_MAX_UINT16 std::numeric_limits<uint16_t>::max()\n+#define X86_SIMD_SORT_MAX_INT16 std::numeric_limits<int16_t>::max()\n+#define X86_SIMD_SORT_MIN_INT16 std::numeric_limits<int16_t>::min()\n+#define X86_SIMD_SORT_MAX_UINT32 std::numeric_limits<uint32_t>::max()\n+#define X86_SIMD_SORT_MAX_INT32 std::numeric_limits<int32_t>::max()\n+#define X86_SIMD_SORT_MIN_INT32 std::numeric_limits<int32_t>::min()\n+#define X86_SIMD_SORT_MAX_UINT64 std::numeric_limits<uint64_t>::max()\n+#define X86_SIMD_SORT_MAX_INT64 std::numeric_limits<int64_t>::max()\n+#define X86_SIMD_SORT_MIN_INT64 std::numeric_limits<int64_t>::min()\n+#define ZMM_MAX_DOUBLE _mm512_set1_pd(X86_SIMD_SORT_INFINITY)\n+#define ZMM_MAX_UINT64 _mm512_set1_epi64(X86_SIMD_SORT_MAX_UINT64)\n+#define ZMM_MAX_INT64 _mm512_set1_epi64(X86_SIMD_SORT_MAX_INT64)\n+#define ZMM_MAX_FLOAT _mm512_set1_ps(X86_SIMD_SORT_INFINITYF)\n+#define ZMM_MAX_UINT _mm512_set1_epi32(X86_SIMD_SORT_MAX_UINT32)\n+#define ZMM_MAX_INT _mm512_set1_epi32(X86_SIMD_SORT_MAX_INT32)\n+#define ZMM_MAX_HALF _mm512_set1_epi16(X86_SIMD_SORT_INFINITYH)\n+#define YMM_MAX_HALF _mm256_set1_epi16(X86_SIMD_SORT_INFINITYH)\n+#define ZMM_MAX_UINT16 _mm512_set1_epi16(X86_SIMD_SORT_MAX_UINT16)\n+#define ZMM_MAX_INT16 _mm512_set1_epi16(X86_SIMD_SORT_MAX_INT16)\n+#define SHUFFLE_MASK(a, b, c, d) (a << 6) | (b << 4) | (c << 2) | d\n+\n+#ifdef _MSC_VER\n+#define X86_SIMD_SORT_INLINE static inline\n+#define X86_SIMD_SORT_FINLINE static __forceinline\n+#elif defined(__CYGWIN__)\n+\/*\n+ * Force inline in cygwin to work around a compiler bug. See\n+ * https:\/\/github.com\/numpy\/numpy\/pull\/22315#issuecomment-1267757584\n+ *\/\n+#define X86_SIMD_SORT_INLINE static __attribute__((always_inline))\n+#define X86_SIMD_SORT_FINLINE static __attribute__((always_inline))\n+#elif defined(__GNUC__)\n+#define X86_SIMD_SORT_INLINE static inline\n+#define X86_SIMD_SORT_FINLINE static __attribute__((always_inline))\n+#else\n+#define X86_SIMD_SORT_INLINE static\n+#define X86_SIMD_SORT_FINLINE static\n+#endif\n+\n+template <typename type>\n+struct zmm_vector;\n+\n+template <typename type>\n+struct ymm_vector;\n+\n+\/\/ Regular quicksort routines:\n+template <typename T>\n+void avx512_qsort(T *arr, int64_t arrsize);\n+void avx512_qsort_fp16(uint16_t *arr, int64_t arrsize);\n+\n+template <typename T>\n+void avx512_qselect(T *arr, int64_t k, int64_t arrsize);\n+void avx512_qselect_fp16(uint16_t *arr, int64_t k, int64_t arrsize);\n+\n+template <typename T>\n+inline void avx512_partial_qsort(T *arr, int64_t k, int64_t arrsize) {\n+    avx512_qselect<T>(arr, k - 1, arrsize);\n+    avx512_qsort<T>(arr, k - 1);\n+}\n+inline void avx512_partial_qsort_fp16(uint16_t *arr, int64_t k,\n+                                      int64_t arrsize) {\n+    avx512_qselect_fp16(arr, k - 1, arrsize);\n+    avx512_qsort_fp16(arr, k - 1);\n+}\n+\n+\/\/ key-value sort routines\n+template <typename T>\n+void avx512_qsort_kv(T *keys, uint64_t *indexes, int64_t arrsize);\n+\n+template <typename vtype, typename T = typename vtype::type_t>\n+bool comparison_func(const T &a, const T &b) {\n+    return a < b;\n+}\n+\n+\/*\n+ * COEX == Compare and Exchange two registers by swapping min and max values\n+ *\/\n+template <typename vtype, typename mm_t>\n+static void COEX(mm_t &a, mm_t &b) {\n+    mm_t temp = a;\n+    a = vtype::min(a, b);\n+    b = vtype::max(temp, b);\n+}\n+template <typename vtype, typename zmm_t = typename vtype::zmm_t,\n+          typename opmask_t = typename vtype::opmask_t>\n+static inline zmm_t cmp_merge(zmm_t in1, zmm_t in2, opmask_t mask) {\n+    zmm_t min = vtype::min(in2, in1);\n+    zmm_t max = vtype::max(in2, in1);\n+    return vtype::mask_mov(min, mask, max);  \/\/ 0 -> min, 1 -> max\n+}\n+\/*\n+ * Parition one ZMM register based on the pivot and returns the\n+ * number of elements that are greater than or equal to the pivot.\n+ *\/\n+template <typename vtype, typename type_t, typename zmm_t>\n+static inline int32_t partition_vec(type_t *arr, int64_t left, int64_t right,\n+                                    const zmm_t curr_vec, const zmm_t pivot_vec,\n+                                    zmm_t *smallest_vec, zmm_t *biggest_vec) {\n+    \/* which elements are larger than or equal to the pivot *\/\n+    typename vtype::opmask_t ge_mask = vtype::ge(curr_vec, pivot_vec);\n+    int32_t amount_ge_pivot = _mm_popcnt_u32((int32_t)ge_mask);\n+    vtype::mask_compressstoreu(arr + left, vtype::knot_opmask(ge_mask),\n+                               curr_vec);\n+    vtype::mask_compressstoreu(arr + right - amount_ge_pivot, ge_mask,\n+                               curr_vec);\n+    *smallest_vec = vtype::min(curr_vec, *smallest_vec);\n+    *biggest_vec = vtype::max(curr_vec, *biggest_vec);\n+    return amount_ge_pivot;\n+}\n+\/*\n+ * Parition an array based on the pivot and returns the index of the\n+ * first element that is greater than or equal to the pivot.\n+ *\/\n+template <typename vtype, typename type_t>\n+static inline int64_t partition_avx512(type_t *arr, int64_t left, int64_t right,\n+                                       type_t pivot, type_t *smallest,\n+                                       type_t *biggest) {\n+    \/* make array length divisible by vtype::numlanes , shortening the array *\/\n+    for (int32_t i = (right - left) % vtype::numlanes; i > 0; --i) {\n+        *smallest = std::min(*smallest, arr[left], comparison_func<vtype>);\n+        *biggest = std::max(*biggest, arr[left], comparison_func<vtype>);\n+        if (!comparison_func<vtype>(arr[left], pivot)) {\n+            std::swap(arr[left], arr[--right]);\n+        } else {\n+            ++left;\n+        }\n+    }\n+\n+    if (left == right)\n+        return left; \/* less than vtype::numlanes elements in the array *\/\n+\n+    using zmm_t = typename vtype::zmm_t;\n+    zmm_t pivot_vec = vtype::set1(pivot);\n+    zmm_t min_vec = vtype::set1(*smallest);\n+    zmm_t max_vec = vtype::set1(*biggest);\n+\n+    if (right - left == vtype::numlanes) {\n+        zmm_t vec = vtype::loadu(arr + left);\n+        int32_t amount_ge_pivot =\n+            partition_vec<vtype>(arr, left, left + vtype::numlanes, vec,\n+                                 pivot_vec, &min_vec, &max_vec);\n+        *smallest = vtype::reducemin(min_vec);\n+        *biggest = vtype::reducemax(max_vec);\n+        return left + (vtype::numlanes - amount_ge_pivot);\n+    }\n+\n+    \/\/ first and last vtype::numlanes values are partitioned at the end\n+    zmm_t vec_left = vtype::loadu(arr + left);\n+    zmm_t vec_right = vtype::loadu(arr + (right - vtype::numlanes));\n+    \/\/ store points of the vectors\n+    int64_t r_store = right - vtype::numlanes;\n+    int64_t l_store = left;\n+    \/\/ indices for loading the elements\n+    left += vtype::numlanes;\n+    right -= vtype::numlanes;\n+    while (right - left != 0) {\n+        zmm_t curr_vec;\n+        \/*\n+         * if fewer elements are stored on the right side of the array,\n+         * then next elements are loaded from the right side,\n+         * otherwise from the left side\n+         *\/\n+        if ((r_store + vtype::numlanes) - right < left - l_store) {\n+            right -= vtype::numlanes;\n+            curr_vec = vtype::loadu(arr + right);\n+        } else {\n+            curr_vec = vtype::loadu(arr + left);\n+            left += vtype::numlanes;\n+        }\n+        \/\/ partition the current vector and save it on both sides of the array\n+        int32_t amount_ge_pivot =\n+            partition_vec<vtype>(arr, l_store, r_store + vtype::numlanes,\n+                                 curr_vec, pivot_vec, &min_vec, &max_vec);\n+        ;\n+        r_store -= amount_ge_pivot;\n+        l_store += (vtype::numlanes - amount_ge_pivot);\n+    }\n+\n+    \/* partition and save vec_left and vec_right *\/\n+    int32_t amount_ge_pivot =\n+        partition_vec<vtype>(arr, l_store, r_store + vtype::numlanes, vec_left,\n+                             pivot_vec, &min_vec, &max_vec);\n+    l_store += (vtype::numlanes - amount_ge_pivot);\n+    amount_ge_pivot =\n+        partition_vec<vtype>(arr, l_store, l_store + vtype::numlanes, vec_right,\n+                             pivot_vec, &min_vec, &max_vec);\n+    l_store += (vtype::numlanes - amount_ge_pivot);\n+    *smallest = vtype::reducemin(min_vec);\n+    *biggest = vtype::reducemax(max_vec);\n+    return l_store;\n+}\n+\n+template <typename vtype, int num_unroll,\n+          typename type_t = typename vtype::type_t>\n+static inline int64_t partition_avx512_unrolled(type_t *arr, int64_t left,\n+                                                int64_t right, type_t pivot,\n+                                                type_t *smallest,\n+                                                type_t *biggest) {\n+    if (right - left <= 2 * num_unroll * vtype::numlanes) {\n+        return partition_avx512<vtype>(arr, left, right, pivot, smallest,\n+                                       biggest);\n+    }\n+    \/* make array length divisible by 8*vtype::numlanes , shortening the array\n+     *\/\n+    for (int32_t i = ((right - left) % (num_unroll * vtype::numlanes)); i > 0;\n+         --i) {\n+        *smallest = std::min(*smallest, arr[left], comparison_func<vtype>);\n+        *biggest = std::max(*biggest, arr[left], comparison_func<vtype>);\n+        if (!comparison_func<vtype>(arr[left], pivot)) {\n+            std::swap(arr[left], arr[--right]);\n+        } else {\n+            ++left;\n+        }\n+    }\n+\n+    if (left == right)\n+        return left; \/* less than vtype::numlanes elements in the array *\/\n+\n+    using zmm_t = typename vtype::zmm_t;\n+    zmm_t pivot_vec = vtype::set1(pivot);\n+    zmm_t min_vec = vtype::set1(*smallest);\n+    zmm_t max_vec = vtype::set1(*biggest);\n+\n+    \/\/ We will now have atleast 16 registers worth of data to process:\n+    \/\/ left and right vtype::numlanes values are partitioned at the end\n+    zmm_t vec_left[num_unroll], vec_right[num_unroll];\n+#pragma GCC unroll 8\n+    for (int ii = 0; ii < num_unroll; ++ii) {\n+        vec_left[ii] = vtype::loadu(arr + left + vtype::numlanes * ii);\n+        vec_right[ii] =\n+            vtype::loadu(arr + (right - vtype::numlanes * (num_unroll - ii)));\n+    }\n+    \/\/ store points of the vectors\n+    int64_t r_store = right - vtype::numlanes;\n+    int64_t l_store = left;\n+    \/\/ indices for loading the elements\n+    left += num_unroll * vtype::numlanes;\n+    right -= num_unroll * vtype::numlanes;\n+    while (right - left != 0) {\n+        zmm_t curr_vec[num_unroll];\n+        \/*\n+         * if fewer elements are stored on the right side of the array,\n+         * then next elements are loaded from the right side,\n+         * otherwise from the left side\n+         *\/\n+        if ((r_store + vtype::numlanes) - right < left - l_store) {\n+            right -= num_unroll * vtype::numlanes;\n+#pragma GCC unroll 8\n+            for (int ii = 0; ii < num_unroll; ++ii) {\n+                curr_vec[ii] = vtype::loadu(arr + right + ii * vtype::numlanes);\n+            }\n+        } else {\n+#pragma GCC unroll 8\n+            for (int ii = 0; ii < num_unroll; ++ii) {\n+                curr_vec[ii] = vtype::loadu(arr + left + ii * vtype::numlanes);\n+            }\n+            left += num_unroll * vtype::numlanes;\n+        }\n+\/\/ partition the current vector and save it on both sides of the array\n+#pragma GCC unroll 8\n+        for (int ii = 0; ii < num_unroll; ++ii) {\n+            int32_t amount_ge_pivot = partition_vec<vtype>(\n+                arr, l_store, r_store + vtype::numlanes, curr_vec[ii],\n+                pivot_vec, &min_vec, &max_vec);\n+            l_store += (vtype::numlanes - amount_ge_pivot);\n+            r_store -= amount_ge_pivot;\n+        }\n+    }\n+\n+\/* partition and save vec_left[8] and vec_right[8] *\/\n+#pragma GCC unroll 8\n+    for (int ii = 0; ii < num_unroll; ++ii) {\n+        int32_t amount_ge_pivot =\n+            partition_vec<vtype>(arr, l_store, r_store + vtype::numlanes,\n+                                 vec_left[ii], pivot_vec, &min_vec, &max_vec);\n+        l_store += (vtype::numlanes - amount_ge_pivot);\n+        r_store -= amount_ge_pivot;\n+    }\n+#pragma GCC unroll 8\n+    for (int ii = 0; ii < num_unroll; ++ii) {\n+        int32_t amount_ge_pivot =\n+            partition_vec<vtype>(arr, l_store, r_store + vtype::numlanes,\n+                                 vec_right[ii], pivot_vec, &min_vec, &max_vec);\n+        l_store += (vtype::numlanes - amount_ge_pivot);\n+        r_store -= amount_ge_pivot;\n+    }\n+    *smallest = vtype::reducemin(min_vec);\n+    *biggest = vtype::reducemax(max_vec);\n+    return l_store;\n+}\n+\n+\/\/ Key-value sort helper functions\n+\n+template <typename vtype1, typename vtype2,\n+          typename zmm_t1 = typename vtype1::zmm_t,\n+          typename zmm_t2 = typename vtype2::zmm_t>\n+static void COEX(zmm_t1 &key1, zmm_t1 &key2, zmm_t2 &index1, zmm_t2 &index2) {\n+    zmm_t1 key_t1 = vtype1::min(key1, key2);\n+    zmm_t1 key_t2 = vtype1::max(key1, key2);\n+\n+    zmm_t2 index_t1 =\n+        vtype2::mask_mov(index2, vtype1::eq(key_t1, key1), index1);\n+    zmm_t2 index_t2 =\n+        vtype2::mask_mov(index1, vtype1::eq(key_t1, key1), index2);\n+\n+    key1 = key_t1;\n+    key2 = key_t2;\n+    index1 = index_t1;\n+    index2 = index_t2;\n+}\n+template <typename vtype1, typename vtype2,\n+          typename zmm_t1 = typename vtype1::zmm_t,\n+          typename zmm_t2 = typename vtype2::zmm_t,\n+          typename opmask_t = typename vtype1::opmask_t>\n+static inline zmm_t1 cmp_merge(zmm_t1 in1, zmm_t1 in2, zmm_t2 &indexes1,\n+                               zmm_t2 indexes2, opmask_t mask) {\n+    zmm_t1 tmp_keys = cmp_merge<vtype1>(in1, in2, mask);\n+    indexes1 = vtype2::mask_mov(indexes2, vtype1::eq(tmp_keys, in1), indexes1);\n+    return tmp_keys;  \/\/ 0 -> min, 1 -> max\n+}\n+\n+\/*\n+ * Parition one ZMM register based on the pivot and returns the index of the\n+ * last element that is less than equal to the pivot.\n+ *\/\n+template <typename vtype1, typename vtype2,\n+          typename type_t1 = typename vtype1::type_t,\n+          typename type_t2 = typename vtype2::type_t,\n+          typename zmm_t1 = typename vtype1::zmm_t,\n+          typename zmm_t2 = typename vtype2::zmm_t>\n+static inline int32_t partition_vec(type_t1 *keys, type_t2 *indexes,\n+                                    int64_t left, int64_t right,\n+                                    const zmm_t1 keys_vec,\n+                                    const zmm_t2 indexes_vec,\n+                                    const zmm_t1 pivot_vec,\n+                                    zmm_t1 *smallest_vec, zmm_t1 *biggest_vec) {\n+    \/* which elements are larger than the pivot *\/\n+    typename vtype1::opmask_t gt_mask = vtype1::ge(keys_vec, pivot_vec);\n+    int32_t amount_gt_pivot = _mm_popcnt_u32((int32_t)gt_mask);\n+    vtype1::mask_compressstoreu(keys + left, vtype1::knot_opmask(gt_mask),\n+                                keys_vec);\n+    vtype1::mask_compressstoreu(keys + right - amount_gt_pivot, gt_mask,\n+                                keys_vec);\n+    vtype2::mask_compressstoreu(indexes + left, vtype2::knot_opmask(gt_mask),\n+                                indexes_vec);\n+    vtype2::mask_compressstoreu(indexes + right - amount_gt_pivot, gt_mask,\n+                                indexes_vec);\n+    *smallest_vec = vtype1::min(keys_vec, *smallest_vec);\n+    *biggest_vec = vtype1::max(keys_vec, *biggest_vec);\n+    return amount_gt_pivot;\n+}\n+\/*\n+ * Parition an array based on the pivot and returns the index of the\n+ * last element that is less than equal to the pivot.\n+ *\/\n+template <typename vtype1, typename vtype2,\n+          typename type_t1 = typename vtype1::type_t,\n+          typename type_t2 = typename vtype2::type_t,\n+          typename zmm_t1 = typename vtype1::zmm_t,\n+          typename zmm_t2 = typename vtype2::zmm_t>\n+static inline int64_t partition_avx512(type_t1 *keys, type_t2 *indexes,\n+                                       int64_t left, int64_t right,\n+                                       type_t1 pivot, type_t1 *smallest,\n+                                       type_t1 *biggest) {\n+    \/* make array length divisible by vtype1::numlanes , shortening the array *\/\n+    for (int32_t i = (right - left) % vtype1::numlanes; i > 0; --i) {\n+        *smallest = std::min(*smallest, keys[left]);\n+        *biggest = std::max(*biggest, keys[left]);\n+        if (keys[left] > pivot) {\n+            right--;\n+            std::swap(keys[left], keys[right]);\n+            std::swap(indexes[left], indexes[right]);\n+        } else {\n+            ++left;\n+        }\n+    }\n+\n+    if (left == right)\n+        return left; \/* less than vtype1::numlanes elements in the array *\/\n+\n+    zmm_t1 pivot_vec = vtype1::set1(pivot);\n+    zmm_t1 min_vec = vtype1::set1(*smallest);\n+    zmm_t1 max_vec = vtype1::set1(*biggest);\n+\n+    if (right - left == vtype1::numlanes) {\n+        zmm_t1 keys_vec = vtype1::loadu(keys + left);\n+        int32_t amount_gt_pivot;\n+\n+        zmm_t2 indexes_vec = vtype2::loadu(indexes + left);\n+        amount_gt_pivot = partition_vec<vtype1, vtype2>(\n+            keys, indexes, left, left + vtype1::numlanes, keys_vec, indexes_vec,\n+            pivot_vec, &min_vec, &max_vec);\n+\n+        *smallest = vtype1::reducemin(min_vec);\n+        *biggest = vtype1::reducemax(max_vec);\n+        return left + (vtype1::numlanes - amount_gt_pivot);\n+    }\n+\n+    \/\/ first and last vtype1::numlanes values are partitioned at the end\n+    zmm_t1 keys_vec_left = vtype1::loadu(keys + left);\n+    zmm_t1 keys_vec_right = vtype1::loadu(keys + (right - vtype1::numlanes));\n+    zmm_t2 indexes_vec_left;\n+    zmm_t2 indexes_vec_right;\n+    indexes_vec_left = vtype2::loadu(indexes + left);\n+    indexes_vec_right = vtype2::loadu(indexes + (right - vtype1::numlanes));\n+\n+    \/\/ store points of the vectors\n+    int64_t r_store = right - vtype1::numlanes;\n+    int64_t l_store = left;\n+    \/\/ indices for loading the elements\n+    left += vtype1::numlanes;\n+    right -= vtype1::numlanes;\n+    while (right - left != 0) {\n+        zmm_t1 keys_vec;\n+        zmm_t2 indexes_vec;\n+        \/*\n+         * if fewer elements are stored on the right side of the array,\n+         * then next elements are loaded from the right side,\n+         * otherwise from the left side\n+         *\/\n+        if ((r_store + vtype1::numlanes) - right < left - l_store) {\n+            right -= vtype1::numlanes;\n+            keys_vec = vtype1::loadu(keys + right);\n+            indexes_vec = vtype2::loadu(indexes + right);\n+        } else {\n+            keys_vec = vtype1::loadu(keys + left);\n+            indexes_vec = vtype2::loadu(indexes + left);\n+            left += vtype1::numlanes;\n+        }\n+        \/\/ partition the current vector and save it on both sides of the array\n+        int32_t amount_gt_pivot;\n+\n+        amount_gt_pivot = partition_vec<vtype1, vtype2>(\n+            keys, indexes, l_store, r_store + vtype1::numlanes, keys_vec,\n+            indexes_vec, pivot_vec, &min_vec, &max_vec);\n+        r_store -= amount_gt_pivot;\n+        l_store += (vtype1::numlanes - amount_gt_pivot);\n+    }\n+\n+    \/* partition and save vec_left and vec_right *\/\n+    int32_t amount_gt_pivot;\n+    amount_gt_pivot = partition_vec<vtype1, vtype2>(\n+        keys, indexes, l_store, r_store + vtype1::numlanes, keys_vec_left,\n+        indexes_vec_left, pivot_vec, &min_vec, &max_vec);\n+    l_store += (vtype1::numlanes - amount_gt_pivot);\n+    amount_gt_pivot = partition_vec<vtype1, vtype2>(\n+        keys, indexes, l_store, l_store + vtype1::numlanes, keys_vec_right,\n+        indexes_vec_right, pivot_vec, &min_vec, &max_vec);\n+    l_store += (vtype1::numlanes - amount_gt_pivot);\n+    *smallest = vtype1::reducemin(min_vec);\n+    *biggest = vtype1::reducemax(max_vec);\n+    return l_store;\n+}\n+#endif  \/\/ AVX512_QSORT_COMMON\n","filename":"src\/java.base\/linux\/native\/libavx512_x86_64\/avx512-common-qsort.h","additions":524,"deletions":0,"binary":false,"changes":524,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2023 Intel Corporation. All rights reserved.\n+ * Intel x86-simd-sort source code.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"avx512-32bit-qsort.hpp\"\n+#include \"avx512-64bit-qsort.hpp\"\n+\n+#define DLL_PUBLIC __attribute__((visibility(\"default\")))\n+\n+extern \"C\" {\n+\n+    DLL_PUBLIC void avx512_sort_int(int32_t *array_fromIndex, int64_t fromIndex,\n+                                    int64_t toIndex) {\n+        avx512_qsort<int32_t>(array_fromIndex, toIndex - fromIndex);\n+    }\n+\n+    DLL_PUBLIC void avx512_sort_long(int64_t *array_fromIndex, int64_t fromIndex,\n+                                    int64_t toIndex) {\n+        avx512_qsort<int64_t>(array_fromIndex, toIndex - fromIndex);\n+    }\n+\n+    DLL_PUBLIC void avx512_sort_float(float *array_fromIndex, int64_t fromIndex,\n+                                    int64_t toIndex) {\n+        avx512_qsort<float>(array_fromIndex, toIndex - fromIndex);\n+    }\n+\n+    DLL_PUBLIC void avx512_sort_double(double *array_fromIndex, int64_t fromIndex,\n+                                    int64_t toIndex) {\n+        avx512_qsort<double>(array_fromIndex, toIndex - fromIndex);\n+    }\n+\n+}\n","filename":"src\/java.base\/linux\/native\/libavx512_x86_64\/avxsort_linux_x86.cpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -80,0 +80,9 @@\n+    @IntrinsicCandidate\n+    private static void arraySort(Class<?> elemType, Object array, int fromIndex, int toIndex) {\n+        if (elemType == int.class) DualPivotQuicksort.sort((int[]) array, 0, fromIndex, toIndex);\n+        else if (elemType == long.class) DualPivotQuicksort.sort((long[]) array, 0, fromIndex, toIndex);\n+        else if (elemType == float.class) DualPivotQuicksort.sort((float[]) array, 0, fromIndex, toIndex);\n+        else if (elemType == double.class) DualPivotQuicksort.sort((double[]) array, 0, fromIndex, toIndex);\n+        else throw new UnsupportedOperationException(\"arraySort intrinsic not supported for this type: \" + elemType.toString());\n+    }\n+\n@@ -99,1 +108,1 @@\n-        DualPivotQuicksort.sort(a, 0, 0, a.length);\n+        arraySort(int.class, a, 0, a.length);\n@@ -123,1 +132,1 @@\n-        DualPivotQuicksort.sort(a, 0, fromIndex, toIndex);\n+        arraySort(int.class, a, fromIndex, toIndex);\n@@ -137,1 +146,1 @@\n-        DualPivotQuicksort.sort(a, 0, 0, a.length);\n+        arraySort(long.class, a, 0, a.length);\n@@ -161,1 +170,1 @@\n-        DualPivotQuicksort.sort(a, 0, fromIndex, toIndex);\n+        arraySort(long.class, a, fromIndex, toIndex);\n@@ -297,1 +306,1 @@\n-        DualPivotQuicksort.sort(a, 0, 0, a.length);\n+        arraySort(float.class, a, 0, a.length);\n@@ -329,1 +338,1 @@\n-        DualPivotQuicksort.sort(a, 0, fromIndex, toIndex);\n+        arraySort(float.class, a, fromIndex, toIndex);\n@@ -351,1 +360,1 @@\n-        DualPivotQuicksort.sort(a, 0, 0, a.length);\n+        arraySort(double.class, a, 0, a.length);\n@@ -383,1 +392,1 @@\n-        DualPivotQuicksort.sort(a, 0, fromIndex, toIndex);\n+        arraySort(double.class, a, fromIndex, toIndex);\n","filename":"src\/java.base\/share\/classes\/java\/util\/Arrays.java","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.io.UnsupportedEncodingException;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+\n+\/**\n+ * Performance test of Arrays.sort() methods\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 3, time=60)\n+@Measurement(iterations = 3, time=120)\n+@Fork(value = 1)\n+public class ArraysSort {\n+\n+\n+    @Param({\"10\",\"25\",\"50\",\"75\",\"100\", \"1000\", \"10000\", \"100000\"})\n+    private int size;\n+\n+    private int[] ints_unsorted;\n+    private long[] longs_unsorted;\n+    private float[] floats_unsorted;\n+    private double[] doubles_unsorted;\n+\n+    private int[] ints_sorted;\n+    private long[] longs_sorted;\n+    private float[] floats_sorted;\n+    private double[] doubles_sorted;\n+\n+\n+    @Setup\n+    public void setup() throws UnsupportedEncodingException, ClassNotFoundException, NoSuchMethodException, Throwable {\n+        Random rnd = new Random(42);\n+\n+        ints_unsorted = new int[size];\n+        longs_unsorted = new long[size];\n+        floats_unsorted = new float[size];\n+        doubles_unsorted = new double[size];\n+\n+        for (int i = 0; i < size; i++) {\n+            ints_unsorted[i] = rnd.nextInt();\n+            longs_unsorted[i] = rnd.nextLong();\n+            floats_unsorted[i] = rnd.nextFloat();\n+            doubles_unsorted[i] = rnd.nextDouble();\n+        }\n+    }\n+\n+    @Setup(Level.Invocation)\n+    public void init() {\n+        ints_sorted = ints_unsorted.clone();\n+        longs_sorted = longs_unsorted.clone();\n+        floats_sorted = floats_unsorted.clone();\n+        doubles_sorted = doubles_unsorted.clone();\n+    }\n+\n+    @Benchmark\n+    public int[] intSort() throws Throwable {\n+        Arrays.sort(ints_sorted);\n+        return ints_sorted;\n+    }\n+\n+    @Benchmark\n+    public long[] longSort() throws Throwable {\n+        Arrays.sort(longs_sorted);\n+        return longs_sorted;\n+    }\n+\n+    @Benchmark\n+    public float[] floatSort() throws Throwable {\n+        Arrays.sort(floats_sorted);\n+        return floats_sorted;\n+    }\n+\n+    @Benchmark\n+    public double[] doubleSort() throws Throwable {\n+        Arrays.sort(doubles_sorted);\n+        return doubles_sorted;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/ArraysSort.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"}]}