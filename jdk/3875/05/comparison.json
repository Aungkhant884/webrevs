{"files":[{"patch":"@@ -3194,25 +3194,1 @@\n-    Thread* thread = Thread::current();\n-    if (thread->is_Java_thread()) {\n-      JavaThread* current_thread = thread->as_Java_thread();\n-\n-      \/* Transition to thread_blocked without entering vm state          *\/\n-      \/* This is really evil. Normally you can't undo _thread_blocked    *\/\n-      \/* transitions like this because it would cause us to miss a       *\/\n-      \/* safepoint but since the thread was already in _thread_in_native *\/\n-      \/* the thread is not leaving a safepoint safe state and it will    *\/\n-      \/* block when it tries to return from native. We can't safepoint   *\/\n-      \/* block in here because we could deadlock the vmthread. Blech.    *\/\n-\n-      JavaThreadState state = current_thread->thread_state();\n-      assert(state == _thread_in_native, \"Must be _thread_in_native\");\n-      \/\/ frame should already be walkable since we are in native\n-      assert(!current_thread->has_last_Java_frame() ||\n-             current_thread->frame_anchor()->walkable(), \"Must be walkable\");\n-      current_thread->set_thread_state(_thread_blocked);\n-\n-      rmonitor->raw_enter(current_thread);\n-      \/\/ restore state, still at a safepoint safe state\n-      current_thread->set_thread_state(state);\n-    } else {\n-      rmonitor->raw_enter(thread);\n-    }\n+    rmonitor->raw_enter(Thread::current());\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -46,4 +46,6 @@\n-  assert(current_java_thread->thread_state() == _thread_in_vm, \"Must be in vm\");\n-  for (int i = 0; i < count(); i++) {\n-    JvmtiRawMonitor* rmonitor = monitors()->at(i);\n-    rmonitor->raw_enter(current_java_thread);\n+  {\n+    ThreadToNativeFromVM ttnfvm(current_java_thread);\n+    for (int i = 0; i < count(); i++) {\n+      JvmtiRawMonitor* rmonitor = monitors()->at(i);\n+      rmonitor->raw_enter(current_java_thread);\n+    }\n@@ -63,1 +65,0 @@\n-                                                     _waiters(0),\n@@ -220,3 +221,1 @@\n-\/\/ transitions. However, we cannot perform such transitions whilst we hold the RawMonitor,\n-\/\/ else we can deadlock with the VMThread (which may also use RawMonitors as part of\n-\/\/ executing various callbacks).\n+\/\/ transitions.\n@@ -225,0 +224,3 @@\n+\/\/ Note:\n+\/\/  - simple_wait never reenters the monitor.\n+\/\/  - A JavaThread must be in native.\n@@ -238,3 +240,5 @@\n-    \/\/ Transition to VM so we can check interrupt state\n-    ThreadInVMfromNative tivm(jt);\n-    if (jt->is_interrupted(true)) {\n+    guarantee(jt->thread_state() == _thread_in_native, \"invariant\");\n+    {\n+      \/\/ This transition must be after we exited the monitor.\n+      ThreadInVMfromNative tivmfn(jt);\n+      if (jt->is_interrupted(true)) {\n@@ -242,4 +246,0 @@\n-    } else {\n-      ThreadBlockInVM tbivm(jt);\n-      if (millis <= 0) {\n-        self->_ParkEvent->park();\n@@ -247,1 +247,10 @@\n-        self->_ParkEvent->park(millis);\n+        ThreadBlockInVM tbivm(jt);\n+        if (millis <= 0) {\n+          self->_ParkEvent->park();\n+        } else {\n+          self->_ParkEvent->park(millis);\n+        }\n+        \/\/ Return to VM before post-check of interrupt state\n+      }\n+      if (jt->is_interrupted(true)) {\n+        ret = M_INTERRUPTED;\n@@ -249,4 +258,0 @@\n-      \/\/ Return to VM before post-check of interrupt state\n-    }\n-    if (jt->is_interrupted(true)) {\n-      ret = M_INTERRUPTED;\n@@ -264,4 +269,0 @@\n-  simple_enter(self);\n-  guarantee(_owner == self, \"invariant\");\n-  guarantee(_recursions == 0, \"invariant\");\n-\n@@ -309,34 +310,5 @@\n-\/\/ Any JavaThread will enter here with state _thread_blocked unless we\n-\/\/ are in single-threaded mode during startup.\n-void JvmtiRawMonitor::raw_enter(Thread* self) {\n-  void* contended;\n-  JavaThread* jt = NULL;\n-  \/\/ don't enter raw monitor if thread is being externally suspended, it will\n-  \/\/ surprise the suspender if a \"suspended\" thread can still enter monitor\n-  if (self->is_Java_thread()) {\n-    jt = self->as_Java_thread();\n-    while (true) {\n-      \/\/ To pause suspend requests while in blocked we must block handshakes.\n-      jt->handshake_state()->lock();\n-      \/\/ Suspend request flag can only be set in handshakes.\n-      \/\/ By blocking handshakes, suspend request flag cannot change its value.\n-      if (!jt->handshake_state()->is_suspended()) {\n-        contended = Atomic::cmpxchg(&_owner, (Thread*)NULL, jt);\n-        jt->handshake_state()->unlock();\n-        break;\n-      }\n-      jt->handshake_state()->unlock();\n-\n-      \/\/ We may only be in states other than _thread_blocked when we are\n-      \/\/ in single-threaded mode during startup.\n-      guarantee(jt->thread_state() == _thread_blocked, \"invariant\");\n-\n-      jt->set_thread_state_fence(_thread_blocked_trans);\n-      SafepointMechanism::process_if_requested(jt);\n-      \/\/ We should transition to thread_in_vm and then to thread_in_vm_trans,\n-      \/\/ but those are always treated the same as _thread_blocked_trans.\n-      jt->set_thread_state(_thread_blocked);\n-    }\n-  } else {\n-    contended = Atomic::cmpxchg(&_owner, (Thread*)NULL, self);\n-  }\n+void JvmtiRawMonitor::ExitOnSuspend::operator()(JavaThread* current) {\n+  \/\/ We must exit the monitor in case of a safepoint.\n+  _rm->simple_exit(current);\n+  _rm_exited = true;\n+}\n@@ -344,1 +316,4 @@\n-  if (contended == self) {\n+\/\/ JavaThreads will enter here with state _thread_in_native.\n+void JvmtiRawMonitor::raw_enter(Thread* self) {\n+  \/\/ TODO Atomic::load on _owner field\n+  if (_owner == self) {\n@@ -349,6 +324,0 @@\n-  if (contended == NULL) {\n-    guarantee(_owner == self, \"invariant\");\n-    guarantee(_recursions == 0, \"invariant\");\n-    return;\n-  }\n-\n@@ -360,2 +329,3 @@\n-    \/\/ In multi-threaded mode, we must enter this method blocked.\n-    guarantee(jt->thread_state() == _thread_blocked, \"invariant\");\n+    JavaThread* jt = self->as_Java_thread();\n+    guarantee(jt->thread_state() == _thread_in_native, \"invariant\");\n+    ThreadInVMfromNative tivmfn(jt);\n@@ -363,4 +333,4 @@\n-      simple_enter(jt);\n-      if (!SafepointMechanism::should_process(jt)) {\n-        \/\/ Not suspended so we're done here.\n-        break;\n+      ExitOnSuspend eos(this);\n+      {\n+        ThreadBlockInVMPreprocess<ExitOnSuspend> tbivmp(jt, eos);\n+        simple_enter(jt);\n@@ -368,2 +338,1 @@\n-      if (!jt->is_suspended()) {\n-        \/\/ Not suspended so we're done here.\n+      if (!eos.monitor_exited()) {\n@@ -372,6 +341,0 @@\n-      simple_exit(jt);\n-      jt->set_thread_state_fence(_thread_blocked_trans);\n-      SafepointMechanism::process_if_requested(jt);\n-      \/\/ We should transition to thread_in_vm and then to thread_in_vm_trans,\n-      \/\/ but those are always treated the same as _thread_blocked_trans.\n-      jt->set_thread_state(_thread_blocked);\n@@ -414,1 +377,0 @@\n-  _waiters++;\n@@ -416,4 +378,0 @@\n-  _recursions = save;\n-  _waiters--;\n-\n-  guarantee(self == _owner, \"invariant\");\n@@ -421,1 +379,3 @@\n-  if (self->is_Java_thread()) {\n+  \/\/ Now we need to re-enter the monitor. For JavaThreads\n+  \/\/ we need to manage suspend requests.\n+  if (self->is_Java_thread()) { \/\/ JavaThread re-enter\n@@ -423,1 +383,1 @@\n-    guarantee(jt->thread_state() == _thread_in_native, \"invariant\");\n+    ThreadInVMfromNative tivmfn(jt);\n@@ -425,3 +385,4 @@\n-      if (!SafepointMechanism::should_process(jt)) {\n-        \/\/ Not suspended so we're done here:\n-        break;\n+      ExitOnSuspend eos(this);\n+      {\n+        ThreadBlockInVMPreprocess<ExitOnSuspend> tbivmp(jt, eos);\n+        simple_enter(jt);\n@@ -429,5 +390,2 @@\n-      simple_exit(jt);\n-      jt->set_thread_state_fence(_thread_in_native_trans);\n-      SafepointMechanism::process_if_requested(jt);\n-      if (jt->is_interrupted(true)) {\n-        ret = M_INTERRUPTED;\n+      if (!eos.monitor_exited()) {\n+        break;\n@@ -435,4 +393,0 @@\n-      \/\/ We should transition to thread_in_vm and then to thread_in_vm_trans,\n-      \/\/ but those are always treated the same as _thread_in_native_trans.\n-      jt->set_thread_state(_thread_in_native);\n-      simple_enter(jt);\n@@ -440,2 +394,4 @@\n-    guarantee(jt == _owner, \"invariant\");\n-  } else {\n+    if (jt->is_interrupted(true)) {\n+      ret = M_INTERRUPTED;\n+    }\n+  } else { \/\/ Non-JavaThread re-enter\n@@ -443,0 +399,1 @@\n+    simple_enter(self);\n@@ -445,0 +402,4 @@\n+  _recursions = save;\n+\n+  guarantee(self == _owner, \"invariant\");\n+  guarantee(save == _recursions, \"invariant\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiRawMonitor.cpp","additions":61,"deletions":100,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -40,0 +40,15 @@\n+\/\/ Important note:\n+\/\/ Raw monitors can be used in callbacks which happen during safepoint by the VM\n+\/\/ thread (e.g., heapRootCallback). This means we may not transition\/safepoint\n+\/\/ poll in many cases, else the agent JavaThread can deadlock with the VM thread,\n+\/\/ as this old comment says:\n+\/\/ \"We can't safepoint block in here because we could deadlock the vmthread. Blech.\"\n+\/\/ The rules are:\n+\/\/ - We must never safepoint poll if raw monitor is owned.\n+\/\/ - We may safepoint poll before it is owned and after it has been released.\n+\/\/ If this were the only thing we needed to think about we could just stay in\n+\/\/ native for all operations. However we need to honor a suspend request, not\n+\/\/ entering a monitor if suspended, and check for interrupts. Honoring a suspend\n+\/\/ request and reading the interrupt flag must be done from VM state\n+\/\/ (a safepoint unsafe state).\n+\n@@ -62,1 +77,0 @@\n-  volatile jint _waiters;       \/\/ number of waiting threads\n@@ -78,0 +92,10 @@\n+  class ExitOnSuspend {\n+   protected:\n+    JvmtiRawMonitor* _rm;\n+    bool _rm_exited;\n+   public:\n+    ExitOnSuspend(JvmtiRawMonitor* rm) : _rm(rm), _rm_exited(false) {}\n+    void operator()(JavaThread* current);\n+    bool monitor_exited() { return _rm_exited; }\n+  };\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiRawMonitor.hpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -603,8 +603,0 @@\n-void HandshakeState::lock() {\n-  _lock.lock_without_safepoint_check();\n-}\n-\n-void HandshakeState::unlock() {\n-  _lock.unlock();\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -76,1 +76,0 @@\n-  friend JvmtiRawMonitor;\n@@ -106,3 +105,0 @@\n-  void lock();\n-  void unlock();\n-\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -205,1 +205,8 @@\n-    trans(_thread_in_vm, _thread_in_native);\n+    assert(_thread->thread_state() == _thread_in_vm, \"coming from wrong thread state\");\n+    \/\/ We cannot assert !_thread->owns_locks() since we have valid cases where\n+    \/\/ we call known native code using this wrapper holding locks.\n+    _thread->check_possible_safepoint();\n+    \/\/ Once we are in native vm expects stack to be walkable\n+    _thread->frame_anchor()->make_walkable(_thread);\n+    OrderAccess::storestore();\n+    _thread->set_thread_state(_thread_in_native);\n@@ -229,7 +236,6 @@\n-\n-\/\/ Parameter in_flight_mutex_addr is only used by class Mutex to avoid certain deadlock\n-\/\/ scenarios while making transitions that might block for a safepoint or handshake.\n-\/\/ It's the address of a pointer to the mutex we are trying to acquire. This will be used to\n-\/\/ access and release said mutex when transitioning back from blocked to vm (destructor) in\n-\/\/ case we need to stop for a safepoint or handshake.\n-class ThreadBlockInVM : public ThreadStateTransition {\n+\/\/ Perform a transition to _thread_blocked and take a call-back to be executed before\n+\/\/ SafepointMechanism::process_if_requested when returning to the VM. This allows us\n+\/\/ to perform an \"undo\" action if we might block processing a safepoint\/handshake operation\n+\/\/ (such as thread suspension).\n+template <typename PRE_PROC>\n+class ThreadBlockInVMPreprocess : public ThreadStateTransition {\n@@ -237,2 +243,1 @@\n-  Mutex** _in_flight_mutex_addr;\n-\n+  PRE_PROC& _pr;\n@@ -240,2 +245,1 @@\n-  ThreadBlockInVM(JavaThread* thread, Mutex** in_flight_mutex_addr = NULL)\n-  : ThreadStateTransition(thread), _in_flight_mutex_addr(in_flight_mutex_addr) {\n+  ThreadBlockInVMPreprocess(JavaThread* thread, PRE_PROC& pr) : ThreadStateTransition(thread), _pr(pr) {\n@@ -246,0 +250,1 @@\n+    OrderAccess::storestore();\n@@ -248,1 +253,1 @@\n-  ~ThreadBlockInVM() {\n+  ~ThreadBlockInVMPreprocess() {\n@@ -254,3 +259,1 @@\n-      if (_in_flight_mutex_addr != NULL) {\n-        release_mutex();\n-      }\n+      _pr(_thread);\n@@ -262,0 +265,1 @@\n+};\n@@ -263,4 +267,8 @@\n-  void release_mutex() {\n-    Mutex* in_flight_mutex = *_in_flight_mutex_addr;\n-    if (in_flight_mutex != NULL) {\n-      in_flight_mutex->release_for_safepoint();\n+class InFlightMutexRelease {\n+ private:\n+  Mutex** _in_flight_mutex_addr;\n+ public:\n+  InFlightMutexRelease(Mutex** in_flight_mutex_addr) : _in_flight_mutex_addr(in_flight_mutex_addr) {}\n+  void operator()(JavaThread* current) {\n+    if (_in_flight_mutex_addr != NULL && *_in_flight_mutex_addr != NULL) {\n+      (*_in_flight_mutex_addr)->release_for_safepoint();\n@@ -272,0 +280,13 @@\n+\/\/ Parameter in_flight_mutex_addr is only used by class Mutex to avoid certain deadlock\n+\/\/ scenarios while making transitions that might block for a safepoint or handshake.\n+\/\/ It's the address of a pointer to the mutex we are trying to acquire. This will be used to\n+\/\/ access and release said mutex when transitioning back from blocked to vm (destructor) in\n+\/\/ case we need to stop for a safepoint or handshake.\n+class ThreadBlockInVM {\n+  InFlightMutexRelease _ifmr;\n+  ThreadBlockInVMPreprocess<InFlightMutexRelease> _tbivmpp;\n+ public:\n+  ThreadBlockInVM(JavaThread* thread, Mutex** in_flight_mutex_addr = NULL)\n+    : _ifmr(in_flight_mutex_addr), _tbivmpp(thread, _ifmr) {}\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":41,"deletions":20,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -310,0 +310,21 @@\n+void ObjectMonitor::ExitOnSuspend::operator()(JavaThread* current) {\n+  if (current->is_suspended()) {\n+    _om->_recursions = 0;\n+    _om->_succ = NULL;\n+    \/\/ Don't need a full fence after clearing successor here because of the call to exit().\n+    _om->exit(current, false \/* not_suspended *\/);\n+    _om_exited = true;\n+\n+    current->set_current_pending_monitor(_om);\n+  }\n+}\n+\n+void ObjectMonitor::ClearSuccOnSuspend::operator()(JavaThread* current) {\n+  if (current->is_suspended()) {\n+    if (_om->_succ == current) {\n+      _om->_succ = NULL;\n+      OrderAccess::fence(); \/\/ always do a full fence when successor is cleared\n+    }\n+  }\n+}\n+\n@@ -409,4 +430,0 @@\n-    current->frame_anchor()->make_walkable(current);\n-    \/\/ Thread must be walkable before it is blocked.\n-    \/\/ Read in reverse order.\n-    OrderAccess::storestore();\n@@ -414,17 +431,14 @@\n-      current->set_thread_state(_thread_blocked);\n-      EnterI(current);\n-      current->set_thread_state_fence(_thread_blocked_trans);\n-      if (SafepointMechanism::should_process(current) &&\n-        current->is_suspended()) {\n-        \/\/ We have acquired the contended monitor, but while we were\n-        \/\/ waiting another thread suspended us. We don't want to enter\n-        \/\/ the monitor while suspended because that would surprise the\n-        \/\/ thread that suspended us.\n-        _recursions = 0;\n-        _succ = NULL;\n-        \/\/ Don't need a full fence after clearing successor here because of the call to exit().\n-        exit(current, false \/* not_suspended *\/);\n-        SafepointMechanism::process_if_requested(current);\n-        \/\/ Since we are going to _thread_blocked we skip setting _thread_in_vm here.\n-      } else {\n-        \/\/ Only exit path from for loop\n+      ExitOnSuspend eos(this);\n+      {\n+        ThreadBlockInVMPreprocess<ExitOnSuspend> tbivs(current, eos);\n+        EnterI(current);\n+        current->set_current_pending_monitor(NULL);\n+        \/\/ We can go to a safepoint at the end of this block. If we\n+        \/\/ do a thread dump during that safepoint, then this thread will show\n+        \/\/ as having \"-locked\" the monitor, but the OS and java.lang.Thread\n+        \/\/ states will still report that the thread is blocked trying to\n+        \/\/ acquire it.\n+      }\n+      if (!eos.exited()) {\n+        \/\/ ExitOnSuspend did not exit the OM\n+        assert(owner_raw() == current, \"invariant\");\n@@ -435,2 +449,0 @@\n-    current->set_current_pending_monitor(NULL);\n-\n@@ -440,9 +452,0 @@\n-    \/\/ We can go to a safepoint at the end of this block. If we\n-    \/\/ do a thread dump during that safepoint, then this thread will show\n-    \/\/ as having \"-locked\" the monitor, but the OS and java.lang.Thread\n-    \/\/ states will still report that the thread is blocked trying to\n-    \/\/ acquire it.\n-\n-    \/\/ Completed the tranisition.\n-    SafepointMechanism::process_if_requested(current);\n-    current->set_thread_state(_thread_in_vm);\n@@ -972,13 +975,4 @@\n-      current->frame_anchor()->make_walkable(current);\n-      \/\/ Thread must be walkable before it is blocked.\n-      \/\/ Read in reverse order.\n-      OrderAccess::storestore();\n-      current->set_thread_state(_thread_blocked);\n-      current->_ParkEvent->park();\n-      current->set_thread_state_fence(_thread_blocked_trans);\n-      if (SafepointMechanism::should_process(current)) {\n-        if (_succ == current) {\n-            _succ = NULL;\n-            OrderAccess::fence(); \/\/ always do a full fence when successor is cleared\n-        }\n-        SafepointMechanism::process_if_requested(current);\n+      {\n+        ClearSuccOnSuspend csos(this);\n+        ThreadBlockInVMPreprocess<ClearSuccOnSuspend> tbivs(current, csos);\n+        current->_ParkEvent->park();\n@@ -986,1 +980,0 @@\n-      current->set_thread_state(_thread_in_vm);\n@@ -1544,5 +1537,2 @@\n-      current->frame_anchor()->make_walkable(current);\n-      \/\/ Thread must be walkable before it is blocked.\n-      \/\/ Read in reverse order.\n-      OrderAccess::storestore();\n-      current->set_thread_state(_thread_blocked);\n+      ClearSuccOnSuspend csos(this);\n+      ThreadBlockInVMPreprocess<ClearSuccOnSuspend> tbivs(current, csos);\n@@ -1558,9 +1548,0 @@\n-      current->set_thread_state_fence(_thread_blocked_trans);\n-      if (SafepointMechanism::should_process(current)) {\n-        if (_succ == current) {\n-            _succ = NULL;\n-            OrderAccess::fence(); \/\/ always do a full fence when successor is cleared\n-        }\n-        SafepointMechanism::process_if_requested(current);\n-      }\n-      current->set_thread_state(_thread_in_vm);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":41,"deletions":60,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -305,0 +305,18 @@\n+ private:\n+  class ExitOnSuspend {\n+   protected:\n+    ObjectMonitor* _om;\n+    bool _om_exited;\n+   public:\n+    ExitOnSuspend(ObjectMonitor* om) : _om(om), _om_exited(false) {}\n+    void operator()(JavaThread* current);\n+    bool exited() { return _om_exited; }\n+  };\n+  class ClearSuccOnSuspend {\n+   protected:\n+    ObjectMonitor* _om;\n+   public:\n+    ClearSuccOnSuspend(ObjectMonitor* om) : _om(om)  {}\n+    void operator()(JavaThread* current);\n+  };\n+ public:\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"}]}