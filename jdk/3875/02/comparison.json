{"files":[{"patch":"@@ -3194,25 +3194,1 @@\n-    Thread* thread = Thread::current();\n-    if (thread->is_Java_thread()) {\n-      JavaThread* current_thread = thread->as_Java_thread();\n-\n-      \/* Transition to thread_blocked without entering vm state          *\/\n-      \/* This is really evil. Normally you can't undo _thread_blocked    *\/\n-      \/* transitions like this because it would cause us to miss a       *\/\n-      \/* safepoint but since the thread was already in _thread_in_native *\/\n-      \/* the thread is not leaving a safepoint safe state and it will    *\/\n-      \/* block when it tries to return from native. We can't safepoint   *\/\n-      \/* block in here because we could deadlock the vmthread. Blech.    *\/\n-\n-      JavaThreadState state = current_thread->thread_state();\n-      assert(state == _thread_in_native, \"Must be _thread_in_native\");\n-      \/\/ frame should already be walkable since we are in native\n-      assert(!current_thread->has_last_Java_frame() ||\n-             current_thread->frame_anchor()->walkable(), \"Must be walkable\");\n-      current_thread->set_thread_state(_thread_blocked);\n-\n-      rmonitor->raw_enter(current_thread);\n-      \/\/ restore state, still at a safepoint safe state\n-      current_thread->set_thread_state(state);\n-    } else {\n-      rmonitor->raw_enter(thread);\n-    }\n+    rmonitor->raw_enter(Thread::current());\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -47,3 +47,6 @@\n-  for (int i = 0; i < count(); i++) {\n-    JvmtiRawMonitor* rmonitor = monitors()->at(i);\n-    rmonitor->raw_enter(current_java_thread);\n+  {\n+    ThreadToNativeFromVM ttnfvm(current_java_thread);\n+    for (int i = 0; i < count(); i++) {\n+      JvmtiRawMonitor* rmonitor = monitors()->at(i);\n+      rmonitor->raw_enter(current_java_thread);\n+    }\n@@ -220,3 +223,1 @@\n-\/\/ transitions. However, we cannot perform such transitions whilst we hold the RawMonitor,\n-\/\/ else we can deadlock with the VMThread (which may also use RawMonitors as part of\n-\/\/ executing various callbacks).\n+\/\/ transitions.\n@@ -225,0 +226,3 @@\n+\/\/ Note:\n+\/\/  - simple_wait never reenters the monitor.\n+\/\/  - A JavaThread must be in native.\n@@ -238,3 +242,5 @@\n-    \/\/ Transition to VM so we can check interrupt state\n-    ThreadInVMfromNative tivm(jt);\n-    if (jt->is_interrupted(true)) {\n+    guarantee(jt->thread_state() == _thread_in_native, \"invariant\");\n+    {\n+      \/\/ This transition must be after we exited the monitor.\n+      ThreadInVMfromNative tivmfn(jt);\n+      if (jt->is_interrupted(true)) {\n@@ -242,4 +248,0 @@\n-    } else {\n-      ThreadBlockInVM tbivm(jt);\n-      if (millis <= 0) {\n-        self->_ParkEvent->park();\n@@ -247,1 +249,10 @@\n-        self->_ParkEvent->park(millis);\n+        ThreadBlockInVM tbivm(jt);\n+        if (millis <= 0) {\n+          self->_ParkEvent->park();\n+        } else {\n+          self->_ParkEvent->park(millis);\n+        }\n+        \/\/ Return to VM before post-check of interrupt state\n+      }\n+      if (jt->is_interrupted(true)) {\n+        ret = M_INTERRUPTED;\n@@ -249,4 +260,0 @@\n-      \/\/ Return to VM before post-check of interrupt state\n-    }\n-    if (jt->is_interrupted(true)) {\n-      ret = M_INTERRUPTED;\n@@ -264,4 +271,0 @@\n-  simple_enter(self);\n-  guarantee(_owner == self, \"invariant\");\n-  guarantee(_recursions == 0, \"invariant\");\n-\n@@ -309,34 +312,5 @@\n-\/\/ Any JavaThread will enter here with state _thread_blocked unless we\n-\/\/ are in single-threaded mode during startup.\n-void JvmtiRawMonitor::raw_enter(Thread* self) {\n-  void* contended;\n-  JavaThread* jt = NULL;\n-  \/\/ don't enter raw monitor if thread is being externally suspended, it will\n-  \/\/ surprise the suspender if a \"suspended\" thread can still enter monitor\n-  if (self->is_Java_thread()) {\n-    jt = self->as_Java_thread();\n-    while (true) {\n-      \/\/ To pause suspend requests while in blocked we must block handshakes.\n-      jt->handshake_state()->lock();\n-      \/\/ Suspend request flag can only be set in handshakes.\n-      \/\/ By blocking handshakes, suspend request flag cannot change its value.\n-      if (!jt->handshake_state()->is_suspended()) {\n-        contended = Atomic::cmpxchg(&_owner, (Thread*)NULL, jt);\n-        jt->handshake_state()->unlock();\n-        break;\n-      }\n-      jt->handshake_state()->unlock();\n-\n-      \/\/ We may only be in states other than _thread_blocked when we are\n-      \/\/ in single-threaded mode during startup.\n-      guarantee(jt->thread_state() == _thread_blocked, \"invariant\");\n-\n-      jt->set_thread_state_fence(_thread_blocked_trans);\n-      SafepointMechanism::process_if_requested(jt);\n-      \/\/ We should transition to thread_in_vm and then to thread_in_vm_trans,\n-      \/\/ but those are always treated the same as _thread_blocked_trans.\n-      jt->set_thread_state(_thread_blocked);\n-    }\n-  } else {\n-    contended = Atomic::cmpxchg(&_owner, (Thread*)NULL, self);\n-  }\n+void JvmtiRawMonitor::ExitOnSuspend::operator()(JavaThread* current) {\n+  \/\/ We must exit the monitor in case of a safepoint.\n+  _rm->simple_exit(current);\n+  _rm_exit = true;\n+}\n@@ -344,1 +318,4 @@\n-  if (contended == self) {\n+\/\/ JavaThreads will enter here with state _thread_in_native.\n+void JvmtiRawMonitor::raw_enter(Thread* self) {\n+  \/\/ TODO Atomic::load on _owner field\n+  if (_owner == self) {\n@@ -349,6 +326,0 @@\n-  if (contended == NULL) {\n-    guarantee(_owner == self, \"invariant\");\n-    guarantee(_recursions == 0, \"invariant\");\n-    return;\n-  }\n-\n@@ -360,2 +331,3 @@\n-    \/\/ In multi-threaded mode, we must enter this method blocked.\n-    guarantee(jt->thread_state() == _thread_blocked, \"invariant\");\n+    JavaThread* jt = self->as_Java_thread();\n+    guarantee(jt->thread_state() == _thread_in_native, \"invariant\");\n+    ThreadInVMfromNative tivmfn(jt);\n@@ -363,4 +335,4 @@\n-      simple_enter(jt);\n-      if (!SafepointMechanism::should_process(jt)) {\n-        \/\/ Not suspended so we're done here.\n-        break;\n+      ExitOnSuspend eos(this);\n+      {\n+        ThreadBlockInVMPreprocess<ExitOnSuspend> tbivmp(jt, eos);\n+        simple_enter(jt);\n@@ -368,2 +340,1 @@\n-      if (!jt->is_suspended()) {\n-        \/\/ Not suspended so we're done here.\n+      if (!eos.monitor_exited()) {\n@@ -372,6 +343,0 @@\n-      simple_exit(jt);\n-      jt->set_thread_state_fence(_thread_blocked_trans);\n-      SafepointMechanism::process_if_requested(jt);\n-      \/\/ We should transition to thread_in_vm and then to thread_in_vm_trans,\n-      \/\/ but those are always treated the same as _thread_blocked_trans.\n-      jt->set_thread_state(_thread_blocked);\n@@ -413,7 +378,0 @@\n-  _recursions = 0;\n-  _waiters++;\n-  ret = simple_wait(self, millis);\n-  _recursions = save;\n-  _waiters--;\n-\n-  guarantee(self == _owner, \"invariant\");\n@@ -424,4 +382,18 @@\n-    for (;;) {\n-      if (!SafepointMechanism::should_process(jt)) {\n-        \/\/ Not suspended so we're done here:\n-        break;\n+\n+    _recursions = 0;\n+    _waiters++;\n+    ret = simple_wait(self, millis);\n+    _waiters--;\n+\n+    {\n+      ThreadInVMfromNative tivmfn(jt);\n+      for (;;) {\n+        ExitOnSuspend eos(this);\n+        {\n+          ThreadBlockInVMPreprocess<ExitOnSuspend> tbivmp(jt, eos);\n+          simple_enter(jt);\n+          _recursions = save;\n+        }\n+        if (!eos.monitor_exited()) {\n+          break;\n+        }\n@@ -429,3 +401,0 @@\n-      simple_exit(jt);\n-      jt->set_thread_state_fence(_thread_in_native_trans);\n-      SafepointMechanism::process_if_requested(jt);\n@@ -435,4 +404,0 @@\n-      \/\/ We should transition to thread_in_vm and then to thread_in_vm_trans,\n-      \/\/ but those are always treated the same as _thread_in_native_trans.\n-      jt->set_thread_state(_thread_in_native);\n-      simple_enter(jt);\n@@ -440,1 +405,0 @@\n-    guarantee(jt == _owner, \"invariant\");\n@@ -442,0 +406,6 @@\n+    _recursions = 0;\n+    _waiters++;\n+    ret = simple_wait(self, millis);\n+    _waiters--;\n+    _recursions = save;\n+    simple_enter(self);\n@@ -445,0 +415,2 @@\n+  guarantee(self == _owner, \"invariant\");\n+  guarantee(save == _recursions, \"invariant\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiRawMonitor.cpp","additions":68,"deletions":96,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -40,0 +40,15 @@\n+\/\/ Important note:\n+\/\/ Raw monitors can be used in callbacks which happen during safepoint by the VM\n+\/\/ thread (e.g., heapRootCallback). This means we may not transition\/safepoint\n+\/\/ poll in many cases, else the agent JavaThread can deadlock with the VM thread,\n+\/\/ as this old comment says:\n+\/\/ \"We can't safepoint block in here because we could deadlock the vmthread. Blech.\"\n+\/\/ The rules are:\n+\/\/ - We must never safepoint poll if raw monitor is owned.\n+\/\/ - We may safepoint poll before it is owned and after it has been released.\n+\/\/ If this were the only thing we needed to think about we could just stay in\n+\/\/ native for all operations. However we need to honor a suspend request, not\n+\/\/ entering a monitor if suspended, and check for interrupts. Honoring a suspend\n+\/\/ request\/\/ and reading the interrupt flag must be done from VM state\n+\/\/ (a safepoint unsafe state).\n+\n@@ -78,0 +93,10 @@\n+  class ExitOnSuspend {\n+   protected:\n+    JvmtiRawMonitor* _rm;\n+    bool _rm_exit;\n+   public:\n+    ExitOnSuspend(JvmtiRawMonitor* rm) : _rm(rm), _rm_exit(false) {}\n+    void operator()(JavaThread* current);\n+    bool monitor_exited() { return _rm_exit; }\n+  };\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiRawMonitor.hpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -603,8 +603,0 @@\n-void HandshakeState::lock() {\n-  _lock.lock_without_safepoint_check();\n-}\n-\n-void HandshakeState::unlock() {\n-  _lock.unlock();\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -76,1 +76,0 @@\n-  friend JvmtiRawMonitor;\n@@ -106,3 +105,0 @@\n-  void lock();\n-  void unlock();\n-\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -205,1 +205,3 @@\n-    trans(_thread_in_vm, _thread_in_native);\n+    assert(_thread->thread_state() == _thread_in_vm, \"coming from wrong thread state\");\n+    assert(!_thread->has_last_Java_frame() || _thread->frame_anchor()->walkable(), \"Unwalkable stack in vm->native transition\");\n+    _thread->set_thread_state(_thread_in_native);\n@@ -229,7 +231,2 @@\n-\n-\/\/ Parameter in_flight_mutex_addr is only used by class Mutex to avoid certain deadlock\n-\/\/ scenarios while making transitions that might block for a safepoint or handshake.\n-\/\/ It's the address of a pointer to the mutex we are trying to acquire. This will be used to\n-\/\/ access and release said mutex when transitioning back from blocked to vm (destructor) in\n-\/\/ case we need to stop for a safepoint or handshake.\n-class ThreadBlockInVM : public ThreadStateTransition {\n+template <typename PRE_PROC>\n+class ThreadBlockInVMPreprocess : public ThreadStateTransition {\n@@ -237,2 +234,1 @@\n-  Mutex** _in_flight_mutex_addr;\n-\n+  PRE_PROC& _pr;\n@@ -240,2 +236,1 @@\n-  ThreadBlockInVM(JavaThread* thread, Mutex** in_flight_mutex_addr = NULL)\n-  : ThreadStateTransition(thread), _in_flight_mutex_addr(in_flight_mutex_addr) {\n+  ThreadBlockInVMPreprocess(JavaThread* thread, PRE_PROC& pr) : ThreadStateTransition(thread), _pr(pr) {\n@@ -248,1 +243,1 @@\n-  ~ThreadBlockInVM() {\n+  ~ThreadBlockInVMPreprocess() {\n@@ -254,3 +249,1 @@\n-      if (_in_flight_mutex_addr != NULL) {\n-        release_mutex();\n-      }\n+      _pr(_thread);\n@@ -262,0 +255,1 @@\n+};\n@@ -263,4 +257,8 @@\n-  void release_mutex() {\n-    Mutex* in_flight_mutex = *_in_flight_mutex_addr;\n-    if (in_flight_mutex != NULL) {\n-      in_flight_mutex->release_for_safepoint();\n+class InFlightMutexRelease {\n+ private:\n+  Mutex** _in_flight_mutex_addr;\n+ public:\n+  InFlightMutexRelease(Mutex** in_flight_mutex_addr) : _in_flight_mutex_addr(in_flight_mutex_addr) {}\n+  void operator()(JavaThread* current) {\n+    if (_in_flight_mutex_addr != NULL && *_in_flight_mutex_addr != NULL) {\n+      (*_in_flight_mutex_addr)->release_for_safepoint();\n@@ -272,0 +270,13 @@\n+\/\/ Parameter in_flight_mutex_addr is only used by class Mutex to avoid certain deadlock\n+\/\/ scenarios while making transitions that might block for a safepoint or handshake.\n+\/\/ It's the address of a pointer to the mutex we are trying to acquire. This will be used to\n+\/\/ access and release said mutex when transitioning back from blocked to vm (destructor) in\n+\/\/ case we need to stop for a safepoint or handshake.\n+class ThreadBlockInVM {\n+  InFlightMutexRelease _ifmr;\n+  ThreadBlockInVMPreprocess<InFlightMutexRelease> _tbivmpp;\n+ public:\n+  ThreadBlockInVM(JavaThread* thread, Mutex** in_flight_mutex_addr = NULL)\n+    : _ifmr(in_flight_mutex_addr), _tbivmpp(thread, _ifmr) {}\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":31,"deletions":20,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -310,0 +310,20 @@\n+void ObjectMonitor::ExitOnSuspend::operator()(JavaThread* current) {\n+  if (current->is_suspended()) {\n+    _om->_recursions = 0;\n+    _om->_succ = NULL;\n+    \/\/ Don't need a full fence after clearing successor here because of the call to exit().\n+    _om->exit(current, false \/* not_suspended *\/);\n+    _om_op_done = true;\n+  }\n+}\n+\n+void ObjectMonitor::ClearSuccOnSuspend::operator()(JavaThread* current) {\n+  if (current->is_suspended()) {\n+    if (_om->_succ == current) {\n+      _om->_succ = NULL;\n+      OrderAccess::fence(); \/\/ always do a full fence when successor is cleared\n+    }\n+    _om_op_done = true;\n+  }\n+}\n+\n@@ -409,4 +429,0 @@\n-    current->frame_anchor()->make_walkable(current);\n-    \/\/ Thread must be walkable before it is blocked.\n-    \/\/ Read in reverse order.\n-    OrderAccess::storestore();\n@@ -414,17 +430,8 @@\n-      current->set_thread_state(_thread_blocked);\n-      EnterI(current);\n-      current->set_thread_state_fence(_thread_blocked_trans);\n-      if (SafepointMechanism::should_process(current) &&\n-        current->is_suspended()) {\n-        \/\/ We have acquired the contended monitor, but while we were\n-        \/\/ waiting another thread suspended us. We don't want to enter\n-        \/\/ the monitor while suspended because that would surprise the\n-        \/\/ thread that suspended us.\n-        _recursions = 0;\n-        _succ = NULL;\n-        \/\/ Don't need a full fence after clearing successor here because of the call to exit().\n-        exit(current, false \/* not_suspended *\/);\n-        SafepointMechanism::process_if_requested(current);\n-        \/\/ Since we are going to _thread_blocked we skip setting _thread_in_vm here.\n-      } else {\n-        \/\/ Only exit path from for loop\n+      ExitOnSuspend eos(this);\n+      {\n+        ThreadBlockInVMPreprocess<ExitOnSuspend> tbivs(current, eos);\n+        EnterI(current);\n+      }\n+      if (!eos.om_op_done()) {\n+        \/\/ ExitOnSuspend did not exit the OM\n+        assert(owner_raw() == current, \"invariant\");\n@@ -446,3 +453,0 @@\n-    \/\/ Completed the tranisition.\n-    SafepointMechanism::process_if_requested(current);\n-    current->set_thread_state(_thread_in_vm);\n@@ -972,13 +976,4 @@\n-      current->frame_anchor()->make_walkable(current);\n-      \/\/ Thread must be walkable before it is blocked.\n-      \/\/ Read in reverse order.\n-      OrderAccess::storestore();\n-      current->set_thread_state(_thread_blocked);\n-      current->_ParkEvent->park();\n-      current->set_thread_state_fence(_thread_blocked_trans);\n-      if (SafepointMechanism::should_process(current)) {\n-        if (_succ == current) {\n-            _succ = NULL;\n-            OrderAccess::fence(); \/\/ always do a full fence when successor is cleared\n-        }\n-        SafepointMechanism::process_if_requested(current);\n+      {\n+        ClearSuccOnSuspend csos(this);\n+        ThreadBlockInVMPreprocess<ClearSuccOnSuspend> tbivs(current, csos);\n+        current->_ParkEvent->park();\n@@ -986,1 +981,0 @@\n-      current->set_thread_state(_thread_in_vm);\n@@ -1544,5 +1538,2 @@\n-      current->frame_anchor()->make_walkable(current);\n-      \/\/ Thread must be walkable before it is blocked.\n-      \/\/ Read in reverse order.\n-      OrderAccess::storestore();\n-      current->set_thread_state(_thread_blocked);\n+      ClearSuccOnSuspend csos(this);\n+      ThreadBlockInVMPreprocess<ClearSuccOnSuspend> tbivs(current, csos);\n@@ -1558,9 +1549,0 @@\n-      current->set_thread_state_fence(_thread_blocked_trans);\n-      if (SafepointMechanism::should_process(current)) {\n-        if (_succ == current) {\n-            _succ = NULL;\n-            OrderAccess::fence(); \/\/ always do a full fence when successor is cleared\n-        }\n-        SafepointMechanism::process_if_requested(current);\n-      }\n-      current->set_thread_state(_thread_in_vm);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":34,"deletions":52,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -305,0 +305,16 @@\n+ private:\n+  class ExitOnSuspend {\n+   protected:\n+    ObjectMonitor* _om;\n+    bool _om_op_done;\n+   public:\n+    ExitOnSuspend(ObjectMonitor* om) : _om(om), _om_op_done(false) {}\n+    void operator()(JavaThread* current);\n+    bool om_op_done() { return _om_op_done; }\n+  };\n+  class ClearSuccOnSuspend : public ExitOnSuspend {\n+   public:\n+    ClearSuccOnSuspend(ObjectMonitor* om) : ExitOnSuspend(om) {}\n+    void operator()(JavaThread* current);\n+  };\n+ public:\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"}]}