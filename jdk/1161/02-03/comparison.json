{"files":[{"patch":"@@ -1509,19 +1509,0 @@\n-static size_t actual_reserved_page_size(ReservedSpace rs) {\n-  size_t page_size = os::vm_page_size();\n-  if (UseLargePages) {\n-    \/\/ There are two ways to manage large page memory.\n-    \/\/ 1. OS supports committing large page memory.\n-    \/\/ 2. OS doesn't support committing large page memory so ReservedSpace manages it.\n-    \/\/    And ReservedSpace calls it 'special'. If we failed to set 'special',\n-    \/\/    we reserved memory without large page.\n-    if (os::can_commit_large_page_memory() || rs.special()) {\n-      \/\/ An alignment at ReservedSpace comes from preferred page size or\n-      \/\/ heap alignment, and if the alignment came from heap alignment, it could be\n-      \/\/ larger than large pages size. So need to cap with the large page size.\n-      page_size = MIN2(rs.alignment(), os::large_page_size());\n-    }\n-  }\n-\n-  return page_size;\n-}\n-\n@@ -1534,1 +1515,1 @@\n-  size_t page_size = actual_reserved_page_size(rs);\n+  size_t page_size = ReservedSpace::actual_reserved_page_size(rs);\n@@ -1626,1 +1607,1 @@\n-  size_t page_size = actual_reserved_page_size(heap_rs);\n+  size_t page_size = ReservedSpace::actual_reserved_page_size(heap_rs);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":2,"deletions":21,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-void ParallelInitLogger::print_gc_specific() {\n+void ParallelInitLogger::print_heap() {\n@@ -32,8 +32,8 @@\n-                     \" space_align=\" SIZE_FORMAT \"%s\"\n-                     \" gen_align=\" SIZE_FORMAT \"%s\"\n-                     \" heap_align=\" SIZE_FORMAT \"%s\",\n-                     byte_size_in_exact_unit(SpaceAlignment), exact_unit_for_byte_size(SpaceAlignment),\n-                     byte_size_in_exact_unit(GenAlignment), exact_unit_for_byte_size(GenAlignment),\n-                     byte_size_in_exact_unit(HeapAlignment), exact_unit_for_byte_size(HeapAlignment)\n-                     );\n-  GCInitLogger::print_gc_specific();\n+                       \" Space \" SIZE_FORMAT \"%s,\"\n+                       \" Generation \" SIZE_FORMAT \"%s,\"\n+                       \" Heap \" SIZE_FORMAT \"%s\",\n+                       byte_size_in_exact_unit(SpaceAlignment), exact_unit_for_byte_size(SpaceAlignment),\n+                       byte_size_in_exact_unit(GenAlignment), exact_unit_for_byte_size(GenAlignment),\n+                       byte_size_in_exact_unit(HeapAlignment), exact_unit_for_byte_size(HeapAlignment)\n+                       );\n+  GCInitLogger::print_heap();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelInitLogger.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-  virtual void print_gc_specific();\n+  virtual void print_heap();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelInitLogger.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -678,14 +678,1 @@\n-    size_t page_size = os::vm_page_size();\n-    if (UseLargePages) {\n-      \/\/ There are two ways to manage large page memory.\n-      \/\/ 1. OS supports committing large page memory.\n-      \/\/ 2. OS doesn't support committing large page memory so ReservedSpace manages it.\n-      \/\/    And ReservedSpace calls it 'special'. If we failed to set 'special',\n-      \/\/    we reserved memory without large page.\n-      if (os::can_commit_large_page_memory() || rs.special()) {\n-        \/\/ An alignment at ReservedSpace comes from preferred page size or\n-        \/\/ heap alignment, and if the alignment came from heap alignment, it could be\n-        \/\/ larger than large pages size. So need to cap with the large page size.\n-        page_size = MIN2(rs.alignment(), os::large_page_size());\n-      }\n-    }\n+    const size_t page_size = ReservedSpace::actual_reserved_page_size(rs);\n@@ -693,5 +680,5 @@\n-                        MinHeapSize,\n-                        reserved_heap_size,\n-                        page_size,\n-                        rs.base(),\n-                        rs.size());\n+                         MinHeapSize,\n+                         reserved_heap_size,\n+                         page_size,\n+                         rs.base(),\n+                         rs.size());\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":6,"deletions":19,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -264,0 +264,18 @@\n+size_t ReservedSpace::actual_reserved_page_size(const ReservedSpace& rs) {\n+  size_t page_size = os::vm_page_size();\n+  if (UseLargePages) {\n+    \/\/ There are two ways to manage large page memory.\n+    \/\/ 1. OS supports committing large page memory.\n+    \/\/ 2. OS doesn't support committing large page memory so ReservedSpace manages it.\n+    \/\/    And ReservedSpace calls it 'special'. If we failed to set 'special',\n+    \/\/    we reserved memory without large page.\n+    if (os::can_commit_large_page_memory() || rs.special()) {\n+      \/\/ An alignment at ReservedSpace comes from preferred page size or\n+      \/\/ heap alignment, and if the alignment came from heap alignment, it could be\n+      \/\/ larger than large pages size. So need to cap with the large page size.\n+      page_size = MIN2(rs.alignment(), os::large_page_size());\n+    }\n+  }\n+\n+  return page_size;\n+}\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -99,0 +99,2 @@\n+\n+  static size_t actual_reserved_page_size(const ReservedSpace& rs);\n","filename":"src\/hotspot\/share\/memory\/virtualspace.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}