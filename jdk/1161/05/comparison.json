{"files":[{"patch":"@@ -1479,19 +1479,0 @@\n-static size_t actual_reserved_page_size(ReservedSpace rs) {\n-  size_t page_size = os::vm_page_size();\n-  if (UseLargePages) {\n-    \/\/ There are two ways to manage large page memory.\n-    \/\/ 1. OS supports committing large page memory.\n-    \/\/ 2. OS doesn't support committing large page memory so ReservedSpace manages it.\n-    \/\/    And ReservedSpace calls it 'special'. If we failed to set 'special',\n-    \/\/    we reserved memory without large page.\n-    if (os::can_commit_large_page_memory() || rs.special()) {\n-      \/\/ An alignment at ReservedSpace comes from preferred page size or\n-      \/\/ heap alignment, and if the alignment came from heap alignment, it could be\n-      \/\/ larger than large pages size. So need to cap with the large page size.\n-      page_size = MIN2(rs.alignment(), os::large_page_size());\n-    }\n-  }\n-\n-  return page_size;\n-}\n-\n@@ -1504,1 +1485,1 @@\n-  size_t page_size = actual_reserved_page_size(rs);\n+  size_t page_size = ReservedSpace::actual_reserved_page_size(rs);\n@@ -1596,1 +1577,1 @@\n-  size_t page_size = actual_reserved_page_size(heap_rs);\n+  size_t page_size = ReservedSpace::actual_reserved_page_size(heap_rs);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":2,"deletions":21,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/parallel\/parallelInitLogger.hpp\"\n+#include \"gc\/shared\/genArguments.hpp\"\n+#include \"gc\/shared\/gcLogPrecious.hpp\"\n+\n+void ParallelInitLogger::print_heap() {\n+  log_info_p(gc, init)(\"Alignments:\"\n+                       \" Space \" SIZE_FORMAT \"%s,\"\n+                       \" Generation \" SIZE_FORMAT \"%s,\"\n+                       \" Heap \" SIZE_FORMAT \"%s\",\n+                       byte_size_in_exact_unit(SpaceAlignment), exact_unit_for_byte_size(SpaceAlignment),\n+                       byte_size_in_exact_unit(GenAlignment), exact_unit_for_byte_size(GenAlignment),\n+                       byte_size_in_exact_unit(HeapAlignment), exact_unit_for_byte_size(HeapAlignment));\n+  GCInitLogger::print_heap();\n+}\n+\n+void ParallelInitLogger::print() {\n+  ParallelInitLogger init_log;\n+  init_log.print_all();\n+}\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelInitLogger.cpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_PARALLEL_PARALLELINITLOGGER_HPP\n+#define SHARE_GC_PARALLEL_PARALLELINITLOGGER_HPP\n+\n+#include \"gc\/shared\/gcInitLogger.hpp\"\n+\n+class ParallelInitLogger : public GCInitLogger {\n+ protected:\n+  virtual void print_heap();\n+ public:\n+  static void print();\n+};\n+\n+#endif \/\/SHARE_GC_PARALLEL_PARALLELINITLOGGER_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelInitLogger.hpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/parallel\/parallelInitLogger.hpp\"\n@@ -66,6 +67,1 @@\n-  os::trace_page_sizes(\"Heap\",\n-                       MinHeapSize,\n-                       reserved_heap_size,\n-                       GenAlignment,\n-                       heap_rs.base(),\n-                       heap_rs.size());\n+  trace_actual_reserved_page_size(reserved_heap_size, heap_rs);\n@@ -136,1 +132,1 @@\n-  GCInitLogger::print();\n+  ParallelInitLogger::print();\n@@ -742,0 +738,13 @@\n+void ParallelScavengeHeap::trace_actual_reserved_page_size(const size_t reserved_heap_size, const ReservedSpace rs) {\n+  \/\/ Check if Info level is enabled, since os::trace_page_sizes() logs on Info level.\n+  if(log_is_enabled(Info, pagesize)) {\n+    const size_t page_size = ReservedSpace::actual_reserved_page_size(rs);\n+    os::trace_page_sizes(\"Heap\",\n+                         MinHeapSize,\n+                         reserved_heap_size,\n+                         page_size,\n+                         rs.base(),\n+                         rs.size());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  void trace_actual_reserved_page_size(const size_t reserved_heap_size, const ReservedSpace rs);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -289,0 +289,18 @@\n+size_t ReservedSpace::actual_reserved_page_size(const ReservedSpace& rs) {\n+  size_t page_size = os::vm_page_size();\n+  if (UseLargePages) {\n+    \/\/ There are two ways to manage large page memory.\n+    \/\/ 1. OS supports committing large page memory.\n+    \/\/ 2. OS doesn't support committing large page memory so ReservedSpace manages it.\n+    \/\/    And ReservedSpace calls it 'special'. If we failed to set 'special',\n+    \/\/    we reserved memory without large page.\n+    if (os::can_commit_large_page_memory() || rs.special()) {\n+      \/\/ An alignment at ReservedSpace comes from preferred page size or\n+      \/\/ heap alignment, and if the alignment came from heap alignment, it could be\n+      \/\/ larger than large pages size. So need to cap with the large page size.\n+      page_size = MIN2(rs.alignment(), os::large_page_size());\n+    }\n+  }\n+\n+  return page_size;\n+}\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -99,0 +99,2 @@\n+\n+  static size_t actual_reserved_page_size(const ReservedSpace& rs);\n","filename":"src\/hotspot\/share\/memory\/virtualspace.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}