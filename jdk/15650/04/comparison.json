{"files":[{"patch":"@@ -1223,0 +1223,2 @@\n+            int elen = CENEXT(cen, pos);\n+            int clen = CENCOM(cen, pos);\n@@ -1227,1 +1229,0 @@\n-            int elen = CENEXT(cen, pos);\n@@ -1234,0 +1235,5 @@\n+            } else if (elen == 0 && (CENSIZ(cen, pos) == ZIP64_MAGICVAL\n+                    || CENLEN(cen, pos) == ZIP64_MAGICVAL\n+                    || CENOFF(cen, pos) == ZIP64_MAGICVAL\n+                    || CENDSK(cen, pos) == ZIP64_MAGICCOUNT)) {\n+                zerror(\"Invalid CEN header (invalid zip64 extra len size)\");\n@@ -1246,2 +1252,2 @@\n-                \/\/ Validate comment if it exists\n-                \/\/ if the bytes representing the comment cannot be converted to\n+                \/\/ Validate comment if it exists.\n+                \/\/ If the bytes representing the comment cannot be converted to\n@@ -1249,1 +1255,0 @@\n-                int clen = CENCOM(cen, pos);\n@@ -1262,0 +1267,1 @@\n+         * @param cenPos The CEN offset for the current Entry\n@@ -1276,1 +1282,1 @@\n-            if (extraEndOffset > cen.length) {\n+            if (extraEndOffset > cen.length - ENDHDR) {\n@@ -1305,0 +1311,2 @@\n+                    \/\/ Get the LOC offset\n+                    long locoff = CENOFF(cen, cenPos);\n@@ -1307,1 +1315,1 @@\n-                            csize, size);\n+                            csize, size, locoff);\n@@ -1315,4 +1323,5 @@\n-         * size and that the uncompressed size and compressed size field\n-         * values are not negative.\n-         * Note:  As we do not use the LOC offset or Starting disk number\n-         * field value we will not validate them\n+         * size; that the uncompressed size, compressed size field and LOC\n+         * offset fields are not negative. Also make sure the field exists if\n+         * the CEN header field is set to 0xFFFFFFFF.\n+         * Note:  As we do not use the Starting disk number field,\n+         * we will not validate its value\n@@ -1323,0 +1332,1 @@\n+         * @param locoff CEN header LOC offset\n@@ -1326,1 +1336,1 @@\n-                                                long size)\n+                                                long size, long locoff)\n@@ -1333,1 +1343,2 @@\n-                if (csize == ZIP64_MAGICVAL || size == ZIP64_MAGICVAL) {\n+                if (csize == ZIP64_MAGICVAL || size == ZIP64_MAGICVAL ||\n+                        locoff == ZIP64_MAGICVAL) {\n@@ -1345,6 +1356,9 @@\n-            \/\/ Note we do not need to check blockSize is >= 8 as\n-            \/\/ we know its length is at least 8 from the call to\n-            \/\/ isZip64ExtBlockSizeValid()\n-            if ((size == ZIP64_MAGICVAL)) {\n-                if(get64(cen, off) < 0) {\n-                    zerror(\"Invalid zip64 extra block size value\");\n+            if (size == ZIP64_MAGICVAL) {\n+                if ( blockSize >= Long.BYTES) {\n+                    if (get64(cen, off) < 0) {\n+                        zerror(\"Invalid zip64 extra block size value\");\n+                    }\n+                    off += Long.BYTES;\n+                    blockSize -= Long.BYTES;\n+                } else {\n+                    zerror(\"Invalid Zip64 extra block, missing size\");\n@@ -1354,3 +1368,23 @@\n-            if ((csize == ZIP64_MAGICVAL) && (blockSize >= 16)) {\n-                if (get64(cen, off + 8) < 0) {\n-                    zerror(\"Invalid zip64 extra block compressed size value\");\n+            if (csize == ZIP64_MAGICVAL) {\n+                if (blockSize >= Long.BYTES) {\n+                    if (get64(cen, off) < 0) {\n+                        zerror(\"Invalid zip64 extra block compressed size value\");\n+                    }\n+                    off += Long.BYTES;\n+                    blockSize -= Long.BYTES;\n+                } else {\n+                    zerror(\"Invalid Zip64 extra block, missing compressed size\");\n+                }\n+            }\n+            \/\/ Check the LOC offset is not negative\n+            if (locoff == ZIP64_MAGICVAL) {\n+                if (blockSize >= Long.BYTES) {\n+                    if (get64(cen, off) < 0) {\n+                        zerror(\"Invalid zip64 extra block LOC OFFSET value\");\n+                    }\n+                    \/\/ Note: We do not need to adjust the following fields as\n+                    \/\/ this is the last field we are leveraging\n+                    \/\/ off += Long.BYTES;\n+                    \/\/ blockSize -= Long.BYTES;\n+                } else {\n+                    zerror(\"Invalid Zip64 extra block, missing LOC offset value\");\n@@ -1381,2 +1415,2 @@\n-             * 24 - uncompressed size, compressed sise, LOC Header offset\n-             * 28 - uncompressed size, compressed sise, LOC Header offset,\n+             * 24 - uncompressed size, compressed size, LOC Header offset\n+             * 28 - uncompressed size, compressed size, LOC Header offset,\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":57,"deletions":23,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -1586,0 +1586,4 @@\n+            long csize = CENSIZ(cen, pos);\n+            long size  = CENLEN(cen, pos);\n+            long locoff = CENOFF(cen, pos);\n+            int diskNo = CENDSK(cen, pos);\n@@ -1595,0 +1599,7 @@\n+            if (elen > 0) {\n+                checkExtraFields(cen, pos, size, csize, locoff,\n+                        pos + CENHDR + nlen, elen);\n+            } else if (elen == 0 && (size == ZIP64_MINVAL || csize == ZIP64_MINVAL ||\n+                    locoff == ZIP64_MINVAL || diskNo == ZIP64_MINVAL32)) {\n+                throw new ZipException(\"Invalid CEN header (invalid zip64 extra len size)\");\n+            }\n@@ -1616,0 +1627,157 @@\n+    \/**\n+     * Validate the Zip64 Extra block fields\n+     * @param cen CEN array\n+     * @param cenPos starting offset in the CEN for the Extra field\n+     * @param size CEN size value\n+     * @param csize CEN csize value\n+     * @param locoff CEN LOC offset value\n+     * @param startingOffset Extra Field starting offset within the CEN\n+     * @param extraFieldLen Length of this Extra field\n+     * @throws ZipException  If an error occurs validating the Zip64 Extra\n+     * block\n+     *\/\n+    private void checkExtraFields( byte[] cen, int cenPos, long size, long csize,\n+                                   long locoff, int startingOffset,\n+                                   int extraFieldLen) throws ZipException {\n+        \/\/ Extra field Length cannot exceed 65,535 bytes per the PKWare\n+        \/\/ APP.note 4.4.11\n+        if (extraFieldLen > 0xFFFF) {\n+            zerror(\"invalid extra field length\");\n+        }\n+        \/\/ CEN Offset where this Extra field ends\n+        int extraEndOffset = startingOffset + extraFieldLen;\n+        if (extraEndOffset > cen.length - ENDHDR) {\n+            zerror(\"Invalid CEN header (extra data field size too long)\");\n+        }\n+        int currentOffset = startingOffset;\n+        \/\/ Walk through each Extra Header. Each Extra Header Must consist of:\n+        \/\/       Header ID - 2 bytes\n+        \/\/       Data Size - 2 bytes:\n+        while (currentOffset + Integer.BYTES <= extraEndOffset) {\n+            int tag = SH(cen, currentOffset);\n+            currentOffset += Short.BYTES;\n+\n+            int tagBlockSize = SH(cen, currentOffset);\n+            currentOffset += Short.BYTES;\n+            int tagBlockEndingOffset = currentOffset + tagBlockSize;\n+\n+            \/\/  The ending offset for this tag block should not go past the\n+            \/\/  offset for the end of the extra field\n+            if (tagBlockEndingOffset > extraEndOffset) {\n+                zerror(String.format(\n+                        \"Invalid CEN header (invalid extra data field size for \" +\n+                                \"tag: 0x%04x at %d)\",\n+                        tag, cenPos));\n+            }\n+\n+            if (tag == EXTID_ZIP64) {\n+                checkZip64ExtraFieldValues(cen, currentOffset, tagBlockSize,\n+                        csize, size, locoff);\n+            }\n+            currentOffset += tagBlockSize;\n+        }\n+    }\n+\n+    \/**\n+     * Validate the Zip64 Extended Information Extra Field (0x0001) block\n+     * size; that the uncompressed size, compressed size field and LOC\n+     * offset fields are not negative. Also make sure the field exists if\n+     * the CEN header field is set to 0xFFFFFFFF.\n+     * Note:  As we do not use the Starting disk number field,\n+     * we will not validate its value\n+     * @param cen CEN array\n+     * @param off the starting offset for the Zip64 field value\n+     * @param blockSize the size of the Zip64 Extended Extra Field\n+     * @param csize CEN header compressed size value\n+     * @param size CEN header uncompressed size value\n+     * @param locoff CEN header LOC offset\n+     * @throws ZipException if an error occurs\n+     *\/\n+    private void checkZip64ExtraFieldValues(byte[] cen, int off, int blockSize, long csize,\n+                                            long size, long locoff)\n+            throws ZipException {\n+        \/\/ if ZIP64_EXTID blocksize == 0, which may occur with some older\n+        \/\/ versions of Apache Ant and Commons Compress, validate csize and size\n+        \/\/ to make sure neither field == ZIP64_MAGICVAL\n+        if (blockSize == 0) {\n+            if (csize == ZIP64_MINVAL || size == ZIP64_MINVAL ||\n+                    locoff == ZIP64_MINVAL) {\n+                zerror(\"Invalid CEN header (invalid zip64 extra data field size)\");\n+            }\n+            \/\/ Only validate the ZIP64_EXTID data if the block size > 0\n+            return;\n+        }\n+        \/\/ Validate the Zip64 Extended Information Extra Field (0x0001)\n+        \/\/ length.\n+        if (!isZip64ExtBlockSizeValid(blockSize)) {\n+            zerror(\"Invalid CEN header (invalid zip64 extra data field size)\");\n+        }\n+        \/\/ Check the uncompressed size is not negative\n+        if (size == ZIP64_MINVAL) {\n+            if (blockSize >= Long.BYTES) {\n+                if (LL(cen, off) < 0) {\n+                    zerror(\"Invalid zip64 extra block size value\");\n+                }\n+                off += Long.BYTES;\n+                blockSize -= Long.BYTES;\n+            } else {\n+                zerror(\"Invalid Zip64 extra block, missing size\");\n+            }\n+        }\n+        \/\/ Check the compressed size is not negative\n+        if (csize == ZIP64_MINVAL) {\n+            if (blockSize >= Long.BYTES) {\n+                if (LL(cen, off) < 0) {\n+                    zerror(\"Invalid zip64 extra block compressed size value\");\n+                }\n+                off += Long.BYTES;\n+                blockSize -= Long.BYTES;\n+            } else {\n+                zerror(\"Invalid Zip64 extra block, missing compressed size\");\n+            }\n+        }\n+        \/\/ Check the LOC offset is not negative\n+        if (locoff == ZIP64_MINVAL) {\n+            if (blockSize >= Long.BYTES) {\n+                if (LL(cen, off) < 0) {\n+                    zerror(\"Invalid zip64 extra block LOC OFFSET value\");\n+                }\n+                \/\/ Note: We do not need to adjust the following fields as\n+                \/\/ this is the last field we are leveraging\n+                \/\/ off += Long.BYTES;\n+                \/\/ blockSize -= Long.BYTES;\n+            } else {\n+                zerror(\"Invalid Zip64 extra block, missing LOC offset value\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Validate the size and contents of a Zip64 extended information field\n+     * The order of the Zip64 fields is fixed, but the fields MUST\n+     * only appear if the corresponding LOC or CEN field is set to 0xFFFF:\n+     * or 0xFFFFFFFF:\n+     * Uncompressed Size - 8 bytes\n+     * Compressed Size   - 8 bytes\n+     * LOC Header offset - 8 bytes\n+     * Disk Start Number - 4 bytes\n+     * See PKWare APP.Note Section 4.5.3 for more details\n+     *\n+     * @param blockSize the Zip64 Extended Information Extra Field size\n+     * @return true if the extra block size is valid; false otherwise\n+     *\/\n+    private static boolean isZip64ExtBlockSizeValid(int blockSize) {\n+        \/*\n+         * As the fields must appear in order, the block size indicates which\n+         * fields to expect:\n+         *  8 - uncompressed size\n+         * 16 - uncompressed size, compressed size\n+         * 24 - uncompressed size, compressed sise, LOC Header offset\n+         * 28 - uncompressed size, compressed sise, LOC Header offset,\n+         * and Disk start number\n+         *\/\n+        return switch(blockSize) {\n+            case 8, 16, 24, 28 -> true;\n+            default -> false;\n+        };\n+    }\n@@ -1635,0 +1803,4 @@\n+    private static void zerror(String msg) throws ZipException {\n+        throw new ZipException(msg);\n+    }\n+\n@@ -1643,1 +1815,0 @@\n-\n@@ -2823,0 +2994,1 @@\n+            int diskNo  = CENDSK(cen, pos);\n@@ -2825,1 +2997,0 @@\n-            disk        = CENDSK(cen, pos);\n@@ -2843,0 +3014,3 @@\n+            } else if (elen == 0 && (size == ZIP64_MINVAL || csize == ZIP64_MINVAL\n+                    || locoff == ZIP64_MINVAL || diskNo == ZIP64_MINVAL32)) {\n+                throw new ZipException(\"Invalid CEN header (invalid zip64 extra len size)\");\n@@ -3092,1 +3266,1 @@\n-            while (off + 4 < elen) {\n+            while (off + 4 <= elen) {\n@@ -3105,14 +3279,1 @@\n-                case EXTID_ZIP64 :\n-                    \/\/ if ZIP64_EXTID blocksize == 0, which may occur with some older\n-                    \/\/ versions of Apache Ant and Commons Compress, validate csize\n-                    \/\/ size, and locoff to make sure the fields != ZIP64_MAGICVAL\n-                    if (sz == 0) {\n-                        if (csize == ZIP64_MINVAL || size == ZIP64_MINVAL || locoff == ZIP64_MINVAL) {\n-                            throw new ZipException(\"Invalid CEN header (invalid zip64 extra data field size)\");\n-                        }\n-                        break;\n-                    }\n-                    \/\/ Check to see if we have a valid block size\n-                    if (!isZip64ExtBlockSizeValid(sz)) {\n-                        throw new ZipException(\"Invalid CEN header (invalid zip64 extra data field size)\");\n-                    }\n+                case EXTID_ZIP64:\n@@ -3172,2 +3333,2 @@\n-                    \/\/ LOC offset from the EXTID_ZIP64 extra data. Therefore\n-                    \/\/ wait until all of the CEN extra data fields have been processed\n+                    \/\/ LOC offset from the EXTID_ZIP64 extra data. Therefore,\n+                    \/\/ wait until all the CEN extra data fields have been processed\n@@ -3201,30 +3362,0 @@\n-        \/**\n-         * Validate the size and contents of a Zip64 extended information field\n-         * The order of the Zip64 fields is fixed, but the fields MUST\n-         * only appear if the corresponding LOC or CEN field is set to 0xFFFF:\n-         * or 0xFFFFFFFF:\n-         * Uncompressed Size - 8 bytes\n-         * Compressed Size   - 8 bytes\n-         * LOC Header offset - 8 bytes\n-         * Disk Start Number - 4 bytes\n-         * See PKWare APP.Note Section 4.5.3 for more details\n-         *\n-         * @param blockSize the Zip64 Extended Information Extra Field size\n-         * @return true if the extra block size is valid; false otherwise\n-         *\/\n-        private static boolean isZip64ExtBlockSizeValid(int blockSize) {\n-            \/*\n-             * As the fields must appear in order, the block size indicates which\n-             * fields to expect:\n-             *  8 - uncompressed size\n-             * 16 - uncompressed size, compressed size\n-             * 24 - uncompressed size, compressed sise, LOC Header offset\n-             * 28 - uncompressed size, compressed sise, LOC Header offset,\n-             * and Disk start number\n-             *\/\n-            return switch(blockSize) {\n-                case 8, 16, 24, 28 -> true;\n-                default -> false;\n-            };\n-        }\n-\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java","additions":180,"deletions":49,"binary":false,"changes":229,"status":"modified"},{"patch":"@@ -0,0 +1,820 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HexFormat;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipFile;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/* @test\n+ * @bug 8314891\n+ * @summary Validate that a ZipException is thrown when the extra len is 0\n+ * and the CEN size, csize,LOC offset fields are set to 0xFFFFFFFF, the disk\n+ * starting number is set to 0xFFFF or when we have a valid Zip64 Extra header\n+ * size but missing the expected header fields.\n+ * @run junit MissingZIP64EntriesTest\n+ *\/\n+public class MissingZIP64EntriesTest {\n+\n+    \/*\n+     * Byte array representing a ZIP file which contains a\n+     * Zip64 Extra Header with only the size field.\n+     *  ----------------#1--------------------\n+     *  [Central Directory Header]\n+     *    0x4d: Signature        : 0x02014b50\n+     *    0x51: Created Zip Spec :       0x2d [4.5]\n+     *    0x52: Created OS       :        0x0 [MS-DOS]\n+     *    0x53: VerMadeby        :       0x2d [0, 4.5]\n+     *    0x54: VerExtract       :       0x2d [4.5]\n+     *    0x55: Flag             :      0x808\n+     *    0x57: Method           :        0x8 [DEFLATED]\n+     *    0x59: Last Mod Time    : 0x57116922 [Thu Aug 17 13:09:04 EDT 2023]\n+     *    0x5d: CRC              : 0x57de98d2\n+     *    0x61: Compressed Size  :       0x16\n+     *    0x65: Uncompressed Size: 0xffffffff\n+     *    0x69: Name Length      :        0x9\n+     *    0x6b: Extra Length     :        0xc\n+     *        Extra data:[01, 00, 08, 00, 14, 00, 00, 00, 00, 00, 00, 00]\n+     *           [tag=0x0001, sz=8]\n+     *               ->ZIP64: size *0x14\n+     *           [data= 14 00 00 00 00 00 00 00 ]\n+     *    0x6d: Comment Length   :        0x0\n+     *    0x6f: Disk Start       :        0x0\n+     *    0x71: Attrs            :        0x0\n+     *    0x73: AttrsEx          :        0x0\n+     *    0x77: Loc Header Offset:        0x0\n+     *    0x7b: File Name        : Hello.txt\n+     *\/\n+    public static byte[] ZIP_WITH_ZIP64_EXTRAHDR_SIZE_ONLY_BYTEARRAY = {\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4, (byte) 0x14, (byte) 0x0, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x8, (byte) 0x0, (byte) 0x22, (byte) 0x69, (byte) 0x11, (byte) 0x57, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x9, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x48, (byte) 0x65,\n+            (byte) 0x6c, (byte) 0x6c, (byte) 0x6f, (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0xf3,\n+            (byte) 0x48, (byte) 0xcd, (byte) 0xc9, (byte) 0xc9, (byte) 0x57, (byte) 0x8, (byte) 0x49, (byte) 0xcd,\n+            (byte) 0xcb, (byte) 0xcb, (byte) 0x2c, (byte) 0x56, (byte) 0x8, (byte) 0xc8, (byte) 0x49, (byte) 0xac,\n+            (byte) 0x4c, (byte) 0x2d, (byte) 0x2a, (byte) 0x6, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x7,\n+            (byte) 0x8, (byte) 0xd2, (byte) 0x98, (byte) 0xde, (byte) 0x57, (byte) 0x16, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x1,\n+            (byte) 0x2, (byte) 0x2d, (byte) 0x0, (byte) 0x2d, (byte) 0x0, (byte) 0x8, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x0, (byte) 0x22, (byte) 0x69, (byte) 0x11, (byte) 0x57, (byte) 0xd2, (byte) 0x98, (byte) 0xde,\n+            (byte) 0x57, (byte) 0x16, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n+            (byte) 0xff, (byte) 0x9, (byte) 0x0, (byte) 0xc, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x48, (byte) 0x65, (byte) 0x6c, (byte) 0x6c, (byte) 0x6f,\n+            (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0x1, (byte) 0x0, (byte) 0x8, (byte) 0x0,\n+            (byte) 0x14, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x5, (byte) 0x6, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x1, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x43, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x4d, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+    };\n+\n+    \/**\n+     * Byte array representing a Zip file with no extra header fields\n+     * ----------------#1--------------------\n+     * [Central Directory Header]\n+     *       0x2f: Signature        : 0x02014b50\n+     *       0x33: Created Zip Spec :       0x14 [2.0]\n+     *       0x34: Created OS       :        0x3 [UNIX]\n+     *       0x35: VerMadeby        :      0x314 [3, 2.0]\n+     *       0x36: VerExtract       :       0x14 [2.0]\n+     *       0x37: Flag             :        0x2\n+     *       0x39: Method           :        0x8 [DEFLATED]\n+     *       0x3b: Last Mod Time    : 0x57039c0d [Thu Aug 03 19:32:26 EDT 2023]\n+     *       0x3f: CRC              : 0x31963516\n+     *       0x43: Compressed Size  :        0x8\n+     *       0x47: Uncompressed Size:        0x6\n+     *       0x4b: Name Length      :        0x9\n+     *       0x4d: Extra Length     :        0x0\n+     *       0x4f: Comment Length   :        0x0\n+     *       0x51: Disk Start       :        0x0\n+     *       0x53: Attrs            :        0x1\n+     *       0x55: AttrsEx          : 0x81a40000\n+     *       0x59: Loc Header Offset:        0x0\n+     *       0x5d: File Name        : Hello.txt\n+     *\/\n+    public static byte[] ZIP_WITH_NO_EXTRA_LEN_BYTEARRAY = {\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4, (byte) 0x14, (byte) 0x0, (byte) 0x2, (byte) 0x0,\n+            (byte) 0x8, (byte) 0x0, (byte) 0xd, (byte) 0x9c, (byte) 0x3, (byte) 0x57, (byte) 0x16, (byte) 0x35,\n+            (byte) 0x96, (byte) 0x31, (byte) 0x8, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x6, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x9, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x48, (byte) 0x65,\n+            (byte) 0x6c, (byte) 0x6c, (byte) 0x6f, (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0xf3,\n+            (byte) 0x48, (byte) 0xcd, (byte) 0xc9, (byte) 0xc9, (byte) 0xe7, (byte) 0x2, (byte) 0x0, (byte) 0x50,\n+            (byte) 0x4b, (byte) 0x1, (byte) 0x2, (byte) 0x14, (byte) 0x3, (byte) 0x14, (byte) 0x0, (byte) 0x2,\n+            (byte) 0x0, (byte) 0x8, (byte) 0x0, (byte) 0xd, (byte) 0x9c, (byte) 0x3, (byte) 0x57, (byte) 0x16,\n+            (byte) 0x35, (byte) 0x96, (byte) 0x31, (byte) 0x8, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x6,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x9, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xa4,\n+            (byte) 0x81, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x48, (byte) 0x65, (byte) 0x6c,\n+            (byte) 0x6c, (byte) 0x6f, (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0x50, (byte) 0x4b,\n+            (byte) 0x5, (byte) 0x6, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0,\n+            (byte) 0x1, (byte) 0x0, (byte) 0x37, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x2f, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+    };\n+\n+    \/**\n+     * Byte array representing a ZIP file which contains a\n+     * Zip64 Extra Header with only the LOC offset field.\n+     * ----------------#1--------------------\n+     * [Central Directory Header]\n+     *       0x4d: Signature        : 0x02014b50\n+     *       0x51: Created Zip Spec :       0x2d [4.5]\n+     *       0x52: Created OS       :        0x0 [MS-DOS]\n+     *       0x53: VerMadeby        :       0x2d [0, 4.5]\n+     *       0x54: VerExtract       :       0x2d [4.5]\n+     *       0x55: Flag             :      0x808\n+     *       0x57: Method           :        0x8 [DEFLATED]\n+     *       0x59: Last Mod Time    : 0x572d69c5 [Wed Sep 13 13:14:10 EDT 2023]\n+     *       0x5d: CRC              : 0x57de98d2\n+     *       0x61: Compressed Size  :       0x16\n+     *       0x65: Uncompressed Size:       0x14\n+     *       0x69: Name Length      :        0x9\n+     *       0x6b: Extra Length     :        0xc\n+     *       Extra data:[01, 00, 08, 00, 00, 00, 00, 00, 00, 00, 00, 00]\n+     *             [tag=0x0001, sz=8]\n+     *           ->ZIP64: LOC Off *0x0\n+     *          [data= 00 00 00 00 00 00 00 00 ]\n+     *       0x6d: Comment Length   :        0x0\n+     *       0x6f: Disk Start       :        0x0\n+     *       0x71: Attrs            :        0x0\n+     *       0x73: AttrsEx          :        0x0\n+     *       0x77: Loc Header Offset: 0xffffffff\n+     *       0x7b: File Name        : Hello.txt\n+     *\/\n+    public static byte[] ZIP_WITH_ZIP64_EXTRAHDR_LOC_ONLY_BYTEARRAY = {\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4, (byte) 0x14, (byte) 0x0, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x8, (byte) 0x0, (byte) 0xc5, (byte) 0x69, (byte) 0x2d, (byte) 0x57, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x9, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x48, (byte) 0x65,\n+            (byte) 0x6c, (byte) 0x6c, (byte) 0x6f, (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0xf3,\n+            (byte) 0x48, (byte) 0xcd, (byte) 0xc9, (byte) 0xc9, (byte) 0x57, (byte) 0x8, (byte) 0x49, (byte) 0xcd,\n+            (byte) 0xcb, (byte) 0xcb, (byte) 0x2c, (byte) 0x56, (byte) 0x8, (byte) 0xc8, (byte) 0x49, (byte) 0xac,\n+            (byte) 0x4c, (byte) 0x2d, (byte) 0x2a, (byte) 0x6, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x7,\n+            (byte) 0x8, (byte) 0xd2, (byte) 0x98, (byte) 0xde, (byte) 0x57, (byte) 0x16, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x1,\n+            (byte) 0x2, (byte) 0x2d, (byte) 0x0, (byte) 0x2d, (byte) 0x0, (byte) 0x8, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x0, (byte) 0xc5, (byte) 0x69, (byte) 0x2d, (byte) 0x57, (byte) 0xd2, (byte) 0x98, (byte) 0xde,\n+            (byte) 0x57, (byte) 0x16, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x9, (byte) 0x0, (byte) 0xc, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xff,\n+            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0x48, (byte) 0x65, (byte) 0x6c, (byte) 0x6c, (byte) 0x6f,\n+            (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0x1, (byte) 0x0, (byte) 0x8, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x5, (byte) 0x6, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x1, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x43, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x4d, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+    };\n+\n+    \/**\n+     * Byte array representing a ZIP file which contains a\n+     * Zip64 Extra Header with only the compressed size field.\n+     * ----------------#1--------------------\n+     * [Central Directory Header]\n+     *       0x4d: Signature        : 0x02014b50\n+     *       0x51: Created Zip Spec :       0x2d [4.5]\n+     *       0x52: Created OS       :        0x0 [MS-DOS]\n+     *       0x53: VerMadeby        :       0x2d [0, 4.5]\n+     *       0x54: VerExtract       :       0x2d [4.5]\n+     *       0x55: Flag             :      0x808\n+     *       0x57: Method           :        0x8 [DEFLATED]\n+     *       0x59: Last Mod Time    : 0x572d6960 [Wed Sep 13 13:11:00 EDT 2023]\n+     *       0x5d: CRC              : 0x57de98d2\n+     *       0x61: Compressed Size  : 0xffffffff\n+     *       0x65: Uncompressed Size:       0x14\n+     *       0x69: Name Length      :        0x9\n+     *       0x6b: Extra Length     :        0xc\n+     *          Extra data:[01, 00, 08, 00, 16, 00, 00, 00, 00, 00, 00, 00]\n+     *       [tag=0x0001, sz=8]\n+     *          ->ZIP64: csize *0x16\n+     *          [data= 16 00 00 00 00 00 00 00 ]\n+     *       0x6d: Comment Length   :        0x0\n+     *       0x6f: Disk Start       :        0x0\n+     *       0x71: Attrs            :        0x0\n+     *       0x73: AttrsEx          :        0x0\n+     *       0x77: Loc Header Offset:        0x0\n+     *       0x7b: File Name        : Hello.txt\n+     *\/\n+    public static byte[] ZIP_WITH_ZIP64_EXTRAHDR_CSIZE_ONLY_BYTEARRAY = {\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4, (byte) 0x14, (byte) 0x0, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x8, (byte) 0x0, (byte) 0x60, (byte) 0x69, (byte) 0x2d, (byte) 0x57, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x9, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x48, (byte) 0x65,\n+            (byte) 0x6c, (byte) 0x6c, (byte) 0x6f, (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0xf3,\n+            (byte) 0x48, (byte) 0xcd, (byte) 0xc9, (byte) 0xc9, (byte) 0x57, (byte) 0x8, (byte) 0x49, (byte) 0xcd,\n+            (byte) 0xcb, (byte) 0xcb, (byte) 0x2c, (byte) 0x56, (byte) 0x8, (byte) 0xc8, (byte) 0x49, (byte) 0xac,\n+            (byte) 0x4c, (byte) 0x2d, (byte) 0x2a, (byte) 0x6, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x7,\n+            (byte) 0x8, (byte) 0xd2, (byte) 0x98, (byte) 0xde, (byte) 0x57, (byte) 0x16, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x1,\n+            (byte) 0x2, (byte) 0x2d, (byte) 0x0, (byte) 0x2d, (byte) 0x0, (byte) 0x8, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x0, (byte) 0x60, (byte) 0x69, (byte) 0x2d, (byte) 0x57, (byte) 0xd2, (byte) 0x98, (byte) 0xde,\n+            (byte) 0x57, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0x14, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x9, (byte) 0x0, (byte) 0xc, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x48, (byte) 0x65, (byte) 0x6c, (byte) 0x6c, (byte) 0x6f,\n+            (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0x1, (byte) 0x0, (byte) 0x8, (byte) 0x0,\n+            (byte) 0x16, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x5, (byte) 0x6, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x1, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x43, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x4d, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+    };\n+\n+    \/**\n+     * Byte array representing a Zip file with a zero length ZIP64 Extra Header\n+     * ----------------#1--------------------\n+     * [Central Directory Header]\n+     *       0x43: Signature        : 0x02014b50\n+     *       0x47: Created Zip Spec :       0x2d [4.5]\n+     *       0x48: Created OS       :        0x3 [UNIX]\n+     *       0x49: VerMadeby        :      0x32d [3, 4.5]\n+     *       0x4a: VerExtract       :       0x2d [4.5]\n+     *       0x4b: Flag             :      0x800\n+     *       0x4d: Method           :        0x8 [DEFLATED]\n+     *       0x4f: Last Mod Time    : 0x572c3477 [Tue Sep 12 06:35:46 EDT 2023]\n+     *       0x53: CRC              : 0x31963516\n+     *       0x57: Compressed Size  :        0x8\n+     *       0x5b: Uncompressed Size:        0x6\n+     *       0x5f: Name Length      :        0x9\n+     *       0x61: Extra Length     :        0x4\n+     *         Extra data:[01, 00, 00, 00]\n+     *         [tag=0x0001, sz=0]\n+     *           ->ZIP64:\n+     *       0x63: Comment Length   :        0x0\n+     *       0x65: Disk Start       :        0x0\n+     *       0x67: Attrs            :        0x0\n+     *       0x69: AttrsEx          : 0x81a40000\n+     *       0x6d: Loc Header Offset:        0x0\n+     *       0x71: File Name        : Hello.txt\n+     *\/\n+    public static byte[] ZIP_WITH_ZEROLEN_ZIP64_EXTRAHDR_BYTEARRAY = {\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4, (byte) 0x2d, (byte) 0x0, (byte) 0x0, (byte) 0x8,\n+            (byte) 0x8, (byte) 0x0, (byte) 0x77, (byte) 0x34, (byte) 0x2c, (byte) 0x57, (byte) 0x16, (byte) 0x35,\n+            (byte) 0x96, (byte) 0x31, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n+            (byte) 0xff, (byte) 0xff, (byte) 0x9, (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x48, (byte) 0x65,\n+            (byte) 0x6c, (byte) 0x6c, (byte) 0x6f, (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0x1,\n+            (byte) 0x0, (byte) 0x10, (byte) 0x0, (byte) 0x6, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x8, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xf3, (byte) 0x48, (byte) 0xcd, (byte) 0xc9, (byte) 0xc9,\n+            (byte) 0xe7, (byte) 0x2, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x1, (byte) 0x2, (byte) 0x2d,\n+            (byte) 0x3, (byte) 0x2d, (byte) 0x0, (byte) 0x0, (byte) 0x8, (byte) 0x8, (byte) 0x0, (byte) 0x77,\n+            (byte) 0x34, (byte) 0x2c, (byte) 0x57, (byte) 0x16, (byte) 0x35, (byte) 0x96, (byte) 0x31, (byte) 0x8,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x6, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x9,\n+            (byte) 0x0, (byte) 0x4, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xa4, (byte) 0x81, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x48, (byte) 0x65, (byte) 0x6c, (byte) 0x6c, (byte) 0x6f, (byte) 0x2e, (byte) 0x74,\n+            (byte) 0x78, (byte) 0x74, (byte) 0x1, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b,\n+            (byte) 0x6, (byte) 0x6, (byte) 0x2c, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x2d, (byte) 0x0, (byte) 0x2d, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x3b, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x43, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b,\n+            (byte) 0x6, (byte) 0x7, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x7e, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x5, (byte) 0x6, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x3b, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x43, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+    };\n+\n+    \/**\n+     * Byte array representing a ZIP file which contains a\n+     * Zip64 Extra Header with the size and csize fields.\n+     * ----------------#1--------------------\n+     * [Central Directory Header]\n+     *       0x4d: Signature        : 0x02014b50\n+     *       0x51: Created Zip Spec :       0x2d [4.5]\n+     *       0x52: Created OS       :        0x0 [MS-DOS]\n+     *       0x53: VerMadeby        :       0x2d [0, 4.5]\n+     *       0x54: VerExtract       :       0x2d [4.5]\n+     *       0x55: Flag             :      0x808\n+     *       0x57: Method           :        0x8 [DEFLATED]\n+     *       0x59: Last Mod Time    : 0x572c6445 [Tue Sep 12 12:34:10 EDT 2023]\n+     *       0x5d: CRC              : 0x57de98d2\n+     *       0x61: Compressed Size  : 0xffffffff\n+     *       0x65: Uncompressed Size: 0xffffffff\n+     *       0x69: Name Length      :        0x9\n+     *       0x6b: Extra Length     :       0x14\n+     *          Extra data:[01, 00, 10, 00, 14, 00, 00, 00, 00, 00, 00, 00, 16, 00, 00, 00, 00, 00, 00, 00]\n+     *       [tag=0x0001, sz=16]\n+     *          ->ZIP64: size *0x14 csize *0x16\n+     *          [data= 14 00 00 00 00 00 00 00 16 00 00 00 00 00 00 00 ]\n+     *       0x6d: Comment Length   :        0x0\n+     *       0x6f: Disk Start       :        0x0\n+     *       0x71: Attrs            :        0x0\n+     *       0x73: AttrsEx          :        0x0\n+     *       0x77: Loc Header Offset:        0x0\n+     *       0x7b: File Name        : Hello.txt\n+     *\/\n+    public static byte[] ZIP_WITH_TWO_ZIP64_HEADER_ENTRIES_BYTEARRAY = {\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4, (byte) 0x14, (byte) 0x0, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x8, (byte) 0x0, (byte) 0x45, (byte) 0x64, (byte) 0x2c, (byte) 0x57, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x9, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x48, (byte) 0x65,\n+            (byte) 0x6c, (byte) 0x6c, (byte) 0x6f, (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0xf3,\n+            (byte) 0x48, (byte) 0xcd, (byte) 0xc9, (byte) 0xc9, (byte) 0x57, (byte) 0x8, (byte) 0x49, (byte) 0xcd,\n+            (byte) 0xcb, (byte) 0xcb, (byte) 0x2c, (byte) 0x56, (byte) 0x8, (byte) 0xc8, (byte) 0x49, (byte) 0xac,\n+            (byte) 0x4c, (byte) 0x2d, (byte) 0x2a, (byte) 0x6, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x7,\n+            (byte) 0x8, (byte) 0xd2, (byte) 0x98, (byte) 0xde, (byte) 0x57, (byte) 0x16, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x1,\n+            (byte) 0x2, (byte) 0x2d, (byte) 0x0, (byte) 0x2d, (byte) 0x0, (byte) 0x8, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x0, (byte) 0x45, (byte) 0x64, (byte) 0x2c, (byte) 0x57, (byte) 0xd2, (byte) 0x98, (byte) 0xde,\n+            (byte) 0x57, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n+            (byte) 0xff, (byte) 0x9, (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x48, (byte) 0x65, (byte) 0x6c, (byte) 0x6c, (byte) 0x6f,\n+            (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0x1, (byte) 0x0, (byte) 0x10, (byte) 0x0,\n+            (byte) 0x14, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x16, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x5, (byte) 0x6, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x1, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x4b, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x4d, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+    };\n+\n+    \/**\n+     * Byte array representing a ZIP file which contains a\n+     * Zip64 Extra Header with the size,csize, and LOC offset fields.\n+     * ----------------#1--------------------\n+     * [Central Directory Header]\n+     *       0x4d: Signature        : 0x02014b50\n+     *       0x51: Created Zip Spec :       0x2d [4.5]\n+     *       0x52: Created OS       :        0x0 [MS-DOS]\n+     *       0x53: VerMadeby        :       0x2d [0, 4.5]\n+     *       0x54: VerExtract       :       0x2d [4.5]\n+     *       0x55: Flag             :      0x808\n+     *       0x57: Method           :        0x8 [DEFLATED]\n+     *       0x59: Last Mod Time    : 0x572d7214 [Wed Sep 13 14:16:40 EDT 2023]\n+     *       0x5d: CRC              : 0x57de98d2\n+     *       0x61: Compressed Size  : 0xffffffff\n+     *       0x65: Uncompressed Size: 0xffffffff\n+     *       0x69: Name Length      :        0x9\n+     *       0x6b: Extra Length     :       0x1c\n+     *          Extra data:[01, 00, 18, 00, 14, 00, 00, 00, 00, 00, 00, 00, 16, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00]\n+     *        [tag=0x0001, sz=24]\n+     *         ->ZIP64: size *0x14 csize *0x16 LOC Off *0x0\n+     *         [data= 14 00 00 00 00 00 00 00 16 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ]\n+     *       0x6d: Comment Length   :        0x0\n+     *       0x6f: Disk Start       :        0x0\n+     *       0x71: Attrs            :        0x0\n+     *       0x73: AttrsEx          :        0x0\n+     *       0x77: Loc Header Offset: 0xffffffff\n+     *       0x7b: File Name        : Hello.txt\n+     *\/\n+    public static byte[] ZIP_WITH_ZIP64_EXTRAHDR_ALL_BYTEARRAY = {\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4, (byte) 0x14, (byte) 0x0, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x8, (byte) 0x0, (byte) 0x14, (byte) 0x72, (byte) 0x2d, (byte) 0x57, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x9, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x48, (byte) 0x65,\n+            (byte) 0x6c, (byte) 0x6c, (byte) 0x6f, (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0xf3,\n+            (byte) 0x48, (byte) 0xcd, (byte) 0xc9, (byte) 0xc9, (byte) 0x57, (byte) 0x8, (byte) 0x49, (byte) 0xcd,\n+            (byte) 0xcb, (byte) 0xcb, (byte) 0x2c, (byte) 0x56, (byte) 0x8, (byte) 0xc8, (byte) 0x49, (byte) 0xac,\n+            (byte) 0x4c, (byte) 0x2d, (byte) 0x2a, (byte) 0x6, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x7,\n+            (byte) 0x8, (byte) 0xd2, (byte) 0x98, (byte) 0xde, (byte) 0x57, (byte) 0x16, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x1,\n+            (byte) 0x2, (byte) 0x2d, (byte) 0x0, (byte) 0x2d, (byte) 0x0, (byte) 0x8, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x0, (byte) 0x14, (byte) 0x72, (byte) 0x2d, (byte) 0x57, (byte) 0xd2, (byte) 0x98, (byte) 0xde,\n+            (byte) 0x57, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n+            (byte) 0xff, (byte) 0x9, (byte) 0x0, (byte) 0x1c, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xff,\n+            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0x48, (byte) 0x65, (byte) 0x6c, (byte) 0x6c, (byte) 0x6f,\n+            (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0x1, (byte) 0x0, (byte) 0x18, (byte) 0x0,\n+            (byte) 0x14, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x16, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x5, (byte) 0x6, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x1, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x53, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x4d, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+    };\n+\n+    \/**\n+     * Enable debug output\n+     *\/\n+    private static final boolean DEBUG = false;\n+\n+    \/**\n+     * Name of the Zip file that we create from the byte array\n+     *\/\n+    public static final String ZIPFILE_NAME = \"validZipFile.zip\";\n+\n+    \/**\n+     * Name of the Zip file that we modify\/corrupt\n+     *\/\n+    public static final String BAD_ZIP_NAME = \"zipWithInvalidZip64ExtraField.zip\";\n+\n+    \/**\n+     * Zip file entry that will be accessed by some the tests\n+     *\/\n+    private static final String ZIP_FILE_ENTRY_NAME = \"Hello.txt\";\n+\n+    \/**\n+     * Expected Error messages\n+     *\/\n+     private static final String MISSING_ZIP64_COMPRESSED_SIZE =\n+            \"Invalid Zip64 extra block, missing compressed size\";\n+     private static final String MISSING_ZIP64_LOC_OFFSET =\n+             \"Invalid Zip64 extra block, missing LOC offset value\";\n+     private static final String INVALID_EXTRA_LENGTH =\n+     \"Invalid CEN header (invalid zip64 extra len size)\";\n+\n+     private static final String INVALID_ZIP64_EXTRAHDR_SIZE =\n+             \"Invalid CEN header (invalid zip64 extra data field size)\";\n+\n+     \/**\n+     * Disk starting number offset for the Zip file created from the\n+     * ZIP_WITH_NO_EXTRA_LEN_BYTEARRAY array\n+     *\/\n+    private static final int DISKNO_OFFSET_ZIP_NO_EXTRA_LEN = 0x51;\n+\n+    \/**\n+     * Value to set the size, csize, or LOC offset CEN fields to when their\n+     * actual value is stored in the Zip64 Extra Header\n+     *\/\n+    private static final long ZIP64_MAGICVAL = 0xFFFFFFFFL;\n+\n+    \/**\n+     * Value to set the Disk Start number offset CEN field to when the\n+     * actual value is stored in the Zip64 Extra Header\n+     *\/\n+    private static final int ZIP64_MAGICCOUNT = 0xFFFF;\n+\n+    \/**\n+     * Copy of the byte array for the ZIP to be modified by a given test run\n+     *\/\n+    private byte[] zipArrayCopy;\n+\n+    \/**\n+     * Little-endian ByteBuffer for manipulating the ZIP copy\n+     *\/\n+    private ByteBuffer buffer;\n+\n+    \/**\n+     * The DataProvider returning a byte array representing the Zip file,\n+     * CEN offsets to set to 0xFFFFFFFF and the expected\n+     * ZipException error message when there are missing Zip64 Extra header fields\n+     * @return Arguments used in each test run\n+     *\/\n+    private static Stream<Arguments> InvalidZip64MagicValues() {\n+        return Stream.of(\n+                \/\/ Byte array representing the Zip file, compressed size offset,\n+                \/\/ and expected ZipException Message\n+                Arguments.of(ZIP_WITH_ZIP64_EXTRAHDR_SIZE_ONLY_BYTEARRAY,\n+                        0x61, MISSING_ZIP64_COMPRESSED_SIZE),\n+                \/\/ Byte array representing the Zip file, LOC offset and expected ZipException Message\n+                Arguments.of(ZIP_WITH_ZIP64_EXTRAHDR_SIZE_ONLY_BYTEARRAY,\n+                        0x77, MISSING_ZIP64_LOC_OFFSET),\n+                \/\/ Byte array representing the Zip file, LOC offset and expected ZipException Message\n+                Arguments.of(ZIP_WITH_TWO_ZIP64_HEADER_ENTRIES_BYTEARRAY,\n+                        0x77, MISSING_ZIP64_LOC_OFFSET)\n+        );\n+    }\n+\n+    \/**\n+     * The DataProvider of CEN offsets to set to 0xFFFFFFFF or 0xFFFF when the Extra Length\n+     * size is 0 for the Zip file created using ZIP_WITH_NO_EXTRA_LEN_BYTEARRAY\n+     * @return Arguments used in each test run\n+     *\/\n+    private static Stream<Arguments> MissingZip64ExtraFieldEntries() {\n+        return Stream.of(\n+                \/\/ Compressed size offset\n+                Arguments.of(0x43),\n+                \/\/ Size offset\n+                Arguments.of(0x47),\n+                \/\/ Disk start number offset\n+                Arguments.of(DISKNO_OFFSET_ZIP_NO_EXTRA_LEN),\n+                \/\/ LOC offset\n+                Arguments.of(0x59)\n+        );\n+    }\n+\n+    \/**\n+     * The DataProvider of CEN offsets to set to 0xFFFFFFFF when the ZIP64 extra header\n+     * Length size is 0 for the Zip file created using\n+     * ZIP_WITH_ZEROLEN_ZIP64_EXTRAHDR_BYTEARRAY\n+     * @return Arguments used in each test run\n+     *\/\n+    private static Stream<Arguments> zip64ZeroLenHeaderExtraFieldEntries() {\n+        return Stream.of(\n+                \/\/ Compressed size offset\n+                Arguments.of(0x57),\n+                \/\/ Size offset\n+                Arguments.of(0x5b),\n+                \/\/ LOC offset\n+                Arguments.of(0x6d)\n+        );\n+    }\n+\n+    \/**\n+     * The DataProvider which will return a byte array representing a\n+     * valid Zip file and the expected content for the Zip file entry 'Hello.txt'.\n+     * @return Arguments used in each test run\n+     *\/\n+    private static Stream<Arguments> validZipFiles() {\n+        return Stream.of(\n+                \/\/ Byte array representing the Zip file, and the expected entry content\n+                Arguments.of(ZIP_WITH_ZIP64_EXTRAHDR_SIZE_ONLY_BYTEARRAY,\n+                        \"Hello Tennis Players\"),\n+                Arguments.of(ZIP_WITH_TWO_ZIP64_HEADER_ENTRIES_BYTEARRAY,\n+                        \"Hello Tennis Players\"),\n+                Arguments.of(ZIP_WITH_ZIP64_EXTRAHDR_LOC_ONLY_BYTEARRAY,\n+                        \"Hello Tennis Players\"),\n+                Arguments.of(ZIP_WITH_ZIP64_EXTRAHDR_CSIZE_ONLY_BYTEARRAY,\n+                        \"Hello Tennis Players\"),\n+                Arguments.of(ZIP_WITH_ZIP64_EXTRAHDR_ALL_BYTEARRAY,\n+                        \"Hello Tennis Players\"),\n+                Arguments.of(ZIP_WITH_NO_EXTRA_LEN_BYTEARRAY,\n+                        \"Hello\\n\")\n+        );\n+    }\n+\n+    \/**\n+     * Initial test setup\n+     * @throws IOException if an error occurs\n+     *\/\n+    @BeforeAll\n+    public static void setup() throws IOException {\n+        Files.deleteIfExists(Path.of(ZIPFILE_NAME));\n+        Files.deleteIfExists(Path.of(BAD_ZIP_NAME));\n+    }\n+\n+    \/**\n+     * Delete the Zip file that will be modified by each test\n+     * @throws IOException if an error occurs\n+     *\/\n+    @BeforeEach\n+    public void beforeEachTestRun() throws IOException {\n+        Files.deleteIfExists(Path.of(ZIPFILE_NAME));\n+        Files.deleteIfExists(Path.of(BAD_ZIP_NAME));\n+    }\n+\n+    \/**\n+     * Verify that a ZipException is thrown by ZipFile if the Zip64 header\n+     * does not contain the required field\n+     * @param zipArray Byte array representing the Zip file\n+     * @param offset Offset of the CEN Header field to set to 0xFFFFFFFF\n+     * @param errorMessage Expected ZipException error message\n+     * @throws IOException if an error occurs\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"InvalidZip64MagicValues\")\n+    public void invalidZip64ExtraHeaderZipFileTest(byte[] zipArray, int offset,\n+                                                   String errorMessage) throws IOException {\n+        \/\/ Set the CEN csize or LOC offset field to 0xFFFFFFFF.  There will not\n+        \/\/ be the expected Zip64 Extra Header field resulting in a ZipException\n+        \/\/ being thrown\n+        zipArrayCopy = zipArray.clone();\n+        buffer = ByteBuffer.wrap(zipArrayCopy).order(ByteOrder.LITTLE_ENDIAN);\n+        buffer.putInt(offset, (int) ZIP64_MAGICVAL);\n+        Files.write(Path.of(BAD_ZIP_NAME), zipArrayCopy);\n+\n+        ZipException ex = assertThrows(ZipException.class, () -> {\n+            openWithZipFile(BAD_ZIP_NAME, ZIP_FILE_ENTRY_NAME, null);\n+        });\n+        assertTrue(ex.getMessage().matches(errorMessage),\n+                \"Unexpected ZipException message: \" + ex.getMessage());\n+    }\n+\n+    \/**\n+     * Verify that a ZipException is thrown by Zip FS if the Zip64 header\n+     * does not contain the required field\n+     * @param zipArray Byte array representing the Zip file\n+     * @param offset Offset of the CEN Header field to set to 0xFFFFFFFF\n+     * @param errorMessage Expected ZipException error message\n+     * @throws IOException if an error occurs\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"InvalidZip64MagicValues\")\n+    public void invalidZip64ExtraHeaderZipFSTest(byte[] zipArray, int offset,\n+                                                 String errorMessage) throws IOException {\n+        \/\/ Set the CEN csize or LOC offset field to 0xFFFFFFFF.  There will not\n+        \/\/ be the expected Zip64 Extra Header field resulting in a ZipException\n+        \/\/ being thrown\n+        zipArrayCopy = zipArray.clone();\n+        buffer = ByteBuffer.wrap(zipArrayCopy).order(ByteOrder.LITTLE_ENDIAN);\n+        buffer.putInt(offset, (int)ZIP64_MAGICVAL);\n+        Files.write(Path.of(BAD_ZIP_NAME), zipArrayCopy);\n+\n+        ZipException ex = assertThrows(ZipException.class, () -> {\n+            openWithZipFS(BAD_ZIP_NAME, ZIP_FILE_ENTRY_NAME, null);\n+        });\n+        assertTrue(ex.getMessage().matches(errorMessage),\n+                \"Unexpected ZipException message: \" + ex.getMessage());\n+    }\n+\n+    \/**\n+     * Verify that ZipFile will throw a ZipException if the CEN\n+     * Extra length is 0 and the  CEN size, csize, LOC offset field is set to\n+     * 0xFFFFFFFF or the disk starting number is set to 0xFFFF\n+     * @param offset Offset of the CEN Header field to set to 0xFFFFFFFF or 0xFFFF\n+     * @throws IOException if an error occurs\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"MissingZip64ExtraFieldEntries\")\n+    public void zipFileBadExtraLength(int offset) throws IOException {\n+        zipArrayCopy = ZIP_WITH_NO_EXTRA_LEN_BYTEARRAY.clone();\n+        buffer = ByteBuffer.wrap(zipArrayCopy).order(ByteOrder.LITTLE_ENDIAN);\n+        if (offset == DISKNO_OFFSET_ZIP_NO_EXTRA_LEN) {\n+            buffer.putShort(offset, (short) ZIP64_MAGICCOUNT);\n+        } else {\n+            buffer.putInt(offset, (int) ZIP64_MAGICVAL);\n+        }\n+        Files.write(Path.of(BAD_ZIP_NAME), zipArrayCopy);\n+\n+        ZipException ex = assertThrows(ZipException.class, () -> {\n+            openWithZipFile(BAD_ZIP_NAME, ZIP_FILE_ENTRY_NAME, null);\n+        });\n+        assertTrue(ex.getMessage().equals(INVALID_EXTRA_LENGTH),\n+                \"Unexpected ZipException message: \" + ex.getMessage());\n+    }\n+\n+    \/**\n+     * Verify that ZipFS will throw a ZipException if the CEN\n+     * Extra length is 0 and the CEN size, csize, LOC offset field is set to\n+     * 0xFFFFFFFF or the disk starting number is set to 0xFFFF\n+     * @param offset the offset of the CEN Header field to set to 0xFFFFFFFF or 0xFFFF\n+     * @throws IOException if an error occurs\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"MissingZip64ExtraFieldEntries\")\n+    public void zipFSBadExtraLength(int offset) throws IOException {\n+        zipArrayCopy = ZIP_WITH_NO_EXTRA_LEN_BYTEARRAY.clone();\n+        buffer = ByteBuffer.wrap(zipArrayCopy).order(ByteOrder.LITTLE_ENDIAN);\n+        if (offset == DISKNO_OFFSET_ZIP_NO_EXTRA_LEN) {\n+            buffer.putShort(offset, (short) ZIP64_MAGICCOUNT);\n+        } else {\n+            buffer.putInt(offset, (int) ZIP64_MAGICVAL);\n+        }\n+        Files.write(Path.of(BAD_ZIP_NAME), zipArrayCopy);\n+\n+        ZipException ex = assertThrows(ZipException.class, () -> {\n+            openWithZipFS(BAD_ZIP_NAME, ZIP_FILE_ENTRY_NAME, null);\n+        });\n+        assertTrue(ex.getMessage().equals(INVALID_EXTRA_LENGTH),\n+                \"Unexpected ZipException message: \" + ex.getMessage());\n+    }\n+\n+    \/**\n+     * Verify that ZipFile will throw a ZipException if the ZIP64 extra header\n+     * has a size of 0 and the CEN size, csize, or the LOC offset field is set to\n+     * 0xFFFFFFFF\n+     * @param offset the offset of the CEN Header field to set to 0xFFFFFFFF\n+     * @throws IOException if an error occurs\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"zip64ZeroLenHeaderExtraFieldEntries\")\n+    public void zipFileZeroLenExtraHeader(int offset) throws IOException {\n+        zipArrayCopy = ZIP_WITH_ZEROLEN_ZIP64_EXTRAHDR_BYTEARRAY.clone();\n+        buffer = ByteBuffer.wrap(zipArrayCopy).order(ByteOrder.LITTLE_ENDIAN);\n+        buffer.putInt(offset, (int) ZIP64_MAGICVAL);\n+        Files.write(Path.of(BAD_ZIP_NAME), zipArrayCopy);\n+        ZipException ex = assertThrows(ZipException.class, () -> {\n+            openWithZipFile(BAD_ZIP_NAME, ZIP_FILE_ENTRY_NAME, null);\n+        });\n+        assertTrue(ex.getMessage().equals(INVALID_ZIP64_EXTRAHDR_SIZE),\n+                \"Unexpected ZipException message: \" + ex.getMessage());\n+    }\n+\n+    \/**\n+     * Verify that ZipFS will throw a ZipException if the ZIP64 extra header\n+     * has a size of 0 and the CEN size, csize, or the LOC offset field is set to\n+     * 0xFFFFFFFF\n+     * @param offset the offset of the CEN Header field to set to 0xFFFFFFFF\n+     * @throws IOException if an error occurs\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"zip64ZeroLenHeaderExtraFieldEntries\")\n+    public void zipFSZeroLenExtraHeader(int offset) throws IOException {\n+        zipArrayCopy = ZIP_WITH_ZEROLEN_ZIP64_EXTRAHDR_BYTEARRAY.clone();\n+        buffer = ByteBuffer.wrap(zipArrayCopy).order(ByteOrder.LITTLE_ENDIAN);\n+        buffer.putInt(offset, (int) ZIP64_MAGICVAL);\n+        Files.write(Path.of(BAD_ZIP_NAME), zipArrayCopy);\n+        ZipException ex = assertThrows(ZipException.class, () -> {\n+            openWithZipFS(BAD_ZIP_NAME, ZIP_FILE_ENTRY_NAME, null);\n+        });\n+        assertTrue(ex.getMessage().equals(INVALID_ZIP64_EXTRAHDR_SIZE),\n+                \"Unexpected ZipException message: \" + ex.getMessage());\n+    }\n+\n+    \/**\n+     * Verify that ZipFile will read the Zip files created from the\n+     * byte arrays prior to modifying the arrays to check that the\n+     * expected ZipException is thrown.\n+     * @param  zipFile the byte array which represents the Zip file that should\n+     *                 be opened and read successfully.\n+     * @param message the expected text contained within the Zip entry\n+     * @throws IOException if an error occurs\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"validZipFiles\")\n+    public void readValidZipFile(byte[] zipFile, String message) throws IOException {\n+        \/\/ Write out the Zip file from the byte array\n+        Files.write(Path.of(ZIPFILE_NAME), zipFile);\n+        openWithZipFile(ZIPFILE_NAME, ZIP_FILE_ENTRY_NAME, message);\n+    }\n+\n+    \/**\n+     * Verify that ZipFS will read the Zip files created from the\n+     * byte arrays prior to modifying the arrays to check that the\n+     * expected ZipException is thrown.\n+     * @param  zipFile the byte array which represents the Zip file that should\n+     *                 be opened and read successfully.\n+     * @param message the expected text contained within the Zip entry\n+     * @throws IOException if an error occurs\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"validZipFiles\")\n+    public void readValidZipFileWithZipFs(byte[] zipFile, String message)\n+            throws IOException {\n+        \/\/ Write out the Zip file from the byte array\n+        Files.write(Path.of(ZIPFILE_NAME), zipFile);\n+        openWithZipFS(ZIPFILE_NAME, ZIP_FILE_ENTRY_NAME, message);\n+    }\n+\n+    \/**\n+     * Utility method used to open a Zip file using ZipFile by the tests.\n+     * @param zipFile name of the Zip file to open\n+     * @param entryName Zip entry to read when the Zip file is expected to be\n+     *                  able to be opened\n+     * @param entryContents the expected contents for the Zip entry\n+     * @throws IOException if an error occurs\n+     *\/\n+    private static void openWithZipFile(String zipFile, String entryName,\n+                                        String entryContents) throws IOException {\n+        try (ZipFile zf = new ZipFile(zipFile)) {\n+            ZipEntry ze = zf.getEntry(entryName);\n+            try (InputStream is = zf.getInputStream(ze)) {\n+                String result = new String(is.readAllBytes());\n+                if (DEBUG) {\n+                    var hx = HexFormat.ofDelimiter(\", \").withPrefix(\"0x\");\n+                    System.out.printf(\"Error: Zip File read :%s%n[%s]%n\", result,\n+                            hx.formatHex(result.getBytes()));\n+                }\n+                \/\/ entryContents will be null when an exception is expected\n+                if (entryContents != null) {\n+                    assertEquals(entryContents, result);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Utility method used to open a Zip file using ZipFS by the tests.\n+     * @param zipFile name of the Zip file to open\n+     * @param entryName Zip entry to read when the Zip file is expected to be\n+     *                  able to be opened\n+     * @param entryContents the expected contents for the Zip entry\n+     * @throws IOException if an error occurs\n+     *\/\n+    private static void openWithZipFS(String zipFile, String entryName,\n+                                      String entryContents) throws IOException {\n+        try (FileSystem fs = FileSystems.newFileSystem(\n+                Path.of(zipFile), Map.of())) {\n+            Path p = fs.getPath(entryName);\n+            String result = new String(Files.readAllBytes(p));\n+            if (DEBUG) {\n+                var hx = HexFormat.ofDelimiter(\", \").withPrefix(\"0x\");\n+                System.out.printf(\"Error: Zip FS read :%s%n[%s]%n\", result,\n+                        hx.formatHex(result.getBytes()));\n+            }\n+            \/\/ entryContents will be null when an exception is expected\n+            if (entryContents != null) {\n+                assertEquals(entryContents, result);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/MissingZIP64EntriesTest.java","additions":820,"deletions":0,"binary":false,"changes":820,"status":"added"}]}