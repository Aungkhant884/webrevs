{"files":[{"patch":"@@ -1223,0 +1223,2 @@\n+            int elen = CENEXT(cen, pos);\n+            int clen = CENCOM(cen, pos);\n@@ -1227,1 +1229,0 @@\n-            int elen = CENEXT(cen, pos);\n@@ -1234,0 +1235,5 @@\n+            } else if (elen == 0 && (CENSIZ(cen, pos) == ZIP64_MAGICVAL\n+                    || CENLEN(cen, pos) == ZIP64_MAGICVAL\n+                    || CENOFF(cen, pos) == ZIP64_MAGICVAL\n+                    || CENDSK(cen, pos) == ZIP64_MAGICCOUNT)) {\n+                zerror(\"Invalid CEN header (invalid zip64 extra len size)\");\n@@ -1246,2 +1252,2 @@\n-                \/\/ Validate comment if it exists\n-                \/\/ if the bytes representing the comment cannot be converted to\n+                \/\/ Validate comment if it exists.\n+                \/\/ If the bytes representing the comment cannot be converted to\n@@ -1249,1 +1255,0 @@\n-                int clen = CENCOM(cen, pos);\n@@ -1276,1 +1281,1 @@\n-            if (extraEndOffset > cen.length) {\n+            if (extraEndOffset > cen.length - ENDHDR) {\n@@ -1305,0 +1310,2 @@\n+                    \/\/ Get the LOC offset\n+                    long locoff = CENOFF(cen, cenPos);\n@@ -1307,1 +1314,1 @@\n-                            csize, size);\n+                            csize, size, locoff);\n@@ -1323,0 +1330,1 @@\n+         * @param locoff CEN header LOC offset\n@@ -1326,1 +1334,1 @@\n-                                                long size)\n+                                                long size, long locoff)\n@@ -1333,1 +1341,2 @@\n-                if (csize == ZIP64_MAGICVAL || size == ZIP64_MAGICVAL) {\n+                if (csize == ZIP64_MAGICVAL || size == ZIP64_MAGICVAL ||\n+                        locoff == ZIP64_MAGICVAL) {\n@@ -1349,1 +1358,1 @@\n-                if(get64(cen, off) < 0) {\n+                if (get64(cen, off) < 0) {\n@@ -1354,3 +1363,17 @@\n-            if ((csize == ZIP64_MAGICVAL) && (blockSize >= 16)) {\n-                if (get64(cen, off + 8) < 0) {\n-                    zerror(\"Invalid zip64 extra block compressed size value\");\n+            if (csize == ZIP64_MAGICVAL) {\n+                if (blockSize >= 16) {\n+                    if (get64(cen, off + 8) < 0) {\n+                        zerror(\"Invalid zip64 extra block compressed size value\");\n+                    }\n+                } else {\n+                    zerror(\"Invalid Zip64 extra block, missing compressed size\");\n+                }\n+            }\n+            \/\/ Check the LOC offset is not negative\n+            if (locoff == ZIP64_MAGICVAL) {\n+                if (blockSize >= 24) {\n+                    if (get64(cen, off + 16) < 0) {\n+                        zerror(\"Invalid zip64 extra block LOC OFFSET value\");\n+                    }\n+                } else {\n+                    zerror(\"Invalid Zip64 extra block, missing LOC offset value\");\n@@ -1381,2 +1404,2 @@\n-             * 24 - uncompressed size, compressed sise, LOC Header offset\n-             * 28 - uncompressed size, compressed sise, LOC Header offset,\n+             * 24 - uncompressed size, compressed size, LOC Header offset\n+             * 28 - uncompressed size, compressed size, LOC Header offset,\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":37,"deletions":14,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1575,0 +1575,4 @@\n+            long csize = CENSIZ(cen, pos);\n+            long size  = CENLEN(cen, pos);\n+            long locoff = CENOFF(cen, pos);\n+            int diskNo = CENDSK(cen, pos);\n@@ -1584,0 +1588,4 @@\n+            if (elen == 0 && (size == ZIP64_MINVAL || csize == ZIP64_MINVAL ||\n+                    locoff == ZIP64_MINVAL || diskNo == ZIP64_MINVAL32)) {\n+                throw new ZipException(\"Invalid CEN header (invalid zip64 extra len size)\");\n+            }\n@@ -2812,0 +2820,1 @@\n+            int diskNo  = CENDSK(cen, pos);\n@@ -2814,1 +2823,0 @@\n-            disk        = CENDSK(cen, pos);\n@@ -2832,0 +2840,3 @@\n+            } else if (elen == 0 && (size == ZIP64_MINVAL || csize == ZIP64_MINVAL\n+                    || locoff == ZIP64_MINVAL || diskNo == ZIP64_MINVAL32)) {\n+                throw new ZipException(\"Invalid CEN header (invalid zip64 extra len size)\");\n@@ -3109,2 +3120,0 @@\n-                        if (pos + 8 > elen)  \/\/ invalid zip64 extra\n-                            break;           \/\/ fields, just skip\n@@ -3115,1 +3124,0 @@\n-                        pos += 8;\n@@ -3118,5 +3126,7 @@\n-                        if (pos + 8 > elen)\n-                            break;\n-                        csize = LL(extra, pos);\n-                        if (csize < 0) {\n-                            throw new ZipException(\"Invalid zip64 extra block compressed size value\");\n+                        if (sz >= 16) {\n+                            csize = LL(extra, pos + 8);\n+                            if (csize < 0) {\n+                                throw new ZipException(\"Invalid zip64 extra block compressed size value\");\n+                            }\n+                        } else {\n+                            throw new ZipException(\"Invalid Zip64 extra block, missing compressed size\");\n@@ -3124,1 +3134,0 @@\n-                        pos += 8;\n@@ -3127,5 +3136,7 @@\n-                        if (pos + 8 > elen)\n-                            break;\n-                        locoff = LL(extra, pos);\n-                        if (locoff < 0) {\n-                            throw new ZipException(\"Invalid zip64 extra block LOC offset value\");\n+                        if (sz >= 24) {\n+                            locoff = LL(extra, pos + 16);\n+                            if (locoff < 0) {\n+                                throw new ZipException(\"Invalid zip64 extra block LOC offset value\");\n+                            }\n+                        } else {\n+                            throw new ZipException(\"Invalid Zip64 extra block, missing LOC offset value\");\n@@ -3161,2 +3172,2 @@\n-                    \/\/ LOC offset from the EXTID_ZIP64 extra data. Therefore\n-                    \/\/ wait until all of the CEN extra data fields have been processed\n+                    \/\/ LOC offset from the EXTID_ZIP64 extra data. Therefore,\n+                    \/\/ wait until all the CEN extra data fields have been processed\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java","additions":28,"deletions":17,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,472 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HexFormat;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipFile;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/* @test\n+ * @bug 8314891\n+ * @summary Validate that a ZipException is thrown when the extra len is 0\n+ * and the CEN size, csize,LOC offset fields are set to 0xFFFFFFFF, the disk\n+ * starting number is set to 0xFFFF or when we have a valid Zip64 Extra header\n+ * size but missing the corresponding field.\n+ * @run junit MissingZIP64EntriesTest\n+ *\/\n+public class MissingZIP64EntriesTest {\n+\n+    \/*\n+     * Byte array holding a ZIP file which contains a\n+     * Zip64 Extra Header with only the size field.\n+     *\n+     *  ----------------#1--------------------\n+     *  [Central Directory Header]\n+     *    0x4d: Signature        : 0x02014b50\n+     *    0x51: Created Zip Spec :       0x2d [4.5]\n+     *    0x52: Created OS       :        0x0 [MS-DOS]\n+     *    0x53: VerMadeby        :       0x2d [0, 4.5]\n+     *    0x54: VerExtract       :       0x2d [4.5]\n+     *    0x55: Flag             :      0x808\n+     *    0x57: Method           :        0x8 [DEFLATED]\n+     *    0x59: Last Mod Time    : 0x57116922 [Thu Aug 17 13:09:04 EDT 2023]\n+     *    0x5d: CRC              : 0x57de98d2\n+     *    0x61: Compressed Size  :       0x16\n+     *    0x65: Uncompressed Size: 0xffffffff\n+     *    0x69: Name Length      :        0x9\n+     *    0x6b: Extra Length     :        0xc\n+     *        Extra data:[01, 00, 08, 00, 14, 00, 00, 00, 00, 00, 00, 00]\n+     *           [tag=0x0001, sz=8]\n+     *               ->ZIP64: size *0x14 *0x6054b50\n+     *           [data= 14 00 00 00 00 00 00 00 ]\n+     *    0x6d: Comment Length   :        0x0\n+     *    0x6f: Disk Start       :        0x0\n+     *    0x71: Attrs            :        0x0\n+     *    0x73: AttrsEx          :        0x0\n+     *    0x77: Loc Header Offset:        0x0\n+     *    0x7b: File Name        : Hello.txt\n+     *\/\n+    public static byte[] ZIP_WITH_SINGLE_ZIP64_HEADER_ENTRY_BYTEARRAY = {\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4, (byte) 0x14, (byte) 0x0, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x8, (byte) 0x0, (byte) 0x22, (byte) 0x69, (byte) 0x11, (byte) 0x57, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x9, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x48, (byte) 0x65,\n+            (byte) 0x6c, (byte) 0x6c, (byte) 0x6f, (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0xf3,\n+            (byte) 0x48, (byte) 0xcd, (byte) 0xc9, (byte) 0xc9, (byte) 0x57, (byte) 0x8, (byte) 0x49, (byte) 0xcd,\n+            (byte) 0xcb, (byte) 0xcb, (byte) 0x2c, (byte) 0x56, (byte) 0x8, (byte) 0xc8, (byte) 0x49, (byte) 0xac,\n+            (byte) 0x4c, (byte) 0x2d, (byte) 0x2a, (byte) 0x6, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x7,\n+            (byte) 0x8, (byte) 0xd2, (byte) 0x98, (byte) 0xde, (byte) 0x57, (byte) 0x16, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x1,\n+            (byte) 0x2, (byte) 0x2d, (byte) 0x0, (byte) 0x2d, (byte) 0x0, (byte) 0x8, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x0, (byte) 0x22, (byte) 0x69, (byte) 0x11, (byte) 0x57, (byte) 0xd2, (byte) 0x98, (byte) 0xde,\n+            (byte) 0x57, (byte) 0x16, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n+            (byte) 0xff, (byte) 0x9, (byte) 0x0, (byte) 0xc, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x48, (byte) 0x65, (byte) 0x6c, (byte) 0x6c, (byte) 0x6f,\n+            (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0x1, (byte) 0x0, (byte) 0x8, (byte) 0x0,\n+            (byte) 0x14, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x5, (byte) 0x6, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x1, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x43, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x4d, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+    };\n+\n+    \/**\n+     * Byte array representing a Zip file with no extra header fields\n+     * ----------------#1--------------------\n+     * [Central Directory Header]\n+     *       0x2f: Signature        : 0x02014b50\n+     *       0x33: Created Zip Spec :       0x14 [2.0]\n+     *       0x34: Created OS       :        0x3 [UNIX]\n+     *       0x35: VerMadeby        :      0x314 [3, 2.0]\n+     *       0x36: VerExtract       :       0x14 [2.0]\n+     *       0x37: Flag             :        0x2\n+     *       0x39: Method           :        0x8 [DEFLATED]\n+     *       0x3b: Last Mod Time    : 0x57039c0d [Thu Aug 03 19:32:26 EDT 2023]\n+     *       0x3f: CRC              : 0x31963516\n+     *       0x43: Compressed Size  :        0x8\n+     *       0x47: Uncompressed Size:        0x6\n+     *       0x4b: Name Length      :        0x9\n+     *       0x4d: Extra Length     :        0x0\n+     *       0x4f: Comment Length   :        0x0\n+     *       0x51: Disk Start       :        0x0\n+     *       0x53: Attrs            :        0x1\n+     *       0x55: AttrsEx          : 0x81a40000\n+     *       0x59: Loc Header Offset:        0x0\n+     *       0x5d: File Name        : Hello.txt\n+     *\/\n+    public static byte[] ZIP_WITH_NO_EXTRA_LEN_BYTEARRAY = {\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4, (byte) 0x14, (byte) 0x0, (byte) 0x2, (byte) 0x0,\n+            (byte) 0x8, (byte) 0x0, (byte) 0xd, (byte) 0x9c, (byte) 0x3, (byte) 0x57, (byte) 0x16, (byte) 0x35,\n+            (byte) 0x96, (byte) 0x31, (byte) 0x8, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x6, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x9, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x48, (byte) 0x65,\n+            (byte) 0x6c, (byte) 0x6c, (byte) 0x6f, (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0xf3,\n+            (byte) 0x48, (byte) 0xcd, (byte) 0xc9, (byte) 0xc9, (byte) 0xe7, (byte) 0x2, (byte) 0x0, (byte) 0x50,\n+            (byte) 0x4b, (byte) 0x1, (byte) 0x2, (byte) 0x14, (byte) 0x3, (byte) 0x14, (byte) 0x0, (byte) 0x2,\n+            (byte) 0x0, (byte) 0x8, (byte) 0x0, (byte) 0xd, (byte) 0x9c, (byte) 0x3, (byte) 0x57, (byte) 0x16,\n+            (byte) 0x35, (byte) 0x96, (byte) 0x31, (byte) 0x8, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x6,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x9, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xa4,\n+            (byte) 0x81, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x48, (byte) 0x65, (byte) 0x6c,\n+            (byte) 0x6c, (byte) 0x6f, (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0x50, (byte) 0x4b,\n+            (byte) 0x5, (byte) 0x6, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0,\n+            (byte) 0x1, (byte) 0x0, (byte) 0x37, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x2f, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+    };\n+\n+    \/**\n+     * Enable debug output\n+     *\/\n+    private static final boolean DEBUG = false;\n+\n+    \/**\n+     * Name of the Zip file that we create from the byte array\n+     *\/\n+    public static final String ZIPFILE_NAME = \"validZipFile.zip\";\n+\n+    \/**\n+     * Name of the Zip file that we modify\/corrupt\n+     *\/\n+    public static final String BAD_ZIP_NAME = \"zipWithInvalidZip64ExtraField.zip\";\n+    \/**\n+     * Zip file entry that will be accessed by some the tests\n+     *\/\n+    private static final String ZIP_FILE_ENTRY_NAME = \"Hello.txt\";\n+\n+    \/**\n+     * Expected Error messages\n+     *\/\n+     private static final String MISSING_ZIP64_COMPRESSED_SIZE =\n+            \"Invalid Zip64 extra block, missing compressed size\";\n+     private static final String MISSING_ZIP64_LOC_OFFSET =\n+             \"Invalid Zip64 extra block, missing LOC offset value\";\n+     private static final String INVALID_EXTRA_LENGTH =\n+     \"Invalid CEN header (invalid zip64 extra len size)\";\n+\n+    \/**\n+     * Disk starting number offset for the Zip file created from the\n+     * ZIP_WITH_NO_EXTRA_LEN_BYTEARRAY array\n+     *\/\n+    private static final int DISKNO_OFFSET_ZIP_NO_EXTRA_LEN = 0x51;\n+\n+    \/**\n+     * Value to set the size, csize, or LOC offset CEN fields to when their\n+     * actual value is stored in the Zip64 Extra Header\n+     *\/\n+    private static final long ZIP64_MAGICVAL = 0xFFFFFFFFL;\n+\n+    \/**\n+     * Value to set the Disk Start number offset CEN field to when the\n+     * actual value is stored in the Zip64 Extra Header\n+     *\/\n+    private static final int  ZIP64_MAGICCOUNT = 0xFFFF;\n+\n+    \/**\n+     * Copy of the byte array for the ZIP to be modified by a given test run\n+     *\/\n+    private byte[] zipArrayCopy;\n+\n+    \/**\n+     * Little-endian ByteBuffer for manipulating the ZIP copy\n+     *\/\n+    private ByteBuffer buffer;\n+\n+    \/**\n+     * The DataProvider of offsets to set to 0xFFFFFFFF and the expected\n+     * ZipException error message when there are missing Zip64 Extra header fields\n+     * @return Arguments used in each test run\n+     *\/\n+    private static Stream<Arguments> InvalidZip64MagicValues() {\n+        return Stream.of(\n+                \/\/ Compressed Size offset and expected ZipException Message\n+                Arguments.of(0x61, MISSING_ZIP64_COMPRESSED_SIZE),\n+                \/\/ LOC offset and expected ZipException Message\n+                Arguments.of(0x77, MISSING_ZIP64_LOC_OFFSET)\n+        );\n+    }\n+\n+    \/**\n+     * The DataProvider of offsets to set to 0xFFFFFFFF or 0xFFFF when the Extra Length\n+     * size is 0 for the Zip file created using ZIP_WITH_NO_EXTRA_LEN_BYTEARRAY\n+     * @return Arguments used in each test run\n+     *\/\n+    private static Stream<Arguments> MissingZip64ExtraFieldEntries() {\n+        return Stream.of(\n+                \/\/ Compressed size offset\n+                Arguments.of(0x43),\n+                \/\/ Size offset\n+                Arguments.of(0x47),\n+                \/\/ Disk start number offset\n+                Arguments.of(DISKNO_OFFSET_ZIP_NO_EXTRA_LEN),\n+                \/\/ LOC offset\n+                Arguments.of(0x59)\n+        );\n+    }\n+\n+    \/**\n+     * The DataProvider which will return a byte array representing a\n+     * valid Zip file and the expected content for the Zip file entry 'Hello.txt'.\n+     * @return Arguments used in each test run\n+     *\/\n+    private static Stream<Arguments> validZipFiles() {\n+        return Stream.of(\n+                Arguments.of(ZIP_WITH_SINGLE_ZIP64_HEADER_ENTRY_BYTEARRAY,\n+                        \"Hello Tennis Players\"),\n+                Arguments.of(ZIP_WITH_NO_EXTRA_LEN_BYTEARRAY,\n+                        \"Hello\\n\")\n+        );\n+    }\n+\n+    \/**\n+     * Initial test setup\n+     * @throws IOException if an error occurs\n+     *\/\n+    @BeforeAll\n+    public static void setup() throws IOException {\n+        Files.deleteIfExists(Path.of(ZIPFILE_NAME));\n+        Files.deleteIfExists(Path.of(BAD_ZIP_NAME));\n+    }\n+\n+    \/**\n+     * Delete the Zip file that will be modified by each test\n+     * @throws IOException if an error occurs\n+     *\/\n+    @BeforeEach\n+    public void beforeEachTestRun() throws IOException {\n+        Files.deleteIfExists(Path.of(ZIPFILE_NAME));\n+        Files.deleteIfExists(Path.of(BAD_ZIP_NAME));\n+    }\n+\n+    \/**\n+     * Verify that a ZipException is thrown by ZipFile if the Zip64 header\n+     * does not contain the required field\n+     * @param offset Offset of the CEN Header field to set to 0xFFFFFFFF\n+     * @param errorMessage Expected ZipException error message\n+     * @throws IOException if an error occurs\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"InvalidZip64MagicValues\")\n+    public void invalidZip64ExtraHeaderZipFileTest(int offset, String errorMessage)\n+            throws IOException {\n+        \/\/ Set the CEN csize or LOC offset field to 0xFFFFFFFF.  There will not\n+        \/\/ be the expected Zip64 Extra Header field resulting in a ZipException\n+        \/\/ being thrown\n+        zipArrayCopy = ZIP_WITH_SINGLE_ZIP64_HEADER_ENTRY_BYTEARRAY.clone();\n+        buffer = ByteBuffer.wrap(zipArrayCopy).order(ByteOrder.LITTLE_ENDIAN);\n+        buffer.putInt(offset, (int) ZIP64_MAGICVAL);\n+        Files.write(Path.of(BAD_ZIP_NAME), zipArrayCopy);\n+\n+        ZipException ex = assertThrows(ZipException.class, () -> {\n+            try (ZipFile zf = new ZipFile(BAD_ZIP_NAME)) {\n+                ZipEntry ze = zf.getEntry(ZIP_FILE_ENTRY_NAME);\n+                try (InputStream is = zf.getInputStream(ze)) {\n+                    String result = new String(is.readAllBytes());\n+                    if (DEBUG) {\n+                        var hx = HexFormat.ofDelimiter(\", \").withPrefix(\"0x\");\n+                        System.out.printf(\"Error: Zip File read :%s%n[%s]%n\", result,\n+                                hx.formatHex(result.getBytes()));\n+                    }\n+                }\n+            }\n+        });\n+        assertTrue(ex.getMessage().matches(errorMessage),\n+                \"Unexpected ZipException message: \" + ex.getMessage());\n+    }\n+\n+    \/**\n+     * Verify that a ZipException is thrown by Zip FS if the Zip64 header\n+     * does not contain the required field\n+     * @param offset Offset of the CEN Header field to set to 0xFFFFFFFF\n+     * @param errorMessage Expected ZipException error message\n+     * @throws IOException if an error occurs\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"InvalidZip64MagicValues\")\n+    public void invalidZip64ExtraHeaderZipFSTest(int offset, String errorMessage) throws IOException {\n+        \/\/ Set the CEN csize or LOC offset field to 0xFFFFFFFF.  There will not\n+        \/\/ be the expected Zip64 Extra Header field resulting in a ZipException\n+        \/\/ being thrown\n+        zipArrayCopy = ZIP_WITH_SINGLE_ZIP64_HEADER_ENTRY_BYTEARRAY.clone();\n+        buffer = ByteBuffer.wrap(zipArrayCopy).order(ByteOrder.LITTLE_ENDIAN);\n+        buffer.putInt(offset, (int)ZIP64_MAGICVAL);\n+        Files.write(Path.of(BAD_ZIP_NAME), zipArrayCopy);\n+\n+        ZipException ex = assertThrows(ZipException.class, () -> {\n+            try (FileSystem fs = FileSystems.newFileSystem(\n+                    Path.of(BAD_ZIP_NAME), Map.of())) {\n+                Path p = fs.getPath(ZIP_FILE_ENTRY_NAME);\n+                String result = new String(Files.readAllBytes(p));\n+                if (DEBUG) {\n+                    var hx = HexFormat.ofDelimiter(\", \").withPrefix(\"0x\");\n+                    System.out.printf(\"Error: Zip FS read :%s%n[%s]%n\", result,\n+                            hx.formatHex(result.getBytes()));\n+                }\n+            }\n+        });\n+        assertTrue(ex.getMessage().matches(errorMessage),\n+                \"Unexpected ZipException message: \" + ex.getMessage());\n+    }\n+\n+    \/**\n+     * Validate that ZipFile will throw a ZipException if the\n+     * Extra length is 0 and the size, csize, LOC offset field is set to\n+     * 0xFFFFFFFF or the disk starting number is set to 0xFFFF\n+     * @throws IOException if an error occurs\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"MissingZip64ExtraFieldEntries\")\n+    public void zipFileBadExtraLength(int offset) throws IOException {\n+        zipArrayCopy = ZIP_WITH_NO_EXTRA_LEN_BYTEARRAY.clone();\n+        buffer = ByteBuffer.wrap(zipArrayCopy).order(ByteOrder.LITTLE_ENDIAN);\n+        if (offset == DISKNO_OFFSET_ZIP_NO_EXTRA_LEN) {\n+            buffer.putShort(offset, (short) ZIP64_MAGICCOUNT);\n+        } else {\n+            buffer.putInt(offset, (int) ZIP64_MAGICVAL);\n+        }\n+        Files.write(Path.of(BAD_ZIP_NAME), zipArrayCopy);\n+\n+        ZipException ex = assertThrows(ZipException.class, () -> {\n+            try (ZipFile zf = new ZipFile(BAD_ZIP_NAME)) {\n+                ZipEntry ze = zf.getEntry(ZIP_FILE_ENTRY_NAME);\n+                try (InputStream is = zf.getInputStream(ze)) {\n+                    String result = new String(is.readAllBytes());\n+                    if (DEBUG) {\n+                        var hx = HexFormat.ofDelimiter(\", \").withPrefix(\"0x\");\n+                        System.out.printf(\"Error: Zip File read :%s%n[%s]%n\", result,\n+                                hx.formatHex(result.getBytes()));\n+                    }\n+                }\n+            }\n+        });\n+        assertTrue(ex.getMessage().equals(INVALID_EXTRA_LENGTH),\n+                \"Unexpected ZipException message: \" + ex.getMessage());\n+    }\n+\n+    \/**\n+     * Validate that ZipFS will throw a ZipException if the\n+     * Extra length is 0 and the size, csize, LOC offset field is set to\n+     * 0xFFFFFFFF or the disk starting number is set to 0xFFFF\n+     * @throws IOException if an error occurs\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"MissingZip64ExtraFieldEntries\")\n+    public void zipFSBadExtraLength(int offset) throws IOException {\n+        zipArrayCopy = ZIP_WITH_NO_EXTRA_LEN_BYTEARRAY.clone();\n+        buffer = ByteBuffer.wrap(zipArrayCopy).order(ByteOrder.LITTLE_ENDIAN);\n+        if (offset == DISKNO_OFFSET_ZIP_NO_EXTRA_LEN) {\n+            buffer.putShort(offset, (short) ZIP64_MAGICCOUNT);\n+        } else {\n+            buffer.putInt(offset, (int) ZIP64_MAGICVAL);\n+        }\n+        Files.write(Path.of(BAD_ZIP_NAME), zipArrayCopy);\n+\n+        ZipException ex = assertThrows(ZipException.class, () -> {\n+            try (FileSystem fs = FileSystems.newFileSystem(\n+                    Path.of(BAD_ZIP_NAME), Map.of())) {\n+                Path p = fs.getPath(ZIP_FILE_ENTRY_NAME);\n+                String result = new String(Files.readAllBytes(p));\n+                if (DEBUG) {\n+                    var hx = HexFormat.ofDelimiter(\", \").withPrefix(\"0x\");\n+                    System.out.printf(\"Error: Zip FS read :%s%n[%s]%n\", result,\n+                            hx.formatHex(result.getBytes()));\n+                }\n+            }\n+        });\n+        assertTrue(ex.getMessage().equals(INVALID_EXTRA_LENGTH),\n+                \"Unexpected ZipException message: \" + ex.getMessage());\n+    }\n+\n+    \/**\n+     * Validate that ZipFile will read the Zip files created from the\n+     * byte arrays prior to modifying the arrays to check that the\n+     * expected ZipException is thrown.\n+     * @param  zipFile the byte array which represents the Zip file that should\n+     *                 be opened and read successfully.\n+     * @param message the expected text contained within the Zip entry\n+     * @throws IOException if an error occurs\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"validZipFiles\")\n+    public void readValidZipFile(byte[] zipFile, String message) throws IOException {\n+        \/\/ Write out the Zip file from the byte array\n+        Files.write(Path.of(ZIPFILE_NAME), zipFile);\n+\n+        try (ZipFile zip = new ZipFile(ZIPFILE_NAME)) {\n+            ZipEntry ze = zip.getEntry(ZIP_FILE_ENTRY_NAME);\n+            try (InputStream is = zip.getInputStream(ze)) {\n+                String result = new String(is.readAllBytes());\n+                if (DEBUG) {\n+                    var hx = HexFormat.ofDelimiter(\", \").withPrefix(\"0x\");\n+                    System.out.printf(\"ZipFile read :%s%n[%s]%n\", result,\n+                            hx.formatHex(result.getBytes()));\n+                }\n+                assertEquals(message, result);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Validate that ZipFS will read the Zip files created from the\n+     * byte arrays prior to modifying the arrays to check that the\n+     * expected ZipException is thrown.\n+     * @param  zipFile the byte array which represents the Zip file that should\n+     *                 be opened and read successfully.\n+     * @param message the expected text contained within the Zip entry\n+     * @throws IOException if an error occurs\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"validZipFiles\")\n+    public void readValidZipFileWithZipFs(byte[] zipFile, String message)\n+            throws IOException {\n+        \/\/ Write out the Zip file from the byte array\n+        Files.write(Path.of(ZIPFILE_NAME), zipFile);\n+\n+        try (FileSystem fs = FileSystems.newFileSystem(\n+                Path.of(ZIPFILE_NAME), Map.of())) {\n+            Path p = fs.getPath(ZIP_FILE_ENTRY_NAME);\n+            String result = new String(Files.readAllBytes(p));\n+            if (DEBUG) {\n+                var hx = HexFormat.ofDelimiter(\", \").withPrefix(\"0x\");\n+                System.out.printf(\"Zip FS read :%s%n[%s]%n\", result,\n+                        hx.formatHex(result.getBytes()));\n+            }\n+            assertEquals(message, result);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/MissingZIP64EntriesTest.java","additions":472,"deletions":0,"binary":false,"changes":472,"status":"added"}]}