{"files":[{"patch":"@@ -1267,0 +1267,1 @@\n+         * @param cenPos The CEN offset for the current Entry\n@@ -1322,4 +1323,5 @@\n-         * size and that the uncompressed size and compressed size field\n-         * values are not negative.\n-         * Note:  As we do not use the LOC offset or Starting disk number\n-         * field value we will not validate them\n+         * size; that the uncompressed size, compressed size field and LOC\n+         * offset fields are not negative. Also make sure the field exists if\n+         * the CEN header field is set to 0xFFFFFFFF.\n+         * Note:  As we do not use the Starting disk number field,\n+         * we will not validate its value\n@@ -1354,6 +1356,9 @@\n-            \/\/ Note we do not need to check blockSize is >= 8 as\n-            \/\/ we know its length is at least 8 from the call to\n-            \/\/ isZip64ExtBlockSizeValid()\n-            if ((size == ZIP64_MAGICVAL)) {\n-                if (get64(cen, off) < 0) {\n-                    zerror(\"Invalid zip64 extra block size value\");\n+            if (size == ZIP64_MAGICVAL) {\n+                if ( blockSize >= Long.BYTES) {\n+                    if (get64(cen, off) < 0) {\n+                        zerror(\"Invalid zip64 extra block size value\");\n+                    }\n+                    off += Long.BYTES;\n+                    blockSize -= Long.BYTES;\n+                } else {\n+                    zerror(\"Invalid Zip64 extra block, missing size\");\n@@ -1364,2 +1369,2 @@\n-                if (blockSize >= 16) {\n-                    if (get64(cen, off + 8) < 0) {\n+                if (blockSize >= Long.BYTES) {\n+                    if (get64(cen, off) < 0) {\n@@ -1368,0 +1373,2 @@\n+                    off += Long.BYTES;\n+                    blockSize -= Long.BYTES;\n@@ -1374,2 +1381,2 @@\n-                if (blockSize >= 24) {\n-                    if (get64(cen, off + 16) < 0) {\n+                if (blockSize >= Long.BYTES) {\n+                    if (get64(cen, off) < 0) {\n@@ -1378,0 +1385,4 @@\n+                    \/\/ Note: We do not need to adjust the following fields as\n+                    \/\/ this is the last field we are leveraging\n+                    \/\/ off += Long.BYTES;\n+                    \/\/ blockSize -= Long.BYTES;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":25,"deletions":14,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1588,1 +1588,4 @@\n-            if (elen == 0 && (size == ZIP64_MINVAL || csize == ZIP64_MINVAL ||\n+            if (elen > 0) {\n+                checkExtraFields(cen, pos, size, csize, locoff,\n+                        pos + CENHDR + nlen, elen);\n+            } else if (elen == 0 && (size == ZIP64_MINVAL || csize == ZIP64_MINVAL ||\n@@ -1613,0 +1616,157 @@\n+    \/**\n+     * Validate the Zip64 Extra block fields\n+     * @param cen CEN array\n+     * @param cenPos starting offset in the CEN for the Extra field\n+     * @param size CEN size value\n+     * @param csize CEN csize value\n+     * @param locoff CEN LOC offset value\n+     * @param startingOffset Extra Field starting offset within the CEN\n+     * @param extraFieldLen Length of this Extra field\n+     * @throws ZipException  If an error occurs validating the Zip64 Extra\n+     * block\n+     *\/\n+    private void checkExtraFields( byte[] cen, int cenPos, long size, long csize,\n+                                   long locoff, int startingOffset,\n+                                   int extraFieldLen) throws ZipException {\n+        \/\/ Extra field Length cannot exceed 65,535 bytes per the PKWare\n+        \/\/ APP.note 4.4.11\n+        if (extraFieldLen > 0xFFFF) {\n+            zerror(\"invalid extra field length\");\n+        }\n+        \/\/ CEN Offset where this Extra field ends\n+        int extraEndOffset = startingOffset + extraFieldLen;\n+        if (extraEndOffset > cen.length - ENDHDR) {\n+            zerror(\"Invalid CEN header (extra data field size too long)\");\n+        }\n+        int currentOffset = startingOffset;\n+        \/\/ Walk through each Extra Header. Each Extra Header Must consist of:\n+        \/\/       Header ID - 2 bytes\n+        \/\/       Data Size - 2 bytes:\n+        while (currentOffset + Integer.BYTES <= extraEndOffset) {\n+            int tag = SH(cen, currentOffset);\n+            currentOffset += Short.BYTES;\n+\n+            int tagBlockSize = SH(cen, currentOffset);\n+            currentOffset += Short.BYTES;\n+            int tagBlockEndingOffset = currentOffset + tagBlockSize;\n+\n+            \/\/  The ending offset for this tag block should not go past the\n+            \/\/  offset for the end of the extra field\n+            if (tagBlockEndingOffset > extraEndOffset) {\n+                zerror(String.format(\n+                        \"Invalid CEN header (invalid extra data field size for \" +\n+                                \"tag: 0x%04x at %d)\",\n+                        tag, cenPos));\n+            }\n+\n+            if (tag == EXTID_ZIP64) {\n+                checkZip64ExtraFieldValues(cen, currentOffset, tagBlockSize,\n+                        csize, size, locoff);\n+            }\n+            currentOffset += tagBlockSize;\n+        }\n+    }\n+\n+    \/**\n+     * Validate the Zip64 Extended Information Extra Field (0x0001) block\n+     * size; that the uncompressed size, compressed size field and LOC\n+     * offset fields are not negative. Also make sure the field exists if\n+     * the CEN header field is set to 0xFFFFFFFF.\n+     * Note:  As we do not use the Starting disk number field,\n+     * we will not validate its value\n+     * @param cen CEN array\n+     * @param off the starting offset for the Zip64 field value\n+     * @param blockSize the size of the Zip64 Extended Extra Field\n+     * @param csize CEN header compressed size value\n+     * @param size CEN header uncompressed size value\n+     * @param locoff CEN header LOC offset\n+     * @throws ZipException if an error occurs\n+     *\/\n+    private void checkZip64ExtraFieldValues(byte[] cen, int off, int blockSize, long csize,\n+                                            long size, long locoff)\n+            throws ZipException {\n+        \/\/ if ZIP64_EXTID blocksize == 0, which may occur with some older\n+        \/\/ versions of Apache Ant and Commons Compress, validate csize and size\n+        \/\/ to make sure neither field == ZIP64_MAGICVAL\n+        if (blockSize == 0) {\n+            if (csize == ZIP64_MINVAL || size == ZIP64_MINVAL ||\n+                    locoff == ZIP64_MINVAL) {\n+                zerror(\"Invalid CEN header (invalid zip64 extra data field size)\");\n+            }\n+            \/\/ Only validate the ZIP64_EXTID data if the block size > 0\n+            return;\n+        }\n+        \/\/ Validate the Zip64 Extended Information Extra Field (0x0001)\n+        \/\/ length.\n+        if (!isZip64ExtBlockSizeValid(blockSize)) {\n+            zerror(\"Invalid CEN header (invalid zip64 extra data field size)\");\n+        }\n+        \/\/ Check the uncompressed size is not negative\n+        if (size == ZIP64_MINVAL) {\n+            if (blockSize >= Long.BYTES) {\n+                if (LL(cen, off) < 0) {\n+                    zerror(\"Invalid zip64 extra block size value\");\n+                }\n+                off += Long.BYTES;\n+                blockSize -= Long.BYTES;\n+            } else {\n+                zerror(\"Invalid Zip64 extra block, missing size\");\n+            }\n+        }\n+        \/\/ Check the compressed size is not negative\n+        if (csize == ZIP64_MINVAL) {\n+            if (blockSize >= Long.BYTES) {\n+                if (LL(cen, off) < 0) {\n+                    zerror(\"Invalid zip64 extra block compressed size value\");\n+                }\n+                off += Long.BYTES;\n+                blockSize -= Long.BYTES;\n+            } else {\n+                zerror(\"Invalid Zip64 extra block, missing compressed size\");\n+            }\n+        }\n+        \/\/ Check the LOC offset is not negative\n+        if (locoff == ZIP64_MINVAL) {\n+            if (blockSize >= Long.BYTES) {\n+                if (LL(cen, off) < 0) {\n+                    zerror(\"Invalid zip64 extra block LOC OFFSET value\");\n+                }\n+                \/\/ Note: We do not need to adjust the following fields as\n+                \/\/ this is the last field we are leveraging\n+                \/\/ off += Long.BYTES;\n+                \/\/ blockSize -= Long.BYTES;\n+            } else {\n+                zerror(\"Invalid Zip64 extra block, missing LOC offset value\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Validate the size and contents of a Zip64 extended information field\n+     * The order of the Zip64 fields is fixed, but the fields MUST\n+     * only appear if the corresponding LOC or CEN field is set to 0xFFFF:\n+     * or 0xFFFFFFFF:\n+     * Uncompressed Size - 8 bytes\n+     * Compressed Size   - 8 bytes\n+     * LOC Header offset - 8 bytes\n+     * Disk Start Number - 4 bytes\n+     * See PKWare APP.Note Section 4.5.3 for more details\n+     *\n+     * @param blockSize the Zip64 Extended Information Extra Field size\n+     * @return true if the extra block size is valid; false otherwise\n+     *\/\n+    private static boolean isZip64ExtBlockSizeValid(int blockSize) {\n+        \/*\n+         * As the fields must appear in order, the block size indicates which\n+         * fields to expect:\n+         *  8 - uncompressed size\n+         * 16 - uncompressed size, compressed size\n+         * 24 - uncompressed size, compressed sise, LOC Header offset\n+         * 28 - uncompressed size, compressed sise, LOC Header offset,\n+         * and Disk start number\n+         *\/\n+        return switch(blockSize) {\n+            case 8, 16, 24, 28 -> true;\n+            default -> false;\n+        };\n+    }\n@@ -1632,0 +1792,4 @@\n+    private static void zerror(String msg) throws ZipException {\n+        throw new ZipException(msg);\n+    }\n+\n@@ -1640,1 +1804,0 @@\n-\n@@ -3092,1 +3255,1 @@\n-            while (off + 4 < elen) {\n+            while (off + 4 <= elen) {\n@@ -3105,14 +3268,1 @@\n-                case EXTID_ZIP64 :\n-                    \/\/ if ZIP64_EXTID blocksize == 0, which may occur with some older\n-                    \/\/ versions of Apache Ant and Commons Compress, validate csize\n-                    \/\/ size, and locoff to make sure the fields != ZIP64_MAGICVAL\n-                    if (sz == 0) {\n-                        if (csize == ZIP64_MINVAL || size == ZIP64_MINVAL || locoff == ZIP64_MINVAL) {\n-                            throw new ZipException(\"Invalid CEN header (invalid zip64 extra data field size)\");\n-                        }\n-                        break;\n-                    }\n-                    \/\/ Check to see if we have a valid block size\n-                    if (!isZip64ExtBlockSizeValid(sz)) {\n-                        throw new ZipException(\"Invalid CEN header (invalid zip64 extra data field size)\");\n-                    }\n+                case EXTID_ZIP64:\n@@ -3120,0 +3270,2 @@\n+                        if (pos + 8 > elen)  \/\/ invalid zip64 extra\n+                            break;           \/\/ fields, just skip\n@@ -3124,0 +3276,1 @@\n+                        pos += 8;\n@@ -3126,7 +3279,5 @@\n-                        if (sz >= 16) {\n-                            csize = LL(extra, pos + 8);\n-                            if (csize < 0) {\n-                                throw new ZipException(\"Invalid zip64 extra block compressed size value\");\n-                            }\n-                        } else {\n-                            throw new ZipException(\"Invalid Zip64 extra block, missing compressed size\");\n+                        if (pos + 8 > elen)\n+                            break;\n+                        csize = LL(extra, pos);\n+                        if (csize < 0) {\n+                            throw new ZipException(\"Invalid zip64 extra block compressed size value\");\n@@ -3134,0 +3285,1 @@\n+                        pos += 8;\n@@ -3136,7 +3288,5 @@\n-                        if (sz >= 24) {\n-                            locoff = LL(extra, pos + 16);\n-                            if (locoff < 0) {\n-                                throw new ZipException(\"Invalid zip64 extra block LOC offset value\");\n-                            }\n-                        } else {\n-                            throw new ZipException(\"Invalid Zip64 extra block, missing LOC offset value\");\n+                        if (pos + 8 > elen)\n+                            break;\n+                        locoff = LL(extra, pos);\n+                        if (locoff < 0) {\n+                            throw new ZipException(\"Invalid zip64 extra block LOC offset value\");\n@@ -3201,30 +3351,0 @@\n-        \/**\n-         * Validate the size and contents of a Zip64 extended information field\n-         * The order of the Zip64 fields is fixed, but the fields MUST\n-         * only appear if the corresponding LOC or CEN field is set to 0xFFFF:\n-         * or 0xFFFFFFFF:\n-         * Uncompressed Size - 8 bytes\n-         * Compressed Size   - 8 bytes\n-         * LOC Header offset - 8 bytes\n-         * Disk Start Number - 4 bytes\n-         * See PKWare APP.Note Section 4.5.3 for more details\n-         *\n-         * @param blockSize the Zip64 Extended Information Extra Field size\n-         * @return true if the extra block size is valid; false otherwise\n-         *\/\n-        private static boolean isZip64ExtBlockSizeValid(int blockSize) {\n-            \/*\n-             * As the fields must appear in order, the block size indicates which\n-             * fields to expect:\n-             *  8 - uncompressed size\n-             * 16 - uncompressed size, compressed size\n-             * 24 - uncompressed size, compressed sise, LOC Header offset\n-             * 28 - uncompressed size, compressed sise, LOC Header offset,\n-             * and Disk start number\n-             *\/\n-            return switch(blockSize) {\n-                case 8, 16, 24, 28 -> true;\n-                default -> false;\n-            };\n-        }\n-\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java","additions":181,"deletions":61,"binary":false,"changes":242,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n- * size but missing the corresponding field.\n+ * size but missing the expected header fields.\n@@ -57,1 +57,1 @@\n-     * Byte array holding a ZIP file which contains a\n+     * Byte array representing a ZIP file which contains a\n@@ -59,1 +59,0 @@\n-     *\n@@ -77,1 +76,1 @@\n-     *               ->ZIP64: size *0x14 *0x6054b50\n+     *               ->ZIP64: size *0x14\n@@ -86,1 +85,1 @@\n-    public static byte[] ZIP_WITH_SINGLE_ZIP64_HEADER_ENTRY_BYTEARRAY = {\n+    public static byte[] ZIP_WITH_ZIP64_EXTRAHDR_SIZE_ONLY_BYTEARRAY = {\n@@ -153,0 +152,273 @@\n+    \/**\n+     * Byte array representing a ZIP file which contains a\n+     * Zip64 Extra Header with only the LOC offset field.\n+     * ----------------#1--------------------\n+     * [Central Directory Header]\n+     *       0x4d: Signature        : 0x02014b50\n+     *       0x51: Created Zip Spec :       0x2d [4.5]\n+     *       0x52: Created OS       :        0x0 [MS-DOS]\n+     *       0x53: VerMadeby        :       0x2d [0, 4.5]\n+     *       0x54: VerExtract       :       0x2d [4.5]\n+     *       0x55: Flag             :      0x808\n+     *       0x57: Method           :        0x8 [DEFLATED]\n+     *       0x59: Last Mod Time    : 0x572d69c5 [Wed Sep 13 13:14:10 EDT 2023]\n+     *       0x5d: CRC              : 0x57de98d2\n+     *       0x61: Compressed Size  :       0x16\n+     *       0x65: Uncompressed Size:       0x14\n+     *       0x69: Name Length      :        0x9\n+     *       0x6b: Extra Length     :        0xc\n+     *       Extra data:[01, 00, 08, 00, 00, 00, 00, 00, 00, 00, 00, 00]\n+     * \t\t[tag=0x0001, sz=8]\n+     *          ->ZIP64: LOC Off *0x0\n+     *          [data= 00 00 00 00 00 00 00 00 ]\n+     *       0x6d: Comment Length   :        0x0\n+     *       0x6f: Disk Start       :        0x0\n+     *       0x71: Attrs            :        0x0\n+     *       0x73: AttrsEx          :        0x0\n+     *       0x77: Loc Header Offset: 0xffffffff\n+     *       0x7b: File Name        : Hello.txt\n+     *\/\n+    public static byte[] ZIP_WITH_ZIP64_EXTRAHDR_LOC_ONLY_BYTEARRAY = {\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4, (byte) 0x14, (byte) 0x0, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x8, (byte) 0x0, (byte) 0xc5, (byte) 0x69, (byte) 0x2d, (byte) 0x57, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x9, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x48, (byte) 0x65,\n+            (byte) 0x6c, (byte) 0x6c, (byte) 0x6f, (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0xf3,\n+            (byte) 0x48, (byte) 0xcd, (byte) 0xc9, (byte) 0xc9, (byte) 0x57, (byte) 0x8, (byte) 0x49, (byte) 0xcd,\n+            (byte) 0xcb, (byte) 0xcb, (byte) 0x2c, (byte) 0x56, (byte) 0x8, (byte) 0xc8, (byte) 0x49, (byte) 0xac,\n+            (byte) 0x4c, (byte) 0x2d, (byte) 0x2a, (byte) 0x6, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x7,\n+            (byte) 0x8, (byte) 0xd2, (byte) 0x98, (byte) 0xde, (byte) 0x57, (byte) 0x16, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x1,\n+            (byte) 0x2, (byte) 0x2d, (byte) 0x0, (byte) 0x2d, (byte) 0x0, (byte) 0x8, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x0, (byte) 0xc5, (byte) 0x69, (byte) 0x2d, (byte) 0x57, (byte) 0xd2, (byte) 0x98, (byte) 0xde,\n+            (byte) 0x57, (byte) 0x16, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x9, (byte) 0x0, (byte) 0xc, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xff,\n+            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0x48, (byte) 0x65, (byte) 0x6c, (byte) 0x6c, (byte) 0x6f,\n+            (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0x1, (byte) 0x0, (byte) 0x8, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x5, (byte) 0x6, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x1, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x43, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x4d, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+    };\n+\n+    \/**\n+     * Byte array representing a ZIP file which contains a\n+     * Zip64 Extra Header with only the compressed size field.\n+     * ----------------#1--------------------\n+     * [Central Directory Header]\n+     *       0x4d: Signature        : 0x02014b50\n+     *       0x51: Created Zip Spec :       0x2d [4.5]\n+     *       0x52: Created OS       :        0x0 [MS-DOS]\n+     *       0x53: VerMadeby        :       0x2d [0, 4.5]\n+     *       0x54: VerExtract       :       0x2d [4.5]\n+     *       0x55: Flag             :      0x808\n+     *       0x57: Method           :        0x8 [DEFLATED]\n+     *       0x59: Last Mod Time    : 0x572d6960 [Wed Sep 13 13:11:00 EDT 2023]\n+     *       0x5d: CRC              : 0x57de98d2\n+     *       0x61: Compressed Size  : 0xffffffff\n+     *       0x65: Uncompressed Size:       0x14\n+     *       0x69: Name Length      :        0x9\n+     *       0x6b: Extra Length     :        0xc\n+     *          Extra data:[01, 00, 08, 00, 16, 00, 00, 00, 00, 00, 00, 00]\n+     *       [tag=0x0001, sz=8]\n+     *          ->ZIP64: csize *0x16\n+     *          [data= 16 00 00 00 00 00 00 00 ]\n+     *       0x6d: Comment Length   :        0x0\n+     *       0x6f: Disk Start       :        0x0\n+     *       0x71: Attrs            :        0x0\n+     *       0x73: AttrsEx          :        0x0\n+     *       0x77: Loc Header Offset:        0x0\n+     *       0x7b: File Name        : Hello.txt\n+     *\/\n+    public static byte[] ZIP_WITH_ZIP64_EXTRAHDR_CSIZE_ONLY_BYTEARRAY = {\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4, (byte) 0x14, (byte) 0x0, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x8, (byte) 0x0, (byte) 0x60, (byte) 0x69, (byte) 0x2d, (byte) 0x57, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x9, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x48, (byte) 0x65,\n+            (byte) 0x6c, (byte) 0x6c, (byte) 0x6f, (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0xf3,\n+            (byte) 0x48, (byte) 0xcd, (byte) 0xc9, (byte) 0xc9, (byte) 0x57, (byte) 0x8, (byte) 0x49, (byte) 0xcd,\n+            (byte) 0xcb, (byte) 0xcb, (byte) 0x2c, (byte) 0x56, (byte) 0x8, (byte) 0xc8, (byte) 0x49, (byte) 0xac,\n+            (byte) 0x4c, (byte) 0x2d, (byte) 0x2a, (byte) 0x6, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x7,\n+            (byte) 0x8, (byte) 0xd2, (byte) 0x98, (byte) 0xde, (byte) 0x57, (byte) 0x16, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x1,\n+            (byte) 0x2, (byte) 0x2d, (byte) 0x0, (byte) 0x2d, (byte) 0x0, (byte) 0x8, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x0, (byte) 0x60, (byte) 0x69, (byte) 0x2d, (byte) 0x57, (byte) 0xd2, (byte) 0x98, (byte) 0xde,\n+            (byte) 0x57, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0x14, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x9, (byte) 0x0, (byte) 0xc, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x48, (byte) 0x65, (byte) 0x6c, (byte) 0x6c, (byte) 0x6f,\n+            (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0x1, (byte) 0x0, (byte) 0x8, (byte) 0x0,\n+            (byte) 0x16, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x5, (byte) 0x6, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x1, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x43, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x4d, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+    };\n+\n+    \/**\n+     * Byte array representing a Zip file with a zero length ZIP64 Extra Header\n+     * ----------------#1--------------------\n+     * [Central Directory Header]\n+     *       0x43: Signature        : 0x02014b50\n+     *       0x47: Created Zip Spec :       0x2d [4.5]\n+     *       0x48: Created OS       :        0x3 [UNIX]\n+     *       0x49: VerMadeby        :      0x32d [3, 4.5]\n+     *       0x4a: VerExtract       :       0x2d [4.5]\n+     *       0x4b: Flag             :      0x800\n+     *       0x4d: Method           :        0x8 [DEFLATED]\n+     *       0x4f: Last Mod Time    : 0x572c3477 [Tue Sep 12 06:35:46 EDT 2023]\n+     *       0x53: CRC              : 0x31963516\n+     *       0x57: Compressed Size  :        0x8\n+     *       0x5b: Uncompressed Size:        0x6\n+     *       0x5f: Name Length      :        0x9\n+     *       0x61: Extra Length     :        0x4\n+     *         Extra data:[01, 00, 00, 00]\n+     *         [tag=0x0001, sz=0]\n+     *           ->ZIP64:\n+     *       0x63: Comment Length   :        0x0\n+     *       0x65: Disk Start       :        0x0\n+     *       0x67: Attrs            :        0x0\n+     *       0x69: AttrsEx          : 0x81a40000\n+     *       0x6d: Loc Header Offset:        0x0\n+     *       0x71: File Name        : Hello.txt\n+     *\/\n+    public static byte[] ZIP_WITH_ZEROLEN_ZIP64_EXTRAHDR_BYTEARRAY = {\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4, (byte) 0x2d, (byte) 0x0, (byte) 0x0, (byte) 0x8,\n+            (byte) 0x8, (byte) 0x0, (byte) 0x77, (byte) 0x34, (byte) 0x2c, (byte) 0x57, (byte) 0x16, (byte) 0x35,\n+            (byte) 0x96, (byte) 0x31, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n+            (byte) 0xff, (byte) 0xff, (byte) 0x9, (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x48, (byte) 0x65,\n+            (byte) 0x6c, (byte) 0x6c, (byte) 0x6f, (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0x1,\n+            (byte) 0x0, (byte) 0x10, (byte) 0x0, (byte) 0x6, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x8, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xf3, (byte) 0x48, (byte) 0xcd, (byte) 0xc9, (byte) 0xc9,\n+            (byte) 0xe7, (byte) 0x2, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x1, (byte) 0x2, (byte) 0x2d,\n+            (byte) 0x3, (byte) 0x2d, (byte) 0x0, (byte) 0x0, (byte) 0x8, (byte) 0x8, (byte) 0x0, (byte) 0x77,\n+            (byte) 0x34, (byte) 0x2c, (byte) 0x57, (byte) 0x16, (byte) 0x35, (byte) 0x96, (byte) 0x31, (byte) 0x8,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x6, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x9,\n+            (byte) 0x0, (byte) 0x4, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xa4, (byte) 0x81, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x48, (byte) 0x65, (byte) 0x6c, (byte) 0x6c, (byte) 0x6f, (byte) 0x2e, (byte) 0x74,\n+            (byte) 0x78, (byte) 0x74, (byte) 0x1, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b,\n+            (byte) 0x6, (byte) 0x6, (byte) 0x2c, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x2d, (byte) 0x0, (byte) 0x2d, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x3b, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x43, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b,\n+            (byte) 0x6, (byte) 0x7, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x7e, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x5, (byte) 0x6, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x3b, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x43, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+    };\n+\n+    \/**\n+     * Byte array representing a ZIP file which contains a\n+     * Zip64 Extra Header with the size and csize fields.\n+     * ----------------#1--------------------\n+     * [Central Directory Header]\n+     *       0x4d: Signature        : 0x02014b50\n+     *       0x51: Created Zip Spec :       0x2d [4.5]\n+     *       0x52: Created OS       :        0x0 [MS-DOS]\n+     *       0x53: VerMadeby        :       0x2d [0, 4.5]\n+     *       0x54: VerExtract       :       0x2d [4.5]\n+     *       0x55: Flag             :      0x808\n+     *       0x57: Method           :        0x8 [DEFLATED]\n+     *       0x59: Last Mod Time    : 0x572c6445 [Tue Sep 12 12:34:10 EDT 2023]\n+     *       0x5d: CRC              : 0x57de98d2\n+     *       0x61: Compressed Size  : 0xffffffff\n+     *       0x65: Uncompressed Size: 0xffffffff\n+     *       0x69: Name Length      :        0x9\n+     *       0x6b: Extra Length     :       0x14\n+     *          Extra data:[01, 00, 10, 00, 14, 00, 00, 00, 00, 00, 00, 00, 16, 00, 00, 00, 00, 00, 00, 00]\n+     *       [tag=0x0001, sz=16]\n+     *          ->ZIP64: size *0x14 csize *0x16\n+     *          [data= 14 00 00 00 00 00 00 00 16 00 00 00 00 00 00 00 ]\n+     *       0x6d: Comment Length   :        0x0\n+     *       0x6f: Disk Start       :        0x0\n+     *       0x71: Attrs            :        0x0\n+     *       0x73: AttrsEx          :        0x0\n+     *       0x77: Loc Header Offset:        0x0\n+     *       0x7b: File Name        : Hello.txt\n+     *\/\n+    public static byte[] ZIP_WITH_TWO_ZIP64_HEADER_ENTRIES_BYTEARRAY = {\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4, (byte) 0x14, (byte) 0x0, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x8, (byte) 0x0, (byte) 0x45, (byte) 0x64, (byte) 0x2c, (byte) 0x57, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x9, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x48, (byte) 0x65,\n+            (byte) 0x6c, (byte) 0x6c, (byte) 0x6f, (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0xf3,\n+            (byte) 0x48, (byte) 0xcd, (byte) 0xc9, (byte) 0xc9, (byte) 0x57, (byte) 0x8, (byte) 0x49, (byte) 0xcd,\n+            (byte) 0xcb, (byte) 0xcb, (byte) 0x2c, (byte) 0x56, (byte) 0x8, (byte) 0xc8, (byte) 0x49, (byte) 0xac,\n+            (byte) 0x4c, (byte) 0x2d, (byte) 0x2a, (byte) 0x6, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x7,\n+            (byte) 0x8, (byte) 0xd2, (byte) 0x98, (byte) 0xde, (byte) 0x57, (byte) 0x16, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x1,\n+            (byte) 0x2, (byte) 0x2d, (byte) 0x0, (byte) 0x2d, (byte) 0x0, (byte) 0x8, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x0, (byte) 0x45, (byte) 0x64, (byte) 0x2c, (byte) 0x57, (byte) 0xd2, (byte) 0x98, (byte) 0xde,\n+            (byte) 0x57, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n+            (byte) 0xff, (byte) 0x9, (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x48, (byte) 0x65, (byte) 0x6c, (byte) 0x6c, (byte) 0x6f,\n+            (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0x1, (byte) 0x0, (byte) 0x10, (byte) 0x0,\n+            (byte) 0x14, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x16, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x5, (byte) 0x6, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x1, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x4b, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x4d, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+    };\n+\n+    \/**\n+     * Byte array representing a ZIP file which contains a\n+     * Zip64 Extra Header with the size,csize, and LOC offset fields.\n+     * ----------------#1--------------------\n+     * [Central Directory Header]\n+     *       0x4d: Signature        : 0x02014b50\n+     *       0x51: Created Zip Spec :       0x2d [4.5]\n+     *       0x52: Created OS       :        0x0 [MS-DOS]\n+     *       0x53: VerMadeby        :       0x2d [0, 4.5]\n+     *       0x54: VerExtract       :       0x2d [4.5]\n+     *       0x55: Flag             :      0x808\n+     *       0x57: Method           :        0x8 [DEFLATED]\n+     *       0x59: Last Mod Time    : 0x572d7214 [Wed Sep 13 14:16:40 EDT 2023]\n+     *       0x5d: CRC              : 0x57de98d2\n+     *       0x61: Compressed Size  : 0xffffffff\n+     *       0x65: Uncompressed Size: 0xffffffff\n+     *       0x69: Name Length      :        0x9\n+     *       0x6b: Extra Length     :       0x1c\n+     *          Extra data:[01, 00, 18, 00, 14, 00, 00, 00, 00, 00, 00, 00, 16, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00]\n+     *        [tag=0x0001, sz=24]\n+     *         ->ZIP64: size *0x14 csize *0x16 LOC Off *0x0\n+     *         [data= 14 00 00 00 00 00 00 00 16 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ]\n+     *       0x6d: Comment Length   :        0x0\n+     *       0x6f: Disk Start       :        0x0\n+     *       0x71: Attrs            :        0x0\n+     *       0x73: AttrsEx          :        0x0\n+     *       0x77: Loc Header Offset: 0xffffffff\n+     *       0x7b: File Name        : Hello.txt\n+     *\/\n+    public static byte[] ZIP_WITH_ZIP64_EXTRAHDR_ALL_BYTEARRAY = {\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4, (byte) 0x14, (byte) 0x0, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x8, (byte) 0x0, (byte) 0x14, (byte) 0x72, (byte) 0x2d, (byte) 0x57, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x9, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x48, (byte) 0x65,\n+            (byte) 0x6c, (byte) 0x6c, (byte) 0x6f, (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0xf3,\n+            (byte) 0x48, (byte) 0xcd, (byte) 0xc9, (byte) 0xc9, (byte) 0x57, (byte) 0x8, (byte) 0x49, (byte) 0xcd,\n+            (byte) 0xcb, (byte) 0xcb, (byte) 0x2c, (byte) 0x56, (byte) 0x8, (byte) 0xc8, (byte) 0x49, (byte) 0xac,\n+            (byte) 0x4c, (byte) 0x2d, (byte) 0x2a, (byte) 0x6, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x7,\n+            (byte) 0x8, (byte) 0xd2, (byte) 0x98, (byte) 0xde, (byte) 0x57, (byte) 0x16, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x1,\n+            (byte) 0x2, (byte) 0x2d, (byte) 0x0, (byte) 0x2d, (byte) 0x0, (byte) 0x8, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x0, (byte) 0x14, (byte) 0x72, (byte) 0x2d, (byte) 0x57, (byte) 0xd2, (byte) 0x98, (byte) 0xde,\n+            (byte) 0x57, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n+            (byte) 0xff, (byte) 0x9, (byte) 0x0, (byte) 0x1c, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xff,\n+            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0x48, (byte) 0x65, (byte) 0x6c, (byte) 0x6c, (byte) 0x6f,\n+            (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0x1, (byte) 0x0, (byte) 0x18, (byte) 0x0,\n+            (byte) 0x14, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x16, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x5, (byte) 0x6, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x1, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x53, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x4d, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+    };\n+\n@@ -167,0 +439,1 @@\n+\n@@ -182,1 +455,4 @@\n-    \/**\n+     private static final String INVALID_ZIP64_EXTRAHDR_SIZE =\n+             \"Invalid CEN header (invalid zip64 extra data field size)\";\n+\n+     \/**\n@@ -198,1 +474,1 @@\n-    private static final int  ZIP64_MAGICCOUNT = 0xFFFF;\n+    private static final int ZIP64_MAGICCOUNT = 0xFFFF;\n@@ -211,1 +487,2 @@\n-     * The DataProvider of offsets to set to 0xFFFFFFFF and the expected\n+     * The DataProvider returning a byte array representing the Zip file,\n+     * CEN offsets to set to 0xFFFFFFFF and the expected\n@@ -217,4 +494,10 @@\n-                \/\/ Compressed Size offset and expected ZipException Message\n-                Arguments.of(0x61, MISSING_ZIP64_COMPRESSED_SIZE),\n-                \/\/ LOC offset and expected ZipException Message\n-                Arguments.of(0x77, MISSING_ZIP64_LOC_OFFSET)\n+                \/\/ Byte array representing the Zip file, compressed size offset,\n+                \/\/ and expected ZipException Message\n+                Arguments.of(ZIP_WITH_ZIP64_EXTRAHDR_SIZE_ONLY_BYTEARRAY,\n+                        0x61, MISSING_ZIP64_COMPRESSED_SIZE),\n+                \/\/ Byte array representing the Zip file, LOC offset and expected ZipException Message\n+                Arguments.of(ZIP_WITH_ZIP64_EXTRAHDR_SIZE_ONLY_BYTEARRAY,\n+                        0x77, MISSING_ZIP64_LOC_OFFSET),\n+                \/\/ Byte array representing the Zip file, LOC offset and expected ZipException Message\n+                Arguments.of(ZIP_WITH_TWO_ZIP64_HEADER_ENTRIES_BYTEARRAY,\n+                        0x77, MISSING_ZIP64_LOC_OFFSET)\n@@ -225,1 +508,1 @@\n-     * The DataProvider of offsets to set to 0xFFFFFFFF or 0xFFFF when the Extra Length\n+     * The DataProvider of CEN offsets to set to 0xFFFFFFFF or 0xFFFF when the Extra Length\n@@ -242,0 +525,17 @@\n+    \/**\n+     * The DataProvider of CEN offsets to set to 0xFFFFFFFF when the ZIP64 extra header\n+     * Length size is 0 for the Zip file created using\n+     * ZIP_WITH_ZEROLEN_ZIP64_EXTRAHDR_BYTEARRAY\n+     * @return Arguments used in each test run\n+     *\/\n+    private static Stream<Arguments> zip64ZeroLenHeaderExtraFieldEntries() {\n+        return Stream.of(\n+                \/\/ Compressed size offset\n+                Arguments.of(0x57),\n+                \/\/ Size offset\n+                Arguments.of(0x5b),\n+                \/\/ LOC offset\n+                Arguments.of(0x6d)\n+        );\n+    }\n+\n@@ -249,1 +549,10 @@\n-                Arguments.of(ZIP_WITH_SINGLE_ZIP64_HEADER_ENTRY_BYTEARRAY,\n+                \/\/ Byte array representing the Zip file, and the expected entry content\n+                Arguments.of(ZIP_WITH_ZIP64_EXTRAHDR_SIZE_ONLY_BYTEARRAY,\n+                        \"Hello Tennis Players\"),\n+                Arguments.of(ZIP_WITH_TWO_ZIP64_HEADER_ENTRIES_BYTEARRAY,\n+                        \"Hello Tennis Players\"),\n+                Arguments.of(ZIP_WITH_ZIP64_EXTRAHDR_LOC_ONLY_BYTEARRAY,\n+                        \"Hello Tennis Players\"),\n+                Arguments.of(ZIP_WITH_ZIP64_EXTRAHDR_CSIZE_ONLY_BYTEARRAY,\n+                        \"Hello Tennis Players\"),\n+                Arguments.of(ZIP_WITH_ZIP64_EXTRAHDR_ALL_BYTEARRAY,\n@@ -279,0 +588,1 @@\n+     * @param zipArray Byte array representing the Zip file\n@@ -285,2 +595,2 @@\n-    public void invalidZip64ExtraHeaderZipFileTest(int offset, String errorMessage)\n-            throws IOException {\n+    public void invalidZip64ExtraHeaderZipFileTest(byte[] zipArray, int offset,\n+                                                   String errorMessage) throws IOException {\n@@ -290,1 +600,1 @@\n-        zipArrayCopy = ZIP_WITH_SINGLE_ZIP64_HEADER_ENTRY_BYTEARRAY.clone();\n+        zipArrayCopy = zipArray.clone();\n@@ -296,11 +606,1 @@\n-            try (ZipFile zf = new ZipFile(BAD_ZIP_NAME)) {\n-                ZipEntry ze = zf.getEntry(ZIP_FILE_ENTRY_NAME);\n-                try (InputStream is = zf.getInputStream(ze)) {\n-                    String result = new String(is.readAllBytes());\n-                    if (DEBUG) {\n-                        var hx = HexFormat.ofDelimiter(\", \").withPrefix(\"0x\");\n-                        System.out.printf(\"Error: Zip File read :%s%n[%s]%n\", result,\n-                                hx.formatHex(result.getBytes()));\n-                    }\n-                }\n-            }\n+            openWithZipFile(BAD_ZIP_NAME, ZIP_FILE_ENTRY_NAME, null);\n@@ -315,0 +615,1 @@\n+     * @param zipArray Byte array representing the Zip file\n@@ -321,1 +622,2 @@\n-    public void invalidZip64ExtraHeaderZipFSTest(int offset, String errorMessage) throws IOException {\n+    public void invalidZip64ExtraHeaderZipFSTest(byte[] zipArray, int offset,\n+                                                 String errorMessage) throws IOException {\n@@ -325,1 +627,1 @@\n-        zipArrayCopy = ZIP_WITH_SINGLE_ZIP64_HEADER_ENTRY_BYTEARRAY.clone();\n+        zipArrayCopy = zipArray.clone();\n@@ -331,10 +633,1 @@\n-            try (FileSystem fs = FileSystems.newFileSystem(\n-                    Path.of(BAD_ZIP_NAME), Map.of())) {\n-                Path p = fs.getPath(ZIP_FILE_ENTRY_NAME);\n-                String result = new String(Files.readAllBytes(p));\n-                if (DEBUG) {\n-                    var hx = HexFormat.ofDelimiter(\", \").withPrefix(\"0x\");\n-                    System.out.printf(\"Error: Zip FS read :%s%n[%s]%n\", result,\n-                            hx.formatHex(result.getBytes()));\n-                }\n-            }\n+            openWithZipFS(BAD_ZIP_NAME, ZIP_FILE_ENTRY_NAME, null);\n@@ -347,2 +640,2 @@\n-     * Validate that ZipFile will throw a ZipException if the\n-     * Extra length is 0 and the size, csize, LOC offset field is set to\n+     * Verify that ZipFile will throw a ZipException if the CEN\n+     * Extra length is 0 and the  CEN size, csize, LOC offset field is set to\n@@ -350,0 +643,1 @@\n+     * @param offset Offset of the CEN Header field to set to 0xFFFFFFFF or 0xFFFF\n@@ -365,11 +659,1 @@\n-            try (ZipFile zf = new ZipFile(BAD_ZIP_NAME)) {\n-                ZipEntry ze = zf.getEntry(ZIP_FILE_ENTRY_NAME);\n-                try (InputStream is = zf.getInputStream(ze)) {\n-                    String result = new String(is.readAllBytes());\n-                    if (DEBUG) {\n-                        var hx = HexFormat.ofDelimiter(\", \").withPrefix(\"0x\");\n-                        System.out.printf(\"Error: Zip File read :%s%n[%s]%n\", result,\n-                                hx.formatHex(result.getBytes()));\n-                    }\n-                }\n-            }\n+            openWithZipFile(BAD_ZIP_NAME, ZIP_FILE_ENTRY_NAME, null);\n@@ -382,2 +666,2 @@\n-     * Validate that ZipFS will throw a ZipException if the\n-     * Extra length is 0 and the size, csize, LOC offset field is set to\n+     * Verify that ZipFS will throw a ZipException if the CEN\n+     * Extra length is 0 and the CEN size, csize, LOC offset field is set to\n@@ -385,0 +669,1 @@\n+     * @param offset the offset of the CEN Header field to set to 0xFFFFFFFF or 0xFFFF\n@@ -400,10 +685,1 @@\n-            try (FileSystem fs = FileSystems.newFileSystem(\n-                    Path.of(BAD_ZIP_NAME), Map.of())) {\n-                Path p = fs.getPath(ZIP_FILE_ENTRY_NAME);\n-                String result = new String(Files.readAllBytes(p));\n-                if (DEBUG) {\n-                    var hx = HexFormat.ofDelimiter(\", \").withPrefix(\"0x\");\n-                    System.out.printf(\"Error: Zip FS read :%s%n[%s]%n\", result,\n-                            hx.formatHex(result.getBytes()));\n-                }\n-            }\n+            openWithZipFS(BAD_ZIP_NAME, ZIP_FILE_ENTRY_NAME, null);\n@@ -416,1 +692,43 @@\n-     * Validate that ZipFile will read the Zip files created from the\n+     * Verify that ZipFile will throw a ZipException if the ZIP64 extra header\n+     * has a size of 0 and the CEN size, csize, or the LOC offset field is set to\n+     * 0xFFFFFFFF\n+     * @param offset the offset of the CEN Header field to set to 0xFFFFFFFF\n+     * @throws IOException if an error occurs\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"zip64ZeroLenHeaderExtraFieldEntries\")\n+    public void zipFileZeroLenExtraHeader(int offset) throws IOException {\n+        zipArrayCopy = ZIP_WITH_ZEROLEN_ZIP64_EXTRAHDR_BYTEARRAY.clone();\n+        buffer = ByteBuffer.wrap(zipArrayCopy).order(ByteOrder.LITTLE_ENDIAN);\n+        buffer.putInt(offset, (int) ZIP64_MAGICVAL);\n+        Files.write(Path.of(BAD_ZIP_NAME), zipArrayCopy);\n+        ZipException ex = assertThrows(ZipException.class, () -> {\n+            openWithZipFile(BAD_ZIP_NAME, ZIP_FILE_ENTRY_NAME, null);\n+        });\n+        assertTrue(ex.getMessage().equals(INVALID_ZIP64_EXTRAHDR_SIZE),\n+                \"Unexpected ZipException message: \" + ex.getMessage());\n+    }\n+\n+    \/**\n+     * Verify that ZipFS will throw a ZipException if the ZIP64 extra header\n+     * has a size of 0 and the CEN size, csize, or the LOC offset field is set to\n+     * 0xFFFFFFFF\n+     * @param offset the offset of the CEN Header field to set to 0xFFFFFFFF\n+     * @throws IOException if an error occurs\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"zip64ZeroLenHeaderExtraFieldEntries\")\n+    public void zipFSZeroLenExtraHeader(int offset) throws IOException {\n+        zipArrayCopy = ZIP_WITH_ZEROLEN_ZIP64_EXTRAHDR_BYTEARRAY.clone();\n+        buffer = ByteBuffer.wrap(zipArrayCopy).order(ByteOrder.LITTLE_ENDIAN);\n+        buffer.putInt(offset, (int) ZIP64_MAGICVAL);\n+        Files.write(Path.of(BAD_ZIP_NAME), zipArrayCopy);\n+        ZipException ex = assertThrows(ZipException.class, () -> {\n+            openWithZipFS(BAD_ZIP_NAME, ZIP_FILE_ENTRY_NAME, null);\n+        });\n+        assertTrue(ex.getMessage().equals(INVALID_ZIP64_EXTRAHDR_SIZE),\n+                \"Unexpected ZipException message: \" + ex.getMessage());\n+    }\n+\n+    \/**\n+     * Verify that ZipFile will read the Zip files created from the\n@@ -429,13 +747,1 @@\n-\n-        try (ZipFile zip = new ZipFile(ZIPFILE_NAME)) {\n-            ZipEntry ze = zip.getEntry(ZIP_FILE_ENTRY_NAME);\n-            try (InputStream is = zip.getInputStream(ze)) {\n-                String result = new String(is.readAllBytes());\n-                if (DEBUG) {\n-                    var hx = HexFormat.ofDelimiter(\", \").withPrefix(\"0x\");\n-                    System.out.printf(\"ZipFile read :%s%n[%s]%n\", result,\n-                            hx.formatHex(result.getBytes()));\n-                }\n-                assertEquals(message, result);\n-            }\n-        }\n+        openWithZipFile(ZIPFILE_NAME, ZIP_FILE_ENTRY_NAME, message);\n@@ -445,1 +751,1 @@\n-     * Validate that ZipFS will read the Zip files created from the\n+     * Verify that ZipFS will read the Zip files created from the\n@@ -459,0 +765,2 @@\n+        openWithZipFS(ZIPFILE_NAME, ZIP_FILE_ENTRY_NAME, message);\n+    }\n@@ -460,0 +768,37 @@\n+    \/**\n+     * Utility method used to open a Zip file using ZipFile by the tests.\n+     * @param zipFile name of the Zip file to open\n+     * @param entryName Zip entry to read when the Zip file is expected to be\n+     *                  able to be opened\n+     * @param entryContents the expected contents for the Zip entry\n+     * @throws IOException if an error occurs\n+     *\/\n+    private static void openWithZipFile(String zipFile, String entryName,\n+                                        String entryContents) throws IOException {\n+        try (ZipFile zf = new ZipFile(zipFile)) {\n+            ZipEntry ze = zf.getEntry(entryName);\n+            try (InputStream is = zf.getInputStream(ze)) {\n+                String result = new String(is.readAllBytes());\n+                if (DEBUG) {\n+                    var hx = HexFormat.ofDelimiter(\", \").withPrefix(\"0x\");\n+                    System.out.printf(\"Error: Zip File read :%s%n[%s]%n\", result,\n+                            hx.formatHex(result.getBytes()));\n+                }\n+                \/\/ entryContents will be null when an exception is expected\n+                if (entryContents != null) {\n+                    assertEquals(entryContents, result);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Utility method used to open a Zip file using ZipFS by the tests.\n+     * @param zipFile name of the Zip file to open\n+     * @param entryName Zip entry to read when the Zip file is expected to be\n+     *                  able to be opened\n+     * @param entryContents the expected contents for the Zip entry\n+     * @throws IOException if an error occurs\n+     *\/\n+    private static void openWithZipFS(String zipFile, String entryName,\n+                                      String entryContents) throws IOException {\n@@ -461,2 +806,2 @@\n-                Path.of(ZIPFILE_NAME), Map.of())) {\n-            Path p = fs.getPath(ZIP_FILE_ENTRY_NAME);\n+                Path.of(zipFile), Map.of())) {\n+            Path p = fs.getPath(entryName);\n@@ -466,1 +811,1 @@\n-                System.out.printf(\"Zip FS read :%s%n[%s]%n\", result,\n+                System.out.printf(\"Error: Zip FS read :%s%n[%s]%n\", result,\n@@ -469,1 +814,4 @@\n-            assertEquals(message, result);\n+            \/\/ entryContents will be null when an exception is expected\n+            if (entryContents != null) {\n+                assertEquals(entryContents, result);\n+            }\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/MissingZIP64EntriesTest.java","additions":432,"deletions":84,"binary":false,"changes":516,"status":"modified"}]}