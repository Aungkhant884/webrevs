{"files":[{"patch":"@@ -71,1 +71,1 @@\n-void ArchiveBuilder::SourceObjList::append(MetaspaceClosure::Ref* enclosing_ref, SourceObjInfo* src_info) {\n+void ArchiveBuilder::SourceObjList::append(SourceObjInfo* src_info) {\n@@ -89,6 +89,1 @@\n-  \/\/ so that we can copy\/relocate it later. E.g., if we have\n-  \/\/    class Foo { intx scala; Bar* ptr; }\n-  \/\/    Foo *f = 0x100;\n-  \/\/ To mark the f->ptr pointer on 64-bit platform, this function is called with\n-  \/\/    src_info()->obj() == 0x100\n-  \/\/    ref->addr() == 0x108\n+  \/\/ so that we can copy\/relocate it later.\n@@ -412,7 +407,1 @@\n-    return _builder->gather_one_source_obj(enclosing_ref(), ref, read_only);\n-  }\n-\n-  virtual void do_pending_ref(Ref* ref) {\n-    if (ref->obj() != nullptr) {\n-      _builder->remember_embedded_pointer_in_gathered_obj(enclosing_ref(), ref);\n-    }\n+    return _builder->gather_one_source_obj(ref, read_only);\n@@ -422,2 +411,1 @@\n-bool ArchiveBuilder::gather_one_source_obj(MetaspaceClosure::Ref* enclosing_ref,\n-                                           MetaspaceClosure::Ref* ref, bool read_only) {\n+bool ArchiveBuilder::gather_one_source_obj(MetaspaceClosure::Ref* ref, bool read_only) {\n@@ -428,1 +416,1 @@\n-  remember_embedded_pointer_in_gathered_obj(enclosing_ref, ref);\n+  remember_embedded_pointer_in_enclosing_obj(ref);\n@@ -443,1 +431,0 @@\n-    ref->set_user_data((void*)p);\n@@ -445,1 +432,1 @@\n-      _ro_src_objs.append(enclosing_ref, p);\n+      _ro_src_objs.append(p);\n@@ -447,1 +434,1 @@\n-      _rw_src_objs.append(enclosing_ref, p);\n+      _rw_src_objs.append(p);\n@@ -455,2 +442,2 @@\n-void ArchiveBuilder::remember_embedded_pointer_in_gathered_obj(MetaspaceClosure::Ref* enclosing_ref,\n-                                                               MetaspaceClosure::Ref* ref) {\n+\/\/ Remember that we have a pointer inside ref->enclosing_obj() that points to ref->obj()\n+void ArchiveBuilder::remember_embedded_pointer_in_enclosing_obj(MetaspaceClosure::Ref* ref) {\n@@ -459,5 +446,30 @@\n-  if (enclosing_ref != nullptr) {\n-    SourceObjInfo* src_info = (SourceObjInfo*)enclosing_ref->user_data();\n-    if (src_info == nullptr) {\n-      \/\/ source objects of point_to_it\/set_to_null types are not copied\n-      \/\/ so we don't need to remember their pointers.\n+  address enclosing_obj = ref->enclosing_obj();\n+  if (enclosing_obj == nullptr) {\n+    return;\n+  }\n+\n+  \/\/ We are dealing with 3 addresses:\n+  \/\/ address o    = ref->obj(): We have found an object whose address is o.\n+  \/\/ address* mpp = ref->mpp(): The object o is pointed to by a pointer whose address is mpp.\n+  \/\/                            I.e., (*mpp == o)\n+  \/\/ enclosing_obj            : If non-null, it is the object which has a field that points to o.\n+  \/\/                            mpp is the address if that field.\n+  \/\/\n+  \/\/ Example: We have an array whose first element points to a Method:\n+  \/\/     Method* o                     = 0x0000abcd;\n+  \/\/     Array<Method*>* enclosing_obj = 0x00001000;\n+  \/\/     enclosing_obj->at_put(0, o);\n+  \/\/\n+  \/\/ We the MetaspaceClosure iterates on the very first element of this array, we have\n+  \/\/     ref->obj()           == 0x0000abcd   (the Method)\n+  \/\/     ref->mpp()           == 0x00001008   (the location of the first element in the array)\n+  \/\/     ref->enclosing_obj() == 0x00001000   (the Array that contains the Method)\n+  \/\/\n+  \/\/ We use the above informatio to mark the bitmap to indicate that there's a pointer on address 0x00001008.\n+  SourceObjInfo* src_info = _src_obj_table.get(enclosing_obj);\n+  if (src_info == nullptr || !src_info->should_copy()) {\n+    \/\/ source objects of point_to_it\/set_to_null types are not copied\n+    \/\/ so we don't need to remember their pointers.\n+  } else {\n+    if (src_info->read_only()) {\n+      _ro_src_objs.remember_embedded_pointer(src_info, ref);\n@@ -465,5 +477,1 @@\n-      if (src_info->read_only()) {\n-        _ro_src_objs.remember_embedded_pointer(src_info, ref);\n-      } else {\n-        _rw_src_objs.remember_embedded_pointer(src_info, ref);\n-      }\n+      _rw_src_objs.remember_embedded_pointer(src_info, ref);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":40,"deletions":32,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-    void append(MetaspaceClosure::Ref* enclosing_ref, SourceObjInfo* src_info);\n+    void append(SourceObjInfo* src_info);\n@@ -333,2 +333,2 @@\n-  bool gather_one_source_obj(MetaspaceClosure::Ref* enclosing_ref, MetaspaceClosure::Ref* ref, bool read_only);\n-  void remember_embedded_pointer_in_gathered_obj(MetaspaceClosure::Ref* enclosing_ref, MetaspaceClosure::Ref* ref);\n+  bool gather_one_source_obj(MetaspaceClosure::Ref* ref, bool read_only);\n+  void remember_embedded_pointer_in_enclosing_obj(MetaspaceClosure::Ref* ref);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,7 +28,0 @@\n-\/\/ Update the reference to point to new_loc.\n-void MetaspaceClosure::Ref::update(address new_loc) const {\n-  log_trace(cds)(\"Ref: [\" PTR_FORMAT \"] -> \" PTR_FORMAT \" => \" PTR_FORMAT,\n-                 p2i(mpp()), p2i(obj()), p2i(new_loc));\n-  *addr() = new_loc;\n-}\n-\n@@ -36,0 +29,6 @@\n+  if (_enclosing_ref != nullptr) {\n+    assert(_nest_level > 0, \"sanity\");\n+    ref->set_enclosing_obj(_enclosing_ref->obj());\n+  } else {\n+    assert(_nest_level == 0, \"sanity\");\n+  }\n@@ -40,1 +39,0 @@\n-    do_pending_ref(ref);\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+    address _enclosing_obj;\n@@ -110,1 +111,0 @@\n-    void* _user_data;\n@@ -115,1 +115,1 @@\n-    Ref(Writability w) : _writability(w), _next(nullptr), _user_data(nullptr) {}\n+    Ref(Writability w) : _writability(w), _enclosing_obj(nullptr), _next(nullptr) {}\n@@ -133,1 +133,7 @@\n-    void update(address new_loc) const;\n+    \/\/ See comments in ArchiveBuilder::remember_embedded_pointer_in_enclosing_obj()\n+    address enclosing_obj() const {\n+      return _enclosing_obj;\n+    }\n+    void set_enclosing_obj(address obj) {\n+      _enclosing_obj = obj;\n+    }\n@@ -136,2 +142,0 @@\n-    void set_user_data(void* data)  { _user_data = data; }\n-    void* user_data()               { return _user_data; }\n@@ -254,0 +258,3 @@\n+  \/\/\n+  \/\/ When we are visting d, the _enclosing_ref is c,\n+  \/\/ When we are visting c, the _enclosing_ref is b, ... and so on.\n@@ -268,20 +275,0 @@\n-  \/\/ enclosing_ref() is used to compute the offset of a field in a C++ class. For example\n-  \/\/ class Foo { intx scala; Bar* ptr; }\n-  \/\/    Foo *f = 0x100;\n-  \/\/ when the f->ptr field is iterated with do_ref() on 64-bit platforms, we will have\n-  \/\/    do_ref(Ref* r) {\n-  \/\/       r->addr() == 0x108;                \/\/ == &f->ptr;\n-  \/\/       enclosing_ref()->obj() == 0x100;   \/\/ == foo\n-  \/\/ So we know that we are iterating upon a field at offset 8 of the object at 0x100.\n-  \/\/\n-  \/\/ Note that if we have stack overflow, do_pending_ref(r) will be called first and\n-  \/\/ do_ref(r) will be called later, for the same r. In this case, enclosing_ref() is valid only\n-  \/\/ when do_pending_ref(r) is called, and will return null when do_ref(r) is called.\n-  Ref* enclosing_ref() const {\n-    return _enclosing_ref;\n-  }\n-\n-  \/\/ This is called when a reference is placed in _pending_refs. Override this\n-  \/\/ function if you're using enclosing_ref(). See notes above.\n-  virtual void do_pending_ref(Ref* ref) {}\n-\n@@ -294,0 +281,2 @@\n+    \/\/ We cannot make stack allocation because the Ref may need to be saved in\n+    \/\/ _pending_refs to avoid overflowing the C call stack\n@@ -311,2 +300,2 @@\n-  \/\/ Hashtable*             h  = ...;  it->push(&h);     => Hashtable is not a subclass of MetaspaceObj\n-  \/\/ Array<Hashtable*>*     a6 = ...;  it->push(&a6);    => Hashtable is not a subclass of MetaspaceObj\n+  \/\/ MemoryPool*            p  = ...;  it->push(&p);     => MemoryPool is not a subclass of MetaspaceObj\n+  \/\/ Array<MemoryPool*>*    a6 = ...;  it->push(&a6);    => MemoryPool is not a subclass of MetaspaceObj\n@@ -336,16 +325,0 @@\n-\n-#if 0\n-  \/\/ Enable this block if you're changing the push(...) methods, to test for types that should be\n-  \/\/ disallowed. Each of the following \"push\" calls should result in a compile-time error.\n-  void test_disallowed_types(MetaspaceClosure* it) {\n-    Hashtable<bool, mtInternal>* h  = nullptr;\n-    it->push(&h);\n-\n-    Array<Hashtable<bool, mtInternal>*>* a6 = nullptr;\n-    it->push(&a6);\n-\n-    Array<int*>* a7 = nullptr;\n-    it->push(&a7);\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":16,"deletions":43,"binary":false,"changes":59,"status":"modified"}]}