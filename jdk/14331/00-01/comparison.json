{"files":[{"patch":"@@ -422,24 +422,9 @@\n-const Type* AddINode::add_ring(const Type* t0, const Type* t1) const {\n-  const TypeInt* r0 = t0->is_int();\n-  const TypeInt* r1 = t1->is_int();\n-\n-  \/\/ Because of the limit check, we know that the counted loop incr never overflows\n-  bool overflow_impossible = is_counted_loop_incr();\n-\n-  \/\/ Compute new range in jlong. Overflow \/ Underflow can be detected if the lo \/ hi\n-  \/\/ go outside the int range.\n-  jlong lo = java_add(r0->lo_as_long(), r1->lo_as_long());\n-  jlong hi = java_add(r0->hi_as_long(), r1->hi_as_long());\n-  int widen = MAX2(r0->_widen,r1->_widen);\n-\n-  if (overflow_impossible) {\n-    \/\/ Overflow \/ Underflow impossible\n-    if (hi < (jlong)min_jint || lo > (jlong)max_jint) {\n-      \/\/ [lo, hi] is outside of int range -> never valid\n-      assert(false, \"is there any such case?\"); \/\/ TODO remove\n-      return Type::TOP;\n-    } else {\n-      \/\/ To prevent type overflow, clamp bounds individually\n-      lo = MAX2((jlong)min_jint, lo);\n-      hi = MIN2((jlong)max_jint, hi);\n-      return TypeInt::make(lo, hi, widen);\n+const Type *AddINode::add_ring( const Type *t0, const Type *t1 ) const {\n+  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n+  const TypeInt *r1 = t1->is_int();\n+  int lo = java_add(r0->_lo, r1->_lo);\n+  int hi = java_add(r0->_hi, r1->_hi);\n+  if( !(r0->is_con() && r1->is_con()) ) {\n+    \/\/ Not both constants, compute approximate result\n+    if( (r0->_lo & r1->_lo) < 0 && lo >= 0 ) {\n+      lo = min_jint; hi = max_jint; \/\/ Underflow on the low side\n@@ -447,18 +432,2 @@\n-  } else {\n-    \/\/ Overflow \/ Underflow possible\n-    if (r0->is_con() && r1->is_con()) {\n-      \/\/ Both constants, compute precise result. Semantics define\n-      \/\/ overflow and underflow for integer addition as expected.\n-      \/\/ In particular: 0x80000000 + 0x80000000 --> 0x0\n-      jint add_con = java_add(r0->get_con(), r1->get_con());\n-      return TypeInt::make(add_con);\n-    } else {\n-      if (lo < (jlong)min_jint || hi > (jlong)max_jint) {\n-        \/\/ Overflow \/ Underflow -> return int\n-        return TypeInt::INT;\n-      } else {\n-        assert((jlong)min_jint <= lo &&\n-               lo <= hi &&\n-               hi <= (jlong)max_jint, \"no overflow\");\n-        return TypeInt::make(lo, hi, widen);\n-      }\n+    if( (~(r0->_hi | r1->_hi)) < 0 && hi < 0 ) {\n+      lo = min_jint; hi = max_jint; \/\/ Overflow on the high side\n@@ -466,0 +435,7 @@\n+    if( lo > hi ) {               \/\/ Handle overflow\n+      lo = min_jint; hi = max_jint;\n+    }\n+  } else {\n+    \/\/ both constants, compute precise result using 'lo' and 'hi'\n+    \/\/ Semantics define overflow and underflow for integer addition\n+    \/\/ as expected.  In particular: 0x80000000 + 0x80000000 --> 0x0\n@@ -467,0 +443,1 @@\n+  return TypeInt::make( lo, hi, MAX2(r0->_widen,r1->_widen) );\n@@ -469,11 +446,0 @@\n-bool AddINode::is_counted_loop_incr() const {\n-  PhiNode* phi = in(1)->isa_Phi();\n-  if (phi == nullptr || phi->in(2) != this) {\n-    return false; \/\/ AddI is not on backedge of a Phi\n-  }\n-  BaseCountedLoopNode* loop = phi->in(0)->isa_BaseCountedLoop();\n-  if (loop == nullptr || loop->incr() != this) {\n-    return false; \/\/ AddI is not incr of a BaseCountedLoop\n-  }\n-  return true;\n-}\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":19,"deletions":53,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"opto\/loopnode.hpp\"\n@@ -98,2 +97,0 @@\n-  bool is_counted_loop_incr() const;\n-\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1450,2 +1450,2 @@\n-\/\/ If cmp is part of a counted loop exit condition, and n is either the incr or limit,\n-\/\/ then return the counted loop Phi. Else return nullptr.\n+\/\/ Return counted loop Phi if as a counted loop exit condition, cmp\n+\/\/ compares the induction variable with n\n@@ -1459,1 +1459,1 @@\n-        if (cle->limit() == n || cle->incr() == n) {\n+        if (cle->limit() == n) {\n@@ -1521,6 +1521,0 @@\n-          \/\/ This can also have an effect on the counted loop incr. For\n-          \/\/ example we may be subsuming an identical AddI node, replacing\n-          \/\/ the incr. The new incr then cannot have a type overflow, which\n-          \/\/ may make its type more precise. Any potential incr must be a\n-          \/\/ user of the phi.\n-          add_users_to_worklist0(phi);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"}]}