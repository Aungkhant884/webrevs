{"files":[{"patch":"@@ -422,15 +422,24 @@\n-const Type *AddINode::add_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t1->is_int();\n-  int lo = java_add(r0->_lo, r1->_lo);\n-  int hi = java_add(r0->_hi, r1->_hi);\n-  if( !(r0->is_con() && r1->is_con()) ) {\n-    \/\/ Not both constants, compute approximate result\n-    if( (r0->_lo & r1->_lo) < 0 && lo >= 0 ) {\n-      lo = min_jint; hi = max_jint; \/\/ Underflow on the low side\n-    }\n-    if( (~(r0->_hi | r1->_hi)) < 0 && hi < 0 ) {\n-      lo = min_jint; hi = max_jint; \/\/ Overflow on the high side\n-    }\n-    if( lo > hi ) {               \/\/ Handle overflow\n-      lo = min_jint; hi = max_jint;\n+const Type* AddINode::add_ring(const Type* t0, const Type* t1) const {\n+  const TypeInt* r0 = t0->is_int();\n+  const TypeInt* r1 = t1->is_int();\n+\n+  \/\/ Because of the limit check, we know that the counted loop incr never overflows\n+  bool overflow_impossible = is_counted_loop_incr();\n+\n+  \/\/ Compute new range in jlong. Overflow \/ Underflow can be detected if the lo \/ hi\n+  \/\/ go outside the int range.\n+  jlong lo = java_add(r0->lo_as_long(), r1->lo_as_long());\n+  jlong hi = java_add(r0->hi_as_long(), r1->hi_as_long());\n+  int widen = MAX2(r0->_widen,r1->_widen);\n+\n+  if (overflow_impossible) {\n+    \/\/ Overflow \/ Underflow impossible\n+    if (hi < (jlong)min_jint || lo > (jlong)max_jint) {\n+      \/\/ [lo, hi] is outside of int range -> never valid\n+      assert(false, \"is there any such case?\"); \/\/ TODO remove\n+      return Type::TOP;\n+    } else {\n+      \/\/ To prevent type overflow, clamp bounds individually\n+      lo = MAX2((jlong)min_jint, lo);\n+      hi = MIN2((jlong)max_jint, hi);\n+      return TypeInt::make(lo, hi, widen);\n@@ -439,3 +448,18 @@\n-    \/\/ both constants, compute precise result using 'lo' and 'hi'\n-    \/\/ Semantics define overflow and underflow for integer addition\n-    \/\/ as expected.  In particular: 0x80000000 + 0x80000000 --> 0x0\n+    \/\/ Overflow \/ Underflow possible\n+    if (r0->is_con() && r1->is_con()) {\n+      \/\/ Both constants, compute precise result. Semantics define\n+      \/\/ overflow and underflow for integer addition as expected.\n+      \/\/ In particular: 0x80000000 + 0x80000000 --> 0x0\n+      jint add_con = java_add(r0->get_con(), r1->get_con());\n+      return TypeInt::make(add_con);\n+    } else {\n+      if (lo < (jlong)min_jint || hi > (jlong)max_jint) {\n+        \/\/ Overflow \/ Underflow -> return int\n+        return TypeInt::INT;\n+      } else {\n+        assert((jlong)min_jint <= lo &&\n+               lo <= hi &&\n+               hi <= (jlong)max_jint, \"no overflow\");\n+        return TypeInt::make(lo, hi, widen);\n+      }\n+    }\n@@ -443,1 +467,0 @@\n-  return TypeInt::make( lo, hi, MAX2(r0->_widen,r1->_widen) );\n@@ -446,0 +469,11 @@\n+bool AddINode::is_counted_loop_incr() const {\n+  PhiNode* phi = in(1)->isa_Phi();\n+  if (phi == nullptr || phi->in(2) != this) {\n+    return false; \/\/ AddI is not on backedge of a Phi\n+  }\n+  BaseCountedLoopNode* loop = phi->in(0)->isa_BaseCountedLoop();\n+  if (loop == nullptr || loop->incr() != this) {\n+    return false; \/\/ AddI is not incr of a BaseCountedLoop\n+  }\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":53,"deletions":19,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"opto\/loopnode.hpp\"\n@@ -97,0 +98,2 @@\n+  bool is_counted_loop_incr() const;\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1450,2 +1450,2 @@\n-\/\/ Return counted loop Phi if as a counted loop exit condition, cmp\n-\/\/ compares the induction variable with n\n+\/\/ If cmp is part of a counted loop exit condition, and n is either the incr or limit,\n+\/\/ then return the counted loop Phi. Else return nullptr.\n@@ -1459,1 +1459,1 @@\n-        if (cle->limit() == n) {\n+        if (cle->limit() == n || cle->incr() == n) {\n@@ -1521,0 +1521,6 @@\n+          \/\/ This can also have an effect on the counted loop incr. For\n+          \/\/ example we may be subsuming an identical AddI node, replacing\n+          \/\/ the incr. The new incr then cannot have a type overflow, which\n+          \/\/ may make its type more precise. Any potential incr must be a\n+          \/\/ user of the phi.\n+          add_users_to_worklist0(phi);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8308504\n+ * @summary With JDK-8303466 the unroll-limit became more precise, and does not overflow.\n+ *          We must ensure that the type of the loop incr also does not overflow.\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:RepeatCompilation=100\n+ *                   -XX:+StressIGVN\n+ *                   -XX:CompileOnly=compiler.loopopts.TestLoopIncrNoOverflow::test\n+ *                   compiler.loopopts.TestLoopIncrNoOverflow\n+ *\/\n+\n+package compiler.loopopts;\n+\n+public class TestLoopIncrNoOverflow {\n+    static int N;\n+\n+    static void test() {\n+        int arr[] = new int[N];\n+        short s = 1;\n+        double d = 1.0;\n+        for (int i = 49; i > 8; i--) {\n+            for (int j = 7; j > i; j -= 3) {\n+                if (i == 8) {\n+                    s *= arr[1];\n+                }\n+                d = arr[j];\n+            }\n+        }\n+        Double.doubleToLongBits(d);\n+    }\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 10_000; i++) {\n+            test();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestLoopIncrNoOverflow.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"}]}