{"files":[{"patch":"@@ -42,0 +42,1 @@\n+import java.lang.invoke.MethodHandle;\n@@ -131,1 +132,1 @@\n-    public void testSameModule() throws Throwable {\n+    public void testModule() throws Throwable {\n@@ -143,0 +144,4 @@\n+        assertTrue(Object.class.getModule().isExported(\"sun.invoke\", m1));\n+        assertTrue(Object.class.getModule().isExported(\"sun.invoke.empty\", m1));\n+        assertTrue(m1.isNamed());\n+        assertTrue(m1.getName().startsWith(\"jdk.MHProxy\"));\n@@ -179,1 +184,1 @@\n-    public void testNoInstantiation() throws IllegalAccessException {\n+    public void testNoAccess() {\n@@ -187,0 +192,10 @@\n+    @Test\n+    public void testNoInstantiation() throws ReflectiveOperationException {\n+        var mh = MethodHandles.zero(void.class);\n+        var instanceClass = asInterfaceInstance(Untrusted.class, mh).getClass();\n+        var ctor = instanceClass.getDeclaredConstructor(Lookup.class, MethodHandle.class, MethodHandle.class);\n+\n+        assertThrows(IllegalAccessException.class, () -> ctor.newInstance(Untrusted.leakLookup(), mh, mh));\n+        assertThrows(IllegalAccessException.class, () -> ctor.newInstance(MethodHandles.publicLookup(), mh, mh));\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/BasicTest.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -53,70 +53,70 @@\n-\t\/**\n-\t * Implementation notes:\n-\t *   - asInterfaceInstance() can only target static MethodHandle (adapters needed to call instance method?)\n-\t *   - baselineCompute will quickly degrade to GC test, if escape analysis is unable to spare the allocation\n-\t *   - testCreate* will always be slower if allocation is not eliminated; baselineAllocCompute makes sure allocation is present\n-\t *\/\n-\n-\tpublic int i;\n-\n-\tprivate MethodHandle target;\n-\tprivate Doable precreated;\n-\n-\t@Setup\n-\tpublic void setup() throws Throwable {\n-\t\ttarget = MethodHandles.lookup().findStatic(MethodHandleProxiesAsIFInstance.class, \"doWork\", MethodType.methodType(int.class, int.class));\n-\t\tprecreated = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\n-\t}\n-\n-\t@Benchmark\n-\tpublic Doable testCreate() {\n-\t\tDoable doable = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\n-\t\treturn doable;              \/\/ make sure allocation happens\n-\t}\n-\n-\t@Benchmark\n-\tpublic Doable testCreateCall() {\n-\t\tDoable doable = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\n-\t\ti = doable.doWork(i);       \/\/ make sure computation happens\n-\t\treturn null;                \/\/ let allocation be eliminated\n-\t}\n-\n-\t@Benchmark\n-\tpublic Doable testCall() {\n-\t\ti = precreated.doWork(i);   \/\/ make sure computation happens\n-\t\treturn precreated;\n-\t}\n-\n-\t@Benchmark\n-\tpublic Doable baselineCompute() {\n-\t\tDoable doable = new Doable() {\n-\t\t\t@Override\n-\t\t\tpublic int doWork(int i) {\n-\t\t\t\treturn MethodHandleProxiesAsIFInstance.doWork(i);\n-\t\t\t}\n-\t\t};\n-\n-\t\ti = doable.doWork(i);       \/\/ make sure computation happens\n-\t\treturn null;                \/\/ let allocation be eliminated\n-\t}\n-\n-\t@Benchmark\n-\tpublic Doable baselineAllocCompute() {\n-\t\tDoable doable = new Doable() {\n-\t\t\t@Override\n-\t\t\tpublic int doWork(int i) {\n-\t\t\t\treturn MethodHandleProxiesAsIFInstance.doWork(i);\n-\t\t\t}\n-\t\t};\n-\n-\t\ti = doable.doWork(i);       \/\/ make sure computation happens\n-\t\treturn doable;              \/\/ make sure allocation happens\n-\t}\n-\n-\tpublic static int doWork(int i) {\n-\t\treturn i + 1;\n-\t}\n-\n-\tpublic interface Doable {\n-\t\tint doWork(int i);\n-\t}\n+    \/**\n+     * Implementation notes:\n+     *   - asInterfaceInstance() can only target static MethodHandle (adapters needed to call instance method?)\n+     *   - baselineCompute will quickly degrade to GC test, if escape analysis is unable to spare the allocation\n+     *   - testCreate* will always be slower if allocation is not eliminated; baselineAllocCompute makes sure allocation is present\n+     *\/\n+\n+    public int i;\n+\n+    private MethodHandle target;\n+    private Doable precreated;\n+\n+    @Setup\n+    public void setup() throws Throwable {\n+        target = MethodHandles.lookup().findStatic(MethodHandleProxiesAsIFInstance.class, \"doWork\", MethodType.methodType(int.class, int.class));\n+        precreated = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\n+    }\n+\n+    @Benchmark\n+    public Doable testCreate() {\n+        Doable doable = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\n+        return doable;              \/\/ make sure allocation happens\n+    }\n+\n+    @Benchmark\n+    public Doable testCreateCall() {\n+        Doable doable = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\n+        i = doable.doWork(i);       \/\/ make sure computation happens\n+        return null;                \/\/ let allocation be eliminated\n+    }\n+\n+    @Benchmark\n+    public Doable testCall() {\n+        i = precreated.doWork(i);   \/\/ make sure computation happens\n+        return precreated;\n+    }\n+\n+    @Benchmark\n+    public Doable baselineCompute() {\n+        Doable doable = new Doable() {\n+            @Override\n+            public int doWork(int i) {\n+                return MethodHandleProxiesAsIFInstance.doWork(i);\n+            }\n+        };\n+\n+        i = doable.doWork(i);       \/\/ make sure computation happens\n+        return null;                \/\/ let allocation be eliminated\n+    }\n+\n+    @Benchmark\n+    public Doable baselineAllocCompute() {\n+        Doable doable = new Doable() {\n+            @Override\n+            public int doWork(int i) {\n+                return MethodHandleProxiesAsIFInstance.doWork(i);\n+            }\n+        };\n+\n+        i = doable.doWork(i);       \/\/ make sure computation happens\n+        return doable;              \/\/ make sure allocation happens\n+    }\n+\n+    public static int doWork(int i) {\n+        return i + 1;\n+    }\n+\n+    public interface Doable {\n+        int doWork(int i);\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/MethodHandleProxiesAsIFInstance.java","additions":70,"deletions":70,"binary":false,"changes":140,"status":"modified"}]}