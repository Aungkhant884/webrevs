{"files":[{"patch":"@@ -208,1 +208,2 @@\n-            proxy = lookup.findConstructor(lookup.lookupClass(), methodType(void.class)).invoke();\n+            proxy = lookup.findConstructor(lookup.lookupClass(), methodType(void.class, Lookup.class))\n+                    .invoke(lookup);\n@@ -283,0 +284,1 @@\n+    private static final ClassDesc CD_IllegalAccessError = desc(IllegalAccessError.class);\n@@ -284,0 +286,5 @@\n+    private static final MethodTypeDesc MTD_void_Lookup = MethodTypeDesc.of(CD_void, CD_MethodHandles_Lookup);\n+    private static final MethodTypeDesc MTD_Class = MethodTypeDesc.of(CD_Class);\n+    private static final MethodTypeDesc MTD_String = MethodTypeDesc.of(CD_String);\n+    private static final MethodTypeDesc MTD_void_String = MethodTypeDesc.of(CD_void, CD_String);\n+    private static final MethodTypeDesc MTD_int = MethodTypeDesc.of(CD_int);\n@@ -301,5 +308,28 @@\n-            \/\/ <init>\n-            clb.withMethodBody(INIT_NAME, MTD_void, 0, cob -> cob\n-                    .aload(0)\n-                    .invokespecial(CD_Object, INIT_NAME, MTD_void)\n-                    .return_());\n+            \/\/ <init>(Lookup)\n+            clb.withMethodBody(INIT_NAME, MTD_void_Lookup, 0, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+\n+                var failLabel = cob.newLabel();\n+                \/\/ check lookupClass\n+                cob.aload(1);\n+                cob.invokevirtual(CD_MethodHandles_Lookup, \"lookupClass\", MTD_Class);\n+                cob.constantInstruction(proxyDesc);\n+                cob.if_acmpne(failLabel);\n+                \/\/ check original access\n+                cob.aload(1);\n+                cob.invokevirtual(CD_MethodHandles_Lookup, \"lookupModes\", MTD_int);\n+                cob.constantInstruction(Lookup.ORIGINAL);\n+                cob.iand();\n+                cob.ifeq(failLabel);\n+                \/\/ success\n+                cob.return_();\n+                \/\/ throw exception\n+                cob.labelBinding(failLabel);\n+                cob.new_(CD_IllegalAccessError);\n+                cob.dup();\n+                cob.aload(1); \/\/ lookup\n+                cob.invokevirtual(CD_Object, \"toString\", MTD_String);\n+                cob.invokespecial(CD_IllegalAccessError, INIT_NAME, MTD_void_String);\n+                cob.athrow();\n+            });\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":36,"deletions":6,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @build BasicTest Untrusted\n@@ -43,0 +44,1 @@\n+import java.lang.invoke.MethodHandles.Lookup;\n@@ -51,1 +53,0 @@\n-import java.util.Objects;\n@@ -159,0 +160,14 @@\n+    @Test\n+    public void testNoInstantiation() throws IllegalAccessException, NoSuchMethodException {\n+        Untrusted untrusted = asInterfaceInstance(Untrusted.class, MethodHandles.zero(void.class));\n+        var instanceClass = untrusted.getClass();\n+        var leakLookup = Untrusted.leakLookup();\n+        assertEquals(Lookup.ORIGINAL, leakLookup.lookupModes() & Lookup.ORIGINAL, \"Leaked lookup original flag\");\n+        var intfLookup = MethodHandles.privateLookupIn(instanceClass, Untrusted.leakLookup());\n+        assertSame(instanceClass, intfLookup.lookupClass());\n+        assertTrue(intfLookup.hasFullPrivilegeAccess());\n+        assertEquals(0, intfLookup.lookupModes() & Lookup.ORIGINAL, \"reflected lookup original flag\");\n+        var ctor = intfLookup.findConstructor(instanceClass, methodType(void.class, Lookup.class));\n+        assertThrows(IllegalAccessError.class, () -> ctor.invoke(intfLookup));\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/BasicTest.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -24,0 +24,3 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+\n@@ -25,0 +28,7 @@\n+    \/**\n+     * Leaks a lookup that has full privilege access in Untrusted.class.\n+     *\/\n+    static Lookup leakLookup() {\n+        return MethodHandles.lookup();\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/Untrusted.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}