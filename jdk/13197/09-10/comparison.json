{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.module.ModuleDescriptor;\n@@ -36,2 +37,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -40,0 +39,1 @@\n+import java.util.HashSet;\n@@ -42,0 +42,2 @@\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -44,0 +46,2 @@\n+import jdk.internal.access.JavaLangReflectAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -47,0 +51,1 @@\n+import jdk.internal.module.Modules;\n@@ -55,0 +60,1 @@\n+import static java.lang.module.ModuleDescriptor.Modifier.SYNTHETIC;\n@@ -194,4 +200,15 @@\n-        \/\/ Interface-specific setup\n-        InterfaceInfo info = INTERFACE_INFOS.get(intfc); \/\/ throws IllegalArgumentException\n-        List<Object> classData = new ArrayList<>(info.types.length + 2);\n-        classData.add(info);\n+        \/*\n+         * For each interface I and each MH, define a new hidden class with\n+         * the target MH in the class data.\n+         *\n+         * The bytecode is generated only once.  One hidden class is defined\n+         * for each invocation of MethodHandleProxies::asInterfaceInstance(I, MH).\n+         * Therefore, one or more hidden classes may be defined for I.\n+         *\n+         * All the hidden classes defined for I are defined in a dynamic module M\n+         * which has access to the types referenced by the members of I including\n+         * the parameter types, return type and exception types.\n+         *\/\n+        ProxyClassDefiner pcd = PROXY_CLASS_DEFINERS.get(intfc); \/\/ throws IllegalArgumentException\n+        List<Object> classData = new ArrayList<>(pcd.types.length + 2);\n+        classData.add(intfc);\n@@ -199,1 +216,1 @@\n-        for (var methodType : info.types) {\n+        for (var methodType : pcd.types) {\n@@ -203,1 +220,0 @@\n-        \/\/ Define the class under the interface\n@@ -206,2 +222,1 @@\n-            var lookup = info.lookup.makeHiddenClassDefiner(info.template, DUMPER)\n-                    .defineClassAsLookup(true, classData);\n+            var lookup = pcd.definer().defineClassAsLookup(true, classData);\n@@ -209,1 +224,2 @@\n-                    .invoke(lookup);\n+                          .invoke(lookup);\n+            assert proxy.getClass().getModule().isNamed() : proxy.getClass() + \" \" + proxy.getClass().getModule();\n@@ -221,1 +237,1 @@\n-    private record InterfaceInfo(MethodType[] types, Lookup lookup, byte[] template) {}\n+    private record ProxyClassDefiner(Lookup.ClassDefiner definer, MethodType[] types, Class<?> intf, byte[] template) {}\n@@ -228,1 +244,1 @@\n-            \"jdk.invoke.MethodHandleProxies.dumpInterfaceInstances\", Path.of(\"DUMP_INTERFACE_INSTANCES\"));\n+            \"jdk.invoke.MethodHandleProxies.dumpClassFiles\", Path.of(\"DUMP_MH_PROXY_CLASSFILES\"));\n@@ -230,1 +246,5 @@\n-    private static final ClassValue<InterfaceInfo> INTERFACE_INFOS = new ClassValue<>() {\n+    \/*\n+     * A map from a given interface to the ProxyClassDefiner.\n+     * This creates a dynamic module for each interface.\n+     *\/\n+    private static final ClassValue<ProxyClassDefiner> PROXY_CLASS_DEFINERS = new ClassValue<>() {\n@@ -232,3 +252,4 @@\n-        protected InterfaceInfo computeValue(Class<?> intfc) {\n-            final List<Method> methods = getSingleNameMethods(intfc);\n-            if (methods == null)\n+        protected ProxyClassDefiner computeValue(Class<?> intfc) {\n+\n+            final SamInfo stats = getStats(intfc);\n+            if (stats == null)\n@@ -237,5 +258,6 @@\n-            List<LocalMethodInfo> infos = new ArrayList<>(methods.size());\n-            MethodType[] types = new MethodType[methods.size()];\n-            for (int i = 0; i < methods.size(); i++) {\n-                Method sm = methods.get(i);\n-                MethodType mt = methodType(sm.getReturnType(), sm.getParameterTypes());\n+            List<LocalMethodInfo> infos = new ArrayList<>(stats.methods.size());\n+            MethodType[] types = new MethodType[stats.methods.size()];\n+            for (int i = 0; i < stats.methods.size(); i++) {\n+                Method m = stats.methods.get(i);\n+                MethodType mt = methodType(m.getReturnType(), JLRA.getExecutableSharedParameterTypes(m));\n+                MethodTypeDesc mtDesc = desc(mt);\n@@ -243,1 +265,1 @@\n-                var thrown = sm.getExceptionTypes();\n+                var thrown = m.getExceptionTypes();\n@@ -245,1 +267,1 @@\n-                    infos.add(new LocalMethodInfo(desc(mt), DEFAULT_RETHROWS));\n+                    infos.add(new LocalMethodInfo(mtDesc, DEFAULT_RETHROWS));\n@@ -247,2 +269,5 @@\n-                    infos.add(new LocalMethodInfo(desc(mt), Stream.concat(DEFAULT_RETHROWS.stream(),\n-                            Arrays.stream(thrown).map(MethodHandleProxies::desc)).distinct().toList()));\n+                    infos.add(new LocalMethodInfo(mtDesc,\n+                                                  Stream.concat(DEFAULT_RETHROWS.stream(),\n+                                                                Arrays.stream(thrown)\n+                                                                      .map(MethodHandleProxies::desc))\n+                                                                      .distinct().toList()));\n@@ -252,12 +277,12 @@\n-            \/\/ default class hierarchy resolver accesses system resources\n-            @SuppressWarnings(\"removal\")\n-            var sm = System.getSecurityManager();\n-            @SuppressWarnings(\"removal\")\n-            byte[] template = sm != null ? AccessController.doPrivileged(new PrivilegedAction<byte[]>() {\n-                @Override\n-                public byte[] run() {\n-                    return createTemplate(desc(intfc), methods.get(0).getName(), infos);\n-                }\n-            }) : createTemplate(desc(intfc), methods.get(0).getName(), infos);\n-\n-            return new InterfaceInfo(types, new Lookup(intfc), template);\n+            Set<Class<?>> referencedTypes = stats.referencedTypes;\n+            Module targetModule = newDynamicModule(intfc.getClassLoader(), referencedTypes);\n+\n+            \/\/ generate a class file in the package of the dynamic module\n+            String pn = targetModule.getName();\n+            String n = intfc.getName() + \"$MHProxy\";\n+            int i = n.lastIndexOf('.');\n+            String cn = i > 0 ? pn + \".\" + n.substring(i+1) : pn + \".\" + n;\n+            ClassDesc proxyDesc = ClassDesc.of(cn);\n+            byte[] template = createTemplate(proxyDesc, desc(intfc), stats.singleName, infos);\n+            var definer = new Lookup(intfc).makeHiddenClassDefiner(cn, template, Set.of(), DUMPER);\n+            return new ProxyClassDefiner(definer, types, intfc, template);\n@@ -272,2 +297,1 @@\n-                    && l.get(0) instanceof InterfaceInfo info\n-                    && l.size() == info.types.length + 2\n+                    && l.get(0) instanceof Class<?> intfc\n@@ -275,1 +299,1 @@\n-                return new WrapperInfo(info.lookup.lookupClass(), mh);\n+                return new WrapperInfo(intfc, mh);\n@@ -277,1 +301,0 @@\n-\n@@ -284,1 +307,1 @@\n-    private static final ClassDesc CD_IllegalAccessError = desc(IllegalAccessError.class);\n+    private static final ClassDesc CD_IllegalAccessException = desc(IllegalAccessException.class);\n@@ -302,2 +325,1 @@\n-    private static byte[] createTemplate(ClassDesc ifaceDesc, String methodName, List<LocalMethodInfo> methods) {\n-        ClassDesc proxyDesc = ifaceDesc.nested(\"$MethodHandleProxy\");\n+    private static byte[] createTemplate(ClassDesc proxyDesc, ClassDesc ifaceDesc, String methodName, List<LocalMethodInfo> methods) {\n@@ -329,1 +351,1 @@\n-                cob.new_(CD_IllegalAccessError);\n+                cob.new_(CD_IllegalAccessException);\n@@ -333,1 +355,1 @@\n-                cob.invokespecial(CD_IllegalAccessError, INIT_NAME, MTD_void_String);\n+                cob.invokespecial(CD_IllegalAccessException, INIT_NAME, MTD_void_String);\n@@ -338,1 +360,1 @@\n-            int classDataIndex = 2; \/\/ 0 is interfaceInfo, 1 is reserved for wrapper instance target\n+            int classDataIndex = 2; \/\/ 0 is the interface, 1 is reserved for wrapper instance target\n@@ -421,0 +443,35 @@\n+    private static final JavaLangReflectAccess JLRA = SharedSecrets.getJavaLangReflectAccess();\n+    private static final AtomicInteger counter = new AtomicInteger();\n+\n+    private static String nextModuleName() {\n+        return \"jdk.MHProxy\" + counter.incrementAndGet();\n+    }\n+\n+    \/**\n+     * Create a dynamic module defined to the given class loader and has\n+     * access to the given types.\n+     * <p>\n+     * The dynamic module contains only one single package named the same as\n+     * the name of the dynamic module.  It's not exported or open.\n+     *\/\n+    private static Module newDynamicModule(ClassLoader ld, Set<Class<?>> types) {\n+        Objects.requireNonNull(types);\n+\n+        \/\/ create a dynamic module and setup module access\n+        String mn = nextModuleName();\n+        ModuleDescriptor descriptor = ModuleDescriptor.newModule(mn, Set.of(SYNTHETIC))\n+                .packages(Set.of(mn))\n+                .build();\n+\n+        Module dynModule = Modules.defineModule(ld, descriptor, null);\n+        Module javaBase = Object.class.getModule();\n+\n+        Modules.addReads(dynModule, javaBase);\n+        Modules.addOpens(dynModule, mn, javaBase);\n+\n+        for (Class<?> c : types) {\n+            ensureAccess(dynModule, c);\n+        }\n+        return dynModule;\n+    }\n+\n@@ -424,1 +481,1 @@\n-                               && m.getParameterCount() == 0;\n+                    && m.getParameterCount() == 0;\n@@ -426,1 +483,1 @@\n-                               && m.getParameterCount() == 0;\n+                    && m.getParameterCount() == 0;\n@@ -428,2 +485,2 @@\n-                               && m.getParameterCount() == 1\n-                               && m.getParameterTypes()[0] == Object.class;\n+                    && m.getParameterCount() == 1\n+                    && JLRA.getExecutableSharedParameterTypes(m)[0] == Object.class;\n@@ -434,1 +491,18 @@\n-    private static List<Method> getSingleNameMethods(Class<?> intfc) {\n+    \/**\n+     * Stores the result of iteration over methods in a given single-abstract-method interface.\n+     *\n+     * @param singleName the single abstract method's name in the given interface\n+     * @param methods the abstract methods to implement in the given interface\n+     * @param referencedTypes a set of types that are referenced by the instance methods of the given interface\n+     *\/\n+    private record SamInfo(String singleName, List<Method> methods, Set<Class<?>> referencedTypes) {\n+    }\n+\n+    \/*\n+     * Returns null if given interface is not SAM\n+     *\/\n+    private static SamInfo getStats(Class<?> intfc) {\n+        if (!intfc.isInterface()) {\n+            throw new IllegalArgumentException(intfc + \" not an inteface\");\n+        }\n+\n@@ -436,0 +510,2 @@\n+        var types = new HashSet<Class<?>>();\n+        types.add(intfc);\n@@ -438,2 +514,12 @@\n-            if (isObjectMethod(m))  continue;\n-            if (!Modifier.isAbstract(m.getModifiers()))  continue;\n+            if (Modifier.isStatic(m.getModifiers()))\n+                continue;\n+\n+            if (isObjectMethod(m))\n+                continue; \/\/ covered by java.base reads\n+\n+            addElementType(types, m.getReturnType());\n+            addElementTypes(types, JLRA.getExecutableSharedParameterTypes(m));\n+            addElementTypes(types, JLRA.getExecutableSharedExceptionTypes(m));\n+\n+            if (!Modifier.isAbstract(m.getModifiers()))\n+                continue;\n@@ -447,2 +533,37 @@\n-        if (uniqueName == null)  return null;\n-        return methods;\n+\n+        if (uniqueName == null)\n+            return null;\n+\n+        return new SamInfo(uniqueName, methods, types);\n+    }\n+\n+    \/*\n+     * Ensure the given module can access the given class.\n+     *\/\n+    private static void ensureAccess(Module target, Class<?> c) {\n+        Module m = c.getModule();\n+        \/\/ add read edge and qualified export for the target module to access\n+        if (!target.canRead(m)) {\n+            Modules.addReads(target, m);\n+        }\n+        String pn = c.getPackageName();\n+        if (!m.isExported(pn, target)) {\n+            Modules.addExports(m, pn, target);\n+        }\n+    }\n+\n+    private static void addElementTypes(Set<Class<?>> types, Class<?>... classes) {\n+        for (var cls : classes) {\n+            addElementType(types, cls);\n+        }\n+    }\n+\n+    private static void addElementType(Set<Class<?>> types, Class<?> cls) {\n+        Class<?> e = cls;\n+        while (e.isArray()) {\n+            e = e.getComponentType();\n+        }\n+\n+        if (!e.isPrimitive()) {\n+            types.add(e);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":178,"deletions":57,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -96,0 +96,3 @@\n+    public Class<?>[] getExecutableSharedExceptionTypes(Executable ex) {\n+        return ex.getSharedExceptionTypes();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ReflectAccess.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -79,0 +79,3 @@\n+    \/** Gets the shared array of exception types of an Executable. *\/\n+    public Class<?>[] getExecutableSharedExceptionTypes(Executable ex);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangReflectAccess.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n@@ -52,2 +54,10 @@\n-                public InputStream apply(ClassDesc classDesc) {\n-                    return ClassLoader.getSystemResourceAsStream(Util.toInternalName(classDesc) + \".class\");\n+                @SuppressWarnings(\"removal\")\n+                public InputStream apply(final ClassDesc classDesc) {\n+                    var sm = System.getSecurityManager();\n+                    if (sm == null) {\n+                        return ClassLoader.getSystemResourceAsStream(Util.toInternalName(classDesc) + \".class\");\n+                    } else {\n+                        PrivilegedAction<InputStream> pa =\n+                                () -> ClassLoader.getSystemResourceAsStream(Util.toInternalName(classDesc) + \".class\");\n+                        return AccessController.doPrivileged(pa);\n+                    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassHierarchyResolver.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run junit\/othervm -Djdk.invoke.MethodHandleProxies.dumpInterfaceInstances BasicTest\n+ * @run junit BasicTest\n@@ -37,1 +37,0 @@\n-import org.junit.jupiter.api.Test;\n@@ -43,0 +42,1 @@\n+import java.lang.invoke.MethodHandleProxies;\n@@ -64,0 +64,2 @@\n+\n+import org.junit.jupiter.api.Test;\n@@ -66,0 +68,1 @@\n+\n@@ -112,1 +115,3 @@\n-\n+    private static long mul2(int i) {\n+        return (long) i * i *2;\n+    }\n@@ -127,0 +132,23 @@\n+    @Test\n+    public void testSameModule() throws Throwable {\n+        var mh = MethodHandles.lookup().findStatic(BasicTest.class, \"mul\", methodType(long.class, int.class));\n+        var mh2 = MethodHandles.lookup().findStatic(BasicTest.class, \"mul2\", methodType(long.class, int.class));\n+\n+        Function<Integer, Long> func1 = (Function<Integer, Long>) asInterfaceInstance(Function.class, mh);\n+        assertEquals(32423432L * 32423432L, func1.apply(32423432));\n+        Class<?> c1 = func1.getClass();\n+        Module m1 = c1.getModule();\n+\n+        Function<Integer, Long> func2 = (Function<Integer, Long>) asInterfaceInstance(Function.class, mh2);\n+        assertEquals(32423432L * 32423432L * 2, func2.apply(32423432));\n+        Class<?> c2 = func2.getClass();\n+        Module m2 = c2.getModule();\n+        assertTrue(c1 != c2);\n+        assertEquals(c1.getPackageName(), c2.getPackageName());\n+        assertTrue(m1 == m2);\n+\n+        String pn = c1.getPackageName();\n+        assertFalse(m1.isExported(pn));\n+        assertTrue(m1.isExported(pn, MethodHandleProxies.class.getModule()));\n+    }\n+\n@@ -161,1 +189,1 @@\n-    public void testNoInstantiation() throws IllegalAccessException, NoSuchMethodException {\n+    public void testNoInstantiation() throws IllegalAccessException {\n@@ -166,6 +194,1 @@\n-        var intfLookup = MethodHandles.privateLookupIn(instanceClass, Untrusted.leakLookup());\n-        assertSame(instanceClass, intfLookup.lookupClass());\n-        assertTrue(intfLookup.hasFullPrivilegeAccess());\n-        assertEquals(0, intfLookup.lookupModes() & Lookup.ORIGINAL, \"reflected lookup original flag\");\n-        var ctor = intfLookup.findConstructor(instanceClass, methodType(void.class, Lookup.class));\n-        assertThrows(IllegalAccessError.class, () -> ctor.invoke(intfLookup));\n+        assertThrows(IllegalAccessException.class, () -> MethodHandles.privateLookupIn(instanceClass, Untrusted.leakLookup()));\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/BasicTest.java","additions":33,"deletions":10,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -38,1 +38,3 @@\n-        var untrustedTarget = MethodHandleProxies.wrapperInstanceTarget(MethodHandleProxies.asInterfaceInstance(Untrusted.class, originalMh));\n+        Object o = MethodHandleProxies.asInterfaceInstance(Untrusted.class, originalMh);\n+        System.out.println(o);\n+        var untrustedTarget = MethodHandleProxies.wrapperInstanceTarget(o);\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/WithSecurityManagerTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}