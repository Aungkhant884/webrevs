{"files":[{"patch":"@@ -78,2 +78,2 @@\n-     * Produces an instance, or a wrapper, of the given single-method interface,\n-     * which redirects its calls to the given method handle.\n+     * Produces an instance of the given single-method interface which redirects\n+     * its calls to the given method handle.\n@@ -81,5 +81,7 @@\n-     * A single-method interface is an interface which all its abstract methods,\n-     * either declared or inherited, share a unique name. When determining the\n-     * uniquely named method of a single-method interface, the public {@link\n-     * Object} methods ({@link Object#toString toString}, {@link Object#equals\n-     * equals}, {@link Object#hashCode hashCode}) are disregarded.\n+     * A single-method interface is an interface which declares a uniquely named method.\n+     * When determining the uniquely named method of a single-method interface,\n+     * the public {@code Object} methods ({@code toString}, {@code equals}, {@code hashCode})\n+     * are disregarded as are any default (non-abstract) methods.\n+     * For example, {@link java.util.Comparator} is a single-method interface,\n+     * even though it re-declares the {@code Object.equals} method and also\n+     * declares default methods, such as {@code Comparator.reverse}.\n@@ -87,3 +89,2 @@\n-     * The interface must be public, not {@linkplain Class#isHidden() hidden},\n-     * and not {@linkplain Class#isSealed() sealed}. No additional access check\n-     * is performed.\n+     * The interface must be public and not {@linkplain Class#isSealed() sealed}.\n+     * No additional access checks are performed.\n@@ -91,4 +92,9 @@\n-     * For each of the methods with the unique name, the target's type will be\n-     * checked before the instance is created, as if by a call to {@link\n-     * MethodHandle#asType asType} with the method's type, which may result in a\n-     * {@link WrongMethodTypeException}.\n+     * The resulting instance of the required type will respond to\n+     * invocation of the type's uniquely named method by calling\n+     * the given target on the incoming arguments,\n+     * and returning or throwing whatever the target\n+     * returns or throws.  The invocation will be as if by\n+     * {@code target.invoke}.\n+     * The target's type will be checked before the\n+     * instance is created, as if by a call to {@code asType},\n+     * which may result in a {@code WrongMethodTypeException}.\n@@ -96,4 +102,6 @@\n-     * The resulting instance of the required type will respond to invocation of\n-     * each method by calling the given target with the incoming arguments, as\n-     * if by {@link MethodHandle#invoke target.invoke}, returning whatever the\n-     * target returns.\n+     * The uniquely named method is allowed to be multiply declared,\n+     * with distinct type descriptors.  (E.g., it can be overloaded,\n+     * or can possess bridge methods.)  All such declarations are\n+     * connected directly to the target method handle.\n+     * Argument and return types are adjusted by {@code asType}\n+     * for each individual declaration.\n@@ -101,6 +109,10 @@\n-     * The {@code target} method handle may throw an <em>undeclared exception<\/em>,\n-     * which means any checked exception (or other checked throwable) not\n-     * declared by the invoked method. If this happens, the throwable will be\n-     * wrapped in an instance of {@link UndeclaredThrowableException} and thrown\n-     * in that wrapped form. Other exceptions thrown by the {@code target}\n-     * method handle pass through.\n+     * The wrapper instance will implement the requested interface\n+     * and its super-types, but no other single-method interfaces.\n+     * This means that the instance will not unexpectedly\n+     * pass an {@code instanceof} test for any unrequested type.\n+     * <p style=\"font-size:smaller;\">\n+     * <em>Implementation Note:<\/em>\n+     * Therefore, each instance must implement a unique single-method interface.\n+     * Implementations may not bundle together\n+     * multiple single-method interfaces onto single implementation classes\n+     * in the style of {@link java.desktop\/java.awt.AWTEventMulticaster}.\n@@ -108,4 +120,6 @@\n-     * The returned instance will implement the requested interface and its\n-     * supertypes, but no other single-method interfaces. This means that the\n-     * instance will not unexpectedly pass an {@code instanceof} test for any\n-     * unrequested single-method interface type.\n+     * The method handle may throw an <em>undeclared exception<\/em>,\n+     * which means any checked exception (or other checked throwable)\n+     * not declared by the requested type's single abstract method.\n+     * If this happens, the throwable will be wrapped in an instance of\n+     * {@link java.lang.reflect.UndeclaredThrowableException UndeclaredThrowableException}\n+     * and thrown in that wrapped form.\n@@ -113,4 +127,4 @@\n-     * If a security manager is installed, this method is caller sensitive.\n-     * During any invocation of the {@code target} method handle via the\n-     * returned wrapper, the original creator of the wrapper (the caller) will\n-     * be visible to context checks requested by the security manager.\n+     * Like {@link java.lang.Integer#valueOf Integer.valueOf},\n+     * {@code asInterfaceInstance} is a factory method whose results are defined\n+     * by their behavior.\n+     * It is not guaranteed to return a new instance for every call.\n@@ -118,12 +132,8 @@\n-     * The returned instance is immutable and does not override the public\n-     * methods in {@link Object}. This API may or may not return identical\n-     * or equal instances for the same arguments; the {@code intfc} and\n-     * {@code target} used to obtain an instance can be recovered from the\n-     * instance via {@link #wrapperInstanceType wrapperInstanceType} and\n-     * {@link #wrapperInstanceTarget wrapperInstanceTarget} respectively\n-     * to determine the instance's behavior.\n-     *\n-     * @apiNote\n-     * This API supports multiple abstract methods with the same name because of\n-     * the possibility of {@linkplain Method#isBridge bridge methods}. It\n-     * supports overloads, such as the methods in {@link Appendable}.\n+     * Because of the possibility of {@linkplain java.lang.reflect.Method#isBridge bridge methods}\n+     * and other corner cases, the interface may also have several abstract methods\n+     * with the same name but having distinct descriptors (types of returns and parameters).\n+     * In this case, all the methods are bound in common to the one given target.\n+     * The type check and effective {@code asType} conversion is applied to each\n+     * method type descriptor, and all abstract methods are bound to the target in common.\n+     * Beyond this type check, no further checks are made to determine that the\n+     * abstract methods are related in any way.\n@@ -131,4 +141,9 @@\n-     * Future versions of this API may accept additional types, such as abstract\n-     * classes with single abstract methods. Future versions of this API may\n-     * also equip wrapper instances with one or more additional public \"marker\"\n-     * interfaces.\n+     * Future versions of this API may accept additional types,\n+     * such as abstract classes with single abstract methods.\n+     * Future versions of this API may also equip wrapper instances\n+     * with one or more additional public \"marker\" interfaces.\n+     * <p>\n+     * If a security manager is installed, this method is caller sensitive.\n+     * During any invocation of the target method handle via the returned wrapper,\n+     * the original creator of the wrapper (the caller) will be visible\n+     * to context checks requested by the security manager.\n@@ -136,1 +151,12 @@\n-     * @implNote\n+     * @param <T> the desired type of the wrapper, a single-method interface\n+     * @param intfc a class object representing {@code T}\n+     * @param target the method handle to invoke from the wrapper\n+     * @return a correctly-typed wrapper for the given target\n+     * @throws NullPointerException if either argument is null\n+     * @throws IllegalArgumentException if the {@code intfc} is not a\n+     *         valid argument to this method\n+     * @throws WrongMethodTypeException if the target cannot\n+     *         be converted to the type required by the requested interface\n+     *\/\n+    \/*\n+     * Implementor notes:\n@@ -145,17 +171,0 @@\n-     * <p style=\"font-size:smaller;\">\n-     * <em>Discussion:<\/em>\n-     * Since project Leyden aims to improve startup speed, asInterfaceInstance\n-     * currently shares one implementation class for each interface than one\n-     * implementation class for each method handle. This is good for use cases\n-     * where multiple distinct method handles are converted into one interface\n-     * stored in a collection, where each instance is invoked rarely (or only\n-     * once), such as property getters on a bean.\n-     * <p style=\"font-size:smaller;\">\n-     * Using super-customized implementation classes for each method handle\n-     * would allow constant-folding of calls through the returned instance, but\n-     * it comes with a huge class definition overhead for each instance and is\n-     * not feasible for rare invocation use cases like above.\n-     * <p style=\"font-size:smaller;\">\n-     * The shared-class implementation is also closer in behavior to the\n-     * original proxy-backed implementation. We might add another API for\n-     * super-customized instances.\n@@ -163,10 +172,14 @@\n-     * @param <T> the desired type of the wrapper, a single-method interface\n-     * @param intfc a class object representing {@code T}\n-     * @param target the method handle to invoke from the wrapper\n-     * @return a correctly-typed wrapper for the given target\n-     * @throws NullPointerException if either argument is {@code null}\n-     * @throws IllegalArgumentException if {@code intfc} is not a valid\n-     *         argument to this method\n-     * @throws WrongMethodTypeException if {@code target} cannot be converted\n-     *         to the method type required by any of the abstract methods in\n-     *         {@code intfc}\n+     * Discussion:\n+     * Since project leyden aims to improve startup speed, asInterfaceInstance\n+     * will share one implementation class for each interface than one implementation\n+     * class for each method handle. This is good for use cases where multiple distinct\n+     * method handles are converted into one interface stored in a collection, where each\n+     * instance is invoked rarely (or only once), such as property getters on a bean.\n+     *\n+     * Using super-customized implementation classes for each method handle would\n+     * allow constant-folding of calls through the returned instance, but it comes with\n+     * a huge class definition overhead for each instance and is not feasible for rare\n+     * invocation use cases like above.\n+     *\n+     * The shared-class implementation is also closer in behavior to the original\n+     * proxy-backed implementation. We might add another API for super-customized instances.\n@@ -174,0 +187,2 @@\n+    @SuppressWarnings({\"removal\",\n+                       \"doclint:reference\"}) \/\/ cross-module links\n@@ -467,6 +482,3 @@\n-     * Determines if the given object was produced by a call to {@link\n-     * #asInterfaceInstance asInterfaceInstance}.\n-     *\n-     * @param x any reference, may be {@code null}\n-     * @return {@code true} if {@code x} is not {@code null} and is an object\n-     *         produced by {@code asInterfaceInstance}, {@code false} otherwise\n+     * Determines if the given object was produced by a call to {@link #asInterfaceInstance asInterfaceInstance}.\n+     * @param x any reference\n+     * @return true if the reference is not null and points to an object produced by {@code asInterfaceInstance}\n@@ -481,3 +493,2 @@\n-     * The object {@code x} must have been produced by a call to {@link\n-     * #asInterfaceInstance asInterfaceInstance}.\n-     *\n+     * The object {@code x} must have been produced by a call to {@link #asInterfaceInstance asInterfaceInstance}.\n+     * This requirement may be tested via {@link #isWrapperInstance isWrapperInstance}.\n@@ -486,3 +497,1 @@\n-     * @throws IllegalArgumentException if {@code x} is not a wrapper instance\n-     *         or is {@code null}\n-     * @see #isWrapperInstance(Object)\n+     * @throws IllegalArgumentException if the reference x is not to a wrapper instance\n@@ -505,4 +514,3 @@\n-     * Recovers the unique single-method interface type for which this wrapper\n-     * instance was created. The object {@code x} must have been produced by a\n-     * call to {@link #asInterfaceInstance asInterfaceInstance}.\n-     *\n+     * Recovers the unique single-method interface type for which this wrapper instance was created.\n+     * The object {@code x} must have been produced by a call to {@link #asInterfaceInstance asInterfaceInstance}.\n+     * This requirement may be tested via {@link #isWrapperInstance isWrapperInstance}.\n@@ -511,3 +519,1 @@\n-     * @throws IllegalArgumentException if {@code x} is not a wrapper instance\n-     *         or is {@code null}\n-     * @see #isWrapperInstance(Object)\n+     * @throws IllegalArgumentException if the reference x is not to a wrapper instance\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":101,"deletions":95,"binary":false,"changes":196,"status":"modified"}]}